{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jp2_cod.h\"\n\n/******************************************************************************\\\n* Function prototypes.\n\\******************************************************************************/\n\n#define\tONES(n)\t((1 << (n)) - 1)\n\njp2_boxinfo_t *jp2_boxinfolookup(int type);\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val);\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val);\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val);\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val);\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val);\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val);\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val);\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val);\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val);\n\njp2_box_t *jp2_box_get(jas_stream_t *in);\nvoid jp2_box_dump(jp2_box_t *box, FILE *out);\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_bpcc_destroy(jp2_box_t *box);\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_colr_destroy(jp2_box_t *box);\nstatic void jp2_cdef_destroy(jp2_box_t *box);\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_cmap_destroy(jp2_box_t *box);\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_pclr_destroy(jp2_box_t *box);\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njp2_boxinfo_t jp2_boxinfos[] = {\n\t{JP2_BOX_JP, \"JP\", 0,\n\t  {0, 0, jp2_jp_getdata, jp2_jp_putdata, 0}},\n\t{JP2_BOX_FTYP, \"FTYP\", 0,\n\t  {0, 0, jp2_ftyp_getdata, jp2_ftyp_putdata, 0}},\n\t{JP2_BOX_JP2H, \"JP2H\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_IHDR, \"IHDR\", 0,\n\t  {0, 0, jp2_ihdr_getdata, jp2_ihdr_putdata, 0}},\n\t{JP2_BOX_BPCC, \"BPCC\", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \"COLR\", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \"PCLR\", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \"CMAP\", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \"CDEF\", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \"RES\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESC, \"RESC\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESD, \"RESD\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2C, \"JP2C\", JP2_BOX_NODATA,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2I, \"JP2I\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_XML, \"XML\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UUID, \"UUID\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UINF, \"UINF\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_ULST, \"ULST\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_URL, \"URL\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{0, 0, 0, {0, 0, 0, 0, 0}},\n};\n\njp2_boxinfo_t jp2_boxinfo_unk = {\n\t0, \"Unknown\", 0, {0, 0, 0, 0, 0}\n};\n\n/******************************************************************************\\\n* Box constructor.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}\n\n/******************************************************************************\\\n* Box destructor.\n\\******************************************************************************/\n\nvoid jp2_box_destroy(jp2_box_t *box)\n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n\nstatic void jp2_bpcc_destroy(jp2_box_t *box)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tif (bpcc->bpcs) {\n\t\tjas_free(bpcc->bpcs);\n\t\tbpcc->bpcs = 0;\n\t}\n}\n\nstatic void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}\n\n/******************************************************************************\\\n* Box input.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\tbox->len = len;\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n\nvoid jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08x); length=%d\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_getuint32(in, &jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tftyp->numcompatcodes = (box->datalen - 8) / 4;\n\tif (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_getuint32(in, &ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_getuint32(in, &ihdr->height) || jp2_getuint32(in, &ihdr->width) ||\n\t  jp2_getuint16(in, &ihdr->numcmpts) || jp2_getuint8(in, &ihdr->bpc) ||\n\t  jp2_getuint8(in, &ihdr->comptype) || jp2_getuint8(in, &ihdr->csunk) ||\n\t  jp2_getuint8(in, &ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tfprintf(out, \"method=%d; pri=%d; approx=%d\\n\", (int)colr->method, (int)colr->pri, (int)colr->approx);\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tfprintf(out, \"csid=%d\\n\", (int)colr->csid);\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tjas_memdump(out, colr->iccp, colr->iccplen);\n\t\tbreak;\n\t}\n}\n\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tfprintf(out, \"channo=%d; type=%d; assoc=%d\\n\",\n\t\t  cdef->ents[i].channo, cdef->ents[i].type, cdef->ents[i].assoc);\n\t}\n}\n\nstatic void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Box output.\n\\******************************************************************************/\n\nint jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_putuint32(out, jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) ||\n\t  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) ||\n\t  jp2_putuint8(out, ihdr->comptype) || jp2_putuint8(out, ihdr->csunk) ||\n\t  jp2_putuint8(out, ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_putuint8(out, bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||\n\t  jp2_putuint8(out, colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_putuint32(out, colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tif (jas_stream_write(out, colr->iccp,\n\t\t  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tjp2_cdefchan_t *ent;\n\n\tif (jp2_putuint16(out, cdef->numchans)) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tent = &cdef->ents[i];\n\t\tif (jp2_putuint16(out, ent->channo) ||\n\t\t  jp2_putuint16(out, ent->type) ||\n\t\t  jp2_putuint16(out, ent->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Input operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val)\n{\n\tuint_fast64_t tmpval;\n\tint i;\n\tint c;\n\n\ttmpval = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\ttmpval <<= 8;\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ttmpval |= (c & 0xff);\n\t}\n\t*val = tmpval;\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Output operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val)\n{\n\tif (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||\n\t  jp2_putuint32(out, val & 0xffffffffUL)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\njp2_boxinfo_t *jp2_boxinfolookup(int type)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n\n\n\n\n\nstatic void jp2_cmap_destroy(jp2_box_t *box)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tif (cmap->ents) {\n\t\tjas_free(cmap->ents);\n\t}\n}\n\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tbox = 0;\n\tout = 0;\n\n\treturn -1;\n}\n\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tunsigned int i;\n\tjp2_cmapent_t *ent;\n\tfprintf(out, \"numchans = %d\\n\", (int) cmap->numchans);\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tfprintf(out, \"cmptno=%d; map=%d; pcol=%d\\n\",\n\t\t  (int) ent->cmptno, (int) ent->map, (int) ent->pcol);\n\t}\n}\n\nstatic void jp2_pclr_destroy(jp2_box_t *box)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tif (pclr->lutdata) {\n\t\tjas_free(pclr->lutdata);\n\t}\n\tif (pclr->bpc)\n\t\tjas_free(pclr->bpc);\n}\n\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}\n\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tunsigned int i;\n\tint j;\n\tfprintf(out, \"numents=%d; numchans=%d\\n\", (int) pclr->numlutents,\n\t  (int) pclr->numchans);\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tfprintf(out, \"LUT[%d][%d]=%d\\n\", i, j, pclr->lutdata[i * pclr->numchans + j]);\n\t\t}\n\t}\n}\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val)\n{\n\tint c;\n\tint i;\n\tuint_fast32_t v;\n\tint m;\n\n\tm = (n + 7) / 8;\n\n\tv = 0;\n\tfor (i = 0; i < m; ++i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ONES(n);\n\tif (s) {\n\t\tint sb;\n\t\tsb = v & (1 << (8 * m - 1));\n\t\t*val = ((~v) + 1) & ONES(8 * m);\n\t\tif (sb) {\n\t\t\t*val = -*val;\n\t\t}\n\t} else {\n\t\t*val = v;\n\t}\n\n\treturn 0;\n}\n\njp2_cdefchan_t *jp2_cdef_lookup(jp2_cdef_t *cdef, int channo)\n{\n\tunsigned int i;\n\tjp2_cdefchan_t *cdefent;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tcdefent = &cdef->ents[i];\n\t\tif (cdefent->channo == JAS_CAST(unsigned int, channo)) {\n\t\t\treturn cdefent;\n\t\t}\n\t}\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_version.h\"\n\n#include \"jp2_cod.h\"\n#include \"jp2_dec.h\"\n\n#define\tJP2_VALIDATELEN\t(JAS_MIN(JP2_JP_LEN + 16, JAS_STREAM_MAXPUTBACK))\n\nstatic jp2_dec_t *jp2_dec_create(void);\nstatic void jp2_dec_destroy(jp2_dec_t *dec);\nstatic int jp2_getcs(jp2_colr_t *colr);\nstatic int fromiccpcs(int cs);\nstatic int jp2_getct(int colorspace, int type, int assoc);\n\n/******************************************************************************\\\n* Functions.\n\\******************************************************************************/\n\njas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\nint jp2_validate(jas_stream_t *in)\n{\n\tchar buf[JP2_VALIDATELEN];\n\tint i;\n\tint n;\n#if 0\n\tjas_stream_t *tmpstream;\n\tjp2_box_t *box;\n#endif\n\n\tassert(JAS_STREAM_MAXPUTBACK >= JP2_VALIDATELEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, JP2_VALIDATELEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Did we read enough data? */\n\tif (n < JP2_VALIDATELEN) {\n\t\treturn -1;\n\t}\n\n\t/* Is the box type correct? */\n\tif (((buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7]) !=\n\t  JP2_BOX_JP)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic jp2_dec_t *jp2_dec_create(void)\n{\n\tjp2_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jp2_dec_t)))) {\n\t\treturn 0;\n\t}\n\tdec->ihdr = 0;\n\tdec->bpcc = 0;\n\tdec->cdef = 0;\n\tdec->pclr = 0;\n\tdec->image = 0;\n\tdec->chantocmptlut = 0;\n\tdec->cmap = 0;\n\tdec->colr = 0;\n\treturn dec;\n}\n\nstatic void jp2_dec_destroy(jp2_dec_t *dec)\n{\n\tif (dec->ihdr) {\n\t\tjp2_box_destroy(dec->ihdr);\n\t}\n\tif (dec->bpcc) {\n\t\tjp2_box_destroy(dec->bpcc);\n\t}\n\tif (dec->cdef) {\n\t\tjp2_box_destroy(dec->cdef);\n\t}\n\tif (dec->pclr) {\n\t\tjp2_box_destroy(dec->pclr);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\tif (dec->cmap) {\n\t\tjp2_box_destroy(dec->cmap);\n\t}\n\tif (dec->colr) {\n\t\tjp2_box_destroy(dec->colr);\n\t}\n\tif (dec->chantocmptlut) {\n\t\tjas_free(dec->chantocmptlut);\n\t}\n\tjas_free(dec);\n}\n\nstatic int jp2_getct(int colorspace, int type, int assoc)\n{\n\tif (type == 1 && assoc == 0) {\n\t\treturn JAS_IMAGE_CT_OPACITY;\n\t}\n\tif (type == 0 && assoc >= 1 && assoc <= 65534) {\n\t\tswitch (colorspace) {\n\t\tcase JAS_CLRSPC_FAM_RGB:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_RGB_R:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_G:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_B:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_YCBCR_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CB:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CR:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_GRAY:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_GRAY_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn JAS_IMAGE_CT_COLOR(assoc - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn JAS_IMAGE_CT_UNKNOWN;\n}\n\nstatic int jp2_getcs(jp2_colr_t *colr)\n{\n\tif (colr->method == JP2_COLR_ENUM) {\n\t\tswitch (colr->csid) {\n\t\tcase JP2_COLR_SRGB:\n\t\t\treturn JAS_CLRSPC_SRGB;\n\t\t\tbreak;\n\t\tcase JP2_COLR_SYCC:\n\t\t\treturn JAS_CLRSPC_SYCBCR;\n\t\t\tbreak;\n\t\tcase JP2_COLR_SGRAY:\n\t\t\treturn JAS_CLRSPC_SGRAY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn JAS_CLRSPC_UNKNOWN;\n}\n\nstatic int fromiccpcs(int cs)\n{\n\tswitch (cs) {\n\tcase ICC_CS_RGB:\n\t\treturn JAS_CLRSPC_GENRGB;\n\t\tbreak;\n\tcase ICC_CS_YCBCR:\n\t\treturn JAS_CLRSPC_GENYCBCR;\n\t\tbreak;\n\tcase ICC_CS_GRAY:\n\t\treturn JAS_CLRSPC_GENGRAY;\n\t\tbreak;\n\t}\n\treturn JAS_CLRSPC_UNKNOWN;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jp2_cod.h\"\n\n/******************************************************************************\\\n* Function prototypes.\n\\******************************************************************************/\n\n#define\tONES(n)\t((1 << (n)) - 1)\n\njp2_boxinfo_t *jp2_boxinfolookup(int type);\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val);\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val);\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val);\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val);\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val);\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val);\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val);\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val);\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val);\n\njp2_box_t *jp2_box_get(jas_stream_t *in);\nvoid jp2_box_dump(jp2_box_t *box, FILE *out);\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_bpcc_destroy(jp2_box_t *box);\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_colr_destroy(jp2_box_t *box);\nstatic void jp2_cdef_destroy(jp2_box_t *box);\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_cmap_destroy(jp2_box_t *box);\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_pclr_destroy(jp2_box_t *box);\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njp2_boxinfo_t jp2_boxinfos[] = {\n\t{JP2_BOX_JP, \"JP\", 0,\n\t  {0, 0, jp2_jp_getdata, jp2_jp_putdata, 0}},\n\t{JP2_BOX_FTYP, \"FTYP\", 0,\n\t  {0, 0, jp2_ftyp_getdata, jp2_ftyp_putdata, 0}},\n\t{JP2_BOX_JP2H, \"JP2H\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_IHDR, \"IHDR\", 0,\n\t  {0, 0, jp2_ihdr_getdata, jp2_ihdr_putdata, 0}},\n\t{JP2_BOX_BPCC, \"BPCC\", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \"COLR\", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \"PCLR\", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \"CMAP\", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \"CDEF\", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \"RES\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESC, \"RESC\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESD, \"RESD\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2C, \"JP2C\", JP2_BOX_NODATA,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2I, \"JP2I\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_XML, \"XML\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UUID, \"UUID\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UINF, \"UINF\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_ULST, \"ULST\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_URL, \"URL\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{0, 0, 0, {0, 0, 0, 0, 0}},\n};\n\njp2_boxinfo_t jp2_boxinfo_unk = {\n\t0, \"Unknown\", 0, {0, 0, 0, 0, 0}\n};\n\n/******************************************************************************\\\n* Box constructor.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}\n\n/******************************************************************************\\\n* Box destructor.\n\\******************************************************************************/\n\nvoid jp2_box_destroy(jp2_box_t *box)\n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n\nstatic void jp2_bpcc_destroy(jp2_box_t *box)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tif (bpcc->bpcs) {\n\t\tjas_free(bpcc->bpcs);\n\t\tbpcc->bpcs = 0;\n\t}\n}\n\nstatic void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}\n\n/******************************************************************************\\\n* Box input.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\t// Mark the box data as never having been constructed\n\t\t\t// so that we will not errantly attempt to destroy it later.\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n\nvoid jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08x); length=%d\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_getuint32(in, &jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tftyp->numcompatcodes = (box->datalen - 8) / 4;\n\tif (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_getuint32(in, &ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_getuint32(in, &ihdr->height) || jp2_getuint32(in, &ihdr->width) ||\n\t  jp2_getuint16(in, &ihdr->numcmpts) || jp2_getuint8(in, &ihdr->bpc) ||\n\t  jp2_getuint8(in, &ihdr->comptype) || jp2_getuint8(in, &ihdr->csunk) ||\n\t  jp2_getuint8(in, &ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tfprintf(out, \"method=%d; pri=%d; approx=%d\\n\", (int)colr->method, (int)colr->pri, (int)colr->approx);\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tfprintf(out, \"csid=%d\\n\", (int)colr->csid);\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tjas_memdump(out, colr->iccp, colr->iccplen);\n\t\tbreak;\n\t}\n}\n\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tfprintf(out, \"channo=%d; type=%d; assoc=%d\\n\",\n\t\t  cdef->ents[i].channo, cdef->ents[i].type, cdef->ents[i].assoc);\n\t}\n}\n\nstatic void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Box output.\n\\******************************************************************************/\n\nint jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_putuint32(out, jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) ||\n\t  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) ||\n\t  jp2_putuint8(out, ihdr->comptype) || jp2_putuint8(out, ihdr->csunk) ||\n\t  jp2_putuint8(out, ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_putuint8(out, bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||\n\t  jp2_putuint8(out, colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_putuint32(out, colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tif (jas_stream_write(out, colr->iccp,\n\t\t  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tjp2_cdefchan_t *ent;\n\n\tif (jp2_putuint16(out, cdef->numchans)) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tent = &cdef->ents[i];\n\t\tif (jp2_putuint16(out, ent->channo) ||\n\t\t  jp2_putuint16(out, ent->type) ||\n\t\t  jp2_putuint16(out, ent->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Input operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val)\n{\n\tuint_fast64_t tmpval;\n\tint i;\n\tint c;\n\n\ttmpval = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\ttmpval <<= 8;\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ttmpval |= (c & 0xff);\n\t}\n\t*val = tmpval;\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Output operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val)\n{\n\tif (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||\n\t  jp2_putuint32(out, val & 0xffffffffUL)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\njp2_boxinfo_t *jp2_boxinfolookup(int type)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n\n\n\n\n\nstatic void jp2_cmap_destroy(jp2_box_t *box)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tif (cmap->ents) {\n\t\tjas_free(cmap->ents);\n\t}\n}\n\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tbox = 0;\n\tout = 0;\n\n\treturn -1;\n}\n\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tunsigned int i;\n\tjp2_cmapent_t *ent;\n\tfprintf(out, \"numchans = %d\\n\", (int) cmap->numchans);\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tfprintf(out, \"cmptno=%d; map=%d; pcol=%d\\n\",\n\t\t  (int) ent->cmptno, (int) ent->map, (int) ent->pcol);\n\t}\n}\n\nstatic void jp2_pclr_destroy(jp2_box_t *box)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tif (pclr->lutdata) {\n\t\tjas_free(pclr->lutdata);\n\t}\n\tif (pclr->bpc)\n\t\tjas_free(pclr->bpc);\n}\n\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}\n\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tunsigned int i;\n\tint j;\n\tfprintf(out, \"numents=%d; numchans=%d\\n\", (int) pclr->numlutents,\n\t  (int) pclr->numchans);\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tfprintf(out, \"LUT[%d][%d]=%d\\n\", i, j, pclr->lutdata[i * pclr->numchans + j]);\n\t\t}\n\t}\n}\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val)\n{\n\tint c;\n\tint i;\n\tuint_fast32_t v;\n\tint m;\n\n\tm = (n + 7) / 8;\n\n\tv = 0;\n\tfor (i = 0; i < m; ++i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ONES(n);\n\tif (s) {\n\t\tint sb;\n\t\tsb = v & (1 << (8 * m - 1));\n\t\t*val = ((~v) + 1) & ONES(8 * m);\n\t\tif (sb) {\n\t\t\t*val = -*val;\n\t\t}\n\t} else {\n\t\t*val = v;\n\t}\n\n\treturn 0;\n}\n\njp2_cdefchan_t *jp2_cdef_lookup(jp2_cdef_t *cdef, int channo)\n{\n\tunsigned int i;\n\tjp2_cdefchan_t *cdefent;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tcdefent = &cdef->ents[i];\n\t\tif (cdefent->channo == JAS_CAST(unsigned int, channo)) {\n\t\t\treturn cdefent;\n\t\t}\n\t}\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_version.h\"\n\n#include \"jp2_cod.h\"\n#include \"jp2_dec.h\"\n\n#define\tJP2_VALIDATELEN\t(JAS_MIN(JP2_JP_LEN + 16, JAS_STREAM_MAXPUTBACK))\n\nstatic jp2_dec_t *jp2_dec_create(void);\nstatic void jp2_dec_destroy(jp2_dec_t *dec);\nstatic int jp2_getcs(jp2_colr_t *colr);\nstatic int fromiccpcs(int cs);\nstatic int jp2_getct(int colorspace, int type, int assoc);\n\n/******************************************************************************\\\n* Functions.\n\\******************************************************************************/\n\njas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\nint jp2_validate(jas_stream_t *in)\n{\n\tchar buf[JP2_VALIDATELEN];\n\tint i;\n\tint n;\n#if 0\n\tjas_stream_t *tmpstream;\n\tjp2_box_t *box;\n#endif\n\n\tassert(JAS_STREAM_MAXPUTBACK >= JP2_VALIDATELEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, JP2_VALIDATELEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Did we read enough data? */\n\tif (n < JP2_VALIDATELEN) {\n\t\treturn -1;\n\t}\n\n\t/* Is the box type correct? */\n\tif (((buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7]) !=\n\t  JP2_BOX_JP)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic jp2_dec_t *jp2_dec_create(void)\n{\n\tjp2_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jp2_dec_t)))) {\n\t\treturn 0;\n\t}\n\tdec->ihdr = 0;\n\tdec->bpcc = 0;\n\tdec->cdef = 0;\n\tdec->pclr = 0;\n\tdec->image = 0;\n\tdec->chantocmptlut = 0;\n\tdec->cmap = 0;\n\tdec->colr = 0;\n\treturn dec;\n}\n\nstatic void jp2_dec_destroy(jp2_dec_t *dec)\n{\n\tif (dec->ihdr) {\n\t\tjp2_box_destroy(dec->ihdr);\n\t}\n\tif (dec->bpcc) {\n\t\tjp2_box_destroy(dec->bpcc);\n\t}\n\tif (dec->cdef) {\n\t\tjp2_box_destroy(dec->cdef);\n\t}\n\tif (dec->pclr) {\n\t\tjp2_box_destroy(dec->pclr);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\tif (dec->cmap) {\n\t\tjp2_box_destroy(dec->cmap);\n\t}\n\tif (dec->colr) {\n\t\tjp2_box_destroy(dec->colr);\n\t}\n\tif (dec->chantocmptlut) {\n\t\tjas_free(dec->chantocmptlut);\n\t}\n\tjas_free(dec);\n}\n\nstatic int jp2_getct(int colorspace, int type, int assoc)\n{\n\tif (type == 1 && assoc == 0) {\n\t\treturn JAS_IMAGE_CT_OPACITY;\n\t}\n\tif (type == 0 && assoc >= 1 && assoc <= 65534) {\n\t\tswitch (colorspace) {\n\t\tcase JAS_CLRSPC_FAM_RGB:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_RGB_R:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_G:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_B:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_YCBCR_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CB:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CR:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_GRAY:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_GRAY_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn JAS_IMAGE_CT_COLOR(assoc - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn JAS_IMAGE_CT_UNKNOWN;\n}\n\nstatic int jp2_getcs(jp2_colr_t *colr)\n{\n\tif (colr->method == JP2_COLR_ENUM) {\n\t\tswitch (colr->csid) {\n\t\tcase JP2_COLR_SRGB:\n\t\t\treturn JAS_CLRSPC_SRGB;\n\t\t\tbreak;\n\t\tcase JP2_COLR_SYCC:\n\t\t\treturn JAS_CLRSPC_SYCBCR;\n\t\t\tbreak;\n\t\tcase JP2_COLR_SGRAY:\n\t\t\treturn JAS_CLRSPC_SGRAY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn JAS_CLRSPC_UNKNOWN;\n}\n\nstatic int fromiccpcs(int cs)\n{\n\tswitch (cs) {\n\tcase ICC_CS_RGB:\n\t\treturn JAS_CLRSPC_GENRGB;\n\t\tbreak;\n\tcase ICC_CS_YCBCR:\n\t\treturn JAS_CLRSPC_GENYCBCR;\n\t\tbreak;\n\tcase ICC_CS_GRAY:\n\t\treturn JAS_CLRSPC_GENGRAY;\n\t\tbreak;\n\t}\n\treturn JAS_CLRSPC_UNKNOWN;\n}\n"], "filenames": ["src/libjasper/jp2/jp2_cod.c", "src/libjasper/jp2/jp2_dec.c"], "buggy_code_start_loc": [260, 158], "buggy_code_end_loc": [284, 159], "fixing_code_start_loc": [261, 158], "fixing_code_end_loc": [292, 159], "type": "CWE-476", "message": "The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).", "other": {"cve": {"id": "CVE-2016-8887", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T18:59:00.257", "lastModified": "2018-06-29T01:29:01.377", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference)."}, {"lang": "es", "value": "La funci\u00f3n jp2_colr_destroy en libjasper/jp2/jp2_cod.c en JasPer en versiones anteriores a 1.900.10 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia de puntero NULL)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.9", "matchCriteriaId": "6FEB8CD1-8991-40A6-BA3F-8DAADB3CD146"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/10/23/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/23/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93835", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blogs.gentoo.org/ago/2016/10/18/jasper-null-pointer-dereference-in-jp2_colr_destroy-jp2_cod-c", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1388828", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/22FCKKHQCQ3S6TZY5G44EFDTMWOJXJRD/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EGI2FZQLOTSZI3VA4ECJERI74SMNQDL4/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d"}}