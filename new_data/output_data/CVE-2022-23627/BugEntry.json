{"buggy_code": ["//     _                _      _  ____   _                           _____\n//    / \\    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___\n//   / _ \\  | '__|/ __|| '_ \\ | |\\___ \\ | __|/ _ \\ / _` || '_ ` _ \\ | |_  / _` || '__|| '_ ` _ \\\n//  / ___ \\ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |\n// /_/   \\_\\|_|   \\___||_| |_||_||____/  \\__|\\___| \\__,_||_| |_| |_||_|   \\__,_||_|   |_| |_| |_|\n// |\n// Copyright 2015-2022 \u0141ukasz \"JustArchi\" Domeradzki\n// Contact: JustArchi@JustArchi.net\n// |\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// |\n// http://www.apache.org/licenses/LICENSE-2.0\n// |\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing ArchiSteamFarm.Core;\nusing ArchiSteamFarm.Helpers;\nusing ArchiSteamFarm.Localization;\nusing ArchiSteamFarm.Plugins;\nusing ArchiSteamFarm.Steam.Cards;\nusing ArchiSteamFarm.Steam.Data;\nusing ArchiSteamFarm.Steam.Integration;\nusing ArchiSteamFarm.Steam.Storage;\nusing ArchiSteamFarm.Storage;\nusing JetBrains.Annotations;\nusing SteamKit2;\n\nnamespace ArchiSteamFarm.Steam.Interaction;\n\npublic sealed class Commands {\n\tprivate const ushort SteamTypingStatusDelay = 10 * 1000; // Steam client broadcasts typing status each 10 seconds\n\n\tprivate readonly Bot Bot;\n\tprivate readonly Dictionary<uint, string> CachedGamesOwned = new();\n\n\tinternal Commands(Bot bot) => Bot = bot ?? throw new ArgumentNullException(nameof(bot));\n\n\t[PublicAPI]\n\tpublic static string FormatBotResponse(string response, string botName) {\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botName)) {\n\t\t\tthrow new ArgumentNullException(nameof(botName));\n\t\t}\n\n\t\treturn $\"{Environment.NewLine}<{botName}> {response}\";\n\t}\n\n\t[PublicAPI]\n\tpublic string FormatBotResponse(string response) {\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t}\n\n\t\treturn $\"<{Bot.BotName}> {response}\";\n\t}\n\n\t[PublicAPI]\n\tpublic static string FormatStaticResponse(string response) {\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t}\n\n\t\treturn $\"<{SharedInfo.ASF}> {response}\";\n\t}\n\n\t[PublicAPI]\n\t[Obsolete($\"Use overload which accepts {nameof(EAccess)} instead, this one will be removed soon.\", true)]\n\tpublic async Task<string?> Response(ulong steamID, string message) {\n\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tEAccess access = Bot.GetAccess(steamID);\n\n\t\treturn await Response(access, message, steamID).ConfigureAwait(false);\n\t}\n\n\t[PublicAPI]\n\tpublic async Task<string?> Response(EAccess access, string message, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t}\n\n\t\tstring[] args = message.Split(Array.Empty<char>(), StringSplitOptions.RemoveEmptyEntries);\n\n\t\tswitch (args.Length) {\n\t\t\tcase 0:\n\t\t\t\tthrow new InvalidOperationException(nameof(args.Length));\n\t\t\tcase 1:\n\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\treturn await Response2FA(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, false).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, true).ConfigureAwait(false);\n\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\treturn ResponseWalletBalance(access);\n\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\treturn ResponseBackgroundGamesRedeemer(access);\n\t\t\t\t\tcase \"EXIT\":\n\t\t\t\t\t\treturn ResponseExit(access);\n\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\treturn await ResponseFarm(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"FB\":\n\t\t\t\t\t\treturn ResponseFarmingBlacklist(access);\n\t\t\t\t\tcase \"FQ\":\n\t\t\t\t\t\treturn ResponseFarmingQueue(access);\n\t\t\t\t\tcase \"HELP\":\n\t\t\t\t\t\treturn ResponseHelp(access);\n\t\t\t\t\tcase \"MAB\":\n\t\t\t\t\t\treturn ResponseMatchActivelyBlacklist(access);\n\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\treturn await ResponseLevel(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\treturn await ResponseLoot(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\treturn await ResponsePause(access, true).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\treturn await ResponsePause(access, false).ConfigureAwait(false);\n\t\t\t\t\tcase \"POINTS\":\n\t\t\t\t\t\treturn await ResponsePointsBalance(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\treturn await ResponseReset(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\treturn ResponseResume(access);\n\t\t\t\t\tcase \"RESTART\":\n\t\t\t\t\t\treturn ResponseRestart(access);\n\t\t\t\t\tcase \"SA\":\n\t\t\t\t\t\treturn await ResponseStatus(access, SharedInfo.ASF).ConfigureAwait(false);\n\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\treturn ResponseStart(access);\n\t\t\t\t\tcase \"STATS\":\n\t\t\t\t\t\treturn ResponseStats(access);\n\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\treturn ResponseStatus(access).Response;\n\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\treturn ResponseStop(access);\n\t\t\t\t\tcase \"TB\":\n\t\t\t\t\t\treturn ResponseTradingBlacklist(access);\n\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\treturn await ResponseUnpackBoosters(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"UPDATE\":\n\t\t\t\t\t\treturn await ResponseUpdate(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"VERSION\":\n\t\t\t\t\t\treturn ResponseVersion(access);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, access, message, args, steamID).ConfigureAwait(false);\n\n\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(access);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\treturn await Response2FA(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, Utilities.GetArgsAsText(args, 1, \",\"), false).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, Utilities.GetArgsAsText(args, 1, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\tcase \"ADDLICENSE\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseAddLicense(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"ADDLICENSE\":\n\t\t\t\t\t\treturn await ResponseAddLicense(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\treturn await ResponseWalletBalance(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\treturn await ResponseBackgroundGamesRedeemer(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"ENCRYPT\" when args.Length > 2:\n\t\t\t\t\t\treturn ResponseEncrypt(access, args[1], Utilities.GetArgsAsText(message, 2));\n\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\treturn await ResponseFarm(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"FB\":\n\t\t\t\t\t\treturn await ResponseFarmingBlacklist(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"FBADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingBlacklistAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"FBADD\":\n\t\t\t\t\t\treturn ResponseFarmingBlacklistAdd(access, args[1]);\n\t\t\t\t\tcase \"FBRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingBlacklistRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"FBRM\":\n\t\t\t\t\t\treturn ResponseFarmingBlacklistRemove(access, args[1]);\n\t\t\t\t\tcase \"FQ\":\n\t\t\t\t\t\treturn await ResponseFarmingQueue(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"FQADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingQueueAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"FQADD\":\n\t\t\t\t\t\treturn ResponseFarmingQueueAdd(access, args[1]);\n\t\t\t\t\tcase \"FQRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingQueueRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"FQRM\":\n\t\t\t\t\t\treturn ResponseFarmingQueueRemove(access, args[1]);\n\t\t\t\t\tcase \"HASH\" when args.Length > 2:\n\t\t\t\t\t\treturn ResponseHash(access, args[1], Utilities.GetArgsAsText(message, 2));\n\t\t\t\t\tcase \"INPUT\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseInput(access, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\tcase \"INPUT\" when args.Length > 2:\n\t\t\t\t\t\treturn ResponseInput(access, args[1], args[2]);\n\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\treturn await ResponseLevel(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\treturn await ResponseLoot(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT^\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseAdvancedLoot(access, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT^\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseAdvancedLoot(access, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT@\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT@\":\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT%\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT%\":\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1], true).ConfigureAwait(false);\n\t\t\t\t\tcase \"MAB\":\n\t\t\t\t\t\treturn await ResponseMatchActivelyBlacklist(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"MABADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseMatchActivelyBlacklistAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"MABADD\":\n\t\t\t\t\t\treturn ResponseMatchActivelyBlacklistAdd(access, args[1]);\n\t\t\t\t\tcase \"MABRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseMatchActivelyBlacklistRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"MABRM\":\n\t\t\t\t\t\treturn ResponseMatchActivelyBlacklistRemove(access, args[1]);\n\t\t\t\t\tcase \"NICKNAME\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseNickname(access, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\tcase \"NICKNAME\":\n\t\t\t\t\t\treturn ResponseNickname(access, args[1]);\n\t\t\t\t\tcase \"OA\":\n\t\t\t\t\t\treturn await ResponseOwns(access, SharedInfo.ASF, Utilities.GetArgsAsText(message, 1)).ConfigureAwait(false);\n\t\t\t\t\tcase \"OWNS\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseOwns(access, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\tcase \"OWNS\":\n\t\t\t\t\t\treturn (await ResponseOwns(access, args[1]).ConfigureAwait(false)).Response;\n\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\treturn await ResponsePause(access, Utilities.GetArgsAsText(args, 1, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\treturn await ResponsePause(access, Utilities.GetArgsAsText(args, 1, \",\"), false).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE&\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponsePause(access, args[1], true, Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE&\":\n\t\t\t\t\t\treturn await ResponsePause(access, true, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"PLAY\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponsePlay(access, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\tcase \"PLAY\":\n\t\t\t\t\t\treturn await ResponsePlay(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"POINTS\":\n\t\t\t\t\t\treturn await ResponsePointsBalance(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"PRIVACY\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponsePrivacy(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"PRIVACY\":\n\t\t\t\t\t\treturn await ResponsePrivacy(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"R\" when args.Length > 2:\n\t\t\t\t\tcase \"REDEEM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseRedeem(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"R\":\n\t\t\t\t\tcase \"REDEEM\":\n\t\t\t\t\t\treturn await ResponseRedeem(access, args[1], steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"R^\" when args.Length > 3:\n\t\t\t\t\tcase \"REDEEM^\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseAdvancedRedeem(access, args[1], args[2], Utilities.GetArgsAsText(args, 3, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"R^\" when args.Length > 2:\n\t\t\t\t\tcase \"REDEEM^\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseAdvancedRedeem(access, args[1], args[2], steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\treturn await ResponseReset(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\treturn await ResponseResume(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\treturn await ResponseStart(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\treturn await ResponseStatus(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\treturn await ResponseStop(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"TB\":\n\t\t\t\t\t\treturn await ResponseTradingBlacklist(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"TBADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTradingBlacklistAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"TBADD\":\n\t\t\t\t\t\treturn ResponseTradingBlacklistAdd(access, args[1]);\n\t\t\t\t\tcase \"TBRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTradingBlacklistRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\tcase \"TBRM\":\n\t\t\t\t\t\treturn ResponseTradingBlacklistRemove(access, args[1]);\n\t\t\t\t\tcase \"TRANSFER\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTransfer(access, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER\":\n\t\t\t\t\t\treturn await ResponseTransfer(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 4:\n\t\t\t\t\t\treturn await ResponseAdvancedTransfer(access, args[1], args[2], args[3], Utilities.GetArgsAsText(message, 4)).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseAdvancedTransfer(access, args[1], args[2], args[3]).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2], Utilities.GetArgsAsText(message, 3), true).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2], true).ConfigureAwait(false);\n\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\treturn await ResponseUnpackBoosters(access, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, access, message, args, steamID).ConfigureAwait(false);\n\n\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(access);\n\t\t\t\t}\n\t\t}\n\t}\n\n\tinternal async Task HandleMessage(ulong steamID, string message) {\n\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t}\n\n\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.Ordinal)) {\n\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\tif (!await Bot.SendMessage(steamID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, pluginsResponse));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (message.Length == commandPrefix!.Length) {\n\t\t\t\t// If the message starts with command prefix and is of the same length as command prefix, then it's just empty command trigger, useless\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage = message[commandPrefix.Length..];\n\t\t}\n\n\t\tEAccess access = Bot.GetAccess(steamID);\n\n\t\tTask<string?> responseTask = Response(access, message, steamID);\n\n\t\tbool feedback = access >= EAccess.FamilySharing;\n\n\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t}\n\n\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tif (!feedback) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse = FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t}\n\n\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\tif (!await Bot.SendMessage(steamID, response!).ConfigureAwait(false)) {\n\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, response));\n\t\t}\n\t}\n\n\tinternal async Task HandleMessage(ulong chatGroupID, ulong chatID, ulong steamID, string message) {\n\t\tif (chatGroupID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(chatGroupID));\n\t\t}\n\n\t\tif (chatID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(chatID));\n\t\t}\n\n\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t}\n\n\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.Ordinal)) {\n\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, pluginsResponse));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (message.Length == commandPrefix!.Length) {\n\t\t\t\t// If the message starts with command prefix and is of the same length as command prefix, then it's just empty command trigger, useless\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage = message[commandPrefix.Length..];\n\t\t}\n\n\t\tEAccess access = Bot.GetAccess(steamID);\n\n\t\tTask<string?> responseTask = Response(access, message, steamID);\n\n\t\tbool feedback = access >= EAccess.FamilySharing;\n\n\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\tstring pleaseWaitMessage = FormatBotResponse(Strings.PleaseWait);\n\n\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t}\n\n\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tif (!feedback) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse = FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t}\n\n\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\tif (!await Bot.SendMessage(chatGroupID, chatID, response!).ConfigureAwait(false)) {\n\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, response));\n\t\t}\n\t}\n\n\tinternal void OnNewLicenseList() {\n\t\tlock (CachedGamesOwned) {\n\t\t\tCachedGamesOwned.Clear();\n\t\t\tCachedGamesOwned.TrimExcess();\n\t\t}\n\t}\n\n\tprivate async Task<Dictionary<uint, string>?> FetchGamesOwned(bool cachedOnly = false) {\n\t\tlock (CachedGamesOwned) {\n\t\t\tif (CachedGamesOwned.Count > 0) {\n\t\t\t\treturn new Dictionary<uint, string>(CachedGamesOwned);\n\t\t\t}\n\t\t}\n\n\t\tif (cachedOnly) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDictionary<uint, string>? gamesOwned = await Bot.ArchiHandler.GetOwnedGames(Bot.SteamID).ConfigureAwait(false);\n\n\t\tif (gamesOwned?.Count > 0) {\n\t\t\tlock (CachedGamesOwned) {\n\t\t\t\tif (CachedGamesOwned.Count == 0) {\n\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned) {\n\t\t\t\t\t\tCachedGamesOwned[appID] = gameName;\n\t\t\t\t\t}\n\n\t\t\t\t\tCachedGamesOwned.TrimExcess();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn gamesOwned;\n\t}\n\n\tprivate async Task<string?> Response2FA(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string? token, string message) = await Bot.Actions.GenerateTwoFactorAuthenticationToken().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success && !string.IsNullOrEmpty(token) ? string.Format(CultureInfo.CurrentCulture, Strings.BotAuthenticatorToken, token) : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> Response2FA(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FA(access))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> Response2FAConfirm(EAccess access, bool confirm) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (!Bot.HasMobileAuthenticator) {\n\t\t\treturn FormatBotResponse(Strings.BotNoASFAuthenticator);\n\t\t}\n\n\t\t(bool success, _, string message) = await Bot.Actions.HandleTwoFactorAuthenticationConfirmations(confirm).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> Response2FAConfirm(EAccess access, string botNames, bool confirm) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FAConfirm(access, confirm))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAddLicense(EAccess access, string query) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tStringBuilder response = new();\n\n\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tforeach (string entry in entries) {\n\t\t\tuint gameID;\n\t\t\tstring type;\n\n\t\t\tint index = entry.IndexOf('/', StringComparison.Ordinal);\n\n\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\tif (!uint.TryParse(entry[(index + 1)..], out gameID) || (gameID == 0)) {\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttype = entry[..index];\n\t\t\t} else if (uint.TryParse(entry, out gameID) && (gameID > 0)) {\n\t\t\t\ttype = \"SUB\";\n\t\t\t} else {\n\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\tcase \"A\":\n\t\t\t\tcase \"APP\":\n\t\t\t\t\tSteamApps.FreeLicenseCallback callback;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcallback = await Bot.SteamApps.RequestFreeLicense(gameID).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicense, $\"app/{gameID}\", EResult.Timeout)));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse((callback.GrantedApps.Count > 0) || (callback.GrantedPackages.Count > 0) ? string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicenseWithItems, $\"app/{gameID}\", callback.Result, string.Join(\", \", callback.GrantedApps.Select(static appID => $\"app/{appID}\").Union(callback.GrantedPackages.Select(static subID => $\"sub/{subID}\")))) : string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicense, $\"app/{gameID}\", callback.Result)));\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t(EResult result, EPurchaseResultDetail purchaseResult) = await Bot.ArchiWebHandler.AddFreeLicense(gameID).ConfigureAwait(false);\n\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicense, $\"sub/{gameID}\", $\"{result}/{purchaseResult}\")));\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn response.Length > 0 ? response.ToString() : null;\n\t}\n\n\tprivate static async Task<string?> ResponseAddLicense(EAccess access, string botNames, string query) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAddLicense(access, query))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedLoot(EAccess access, string targetAppID, string targetContextID) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetContextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetContextID));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t}\n\n\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseAdvancedLoot(EAccess access, string botNames, string appID, string contextID) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(appID)) {\n\t\t\tthrow new ArgumentNullException(nameof(appID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(contextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(contextID));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedLoot(access, appID, contextID))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedRedeem(EAccess access, string options, string keys, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(options)) {\n\t\t\tthrow new ArgumentNullException(nameof(options));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keys)) {\n\t\t\tthrow new ArgumentNullException(nameof(keys));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] flags = options.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (flags.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(flags)));\n\t\t}\n\n\t\tERedeemFlags redeemFlags = ERedeemFlags.None;\n\n\t\tforeach (string flag in flags) {\n\t\t\tswitch (flag.ToUpperInvariant()) {\n\t\t\t\tcase \"FAWK\":\n\t\t\t\tcase \"FORCEASSUMEWALLETKEY\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FD\":\n\t\t\t\tcase \"FORCEDISTRIBUTING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceDistributing;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FF\":\n\t\t\t\tcase \"FORCEFORWARDING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceForwarding;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FKMG\":\n\t\t\t\tcase \"FORCEKEEPMISSINGGAMES\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceKeepMissingGames;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SAWK\":\n\t\t\t\tcase \"SKIPASSUMEWALLETKEY\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SD\":\n\t\t\t\tcase \"SKIPDISTRIBUTING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipDistributing;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SF\":\n\t\t\t\tcase \"SKIPFORWARDING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipForwarding;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SI\":\n\t\t\t\tcase \"SKIPINITIAL\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipInitial;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SKMG\":\n\t\t\t\tcase \"SKIPKEEPMISSINGGAMES\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipKeepMissingGames;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"V\":\n\t\t\t\tcase \"VALIDATE\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.Validate;\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, flag));\n\t\t\t}\n\t\t}\n\n\t\treturn await ResponseRedeem(access, keys, steamID, redeemFlags).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponseAdvancedRedeem(EAccess access, string botNames, string options, string keys, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(options)) {\n\t\t\tthrow new ArgumentNullException(nameof(options));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keys)) {\n\t\t\tthrow new ArgumentNullException(nameof(keys));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedRedeem(access, options, keys, steamID))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedTransfer(EAccess access, uint appID, ulong contextID, Bot targetBot) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (appID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(appID));\n\t\t}\n\n\t\tif (contextID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(contextID));\n\t\t}\n\n\t\tArgumentNullException.ThrowIfNull(targetBot);\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID, targetBot.SteamID).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedTransfer(EAccess access, string targetAppID, string targetContextID, string botNameTo) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetContextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetContextID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t}\n\n\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t}\n\n\t\treturn await ResponseAdvancedTransfer(access, appID, contextID, targetBot).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponseAdvancedTransfer(EAccess access, string botNames, string targetAppID, string targetContextID, string botNameTo) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetContextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetContextID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t}\n\n\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedTransfer(access, appID, contextID, targetBot))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseBackgroundGamesRedeemer(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tuint count = Bot.GamesToRedeemInBackgroundCount;\n\n\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotGamesToRedeemInBackgroundCount, count));\n\t}\n\n\tprivate static async Task<string?> ResponseBackgroundGamesRedeemer(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBackgroundGamesRedeemer(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static string? ResponseEncrypt(EAccess access, string cryptoMethodText, string stringToEncrypt) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(cryptoMethodText)) {\n\t\t\tthrow new ArgumentNullException(nameof(cryptoMethodText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(stringToEncrypt)) {\n\t\t\tthrow new ArgumentNullException(nameof(stringToEncrypt));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Enum.TryParse(cryptoMethodText, true, out ArchiCryptoHelper.ECryptoMethod cryptoMethod)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(cryptoMethod)));\n\t\t}\n\n\t\tstring? encryptedString = Actions.Encrypt(cryptoMethod, stringToEncrypt);\n\n\t\treturn FormatStaticResponse(!string.IsNullOrEmpty(encryptedString) ? string.Format(CultureInfo.CurrentCulture, Strings.Result, encryptedString) : Strings.WarningFailed);\n\t}\n\n\tprivate static string? ResponseExit(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Actions.Exit();\n\n\t\treturn FormatStaticResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponseFarm(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.NowFarming) {\n\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t}\n\n\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarm(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseFarm(access))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingBlacklist(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.FarmingBlacklistAppIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.FarmingBlacklistAppIDs)) : string.Join(\", \", Bot.BotDatabase.FarmingBlacklistAppIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingBlacklist(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingBlacklist(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingBlacklistAdd(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingBlacklistAppIDs.AddRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.NowFarming && Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID))) {\n\t\t\tUtilities.InBackground(\n\t\t\t\tasync () => {\n\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingBlacklistAdd(EAccess access, string botNames, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingBlacklistAdd(access, targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingBlacklistRemove(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingBlacklistAppIDs.RemoveRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tif (!Bot.CardsFarmer.NowFarming) {\n\t\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingBlacklistRemove(EAccess access, string botNames, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingBlacklistRemove(access, targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingQueue(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.FarmingPriorityQueueAppIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.FarmingPriorityQueueAppIDs)) : string.Join(\", \", Bot.BotDatabase.FarmingPriorityQueueAppIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingQueue(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingQueue(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingQueueAdd(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingPriorityQueueAppIDs.AddRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tswitch (Bot.CardsFarmer.NowFarming) {\n\t\t\tcase false when Bot.BotConfig.FarmPriorityQueueOnly:\n\t\t\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\n\t\t\t\tbreak;\n\t\t\tcase true when Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID)):\n\t\t\t\tUtilities.InBackground(\n\t\t\t\t\tasync () => {\n\t\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingQueueAdd(EAccess access, string botNames, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingQueueAdd(access, targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingQueueRemove(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingPriorityQueueAppIDs.RemoveRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.NowFarming && Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID))) {\n\t\t\tUtilities.InBackground(\n\t\t\t\tasync () => {\n\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingQueueRemove(EAccess access, string botNames, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingQueueRemove(access, targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static string? ResponseHash(EAccess access, string hashingMethodText, string stringToHash) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(hashingMethodText)) {\n\t\t\tthrow new ArgumentNullException(nameof(hashingMethodText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(stringToHash)) {\n\t\t\tthrow new ArgumentNullException(nameof(stringToHash));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Enum.TryParse(hashingMethodText, true, out ArchiCryptoHelper.EHashingMethod hashingMethod)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(hashingMethod)));\n\t\t}\n\n\t\tstring hash = Actions.Hash(hashingMethod, stringToHash);\n\n\t\treturn FormatStaticResponse(!string.IsNullOrEmpty(hash) ? string.Format(CultureInfo.CurrentCulture, Strings.Result, hash) : Strings.WarningFailed);\n\t}\n\n\tprivate string? ResponseHelp(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access >= EAccess.FamilySharing ? FormatBotResponse($\"{SharedInfo.ProjectURL}/wiki/Commands\") : null;\n\t}\n\n\tprivate string? ResponseInput(EAccess access, string propertyName, string inputValue) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(propertyName)) {\n\t\t\tthrow new ArgumentNullException(nameof(propertyName));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(inputValue)) {\n\t\t\tthrow new ArgumentNullException(nameof(inputValue));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tbool headless = Program.Service || (ASF.GlobalConfig?.Headless ?? GlobalConfig.DefaultHeadless);\n\n\t\tif (!headless) {\n\t\t\treturn FormatBotResponse(Strings.ErrorFunctionOnlyInHeadlessMode);\n\t\t}\n\n\t\tif (!Enum.TryParse(propertyName, true, out ASF.EUserInputType inputType) || (inputType == ASF.EUserInputType.None) || !Enum.IsDefined(inputType)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(inputType)));\n\t\t}\n\n\t\tbool result = Bot.SetUserInput(inputType, inputValue);\n\n\t\treturn FormatBotResponse(result ? Strings.Done : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponseInput(EAccess access, string botNames, string propertyName, string inputValue) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(propertyName)) {\n\t\t\tthrow new ArgumentNullException(nameof(propertyName));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(inputValue)) {\n\t\t\tthrow new ArgumentNullException(nameof(inputValue));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseInput(access, propertyName, inputValue)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseLevel(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tuint? level = await Bot.ArchiHandler.GetLevel().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(level.HasValue ? string.Format(CultureInfo.CurrentCulture, Strings.BotLevel, level.Value) : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponseLevel(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLevel(access))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseLoot(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseLoot(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLoot(access))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseLootByRealAppIDs(EAccess access, string realAppIDsText, bool exclude = false) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t}\n\n\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (appIDTexts.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t}\n\n\t\tHashSet<uint> realAppIDs = new();\n\n\t\tforeach (string appIDText in appIDTexts) {\n\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\trealAppIDs.Add(appID);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseLootByRealAppIDs(EAccess access, string botNames, string realAppIDsText, bool exclude = false) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLootByRealAppIDs(access, realAppIDsText, exclude))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseMatchActivelyBlacklist(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.MatchActivelyBlacklistAppIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.MatchActivelyBlacklistAppIDs)) : string.Join(\", \", Bot.BotDatabase.MatchActivelyBlacklistAppIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseMatchActivelyBlacklist(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseMatchActivelyBlacklist(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseMatchActivelyBlacklistAdd(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.MatchActivelyBlacklistAppIDs.AddRange(appIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseMatchActivelyBlacklistAdd(EAccess access, string botNames, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseMatchActivelyBlacklistAdd(access, targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseMatchActivelyBlacklistRemove(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.MatchActivelyBlacklistAppIDs.RemoveRange(appIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseMatchActivelyBlacklistRemove(EAccess access, string botNames, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseMatchActivelyBlacklistRemove(access, targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseNickname(EAccess access, string nickname) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(nickname)) {\n\t\t\tthrow new ArgumentNullException(nameof(nickname));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tBot.SteamFriends.SetPersonaName(nickname);\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseNickname(EAccess access, string botNames, string nickname) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(nickname)) {\n\t\t\tthrow new ArgumentNullException(nameof(nickname));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseNickname(access, nickname)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<(string? Response, Dictionary<string, string>? OwnedGames)> ResponseOwns(EAccess access, string query) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn (null, null);\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn (FormatBotResponse(Strings.BotNotConnected), null);\n\t\t}\n\n\t\tDictionary<uint, string>? gamesOwned = await FetchGamesOwned(true).ConfigureAwait(false);\n\n\t\tStringBuilder response = new();\n\t\tDictionary<string, string> result = new(StringComparer.Ordinal);\n\n\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tforeach (string entry in entries) {\n\t\t\tstring game;\n\t\t\tstring type;\n\n\t\t\tint index = entry.IndexOf('/', StringComparison.Ordinal);\n\n\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\tgame = entry[(index + 1)..];\n\t\t\t\ttype = entry[..index];\n\t\t\t} else if (uint.TryParse(entry, out uint appID) && (appID > 0)) {\n\t\t\t\tgame = entry;\n\t\t\t\ttype = \"APP\";\n\t\t\t} else {\n\t\t\t\tgame = entry;\n\t\t\t\ttype = \"NAME\";\n\t\t\t}\n\n\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\tcase \"A\" when uint.TryParse(game, out uint appID) && (appID > 0):\n\t\t\t\tcase \"APP\" when uint.TryParse(game, out appID) && (appID > 0):\n\t\t\t\t\tHashSet<uint>? packageIDs = ASF.GlobalDatabase?.GetPackageIDs(appID, Bot.OwnedPackageIDs.Keys);\n\n\t\t\t\t\tif (packageIDs?.Count > 0) {\n\t\t\t\t\t\tif ((gamesOwned != null) && gamesOwned.TryGetValue(appID, out string? cachedGameName)) {\n\t\t\t\t\t\t\tresult[$\"app/{appID}\"] = cachedGameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", cachedGameName)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[$\"app/{appID}\"] = appID.ToString(CultureInfo.InvariantCulture);\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlready, $\"app/{appID}\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (gamesOwned.TryGetValue(appID, out string? gameName)) {\n\t\t\t\t\t\t\tresult[$\"app/{appID}\"] = gameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", gameName)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, $\"app/{appID}\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"R\":\n\t\t\t\tcase \"REGEX\":\n\t\t\t\t\tRegex regex;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tregex = new Regex(game);\n\t\t\t\t\t} catch (ArgumentException e) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(regex))));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool foundWithRegex = false;\n\n\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => regex.IsMatch(gameOwned.Value))) {\n\t\t\t\t\t\tfoundWithRegex = true;\n\n\t\t\t\t\t\tresult[$\"app/{appID}\"] = gameName;\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", gameName)));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!foundWithRegex) {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\tcase \"S\" when uint.TryParse(game, out uint packageID) && (packageID > 0):\n\t\t\t\tcase \"SUB\" when uint.TryParse(game, out packageID) && (packageID > 0):\n\t\t\t\t\tif (Bot.OwnedPackageIDs.ContainsKey(packageID)) {\n\t\t\t\t\t\tresult[$\"sub/{packageID}\"] = packageID.ToString(CultureInfo.InvariantCulture);\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlready, $\"sub/{packageID}\")));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, $\"sub/{packageID}\")));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool foundWithName = false;\n\n\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => gameOwned.Value.Contains(game, StringComparison.OrdinalIgnoreCase))) {\n\t\t\t\t\t\tfoundWithName = true;\n\n\t\t\t\t\t\tresult[$\"app/{appID}\"] = gameName;\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", gameName)));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!foundWithName) {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (response.Length > 0 ? response.ToString() : FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, query)), result);\n\t}\n\n\tprivate static async Task<string?> ResponseOwns(EAccess access, string botNames, string query) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<(string? Response, Dictionary<string, string>? OwnedGames)> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseOwns(access, query))).ConfigureAwait(false);\n\n\t\tList<(string Response, Dictionary<string, string> OwnedGames)> validResults = new(results.Where(static result => !string.IsNullOrEmpty(result.Response) && (result.OwnedGames != null))!);\n\n\t\tif (validResults.Count == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDictionary<string, (ushort Count, string GameName)> ownedGamesStats = new(StringComparer.Ordinal);\n\n\t\tforeach ((string gameID, string gameName) in validResults.Where(static validResult => validResult.OwnedGames.Count > 0).SelectMany(static validResult => validResult.OwnedGames)) {\n\t\t\tif (ownedGamesStats.TryGetValue(gameID, out (ushort Count, string GameName) ownedGameStats)) {\n\t\t\t\townedGameStats.Count++;\n\t\t\t} else {\n\t\t\t\townedGameStats.Count = 1;\n\t\t\t}\n\n\t\t\tif (!string.IsNullOrEmpty(gameName)) {\n\t\t\t\townedGameStats.GameName = gameName;\n\t\t\t}\n\n\t\t\townedGamesStats[gameID] = ownedGameStats;\n\t\t}\n\n\t\tIEnumerable<string> extraResponses = ownedGamesStats.Select(kv => FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnsOverviewPerGame, kv.Value.Count, validResults.Count, $\"{kv.Key}{(!string.IsNullOrEmpty(kv.Value.GameName) ? $\" | {kv.Value.GameName}\" : \"\")}\")));\n\n\t\treturn string.Join(Environment.NewLine, validResults.Select(static result => result.Response).Concat(extraResponses));\n\t}\n\n\tprivate async Task<string?> ResponsePause(EAccess access, bool permanent, string? resumeInSecondsText = null) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.FamilySharing) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (permanent && (access < EAccess.Operator)) {\n\t\t\treturn FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t}\n\n\t\tushort resumeInSeconds = 0;\n\n\t\tif (!string.IsNullOrEmpty(resumeInSecondsText) && (!ushort.TryParse(resumeInSecondsText, out resumeInSeconds) || (resumeInSeconds == 0))) {\n\t\t\treturn string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(resumeInSecondsText));\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.Pause(permanent, resumeInSeconds).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponsePause(EAccess access, string botNames, bool permanent, string? resumeInSecondsText = null) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePause(access, permanent, resumeInSecondsText))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponsePlay(EAccess access, IReadOnlyCollection<uint> gameIDs, string? gameName = null) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tArgumentNullException.ThrowIfNull(gameIDs);\n\n\t\tif (gameIDs.Count > ArchiHandler.MaxGamesPlayedConcurrently) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(gameIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.Play(gameIDs, gameName).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponsePlay(EAccess access, string targetGameIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetGameIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tstring[] games = targetGameIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (games.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(games)));\n\t\t}\n\n\t\tHashSet<uint> gamesToPlay = new();\n\t\tStringBuilder gameName = new();\n\n\t\tforeach (string game in games) {\n\t\t\tif (!uint.TryParse(game, out uint gameID) || (gameID == 0)) {\n\t\t\t\tif (gameName.Length > 0) {\n\t\t\t\t\tgameName.Append(' ');\n\t\t\t\t}\n\n\t\t\t\tgameName.Append(game);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (gamesToPlay.Count >= ArchiHandler.MaxGamesPlayedConcurrently) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, $\"{nameof(gamesToPlay)} > {ArchiHandler.MaxGamesPlayedConcurrently}\"));\n\t\t\t}\n\n\t\t\tgamesToPlay.Add(gameID);\n\t\t}\n\n\t\treturn await ResponsePlay(access, gamesToPlay, gameName.Length > 0 ? gameName.ToString() : null).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponsePlay(EAccess access, string botNames, string targetGameIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetGameIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePlay(access, targetGameIDs))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponsePointsBalance(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tuint? points = await Bot.ArchiWebHandler.GetPointsBalance().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(points.HasValue ? string.Format(CultureInfo.CurrentCulture, Strings.BotPointsBalance, points) : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponsePointsBalance(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePointsBalance(access))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponsePrivacy(EAccess access, string privacySettingsText) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(privacySettingsText));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\t// There are only 7 privacy settings\n\t\tconst byte privacySettings = 7;\n\n\t\tstring[] privacySettingsArgs = privacySettingsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tswitch (privacySettingsArgs.Length) {\n\t\t\tcase 0:\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(privacySettingsArgs)));\n\t\t\tcase > privacySettings:\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t}\n\n\t\tArchiHandler.EPrivacySetting profile = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting ownedGames = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting playtime = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting friendsList = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting inventory = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting inventoryGifts = ArchiHandler.EPrivacySetting.Private;\n\t\tUserPrivacy.ECommentPermission comments = UserPrivacy.ECommentPermission.Private;\n\n\t\t// Converting digits to enum\n\t\tfor (byte index = 0; index < privacySettingsArgs.Length; index++) {\n\t\t\tif (!Enum.TryParse(privacySettingsArgs[index], true, out ArchiHandler.EPrivacySetting privacySetting) || (privacySetting == ArchiHandler.EPrivacySetting.Unknown) || !Enum.IsDefined(privacySetting)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t\t}\n\n\t\t\t// Child setting can't be less restrictive than its parent\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\t// Profile\n\t\t\t\t\tprofile = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// OwnedGames, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t}\n\n\t\t\t\t\townedGames = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Playtime, child of OwnedGames\n\t\t\t\t\tif (ownedGames < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(playtime)));\n\t\t\t\t\t}\n\n\t\t\t\t\tplaytime = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// FriendsList, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t}\n\n\t\t\t\t\tfriendsList = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t// Inventory, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(inventory)));\n\t\t\t\t\t}\n\n\t\t\t\t\tinventory = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\t// InventoryGifts, child of Inventory\n\t\t\t\t\tif (inventory < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(inventoryGifts)));\n\t\t\t\t\t}\n\n\t\t\t\t\tinventoryGifts = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\t// Comments, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(comments)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Comments use different numbers than everything else, but we want to have this command consistent for end-user, so we'll map them\n\t\t\t\t\tswitch (privacySetting) {\n\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.FriendsOnly:\n\t\t\t\t\t\t\tcomments = UserPrivacy.ECommentPermission.FriendsOnly;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Private:\n\t\t\t\t\t\t\tcomments = UserPrivacy.ECommentPermission.Private;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Public:\n\t\t\t\t\t\t\tcomments = UserPrivacy.ECommentPermission.Public;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.WarningUnknownValuePleaseReport, nameof(privacySetting), privacySetting));\n\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(privacySetting)));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.WarningUnknownValuePleaseReport, nameof(index), index));\n\n\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(index)));\n\t\t\t}\n\t\t}\n\n\t\tUserPrivacy userPrivacy = new(new UserPrivacy.PrivacySettings(profile, ownedGames, playtime, friendsList, inventory, inventoryGifts), comments);\n\n\t\treturn FormatBotResponse(await Bot.ArchiWebHandler.ChangePrivacySettings(userPrivacy).ConfigureAwait(false) ? Strings.Success : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponsePrivacy(EAccess access, string botNames, string privacySettingsText) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(privacySettingsText));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePrivacy(access, privacySettingsText))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseRedeem(EAccess access, string keysText, ulong steamID = 0, ERedeemFlags redeemFlags = ERedeemFlags.None) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keysText)) {\n\t\t\tthrow new ArgumentNullException(nameof(keysText));\n\t\t}\n\n\t\tif ((steamID != 0) && !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tif (Bot.Bots == null) {\n\t\t\tthrow new InvalidOperationException(nameof(Bot.Bots));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tstring[] keys = keysText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (keys.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(keys)));\n\t\t}\n\n\t\tbool forward = !redeemFlags.HasFlag(ERedeemFlags.SkipForwarding) && (redeemFlags.HasFlag(ERedeemFlags.ForceForwarding) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Forwarding));\n\t\tbool distribute = !redeemFlags.HasFlag(ERedeemFlags.SkipDistributing) && (redeemFlags.HasFlag(ERedeemFlags.ForceDistributing) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Distributing));\n\t\tbool keepMissingGames = !redeemFlags.HasFlag(ERedeemFlags.SkipKeepMissingGames) && (redeemFlags.HasFlag(ERedeemFlags.ForceKeepMissingGames) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.KeepMissingGames));\n\t\tbool assumeWalletKeyOnBadActivationCode = !redeemFlags.HasFlag(ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode) && (redeemFlags.HasFlag(ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.AssumeWalletKeyOnBadActivationCode));\n\n\t\tHashSet<string> pendingKeys = keys.ToHashSet(StringComparer.Ordinal);\n\t\tHashSet<string> unusedKeys = pendingKeys.ToHashSet(StringComparer.Ordinal);\n\n\t\tHashSet<Bot> rateLimitedBots = new();\n\t\tHashSet<Bot> triedBots = new();\n\n\t\tStringBuilder response = new();\n\n\t\tusing (HashSet<string>.Enumerator keysEnumerator = pendingKeys.GetEnumerator()) {\n\t\t\t// Initial key\n\t\t\tstring? key = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\tstring? previousKey = key;\n\n\t\t\twhile (!string.IsNullOrEmpty(key)) {\n\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\tstring startingKey = key!;\n\n\t\t\t\tusing (IEnumerator<Bot> botsEnumerator = Bot.Bots.Where(bot => (bot.Value != Bot) && bot.Value.IsConnectedAndLoggedOn && ((access >= EAccess.Owner) || ((steamID != 0) && (bot.Value.GetAccess(steamID) >= EAccess.Operator)))).OrderByDescending(bot => Bot.BotsComparer?.Compare(bot.Key, Bot.BotName) > 0).ThenBy(static bot => bot.Key, Bot.BotsComparer).Select(static bot => bot.Value).GetEnumerator()) {\n\t\t\t\t\tBot? currentBot = Bot;\n\n\t\t\t\t\twhile (!string.IsNullOrEmpty(key) && (currentBot != null)) {\n\t\t\t\t\t\tif (previousKey != key) {\n\t\t\t\t\t\t\ttriedBots.Clear();\n\t\t\t\t\t\t\tpreviousKey = key;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\tif (redeemFlags.HasFlag(ERedeemFlags.Validate) && !Utilities.IsValidCdKey(key!)) {\n\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((currentBot == Bot) && redeemFlags.HasFlag(ERedeemFlags.SkipInitial)) {\n\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbool skipRequest = triedBots.Contains(currentBot) || rateLimitedBots.Contains(currentBot);\n\n\t\t\t\t\t\t\tEResult result = EResult.Fail;\n\t\t\t\t\t\t\tEPurchaseResultDetail purchaseResultDetail = EPurchaseResultDetail.CancelledByUser;\n\t\t\t\t\t\t\tDictionary<uint, string>? items = null;\n\n\t\t\t\t\t\t\tif (!skipRequest) {\n\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\tSteamApps.PurchaseResponseCallback? redeemResult = await currentBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tresult = redeemResult?.Result ?? EResult.Timeout;\n\t\t\t\t\t\t\t\tpurchaseResultDetail = redeemResult?.PurchaseResultDetail ?? EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t\t\titems = redeemResult?.ParseItems();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((result == EResult.Timeout) || (purchaseResultDetail == EPurchaseResultDetail.Timeout)) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{result}/{purchaseResultDetail}\"), currentBot.BotName));\n\n\t\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttriedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\tif ((purchaseResultDetail == EPurchaseResultDetail.CannotRedeemCodeFromClient) || ((purchaseResultDetail == EPurchaseResultDetail.BadActivationCode) && assumeWalletKeyOnBadActivationCode)) {\n\t\t\t\t\t\t\t\t\tif (Bot.WalletCurrency != ECurrencyCode.Invalid) {\n\t\t\t\t\t\t\t\t\t\t// If it's a wallet code, we try to redeem it first, then handle the inner result as our primary one\n\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t(EResult Result, EPurchaseResultDetail? PurchaseResult)? walletResult = await currentBot.ArchiWebHandler.RedeemWalletKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\tif (walletResult != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult = walletResult.Value.Result;\n\t\t\t\t\t\t\t\t\t\t\tpurchaseResultDetail = walletResult.Value.PurchaseResult.GetValueOrDefault(walletResult.Value.Result == EResult.OK ? EPurchaseResultDetail.NoDetail : EPurchaseResultDetail.CannotRedeemCodeFromClient);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tresult = EResult.Timeout;\n\t\t\t\t\t\t\t\t\t\t\tpurchaseResultDetail = EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// We're unable to redeem this code from the client due to missing currency information\n\t\t\t\t\t\t\t\t\t\tpurchaseResultDetail = EPurchaseResultDetail.CannotRedeemCodeFromClient;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (items?.Count > 0) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeemWithItems, key, $\"{result}/{purchaseResultDetail}\", string.Join(\", \", items)), currentBot.BotName));\n\t\t\t\t\t\t\t\t} else if (!skipRequest) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{result}/{purchaseResultDetail}\"), currentBot.BotName));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tswitch (purchaseResultDetail) {\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CannotRedeemCodeFromClient:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.Timeout:\n\t\t\t\t\t\t\t\t\t\tif ((result != EResult.Timeout) && (purchaseResultDetail != EPurchaseResultDetail.Timeout)) {\n\t\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\tif (purchaseResultDetail == EPurchaseResultDetail.NoDetail) {\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AccountLocked:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AlreadyPurchased:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CancelledByUser:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DoesNotOwnRequiredApp:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RestrictedCountry:\n\t\t\t\t\t\t\t\t\t\tif (!forward || (keepMissingGames && (purchaseResultDetail != EPurchaseResultDetail.AlreadyPurchased))) {\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (distribute) {\n\t\t\t\t\t\t\t\t\t\t\t// Next bot, without changing key\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\titems ??= new Dictionary<uint, string>();\n\n\t\t\t\t\t\t\t\t\t\tbool alreadyHandled = false;\n\n\t\t\t\t\t\t\t\t\t\tforeach (Bot innerBot in Bot.Bots.Where(bot => (bot.Value != currentBot) && (!redeemFlags.HasFlag(ERedeemFlags.SkipInitial) || (bot.Value != Bot)) && !triedBots.Contains(bot.Value) && !rateLimitedBots.Contains(bot.Value) && bot.Value.IsConnectedAndLoggedOn && ((access >= EAccess.Owner) || ((steamID != 0) && (bot.Value.GetAccess(steamID) >= EAccess.Operator))) && ((items.Count == 0) || items.Keys.Any(packageID => !bot.Value.OwnedPackageIDs.ContainsKey(packageID)))).OrderBy(static bot => bot.Key, Bot.BotsComparer).Select(static bot => bot.Value)) {\n\t\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t\tSteamApps.PurchaseResponseCallback? redeemResult = await innerBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\t\tif (redeemResult == null) {\n\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{EResult.Timeout}/{EPurchaseResultDetail.Timeout}\"), innerBot.BotName));\n\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ttriedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\tswitch (redeemResult.PurchaseResultDetail) {\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\t\t\t\t\t// This key is already handled, as we either redeemed it or we're sure it's dupe/invalid\n\t\t\t\t\t\t\t\t\t\t\t\t\talreadyHandled = true;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tDictionary<uint, string>? redeemItems = redeemResult.ParseItems();\n\n\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(redeemItems?.Count > 0 ? string.Format(CultureInfo.CurrentCulture, Strings.BotRedeemWithItems, key, $\"{redeemResult.Result}/{redeemResult.PurchaseResultDetail}\", string.Join(\", \", redeemItems)) : string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{redeemResult.Result}/{redeemResult.PurchaseResultDetail}\"), innerBot.BotName));\n\n\t\t\t\t\t\t\t\t\t\t\tif (alreadyHandled) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (redeemItems == null) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tforeach ((uint packageID, string packageName) in redeemItems.Where(item => !items.ContainsKey(item.Key))) {\n\t\t\t\t\t\t\t\t\t\t\t\titems[packageID] = packageName;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\t\t\tgoto case EPurchaseResultDetail.CancelledByUser;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.WarningUnknownValuePleaseReport, nameof(purchaseResultDetail), purchaseResultDetail));\n\n\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We want to change bot in two cases:\n\t\t\t\t\t\t// a) When we have distribution enabled, obviously\n\t\t\t\t\t\t// b) When we're skipping initial bot AND we have forwarding enabled, otherwise we won't get down to other accounts\n\t\t\t\t\t\tif (distribute || (forward && redeemFlags.HasFlag(ERedeemFlags.SkipInitial))) {\n\t\t\t\t\t\t\tcurrentBot = botsEnumerator.MoveNext() ? botsEnumerator.Current : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (key == startingKey) {\n\t\t\t\t\t// We ran out of bots to try for this key, so change it to avoid infinite loop, next key\n\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (unusedKeys.Count > 0) {\n\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.UnusedKeys, string.Join(\", \", unusedKeys))));\n\t\t}\n\n\t\treturn response.Length > 0 ? response.ToString() : null;\n\t}\n\n\tprivate static async Task<string?> ResponseRedeem(EAccess access, string botNames, string keysText, ulong steamID = 0, ERedeemFlags redeemFlags = ERedeemFlags.None) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keysText)) {\n\t\t\tthrow new ArgumentNullException(nameof(keysText));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseRedeem(access, keysText, steamID, redeemFlags))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseReset(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tawait Bot.CheckOccupationStatus().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseReset(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseReset(access))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static string? ResponseRestart(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Actions.Restart();\n\n\t\treturn FormatStaticResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate string? ResponseResume(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.FamilySharing) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Bot.Actions.Resume();\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseResume(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseResume(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseStart(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Bot.Actions.Start();\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseStart(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStart(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseStats(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\tushort memoryInMegabytes = (ushort) (GC.GetTotalMemory(false) / 1024 / 1024);\n\t\tTimeSpan uptime = DateTime.UtcNow.Subtract(OS.ProcessStartTime);\n\n\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotStats, memoryInMegabytes, uptime.ToHumanReadable()));\n\t}\n\n\tprivate (string? Response, Bot Bot) ResponseStatus(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.FamilySharing) {\n\t\t\treturn (null, Bot);\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn (FormatBotResponse(Bot.KeepRunning ? Strings.BotStatusConnecting : Strings.BotStatusNotRunning), Bot);\n\t\t}\n\n\t\tif (Bot.PlayingBlocked) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusPlayingNotAvailable), Bot);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.Paused) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusPaused), Bot);\n\t\t}\n\n\t\tif (Bot.IsAccountLimited) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusLimited), Bot);\n\t\t}\n\n\t\tif (Bot.IsAccountLocked) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusLocked), Bot);\n\t\t}\n\n\t\tif (!Bot.CardsFarmer.NowFarming || (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count == 0)) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusNotIdling), Bot);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count > 1) {\n\t\t\treturn (FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotStatusIdlingList, string.Join(\", \", Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Select(static game => $\"{game.AppID} ({game.GameName})\")), Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(static game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t\t}\n\n\t\tGame soloGame = Bot.CardsFarmer.CurrentGamesFarmingReadOnly.First();\n\n\t\treturn (FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotStatusIdling, soloGame.AppID, soloGame.GameName, soloGame.CardsRemaining, Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(static game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t}\n\n\tprivate static async Task<string?> ResponseStatus(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<(string? Response, Bot Bot)> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStatus(access)))).ConfigureAwait(false);\n\n\t\tList<(string Response, Bot Bot)> validResults = new(results.Where(static result => !string.IsNullOrEmpty(result.Response))!);\n\n\t\tif (validResults.Count == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tHashSet<Bot> botsRunning = validResults.Where(static result => result.Bot.KeepRunning).Select(static result => result.Bot).ToHashSet();\n\n\t\tstring extraResponse = string.Format(CultureInfo.CurrentCulture, Strings.BotStatusOverview, botsRunning.Count, validResults.Count, botsRunning.Sum(static bot => bot.CardsFarmer.GamesToFarmReadOnly.Count), botsRunning.Sum(static bot => bot.CardsFarmer.GamesToFarmReadOnly.Sum(static game => game.CardsRemaining)));\n\n\t\treturn string.Join(Environment.NewLine, validResults.Select(static result => result.Response).Union(extraResponse.ToEnumerable()));\n\t}\n\n\tprivate string? ResponseStop(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Bot.Actions.Stop();\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseStop(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStop(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseTradingBlacklist(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.TradingBlacklistSteamIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.TradingBlacklistSteamIDs)) : string.Join(\", \", Bot.BotDatabase.TradingBlacklistSteamIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseTradingBlacklist(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseTradingBlacklist(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseTradingBlacklistAdd(EAccess access, string targetSteamIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<ulong> targetIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t}\n\n\t\t\ttargetIDs.Add(targetID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.TradingBlacklistSteamIDs.AddRange(targetIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseTradingBlacklistAdd(EAccess access, string botNames, string targetSteamIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseTradingBlacklistAdd(access, targetSteamIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseTradingBlacklistRemove(EAccess access, string targetSteamIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<ulong> targetIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t}\n\n\t\t\ttargetIDs.Add(targetID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.TradingBlacklistSteamIDs.RemoveRange(targetIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseTradingBlacklistRemove(EAccess access, string botNames, string targetSteamIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseTradingBlacklistRemove(access, targetSteamIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseTransfer(EAccess access, string botNameTo) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t}\n\n\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseTransfer(EAccess access, string botNames, string botNameTo) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransfer(access, botNameTo))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseTransferByRealAppIDs(EAccess access, IReadOnlyCollection<uint> realAppIDs, Bot targetBot, bool exclude = false) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif ((realAppIDs == null) || (realAppIDs.Count == 0)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDs));\n\t\t}\n\n\t\tArgumentNullException.ThrowIfNull(targetBot);\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t}\n\n\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t}\n\n\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponseTransferByRealAppIDs(EAccess access, string realAppIDsText, string botNameTo, bool exclude = false) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (appIDTexts.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t}\n\n\t\tHashSet<uint> realAppIDs = new();\n\n\t\tforeach (string appIDText in appIDTexts) {\n\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\trealAppIDs.Add(appID);\n\t\t}\n\n\t\treturn await ResponseTransferByRealAppIDs(access, realAppIDs, targetBot, exclude).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponseTransferByRealAppIDs(EAccess access, string botNames, string realAppIDsText, string botNameTo, bool exclude = false) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (appIDTexts.Length == 0) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t}\n\n\t\tHashSet<uint> realAppIDs = new();\n\n\t\tforeach (string appIDText in appIDTexts) {\n\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\trealAppIDs.Add(appID);\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransferByRealAppIDs(access, realAppIDs, targetBot, exclude))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseUnknown(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access >= EAccess.Operator ? FormatBotResponse(Strings.UnknownCommand) : null;\n\t}\n\n\tprivate async Task<string?> ResponseUnpackBoosters(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\t// It'd make sense here to actually check return code of ArchiWebHandler.UnpackBooster(), but it lies most of the time | https://github.com/JustArchi/ArchiSteamFarm/issues/704\n\t\tbool completeSuccess = true;\n\n\t\t// It'd also make sense to run all of this in parallel, but it seems that Steam has a lot of problems with inventory-related parallel requests | https://steamcommunity.com/groups/archiasf/discussions/1/3559414588264550284/\n\t\ttry {\n\t\t\tawait foreach (Asset item in Bot.ArchiWebHandler.GetInventoryAsync().Where(static item => item.Type == Asset.EType.BoosterPack).ConfigureAwait(false)) {\n\t\t\t\tif (!await Bot.ArchiWebHandler.UnpackBooster(item.RealAppID, item.AssetID).ConfigureAwait(false)) {\n\t\t\t\t\tcompleteSuccess = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HttpRequestException e) {\n\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\n\t\t\tcompleteSuccess = false;\n\t\t} catch (Exception e) {\n\t\t\tBot.ArchiLogger.LogGenericException(e);\n\n\t\t\tcompleteSuccess = false;\n\t\t}\n\n\t\treturn FormatBotResponse(completeSuccess ? Strings.Success : Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseUnpackBoosters(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseUnpackBoosters(access))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static async Task<string?> ResponseUpdate(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string? message, Version? version) = await Actions.Update().ConfigureAwait(false);\n\n\t\treturn FormatStaticResponse($\"{(success ? Strings.Success : Strings.WarningFailed)}{(!string.IsNullOrEmpty(message) ? $\" {message}\" : version != null ? $\" {version}\" : \"\")}\");\n\t}\n\n\tprivate string? ResponseVersion(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access >= EAccess.Operator ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotVersion, SharedInfo.ASF, SharedInfo.Version)) : null;\n\t}\n\n\tprivate string? ResponseWalletBalance(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn !Bot.IsConnectedAndLoggedOn ? FormatBotResponse(Strings.BotNotConnected) : FormatBotResponse(Bot.WalletCurrency != ECurrencyCode.Invalid ? string.Format(CultureInfo.CurrentCulture, Strings.BotWalletBalance, Bot.WalletBalance / 100.0, Bot.WalletCurrency.ToString()) : Strings.BotHasNoWallet);\n\t}\n\n\tprivate static async Task<string?> ResponseWalletBalance(EAccess access, string botNames) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseWalletBalance(access)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\t[Flags]\n\tprivate enum ERedeemFlags : ushort {\n\t\tNone = 0,\n\t\tValidate = 1,\n\t\tForceForwarding = 2,\n\t\tSkipForwarding = 4,\n\t\tForceDistributing = 8,\n\t\tSkipDistributing = 16,\n\t\tSkipInitial = 32,\n\t\tForceKeepMissingGames = 64,\n\t\tSkipKeepMissingGames = 128,\n\t\tForceAssumeWalletKeyOnBadActivationCode = 256,\n\t\tSkipAssumeWalletKeyOnBadActivationCode = 512\n\t}\n}\n"], "fixing_code": ["//     _                _      _  ____   _                           _____\n//    / \\    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___\n//   / _ \\  | '__|/ __|| '_ \\ | |\\___ \\ | __|/ _ \\ / _` || '_ ` _ \\ | |_  / _` || '__|| '_ ` _ \\\n//  / ___ \\ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |\n// /_/   \\_\\|_|   \\___||_| |_||_||____/  \\__|\\___| \\__,_||_| |_| |_||_|   \\__,_||_|   |_| |_| |_|\n// |\n// Copyright 2015-2022 \u0141ukasz \"JustArchi\" Domeradzki\n// Contact: JustArchi@JustArchi.net\n// |\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// |\n// http://www.apache.org/licenses/LICENSE-2.0\n// |\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing ArchiSteamFarm.Core;\nusing ArchiSteamFarm.Helpers;\nusing ArchiSteamFarm.Localization;\nusing ArchiSteamFarm.Plugins;\nusing ArchiSteamFarm.Steam.Cards;\nusing ArchiSteamFarm.Steam.Data;\nusing ArchiSteamFarm.Steam.Integration;\nusing ArchiSteamFarm.Steam.Storage;\nusing ArchiSteamFarm.Storage;\nusing JetBrains.Annotations;\nusing SteamKit2;\n\nnamespace ArchiSteamFarm.Steam.Interaction;\n\npublic sealed class Commands {\n\tprivate const ushort SteamTypingStatusDelay = 10 * 1000; // Steam client broadcasts typing status each 10 seconds\n\n\tprivate readonly Bot Bot;\n\tprivate readonly Dictionary<uint, string> CachedGamesOwned = new();\n\n\tinternal Commands(Bot bot) => Bot = bot ?? throw new ArgumentNullException(nameof(bot));\n\n\t[PublicAPI]\n\tpublic static string FormatBotResponse(string response, string botName) {\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botName)) {\n\t\t\tthrow new ArgumentNullException(nameof(botName));\n\t\t}\n\n\t\treturn $\"{Environment.NewLine}<{botName}> {response}\";\n\t}\n\n\t[PublicAPI]\n\tpublic string FormatBotResponse(string response) {\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t}\n\n\t\treturn $\"<{Bot.BotName}> {response}\";\n\t}\n\n\t[PublicAPI]\n\tpublic static string FormatStaticResponse(string response) {\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t}\n\n\t\treturn $\"<{SharedInfo.ASF}> {response}\";\n\t}\n\n\t[PublicAPI]\n\t[Obsolete($\"Use overload which accepts {nameof(EAccess)} instead, this one will be removed soon.\", true)]\n\tpublic async Task<string?> Response(ulong steamID, string message) {\n\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tEAccess access = Bot.GetAccess(steamID);\n\n\t\treturn await Response(access, message, steamID).ConfigureAwait(false);\n\t}\n\n\t[PublicAPI]\n\tpublic async Task<string?> Response(EAccess access, string message, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t}\n\n\t\tstring[] args = message.Split(Array.Empty<char>(), StringSplitOptions.RemoveEmptyEntries);\n\n\t\tswitch (args.Length) {\n\t\t\tcase 0:\n\t\t\t\tthrow new InvalidOperationException(nameof(args.Length));\n\t\t\tcase 1:\n\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\treturn await Response2FA(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, false).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, true).ConfigureAwait(false);\n\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\treturn ResponseWalletBalance(access);\n\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\treturn ResponseBackgroundGamesRedeemer(access);\n\t\t\t\t\tcase \"EXIT\":\n\t\t\t\t\t\treturn ResponseExit(access);\n\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\treturn await ResponseFarm(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"FB\":\n\t\t\t\t\t\treturn ResponseFarmingBlacklist(access);\n\t\t\t\t\tcase \"FQ\":\n\t\t\t\t\t\treturn ResponseFarmingQueue(access);\n\t\t\t\t\tcase \"HELP\":\n\t\t\t\t\t\treturn ResponseHelp(access);\n\t\t\t\t\tcase \"MAB\":\n\t\t\t\t\t\treturn ResponseMatchActivelyBlacklist(access);\n\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\treturn await ResponseLevel(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\treturn await ResponseLoot(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\treturn await ResponsePause(access, true).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\treturn await ResponsePause(access, false).ConfigureAwait(false);\n\t\t\t\t\tcase \"POINTS\":\n\t\t\t\t\t\treturn await ResponsePointsBalance(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\treturn await ResponseReset(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\treturn ResponseResume(access);\n\t\t\t\t\tcase \"RESTART\":\n\t\t\t\t\t\treturn ResponseRestart(access);\n\t\t\t\t\tcase \"SA\":\n\t\t\t\t\t\treturn await ResponseStatus(access, SharedInfo.ASF, steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\treturn ResponseStart(access);\n\t\t\t\t\tcase \"STATS\":\n\t\t\t\t\t\treturn ResponseStats(access);\n\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\treturn ResponseStatus(access).Response;\n\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\treturn ResponseStop(access);\n\t\t\t\t\tcase \"TB\":\n\t\t\t\t\t\treturn ResponseTradingBlacklist(access);\n\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\treturn await ResponseUnpackBoosters(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"UPDATE\":\n\t\t\t\t\t\treturn await ResponseUpdate(access).ConfigureAwait(false);\n\t\t\t\t\tcase \"VERSION\":\n\t\t\t\t\t\treturn ResponseVersion(access);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, access, message, args, steamID).ConfigureAwait(false);\n\n\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(access);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\treturn await Response2FA(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, Utilities.GetArgsAsText(args, 1, \",\"), false, steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\treturn await Response2FAConfirm(access, Utilities.GetArgsAsText(args, 1, \",\"), true, steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"ADDLICENSE\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseAddLicense(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"ADDLICENSE\":\n\t\t\t\t\t\treturn await ResponseAddLicense(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\treturn await ResponseWalletBalance(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\treturn await ResponseBackgroundGamesRedeemer(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"ENCRYPT\" when args.Length > 2:\n\t\t\t\t\t\treturn ResponseEncrypt(access, args[1], Utilities.GetArgsAsText(message, 2));\n\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\treturn await ResponseFarm(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"FB\":\n\t\t\t\t\t\treturn await ResponseFarmingBlacklist(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"FBADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingBlacklistAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"FBADD\":\n\t\t\t\t\t\treturn ResponseFarmingBlacklistAdd(access, args[1]);\n\t\t\t\t\tcase \"FBRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingBlacklistRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"FBRM\":\n\t\t\t\t\t\treturn ResponseFarmingBlacklistRemove(access, args[1]);\n\t\t\t\t\tcase \"FQ\":\n\t\t\t\t\t\treturn await ResponseFarmingQueue(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"FQADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingQueueAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"FQADD\":\n\t\t\t\t\t\treturn ResponseFarmingQueueAdd(access, args[1]);\n\t\t\t\t\tcase \"FQRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseFarmingQueueRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"FQRM\":\n\t\t\t\t\t\treturn ResponseFarmingQueueRemove(access, args[1]);\n\t\t\t\t\tcase \"HASH\" when args.Length > 2:\n\t\t\t\t\t\treturn ResponseHash(access, args[1], Utilities.GetArgsAsText(message, 2));\n\t\t\t\t\tcase \"INPUT\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseInput(access, args[1], args[2], Utilities.GetArgsAsText(message, 3), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"INPUT\" when args.Length > 2:\n\t\t\t\t\t\treturn ResponseInput(access, args[1], args[2]);\n\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\treturn await ResponseLevel(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\treturn await ResponseLoot(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT^\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseAdvancedLoot(access, args[1], args[2], Utilities.GetArgsAsText(message, 3), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT^\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseAdvancedLoot(access, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT@\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), false, steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT@\":\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1], false).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT%\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), true, steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"LOOT%\":\n\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(access, args[1], true).ConfigureAwait(false);\n\t\t\t\t\tcase \"MAB\":\n\t\t\t\t\t\treturn await ResponseMatchActivelyBlacklist(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"MABADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseMatchActivelyBlacklistAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"MABADD\":\n\t\t\t\t\t\treturn ResponseMatchActivelyBlacklistAdd(access, args[1]);\n\t\t\t\t\tcase \"MABRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseMatchActivelyBlacklistRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"MABRM\":\n\t\t\t\t\t\treturn ResponseMatchActivelyBlacklistRemove(access, args[1]);\n\t\t\t\t\tcase \"NICKNAME\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseNickname(access, args[1], Utilities.GetArgsAsText(message, 2), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"NICKNAME\":\n\t\t\t\t\t\treturn ResponseNickname(access, args[1]);\n\t\t\t\t\tcase \"OA\":\n\t\t\t\t\t\treturn await ResponseOwns(access, SharedInfo.ASF, Utilities.GetArgsAsText(message, 1), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"OWNS\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseOwns(access, args[1], Utilities.GetArgsAsText(message, 2), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"OWNS\":\n\t\t\t\t\t\treturn (await ResponseOwns(access, args[1]).ConfigureAwait(false)).Response;\n\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\treturn await ResponsePause(access, Utilities.GetArgsAsText(args, 1, \",\"), true, steamID: steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\treturn await ResponsePause(access, Utilities.GetArgsAsText(args, 1, \",\"), false, steamID: steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE&\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponsePause(access, args[1], true, Utilities.GetArgsAsText(message, 2), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"PAUSE&\":\n\t\t\t\t\t\treturn await ResponsePause(access, true, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"PLAY\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponsePlay(access, args[1], Utilities.GetArgsAsText(message, 2), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"PLAY\":\n\t\t\t\t\t\treturn await ResponsePlay(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"POINTS\":\n\t\t\t\t\t\treturn await ResponsePointsBalance(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"PRIVACY\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponsePrivacy(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"PRIVACY\":\n\t\t\t\t\t\treturn await ResponsePrivacy(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"R\" when args.Length > 2:\n\t\t\t\t\tcase \"REDEEM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseRedeem(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID: steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"R\":\n\t\t\t\t\tcase \"REDEEM\":\n\t\t\t\t\t\treturn await ResponseRedeem(access, args[1], steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"R^\" when args.Length > 3:\n\t\t\t\t\tcase \"REDEEM^\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseAdvancedRedeem(access, args[1], args[2], Utilities.GetArgsAsText(args, 3, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"R^\" when args.Length > 2:\n\t\t\t\t\tcase \"REDEEM^\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseAdvancedRedeem(access, args[1], args[2], steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\treturn await ResponseReset(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\treturn await ResponseResume(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\treturn await ResponseStart(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\treturn await ResponseStatus(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\treturn await ResponseStop(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TB\":\n\t\t\t\t\t\treturn await ResponseTradingBlacklist(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TBADD\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTradingBlacklistAdd(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TBADD\":\n\t\t\t\t\t\treturn ResponseTradingBlacklistAdd(access, args[1]);\n\t\t\t\t\tcase \"TBRM\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTradingBlacklistRemove(access, args[1], Utilities.GetArgsAsText(args, 2, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TBRM\":\n\t\t\t\t\t\treturn ResponseTradingBlacklistRemove(access, args[1]);\n\t\t\t\t\tcase \"TRANSFER\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTransfer(access, args[1], Utilities.GetArgsAsText(message, 2), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER\":\n\t\t\t\t\t\treturn await ResponseTransfer(access, args[1]).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 4:\n\t\t\t\t\t\treturn await ResponseAdvancedTransfer(access, args[1], args[2], args[3], Utilities.GetArgsAsText(message, 4), steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseAdvancedTransfer(access, args[1], args[2], args[3]).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2], Utilities.GetArgsAsText(message, 3), false, steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2], false).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 3:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2], Utilities.GetArgsAsText(message, 3), true, steamID).ConfigureAwait(false);\n\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 2:\n\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(access, args[1], args[2], true).ConfigureAwait(false);\n\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\treturn await ResponseUnpackBoosters(access, Utilities.GetArgsAsText(args, 1, \",\"), steamID).ConfigureAwait(false);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, access, message, args, steamID).ConfigureAwait(false);\n\n\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(access);\n\t\t\t\t}\n\t\t}\n\t}\n\n\tinternal async Task HandleMessage(ulong steamID, string message) {\n\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t}\n\n\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.Ordinal)) {\n\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\tif (!await Bot.SendMessage(steamID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, pluginsResponse));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (message.Length == commandPrefix!.Length) {\n\t\t\t\t// If the message starts with command prefix and is of the same length as command prefix, then it's just empty command trigger, useless\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage = message[commandPrefix.Length..];\n\t\t}\n\n\t\tEAccess access = Bot.GetAccess(steamID);\n\n\t\tTask<string?> responseTask = Response(access, message, steamID);\n\n\t\tbool feedback = access >= EAccess.FamilySharing;\n\n\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t}\n\n\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tif (!feedback) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse = FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t}\n\n\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\tif (!await Bot.SendMessage(steamID, response!).ConfigureAwait(false)) {\n\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, response));\n\t\t}\n\t}\n\n\tinternal async Task HandleMessage(ulong chatGroupID, ulong chatID, ulong steamID, string message) {\n\t\tif (chatGroupID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(chatGroupID));\n\t\t}\n\n\t\tif (chatID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(chatID));\n\t\t}\n\n\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t}\n\n\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.Ordinal)) {\n\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, pluginsResponse));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\tif (message.Length == commandPrefix!.Length) {\n\t\t\t\t// If the message starts with command prefix and is of the same length as command prefix, then it's just empty command trigger, useless\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage = message[commandPrefix.Length..];\n\t\t}\n\n\t\tEAccess access = Bot.GetAccess(steamID);\n\n\t\tTask<string?> responseTask = Response(access, message, steamID);\n\n\t\tbool feedback = access >= EAccess.FamilySharing;\n\n\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\tstring pleaseWaitMessage = FormatBotResponse(Strings.PleaseWait);\n\n\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t}\n\n\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\tif (!feedback) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse = FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t}\n\n\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\tif (!await Bot.SendMessage(chatGroupID, chatID, response!).ConfigureAwait(false)) {\n\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(CultureInfo.CurrentCulture, Strings.Content, response));\n\t\t}\n\t}\n\n\tinternal void OnNewLicenseList() {\n\t\tlock (CachedGamesOwned) {\n\t\t\tCachedGamesOwned.Clear();\n\t\t\tCachedGamesOwned.TrimExcess();\n\t\t}\n\t}\n\n\tprivate async Task<Dictionary<uint, string>?> FetchGamesOwned(bool cachedOnly = false) {\n\t\tlock (CachedGamesOwned) {\n\t\t\tif (CachedGamesOwned.Count > 0) {\n\t\t\t\treturn new Dictionary<uint, string>(CachedGamesOwned);\n\t\t\t}\n\t\t}\n\n\t\tif (cachedOnly) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDictionary<uint, string>? gamesOwned = await Bot.ArchiHandler.GetOwnedGames(Bot.SteamID).ConfigureAwait(false);\n\n\t\tif (gamesOwned?.Count > 0) {\n\t\t\tlock (CachedGamesOwned) {\n\t\t\t\tif (CachedGamesOwned.Count == 0) {\n\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned) {\n\t\t\t\t\t\tCachedGamesOwned[appID] = gameName;\n\t\t\t\t\t}\n\n\t\t\t\t\tCachedGamesOwned.TrimExcess();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn gamesOwned;\n\t}\n\n\tprivate static EAccess ProxyAccess(Bot bot, EAccess access, ulong steamID = 0) {\n\t\t// The objective here should be simple, calculating effective access of the user\n\t\t// Problem is, history already proved nothing in this damn file is as simple as it seems\n\t\t// We use this function for proxying commands such as !status 2 sent to bot 1, which should use 2's user access instead\n\t\tArgumentNullException.ThrowIfNull(bot);\n\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif ((steamID != 0) && !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\t// If we got executed with owner access or lack steamID entirely, then this is effective access\n\t\tif ((access >= EAccess.Owner) || (steamID == 0)) {\n\t\t\treturn access;\n\t\t}\n\n\t\t// Otherwise, effective access is the access of the user on target bot, whatever that would be, not this one\n\t\treturn bot.GetAccess(steamID);\n\t}\n\n\tprivate async Task<string?> Response2FA(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string? token, string message) = await Bot.Actions.GenerateTwoFactorAuthenticationToken().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success && !string.IsNullOrEmpty(token) ? string.Format(CultureInfo.CurrentCulture, Strings.BotAuthenticatorToken, token) : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> Response2FA(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FA(ProxyAccess(bot, access, steamID)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> Response2FAConfirm(EAccess access, bool confirm) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (!Bot.HasMobileAuthenticator) {\n\t\t\treturn FormatBotResponse(Strings.BotNoASFAuthenticator);\n\t\t}\n\n\t\t(bool success, _, string message) = await Bot.Actions.HandleTwoFactorAuthenticationConfirmations(confirm).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> Response2FAConfirm(EAccess access, string botNames, bool confirm, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FAConfirm(ProxyAccess(bot, access, steamID), confirm))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAddLicense(EAccess access, string query) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tStringBuilder response = new();\n\n\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tforeach (string entry in entries) {\n\t\t\tuint gameID;\n\t\t\tstring type;\n\n\t\t\tint index = entry.IndexOf('/', StringComparison.Ordinal);\n\n\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\tif (!uint.TryParse(entry[(index + 1)..], out gameID) || (gameID == 0)) {\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttype = entry[..index];\n\t\t\t} else if (uint.TryParse(entry, out gameID) && (gameID > 0)) {\n\t\t\t\ttype = \"SUB\";\n\t\t\t} else {\n\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\tcase \"A\":\n\t\t\t\tcase \"APP\":\n\t\t\t\t\tSteamApps.FreeLicenseCallback callback;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcallback = await Bot.SteamApps.RequestFreeLicense(gameID).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicense, $\"app/{gameID}\", EResult.Timeout)));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse((callback.GrantedApps.Count > 0) || (callback.GrantedPackages.Count > 0) ? string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicenseWithItems, $\"app/{gameID}\", callback.Result, string.Join(\", \", callback.GrantedApps.Select(static appID => $\"app/{appID}\").Union(callback.GrantedPackages.Select(static subID => $\"sub/{subID}\")))) : string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicense, $\"app/{gameID}\", callback.Result)));\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t(EResult result, EPurchaseResultDetail purchaseResult) = await Bot.ArchiWebHandler.AddFreeLicense(gameID).ConfigureAwait(false);\n\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotAddLicense, $\"sub/{gameID}\", $\"{result}/{purchaseResult}\")));\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn response.Length > 0 ? response.ToString() : null;\n\t}\n\n\tprivate static async Task<string?> ResponseAddLicense(EAccess access, string botNames, string query, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAddLicense(ProxyAccess(bot, access, steamID), query))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedLoot(EAccess access, string targetAppID, string targetContextID) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetContextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetContextID));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t}\n\n\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseAdvancedLoot(EAccess access, string botNames, string appID, string contextID, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(appID)) {\n\t\t\tthrow new ArgumentNullException(nameof(appID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(contextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(contextID));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedLoot(ProxyAccess(bot, access, steamID), appID, contextID))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedRedeem(EAccess access, string options, string keys, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(options)) {\n\t\t\tthrow new ArgumentNullException(nameof(options));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keys)) {\n\t\t\tthrow new ArgumentNullException(nameof(keys));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] flags = options.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (flags.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(flags)));\n\t\t}\n\n\t\tERedeemFlags redeemFlags = ERedeemFlags.None;\n\n\t\tforeach (string flag in flags) {\n\t\t\tswitch (flag.ToUpperInvariant()) {\n\t\t\t\tcase \"FAWK\":\n\t\t\t\tcase \"FORCEASSUMEWALLETKEY\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FD\":\n\t\t\t\tcase \"FORCEDISTRIBUTING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceDistributing;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FF\":\n\t\t\t\tcase \"FORCEFORWARDING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceForwarding;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FKMG\":\n\t\t\t\tcase \"FORCEKEEPMISSINGGAMES\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceKeepMissingGames;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SAWK\":\n\t\t\t\tcase \"SKIPASSUMEWALLETKEY\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SD\":\n\t\t\t\tcase \"SKIPDISTRIBUTING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipDistributing;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SF\":\n\t\t\t\tcase \"SKIPFORWARDING\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipForwarding;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SI\":\n\t\t\t\tcase \"SKIPINITIAL\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipInitial;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SKMG\":\n\t\t\t\tcase \"SKIPKEEPMISSINGGAMES\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipKeepMissingGames;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"V\":\n\t\t\t\tcase \"VALIDATE\":\n\t\t\t\t\tredeemFlags |= ERedeemFlags.Validate;\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, flag));\n\t\t\t}\n\t\t}\n\n\t\treturn await ResponseRedeem(access, keys, steamID, redeemFlags).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponseAdvancedRedeem(EAccess access, string botNames, string options, string keys, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(options)) {\n\t\t\tthrow new ArgumentNullException(nameof(options));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keys)) {\n\t\t\tthrow new ArgumentNullException(nameof(keys));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedRedeem(ProxyAccess(bot, access, steamID), options, keys, steamID))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedTransfer(EAccess access, uint appID, ulong contextID, Bot targetBot) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (appID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(appID));\n\t\t}\n\n\t\tif (contextID == 0) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(contextID));\n\t\t}\n\n\t\tArgumentNullException.ThrowIfNull(targetBot);\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID, targetBot.SteamID).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponseAdvancedTransfer(EAccess access, string targetAppID, string targetContextID, string botNameTo) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetContextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetContextID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t}\n\n\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t}\n\n\t\treturn await ResponseAdvancedTransfer(access, appID, contextID, targetBot).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponseAdvancedTransfer(EAccess access, string botNames, string targetAppID, string targetContextID, string botNameTo, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetContextID)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetContextID));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t}\n\n\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedTransfer(ProxyAccess(bot, access, steamID), appID, contextID, targetBot))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseBackgroundGamesRedeemer(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tuint count = Bot.GamesToRedeemInBackgroundCount;\n\n\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotGamesToRedeemInBackgroundCount, count));\n\t}\n\n\tprivate static async Task<string?> ResponseBackgroundGamesRedeemer(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBackgroundGamesRedeemer(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static string? ResponseEncrypt(EAccess access, string cryptoMethodText, string stringToEncrypt) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(cryptoMethodText)) {\n\t\t\tthrow new ArgumentNullException(nameof(cryptoMethodText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(stringToEncrypt)) {\n\t\t\tthrow new ArgumentNullException(nameof(stringToEncrypt));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Enum.TryParse(cryptoMethodText, true, out ArchiCryptoHelper.ECryptoMethod cryptoMethod)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(cryptoMethod)));\n\t\t}\n\n\t\tstring? encryptedString = Actions.Encrypt(cryptoMethod, stringToEncrypt);\n\n\t\treturn FormatStaticResponse(!string.IsNullOrEmpty(encryptedString) ? string.Format(CultureInfo.CurrentCulture, Strings.Result, encryptedString) : Strings.WarningFailed);\n\t}\n\n\tprivate static string? ResponseExit(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Actions.Exit();\n\n\t\treturn FormatStaticResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponseFarm(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.NowFarming) {\n\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t}\n\n\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarm(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseFarm(ProxyAccess(bot, access, steamID)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingBlacklist(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.FarmingBlacklistAppIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.FarmingBlacklistAppIDs)) : string.Join(\", \", Bot.BotDatabase.FarmingBlacklistAppIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingBlacklist(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingBlacklist(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingBlacklistAdd(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingBlacklistAppIDs.AddRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.NowFarming && Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID))) {\n\t\t\tUtilities.InBackground(\n\t\t\t\tasync () => {\n\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingBlacklistAdd(EAccess access, string botNames, string targetAppIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingBlacklistAdd(ProxyAccess(bot, access, steamID), targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingBlacklistRemove(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingBlacklistAppIDs.RemoveRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tif (!Bot.CardsFarmer.NowFarming) {\n\t\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingBlacklistRemove(EAccess access, string botNames, string targetAppIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingBlacklistRemove(ProxyAccess(bot, access, steamID), targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingQueue(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.FarmingPriorityQueueAppIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.FarmingPriorityQueueAppIDs)) : string.Join(\", \", Bot.BotDatabase.FarmingPriorityQueueAppIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingQueue(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingQueue(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingQueueAdd(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingPriorityQueueAppIDs.AddRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tswitch (Bot.CardsFarmer.NowFarming) {\n\t\t\tcase false when Bot.BotConfig.FarmPriorityQueueOnly:\n\t\t\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\n\t\t\t\tbreak;\n\t\t\tcase true when Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID)):\n\t\t\t\tUtilities.InBackground(\n\t\t\t\t\tasync () => {\n\t\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingQueueAdd(EAccess access, string botNames, string targetAppIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingQueueAdd(ProxyAccess(bot, access, steamID), targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseFarmingQueueRemove(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\tif (!Bot.BotDatabase.FarmingPriorityQueueAppIDs.RemoveRange(appIDs)) {\n\t\t\treturn FormatBotResponse(Strings.NothingFound);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.NowFarming && Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID))) {\n\t\t\tUtilities.InBackground(\n\t\t\t\tasync () => {\n\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseFarmingQueueRemove(EAccess access, string botNames, string targetAppIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseFarmingQueueRemove(ProxyAccess(bot, access, steamID), targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static string? ResponseHash(EAccess access, string hashingMethodText, string stringToHash) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(hashingMethodText)) {\n\t\t\tthrow new ArgumentNullException(nameof(hashingMethodText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(stringToHash)) {\n\t\t\tthrow new ArgumentNullException(nameof(stringToHash));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Enum.TryParse(hashingMethodText, true, out ArchiCryptoHelper.EHashingMethod hashingMethod)) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(hashingMethod)));\n\t\t}\n\n\t\tstring hash = Actions.Hash(hashingMethod, stringToHash);\n\n\t\treturn FormatStaticResponse(!string.IsNullOrEmpty(hash) ? string.Format(CultureInfo.CurrentCulture, Strings.Result, hash) : Strings.WarningFailed);\n\t}\n\n\tprivate string? ResponseHelp(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access >= EAccess.FamilySharing ? FormatBotResponse($\"{SharedInfo.ProjectURL}/wiki/Commands\") : null;\n\t}\n\n\tprivate string? ResponseInput(EAccess access, string propertyName, string inputValue) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(propertyName)) {\n\t\t\tthrow new ArgumentNullException(nameof(propertyName));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(inputValue)) {\n\t\t\tthrow new ArgumentNullException(nameof(inputValue));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tbool headless = Program.Service || (ASF.GlobalConfig?.Headless ?? GlobalConfig.DefaultHeadless);\n\n\t\tif (!headless) {\n\t\t\treturn FormatBotResponse(Strings.ErrorFunctionOnlyInHeadlessMode);\n\t\t}\n\n\t\tif (!Enum.TryParse(propertyName, true, out ASF.EUserInputType inputType) || (inputType == ASF.EUserInputType.None) || !Enum.IsDefined(inputType)) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(inputType)));\n\t\t}\n\n\t\tbool result = Bot.SetUserInput(inputType, inputValue);\n\n\t\treturn FormatBotResponse(result ? Strings.Done : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponseInput(EAccess access, string botNames, string propertyName, string inputValue, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(propertyName)) {\n\t\t\tthrow new ArgumentNullException(nameof(propertyName));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(inputValue)) {\n\t\t\tthrow new ArgumentNullException(nameof(inputValue));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseInput(ProxyAccess(bot, access, steamID), propertyName, inputValue)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseLevel(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tuint? level = await Bot.ArchiHandler.GetLevel().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(level.HasValue ? string.Format(CultureInfo.CurrentCulture, Strings.BotLevel, level.Value) : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponseLevel(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLevel(ProxyAccess(bot, access, steamID)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseLoot(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseLoot(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLoot(ProxyAccess(bot, access, steamID)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseLootByRealAppIDs(EAccess access, string realAppIDsText, bool exclude) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t}\n\n\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (appIDTexts.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t}\n\n\t\tHashSet<uint> realAppIDs = new();\n\n\t\tforeach (string appIDText in appIDTexts) {\n\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\trealAppIDs.Add(appID);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseLootByRealAppIDs(EAccess access, string botNames, string realAppIDsText, bool exclude, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLootByRealAppIDs(ProxyAccess(bot, access, steamID), realAppIDsText, exclude))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseMatchActivelyBlacklist(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.MatchActivelyBlacklistAppIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.MatchActivelyBlacklistAppIDs)) : string.Join(\", \", Bot.BotDatabase.MatchActivelyBlacklistAppIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseMatchActivelyBlacklist(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseMatchActivelyBlacklist(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseMatchActivelyBlacklistAdd(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.MatchActivelyBlacklistAppIDs.AddRange(appIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseMatchActivelyBlacklistAdd(EAccess access, string botNames, string targetAppIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseMatchActivelyBlacklistAdd(ProxyAccess(bot, access, steamID), targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseMatchActivelyBlacklistRemove(EAccess access, string targetAppIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<uint> appIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t}\n\n\t\t\tappIDs.Add(appID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.MatchActivelyBlacklistAppIDs.RemoveRange(appIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseMatchActivelyBlacklistRemove(EAccess access, string botNames, string targetAppIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetAppIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseMatchActivelyBlacklistRemove(ProxyAccess(bot, access, steamID), targetAppIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseNickname(EAccess access, string nickname) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(nickname)) {\n\t\t\tthrow new ArgumentNullException(nameof(nickname));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tBot.SteamFriends.SetPersonaName(nickname);\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseNickname(EAccess access, string botNames, string nickname, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(nickname)) {\n\t\t\tthrow new ArgumentNullException(nameof(nickname));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseNickname(ProxyAccess(bot, access, steamID), nickname)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<(string? Response, Dictionary<string, string>? OwnedGames)> ResponseOwns(EAccess access, string query) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn (null, null);\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn (FormatBotResponse(Strings.BotNotConnected), null);\n\t\t}\n\n\t\tDictionary<uint, string>? gamesOwned = await FetchGamesOwned(true).ConfigureAwait(false);\n\n\t\tStringBuilder response = new();\n\t\tDictionary<string, string> result = new(StringComparer.Ordinal);\n\n\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tforeach (string entry in entries) {\n\t\t\tstring game;\n\t\t\tstring type;\n\n\t\t\tint index = entry.IndexOf('/', StringComparison.Ordinal);\n\n\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\tgame = entry[(index + 1)..];\n\t\t\t\ttype = entry[..index];\n\t\t\t} else if (uint.TryParse(entry, out uint appID) && (appID > 0)) {\n\t\t\t\tgame = entry;\n\t\t\t\ttype = \"APP\";\n\t\t\t} else {\n\t\t\t\tgame = entry;\n\t\t\t\ttype = \"NAME\";\n\t\t\t}\n\n\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\tcase \"A\" when uint.TryParse(game, out uint appID) && (appID > 0):\n\t\t\t\tcase \"APP\" when uint.TryParse(game, out appID) && (appID > 0):\n\t\t\t\t\tHashSet<uint>? packageIDs = ASF.GlobalDatabase?.GetPackageIDs(appID, Bot.OwnedPackageIDs.Keys);\n\n\t\t\t\t\tif (packageIDs?.Count > 0) {\n\t\t\t\t\t\tif ((gamesOwned != null) && gamesOwned.TryGetValue(appID, out string? cachedGameName)) {\n\t\t\t\t\t\t\tresult[$\"app/{appID}\"] = cachedGameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", cachedGameName)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[$\"app/{appID}\"] = appID.ToString(CultureInfo.InvariantCulture);\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlready, $\"app/{appID}\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (gamesOwned.TryGetValue(appID, out string? gameName)) {\n\t\t\t\t\t\t\tresult[$\"app/{appID}\"] = gameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", gameName)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, $\"app/{appID}\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"R\":\n\t\t\t\tcase \"REGEX\":\n\t\t\t\t\tRegex regex;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tregex = new Regex(game);\n\t\t\t\t\t} catch (ArgumentException e) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(regex))));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool foundWithRegex = false;\n\n\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => regex.IsMatch(gameOwned.Value))) {\n\t\t\t\t\t\tfoundWithRegex = true;\n\n\t\t\t\t\t\tresult[$\"app/{appID}\"] = gameName;\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", gameName)));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!foundWithRegex) {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\tcase \"S\" when uint.TryParse(game, out uint packageID) && (packageID > 0):\n\t\t\t\tcase \"SUB\" when uint.TryParse(game, out packageID) && (packageID > 0):\n\t\t\t\t\tif (Bot.OwnedPackageIDs.ContainsKey(packageID)) {\n\t\t\t\t\t\tresult[$\"sub/{packageID}\"] = packageID.ToString(CultureInfo.InvariantCulture);\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlready, $\"sub/{packageID}\")));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, $\"sub/{packageID}\")));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool foundWithName = false;\n\n\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => gameOwned.Value.Contains(game, StringComparison.OrdinalIgnoreCase))) {\n\t\t\t\t\t\tfoundWithName = true;\n\n\t\t\t\t\t\tresult[$\"app/{appID}\"] = gameName;\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnedAlreadyWithName, $\"app/{appID}\", gameName)));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!foundWithName) {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (response.Length > 0 ? response.ToString() : FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotOwnedYet, query)), result);\n\t}\n\n\tprivate static async Task<string?> ResponseOwns(EAccess access, string botNames, string query, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(query)) {\n\t\t\tthrow new ArgumentNullException(nameof(query));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<(string? Response, Dictionary<string, string>? OwnedGames)> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseOwns(ProxyAccess(bot, access, steamID), query))).ConfigureAwait(false);\n\n\t\tList<(string Response, Dictionary<string, string> OwnedGames)> validResults = new(results.Where(static result => !string.IsNullOrEmpty(result.Response) && (result.OwnedGames != null))!);\n\n\t\tif (validResults.Count == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDictionary<string, (ushort Count, string GameName)> ownedGamesStats = new(StringComparer.Ordinal);\n\n\t\tforeach ((string gameID, string gameName) in validResults.Where(static validResult => validResult.OwnedGames.Count > 0).SelectMany(static validResult => validResult.OwnedGames)) {\n\t\t\tif (ownedGamesStats.TryGetValue(gameID, out (ushort Count, string GameName) ownedGameStats)) {\n\t\t\t\townedGameStats.Count++;\n\t\t\t} else {\n\t\t\t\townedGameStats.Count = 1;\n\t\t\t}\n\n\t\t\tif (!string.IsNullOrEmpty(gameName)) {\n\t\t\t\townedGameStats.GameName = gameName;\n\t\t\t}\n\n\t\t\townedGamesStats[gameID] = ownedGameStats;\n\t\t}\n\n\t\tIEnumerable<string> extraResponses = ownedGamesStats.Select(kv => FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotOwnsOverviewPerGame, kv.Value.Count, validResults.Count, $\"{kv.Key}{(!string.IsNullOrEmpty(kv.Value.GameName) ? $\" | {kv.Value.GameName}\" : \"\")}\")));\n\n\t\treturn string.Join(Environment.NewLine, validResults.Select(static result => result.Response).Concat(extraResponses));\n\t}\n\n\tprivate async Task<string?> ResponsePause(EAccess access, bool permanent, string? resumeInSecondsText = null) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.FamilySharing) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (permanent && (access < EAccess.Operator)) {\n\t\t\treturn FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t}\n\n\t\tushort resumeInSeconds = 0;\n\n\t\tif (!string.IsNullOrEmpty(resumeInSecondsText) && (!ushort.TryParse(resumeInSecondsText, out resumeInSeconds) || (resumeInSeconds == 0))) {\n\t\t\treturn string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(resumeInSecondsText));\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.Pause(permanent, resumeInSeconds).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponsePause(EAccess access, string botNames, bool permanent, string? resumeInSecondsText = null, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePause(ProxyAccess(bot, access, steamID), permanent, resumeInSecondsText))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponsePlay(EAccess access, IReadOnlyCollection<uint> gameIDs, string? gameName = null) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tArgumentNullException.ThrowIfNull(gameIDs);\n\n\t\tif (gameIDs.Count > ArchiHandler.MaxGamesPlayedConcurrently) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(gameIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.Play(gameIDs, gameName).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponsePlay(EAccess access, string targetGameIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetGameIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tstring[] games = targetGameIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (games.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(games)));\n\t\t}\n\n\t\tHashSet<uint> gamesToPlay = new();\n\t\tStringBuilder gameName = new();\n\n\t\tforeach (string game in games) {\n\t\t\tif (!uint.TryParse(game, out uint gameID) || (gameID == 0)) {\n\t\t\t\tif (gameName.Length > 0) {\n\t\t\t\t\tgameName.Append(' ');\n\t\t\t\t}\n\n\t\t\t\tgameName.Append(game);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (gamesToPlay.Count >= ArchiHandler.MaxGamesPlayedConcurrently) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, $\"{nameof(gamesToPlay)} > {ArchiHandler.MaxGamesPlayedConcurrently}\"));\n\t\t\t}\n\n\t\t\tgamesToPlay.Add(gameID);\n\t\t}\n\n\t\treturn await ResponsePlay(access, gamesToPlay, gameName.Length > 0 ? gameName.ToString() : null).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponsePlay(EAccess access, string botNames, string targetGameIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetGameIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePlay(ProxyAccess(bot, access, steamID), targetGameIDs))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponsePointsBalance(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tuint? points = await Bot.ArchiWebHandler.GetPointsBalance().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(points.HasValue ? string.Format(CultureInfo.CurrentCulture, Strings.BotPointsBalance, points) : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponsePointsBalance(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePointsBalance(ProxyAccess(bot, access, steamID)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponsePrivacy(EAccess access, string privacySettingsText) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(privacySettingsText));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\t// There are only 7 privacy settings\n\t\tconst byte privacySettings = 7;\n\n\t\tstring[] privacySettingsArgs = privacySettingsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tswitch (privacySettingsArgs.Length) {\n\t\t\tcase 0:\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(privacySettingsArgs)));\n\t\t\tcase > privacySettings:\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t}\n\n\t\tArchiHandler.EPrivacySetting profile = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting ownedGames = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting playtime = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting friendsList = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting inventory = ArchiHandler.EPrivacySetting.Private;\n\t\tArchiHandler.EPrivacySetting inventoryGifts = ArchiHandler.EPrivacySetting.Private;\n\t\tUserPrivacy.ECommentPermission comments = UserPrivacy.ECommentPermission.Private;\n\n\t\t// Converting digits to enum\n\t\tfor (byte index = 0; index < privacySettingsArgs.Length; index++) {\n\t\t\tif (!Enum.TryParse(privacySettingsArgs[index], true, out ArchiHandler.EPrivacySetting privacySetting) || (privacySetting == ArchiHandler.EPrivacySetting.Unknown) || !Enum.IsDefined(privacySetting)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t\t}\n\n\t\t\t// Child setting can't be less restrictive than its parent\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\t// Profile\n\t\t\t\t\tprofile = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// OwnedGames, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t}\n\n\t\t\t\t\townedGames = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Playtime, child of OwnedGames\n\t\t\t\t\tif (ownedGames < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(playtime)));\n\t\t\t\t\t}\n\n\t\t\t\t\tplaytime = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// FriendsList, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t}\n\n\t\t\t\t\tfriendsList = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t// Inventory, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(inventory)));\n\t\t\t\t\t}\n\n\t\t\t\t\tinventory = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\t// InventoryGifts, child of Inventory\n\t\t\t\t\tif (inventory < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(inventoryGifts)));\n\t\t\t\t\t}\n\n\t\t\t\t\tinventoryGifts = privacySetting;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\t// Comments, child of Profile\n\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(comments)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Comments use different numbers than everything else, but we want to have this command consistent for end-user, so we'll map them\n\t\t\t\t\tswitch (privacySetting) {\n\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.FriendsOnly:\n\t\t\t\t\t\t\tcomments = UserPrivacy.ECommentPermission.FriendsOnly;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Private:\n\t\t\t\t\t\t\tcomments = UserPrivacy.ECommentPermission.Private;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Public:\n\t\t\t\t\t\t\tcomments = UserPrivacy.ECommentPermission.Public;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.WarningUnknownValuePleaseReport, nameof(privacySetting), privacySetting));\n\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(privacySetting)));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.WarningUnknownValuePleaseReport, nameof(index), index));\n\n\t\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(index)));\n\t\t\t}\n\t\t}\n\n\t\tUserPrivacy userPrivacy = new(new UserPrivacy.PrivacySettings(profile, ownedGames, playtime, friendsList, inventory, inventoryGifts), comments);\n\n\t\treturn FormatBotResponse(await Bot.ArchiWebHandler.ChangePrivacySettings(userPrivacy).ConfigureAwait(false) ? Strings.Success : Strings.WarningFailed);\n\t}\n\n\tprivate static async Task<string?> ResponsePrivacy(EAccess access, string botNames, string privacySettingsText, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(privacySettingsText));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePrivacy(ProxyAccess(bot, access, steamID), privacySettingsText))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseRedeem(EAccess access, string keysText, ulong steamID = 0, ERedeemFlags redeemFlags = ERedeemFlags.None) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keysText)) {\n\t\t\tthrow new ArgumentNullException(nameof(keysText));\n\t\t}\n\n\t\tif ((steamID != 0) && !new SteamID(steamID).IsIndividualAccount) {\n\t\t\tthrow new ArgumentOutOfRangeException(nameof(steamID));\n\t\t}\n\n\t\tif (Bot.Bots == null) {\n\t\t\tthrow new InvalidOperationException(nameof(Bot.Bots));\n\t\t}\n\n\t\tif (access < EAccess.Operator) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tstring[] keys = keysText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (keys.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(keys)));\n\t\t}\n\n\t\tbool forward = !redeemFlags.HasFlag(ERedeemFlags.SkipForwarding) && (redeemFlags.HasFlag(ERedeemFlags.ForceForwarding) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Forwarding));\n\t\tbool distribute = !redeemFlags.HasFlag(ERedeemFlags.SkipDistributing) && (redeemFlags.HasFlag(ERedeemFlags.ForceDistributing) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Distributing));\n\t\tbool keepMissingGames = !redeemFlags.HasFlag(ERedeemFlags.SkipKeepMissingGames) && (redeemFlags.HasFlag(ERedeemFlags.ForceKeepMissingGames) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.KeepMissingGames));\n\t\tbool assumeWalletKeyOnBadActivationCode = !redeemFlags.HasFlag(ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode) && (redeemFlags.HasFlag(ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.AssumeWalletKeyOnBadActivationCode));\n\n\t\tHashSet<string> pendingKeys = keys.ToHashSet(StringComparer.Ordinal);\n\t\tHashSet<string> unusedKeys = pendingKeys.ToHashSet(StringComparer.Ordinal);\n\n\t\tHashSet<Bot> rateLimitedBots = new();\n\t\tHashSet<Bot> triedBots = new();\n\n\t\tStringBuilder response = new();\n\n\t\tusing (HashSet<string>.Enumerator keysEnumerator = pendingKeys.GetEnumerator()) {\n\t\t\t// Initial key\n\t\t\tstring? key = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\tstring? previousKey = key;\n\n\t\t\twhile (!string.IsNullOrEmpty(key)) {\n\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\tstring startingKey = key!;\n\n\t\t\t\tusing (IEnumerator<Bot> botsEnumerator = Bot.Bots.Where(bot => (bot.Value != Bot) && bot.Value.IsConnectedAndLoggedOn && ((access >= EAccess.Owner) || ((steamID != 0) && (bot.Value.GetAccess(steamID) >= EAccess.Operator)))).OrderByDescending(bot => Bot.BotsComparer?.Compare(bot.Key, Bot.BotName) > 0).ThenBy(static bot => bot.Key, Bot.BotsComparer).Select(static bot => bot.Value).GetEnumerator()) {\n\t\t\t\t\tBot? currentBot = Bot;\n\n\t\t\t\t\twhile (!string.IsNullOrEmpty(key) && (currentBot != null)) {\n\t\t\t\t\t\tif (previousKey != key) {\n\t\t\t\t\t\t\ttriedBots.Clear();\n\t\t\t\t\t\t\tpreviousKey = key;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\tif (redeemFlags.HasFlag(ERedeemFlags.Validate) && !Utilities.IsValidCdKey(key!)) {\n\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((currentBot == Bot) && redeemFlags.HasFlag(ERedeemFlags.SkipInitial)) {\n\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbool skipRequest = triedBots.Contains(currentBot) || rateLimitedBots.Contains(currentBot);\n\n\t\t\t\t\t\t\tEResult result = EResult.Fail;\n\t\t\t\t\t\t\tEPurchaseResultDetail purchaseResultDetail = EPurchaseResultDetail.CancelledByUser;\n\t\t\t\t\t\t\tDictionary<uint, string>? items = null;\n\n\t\t\t\t\t\t\tif (!skipRequest) {\n\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\tSteamApps.PurchaseResponseCallback? redeemResult = await currentBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tresult = redeemResult?.Result ?? EResult.Timeout;\n\t\t\t\t\t\t\t\tpurchaseResultDetail = redeemResult?.PurchaseResultDetail ?? EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t\t\titems = redeemResult?.ParseItems();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((result == EResult.Timeout) || (purchaseResultDetail == EPurchaseResultDetail.Timeout)) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{result}/{purchaseResultDetail}\"), currentBot.BotName));\n\n\t\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttriedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\tif ((purchaseResultDetail == EPurchaseResultDetail.CannotRedeemCodeFromClient) || ((purchaseResultDetail == EPurchaseResultDetail.BadActivationCode) && assumeWalletKeyOnBadActivationCode)) {\n\t\t\t\t\t\t\t\t\tif (Bot.WalletCurrency != ECurrencyCode.Invalid) {\n\t\t\t\t\t\t\t\t\t\t// If it's a wallet code, we try to redeem it first, then handle the inner result as our primary one\n\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t(EResult Result, EPurchaseResultDetail? PurchaseResult)? walletResult = await currentBot.ArchiWebHandler.RedeemWalletKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\tif (walletResult != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult = walletResult.Value.Result;\n\t\t\t\t\t\t\t\t\t\t\tpurchaseResultDetail = walletResult.Value.PurchaseResult.GetValueOrDefault(walletResult.Value.Result == EResult.OK ? EPurchaseResultDetail.NoDetail : EPurchaseResultDetail.CannotRedeemCodeFromClient);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tresult = EResult.Timeout;\n\t\t\t\t\t\t\t\t\t\t\tpurchaseResultDetail = EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// We're unable to redeem this code from the client due to missing currency information\n\t\t\t\t\t\t\t\t\t\tpurchaseResultDetail = EPurchaseResultDetail.CannotRedeemCodeFromClient;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (items?.Count > 0) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeemWithItems, key, $\"{result}/{purchaseResultDetail}\", string.Join(\", \", items)), currentBot.BotName));\n\t\t\t\t\t\t\t\t} else if (!skipRequest) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{result}/{purchaseResultDetail}\"), currentBot.BotName));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tswitch (purchaseResultDetail) {\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CannotRedeemCodeFromClient:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.Timeout:\n\t\t\t\t\t\t\t\t\t\tif ((result != EResult.Timeout) && (purchaseResultDetail != EPurchaseResultDetail.Timeout)) {\n\t\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\tif (purchaseResultDetail == EPurchaseResultDetail.NoDetail) {\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AccountLocked:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AlreadyPurchased:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CancelledByUser:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DoesNotOwnRequiredApp:\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RestrictedCountry:\n\t\t\t\t\t\t\t\t\t\tif (!forward || (keepMissingGames && (purchaseResultDetail != EPurchaseResultDetail.AlreadyPurchased))) {\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (distribute) {\n\t\t\t\t\t\t\t\t\t\t\t// Next bot, without changing key\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\titems ??= new Dictionary<uint, string>();\n\n\t\t\t\t\t\t\t\t\t\tbool alreadyHandled = false;\n\n\t\t\t\t\t\t\t\t\t\tforeach (Bot innerBot in Bot.Bots.Where(bot => (bot.Value != currentBot) && (!redeemFlags.HasFlag(ERedeemFlags.SkipInitial) || (bot.Value != Bot)) && !triedBots.Contains(bot.Value) && !rateLimitedBots.Contains(bot.Value) && bot.Value.IsConnectedAndLoggedOn && ((access >= EAccess.Owner) || ((steamID != 0) && (bot.Value.GetAccess(steamID) >= EAccess.Operator))) && ((items.Count == 0) || items.Keys.Any(packageID => !bot.Value.OwnedPackageIDs.ContainsKey(packageID)))).OrderBy(static bot => bot.Key, Bot.BotsComparer).Select(static bot => bot.Value)) {\n\t\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t\tSteamApps.PurchaseResponseCallback? redeemResult = await innerBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\t\tif (redeemResult == null) {\n\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{EResult.Timeout}/{EPurchaseResultDetail.Timeout}\"), innerBot.BotName));\n\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ttriedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\tswitch (redeemResult.PurchaseResultDetail) {\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\t\t\t\t\t// This key is already handled, as we either redeemed it or we're sure it's dupe/invalid\n\t\t\t\t\t\t\t\t\t\t\t\t\talreadyHandled = true;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tDictionary<uint, string>? redeemItems = redeemResult.ParseItems();\n\n\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(redeemItems?.Count > 0 ? string.Format(CultureInfo.CurrentCulture, Strings.BotRedeemWithItems, key, $\"{redeemResult.Result}/{redeemResult.PurchaseResultDetail}\", string.Join(\", \", redeemItems)) : string.Format(CultureInfo.CurrentCulture, Strings.BotRedeem, key, $\"{redeemResult.Result}/{redeemResult.PurchaseResultDetail}\"), innerBot.BotName));\n\n\t\t\t\t\t\t\t\t\t\t\tif (alreadyHandled) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (redeemItems == null) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tforeach ((uint packageID, string packageName) in redeemItems.Where(item => !items.ContainsKey(item.Key))) {\n\t\t\t\t\t\t\t\t\t\t\t\titems[packageID] = packageName;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\t\t\tgoto case EPurchaseResultDetail.CancelledByUser;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.WarningUnknownValuePleaseReport, nameof(purchaseResultDetail), purchaseResultDetail));\n\n\t\t\t\t\t\t\t\t\t\t// ReSharper disable once RedundantSuppressNullableWarningExpression - required for .NET Framework\n\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We want to change bot in two cases:\n\t\t\t\t\t\t// a) When we have distribution enabled, obviously\n\t\t\t\t\t\t// b) When we're skipping initial bot AND we have forwarding enabled, otherwise we won't get down to other accounts\n\t\t\t\t\t\tif (distribute || (forward && redeemFlags.HasFlag(ERedeemFlags.SkipInitial))) {\n\t\t\t\t\t\t\tcurrentBot = botsEnumerator.MoveNext() ? botsEnumerator.Current : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (key == startingKey) {\n\t\t\t\t\t// We ran out of bots to try for this key, so change it to avoid infinite loop, next key\n\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (unusedKeys.Count > 0) {\n\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.UnusedKeys, string.Join(\", \", unusedKeys))));\n\t\t}\n\n\t\treturn response.Length > 0 ? response.ToString() : null;\n\t}\n\n\tprivate static async Task<string?> ResponseRedeem(EAccess access, string botNames, string keysText, ERedeemFlags redeemFlags = ERedeemFlags.None, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(keysText)) {\n\t\t\tthrow new ArgumentNullException(nameof(keysText));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseRedeem(ProxyAccess(bot, access, steamID), keysText, steamID, redeemFlags))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseReset(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tawait Bot.CheckOccupationStatus().ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseReset(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseReset(ProxyAccess(bot, access, steamID)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static string? ResponseRestart(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Actions.Restart();\n\n\t\treturn FormatStaticResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate string? ResponseResume(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.FamilySharing) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Bot.Actions.Resume();\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseResume(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseResume(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseStart(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Bot.Actions.Start();\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseStart(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStart(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseStats(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\tushort memoryInMegabytes = (ushort) (GC.GetTotalMemory(false) / 1024 / 1024);\n\t\tTimeSpan uptime = DateTime.UtcNow.Subtract(OS.ProcessStartTime);\n\n\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotStats, memoryInMegabytes, uptime.ToHumanReadable()));\n\t}\n\n\tprivate (string? Response, Bot Bot) ResponseStatus(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.FamilySharing) {\n\t\t\treturn (null, Bot);\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn (FormatBotResponse(Bot.KeepRunning ? Strings.BotStatusConnecting : Strings.BotStatusNotRunning), Bot);\n\t\t}\n\n\t\tif (Bot.PlayingBlocked) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusPlayingNotAvailable), Bot);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.Paused) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusPaused), Bot);\n\t\t}\n\n\t\tif (Bot.IsAccountLimited) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusLimited), Bot);\n\t\t}\n\n\t\tif (Bot.IsAccountLocked) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusLocked), Bot);\n\t\t}\n\n\t\tif (!Bot.CardsFarmer.NowFarming || (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count == 0)) {\n\t\t\treturn (FormatBotResponse(Strings.BotStatusNotIdling), Bot);\n\t\t}\n\n\t\tif (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count > 1) {\n\t\t\treturn (FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotStatusIdlingList, string.Join(\", \", Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Select(static game => $\"{game.AppID} ({game.GameName})\")), Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(static game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t\t}\n\n\t\tGame soloGame = Bot.CardsFarmer.CurrentGamesFarmingReadOnly.First();\n\n\t\treturn (FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotStatusIdling, soloGame.AppID, soloGame.GameName, soloGame.CardsRemaining, Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(static game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t}\n\n\tprivate static async Task<string?> ResponseStatus(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<(string? Response, Bot Bot)> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStatus(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<(string Response, Bot Bot)> validResults = new(results.Where(static result => !string.IsNullOrEmpty(result.Response))!);\n\n\t\tif (validResults.Count == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tHashSet<Bot> botsRunning = validResults.Where(static result => result.Bot.KeepRunning).Select(static result => result.Bot).ToHashSet();\n\n\t\tstring extraResponse = string.Format(CultureInfo.CurrentCulture, Strings.BotStatusOverview, botsRunning.Count, validResults.Count, botsRunning.Sum(static bot => bot.CardsFarmer.GamesToFarmReadOnly.Count), botsRunning.Sum(static bot => bot.CardsFarmer.GamesToFarmReadOnly.Sum(static game => game.CardsRemaining)));\n\n\t\treturn string.Join(Environment.NewLine, validResults.Select(static result => result.Response).Union(extraResponse.ToEnumerable()));\n\t}\n\n\tprivate string? ResponseStop(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string message) = Bot.Actions.Stop();\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseStop(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStop(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseTradingBlacklist(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access < EAccess.Master ? null : FormatBotResponse(Bot.BotDatabase.TradingBlacklistSteamIDs.Count == 0 ? string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotDatabase.TradingBlacklistSteamIDs)) : string.Join(\", \", Bot.BotDatabase.TradingBlacklistSteamIDs));\n\t}\n\n\tprivate static async Task<string?> ResponseTradingBlacklist(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseTradingBlacklist(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseTradingBlacklistAdd(EAccess access, string targetSteamIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<ulong> targetIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t}\n\n\t\t\ttargetIDs.Add(targetID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.TradingBlacklistSteamIDs.AddRange(targetIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseTradingBlacklistAdd(EAccess access, string botNames, string targetSteamIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseTradingBlacklistAdd(ProxyAccess(bot, access, steamID), targetSteamIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseTradingBlacklistRemove(EAccess access, string targetSteamIDs) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (targets.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(targets)));\n\t\t}\n\n\t\tHashSet<ulong> targetIDs = new();\n\n\t\tforeach (string target in targets) {\n\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t}\n\n\t\t\ttargetIDs.Add(targetID);\n\t\t}\n\n\t\treturn FormatBotResponse(Bot.BotDatabase.TradingBlacklistSteamIDs.RemoveRange(targetIDs) ? Strings.Done : Strings.NothingFound);\n\t}\n\n\tprivate static async Task<string?> ResponseTradingBlacklistRemove(EAccess access, string botNames, string targetSteamIDs, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\tthrow new ArgumentNullException(nameof(targetSteamIDs));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseTradingBlacklistRemove(ProxyAccess(bot, access, steamID), targetSteamIDs)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseTransfer(EAccess access, string botNameTo) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t}\n\n\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate static async Task<string?> ResponseTransfer(EAccess access, string botNames, string botNameTo, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransfer(ProxyAccess(bot, access, steamID), botNameTo))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate async Task<string?> ResponseTransferByRealAppIDs(EAccess access, IReadOnlyCollection<uint> realAppIDs, Bot targetBot, bool exclude) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif ((realAppIDs == null) || (realAppIDs.Count == 0)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDs));\n\t\t}\n\n\t\tArgumentNullException.ThrowIfNull(targetBot);\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t}\n\n\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t}\n\n\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t}\n\n\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\treturn FormatBotResponse(success ? message : string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, message));\n\t}\n\n\tprivate async Task<string?> ResponseTransferByRealAppIDs(EAccess access, string realAppIDsText, string botNameTo, bool exclude) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (appIDTexts.Length == 0) {\n\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t}\n\n\t\tHashSet<uint> realAppIDs = new();\n\n\t\tforeach (string appIDText in appIDTexts) {\n\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\trealAppIDs.Add(appID);\n\t\t}\n\n\t\treturn await ResponseTransferByRealAppIDs(access, realAppIDs, targetBot, exclude).ConfigureAwait(false);\n\t}\n\n\tprivate static async Task<string?> ResponseTransferByRealAppIDs(EAccess access, string botNames, string realAppIDsText, string botNameTo, bool exclude, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\tthrow new ArgumentNullException(nameof(realAppIDsText));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNameTo)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNameTo));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\tif (appIDTexts.Length == 0) {\n\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t}\n\n\t\tHashSet<uint> realAppIDs = new();\n\n\t\tforeach (string appIDText in appIDTexts) {\n\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\trealAppIDs.Add(appID);\n\t\t}\n\n\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\tif (targetBot == null) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNameTo)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransferByRealAppIDs(ProxyAccess(bot, access, steamID), realAppIDs, targetBot, exclude))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate string? ResponseUnknown(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access >= EAccess.Operator ? FormatBotResponse(Strings.UnknownCommand) : null;\n\t}\n\n\tprivate async Task<string?> ResponseUnpackBoosters(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t}\n\n\t\t// It'd make sense here to actually check return code of ArchiWebHandler.UnpackBooster(), but it lies most of the time | https://github.com/JustArchi/ArchiSteamFarm/issues/704\n\t\tbool completeSuccess = true;\n\n\t\t// It'd also make sense to run all of this in parallel, but it seems that Steam has a lot of problems with inventory-related parallel requests | https://steamcommunity.com/groups/archiasf/discussions/1/3559414588264550284/\n\t\ttry {\n\t\t\tawait foreach (Asset item in Bot.ArchiWebHandler.GetInventoryAsync().Where(static item => item.Type == Asset.EType.BoosterPack).ConfigureAwait(false)) {\n\t\t\t\tif (!await Bot.ArchiWebHandler.UnpackBooster(item.RealAppID, item.AssetID).ConfigureAwait(false)) {\n\t\t\t\t\tcompleteSuccess = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HttpRequestException e) {\n\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\n\t\t\tcompleteSuccess = false;\n\t\t} catch (Exception e) {\n\t\t\tBot.ArchiLogger.LogGenericException(e);\n\n\t\t\tcompleteSuccess = false;\n\t\t}\n\n\t\treturn FormatBotResponse(completeSuccess ? Strings.Success : Strings.Done);\n\t}\n\n\tprivate static async Task<string?> ResponseUnpackBoosters(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseUnpackBoosters(ProxyAccess(bot, access, steamID)))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\tprivate static async Task<string?> ResponseUpdate(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Owner) {\n\t\t\treturn null;\n\t\t}\n\n\t\t(bool success, string? message, Version? version) = await Actions.Update().ConfigureAwait(false);\n\n\t\treturn FormatStaticResponse($\"{(success ? Strings.Success : Strings.WarningFailed)}{(!string.IsNullOrEmpty(message) ? $\" {message}\" : version != null ? $\" {version}\" : \"\")}\");\n\t}\n\n\tprivate string? ResponseVersion(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\treturn access >= EAccess.Operator ? FormatBotResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotVersion, SharedInfo.ASF, SharedInfo.Version)) : null;\n\t}\n\n\tprivate string? ResponseWalletBalance(EAccess access) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (access < EAccess.Master) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn !Bot.IsConnectedAndLoggedOn ? FormatBotResponse(Strings.BotNotConnected) : FormatBotResponse(Bot.WalletCurrency != ECurrencyCode.Invalid ? string.Format(CultureInfo.CurrentCulture, Strings.BotWalletBalance, Bot.WalletBalance / 100.0, Bot.WalletCurrency.ToString()) : Strings.BotHasNoWallet);\n\t}\n\n\tprivate static async Task<string?> ResponseWalletBalance(EAccess access, string botNames, ulong steamID = 0) {\n\t\tif (!Enum.IsDefined(access)) {\n\t\t\tthrow new InvalidEnumArgumentException(nameof(access), (int) access, typeof(EAccess));\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(botNames)) {\n\t\t\tthrow new ArgumentNullException(nameof(botNames));\n\t\t}\n\n\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\treturn access >= EAccess.Owner ? FormatStaticResponse(string.Format(CultureInfo.CurrentCulture, Strings.BotNotFound, botNames)) : null;\n\t\t}\n\n\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseWalletBalance(ProxyAccess(bot, access, steamID))))).ConfigureAwait(false);\n\n\t\tList<string> responses = new(results.Where(static result => !string.IsNullOrEmpty(result))!);\n\n\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t}\n\n\t[Flags]\n\tprivate enum ERedeemFlags : ushort {\n\t\tNone = 0,\n\t\tValidate = 1,\n\t\tForceForwarding = 2,\n\t\tSkipForwarding = 4,\n\t\tForceDistributing = 8,\n\t\tSkipDistributing = 16,\n\t\tSkipInitial = 32,\n\t\tForceKeepMissingGames = 64,\n\t\tSkipKeepMissingGames = 128,\n\t\tForceAssumeWalletKeyOnBadActivationCode = 256,\n\t\tSkipAssumeWalletKeyOnBadActivationCode = 512\n\t}\n}\n"], "filenames": ["ArchiSteamFarm/Steam/Interaction/Commands.cs"], "buggy_code_start_loc": [152], "buggy_code_end_loc": [3433], "fixing_code_start_loc": [152], "fixing_code_end_loc": [3456], "type": "CWE-863", "message": "ArchiSteamFarm (ASF) is a C# application with primary purpose of idling Steam cards from multiple accounts simultaneously. Due to a bug in ASF code, introduced in version V5.2.2.2, the program didn't adequately verify effective access of the user sending proxy (i.e. `[Bots]`) commands. In particular, a proxy-like command sent to bot `A` targeting bot `B` has incorrectly verified user's access against bot `A` - instead of bot `B`, to which the command was originally designated. This in result allowed access to resources beyond those configured, being a security threat affecting confidentiality of other bot instances. A successful attack exploiting this bug requires a significant access granted explicitly by original owner of the ASF process prior to that, as attacker has to control at least a single bot in the process to make use of this inadequate access verification loophole. The issue is patched in ASF V5.2.2.5, V5.2.3.2 and future versions. Users are advised to update as soon as possible.", "other": {"cve": {"id": "CVE-2022-23627", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-08T23:15:07.470", "lastModified": "2022-02-16T17:23:51.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ArchiSteamFarm (ASF) is a C# application with primary purpose of idling Steam cards from multiple accounts simultaneously. Due to a bug in ASF code, introduced in version V5.2.2.2, the program didn't adequately verify effective access of the user sending proxy (i.e. `[Bots]`) commands. In particular, a proxy-like command sent to bot `A` targeting bot `B` has incorrectly verified user's access against bot `A` - instead of bot `B`, to which the command was originally designated. This in result allowed access to resources beyond those configured, being a security threat affecting confidentiality of other bot instances. A successful attack exploiting this bug requires a significant access granted explicitly by original owner of the ASF process prior to that, as attacker has to control at least a single bot in the process to make use of this inadequate access verification loophole. The issue is patched in ASF V5.2.2.5, V5.2.3.2 and future versions. Users are advised to update as soon as possible."}, {"lang": "es", "value": "ArchiSteamFarm (ASF) es una aplicaci\u00f3n C# con el prop\u00f3sito principal de ralentizar las tarjetas de Steam de m\u00faltiples cuentas simult\u00e1neamente. Debido a un bug en el c\u00f3digo de ASF, introducido en la versi\u00f3n V5.2.2.2, el programa no comprobaba apropiadamente el acceso efectivo del usuario que enviaba comandos proxy (es decir, \"[Bots]\"). En particular, un comando tipo proxy enviado al bot \"A\" dirigido al bot \"B\" verificaba incorrectamente el acceso del usuario contra el bot \"A\" - en lugar del bot \"B\", al que el comando estaba originalmente designado. Esto en resultado permiti\u00f3 el acceso a recursos m\u00e1s all\u00e1 de los configurados, siendo una amenaza de seguridad que afecta a la confidencialidad de otras instancias del bot. Un ataque con \u00e9xito explotando este bug requiere un acceso significativo concedido expl\u00edcitamente por el propietario original del proceso ASF antes de eso, ya que el atacante tiene que controlar al menos un solo bot en el proceso para hacer uso de esta laguna de verificaci\u00f3n de acceso inapropiada. El problema est\u00e1 parcheado en ASF versiones V5.2.2.5, V5.2.3.2 y futuras versiones. Es recomendado a usuarios actualizar lo antes posible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:archisteamfarm_project:archisteamfarm:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.2.2.2", "versionEndExcluding": "5.2.2.5", "matchCriteriaId": "C18CEFC4-C94B-436D-8E8B-EBF228EE0B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:archisteamfarm_project:archisteamfarm:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.2.3.0", "versionEndExcluding": "5.2.3.2", "matchCriteriaId": "EBE6F215-B10A-4A95-8529-BB42559FCDD1"}]}]}], "references": [{"url": "https://github.com/JustArchiNET/ArchiSteamFarm/commit/7a29d9282bdc3280db2a379c24f73916d786f9b4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/JustArchiNET/ArchiSteamFarm/commit/f807bdb660e75dee5a34994f2ea70970ca6d0492", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/JustArchiNET/ArchiSteamFarm/pull/2501", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/JustArchiNET/ArchiSteamFarm/pull/2509", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/JustArchiNET/ArchiSteamFarm/releases/tag/5.2.2.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/JustArchiNET/ArchiSteamFarm/releases/tag/5.2.3.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/JustArchiNET/ArchiSteamFarm/security/advisories/GHSA-88ch-366c-5m89", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/JustArchiNET/ArchiSteamFarm/commit/7a29d9282bdc3280db2a379c24f73916d786f9b4"}}