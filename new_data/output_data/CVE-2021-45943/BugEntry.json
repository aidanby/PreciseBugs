{"buggy_code": ["/******************************************************************************\n *\n * Purpose:  Implementation of the CPCIDSKBinarySegment class.\n *\n ******************************************************************************\n * Copyright (c) 2010\n * PCI Geomatics, 90 Allstate Parkway, Markham, Ontario, Canada.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"segment/cpcidskbinarysegment.h\"\n#include \"segment/cpcidsksegment.h\"\n#include \"core/pcidsk_utils.h\"\n#include \"pcidsk_exception.h\"\n#include \"core/pcidsk_utils.h\"\n\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cstring>\n\nusing namespace PCIDSK;\n\n/**\n * Binary Segment constructor\n * @param[in,out] fileIn the PCIDSK file\n * @param[in] segmentIn the segment index\n * @param[in] segment_pointer the segment pointer\n * @param[in] bLoad true to load the segment, else false (default true)\n */\nCPCIDSKBinarySegment::CPCIDSKBinarySegment(PCIDSKFile *fileIn,\n                                           int segmentIn,\n                                           const char *segment_pointer,\n                                           bool bLoad) :\n    CPCIDSKSegment(fileIn, segmentIn, segment_pointer),\n    loaded_(false),mbModified(false)\n{\n    if (true == bLoad)\n    {\n        Load();\n    }\n    return;\n}// Initializer constructor\n\n\nCPCIDSKBinarySegment::~CPCIDSKBinarySegment()\n{\n}\n\n/**\n * Load the contents of the segment\n */\nvoid CPCIDSKBinarySegment::Load()\n{\n    // Check if we've already loaded the segment into memory\n    if (loaded_) {\n        return;\n    }\n\n    seg_data.SetSize((int)data_size - 1024);\n\n    ReadFromFile(seg_data.buffer, 0, data_size - 1024);\n\n    // Mark it as being loaded properly.\n    loaded_ = true;\n}\n\n/**\n * Write the segment on disk\n */\nvoid CPCIDSKBinarySegment::Write(void)\n{\n    //We are not writing if nothing was loaded.\n    if (!loaded_) {\n        return;\n    }\n\n    WriteToFile(seg_data.buffer, 0, seg_data.buffer_size);\n\n    mbModified = false;\n}\n\n/**\n * Synchronize the segment, if it was modified then\n * write it into disk.\n */\nvoid CPCIDSKBinarySegment::Synchronize()\n{\n    if(mbModified)\n    {\n        this->Write();\n    }\n}\n\nvoid\nCPCIDSKBinarySegment::SetBuffer(const char* pabyBuf,\n                                unsigned int nBufSize)\n{\n    // Round the buffer size up to the next multiple of 512.\n    int nNumBlocks = nBufSize / 512 + ((0 == nBufSize % 512) ? 0 : 1);\n    unsigned int nAllocBufSize = 512 * nNumBlocks;\n\n    seg_data.SetSize((int)nAllocBufSize);\n    data_size = nAllocBufSize + 1024; // Incl. header\n\n    memcpy(seg_data.buffer, pabyBuf, nBufSize);\n\n    // Fill unused data at end with zeroes.\n    if (nBufSize < nAllocBufSize)\n    {\n        memset(seg_data.buffer + nBufSize, 0,\n            nAllocBufSize - nBufSize);\n    }\n    mbModified = true;\n\n    return;\n}// SetBuffer\n"], "fixing_code": ["/******************************************************************************\n *\n * Purpose:  Implementation of the CPCIDSKBinarySegment class.\n *\n ******************************************************************************\n * Copyright (c) 2010\n * PCI Geomatics, 90 Allstate Parkway, Markham, Ontario, Canada.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"segment/cpcidskbinarysegment.h\"\n#include \"segment/cpcidsksegment.h\"\n#include \"core/pcidsk_utils.h\"\n#include \"pcidsk_exception.h\"\n#include \"core/pcidsk_utils.h\"\n\n#include <limits>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <cstring>\n\nusing namespace PCIDSK;\n\n/**\n * Binary Segment constructor\n * @param[in,out] fileIn the PCIDSK file\n * @param[in] segmentIn the segment index\n * @param[in] segment_pointer the segment pointer\n * @param[in] bLoad true to load the segment, else false (default true)\n */\nCPCIDSKBinarySegment::CPCIDSKBinarySegment(PCIDSKFile *fileIn,\n                                           int segmentIn,\n                                           const char *segment_pointer,\n                                           bool bLoad) :\n    CPCIDSKSegment(fileIn, segmentIn, segment_pointer),\n    loaded_(false),mbModified(false)\n{\n    if (true == bLoad)\n    {\n        Load();\n    }\n    return;\n}// Initializer constructor\n\n\nCPCIDSKBinarySegment::~CPCIDSKBinarySegment()\n{\n}\n\n/**\n * Load the contents of the segment\n */\nvoid CPCIDSKBinarySegment::Load()\n{\n    // Check if we've already loaded the segment into memory\n    if (loaded_) {\n        return;\n    }\n    if( data_size - 1024 > static_cast<uint64_t>(std::numeric_limits<int>::max()) )\n    {\n        return ThrowPCIDSKException(\"too large data_size\");\n    }\n\n    seg_data.SetSize((int)(data_size - 1024));\n\n    ReadFromFile(seg_data.buffer, 0, data_size - 1024);\n\n    // Mark it as being loaded properly.\n    loaded_ = true;\n}\n\n/**\n * Write the segment on disk\n */\nvoid CPCIDSKBinarySegment::Write(void)\n{\n    //We are not writing if nothing was loaded.\n    if (!loaded_) {\n        return;\n    }\n\n    WriteToFile(seg_data.buffer, 0, seg_data.buffer_size);\n\n    mbModified = false;\n}\n\n/**\n * Synchronize the segment, if it was modified then\n * write it into disk.\n */\nvoid CPCIDSKBinarySegment::Synchronize()\n{\n    if(mbModified)\n    {\n        this->Write();\n    }\n}\n\nvoid\nCPCIDSKBinarySegment::SetBuffer(const char* pabyBuf,\n                                unsigned int nBufSize)\n{\n    // Round the buffer size up to the next multiple of 512.\n    int nNumBlocks = nBufSize / 512 + ((0 == nBufSize % 512) ? 0 : 1);\n    unsigned int nAllocBufSize = 512 * nNumBlocks;\n\n    seg_data.SetSize((int)nAllocBufSize);\n    data_size = nAllocBufSize + 1024; // Incl. header\n\n    memcpy(seg_data.buffer, pabyBuf, nBufSize);\n\n    // Fill unused data at end with zeroes.\n    if (nBufSize < nAllocBufSize)\n    {\n        memset(seg_data.buffer + nBufSize, 0,\n            nAllocBufSize - nBufSize);\n    }\n    mbModified = true;\n\n    return;\n}// SetBuffer\n"], "filenames": ["frmts/pcidsk/sdk/segment/cpcidskbinarysegment.cpp"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [78], "fixing_code_start_loc": [34], "fixing_code_end_loc": [83], "type": "CWE-787", "message": "GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).", "other": {"cve": {"id": "CVE-2021-45943", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-01T01:15:09.100", "lastModified": "2022-11-04T15:49:23.800", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment)."}, {"lang": "es", "value": "GDAL versiones 3.3.0 hasta 3.4.0, presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n PCIDSK::CPCIDSKFile::ReadFromFile (llamado desde PCIDSK::CPCIDSKSegment::ReadFromFile y PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:gdal:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3.0", "versionEndIncluding": "3.4.0", "matchCriteriaId": "A7BC8292-3409-4226-B5FA-28FDE0A13AA1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:spatial_and_graph:19c:*:*:*:*:*:*:*", "matchCriteriaId": "05508099-EEB4-4CE6-8621-D07A5B8B16D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:spatial_and_graph:21c:*:*:*:*:*:*:*", "matchCriteriaId": "36F9812A-A506-4DC9-B859-16085A9BD7EC"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41993", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/OSGeo/gdal/commit/1ca6a3e5168c200763fa46d8aa7e698d0b757e7e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OSGeo/gdal/pull/4944", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/gdal/OSV-2021-1651.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/01/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JBPJGXY7IYY65NVJBLP3RONXE7ZBVCNU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/P23E4DEHY5FJCR5VJ46I6TO32DT7Y3T4/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-15", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5239", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OSGeo/gdal/commit/1ca6a3e5168c200763fa46d8aa7e698d0b757e7e"}}