{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2001, 2007 by the Massachusetts Institute of Technology.\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Copyright (C) 1998 by the FundsXpress, INC.\n *\n * All rights reserved.\n *\n * Export of this software from the United States of America may require\n * a specific license from the United States Government.  It is the\n * responsibility of any person or organization contemplating export to\n * obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of FundsXpress. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  FundsXpress makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include \"gssapiP_krb5.h\"\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif\n#include <assert.h>\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nstatic OM_uint32\nkg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,\n             conf_state, qop_state, toktype)\n    krb5_context context;\n    OM_uint32 *minor_status;\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    int bodysize;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_error_code code;\n    int conflen = 0;\n    int signalg;\n    int sealalg;\n    gss_buffer_desc token;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    krb5_data plaind;\n    char *data_ptr;\n    unsigned char *plain;\n    unsigned int cksum_len = 0;\n    size_t plainlen;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        message_buffer->length = 0;\n        message_buffer->value = NULL;\n    }\n\n    /* get the sign and seal algorithms */\n\n    signalg = ptr[0] + (ptr[1]<<8);\n    sealalg = ptr[2] + (ptr[3]<<8);\n\n    /* Sanity checks */\n\n    if ((ptr[4] != 0xff) || (ptr[5] != 0xff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((toktype != KG_TOK_SEAL_MSG) &&\n        (sealalg != 0xffff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* in the current spec, there is only one valid seal algorithm per\n       key type, so a simple comparison is ok */\n\n    if ((toktype == KG_TOK_SEAL_MSG) &&\n        !((sealalg == 0xffff) ||\n          (sealalg == ctx->sealalg))) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* there are several mappings of seal algorithms to sign algorithms,\n       but few enough that we can try them all. */\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_SEAL_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n\n    if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,\n                               &seqnum))) {\n        *minor_status = code;\n        return(GSS_S_BAD_SIG);\n    }\n\n    /* decode the message, if SEAL */\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        size_t tmsglen = bodysize-(14+cksum_len);\n        if (sealalg != 0xffff) {\n            if ((plain = (unsigned char *) xmalloc(tmsglen)) == NULL) {\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                int i;\n                store_32_be(seqnum, bigend_seqnum);\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code)\n                {\n                    xfree(plain);\n                    *minor_status = code;\n                    return(GSS_S_FAILURE);\n                }\n\n                assert (enc_key->length == 16);\n                for (i = 0; i <= 15; i++)\n                    ((char *) enc_key->contents)[i] ^=0xf0;\n                code = kg_arcfour_docrypt (enc_key, 0,\n                                           &bigend_seqnum[0], 4,\n                                           ptr+14+cksum_len, tmsglen,\n                                           plain);\n                krb5_free_keyblock (context, enc_key);\n            } else {\n                code = kg_decrypt(context, ctx->enc, KG_USAGE_SEAL, NULL,\n                                  ptr+14+cksum_len, plain, tmsglen);\n            }\n            if (code) {\n                xfree(plain);\n                *minor_status = code;\n                return(GSS_S_FAILURE);\n            }\n        } else {\n            plain = ptr+14+cksum_len;\n        }\n\n        plainlen = tmsglen;\n\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n        token.length = tmsglen - conflen - plain[tmsglen-1];\n\n        if (token.length) {\n            if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {\n                if (sealalg != 0xffff)\n                    xfree(plain);\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            memcpy(token.value, plain+conflen, token.length);\n        } else {\n            token.value = NULL;\n        }\n    } else if (toktype == KG_TOK_SIGN_MSG) {\n        token = *message_buffer;\n        plain = token.value;\n        plainlen = token.length;\n    } else {\n        token.length = 0;\n        token.value = NULL;\n        plain = token.value;\n        plainlen = token.length;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the the cksum */\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort ();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code)\n        return(code);\n    md5cksum.length = sumlen;\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (signalg == 0)\n            cksum.length = 8;\n        else\n            cksum.length = 16;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n\n    case SGN_ALG_MD2_5:\n        if (!ctx->seed_init &&\n            (code = kg_make_seed(context, ctx->subkey, ctx->seed))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (! (data_ptr = xmalloc(sizeof(ctx->seed) + 8 + plainlen))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n        (void) memcpy(data_ptr, ptr-2, 8);\n        (void) memcpy(data_ptr+8, ctx->seed, sizeof(ctx->seed));\n        (void) memcpy(data_ptr+8+sizeof(ctx->seed), plain, plainlen);\n        plaind.length = 8 + sizeof(ctx->seed) + plainlen;\n        plaind.data = data_ptr;\n        krb5_free_checksum_contents(context, &md5cksum);\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, 8);\n        /* Falls through to defective-token??  */\n\n    default:\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    }\n\n    krb5_free_checksum_contents(context, &md5cksum);\n    if (sealalg != 0xffff)\n        xfree(plain);\n\n    /* compare the computed checksum against the transmitted checksum */\n\n    if (code) {\n        if (toktype == KG_TOK_SEAL_MSG)\n            gssalloc_free(token.value);\n        *minor_status = 0;\n        return(GSS_S_BAD_SIG);\n    }\n\n\n    /* it got through unscathed.  Make sure the context is unexpired */\n\n    if (toktype == KG_TOK_SEAL_MSG)\n        *message_buffer = token;\n\n    if (conf_state)\n        *conf_state = (sealalg != 0xffff);\n\n    if (qop_state)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    /* do sequencing checks */\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        if (toktype == KG_TOK_SEAL_MSG) {\n            gssalloc_free(token.value);\n            message_buffer->value = NULL;\n            message_buffer->length = 0;\n        }\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        return(GSS_S_BAD_SIG);\n    }\n\n    retval = g_order_check(&(ctx->seqstate), (gssint_uint64)seqnum);\n\n    /* success or ordering violation */\n\n    *minor_status = 0;\n    return(retval);\n}\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nOM_uint32\nkg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n\n\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n\n    return ret;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap(minor_status, context_handle,\n                input_message_buffer, output_message_buffer,\n                conf_state, qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        input_message_buffer;\n    gss_buffer_t        output_message_buffer;\n    int                 *conf_state;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      input_message_buffer, output_message_buffer,\n                      conf_state, qop_state, KG_TOK_WRAP_MSG);\n    return(rstat);\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic(minor_status, context_handle,\n                    message_buffer, token_buffer,\n                    qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        message_buffer;\n    gss_buffer_t        token_buffer;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      token_buffer, message_buffer,\n                      NULL, qop_state, KG_TOK_MIC_MSG);\n    return(rstat);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/gssapi/krb5/k5unsealiov.c */\n/*\n * Copyright 2008, 2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include <assert.h>\n#include \"k5-platform.h\"        /* for 64-bit support */\n#include \"k5-int.h\"          /* for zap() */\n#include \"gssapiP_krb5.h\"\n#include <stdarg.h>\n\nstatic OM_uint32\nkg_unseal_v1_iov(krb5_context context,\n                 OM_uint32 *minor_status,\n                 krb5_gss_ctx_id_rec *ctx,\n                 gss_iov_buffer_desc *iov,\n                 int iov_count,\n                 size_t token_wrapper_len,\n                 int *conf_state,\n                 gss_qop_t *qop_state,\n                 int toktype)\n{\n    OM_uint32 code;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t trailer;\n    unsigned char *ptr;\n    int sealalg;\n    int signalg;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    size_t cksum_len = 0;\n    size_t conflen = 0;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    md5cksum.length = cksum.length = 0;\n    md5cksum.contents = cksum.contents = NULL;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    assert(header != NULL);\n\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n    if (trailer != NULL && trailer->buffer.length != 0) {\n        *minor_status = (OM_uint32)KRB5_BAD_MSIZE;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (header->buffer.length < token_wrapper_len + 14) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    ptr = (unsigned char *)header->buffer.value + token_wrapper_len;\n\n    signalg  = ptr[0];\n    signalg |= ptr[1] << 8;\n\n    sealalg  = ptr[2];\n    sealalg |= ptr[3] << 8;\n\n    if (ptr[4] != 0xFF || ptr[5] != 0xFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype == KG_TOK_WRAP_MSG &&\n        !(sealalg == 0xFFFF || sealalg == ctx->sealalg)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_WRAP_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n    code = kg_get_seq_num(context, ctx->seq, ptr + 14, ptr + 6, &direction,\n                          &seqnum);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_BAD_SIG;\n    }\n\n    /* decode the message, if SEAL */\n    if (toktype == KG_TOK_WRAP_MSG) {\n        if (sealalg != 0xFFFF) {\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                size_t i;\n\n                store_32_be(seqnum, bigend_seqnum);\n\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code != 0) {\n                    retval = GSS_S_FAILURE;\n                    goto cleanup;\n                }\n\n                assert(enc_key->length == 16);\n\n                for (i = 0; i < enc_key->length; i++)\n                    ((char *)enc_key->contents)[i] ^= 0xF0;\n\n                code = kg_arcfour_docrypt_iov(context, enc_key, 0,\n                                              &bigend_seqnum[0], 4,\n                                              iov, iov_count);\n                krb5_free_keyblock(context, enc_key);\n            } else {\n                code = kg_decrypt_iov(context, 0,\n                                      ((ctx->gss_flags & GSS_C_DCE_STYLE) != 0),\n                                      0 /*EC*/, 0 /*RRC*/,\n                                      ctx->enc, KG_USAGE_SEAL, NULL,\n                                      iov, iov_count);\n            }\n            if (code != 0) {\n                retval = GSS_S_FAILURE;\n                goto cleanup;\n            }\n        }\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n    }\n\n    if (header->buffer.length != token_wrapper_len + 14 + cksum_len + conflen) {\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the checksum */\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n    md5cksum.length = sumlen;\n\n    /* compute the checksum of the message */\n    code = kg_make_checksum_iov_v1(context, md5cksum.checksum_type,\n                                   cksum_len, ctx->seq, ctx->enc,\n                                   sign_usage, iov, iov_count, toktype,\n                                   &md5cksum);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code != 0) {\n            retval = GSS_S_FAILURE;\n            goto cleanup;\n        }\n\n        cksum.length = cksum_len;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    default:\n        code = 0;\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    if (code != 0) {\n        code = 0;\n        retval = GSS_S_BAD_SIG;\n        goto cleanup;\n    }\n\n    /*\n     * For GSS_C_DCE_STYLE, the caller manages the padding, because the\n     * pad length is in the RPC PDU. The value of the padding may be\n     * uninitialized. For normal GSS, the last bytes of the decrypted\n     * data contain the pad length. kg_fixup_padding_iov() will find\n     * this and fixup the last data IOV appropriately.\n     */\n    if (toktype == KG_TOK_WRAP_MSG &&\n        (ctx->gss_flags & GSS_C_DCE_STYLE) == 0) {\n        retval = kg_fixup_padding_iov(&code, iov, iov_count);\n        if (retval != GSS_S_COMPLETE)\n            goto cleanup;\n    }\n\n    if (conf_state != NULL)\n        *conf_state = (sealalg != 0xFFFF);\n\n    if (qop_state != NULL)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        retval = GSS_S_BAD_SIG;\n    }\n\n    code = 0;\n    retval = g_order_check(&ctx->seqstate, (gssint_uint64)seqnum);\n\ncleanup:\n    krb5_free_checksum_contents(context, &md5cksum);\n\n    *minor_status = code;\n\n    return retval;\n}\n\n/*\n * Caller must provide TOKEN | DATA | PADDING | TRAILER, except\n * for DCE in which case it can just provide TOKEN | DATA (must\n * guarantee that DATA is padded)\n */\nstatic OM_uint32\nkg_unseal_iov_token(OM_uint32 *minor_status,\n                    krb5_gss_ctx_id_rec *ctx,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count,\n                    int toktype)\n{\n    krb5_error_code code;\n    krb5_context context = ctx->k5_context;\n    unsigned char *ptr;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t padding;\n    gss_iov_buffer_t trailer;\n    size_t input_length;\n    unsigned int bodysize;\n    int toktype2;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    if (header == NULL) {\n        *minor_status = EINVAL;\n        return GSS_S_FAILURE;\n    }\n\n    padding = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_PADDING);\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n\n    ptr = (unsigned char *)header->buffer.value;\n    input_length = header->buffer.length;\n\n    if ((ctx->gss_flags & GSS_C_DCE_STYLE) == 0 &&\n        toktype == KG_TOK_WRAP_MSG) {\n        size_t data_length, assoc_data_length;\n\n        kg_iov_msglen(iov, iov_count, &data_length, &assoc_data_length);\n\n        input_length += data_length - assoc_data_length;\n\n        if (padding != NULL)\n            input_length += padding->buffer.length;\n\n        if (trailer != NULL)\n            input_length += trailer->buffer.length;\n    }\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 input_length, 0);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        code = gss_krb5int_unseal_v3_iov(context, minor_status, ctx, iov, iov_count,\n                                         conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        code = kg_unseal_v1_iov(context, minor_status, ctx, iov, iov_count,\n                                (size_t)(ptr - (unsigned char *)header->buffer.value),\n                                conf_state, qop_state, toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        code = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (code != 0)\n        save_error_info(*minor_status, context);\n\n    return code;\n}\n\n/*\n * Split a STREAM | SIGN_DATA | DATA into\n *         HEADER | SIGN_DATA | DATA | PADDING | TRAILER\n */\nstatic OM_uint32\nkg_unseal_stream_iov(OM_uint32 *minor_status,\n                     krb5_gss_ctx_id_rec *ctx,\n                     int *conf_state,\n                     gss_qop_t *qop_state,\n                     gss_iov_buffer_desc *iov,\n                     int iov_count,\n                     int toktype)\n{\n    unsigned char *ptr;\n    unsigned int bodysize;\n    OM_uint32 code = 0, major_status = GSS_S_FAILURE;\n    krb5_context context = ctx->k5_context;\n    int conf_req_flag, toktype2;\n    int i = 0, j;\n    gss_iov_buffer_desc *tiov = NULL;\n    gss_iov_buffer_t stream, data = NULL;\n    gss_iov_buffer_t theader, tdata = NULL, tpadding, ttrailer;\n\n    assert(toktype == KG_TOK_WRAP_MSG);\n\n    if (toktype != KG_TOK_WRAP_MSG || (ctx->gss_flags & GSS_C_DCE_STYLE)) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    stream = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM);\n    assert(stream != NULL);\n\n    ptr = (unsigned char *)stream->buffer.value;\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 stream->buffer.length, 0);\n    if (code != 0) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    tiov = (gss_iov_buffer_desc *)calloc((size_t)iov_count + 2, sizeof(gss_iov_buffer_desc));\n    if (tiov == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n\n    /* HEADER */\n    theader = &tiov[i++];\n    theader->type = GSS_IOV_BUFFER_TYPE_HEADER;\n    theader->buffer.value = stream->buffer.value;\n    theader->buffer.length = ptr - (unsigned char *)stream->buffer.value;\n    if (bodysize < 14 ||\n        stream->buffer.length != theader->buffer.length + bodysize) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n    theader->buffer.length += 14;\n\n    /* n[SIGN_DATA] | DATA | m[SIGN_DATA] */\n    for (j = 0; j < iov_count; j++) {\n        OM_uint32 type = GSS_IOV_BUFFER_TYPE(iov[j].type);\n\n        if (type == GSS_IOV_BUFFER_TYPE_DATA) {\n            if (data != NULL) {\n                /* only a single DATA buffer can appear */\n                code = EINVAL;\n                goto cleanup;\n            }\n\n            data = &iov[j];\n            tdata = &tiov[i];\n        }\n        if (type == GSS_IOV_BUFFER_TYPE_DATA ||\n            type == GSS_IOV_BUFFER_TYPE_SIGN_ONLY)\n            tiov[i++] = iov[j];\n    }\n\n    if (data == NULL) {\n        /* a single DATA buffer must be present */\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    /* PADDING | TRAILER */\n    tpadding = &tiov[i++];\n    tpadding->type = GSS_IOV_BUFFER_TYPE_PADDING;\n    tpadding->buffer.length = 0;\n    tpadding->buffer.value = NULL;\n\n    ttrailer = &tiov[i++];\n    ttrailer->type = GSS_IOV_BUFFER_TYPE_TRAILER;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX: {\n        size_t ec, rrc;\n        krb5_enctype enctype;\n        unsigned int k5_headerlen = 0;\n        unsigned int k5_trailerlen = 0;\n\n        if (ctx->have_acceptor_subkey)\n            enctype = ctx->acceptor_subkey->keyblock.enctype;\n        else\n            enctype = ctx->subkey->keyblock.enctype;\n        conf_req_flag = ((ptr[0] & FLAG_WRAP_CONFIDENTIAL) != 0);\n        ec = conf_req_flag ? load_16_be(ptr + 2) : 0;\n        rrc = load_16_be(ptr + 4);\n\n        if (rrc != 0) {\n            if (!gss_krb5int_rotate_left((unsigned char *)stream->buffer.value + 16,\n                                         stream->buffer.length - 16, rrc)) {\n                code = ENOMEM;\n                goto cleanup;\n            }\n            store_16_be(0, ptr + 4); /* set RRC to zero */\n        }\n\n        if (conf_req_flag) {\n            code = krb5_c_crypto_length(context, enctype, KRB5_CRYPTO_TYPE_HEADER, &k5_headerlen);\n            if (code != 0)\n                goto cleanup;\n            theader->buffer.length += k5_headerlen; /* length validated later */\n        }\n\n        /* no PADDING for CFX, EC is used instead */\n        code = krb5_c_crypto_length(context, enctype,\n                                    conf_req_flag ? KRB5_CRYPTO_TYPE_TRAILER : KRB5_CRYPTO_TYPE_CHECKSUM,\n                                    &k5_trailerlen);\n        if (code != 0)\n            goto cleanup;\n\n        ttrailer->buffer.length = ec + (conf_req_flag ? 16 : 0 /* E(Header) */) + k5_trailerlen;\n        ttrailer->buffer.value = (unsigned char *)stream->buffer.value +\n            stream->buffer.length - ttrailer->buffer.length;\n        break;\n    }\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        theader->buffer.length += ctx->cksum_size +\n            kg_confounder_size(context, ctx->enc->keyblock.enctype);\n\n        /*\n         * we can't set the padding accurately until decryption;\n         * kg_fixup_padding_iov() will take care of this\n         */\n        tpadding->buffer.length = 1;\n        tpadding->buffer.value = (unsigned char *)stream->buffer.value + stream->buffer.length - 1;\n\n        /* no TRAILER for pre-CFX */\n        ttrailer->buffer.length = 0;\n        ttrailer->buffer.value = NULL;\n\n        break;\n    default:\n        code = (OM_uint32)G_BAD_TOK_HEADER;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    /* IOV: -----------0-------------+---1---+--2--+----------------3--------------*/\n    /* Old: GSS-Header | Conf        | Data  | Pad |                               */\n    /* CFX: GSS-Header | Kerb-Header | Data  |     | EC | E(Header) | Kerb-Trailer */\n    /* GSS: -------GSS-HEADER--------+-DATA--+-PAD-+----------GSS-TRAILER----------*/\n\n    /* validate lengths */\n    if (stream->buffer.length < theader->buffer.length +\n        tpadding->buffer.length +\n        ttrailer->buffer.length)\n    {\n        code = (OM_uint32)KRB5_BAD_MSIZE;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* setup data */\n    tdata->buffer.length = stream->buffer.length - ttrailer->buffer.length -\n        tpadding->buffer.length - theader->buffer.length;\n\n    assert(data != NULL);\n\n    if (data->type & GSS_IOV_BUFFER_FLAG_ALLOCATE) {\n        code = kg_allocate_iov(tdata, tdata->buffer.length);\n        if (code != 0)\n            goto cleanup;\n        memcpy(tdata->buffer.value,\n               (unsigned char *)stream->buffer.value + theader->buffer.length, tdata->buffer.length);\n    } else\n        tdata->buffer.value = (unsigned char *)stream->buffer.value + theader->buffer.length;\n\n    assert(i <= iov_count + 2);\n\n    major_status = kg_unseal_iov_token(&code, ctx, conf_state, qop_state,\n                                       tiov, i, toktype);\n    if (major_status == GSS_S_COMPLETE)\n        *data = *tdata;\n    else\n        kg_release_iov(tdata, 1);\n\ncleanup:\n    if (tiov != NULL)\n        free(tiov);\n\n    *minor_status = code;\n\n    return major_status;\n}\n\nOM_uint32\nkg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap_iov(OM_uint32 *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 conf_state, qop_state,\n                                 iov, iov_count, KG_TOK_WRAP_MSG);\n\n    return major_status;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic_iov(OM_uint32 *minor_status,\n                        gss_ctx_id_t context_handle,\n                        gss_qop_t *qop_state,\n                        gss_iov_buffer_desc *iov,\n                        int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 NULL, qop_state,\n                                 iov, iov_count, KG_TOK_MIC_MSG);\n\n    return major_status;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2001, 2007 by the Massachusetts Institute of Technology.\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Copyright (C) 1998 by the FundsXpress, INC.\n *\n * All rights reserved.\n *\n * Export of this software from the United States of America may require\n * a specific license from the United States Government.  It is the\n * responsibility of any person or organization contemplating export to\n * obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of FundsXpress. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  FundsXpress makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#include \"gssapiP_krb5.h\"\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif\n#include <assert.h>\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nstatic OM_uint32\nkg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,\n             conf_state, qop_state, toktype)\n    krb5_context context;\n    OM_uint32 *minor_status;\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    int bodysize;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_error_code code;\n    int conflen = 0;\n    int signalg;\n    int sealalg;\n    int bad_pad = 0;\n    gss_buffer_desc token;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    krb5_data plaind;\n    char *data_ptr;\n    unsigned char *plain;\n    unsigned int cksum_len = 0;\n    size_t plainlen;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    size_t padlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        message_buffer->length = 0;\n        message_buffer->value = NULL;\n    }\n\n    /* Sanity checks */\n\n    if (ctx->seq == NULL) {\n        /* ctx was established using a newer enctype, and cannot process RFC\n         * 1964 tokens. */\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((bodysize < 22) || (ptr[4] != 0xff) || (ptr[5] != 0xff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    signalg = ptr[0] + (ptr[1]<<8);\n    sealalg = ptr[2] + (ptr[3]<<8);\n\n    if ((toktype != KG_TOK_SEAL_MSG) &&\n        (sealalg != 0xffff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* in the current spec, there is only one valid seal algorithm per\n       key type, so a simple comparison is ok */\n\n    if ((toktype == KG_TOK_SEAL_MSG) &&\n        !((sealalg == 0xffff) ||\n          (sealalg == ctx->sealalg))) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* there are several mappings of seal algorithms to sign algorithms,\n       but few enough that we can try them all. */\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_SEAL_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((size_t)bodysize < 14 + cksum_len) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n\n    if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,\n                               &seqnum))) {\n        *minor_status = code;\n        return(GSS_S_BAD_SIG);\n    }\n\n    /* decode the message, if SEAL */\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        size_t tmsglen = bodysize-(14+cksum_len);\n        if (sealalg != 0xffff) {\n            if ((plain = (unsigned char *) xmalloc(tmsglen)) == NULL) {\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                int i;\n                store_32_be(seqnum, bigend_seqnum);\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code)\n                {\n                    xfree(plain);\n                    *minor_status = code;\n                    return(GSS_S_FAILURE);\n                }\n\n                assert (enc_key->length == 16);\n                for (i = 0; i <= 15; i++)\n                    ((char *) enc_key->contents)[i] ^=0xf0;\n                code = kg_arcfour_docrypt (enc_key, 0,\n                                           &bigend_seqnum[0], 4,\n                                           ptr+14+cksum_len, tmsglen,\n                                           plain);\n                krb5_free_keyblock (context, enc_key);\n            } else {\n                code = kg_decrypt(context, ctx->enc, KG_USAGE_SEAL, NULL,\n                                  ptr+14+cksum_len, plain, tmsglen);\n            }\n            if (code) {\n                xfree(plain);\n                *minor_status = code;\n                return(GSS_S_FAILURE);\n            }\n        } else {\n            plain = ptr+14+cksum_len;\n        }\n\n        plainlen = tmsglen;\n\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n        if (tmsglen < conflen) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            *minor_status = 0;\n            return(GSS_S_DEFECTIVE_TOKEN);\n        }\n        padlen = plain[tmsglen - 1];\n        if (tmsglen - conflen < padlen) {\n            /* Don't error out yet, to avoid padding oracle attacks.  We will\n             * treat this as a checksum failure later on. */\n            padlen = 0;\n            bad_pad = 1;\n        }\n        token.length = tmsglen - conflen - padlen;\n\n        if (token.length) {\n            if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {\n                if (sealalg != 0xffff)\n                    xfree(plain);\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            memcpy(token.value, plain+conflen, token.length);\n        } else {\n            token.value = NULL;\n        }\n    } else if (toktype == KG_TOK_SIGN_MSG) {\n        token = *message_buffer;\n        plain = token.value;\n        plainlen = token.length;\n    } else {\n        token.length = 0;\n        token.value = NULL;\n        plain = token.value;\n        plainlen = token.length;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the the cksum */\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort ();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code)\n        return(code);\n    md5cksum.length = sumlen;\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (signalg == 0)\n            cksum.length = 8;\n        else\n            cksum.length = 16;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n\n    case SGN_ALG_MD2_5:\n        if (!ctx->seed_init &&\n            (code = kg_make_seed(context, ctx->subkey, ctx->seed))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (! (data_ptr = xmalloc(sizeof(ctx->seed) + 8 + plainlen))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n        (void) memcpy(data_ptr, ptr-2, 8);\n        (void) memcpy(data_ptr+8, ctx->seed, sizeof(ctx->seed));\n        (void) memcpy(data_ptr+8+sizeof(ctx->seed), plain, plainlen);\n        plaind.length = 8 + sizeof(ctx->seed) + plainlen;\n        plaind.data = data_ptr;\n        krb5_free_checksum_contents(context, &md5cksum);\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, 8);\n        /* Falls through to defective-token??  */\n\n    default:\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    }\n\n    krb5_free_checksum_contents(context, &md5cksum);\n    if (sealalg != 0xffff)\n        xfree(plain);\n\n    /* compare the computed checksum against the transmitted checksum */\n\n    if (code || bad_pad) {\n        if (toktype == KG_TOK_SEAL_MSG)\n            gssalloc_free(token.value);\n        *minor_status = 0;\n        return(GSS_S_BAD_SIG);\n    }\n\n\n    /* it got through unscathed.  Make sure the context is unexpired */\n\n    if (toktype == KG_TOK_SEAL_MSG)\n        *message_buffer = token;\n\n    if (conf_state)\n        *conf_state = (sealalg != 0xffff);\n\n    if (qop_state)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    /* do sequencing checks */\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        if (toktype == KG_TOK_SEAL_MSG) {\n            gssalloc_free(token.value);\n            message_buffer->value = NULL;\n            message_buffer->length = 0;\n        }\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        return(GSS_S_BAD_SIG);\n    }\n\n    retval = g_order_check(&(ctx->seqstate), (gssint_uint64)seqnum);\n\n    /* success or ordering violation */\n\n    *minor_status = 0;\n    return(retval);\n}\n\n/* message_buffer is an input if SIGN, output if SEAL, and ignored if DEL_CTX\n   conf_state is only valid if SEAL. */\n\nOM_uint32\nkg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n\n\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n\n    return ret;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap(minor_status, context_handle,\n                input_message_buffer, output_message_buffer,\n                conf_state, qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        input_message_buffer;\n    gss_buffer_t        output_message_buffer;\n    int                 *conf_state;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      input_message_buffer, output_message_buffer,\n                      conf_state, qop_state, KG_TOK_WRAP_MSG);\n    return(rstat);\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic(minor_status, context_handle,\n                    message_buffer, token_buffer,\n                    qop_state)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    gss_buffer_t        message_buffer;\n    gss_buffer_t        token_buffer;\n    gss_qop_t           *qop_state;\n{\n    OM_uint32           rstat;\n\n    rstat = kg_unseal(minor_status, context_handle,\n                      token_buffer, message_buffer,\n                      NULL, qop_state, KG_TOK_MIC_MSG);\n    return(rstat);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/gssapi/krb5/k5unsealiov.c */\n/*\n * Copyright 2008, 2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include <assert.h>\n#include \"k5-platform.h\"        /* for 64-bit support */\n#include \"k5-int.h\"          /* for zap() */\n#include \"gssapiP_krb5.h\"\n#include <stdarg.h>\n\nstatic OM_uint32\nkg_unseal_v1_iov(krb5_context context,\n                 OM_uint32 *minor_status,\n                 krb5_gss_ctx_id_rec *ctx,\n                 gss_iov_buffer_desc *iov,\n                 int iov_count,\n                 size_t token_wrapper_len,\n                 int *conf_state,\n                 gss_qop_t *qop_state,\n                 int toktype)\n{\n    OM_uint32 code;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t trailer;\n    unsigned char *ptr;\n    int sealalg;\n    int signalg;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    size_t cksum_len = 0;\n    size_t conflen = 0;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    md5cksum.length = cksum.length = 0;\n    md5cksum.contents = cksum.contents = NULL;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    assert(header != NULL);\n\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n    if (trailer != NULL && trailer->buffer.length != 0) {\n        *minor_status = (OM_uint32)KRB5_BAD_MSIZE;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (ctx->seq == NULL) {\n        /* ctx was established using a newer enctype, and cannot process RFC\n         * 1964 tokens. */\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (header->buffer.length < token_wrapper_len + 22) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    ptr = (unsigned char *)header->buffer.value + token_wrapper_len;\n\n    signalg  = ptr[0];\n    signalg |= ptr[1] << 8;\n\n    sealalg  = ptr[2];\n    sealalg |= ptr[3] << 8;\n\n    if (ptr[4] != 0xFF || ptr[5] != 0xFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (toktype == KG_TOK_WRAP_MSG &&\n        !(sealalg == 0xFFFF || sealalg == ctx->sealalg)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_WRAP_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n    code = kg_get_seq_num(context, ctx->seq, ptr + 14, ptr + 6, &direction,\n                          &seqnum);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_BAD_SIG;\n    }\n\n    /* decode the message, if SEAL */\n    if (toktype == KG_TOK_WRAP_MSG) {\n        if (sealalg != 0xFFFF) {\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                size_t i;\n\n                store_32_be(seqnum, bigend_seqnum);\n\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code != 0) {\n                    retval = GSS_S_FAILURE;\n                    goto cleanup;\n                }\n\n                assert(enc_key->length == 16);\n\n                for (i = 0; i < enc_key->length; i++)\n                    ((char *)enc_key->contents)[i] ^= 0xF0;\n\n                code = kg_arcfour_docrypt_iov(context, enc_key, 0,\n                                              &bigend_seqnum[0], 4,\n                                              iov, iov_count);\n                krb5_free_keyblock(context, enc_key);\n            } else {\n                code = kg_decrypt_iov(context, 0,\n                                      ((ctx->gss_flags & GSS_C_DCE_STYLE) != 0),\n                                      0 /*EC*/, 0 /*RRC*/,\n                                      ctx->enc, KG_USAGE_SEAL, NULL,\n                                      iov, iov_count);\n            }\n            if (code != 0) {\n                retval = GSS_S_FAILURE;\n                goto cleanup;\n            }\n        }\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n    }\n\n    if (header->buffer.length != token_wrapper_len + 14 + cksum_len + conflen) {\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the checksum */\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n    md5cksum.length = sumlen;\n\n    /* compute the checksum of the message */\n    code = kg_make_checksum_iov_v1(context, md5cksum.checksum_type,\n                                   cksum_len, ctx->seq, ctx->enc,\n                                   sign_usage, iov, iov_count, toktype,\n                                   &md5cksum);\n    if (code != 0) {\n        retval = GSS_S_FAILURE;\n        goto cleanup;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code != 0) {\n            retval = GSS_S_FAILURE;\n            goto cleanup;\n        }\n\n        cksum.length = cksum_len;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    default:\n        code = 0;\n        retval = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    if (code != 0) {\n        code = 0;\n        retval = GSS_S_BAD_SIG;\n        goto cleanup;\n    }\n\n    /*\n     * For GSS_C_DCE_STYLE, the caller manages the padding, because the\n     * pad length is in the RPC PDU. The value of the padding may be\n     * uninitialized. For normal GSS, the last bytes of the decrypted\n     * data contain the pad length. kg_fixup_padding_iov() will find\n     * this and fixup the last data IOV appropriately.\n     */\n    if (toktype == KG_TOK_WRAP_MSG &&\n        (ctx->gss_flags & GSS_C_DCE_STYLE) == 0) {\n        retval = kg_fixup_padding_iov(&code, iov, iov_count);\n        if (retval != GSS_S_COMPLETE)\n            goto cleanup;\n    }\n\n    if (conf_state != NULL)\n        *conf_state = (sealalg != 0xFFFF);\n\n    if (qop_state != NULL)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        retval = GSS_S_BAD_SIG;\n    }\n\n    code = 0;\n    retval = g_order_check(&ctx->seqstate, (gssint_uint64)seqnum);\n\ncleanup:\n    krb5_free_checksum_contents(context, &md5cksum);\n\n    *minor_status = code;\n\n    return retval;\n}\n\n/*\n * Caller must provide TOKEN | DATA | PADDING | TRAILER, except\n * for DCE in which case it can just provide TOKEN | DATA (must\n * guarantee that DATA is padded)\n */\nstatic OM_uint32\nkg_unseal_iov_token(OM_uint32 *minor_status,\n                    krb5_gss_ctx_id_rec *ctx,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count,\n                    int toktype)\n{\n    krb5_error_code code;\n    krb5_context context = ctx->k5_context;\n    unsigned char *ptr;\n    gss_iov_buffer_t header;\n    gss_iov_buffer_t padding;\n    gss_iov_buffer_t trailer;\n    size_t input_length;\n    unsigned int bodysize;\n    int toktype2;\n\n    header = kg_locate_header_iov(iov, iov_count, toktype);\n    if (header == NULL) {\n        *minor_status = EINVAL;\n        return GSS_S_FAILURE;\n    }\n\n    padding = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_PADDING);\n    trailer = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_TRAILER);\n\n    ptr = (unsigned char *)header->buffer.value;\n    input_length = header->buffer.length;\n\n    if ((ctx->gss_flags & GSS_C_DCE_STYLE) == 0 &&\n        toktype == KG_TOK_WRAP_MSG) {\n        size_t data_length, assoc_data_length;\n\n        kg_iov_msglen(iov, iov_count, &data_length, &assoc_data_length);\n\n        input_length += data_length - assoc_data_length;\n\n        if (padding != NULL)\n            input_length += padding->buffer.length;\n\n        if (trailer != NULL)\n            input_length += trailer->buffer.length;\n    }\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 input_length, 0);\n    if (code != 0) {\n        *minor_status = code;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        code = gss_krb5int_unseal_v3_iov(context, minor_status, ctx, iov, iov_count,\n                                         conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        code = kg_unseal_v1_iov(context, minor_status, ctx, iov, iov_count,\n                                (size_t)(ptr - (unsigned char *)header->buffer.value),\n                                conf_state, qop_state, toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        code = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (code != 0)\n        save_error_info(*minor_status, context);\n\n    return code;\n}\n\n/*\n * Split a STREAM | SIGN_DATA | DATA into\n *         HEADER | SIGN_DATA | DATA | PADDING | TRAILER\n */\nstatic OM_uint32\nkg_unseal_stream_iov(OM_uint32 *minor_status,\n                     krb5_gss_ctx_id_rec *ctx,\n                     int *conf_state,\n                     gss_qop_t *qop_state,\n                     gss_iov_buffer_desc *iov,\n                     int iov_count,\n                     int toktype)\n{\n    unsigned char *ptr;\n    unsigned int bodysize;\n    OM_uint32 code = 0, major_status = GSS_S_FAILURE;\n    krb5_context context = ctx->k5_context;\n    int conf_req_flag, toktype2;\n    int i = 0, j;\n    gss_iov_buffer_desc *tiov = NULL;\n    gss_iov_buffer_t stream, data = NULL;\n    gss_iov_buffer_t theader, tdata = NULL, tpadding, ttrailer;\n\n    assert(toktype == KG_TOK_WRAP_MSG);\n\n    if (toktype != KG_TOK_WRAP_MSG || (ctx->gss_flags & GSS_C_DCE_STYLE)) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    stream = kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM);\n    assert(stream != NULL);\n\n    ptr = (unsigned char *)stream->buffer.value;\n\n    code = g_verify_token_header(ctx->mech_used,\n                                 &bodysize, &ptr, -1,\n                                 stream->buffer.length, 0);\n    if (code != 0) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    tiov = (gss_iov_buffer_desc *)calloc((size_t)iov_count + 2, sizeof(gss_iov_buffer_desc));\n    if (tiov == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n\n    /* HEADER */\n    theader = &tiov[i++];\n    theader->type = GSS_IOV_BUFFER_TYPE_HEADER;\n    theader->buffer.value = stream->buffer.value;\n    theader->buffer.length = ptr - (unsigned char *)stream->buffer.value;\n    if (bodysize < 14 ||\n        stream->buffer.length != theader->buffer.length + bodysize) {\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n    theader->buffer.length += 14;\n\n    /* n[SIGN_DATA] | DATA | m[SIGN_DATA] */\n    for (j = 0; j < iov_count; j++) {\n        OM_uint32 type = GSS_IOV_BUFFER_TYPE(iov[j].type);\n\n        if (type == GSS_IOV_BUFFER_TYPE_DATA) {\n            if (data != NULL) {\n                /* only a single DATA buffer can appear */\n                code = EINVAL;\n                goto cleanup;\n            }\n\n            data = &iov[j];\n            tdata = &tiov[i];\n        }\n        if (type == GSS_IOV_BUFFER_TYPE_DATA ||\n            type == GSS_IOV_BUFFER_TYPE_SIGN_ONLY)\n            tiov[i++] = iov[j];\n    }\n\n    if (data == NULL) {\n        /* a single DATA buffer must be present */\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    /* PADDING | TRAILER */\n    tpadding = &tiov[i++];\n    tpadding->type = GSS_IOV_BUFFER_TYPE_PADDING;\n    tpadding->buffer.length = 0;\n    tpadding->buffer.value = NULL;\n\n    ttrailer = &tiov[i++];\n    ttrailer->type = GSS_IOV_BUFFER_TYPE_TRAILER;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX: {\n        size_t ec, rrc;\n        krb5_enctype enctype;\n        unsigned int k5_headerlen = 0;\n        unsigned int k5_trailerlen = 0;\n\n        if (ctx->have_acceptor_subkey)\n            enctype = ctx->acceptor_subkey->keyblock.enctype;\n        else\n            enctype = ctx->subkey->keyblock.enctype;\n        conf_req_flag = ((ptr[0] & FLAG_WRAP_CONFIDENTIAL) != 0);\n        ec = conf_req_flag ? load_16_be(ptr + 2) : 0;\n        rrc = load_16_be(ptr + 4);\n\n        if (rrc != 0) {\n            if (!gss_krb5int_rotate_left((unsigned char *)stream->buffer.value + 16,\n                                         stream->buffer.length - 16, rrc)) {\n                code = ENOMEM;\n                goto cleanup;\n            }\n            store_16_be(0, ptr + 4); /* set RRC to zero */\n        }\n\n        if (conf_req_flag) {\n            code = krb5_c_crypto_length(context, enctype, KRB5_CRYPTO_TYPE_HEADER, &k5_headerlen);\n            if (code != 0)\n                goto cleanup;\n            theader->buffer.length += k5_headerlen; /* length validated later */\n        }\n\n        /* no PADDING for CFX, EC is used instead */\n        code = krb5_c_crypto_length(context, enctype,\n                                    conf_req_flag ? KRB5_CRYPTO_TYPE_TRAILER : KRB5_CRYPTO_TYPE_CHECKSUM,\n                                    &k5_trailerlen);\n        if (code != 0)\n            goto cleanup;\n\n        ttrailer->buffer.length = ec + (conf_req_flag ? 16 : 0 /* E(Header) */) + k5_trailerlen;\n        ttrailer->buffer.value = (unsigned char *)stream->buffer.value +\n            stream->buffer.length - ttrailer->buffer.length;\n        break;\n    }\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        theader->buffer.length += ctx->cksum_size +\n            kg_confounder_size(context, ctx->enc->keyblock.enctype);\n\n        /*\n         * we can't set the padding accurately until decryption;\n         * kg_fixup_padding_iov() will take care of this\n         */\n        tpadding->buffer.length = 1;\n        tpadding->buffer.value = (unsigned char *)stream->buffer.value + stream->buffer.length - 1;\n\n        /* no TRAILER for pre-CFX */\n        ttrailer->buffer.length = 0;\n        ttrailer->buffer.value = NULL;\n\n        break;\n    default:\n        code = (OM_uint32)G_BAD_TOK_HEADER;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n        break;\n    }\n\n    /* IOV: -----------0-------------+---1---+--2--+----------------3--------------*/\n    /* Old: GSS-Header | Conf        | Data  | Pad |                               */\n    /* CFX: GSS-Header | Kerb-Header | Data  |     | EC | E(Header) | Kerb-Trailer */\n    /* GSS: -------GSS-HEADER--------+-DATA--+-PAD-+----------GSS-TRAILER----------*/\n\n    /* validate lengths */\n    if (stream->buffer.length < theader->buffer.length +\n        tpadding->buffer.length +\n        ttrailer->buffer.length)\n    {\n        code = (OM_uint32)KRB5_BAD_MSIZE;\n        major_status = GSS_S_DEFECTIVE_TOKEN;\n        goto cleanup;\n    }\n\n    /* setup data */\n    tdata->buffer.length = stream->buffer.length - ttrailer->buffer.length -\n        tpadding->buffer.length - theader->buffer.length;\n\n    assert(data != NULL);\n\n    if (data->type & GSS_IOV_BUFFER_FLAG_ALLOCATE) {\n        code = kg_allocate_iov(tdata, tdata->buffer.length);\n        if (code != 0)\n            goto cleanup;\n        memcpy(tdata->buffer.value,\n               (unsigned char *)stream->buffer.value + theader->buffer.length, tdata->buffer.length);\n    } else\n        tdata->buffer.value = (unsigned char *)stream->buffer.value + theader->buffer.length;\n\n    assert(i <= iov_count + 2);\n\n    major_status = kg_unseal_iov_token(&code, ctx, conf_state, qop_state,\n                                       tiov, i, toktype);\n    if (major_status == GSS_S_COMPLETE)\n        *data = *tdata;\n    else\n        kg_release_iov(tdata, 1);\n\ncleanup:\n    if (tiov != NULL)\n        free(tiov);\n\n    *minor_status = code;\n\n    return major_status;\n}\n\nOM_uint32\nkg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_unwrap_iov(OM_uint32 *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int *conf_state,\n                    gss_qop_t *qop_state,\n                    gss_iov_buffer_desc *iov,\n                    int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 conf_state, qop_state,\n                                 iov, iov_count, KG_TOK_WRAP_MSG);\n\n    return major_status;\n}\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_verify_mic_iov(OM_uint32 *minor_status,\n                        gss_ctx_id_t context_handle,\n                        gss_qop_t *qop_state,\n                        gss_iov_buffer_desc *iov,\n                        int iov_count)\n{\n    OM_uint32 major_status;\n\n    major_status = kg_unseal_iov(minor_status, context_handle,\n                                 NULL, qop_state,\n                                 iov, iov_count, KG_TOK_MIC_MSG);\n\n    return major_status;\n}\n"], "filenames": ["src/lib/gssapi/krb5/k5unseal.c", "src/lib/gssapi/krb5/k5unsealiov.c"], "buggy_code_start_loc": [76, 72], "buggy_code_end_loc": [407, 73], "fixing_code_start_loc": [77, 72], "fixing_code_end_loc": [432, 80], "type": "CWE-125", "message": "MIT Kerberos 5 (aka krb5) before 1.12.2 allows remote attackers to cause a denial of service (buffer over-read and application crash) by injecting invalid tokens into a GSSAPI application session.", "other": {"cve": {"id": "CVE-2014-4341", "sourceIdentifier": "cve@mitre.org", "published": "2014-07-20T11:12:50.823", "lastModified": "2021-02-02T19:00:48.647", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MIT Kerberos 5 (aka krb5) before 1.12.2 allows remote attackers to cause a denial of service (buffer over-read and application crash) by injecting invalid tokens into a GSSAPI application session."}, {"lang": "es", "value": "MIT Kerberos 5 (tambi\u00e9n conocido como krb5) anterior a 1.12.2 permite a atacantes remotos causar una denegaci\u00f3n de servicio (sobrelectura de buffer y ca\u00edda de aplicaci\u00f3n) mediante la inyecci\u00f3n de tokens inv\u00e1lido en una sesi\u00f3n de la aplicaci\u00f3n GSSAPI."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.2", "matchCriteriaId": "D5877EC2-4E69-45F0-ADDF-48D3F7D49646"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "807C024A-F8E8-4B48-A349-4C68CD252CA1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "F96E3779-F56A-45FF-BB3D-4980527D721E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "0CF73560-2F5B-4723-A8A1-9AADBB3ADA00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "83737173-E12E-4641-BC49-0BD84A6B29D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "21690BAC-2129-4A33-9B48-1F3BF30072A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "78FD06FA-44C9-46FE-8014-C381848ADCFF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "1995855A-1883-412D-B629-5436E881FF08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "FC88059E-CCFD-4AFD-9982-41DF225FB840"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:20:*:*:*:*:*:*:*", "matchCriteriaId": "FF47C9F0-D8DA-4B55-89EB-9B2C9383ADB9"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2014-0345.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://aix.software.ibm.com/aix/efixes/security/nas_advisory1.asc", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7949", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-August/136360.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0439.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59102", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60082", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60448", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://security.gentoo.org/glsa/glsa-201412-53.xml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3000", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2014:165", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68909", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1030706", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/94904", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73"}}