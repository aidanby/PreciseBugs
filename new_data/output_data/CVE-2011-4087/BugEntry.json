{"buggy_code": ["/*\n *\tHandle firewalling\n *\tLinux ethernet bridge\n *\n *\tAuthors:\n *\tLennert Buytenhek\t\t<buytenh@gnu.org>\n *\tBart De Schuymer\t\t<bdschuym@pandora.be>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n *\tLennert dedicates this file to Kerstin Wurdinger.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_arp.h>\n#include <linux/in_route.h>\n#include <linux/inetdevice.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/route.h>\n\n#include <asm/uaccess.h>\n#include \"br_private.h\"\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#define skb_origaddr(skb)\t (((struct bridge_skb_cb *) \\\n\t\t\t\t (skb->nf_bridge->data))->daddr.ipv4)\n#define store_orig_dstaddr(skb)\t (skb_origaddr(skb) = ip_hdr(skb)->daddr)\n#define dnat_took_place(skb)\t (skb_origaddr(skb) != ip_hdr(skb)->daddr)\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table_header *brnf_sysctl_header;\nstatic int brnf_call_iptables __read_mostly = 1;\nstatic int brnf_call_ip6tables __read_mostly = 1;\nstatic int brnf_call_arptables __read_mostly = 1;\nstatic int brnf_filter_vlan_tagged __read_mostly = 0;\nstatic int brnf_filter_pppoe_tagged __read_mostly = 0;\n#else\n#define brnf_call_iptables 1\n#define brnf_call_ip6tables 1\n#define brnf_call_arptables 1\n#define brnf_filter_vlan_tagged 0\n#define brnf_filter_pppoe_tagged 0\n#endif\n\nstatic inline __be16 vlan_proto(const struct sk_buff *skb)\n{\n\tif (vlan_tx_tag_present(skb))\n\t\treturn skb->protocol;\n\telse if (skb->protocol == htons(ETH_P_8021Q))\n\t\treturn vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;\n\telse\n\t\treturn 0;\n}\n\n#define IS_VLAN_IP(skb) \\\n\t(vlan_proto(skb) == htons(ETH_P_IP) && \\\n\t brnf_filter_vlan_tagged)\n\n#define IS_VLAN_IPV6(skb) \\\n\t(vlan_proto(skb) == htons(ETH_P_IPV6) && \\\n\t brnf_filter_vlan_tagged)\n\n#define IS_VLAN_ARP(skb) \\\n\t(vlan_proto(skb) == htons(ETH_P_ARP) &&\t\\\n\t brnf_filter_vlan_tagged)\n\nstatic inline __be16 pppoe_proto(const struct sk_buff *skb)\n{\n\treturn *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +\n\t\t\t    sizeof(struct pppoe_hdr)));\n}\n\n#define IS_PPPOE_IP(skb) \\\n\t(skb->protocol == htons(ETH_P_PPP_SES) && \\\n\t pppoe_proto(skb) == htons(PPP_IP) && \\\n\t brnf_filter_pppoe_tagged)\n\n#define IS_PPPOE_IPV6(skb) \\\n\t(skb->protocol == htons(ETH_P_PPP_SES) && \\\n\t pppoe_proto(skb) == htons(PPP_IPV6) && \\\n\t brnf_filter_pppoe_tagged)\n\nstatic void fake_update_pmtu(struct dst_entry *dst, u32 mtu)\n{\n}\n\nstatic struct dst_ops fake_dst_ops = {\n\t.family =\t\tAF_INET,\n\t.protocol =\t\tcpu_to_be16(ETH_P_IP),\n\t.update_pmtu =\t\tfake_update_pmtu,\n};\n\n/*\n * Initialize bogus route table used to keep netfilter happy.\n * Currently, we fill in the PMTU entry because netfilter\n * refragmentation needs it, and the rt_flags entry because\n * ipt_REJECT needs it.  Future netfilter modules might\n * require us to fill additional fields.\n */\nvoid br_netfilter_rtable_init(struct net_bridge *br)\n{\n\tstruct rtable *rt = &br->fake_rtable;\n\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->dst.dev = br->dev;\n\trt->dst.path = &rt->dst;\n\tdst_metric_set(&rt->dst, RTAX_MTU, 1500);\n\trt->dst.flags\t= DST_NOXFRM;\n\trt->dst.ops = &fake_dst_ops;\n}\n\nstatic inline struct rtable *bridge_parent_rtable(const struct net_device *dev)\n{\n\tstruct net_bridge_port *port;\n\n\tport = br_port_get_rcu(dev);\n\treturn port ? &port->br->fake_rtable : NULL;\n}\n\nstatic inline struct net_device *bridge_parent(const struct net_device *dev)\n{\n\tstruct net_bridge_port *port;\n\n\tport = br_port_get_rcu(dev);\n\treturn port ? port->br->dev : NULL;\n}\n\nstatic inline struct nf_bridge_info *nf_bridge_alloc(struct sk_buff *skb)\n{\n\tskb->nf_bridge = kzalloc(sizeof(struct nf_bridge_info), GFP_ATOMIC);\n\tif (likely(skb->nf_bridge))\n\t\tatomic_set(&(skb->nf_bridge->use), 1);\n\n\treturn skb->nf_bridge;\n}\n\nstatic inline struct nf_bridge_info *nf_bridge_unshare(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\n\tif (atomic_read(&nf_bridge->use) > 1) {\n\t\tstruct nf_bridge_info *tmp = nf_bridge_alloc(skb);\n\n\t\tif (tmp) {\n\t\t\tmemcpy(tmp, nf_bridge, sizeof(struct nf_bridge_info));\n\t\t\tatomic_set(&tmp->use, 1);\n\t\t}\n\t\tnf_bridge_put(nf_bridge);\n\t\tnf_bridge = tmp;\n\t}\n\treturn nf_bridge;\n}\n\nstatic inline void nf_bridge_push_encap_header(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_push(skb, len);\n\tskb->network_header -= len;\n}\n\nstatic inline void nf_bridge_pull_encap_header(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_pull(skb, len);\n\tskb->network_header += len;\n}\n\nstatic inline void nf_bridge_pull_encap_header_rcsum(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_pull_rcsum(skb, len);\n\tskb->network_header += len;\n}\n\nstatic inline void nf_bridge_save_header(struct sk_buff *skb)\n{\n\tint header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);\n\n\tskb_copy_from_linear_data_offset(skb, -header_size,\n\t\t\t\t\t skb->nf_bridge->data, header_size);\n}\n\nstatic inline void nf_bridge_update_protocol(struct sk_buff *skb)\n{\n\tif (skb->nf_bridge->mask & BRNF_8021Q)\n\t\tskb->protocol = htons(ETH_P_8021Q);\n\telse if (skb->nf_bridge->mask & BRNF_PPPoE)\n\t\tskb->protocol = htons(ETH_P_PPP_SES);\n}\n\n/* When handing a packet over to the IP layer\n * check whether we have a skb that is in the\n * expected format\n */\n\nstatic int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t/* Basic sanity checks */\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\t/* Zero out the CB buffer if no options present */\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t/* Check correct handling of SRR option */\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}\n\n/* Fill in the header for fragmented IP packets handled by\n * the IPv4 connection tracking code.\n */\nint nf_bridge_copy_header(struct sk_buff *skb)\n{\n\tint err;\n\tunsigned int header_size;\n\n\tnf_bridge_update_protocol(skb);\n\theader_size = ETH_HLEN + nf_bridge_encap_header_len(skb);\n\terr = skb_cow_head(skb, header_size);\n\tif (err)\n\t\treturn err;\n\n\tskb_copy_to_linear_data_offset(skb, -header_size,\n\t\t\t\t       skb->nf_bridge->data, header_size);\n\t__skb_push(skb, nf_bridge_encap_header_len(skb));\n\treturn 0;\n}\n\n/* PF_BRIDGE/PRE_ROUTING *********************************************/\n/* Undo the changes made for ip6tables PREROUTING and continue the\n * bridge PRE_ROUTING hook. */\nstatic int br_nf_pre_routing_finish_ipv6(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct rtable *rt;\n\n\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t}\n\tnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\n\n\trt = bridge_parent_rtable(nf_bridge->physindev);\n\tif (!rt) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\tskb_dst_set_noref(skb, &rt->dst);\n\n\tskb->dev = nf_bridge->physindev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\n\t\t       br_handle_frame_finish, 1);\n\n\treturn 0;\n}\n\n/* Obtain the correct destination MAC address, while preserving the original\n * source MAC address. If we already know this address, we just copy it. If we\n * don't, we use the neighbour framework to find out. In both cases, we make\n * sure that br_handle_frame_finish() is called afterwards.\n */\nstatic int br_nf_pre_routing_finish_bridge(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct dst_entry *dst;\n\n\tskb->dev = bridge_parent(skb->dev);\n\tif (!skb->dev)\n\t\tgoto free_skb;\n\tdst = skb_dst(skb);\n\tif (dst->hh) {\n\t\tneigh_hh_bridge(dst->hh, skb);\n\t\tskb->dev = nf_bridge->physindev;\n\t\treturn br_handle_frame_finish(skb);\n\t} else if (dst->neighbour) {\n\t\t/* the neighbour function below overwrites the complete\n\t\t * MAC header, so we save the Ethernet source address and\n\t\t * protocol number. */\n\t\tskb_copy_from_linear_data_offset(skb, -(ETH_HLEN-ETH_ALEN), skb->nf_bridge->data, ETH_HLEN-ETH_ALEN);\n\t\t/* tell br_dev_xmit to continue with forwarding */\n\t\tnf_bridge->mask |= BRNF_BRIDGED_DNAT;\n\t\treturn dst->neighbour->output(skb);\n\t}\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/* This requires some explaining. If DNAT has taken place,\n * we will need to fix up the destination Ethernet address.\n *\n * There are two cases to consider:\n * 1. The packet was DNAT'ed to a device in the same bridge\n *    port group as it was received on. We can still bridge\n *    the packet.\n * 2. The packet was DNAT'ed to a different device, either\n *    a non-bridged device or another bridge port group.\n *    The packet will need to be routed.\n *\n * The correct way of distinguishing between these two cases is to\n * call ip_route_input() and to look at skb->dst->dev, which is\n * changed to the destination device if ip_route_input() succeeds.\n *\n * Let's first consider the case that ip_route_input() succeeds:\n *\n * If the output device equals the logical bridge device the packet\n * came in on, we can consider this bridging. The corresponding MAC\n * address will be obtained in br_nf_pre_routing_finish_bridge.\n * Otherwise, the packet is considered to be routed and we just\n * change the destination MAC address so that the packet will\n * later be passed up to the IP stack to be routed. For a redirected\n * packet, ip_route_input() will give back the localhost as output device,\n * which differs from the bridge device.\n *\n * Let's now consider the case that ip_route_input() fails:\n *\n * This can be because the destination address is martian, in which case\n * the packet will be dropped.\n * If IP forwarding is disabled, ip_route_input() will fail, while\n * ip_route_output_key() can return success. The source\n * address for ip_route_output_key() is set to zero, so ip_route_output_key()\n * thinks we're handling a locally generated packet and won't care\n * if IP forwarding is enabled. If the output device equals the logical bridge\n * device, we proceed as if ip_route_input() succeeded. If it differs from the\n * logical bridge port or if ip_route_output_key() fails we drop the packet.\n */\nstatic int br_nf_pre_routing_finish(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct rtable *rt;\n\tint err;\n\n\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t}\n\tnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\n\tif (dnat_took_place(skb)) {\n\t\tif ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {\n\t\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\t\t/* If err equals -EHOSTUNREACH the error is due to a\n\t\t\t * martian destination or due to the fact that\n\t\t\t * forwarding is disabled. For most martian packets,\n\t\t\t * ip_route_output_key() will fail. It won't fail for 2 types of\n\t\t\t * martian destinations: loopback destinations and destination\n\t\t\t * 0.0.0.0. In both cases the packet will be dropped because the\n\t\t\t * destination is the loopback device and not the bridge. */\n\t\t\tif (err != -EHOSTUNREACH || !in_dev || IN_DEV_FORWARD(in_dev))\n\t\t\t\tgoto free_skb;\n\n\t\t\trt = ip_route_output(dev_net(dev), iph->daddr, 0,\n\t\t\t\t\t     RT_TOS(iph->tos), 0);\n\t\t\tif (!IS_ERR(rt)) {\n\t\t\t\t/* - Bridged-and-DNAT'ed traffic doesn't\n\t\t\t\t *   require ip_forwarding. */\n\t\t\t\tif (rt->dst.dev == dev) {\n\t\t\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\t\t\tgoto bridged_dnat;\n\t\t\t\t}\n\t\t\t\tip_rt_put(rt);\n\t\t\t}\nfree_skb:\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (skb_dst(skb)->dev == dev) {\nbridged_dnat:\n\t\t\t\tskb->dev = nf_bridge->physindev;\n\t\t\t\tnf_bridge_update_protocol(skb);\n\t\t\t\tnf_bridge_push_encap_header(skb);\n\t\t\t\tNF_HOOK_THRESH(NFPROTO_BRIDGE,\n\t\t\t\t\t       NF_BR_PRE_ROUTING,\n\t\t\t\t\t       skb, skb->dev, NULL,\n\t\t\t\t\t       br_nf_pre_routing_finish_bridge,\n\t\t\t\t\t       1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(eth_hdr(skb)->h_dest, dev->dev_addr, ETH_ALEN);\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t}\n\t} else {\n\t\trt = bridge_parent_rtable(nf_bridge->physindev);\n\t\tif (!rt) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\t}\n\n\tskb->dev = nf_bridge->physindev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\n\t\t       br_handle_frame_finish, 1);\n\n\treturn 0;\n}\n\n/* Some common code for IPv4/IPv6 */\nstatic struct net_device *setup_pre_routing(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->mask |= BRNF_PKT_TYPE;\n\t}\n\n\tnf_bridge->mask |= BRNF_NF_BRIDGE_PREROUTING;\n\tnf_bridge->physindev = skb->dev;\n\tskb->dev = bridge_parent(skb->dev);\n\tif (skb->protocol == htons(ETH_P_8021Q))\n\t\tnf_bridge->mask |= BRNF_8021Q;\n\telse if (skb->protocol == htons(ETH_P_PPP_SES))\n\t\tnf_bridge->mask |= BRNF_PPPoE;\n\n\treturn skb->dev;\n}\n\n/* We only check the length. A bridge shouldn't do any hop-by-hop stuff anyway */\nstatic int check_hbh_len(struct sk_buff *skb)\n{\n\tunsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);\n\tu32 pkt_len;\n\tconst unsigned char *nh = skb_network_header(skb);\n\tint off = raw - nh;\n\tint len = (raw[1] + 1) << 3;\n\n\tif ((raw + len) - skb->data > skb_headlen(skb))\n\t\tgoto bad;\n\n\toff += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\t\tint optlen = nh[off + 1] + 2;\n\n\t\tswitch (nh[off]) {\n\t\tcase IPV6_TLV_PAD0:\n\t\t\toptlen = 1;\n\t\t\tbreak;\n\n\t\tcase IPV6_TLV_PADN:\n\t\t\tbreak;\n\n\t\tcase IPV6_TLV_JUMBO:\n\t\t\tif (nh[off + 1] != 4 || (off & 3) != 2)\n\t\t\t\tgoto bad;\n\t\t\tpkt_len = ntohl(*(__be32 *) (nh + off + 2));\n\t\t\tif (pkt_len <= IPV6_MAXPLEN ||\n\t\t\t    ipv6_hdr(skb)->payload_len)\n\t\t\t\tgoto bad;\n\t\t\tif (pkt_len > skb->len - sizeof(struct ipv6hdr))\n\t\t\t\tgoto bad;\n\t\t\tif (pskb_trim_rcsum(skb,\n\t\t\t\t\t    pkt_len + sizeof(struct ipv6hdr)))\n\t\t\t\tgoto bad;\n\t\t\tnh = skb_network_header(skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (optlen > len)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\tif (len == 0)\n\t\treturn 0;\nbad:\n\treturn -1;\n\n}\n\n/* Replicate the checks that IPv6 does on packet reception and pass the packet\n * to ip6tables, which doesn't support NAT, so things are fairly simple. */\nstatic unsigned int br_nf_pre_routing_ipv6(unsigned int hook,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const struct net_device *in,\n\t\t\t\t\t   const struct net_device *out,\n\t\t\t\t\t   int (*okfn)(struct sk_buff *))\n{\n\tstruct ipv6hdr *hdr;\n\tu32 pkt_len;\n\n\tif (skb->len < sizeof(struct ipv6hdr))\n\t\treturn NF_DROP;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\treturn NF_DROP;\n\n\thdr = ipv6_hdr(skb);\n\n\tif (hdr->version != 6)\n\t\treturn NF_DROP;\n\n\tpkt_len = ntohs(hdr->payload_len);\n\n\tif (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {\n\t\tif (pkt_len + sizeof(struct ipv6hdr) > skb->len)\n\t\t\treturn NF_DROP;\n\t\tif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\n\t\t\treturn NF_DROP;\n\t}\n\tif (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))\n\t\treturn NF_DROP;\n\n\tnf_bridge_put(skb->nf_bridge);\n\tif (!nf_bridge_alloc(skb))\n\t\treturn NF_DROP;\n\tif (!setup_pre_routing(skb))\n\t\treturn NF_DROP;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,\n\t\tbr_nf_pre_routing_finish_ipv6);\n\n\treturn NF_STOLEN;\n}\n\n/* Direct IPv6 traffic to br_nf_pre_routing_ipv6.\n * Replicate the checks that IPv4 does on packet reception.\n * Set skb->dev to the bridge device (i.e. parent of the\n * receiving device) to make netfilter happy, the REDIRECT\n * target in particular.  Save the original destination IP\n * address to be able to detect DNAT afterwards. */\nstatic unsigned int br_nf_pre_routing(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t      const struct net_device *in,\n\t\t\t\t      const struct net_device *out,\n\t\t\t\t      int (*okfn)(struct sk_buff *))\n{\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\t__u32 len = nf_bridge_encap_header_len(skb);\n\n\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\treturn NF_DROP;\n\n\tp = br_port_get_rcu(in);\n\tif (p == NULL)\n\t\treturn NF_DROP;\n\tbr = p->br;\n\n\tif (skb->protocol == htons(ETH_P_IPV6) || IS_VLAN_IPV6(skb) ||\n\t    IS_PPPOE_IPV6(skb)) {\n\t\tif (!brnf_call_ip6tables && !br->nf_call_ip6tables)\n\t\t\treturn NF_ACCEPT;\n\n\t\tnf_bridge_pull_encap_header_rcsum(skb);\n\t\treturn br_nf_pre_routing_ipv6(hook, skb, in, out, okfn);\n\t}\n\n\tif (!brnf_call_iptables && !br->nf_call_iptables)\n\t\treturn NF_ACCEPT;\n\n\tif (skb->protocol != htons(ETH_P_IP) && !IS_VLAN_IP(skb) &&\n\t    !IS_PPPOE_IP(skb))\n\t\treturn NF_ACCEPT;\n\n\tnf_bridge_pull_encap_header_rcsum(skb);\n\n\tif (br_parse_ip_options(skb))\n\t\treturn NF_DROP;\n\n\tnf_bridge_put(skb->nf_bridge);\n\tif (!nf_bridge_alloc(skb))\n\t\treturn NF_DROP;\n\tif (!setup_pre_routing(skb))\n\t\treturn NF_DROP;\n\tstore_orig_dstaddr(skb);\n\tskb->protocol = htons(ETH_P_IP);\n\n\tNF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,\n\t\tbr_nf_pre_routing_finish);\n\n\treturn NF_STOLEN;\n}\n\n\n/* PF_BRIDGE/LOCAL_IN ************************************************/\n/* The packet is locally destined, which requires a real\n * dst_entry, so detach the fake one.  On the way up, the\n * packet would pass through PRE_ROUTING again (which already\n * took place when the packet entered the bridge), but we\n * register an IPv4 PRE_ROUTING 'sabotage' hook that will\n * prevent this from happening. */\nstatic unsigned int br_nf_local_in(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t   const struct net_device *in,\n\t\t\t\t   const struct net_device *out,\n\t\t\t\t   int (*okfn)(struct sk_buff *))\n{\n\tstruct rtable *rt = skb_rtable(skb);\n\n\tif (rt && rt == bridge_parent_rtable(in))\n\t\tskb_dst_drop(skb);\n\n\treturn NF_ACCEPT;\n}\n\n/* PF_BRIDGE/FORWARD *************************************************/\nstatic int br_nf_forward_finish(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct net_device *in;\n\n\tif (skb->protocol != htons(ETH_P_ARP) && !IS_VLAN_ARP(skb)) {\n\t\tin = nf_bridge->physindev;\n\t\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t\t}\n\t\tnf_bridge_update_protocol(skb);\n\t} else {\n\t\tin = *((struct net_device **)(skb->cb));\n\t}\n\tnf_bridge_push_encap_header(skb);\n\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, in,\n\t\t       skb->dev, br_forward_finish, 1);\n\treturn 0;\n}\n\n/* This is the 'purely bridged' case.  For IP, we pass the packet to\n * netfilter with indev and outdev set to the bridge device,\n * but we are still able to filter on the 'real' indev/outdev\n * because of the physdev module. For ARP, indev and outdev are the\n * bridge ports. */\nstatic unsigned int br_nf_forward_ip(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t     const struct net_device *in,\n\t\t\t\t     const struct net_device *out,\n\t\t\t\t     int (*okfn)(struct sk_buff *))\n{\n\tstruct nf_bridge_info *nf_bridge;\n\tstruct net_device *parent;\n\tu_int8_t pf;\n\n\tif (!skb->nf_bridge)\n\t\treturn NF_ACCEPT;\n\n\t/* Need exclusive nf_bridge_info since we might have multiple\n\t * different physoutdevs. */\n\tif (!nf_bridge_unshare(skb))\n\t\treturn NF_DROP;\n\n\tparent = bridge_parent(out);\n\tif (!parent)\n\t\treturn NF_DROP;\n\n\tif (skb->protocol == htons(ETH_P_IP) || IS_VLAN_IP(skb) ||\n\t    IS_PPPOE_IP(skb))\n\t\tpf = PF_INET;\n\telse if (skb->protocol == htons(ETH_P_IPV6) || IS_VLAN_IPV6(skb) ||\n\t\t IS_PPPOE_IPV6(skb))\n\t\tpf = PF_INET6;\n\telse\n\t\treturn NF_ACCEPT;\n\n\tnf_bridge_pull_encap_header(skb);\n\n\tnf_bridge = skb->nf_bridge;\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->mask |= BRNF_PKT_TYPE;\n\t}\n\n\tif (br_parse_ip_options(skb))\n\t\treturn NF_DROP;\n\n\t/* The physdev module checks on this */\n\tnf_bridge->mask |= BRNF_BRIDGED;\n\tnf_bridge->physoutdev = skb->dev;\n\tif (pf == PF_INET)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tNF_HOOK(pf, NF_INET_FORWARD, skb, bridge_parent(in), parent,\n\t\tbr_nf_forward_finish);\n\n\treturn NF_STOLEN;\n}\n\nstatic unsigned int br_nf_forward_arp(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t      const struct net_device *in,\n\t\t\t\t      const struct net_device *out,\n\t\t\t\t      int (*okfn)(struct sk_buff *))\n{\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\tstruct net_device **d = (struct net_device **)(skb->cb);\n\n\tp = br_port_get_rcu(out);\n\tif (p == NULL)\n\t\treturn NF_ACCEPT;\n\tbr = p->br;\n\n\tif (!brnf_call_arptables && !br->nf_call_arptables)\n\t\treturn NF_ACCEPT;\n\n\tif (skb->protocol != htons(ETH_P_ARP)) {\n\t\tif (!IS_VLAN_ARP(skb))\n\t\t\treturn NF_ACCEPT;\n\t\tnf_bridge_pull_encap_header(skb);\n\t}\n\n\tif (arp_hdr(skb)->ar_pln != 4) {\n\t\tif (IS_VLAN_ARP(skb))\n\t\t\tnf_bridge_push_encap_header(skb);\n\t\treturn NF_ACCEPT;\n\t}\n\t*d = (struct net_device *)in;\n\tNF_HOOK(NFPROTO_ARP, NF_ARP_FORWARD, skb, (struct net_device *)in,\n\t\t(struct net_device *)out, br_nf_forward_finish);\n\n\treturn NF_STOLEN;\n}\n\n#if defined(CONFIG_NF_CONNTRACK_IPV4) || defined(CONFIG_NF_CONNTRACK_IPV4_MODULE)\nstatic int br_nf_dev_queue_xmit(struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&\n\t    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&\n\t    !skb_is_gso(skb)) {\n\t\tif (br_parse_ip_options(skb))\n\t\t\t/* Drop invalid packet */\n\t\t\treturn NF_DROP;\n\t\tret = ip_fragment(skb, br_dev_queue_push_xmit);\n\t} else\n\t\tret = br_dev_queue_push_xmit(skb);\n\n\treturn ret;\n}\n#else\nstatic int br_nf_dev_queue_xmit(struct sk_buff *skb)\n{\n        return br_dev_queue_push_xmit(skb);\n}\n#endif\n\n/* PF_BRIDGE/POST_ROUTING ********************************************/\nstatic unsigned int br_nf_post_routing(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t       const struct net_device *in,\n\t\t\t\t       const struct net_device *out,\n\t\t\t\t       int (*okfn)(struct sk_buff *))\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct net_device *realoutdev = bridge_parent(skb->dev);\n\tu_int8_t pf;\n\n\tif (!nf_bridge || !(nf_bridge->mask & BRNF_BRIDGED))\n\t\treturn NF_ACCEPT;\n\n\tif (!realoutdev)\n\t\treturn NF_DROP;\n\n\tif (skb->protocol == htons(ETH_P_IP) || IS_VLAN_IP(skb) ||\n\t    IS_PPPOE_IP(skb))\n\t\tpf = PF_INET;\n\telse if (skb->protocol == htons(ETH_P_IPV6) || IS_VLAN_IPV6(skb) ||\n\t\t IS_PPPOE_IPV6(skb))\n\t\tpf = PF_INET6;\n\telse\n\t\treturn NF_ACCEPT;\n\n\t/* We assume any code from br_dev_queue_push_xmit onwards doesn't care\n\t * about the value of skb->pkt_type. */\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->mask |= BRNF_PKT_TYPE;\n\t}\n\n\tnf_bridge_pull_encap_header(skb);\n\tnf_bridge_save_header(skb);\n\tif (pf == PF_INET)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tNF_HOOK(pf, NF_INET_POST_ROUTING, skb, NULL, realoutdev,\n\t\tbr_nf_dev_queue_xmit);\n\n\treturn NF_STOLEN;\n}\n\n/* IP/SABOTAGE *****************************************************/\n/* Don't hand locally destined packets to PF_INET(6)/PRE_ROUTING\n * for the second time. */\nstatic unsigned int ip_sabotage_in(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t   const struct net_device *in,\n\t\t\t\t   const struct net_device *out,\n\t\t\t\t   int (*okfn)(struct sk_buff *))\n{\n\tif (skb->nf_bridge &&\n\t    !(skb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)) {\n\t\treturn NF_STOP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\n/* For br_nf_post_routing, we need (prio = NF_BR_PRI_LAST), because\n * br_dev_queue_push_xmit is called afterwards */\nstatic struct nf_hook_ops br_nf_ops[] __read_mostly = {\n\t{\n\t\t.hook = br_nf_pre_routing,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_PRE_ROUTING,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_local_in,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_LOCAL_IN,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_forward_ip,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_FORWARD,\n\t\t.priority = NF_BR_PRI_BRNF - 1,\n\t},\n\t{\n\t\t.hook = br_nf_forward_arp,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_FORWARD,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_post_routing,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_POST_ROUTING,\n\t\t.priority = NF_BR_PRI_LAST,\n\t},\n\t{\n\t\t.hook = ip_sabotage_in,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_INET,\n\t\t.hooknum = NF_INET_PRE_ROUTING,\n\t\t.priority = NF_IP_PRI_FIRST,\n\t},\n\t{\n\t\t.hook = ip_sabotage_in,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_INET6,\n\t\t.hooknum = NF_INET_PRE_ROUTING,\n\t\t.priority = NF_IP6_PRI_FIRST,\n\t},\n};\n\n#ifdef CONFIG_SYSCTL\nstatic\nint brnf_sysctl_call_tables(ctl_table * ctl, int write,\n\t\t\t    void __user * buffer, size_t * lenp, loff_t * ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write && *(int *)(ctl->data))\n\t\t*(int *)(ctl->data) = 1;\n\treturn ret;\n}\n\nstatic ctl_table brnf_table[] = {\n\t{\n\t\t.procname\t= \"bridge-nf-call-arptables\",\n\t\t.data\t\t= &brnf_call_arptables,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-call-iptables\",\n\t\t.data\t\t= &brnf_call_iptables,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-call-ip6tables\",\n\t\t.data\t\t= &brnf_call_ip6tables,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-filter-vlan-tagged\",\n\t\t.data\t\t= &brnf_filter_vlan_tagged,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-filter-pppoe-tagged\",\n\t\t.data\t\t= &brnf_filter_pppoe_tagged,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{ }\n};\n\nstatic struct ctl_path brnf_path[] = {\n\t{ .procname = \"net\", },\n\t{ .procname = \"bridge\", },\n\t{ }\n};\n#endif\n\nint __init br_netfilter_init(void)\n{\n\tint ret;\n\n\tret = dst_entries_init(&fake_dst_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nf_register_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\n\tif (ret < 0) {\n\t\tdst_entries_destroy(&fake_dst_ops);\n\t\treturn ret;\n\t}\n#ifdef CONFIG_SYSCTL\n\tbrnf_sysctl_header = register_sysctl_paths(brnf_path, brnf_table);\n\tif (brnf_sysctl_header == NULL) {\n\t\tprintk(KERN_WARNING\n\t\t       \"br_netfilter: can't register to sysctl.\\n\");\n\t\tnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\n\t\tdst_entries_destroy(&fake_dst_ops);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\tprintk(KERN_NOTICE \"Bridge firewalling registered\\n\");\n\treturn 0;\n}\n\nvoid br_netfilter_fini(void)\n{\n\tnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\n#ifdef CONFIG_SYSCTL\n\tunregister_sysctl_table(brnf_sysctl_header);\n#endif\n\tdst_entries_destroy(&fake_dst_ops);\n}\n"], "fixing_code": ["/*\n *\tHandle firewalling\n *\tLinux ethernet bridge\n *\n *\tAuthors:\n *\tLennert Buytenhek\t\t<buytenh@gnu.org>\n *\tBart De Schuymer\t\t<bdschuym@pandora.be>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n *\tLennert dedicates this file to Kerstin Wurdinger.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_arp.h>\n#include <linux/in_route.h>\n#include <linux/inetdevice.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/route.h>\n\n#include <asm/uaccess.h>\n#include \"br_private.h\"\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#define skb_origaddr(skb)\t (((struct bridge_skb_cb *) \\\n\t\t\t\t (skb->nf_bridge->data))->daddr.ipv4)\n#define store_orig_dstaddr(skb)\t (skb_origaddr(skb) = ip_hdr(skb)->daddr)\n#define dnat_took_place(skb)\t (skb_origaddr(skb) != ip_hdr(skb)->daddr)\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table_header *brnf_sysctl_header;\nstatic int brnf_call_iptables __read_mostly = 1;\nstatic int brnf_call_ip6tables __read_mostly = 1;\nstatic int brnf_call_arptables __read_mostly = 1;\nstatic int brnf_filter_vlan_tagged __read_mostly = 0;\nstatic int brnf_filter_pppoe_tagged __read_mostly = 0;\n#else\n#define brnf_call_iptables 1\n#define brnf_call_ip6tables 1\n#define brnf_call_arptables 1\n#define brnf_filter_vlan_tagged 0\n#define brnf_filter_pppoe_tagged 0\n#endif\n\nstatic inline __be16 vlan_proto(const struct sk_buff *skb)\n{\n\tif (vlan_tx_tag_present(skb))\n\t\treturn skb->protocol;\n\telse if (skb->protocol == htons(ETH_P_8021Q))\n\t\treturn vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;\n\telse\n\t\treturn 0;\n}\n\n#define IS_VLAN_IP(skb) \\\n\t(vlan_proto(skb) == htons(ETH_P_IP) && \\\n\t brnf_filter_vlan_tagged)\n\n#define IS_VLAN_IPV6(skb) \\\n\t(vlan_proto(skb) == htons(ETH_P_IPV6) && \\\n\t brnf_filter_vlan_tagged)\n\n#define IS_VLAN_ARP(skb) \\\n\t(vlan_proto(skb) == htons(ETH_P_ARP) &&\t\\\n\t brnf_filter_vlan_tagged)\n\nstatic inline __be16 pppoe_proto(const struct sk_buff *skb)\n{\n\treturn *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +\n\t\t\t    sizeof(struct pppoe_hdr)));\n}\n\n#define IS_PPPOE_IP(skb) \\\n\t(skb->protocol == htons(ETH_P_PPP_SES) && \\\n\t pppoe_proto(skb) == htons(PPP_IP) && \\\n\t brnf_filter_pppoe_tagged)\n\n#define IS_PPPOE_IPV6(skb) \\\n\t(skb->protocol == htons(ETH_P_PPP_SES) && \\\n\t pppoe_proto(skb) == htons(PPP_IPV6) && \\\n\t brnf_filter_pppoe_tagged)\n\nstatic void fake_update_pmtu(struct dst_entry *dst, u32 mtu)\n{\n}\n\nstatic struct dst_ops fake_dst_ops = {\n\t.family =\t\tAF_INET,\n\t.protocol =\t\tcpu_to_be16(ETH_P_IP),\n\t.update_pmtu =\t\tfake_update_pmtu,\n};\n\n/*\n * Initialize bogus route table used to keep netfilter happy.\n * Currently, we fill in the PMTU entry because netfilter\n * refragmentation needs it, and the rt_flags entry because\n * ipt_REJECT needs it.  Future netfilter modules might\n * require us to fill additional fields.\n */\nvoid br_netfilter_rtable_init(struct net_bridge *br)\n{\n\tstruct rtable *rt = &br->fake_rtable;\n\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->dst.dev = br->dev;\n\trt->dst.path = &rt->dst;\n\tdst_metric_set(&rt->dst, RTAX_MTU, 1500);\n\trt->dst.flags\t= DST_NOXFRM;\n\trt->dst.ops = &fake_dst_ops;\n}\n\nstatic inline struct rtable *bridge_parent_rtable(const struct net_device *dev)\n{\n\tstruct net_bridge_port *port;\n\n\tport = br_port_get_rcu(dev);\n\treturn port ? &port->br->fake_rtable : NULL;\n}\n\nstatic inline struct net_device *bridge_parent(const struct net_device *dev)\n{\n\tstruct net_bridge_port *port;\n\n\tport = br_port_get_rcu(dev);\n\treturn port ? port->br->dev : NULL;\n}\n\nstatic inline struct nf_bridge_info *nf_bridge_alloc(struct sk_buff *skb)\n{\n\tskb->nf_bridge = kzalloc(sizeof(struct nf_bridge_info), GFP_ATOMIC);\n\tif (likely(skb->nf_bridge))\n\t\tatomic_set(&(skb->nf_bridge->use), 1);\n\n\treturn skb->nf_bridge;\n}\n\nstatic inline struct nf_bridge_info *nf_bridge_unshare(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\n\tif (atomic_read(&nf_bridge->use) > 1) {\n\t\tstruct nf_bridge_info *tmp = nf_bridge_alloc(skb);\n\n\t\tif (tmp) {\n\t\t\tmemcpy(tmp, nf_bridge, sizeof(struct nf_bridge_info));\n\t\t\tatomic_set(&tmp->use, 1);\n\t\t}\n\t\tnf_bridge_put(nf_bridge);\n\t\tnf_bridge = tmp;\n\t}\n\treturn nf_bridge;\n}\n\nstatic inline void nf_bridge_push_encap_header(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_push(skb, len);\n\tskb->network_header -= len;\n}\n\nstatic inline void nf_bridge_pull_encap_header(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_pull(skb, len);\n\tskb->network_header += len;\n}\n\nstatic inline void nf_bridge_pull_encap_header_rcsum(struct sk_buff *skb)\n{\n\tunsigned int len = nf_bridge_encap_header_len(skb);\n\n\tskb_pull_rcsum(skb, len);\n\tskb->network_header += len;\n}\n\nstatic inline void nf_bridge_save_header(struct sk_buff *skb)\n{\n\tint header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);\n\n\tskb_copy_from_linear_data_offset(skb, -header_size,\n\t\t\t\t\t skb->nf_bridge->data, header_size);\n}\n\nstatic inline void nf_bridge_update_protocol(struct sk_buff *skb)\n{\n\tif (skb->nf_bridge->mask & BRNF_8021Q)\n\t\tskb->protocol = htons(ETH_P_8021Q);\n\telse if (skb->nf_bridge->mask & BRNF_PPPoE)\n\t\tskb->protocol = htons(ETH_P_PPP_SES);\n}\n\n/* When handing a packet over to the IP layer\n * check whether we have a skb that is in the\n * expected format\n */\n\nstatic int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t/* Basic sanity checks */\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\tif (iph->ihl == 5)\n\t\treturn 0;\n\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t/* Check correct handling of SRR option */\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}\n\n/* Fill in the header for fragmented IP packets handled by\n * the IPv4 connection tracking code.\n */\nint nf_bridge_copy_header(struct sk_buff *skb)\n{\n\tint err;\n\tunsigned int header_size;\n\n\tnf_bridge_update_protocol(skb);\n\theader_size = ETH_HLEN + nf_bridge_encap_header_len(skb);\n\terr = skb_cow_head(skb, header_size);\n\tif (err)\n\t\treturn err;\n\n\tskb_copy_to_linear_data_offset(skb, -header_size,\n\t\t\t\t       skb->nf_bridge->data, header_size);\n\t__skb_push(skb, nf_bridge_encap_header_len(skb));\n\treturn 0;\n}\n\n/* PF_BRIDGE/PRE_ROUTING *********************************************/\n/* Undo the changes made for ip6tables PREROUTING and continue the\n * bridge PRE_ROUTING hook. */\nstatic int br_nf_pre_routing_finish_ipv6(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct rtable *rt;\n\n\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t}\n\tnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\n\n\trt = bridge_parent_rtable(nf_bridge->physindev);\n\tif (!rt) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\tskb_dst_set_noref(skb, &rt->dst);\n\n\tskb->dev = nf_bridge->physindev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\n\t\t       br_handle_frame_finish, 1);\n\n\treturn 0;\n}\n\n/* Obtain the correct destination MAC address, while preserving the original\n * source MAC address. If we already know this address, we just copy it. If we\n * don't, we use the neighbour framework to find out. In both cases, we make\n * sure that br_handle_frame_finish() is called afterwards.\n */\nstatic int br_nf_pre_routing_finish_bridge(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct dst_entry *dst;\n\n\tskb->dev = bridge_parent(skb->dev);\n\tif (!skb->dev)\n\t\tgoto free_skb;\n\tdst = skb_dst(skb);\n\tif (dst->hh) {\n\t\tneigh_hh_bridge(dst->hh, skb);\n\t\tskb->dev = nf_bridge->physindev;\n\t\treturn br_handle_frame_finish(skb);\n\t} else if (dst->neighbour) {\n\t\t/* the neighbour function below overwrites the complete\n\t\t * MAC header, so we save the Ethernet source address and\n\t\t * protocol number. */\n\t\tskb_copy_from_linear_data_offset(skb, -(ETH_HLEN-ETH_ALEN), skb->nf_bridge->data, ETH_HLEN-ETH_ALEN);\n\t\t/* tell br_dev_xmit to continue with forwarding */\n\t\tnf_bridge->mask |= BRNF_BRIDGED_DNAT;\n\t\treturn dst->neighbour->output(skb);\n\t}\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/* This requires some explaining. If DNAT has taken place,\n * we will need to fix up the destination Ethernet address.\n *\n * There are two cases to consider:\n * 1. The packet was DNAT'ed to a device in the same bridge\n *    port group as it was received on. We can still bridge\n *    the packet.\n * 2. The packet was DNAT'ed to a different device, either\n *    a non-bridged device or another bridge port group.\n *    The packet will need to be routed.\n *\n * The correct way of distinguishing between these two cases is to\n * call ip_route_input() and to look at skb->dst->dev, which is\n * changed to the destination device if ip_route_input() succeeds.\n *\n * Let's first consider the case that ip_route_input() succeeds:\n *\n * If the output device equals the logical bridge device the packet\n * came in on, we can consider this bridging. The corresponding MAC\n * address will be obtained in br_nf_pre_routing_finish_bridge.\n * Otherwise, the packet is considered to be routed and we just\n * change the destination MAC address so that the packet will\n * later be passed up to the IP stack to be routed. For a redirected\n * packet, ip_route_input() will give back the localhost as output device,\n * which differs from the bridge device.\n *\n * Let's now consider the case that ip_route_input() fails:\n *\n * This can be because the destination address is martian, in which case\n * the packet will be dropped.\n * If IP forwarding is disabled, ip_route_input() will fail, while\n * ip_route_output_key() can return success. The source\n * address for ip_route_output_key() is set to zero, so ip_route_output_key()\n * thinks we're handling a locally generated packet and won't care\n * if IP forwarding is enabled. If the output device equals the logical bridge\n * device, we proceed as if ip_route_input() succeeded. If it differs from the\n * logical bridge port or if ip_route_output_key() fails we drop the packet.\n */\nstatic int br_nf_pre_routing_finish(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct rtable *rt;\n\tint err;\n\n\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t}\n\tnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\n\tif (dnat_took_place(skb)) {\n\t\tif ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {\n\t\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\t\t/* If err equals -EHOSTUNREACH the error is due to a\n\t\t\t * martian destination or due to the fact that\n\t\t\t * forwarding is disabled. For most martian packets,\n\t\t\t * ip_route_output_key() will fail. It won't fail for 2 types of\n\t\t\t * martian destinations: loopback destinations and destination\n\t\t\t * 0.0.0.0. In both cases the packet will be dropped because the\n\t\t\t * destination is the loopback device and not the bridge. */\n\t\t\tif (err != -EHOSTUNREACH || !in_dev || IN_DEV_FORWARD(in_dev))\n\t\t\t\tgoto free_skb;\n\n\t\t\trt = ip_route_output(dev_net(dev), iph->daddr, 0,\n\t\t\t\t\t     RT_TOS(iph->tos), 0);\n\t\t\tif (!IS_ERR(rt)) {\n\t\t\t\t/* - Bridged-and-DNAT'ed traffic doesn't\n\t\t\t\t *   require ip_forwarding. */\n\t\t\t\tif (rt->dst.dev == dev) {\n\t\t\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\t\t\tgoto bridged_dnat;\n\t\t\t\t}\n\t\t\t\tip_rt_put(rt);\n\t\t\t}\nfree_skb:\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (skb_dst(skb)->dev == dev) {\nbridged_dnat:\n\t\t\t\tskb->dev = nf_bridge->physindev;\n\t\t\t\tnf_bridge_update_protocol(skb);\n\t\t\t\tnf_bridge_push_encap_header(skb);\n\t\t\t\tNF_HOOK_THRESH(NFPROTO_BRIDGE,\n\t\t\t\t\t       NF_BR_PRE_ROUTING,\n\t\t\t\t\t       skb, skb->dev, NULL,\n\t\t\t\t\t       br_nf_pre_routing_finish_bridge,\n\t\t\t\t\t       1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(eth_hdr(skb)->h_dest, dev->dev_addr, ETH_ALEN);\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t}\n\t} else {\n\t\trt = bridge_parent_rtable(nf_bridge->physindev);\n\t\tif (!rt) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\t}\n\n\tskb->dev = nf_bridge->physindev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\n\t\t       br_handle_frame_finish, 1);\n\n\treturn 0;\n}\n\n/* Some common code for IPv4/IPv6 */\nstatic struct net_device *setup_pre_routing(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->mask |= BRNF_PKT_TYPE;\n\t}\n\n\tnf_bridge->mask |= BRNF_NF_BRIDGE_PREROUTING;\n\tnf_bridge->physindev = skb->dev;\n\tskb->dev = bridge_parent(skb->dev);\n\tif (skb->protocol == htons(ETH_P_8021Q))\n\t\tnf_bridge->mask |= BRNF_8021Q;\n\telse if (skb->protocol == htons(ETH_P_PPP_SES))\n\t\tnf_bridge->mask |= BRNF_PPPoE;\n\n\treturn skb->dev;\n}\n\n/* We only check the length. A bridge shouldn't do any hop-by-hop stuff anyway */\nstatic int check_hbh_len(struct sk_buff *skb)\n{\n\tunsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);\n\tu32 pkt_len;\n\tconst unsigned char *nh = skb_network_header(skb);\n\tint off = raw - nh;\n\tint len = (raw[1] + 1) << 3;\n\n\tif ((raw + len) - skb->data > skb_headlen(skb))\n\t\tgoto bad;\n\n\toff += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\t\tint optlen = nh[off + 1] + 2;\n\n\t\tswitch (nh[off]) {\n\t\tcase IPV6_TLV_PAD0:\n\t\t\toptlen = 1;\n\t\t\tbreak;\n\n\t\tcase IPV6_TLV_PADN:\n\t\t\tbreak;\n\n\t\tcase IPV6_TLV_JUMBO:\n\t\t\tif (nh[off + 1] != 4 || (off & 3) != 2)\n\t\t\t\tgoto bad;\n\t\t\tpkt_len = ntohl(*(__be32 *) (nh + off + 2));\n\t\t\tif (pkt_len <= IPV6_MAXPLEN ||\n\t\t\t    ipv6_hdr(skb)->payload_len)\n\t\t\t\tgoto bad;\n\t\t\tif (pkt_len > skb->len - sizeof(struct ipv6hdr))\n\t\t\t\tgoto bad;\n\t\t\tif (pskb_trim_rcsum(skb,\n\t\t\t\t\t    pkt_len + sizeof(struct ipv6hdr)))\n\t\t\t\tgoto bad;\n\t\t\tnh = skb_network_header(skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (optlen > len)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\tif (len == 0)\n\t\treturn 0;\nbad:\n\treturn -1;\n\n}\n\n/* Replicate the checks that IPv6 does on packet reception and pass the packet\n * to ip6tables, which doesn't support NAT, so things are fairly simple. */\nstatic unsigned int br_nf_pre_routing_ipv6(unsigned int hook,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const struct net_device *in,\n\t\t\t\t\t   const struct net_device *out,\n\t\t\t\t\t   int (*okfn)(struct sk_buff *))\n{\n\tstruct ipv6hdr *hdr;\n\tu32 pkt_len;\n\n\tif (skb->len < sizeof(struct ipv6hdr))\n\t\treturn NF_DROP;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\treturn NF_DROP;\n\n\thdr = ipv6_hdr(skb);\n\n\tif (hdr->version != 6)\n\t\treturn NF_DROP;\n\n\tpkt_len = ntohs(hdr->payload_len);\n\n\tif (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {\n\t\tif (pkt_len + sizeof(struct ipv6hdr) > skb->len)\n\t\t\treturn NF_DROP;\n\t\tif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\n\t\t\treturn NF_DROP;\n\t}\n\tif (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))\n\t\treturn NF_DROP;\n\n\tnf_bridge_put(skb->nf_bridge);\n\tif (!nf_bridge_alloc(skb))\n\t\treturn NF_DROP;\n\tif (!setup_pre_routing(skb))\n\t\treturn NF_DROP;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,\n\t\tbr_nf_pre_routing_finish_ipv6);\n\n\treturn NF_STOLEN;\n}\n\n/* Direct IPv6 traffic to br_nf_pre_routing_ipv6.\n * Replicate the checks that IPv4 does on packet reception.\n * Set skb->dev to the bridge device (i.e. parent of the\n * receiving device) to make netfilter happy, the REDIRECT\n * target in particular.  Save the original destination IP\n * address to be able to detect DNAT afterwards. */\nstatic unsigned int br_nf_pre_routing(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t      const struct net_device *in,\n\t\t\t\t      const struct net_device *out,\n\t\t\t\t      int (*okfn)(struct sk_buff *))\n{\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\t__u32 len = nf_bridge_encap_header_len(skb);\n\n\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\treturn NF_DROP;\n\n\tp = br_port_get_rcu(in);\n\tif (p == NULL)\n\t\treturn NF_DROP;\n\tbr = p->br;\n\n\tif (skb->protocol == htons(ETH_P_IPV6) || IS_VLAN_IPV6(skb) ||\n\t    IS_PPPOE_IPV6(skb)) {\n\t\tif (!brnf_call_ip6tables && !br->nf_call_ip6tables)\n\t\t\treturn NF_ACCEPT;\n\n\t\tnf_bridge_pull_encap_header_rcsum(skb);\n\t\treturn br_nf_pre_routing_ipv6(hook, skb, in, out, okfn);\n\t}\n\n\tif (!brnf_call_iptables && !br->nf_call_iptables)\n\t\treturn NF_ACCEPT;\n\n\tif (skb->protocol != htons(ETH_P_IP) && !IS_VLAN_IP(skb) &&\n\t    !IS_PPPOE_IP(skb))\n\t\treturn NF_ACCEPT;\n\n\tnf_bridge_pull_encap_header_rcsum(skb);\n\n\tif (br_parse_ip_options(skb))\n\t\treturn NF_DROP;\n\n\tnf_bridge_put(skb->nf_bridge);\n\tif (!nf_bridge_alloc(skb))\n\t\treturn NF_DROP;\n\tif (!setup_pre_routing(skb))\n\t\treturn NF_DROP;\n\tstore_orig_dstaddr(skb);\n\tskb->protocol = htons(ETH_P_IP);\n\n\tNF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,\n\t\tbr_nf_pre_routing_finish);\n\n\treturn NF_STOLEN;\n}\n\n\n/* PF_BRIDGE/LOCAL_IN ************************************************/\n/* The packet is locally destined, which requires a real\n * dst_entry, so detach the fake one.  On the way up, the\n * packet would pass through PRE_ROUTING again (which already\n * took place when the packet entered the bridge), but we\n * register an IPv4 PRE_ROUTING 'sabotage' hook that will\n * prevent this from happening. */\nstatic unsigned int br_nf_local_in(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t   const struct net_device *in,\n\t\t\t\t   const struct net_device *out,\n\t\t\t\t   int (*okfn)(struct sk_buff *))\n{\n\tstruct rtable *rt = skb_rtable(skb);\n\n\tif (rt && rt == bridge_parent_rtable(in))\n\t\tskb_dst_drop(skb);\n\n\treturn NF_ACCEPT;\n}\n\n/* PF_BRIDGE/FORWARD *************************************************/\nstatic int br_nf_forward_finish(struct sk_buff *skb)\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct net_device *in;\n\n\tif (skb->protocol != htons(ETH_P_ARP) && !IS_VLAN_ARP(skb)) {\n\t\tin = nf_bridge->physindev;\n\t\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t\t}\n\t\tnf_bridge_update_protocol(skb);\n\t} else {\n\t\tin = *((struct net_device **)(skb->cb));\n\t}\n\tnf_bridge_push_encap_header(skb);\n\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, in,\n\t\t       skb->dev, br_forward_finish, 1);\n\treturn 0;\n}\n\n/* This is the 'purely bridged' case.  For IP, we pass the packet to\n * netfilter with indev and outdev set to the bridge device,\n * but we are still able to filter on the 'real' indev/outdev\n * because of the physdev module. For ARP, indev and outdev are the\n * bridge ports. */\nstatic unsigned int br_nf_forward_ip(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t     const struct net_device *in,\n\t\t\t\t     const struct net_device *out,\n\t\t\t\t     int (*okfn)(struct sk_buff *))\n{\n\tstruct nf_bridge_info *nf_bridge;\n\tstruct net_device *parent;\n\tu_int8_t pf;\n\n\tif (!skb->nf_bridge)\n\t\treturn NF_ACCEPT;\n\n\t/* Need exclusive nf_bridge_info since we might have multiple\n\t * different physoutdevs. */\n\tif (!nf_bridge_unshare(skb))\n\t\treturn NF_DROP;\n\n\tparent = bridge_parent(out);\n\tif (!parent)\n\t\treturn NF_DROP;\n\n\tif (skb->protocol == htons(ETH_P_IP) || IS_VLAN_IP(skb) ||\n\t    IS_PPPOE_IP(skb))\n\t\tpf = PF_INET;\n\telse if (skb->protocol == htons(ETH_P_IPV6) || IS_VLAN_IPV6(skb) ||\n\t\t IS_PPPOE_IPV6(skb))\n\t\tpf = PF_INET6;\n\telse\n\t\treturn NF_ACCEPT;\n\n\tnf_bridge_pull_encap_header(skb);\n\n\tnf_bridge = skb->nf_bridge;\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->mask |= BRNF_PKT_TYPE;\n\t}\n\n\tif (br_parse_ip_options(skb))\n\t\treturn NF_DROP;\n\n\t/* The physdev module checks on this */\n\tnf_bridge->mask |= BRNF_BRIDGED;\n\tnf_bridge->physoutdev = skb->dev;\n\tif (pf == PF_INET)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tNF_HOOK(pf, NF_INET_FORWARD, skb, bridge_parent(in), parent,\n\t\tbr_nf_forward_finish);\n\n\treturn NF_STOLEN;\n}\n\nstatic unsigned int br_nf_forward_arp(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t      const struct net_device *in,\n\t\t\t\t      const struct net_device *out,\n\t\t\t\t      int (*okfn)(struct sk_buff *))\n{\n\tstruct net_bridge_port *p;\n\tstruct net_bridge *br;\n\tstruct net_device **d = (struct net_device **)(skb->cb);\n\n\tp = br_port_get_rcu(out);\n\tif (p == NULL)\n\t\treturn NF_ACCEPT;\n\tbr = p->br;\n\n\tif (!brnf_call_arptables && !br->nf_call_arptables)\n\t\treturn NF_ACCEPT;\n\n\tif (skb->protocol != htons(ETH_P_ARP)) {\n\t\tif (!IS_VLAN_ARP(skb))\n\t\t\treturn NF_ACCEPT;\n\t\tnf_bridge_pull_encap_header(skb);\n\t}\n\n\tif (arp_hdr(skb)->ar_pln != 4) {\n\t\tif (IS_VLAN_ARP(skb))\n\t\t\tnf_bridge_push_encap_header(skb);\n\t\treturn NF_ACCEPT;\n\t}\n\t*d = (struct net_device *)in;\n\tNF_HOOK(NFPROTO_ARP, NF_ARP_FORWARD, skb, (struct net_device *)in,\n\t\t(struct net_device *)out, br_nf_forward_finish);\n\n\treturn NF_STOLEN;\n}\n\n#if defined(CONFIG_NF_CONNTRACK_IPV4) || defined(CONFIG_NF_CONNTRACK_IPV4_MODULE)\nstatic int br_nf_dev_queue_xmit(struct sk_buff *skb)\n{\n\tint ret;\n\n\tif (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&\n\t    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&\n\t    !skb_is_gso(skb)) {\n\t\tif (br_parse_ip_options(skb))\n\t\t\t/* Drop invalid packet */\n\t\t\treturn NF_DROP;\n\t\tret = ip_fragment(skb, br_dev_queue_push_xmit);\n\t} else\n\t\tret = br_dev_queue_push_xmit(skb);\n\n\treturn ret;\n}\n#else\nstatic int br_nf_dev_queue_xmit(struct sk_buff *skb)\n{\n        return br_dev_queue_push_xmit(skb);\n}\n#endif\n\n/* PF_BRIDGE/POST_ROUTING ********************************************/\nstatic unsigned int br_nf_post_routing(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t       const struct net_device *in,\n\t\t\t\t       const struct net_device *out,\n\t\t\t\t       int (*okfn)(struct sk_buff *))\n{\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct net_device *realoutdev = bridge_parent(skb->dev);\n\tu_int8_t pf;\n\n\tif (!nf_bridge || !(nf_bridge->mask & BRNF_BRIDGED))\n\t\treturn NF_ACCEPT;\n\n\tif (!realoutdev)\n\t\treturn NF_DROP;\n\n\tif (skb->protocol == htons(ETH_P_IP) || IS_VLAN_IP(skb) ||\n\t    IS_PPPOE_IP(skb))\n\t\tpf = PF_INET;\n\telse if (skb->protocol == htons(ETH_P_IPV6) || IS_VLAN_IPV6(skb) ||\n\t\t IS_PPPOE_IPV6(skb))\n\t\tpf = PF_INET6;\n\telse\n\t\treturn NF_ACCEPT;\n\n\t/* We assume any code from br_dev_queue_push_xmit onwards doesn't care\n\t * about the value of skb->pkt_type. */\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tnf_bridge->mask |= BRNF_PKT_TYPE;\n\t}\n\n\tnf_bridge_pull_encap_header(skb);\n\tnf_bridge_save_header(skb);\n\tif (pf == PF_INET)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tNF_HOOK(pf, NF_INET_POST_ROUTING, skb, NULL, realoutdev,\n\t\tbr_nf_dev_queue_xmit);\n\n\treturn NF_STOLEN;\n}\n\n/* IP/SABOTAGE *****************************************************/\n/* Don't hand locally destined packets to PF_INET(6)/PRE_ROUTING\n * for the second time. */\nstatic unsigned int ip_sabotage_in(unsigned int hook, struct sk_buff *skb,\n\t\t\t\t   const struct net_device *in,\n\t\t\t\t   const struct net_device *out,\n\t\t\t\t   int (*okfn)(struct sk_buff *))\n{\n\tif (skb->nf_bridge &&\n\t    !(skb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)) {\n\t\treturn NF_STOP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\n/* For br_nf_post_routing, we need (prio = NF_BR_PRI_LAST), because\n * br_dev_queue_push_xmit is called afterwards */\nstatic struct nf_hook_ops br_nf_ops[] __read_mostly = {\n\t{\n\t\t.hook = br_nf_pre_routing,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_PRE_ROUTING,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_local_in,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_LOCAL_IN,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_forward_ip,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_FORWARD,\n\t\t.priority = NF_BR_PRI_BRNF - 1,\n\t},\n\t{\n\t\t.hook = br_nf_forward_arp,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_FORWARD,\n\t\t.priority = NF_BR_PRI_BRNF,\n\t},\n\t{\n\t\t.hook = br_nf_post_routing,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_BRIDGE,\n\t\t.hooknum = NF_BR_POST_ROUTING,\n\t\t.priority = NF_BR_PRI_LAST,\n\t},\n\t{\n\t\t.hook = ip_sabotage_in,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_INET,\n\t\t.hooknum = NF_INET_PRE_ROUTING,\n\t\t.priority = NF_IP_PRI_FIRST,\n\t},\n\t{\n\t\t.hook = ip_sabotage_in,\n\t\t.owner = THIS_MODULE,\n\t\t.pf = PF_INET6,\n\t\t.hooknum = NF_INET_PRE_ROUTING,\n\t\t.priority = NF_IP6_PRI_FIRST,\n\t},\n};\n\n#ifdef CONFIG_SYSCTL\nstatic\nint brnf_sysctl_call_tables(ctl_table * ctl, int write,\n\t\t\t    void __user * buffer, size_t * lenp, loff_t * ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write && *(int *)(ctl->data))\n\t\t*(int *)(ctl->data) = 1;\n\treturn ret;\n}\n\nstatic ctl_table brnf_table[] = {\n\t{\n\t\t.procname\t= \"bridge-nf-call-arptables\",\n\t\t.data\t\t= &brnf_call_arptables,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-call-iptables\",\n\t\t.data\t\t= &brnf_call_iptables,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-call-ip6tables\",\n\t\t.data\t\t= &brnf_call_ip6tables,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-filter-vlan-tagged\",\n\t\t.data\t\t= &brnf_filter_vlan_tagged,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{\n\t\t.procname\t= \"bridge-nf-filter-pppoe-tagged\",\n\t\t.data\t\t= &brnf_filter_pppoe_tagged,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= brnf_sysctl_call_tables,\n\t},\n\t{ }\n};\n\nstatic struct ctl_path brnf_path[] = {\n\t{ .procname = \"net\", },\n\t{ .procname = \"bridge\", },\n\t{ }\n};\n#endif\n\nint __init br_netfilter_init(void)\n{\n\tint ret;\n\n\tret = dst_entries_init(&fake_dst_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nf_register_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\n\tif (ret < 0) {\n\t\tdst_entries_destroy(&fake_dst_ops);\n\t\treturn ret;\n\t}\n#ifdef CONFIG_SYSCTL\n\tbrnf_sysctl_header = register_sysctl_paths(brnf_path, brnf_table);\n\tif (brnf_sysctl_header == NULL) {\n\t\tprintk(KERN_WARNING\n\t\t       \"br_netfilter: can't register to sysctl.\\n\");\n\t\tnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\n\t\tdst_entries_destroy(&fake_dst_ops);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\tprintk(KERN_NOTICE \"Bridge firewalling registered\\n\");\n\treturn 0;\n}\n\nvoid br_netfilter_fini(void)\n{\n\tnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\n#ifdef CONFIG_SYSCTL\n\tunregister_sysctl_table(brnf_sysctl_header);\n#endif\n\tdst_entries_destroy(&fake_dst_ops);\n}\n"], "filenames": ["net/bridge/br_netfilter.c"], "buggy_code_start_loc": [252], "buggy_code_end_loc": [257], "fixing_code_start_loc": [252], "fixing_code_end_loc": [254], "type": "CWE-665", "message": "The br_parse_ip_options function in net/bridge/br_netfilter.c in the Linux kernel before 2.6.39 does not properly initialize a certain data structure, which allows remote attackers to cause a denial of service by leveraging connectivity to a network interface that uses an Ethernet bridge device.", "other": {"cve": {"id": "CVE-2011-4087", "sourceIdentifier": "secalert@redhat.com", "published": "2013-06-08T13:05:55.210", "lastModified": "2020-07-27T19:57:08.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The br_parse_ip_options function in net/bridge/br_netfilter.c in the Linux kernel before 2.6.39 does not properly initialize a certain data structure, which allows remote attackers to cause a denial of service by leveraging connectivity to a network interface that uses an Ethernet bridge device."}, {"lang": "es", "value": "La funci\u00f3n br_parse_ip_options en net/bridge/br_netfilter.c de los kernel Linux anteriores a v2.6.39 no inicia adecuadamente cierta estructura de datos, permitiendo que atacantes remotos provoquen denegaciones de servicio mediante la indicaci\u00f3n de conexi\u00f3n a un interfaz de red que usa un dispositivo bridge Ethernet."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39", "matchCriteriaId": "176353CE-F17E-4776-AD9F-19014DA75B76"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=f8e9881c2aef1e982e5abc25c046820cd0b7cf64", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/10/28/14", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64"}}