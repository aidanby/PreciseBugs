{"buggy_code": ["# frozen_string_literal: true\n\nclass FinalDestination\n  module SSRFDetector\n    class DisallowedIpError < SocketError\n    end\n    class LookupFailedError < SocketError\n    end\n\n    def self.standard_private_ranges\n      @private_ranges ||= [\n        IPAddr.new(\"0.0.0.0/8\"),\n        IPAddr.new(\"127.0.0.1\"),\n        IPAddr.new(\"172.16.0.0/12\"),\n        IPAddr.new(\"192.168.0.0/16\"),\n        IPAddr.new(\"10.0.0.0/8\"),\n        IPAddr.new(\"::1\"),\n        IPAddr.new(\"fc00::/7\"),\n        IPAddr.new(\"fe80::/10\"),\n      ]\n    end\n\n    def self.blocked_ip_blocks\n      SiteSetting\n        .blocked_ip_blocks\n        .split(/[|\\n]/)\n        .filter_map do |r|\n          IPAddr.new(r.strip)\n        rescue IPAddr::InvalidAddressError\n          nil\n        end\n    end\n\n    def self.allowed_internal_hosts\n      hosts =\n        [\n          SiteSetting.Upload.s3_cdn_url,\n          GlobalSetting.try(:cdn_url),\n          Discourse.base_url_no_prefix,\n        ].filter_map do |url|\n          URI.parse(url).hostname if url\n        rescue URI::Error\n          nil\n        end\n\n      hosts += SiteSetting.allowed_internal_hosts.split(/[|\\n]/).filter_map { |h| h.strip.presence }\n\n      hosts\n    end\n\n    def self.host_bypasses_checks?(hostname)\n      allowed_internal_hosts.any? { |h| h.downcase == hostname.downcase }\n    end\n\n    def self.ip_allowed?(ip)\n      ip = ip.is_a?(IPAddr) ? ip : IPAddr.new(ip)\n\n      if ip_in_ranges?(ip, blocked_ip_blocks) || ip_in_ranges?(ip, standard_private_ranges)\n        return false\n      end\n\n      true\n    end\n\n    def self.lookup_and_filter_ips(name, timeout: nil)\n      begin\n        ips = lookup_ips(name, timeout: timeout)\n      rescue SocketError\n        raise LookupFailedError, \"FinalDestination: lookup failed\"\n      end\n\n      return ips if host_bypasses_checks?(name)\n\n      ips.filter! { |ip| FinalDestination::SSRFDetector.ip_allowed?(ip) }\n\n      raise DisallowedIpError, \"FinalDestination: all resolved IPs were disallowed\" if ips.empty?\n\n      ips\n    end\n\n    def self.allow_ip_lookups_in_test!\n      @allow_ip_lookups_in_test = true\n    end\n\n    def self.disallow_ip_lookups_in_test!\n      @allow_ip_lookups_in_test = false\n    end\n\n    private\n\n    def self.ip_in_ranges?(ip, ranges)\n      ranges.any? { |r| r === ip }\n    end\n\n    def self.lookup_ips(name, timeout: nil)\n      if Rails.env.test? && !@allow_ip_lookups_in_test\n        [\"1.2.3.4\"]\n      else\n        FinalDestination::Resolver.lookup(name, timeout: timeout)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe FinalDestination::SSRFDetector do\n  describe \"site setting parsing\" do\n    it \"can parse the blocked_ip_blocks and allowed_internal_hosts settings when the delimiter is pipe\" do\n      SiteSetting.blocked_ip_blocks = \"13.134.89.0/24|73.234.19.0/30\\n\"\n      SiteSetting.allowed_internal_hosts = \"awesomesauce.com\\n|goodbye.net\"\n\n      expect(subject.blocked_ip_blocks).to eq(%w[13.134.89.0/24 73.234.19.0/30])\n      expect(subject.allowed_internal_hosts).to eq(\n        [\n          \"test.localhost\", # Discourse.base_url\n          \"awesomesauce.com\",\n          \"goodbye.net\",\n        ],\n      )\n    end\n\n    it \"can parse the blocked_ip_blocks and allowed_internal_hosts settings when the delimiter is newline\" do\n      SiteSetting.blocked_ip_blocks = \"13.134.89.0/24\\n73.234.19.0/30\\n\\n\"\n      SiteSetting.allowed_internal_hosts = \"awesomesauce.com\\n\\ngoodbye.net\\n\\n\"\n\n      expect(subject.blocked_ip_blocks).to eq(%w[13.134.89.0/24 73.234.19.0/30])\n      expect(subject.allowed_internal_hosts).to eq(\n        [\n          \"test.localhost\", # Discourse.base_url\n          \"awesomesauce.com\",\n          \"goodbye.net\",\n        ],\n      )\n    end\n\n    it \"ignores invalid IP blocks\" do\n      SiteSetting.blocked_ip_blocks = \"2001:abc:de::/48|notanip\"\n      expect(subject.blocked_ip_blocks).to eq(%w[2001:abc:de::/48])\n    end\n  end\n\n  describe \".ip_allowed?\" do\n    it \"returns false for blocked IPs\" do\n      SiteSetting.blocked_ip_blocks = \"98.0.0.0/8|78.13.47.0/24|9001:82f3::/32\"\n      expect(subject.ip_allowed?(\"98.23.19.111\")).to eq(false)\n      expect(subject.ip_allowed?(\"9001:82f3:8873::3\")).to eq(false)\n    end\n\n    it \"returns false for standard internal IPs\" do\n      expect(subject.ip_allowed?(\"172.31.100.31\")).to eq(false)\n      expect(subject.ip_allowed?(\"fd02:77fa:ffea::f\")).to eq(false)\n    end\n  end\n\n  describe \".host_bypasses_checks?\" do\n    it \"returns true for URLs when allowed_internal_hosts allows the host\" do\n      SiteSetting.allowed_internal_hosts = \"allowedhost1.com|allowedhost2.com\"\n      expect(subject.host_bypasses_checks?(\"allowedhost1.com\")).to eq(true)\n      expect(subject.host_bypasses_checks?(\"allowedhost2.com\")).to eq(true)\n    end\n\n    it \"returns false for other hosts\" do\n      expect(subject.host_bypasses_checks?(\"otherhost.com\")).to eq(false)\n    end\n\n    it \"returns true for the base uri\" do\n      SiteSetting.force_hostname = \"final-test.example.com\"\n      expect(subject.host_bypasses_checks?(\"final-test.example.com\")).to eq(true)\n    end\n\n    it \"returns true for the S3 CDN url\" do\n      SiteSetting.enable_s3_uploads = true\n      SiteSetting.s3_cdn_url = \"https://s3.example.com\"\n      expect(subject.host_bypasses_checks?(\"s3.example.com\")).to eq(true)\n    end\n\n    it \"returns true for the CDN url\" do\n      GlobalSetting.stubs(:cdn_url).returns(\"https://cdn.example.com/discourse\")\n      expect(subject.host_bypasses_checks?(\"cdn.example.com\")).to eq(true)\n    end\n  end\n\n  describe \".lookup_and_filter_ips\" do\n    it \"returns a fake response in tests\" do\n      expect(subject.lookup_and_filter_ips(\"example.com\")).to eq([\"1.2.3.4\"])\n    end\n\n    it \"correctly filters private and blocked IPs\" do\n      SiteSetting.blocked_ip_blocks = \"9.10.11.12/24\"\n      subject.stubs(:lookup_ips).returns(%w[127.0.0.1 5.6.7.8 9.10.11.12])\n      expect(subject.lookup_and_filter_ips(\"example.com\")).to eq([\"5.6.7.8\"])\n    end\n\n    it \"raises an exception if all IPs are blocked\" do\n      subject.stubs(:lookup_ips).returns([\"127.0.0.1\"])\n      expect { subject.lookup_and_filter_ips(\"example.com\") }.to raise_error(\n        subject::DisallowedIpError,\n      )\n    end\n\n    it \"raises an exception if lookup fails\" do\n      subject.stubs(:lookup_ips).raises(SocketError)\n      expect { subject.lookup_and_filter_ips(\"example.com\") }.to raise_error(\n        subject::LookupFailedError,\n      )\n    end\n\n    it \"bypasses filtering for allowlisted hosts\" do\n      SiteSetting.allowed_internal_hosts = \"example.com\"\n      subject.stubs(:lookup_ips).returns([\"127.0.0.1\"])\n      expect(subject.lookup_and_filter_ips(\"example.com\")).to eq([\"127.0.0.1\"])\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass FinalDestination\n  module SSRFDetector\n    class DisallowedIpError < SocketError\n    end\n    class LookupFailedError < SocketError\n    end\n\n    # This is a list of private IPv4 IP ranges that are not allowed to be globally reachable as given by\n    # https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml.\n    PRIVATE_IPV4_RANGES = [\n      IPAddr.new(\"0.0.0.0/8\"),\n      IPAddr.new(\"10.0.0.0/8\"),\n      IPAddr.new(\"100.64.0.0/10\"),\n      IPAddr.new(\"127.0.0.0/8\"),\n      IPAddr.new(\"169.254.0.0/16\"),\n      IPAddr.new(\"172.16.0.0/12\"),\n      IPAddr.new(\"192.0.0.0/24\"),\n      IPAddr.new(\"192.0.0.0/29\"),\n      IPAddr.new(\"192.0.0.8/32\"),\n      IPAddr.new(\"192.0.0.170/32\"),\n      IPAddr.new(\"192.0.0.171/32\"),\n      IPAddr.new(\"192.0.2.0/24\"),\n      IPAddr.new(\"192.168.0.0/16\"),\n      IPAddr.new(\"192.175.48.0/24\"),\n      IPAddr.new(\"198.18.0.0/15\"),\n      IPAddr.new(\"198.51.100.0/24\"),\n      IPAddr.new(\"203.0.113.0/24\"),\n      IPAddr.new(\"240.0.0.0/4\"),\n      IPAddr.new(\"255.255.255.255/32\"),\n    ]\n\n    # This is a list of private IPv6 IP ranges that are not allowed to be globally reachable as given by\n    # https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml.\n    #\n    # ::ffff:0:0/96 is excluded from the list because it is used for IPv4-mapped IPv6 addresses which is something we want to allow.\n    PRIVATE_IPV6_RANGES = [\n      IPAddr.new(\"::1/128\"),\n      IPAddr.new(\"::/128\"),\n      IPAddr.new(\"64:ff9b:1::/48\"),\n      IPAddr.new(\"100::/64\"),\n      IPAddr.new(\"2001::/23\"),\n      IPAddr.new(\"2001:2::/48\"),\n      IPAddr.new(\"2001:db8::/32\"),\n      IPAddr.new(\"fc00::/7\"),\n      IPAddr.new(\"fe80::/10\"),\n    ]\n\n    PRIVATE_IP_RANGES = PRIVATE_IPV4_RANGES + PRIVATE_IPV6_RANGES\n\n    def self.blocked_ip_blocks\n      SiteSetting\n        .blocked_ip_blocks\n        .split(/[|\\n]/)\n        .filter_map do |r|\n          IPAddr.new(r.strip)\n        rescue IPAddr::InvalidAddressError\n          nil\n        end\n    end\n\n    def self.allowed_internal_hosts\n      hosts =\n        [\n          SiteSetting.Upload.s3_cdn_url,\n          GlobalSetting.try(:cdn_url),\n          Discourse.base_url_no_prefix,\n        ].filter_map do |url|\n          URI.parse(url).hostname if url\n        rescue URI::Error\n          nil\n        end\n\n      hosts += SiteSetting.allowed_internal_hosts.split(/[|\\n]/).filter_map { |h| h.strip.presence }\n\n      hosts\n    end\n\n    def self.host_bypasses_checks?(hostname)\n      allowed_internal_hosts.any? { |h| h.downcase == hostname.downcase }\n    end\n\n    def self.ip_allowed?(ip)\n      ip = ip.is_a?(IPAddr) ? ip : IPAddr.new(ip)\n      ip = ip.native\n\n      return false if ip_in_ranges?(ip, blocked_ip_blocks) || ip_in_ranges?(ip, PRIVATE_IP_RANGES)\n\n      true\n    end\n\n    def self.lookup_and_filter_ips(name, timeout: nil)\n      begin\n        ips = lookup_ips(name, timeout: timeout)\n      rescue SocketError\n        raise LookupFailedError, \"FinalDestination: lookup failed\"\n      end\n\n      return ips if host_bypasses_checks?(name)\n\n      ips.filter! { |ip| FinalDestination::SSRFDetector.ip_allowed?(ip) }\n\n      raise DisallowedIpError, \"FinalDestination: all resolved IPs were disallowed\" if ips.empty?\n\n      ips\n    end\n\n    def self.allow_ip_lookups_in_test!\n      @allow_ip_lookups_in_test = true\n    end\n\n    def self.disallow_ip_lookups_in_test!\n      @allow_ip_lookups_in_test = false\n    end\n\n    private\n\n    def self.ip_in_ranges?(ip, ranges)\n      ranges.any? { |r| r === ip }\n    end\n\n    def self.lookup_ips(name, timeout: nil)\n      if Rails.env.test? && !@allow_ip_lookups_in_test\n        [\"1.2.3.4\"]\n      else\n        FinalDestination::Resolver.lookup(name, timeout: timeout)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe FinalDestination::SSRFDetector do\n  describe \"site setting parsing\" do\n    it \"can parse the blocked_ip_blocks and allowed_internal_hosts settings when the delimiter is pipe\" do\n      SiteSetting.blocked_ip_blocks = \"13.134.89.0/24|73.234.19.0/30\\n\"\n      SiteSetting.allowed_internal_hosts = \"awesomesauce.com\\n|goodbye.net\"\n\n      expect(subject.blocked_ip_blocks).to eq(%w[13.134.89.0/24 73.234.19.0/30])\n      expect(subject.allowed_internal_hosts).to eq(\n        [\n          \"test.localhost\", # Discourse.base_url\n          \"awesomesauce.com\",\n          \"goodbye.net\",\n        ],\n      )\n    end\n\n    it \"can parse the blocked_ip_blocks and allowed_internal_hosts settings when the delimiter is newline\" do\n      SiteSetting.blocked_ip_blocks = \"13.134.89.0/24\\n73.234.19.0/30\\n\\n\"\n      SiteSetting.allowed_internal_hosts = \"awesomesauce.com\\n\\ngoodbye.net\\n\\n\"\n\n      expect(subject.blocked_ip_blocks).to eq(%w[13.134.89.0/24 73.234.19.0/30])\n      expect(subject.allowed_internal_hosts).to eq(\n        [\n          \"test.localhost\", # Discourse.base_url\n          \"awesomesauce.com\",\n          \"goodbye.net\",\n        ],\n      )\n    end\n\n    it \"ignores invalid IP blocks\" do\n      SiteSetting.blocked_ip_blocks = \"2001:abc:de::/48|notanip\"\n      expect(subject.blocked_ip_blocks).to eq(%w[2001:abc:de::/48])\n    end\n  end\n\n  describe \".ip_allowed?\" do\n    it \"returns false for blocked IPs\" do\n      SiteSetting.blocked_ip_blocks = \"98.0.0.0/8|78.13.47.0/24|9001:82f3::/32\"\n      expect(subject.ip_allowed?(\"98.23.19.111\")).to eq(false)\n      expect(subject.ip_allowed?(\"9001:82f3:8873::3\")).to eq(false)\n    end\n\n    %w[0.0.0.0 10.0.0.0 127.0.0.0 172.31.100.31 255.255.255.255 ::1 ::].each do |internal_ip|\n      it \"returns false for '#{internal_ip}'\" do\n        expect(subject.ip_allowed?(internal_ip)).to eq(false)\n      end\n    end\n\n    it \"returns false for private IPv4-mapped IPv6 addresses\" do\n      expect(subject.ip_allowed?(\"::ffff:172.31.100.31\")).to eq(false)\n      expect(subject.ip_allowed?(\"::ffff:0.0.0.0\")).to eq(false)\n    end\n\n    it \"returns true for public IPv4-mapped IPv6 addresses\" do\n      expect(subject.ip_allowed?(\"::ffff:52.52.167.244\")).to eq(true)\n    end\n  end\n\n  describe \".host_bypasses_checks?\" do\n    it \"returns true for URLs when allowed_internal_hosts allows the host\" do\n      SiteSetting.allowed_internal_hosts = \"allowedhost1.com|allowedhost2.com\"\n      expect(subject.host_bypasses_checks?(\"allowedhost1.com\")).to eq(true)\n      expect(subject.host_bypasses_checks?(\"allowedhost2.com\")).to eq(true)\n    end\n\n    it \"returns false for other hosts\" do\n      expect(subject.host_bypasses_checks?(\"otherhost.com\")).to eq(false)\n    end\n\n    it \"returns true for the base uri\" do\n      SiteSetting.force_hostname = \"final-test.example.com\"\n      expect(subject.host_bypasses_checks?(\"final-test.example.com\")).to eq(true)\n    end\n\n    it \"returns true for the S3 CDN url\" do\n      SiteSetting.enable_s3_uploads = true\n      SiteSetting.s3_cdn_url = \"https://s3.example.com\"\n      expect(subject.host_bypasses_checks?(\"s3.example.com\")).to eq(true)\n    end\n\n    it \"returns true for the CDN url\" do\n      GlobalSetting.stubs(:cdn_url).returns(\"https://cdn.example.com/discourse\")\n      expect(subject.host_bypasses_checks?(\"cdn.example.com\")).to eq(true)\n    end\n  end\n\n  describe \".lookup_and_filter_ips\" do\n    it \"returns a fake response in tests\" do\n      expect(subject.lookup_and_filter_ips(\"example.com\")).to eq([\"1.2.3.4\"])\n    end\n\n    it \"correctly filters private and blocked IPs\" do\n      SiteSetting.blocked_ip_blocks = \"9.10.11.12/24\"\n      subject.stubs(:lookup_ips).returns(%w[127.0.0.1 5.6.7.8 9.10.11.12])\n      expect(subject.lookup_and_filter_ips(\"example.com\")).to eq([\"5.6.7.8\"])\n    end\n\n    it \"raises an exception if all IPs are blocked\" do\n      subject.stubs(:lookup_ips).returns([\"127.0.0.1\"])\n      expect { subject.lookup_and_filter_ips(\"example.com\") }.to raise_error(\n        subject::DisallowedIpError,\n      )\n    end\n\n    it \"raises an exception if lookup fails\" do\n      subject.stubs(:lookup_ips).raises(SocketError)\n      expect { subject.lookup_and_filter_ips(\"example.com\") }.to raise_error(\n        subject::LookupFailedError,\n      )\n    end\n\n    it \"bypasses filtering for allowlisted hosts\" do\n      SiteSetting.allowed_internal_hosts = \"example.com\"\n      subject.stubs(:lookup_ips).returns([\"127.0.0.1\"])\n      expect(subject.lookup_and_filter_ips(\"example.com\")).to eq([\"127.0.0.1\"])\n    end\n  end\nend\n"], "filenames": ["lib/final_destination/ssrf_detector.rb", "spec/lib/final_destination/ssrf_detector_spec.rb"], "buggy_code_start_loc": [10, 46], "buggy_code_end_loc": [61, 49], "fixing_code_start_loc": [10, 46], "fixing_code_end_loc": [89, 59], "type": "CWE-918", "message": "Discourse is an open-source discussion platform. Prior to version 3.1.0.beta3 of the `beta` and `tests-passed` branches, attackers are able to bypass Discourse's server-side request forgery (SSRF) protection for private IPv4 addresses by using a IPv4-mapped IPv6 address. The issue is patched in the latest beta and tests-passed version of Discourse. version 3.1.0.beta3 of the `beta` and `tests-passed` branches. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-28111", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-17T17:15:11.613", "lastModified": "2023-03-23T20:57:42.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open-source discussion platform. Prior to version 3.1.0.beta3 of the `beta` and `tests-passed` branches, attackers are able to bypass Discourse's server-side request forgery (SSRF) protection for private IPv4 addresses by using a IPv4-mapped IPv6 address. The issue is patched in the latest beta and tests-passed version of Discourse. version 3.1.0.beta3 of the `beta` and `tests-passed` branches. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:beta:*:*:*", "versionEndExcluding": "3.1.0", "matchCriteriaId": "D3C08972-822D-4657-9B6F-02BC692B7C6E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B9BBED17-A6BA-4F17-8814-8D8521F28375"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "888B8ECF-EBE0-4821-82F6-B0026E95E407"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/fd16eade7fcc6bba4b71e71106a2eb13cdfdae4a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/pull/20710", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-26h3-8ww8-v5fc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/fd16eade7fcc6bba4b71e71106a2eb13cdfdae4a"}}