{"buggy_code": ["// This is a port of the test suite:\n// hungry/js/test/parse_file_test.js\n\n'use strict';\n\nconst { FilesController } = require('../lib/Controllers/FilesController');\nconst request = require('../lib/request');\n\nconst str = 'Hello World!';\nconst data = [];\nfor (let i = 0; i < str.length; i++) {\n  data.push(str.charCodeAt(i));\n}\n\ndescribe('Parse.File testing', () => {\n  describe('creating files', () => {\n    it('works with Content-Type', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('works with _ContentType', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['*'],\n        },\n      });\n      let response = await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/files/file',\n        body: JSON.stringify({\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ContentType: 'text/html',\n          base64: 'PGh0bWw+PC9odG1sPgo=',\n        }),\n      });\n      const b = response.data;\n      expect(b.name).toMatch(/_file.html/);\n      expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.html$/);\n      response = await request({ url: b.url });\n      const body = response.text;\n      try {\n        expect(response.headers['content-type']).toMatch('^text/html');\n        expect(body).toEqual('<html></html>\\n');\n      } catch (e) {\n        jfail(e);\n      }\n    });\n\n    it('works without Content-Type', done => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          expect(response.text).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('supports REST end-to-end file create, read, delete, read', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/testfile.txt',\n        body: 'check one two',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_testfile.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*testfile.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('check one two');\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'test',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(response => {\n            expect(response.status).toEqual(200);\n            request({\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: b.url,\n            }).then(fail, response => {\n              expect(response.status).toEqual(404);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('blocks file deletions with missing or incorrect master-key header', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/thefile.jpg',\n        body: 'the file body',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*thefile.jpg$/);\n        // missing X-Parse-Master-Key header\n        request({\n          method: 'DELETE',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/files/' + b.name,\n        }).then(fail, response => {\n          const del_b = response.data;\n          expect(response.status).toEqual(403);\n          expect(del_b.error).toMatch(/unauthorized/);\n          // incorrect X-Parse-Master-Key header\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'tryagain',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(fail, response => {\n            const del_b2 = response.data;\n            expect(response.status).toEqual(403);\n            expect(del_b2.error).toMatch(/unauthorized/);\n            done();\n          });\n        });\n      });\n    });\n\n    it('handles other filetypes', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.jpg',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.jpg$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/.*file.jpg$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('save file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n    });\n\n    it('saves the file with tags', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      const tags = { hello: 'world' };\n      file.setTags(tags);\n      expect(file.url()).toBeUndefined();\n      const result = await file.save();\n      expect(file.name()).toBeDefined();\n      expect(file.url()).toBeDefined();\n      expect(result.tags()).toEqual(tags);\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        tags: tags,\n        metadata: {},\n      });\n    });\n\n    it('does not pass empty file tags while saving', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      expect(file.url()).toBeUndefined();\n      expect(file.name()).toBeDefined();\n      await file.save();\n      expect(file.url()).toBeDefined();\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        metadata: {},\n      });\n    });\n\n    it('save file in object', async done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file: file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n      done();\n    });\n\n    it('save file in object with escaped characters in filename', async () => {\n      const file = new Parse.File('hello . txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello . txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n    });\n\n    it('autosave file in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      file = objectAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('autosave file in object in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n\n      const child = new Parse.Object('Child');\n      child.set('file', file);\n\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n\n      await parent.save();\n      const query = new Parse.Query('Parent');\n      query.include('child');\n      const parentAgain = await query.get(parent.id);\n      const childAgain = parentAgain.get('child');\n      file = childAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('saving an already saved file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      const previousName = file.name();\n\n      await file.save();\n      equal(file.name(), previousName);\n    });\n\n    it('two saves at the same time', done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n\n      let firstName;\n      let secondName;\n\n      const firstSave = file.save().then(function () {\n        firstName = file.name();\n      });\n      const secondSave = file.save().then(function () {\n        secondName = file.name();\n      });\n\n      Promise.all([firstSave, secondSave]).then(\n        function () {\n          equal(firstName, secondName);\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n    });\n\n    it('file toJSON testing', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file: file,\n      });\n      ok(object.toJSON().file.url);\n    });\n\n    it('content-type used with no extension', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['*'],\n        },\n      });\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      let response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file',\n        body: 'fee fi fo',\n      });\n\n      const b = response.data;\n      expect(b.name).toMatch(/\\.html$/);\n      response = await request({ url: b.url });\n      expect(response.headers['content-type']).toMatch(/^text\\/html/);\n    });\n\n    it('filename is url encoded', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/hello world.txt',\n        body: 'oh emm gee',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/hello%20world/);\n        done();\n      });\n    });\n\n    it('supports array of files', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const files = [file, file];\n      const obj = new Parse.Object('FilesArrayTest');\n      obj.set('files', files);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FilesArrayTest');\n          return query.first();\n        })\n        .then(result => {\n          const filesAgain = result.get('files');\n          expect(filesAgain.length).toEqual(2);\n          expect(filesAgain[0].name()).toEqual('meep');\n          expect(filesAgain[0].url()).toEqual('http://meep.meep');\n          done();\n        });\n    });\n\n    it('validates filename characters', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/di$avowed.txt',\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('validates filename length', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const fileName =\n        'Onceuponamidnightdrearywhileiponderedweak' +\n        'andwearyOveramanyquaintandcuriousvolumeof' +\n        'forgottenloreWhileinoddednearlynappingsud' +\n        'denlytherecameatapping';\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/' + fileName,\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('supports a dictionary with file', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const dict = {\n        file: file,\n      };\n      const obj = new Parse.Object('FileObjTest');\n      obj.set('obj', dict);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileObjTest');\n          return query.first();\n        })\n        .then(result => {\n          const dictAgain = result.get('obj');\n          expect(typeof dictAgain).toEqual('object');\n          const fileAgain = dictAgain['file'];\n          expect(fileAgain.name()).toEqual('meep');\n          expect(fileAgain.url()).toEqual('http://meep.meep');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parsetfss.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'tfss-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual('http://files.parsetfss.com/test/tfss-123.txt');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parse.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'd6e80979-a128-4c57-a167-302f874700dc-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual(\n            'http://files.parse.com/test/d6e80979-a128-4c57-a167-302f874700dc-123.txt'\n          );\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('supports files in objects without urls', done => {\n      const file = {\n        __type: 'File',\n        name: '123.txt',\n      };\n      const obj = new Parse.Object('FileTest');\n      obj.set('file', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url()).toMatch(/123.txt$/);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('return with publicServerURL when provided', done => {\n      reconfigureServer({\n        publicServerURL: 'https://mydomain/parse',\n      })\n        .then(() => {\n          const file = {\n            __type: 'File',\n            name: '123.txt',\n          };\n          const obj = new Parse.Object('FileTest');\n          obj.set('file', file);\n          return obj.save();\n        })\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url().indexOf('https://mydomain/parse')).toBe(0);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('fails to upload an empty file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: '',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":130,\"error\":\"Invalid file upload.\"}');\n        done();\n      });\n    });\n\n    it('fails to upload without a file name', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/',\n        body: 'yolo',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":122,\"error\":\"Filename not provided.\"}');\n        done();\n      });\n    });\n  });\n\n  describe('deleting files', () => {\n    it('fails to delete an unkown file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Master-Key': 'test',\n      };\n      request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(typeof body).toBe('string');\n        const { code, error } = JSON.parse(body);\n        expect(code).toBe(153);\n        expect(typeof error).toBe('string');\n        expect(error.length).toBeGreaterThan(0);\n        done();\n      });\n    });\n  });\n\n  describe('getting files', () => {\n    it('does not crash on file request with invalid app ID', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id/invalid-file.txt',\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({ code: 119, error: 'Invalid application ID.' });\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n\n    it('does not crash on file request with invalid path', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id//invalid-path/%20/invalid-file.txt',\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({ error: 'unauthorized' });\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n\n    it('does not crash on file metadata request with invalid app ID', async () => {\n      const res1 = await request({\n        url: `http://localhost:8378/1/files/invalid-id/metadata/invalid-file.txt`,\n      });\n      expect(res1.status).toBe(200);\n      expect(res1.data).toEqual({});\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n  });\n\n  describe_only_db('mongo')('Gridstore Range', () => {\n    it('supports bytes range out of range', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=15000-18000',\n        },\n      });\n      expect(file.headers['content-range']).toBe('bytes 1212-1212/1212');\n    });\n\n    it('supports bytes range if end greater than start', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=15000-100',\n        },\n      });\n      expect(file.headers['content-range']).toBe('bytes 100-1212/1212');\n    });\n\n    it('supports bytes range if end is undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=100-',\n        },\n      });\n      expect(file.headers['content-range']).toBe('bytes 100-1212/1212');\n    });\n\n    it('supports bytes range if start and end undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=abc-efs',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBeUndefined();\n    });\n\n    it('supports bytes range if start and end undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBeUndefined();\n    });\n\n    it('supports bytes range if end is greater than size', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=0-2000',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1212/1212');\n    });\n\n    it('supports bytes range if end is greater than size', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=0-2000',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1212/1212');\n    });\n\n    it('supports bytes range with 0 length', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: 'a',\n      }).catch(e => e);\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=-2000',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1/1');\n    });\n\n    it('supports range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle ');\n          done();\n        });\n      });\n    });\n\n    it('supports small range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('arg');\n          done();\n        });\n      });\n    });\n\n    // See specs https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    it('supports getting one byte', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=2-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('g');\n          done();\n        });\n      });\n    });\n\n    it('supports getting last n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=-4',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toBe(4);\n          expect(body).toEqual('rent');\n          done();\n        });\n      });\n    });\n\n    it('supports getting first n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=10-',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('different');\n          done();\n        });\n      });\n    });\n\n    function repeat(string, count) {\n      let s = string;\n      while (count > 0) {\n        s += string;\n        count--;\n      }\n      return s;\n    }\n\n    it('supports large range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: repeat('argle bargle', 100),\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=13-240',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toEqual(228);\n          expect(body.indexOf('rgle barglea')).toBe(0);\n          done();\n        });\n      });\n    });\n\n    it('fails to stream unknown file', async () => {\n      const response = await request({\n        url: 'http://localhost:8378/1/files/test/file.txt',\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n          Range: 'bytes=13-240',\n        },\n      }).catch(e => e);\n      expect(response.status).toBe(404);\n      const body = response.text;\n      expect(body).toEqual('File not found.');\n    });\n  });\n\n  // Because GridStore is not loaded on PG, those are perfect\n  // for fallback tests\n  describe_only_db('postgres')('Default Range tests', () => {\n    it('fallback to regular request', async done => {\n      await reconfigureServer();\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n  });\n\n  describe('file upload configuration', () => {\n    it('allows file upload only for authenticated user by default', async () => {\n      await reconfigureServer({\n        fileUpload: {},\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload with master key', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save({ useMasterKey: true })).toBeResolved();\n    });\n\n    it('rejects all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload only for public', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for anonymous user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for authenticated user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('rejects invalid fileUpload configuration', async () => {\n      const invalidConfigs = [\n        { fileUpload: undefined },\n        { fileUpload: null },\n        { fileUpload: [] },\n        { fileUpload: 1 },\n        { fileUpload: 'string' },\n      ];\n      const validConfigs = [{ fileUpload: {} }];\n      const keys = ['enableForPublic', 'enableForAnonymousUser', 'enableForAuthenticatedUser'];\n      const invalidValues = [[], {}, 1, 'string', null];\n      const validValues = [undefined, true, false];\n      for (const config of invalidConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeRejectedWith(\n          'fileUpload must be an object value.'\n        );\n      }\n      for (const config of validConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeResolved();\n      }\n      for (const key of keys) {\n        for (const value of invalidValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeRejectedWith(\n            `fileUpload.${key} must be a boolean value.`\n          );\n        }\n        for (const value of validValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeResolved();\n        }\n      }\n      await expectAsync(\n        reconfigureServer({\n          fileUpload: {\n            fileExtensions: 1,\n          },\n        })\n      ).toBeRejectedWith('fileUpload.fileExtensions must be an array.');\n    });\n  });\n\n  describe('fileExtensions', () => {\n    it('works with _ContentType', async () => {\n      await reconfigureServer({\n        silent: false,\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['png'],\n        },\n      });\n      await expectAsync(\n        request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/files/file',\n          body: JSON.stringify({\n            _ApplicationId: 'test',\n            _JavaScriptKey: 'test',\n            _ContentType: 'text/html',\n            base64: 'PGh0bWw+PC9odG1sPgo=',\n          }),\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('works without Content-Type', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n        },\n      });\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      await expectAsync(\n        request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/files/file.html',\n          body: '<html></html>\\n',\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('works with array', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['jpg'],\n        },\n      });\n      await expectAsync(\n        request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/files/file',\n          body: JSON.stringify({\n            _ApplicationId: 'test',\n            _JavaScriptKey: 'test',\n            _ContentType: 'text/html',\n            base64: 'PGh0bWw+PC9odG1sPgo=',\n          }),\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('works with array without Content-Type', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['jpg'],\n        },\n      });\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      await expectAsync(\n        request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/files/file.html',\n          body: '<html></html>\\n',\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('works with array with correct file type', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['html'],\n        },\n      });\n      const response = await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/files/file',\n        body: JSON.stringify({\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ContentType: 'text/html',\n          base64: 'PGh0bWw+PC9odG1sPgo=',\n        }),\n      });\n      const b = response.data;\n      expect(b.name).toMatch(/_file.html$/);\n      expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.html$/);\n    });\n  });\n});\n", "import express from 'express';\nimport BodyParser from 'body-parser';\nimport * as Middlewares from '../middlewares';\nimport Parse from 'parse/node';\nimport Config from '../Config';\nimport mime from 'mime';\nimport logger from '../logger';\nconst triggers = require('../triggers');\nconst http = require('http');\nconst Utils = require('../Utils');\n\nconst downloadFileFromURI = uri => {\n  return new Promise((res, rej) => {\n    http\n      .get(uri, response => {\n        response.setDefaultEncoding('base64');\n        let body = `data:${response.headers['content-type']};base64,`;\n        response.on('data', data => (body += data));\n        response.on('end', () => res(body));\n      })\n      .on('error', e => {\n        rej(`Error downloading file from ${uri}: ${e.message}`);\n      });\n  });\n};\n\nconst addFileDataIfNeeded = async file => {\n  if (file._source.format === 'uri') {\n    const base64 = await downloadFileFromURI(file._source.uri);\n    file._previousSave = file;\n    file._data = base64;\n    file._requestTask = null;\n  }\n  return file;\n};\n\nexport class FilesRouter {\n  expressRouter({ maxUploadSize = '20Mb' } = {}) {\n    var router = express.Router();\n    router.get('/files/:appId/:filename', this.getHandler);\n    router.get('/files/:appId/metadata/:filename', this.metadataHandler);\n\n    router.post('/files', function (req, res, next) {\n      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));\n    });\n\n    router.post(\n      '/files/:filename',\n      BodyParser.raw({\n        type: () => {\n          return true;\n        },\n        limit: maxUploadSize,\n      }), // Allow uploads without Content-Type, or with any Content-Type.\n      Middlewares.handleParseHeaders,\n      this.createHandler\n    );\n\n    router.delete(\n      '/files/:filename',\n      Middlewares.handleParseHeaders,\n      Middlewares.enforceMasterKeyAccess,\n      this.deleteHandler\n    );\n    return router;\n  }\n\n  getHandler(req, res) {\n    const config = Config.get(req.params.appId);\n    if (!config) {\n      res.status(403);\n      const err = new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Invalid application ID.');\n      res.json({ code: err.code, error: err.message });\n      return;\n    }\n    const filesController = config.filesController;\n    const filename = req.params.filename;\n    const contentType = mime.getType(filename);\n    if (isFileStreamable(req, filesController)) {\n      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {\n        res.status(404);\n        res.set('Content-Type', 'text/plain');\n        res.end('File not found.');\n      });\n    } else {\n      filesController\n        .getFileData(config, filename)\n        .then(data => {\n          res.status(200);\n          res.set('Content-Type', contentType);\n          res.set('Content-Length', data.length);\n          res.end(data);\n        })\n        .catch(() => {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n    }\n  }\n\n  async createHandler(req, res, next) {\n    const config = req.config;\n    const user = req.auth.user;\n    const isMaster = req.auth.isMaster;\n    const isLinked = user && Parse.AnonymousUtils.isLinked(user);\n    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {\n      next(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {\n      next(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForPublic && !user) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      return;\n    }\n    const filesController = config.filesController;\n    const { filename } = req.params;\n    const contentType = req.get('Content-type');\n\n    if (!req.body || !req.body.length) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));\n      return;\n    }\n\n    const error = filesController.validateFilename(filename);\n    if (error) {\n      next(error);\n      return;\n    }\n\n    const fileExtensions = config.fileUpload?.fileExtensions;\n    if (!isMaster && fileExtensions) {\n      const isValidExtension = extension => {\n        return fileExtensions.some(ext => {\n          if (ext === '*') {\n            return true;\n          }\n          const regex = new RegExp(fileExtensions);\n          if (regex.test(extension)) {\n            return true;\n          }\n        });\n      };\n      let extension = contentType;\n      if (filename && filename.includes('.')) {\n        extension = filename.split('.')[1];\n      } else if (contentType && contentType.includes('/')) {\n        extension = contentType.split('/')[1];\n      }\n      extension = extension.split(' ').join('');\n\n      if (!isValidExtension(extension)) {\n        next(\n          new Parse.Error(\n            Parse.Error.FILE_SAVE_ERROR,\n            `File upload of extension ${extension} is disabled.`\n          )\n        );\n        return;\n      }\n    }\n\n    const base64 = req.body.toString('base64');\n    const file = new Parse.File(filename, { base64 }, contentType);\n    const { metadata = {}, tags = {} } = req.fileData || {};\n    try {\n      // Scan request data for denied keywords\n      Utils.checkProhibitedKeywords(config, metadata);\n      Utils.checkProhibitedKeywords(config, tags);\n    } catch (error) {\n      next(new Parse.Error(Parse.Error.INVALID_KEY_NAME, error));\n      return;\n    }\n    file.setTags(tags);\n    file.setMetadata(metadata);\n    const fileSize = Buffer.byteLength(req.body);\n    const fileObject = { file, fileSize };\n    try {\n      // run beforeSaveFile trigger\n      const triggerResult = await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeSave,\n        fileObject,\n        config,\n        req.auth\n      );\n      let saveResult;\n      // if a new ParseFile is returned check if it's an already saved file\n      if (triggerResult instanceof Parse.File) {\n        fileObject.file = triggerResult;\n        if (triggerResult.url()) {\n          // set fileSize to null because we wont know how big it is here\n          fileObject.fileSize = null;\n          saveResult = {\n            url: triggerResult.url(),\n            name: triggerResult._name,\n          };\n        }\n      }\n      // if the file returned by the trigger has already been saved skip saving anything\n      if (!saveResult) {\n        // if the ParseFile returned is type uri, download the file before saving it\n        await addFileDataIfNeeded(fileObject.file);\n        // update fileSize\n        const bufferData = Buffer.from(fileObject.file._data, 'base64');\n        fileObject.fileSize = Buffer.byteLength(bufferData);\n        // prepare file options\n        const fileOptions = {\n          metadata: fileObject.file._metadata,\n        };\n        // some s3-compatible providers (DigitalOcean, Linode) do not accept tags\n        // so we do not include the tags option if it is empty.\n        const fileTags =\n          Object.keys(fileObject.file._tags).length > 0 ? { tags: fileObject.file._tags } : {};\n        Object.assign(fileOptions, fileTags);\n        // save file\n        const createFileResult = await filesController.createFile(\n          config,\n          fileObject.file._name,\n          bufferData,\n          fileObject.file._source.type,\n          fileOptions\n        );\n        // update file with new data\n        fileObject.file._name = createFileResult.name;\n        fileObject.file._url = createFileResult.url;\n        fileObject.file._requestTask = null;\n        fileObject.file._previousSave = Promise.resolve(fileObject.file);\n        saveResult = {\n          url: createFileResult.url,\n          name: createFileResult.name,\n        };\n      }\n      // run afterSaveFile trigger\n      await triggers.maybeRunFileTrigger(triggers.Types.afterSave, fileObject, config, req.auth);\n      res.status(201);\n      res.set('Location', saveResult.url);\n      res.json(saveResult);\n    } catch (e) {\n      logger.error('Error creating a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_SAVE_ERROR,\n        message: `Could not store file: ${fileObject.file._name}.`,\n      });\n      next(error);\n    }\n  }\n\n  async deleteHandler(req, res, next) {\n    try {\n      const { filesController } = req.config;\n      const { filename } = req.params;\n      // run beforeDeleteFile trigger\n      const file = new Parse.File(filename);\n      file._url = filesController.adapter.getFileLocation(req.config, filename);\n      const fileObject = { file, fileSize: null };\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      // delete file\n      await filesController.deleteFile(req.config, filename);\n      // run afterDeleteFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      res.status(200);\n      // TODO: return useful JSON here?\n      res.end();\n    } catch (e) {\n      logger.error('Error deleting a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_DELETE_ERROR,\n        message: 'Could not delete file.',\n      });\n      next(error);\n    }\n  }\n\n  async metadataHandler(req, res) {\n    try {\n      const config = Config.get(req.params.appId);\n      const { filesController } = config;\n      const { filename } = req.params;\n      const data = await filesController.getMetadata(filename);\n      res.status(200);\n      res.json(data);\n    } catch (e) {\n      res.status(200);\n      res.json({});\n    }\n  }\n}\n\nfunction isFileStreamable(req, filesController) {\n  const range = (req.get('Range') || '/-/').split('-');\n  const start = Number(range[0]);\n  const end = Number(range[1]);\n  return (\n    (!isNaN(start) || !isNaN(end)) && typeof filesController.adapter.handleFileStream === 'function'\n  );\n}\n"], "fixing_code": ["// This is a port of the test suite:\n// hungry/js/test/parse_file_test.js\n\n'use strict';\n\nconst { FilesController } = require('../lib/Controllers/FilesController');\nconst request = require('../lib/request');\n\nconst str = 'Hello World!';\nconst data = [];\nfor (let i = 0; i < str.length; i++) {\n  data.push(str.charCodeAt(i));\n}\n\ndescribe('Parse.File testing', () => {\n  describe('creating files', () => {\n    it('works with Content-Type', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('works with _ContentType', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['*'],\n        },\n      });\n      let response = await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/files/file',\n        body: JSON.stringify({\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ContentType: 'text/html',\n          base64: 'PGh0bWw+PC9odG1sPgo=',\n        }),\n      });\n      const b = response.data;\n      expect(b.name).toMatch(/_file.html/);\n      expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.html$/);\n      response = await request({ url: b.url });\n      const body = response.text;\n      try {\n        expect(response.headers['content-type']).toMatch('^text/html');\n        expect(body).toEqual('<html></html>\\n');\n      } catch (e) {\n        jfail(e);\n      }\n    });\n\n    it('works without Content-Type', done => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          expect(response.text).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('supports REST end-to-end file create, read, delete, read', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/testfile.txt',\n        body: 'check one two',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_testfile.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*testfile.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('check one two');\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'test',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(response => {\n            expect(response.status).toEqual(200);\n            request({\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: b.url,\n            }).then(fail, response => {\n              expect(response.status).toEqual(404);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('blocks file deletions with missing or incorrect master-key header', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/thefile.jpg',\n        body: 'the file body',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*thefile.jpg$/);\n        // missing X-Parse-Master-Key header\n        request({\n          method: 'DELETE',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/files/' + b.name,\n        }).then(fail, response => {\n          const del_b = response.data;\n          expect(response.status).toEqual(403);\n          expect(del_b.error).toMatch(/unauthorized/);\n          // incorrect X-Parse-Master-Key header\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'tryagain',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(fail, response => {\n            const del_b2 = response.data;\n            expect(response.status).toEqual(403);\n            expect(del_b2.error).toMatch(/unauthorized/);\n            done();\n          });\n        });\n      });\n    });\n\n    it('handles other filetypes', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.jpg',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.jpg$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/.*file.jpg$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('save file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n    });\n\n    it('saves the file with tags', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      const tags = { hello: 'world' };\n      file.setTags(tags);\n      expect(file.url()).toBeUndefined();\n      const result = await file.save();\n      expect(file.name()).toBeDefined();\n      expect(file.url()).toBeDefined();\n      expect(result.tags()).toEqual(tags);\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        tags: tags,\n        metadata: {},\n      });\n    });\n\n    it('does not pass empty file tags while saving', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      expect(file.url()).toBeUndefined();\n      expect(file.name()).toBeDefined();\n      await file.save();\n      expect(file.url()).toBeDefined();\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        metadata: {},\n      });\n    });\n\n    it('save file in object', async done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file: file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n      done();\n    });\n\n    it('save file in object with escaped characters in filename', async () => {\n      const file = new Parse.File('hello . txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello . txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n    });\n\n    it('autosave file in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      file = objectAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('autosave file in object in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n\n      const child = new Parse.Object('Child');\n      child.set('file', file);\n\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n\n      await parent.save();\n      const query = new Parse.Query('Parent');\n      query.include('child');\n      const parentAgain = await query.get(parent.id);\n      const childAgain = parentAgain.get('child');\n      file = childAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('saving an already saved file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      const previousName = file.name();\n\n      await file.save();\n      equal(file.name(), previousName);\n    });\n\n    it('two saves at the same time', done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n\n      let firstName;\n      let secondName;\n\n      const firstSave = file.save().then(function () {\n        firstName = file.name();\n      });\n      const secondSave = file.save().then(function () {\n        secondName = file.name();\n      });\n\n      Promise.all([firstSave, secondSave]).then(\n        function () {\n          equal(firstName, secondName);\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n    });\n\n    it('file toJSON testing', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file: file,\n      });\n      ok(object.toJSON().file.url);\n    });\n\n    it('content-type used with no extension', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['*'],\n        },\n      });\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      let response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file',\n        body: 'fee fi fo',\n      });\n\n      const b = response.data;\n      expect(b.name).toMatch(/\\.html$/);\n      response = await request({ url: b.url });\n      expect(response.headers['content-type']).toMatch(/^text\\/html/);\n    });\n\n    it('filename is url encoded', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/hello world.txt',\n        body: 'oh emm gee',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/hello%20world/);\n        done();\n      });\n    });\n\n    it('supports array of files', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const files = [file, file];\n      const obj = new Parse.Object('FilesArrayTest');\n      obj.set('files', files);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FilesArrayTest');\n          return query.first();\n        })\n        .then(result => {\n          const filesAgain = result.get('files');\n          expect(filesAgain.length).toEqual(2);\n          expect(filesAgain[0].name()).toEqual('meep');\n          expect(filesAgain[0].url()).toEqual('http://meep.meep');\n          done();\n        });\n    });\n\n    it('validates filename characters', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/di$avowed.txt',\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('validates filename length', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const fileName =\n        'Onceuponamidnightdrearywhileiponderedweak' +\n        'andwearyOveramanyquaintandcuriousvolumeof' +\n        'forgottenloreWhileinoddednearlynappingsud' +\n        'denlytherecameatapping';\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/' + fileName,\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('supports a dictionary with file', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const dict = {\n        file: file,\n      };\n      const obj = new Parse.Object('FileObjTest');\n      obj.set('obj', dict);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileObjTest');\n          return query.first();\n        })\n        .then(result => {\n          const dictAgain = result.get('obj');\n          expect(typeof dictAgain).toEqual('object');\n          const fileAgain = dictAgain['file'];\n          expect(fileAgain.name()).toEqual('meep');\n          expect(fileAgain.url()).toEqual('http://meep.meep');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parsetfss.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'tfss-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual('http://files.parsetfss.com/test/tfss-123.txt');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parse.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'd6e80979-a128-4c57-a167-302f874700dc-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual(\n            'http://files.parse.com/test/d6e80979-a128-4c57-a167-302f874700dc-123.txt'\n          );\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('supports files in objects without urls', done => {\n      const file = {\n        __type: 'File',\n        name: '123.txt',\n      };\n      const obj = new Parse.Object('FileTest');\n      obj.set('file', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url()).toMatch(/123.txt$/);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('return with publicServerURL when provided', done => {\n      reconfigureServer({\n        publicServerURL: 'https://mydomain/parse',\n      })\n        .then(() => {\n          const file = {\n            __type: 'File',\n            name: '123.txt',\n          };\n          const obj = new Parse.Object('FileTest');\n          obj.set('file', file);\n          return obj.save();\n        })\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url().indexOf('https://mydomain/parse')).toBe(0);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('fails to upload an empty file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: '',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":130,\"error\":\"Invalid file upload.\"}');\n        done();\n      });\n    });\n\n    it('fails to upload without a file name', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/',\n        body: 'yolo',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":122,\"error\":\"Filename not provided.\"}');\n        done();\n      });\n    });\n  });\n\n  describe('deleting files', () => {\n    it('fails to delete an unkown file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Master-Key': 'test',\n      };\n      request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(typeof body).toBe('string');\n        const { code, error } = JSON.parse(body);\n        expect(code).toBe(153);\n        expect(typeof error).toBe('string');\n        expect(error.length).toBeGreaterThan(0);\n        done();\n      });\n    });\n  });\n\n  describe('getting files', () => {\n    it('does not crash on file request with invalid app ID', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id/invalid-file.txt',\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({ code: 119, error: 'Invalid application ID.' });\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n\n    it('does not crash on file request with invalid path', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id//invalid-path/%20/invalid-file.txt',\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({ error: 'unauthorized' });\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n\n    it('does not crash on file metadata request with invalid app ID', async () => {\n      const res1 = await request({\n        url: `http://localhost:8378/1/files/invalid-id/metadata/invalid-file.txt`,\n      });\n      expect(res1.status).toBe(200);\n      expect(res1.data).toEqual({});\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n  });\n\n  describe_only_db('mongo')('Gridstore Range', () => {\n    it('supports bytes range out of range', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=15000-18000',\n        },\n      });\n      expect(file.headers['content-range']).toBe('bytes 1212-1212/1212');\n    });\n\n    it('supports bytes range if end greater than start', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=15000-100',\n        },\n      });\n      expect(file.headers['content-range']).toBe('bytes 100-1212/1212');\n    });\n\n    it('supports bytes range if end is undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=100-',\n        },\n      });\n      expect(file.headers['content-range']).toBe('bytes 100-1212/1212');\n    });\n\n    it('supports bytes range if start and end undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=abc-efs',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBeUndefined();\n    });\n\n    it('supports bytes range if start and end undefined', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBeUndefined();\n    });\n\n    it('supports bytes range if end is greater than size', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=0-2000',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1212/1212');\n    });\n\n    it('supports bytes range if end is greater than size', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: repeat('argle bargle', 100),\n      });\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=0-2000',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1212/1212');\n    });\n\n    it('supports bytes range with 0 length', async () => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1//files/file.txt ',\n        body: 'a',\n      }).catch(e => e);\n      const b = response.data;\n      const file = await request({\n        url: b.url,\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          Range: 'bytes=-2000',\n        },\n      }).catch(e => e);\n      expect(file.headers['content-range']).toBe('bytes 0-1/1');\n    });\n\n    it('supports range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle ');\n          done();\n        });\n      });\n    });\n\n    it('supports small range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('arg');\n          done();\n        });\n      });\n    });\n\n    // See specs https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    it('supports getting one byte', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=2-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('g');\n          done();\n        });\n      });\n    });\n\n    it('supports getting last n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=-4',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toBe(4);\n          expect(body).toEqual('rent');\n          done();\n        });\n      });\n    });\n\n    it('supports getting first n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=10-',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('different');\n          done();\n        });\n      });\n    });\n\n    function repeat(string, count) {\n      let s = string;\n      while (count > 0) {\n        s += string;\n        count--;\n      }\n      return s;\n    }\n\n    it('supports large range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: repeat('argle bargle', 100),\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=13-240',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toEqual(228);\n          expect(body.indexOf('rgle barglea')).toBe(0);\n          done();\n        });\n      });\n    });\n\n    it('fails to stream unknown file', async () => {\n      const response = await request({\n        url: 'http://localhost:8378/1/files/test/file.txt',\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n          Range: 'bytes=13-240',\n        },\n      }).catch(e => e);\n      expect(response.status).toBe(404);\n      const body = response.text;\n      expect(body).toEqual('File not found.');\n    });\n  });\n\n  // Because GridStore is not loaded on PG, those are perfect\n  // for fallback tests\n  describe_only_db('postgres')('Default Range tests', () => {\n    it('fallback to regular request', async done => {\n      await reconfigureServer();\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n  });\n\n  describe('file upload configuration', () => {\n    it('allows file upload only for authenticated user by default', async () => {\n      await reconfigureServer({\n        fileUpload: {},\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload with master key', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save({ useMasterKey: true })).toBeResolved();\n    });\n\n    it('rejects all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload only for public', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for anonymous user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for authenticated user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('rejects invalid fileUpload configuration', async () => {\n      const invalidConfigs = [\n        { fileUpload: undefined },\n        { fileUpload: null },\n        { fileUpload: [] },\n        { fileUpload: 1 },\n        { fileUpload: 'string' },\n      ];\n      const validConfigs = [{ fileUpload: {} }];\n      const keys = ['enableForPublic', 'enableForAnonymousUser', 'enableForAuthenticatedUser'];\n      const invalidValues = [[], {}, 1, 'string', null];\n      const validValues = [undefined, true, false];\n      for (const config of invalidConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeRejectedWith(\n          'fileUpload must be an object value.'\n        );\n      }\n      for (const config of validConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeResolved();\n      }\n      for (const key of keys) {\n        for (const value of invalidValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeRejectedWith(\n            `fileUpload.${key} must be a boolean value.`\n          );\n        }\n        for (const value of validValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeResolved();\n        }\n      }\n      await expectAsync(\n        reconfigureServer({\n          fileUpload: {\n            fileExtensions: 1,\n          },\n        })\n      ).toBeRejectedWith('fileUpload.fileExtensions must be an array.');\n    });\n  });\n\n  describe('fileExtensions', () => {\n    it('works with _ContentType', async () => {\n      await reconfigureServer({\n        silent: false,\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['png'],\n        },\n      });\n      await expectAsync(\n        request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/files/file',\n          body: JSON.stringify({\n            _ApplicationId: 'test',\n            _JavaScriptKey: 'test',\n            _ContentType: 'text/html',\n            base64: 'PGh0bWw+PC9odG1sPgo=',\n          }),\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('works without Content-Type', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n        },\n      });\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      await expectAsync(\n        request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/files/file.html',\n          body: '<html></html>\\n',\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('allows file without extension', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['^[^hH][^tT][^mM][^lL]?$'],\n        },\n      });\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n\n      const values = ['filenamewithoutextension'];\n\n      for (const value of values) {\n        await expectAsync(\n          request({\n            method: 'POST',\n            headers: headers,\n            url: `http://localhost:8378/1/files/${value}`,\n            body: '<html></html>\\n',\n          }).catch(e => {\n            throw new Error(e.data.error);\n          })\n        ).toBeResolved();\n      }\n    });\n\n    it('works with array', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['jpg'],\n        },\n      });\n      await expectAsync(\n        request({\n          method: 'POST',\n          url: 'http://localhost:8378/1/files/file',\n          body: JSON.stringify({\n            _ApplicationId: 'test',\n            _JavaScriptKey: 'test',\n            _ContentType: 'text/html',\n            base64: 'PGh0bWw+PC9odG1sPgo=',\n          }),\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('works with array without Content-Type', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['jpg'],\n        },\n      });\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      await expectAsync(\n        request({\n          method: 'POST',\n          headers: headers,\n          url: 'http://localhost:8378/1/files/file.html',\n          body: '<html></html>\\n',\n        }).catch(e => {\n          throw new Error(e.data.error);\n        })\n      ).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, `File upload of extension html is disabled.`)\n      );\n    });\n\n    it('works with array with correct file type', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          fileExtensions: ['html'],\n        },\n      });\n      const response = await request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/files/file',\n        body: JSON.stringify({\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ContentType: 'text/html',\n          base64: 'PGh0bWw+PC9odG1sPgo=',\n        }),\n      });\n      const b = response.data;\n      expect(b.name).toMatch(/_file.html$/);\n      expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.html$/);\n    });\n  });\n});\n", "import express from 'express';\nimport BodyParser from 'body-parser';\nimport * as Middlewares from '../middlewares';\nimport Parse from 'parse/node';\nimport Config from '../Config';\nimport mime from 'mime';\nimport logger from '../logger';\nconst triggers = require('../triggers');\nconst http = require('http');\nconst Utils = require('../Utils');\n\nconst downloadFileFromURI = uri => {\n  return new Promise((res, rej) => {\n    http\n      .get(uri, response => {\n        response.setDefaultEncoding('base64');\n        let body = `data:${response.headers['content-type']};base64,`;\n        response.on('data', data => (body += data));\n        response.on('end', () => res(body));\n      })\n      .on('error', e => {\n        rej(`Error downloading file from ${uri}: ${e.message}`);\n      });\n  });\n};\n\nconst addFileDataIfNeeded = async file => {\n  if (file._source.format === 'uri') {\n    const base64 = await downloadFileFromURI(file._source.uri);\n    file._previousSave = file;\n    file._data = base64;\n    file._requestTask = null;\n  }\n  return file;\n};\n\nexport class FilesRouter {\n  expressRouter({ maxUploadSize = '20Mb' } = {}) {\n    var router = express.Router();\n    router.get('/files/:appId/:filename', this.getHandler);\n    router.get('/files/:appId/metadata/:filename', this.metadataHandler);\n\n    router.post('/files', function (req, res, next) {\n      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));\n    });\n\n    router.post(\n      '/files/:filename',\n      BodyParser.raw({\n        type: () => {\n          return true;\n        },\n        limit: maxUploadSize,\n      }), // Allow uploads without Content-Type, or with any Content-Type.\n      Middlewares.handleParseHeaders,\n      this.createHandler\n    );\n\n    router.delete(\n      '/files/:filename',\n      Middlewares.handleParseHeaders,\n      Middlewares.enforceMasterKeyAccess,\n      this.deleteHandler\n    );\n    return router;\n  }\n\n  getHandler(req, res) {\n    const config = Config.get(req.params.appId);\n    if (!config) {\n      res.status(403);\n      const err = new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Invalid application ID.');\n      res.json({ code: err.code, error: err.message });\n      return;\n    }\n    const filesController = config.filesController;\n    const filename = req.params.filename;\n    const contentType = mime.getType(filename);\n    if (isFileStreamable(req, filesController)) {\n      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {\n        res.status(404);\n        res.set('Content-Type', 'text/plain');\n        res.end('File not found.');\n      });\n    } else {\n      filesController\n        .getFileData(config, filename)\n        .then(data => {\n          res.status(200);\n          res.set('Content-Type', contentType);\n          res.set('Content-Length', data.length);\n          res.end(data);\n        })\n        .catch(() => {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n    }\n  }\n\n  async createHandler(req, res, next) {\n    const config = req.config;\n    const user = req.auth.user;\n    const isMaster = req.auth.isMaster;\n    const isLinked = user && Parse.AnonymousUtils.isLinked(user);\n    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {\n      next(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {\n      next(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForPublic && !user) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      return;\n    }\n    const filesController = config.filesController;\n    const { filename } = req.params;\n    const contentType = req.get('Content-type');\n\n    if (!req.body || !req.body.length) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));\n      return;\n    }\n\n    const error = filesController.validateFilename(filename);\n    if (error) {\n      next(error);\n      return;\n    }\n\n    const fileExtensions = config.fileUpload?.fileExtensions;\n    if (!isMaster && fileExtensions) {\n      const isValidExtension = extension => {\n        return fileExtensions.some(ext => {\n          if (ext === '*') {\n            return true;\n          }\n          const regex = new RegExp(fileExtensions);\n          if (regex.test(extension)) {\n            return true;\n          }\n        });\n      };\n      let extension = contentType;\n      if (filename && filename.includes('.')) {\n        extension = filename.split('.')[1];\n      } else if (contentType && contentType.includes('/')) {\n        extension = contentType.split('/')[1];\n      }\n      extension = extension?.split(' ')?.join('');\n\n      if (extension && !isValidExtension(extension)) {\n        next(\n          new Parse.Error(\n            Parse.Error.FILE_SAVE_ERROR,\n            `File upload of extension ${extension} is disabled.`\n          )\n        );\n        return;\n      }\n    }\n\n    const base64 = req.body.toString('base64');\n    const file = new Parse.File(filename, { base64 }, contentType);\n    const { metadata = {}, tags = {} } = req.fileData || {};\n    try {\n      // Scan request data for denied keywords\n      Utils.checkProhibitedKeywords(config, metadata);\n      Utils.checkProhibitedKeywords(config, tags);\n    } catch (error) {\n      next(new Parse.Error(Parse.Error.INVALID_KEY_NAME, error));\n      return;\n    }\n    file.setTags(tags);\n    file.setMetadata(metadata);\n    const fileSize = Buffer.byteLength(req.body);\n    const fileObject = { file, fileSize };\n    try {\n      // run beforeSaveFile trigger\n      const triggerResult = await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeSave,\n        fileObject,\n        config,\n        req.auth\n      );\n      let saveResult;\n      // if a new ParseFile is returned check if it's an already saved file\n      if (triggerResult instanceof Parse.File) {\n        fileObject.file = triggerResult;\n        if (triggerResult.url()) {\n          // set fileSize to null because we wont know how big it is here\n          fileObject.fileSize = null;\n          saveResult = {\n            url: triggerResult.url(),\n            name: triggerResult._name,\n          };\n        }\n      }\n      // if the file returned by the trigger has already been saved skip saving anything\n      if (!saveResult) {\n        // if the ParseFile returned is type uri, download the file before saving it\n        await addFileDataIfNeeded(fileObject.file);\n        // update fileSize\n        const bufferData = Buffer.from(fileObject.file._data, 'base64');\n        fileObject.fileSize = Buffer.byteLength(bufferData);\n        // prepare file options\n        const fileOptions = {\n          metadata: fileObject.file._metadata,\n        };\n        // some s3-compatible providers (DigitalOcean, Linode) do not accept tags\n        // so we do not include the tags option if it is empty.\n        const fileTags =\n          Object.keys(fileObject.file._tags).length > 0 ? { tags: fileObject.file._tags } : {};\n        Object.assign(fileOptions, fileTags);\n        // save file\n        const createFileResult = await filesController.createFile(\n          config,\n          fileObject.file._name,\n          bufferData,\n          fileObject.file._source.type,\n          fileOptions\n        );\n        // update file with new data\n        fileObject.file._name = createFileResult.name;\n        fileObject.file._url = createFileResult.url;\n        fileObject.file._requestTask = null;\n        fileObject.file._previousSave = Promise.resolve(fileObject.file);\n        saveResult = {\n          url: createFileResult.url,\n          name: createFileResult.name,\n        };\n      }\n      // run afterSaveFile trigger\n      await triggers.maybeRunFileTrigger(triggers.Types.afterSave, fileObject, config, req.auth);\n      res.status(201);\n      res.set('Location', saveResult.url);\n      res.json(saveResult);\n    } catch (e) {\n      logger.error('Error creating a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_SAVE_ERROR,\n        message: `Could not store file: ${fileObject.file._name}.`,\n      });\n      next(error);\n    }\n  }\n\n  async deleteHandler(req, res, next) {\n    try {\n      const { filesController } = req.config;\n      const { filename } = req.params;\n      // run beforeDeleteFile trigger\n      const file = new Parse.File(filename);\n      file._url = filesController.adapter.getFileLocation(req.config, filename);\n      const fileObject = { file, fileSize: null };\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      // delete file\n      await filesController.deleteFile(req.config, filename);\n      // run afterDeleteFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      res.status(200);\n      // TODO: return useful JSON here?\n      res.end();\n    } catch (e) {\n      logger.error('Error deleting a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_DELETE_ERROR,\n        message: 'Could not delete file.',\n      });\n      next(error);\n    }\n  }\n\n  async metadataHandler(req, res) {\n    try {\n      const config = Config.get(req.params.appId);\n      const { filesController } = config;\n      const { filename } = req.params;\n      const data = await filesController.getMetadata(filename);\n      res.status(200);\n      res.json(data);\n    } catch (e) {\n      res.status(200);\n      res.json({});\n    }\n  }\n}\n\nfunction isFileStreamable(req, filesController) {\n  const range = (req.get('Range') || '/-/').split('-');\n  const start = Number(range[0]);\n  const end = Number(range[1]);\n  return (\n    (!isNaN(start) || !isNaN(end)) && typeof filesController.adapter.handleFileStream === 'function'\n  );\n}\n"], "filenames": ["spec/ParseFile.spec.js", "src/Routers/FilesRouter.js"], "buggy_code_start_loc": [1368, 160], "buggy_code_end_loc": [1368, 163], "fixing_code_start_loc": [1369, 160], "fixing_code_end_loc": [1397, 163], "type": "CWE-22", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Parse Server crashes when uploading a file without extension. This vulnerability has been patched in versions 5.5.6 and 6.3.1.\n\n", "other": {"cve": {"id": "CVE-2023-46119", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-25T18:17:36.183", "lastModified": "2023-11-01T17:09:01.520", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Parse Server crashes when uploading a file without extension. This vulnerability has been patched in versions 5.5.6 and 6.3.1.\n\n"}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que se puede implementar en cualquier infraestructura que pueda ejecutar Node.js. Parse Server falla al cargar un archivo sin extensi\u00f3n. Esta vulnerabilidad ha sido parcheada en las versiones 5.5.6 y 6.3.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-23"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "5.5.6", "matchCriteriaId": "DD729BE7-3FF0-420D-BB40-5CC4D7AAA89A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.3.1", "matchCriteriaId": "E2229024-7226-4410-85D7-80CDA49F303B"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/686a9f282dc23c31beab3d93e6d21ccd0e1328fe", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/parse-community/parse-server/commit/fd86278919556d3682e7e2c856dfccd5beffbfc0", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/5.5.6", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/6.3.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-792q-q67h-w579", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/686a9f282dc23c31beab3d93e6d21ccd0e1328fe"}}