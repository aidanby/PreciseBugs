{"buggy_code": ["# ***** BEGIN LICENSE BLOCK *****\n# Copyright (c) 2011-2012 VMware, Inc.\n#\n# For the license see COPYING.\n# ***** END LICENSE BLOCK *****\n\nurl = require('url')\nquerystring = require('querystring')\nfs = require('fs')\nhttp = require('http')\n\nutils = require('./utils')\n\n\nexecute_request = (app, funs, req, res, data) ->\n    try\n        while funs.length > 0\n            fun = funs.shift()\n            req.last_fun = fun\n            data = app[fun](req, res, data, req.next_filter)\n    catch x\n        if typeof x is 'object' and 'status' of x\n            if x.status is 0\n                return\n            else if 'handle_' + x.status of app\n                app['handle_' + x.status](req, res, x)\n            else\n                app['handle_error'](req, res, x)\n        else\n           app['handle_error'](req, res, x)\n        app['log_request'](req, res, true)\n\n\nfake_response = (req, res) ->\n        # This is quite simplistic, don't expect much.\n        headers = {'Connection': 'close'}\n        res.writeHead = (status, user_headers = {}) ->\n            r = []\n            r.push('HTTP/' + req.httpVersion + ' ' + status +\n                   ' ' + http.STATUS_CODES[status])\n            utils.objectExtend(headers, user_headers)\n            for k of headers\n                r.push(k + ': ' + headers[k])\n            r = r.concat(['', ''])\n            try\n                res.write(r.join('\\r\\n'))\n            catch x\n            try\n                res.end()\n            catch x\n        res.setHeader = (k, v) -> headers[k] = v\n\n\nexports.generateHandler = (app, dispatcher) ->\n    return (req, res, head) ->\n        if typeof res.writeHead is \"undefined\"\n            fake_response(req, res)\n        utils.objectExtend(req, url.parse(req.url, true))\n        req.start_date = new Date()\n\n        found = false\n        allowed_methods = []\n        for row in dispatcher\n            [method, path, funs] = row\n            if path.constructor isnt Array\n                path = [path]\n            # path[0] must be a regexp\n            m = req.pathname.match(path[0])\n            if not m\n                continue\n            if not req.method.match(new RegExp(method))\n                allowed_methods.push(method)\n                continue\n            for i in [1...path.length]\n                req[path[i]] = m[i]\n            funs = funs[0..]\n            funs.push('log_request')\n            req.next_filter = (data) ->\n                execute_request(app, funs, req, res, data)\n            req.next_filter(head)\n            found = true\n            break\n\n        if not found\n            if allowed_methods.length isnt 0\n                app['handle_405'](req, res, allowed_methods)\n            else\n                app['handle_404'](req, res)\n            app['log_request'](req, res, true)\n        return\n\nexports.GenericApp = class GenericApp\n    handle_404: (req, res, x) ->\n        if res.finished\n            return x\n        res.writeHead(404, {})\n        res.end()\n        return true\n\n    handle_405:(req, res, methods) ->\n        res.writeHead(405, {'Allow': methods.join(', ')})\n        res.end()\n        return true\n\n    handle_error: (req, res, x) ->\n        # console.log('handle_error', x.stack)\n        if res.finished\n            return x\n        if typeof x is 'object' and 'status' of x\n            res.writeHead(x.status, {})\n            res.end((x.message or \"\"))\n        else\n            try\n                res.writeHead(500, {})\n                res.end(\"500 - Internal Server Error\")\n            catch x\n            @log('error', 'Exception on \"'+ req.method + ' ' + req.href + '\" in filter \"' + req.last_fun + '\":\\n' + (x.stack || x))\n        return true\n\n    log_request: (req, res, data) ->\n        td = (new Date()) - req.start_date\n        @log('info', req.method + ' ' + req.url + ' ' + td + 'ms ' +\n                (if res.finished then res.statusCode else '(unfinished)'))\n        return data\n\n    log: (severity, line) ->\n        console.log(line)\n\n    expose_html: (req, res, content) ->\n        if res.finished\n            return content\n        if not res.getHeader('Content-Type')\n            res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n        return @expose(req, res, content)\n\n    expose_json: (req, res, content) ->\n        if res.finished\n            return content\n        if not res.getHeader('Content-Type')\n            res.setHeader('Content-Type', 'application/json')\n        return @expose(req, res, JSON.stringify(content))\n\n    expose: (req, res, content) ->\n        if res.finished\n            return content\n        if content and not res.getHeader('Content-Type')\n            res.setHeader('Content-Type', 'text/plain')\n        if content\n            res.setHeader('Content-Length', content.length)\n        res.writeHead(res.statusCode)\n        res.end(content, 'utf8')\n        return true\n\n    serve_file: (req, res, filename, next_filter) ->\n        a = (error, content) ->\n            if error\n                res.writeHead(500)\n                res.end(\"can't read file\")\n            else\n                res.setHeader('Content-length', content.length)\n                res.writeHead(res.statusCode, res.headers)\n                res.end(content, 'utf8')\n            next_filter(true)\n        fs.readFile(filename, a)\n        throw {status:0}\n\n    cache_for: (req, res, content) ->\n        res.cache_for = res.cache_for or 365 * 24 * 60 * 60 # one year.\n        # See: http://code.google.com/speed/page-speed/docs/caching.html\n        res.setHeader('Cache-Control', 'public, max-age=' + res.cache_for)\n        exp = new Date()\n        exp.setTime(exp.getTime() + res.cache_for * 1000)\n        res.setHeader('Expires', exp.toGMTString())\n        return content\n\n    h_no_cache: (req, res, content) ->\n        res.setHeader('Cache-Control', 'no-store, no-cache, no-transform, must-revalidate, max-age=0')\n        return content\n\n    expect_form: (req, res, _data, next_filter) ->\n        data = new Buffer(0)\n        req.on 'data', (d) =>\n            data = utils.buffer_concat(data, new Buffer(d, 'binary'))\n        req.on 'end', =>\n            data = data.toString('utf-8')\n            switch (req.headers['content-type'] or '').split(';')[0]\n                when 'application/x-www-form-urlencoded'\n                    q = querystring.parse(data)\n                when 'text/plain', ''\n                    q = data\n                else\n                    @log('error', \"Unsupported content-type \" +\n                                  req.headers['content-type'])\n                    q = undefined\n            next_filter(q)\n        throw {status:0}\n\n    expect_xhr: (req, res, _data, next_filter) ->\n        data = new Buffer(0)\n        req.on 'data', (d) =>\n            data = utils.buffer_concat(data, new Buffer(d, 'binary'))\n        req.on 'end', =>\n            data = data.toString('utf-8')\n            switch (req.headers['content-type'] or '').split(';')[0]\n                when 'text/plain', 'T', 'application/json', 'application/xml', '', 'text/xml'\n                    q = data\n                else\n                    @log('error', 'Unsupported content-type ' +\n                                  req.headers['content-type'])\n                    q = undefined\n            next_filter(q)\n        throw {status:0}\n"], "fixing_code": ["# ***** BEGIN LICENSE BLOCK *****\n# Copyright (c) 2011-2012 VMware, Inc.\n#\n# For the license see COPYING.\n# ***** END LICENSE BLOCK *****\n\nurl = require('url')\nquerystring = require('querystring')\nfs = require('fs')\nhttp = require('http')\n\nutils = require('./utils')\n\n\nexecute_request = (app, funs, req, res, data) ->\n    try\n        while funs.length > 0\n            fun = funs.shift()\n            req.last_fun = fun\n            data = app[fun](req, res, data, req.next_filter)\n    catch x\n        if typeof x is 'object' and 'status' of x\n            if x.status is 0\n                return\n            else if 'handle_' + x.status of app\n                app['handle_' + x.status](req, res, x)\n            else\n                app['handle_error'](req, res, x)\n        else\n           app['handle_error'](req, res, x)\n        app['log_request'](req, res, true)\n\n\nfake_response = (req, res) ->\n        # This is quite simplistic, don't expect much.\n        headers = {'Connection': 'close'}\n        res.writeHead = (status, user_headers = {}) ->\n            r = []\n            r.push('HTTP/' + req.httpVersion + ' ' + status +\n                   ' ' + http.STATUS_CODES[status])\n            utils.objectExtend(headers, user_headers)\n            for k of headers\n                r.push(k + ': ' + headers[k])\n            r = r.concat(['', ''])\n            try\n                res.write(r.join('\\r\\n'))\n            catch x\n        res.setHeader = (k, v) -> headers[k] = v\n\n\nexports.generateHandler = (app, dispatcher) ->\n    return (req, res, head) ->\n        if typeof res.writeHead is \"undefined\"\n            fake_response(req, res)\n        utils.objectExtend(req, url.parse(req.url, true))\n        req.start_date = new Date()\n\n        found = false\n        allowed_methods = []\n        for row in dispatcher\n            [method, path, funs] = row\n            if path.constructor isnt Array\n                path = [path]\n            # path[0] must be a regexp\n            m = req.pathname.match(path[0])\n            if not m\n                continue\n            if not req.method.match(new RegExp(method))\n                allowed_methods.push(method)\n                continue\n            for i in [1...path.length]\n                req[path[i]] = m[i]\n            funs = funs[0..]\n            funs.push('log_request')\n            req.next_filter = (data) ->\n                execute_request(app, funs, req, res, data)\n            req.next_filter(head)\n            found = true\n            break\n\n        if not found\n            if allowed_methods.length isnt 0\n                app['handle_405'](req, res, allowed_methods)\n            else\n                app['handle_404'](req, res)\n            app['log_request'](req, res, true)\n        return\n\nexports.GenericApp = class GenericApp\n    handle_404: (req, res, x) ->\n        if res.finished\n            return x\n        res.writeHead(404, {})\n        res.end()\n        return true\n\n    handle_405:(req, res, methods) ->\n        res.writeHead(405, {'Allow': methods.join(', ')})\n        res.end()\n        return true\n\n    handle_error: (req, res, x) ->\n        # console.log('handle_error', x.stack)\n        if res.finished\n            return x\n        if typeof x is 'object' and 'status' of x\n            res.writeHead(x.status, {})\n            res.end((x.message or \"\"))\n        else\n            try\n                res.writeHead(500, {})\n                res.end(\"500 - Internal Server Error\")\n            catch x\n            @log('error', 'Exception on \"'+ req.method + ' ' + req.href + '\" in filter \"' + req.last_fun + '\":\\n' + (x.stack || x))\n        return true\n\n    log_request: (req, res, data) ->\n        td = (new Date()) - req.start_date\n        @log('info', req.method + ' ' + req.url + ' ' + td + 'ms ' +\n                (if res.finished then res.statusCode else '(unfinished)'))\n        return data\n\n    log: (severity, line) ->\n        console.log(line)\n\n    expose_html: (req, res, content) ->\n        if res.finished\n            return content\n        if not res.getHeader('Content-Type')\n            res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n        return @expose(req, res, content)\n\n    expose_json: (req, res, content) ->\n        if res.finished\n            return content\n        if not res.getHeader('Content-Type')\n            res.setHeader('Content-Type', 'application/json')\n        return @expose(req, res, JSON.stringify(content))\n\n    expose: (req, res, content) ->\n        if res.finished\n            return content\n        if content and not res.getHeader('Content-Type')\n            res.setHeader('Content-Type', 'text/plain')\n        if content\n            res.setHeader('Content-Length', content.length)\n        res.writeHead(res.statusCode)\n        res.end(content, 'utf8')\n        return true\n\n    serve_file: (req, res, filename, next_filter) ->\n        a = (error, content) ->\n            if error\n                res.writeHead(500)\n                res.end(\"can't read file\")\n            else\n                res.setHeader('Content-length', content.length)\n                res.writeHead(res.statusCode, res.headers)\n                res.end(content, 'utf8')\n            next_filter(true)\n        fs.readFile(filename, a)\n        throw {status:0}\n\n    cache_for: (req, res, content) ->\n        res.cache_for = res.cache_for or 365 * 24 * 60 * 60 # one year.\n        # See: http://code.google.com/speed/page-speed/docs/caching.html\n        res.setHeader('Cache-Control', 'public, max-age=' + res.cache_for)\n        exp = new Date()\n        exp.setTime(exp.getTime() + res.cache_for * 1000)\n        res.setHeader('Expires', exp.toGMTString())\n        return content\n\n    h_no_cache: (req, res, content) ->\n        res.setHeader('Cache-Control', 'no-store, no-cache, no-transform, must-revalidate, max-age=0')\n        return content\n\n    expect_form: (req, res, _data, next_filter) ->\n        data = new Buffer(0)\n        req.on 'data', (d) =>\n            data = utils.buffer_concat(data, new Buffer(d, 'binary'))\n        req.on 'end', =>\n            data = data.toString('utf-8')\n            switch (req.headers['content-type'] or '').split(';')[0]\n                when 'application/x-www-form-urlencoded'\n                    q = querystring.parse(data)\n                when 'text/plain', ''\n                    q = data\n                else\n                    @log('error', \"Unsupported content-type \" +\n                                  req.headers['content-type'])\n                    q = undefined\n            next_filter(q)\n        throw {status:0}\n\n    expect_xhr: (req, res, _data, next_filter) ->\n        data = new Buffer(0)\n        req.on 'data', (d) =>\n            data = utils.buffer_concat(data, new Buffer(d, 'binary'))\n        req.on 'end', =>\n            data = data.toString('utf-8')\n            switch (req.headers['content-type'] or '').split(';')[0]\n                when 'text/plain', 'T', 'application/json', 'application/xml', '', 'text/xml'\n                    q = data\n                else\n                    @log('error', 'Unsupported content-type ' +\n                                  req.headers['content-type'])\n                    q = undefined\n            next_filter(q)\n        throw {status:0}\n"], "filenames": ["src/webjs.coffee"], "buggy_code_start_loc": [47], "buggy_code_end_loc": [50], "fixing_code_start_loc": [46], "fixing_code_end_loc": [46], "type": "CWE-755", "message": "Incorrect handling of Upgrade header with the value websocket leads in crashing of containers hosting sockjs apps. This affects the package sockjs before 0.3.20.", "other": {"cve": {"id": "CVE-2020-7693", "sourceIdentifier": "report@snyk.io", "published": "2020-07-09T14:15:11.197", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Incorrect handling of Upgrade header with the value websocket leads in crashing of containers hosting sockjs apps. This affects the package sockjs before 0.3.20."}, {"lang": "es", "value": "El manejo incorrecto del encabezado Upgrade con el valor websocket conlleva en un bloqueo de contenedores que alojan aplicaciones sockjs. Esto afecta el paquete sockjs versiones anteriores a 0.3.20"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sockjs_project:sockjs:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.3.20", "matchCriteriaId": "3C576127-F274-4E41-ACA9-24E32CA01599"}]}]}], "references": [{"url": "https://github.com/andsnw/sockjs-dos-py", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/sockjs/sockjs-node/commit/dd7e642cd69ee74385825816d30642c43e051d16", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sockjs/sockjs-node/issues/252", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/sockjs/sockjs-node/pull/265", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-575448", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-SOCKJS-575261", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sockjs/sockjs-node/commit/dd7e642cd69ee74385825816d30642c43e051d16"}}