{"buggy_code": [".. _topics-downloader-middleware:\n\n=====================\nDownloader Middleware\n=====================\n\nThe downloader middleware is a framework of hooks into Scrapy's\nrequest/response processing.  It's a light, low-level system for globally\naltering Scrapy's requests and responses.\n\n.. _topics-downloader-middleware-setting:\n\nActivating a downloader middleware\n==================================\n\nTo activate a downloader middleware component, add it to the\n:setting:`DOWNLOADER_MIDDLEWARES` setting, which is a dict whose keys are the\nmiddleware class paths and their values are the middleware orders.\n\nHere's an example::\n\n    DOWNLOADER_MIDDLEWARES = {\n        'myproject.middlewares.CustomDownloaderMiddleware': 543,\n    }\n\nThe :setting:`DOWNLOADER_MIDDLEWARES` setting is merged with the\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` setting defined in Scrapy (and not meant\nto be overridden) and then sorted by order to get the final sorted list of\nenabled middlewares: the first middleware is the one closer to the engine and\nthe last is the one closer to the downloader. In other words,\nthe :meth:`~scrapy.downloadermiddlewares.DownloaderMiddleware.process_request`\nmethod of each middleware will be invoked in increasing\nmiddleware order (100, 200, 300, ...) and the :meth:`~scrapy.downloadermiddlewares.DownloaderMiddleware.process_response` method\nof each middleware will be invoked in decreasing order.\n\nTo decide which order to assign to your middleware see the\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` setting and pick a value according to\nwhere you want to insert the middleware. The order does matter because each\nmiddleware performs a different action and your middleware could depend on some\nprevious (or subsequent) middleware being applied.\n\nIf you want to disable a built-in middleware (the ones defined in\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` and enabled by default) you must define it\nin your project's :setting:`DOWNLOADER_MIDDLEWARES` setting and assign ``None``\nas its value.  For example, if you want to disable the user-agent middleware::\n\n    DOWNLOADER_MIDDLEWARES = {\n        'myproject.middlewares.CustomDownloaderMiddleware': 543,\n        'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,\n    }\n\nFinally, keep in mind that some middlewares may need to be enabled through a\nparticular setting. See each middleware documentation for more info.\n\n.. _topics-downloader-middleware-custom:\n\nWriting your own downloader middleware\n======================================\n\nEach downloader middleware is a Python class that defines one or more of the\nmethods defined below.\n\nThe main entry point is the ``from_crawler`` class method, which receives a\n:class:`~scrapy.crawler.Crawler` instance. The :class:`~scrapy.crawler.Crawler`\nobject gives you access, for example, to the :ref:`settings <topics-settings>`.\n\n.. module:: scrapy.downloadermiddlewares\n\n.. class:: DownloaderMiddleware\n\n   .. note::  Any of the downloader middleware methods may also return a deferred.\n\n   .. method:: process_request(request, spider)\n\n      This method is called for each request that goes through the download\n      middleware.\n\n      :meth:`process_request` should either: return ``None``, return a\n      :class:`~scrapy.http.Response` object, return a :class:`~scrapy.http.Request`\n      object, or raise :exc:`~scrapy.exceptions.IgnoreRequest`.\n\n      If it returns ``None``, Scrapy will continue processing this request, executing all\n      other middlewares until, finally, the appropriate downloader handler is called\n      the request performed (and its response downloaded).\n\n      If it returns a :class:`~scrapy.http.Response` object, Scrapy won't bother\n      calling *any* other :meth:`process_request` or :meth:`process_exception` methods,\n      or the appropriate download function; it'll return that response. The :meth:`process_response`\n      methods of installed middleware is always called on every response.\n\n      If it returns a :class:`~scrapy.http.Request` object, Scrapy will stop calling\n      process_request methods and reschedule the returned request. Once the newly returned\n      request is performed, the appropriate middleware chain will be called on\n      the downloaded response.\n\n      If it raises an :exc:`~scrapy.exceptions.IgnoreRequest` exception, the\n      :meth:`process_exception` methods of installed downloader middleware will be called.\n      If none of them handle the exception, the errback function of the request\n      (``Request.errback``) is called. If no code handles the raised exception, it is\n      ignored and not logged (unlike other exceptions).\n\n      :param request: the request being processed\n      :type request: :class:`~scrapy.http.Request` object\n\n      :param spider: the spider for which this request is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n   .. method:: process_response(request, response, spider)\n\n      :meth:`process_response` should either: return a :class:`~scrapy.http.Response`\n      object, return a :class:`~scrapy.http.Request` object or\n      raise a :exc:`~scrapy.exceptions.IgnoreRequest` exception.\n\n      If it returns a :class:`~scrapy.http.Response` (it could be the same given\n      response, or a brand-new one), that response will continue to be processed\n      with the :meth:`process_response` of the next middleware in the chain.\n\n      If it returns a :class:`~scrapy.http.Request` object, the middleware chain is\n      halted and the returned request is rescheduled to be downloaded in the future.\n      This is the same behavior as if a request is returned from :meth:`process_request`.\n\n      If it raises an :exc:`~scrapy.exceptions.IgnoreRequest` exception, the errback\n      function of the request (``Request.errback``) is called. If no code handles the raised\n      exception, it is ignored and not logged (unlike other exceptions).\n\n      :param request: the request that originated the response\n      :type request: is a :class:`~scrapy.http.Request` object\n\n      :param response: the response being processed\n      :type response: :class:`~scrapy.http.Response` object\n\n      :param spider: the spider for which this response is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n   .. method:: process_exception(request, exception, spider)\n\n      Scrapy calls :meth:`process_exception` when a download handler\n      or a :meth:`process_request` (from a downloader middleware) raises an\n      exception (including an :exc:`~scrapy.exceptions.IgnoreRequest` exception)\n\n      :meth:`process_exception` should return: either ``None``,\n      a :class:`~scrapy.http.Response` object, or a :class:`~scrapy.http.Request` object.\n\n      If it returns ``None``, Scrapy will continue processing this exception,\n      executing any other :meth:`process_exception` methods of installed middleware,\n      until no middleware is left and the default exception handling kicks in.\n\n      If it returns a :class:`~scrapy.http.Response` object, the :meth:`process_response`\n      method chain of installed middleware is started, and Scrapy won't bother calling\n      any other :meth:`process_exception` methods of middleware.\n\n      If it returns a :class:`~scrapy.http.Request` object, the returned request is\n      rescheduled to be downloaded in the future. This stops the execution of\n      :meth:`process_exception` methods of the middleware the same as returning a\n      response would.\n\n      :param request: the request that generated the exception\n      :type request: is a :class:`~scrapy.http.Request` object\n\n      :param exception: the raised exception\n      :type exception: an ``Exception`` object\n\n      :param spider: the spider for which this request is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n   .. method:: from_crawler(cls, crawler)\n\n      If present, this classmethod is called to create a middleware instance\n      from a :class:`~scrapy.crawler.Crawler`. It must return a new instance\n      of the middleware. Crawler object provides access to all Scrapy core\n      components like settings and signals; it is a way for middleware to\n      access them and hook its functionality into Scrapy.\n\n      :param crawler: crawler that uses this middleware\n      :type crawler: :class:`~scrapy.crawler.Crawler` object\n\n.. _topics-downloader-middleware-ref:\n\nBuilt-in downloader middleware reference\n========================================\n\nThis page describes all downloader middleware components that come with\nScrapy. For information on how to use them and how to write your own downloader\nmiddleware, see the :ref:`downloader middleware usage guide\n<topics-downloader-middleware>`.\n\nFor a list of the components enabled by default (and their orders) see the\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` setting.\n\n.. _cookies-mw:\n\nCookiesMiddleware\n-----------------\n\n.. module:: scrapy.downloadermiddlewares.cookies\n   :synopsis: Cookies Downloader Middleware\n\n.. class:: CookiesMiddleware\n\n   This middleware enables working with sites that require cookies, such as\n   those that use sessions. It keeps track of cookies sent by web servers, and\n   send them back on subsequent requests (from that spider), just like web\n   browsers do.\n\nThe following settings can be used to configure the cookie middleware:\n\n* :setting:`COOKIES_ENABLED`\n* :setting:`COOKIES_DEBUG`\n\n.. reqmeta:: cookiejar\n\nMultiple cookie sessions per spider\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. versionadded:: 0.15\n\nThere is support for keeping multiple cookie sessions per spider by using the\n:reqmeta:`cookiejar` Request meta key. By default it uses a single cookie jar\n(session), but you can pass an identifier to use different ones.\n\nFor example::\n\n    for i, url in enumerate(urls):\n        yield scrapy.Request(url, meta={'cookiejar': i},\n            callback=self.parse_page)\n\nKeep in mind that the :reqmeta:`cookiejar` meta key is not \"sticky\". You need to keep\npassing it along on subsequent requests. For example::\n\n    def parse_page(self, response):\n        # do some processing\n        return scrapy.Request(\"http://www.example.com/otherpage\",\n            meta={'cookiejar': response.meta['cookiejar']},\n            callback=self.parse_other_page)\n\n.. setting:: COOKIES_ENABLED\n\nCOOKIES_ENABLED\n~~~~~~~~~~~~~~~\n\nDefault: ``True``\n\nWhether to enable the cookies middleware. If disabled, no cookies will be sent\nto web servers.\n\nNotice that despite the value of :setting:`COOKIES_ENABLED` setting if\n``Request.``:reqmeta:`meta['dont_merge_cookies'] <dont_merge_cookies>`\nevaluates to ``True`` the request cookies will **not** be sent to the\nweb server and received cookies in :class:`~scrapy.http.Response` will\n**not** be merged with the existing cookies.\n\nFor more detailed information see the ``cookies`` parameter in\n:class:`~scrapy.http.Request`.\n\n.. setting:: COOKIES_DEBUG\n\nCOOKIES_DEBUG\n~~~~~~~~~~~~~\n\nDefault: ``False``\n\nIf enabled, Scrapy will log all cookies sent in requests (ie. ``Cookie``\nheader) and all cookies received in responses (ie. ``Set-Cookie`` header).\n\nHere's an example of a log with :setting:`COOKIES_DEBUG` enabled::\n\n    2011-04-06 14:35:10-0300 [scrapy.core.engine] INFO: Spider opened\n    2011-04-06 14:35:10-0300 [scrapy.downloadermiddlewares.cookies] DEBUG: Sending cookies to: <GET http://www.diningcity.com/netherlands/index.html>\n            Cookie: clientlanguage_nl=en_EN\n    2011-04-06 14:35:14-0300 [scrapy.downloadermiddlewares.cookies] DEBUG: Received cookies from: <200 http://www.diningcity.com/netherlands/index.html>\n            Set-Cookie: JSESSIONID=B~FA4DC0C496C8762AE4F1A620EAB34F38; Path=/\n            Set-Cookie: ip_isocode=US\n            Set-Cookie: clientlanguage_nl=en_EN; Expires=Thu, 07-Apr-2011 21:21:34 GMT; Path=/\n    2011-04-06 14:49:50-0300 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.diningcity.com/netherlands/index.html> (referer: None)\n    [...]\n\n\nDefaultHeadersMiddleware\n------------------------\n\n.. module:: scrapy.downloadermiddlewares.defaultheaders\n   :synopsis: Default Headers Downloader Middleware\n\n.. class:: DefaultHeadersMiddleware\n\n    This middleware sets all default requests headers specified in the\n    :setting:`DEFAULT_REQUEST_HEADERS` setting.\n\nDownloadTimeoutMiddleware\n-------------------------\n\n.. module:: scrapy.downloadermiddlewares.downloadtimeout\n   :synopsis: Download timeout middleware\n\n.. class:: DownloadTimeoutMiddleware\n\n    This middleware sets the download timeout for requests specified in the\n    :setting:`DOWNLOAD_TIMEOUT` setting or :attr:`download_timeout`\n    spider attribute.\n\n.. note::\n\n    You can also set download timeout per-request using\n    :reqmeta:`download_timeout` Request.meta key; this is supported\n    even when DownloadTimeoutMiddleware is disabled.\n\nHttpAuthMiddleware\n------------------\n\n.. module:: scrapy.downloadermiddlewares.httpauth\n   :synopsis: HTTP Auth downloader middleware\n\n.. class:: HttpAuthMiddleware\n\n    This middleware authenticates all requests generated from certain spiders\n    using `Basic access authentication`_ (aka. HTTP auth).\n\n    To enable HTTP authentication from certain spiders, set the ``http_user``\n    and ``http_pass`` attributes of those spiders.\n\n    Example::\n\n        from scrapy.spiders import CrawlSpider\n\n        class SomeIntranetSiteSpider(CrawlSpider):\n\n            http_user = 'someuser'\n            http_pass = 'somepass'\n            name = 'intranet.example.com'\n\n            # .. rest of the spider code omitted ...\n\n.. _Basic access authentication: https://en.wikipedia.org/wiki/Basic_access_authentication\n\n\nHttpCacheMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.httpcache\n   :synopsis: HTTP Cache downloader middleware\n\n.. class:: HttpCacheMiddleware\n\n    This middleware provides low-level cache to all HTTP requests and responses.\n    It has to be combined with a cache storage backend as well as a cache policy.\n\n    Scrapy ships with three HTTP cache storage backends:\n\n        * :ref:`httpcache-storage-fs`\n        * :ref:`httpcache-storage-dbm`\n\n    You can change the HTTP cache storage backend with the :setting:`HTTPCACHE_STORAGE`\n    setting. Or you can also :ref:`implement your own storage backend. <httpcache-storage-custom>`\n\n    Scrapy ships with two HTTP cache policies:\n\n        * :ref:`httpcache-policy-rfc2616`\n        * :ref:`httpcache-policy-dummy`\n\n    You can change the HTTP cache policy with the :setting:`HTTPCACHE_POLICY`\n    setting. Or you can also implement your own policy.\n\n    .. reqmeta:: dont_cache\n\n    You can also avoid caching a response on every policy using :reqmeta:`dont_cache` meta key equals ``True``.\n\n.. module:: scrapy.extensions.httpcache\n   :noindex:\n\n.. _httpcache-policy-dummy:\n\nDummy policy (default)\n~~~~~~~~~~~~~~~~~~~~~~\n\n.. class:: DummyPolicy\n\n    This policy has no awareness of any HTTP Cache-Control directives.\n    Every request and its corresponding response are cached.  When the same\n    request is seen again, the response is returned without transferring\n    anything from the Internet.\n\n    The Dummy policy is useful for testing spiders faster (without having\n    to wait for downloads every time) and for trying your spider offline,\n    when an Internet connection is not available. The goal is to be able to\n    \"replay\" a spider run *exactly as it ran before*.\n\n\n.. _httpcache-policy-rfc2616:\n\nRFC2616 policy\n~~~~~~~~~~~~~~\n\n.. class:: RFC2616Policy\n\n    This policy provides a RFC2616 compliant HTTP cache, i.e. with HTTP\n    Cache-Control awareness, aimed at production and used in continuous\n    runs to avoid downloading unmodified data (to save bandwidth and speed up\n    crawls).\n\n    What is implemented:\n\n    * Do not attempt to store responses/requests with ``no-store`` cache-control directive set\n    * Do not serve responses from cache if ``no-cache`` cache-control directive is set even for fresh responses\n    * Compute freshness lifetime from ``max-age`` cache-control directive\n    * Compute freshness lifetime from ``Expires`` response header\n    * Compute freshness lifetime from ``Last-Modified`` response header (heuristic used by Firefox)\n    * Compute current age from ``Age`` response header\n    * Compute current age from ``Date`` header\n    * Revalidate stale responses based on ``Last-Modified`` response header\n    * Revalidate stale responses based on ``ETag`` response header\n    * Set ``Date`` header for any received response missing it\n    * Support ``max-stale`` cache-control directive in requests\n\n    This allows spiders to be configured with the full RFC2616 cache policy,\n    but avoid revalidation on a request-by-request basis, while remaining\n    conformant with the HTTP spec.\n\n    Example:\n\n    Add ``Cache-Control: max-stale=600`` to Request headers to accept responses that\n    have exceeded their expiration time by no more than 600 seconds.\n\n    See also: RFC2616, 14.9.3\n\n    What is missing:\n\n    * ``Pragma: no-cache`` support https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.1\n    * ``Vary`` header support https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.6\n    * Invalidation after updates or deletes https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.10\n    * ... probably others ..\n\n\n.. _httpcache-storage-fs:\n\nFilesystem storage backend (default)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. class:: FilesystemCacheStorage\n\n    File system storage backend is available for the HTTP cache middleware.\n\n    Each request/response pair is stored in a different directory containing\n    the following files:\n\n    *   ``request_body`` - the plain request body\n\n    *   ``request_headers`` - the request headers (in raw HTTP format)\n\n    *   ``response_body`` - the plain response body\n\n    *   ``response_headers`` - the request headers (in raw HTTP format)\n\n    *   ``meta`` - some metadata of this cache resource in Python ``repr()``\n        format (grep-friendly format)\n\n    *   ``pickled_meta`` - the same metadata in ``meta`` but pickled for more\n        efficient deserialization\n\n    The directory name is made from the request fingerprint (see\n    ``scrapy.utils.request.fingerprint``), and one level of subdirectories is\n    used to avoid creating too many files into the same directory (which is\n    inefficient in many file systems). An example directory could be::\n\n        /path/to/cache/dir/example.com/72/72811f648e718090f041317756c03adb0ada46c7\n\n.. _httpcache-storage-dbm:\n\nDBM storage backend\n~~~~~~~~~~~~~~~~~~~\n\n.. class:: DbmCacheStorage\n\n    .. versionadded:: 0.13\n\n    A DBM_ storage backend is also available for the HTTP cache middleware.\n\n    By default, it uses the anydbm_ module, but you can change it with the\n    :setting:`HTTPCACHE_DBM_MODULE` setting.\n\n.. _httpcache-storage-custom:\n\nWriting your own storage backend\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can implement a cache storage backend by creating a Python class that\ndefines the methods described below.\n\n.. module:: scrapy.extensions.httpcache\n\n.. class:: CacheStorage\n\n    .. method:: open_spider(spider)\n\n      This method gets called after a spider has been opened for crawling. It handles\n      the :signal:`open_spider <spider_opened>` signal.\n\n      :param spider: the spider which has been opened\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n    .. method:: close_spider(spider)\n\n      This method gets called after a spider has been closed. It handles\n      the :signal:`close_spider <spider_closed>` signal.\n\n      :param spider: the spider which has been closed\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n    .. method:: retrieve_response(spider, request)\n\n      Return response if present in cache, or ``None`` otherwise.\n\n      :param spider: the spider which generated the request\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n      :param request: the request to find cached response for\n      :type request: :class:`~scrapy.http.Request` object\n\n    .. method:: store_response(spider, request, response)\n\n      Store the given response in the cache.\n\n      :param spider: the spider for which the response is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n      :param request: the corresponding request the spider generated\n      :type request: :class:`~scrapy.http.Request` object\n\n      :param response: the response to store in the cache\n      :type response: :class:`~scrapy.http.Response` object\n\nIn order to use your storage backend, set:\n\n* :setting:`HTTPCACHE_STORAGE` to the Python import path of your custom storage class.\n\n\nHTTPCache middleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe :class:`HttpCacheMiddleware` can be configured through the following\nsettings:\n\n.. setting:: HTTPCACHE_ENABLED\n\nHTTPCACHE_ENABLED\n^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.11\n\nDefault: ``False``\n\nWhether the HTTP cache will be enabled.\n\n.. versionchanged:: 0.11\n   Before 0.11, :setting:`HTTPCACHE_DIR` was used to enable cache.\n\n.. setting:: HTTPCACHE_EXPIRATION_SECS\n\nHTTPCACHE_EXPIRATION_SECS\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``0``\n\nExpiration time for cached requests, in seconds.\n\nCached requests older than this time will be re-downloaded. If zero, cached\nrequests will never expire.\n\n.. versionchanged:: 0.11\n   Before 0.11, zero meant cached requests always expire.\n\n.. setting:: HTTPCACHE_DIR\n\nHTTPCACHE_DIR\n^^^^^^^^^^^^^\n\nDefault: ``'httpcache'``\n\nThe directory to use for storing the (low-level) HTTP cache. If empty, the HTTP\ncache will be disabled. If a relative path is given, is taken relative to the\nproject data dir. For more info see: :ref:`topics-project-structure`.\n\n.. setting:: HTTPCACHE_IGNORE_HTTP_CODES\n\nHTTPCACHE_IGNORE_HTTP_CODES\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.10\n\nDefault: ``[]``\n\nDon't cache response with these HTTP codes.\n\n.. setting:: HTTPCACHE_IGNORE_MISSING\n\nHTTPCACHE_IGNORE_MISSING\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``False``\n\nIf enabled, requests not found in the cache will be ignored instead of downloaded.\n\n.. setting:: HTTPCACHE_IGNORE_SCHEMES\n\nHTTPCACHE_IGNORE_SCHEMES\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.10\n\nDefault: ``['file']``\n\nDon't cache responses with these URI schemes.\n\n.. setting:: HTTPCACHE_STORAGE\n\nHTTPCACHE_STORAGE\n^^^^^^^^^^^^^^^^^\n\nDefault: ``'scrapy.extensions.httpcache.FilesystemCacheStorage'``\n\nThe class which implements the cache storage backend.\n\n.. setting:: HTTPCACHE_DBM_MODULE\n\nHTTPCACHE_DBM_MODULE\n^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.13\n\nDefault: ``'anydbm'``\n\nThe database module to use in the :ref:`DBM storage backend\n<httpcache-storage-dbm>`. This setting is specific to the DBM backend.\n\n.. setting:: HTTPCACHE_POLICY\n\nHTTPCACHE_POLICY\n^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.18\n\nDefault: ``'scrapy.extensions.httpcache.DummyPolicy'``\n\nThe class which implements the cache policy.\n\n.. setting:: HTTPCACHE_GZIP\n\nHTTPCACHE_GZIP\n^^^^^^^^^^^^^^\n\n.. versionadded:: 1.0\n\nDefault: ``False``\n\nIf enabled, will compress all cached data with gzip.\nThis setting is specific to the Filesystem backend.\n\n.. setting:: HTTPCACHE_ALWAYS_STORE\n\nHTTPCACHE_ALWAYS_STORE\n^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 1.1\n\nDefault: ``False``\n\nIf enabled, will cache pages unconditionally.\n\nA spider may wish to have all responses available in the cache, for\nfuture use with ``Cache-Control: max-stale``, for instance. The\nDummyPolicy caches all responses but never revalidates them, and\nsometimes a more nuanced policy is desirable.\n\nThis setting still respects ``Cache-Control: no-store`` directives in responses.\nIf you don't want that, filter ``no-store`` out of the Cache-Control headers in\nresponses you feedto the cache middleware.\n\n.. setting:: HTTPCACHE_IGNORE_RESPONSE_CACHE_CONTROLS\n\nHTTPCACHE_IGNORE_RESPONSE_CACHE_CONTROLS\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 1.1\n\nDefault: ``[]``\n\nList of Cache-Control directives in responses to be ignored.\n\nSites often set \"no-store\", \"no-cache\", \"must-revalidate\", etc., but get\nupset at the traffic a spider can generate if it respects those\ndirectives. This allows to selectively ignore Cache-Control directives\nthat are known to be unimportant for the sites being crawled.\n\nWe assume that the spider will not issue Cache-Control directives\nin requests unless it actually needs them, so directives in requests are\nnot filtered.\n\nHttpCompressionMiddleware\n-------------------------\n\n.. module:: scrapy.downloadermiddlewares.httpcompression\n   :synopsis: Http Compression Middleware\n\n.. class:: HttpCompressionMiddleware\n\n   This middleware allows compressed (gzip, deflate) traffic to be\n   sent/received from web sites.\n\n   This middleware also supports decoding `brotli-compressed`_ responses,\n   provided `brotlipy`_ is installed.\n\n.. _brotli-compressed: https://www.ietf.org/rfc/rfc7932.txt\n.. _brotlipy: https://pypi.python.org/pypi/brotlipy\n\nHttpCompressionMiddleware Settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: COMPRESSION_ENABLED\n\nCOMPRESSION_ENABLED\n^^^^^^^^^^^^^^^^^^^\n\nDefault: ``True``\n\nWhether the Compression middleware will be enabled.\n\n\nHttpProxyMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.httpproxy\n   :synopsis: Http Proxy Middleware\n\n.. versionadded:: 0.8\n\n.. reqmeta:: proxy\n\n.. class:: HttpProxyMiddleware\n\n   This middleware sets the HTTP proxy to use for requests, by setting the\n   ``proxy`` meta value for :class:`~scrapy.http.Request` objects.\n\n   Like the Python standard library modules `urllib`_ and `urllib2`_, it obeys\n   the following environment variables:\n\n   * ``http_proxy``\n   * ``https_proxy``\n   * ``no_proxy``\n\n   You can also set the meta key ``proxy`` per-request, to a value like\n   ``http://some_proxy_server:port`` or ``http://username:password@some_proxy_server:port``.\n   Keep in mind this value will take precedence over ``http_proxy``/``https_proxy``\n   environment variables, and it will also ignore ``no_proxy`` environment variable.\n\n.. _urllib: https://docs.python.org/2/library/urllib.html\n.. _urllib2: https://docs.python.org/2/library/urllib2.html\n\nRedirectMiddleware\n------------------\n\n.. module:: scrapy.downloadermiddlewares.redirect\n   :synopsis: Redirection Middleware\n\n.. class:: RedirectMiddleware\n\n   This middleware handles redirection of requests based on response status.\n\n.. reqmeta:: redirect_urls\n\nThe urls which the request goes through (while being redirected) can be found\nin the ``redirect_urls`` :attr:`Request.meta <scrapy.http.Request.meta>` key.\n\n.. reqmeta:: redirect_reasons\n\nThe reason behind each redirect in :reqmeta:`redirect_urls` can be found in the\n``redirect_reasons`` :attr:`Request.meta <scrapy.http.Request.meta>` key. For\nexample: ``[301, 302, 307, 'meta refresh']``.\n\nThe format of a reason depends on the middleware that handled the corresponding\nredirect. For example, :class:`RedirectMiddleware` indicates the triggering\nresponse status code as an integer, while :class:`MetaRefreshMiddleware`\nalways uses the ``'meta refresh'`` string as reason.\n\nThe :class:`RedirectMiddleware` can be configured through the following\nsettings (see the settings documentation for more info):\n\n* :setting:`REDIRECT_ENABLED`\n* :setting:`REDIRECT_MAX_TIMES`\n\n.. reqmeta:: dont_redirect\n\nIf :attr:`Request.meta <scrapy.http.Request.meta>` has ``dont_redirect``\nkey set to True, the request will be ignored by this middleware.\n\nIf you want to handle some redirect status codes in your spider, you can\nspecify these in the ``handle_httpstatus_list`` spider attribute.\n\nFor example, if you want the redirect middleware to ignore 301 and 302\nresponses (and pass them through to your spider) you can do this::\n\n    class MySpider(CrawlSpider):\n        handle_httpstatus_list = [301, 302]\n\nThe ``handle_httpstatus_list`` key of :attr:`Request.meta\n<scrapy.http.Request.meta>` can also be used to specify which response codes to\nallow on a per-request basis. You can also set the meta key\n``handle_httpstatus_all`` to ``True`` if you want to allow any response code\nfor a request.\n\n\nRedirectMiddleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: REDIRECT_ENABLED\n\nREDIRECT_ENABLED\n^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.13\n\nDefault: ``True``\n\nWhether the Redirect middleware will be enabled.\n\n.. setting:: REDIRECT_MAX_TIMES\n\nREDIRECT_MAX_TIMES\n^^^^^^^^^^^^^^^^^^\n\nDefault: ``20``\n\nDefines the maximum times a request can be redirected. After this maximum the\nrequest's response is returned as is. We used Firefox default value for the\nsame task.\n\nMetaRefreshMiddleware\n---------------------\n\n.. class:: MetaRefreshMiddleware\n\n   This middleware handles redirection of requests based on meta-refresh html tag.\n\nThe :class:`MetaRefreshMiddleware` can be configured through the following\nsettings (see the settings documentation for more info):\n\n* :setting:`METAREFRESH_ENABLED`\n* :setting:`METAREFRESH_IGNORE_TAGS`\n* :setting:`METAREFRESH_MAXDELAY`\n\nThis middleware obey :setting:`REDIRECT_MAX_TIMES` setting, :reqmeta:`dont_redirect`,\n:reqmeta:`redirect_urls` and :reqmeta:`redirect_reasons` request meta keys as described\nfor :class:`RedirectMiddleware`\n\n\nMetaRefreshMiddleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: METAREFRESH_ENABLED\n\nMETAREFRESH_ENABLED\n^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.17\n\nDefault: ``True``\n\nWhether the Meta Refresh middleware will be enabled.\n\n.. setting:: METAREFRESH_IGNORE_TAGS\n\nMETAREFRESH_IGNORE_TAGS\n^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``['script', 'noscript']``\n\nMeta tags within these tags are ignored.\n\n.. setting:: METAREFRESH_MAXDELAY\n\nMETAREFRESH_MAXDELAY\n^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``100``\n\nThe maximum meta-refresh delay (in seconds) to follow the redirection.\nSome sites use meta-refresh for redirecting to a session expired page, so we\nrestrict automatic redirection to the maximum delay.\n\nRetryMiddleware\n---------------\n\n.. module:: scrapy.downloadermiddlewares.retry\n   :synopsis: Retry Middleware\n\n.. class:: RetryMiddleware\n\n   A middleware to retry failed requests that are potentially caused by\n   temporary problems such as a connection timeout or HTTP 500 error.\n\nFailed pages are collected on the scraping process and rescheduled at the\nend, once the spider has finished crawling all regular (non failed) pages.\n\nThe :class:`RetryMiddleware` can be configured through the following\nsettings (see the settings documentation for more info):\n\n* :setting:`RETRY_ENABLED`\n* :setting:`RETRY_TIMES`\n* :setting:`RETRY_HTTP_CODES`\n\n.. reqmeta:: dont_retry\n\nIf :attr:`Request.meta <scrapy.http.Request.meta>` has ``dont_retry`` key\nset to True, the request will be ignored by this middleware.\n\nRetryMiddleware Settings\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: RETRY_ENABLED\n\nRETRY_ENABLED\n^^^^^^^^^^^^^\n\n.. versionadded:: 0.13\n\nDefault: ``True``\n\nWhether the Retry middleware will be enabled.\n\n.. setting:: RETRY_TIMES\n\nRETRY_TIMES\n^^^^^^^^^^^\n\nDefault: ``2``\n\nMaximum number of times to retry, in addition to the first download.\n\nMaximum number of retries can also be specified per-request using\n:reqmeta:`max_retry_times` attribute of :attr:`Request.meta <scrapy.http.Request.meta>`.\nWhen initialized, the :reqmeta:`max_retry_times` meta key takes higher\nprecedence over the :setting:`RETRY_TIMES` setting.\n\n.. setting:: RETRY_HTTP_CODES\n\nRETRY_HTTP_CODES\n^^^^^^^^^^^^^^^^\n\nDefault: ``[500, 502, 503, 504, 522, 524, 408, 429]``\n\nWhich HTTP response codes to retry. Other errors (DNS lookup issues,\nconnections lost, etc) are always retried.\n\nIn some cases you may want to add 400 to :setting:`RETRY_HTTP_CODES` because\nit is a common code used to indicate server overload. It is not included by\ndefault because HTTP specs say so.\n\n\n.. _topics-dlmw-robots:\n\nRobotsTxtMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.robotstxt\n   :synopsis: robots.txt middleware\n\n.. class:: RobotsTxtMiddleware\n\n    This middleware filters out requests forbidden by the robots.txt exclusion\n    standard.\n\n    To make sure Scrapy respects robots.txt make sure the middleware is enabled\n    and the :setting:`ROBOTSTXT_OBEY` setting is enabled.\n\n    The :setting:`ROBOTSTXT_USER_AGENT` setting can be used to specify the\n    user agent string to use for matching in the robots.txt_ file. If it\n    is ``None``, the User-Agent header you are sending with the request or the\n    :setting:`USER_AGENT` setting (in that order) will be used for determining\n    the user agent to use in the robots.txt_ file.\n\n    This middleware has to be combined with a robots.txt_ parser.\n\n    Scrapy ships with support for the following robots.txt_ parsers:\n\n    * :ref:`Protego <protego-parser>` (default)\n    * :ref:`RobotFileParser <python-robotfileparser>`\n    * :ref:`Reppy <reppy-parser>`\n    * :ref:`Robotexclusionrulesparser <rerp-parser>`\n\n    You can change the robots.txt_ parser with the :setting:`ROBOTSTXT_PARSER`\n    setting. Or you can also :ref:`implement support for a new parser <support-for-new-robots-parser>`.\n\n.. reqmeta:: dont_obey_robotstxt\n\nIf :attr:`Request.meta <scrapy.http.Request.meta>` has\n``dont_obey_robotstxt`` key set to True\nthe request will be ignored by this middleware even if\n:setting:`ROBOTSTXT_OBEY` is enabled.\n\nParsers vary in several aspects:\n\n* Language of implementation\n\n* Supported specification\n\n* Support for wildcard matching\n\n* Usage of `length based rule <https://developers.google.com/search/reference/robots_txt#order-of-precedence-for-group-member-lines>`_:\n  in particular for ``Allow`` and ``Disallow`` directives, where the most\n  specific rule based on the length of the path trumps the less specific\n  (shorter) rule\n\nPerformance comparison of different parsers is available at `the following link\n<https://anubhavp28.github.io/gsoc-weekly-checkin-12/>`_.\n\n.. _protego-parser:\n\nProtego parser\n~~~~~~~~~~~~~~\n\nBased on `Protego <https://github.com/scrapy/protego>`_:\n\n* implemented in Python\n\n* is compliant with `Google's Robots.txt Specification\n  <https://developers.google.com/search/reference/robots_txt>`_\n\n* supports wildcard matching\n\n* uses the length based rule\n\nScrapy uses this parser by default.\n\n.. _python-robotfileparser:\n\nRobotFileParser\n~~~~~~~~~~~~~~~\n\nBased on `RobotFileParser\n<https://docs.python.org/3.7/library/urllib.robotparser.html>`_:\n\n* is Python's built-in robots.txt_ parser\n\n* is compliant with `Martijn Koster's 1996 draft specification\n  <http://www.robotstxt.org/norobots-rfc.txt>`_\n\n* lacks support for wildcard matching\n\n* doesn't use the length based rule\n\nIt is faster than Protego and backward-compatible with versions of Scrapy before 1.8.0.\n\nIn order to use this parser, set:\n\n* :setting:`ROBOTSTXT_PARSER` to ``scrapy.robotstxt.PythonRobotParser``\n\n.. _reppy-parser:\n\nReppy parser\n~~~~~~~~~~~~\n\nBased on `Reppy <https://github.com/seomoz/reppy/>`_:\n\n* is a Python wrapper around `Robots Exclusion Protocol Parser for C++\n  <https://github.com/seomoz/rep-cpp>`_\n\n* is compliant with `Martijn Koster's 1996 draft specification\n  <http://www.robotstxt.org/norobots-rfc.txt>`_\n\n* supports wildcard matching\n\n* uses the length based rule\n\nNative implementation, provides better speed than Protego.\n\nIn order to use this parser:\n\n* Install `Reppy <https://github.com/seomoz/reppy/>`_ by running ``pip install reppy``\n\n* Set :setting:`ROBOTSTXT_PARSER` setting to\n  ``scrapy.robotstxt.ReppyRobotParser``\n\n.. _rerp-parser:\n\nRobotexclusionrulesparser\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBased on `Robotexclusionrulesparser <http://nikitathespider.com/python/rerp/>`_:\n\n* implemented in Python\n\n* is compliant with `Martijn Koster's 1996 draft specification\n  <http://www.robotstxt.org/norobots-rfc.txt>`_\n\n* supports wildcard matching\n\n* doesn't use the length based rule\n\nIn order to use this parser:\n\n* Install `Robotexclusionrulesparser <http://nikitathespider.com/python/rerp/>`_ by running\n  ``pip install robotexclusionrulesparser``\n\n* Set :setting:`ROBOTSTXT_PARSER` setting to\n  ``scrapy.robotstxt.RerpRobotParser``\n\n.. _support-for-new-robots-parser:\n\nImplementing support for a new parser\n-------------------------------------\n\nYou can implement support for a new robots.txt_ parser by subclassing\nthe abstract base class :class:`~scrapy.robotstxt.RobotParser` and\nimplementing the methods described below.\n\n.. module:: scrapy.robotstxt\n   :synopsis: robots.txt parser interface and implementations\n\n.. autoclass:: RobotParser\n   :members:\n\n.. _robots.txt: http://www.robotstxt.org/\n\nDownloaderStats\n---------------\n\n.. module:: scrapy.downloadermiddlewares.stats\n   :synopsis: Downloader Stats Middleware\n\n.. class:: DownloaderStats\n\n   Middleware that stores stats of all requests, responses and exceptions that\n   pass through it.\n\n   To use this middleware you must enable the :setting:`DOWNLOADER_STATS`\n   setting.\n\nUserAgentMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.useragent\n   :synopsis: User Agent Middleware\n\n.. class:: UserAgentMiddleware\n\n   Middleware that allows spiders to override the default user agent.\n\n   In order for a spider to override the default user agent, its ``user_agent``\n   attribute must be set.\n\n.. _ajaxcrawl-middleware:\n\nAjaxCrawlMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.ajaxcrawl\n\n.. class:: AjaxCrawlMiddleware\n\n   Middleware that finds 'AJAX crawlable' page variants based\n   on meta-fragment html tag. See\n   https://developers.google.com/webmasters/ajax-crawling/docs/getting-started\n   for more info.\n\n   .. note::\n\n       Scrapy finds 'AJAX crawlable' pages for URLs like\n       ``'http://example.com/!#foo=bar'`` even without this middleware.\n       AjaxCrawlMiddleware is necessary when URL doesn't contain ``'!#'``.\n       This is often a case for 'index' or 'main' website pages.\n\nAjaxCrawlMiddleware Settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: AJAXCRAWL_ENABLED\n\nAJAXCRAWL_ENABLED\n^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.21\n\nDefault: ``False``\n\nWhether the AjaxCrawlMiddleware will be enabled. You may want to\nenable it for :ref:`broad crawls <topics-broad-crawls>`.\n\nHttpProxyMiddleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: HTTPPROXY_ENABLED\n.. setting:: HTTPPROXY_AUTH_ENCODING\n\nHTTPPROXY_ENABLED\n^^^^^^^^^^^^^^^^^\n\nDefault: ``True``\n\nWhether or not to enable the :class:`HttpProxyMiddleware`.\n\nHTTPPROXY_AUTH_ENCODING\n^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``\"latin-1\"``\n\nThe default encoding for proxy authentication on :class:`HttpProxyMiddleware`.\n\n\n.. _DBM: https://en.wikipedia.org/wiki/Dbm\n.. _anydbm: https://docs.python.org/2/library/anydbm.html\n", "\"\"\"\nHTTP basic auth downloader middleware\n\nSee documentation in docs/topics/downloader-middleware.rst\n\"\"\"\n\nfrom w3lib.http import basic_auth_header\n\nfrom scrapy import signals\n\n\nclass HttpAuthMiddleware(object):\n    \"\"\"Set Basic HTTP Authorization header\n    (http_user and http_pass spider class attributes)\"\"\"\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        o = cls()\n        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n        return o\n\n    def spider_opened(self, spider):\n        usr = getattr(spider, 'http_user', '')\n        pwd = getattr(spider, 'http_pass', '')\n        if usr or pwd:\n            self.auth = basic_auth_header(usr, pwd)\n\n    def process_request(self, request, spider):\n        auth = getattr(self, 'auth', None)\n        if auth and b'Authorization' not in request.headers:\n            request.headers[b'Authorization'] = auth\n", "import unittest\n\nfrom scrapy.http import Request\nfrom scrapy.downloadermiddlewares.httpauth import HttpAuthMiddleware\nfrom scrapy.spiders import Spider\n\n\nclass TestSpider(Spider):\n    http_user = 'foo'\n    http_pass = 'bar'\n\n\nclass HttpAuthMiddlewareTest(unittest.TestCase):\n\n    def setUp(self):\n        self.mw = HttpAuthMiddleware()\n        self.spider = TestSpider('foo')\n        self.mw.spider_opened(self.spider)\n\n    def tearDown(self):\n        del self.mw\n\n    def test_auth(self):\n        req = Request('http://scrapytest.org/')\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], b'Basic Zm9vOmJhcg==')\n\n    def test_auth_already_set(self):\n        req = Request('http://scrapytest.org/',\n                      headers=dict(Authorization='Digest 123'))\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], b'Digest 123')\n"], "fixing_code": [".. _topics-downloader-middleware:\n\n=====================\nDownloader Middleware\n=====================\n\nThe downloader middleware is a framework of hooks into Scrapy's\nrequest/response processing.  It's a light, low-level system for globally\naltering Scrapy's requests and responses.\n\n.. _topics-downloader-middleware-setting:\n\nActivating a downloader middleware\n==================================\n\nTo activate a downloader middleware component, add it to the\n:setting:`DOWNLOADER_MIDDLEWARES` setting, which is a dict whose keys are the\nmiddleware class paths and their values are the middleware orders.\n\nHere's an example::\n\n    DOWNLOADER_MIDDLEWARES = {\n        'myproject.middlewares.CustomDownloaderMiddleware': 543,\n    }\n\nThe :setting:`DOWNLOADER_MIDDLEWARES` setting is merged with the\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` setting defined in Scrapy (and not meant\nto be overridden) and then sorted by order to get the final sorted list of\nenabled middlewares: the first middleware is the one closer to the engine and\nthe last is the one closer to the downloader. In other words,\nthe :meth:`~scrapy.downloadermiddlewares.DownloaderMiddleware.process_request`\nmethod of each middleware will be invoked in increasing\nmiddleware order (100, 200, 300, ...) and the :meth:`~scrapy.downloadermiddlewares.DownloaderMiddleware.process_response` method\nof each middleware will be invoked in decreasing order.\n\nTo decide which order to assign to your middleware see the\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` setting and pick a value according to\nwhere you want to insert the middleware. The order does matter because each\nmiddleware performs a different action and your middleware could depend on some\nprevious (or subsequent) middleware being applied.\n\nIf you want to disable a built-in middleware (the ones defined in\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` and enabled by default) you must define it\nin your project's :setting:`DOWNLOADER_MIDDLEWARES` setting and assign ``None``\nas its value.  For example, if you want to disable the user-agent middleware::\n\n    DOWNLOADER_MIDDLEWARES = {\n        'myproject.middlewares.CustomDownloaderMiddleware': 543,\n        'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,\n    }\n\nFinally, keep in mind that some middlewares may need to be enabled through a\nparticular setting. See each middleware documentation for more info.\n\n.. _topics-downloader-middleware-custom:\n\nWriting your own downloader middleware\n======================================\n\nEach downloader middleware is a Python class that defines one or more of the\nmethods defined below.\n\nThe main entry point is the ``from_crawler`` class method, which receives a\n:class:`~scrapy.crawler.Crawler` instance. The :class:`~scrapy.crawler.Crawler`\nobject gives you access, for example, to the :ref:`settings <topics-settings>`.\n\n.. module:: scrapy.downloadermiddlewares\n\n.. class:: DownloaderMiddleware\n\n   .. note::  Any of the downloader middleware methods may also return a deferred.\n\n   .. method:: process_request(request, spider)\n\n      This method is called for each request that goes through the download\n      middleware.\n\n      :meth:`process_request` should either: return ``None``, return a\n      :class:`~scrapy.http.Response` object, return a :class:`~scrapy.http.Request`\n      object, or raise :exc:`~scrapy.exceptions.IgnoreRequest`.\n\n      If it returns ``None``, Scrapy will continue processing this request, executing all\n      other middlewares until, finally, the appropriate downloader handler is called\n      the request performed (and its response downloaded).\n\n      If it returns a :class:`~scrapy.http.Response` object, Scrapy won't bother\n      calling *any* other :meth:`process_request` or :meth:`process_exception` methods,\n      or the appropriate download function; it'll return that response. The :meth:`process_response`\n      methods of installed middleware is always called on every response.\n\n      If it returns a :class:`~scrapy.http.Request` object, Scrapy will stop calling\n      process_request methods and reschedule the returned request. Once the newly returned\n      request is performed, the appropriate middleware chain will be called on\n      the downloaded response.\n\n      If it raises an :exc:`~scrapy.exceptions.IgnoreRequest` exception, the\n      :meth:`process_exception` methods of installed downloader middleware will be called.\n      If none of them handle the exception, the errback function of the request\n      (``Request.errback``) is called. If no code handles the raised exception, it is\n      ignored and not logged (unlike other exceptions).\n\n      :param request: the request being processed\n      :type request: :class:`~scrapy.http.Request` object\n\n      :param spider: the spider for which this request is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n   .. method:: process_response(request, response, spider)\n\n      :meth:`process_response` should either: return a :class:`~scrapy.http.Response`\n      object, return a :class:`~scrapy.http.Request` object or\n      raise a :exc:`~scrapy.exceptions.IgnoreRequest` exception.\n\n      If it returns a :class:`~scrapy.http.Response` (it could be the same given\n      response, or a brand-new one), that response will continue to be processed\n      with the :meth:`process_response` of the next middleware in the chain.\n\n      If it returns a :class:`~scrapy.http.Request` object, the middleware chain is\n      halted and the returned request is rescheduled to be downloaded in the future.\n      This is the same behavior as if a request is returned from :meth:`process_request`.\n\n      If it raises an :exc:`~scrapy.exceptions.IgnoreRequest` exception, the errback\n      function of the request (``Request.errback``) is called. If no code handles the raised\n      exception, it is ignored and not logged (unlike other exceptions).\n\n      :param request: the request that originated the response\n      :type request: is a :class:`~scrapy.http.Request` object\n\n      :param response: the response being processed\n      :type response: :class:`~scrapy.http.Response` object\n\n      :param spider: the spider for which this response is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n   .. method:: process_exception(request, exception, spider)\n\n      Scrapy calls :meth:`process_exception` when a download handler\n      or a :meth:`process_request` (from a downloader middleware) raises an\n      exception (including an :exc:`~scrapy.exceptions.IgnoreRequest` exception)\n\n      :meth:`process_exception` should return: either ``None``,\n      a :class:`~scrapy.http.Response` object, or a :class:`~scrapy.http.Request` object.\n\n      If it returns ``None``, Scrapy will continue processing this exception,\n      executing any other :meth:`process_exception` methods of installed middleware,\n      until no middleware is left and the default exception handling kicks in.\n\n      If it returns a :class:`~scrapy.http.Response` object, the :meth:`process_response`\n      method chain of installed middleware is started, and Scrapy won't bother calling\n      any other :meth:`process_exception` methods of middleware.\n\n      If it returns a :class:`~scrapy.http.Request` object, the returned request is\n      rescheduled to be downloaded in the future. This stops the execution of\n      :meth:`process_exception` methods of the middleware the same as returning a\n      response would.\n\n      :param request: the request that generated the exception\n      :type request: is a :class:`~scrapy.http.Request` object\n\n      :param exception: the raised exception\n      :type exception: an ``Exception`` object\n\n      :param spider: the spider for which this request is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n   .. method:: from_crawler(cls, crawler)\n\n      If present, this classmethod is called to create a middleware instance\n      from a :class:`~scrapy.crawler.Crawler`. It must return a new instance\n      of the middleware. Crawler object provides access to all Scrapy core\n      components like settings and signals; it is a way for middleware to\n      access them and hook its functionality into Scrapy.\n\n      :param crawler: crawler that uses this middleware\n      :type crawler: :class:`~scrapy.crawler.Crawler` object\n\n.. _topics-downloader-middleware-ref:\n\nBuilt-in downloader middleware reference\n========================================\n\nThis page describes all downloader middleware components that come with\nScrapy. For information on how to use them and how to write your own downloader\nmiddleware, see the :ref:`downloader middleware usage guide\n<topics-downloader-middleware>`.\n\nFor a list of the components enabled by default (and their orders) see the\n:setting:`DOWNLOADER_MIDDLEWARES_BASE` setting.\n\n.. _cookies-mw:\n\nCookiesMiddleware\n-----------------\n\n.. module:: scrapy.downloadermiddlewares.cookies\n   :synopsis: Cookies Downloader Middleware\n\n.. class:: CookiesMiddleware\n\n   This middleware enables working with sites that require cookies, such as\n   those that use sessions. It keeps track of cookies sent by web servers, and\n   send them back on subsequent requests (from that spider), just like web\n   browsers do.\n\nThe following settings can be used to configure the cookie middleware:\n\n* :setting:`COOKIES_ENABLED`\n* :setting:`COOKIES_DEBUG`\n\n.. reqmeta:: cookiejar\n\nMultiple cookie sessions per spider\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. versionadded:: 0.15\n\nThere is support for keeping multiple cookie sessions per spider by using the\n:reqmeta:`cookiejar` Request meta key. By default it uses a single cookie jar\n(session), but you can pass an identifier to use different ones.\n\nFor example::\n\n    for i, url in enumerate(urls):\n        yield scrapy.Request(url, meta={'cookiejar': i},\n            callback=self.parse_page)\n\nKeep in mind that the :reqmeta:`cookiejar` meta key is not \"sticky\". You need to keep\npassing it along on subsequent requests. For example::\n\n    def parse_page(self, response):\n        # do some processing\n        return scrapy.Request(\"http://www.example.com/otherpage\",\n            meta={'cookiejar': response.meta['cookiejar']},\n            callback=self.parse_other_page)\n\n.. setting:: COOKIES_ENABLED\n\nCOOKIES_ENABLED\n~~~~~~~~~~~~~~~\n\nDefault: ``True``\n\nWhether to enable the cookies middleware. If disabled, no cookies will be sent\nto web servers.\n\nNotice that despite the value of :setting:`COOKIES_ENABLED` setting if\n``Request.``:reqmeta:`meta['dont_merge_cookies'] <dont_merge_cookies>`\nevaluates to ``True`` the request cookies will **not** be sent to the\nweb server and received cookies in :class:`~scrapy.http.Response` will\n**not** be merged with the existing cookies.\n\nFor more detailed information see the ``cookies`` parameter in\n:class:`~scrapy.http.Request`.\n\n.. setting:: COOKIES_DEBUG\n\nCOOKIES_DEBUG\n~~~~~~~~~~~~~\n\nDefault: ``False``\n\nIf enabled, Scrapy will log all cookies sent in requests (ie. ``Cookie``\nheader) and all cookies received in responses (ie. ``Set-Cookie`` header).\n\nHere's an example of a log with :setting:`COOKIES_DEBUG` enabled::\n\n    2011-04-06 14:35:10-0300 [scrapy.core.engine] INFO: Spider opened\n    2011-04-06 14:35:10-0300 [scrapy.downloadermiddlewares.cookies] DEBUG: Sending cookies to: <GET http://www.diningcity.com/netherlands/index.html>\n            Cookie: clientlanguage_nl=en_EN\n    2011-04-06 14:35:14-0300 [scrapy.downloadermiddlewares.cookies] DEBUG: Received cookies from: <200 http://www.diningcity.com/netherlands/index.html>\n            Set-Cookie: JSESSIONID=B~FA4DC0C496C8762AE4F1A620EAB34F38; Path=/\n            Set-Cookie: ip_isocode=US\n            Set-Cookie: clientlanguage_nl=en_EN; Expires=Thu, 07-Apr-2011 21:21:34 GMT; Path=/\n    2011-04-06 14:49:50-0300 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.diningcity.com/netherlands/index.html> (referer: None)\n    [...]\n\n\nDefaultHeadersMiddleware\n------------------------\n\n.. module:: scrapy.downloadermiddlewares.defaultheaders\n   :synopsis: Default Headers Downloader Middleware\n\n.. class:: DefaultHeadersMiddleware\n\n    This middleware sets all default requests headers specified in the\n    :setting:`DEFAULT_REQUEST_HEADERS` setting.\n\nDownloadTimeoutMiddleware\n-------------------------\n\n.. module:: scrapy.downloadermiddlewares.downloadtimeout\n   :synopsis: Download timeout middleware\n\n.. class:: DownloadTimeoutMiddleware\n\n    This middleware sets the download timeout for requests specified in the\n    :setting:`DOWNLOAD_TIMEOUT` setting or :attr:`download_timeout`\n    spider attribute.\n\n.. note::\n\n    You can also set download timeout per-request using\n    :reqmeta:`download_timeout` Request.meta key; this is supported\n    even when DownloadTimeoutMiddleware is disabled.\n\nHttpAuthMiddleware\n------------------\n\n.. module:: scrapy.downloadermiddlewares.httpauth\n   :synopsis: HTTP Auth downloader middleware\n\n.. class:: HttpAuthMiddleware\n\n    This middleware authenticates all requests generated from certain spiders\n    using `Basic access authentication`_ (aka. HTTP auth).\n\n    To enable HTTP authentication for a spider, set the ``http_user`` and\n    ``http_pass`` spider attributes to the authentication data and the\n    ``http_auth_domain`` spider attribute to the domain which requires this\n    authentication (its subdomains will be also handled in the same way).\n    You can set ``http_auth_domain`` to ``None`` to enable the\n    authentication for all requests but usually this is not needed.\n\n    .. warning::\n        In the previous Scrapy versions HttpAuthMiddleware sent the\n        authentication data with all requests, which is a security problem if\n        the spider makes requests to several different domains. Currently if\n        the ``http_auth_domain`` attribute is not set, the middleware will use\n        the domain of the first request, which will work for some spider but\n        not for others. In the future the middleware will produce an error\n        instead.\n\n    Example::\n\n        from scrapy.spiders import CrawlSpider\n\n        class SomeIntranetSiteSpider(CrawlSpider):\n\n            http_user = 'someuser'\n            http_pass = 'somepass'\n            http_auth_domain = 'intranet.example.com'\n            name = 'intranet.example.com'\n\n            # .. rest of the spider code omitted ...\n\n.. _Basic access authentication: https://en.wikipedia.org/wiki/Basic_access_authentication\n\n\nHttpCacheMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.httpcache\n   :synopsis: HTTP Cache downloader middleware\n\n.. class:: HttpCacheMiddleware\n\n    This middleware provides low-level cache to all HTTP requests and responses.\n    It has to be combined with a cache storage backend as well as a cache policy.\n\n    Scrapy ships with three HTTP cache storage backends:\n\n        * :ref:`httpcache-storage-fs`\n        * :ref:`httpcache-storage-dbm`\n\n    You can change the HTTP cache storage backend with the :setting:`HTTPCACHE_STORAGE`\n    setting. Or you can also :ref:`implement your own storage backend. <httpcache-storage-custom>`\n\n    Scrapy ships with two HTTP cache policies:\n\n        * :ref:`httpcache-policy-rfc2616`\n        * :ref:`httpcache-policy-dummy`\n\n    You can change the HTTP cache policy with the :setting:`HTTPCACHE_POLICY`\n    setting. Or you can also implement your own policy.\n\n    .. reqmeta:: dont_cache\n\n    You can also avoid caching a response on every policy using :reqmeta:`dont_cache` meta key equals ``True``.\n\n.. module:: scrapy.extensions.httpcache\n   :noindex:\n\n.. _httpcache-policy-dummy:\n\nDummy policy (default)\n~~~~~~~~~~~~~~~~~~~~~~\n\n.. class:: DummyPolicy\n\n    This policy has no awareness of any HTTP Cache-Control directives.\n    Every request and its corresponding response are cached.  When the same\n    request is seen again, the response is returned without transferring\n    anything from the Internet.\n\n    The Dummy policy is useful for testing spiders faster (without having\n    to wait for downloads every time) and for trying your spider offline,\n    when an Internet connection is not available. The goal is to be able to\n    \"replay\" a spider run *exactly as it ran before*.\n\n\n.. _httpcache-policy-rfc2616:\n\nRFC2616 policy\n~~~~~~~~~~~~~~\n\n.. class:: RFC2616Policy\n\n    This policy provides a RFC2616 compliant HTTP cache, i.e. with HTTP\n    Cache-Control awareness, aimed at production and used in continuous\n    runs to avoid downloading unmodified data (to save bandwidth and speed up\n    crawls).\n\n    What is implemented:\n\n    * Do not attempt to store responses/requests with ``no-store`` cache-control directive set\n    * Do not serve responses from cache if ``no-cache`` cache-control directive is set even for fresh responses\n    * Compute freshness lifetime from ``max-age`` cache-control directive\n    * Compute freshness lifetime from ``Expires`` response header\n    * Compute freshness lifetime from ``Last-Modified`` response header (heuristic used by Firefox)\n    * Compute current age from ``Age`` response header\n    * Compute current age from ``Date`` header\n    * Revalidate stale responses based on ``Last-Modified`` response header\n    * Revalidate stale responses based on ``ETag`` response header\n    * Set ``Date`` header for any received response missing it\n    * Support ``max-stale`` cache-control directive in requests\n\n    This allows spiders to be configured with the full RFC2616 cache policy,\n    but avoid revalidation on a request-by-request basis, while remaining\n    conformant with the HTTP spec.\n\n    Example:\n\n    Add ``Cache-Control: max-stale=600`` to Request headers to accept responses that\n    have exceeded their expiration time by no more than 600 seconds.\n\n    See also: RFC2616, 14.9.3\n\n    What is missing:\n\n    * ``Pragma: no-cache`` support https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.1\n    * ``Vary`` header support https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.6\n    * Invalidation after updates or deletes https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.10\n    * ... probably others ..\n\n\n.. _httpcache-storage-fs:\n\nFilesystem storage backend (default)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. class:: FilesystemCacheStorage\n\n    File system storage backend is available for the HTTP cache middleware.\n\n    Each request/response pair is stored in a different directory containing\n    the following files:\n\n    *   ``request_body`` - the plain request body\n\n    *   ``request_headers`` - the request headers (in raw HTTP format)\n\n    *   ``response_body`` - the plain response body\n\n    *   ``response_headers`` - the request headers (in raw HTTP format)\n\n    *   ``meta`` - some metadata of this cache resource in Python ``repr()``\n        format (grep-friendly format)\n\n    *   ``pickled_meta`` - the same metadata in ``meta`` but pickled for more\n        efficient deserialization\n\n    The directory name is made from the request fingerprint (see\n    ``scrapy.utils.request.fingerprint``), and one level of subdirectories is\n    used to avoid creating too many files into the same directory (which is\n    inefficient in many file systems). An example directory could be::\n\n        /path/to/cache/dir/example.com/72/72811f648e718090f041317756c03adb0ada46c7\n\n.. _httpcache-storage-dbm:\n\nDBM storage backend\n~~~~~~~~~~~~~~~~~~~\n\n.. class:: DbmCacheStorage\n\n    .. versionadded:: 0.13\n\n    A DBM_ storage backend is also available for the HTTP cache middleware.\n\n    By default, it uses the anydbm_ module, but you can change it with the\n    :setting:`HTTPCACHE_DBM_MODULE` setting.\n\n.. _httpcache-storage-custom:\n\nWriting your own storage backend\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can implement a cache storage backend by creating a Python class that\ndefines the methods described below.\n\n.. module:: scrapy.extensions.httpcache\n\n.. class:: CacheStorage\n\n    .. method:: open_spider(spider)\n\n      This method gets called after a spider has been opened for crawling. It handles\n      the :signal:`open_spider <spider_opened>` signal.\n\n      :param spider: the spider which has been opened\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n    .. method:: close_spider(spider)\n\n      This method gets called after a spider has been closed. It handles\n      the :signal:`close_spider <spider_closed>` signal.\n\n      :param spider: the spider which has been closed\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n    .. method:: retrieve_response(spider, request)\n\n      Return response if present in cache, or ``None`` otherwise.\n\n      :param spider: the spider which generated the request\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n      :param request: the request to find cached response for\n      :type request: :class:`~scrapy.http.Request` object\n\n    .. method:: store_response(spider, request, response)\n\n      Store the given response in the cache.\n\n      :param spider: the spider for which the response is intended\n      :type spider: :class:`~scrapy.spiders.Spider` object\n\n      :param request: the corresponding request the spider generated\n      :type request: :class:`~scrapy.http.Request` object\n\n      :param response: the response to store in the cache\n      :type response: :class:`~scrapy.http.Response` object\n\nIn order to use your storage backend, set:\n\n* :setting:`HTTPCACHE_STORAGE` to the Python import path of your custom storage class.\n\n\nHTTPCache middleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe :class:`HttpCacheMiddleware` can be configured through the following\nsettings:\n\n.. setting:: HTTPCACHE_ENABLED\n\nHTTPCACHE_ENABLED\n^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.11\n\nDefault: ``False``\n\nWhether the HTTP cache will be enabled.\n\n.. versionchanged:: 0.11\n   Before 0.11, :setting:`HTTPCACHE_DIR` was used to enable cache.\n\n.. setting:: HTTPCACHE_EXPIRATION_SECS\n\nHTTPCACHE_EXPIRATION_SECS\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``0``\n\nExpiration time for cached requests, in seconds.\n\nCached requests older than this time will be re-downloaded. If zero, cached\nrequests will never expire.\n\n.. versionchanged:: 0.11\n   Before 0.11, zero meant cached requests always expire.\n\n.. setting:: HTTPCACHE_DIR\n\nHTTPCACHE_DIR\n^^^^^^^^^^^^^\n\nDefault: ``'httpcache'``\n\nThe directory to use for storing the (low-level) HTTP cache. If empty, the HTTP\ncache will be disabled. If a relative path is given, is taken relative to the\nproject data dir. For more info see: :ref:`topics-project-structure`.\n\n.. setting:: HTTPCACHE_IGNORE_HTTP_CODES\n\nHTTPCACHE_IGNORE_HTTP_CODES\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.10\n\nDefault: ``[]``\n\nDon't cache response with these HTTP codes.\n\n.. setting:: HTTPCACHE_IGNORE_MISSING\n\nHTTPCACHE_IGNORE_MISSING\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``False``\n\nIf enabled, requests not found in the cache will be ignored instead of downloaded.\n\n.. setting:: HTTPCACHE_IGNORE_SCHEMES\n\nHTTPCACHE_IGNORE_SCHEMES\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.10\n\nDefault: ``['file']``\n\nDon't cache responses with these URI schemes.\n\n.. setting:: HTTPCACHE_STORAGE\n\nHTTPCACHE_STORAGE\n^^^^^^^^^^^^^^^^^\n\nDefault: ``'scrapy.extensions.httpcache.FilesystemCacheStorage'``\n\nThe class which implements the cache storage backend.\n\n.. setting:: HTTPCACHE_DBM_MODULE\n\nHTTPCACHE_DBM_MODULE\n^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.13\n\nDefault: ``'anydbm'``\n\nThe database module to use in the :ref:`DBM storage backend\n<httpcache-storage-dbm>`. This setting is specific to the DBM backend.\n\n.. setting:: HTTPCACHE_POLICY\n\nHTTPCACHE_POLICY\n^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.18\n\nDefault: ``'scrapy.extensions.httpcache.DummyPolicy'``\n\nThe class which implements the cache policy.\n\n.. setting:: HTTPCACHE_GZIP\n\nHTTPCACHE_GZIP\n^^^^^^^^^^^^^^\n\n.. versionadded:: 1.0\n\nDefault: ``False``\n\nIf enabled, will compress all cached data with gzip.\nThis setting is specific to the Filesystem backend.\n\n.. setting:: HTTPCACHE_ALWAYS_STORE\n\nHTTPCACHE_ALWAYS_STORE\n^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 1.1\n\nDefault: ``False``\n\nIf enabled, will cache pages unconditionally.\n\nA spider may wish to have all responses available in the cache, for\nfuture use with ``Cache-Control: max-stale``, for instance. The\nDummyPolicy caches all responses but never revalidates them, and\nsometimes a more nuanced policy is desirable.\n\nThis setting still respects ``Cache-Control: no-store`` directives in responses.\nIf you don't want that, filter ``no-store`` out of the Cache-Control headers in\nresponses you feedto the cache middleware.\n\n.. setting:: HTTPCACHE_IGNORE_RESPONSE_CACHE_CONTROLS\n\nHTTPCACHE_IGNORE_RESPONSE_CACHE_CONTROLS\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 1.1\n\nDefault: ``[]``\n\nList of Cache-Control directives in responses to be ignored.\n\nSites often set \"no-store\", \"no-cache\", \"must-revalidate\", etc., but get\nupset at the traffic a spider can generate if it respects those\ndirectives. This allows to selectively ignore Cache-Control directives\nthat are known to be unimportant for the sites being crawled.\n\nWe assume that the spider will not issue Cache-Control directives\nin requests unless it actually needs them, so directives in requests are\nnot filtered.\n\nHttpCompressionMiddleware\n-------------------------\n\n.. module:: scrapy.downloadermiddlewares.httpcompression\n   :synopsis: Http Compression Middleware\n\n.. class:: HttpCompressionMiddleware\n\n   This middleware allows compressed (gzip, deflate) traffic to be\n   sent/received from web sites.\n\n   This middleware also supports decoding `brotli-compressed`_ responses,\n   provided `brotlipy`_ is installed.\n\n.. _brotli-compressed: https://www.ietf.org/rfc/rfc7932.txt\n.. _brotlipy: https://pypi.python.org/pypi/brotlipy\n\nHttpCompressionMiddleware Settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: COMPRESSION_ENABLED\n\nCOMPRESSION_ENABLED\n^^^^^^^^^^^^^^^^^^^\n\nDefault: ``True``\n\nWhether the Compression middleware will be enabled.\n\n\nHttpProxyMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.httpproxy\n   :synopsis: Http Proxy Middleware\n\n.. versionadded:: 0.8\n\n.. reqmeta:: proxy\n\n.. class:: HttpProxyMiddleware\n\n   This middleware sets the HTTP proxy to use for requests, by setting the\n   ``proxy`` meta value for :class:`~scrapy.http.Request` objects.\n\n   Like the Python standard library modules `urllib`_ and `urllib2`_, it obeys\n   the following environment variables:\n\n   * ``http_proxy``\n   * ``https_proxy``\n   * ``no_proxy``\n\n   You can also set the meta key ``proxy`` per-request, to a value like\n   ``http://some_proxy_server:port`` or ``http://username:password@some_proxy_server:port``.\n   Keep in mind this value will take precedence over ``http_proxy``/``https_proxy``\n   environment variables, and it will also ignore ``no_proxy`` environment variable.\n\n.. _urllib: https://docs.python.org/2/library/urllib.html\n.. _urllib2: https://docs.python.org/2/library/urllib2.html\n\nRedirectMiddleware\n------------------\n\n.. module:: scrapy.downloadermiddlewares.redirect\n   :synopsis: Redirection Middleware\n\n.. class:: RedirectMiddleware\n\n   This middleware handles redirection of requests based on response status.\n\n.. reqmeta:: redirect_urls\n\nThe urls which the request goes through (while being redirected) can be found\nin the ``redirect_urls`` :attr:`Request.meta <scrapy.http.Request.meta>` key.\n\n.. reqmeta:: redirect_reasons\n\nThe reason behind each redirect in :reqmeta:`redirect_urls` can be found in the\n``redirect_reasons`` :attr:`Request.meta <scrapy.http.Request.meta>` key. For\nexample: ``[301, 302, 307, 'meta refresh']``.\n\nThe format of a reason depends on the middleware that handled the corresponding\nredirect. For example, :class:`RedirectMiddleware` indicates the triggering\nresponse status code as an integer, while :class:`MetaRefreshMiddleware`\nalways uses the ``'meta refresh'`` string as reason.\n\nThe :class:`RedirectMiddleware` can be configured through the following\nsettings (see the settings documentation for more info):\n\n* :setting:`REDIRECT_ENABLED`\n* :setting:`REDIRECT_MAX_TIMES`\n\n.. reqmeta:: dont_redirect\n\nIf :attr:`Request.meta <scrapy.http.Request.meta>` has ``dont_redirect``\nkey set to True, the request will be ignored by this middleware.\n\nIf you want to handle some redirect status codes in your spider, you can\nspecify these in the ``handle_httpstatus_list`` spider attribute.\n\nFor example, if you want the redirect middleware to ignore 301 and 302\nresponses (and pass them through to your spider) you can do this::\n\n    class MySpider(CrawlSpider):\n        handle_httpstatus_list = [301, 302]\n\nThe ``handle_httpstatus_list`` key of :attr:`Request.meta\n<scrapy.http.Request.meta>` can also be used to specify which response codes to\nallow on a per-request basis. You can also set the meta key\n``handle_httpstatus_all`` to ``True`` if you want to allow any response code\nfor a request.\n\n\nRedirectMiddleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: REDIRECT_ENABLED\n\nREDIRECT_ENABLED\n^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.13\n\nDefault: ``True``\n\nWhether the Redirect middleware will be enabled.\n\n.. setting:: REDIRECT_MAX_TIMES\n\nREDIRECT_MAX_TIMES\n^^^^^^^^^^^^^^^^^^\n\nDefault: ``20``\n\nDefines the maximum times a request can be redirected. After this maximum the\nrequest's response is returned as is. We used Firefox default value for the\nsame task.\n\nMetaRefreshMiddleware\n---------------------\n\n.. class:: MetaRefreshMiddleware\n\n   This middleware handles redirection of requests based on meta-refresh html tag.\n\nThe :class:`MetaRefreshMiddleware` can be configured through the following\nsettings (see the settings documentation for more info):\n\n* :setting:`METAREFRESH_ENABLED`\n* :setting:`METAREFRESH_IGNORE_TAGS`\n* :setting:`METAREFRESH_MAXDELAY`\n\nThis middleware obey :setting:`REDIRECT_MAX_TIMES` setting, :reqmeta:`dont_redirect`,\n:reqmeta:`redirect_urls` and :reqmeta:`redirect_reasons` request meta keys as described\nfor :class:`RedirectMiddleware`\n\n\nMetaRefreshMiddleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: METAREFRESH_ENABLED\n\nMETAREFRESH_ENABLED\n^^^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.17\n\nDefault: ``True``\n\nWhether the Meta Refresh middleware will be enabled.\n\n.. setting:: METAREFRESH_IGNORE_TAGS\n\nMETAREFRESH_IGNORE_TAGS\n^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``['script', 'noscript']``\n\nMeta tags within these tags are ignored.\n\n.. setting:: METAREFRESH_MAXDELAY\n\nMETAREFRESH_MAXDELAY\n^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``100``\n\nThe maximum meta-refresh delay (in seconds) to follow the redirection.\nSome sites use meta-refresh for redirecting to a session expired page, so we\nrestrict automatic redirection to the maximum delay.\n\nRetryMiddleware\n---------------\n\n.. module:: scrapy.downloadermiddlewares.retry\n   :synopsis: Retry Middleware\n\n.. class:: RetryMiddleware\n\n   A middleware to retry failed requests that are potentially caused by\n   temporary problems such as a connection timeout or HTTP 500 error.\n\nFailed pages are collected on the scraping process and rescheduled at the\nend, once the spider has finished crawling all regular (non failed) pages.\n\nThe :class:`RetryMiddleware` can be configured through the following\nsettings (see the settings documentation for more info):\n\n* :setting:`RETRY_ENABLED`\n* :setting:`RETRY_TIMES`\n* :setting:`RETRY_HTTP_CODES`\n\n.. reqmeta:: dont_retry\n\nIf :attr:`Request.meta <scrapy.http.Request.meta>` has ``dont_retry`` key\nset to True, the request will be ignored by this middleware.\n\nRetryMiddleware Settings\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: RETRY_ENABLED\n\nRETRY_ENABLED\n^^^^^^^^^^^^^\n\n.. versionadded:: 0.13\n\nDefault: ``True``\n\nWhether the Retry middleware will be enabled.\n\n.. setting:: RETRY_TIMES\n\nRETRY_TIMES\n^^^^^^^^^^^\n\nDefault: ``2``\n\nMaximum number of times to retry, in addition to the first download.\n\nMaximum number of retries can also be specified per-request using\n:reqmeta:`max_retry_times` attribute of :attr:`Request.meta <scrapy.http.Request.meta>`.\nWhen initialized, the :reqmeta:`max_retry_times` meta key takes higher\nprecedence over the :setting:`RETRY_TIMES` setting.\n\n.. setting:: RETRY_HTTP_CODES\n\nRETRY_HTTP_CODES\n^^^^^^^^^^^^^^^^\n\nDefault: ``[500, 502, 503, 504, 522, 524, 408, 429]``\n\nWhich HTTP response codes to retry. Other errors (DNS lookup issues,\nconnections lost, etc) are always retried.\n\nIn some cases you may want to add 400 to :setting:`RETRY_HTTP_CODES` because\nit is a common code used to indicate server overload. It is not included by\ndefault because HTTP specs say so.\n\n\n.. _topics-dlmw-robots:\n\nRobotsTxtMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.robotstxt\n   :synopsis: robots.txt middleware\n\n.. class:: RobotsTxtMiddleware\n\n    This middleware filters out requests forbidden by the robots.txt exclusion\n    standard.\n\n    To make sure Scrapy respects robots.txt make sure the middleware is enabled\n    and the :setting:`ROBOTSTXT_OBEY` setting is enabled.\n\n    The :setting:`ROBOTSTXT_USER_AGENT` setting can be used to specify the\n    user agent string to use for matching in the robots.txt_ file. If it\n    is ``None``, the User-Agent header you are sending with the request or the\n    :setting:`USER_AGENT` setting (in that order) will be used for determining\n    the user agent to use in the robots.txt_ file.\n\n    This middleware has to be combined with a robots.txt_ parser.\n\n    Scrapy ships with support for the following robots.txt_ parsers:\n\n    * :ref:`Protego <protego-parser>` (default)\n    * :ref:`RobotFileParser <python-robotfileparser>`\n    * :ref:`Reppy <reppy-parser>`\n    * :ref:`Robotexclusionrulesparser <rerp-parser>`\n\n    You can change the robots.txt_ parser with the :setting:`ROBOTSTXT_PARSER`\n    setting. Or you can also :ref:`implement support for a new parser <support-for-new-robots-parser>`.\n\n.. reqmeta:: dont_obey_robotstxt\n\nIf :attr:`Request.meta <scrapy.http.Request.meta>` has\n``dont_obey_robotstxt`` key set to True\nthe request will be ignored by this middleware even if\n:setting:`ROBOTSTXT_OBEY` is enabled.\n\nParsers vary in several aspects:\n\n* Language of implementation\n\n* Supported specification\n\n* Support for wildcard matching\n\n* Usage of `length based rule <https://developers.google.com/search/reference/robots_txt#order-of-precedence-for-group-member-lines>`_:\n  in particular for ``Allow`` and ``Disallow`` directives, where the most\n  specific rule based on the length of the path trumps the less specific\n  (shorter) rule\n\nPerformance comparison of different parsers is available at `the following link\n<https://anubhavp28.github.io/gsoc-weekly-checkin-12/>`_.\n\n.. _protego-parser:\n\nProtego parser\n~~~~~~~~~~~~~~\n\nBased on `Protego <https://github.com/scrapy/protego>`_:\n\n* implemented in Python\n\n* is compliant with `Google's Robots.txt Specification\n  <https://developers.google.com/search/reference/robots_txt>`_\n\n* supports wildcard matching\n\n* uses the length based rule\n\nScrapy uses this parser by default.\n\n.. _python-robotfileparser:\n\nRobotFileParser\n~~~~~~~~~~~~~~~\n\nBased on `RobotFileParser\n<https://docs.python.org/3.7/library/urllib.robotparser.html>`_:\n\n* is Python's built-in robots.txt_ parser\n\n* is compliant with `Martijn Koster's 1996 draft specification\n  <http://www.robotstxt.org/norobots-rfc.txt>`_\n\n* lacks support for wildcard matching\n\n* doesn't use the length based rule\n\nIt is faster than Protego and backward-compatible with versions of Scrapy before 1.8.0.\n\nIn order to use this parser, set:\n\n* :setting:`ROBOTSTXT_PARSER` to ``scrapy.robotstxt.PythonRobotParser``\n\n.. _reppy-parser:\n\nReppy parser\n~~~~~~~~~~~~\n\nBased on `Reppy <https://github.com/seomoz/reppy/>`_:\n\n* is a Python wrapper around `Robots Exclusion Protocol Parser for C++\n  <https://github.com/seomoz/rep-cpp>`_\n\n* is compliant with `Martijn Koster's 1996 draft specification\n  <http://www.robotstxt.org/norobots-rfc.txt>`_\n\n* supports wildcard matching\n\n* uses the length based rule\n\nNative implementation, provides better speed than Protego.\n\nIn order to use this parser:\n\n* Install `Reppy <https://github.com/seomoz/reppy/>`_ by running ``pip install reppy``\n\n* Set :setting:`ROBOTSTXT_PARSER` setting to\n  ``scrapy.robotstxt.ReppyRobotParser``\n\n.. _rerp-parser:\n\nRobotexclusionrulesparser\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBased on `Robotexclusionrulesparser <http://nikitathespider.com/python/rerp/>`_:\n\n* implemented in Python\n\n* is compliant with `Martijn Koster's 1996 draft specification\n  <http://www.robotstxt.org/norobots-rfc.txt>`_\n\n* supports wildcard matching\n\n* doesn't use the length based rule\n\nIn order to use this parser:\n\n* Install `Robotexclusionrulesparser <http://nikitathespider.com/python/rerp/>`_ by running\n  ``pip install robotexclusionrulesparser``\n\n* Set :setting:`ROBOTSTXT_PARSER` setting to\n  ``scrapy.robotstxt.RerpRobotParser``\n\n.. _support-for-new-robots-parser:\n\nImplementing support for a new parser\n-------------------------------------\n\nYou can implement support for a new robots.txt_ parser by subclassing\nthe abstract base class :class:`~scrapy.robotstxt.RobotParser` and\nimplementing the methods described below.\n\n.. module:: scrapy.robotstxt\n   :synopsis: robots.txt parser interface and implementations\n\n.. autoclass:: RobotParser\n   :members:\n\n.. _robots.txt: http://www.robotstxt.org/\n\nDownloaderStats\n---------------\n\n.. module:: scrapy.downloadermiddlewares.stats\n   :synopsis: Downloader Stats Middleware\n\n.. class:: DownloaderStats\n\n   Middleware that stores stats of all requests, responses and exceptions that\n   pass through it.\n\n   To use this middleware you must enable the :setting:`DOWNLOADER_STATS`\n   setting.\n\nUserAgentMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.useragent\n   :synopsis: User Agent Middleware\n\n.. class:: UserAgentMiddleware\n\n   Middleware that allows spiders to override the default user agent.\n\n   In order for a spider to override the default user agent, its ``user_agent``\n   attribute must be set.\n\n.. _ajaxcrawl-middleware:\n\nAjaxCrawlMiddleware\n-------------------\n\n.. module:: scrapy.downloadermiddlewares.ajaxcrawl\n\n.. class:: AjaxCrawlMiddleware\n\n   Middleware that finds 'AJAX crawlable' page variants based\n   on meta-fragment html tag. See\n   https://developers.google.com/webmasters/ajax-crawling/docs/getting-started\n   for more info.\n\n   .. note::\n\n       Scrapy finds 'AJAX crawlable' pages for URLs like\n       ``'http://example.com/!#foo=bar'`` even without this middleware.\n       AjaxCrawlMiddleware is necessary when URL doesn't contain ``'!#'``.\n       This is often a case for 'index' or 'main' website pages.\n\nAjaxCrawlMiddleware Settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: AJAXCRAWL_ENABLED\n\nAJAXCRAWL_ENABLED\n^^^^^^^^^^^^^^^^^\n\n.. versionadded:: 0.21\n\nDefault: ``False``\n\nWhether the AjaxCrawlMiddleware will be enabled. You may want to\nenable it for :ref:`broad crawls <topics-broad-crawls>`.\n\nHttpProxyMiddleware settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. setting:: HTTPPROXY_ENABLED\n.. setting:: HTTPPROXY_AUTH_ENCODING\n\nHTTPPROXY_ENABLED\n^^^^^^^^^^^^^^^^^\n\nDefault: ``True``\n\nWhether or not to enable the :class:`HttpProxyMiddleware`.\n\nHTTPPROXY_AUTH_ENCODING\n^^^^^^^^^^^^^^^^^^^^^^^\n\nDefault: ``\"latin-1\"``\n\nThe default encoding for proxy authentication on :class:`HttpProxyMiddleware`.\n\n\n.. _DBM: https://en.wikipedia.org/wiki/Dbm\n.. _anydbm: https://docs.python.org/2/library/anydbm.html\n", "\"\"\"\nHTTP basic auth downloader middleware\n\nSee documentation in docs/topics/downloader-middleware.rst\n\"\"\"\nimport warnings\n\nfrom w3lib.http import basic_auth_header\n\nfrom scrapy import signals\nfrom scrapy.exceptions import ScrapyDeprecationWarning\nfrom scrapy.utils.httpobj import urlparse_cached\nfrom scrapy.utils.url import url_is_from_any_domain\n\n\nclass HttpAuthMiddleware(object):\n    \"\"\"Set Basic HTTP Authorization header\n    (http_user and http_pass spider class attributes)\"\"\"\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        o = cls()\n        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n        return o\n\n    def spider_opened(self, spider):\n        usr = getattr(spider, 'http_user', '')\n        pwd = getattr(spider, 'http_pass', '')\n        if usr or pwd:\n            self.auth = basic_auth_header(usr, pwd)\n            if not hasattr(spider, 'http_auth_domain'):\n                warnings.warn('Using HttpAuthMiddleware without http_auth_domain is deprecated and can cause security '\n                              'problems if the spider makes requests to several different domains. http_auth_domain '\n                              'will be set to the domain of the first request, please set it to the correct value '\n                              'explicitly.',\n                              category=ScrapyDeprecationWarning)\n                self.domain_unset = True\n            else:\n                self.domain = spider.http_auth_domain\n                self.domain_unset = False\n\n    def process_request(self, request, spider):\n        auth = getattr(self, 'auth', None)\n        if auth and b'Authorization' not in request.headers:\n            domain = urlparse_cached(request).hostname\n            if self.domain_unset:\n                self.domain = domain\n                self.domain_unset = False\n            if not self.domain or url_is_from_any_domain(request.url, [self.domain]):\n                request.headers[b'Authorization'] = auth\n", "import unittest\n\nfrom w3lib.http import basic_auth_header\n\nfrom scrapy.http import Request\nfrom scrapy.downloadermiddlewares.httpauth import HttpAuthMiddleware\nfrom scrapy.spiders import Spider\n\n\nclass TestSpiderLegacy(Spider):\n    http_user = 'foo'\n    http_pass = 'bar'\n\n\nclass TestSpider(Spider):\n    http_user = 'foo'\n    http_pass = 'bar'\n    http_auth_domain = 'example.com'\n\n\nclass TestSpiderAny(Spider):\n    http_user = 'foo'\n    http_pass = 'bar'\n    http_auth_domain = None\n\n\nclass HttpAuthMiddlewareLegacyTest(unittest.TestCase):\n\n    def setUp(self):\n        self.spider = TestSpiderLegacy('foo')\n\n    def test_auth(self):\n        mw = HttpAuthMiddleware()\n        mw.spider_opened(self.spider)\n\n        # initial request, sets the domain and sends the header\n        req = Request('http://example.com/')\n        assert mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], basic_auth_header('foo', 'bar'))\n\n        # subsequent request to the same domain, should send the header\n        req = Request('http://example.com/')\n        assert mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], basic_auth_header('foo', 'bar'))\n\n        # subsequent request to a different domain, shouldn't send the header\n        req = Request('http://example-noauth.com/')\n        assert mw.process_request(req, self.spider) is None\n        self.assertNotIn('Authorization', req.headers)\n\n    def test_auth_already_set(self):\n        mw = HttpAuthMiddleware()\n        mw.spider_opened(self.spider)\n        req = Request('http://example.com/',\n                      headers=dict(Authorization='Digest 123'))\n        assert mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], b'Digest 123')\n\n\nclass HttpAuthMiddlewareTest(unittest.TestCase):\n\n    def setUp(self):\n        self.mw = HttpAuthMiddleware()\n        self.spider = TestSpider('foo')\n        self.mw.spider_opened(self.spider)\n\n    def tearDown(self):\n        del self.mw\n\n    def test_no_auth(self):\n        req = Request('http://example-noauth.com/')\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertNotIn('Authorization', req.headers)\n\n    def test_auth_domain(self):\n        req = Request('http://example.com/')\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], basic_auth_header('foo', 'bar'))\n\n    def test_auth_subdomain(self):\n        req = Request('http://foo.example.com/')\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], basic_auth_header('foo', 'bar'))\n\n    def test_auth_already_set(self):\n        req = Request('http://example.com/',\n                      headers=dict(Authorization='Digest 123'))\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], b'Digest 123')\n\n\nclass HttpAuthAnyMiddlewareTest(unittest.TestCase):\n\n    def setUp(self):\n        self.mw = HttpAuthMiddleware()\n        self.spider = TestSpiderAny('foo')\n        self.mw.spider_opened(self.spider)\n\n    def tearDown(self):\n        del self.mw\n\n    def test_auth(self):\n        req = Request('http://example.com/')\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], basic_auth_header('foo', 'bar'))\n\n    def test_auth_already_set(self):\n        req = Request('http://example.com/',\n                      headers=dict(Authorization='Digest 123'))\n        assert self.mw.process_request(req, self.spider) is None\n        self.assertEqual(req.headers['Authorization'], b'Digest 123')\n"], "filenames": ["docs/topics/downloader-middleware.rst", "scrapy/downloadermiddlewares/httpauth.py", "tests/test_downloadermiddleware_httpauth.py"], "buggy_code_start_loc": [318, 5, 1], "buggy_code_end_loc": [328, 32, 32], "fixing_code_start_loc": [318, 6, 2], "fixing_code_end_loc": [343, 51, 112], "type": "CWE-522", "message": "Scrapy is a high-level web crawling and scraping framework for Python. If you use `HttpAuthMiddleware` (i.e. the `http_user` and `http_pass` spider attributes) for HTTP authentication, all requests will expose your credentials to the request target. This includes requests generated by Scrapy components, such as `robots.txt` requests sent by Scrapy when the `ROBOTSTXT_OBEY` setting is set to `True`, or as requests reached through redirects. Upgrade to Scrapy 2.5.1 and use the new `http_auth_domain` spider attribute to control which domains are allowed to receive the configured HTTP authentication credentials. If you are using Scrapy 1.8 or a lower version, and upgrading to Scrapy 2.5.1 is not an option, you may upgrade to Scrapy 1.8.1 instead. If you cannot upgrade, set your HTTP authentication credentials on a per-request basis, using for example the `w3lib.http.basic_auth_header` function to convert your credentials into a value that you can assign to the `Authorization` header of your request, instead of defining your credentials globally using `HttpAuthMiddleware`.", "other": {"cve": {"id": "CVE-2021-41125", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-06T18:15:10.953", "lastModified": "2022-04-22T16:00:36.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Scrapy is a high-level web crawling and scraping framework for Python. If you use `HttpAuthMiddleware` (i.e. the `http_user` and `http_pass` spider attributes) for HTTP authentication, all requests will expose your credentials to the request target. This includes requests generated by Scrapy components, such as `robots.txt` requests sent by Scrapy when the `ROBOTSTXT_OBEY` setting is set to `True`, or as requests reached through redirects. Upgrade to Scrapy 2.5.1 and use the new `http_auth_domain` spider attribute to control which domains are allowed to receive the configured HTTP authentication credentials. If you are using Scrapy 1.8 or a lower version, and upgrading to Scrapy 2.5.1 is not an option, you may upgrade to Scrapy 1.8.1 instead. If you cannot upgrade, set your HTTP authentication credentials on a per-request basis, using for example the `w3lib.http.basic_auth_header` function to convert your credentials into a value that you can assign to the `Authorization` header of your request, instead of defining your credentials globally using `HttpAuthMiddleware`."}, {"lang": "es", "value": "Scrapy es un marco de trabajo de alto nivel para el rastreo de la web y el scraping para Python. Si usa \"HttpAuthMiddleware\" (es decir, los atributos de ara\u00f1a \"http_user\" y \"http_pass\") para la autenticaci\u00f3n HTTP, todas las peticiones expondr\u00e1n sus credenciales al objetivo de la petici\u00f3n. Esto incluye las peticiones generadas por los componentes de Scrapy, como las peticiones \"robots.txt\" enviadas por Scrapy cuando la configuraci\u00f3n \"ROBOTSTXT_OBEY\" se establece en \"True\", o como las peticiones alcanzadas a trav\u00e9s de redirecciones. Actualice a Scrapy 2.5.1 y use el nuevo atributo de ara\u00f1a \"http_auth_domain\" para controlar qu\u00e9 dominios pueden recibir las credenciales de autenticaci\u00f3n HTTP configuradas. Si est\u00e1 usando Scrapy versi\u00f3n 1.8 o una versi\u00f3n inferior, y la actualizaci\u00f3n a Scrapy versi\u00f3n 2.5.1 no es una opci\u00f3n, puede actualizar a Scrapy versi\u00f3n 1.8.1 en su lugar. Si no puede actualizar, establezca sus credenciales de autenticaci\u00f3n HTTP por petici\u00f3n, usando por ejemplo la funci\u00f3n \"w3lib.http.basic_auth_header\" para convertir sus credenciales en un valor que pueda asignar al encabezado \"Authorization\" de su petici\u00f3n, en lugar de definir sus credenciales globalmente usando \"HttpAuthMiddleware\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:scrapy:scrapy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.1", "matchCriteriaId": "4055A315-2C5D-4B44-BD9F-89C1AD000837"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scrapy:scrapy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.5.1", "matchCriteriaId": "AC1006AF-4F0A-470B-BC01-0F95C9CA0975"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://doc.scrapy.org/en/latest/topics/downloader-middleware.html#module-scrapy.downloadermiddlewares.httpauth", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/scrapy/scrapy/commit/b01d69a1bf48060daec8f751368622352d8b85a6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/scrapy/scrapy/security/advisories/GHSA-jwqp-28gf-p498", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://w3lib.readthedocs.io/en/latest/w3lib.html#w3lib.http.basic_auth_header", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/scrapy/scrapy/commit/b01d69a1bf48060daec8f751368622352d8b85a6"}}