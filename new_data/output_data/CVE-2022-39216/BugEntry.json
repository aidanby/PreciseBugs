{"buggy_code": ["<?php\n// Copyright (C) 2010-2017 Combodo SARL\n//\n//   This file is part of iTop.\n//\n//   iTop is free software; you can redistribute it and/or modify\t\n//   it under the terms of the GNU Affero General Public License as published by\n//   the Free Software Foundation, either version 3 of the License, or\n//   (at your option) any later version.\n//\n//   iTop is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU Affero General Public License for more details.\n//\n//   You should have received a copy of the GNU Affero General Public License\n//   along with iTop. If not, see <http://www.gnu.org/licenses/>\n\n\n/**\n * Class LoginWebPage\n *\n * @copyright   Copyright (C) 2010-2017 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\n/**\n * Web page used for displaying the login form\n */\n\nclass LoginWebPage extends NiceWebPage\n{\n\tconst EXIT_PROMPT = 0;\n\tconst EXIT_HTTP_401 = 1;\n\tconst EXIT_RETURN = 2;\n\t\n\tconst EXIT_CODE_OK = 0;\n\tconst EXIT_CODE_MISSINGLOGIN = 1;\n\tconst EXIT_CODE_MISSINGPASSWORD = 2;\n\tconst EXIT_CODE_WRONGCREDENTIALS = 3;\n\tconst EXIT_CODE_MUSTBEADMIN = 4;\n\tconst EXIT_CODE_PORTALUSERNOTAUTHORIZED = 5;\n\tconst EXIT_CODE_NOTAUTHORIZED = 6;\n\n\t// Login FSM States\n\tconst LOGIN_STATE_START = 'start';                          // Entry state\n\tconst LOGIN_STATE_MODE_DETECTION = 'login mode detection';  // Detect which login plugin to use\n\tconst LOGIN_STATE_READ_CREDENTIALS = 'read credentials';    // Read the credentials\n\tconst LOGIN_STATE_CHECK_CREDENTIALS = 'check credentials';  // Check if the credentials are valid\n\tconst LOGIN_STATE_CREDENTIALS_OK = 'credentials ok';        // User provisioning\n\tconst LOGIN_STATE_USER_OK = 'user ok';                      // Additional check (2FA)\n\tconst LOGIN_STATE_CONNECTED = 'connected';                  // User connected\n\tconst LOGIN_STATE_SET_ERROR = 'prepare for error';\t        // Internal state to trigger ERROR state\n\tconst LOGIN_STATE_ERROR = 'error';                          // An error occurred, next state will be NONE\n\n\t// Login FSM Returns\n\tconst LOGIN_FSM_RETURN = 0;           // End the FSM OK (connected)\n\tconst LOGIN_FSM_ERROR = 1;        // Error signaled\n\tconst LOGIN_FSM_CONTINUE = 2;     // Continue FSM\n\n\tprotected static $sHandlerClass = __class__;\n\tprivate static $iOnExit;\n\n\tpublic static function RegisterHandler($sClass)\n\t{\n\t\tself::$sHandlerClass = $sClass;\n\t}\n\n\t/**\n\t * @return \\LoginWebPage\n\t */\n\tpublic static function NewLoginWebPage()\n\t{\n\t\treturn new self::$sHandlerClass;\n\t}\n\n\tprotected static $m_sLoginFailedMessage = '';\n\t\n\tpublic function __construct($sTitle = null)\n\t{\n\t\tif ($sTitle === null) {\n\t\t\t$sTitle = Dict::S('UI:Login:Title');\n\t\t}\n\n\t\tparent::__construct($sTitle);\n\t\t$this->SetStyleSheet();\n\t\t$this->no_cache();\n\t\t$this->add_xframe_options();\n\t}\n\t\n\tpublic function SetStyleSheet()\n\t{\n\t\t$this->add_linked_stylesheet(utils::GetAbsoluteUrlAppRoot().'css/login.css');\n\t\t$this->add_linked_stylesheet(utils::GetAbsoluteUrlAppRoot().'css/font-awesome/css/all.min.css');\n\t\t$this->add_linked_stylesheet(utils::GetAbsoluteUrlAppRoot().'css/font-awesome/css/v4-shims.min.css');\n\t}\n\n\tpublic static function SetLoginFailedMessage($sMessage)\n\t{\n\t\tself::$m_sLoginFailedMessage = $sMessage;\n\t}\n\n\tpublic function DisplayLoginHeader($bMainAppLogo = false)\n\t{\n\t\t$sLogo = 'itop-logo-external.png';\n\t\t$sBrandingLogo = 'login-logo.png';\n\n\t\t$sVersionShort = Dict::Format('UI:iTopVersion:Short', ITOP_APPLICATION, ITOP_VERSION);\n\t\t$sIconUrl = Utils::GetConfig()->Get('app_icon_url');\n\t\t$sDisplayIcon = utils::GetAbsoluteUrlAppRoot().'images/'.$sLogo.'?t='.utils::GetCacheBusterTimestamp();\n\t\tif (file_exists(MODULESROOT.'branding/'.$sBrandingLogo))\n\t\t{\n\t\t\t$sDisplayIcon = utils::GetAbsoluteUrlModulesRoot().'branding/'.$sBrandingLogo.'?t='.utils::GetCacheBusterTimestamp();\n\t\t}\n\t\t$this->add(\"<div id=\\\"login-logo\\\"><a href=\\\"\".htmlentities($sIconUrl, ENT_QUOTES,\n\t\t\t\tself::PAGES_CHARSET).\"\\\"><img title=\\\"$sVersionShort\\\" src=\\\"$sDisplayIcon\\\"></a></div>\\n\");\n\t}\n\n\tpublic function DisplayLoginForm($bFailedLogin = false)\n\t{\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aPostedVars = array_merge(array('login_mode', 'loginop'), $oTwigContext->GetPostedVars());\n\n\t\t$sMessage = Dict::S('UI:Login:IdentifyYourself');\n\n\t\t// Error message\n\t\tif ($bFailedLogin)\n\t\t{\n\t\t\tif (self::$m_sLoginFailedMessage != '')\n\t\t\t{\n\t\t\t\t$sMessage = self::$m_sLoginFailedMessage;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$sMessage = Dict::S('UI:Login:IncorrectLoginPassword');\n\t\t\t}\n\t\t}\n\n\t\t// Keep the OTHER parameters posted\n\t\t$aPreviousPostedVars = array();\n\t\tforeach($_POST as $sPostedKey => $postedValue)\n\t\t{\n\t\t\tif (!in_array($sPostedKey, $aPostedVars))\n\t\t\t{\n\t\t\t\tif (is_array($postedValue))\n\t\t\t\t{\n\t\t\t\t\tforeach($postedValue as $sKey => $sValue)\n\t\t\t\t\t{\n\t\t\t\t\t\t$sName = \"{$sPostedKey}[{$sKey}]\";\n\t\t\t\t\t\t$aPreviousPostedVars[$sName] = $sValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$aPreviousPostedVars[$sPostedKey] = $postedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$aVars = array(\n\t\t\t'bFailedLogin' => $bFailedLogin,\n\t\t\t'sMessage' => $sMessage,\n\t\t\t'aPreviousPostedVars' => $aPreviousPostedVars,\n\t\t);\n\t\t$aVars = array_merge($aVars, $oTwigContext->GetDefaultVars());\n\n\t\t$oTwigContext->Render($this, 'login.html.twig', $aVars);\n\t}\n\n\tpublic function DisplayForgotPwdForm($bFailedToReset = false, $sFailureReason = null)\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', true, 'raw_data');\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t$aVars['sAuthUser'] = $sAuthUser;\n\t\t$aVars['bFailedToReset'] = $bFailedToReset;\n\t\t$aVars['sFailureReason'] = $sFailureReason;\n\n\t\t$oTwigContext->Render($this, 'forgotpwdform.html.twig', $aVars);\n\t}\n\n\tprotected function ForgotPwdGo()\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', true, 'raw_data');\n\n\t\ttry\n\t\t{\n\t\t\tUserRights::Login($sAuthUser); // Set the user's language (if possible!)\n            /** @var UserInternal $oUser */\n            $oUser = UserRights::GetUserObject();\n\n\t\t\tif ($oUser != null)\n\t\t\t{\n\t\t\t\tif (!MetaModel::IsValidAttCode(get_class($oUser), 'reset_pwd_token'))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-NotPossible'));\n\t\t\t\t}\n\t\t\t\tif (!$oUser->CanChangePassword())\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-FixedPwd'));\n\t\t\t\t}\n\n\t\t\t\t$sTo = $oUser->GetResetPasswordEmail(); // throws Exceptions if not allowed\n\t\t\t\tif ($sTo == '')\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-NoEmail'));\n\t\t\t\t}\n\n\t\t\t\t// This token allows the user to change the password without knowing the previous one\n\t\t\t\t$sToken = substr(md5(APPROOT.uniqid()), 0, 16);\n\t\t\t\t$oUser->Set('reset_pwd_token', $sToken);\n\t\t\t\tCMDBObject::SetTrackInfo('Reset password');\n\t\t\t\t$oUser->AllowWrite(true);\n\t\t\t\t$oUser->DBUpdate();\n\n\t\t\t\t$oEmail = new Email();\n\t\t\t\t$oEmail->SetRecipientTO($sTo);\n\t\t\t\t$sFrom = MetaModel::GetConfig()->Get('forgot_password_from');\n\t\t\t\t$oEmail->SetRecipientFrom($sFrom);\n\t\t\t\t$oEmail->SetSubject(Dict::S('UI:ResetPwd-EmailSubject', $oUser->Get('login')));\n\t\t\t\t$sResetUrl = utils::GetAbsoluteUrlAppRoot().'pages/UI.php?loginop=reset_pwd&auth_user='.urlencode($oUser->Get('login')).'&token='.urlencode($sToken);\n\t\t\t\t$oEmail->SetBody(Dict::Format('UI:ResetPwd-EmailBody', $sResetUrl, $oUser->Get('login')));\n\t\t\t\t$iRes = $oEmail->Send($aIssues, true /* force synchronous exec */);\n\t\t\t\tswitch ($iRes)\n\t\t\t\t{\n\t\t\t\t\t//case EMAIL_SEND_PENDING:\n\t\t\t\t\tcase EMAIL_SEND_OK:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EMAIL_SEND_ERROR:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tIssueLog::Error('Failed to send the email with the NEW password for '.$oUser->Get('friendlyname').': '.implode(', ', $aIssues));\n\t\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-Send'));\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t\t$oTwigContext->Render($this, 'forgotpwdsent.html.twig', $aVars);\n\t\t}\n\t\tcatch(Exception $e)\n\t\t{\n\t\t\t$this->DisplayForgotPwdForm(true, $e->getMessage());\n\t\t}\n\t}\n\n\tpublic function DisplayResetPwdForm($sErrorMessage = null)\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t$sToken = utils::ReadParam('token', '', false, 'raw_data');\n\n\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t$oUser = UserRights::GetUserObject();\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\n\t\t$aVars['sAuthUser'] = $sAuthUser;\n\t\t$aVars['sToken'] = $sToken;\n\t\t$aVars['sErrorMessage'] = $sErrorMessage;\n\n\t\tif (($oUser == null))\n\t\t{\n\t\t\t$aVars['bNoUser'] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$aVars['bNoUser'] = false;\n\t\t\t$aVars['sUserName'] = $oUser->GetFriendlyName();\n\t\t\t$oEncryptedToken = $oUser->Get('reset_pwd_token');\n\n\t\t\tif (!$oEncryptedToken->CheckPassword($sToken))\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = false;\n\t\t\t}\n\t\t}\n\n\t\t$oTwigContext->Render($this, 'resetpwdform.html.twig', $aVars);\n\t}\n\n\tpublic function DoResetPassword()\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t$sToken = utils::ReadParam('token', '', false, 'raw_data');\n\t\t$sNewPwd = utils::ReadPostedParam('new_pwd', '', 'raw_data');\n\n\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t/** @var \\UserLocal $oUser */\n\t\t$oUser = UserRights::GetUserObject();\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\n\t\t$aVars['sAuthUser'] = $sAuthUser;\n\t\t$aVars['sToken'] = $sToken;\n\t\tif (($oUser == null))\n\t\t{\n\t\t\t$aVars['bNoUser'] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$aVars['bNoUser'] = false;\n\t\t\t$oEncryptedToken = $oUser->Get('reset_pwd_token');\n\n\t\t\tif (!$oEncryptedToken->CheckPassword($sToken))\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = false;\n\t\t\t\t// Trash the token and change the password\n\t\t\t\t$oUser->Set('reset_pwd_token', new ormPassword());\n\t\t\t\t$oUser->AllowWrite(true);\n\t\t\t\t$oUser->SetPassword($sNewPwd); // Does record the change into the DB\n\t\t\t\t$aVars['sUrl'] = utils::GetAbsoluteUrlAppRoot();\n\t\t\t}\n\t\t}\n\n\t\t$oTwigContext->Render($this, 'resetpwddone.html.twig', $aVars);\n\t}\n\n\tpublic function DisplayChangePwdForm($bFailedLogin = false, $sIssue = null)\n\t{\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t$aVars['bFailedLogin'] = $bFailedLogin;\n\t\t$aVars['sIssue'] = $sIssue;\n\t\t$oTwigContext->Render($this, 'changepwdform.html.twig', $aVars);\n\t}\n\n\tpublic function DisplayLogoutPage($bPortal, $sTitle = null)\n\t{\n\t\t$sUrl = utils::GetAbsoluteUrlAppRoot();\n\t\t$sUrl .= $bPortal ? 'portal/' : 'pages/UI.php';\n\t\t$sTitle = empty($sTitle) ? Dict::S('UI:LogOff:ThankYou') : $sTitle;\n\t\t$sMessage = Dict::S('UI:LogOff:ClickHereToLoginAgain');\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t$aVars['sUrl'] = $sUrl;\n\t\t$aVars['sTitle'] = $sTitle;\n\t\t$aVars['sMessage'] = $sMessage;\n\n\t\t$oTwigContext->Render($this, 'logout.html.twig', $aVars);\n\t\t$this->output();\n\t}\n\n\tpublic static function ResetSession()\n\t{\n\t\t// Unset all of the session variables.\n\t\tunset($_SESSION['auth_user']);\n\t\tunset($_SESSION['login_state']);\n\t\tunset($_SESSION['can_logoff']);\n\t\tunset($_SESSION['archive_mode']);\n\t\tunset($_SESSION['impersonate_user']);\n\t\tUserRights::_ResetSessionCache();\n\t\t// If it's desired to kill the session, also delete the session cookie.\n\t\t// Note: This will destroy the session, and not just the session data!\n\t}\n\n\tstatic function SecureConnectionRequired()\n\t{\n\t\treturn MetaModel::GetConfig()->GetSecureConnectionRequired();\n\t}\n\n\t/**\n\t * Guess if a string looks like an UTF-8 string based on some ranges of multi-bytes encoding\n\t * @param string $sString\n\t * @return bool True if the string contains some typical UTF-8 multi-byte sequences\n\t */\n\tstatic function LooksLikeUTF8($sString)\n\t{\n\t\treturn preg_match('%(?:\n        \t\t\t[\\xC2-\\xDF][\\x80-\\xBF]             # non-overlong 2-byte\n        \t\t\t|\\xE0[\\xA0-\\xBF][\\x80-\\xBF]        # excluding overlongs\n        \t\t\t|[\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2} # straight 3-byte\n        \t\t\t|\\xED[\\x80-\\x9F][\\x80-\\xBF]        # excluding surrogates\n        \t\t\t|\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}     # planes 1-3\n        \t\t\t|[\\xF1-\\xF3][\\x80-\\xBF]{3}         # planes 4-15\n        \t\t\t|\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}     # plane 16\n        \t)+%xs', $sString);\n\t}\n\t/**\n\t * Attempt a login\n\t *\n\t * @param int iOnExit What action to take if the user is not logged on (one of the class constants EXIT_...)\n\t *\n\t * @return int|void One of the class constants EXIT_CODE_...\n\t * @throws \\Exception\n\t */\n\tprotected static function Login($iOnExit)\n\t{\n\t\tself::$iOnExit = $iOnExit;\n\t\tif (self::SecureConnectionRequired() && !utils::IsConnectionSecure())\n\t\t{\n\t\t\t// Non secured URL... request for a secure connection\n\t\t\tthrow new Exception('Secure connection required!');\n\t\t}\n\t\t$bLoginDebug = MetaModel::GetConfig()->Get('login_debug');\n\n\t\tif (!isset($_SESSION['login_state']) || ($_SESSION['login_state'] == self::LOGIN_STATE_ERROR))\n\t\t{\n\t\t\t$_SESSION['login_state'] = self::LOGIN_STATE_START;\n\t\t}\n\t\t$sLoginState = $_SESSION['login_state'];\n\n\t\t$sSessionLog = '';\n\t\tif ($bLoginDebug)\n\t\t{\n\t\t\tIssueLog::Info(\"---------------------------------\");\n\t\t\tIssueLog::Info($_SERVER['REQUEST_URI']);\n\t\t\tIssueLog::Info(\"--> Entering Login FSM with state: [$sLoginState]\");\n\t\t\t$sSessionLog = session_id().' '.utils::GetSessionLog();\n\t\t\tIssueLog::Info(\"SESSION: $sSessionLog\");\n\t\t}\n\n\t\t$iErrorCode = self::EXIT_CODE_OK;\n\n\t\t// Finite state machine loop\n\t\twhile (true)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t$aLoginPlugins = self::GetLoginPluginList();\n\t\t\t\tif (empty($aLoginPlugins))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Missing login classes\");\n\t\t\t\t}\n\n\t\t\t\t/** @var iLoginFSMExtension $oLoginFSMExtensionInstance */\n\t\t\t\tforeach ($aLoginPlugins as $oLoginFSMExtensionInstance)\n\t\t\t\t{\n\t\t\t\t\tif ($bLoginDebug)\n\t\t\t\t\t{\n\t\t\t\t\t\t$sCurrSessionLog = session_id().' '.utils::GetSessionLog();\n\t\t\t\t\t\tif ($sCurrSessionLog != $sSessionLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$sSessionLog = $sCurrSessionLog;\n\t\t\t\t\t\t\tIssueLog::Info(\"SESSION: $sSessionLog\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tIssueLog::Info(\"Login: state: [$sLoginState] call: \".get_class($oLoginFSMExtensionInstance));\n\t\t\t\t\t}\n\t\t\t\t\t$iResponse = $oLoginFSMExtensionInstance->LoginAction($sLoginState, $iErrorCode);\n\t\t\t\t\tif ($iResponse == self::LOGIN_FSM_RETURN)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn $iErrorCode; // Asked to exit FSM, generally login OK\n\t\t\t\t\t}\n\t\t\t\t\tif ($iResponse == self::LOGIN_FSM_ERROR)\n\t\t\t\t\t{\n\t\t\t\t\t\t$sLoginState = self::LOGIN_STATE_SET_ERROR; // Next state will be error\n\t\t\t\t\t\t// An error was detected, skip the other plugins turn\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// The plugin has nothing to do for this state, continue to the next plugin\n\t\t\t\t}\n\n\t\t\t\t// Every plugin has nothing else to do in this state, go forward\n\t\t\t\t$sLoginState = self::AdvanceLoginFSMState($sLoginState);\n\t\t\t\t$_SESSION['login_state'] = $sLoginState;\n\t\t\t}\n\t\t\tcatch (Exception $e)\n\t\t\t{\n\t\t\t\tIssueLog::Error($e->getTraceAsString());\n\t\t\t\tstatic::ResetSession();\n\t\t\t\tdie($e->getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get plugins list ordered by config 'allowed_login_types'\n\t * Use the login mode to filter plugins\n\t *\n\t * @param string $sInterface 'iLoginFSMExtension' or 'iLogoutExtension'\n\t * @param bool $bFilterWithMode if false do not filter the plugin list with login mode\n\t *\n\t * @return array of plugins\n\t */\n\tpublic static function GetLoginPluginList($sInterface = 'iLoginFSMExtension', $bFilterWithMode = true)\n\t{\n\t\t$aAllPlugins = array();\n\n\t\tif ($bFilterWithMode)\n\t\t{\n\t\t\t$sCurrentLoginMode = isset($_SESSION['login_mode']) ? $_SESSION['login_mode'] : '';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$sCurrentLoginMode = '';\n\t\t}\n\n\t\t/** @var iLoginExtension $oLoginExtensionInstance */\n\t\tforeach (MetaModel::EnumPlugins($sInterface) as $oLoginExtensionInstance)\n\t\t{\n\t\t\t$aLoginModes = $oLoginExtensionInstance->ListSupportedLoginModes();\n\t\t\t$aLoginModes = (is_array($aLoginModes) ? $aLoginModes : array());\n\t\t\tforeach ($aLoginModes as $sLoginMode)\n\t\t\t{\n\t\t\t\t// Keep only the plugins for the current login mode + before + after\n\t\t\t\tif (empty($sCurrentLoginMode) || ($sLoginMode == $sCurrentLoginMode) || ($sLoginMode == 'before') || ($sLoginMode == 'after'))\n\t\t\t\t{\n\t\t\t\t\tif (!isset($aAllPlugins[$sLoginMode]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aAllPlugins[$sLoginMode] = array();\n\t\t\t\t\t}\n\t\t\t\t\t$aAllPlugins[$sLoginMode][] = $oLoginExtensionInstance;\n\t\t\t\t\tbreak; // Stop here to avoid registering a plugin twice\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Order and filter by the config list of allowed types (allowed_login_types)\n\t\t$aAllowedLoginModes = array_merge(array('before'), MetaModel::GetConfig()->GetAllowedLoginTypes(), array('after'));\n\t\t$aPlugins = array();\n\t\tforeach ($aAllowedLoginModes as $sAllowedMode)\n\t\t{\n\t\t\tif (isset($aAllPlugins[$sAllowedMode]))\n\t\t\t{\n\t\t\t\t$aPlugins = array_merge($aPlugins, $aAllPlugins[$sAllowedMode]);\n\t\t\t}\n\t\t}\n\t\treturn $aPlugins;\n\t}\n\n\t/**\n\t * Advance Login Finite State Machine to the next step\n\t *\n\t * @param string $sLoginState Current step\n\t *\n\t * @return string next step\n\t */\n\tprivate static function AdvanceLoginFSMState($sLoginState)\n\t{\n\t\tswitch ($sLoginState)\n\t\t{\n\t\t\tcase self::LOGIN_STATE_START:\n\t\t\t\treturn self::LOGIN_STATE_MODE_DETECTION;\n\n\t\t\tcase self::LOGIN_STATE_MODE_DETECTION:\n\t\t\t\treturn self::LOGIN_STATE_READ_CREDENTIALS;\n\n\t\t\tcase self::LOGIN_STATE_READ_CREDENTIALS:\n\t\t\t\treturn self::LOGIN_STATE_CHECK_CREDENTIALS;\n\n\t\t\tcase self::LOGIN_STATE_CHECK_CREDENTIALS:\n\t\t\t\treturn self::LOGIN_STATE_CREDENTIALS_OK;\n\n\t\t\tcase self::LOGIN_STATE_CREDENTIALS_OK:\n\t\t\t\treturn self::LOGIN_STATE_USER_OK;\n\n\t\t\tcase self::LOGIN_STATE_USER_OK:\n\t\t\t\treturn self::LOGIN_STATE_CONNECTED;\n\n\t\t\tcase self::LOGIN_STATE_CONNECTED:\n\t\t\tcase self::LOGIN_STATE_ERROR:\n\t\t\t\treturn self::LOGIN_STATE_START;\n\n\t\t\tcase self::LOGIN_STATE_SET_ERROR:\n\t\t\t\treturn self::LOGIN_STATE_ERROR;\n\t\t}\n\n\t\t// Default reset to NONE\n\t\treturn self::LOGIN_STATE_START;\n\t}\n\n\t/**\n\t * Login API: Check that credentials correspond to a valid user\n\t * Used only during login process when the password is known\n\t *\n\t * @api\n\t *\n\t * @param string $sAuthUser\n\t * @param string $sAuthPassword\n\t * @param string $sAuthentication ('internal' or 'external')\n\t *\n\t * @return bool (true if User OK)\n\t *\n\t */\n\tpublic static function CheckUser($sAuthUser, $sAuthPassword = '', $sAuthentication = 'external')\n\t{\n\t\t$oUser = self::FindUser($sAuthUser, true, ucfirst(strtolower($sAuthentication)));\n\t\tif (is_null($oUser))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $oUser->CheckCredentials($sAuthPassword);\n\t}\n\n\t/**\n\t * Login API: Store User info in the session when connection is OK\n\t *\n\t * @api\n\t *\n\t * @param $sAuthUser\n\t * @param $sAuthentication\n\t * @param $sLoginMode\n\t *\n\t * @throws ArchivedObjectException\n\t * @throws CoreCannotSaveObjectException\n\t * @throws CoreException\n\t * @throws CoreUnexpectedValue\n\t * @throws CoreWarning\n\t * @throws MySQLException\n\t * @throws OQLException\n\t * @throws \\Exception\n\t */\n\tpublic static function OnLoginSuccess($sAuthUser, $sAuthentication, $sLoginMode)\n\t{\n\t\t// User is Ok, let's save it in the session and proceed with normal login\n\t\t$bLoginSuccess = UserRights::Login($sAuthUser, $sAuthentication); // Login & set the user's language\n\t\tif (!$bLoginSuccess)\n\t\t{\n\t\t\tthrow new Exception(\"Bad user\");\n\t\t}\n\t\tif (MetaModel::GetConfig()->Get('log_usage')) {\n\t\t\t$oLog = new EventLoginUsage();\n\t\t\t$oLog->Set('userinfo', UserRights::GetUser());\n\t\t\t$oLog->Set('user_id', UserRights::GetUserObject()->GetKey());\n\t\t\t$oLog->Set('message', 'Successful login');\n\t\t\t$oLog->DBInsertNoReload();\n\t\t}\n\n\t\t$_SESSION['auth_user'] = $sAuthUser;\n\t\t$_SESSION['login_mode'] = $sLoginMode;\n\t\tUserRights::_InitSessionCache();\n\t}\n\n\t/**\n\t * Login API: Check that an already logger User is still valid\n\t *\n\t * @api\n\t *\n\t * @param int $iErrorCode\n\t *\n\t * @return int LOGIN_FSM_RETURN_OK or LOGIN_FSM_RETURN_ERROR\n\t */\n\tpublic static function CheckLoggedUser(&$iErrorCode)\n\t{\n\t\tif (isset($_SESSION['auth_user']))\n\t\t{\n\t\t\t// Already authenticated\n\t\t\t$bRet = UserRights::Login($_SESSION['auth_user']); // Login & set the user's language\n\t\t\tif ($bRet)\n\t\t\t{\n\t\t\t\t$iErrorCode = self::EXIT_CODE_OK;\n\t\t\t\treturn self::LOGIN_FSM_RETURN;\n\t\t\t}\n\t\t}\n\t\t// The user account is no longer valid/enabled\n\t\t$iErrorCode = self::EXIT_CODE_WRONGCREDENTIALS;\n\n\t\treturn self::LOGIN_FSM_ERROR;\n\t}\n\n\t/**\n\t * Exit with an HTTP 401 error\n\t */\n\tpublic static function HTTP401Error()\n\t{\n\t\theader('WWW-Authenticate: Basic realm=\"'.Dict::Format('UI:iTopVersion:Short', ITOP_APPLICATION, ITOP_VERSION));\n\t\theader('HTTP/1.0 401 Unauthorized');\n\t\theader('Content-type: text/html; charset='.self::PAGES_CHARSET);\n\t\t// Note: displayed when the user will click on Cancel\n\t\techo '<p><strong>'.Dict::S('UI:Login:Error:AccessRestricted').'</strong></p>';\n\t\texit;\n\t}\n\n\tpublic static function SetLoginModeAndReload($sNewLoginMode)\n\t{\n\t\tif (isset($_SESSION['login_mode']) && ($_SESSION['login_mode'] == $sNewLoginMode))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t$_SESSION['login_mode'] = $sNewLoginMode;\n\t\tself::HTTPReload();\n\t}\n\n\tpublic static function HTTPReload()\n\t{\n\t\t$sOriginURL = utils::GetCurrentAbsoluteUrl();\n\t\tif (!utils::StartsWith($sOriginURL, utils::GetAbsoluteUrlAppRoot()))\n\t\t{\n\t\t\t// If the found URL does not start with the configured AppRoot URL\n\t\t\t$sOriginURL = utils::GetAbsoluteUrlAppRoot().'pages/UI.php';\n\t\t}\n\t\tself::HTTPRedirect($sOriginURL);\n\t}\n\n\tpublic static function HTTPRedirect($sURL)\n\t{\n\t\theader('HTTP/1.1 307 Temporary Redirect');\n\t\theader('Location: '.$sURL);\n\t\texit;\n\t}\n\n\n\t/**\n\t * Provisioning API: Find a User\n\t *\n\t * @api\n\t *\n\t * @param string $sAuthUser\n\t * @param bool $bMustBeValid\n\t * @param string $sType\n\t *\n\t * @return \\User|null\n\t */\n\tpublic static function FindUser($sAuthUser, $bMustBeValid = true, $sType = 'External')\n\t{\n\t\ttry\n\t\t{\n\t\t\t$aArgs = array('login' => $sAuthUser);\n\t\t\t$sUserClass = \"User$sType\";\n\t\t\t$oSearch = DBObjectSearch::FromOQL(\"SELECT $sUserClass WHERE login = :login\");\n\t\t\tif ($bMustBeValid)\n\t\t\t{\n\t\t\t\t$oSearch->AddCondition('status', 'enabled');\n\t\t\t}\n\t\t\t$oSet = new DBObjectSet($oSearch, array(), $aArgs);\n\t\t\tif ($oSet->CountExceeds(0))\n\t\t\t{\n\t\t\t\t/** @var User $oUser */\n\t\t\t\t$oUser = $oSet->Fetch();\n\n\t\t\t\treturn $oUser;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n \t * Provisioning API: Find a Person by email\n\t *\n\t * @api\n\t *\n\t * @param string $sEmail\n\t *\n\t * @return \\Person|null\n\t */\n\tpublic static function FindPerson($sEmail)\n\t{\n\t\t/** @var \\Person $oPerson */\n\t\t$oPerson = null;\n\t\ttry\n\t\t{\n\t\t\t$oSearch = new DBObjectSearch('Person');\n\t\t\t$oSearch->AddCondition('email', $sEmail);\n\t\t\t$oSet = new DBObjectSet($oSearch);\n\t\t\tif ($oSet->CountExceeds(1))\n\t\t\t{\n\t\t\t\tthrow new Exception(Dict::S('UI:Login:Error:MultipleContactsHaveSameEmail'));\n\t\t\t}\n\t\t\t$oPerson = $oSet->Fetch();\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\t\treturn $oPerson;\n\t}\n\n\t/**\n\t * Provisioning API: Create a person\n\t *\n\t * @api\n\t *\n\t * @param string $sFirstName\n\t * @param string $sLastName\n\t * @param string $sEmail\n\t * @param string $sOrganization\n\t * @param array $aAdditionalParams\n\t *\n\t * @return \\Person\n\t */\n\tpublic static function ProvisionPerson($sFirstName, $sLastName, $sEmail, $sOrganization, $aAdditionalParams = array())\n\t{\n\t\t/** @var Person $oPerson */\n\t\t$oPerson = null;\n\t\ttry\n\t\t{\n\t\t\tCMDBObject::SetTrackOrigin('custom-extension');\n\t\t\t$sInfo = 'External User provisioning';\n\t\t\tif (isset($_SESSION['login_mode']))\n\t\t\t{\n\t\t\t\t$sInfo .= \" ({$_SESSION['login_mode']})\";\n\t\t\t}\n\t\t\tCMDBObject::SetTrackInfo($sInfo);\n\n\t\t\t$oPerson = MetaModel::NewObject('Person');\n\t\t\t$oPerson->Set('first_name', $sFirstName);\n\t\t\t$oPerson->Set('name', $sLastName);\n\t\t\t$oPerson->Set('email', $sEmail);\n\t\t\t$oOrg = MetaModel::GetObjectByName('Organization', $sOrganization, false);\n\t\t\tif (is_null($oOrg))\n\t\t\t{\n\t\t\t\tthrow new Exception(Dict::S('UI:Login:Error:WrongOrganizationName'));\n\t\t\t}\n\t\t\t$oPerson->Set('org_id', $oOrg->GetKey());\n\t\t\tforeach ($aAdditionalParams as $sAttCode => $sValue)\n\t\t\t{\n\t\t\t\t$oPerson->Set($sAttCode, $sValue);\n\t\t\t}\n\t\t\t$oPerson->DBInsert();\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\t\treturn $oPerson;\n\t}\n\n\t/**\n\t * Provisioning API: Create or update a User\n\t *\n\t * @api\n\t *\n\t * @param string $sAuthUser\n\t * @param Person $oPerson\n\t * @param array $aRequestedProfiles profiles to add to the new user\n\t *\n\t * @return \\UserExternal|null\n\t */\n\tpublic static function ProvisionUser($sAuthUser, $oPerson, $aRequestedProfiles)\n\t{\n\t\tif (!MetaModel::IsValidClass('URP_Profiles'))\n\t\t{\n\t\t\tIssueLog::Error(\"URP_Profiles is not a valid class. Automatic creation of Users is not supported in this context, sorry.\");\n\t\t\treturn null;\n\t\t}\n\n\t\t/** @var UserExternal $oUser */\n\t\t$oUser = null;\n\t\ttry\n\t\t{\n\t\t\tCMDBObject::SetTrackOrigin('custom-extension');\n\t\t\t$sInfo = 'External User provisioning';\n\t\t\tif (isset($_SESSION['login_mode']))\n\t\t\t{\n\t\t\t\t$sInfo .= \" ({$_SESSION['login_mode']})\";\n\t\t\t}\n\t\t\tCMDBObject::SetTrackInfo($sInfo);\n\n\t\t\t$oUser = MetaModel::GetObjectByName('UserExternal', $sAuthUser, false);\n\t\t\tif (is_null($oUser))\n\t\t\t{\n\t\t\t\t$oUser = MetaModel::NewObject('UserExternal');\n\t\t\t\t$oUser->Set('login', $sAuthUser);\n\t\t\t\t$oUser->Set('contactid', $oPerson->GetKey());\n\t\t\t\t$oUser->Set('language', MetaModel::GetConfig()->GetDefaultLanguage());\n\t\t\t}\n\n\t\t\t// read all the existing profiles\n\t\t\t$oProfilesSearch = new DBObjectSearch('URP_Profiles');\n\t\t\t$oProfilesSet = new DBObjectSet($oProfilesSearch);\n\t\t\t$aAllProfiles = array();\n\t\t\twhile ($oProfile = $oProfilesSet->Fetch())\n\t\t\t{\n\t\t\t\t$aAllProfiles[strtolower($oProfile->GetName())] = $oProfile->GetKey();\n\t\t\t}\n\n\t\t\t$aProfiles = array();\n\t\t\tforeach ($aRequestedProfiles as $sRequestedProfile)\n\t\t\t{\n\t\t\t\t$sRequestedProfile = strtolower($sRequestedProfile);\n\t\t\t\tif (isset($aAllProfiles[$sRequestedProfile]))\n\t\t\t\t{\n\t\t\t\t\t$aProfiles[] = $aAllProfiles[$sRequestedProfile];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (empty($aProfiles))\n\t\t\t{\n\t\t\t\tthrow new Exception(Dict::S('UI:Login:Error:NoValidProfiles'));\n\t\t\t}\n\n\t\t\t// Now synchronize the profiles\n\t\t\t$oProfilesSet = DBObjectSet::FromScratch('URP_UserProfile');\n\t\t\t$sOrigin = 'External User provisioning';\n\t\t\tif (isset($_SESSION['login_mode']))\n\t\t\t{\n\t\t\t\t$sOrigin .= \" ({$_SESSION['login_mode']})\";\n\t\t\t}\n\t\t\tforeach ($aProfiles as $iProfileId)\n\t\t\t{\n\t\t\t\t$oLink = new URP_UserProfile();\n\t\t\t\t$oLink->Set('profileid', $iProfileId);\n\t\t\t\t$oLink->Set('reason', $sOrigin);\n\t\t\t\t$oProfilesSet->AddObject($oLink);\n\t\t\t}\n\t\t\t$oUser->Set('profile_list', $oProfilesSet);\n\t\t\tif ($oUser->IsModified())\n\t\t\t{\n\t\t\t\t$oUser->DBWrite();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\n\t\treturn $oUser;\n\t}\n\n\t/**\n\t * Overridable: depending on the user, head toward a dedicated portal\n\t * @param string|null $sRequestedPortalId\n\t * @param int $iOnExit How to complete the call: redirect or return a code\n\t */\t \n\tprotected static function ChangeLocation($sRequestedPortalId = null, $iOnExit = self::EXIT_PROMPT)\n\t{\n\t\t$ret = call_user_func(array(self::$sHandlerClass, 'Dispatch'), $sRequestedPortalId);\n\t\tif ($ret === true)\n\t\t{\n\t\t\treturn self::EXIT_CODE_OK;\n\t\t}\n\t\telse if($ret === false)\n\t\t{\n\t\t\tthrow new Exception('Nowhere to go??');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($iOnExit == self::EXIT_RETURN)\n\t\t\t{\n\t\t\t\treturn self::EXIT_CODE_PORTALUSERNOTAUTHORIZED;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// No rights to be here, redirect to the portal\n\t\t\t\theader('Location: '.$ret);\n\t\t\t\tdie();\n\t\t\t}\n\t\t}\n\t\treturn self::EXIT_CODE_OK;\n\t}\n\n\t/**\n\t * Check if the user is already authentified, if yes, then performs some additional validations:\n\t * - if $bMustBeAdmin is true, then the user must be an administrator, otherwise an error is displayed\n\t * - if $bIsAllowedToPortalUsers is false and the user has only access to the portal, then the user is redirected\n\t * to the portal\n\t *\n\t * @param bool $bMustBeAdmin Whether or not the user must be an admin to access the current page\n\t * @param bool $bIsAllowedToPortalUsers Whether or not the current page is considered as part of the portal\n\t * @param int iOnExit What action to take if the user is not logged on (one of the class constants EXIT_...)\n\t *\n\t * @return int|mixed|string\n\t * @throws \\Exception\n\t */\n\tstatic function DoLogin($bMustBeAdmin = false, $bIsAllowedToPortalUsers = false, $iOnExit = self::EXIT_PROMPT)\n\t{\n\t\t$sRequestedPortalId = $bIsAllowedToPortalUsers ? 'legacy_portal' : 'backoffice';\n\t\treturn self::DoLoginEx($sRequestedPortalId, $bMustBeAdmin, $iOnExit);\n\t}\n\n\t/**\n\t * Check if the user is already authentified, if yes, then performs some additional validations to redirect towards\n\t * the desired \"portal\"\n\t *\n\t * @param string|null $sRequestedPortalId The requested \"portal\" interface, null for any\n\t * @param bool $bMustBeAdmin Whether or not the user must be an admin to access the current page\n\t * @param int iOnExit What action to take if the user is not logged on (one of the class constants EXIT_...)\n\t *\n\t * @return int|mixed|string\n\t * @throws \\Exception\n\t */\n\tstatic function DoLoginEx($sRequestedPortalId = null, $bMustBeAdmin = false, $iOnExit = self::EXIT_PROMPT)\n\t{\n\t\t$operation = utils::ReadParam('loginop', '');\n\t\n\t\t$sMessage = self::HandleOperations($operation); // May exit directly\n\t\n\t\t$iRet = self::Login($iOnExit);\n\t\n\t\tif ($iRet == self::EXIT_CODE_OK)\n\t\t{\n\t\t\tif ($bMustBeAdmin && !UserRights::IsAdministrator())\n\t\t\t{\n\t\t\t\tif ($iOnExit == self::EXIT_RETURN)\n\t\t\t\t{\n\t\t\t\t\treturn self::EXIT_CODE_MUSTBEADMIN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trequire_once(APPROOT.'/setup/setuppage.class.inc.php');\n\t\t\t\t\t$oP = new ErrorPage(Dict::S('UI:PageTitle:FatalError'));\n\t\t\t\t\t$oP->add(\"<h1>\".Dict::S('UI:Login:Error:AccessAdmin').\"</h1>\\n\");\n\t\t\t\t\t$oP->p(\"<a href=\\\"\".utils::GetAbsoluteUrlAppRoot().\"pages/logoff.php\\\">\".Dict::S('UI:LogOffMenu').\"</a>\");\n\t\t\t\t\t$oP->output();\n\t\t\t\t\texit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$iRet = call_user_func(array(self::$sHandlerClass, 'ChangeLocation'), $sRequestedPortalId, $iOnExit);\n\t\t}\n\t\tif ($iOnExit == self::EXIT_RETURN)\n\t\t{\n\t\t\treturn $iRet;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn $sMessage;\n\t\t}\n\t}\t\n\tprotected static function HandleOperations($operation)\n\t{\n\t\t$sMessage = ''; // most of the operations never return, but some can return a message to be displayed\n\t\tif ($operation == 'logoff')\n\t\t{\n\t\t\tself::ResetSession();\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->DisplayLoginForm(false /* not a failed attempt */);\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'forgot_pwd')\n\t\t{\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->DisplayForgotPwdForm();\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'forgot_pwd_go')\n\t\t{\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->ForgotPwdGo();\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'reset_pwd')\n\t\t{\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->DisplayResetPwdForm();\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'do_reset_pwd')\n\t\t{\n\n\t\t\ttry {\n\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t$oPage->DoResetPassword();\n\t\t\t}\n\t\t\tcatch (CoreCannotSaveObjectException $e)\n\t\t\t{\n\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t$oPage->DisplayResetPwdForm($e->getIssue());\n\t\t\t}\n\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'change_pwd')\n\t\t{\n\t\t\tif (isset($_SESSION['auth_user']))\n\t\t\t{\n\t\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t$oPage->DisplayChangePwdForm();\n\t\t\t\t$oPage->output();\n\t\t\t\texit;\n\t\t\t}\n\t\t}\n\t\telse if ($operation == 'check_pwd_policy')\n\t\t{\n\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\tUserRights::Login($sAuthUser); // Set the user's language\n\n\t\t\t$aPwdMap = array();\n\n\t\t\tforeach (array('new_pwd', 'retype_new_pwd') as $postedPwd)\n\t\t\t{\n\t\t\t\t$oUser = new UserLocal();\n\t\t\t\t$oUser->ValidatePassword($_POST[$postedPwd]);\n\n\t\t\t\t$aPwdMap[$postedPwd]['isValid'] = $oUser->IsPasswordValid();\n\t\t\t\t$aPwdMap[$postedPwd]['message'] = $oUser->getPasswordValidityMessage();\n\t\t\t}\n\t\t\techo json_encode($aPwdMap);\n\t\t\tdie();\n\t\t}\n\t\tif ($operation == 'do_change_pwd')\n\t\t{\n\t\t\tif (isset($_SESSION['auth_user']))\n\t\t\t{\n\t\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t\t\t$sOldPwd = utils::ReadPostedParam('old_pwd', '', 'raw_data');\n\t\t\t\t$sNewPwd = utils::ReadPostedParam('new_pwd', '', 'raw_data');\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (UserRights::CanChangePassword() && ((!UserRights::CheckCredentials($sAuthUser, $sOldPwd)) || (!UserRights::ChangePassword($sOldPwd, $sNewPwd))))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t\t\t$oPage->DisplayChangePwdForm(true); // old pwd was wrong\n\t\t\t\t\t\t$oPage->output();\n\t\t\t\t\t\texit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (CoreCannotSaveObjectException $e)\n\t\t\t\t{\n\t\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t\t$oPage->DisplayChangePwdForm(true, $e->getIssue()); // password policy was not met.\n\t\t\t\t\t$oPage->output();\n\t\t\t\t\texit;\n\t\t\t\t}\n\t\t\t\t$sMessage = Dict::S('UI:Login:PasswordChanged');\n\t\t\t}\n\t\t}\n\t\treturn $sMessage;\n\t}\n\t\n\tprotected static function Dispatch($sRequestedPortalId)\n\t{\n\t\tif ($sRequestedPortalId === null) return true; // allowed to any portal => return true\n\t\t\n\t\t$aPortalsConf = PortalDispatcherData::GetData();\n\t\t$aDispatchers = array();\n\t\tforeach($aPortalsConf as $sPortalId => $aConf)\n\t\t{\n\t\t\t$sHandlerClass = $aConf['handler'];\n\t\t\t$aDispatchers[$sPortalId] = new $sHandlerClass($sPortalId);\n\t\t}\n\t\t\n\t\tif (array_key_exists($sRequestedPortalId, $aDispatchers) && $aDispatchers[$sRequestedPortalId]->IsUserAllowed())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tforeach($aDispatchers as $sPortalId => $oDispatcher)\n\t\t{\n\t\t\tif ($oDispatcher->IsUserAllowed()) return $oDispatcher->GetUrl();\n\t\t}\n\t\treturn false; // nothing matched !!\n\t}\n\n\t/**\n\t * @return mixed\n\t */\n\tpublic static function getIOnExit()\n\t{\n\t\treturn self::$iOnExit;\n\t}\n\n} // End of class\n"], "fixing_code": ["<?php\n// Copyright (C) 2010-2017 Combodo SARL\n//\n//   This file is part of iTop.\n//\n//   iTop is free software; you can redistribute it and/or modify\t\n//   it under the terms of the GNU Affero General Public License as published by\n//   the Free Software Foundation, either version 3 of the License, or\n//   (at your option) any later version.\n//\n//   iTop is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU Affero General Public License for more details.\n//\n//   You should have received a copy of the GNU Affero General Public License\n//   along with iTop. If not, see <http://www.gnu.org/licenses/>\n\n\n/**\n * Class LoginWebPage\n *\n * @copyright   Copyright (C) 2010-2017 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\n/**\n * Web page used for displaying the login form\n */\n\nclass LoginWebPage extends NiceWebPage\n{\n\tconst EXIT_PROMPT = 0;\n\tconst EXIT_HTTP_401 = 1;\n\tconst EXIT_RETURN = 2;\n\t\n\tconst EXIT_CODE_OK = 0;\n\tconst EXIT_CODE_MISSINGLOGIN = 1;\n\tconst EXIT_CODE_MISSINGPASSWORD = 2;\n\tconst EXIT_CODE_WRONGCREDENTIALS = 3;\n\tconst EXIT_CODE_MUSTBEADMIN = 4;\n\tconst EXIT_CODE_PORTALUSERNOTAUTHORIZED = 5;\n\tconst EXIT_CODE_NOTAUTHORIZED = 6;\n\n\t// Login FSM States\n\tconst LOGIN_STATE_START = 'start';                          // Entry state\n\tconst LOGIN_STATE_MODE_DETECTION = 'login mode detection';  // Detect which login plugin to use\n\tconst LOGIN_STATE_READ_CREDENTIALS = 'read credentials';    // Read the credentials\n\tconst LOGIN_STATE_CHECK_CREDENTIALS = 'check credentials';  // Check if the credentials are valid\n\tconst LOGIN_STATE_CREDENTIALS_OK = 'credentials ok';        // User provisioning\n\tconst LOGIN_STATE_USER_OK = 'user ok';                      // Additional check (2FA)\n\tconst LOGIN_STATE_CONNECTED = 'connected';                  // User connected\n\tconst LOGIN_STATE_SET_ERROR = 'prepare for error';\t        // Internal state to trigger ERROR state\n\tconst LOGIN_STATE_ERROR = 'error';                          // An error occurred, next state will be NONE\n\n\t// Login FSM Returns\n\tconst LOGIN_FSM_RETURN = 0;           // End the FSM OK (connected)\n\tconst LOGIN_FSM_ERROR = 1;        // Error signaled\n\tconst LOGIN_FSM_CONTINUE = 2;     // Continue FSM\n\n\tprotected static $sHandlerClass = __class__;\n\tprivate static $iOnExit;\n\n\tpublic static function RegisterHandler($sClass)\n\t{\n\t\tself::$sHandlerClass = $sClass;\n\t}\n\n\t/**\n\t * @return \\LoginWebPage\n\t */\n\tpublic static function NewLoginWebPage()\n\t{\n\t\treturn new self::$sHandlerClass;\n\t}\n\n\tprotected static $m_sLoginFailedMessage = '';\n\t\n\tpublic function __construct($sTitle = null)\n\t{\n\t\tif ($sTitle === null) {\n\t\t\t$sTitle = Dict::S('UI:Login:Title');\n\t\t}\n\n\t\tparent::__construct($sTitle);\n\t\t$this->SetStyleSheet();\n\t\t$this->no_cache();\n\t\t$this->add_xframe_options();\n\t}\n\t\n\tpublic function SetStyleSheet()\n\t{\n\t\t$this->add_linked_stylesheet(utils::GetAbsoluteUrlAppRoot().'css/login.css');\n\t\t$this->add_linked_stylesheet(utils::GetAbsoluteUrlAppRoot().'css/font-awesome/css/all.min.css');\n\t\t$this->add_linked_stylesheet(utils::GetAbsoluteUrlAppRoot().'css/font-awesome/css/v4-shims.min.css');\n\t}\n\n\tpublic static function SetLoginFailedMessage($sMessage)\n\t{\n\t\tself::$m_sLoginFailedMessage = $sMessage;\n\t}\n\n\tpublic function DisplayLoginHeader($bMainAppLogo = false)\n\t{\n\t\t$sLogo = 'itop-logo-external.png';\n\t\t$sBrandingLogo = 'login-logo.png';\n\n\t\t$sVersionShort = Dict::Format('UI:iTopVersion:Short', ITOP_APPLICATION, ITOP_VERSION);\n\t\t$sIconUrl = Utils::GetConfig()->Get('app_icon_url');\n\t\t$sDisplayIcon = utils::GetAbsoluteUrlAppRoot().'images/'.$sLogo.'?t='.utils::GetCacheBusterTimestamp();\n\t\tif (file_exists(MODULESROOT.'branding/'.$sBrandingLogo))\n\t\t{\n\t\t\t$sDisplayIcon = utils::GetAbsoluteUrlModulesRoot().'branding/'.$sBrandingLogo.'?t='.utils::GetCacheBusterTimestamp();\n\t\t}\n\t\t$this->add(\"<div id=\\\"login-logo\\\"><a href=\\\"\".htmlentities($sIconUrl, ENT_QUOTES,\n\t\t\t\tself::PAGES_CHARSET).\"\\\"><img title=\\\"$sVersionShort\\\" src=\\\"$sDisplayIcon\\\"></a></div>\\n\");\n\t}\n\n\tpublic function DisplayLoginForm($bFailedLogin = false)\n\t{\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aPostedVars = array_merge(array('login_mode', 'loginop'), $oTwigContext->GetPostedVars());\n\n\t\t$sMessage = Dict::S('UI:Login:IdentifyYourself');\n\n\t\t// Error message\n\t\tif ($bFailedLogin)\n\t\t{\n\t\t\tif (self::$m_sLoginFailedMessage != '')\n\t\t\t{\n\t\t\t\t$sMessage = self::$m_sLoginFailedMessage;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$sMessage = Dict::S('UI:Login:IncorrectLoginPassword');\n\t\t\t}\n\t\t}\n\n\t\t// Keep the OTHER parameters posted\n\t\t$aPreviousPostedVars = array();\n\t\tforeach($_POST as $sPostedKey => $postedValue)\n\t\t{\n\t\t\tif (!in_array($sPostedKey, $aPostedVars))\n\t\t\t{\n\t\t\t\tif (is_array($postedValue))\n\t\t\t\t{\n\t\t\t\t\tforeach($postedValue as $sKey => $sValue)\n\t\t\t\t\t{\n\t\t\t\t\t\t$sName = \"{$sPostedKey}[{$sKey}]\";\n\t\t\t\t\t\t$aPreviousPostedVars[$sName] = $sValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$aPreviousPostedVars[$sPostedKey] = $postedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$aVars = array(\n\t\t\t'bFailedLogin' => $bFailedLogin,\n\t\t\t'sMessage' => $sMessage,\n\t\t\t'aPreviousPostedVars' => $aPreviousPostedVars,\n\t\t);\n\t\t$aVars = array_merge($aVars, $oTwigContext->GetDefaultVars());\n\n\t\t$oTwigContext->Render($this, 'login.html.twig', $aVars);\n\t}\n\n\tpublic function DisplayForgotPwdForm($bFailedToReset = false, $sFailureReason = null)\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', true, 'raw_data');\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t$aVars['sAuthUser'] = $sAuthUser;\n\t\t$aVars['bFailedToReset'] = $bFailedToReset;\n\t\t$aVars['sFailureReason'] = $sFailureReason;\n\n\t\t$oTwigContext->Render($this, 'forgotpwdform.html.twig', $aVars);\n\t}\n\n\tprotected function ForgotPwdGo()\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', true, 'raw_data');\n\n\t\ttry\n\t\t{\n\t\t\tUserRights::Login($sAuthUser); // Set the user's language (if possible!)\n            /** @var UserInternal $oUser */\n            $oUser = UserRights::GetUserObject();\n\n\t\t\tif ($oUser != null)\n\t\t\t{\n\t\t\t\tif (!MetaModel::IsValidAttCode(get_class($oUser), 'reset_pwd_token'))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-NotPossible'));\n\t\t\t\t}\n\t\t\t\tif (!$oUser->CanChangePassword())\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-FixedPwd'));\n\t\t\t\t}\n\n\t\t\t\t$sTo = $oUser->GetResetPasswordEmail(); // throws Exceptions if not allowed\n\t\t\t\tif ($sTo == '')\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-NoEmail'));\n\t\t\t\t}\n\n\t\t\t\t// This token allows the user to change the password without knowing the previous one\n\t\t\t\t$sToken = bin2hex(random_bytes(32));\n\t\t\t\t$oUser->Set('reset_pwd_token', $sToken);\n\t\t\t\tCMDBObject::SetTrackInfo('Reset password');\n\t\t\t\t$oUser->AllowWrite(true);\n\t\t\t\t$oUser->DBUpdate();\n\n\t\t\t\t$oEmail = new Email();\n\t\t\t\t$oEmail->SetRecipientTO($sTo);\n\t\t\t\t$sFrom = MetaModel::GetConfig()->Get('forgot_password_from');\n\t\t\t\t$oEmail->SetRecipientFrom($sFrom);\n\t\t\t\t$oEmail->SetSubject(Dict::S('UI:ResetPwd-EmailSubject', $oUser->Get('login')));\n\t\t\t\t$sResetUrl = utils::GetAbsoluteUrlAppRoot().'pages/UI.php?loginop=reset_pwd&auth_user='.urlencode($oUser->Get('login')).'&token='.urlencode($sToken);\n\t\t\t\t$oEmail->SetBody(Dict::Format('UI:ResetPwd-EmailBody', $sResetUrl, $oUser->Get('login')));\n\t\t\t\t$iRes = $oEmail->Send($aIssues, true /* force synchronous exec */);\n\t\t\t\tswitch ($iRes)\n\t\t\t\t{\n\t\t\t\t\t//case EMAIL_SEND_PENDING:\n\t\t\t\t\tcase EMAIL_SEND_OK:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EMAIL_SEND_ERROR:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tIssueLog::Error('Failed to send the email with the NEW password for '.$oUser->Get('friendlyname').': '.implode(', ', $aIssues));\n\t\t\t\t\t\tthrow new Exception(Dict::S('UI:ResetPwd-Error-Send'));\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t\t$oTwigContext->Render($this, 'forgotpwdsent.html.twig', $aVars);\n\t\t}\n\t\tcatch(Exception $e)\n\t\t{\n\t\t\t$this->DisplayForgotPwdForm(true, $e->getMessage());\n\t\t}\n\t}\n\n\tpublic function DisplayResetPwdForm($sErrorMessage = null)\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t$sToken = utils::ReadParam('token', '', false, 'raw_data');\n\n\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t$oUser = UserRights::GetUserObject();\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\n\t\t$aVars['sAuthUser'] = $sAuthUser;\n\t\t$aVars['sToken'] = $sToken;\n\t\t$aVars['sErrorMessage'] = $sErrorMessage;\n\n\t\tif (($oUser == null))\n\t\t{\n\t\t\t$aVars['bNoUser'] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$aVars['bNoUser'] = false;\n\t\t\t$aVars['sUserName'] = $oUser->GetFriendlyName();\n\t\t\t$oEncryptedToken = $oUser->Get('reset_pwd_token');\n\n\t\t\tif (!$oEncryptedToken->CheckPassword($sToken))\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = false;\n\t\t\t}\n\t\t}\n\n\t\t$oTwigContext->Render($this, 'resetpwdform.html.twig', $aVars);\n\t}\n\n\tpublic function DoResetPassword()\n\t{\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t$sToken = utils::ReadParam('token', '', false, 'raw_data');\n\t\t$sNewPwd = utils::ReadPostedParam('new_pwd', '', 'raw_data');\n\n\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t/** @var \\UserLocal $oUser */\n\t\t$oUser = UserRights::GetUserObject();\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\n\t\t$aVars['sAuthUser'] = $sAuthUser;\n\t\t$aVars['sToken'] = $sToken;\n\t\tif (($oUser == null))\n\t\t{\n\t\t\t$aVars['bNoUser'] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$aVars['bNoUser'] = false;\n\t\t\t$oEncryptedToken = $oUser->Get('reset_pwd_token');\n\n\t\t\tif (!$oEncryptedToken->CheckPassword($sToken))\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$aVars['bBadToken'] = false;\n\t\t\t\t// Trash the token and change the password\n\t\t\t\t$oUser->Set('reset_pwd_token', new ormPassword());\n\t\t\t\t$oUser->AllowWrite(true);\n\t\t\t\t$oUser->SetPassword($sNewPwd); // Does record the change into the DB\n\t\t\t\t$aVars['sUrl'] = utils::GetAbsoluteUrlAppRoot();\n\t\t\t}\n\t\t}\n\n\t\t$oTwigContext->Render($this, 'resetpwddone.html.twig', $aVars);\n\t}\n\n\tpublic function DisplayChangePwdForm($bFailedLogin = false, $sIssue = null)\n\t{\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t$aVars['bFailedLogin'] = $bFailedLogin;\n\t\t$aVars['sIssue'] = $sIssue;\n\t\t$oTwigContext->Render($this, 'changepwdform.html.twig', $aVars);\n\t}\n\n\tpublic function DisplayLogoutPage($bPortal, $sTitle = null)\n\t{\n\t\t$sUrl = utils::GetAbsoluteUrlAppRoot();\n\t\t$sUrl .= $bPortal ? 'portal/' : 'pages/UI.php';\n\t\t$sTitle = empty($sTitle) ? Dict::S('UI:LogOff:ThankYou') : $sTitle;\n\t\t$sMessage = Dict::S('UI:LogOff:ClickHereToLoginAgain');\n\n\t\t$oTwigContext = new LoginTwigRenderer();\n\t\t$aVars = $oTwigContext->GetDefaultVars();\n\t\t$aVars['sUrl'] = $sUrl;\n\t\t$aVars['sTitle'] = $sTitle;\n\t\t$aVars['sMessage'] = $sMessage;\n\n\t\t$oTwigContext->Render($this, 'logout.html.twig', $aVars);\n\t\t$this->output();\n\t}\n\n\tpublic static function ResetSession()\n\t{\n\t\t// Unset all of the session variables.\n\t\tunset($_SESSION['auth_user']);\n\t\tunset($_SESSION['login_state']);\n\t\tunset($_SESSION['can_logoff']);\n\t\tunset($_SESSION['archive_mode']);\n\t\tunset($_SESSION['impersonate_user']);\n\t\tUserRights::_ResetSessionCache();\n\t\t// If it's desired to kill the session, also delete the session cookie.\n\t\t// Note: This will destroy the session, and not just the session data!\n\t}\n\n\tstatic function SecureConnectionRequired()\n\t{\n\t\treturn MetaModel::GetConfig()->GetSecureConnectionRequired();\n\t}\n\n\t/**\n\t * Guess if a string looks like an UTF-8 string based on some ranges of multi-bytes encoding\n\t * @param string $sString\n\t * @return bool True if the string contains some typical UTF-8 multi-byte sequences\n\t */\n\tstatic function LooksLikeUTF8($sString)\n\t{\n\t\treturn preg_match('%(?:\n        \t\t\t[\\xC2-\\xDF][\\x80-\\xBF]             # non-overlong 2-byte\n        \t\t\t|\\xE0[\\xA0-\\xBF][\\x80-\\xBF]        # excluding overlongs\n        \t\t\t|[\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2} # straight 3-byte\n        \t\t\t|\\xED[\\x80-\\x9F][\\x80-\\xBF]        # excluding surrogates\n        \t\t\t|\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}     # planes 1-3\n        \t\t\t|[\\xF1-\\xF3][\\x80-\\xBF]{3}         # planes 4-15\n        \t\t\t|\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}     # plane 16\n        \t)+%xs', $sString);\n\t}\n\t/**\n\t * Attempt a login\n\t *\n\t * @param int iOnExit What action to take if the user is not logged on (one of the class constants EXIT_...)\n\t *\n\t * @return int|void One of the class constants EXIT_CODE_...\n\t * @throws \\Exception\n\t */\n\tprotected static function Login($iOnExit)\n\t{\n\t\tself::$iOnExit = $iOnExit;\n\t\tif (self::SecureConnectionRequired() && !utils::IsConnectionSecure())\n\t\t{\n\t\t\t// Non secured URL... request for a secure connection\n\t\t\tthrow new Exception('Secure connection required!');\n\t\t}\n\t\t$bLoginDebug = MetaModel::GetConfig()->Get('login_debug');\n\n\t\tif (!isset($_SESSION['login_state']) || ($_SESSION['login_state'] == self::LOGIN_STATE_ERROR))\n\t\t{\n\t\t\t$_SESSION['login_state'] = self::LOGIN_STATE_START;\n\t\t}\n\t\t$sLoginState = $_SESSION['login_state'];\n\n\t\t$sSessionLog = '';\n\t\tif ($bLoginDebug)\n\t\t{\n\t\t\tIssueLog::Info(\"---------------------------------\");\n\t\t\tIssueLog::Info($_SERVER['REQUEST_URI']);\n\t\t\tIssueLog::Info(\"--> Entering Login FSM with state: [$sLoginState]\");\n\t\t\t$sSessionLog = session_id().' '.utils::GetSessionLog();\n\t\t\tIssueLog::Info(\"SESSION: $sSessionLog\");\n\t\t}\n\n\t\t$iErrorCode = self::EXIT_CODE_OK;\n\n\t\t// Finite state machine loop\n\t\twhile (true)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t$aLoginPlugins = self::GetLoginPluginList();\n\t\t\t\tif (empty($aLoginPlugins))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Missing login classes\");\n\t\t\t\t}\n\n\t\t\t\t/** @var iLoginFSMExtension $oLoginFSMExtensionInstance */\n\t\t\t\tforeach ($aLoginPlugins as $oLoginFSMExtensionInstance)\n\t\t\t\t{\n\t\t\t\t\tif ($bLoginDebug)\n\t\t\t\t\t{\n\t\t\t\t\t\t$sCurrSessionLog = session_id().' '.utils::GetSessionLog();\n\t\t\t\t\t\tif ($sCurrSessionLog != $sSessionLog)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$sSessionLog = $sCurrSessionLog;\n\t\t\t\t\t\t\tIssueLog::Info(\"SESSION: $sSessionLog\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tIssueLog::Info(\"Login: state: [$sLoginState] call: \".get_class($oLoginFSMExtensionInstance));\n\t\t\t\t\t}\n\t\t\t\t\t$iResponse = $oLoginFSMExtensionInstance->LoginAction($sLoginState, $iErrorCode);\n\t\t\t\t\tif ($iResponse == self::LOGIN_FSM_RETURN)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn $iErrorCode; // Asked to exit FSM, generally login OK\n\t\t\t\t\t}\n\t\t\t\t\tif ($iResponse == self::LOGIN_FSM_ERROR)\n\t\t\t\t\t{\n\t\t\t\t\t\t$sLoginState = self::LOGIN_STATE_SET_ERROR; // Next state will be error\n\t\t\t\t\t\t// An error was detected, skip the other plugins turn\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// The plugin has nothing to do for this state, continue to the next plugin\n\t\t\t\t}\n\n\t\t\t\t// Every plugin has nothing else to do in this state, go forward\n\t\t\t\t$sLoginState = self::AdvanceLoginFSMState($sLoginState);\n\t\t\t\t$_SESSION['login_state'] = $sLoginState;\n\t\t\t}\n\t\t\tcatch (Exception $e)\n\t\t\t{\n\t\t\t\tIssueLog::Error($e->getTraceAsString());\n\t\t\t\tstatic::ResetSession();\n\t\t\t\tdie($e->getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get plugins list ordered by config 'allowed_login_types'\n\t * Use the login mode to filter plugins\n\t *\n\t * @param string $sInterface 'iLoginFSMExtension' or 'iLogoutExtension'\n\t * @param bool $bFilterWithMode if false do not filter the plugin list with login mode\n\t *\n\t * @return array of plugins\n\t */\n\tpublic static function GetLoginPluginList($sInterface = 'iLoginFSMExtension', $bFilterWithMode = true)\n\t{\n\t\t$aAllPlugins = array();\n\n\t\tif ($bFilterWithMode)\n\t\t{\n\t\t\t$sCurrentLoginMode = isset($_SESSION['login_mode']) ? $_SESSION['login_mode'] : '';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$sCurrentLoginMode = '';\n\t\t}\n\n\t\t/** @var iLoginExtension $oLoginExtensionInstance */\n\t\tforeach (MetaModel::EnumPlugins($sInterface) as $oLoginExtensionInstance)\n\t\t{\n\t\t\t$aLoginModes = $oLoginExtensionInstance->ListSupportedLoginModes();\n\t\t\t$aLoginModes = (is_array($aLoginModes) ? $aLoginModes : array());\n\t\t\tforeach ($aLoginModes as $sLoginMode)\n\t\t\t{\n\t\t\t\t// Keep only the plugins for the current login mode + before + after\n\t\t\t\tif (empty($sCurrentLoginMode) || ($sLoginMode == $sCurrentLoginMode) || ($sLoginMode == 'before') || ($sLoginMode == 'after'))\n\t\t\t\t{\n\t\t\t\t\tif (!isset($aAllPlugins[$sLoginMode]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aAllPlugins[$sLoginMode] = array();\n\t\t\t\t\t}\n\t\t\t\t\t$aAllPlugins[$sLoginMode][] = $oLoginExtensionInstance;\n\t\t\t\t\tbreak; // Stop here to avoid registering a plugin twice\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Order and filter by the config list of allowed types (allowed_login_types)\n\t\t$aAllowedLoginModes = array_merge(array('before'), MetaModel::GetConfig()->GetAllowedLoginTypes(), array('after'));\n\t\t$aPlugins = array();\n\t\tforeach ($aAllowedLoginModes as $sAllowedMode)\n\t\t{\n\t\t\tif (isset($aAllPlugins[$sAllowedMode]))\n\t\t\t{\n\t\t\t\t$aPlugins = array_merge($aPlugins, $aAllPlugins[$sAllowedMode]);\n\t\t\t}\n\t\t}\n\t\treturn $aPlugins;\n\t}\n\n\t/**\n\t * Advance Login Finite State Machine to the next step\n\t *\n\t * @param string $sLoginState Current step\n\t *\n\t * @return string next step\n\t */\n\tprivate static function AdvanceLoginFSMState($sLoginState)\n\t{\n\t\tswitch ($sLoginState)\n\t\t{\n\t\t\tcase self::LOGIN_STATE_START:\n\t\t\t\treturn self::LOGIN_STATE_MODE_DETECTION;\n\n\t\t\tcase self::LOGIN_STATE_MODE_DETECTION:\n\t\t\t\treturn self::LOGIN_STATE_READ_CREDENTIALS;\n\n\t\t\tcase self::LOGIN_STATE_READ_CREDENTIALS:\n\t\t\t\treturn self::LOGIN_STATE_CHECK_CREDENTIALS;\n\n\t\t\tcase self::LOGIN_STATE_CHECK_CREDENTIALS:\n\t\t\t\treturn self::LOGIN_STATE_CREDENTIALS_OK;\n\n\t\t\tcase self::LOGIN_STATE_CREDENTIALS_OK:\n\t\t\t\treturn self::LOGIN_STATE_USER_OK;\n\n\t\t\tcase self::LOGIN_STATE_USER_OK:\n\t\t\t\treturn self::LOGIN_STATE_CONNECTED;\n\n\t\t\tcase self::LOGIN_STATE_CONNECTED:\n\t\t\tcase self::LOGIN_STATE_ERROR:\n\t\t\t\treturn self::LOGIN_STATE_START;\n\n\t\t\tcase self::LOGIN_STATE_SET_ERROR:\n\t\t\t\treturn self::LOGIN_STATE_ERROR;\n\t\t}\n\n\t\t// Default reset to NONE\n\t\treturn self::LOGIN_STATE_START;\n\t}\n\n\t/**\n\t * Login API: Check that credentials correspond to a valid user\n\t * Used only during login process when the password is known\n\t *\n\t * @api\n\t *\n\t * @param string $sAuthUser\n\t * @param string $sAuthPassword\n\t * @param string $sAuthentication ('internal' or 'external')\n\t *\n\t * @return bool (true if User OK)\n\t *\n\t */\n\tpublic static function CheckUser($sAuthUser, $sAuthPassword = '', $sAuthentication = 'external')\n\t{\n\t\t$oUser = self::FindUser($sAuthUser, true, ucfirst(strtolower($sAuthentication)));\n\t\tif (is_null($oUser))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $oUser->CheckCredentials($sAuthPassword);\n\t}\n\n\t/**\n\t * Login API: Store User info in the session when connection is OK\n\t *\n\t * @api\n\t *\n\t * @param $sAuthUser\n\t * @param $sAuthentication\n\t * @param $sLoginMode\n\t *\n\t * @throws ArchivedObjectException\n\t * @throws CoreCannotSaveObjectException\n\t * @throws CoreException\n\t * @throws CoreUnexpectedValue\n\t * @throws CoreWarning\n\t * @throws MySQLException\n\t * @throws OQLException\n\t * @throws \\Exception\n\t */\n\tpublic static function OnLoginSuccess($sAuthUser, $sAuthentication, $sLoginMode)\n\t{\n\t\t// User is Ok, let's save it in the session and proceed with normal login\n\t\t$bLoginSuccess = UserRights::Login($sAuthUser, $sAuthentication); // Login & set the user's language\n\t\tif (!$bLoginSuccess)\n\t\t{\n\t\t\tthrow new Exception(\"Bad user\");\n\t\t}\n\t\tif (MetaModel::GetConfig()->Get('log_usage')) {\n\t\t\t$oLog = new EventLoginUsage();\n\t\t\t$oLog->Set('userinfo', UserRights::GetUser());\n\t\t\t$oLog->Set('user_id', UserRights::GetUserObject()->GetKey());\n\t\t\t$oLog->Set('message', 'Successful login');\n\t\t\t$oLog->DBInsertNoReload();\n\t\t}\n\n\t\t$_SESSION['auth_user'] = $sAuthUser;\n\t\t$_SESSION['login_mode'] = $sLoginMode;\n\t\tUserRights::_InitSessionCache();\n\t}\n\n\t/**\n\t * Login API: Check that an already logger User is still valid\n\t *\n\t * @api\n\t *\n\t * @param int $iErrorCode\n\t *\n\t * @return int LOGIN_FSM_RETURN_OK or LOGIN_FSM_RETURN_ERROR\n\t */\n\tpublic static function CheckLoggedUser(&$iErrorCode)\n\t{\n\t\tif (isset($_SESSION['auth_user']))\n\t\t{\n\t\t\t// Already authenticated\n\t\t\t$bRet = UserRights::Login($_SESSION['auth_user']); // Login & set the user's language\n\t\t\tif ($bRet)\n\t\t\t{\n\t\t\t\t$iErrorCode = self::EXIT_CODE_OK;\n\t\t\t\treturn self::LOGIN_FSM_RETURN;\n\t\t\t}\n\t\t}\n\t\t// The user account is no longer valid/enabled\n\t\t$iErrorCode = self::EXIT_CODE_WRONGCREDENTIALS;\n\n\t\treturn self::LOGIN_FSM_ERROR;\n\t}\n\n\t/**\n\t * Exit with an HTTP 401 error\n\t */\n\tpublic static function HTTP401Error()\n\t{\n\t\theader('WWW-Authenticate: Basic realm=\"'.Dict::Format('UI:iTopVersion:Short', ITOP_APPLICATION, ITOP_VERSION));\n\t\theader('HTTP/1.0 401 Unauthorized');\n\t\theader('Content-type: text/html; charset='.self::PAGES_CHARSET);\n\t\t// Note: displayed when the user will click on Cancel\n\t\techo '<p><strong>'.Dict::S('UI:Login:Error:AccessRestricted').'</strong></p>';\n\t\texit;\n\t}\n\n\tpublic static function SetLoginModeAndReload($sNewLoginMode)\n\t{\n\t\tif (isset($_SESSION['login_mode']) && ($_SESSION['login_mode'] == $sNewLoginMode))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t$_SESSION['login_mode'] = $sNewLoginMode;\n\t\tself::HTTPReload();\n\t}\n\n\tpublic static function HTTPReload()\n\t{\n\t\t$sOriginURL = utils::GetCurrentAbsoluteUrl();\n\t\tif (!utils::StartsWith($sOriginURL, utils::GetAbsoluteUrlAppRoot()))\n\t\t{\n\t\t\t// If the found URL does not start with the configured AppRoot URL\n\t\t\t$sOriginURL = utils::GetAbsoluteUrlAppRoot().'pages/UI.php';\n\t\t}\n\t\tself::HTTPRedirect($sOriginURL);\n\t}\n\n\tpublic static function HTTPRedirect($sURL)\n\t{\n\t\theader('HTTP/1.1 307 Temporary Redirect');\n\t\theader('Location: '.$sURL);\n\t\texit;\n\t}\n\n\n\t/**\n\t * Provisioning API: Find a User\n\t *\n\t * @api\n\t *\n\t * @param string $sAuthUser\n\t * @param bool $bMustBeValid\n\t * @param string $sType\n\t *\n\t * @return \\User|null\n\t */\n\tpublic static function FindUser($sAuthUser, $bMustBeValid = true, $sType = 'External')\n\t{\n\t\ttry\n\t\t{\n\t\t\t$aArgs = array('login' => $sAuthUser);\n\t\t\t$sUserClass = \"User$sType\";\n\t\t\t$oSearch = DBObjectSearch::FromOQL(\"SELECT $sUserClass WHERE login = :login\");\n\t\t\tif ($bMustBeValid)\n\t\t\t{\n\t\t\t\t$oSearch->AddCondition('status', 'enabled');\n\t\t\t}\n\t\t\t$oSet = new DBObjectSet($oSearch, array(), $aArgs);\n\t\t\tif ($oSet->CountExceeds(0))\n\t\t\t{\n\t\t\t\t/** @var User $oUser */\n\t\t\t\t$oUser = $oSet->Fetch();\n\n\t\t\t\treturn $oUser;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n \t * Provisioning API: Find a Person by email\n\t *\n\t * @api\n\t *\n\t * @param string $sEmail\n\t *\n\t * @return \\Person|null\n\t */\n\tpublic static function FindPerson($sEmail)\n\t{\n\t\t/** @var \\Person $oPerson */\n\t\t$oPerson = null;\n\t\ttry\n\t\t{\n\t\t\t$oSearch = new DBObjectSearch('Person');\n\t\t\t$oSearch->AddCondition('email', $sEmail);\n\t\t\t$oSet = new DBObjectSet($oSearch);\n\t\t\tif ($oSet->CountExceeds(1))\n\t\t\t{\n\t\t\t\tthrow new Exception(Dict::S('UI:Login:Error:MultipleContactsHaveSameEmail'));\n\t\t\t}\n\t\t\t$oPerson = $oSet->Fetch();\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\t\treturn $oPerson;\n\t}\n\n\t/**\n\t * Provisioning API: Create a person\n\t *\n\t * @api\n\t *\n\t * @param string $sFirstName\n\t * @param string $sLastName\n\t * @param string $sEmail\n\t * @param string $sOrganization\n\t * @param array $aAdditionalParams\n\t *\n\t * @return \\Person\n\t */\n\tpublic static function ProvisionPerson($sFirstName, $sLastName, $sEmail, $sOrganization, $aAdditionalParams = array())\n\t{\n\t\t/** @var Person $oPerson */\n\t\t$oPerson = null;\n\t\ttry\n\t\t{\n\t\t\tCMDBObject::SetTrackOrigin('custom-extension');\n\t\t\t$sInfo = 'External User provisioning';\n\t\t\tif (isset($_SESSION['login_mode']))\n\t\t\t{\n\t\t\t\t$sInfo .= \" ({$_SESSION['login_mode']})\";\n\t\t\t}\n\t\t\tCMDBObject::SetTrackInfo($sInfo);\n\n\t\t\t$oPerson = MetaModel::NewObject('Person');\n\t\t\t$oPerson->Set('first_name', $sFirstName);\n\t\t\t$oPerson->Set('name', $sLastName);\n\t\t\t$oPerson->Set('email', $sEmail);\n\t\t\t$oOrg = MetaModel::GetObjectByName('Organization', $sOrganization, false);\n\t\t\tif (is_null($oOrg))\n\t\t\t{\n\t\t\t\tthrow new Exception(Dict::S('UI:Login:Error:WrongOrganizationName'));\n\t\t\t}\n\t\t\t$oPerson->Set('org_id', $oOrg->GetKey());\n\t\t\tforeach ($aAdditionalParams as $sAttCode => $sValue)\n\t\t\t{\n\t\t\t\t$oPerson->Set($sAttCode, $sValue);\n\t\t\t}\n\t\t\t$oPerson->DBInsert();\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\t\treturn $oPerson;\n\t}\n\n\t/**\n\t * Provisioning API: Create or update a User\n\t *\n\t * @api\n\t *\n\t * @param string $sAuthUser\n\t * @param Person $oPerson\n\t * @param array $aRequestedProfiles profiles to add to the new user\n\t *\n\t * @return \\UserExternal|null\n\t */\n\tpublic static function ProvisionUser($sAuthUser, $oPerson, $aRequestedProfiles)\n\t{\n\t\tif (!MetaModel::IsValidClass('URP_Profiles'))\n\t\t{\n\t\t\tIssueLog::Error(\"URP_Profiles is not a valid class. Automatic creation of Users is not supported in this context, sorry.\");\n\t\t\treturn null;\n\t\t}\n\n\t\t/** @var UserExternal $oUser */\n\t\t$oUser = null;\n\t\ttry\n\t\t{\n\t\t\tCMDBObject::SetTrackOrigin('custom-extension');\n\t\t\t$sInfo = 'External User provisioning';\n\t\t\tif (isset($_SESSION['login_mode']))\n\t\t\t{\n\t\t\t\t$sInfo .= \" ({$_SESSION['login_mode']})\";\n\t\t\t}\n\t\t\tCMDBObject::SetTrackInfo($sInfo);\n\n\t\t\t$oUser = MetaModel::GetObjectByName('UserExternal', $sAuthUser, false);\n\t\t\tif (is_null($oUser))\n\t\t\t{\n\t\t\t\t$oUser = MetaModel::NewObject('UserExternal');\n\t\t\t\t$oUser->Set('login', $sAuthUser);\n\t\t\t\t$oUser->Set('contactid', $oPerson->GetKey());\n\t\t\t\t$oUser->Set('language', MetaModel::GetConfig()->GetDefaultLanguage());\n\t\t\t}\n\n\t\t\t// read all the existing profiles\n\t\t\t$oProfilesSearch = new DBObjectSearch('URP_Profiles');\n\t\t\t$oProfilesSet = new DBObjectSet($oProfilesSearch);\n\t\t\t$aAllProfiles = array();\n\t\t\twhile ($oProfile = $oProfilesSet->Fetch())\n\t\t\t{\n\t\t\t\t$aAllProfiles[strtolower($oProfile->GetName())] = $oProfile->GetKey();\n\t\t\t}\n\n\t\t\t$aProfiles = array();\n\t\t\tforeach ($aRequestedProfiles as $sRequestedProfile)\n\t\t\t{\n\t\t\t\t$sRequestedProfile = strtolower($sRequestedProfile);\n\t\t\t\tif (isset($aAllProfiles[$sRequestedProfile]))\n\t\t\t\t{\n\t\t\t\t\t$aProfiles[] = $aAllProfiles[$sRequestedProfile];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (empty($aProfiles))\n\t\t\t{\n\t\t\t\tthrow new Exception(Dict::S('UI:Login:Error:NoValidProfiles'));\n\t\t\t}\n\n\t\t\t// Now synchronize the profiles\n\t\t\t$oProfilesSet = DBObjectSet::FromScratch('URP_UserProfile');\n\t\t\t$sOrigin = 'External User provisioning';\n\t\t\tif (isset($_SESSION['login_mode']))\n\t\t\t{\n\t\t\t\t$sOrigin .= \" ({$_SESSION['login_mode']})\";\n\t\t\t}\n\t\t\tforeach ($aProfiles as $iProfileId)\n\t\t\t{\n\t\t\t\t$oLink = new URP_UserProfile();\n\t\t\t\t$oLink->Set('profileid', $iProfileId);\n\t\t\t\t$oLink->Set('reason', $sOrigin);\n\t\t\t\t$oProfilesSet->AddObject($oLink);\n\t\t\t}\n\t\t\t$oUser->Set('profile_list', $oProfilesSet);\n\t\t\tif ($oUser->IsModified())\n\t\t\t{\n\t\t\t\t$oUser->DBWrite();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tIssueLog::Error($e->getMessage());\n\t\t}\n\n\t\treturn $oUser;\n\t}\n\n\t/**\n\t * Overridable: depending on the user, head toward a dedicated portal\n\t * @param string|null $sRequestedPortalId\n\t * @param int $iOnExit How to complete the call: redirect or return a code\n\t */\t \n\tprotected static function ChangeLocation($sRequestedPortalId = null, $iOnExit = self::EXIT_PROMPT)\n\t{\n\t\t$ret = call_user_func(array(self::$sHandlerClass, 'Dispatch'), $sRequestedPortalId);\n\t\tif ($ret === true)\n\t\t{\n\t\t\treturn self::EXIT_CODE_OK;\n\t\t}\n\t\telse if($ret === false)\n\t\t{\n\t\t\tthrow new Exception('Nowhere to go??');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($iOnExit == self::EXIT_RETURN)\n\t\t\t{\n\t\t\t\treturn self::EXIT_CODE_PORTALUSERNOTAUTHORIZED;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// No rights to be here, redirect to the portal\n\t\t\t\theader('Location: '.$ret);\n\t\t\t\tdie();\n\t\t\t}\n\t\t}\n\t\treturn self::EXIT_CODE_OK;\n\t}\n\n\t/**\n\t * Check if the user is already authentified, if yes, then performs some additional validations:\n\t * - if $bMustBeAdmin is true, then the user must be an administrator, otherwise an error is displayed\n\t * - if $bIsAllowedToPortalUsers is false and the user has only access to the portal, then the user is redirected\n\t * to the portal\n\t *\n\t * @param bool $bMustBeAdmin Whether or not the user must be an admin to access the current page\n\t * @param bool $bIsAllowedToPortalUsers Whether or not the current page is considered as part of the portal\n\t * @param int iOnExit What action to take if the user is not logged on (one of the class constants EXIT_...)\n\t *\n\t * @return int|mixed|string\n\t * @throws \\Exception\n\t */\n\tstatic function DoLogin($bMustBeAdmin = false, $bIsAllowedToPortalUsers = false, $iOnExit = self::EXIT_PROMPT)\n\t{\n\t\t$sRequestedPortalId = $bIsAllowedToPortalUsers ? 'legacy_portal' : 'backoffice';\n\t\treturn self::DoLoginEx($sRequestedPortalId, $bMustBeAdmin, $iOnExit);\n\t}\n\n\t/**\n\t * Check if the user is already authentified, if yes, then performs some additional validations to redirect towards\n\t * the desired \"portal\"\n\t *\n\t * @param string|null $sRequestedPortalId The requested \"portal\" interface, null for any\n\t * @param bool $bMustBeAdmin Whether or not the user must be an admin to access the current page\n\t * @param int iOnExit What action to take if the user is not logged on (one of the class constants EXIT_...)\n\t *\n\t * @return int|mixed|string\n\t * @throws \\Exception\n\t */\n\tstatic function DoLoginEx($sRequestedPortalId = null, $bMustBeAdmin = false, $iOnExit = self::EXIT_PROMPT)\n\t{\n\t\t$operation = utils::ReadParam('loginop', '');\n\t\n\t\t$sMessage = self::HandleOperations($operation); // May exit directly\n\t\n\t\t$iRet = self::Login($iOnExit);\n\t\n\t\tif ($iRet == self::EXIT_CODE_OK)\n\t\t{\n\t\t\tif ($bMustBeAdmin && !UserRights::IsAdministrator())\n\t\t\t{\n\t\t\t\tif ($iOnExit == self::EXIT_RETURN)\n\t\t\t\t{\n\t\t\t\t\treturn self::EXIT_CODE_MUSTBEADMIN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trequire_once(APPROOT.'/setup/setuppage.class.inc.php');\n\t\t\t\t\t$oP = new ErrorPage(Dict::S('UI:PageTitle:FatalError'));\n\t\t\t\t\t$oP->add(\"<h1>\".Dict::S('UI:Login:Error:AccessAdmin').\"</h1>\\n\");\n\t\t\t\t\t$oP->p(\"<a href=\\\"\".utils::GetAbsoluteUrlAppRoot().\"pages/logoff.php\\\">\".Dict::S('UI:LogOffMenu').\"</a>\");\n\t\t\t\t\t$oP->output();\n\t\t\t\t\texit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$iRet = call_user_func(array(self::$sHandlerClass, 'ChangeLocation'), $sRequestedPortalId, $iOnExit);\n\t\t}\n\t\tif ($iOnExit == self::EXIT_RETURN)\n\t\t{\n\t\t\treturn $iRet;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn $sMessage;\n\t\t}\n\t}\t\n\tprotected static function HandleOperations($operation)\n\t{\n\t\t$sMessage = ''; // most of the operations never return, but some can return a message to be displayed\n\t\tif ($operation == 'logoff')\n\t\t{\n\t\t\tself::ResetSession();\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->DisplayLoginForm(false /* not a failed attempt */);\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'forgot_pwd')\n\t\t{\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->DisplayForgotPwdForm();\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'forgot_pwd_go')\n\t\t{\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->ForgotPwdGo();\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'reset_pwd')\n\t\t{\n\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t$oPage->DisplayResetPwdForm();\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'do_reset_pwd')\n\t\t{\n\n\t\t\ttry {\n\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t$oPage->DoResetPassword();\n\t\t\t}\n\t\t\tcatch (CoreCannotSaveObjectException $e)\n\t\t\t{\n\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t$oPage->DisplayResetPwdForm($e->getIssue());\n\t\t\t}\n\n\t\t\t$oPage->output();\n\t\t\texit;\n\t\t}\n\t\telse if ($operation == 'change_pwd')\n\t\t{\n\t\t\tif (isset($_SESSION['auth_user']))\n\t\t\t{\n\t\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t$oPage->DisplayChangePwdForm();\n\t\t\t\t$oPage->output();\n\t\t\t\texit;\n\t\t\t}\n\t\t}\n\t\telse if ($operation == 'check_pwd_policy')\n\t\t{\n\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\tUserRights::Login($sAuthUser); // Set the user's language\n\n\t\t\t$aPwdMap = array();\n\n\t\t\tforeach (array('new_pwd', 'retype_new_pwd') as $postedPwd)\n\t\t\t{\n\t\t\t\t$oUser = new UserLocal();\n\t\t\t\t$oUser->ValidatePassword($_POST[$postedPwd]);\n\n\t\t\t\t$aPwdMap[$postedPwd]['isValid'] = $oUser->IsPasswordValid();\n\t\t\t\t$aPwdMap[$postedPwd]['message'] = $oUser->getPasswordValidityMessage();\n\t\t\t}\n\t\t\techo json_encode($aPwdMap);\n\t\t\tdie();\n\t\t}\n\t\tif ($operation == 'do_change_pwd')\n\t\t{\n\t\t\tif (isset($_SESSION['auth_user']))\n\t\t\t{\n\t\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\t\tUserRights::Login($sAuthUser); // Set the user's language\n\t\t\t\t$sOldPwd = utils::ReadPostedParam('old_pwd', '', 'raw_data');\n\t\t\t\t$sNewPwd = utils::ReadPostedParam('new_pwd', '', 'raw_data');\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (UserRights::CanChangePassword() && ((!UserRights::CheckCredentials($sAuthUser, $sOldPwd)) || (!UserRights::ChangePassword($sOldPwd, $sNewPwd))))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t\t\t$oPage->DisplayChangePwdForm(true); // old pwd was wrong\n\t\t\t\t\t\t$oPage->output();\n\t\t\t\t\t\texit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (CoreCannotSaveObjectException $e)\n\t\t\t\t{\n\t\t\t\t\t$oPage = self::NewLoginWebPage();\n\t\t\t\t\t$oPage->DisplayChangePwdForm(true, $e->getIssue()); // password policy was not met.\n\t\t\t\t\t$oPage->output();\n\t\t\t\t\texit;\n\t\t\t\t}\n\t\t\t\t$sMessage = Dict::S('UI:Login:PasswordChanged');\n\t\t\t}\n\t\t}\n\t\treturn $sMessage;\n\t}\n\t\n\tprotected static function Dispatch($sRequestedPortalId)\n\t{\n\t\tif ($sRequestedPortalId === null) return true; // allowed to any portal => return true\n\t\t\n\t\t$aPortalsConf = PortalDispatcherData::GetData();\n\t\t$aDispatchers = array();\n\t\tforeach($aPortalsConf as $sPortalId => $aConf)\n\t\t{\n\t\t\t$sHandlerClass = $aConf['handler'];\n\t\t\t$aDispatchers[$sPortalId] = new $sHandlerClass($sPortalId);\n\t\t}\n\t\t\n\t\tif (array_key_exists($sRequestedPortalId, $aDispatchers) && $aDispatchers[$sRequestedPortalId]->IsUserAllowed())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tforeach($aDispatchers as $sPortalId => $oDispatcher)\n\t\t{\n\t\t\tif ($oDispatcher->IsUserAllowed()) return $oDispatcher->GetUrl();\n\t\t}\n\t\treturn false; // nothing matched !!\n\t}\n\n\t/**\n\t * @return mixed\n\t */\n\tpublic static function getIOnExit()\n\t{\n\t\treturn self::$iOnExit;\n\t}\n\n} // End of class\n"], "filenames": ["application/loginwebpage.class.inc.php"], "buggy_code_start_loc": [211], "buggy_code_end_loc": [212], "fixing_code_start_loc": [211], "fixing_code_end_loc": [212], "type": "CWE-330", "message": "Combodo iTop is an open source, web-based IT service management platform. Prior to versions 2.7.8 and 3.0.2-1, the reset password token is generated without any randomness parameter. This may lead to account takeover. The issue is fixed in versions 2.7.8 and 3.0.2-1.", "other": {"cve": {"id": "CVE-2022-39216", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-14T16:15:10.377", "lastModified": "2023-03-19T03:56:09.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Combodo iTop is an open source, web-based IT service management platform. Prior to versions 2.7.8 and 3.0.2-1, the reset password token is generated without any randomness parameter. This may lead to account takeover. The issue is fixed in versions 2.7.8 and 3.0.2-1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-330"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:*:*:*:*:*:*:*:*", "versionStartExcluding": "2.0.2", "versionEndExcluding": "2.7.8", "matchCriteriaId": "6609A3B5-DE4C-4E5E-8D2E-12D8F6F84B5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:*:*:*:*:*:*:*:*", "versionStartExcluding": "3.0.0", "versionEndExcluding": "3.0.2-1", "matchCriteriaId": "BFD5F02C-2718-439E-AA59-6E1A0B18B024"}]}]}], "references": [{"url": "https://github.com/Combodo/iTop/commit/35a8b501c9e4e767ec4b36c2586f34d4ab66d229", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Combodo/iTop/commit/f10e9c2d64d0304777660a4f70f1e80850ea864b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Combodo/iTop/security/advisories/GHSA-hggq-48p2-cmhm", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Combodo/iTop/commit/35a8b501c9e4e767ec4b36c2586f34d4ab66d229"}}