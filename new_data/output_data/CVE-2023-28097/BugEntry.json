{"buggy_code": ["/*\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * 2003-08-04 parse_content_type_hdr separates type from subtype inside\n * the mime type (bogdan)\n * 2003-08-04 CPL subtype added (bogdan)\n * 2003-08-05 parse_accept_hdr function added (bogdan)\n * 2011-06-22 ISUP subtype added (roger)\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"../mem/mem.h\"\n#include \"../dprint.h\"\n#include \"../str.h\"\n#include \"../ut.h\"\n#include \"../errinfo.h\"\n#include \"parse_content.h\"\n\n\n#define is_mime_char(_c_) \\\n\t(isalnum((int)_c_) || (_c_)=='-' || (_c_)=='+' || (_c_)=='.')\n#define is_char_equal(_c_,_cs_) \\\n\t( (isalpha((int)_c_)?(((_c_)|0x20)==(_cs_)):((_c_)==(_cs_)))==1 )\n\n\n/*\n * Node of the type's tree; this tree contains all the known types;\n */\ntypedef struct type_node_s {\n\tchar c;                      /* char contained by this node */\n\tunsigned char final;         /* says what mime type/subtype was detected\n\t                              * if string ends at this node */\n\tunsigned char nr_sons;       /* the number of sub-nodes */\n\tint next;                    /* the next sibling node */\n}type_node_t;\n\n\nstatic type_node_t type_tree[] = {\n\t{'t',TYPE_UNKNOWN,1,4}, /* 0 */\n\t\t{'e',TYPE_UNKNOWN,1,-1},\n\t\t\t{'x',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'t',TYPE_TEXT,0,-1},\n\t{'m',TYPE_UNKNOWN,2,19}, /* 4 */\n\t\t{'e',TYPE_UNKNOWN,1,11}, /* 5 */\n\t\t\t{'s',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'s',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'a',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'g',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'e',TYPE_MESSAGE,0,-1},\n\t\t{'u',TYPE_UNKNOWN,1,-1}, /* 11 */\n\t\t\t{'l',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'t',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'i',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'p',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'a',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'r',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'t',TYPE_MULTIPART,0,-1},\n\t{'a',TYPE_UNKNOWN,1,-1}, /* 19 */\n\t\t{'p',TYPE_UNKNOWN,1,-1},\n\t\t\t{'p',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'l',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'i',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'c',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'a',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'t',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'i',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'o',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'n',TYPE_APPLICATION,0,-1},\n\t};\n\n\nstatic type_node_t subtype_tree[] = {\n        {'p',SUBTYPE_UNKNOWN,2,12},  /* 0 */\n\t\t{'l',SUBTYPE_UNKNOWN,1,5},\n\t\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'n',SUBTYPE_PLAIN,0,-1},\n\t\t{'i',SUBTYPE_UNKNOWN,1,-1}, /* 5 */\n\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'l',SUBTYPE_PIDFXML,0,-1},\n\t{'s',SUBTYPE_UNKNOWN,2,36}, /* 12 */\n\t\t{'d',SUBTYPE_UNKNOWN,1,15},\n\t\t\t{'p',SUBTYPE_SDP,0,-1},\n\t        {'i',SUBTYPE_UNKNOWN,1,-1},  /* 15 */\n\t                {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                    {'p',SUBTYPE_UNKNOWN,1,-1},\n\t                        {'l',SUBTYPE_UNKNOWN,1,-1},\n\t                            {'e',SUBTYPE_UNKNOWN,1,-1},\n\t                                {'-',SUBTYPE_UNKNOWN,1,-1},\n\t                                    {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                                        {'e',SUBTYPE_UNKNOWN,1,-1},\n\t                                            {'s',SUBTYPE_UNKNOWN,1,-1},\n\t                                                {'s',SUBTYPE_UNKNOWN,1,-1},\n\t                                                    {'a',SUBTYPE_UNKNOWN,1,-1},\n\t                                                        {'g',SUBTYPE_UNKNOWN,1,-1},\n\t                                                            {'e',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                {'-',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                    {'s',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                        {'u',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                            {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                    {'a',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                        {'r',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                            {'y',SUBTYPE_SMS,0,-1},\n\t{'c',SUBTYPE_UNKNOWN,1,45}, /* 36 */\n\t\t{'p',SUBTYPE_UNKNOWN,2,-1},\n\t\t\t{'i',SUBTYPE_UNKNOWN,1,40},\n\t\t\t\t{'m',SUBTYPE_CPIM,0,-1},\n\t                {'l',SUBTYPE_UNKNOWN,1,-1}, /* 40 */\n\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'l',SUBTYPE_CPLXML,0,-1},\n\t{'r',SUBTYPE_UNKNOWN,2,59}, /* 45 */\n\t\t{'l',SUBTYPE_UNKNOWN,1,53},\n\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'l',SUBTYPE_RLMIXML,0,-1},\n\t\t{'e',SUBTYPE_UNKNOWN,1,-1}, /* 53 */\n\t\t\t{'l',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'d',SUBTYPE_RELATED,0,-1},\n\t{'l',SUBTYPE_UNKNOWN,1,68}, /* 59 */\n\t\t{'p',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'l',SUBTYPE_LPIDFXML,0,-1},\n\t{'w',SUBTYPE_UNKNOWN,1,83}, /* 68 */\n\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'c',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'h',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'r',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'n',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'o',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{'l',SUBTYPE_WATCHERINFOXML,0,-1},\n\t{'x',SUBTYPE_UNKNOWN,2,105}, /* 83 */\n\t\t{'p',SUBTYPE_UNKNOWN,1,92},\n\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'l',SUBTYPE_XPIDFXML,0,-1},\n\t\t{'m',SUBTYPE_UNKNOWN,1,-1}, /* 92 */\n\t\t\t{'l',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'s',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'r',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'c',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'.',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'p',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{'f',SUBTYPE_XML_MSRTC_PIDF,0,-1},\n\t{'e',SUBTYPE_UNKNOWN,1,118}, /* 105 */\n\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'r',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'n',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'l',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'-',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'b',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'o',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{'y',SUBTYPE_EXTERNAL_BODY,0,-1},\n\t{'m',SUBTYPE_UNKNOWN,1,123}, /* 118 */\n\t         {'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'d',SUBTYPE_MIXED,0,-1},\n\t{'i',SUBTYPE_UNKNOWN,1,-1}, /* 123 */\n\t\t{'s',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'u',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'p',SUBTYPE_ISUP,0,-1},\n\n        };\nchar str_contenttype[50];\n\n\n\nchar* parse_content_length( char* buffer, char* end, int* length)\n{\n\tint number;\n\tchar *p;\n\tint  size;\n\n\tp = buffer;\n\t/* search the beginning of the number */\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t/* parse the number */\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\t/* now we should have only spaces at the end */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t/* the header ends proper? */\n\tif ( (*(p++)!='\\n') && (*(p-1)!='\\r' || *(p++)!='\\n' ) )\n\t\tgoto error;\n\n\t*length = number;\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near char [%d][%c]\\n\",*p,*p);\n\treturn 0;\n}\n\n\n\nchar* decode_mime_type(char *start, char *end, unsigned int *mime_type, content_t * con)\n{\n\tint node;\n\tchar *mark;\n\tchar *p;\n\n\tp = start;\n\n\tLM_DBG(\"Decoding MIME type for:[%.*s]\\n\",(int)(end-start),start);\n\n\t/* search the beginning of the type */\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\n\t/* parse the type */\n\tif (*p=='*') {\n\t\t*mime_type = TYPE_ALL<<16;\n\t\tp++;\n\t} else {\n\t\tnode = 0;\n\t\tmark = p;\n\t\twhile (p<end && is_mime_char(*p)  ) {\n\t\t\twhile ( node!=-1 && !is_char_equal(*p,type_tree[node].c) ){\n\t\t\t\tnode = type_tree[node].next;\n\t\t\t}\n\t\t\tif (node!=-1 && type_tree[node].nr_sons)\n\t\t\t\tnode++;\n\t\t\tp++;\n\t\t}\n\t\tif (p==end || mark==p)\n\t\t\tgoto error;\n\t\tif (node!=-1)\n\t\t\t*mime_type = type_tree[node].final<<16;\n\t\telse\n\t\t\t*mime_type = TYPE_UNKNOWN<<16;\n\t}\n\n\t/* search the '/' separator */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif ( p==end || *(p++)!='/')\n\t\tgoto error;\n\n\t/* search the beginning of the sub-type */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\n\t/* parse the sub-type */\n\tif (*p=='*') {\n\t\t*mime_type |= SUBTYPE_ALL;\n\t\tp++;\n\t} else {\n\t\tnode = 0;\n\t\tmark = p;\n\t\twhile (p<end && (is_mime_char(*p) || *p == '_')) {\n\t\t\twhile(node!=-1 && !is_char_equal(*p,subtype_tree[node].c) )\n\t\t\t\tnode = subtype_tree[node].next;\n\t\t\tif (node!=-1 && subtype_tree[node].nr_sons)\n\t\t\t\tnode++;\n\t\t\tp++;\n\t\t}\n\t\tif (p==mark)\n\t\t\tgoto error;\n\t\tif (node!=-1)\n\t\t\t*mime_type |= subtype_tree[node].final;\n\t\telse\n\t\t\t*mime_type |= SUBTYPE_UNKNOWN;\n\t}\n\n\t/* now its possible to have some spaces */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\n\t/* if there are params, ignore them!! -> eat everything to\n\t * the end or to the first ',' */\n\tif ( p<end && *p==';' )\n\t{\n\t\tif( con == NULL)\n\t\t\tfor(p++; p<end && *p!=','; p++);\n\t\telse\n\t\t{\n\t\t\tstr params_str;\n\t\t\tparam_hooks_t phooks;\n\t\t\tparam_t * cur;\n\n\t\t\tparams_str.s = p;\n\t\t\tparams_str.len = end - p ;\n\n\t\t\tif (parse_params(&params_str, CLASS_ANY, &phooks, &con->params) < 0)\n\t\t\t\tgoto error;\n\n\t\t\tp = params_str.s;\n\n\t\t\tcur = con->params;\n\n\t\t\twhile(cur)\n\t\t\t{\n\t\t\t\tif( cur->name.len == 8 && !strncasecmp(cur->name.s,\"boundary\",cur->name.len ) )\n\t\t\t\t\tcon->boundary = cur->body;\n\n\t\t\t\tif( cur->name.len == 5 && !strncasecmp(cur->name.s,\"start\",cur->name.len ) )\n\t\t\t\t\tcon->start = cur->body;\n\n\t\t\t\tcur = cur ->next;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/* is this the correct end? */\n\tif (p!=end && *p!=',' )\n\t\tgoto error;\n\n\t/* check the format of the decoded mime */\n\tif ((*mime_type)>>16==TYPE_ALL && ((*mime_type)&0x00ff)!=SUBTYPE_ALL) {\n\t\tLM_ERR(\"invalid mime format found \"\n\t\t\t\" <*/submime> in [%.*s]!!\\n\", (int)(end-start),start);\n\t\treturn 0;\n\t}\n\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near in [%.*s] char\"\n\t\t\"[%d][%c] offset=%d\\n\", (int)(end-start),start,*p,*p,(int)(p-start));\n\treturn 0;\n}\n\n\n\n/* returns: > 0 mime found\n *          = 0 hdr not found\n *          =-1 error */\nint parse_content_type_hdr( struct sip_msg *msg )\n{\n\tchar *end;\n\tchar *ret;\n\tunsigned int  mime;\n\tcontent_t * rez;\n\n\t/* is the header already found? */\n\tif ( msg->content_type==0 ) {\n\t\t/* if not, found it */\n\t\tif ( parse_headers(msg, HDR_CONTENTTYPE_F, 0)==-1)\n\t\t\tgoto error;\n\t\tif ( msg->content_type==0 ) {\n\t\t\tLM_DBG(\"missing Content-Type header\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* maybe the header is already parsed! */\n\tif ( msg->content_type->parsed!=0)\n\t\treturn get_content_type(msg);\n\n\trez = (content_t*) pkg_malloc(sizeof (content_t));\n\tif (rez == NULL)\n\t{\n\t\tLM_ERR(\"Unable to allocate memory\\n\");\n\t\tgoto error;\n\t}\n\tmemset(rez, 0, sizeof (content_t));\n\n\n\t/* it seams we have to parse it! :-( */\n\tend = msg->content_type->body.s + msg->content_type->body.len;\n\tret = decode_mime_type(msg->content_type->body.s, end , &mime, rez);\n\tif (ret==0)\n\t\tgoto parse_error;\n\tif (ret!=end) {\n\t\tLM_ERR(\"the header CONTENT_TYPE contains \"\n\t\t\t\"more then one mime type :-(!\\n\");\n\t\tgoto parse_error;\n\t}\n\tif ((mime&0x00ff)==SUBTYPE_ALL || (mime>>16)==TYPE_ALL) {\n\t\tLM_ERR(\"invalid mime with wildcard '*' in Content-Type hdr!\\n\");\n\t\tgoto parse_error;\n\t}\n\n\n\trez->type = mime;\n\tmsg->content_type->parsed = rez;\n\treturn mime;\n\nparse_error:\n\tpkg_free(rez);\n\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\"error parsing CT-TYPE header\");\n\tset_err_reply(400, \"bad headers\");\n\nerror:\n\treturn -1;\n}\n\n\n\n/* returns: > 0 ok\n *          = 0 hdr not found\n *          = -1 error */\nint parse_accept_hdr( struct sip_msg *msg )\n{\n\tstatic unsigned int mimes[MAX_MIMES_NR];\n\tint nr_mimes;\n\tunsigned int mime;\n\tchar *end;\n\tchar *ret;\n\n\t/* is the header already found? */\n\tif ( msg->accept==0 ) {\n\t\t/* if not, found it */\n\t\tif ( parse_headers(msg, HDR_ACCEPT_F, 0)==-1)\n\t\t\tgoto error;\n\t\tif ( msg->accept==0 ) {\n\t\t\tLM_DBG(\"missing Accept header\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* maybe the header is already parsed! */\n\tif ( msg->accept->parsed!=0)\n\t\treturn 1;\n\n\t/* it seams we have to parse it! :-( */\n\tret = msg->accept->body.s;\n\tend = ret + msg->accept->body.len;\n\tnr_mimes = 0;\n\twhile (1){\n\t\tret = decode_mime_type(ret, end , &mime, NULL);\n\t\tif (ret==0)\n\t\t\tgoto parse_error;\n\t\t/* a new mime was found  -> put it into array */\n\t\tif (nr_mimes==MAX_MIMES_NR) {\n\t\t\tLM_ERR(\"accept hdr contains more than\"\n\t\t\t\t\" %d mime type -> buffer overflow!!\\n\",MAX_MIMES_NR);\n\t\t\tgoto error;\n\t\t}\n\t\tmimes[nr_mimes++] = mime;\n\t\t/* is another mime following? */\n\t\tif (ret==end )\n\t\t\tbreak;\n\t\t/* parse the mime separator ',' */\n\t\tif (*ret!=',' || ret+1==end) {\n\t\t\tLM_ERR(\"parse error between mimes at \"\n\t\t\t\t\"char <%x> (offset=%d) in <%.*s>!\\n\",\n\t\t\t\t*ret, (int)(ret-msg->accept->body.s),\n\t\t\t\tmsg->accept->body.len, msg->accept->body.s);\n\t\t\tgoto parse_error;\n\t\t}\n\t\t/* skip the ',' */\n\t\tret++;\n\t}\n\n\t/* copy and link the mime buffer into the message */\n\tmsg->accept->parsed = (void*)pkg_malloc((nr_mimes+1)*sizeof(int));\n\tif (msg->accept->parsed==0) {\n\t\tLM_ERR(\"no more pkg memory\\n\");\n\t\tgoto error;\n\t}\n\tmemcpy(msg->accept->parsed,mimes,nr_mimes*sizeof(int));\n\t/* make the buffer null terminated */\n\t((int*)msg->accept->parsed)[nr_mimes] = 0;\n\n\treturn 1;\n\nparse_error:\n\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\"error parsing ACCEPT header\");\n\tset_err_reply(400, \"bad headers\");\nerror:\n\treturn -1;\n}\n\nvoid free_contenttype(content_t ** con)\n{\n\n\tif (*con)\n\t{\n\t\tif((*con)->params)\n\t\t\tfree_params((*con)->params);\n\t\tpkg_free(*con);\n\t}\n\t*con = 0;\n}\n\nchar* convert_mime2string_CT(int contenttype)\n{\n\t#define SET_TYPE_PTRS(_type_) \\\n\t\tdo { \\\n\t\t\tsubtype_start = type_start + sizeof(_type_) - 1; \\\n\t\t\tmemcpy(type_start, _type_, sizeof(_type_) - 1); \\\n\t\t} while(0);\n\n\t#define SET_SUBTYPE_PTR(_subtype_) memcpy(subtype_start, _subtype_, sizeof(_subtype_))\n\n\t/* last 16 bits */\n\tint type = contenttype >> 16;\n\t/* only first 16 bits */\n\tint subtype = contenttype & (0xFF);\n\tchar* type_start;\n\tchar* subtype_start;\n\n\tmemset(str_contenttype, 0 , sizeof(str_contenttype));\n\ttype_start = str_contenttype;\n\n\tswitch (type) {\n\t\tcase TYPE_TEXT:\n\t\t\tSET_TYPE_PTRS(\"text/\");\n\t\t\tbreak;\n\t\tcase TYPE_MESSAGE:\n\t\t\tSET_TYPE_PTRS(\"message/\");\n\t\t\tbreak;\n\t\tcase TYPE_APPLICATION:\n\t\t\tSET_TYPE_PTRS(\"application/\");\n\t\t\tbreak;\n\t\tcase TYPE_MULTIPART:\n\t\t\tSET_TYPE_PTRS(\"multipart/\");\n\t\t\tbreak;\n\t\tcase TYPE_ALL:\n\t\t\tSET_TYPE_PTRS(\"*/\");\n\t\t\tbreak;\n\t\tcase TYPE_UNKNOWN:\n\t\t\tSET_TYPE_PTRS(\"unknown/\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"invalid type\\n\");\n\t\t\treturn 0;\n\t}\n\n\tswitch (subtype) {\n\t\tcase SUBTYPE_PLAIN:\n\t\t\tSET_SUBTYPE_PTR(\"plain\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_CPIM:\n\t\t\tSET_SUBTYPE_PTR(\"cpim\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_SDP:\n\t\t\tSET_SUBTYPE_PTR(\"sdp\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_CPLXML:\n\t\t\tSET_SUBTYPE_PTR(\"cplxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_PIDFXML:\n\t\t\tSET_SUBTYPE_PTR(\"pidfxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_RLMIXML:\n\t\t\tSET_SUBTYPE_PTR(\"rlmixml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_RELATED:\n\t\t\tSET_SUBTYPE_PTR(\"related\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_LPIDFXML:\n\t\t\tSET_SUBTYPE_PTR(\"lpidfxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_XPIDFXML:\n\t\t\tSET_SUBTYPE_PTR(\"xpidfxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_WATCHERINFOXML:\n\t\t\tSET_SUBTYPE_PTR(\"watcherinfoxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_EXTERNAL_BODY:\n\t\t\tSET_SUBTYPE_PTR(\"external_body\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_XML_MSRTC_PIDF:\n\t\t\tSET_SUBTYPE_PTR(\"xmlmsrtcpidf\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_SMS:\n\t\t\tSET_SUBTYPE_PTR(\"sms\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_MIXED:\n\t\t\tSET_SUBTYPE_PTR(\"mixed\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_ISUP:\n\t\t\tSET_SUBTYPE_PTR(\"isup\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_ALL:\n\t\t\tSET_SUBTYPE_PTR(\"*\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_UNKNOWN:\n\t\t\tSET_SUBTYPE_PTR(\"unknown\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"invalid subtype\\n\");\n\t\t\treturn 0;\n\t}\n\n\treturn str_contenttype;\n\n#undef SET_TYPE_PTRS\n#undef SET_SUBTYPE_PTR\n}\n\n\n\n"], "fixing_code": ["/*\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * 2003-08-04 parse_content_type_hdr separates type from subtype inside\n * the mime type (bogdan)\n * 2003-08-04 CPL subtype added (bogdan)\n * 2003-08-05 parse_accept_hdr function added (bogdan)\n * 2011-06-22 ISUP subtype added (roger)\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"../mem/mem.h\"\n#include \"../dprint.h\"\n#include \"../str.h\"\n#include \"../ut.h\"\n#include \"../errinfo.h\"\n#include \"parse_content.h\"\n\n\n#define is_mime_char(_c_) \\\n\t(isalnum((int)_c_) || (_c_)=='-' || (_c_)=='+' || (_c_)=='.')\n#define is_char_equal(_c_,_cs_) \\\n\t( (isalpha((int)_c_)?(((_c_)|0x20)==(_cs_)):((_c_)==(_cs_)))==1 )\n\n\n/*\n * Node of the type's tree; this tree contains all the known types;\n */\ntypedef struct type_node_s {\n\tchar c;                      /* char contained by this node */\n\tunsigned char final;         /* says what mime type/subtype was detected\n\t                              * if string ends at this node */\n\tunsigned char nr_sons;       /* the number of sub-nodes */\n\tint next;                    /* the next sibling node */\n}type_node_t;\n\n\nstatic type_node_t type_tree[] = {\n\t{'t',TYPE_UNKNOWN,1,4}, /* 0 */\n\t\t{'e',TYPE_UNKNOWN,1,-1},\n\t\t\t{'x',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'t',TYPE_TEXT,0,-1},\n\t{'m',TYPE_UNKNOWN,2,19}, /* 4 */\n\t\t{'e',TYPE_UNKNOWN,1,11}, /* 5 */\n\t\t\t{'s',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'s',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'a',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'g',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'e',TYPE_MESSAGE,0,-1},\n\t\t{'u',TYPE_UNKNOWN,1,-1}, /* 11 */\n\t\t\t{'l',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'t',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'i',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'p',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'a',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'r',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'t',TYPE_MULTIPART,0,-1},\n\t{'a',TYPE_UNKNOWN,1,-1}, /* 19 */\n\t\t{'p',TYPE_UNKNOWN,1,-1},\n\t\t\t{'p',TYPE_UNKNOWN,1,-1},\n\t\t\t\t{'l',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'i',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'c',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'a',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'t',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'i',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'o',TYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'n',TYPE_APPLICATION,0,-1},\n\t};\n\n\nstatic type_node_t subtype_tree[] = {\n        {'p',SUBTYPE_UNKNOWN,2,12},  /* 0 */\n\t\t{'l',SUBTYPE_UNKNOWN,1,5},\n\t\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'n',SUBTYPE_PLAIN,0,-1},\n\t\t{'i',SUBTYPE_UNKNOWN,1,-1}, /* 5 */\n\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'l',SUBTYPE_PIDFXML,0,-1},\n\t{'s',SUBTYPE_UNKNOWN,2,36}, /* 12 */\n\t\t{'d',SUBTYPE_UNKNOWN,1,15},\n\t\t\t{'p',SUBTYPE_SDP,0,-1},\n\t        {'i',SUBTYPE_UNKNOWN,1,-1},  /* 15 */\n\t                {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                    {'p',SUBTYPE_UNKNOWN,1,-1},\n\t                        {'l',SUBTYPE_UNKNOWN,1,-1},\n\t                            {'e',SUBTYPE_UNKNOWN,1,-1},\n\t                                {'-',SUBTYPE_UNKNOWN,1,-1},\n\t                                    {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                                        {'e',SUBTYPE_UNKNOWN,1,-1},\n\t                                            {'s',SUBTYPE_UNKNOWN,1,-1},\n\t                                                {'s',SUBTYPE_UNKNOWN,1,-1},\n\t                                                    {'a',SUBTYPE_UNKNOWN,1,-1},\n\t                                                        {'g',SUBTYPE_UNKNOWN,1,-1},\n\t                                                            {'e',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                {'-',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                    {'s',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                        {'u',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                            {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                {'m',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                    {'a',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                        {'r',SUBTYPE_UNKNOWN,1,-1},\n\t                                                                                            {'y',SUBTYPE_SMS,0,-1},\n\t{'c',SUBTYPE_UNKNOWN,1,45}, /* 36 */\n\t\t{'p',SUBTYPE_UNKNOWN,2,-1},\n\t\t\t{'i',SUBTYPE_UNKNOWN,1,40},\n\t\t\t\t{'m',SUBTYPE_CPIM,0,-1},\n\t                {'l',SUBTYPE_UNKNOWN,1,-1}, /* 40 */\n\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'l',SUBTYPE_CPLXML,0,-1},\n\t{'r',SUBTYPE_UNKNOWN,2,59}, /* 45 */\n\t\t{'l',SUBTYPE_UNKNOWN,1,53},\n\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'l',SUBTYPE_RLMIXML,0,-1},\n\t\t{'e',SUBTYPE_UNKNOWN,1,-1}, /* 53 */\n\t\t\t{'l',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'d',SUBTYPE_RELATED,0,-1},\n\t{'l',SUBTYPE_UNKNOWN,1,68}, /* 59 */\n\t\t{'p',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'l',SUBTYPE_LPIDFXML,0,-1},\n\t{'w',SUBTYPE_UNKNOWN,1,83}, /* 68 */\n\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'c',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'h',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'r',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'n',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'o',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{'l',SUBTYPE_WATCHERINFOXML,0,-1},\n\t{'x',SUBTYPE_UNKNOWN,2,105}, /* 83 */\n\t\t{'p',SUBTYPE_UNKNOWN,1,92},\n\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'f',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'l',SUBTYPE_XPIDFXML,0,-1},\n\t\t{'m',SUBTYPE_UNKNOWN,1,-1}, /* 92 */\n\t\t\t{'l',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'+',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'m',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'s',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'r',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'c',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'.',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'p',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t{'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{'f',SUBTYPE_XML_MSRTC_PIDF,0,-1},\n\t{'e',SUBTYPE_UNKNOWN,1,118}, /* 105 */\n\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'t',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'r',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t{'n',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t{'a',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t{'l',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t{'-',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t{'b',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t{'o',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t{'d',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{'y',SUBTYPE_EXTERNAL_BODY,0,-1},\n\t{'m',SUBTYPE_UNKNOWN,1,123}, /* 118 */\n\t         {'i',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'x',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'e',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t\t{'d',SUBTYPE_MIXED,0,-1},\n\t{'i',SUBTYPE_UNKNOWN,1,-1}, /* 123 */\n\t\t{'s',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t{'u',SUBTYPE_UNKNOWN,1,-1},\n\t\t\t\t{'p',SUBTYPE_ISUP,0,-1},\n\n        };\nchar str_contenttype[50];\n\n\n\nchar* parse_content_length( char* buffer, char* end, int* length)\n{\n\tint number;\n\tchar *p;\n\tint  size;\n\n\tp = buffer;\n\t/* search the beginning of the number */\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t/* parse the number */\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\t/* do not actually cause an integer overflow, as it is UB! --liviu */\n\t\tif (number > 214748363) {\n\t\t\tLM_ERR(\"integer overflow risk at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\n\t\tnumber = number*10 + (*p)-'0';\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\t/* now we should have only spaces at the end */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t/* the header ends proper? */\n\tif ( (*(p++)!='\\n') && (*(p-1)!='\\r' || *(p++)!='\\n' ) )\n\t\tgoto error;\n\n\t*length = number;\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near char [%d][%c]\\n\",*p,*p);\n\treturn 0;\n}\n\n\n\nchar* decode_mime_type(char *start, char *end, unsigned int *mime_type, content_t * con)\n{\n\tint node;\n\tchar *mark;\n\tchar *p;\n\n\tp = start;\n\n\tLM_DBG(\"Decoding MIME type for:[%.*s]\\n\",(int)(end-start),start);\n\n\t/* search the beginning of the type */\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\n\t/* parse the type */\n\tif (*p=='*') {\n\t\t*mime_type = TYPE_ALL<<16;\n\t\tp++;\n\t} else {\n\t\tnode = 0;\n\t\tmark = p;\n\t\twhile (p<end && is_mime_char(*p)  ) {\n\t\t\twhile ( node!=-1 && !is_char_equal(*p,type_tree[node].c) ){\n\t\t\t\tnode = type_tree[node].next;\n\t\t\t}\n\t\t\tif (node!=-1 && type_tree[node].nr_sons)\n\t\t\t\tnode++;\n\t\t\tp++;\n\t\t}\n\t\tif (p==end || mark==p)\n\t\t\tgoto error;\n\t\tif (node!=-1)\n\t\t\t*mime_type = type_tree[node].final<<16;\n\t\telse\n\t\t\t*mime_type = TYPE_UNKNOWN<<16;\n\t}\n\n\t/* search the '/' separator */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif ( p==end || *(p++)!='/')\n\t\tgoto error;\n\n\t/* search the beginning of the sub-type */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\n\t/* parse the sub-type */\n\tif (*p=='*') {\n\t\t*mime_type |= SUBTYPE_ALL;\n\t\tp++;\n\t} else {\n\t\tnode = 0;\n\t\tmark = p;\n\t\twhile (p<end && (is_mime_char(*p) || *p == '_')) {\n\t\t\twhile(node!=-1 && !is_char_equal(*p,subtype_tree[node].c) )\n\t\t\t\tnode = subtype_tree[node].next;\n\t\t\tif (node!=-1 && subtype_tree[node].nr_sons)\n\t\t\t\tnode++;\n\t\t\tp++;\n\t\t}\n\t\tif (p==mark)\n\t\t\tgoto error;\n\t\tif (node!=-1)\n\t\t\t*mime_type |= subtype_tree[node].final;\n\t\telse\n\t\t\t*mime_type |= SUBTYPE_UNKNOWN;\n\t}\n\n\t/* now its possible to have some spaces */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\n\t/* if there are params, ignore them!! -> eat everything to\n\t * the end or to the first ',' */\n\tif ( p<end && *p==';' )\n\t{\n\t\tif( con == NULL)\n\t\t\tfor(p++; p<end && *p!=','; p++);\n\t\telse\n\t\t{\n\t\t\tstr params_str;\n\t\t\tparam_hooks_t phooks;\n\t\t\tparam_t * cur;\n\n\t\t\tparams_str.s = p;\n\t\t\tparams_str.len = end - p ;\n\n\t\t\tif (parse_params(&params_str, CLASS_ANY, &phooks, &con->params) < 0)\n\t\t\t\tgoto error;\n\n\t\t\tp = params_str.s;\n\n\t\t\tcur = con->params;\n\n\t\t\twhile(cur)\n\t\t\t{\n\t\t\t\tif( cur->name.len == 8 && !strncasecmp(cur->name.s,\"boundary\",cur->name.len ) )\n\t\t\t\t\tcon->boundary = cur->body;\n\n\t\t\t\tif( cur->name.len == 5 && !strncasecmp(cur->name.s,\"start\",cur->name.len ) )\n\t\t\t\t\tcon->start = cur->body;\n\n\t\t\t\tcur = cur ->next;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/* is this the correct end? */\n\tif (p!=end && *p!=',' )\n\t\tgoto error;\n\n\t/* check the format of the decoded mime */\n\tif ((*mime_type)>>16==TYPE_ALL && ((*mime_type)&0x00ff)!=SUBTYPE_ALL) {\n\t\tLM_ERR(\"invalid mime format found \"\n\t\t\t\" <*/submime> in [%.*s]!!\\n\", (int)(end-start),start);\n\t\treturn 0;\n\t}\n\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near in [%.*s] char\"\n\t\t\"[%d][%c] offset=%d\\n\", (int)(end-start),start,*p,*p,(int)(p-start));\n\treturn 0;\n}\n\n\n\n/* returns: > 0 mime found\n *          = 0 hdr not found\n *          =-1 error */\nint parse_content_type_hdr( struct sip_msg *msg )\n{\n\tchar *end;\n\tchar *ret;\n\tunsigned int  mime;\n\tcontent_t * rez;\n\n\t/* is the header already found? */\n\tif ( msg->content_type==0 ) {\n\t\t/* if not, found it */\n\t\tif ( parse_headers(msg, HDR_CONTENTTYPE_F, 0)==-1)\n\t\t\tgoto error;\n\t\tif ( msg->content_type==0 ) {\n\t\t\tLM_DBG(\"missing Content-Type header\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* maybe the header is already parsed! */\n\tif ( msg->content_type->parsed!=0)\n\t\treturn get_content_type(msg);\n\n\trez = (content_t*) pkg_malloc(sizeof (content_t));\n\tif (rez == NULL)\n\t{\n\t\tLM_ERR(\"Unable to allocate memory\\n\");\n\t\tgoto error;\n\t}\n\tmemset(rez, 0, sizeof (content_t));\n\n\n\t/* it seams we have to parse it! :-( */\n\tend = msg->content_type->body.s + msg->content_type->body.len;\n\tret = decode_mime_type(msg->content_type->body.s, end , &mime, rez);\n\tif (ret==0)\n\t\tgoto parse_error;\n\tif (ret!=end) {\n\t\tLM_ERR(\"the header CONTENT_TYPE contains \"\n\t\t\t\"more then one mime type :-(!\\n\");\n\t\tgoto parse_error;\n\t}\n\tif ((mime&0x00ff)==SUBTYPE_ALL || (mime>>16)==TYPE_ALL) {\n\t\tLM_ERR(\"invalid mime with wildcard '*' in Content-Type hdr!\\n\");\n\t\tgoto parse_error;\n\t}\n\n\n\trez->type = mime;\n\tmsg->content_type->parsed = rez;\n\treturn mime;\n\nparse_error:\n\tpkg_free(rez);\n\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\"error parsing CT-TYPE header\");\n\tset_err_reply(400, \"bad headers\");\n\nerror:\n\treturn -1;\n}\n\n\n\n/* returns: > 0 ok\n *          = 0 hdr not found\n *          = -1 error */\nint parse_accept_hdr( struct sip_msg *msg )\n{\n\tstatic unsigned int mimes[MAX_MIMES_NR];\n\tint nr_mimes;\n\tunsigned int mime;\n\tchar *end;\n\tchar *ret;\n\n\t/* is the header already found? */\n\tif ( msg->accept==0 ) {\n\t\t/* if not, found it */\n\t\tif ( parse_headers(msg, HDR_ACCEPT_F, 0)==-1)\n\t\t\tgoto error;\n\t\tif ( msg->accept==0 ) {\n\t\t\tLM_DBG(\"missing Accept header\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* maybe the header is already parsed! */\n\tif ( msg->accept->parsed!=0)\n\t\treturn 1;\n\n\t/* it seams we have to parse it! :-( */\n\tret = msg->accept->body.s;\n\tend = ret + msg->accept->body.len;\n\tnr_mimes = 0;\n\twhile (1){\n\t\tret = decode_mime_type(ret, end , &mime, NULL);\n\t\tif (ret==0)\n\t\t\tgoto parse_error;\n\t\t/* a new mime was found  -> put it into array */\n\t\tif (nr_mimes==MAX_MIMES_NR) {\n\t\t\tLM_ERR(\"accept hdr contains more than\"\n\t\t\t\t\" %d mime type -> buffer overflow!!\\n\",MAX_MIMES_NR);\n\t\t\tgoto error;\n\t\t}\n\t\tmimes[nr_mimes++] = mime;\n\t\t/* is another mime following? */\n\t\tif (ret==end )\n\t\t\tbreak;\n\t\t/* parse the mime separator ',' */\n\t\tif (*ret!=',' || ret+1==end) {\n\t\t\tLM_ERR(\"parse error between mimes at \"\n\t\t\t\t\"char <%x> (offset=%d) in <%.*s>!\\n\",\n\t\t\t\t*ret, (int)(ret-msg->accept->body.s),\n\t\t\t\tmsg->accept->body.len, msg->accept->body.s);\n\t\t\tgoto parse_error;\n\t\t}\n\t\t/* skip the ',' */\n\t\tret++;\n\t}\n\n\t/* copy and link the mime buffer into the message */\n\tmsg->accept->parsed = (void*)pkg_malloc((nr_mimes+1)*sizeof(int));\n\tif (msg->accept->parsed==0) {\n\t\tLM_ERR(\"no more pkg memory\\n\");\n\t\tgoto error;\n\t}\n\tmemcpy(msg->accept->parsed,mimes,nr_mimes*sizeof(int));\n\t/* make the buffer null terminated */\n\t((int*)msg->accept->parsed)[nr_mimes] = 0;\n\n\treturn 1;\n\nparse_error:\n\tset_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,\n\t\t\"error parsing ACCEPT header\");\n\tset_err_reply(400, \"bad headers\");\nerror:\n\treturn -1;\n}\n\nvoid free_contenttype(content_t ** con)\n{\n\n\tif (*con)\n\t{\n\t\tif((*con)->params)\n\t\t\tfree_params((*con)->params);\n\t\tpkg_free(*con);\n\t}\n\t*con = 0;\n}\n\nchar* convert_mime2string_CT(int contenttype)\n{\n\t#define SET_TYPE_PTRS(_type_) \\\n\t\tdo { \\\n\t\t\tsubtype_start = type_start + sizeof(_type_) - 1; \\\n\t\t\tmemcpy(type_start, _type_, sizeof(_type_) - 1); \\\n\t\t} while(0);\n\n\t#define SET_SUBTYPE_PTR(_subtype_) memcpy(subtype_start, _subtype_, sizeof(_subtype_))\n\n\t/* last 16 bits */\n\tint type = contenttype >> 16;\n\t/* only first 16 bits */\n\tint subtype = contenttype & (0xFF);\n\tchar* type_start;\n\tchar* subtype_start;\n\n\tmemset(str_contenttype, 0 , sizeof(str_contenttype));\n\ttype_start = str_contenttype;\n\n\tswitch (type) {\n\t\tcase TYPE_TEXT:\n\t\t\tSET_TYPE_PTRS(\"text/\");\n\t\t\tbreak;\n\t\tcase TYPE_MESSAGE:\n\t\t\tSET_TYPE_PTRS(\"message/\");\n\t\t\tbreak;\n\t\tcase TYPE_APPLICATION:\n\t\t\tSET_TYPE_PTRS(\"application/\");\n\t\t\tbreak;\n\t\tcase TYPE_MULTIPART:\n\t\t\tSET_TYPE_PTRS(\"multipart/\");\n\t\t\tbreak;\n\t\tcase TYPE_ALL:\n\t\t\tSET_TYPE_PTRS(\"*/\");\n\t\t\tbreak;\n\t\tcase TYPE_UNKNOWN:\n\t\t\tSET_TYPE_PTRS(\"unknown/\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"invalid type\\n\");\n\t\t\treturn 0;\n\t}\n\n\tswitch (subtype) {\n\t\tcase SUBTYPE_PLAIN:\n\t\t\tSET_SUBTYPE_PTR(\"plain\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_CPIM:\n\t\t\tSET_SUBTYPE_PTR(\"cpim\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_SDP:\n\t\t\tSET_SUBTYPE_PTR(\"sdp\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_CPLXML:\n\t\t\tSET_SUBTYPE_PTR(\"cplxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_PIDFXML:\n\t\t\tSET_SUBTYPE_PTR(\"pidfxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_RLMIXML:\n\t\t\tSET_SUBTYPE_PTR(\"rlmixml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_RELATED:\n\t\t\tSET_SUBTYPE_PTR(\"related\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_LPIDFXML:\n\t\t\tSET_SUBTYPE_PTR(\"lpidfxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_XPIDFXML:\n\t\t\tSET_SUBTYPE_PTR(\"xpidfxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_WATCHERINFOXML:\n\t\t\tSET_SUBTYPE_PTR(\"watcherinfoxml\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_EXTERNAL_BODY:\n\t\t\tSET_SUBTYPE_PTR(\"external_body\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_XML_MSRTC_PIDF:\n\t\t\tSET_SUBTYPE_PTR(\"xmlmsrtcpidf\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_SMS:\n\t\t\tSET_SUBTYPE_PTR(\"sms\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_MIXED:\n\t\t\tSET_SUBTYPE_PTR(\"mixed\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_ISUP:\n\t\t\tSET_SUBTYPE_PTR(\"isup\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_ALL:\n\t\t\tSET_SUBTYPE_PTR(\"*\");\n\t\t\tbreak;\n\t\tcase SUBTYPE_UNKNOWN:\n\t\t\tSET_SUBTYPE_PTR(\"unknown\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_ERR(\"invalid subtype\\n\");\n\t\t\treturn 0;\n\t}\n\n\treturn str_contenttype;\n\n#undef SET_TYPE_PTRS\n#undef SET_SUBTYPE_PTR\n}\n\n\n\n"], "filenames": ["parser/parse_content.c"], "buggy_code_start_loc": [244], "buggy_code_end_loc": [249], "fixing_code_start_loc": [244], "fixing_code_end_loc": [252], "type": "CWE-190", "message": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.9 and 3.2.6, a malformed SIP message containing a large _Content-Length_ value and a specially crafted Request-URI causes a segmentation fault in OpenSIPS. This issue occurs when a large amount of shared memory using the `-m` flag was allocated to OpenSIPS, such as 10 GB of RAM. On the test system, this issue occurred when shared memory was set to `2362` or higher. This issue is fixed in versions 3.1.9 and 3.2.6. The only workaround is to guarantee that the Content-Length value of input messages is never larger than `2147483647`.", "other": {"cve": {"id": "CVE-2023-28097", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-15T23:15:09.627", "lastModified": "2023-03-21T22:40:02.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.9 and 3.2.6, a malformed SIP message containing a large _Content-Length_ value and a specially crafted Request-URI causes a segmentation fault in OpenSIPS. This issue occurs when a large amount of shared memory using the `-m` flag was allocated to OpenSIPS, such as 10 GB of RAM. On the test system, this issue occurred when shared memory was set to `2362` or higher. This issue is fixed in versions 3.1.9 and 3.2.6. The only workaround is to guarantee that the Content-Length value of input messages is never larger than `2147483647`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.9", "matchCriteriaId": "F318FB66-A6E9-4A16-996B-DD76A8C64A6E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.6", "matchCriteriaId": "3C466525-94B6-4196-9CEA-CD72452FE22D"}]}]}], "references": [{"url": "https://github.com/OpenSIPS/opensips/commit/7cab422e2fc648f910abba34f3f0dbb3ae171ff5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-c6j5-f4h4-2xrq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenSIPS/opensips/commit/7cab422e2fc648f910abba34f3f0dbb3ae171ff5"}}