{"buggy_code": ["<?php\n\nnamespace SimpleSAML\\Utils;\n\n/**\n * A class for cryptography-related functions.\n *\n * @package SimpleSAMLphp\n */\nclass Crypto\n{\n\n    /**\n     * Decrypt data using AES-256-CBC and the key provided as a parameter.\n     *\n     * @param string $ciphertext The HMAC of the encrypted data, the IV used and the encrypted data, concatenated.\n     * @param string $secret The secret to use to decrypt the data.\n     *\n     * @return string The decrypted data.\n     * @throws \\InvalidArgumentException If $ciphertext is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @see \\SimpleSAML\\Utils\\Crypto::aesDecrypt()\n     */\n    private static function _aesDecrypt($ciphertext, $secret)\n    {\n        if (!is_string($ciphertext) || mb_strlen($ciphertext, '8bit') < 48) {\n            throw new \\InvalidArgumentException(\n                'Input parameter \"$ciphertext\" must be a string with more than 48 characters.'\n            );\n        }\n        if (!function_exists(\"openssl_decrypt\")) {\n            throw new \\SimpleSAML_Error_Exception(\"The openssl PHP module is not loaded.\");\n        }\n\n        // derive encryption and authentication keys from the secret\n        $key  = openssl_digest($secret, 'sha512');\n\n        $hmac = mb_substr($ciphertext, 0, 32, '8bit');\n        $iv   = mb_substr($ciphertext, 32, 16, '8bit');\n        $msg  = mb_substr($ciphertext, 48, mb_strlen($ciphertext, '8bit') - 48, '8bit');\n\n        // authenticate the ciphertext\n        if (self::secureCompare(hash_hmac('sha256', $iv.$msg, substr($key, 64, 64), true), $hmac)) {\n            $plaintext = openssl_decrypt(\n                $msg,\n                'AES-256-CBC',\n                substr($key, 0, 64),\n                defined('OPENSSL_RAW_DATA') ? OPENSSL_RAW_DATA : true,\n                $iv\n            );\n\n            if ($plaintext != false) {\n                return $plaintext;\n            }\n        }\n\n        throw new \\SimpleSAML_Error_Exception(\"Failed to decrypt ciphertext.\");\n    }\n\n\n    /**\n     * Decrypt data using AES-256-CBC and the system-wide secret salt as key.\n     *\n     * @param string $ciphertext The HMAC of the encrypted data, the IV used and the encrypted data, concatenated.\n     *\n     * @return string The decrypted data.\n     * @throws \\InvalidArgumentException If $ciphertext is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Jaime Perez, UNINETT AS <jaime.perez@uninett.no>\n     */\n    public static function aesDecrypt($ciphertext)\n    {\n        return self::_aesDecrypt($ciphertext, Config::getSecretSalt());\n    }\n\n\n    /**\n     * Encrypt data using AES-256-CBC and the key provided as a parameter.\n     *\n     * @param string $data The data to encrypt.\n     * @param string $secret The secret to use to encrypt the data.\n     *\n     * @return string An HMAC of the encrypted data, the IV and the encrypted data, concatenated.\n     * @throws \\InvalidArgumentException If $data is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @see \\SimpleSAML\\Utils\\Crypto::aesEncrypt()\n     */\n    private static function _aesEncrypt($data, $secret)\n    {\n        if (!is_string($data)) {\n            throw new \\InvalidArgumentException('Input parameter \"$data\" must be a string.');\n        }\n\n        if (!function_exists(\"openssl_encrypt\")) {\n            throw new \\SimpleSAML_Error_Exception('The openssl PHP module is not loaded.');\n        }\n\n        // derive encryption and authentication keys from the secret\n        $key = openssl_digest($secret, 'sha512');\n\n        // generate a random IV\n        $iv = openssl_random_pseudo_bytes(16);\n\n        // encrypt the message\n        $ciphertext = $iv.openssl_encrypt(\n            $data,\n            'AES-256-CBC',\n            substr($key, 0, 64),\n            defined('OPENSSL_RAW_DATA') ? OPENSSL_RAW_DATA : true,\n            $iv\n        );\n\n        if ($ciphertext === false) {\n            throw new \\SimpleSAML_Error_Exception(\"Failed to encrypt plaintext.\");\n        }\n\n        // return the ciphertext with proper authentication\n        return hash_hmac('sha256', $ciphertext, substr($key, 64, 64), true).$ciphertext;\n    }\n\n\n    /**\n     * Encrypt data using AES-256-CBC and the system-wide secret salt as key.\n     *\n     * @param string $data The data to encrypt.\n     *\n     * @return string An HMAC of the encrypted data, the IV and the encrypted data, concatenated.\n     * @throws \\InvalidArgumentException If $data is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Jaime Perez, UNINETT AS <jaime.perez@uninett.no>\n     */\n    public static function aesEncrypt($data)\n    {\n        return self::_aesEncrypt($data, Config::getSecretSalt());\n    }\n\n\n    /**\n     * Convert data from DER to PEM encoding.\n     *\n     * @param string $der Data encoded in DER format.\n     * @param string $type The type of data we are encoding, as expressed by the PEM header. Defaults to \"CERTIFICATE\".\n     * @return string The same data encoded in PEM format.\n     * @see RFC7648 for known types and PEM format specifics.\n     */\n    public static function der2pem($der, $type = 'CERTIFICATE')\n    {\n        return \"-----BEGIN \".$type.\"-----\\n\".\n               chunk_split(base64_encode($der), 64, \"\\n\").\n               \"-----END \".$type.\"-----\\n\";\n    }\n\n\n    /**\n     * Load a private key from metadata.\n     *\n     * This function loads a private key from a metadata array. It looks for the following elements:\n     * - 'privatekey': Name of a private key file in the cert-directory.\n     * - 'privatekey_pass': Password for the private key.\n     *\n     * It returns and array with the following elements:\n     * - 'PEM': Data for the private key, in PEM-format.\n     * - 'password': Password for the private key.\n     *\n     * @param \\SimpleSAML_Configuration $metadata The metadata array the private key should be loaded from.\n     * @param bool                      $required Whether the private key is required. If this is true, a\n     * missing key will cause an exception. Defaults to false.\n     * @param string                    $prefix The prefix which should be used when reading from the metadata\n     * array. Defaults to ''.\n     *\n     * @return array|NULL Extracted private key, or NULL if no private key is present.\n     * @throws \\InvalidArgumentException If $required is not boolean or $prefix is not a string.\n     * @throws \\SimpleSAML_Error_Exception If no private key is found in the metadata, or it was not possible to load\n     *     it.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Olav Morken, UNINETT AS <olav.morken@uninett.no>\n     */\n    public static function loadPrivateKey(\\SimpleSAML_Configuration $metadata, $required = false, $prefix = '')\n    {\n        if (!is_bool($required) || !is_string($prefix)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        $file = $metadata->getString($prefix.'privatekey', null);\n        if ($file === null) {\n            // no private key found\n            if ($required) {\n                throw new \\SimpleSAML_Error_Exception('No private key found in metadata.');\n            } else {\n                return null;\n            }\n        }\n\n        $file = Config::getCertPath($file);\n        $data = @file_get_contents($file);\n        if ($data === false) {\n            throw new \\SimpleSAML_Error_Exception('Unable to load private key from file \"'.$file.'\"');\n        }\n\n        $ret = array(\n            'PEM' => $data,\n        );\n\n        if ($metadata->hasValue($prefix.'privatekey_pass')) {\n            $ret['password'] = $metadata->getString($prefix.'privatekey_pass');\n        }\n\n        return $ret;\n    }\n\n\n    /**\n     * Get public key or certificate from metadata.\n     *\n     * This function implements a function to retrieve the public key or certificate from a metadata array.\n     *\n     * It will search for the following elements in the metadata:\n     * - 'certData': The certificate as a base64-encoded string.\n     * - 'certificate': A file with a certificate or public key in PEM-format.\n     * - 'certFingerprint': The fingerprint of the certificate. Can be a single fingerprint, or an array of multiple\n     * valid fingerprints. (deprecated)\n     *\n     * This function will return an array with these elements:\n     * - 'PEM': The public key/certificate in PEM-encoding.\n     * - 'certData': The certificate data, base64 encoded, on a single line. (Only present if this is a certificate.)\n     * - 'certFingerprint': Array of valid certificate fingerprints. (Deprecated. Only present if this is a\n     *   certificate.)\n     *\n     * @param \\SimpleSAML_Configuration $metadata The metadata.\n     * @param bool                      $required Whether the private key is required. If this is TRUE, a missing key\n     *     will cause an exception. Default is FALSE.\n     * @param string                    $prefix The prefix which should be used when reading from the metadata array.\n     *     Defaults to ''.\n     *\n     * @return array|NULL Public key or certificate data, or NULL if no public key or certificate was found.\n     * @throws \\InvalidArgumentException If $metadata is not an instance of \\SimpleSAML_Configuration, $required is not\n     *     boolean or $prefix is not a string.\n     * @throws \\SimpleSAML_Error_Exception If no private key is found in the metadata, or it was not possible to load\n     *     it.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Olav Morken, UNINETT AS <olav.morken@uninett.no>\n     * @author Lasse Birnbaum Jensen\n     */\n    public static function loadPublicKey(\\SimpleSAML_Configuration $metadata, $required = false, $prefix = '')\n    {\n        if (!is_bool($required) || !is_string($prefix)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        $keys = $metadata->getPublicKeys(null, false, $prefix);\n        if ($keys !== null) {\n            foreach ($keys as $key) {\n                if ($key['type'] !== 'X509Certificate') {\n                    continue;\n                }\n                if ($key['signing'] !== true) {\n                    continue;\n                }\n                $certData = $key['X509Certificate'];\n                $pem = \"-----BEGIN CERTIFICATE-----\\n\".\n                    chunk_split($certData, 64).\n                    \"-----END CERTIFICATE-----\\n\";\n                $certFingerprint = strtolower(sha1(base64_decode($certData)));\n\n                return array(\n                    'certData'        => $certData,\n                    'PEM'             => $pem,\n                    'certFingerprint' => array($certFingerprint),\n                );\n            }\n            // no valid key found\n        } elseif ($metadata->hasValue($prefix.'certFingerprint')) {\n            // we only have a fingerprint available\n            $fps = $metadata->getArrayizeString($prefix.'certFingerprint');\n\n            // normalize fingerprint(s) - lowercase and no colons\n            foreach ($fps as &$fp) {\n                assert('is_string($fp)');\n                $fp = strtolower(str_replace(':', '', $fp));\n            }\n\n            /*\n             * We can't build a full certificate from a fingerprint, and may as well return an array with only the\n             * fingerprint(s) immediately.\n             */\n            return array('certFingerprint' => $fps);\n        }\n\n        // no public key/certificate available\n        if ($required) {\n            throw new \\SimpleSAML_Error_Exception('No public key / certificate found in metadata.');\n        } else {\n            return null;\n        }\n    }\n\n\n    /**\n     * Convert from PEM to DER encoding.\n     *\n     * @param string $pem Data encoded in PEM format.\n     * @return string The same data encoded in DER format.\n     * @throws \\InvalidArgumentException If $pem is not encoded in PEM format.\n     * @see RFC7648 for PEM format specifics.\n     */\n    public static function pem2der($pem)\n    {\n        $pem   = trim($pem);\n        $begin = \"-----BEGIN \";\n        $end   = \"-----END \";\n        $lines = explode(\"\\n\", $pem);\n        $last  = count($lines) - 1;\n\n        if (strpos($lines[0], $begin) !== 0) {\n            throw new \\InvalidArgumentException(\"pem2der: input is not encoded in PEM format.\");\n        }\n        unset($lines[0]);\n        if (strpos($lines[$last], $end) !== 0) {\n            throw new \\InvalidArgumentException(\"pem2der: input is not encoded in PEM format.\");\n        }\n        unset($lines[$last]);\n\n        return base64_decode(implode($lines));\n    }\n\n\n    /**\n     * This function hashes a password with a given algorithm.\n     *\n     * @param string $password The password to hash.\n     * @param string $algorithm The hashing algorithm, uppercase, optionally prepended with 'S' (salted). See\n     *     hash_algos() for a complete list of hashing algorithms.\n     * @param string $salt An optional salt to use.\n     *\n     * @return string The hashed password.\n     * @throws \\InvalidArgumentException If the input parameters are not strings.\n     * @throws \\SimpleSAML_Error_Exception If the algorithm specified is not supported.\n     *\n     * @see hash_algos()\n     *\n     * @author Dyonisius Visser, TERENA <visser@terena.org>\n     * @author Jaime Perez, UNINETT AS <jaime.perez@uninett.no>\n     */\n    public static function pwHash($password, $algorithm, $salt = null)\n    {\n        if (!is_string($algorithm) || !is_string($password)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        // hash w/o salt\n        if (in_array(strtolower($algorithm), hash_algos())) {\n            $alg_str = '{'.str_replace('SHA1', 'SHA', $algorithm).'}'; // LDAP compatibility\n            $hash = hash(strtolower($algorithm), $password, true);\n            return $alg_str.base64_encode($hash);\n        }\n\n        // hash w/ salt\n        if ($salt === null) { // no salt provided, generate one\n            // default 8 byte salt, but 4 byte for LDAP SHA1 hashes\n            $bytes = ($algorithm == 'SSHA1') ? 4 : 8;\n            $salt = openssl_random_pseudo_bytes($bytes);\n        }\n\n        if ($algorithm[0] == 'S' && in_array(substr(strtolower($algorithm), 1), hash_algos())) {\n            $alg = substr(strtolower($algorithm), 1); // 'sha256' etc\n            $alg_str = '{'.str_replace('SSHA1', 'SSHA', $algorithm).'}'; // LDAP compatibility\n            $hash = hash($alg, $password.$salt, true);\n            return $alg_str.base64_encode($hash.$salt);\n        }\n\n        throw new \\SimpleSAML_Error_Exception('Hashing algorithm \\''.strtolower($algorithm).'\\' is not supported');\n    }\n\n\n    /**\n     * Compare two strings securely.\n     *\n     * This method checks if two strings are equal in constant time, avoiding timing attacks. Use it every time we need\n     * to compare a string with a secret that shouldn't be leaked, i.e. when verifying passwords, one-time codes, etc.\n     *\n     * @param string $known A known string.\n     * @param string $user A user-provided string to compare with the known string.\n     *\n     * @return bool True if both strings are equal, false otherwise.\n     */\n    public static function secureCompare($known, $user)\n    {\n        if (function_exists('hash_equals')) {\n            // use hash_equals() if available (PHP >= 5.6)\n            return hash_equals($known, $user);\n        }\n\n        // compare manually in constant time\n        $len = mb_strlen($known, '8bit'); // see mbstring.func_overload\n        if ($len !== mb_strlen($user, '8bit')) {\n            return false; // length differs\n        }\n        $diff = 0;\n        for ($i = 0; $i < $len; ++$i) {\n            $diff |= $known[$i] ^ $user[$i];\n        }\n        // if all the bytes in $a and $b are identical, $diff should be equal to 0\n        return $diff === 0;\n    }\n\n\n    /**\n     * This function checks if a password is valid\n     *\n     * @param string $hash The password as it appears in password file, optionally prepended with algorithm.\n     * @param string $password The password to check in clear.\n     *\n     * @return boolean True if the hash corresponds with the given password, false otherwise.\n     * @throws \\InvalidArgumentException If the input parameters are not strings.\n     * @throws \\SimpleSAML_Error_Exception If the algorithm specified is not supported.\n     *\n     * @author Dyonisius Visser, TERENA <visser@terena.org>\n     */\n    public static function pwValid($hash, $password)\n    {\n        if (!is_string($hash) || !is_string($password)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        // match algorithm string (e.g. '{SSHA256}', '{MD5}')\n        if (preg_match('/^{(.*?)}(.*)$/', $hash, $matches)) {\n            // LDAP compatibility\n            $alg = preg_replace('/^(S?SHA)$/', '${1}1', $matches[1]);\n\n            // hash w/o salt\n            if (in_array(strtolower($alg), hash_algos())) {\n                return self::secureCompare($hash, self::pwHash($password, $alg));\n            }\n\n            // hash w/ salt\n            if ($alg[0] === 'S' && in_array(substr(strtolower($alg), 1), hash_algos())) {\n                $php_alg = substr(strtolower($alg), 1);\n\n                // get hash length of this algorithm to learn how long the salt is\n                $hash_length = strlen(hash($php_alg, '', true));\n                $salt = substr(base64_decode($matches[2]), $hash_length);\n                return self::secureCompare($hash, self::pwHash($password, $alg, $salt));\n            }\n        } else {\n            return $hash === $password;\n        }\n\n        throw new \\SimpleSAML_Error_Exception('Hashing algorithm \\''.strtolower($alg).'\\' is not supported');\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace SimpleSAML\\Utils;\n\n/**\n * A class for cryptography-related functions.\n *\n * @package SimpleSAMLphp\n */\nclass Crypto\n{\n\n    /**\n     * Decrypt data using AES-256-CBC and the key provided as a parameter.\n     *\n     * @param string $ciphertext The HMAC of the encrypted data, the IV used and the encrypted data, concatenated.\n     * @param string $secret The secret to use to decrypt the data.\n     *\n     * @return string The decrypted data.\n     * @throws \\InvalidArgumentException If $ciphertext is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @see \\SimpleSAML\\Utils\\Crypto::aesDecrypt()\n     */\n    private static function _aesDecrypt($ciphertext, $secret)\n    {\n        if (!is_string($ciphertext) || mb_strlen($ciphertext, '8bit') < 48) {\n            throw new \\InvalidArgumentException(\n                'Input parameter \"$ciphertext\" must be a string with more than 48 characters.'\n            );\n        }\n        if (!function_exists(\"openssl_decrypt\")) {\n            throw new \\SimpleSAML_Error_Exception(\"The openssl PHP module is not loaded.\");\n        }\n\n        // derive encryption and authentication keys from the secret\n        $key  = openssl_digest($secret, 'sha512');\n\n        $hmac = mb_substr($ciphertext, 0, 32, '8bit');\n        $iv   = mb_substr($ciphertext, 32, 16, '8bit');\n        $msg  = mb_substr($ciphertext, 48, mb_strlen($ciphertext, '8bit') - 48, '8bit');\n\n        // authenticate the ciphertext\n        if (self::secureCompare(hash_hmac('sha256', $iv.$msg, substr($key, 64, 64), true), $hmac)) {\n            $plaintext = openssl_decrypt(\n                $msg,\n                'AES-256-CBC',\n                substr($key, 0, 64),\n                defined('OPENSSL_RAW_DATA') ? OPENSSL_RAW_DATA : true,\n                $iv\n            );\n\n            if ($plaintext != false) {\n                return $plaintext;\n            }\n        }\n\n        throw new \\SimpleSAML_Error_Exception(\"Failed to decrypt ciphertext.\");\n    }\n\n\n    /**\n     * Decrypt data using AES-256-CBC and the system-wide secret salt as key.\n     *\n     * @param string $ciphertext The HMAC of the encrypted data, the IV used and the encrypted data, concatenated.\n     *\n     * @return string The decrypted data.\n     * @throws \\InvalidArgumentException If $ciphertext is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Jaime Perez, UNINETT AS <jaime.perez@uninett.no>\n     */\n    public static function aesDecrypt($ciphertext)\n    {\n        return self::_aesDecrypt($ciphertext, Config::getSecretSalt());\n    }\n\n\n    /**\n     * Encrypt data using AES-256-CBC and the key provided as a parameter.\n     *\n     * @param string $data The data to encrypt.\n     * @param string $secret The secret to use to encrypt the data.\n     *\n     * @return string An HMAC of the encrypted data, the IV and the encrypted data, concatenated.\n     * @throws \\InvalidArgumentException If $data is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @see \\SimpleSAML\\Utils\\Crypto::aesEncrypt()\n     */\n    private static function _aesEncrypt($data, $secret)\n    {\n        if (!is_string($data)) {\n            throw new \\InvalidArgumentException('Input parameter \"$data\" must be a string.');\n        }\n\n        if (!function_exists(\"openssl_encrypt\")) {\n            throw new \\SimpleSAML_Error_Exception('The openssl PHP module is not loaded.');\n        }\n\n        // derive encryption and authentication keys from the secret\n        $key = openssl_digest($secret, 'sha512');\n\n        // generate a random IV\n        $iv = openssl_random_pseudo_bytes(16);\n\n        // encrypt the message\n        $ciphertext = $iv.openssl_encrypt(\n            $data,\n            'AES-256-CBC',\n            substr($key, 0, 64),\n            defined('OPENSSL_RAW_DATA') ? OPENSSL_RAW_DATA : true,\n            $iv\n        );\n\n        if ($ciphertext === false) {\n            throw new \\SimpleSAML_Error_Exception(\"Failed to encrypt plaintext.\");\n        }\n\n        // return the ciphertext with proper authentication\n        return hash_hmac('sha256', $ciphertext, substr($key, 64, 64), true).$ciphertext;\n    }\n\n\n    /**\n     * Encrypt data using AES-256-CBC and the system-wide secret salt as key.\n     *\n     * @param string $data The data to encrypt.\n     *\n     * @return string An HMAC of the encrypted data, the IV and the encrypted data, concatenated.\n     * @throws \\InvalidArgumentException If $data is not a string.\n     * @throws \\SimpleSAML_Error_Exception If the openssl module is not loaded.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Jaime Perez, UNINETT AS <jaime.perez@uninett.no>\n     */\n    public static function aesEncrypt($data)\n    {\n        return self::_aesEncrypt($data, Config::getSecretSalt());\n    }\n\n\n    /**\n     * Convert data from DER to PEM encoding.\n     *\n     * @param string $der Data encoded in DER format.\n     * @param string $type The type of data we are encoding, as expressed by the PEM header. Defaults to \"CERTIFICATE\".\n     * @return string The same data encoded in PEM format.\n     * @see RFC7648 for known types and PEM format specifics.\n     */\n    public static function der2pem($der, $type = 'CERTIFICATE')\n    {\n        return \"-----BEGIN \".$type.\"-----\\n\".\n               chunk_split(base64_encode($der), 64, \"\\n\").\n               \"-----END \".$type.\"-----\\n\";\n    }\n\n\n    /**\n     * Load a private key from metadata.\n     *\n     * This function loads a private key from a metadata array. It looks for the following elements:\n     * - 'privatekey': Name of a private key file in the cert-directory.\n     * - 'privatekey_pass': Password for the private key.\n     *\n     * It returns and array with the following elements:\n     * - 'PEM': Data for the private key, in PEM-format.\n     * - 'password': Password for the private key.\n     *\n     * @param \\SimpleSAML_Configuration $metadata The metadata array the private key should be loaded from.\n     * @param bool                      $required Whether the private key is required. If this is true, a\n     * missing key will cause an exception. Defaults to false.\n     * @param string                    $prefix The prefix which should be used when reading from the metadata\n     * array. Defaults to ''.\n     *\n     * @return array|NULL Extracted private key, or NULL if no private key is present.\n     * @throws \\InvalidArgumentException If $required is not boolean or $prefix is not a string.\n     * @throws \\SimpleSAML_Error_Exception If no private key is found in the metadata, or it was not possible to load\n     *     it.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Olav Morken, UNINETT AS <olav.morken@uninett.no>\n     */\n    public static function loadPrivateKey(\\SimpleSAML_Configuration $metadata, $required = false, $prefix = '')\n    {\n        if (!is_bool($required) || !is_string($prefix)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        $file = $metadata->getString($prefix.'privatekey', null);\n        if ($file === null) {\n            // no private key found\n            if ($required) {\n                throw new \\SimpleSAML_Error_Exception('No private key found in metadata.');\n            } else {\n                return null;\n            }\n        }\n\n        $file = Config::getCertPath($file);\n        $data = @file_get_contents($file);\n        if ($data === false) {\n            throw new \\SimpleSAML_Error_Exception('Unable to load private key from file \"'.$file.'\"');\n        }\n\n        $ret = array(\n            'PEM' => $data,\n        );\n\n        if ($metadata->hasValue($prefix.'privatekey_pass')) {\n            $ret['password'] = $metadata->getString($prefix.'privatekey_pass');\n        }\n\n        return $ret;\n    }\n\n\n    /**\n     * Get public key or certificate from metadata.\n     *\n     * This function implements a function to retrieve the public key or certificate from a metadata array.\n     *\n     * It will search for the following elements in the metadata:\n     * - 'certData': The certificate as a base64-encoded string.\n     * - 'certificate': A file with a certificate or public key in PEM-format.\n     * - 'certFingerprint': The fingerprint of the certificate. Can be a single fingerprint, or an array of multiple\n     * valid fingerprints. (deprecated)\n     *\n     * This function will return an array with these elements:\n     * - 'PEM': The public key/certificate in PEM-encoding.\n     * - 'certData': The certificate data, base64 encoded, on a single line. (Only present if this is a certificate.)\n     * - 'certFingerprint': Array of valid certificate fingerprints. (Deprecated. Only present if this is a\n     *   certificate.)\n     *\n     * @param \\SimpleSAML_Configuration $metadata The metadata.\n     * @param bool                      $required Whether the private key is required. If this is TRUE, a missing key\n     *     will cause an exception. Default is FALSE.\n     * @param string                    $prefix The prefix which should be used when reading from the metadata array.\n     *     Defaults to ''.\n     *\n     * @return array|NULL Public key or certificate data, or NULL if no public key or certificate was found.\n     * @throws \\InvalidArgumentException If $metadata is not an instance of \\SimpleSAML_Configuration, $required is not\n     *     boolean or $prefix is not a string.\n     * @throws \\SimpleSAML_Error_Exception If no private key is found in the metadata, or it was not possible to load\n     *     it.\n     *\n     * @author Andreas Solberg, UNINETT AS <andreas.solberg@uninett.no>\n     * @author Olav Morken, UNINETT AS <olav.morken@uninett.no>\n     * @author Lasse Birnbaum Jensen\n     */\n    public static function loadPublicKey(\\SimpleSAML_Configuration $metadata, $required = false, $prefix = '')\n    {\n        if (!is_bool($required) || !is_string($prefix)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        $keys = $metadata->getPublicKeys(null, false, $prefix);\n        if ($keys !== null) {\n            foreach ($keys as $key) {\n                if ($key['type'] !== 'X509Certificate') {\n                    continue;\n                }\n                if ($key['signing'] !== true) {\n                    continue;\n                }\n                $certData = $key['X509Certificate'];\n                $pem = \"-----BEGIN CERTIFICATE-----\\n\".\n                    chunk_split($certData, 64).\n                    \"-----END CERTIFICATE-----\\n\";\n                $certFingerprint = strtolower(sha1(base64_decode($certData)));\n\n                return array(\n                    'certData'        => $certData,\n                    'PEM'             => $pem,\n                    'certFingerprint' => array($certFingerprint),\n                );\n            }\n            // no valid key found\n        } elseif ($metadata->hasValue($prefix.'certFingerprint')) {\n            // we only have a fingerprint available\n            $fps = $metadata->getArrayizeString($prefix.'certFingerprint');\n\n            // normalize fingerprint(s) - lowercase and no colons\n            foreach ($fps as &$fp) {\n                assert('is_string($fp)');\n                $fp = strtolower(str_replace(':', '', $fp));\n            }\n\n            /*\n             * We can't build a full certificate from a fingerprint, and may as well return an array with only the\n             * fingerprint(s) immediately.\n             */\n            return array('certFingerprint' => $fps);\n        }\n\n        // no public key/certificate available\n        if ($required) {\n            throw new \\SimpleSAML_Error_Exception('No public key / certificate found in metadata.');\n        } else {\n            return null;\n        }\n    }\n\n\n    /**\n     * Convert from PEM to DER encoding.\n     *\n     * @param string $pem Data encoded in PEM format.\n     * @return string The same data encoded in DER format.\n     * @throws \\InvalidArgumentException If $pem is not encoded in PEM format.\n     * @see RFC7648 for PEM format specifics.\n     */\n    public static function pem2der($pem)\n    {\n        $pem   = trim($pem);\n        $begin = \"-----BEGIN \";\n        $end   = \"-----END \";\n        $lines = explode(\"\\n\", $pem);\n        $last  = count($lines) - 1;\n\n        if (strpos($lines[0], $begin) !== 0) {\n            throw new \\InvalidArgumentException(\"pem2der: input is not encoded in PEM format.\");\n        }\n        unset($lines[0]);\n        if (strpos($lines[$last], $end) !== 0) {\n            throw new \\InvalidArgumentException(\"pem2der: input is not encoded in PEM format.\");\n        }\n        unset($lines[$last]);\n\n        return base64_decode(implode($lines));\n    }\n\n\n    /**\n     * This function hashes a password with a given algorithm.\n     *\n     * @param string $password The password to hash.\n     * @param string $algorithm The hashing algorithm, uppercase, optionally prepended with 'S' (salted). See\n     *     hash_algos() for a complete list of hashing algorithms.\n     * @param string $salt An optional salt to use.\n     *\n     * @return string The hashed password.\n     * @throws \\InvalidArgumentException If the input parameters are not strings.\n     * @throws \\SimpleSAML_Error_Exception If the algorithm specified is not supported.\n     *\n     * @see hash_algos()\n     *\n     * @author Dyonisius Visser, TERENA <visser@terena.org>\n     * @author Jaime Perez, UNINETT AS <jaime.perez@uninett.no>\n     */\n    public static function pwHash($password, $algorithm, $salt = null)\n    {\n        if (!is_string($algorithm) || !is_string($password)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        // hash w/o salt\n        if (in_array(strtolower($algorithm), hash_algos())) {\n            $alg_str = '{'.str_replace('SHA1', 'SHA', $algorithm).'}'; // LDAP compatibility\n            $hash = hash(strtolower($algorithm), $password, true);\n            return $alg_str.base64_encode($hash);\n        }\n\n        // hash w/ salt\n        if ($salt === null) { // no salt provided, generate one\n            // default 8 byte salt, but 4 byte for LDAP SHA1 hashes\n            $bytes = ($algorithm == 'SSHA1') ? 4 : 8;\n            $salt = openssl_random_pseudo_bytes($bytes);\n        }\n\n        if ($algorithm[0] == 'S' && in_array(substr(strtolower($algorithm), 1), hash_algos())) {\n            $alg = substr(strtolower($algorithm), 1); // 'sha256' etc\n            $alg_str = '{'.str_replace('SSHA1', 'SSHA', $algorithm).'}'; // LDAP compatibility\n            $hash = hash($alg, $password.$salt, true);\n            return $alg_str.base64_encode($hash.$salt);\n        }\n\n        throw new \\SimpleSAML_Error_Exception('Hashing algorithm \\''.strtolower($algorithm).'\\' is not supported');\n    }\n\n\n    /**\n     * Compare two strings securely.\n     *\n     * This method checks if two strings are equal in constant time, avoiding timing attacks. Use it every time we need\n     * to compare a string with a secret that shouldn't be leaked, i.e. when verifying passwords, one-time codes, etc.\n     *\n     * @param string $known A known string.\n     * @param string $user A user-provided string to compare with the known string.\n     *\n     * @return bool True if both strings are equal, false otherwise.\n     */\n    public static function secureCompare($known, $user)\n    {\n        if (function_exists('hash_equals')) {\n            // use hash_equals() if available (PHP >= 5.6)\n            return hash_equals($known, $user);\n        }\n\n        // compare manually in constant time\n        $len = mb_strlen($known, '8bit'); // see mbstring.func_overload\n        if ($len !== mb_strlen($user, '8bit')) {\n            return false; // length differs\n        }\n        $diff = 0;\n        for ($i = 0; $i < $len; $i++) {\n            $diff |= ord($known[$i]) ^ ord($user[$i]);\n        }\n        // if all the bytes in $a and $b are identical, $diff should be equal to 0\n        return $diff === 0;\n    }\n\n\n    /**\n     * This function checks if a password is valid\n     *\n     * @param string $hash The password as it appears in password file, optionally prepended with algorithm.\n     * @param string $password The password to check in clear.\n     *\n     * @return boolean True if the hash corresponds with the given password, false otherwise.\n     * @throws \\InvalidArgumentException If the input parameters are not strings.\n     * @throws \\SimpleSAML_Error_Exception If the algorithm specified is not supported.\n     *\n     * @author Dyonisius Visser, TERENA <visser@terena.org>\n     */\n    public static function pwValid($hash, $password)\n    {\n        if (!is_string($hash) || !is_string($password)) {\n            throw new \\InvalidArgumentException('Invalid input parameters.');\n        }\n\n        // match algorithm string (e.g. '{SSHA256}', '{MD5}')\n        if (preg_match('/^{(.*?)}(.*)$/', $hash, $matches)) {\n            // LDAP compatibility\n            $alg = preg_replace('/^(S?SHA)$/', '${1}1', $matches[1]);\n\n            // hash w/o salt\n            if (in_array(strtolower($alg), hash_algos())) {\n                return self::secureCompare($hash, self::pwHash($password, $alg));\n            }\n\n            // hash w/ salt\n            if ($alg[0] === 'S' && in_array(substr(strtolower($alg), 1), hash_algos())) {\n                $php_alg = substr(strtolower($alg), 1);\n\n                // get hash length of this algorithm to learn how long the salt is\n                $hash_length = strlen(hash($php_alg, '', true));\n                $salt = substr(base64_decode($matches[2]), $hash_length);\n                return self::secureCompare($hash, self::pwHash($password, $alg, $salt));\n            }\n        } else {\n            return $hash === $password;\n        }\n\n        throw new \\SimpleSAML_Error_Exception('Hashing algorithm \\''.strtolower($alg).'\\' is not supported');\n    }\n}\n"], "filenames": ["lib/SimpleSAML/Utils/Crypto.php"], "buggy_code_start_loc": [407], "buggy_code_end_loc": [409], "fixing_code_start_loc": [407], "fixing_code_end_loc": [409], "type": "CWE-384", "message": "The secureCompare method in lib/SimpleSAML/Utils/Crypto.php in SimpleSAMLphp 1.14.13 and earlier, when used with PHP before 5.6, allows attackers to conduct session fixation attacks or possibly bypass authentication by leveraging missing character conversions before an XOR operation.", "other": {"cve": {"id": "CVE-2017-12868", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-01T13:29:00.240", "lastModified": "2018-07-01T01:29:01.317", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The secureCompare method in lib/SimpleSAML/Utils/Crypto.php in SimpleSAMLphp 1.14.13 and earlier, when used with PHP before 5.6, allows attackers to conduct session fixation attacks or possibly bypass authentication by leveraging missing character conversions before an XOR operation."}, {"lang": "es", "value": "El m\u00e9todo secureCompare en lib/SimpleSAML/Utils/Crypto.php en SimpleSAMLphp 1.14.13 y anteriores, al usarse con PHP en versiones anteriores a la 5.6, permite que los atacantes lleven a cabo ataques de fijaci\u00f3n de sesi\u00f3n o que, posiblemente, omitan la autenticaci\u00f3n aprovechando las conversiones de caracteres que faltan antes de una operaci\u00f3n XOR."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simplesamlphp:simplesamlphp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.14.13", "matchCriteriaId": "AA1268D7-6B0D-4BE5-9916-BE2860E66710"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.5.38", "matchCriteriaId": "44B09073-783B-4ADE-A5B8-DA6F93DBA46F"}]}]}], "references": [{"url": "https://github.com/simplesamlphp/simplesamlphp/commit/4bc629658e7b7d17c9ac3fe0da7dc5df71f1b85e", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00007.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2018/06/msg00017.html", "source": "cve@mitre.org"}, {"url": "https://simplesamlphp.org/security/201705-01", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/simplesamlphp/simplesamlphp/commit/4bc629658e7b7d17c9ac3fe0da7dc5df71f1b85e"}}