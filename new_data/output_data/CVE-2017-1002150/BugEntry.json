{"buggy_code": ["# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2008-2012  Red Hat, Inc.\n# Copyright (C) 2008  Ricky Zhou\n# This file is part of python-fedora\n#\n# python-fedora is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# python-fedora is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with python-fedora; if not, see <http://www.gnu.org/licenses/>\n#\n'''\nMiscellaneous functions of use on a TurboGears Server\n\n.. versionchanged:: 0.3.14\n   Save the original turbogears.url function as :func:`fedora.tg.util.tg_url`\n\n.. versionchanged:: 0.3.17\n   Renamed from fedora.tg.util\n\n.. versionchanged:: 0.3.25\n   Renamed from fedora.tg.tg1utils\n\n.. moduleauthor:: Toshio Kuratomi <tkuratom@redhat.com>\n.. moduleauthor:: Ricky Zhou <ricky@fedoraproject.org>\n'''\nfrom itertools import chain\nimport cgi\nimport os\n\nimport cherrypy\nfrom cherrypy import request\nfrom decorator import decorator\nimport pkg_resources\nimport turbogears\nfrom turbogears import flash, redirect, config, identity\nimport turbogears.util as tg_util\nfrom turbogears.controllers import check_app_root\nfrom turbogears.identity.exceptions import RequestRequiredException\nimport six\nfrom six.moves.urllib.parse import urlencode, urlparse, urlunparse\n\n\n# Save this for people who need the original url() function\ntg_url = turbogears.url\n\n\ndef add_custom_stdvars(new_vars):\n    return new_vars.update({'fedora_template': fedora_template})\n\n\ndef url(tgpath, tgparams=None, **kwargs):\n    '''Computes URLs.\n\n    This is a replacement for :func:`turbogears.controllers.url` (aka\n    :func:`tg.url` in the template).  In addition to the functionality that\n    :func:`tg.url` provides, it adds a token to prevent :term:`CSRF` attacks.\n\n    :arg tgpath:  a list or a string. If the path is absolute (starts\n        with a \"/\"), the :attr:`server.webpath`, :envvar:`SCRIPT_NAME` and\n        the approot of the application are prepended to the path. In order for\n        the approot to be detected properly, the root object should extend\n        :class:`turbogears.controllers.RootController`.\n    :kwarg tgparams: See param: ``kwargs``\n    :kwarg kwargs: Query parameters for the URL can be passed in as a\n        dictionary in the second argument *or* as keyword parameters.\n        Values which are a list or a tuple are used to create multiple\n        key-value pairs.\n    :returns: The changed path\n\n    .. versionadded:: 0.3.10\n       Modified from turbogears.controllers.url for :ref:`CSRF-Protection`\n    '''\n    if not isinstance(tgpath, six.string_types):\n        tgpath = '/'.join(list(tgpath))\n    if tgpath.startswith('/'):\n        webpath = (config.get('server.webpath') or '').rstrip('/')\n        if tg_util.request_available():\n            check_app_root()\n            tgpath = request.app_root + tgpath\n            try:\n                webpath += request.wsgi_environ['SCRIPT_NAME'].rstrip('/')\n            except (AttributeError, KeyError):  # pylint: disable-msg=W0704\n                # :W0704: Lack of wsgi environ is fine... we still have\n                # server.webpath\n                pass\n        tgpath = webpath + tgpath\n    if tgparams is None:\n        tgparams = kwargs\n    else:\n        try:\n            tgparams = tgparams.copy()\n            tgparams.update(kwargs)\n        except AttributeError:\n            raise TypeError(\n                'url() expects a dictionary for query parameters')\n    args = []\n    # Add the _csrf_token\n    try:\n        if identity.current.csrf_token:\n            tgparams.update({'_csrf_token': identity.current.csrf_token})\n    except RequestRequiredException:  # pylint: disable-msg=W0704\n        # :W0704: If we are outside of a request (called from non-controller\n        # methods/ templates) just don't set the _csrf_token.\n        pass\n\n    # Check for query params in the current url\n    query_params = six.iteritems(tgparams)\n    scheme, netloc, path, params, query_s, fragment = urlparse(tgpath)\n    if query_s:\n        query_params = chain((p for p in cgi.parse_qsl(query_s) if p[0] !=\n                              '_csrf_token'), query_params)\n\n    for key, value in query_params:\n        if value is None:\n            continue\n        if isinstance(value, (list, tuple)):\n            pairs = [(key, v) for v in value]\n        else:\n            pairs = [(key, value)]\n        for key, value in pairs:\n            if value is None:\n                continue\n            if isinstance(value, unicode):\n                value = value.encode('utf8')\n            args.append((key, str(value)))\n    query_string = urlencode(args, True)\n    tgpath = urlunparse((scheme, netloc, path, params, query_string, fragment))\n    return tgpath\n\n\n# this is taken from turbogears 1.1 branch\ndef _get_server_name():\n    \"\"\"Return name of the server this application runs on.\n\n    Respects 'Host' and 'X-Forwarded-Host' header.\n\n    See the docstring of the 'absolute_url' function for more information.\n\n    .. note:: This comes from turbogears 1.1 branch.  It is only needed for\n        _tg_absolute_url().  If we find that turbogears.get_server_name()\n        exists, we replace this function with that one.\n    \"\"\"\n    get = config.get\n    h = request.headers\n    host = get('tg.url_domain') or h.get('X-Forwarded-Host', h.get('Host'))\n    if not host:\n        host = '%s:%s' % (get('server.socket_host', 'localhost'),\n                          get('server.socket_port', 8080))\n    return host\n\n\n# this is taken from turbogears 1.1 branch\ndef tg_absolute_url(tgpath='/', params=None, **kw):\n    \"\"\"Return absolute URL (including schema and host to this server).\n\n    Tries to account for 'Host' header and reverse proxying\n    ('X-Forwarded-Host').\n\n    The host name is determined this way:\n\n    * If the config setting 'tg.url_domain' is set and non-null, use this\n      value.\n    * Else, if the 'base_url_filter.use_x_forwarded_host' config setting is\n      True, use the value from the 'Host' or 'X-Forwarded-Host' request header.\n    * Else, if config setting 'base_url_filter.on' is True and\n      'base_url_filter.base_url' is non-null, use its value for the host AND\n      scheme part of the URL.\n    * As a last fallback, use the value of 'server.socket_host' and\n      'server.socket_port' config settings (defaults to 'localhost:8080').\n\n    The URL scheme ('http' or 'http') used is determined in the following way:\n\n    * If 'base_url_filter.base_url' is used, use the scheme from this URL.\n    * If there is a 'X-Use-SSL' request header, use 'https'.\n    * Else, if the config setting 'tg.url_scheme' is set, use its value.\n    * Else, use the value of 'cherrypy.request.scheme'.\n\n    .. note:: This comes from turbogears 1.1 branch with one change: we\n        call tg_url() rather than turbogears.url() so that it never adds the\n        csrf_token\n\n    .. versionadded:: 0.3.19\n       Modified from turbogears.absolute_url() for :ref:`CSRF-Protection`\n    \"\"\"\n    get = config.get\n    use_xfh = get('base_url_filter.use_x_forwarded_host', False)\n    if request.headers.get('X-Use-SSL'):\n        scheme = 'https'\n    else:\n        scheme = get('tg.url_scheme')\n    if not scheme:\n        scheme = request.scheme\n    base_url = '%s://%s' % (scheme, _get_server_name())\n    if get('base_url_filter.on', False) and not use_xfh:\n        base_url = get('base_url_filter.base_url').rstrip('/')\n    return '%s%s' % (base_url, tg_url(tgpath, params, **kw))\n\n\ndef absolute_url(tgpath='/', params=None, **kw):\n    \"\"\"Return absolute URL (including schema and host to this server).\n\n    Tries to account for 'Host' header and reverse proxying\n    ('X-Forwarded-Host').\n\n    The host name is determined this way:\n\n    * If the config setting 'tg.url_domain' is set and non-null, use this\n      value.\n    * Else, if the 'base_url_filter.use_x_forwarded_host' config setting is\n      True, use the value from the 'Host' or 'X-Forwarded-Host' request header.\n    * Else, if config setting 'base_url_filter.on' is True and\n      'base_url_filter.base_url' is non-null, use its value for the host AND\n      scheme part of the URL.\n    * As a last fallback, use the value of 'server.socket_host' and\n      'server.socket_port' config settings (defaults to 'localhost:8080').\n\n    The URL scheme ('http' or 'http') used is determined in the following way:\n\n    * If 'base_url_filter.base_url' is used, use the scheme from this URL.\n    * If there is a 'X-Use-SSL' request header, use 'https'.\n    * Else, if the config setting 'tg.url_scheme' is set, use its value.\n    * Else, use the value of 'cherrypy.request.scheme'.\n\n    .. versionadded:: 0.3.19\n       Modified from turbogears.absolute_url() for :ref:`CSRF-Protection`\n    \"\"\"\n    return url(tg_absolute_url(tgpath, params, **kw))\n\n\ndef enable_csrf():\n    '''A startup function to setup :ref:`CSRF-Protection`.\n\n    This should be run at application startup.  Code like the following in the\n    start-APP script or the method in :file:`commands.py` that starts it::\n\n        from turbogears import startup\n        from fedora.tg.util import enable_csrf\n        startup.call_on_startup.append(enable_csrf)\n\n    If we can get the :ref:`CSRF-Protection` into upstream :term:`TurboGears`,\n    we might be able to remove this in the future.\n\n    .. versionadded:: 0.3.10\n       Added to enable :ref:`CSRF-Protection`\n    '''\n    # Override the turbogears.url function with our own\n    # Note, this also changes turbogears.absolute_url since that calls\n    # turbogears.url\n    turbogears.url = url\n    turbogears.controllers.url = url\n\n    # Ignore the _csrf_token parameter\n    ignore = config.get('tg.ignore_parameters', [])\n    if '_csrf_token' not in ignore:\n        ignore.append('_csrf_token')\n        config.update({'tg.ignore_parameters': ignore})\n\n    # Add a function to the template tg stdvars that looks up a template.\n    turbogears.view.variable_providers.append(add_custom_stdvars)\n\n\ndef request_format():\n    '''Return the output format that was requested by the user.\n\n    The user is able to specify a specific output format using either the\n    ``Accept:`` HTTP header or the ``tg_format`` query parameter.  This\n    function checks both of those to determine what format the reply should\n    be in.\n\n    :rtype: string\n    :returns: The requested format.  If none was specified, 'default' is\n        returned\n\n    .. versionchanged:: 0.3.17\n        Return symbolic names for json, html, xhtml, and xml instead of\n        letting raw mime types through\n    '''\n    output_format = cherrypy.request.params.get('tg_format', '').lower()\n    if not output_format:\n        ### TODO: Two problems with this:\n        # 1) TG lets this be extended via as_format and accept_format.  We need\n        #    tie into that as well somehow.\n        # 2) Decide whether to standardize on \"json\" or \"application/json\"\n        accept = tg_util.simplify_http_accept_header(\n            request.headers.get('Accept', 'default').lower())\n        if accept in ('text/javascript', 'application/json'):\n            output_format = 'json'\n        elif accept == 'text/html':\n            output_format = 'html'\n        elif accept == 'text/plain':\n            output_format = 'plain'\n        elif accept == 'text/xhtml':\n            output_format = 'xhtml'\n        elif accept == 'text/xml':\n            output_format = 'xml'\n        else:\n            output_format = accept\n    return output_format\n\n\ndef jsonify_validation_errors():\n    '''Return an error for :term:`JSON` if validation failed.\n\n    This function checks for two things:\n\n    1) We're expected to return :term:`JSON` data.\n    2) There were errors in the validation process.\n\n    If both of those are true, this function constructs a response that\n    will return the validation error messages as :term:`JSON` data.\n\n    All controller methods that are error_handlers need to use this::\n\n        @expose(template='templates.numberform')\n        def enter_number(self, number):\n            errors = fedora.tg.util.jsonify_validation_errors()\n            if errors:\n                return errors\n            [...]\n\n        @expose(allow_json=True)\n        @error_handler(enter_number)\n        @validate(form=number_form)\n        def save(self, number):\n            return dict(success=True)\n\n    :rtype: None or dict\n    :Returns: None if there are no validation errors or :term:`JSON` isn't\n        requested, otherwise a dictionary with the error that's suitable for\n        return from the controller.  The error message is set in tg_flash\n        whether :term:`JSON` was requested or not.\n    '''\n    # Check for validation errors\n    errors = getattr(cherrypy.request, 'validation_errors', None)\n    if not errors:\n        return None\n\n    # Set the message for both html and json output\n    message = u'\\n'.join([u'%s: %s' % (param, msg) for param, msg in\n                          errors.items()])\n    format = request_format()\n    if format in ('html', 'xhtml'):\n        message.translate({ord('\\n'): u'<br />\\n'})\n    flash(message)\n\n    # If json, return additional information to make this an exception\n    if format == 'json':\n        # Note: explicit setting of tg_template is needed in TG < 1.0.4.4\n        # A fix has been applied for TG-1.0.4.5\n        return dict(exc='Invalid', tg_template='json')\n    return None\n\n\ndef json_or_redirect(forward_url):\n    '''If :term:`JSON` is requested, return a dict, otherwise redirect.\n\n    This is a decorator to use with a method that returns :term:`JSON` by\n    default.  If :term:`JSON` is requested, then it will return the dict from\n    the method.  If :term:`JSON` is not requested, it will redirect to the\n    given URL.  The method that is decorated should be constructed so that it\n    calls turbogears.flash() with a message that will be displayed on the\n    forward_url page.\n\n    Use it like this::\n\n        import turbogears\n\n        @json_or_redirect('http://localhost/calc/')\n        @expose(allow_json=True)\n        def divide(self, dividend, divisor):\n            try:\n                answer = dividend * 1.0 / divisor\n            except ZeroDivisionError:\n                turbogears.flash('Division by zero not allowed')\n                return dict(exc='ZeroDivisionError')\n            turbogears.flash('The quotient is %s' % answer)\n            return dict(quotient=answer)\n\n    In the example, we return either an exception or an answer, using\n    :func:`turbogears.flash` to tell people of the result in either case.  If\n    :term:`JSON` data is requested, the user will get back a :term:`JSON`\n    string with the proper information.  If html is requested, we will be\n    redirected to 'http://localhost/calc/' where the flashed message will be\n    displayed.\n\n    :arg forward_url: If :term:`JSON` was not requested, redirect to this URL\n        after.\n\n    .. versionadded:: 0.3.7\n       To make writing methods that use validation easier\n    '''\n    def call(func, *args, **kwargs):\n        if request_format() == 'json':\n            return func(*args, **kwargs)\n        else:\n            func(*args, **kwargs)\n            raise redirect(forward_url)\n    return decorator(call)\n\nif hasattr(turbogears, 'get_server_name'):\n    _get_server_name = turbogears.get_server_name\n\n\ndef fedora_template(template, template_type='genshi'):\n    '''Function to return the path to a template.\n\n    :arg template: filename of the template itself.  Ex: login.html\n    :kwarg template_type: template language we need the template written in\n        Defaults to 'genshi'\n    :returns: filesystem path to the template\n    '''\n    # :E1101: pkg_resources does have resource_filename\n    # pylint: disable-msg=E1101\n    return pkg_resources.resource_filename(\n        'fedora', os.path.join('tg',\n                               'templates', template_type, template))\n\n__all__ = (\n    'add_custom_stdvars', 'absolute_url', 'enable_csrf',\n    'fedora_template', 'jsonify_validation_errors', 'json_or_redirect',\n    'request_format', 'tg_absolute_url', 'tg_url', 'url')\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2008-2012  Red Hat, Inc.\n# Copyright (C) 2008  Ricky Zhou\n# This file is part of python-fedora\n#\n# python-fedora is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# python-fedora is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with python-fedora; if not, see <http://www.gnu.org/licenses/>\n#\n'''\nMiscellaneous functions of use on a TurboGears Server\n\n.. versionchanged:: 0.3.14\n   Save the original turbogears.url function as :func:`fedora.tg.util.tg_url`\n\n.. versionchanged:: 0.3.17\n   Renamed from fedora.tg.util\n\n.. versionchanged:: 0.3.25\n   Renamed from fedora.tg.tg1utils\n\n.. moduleauthor:: Toshio Kuratomi <tkuratom@redhat.com>\n.. moduleauthor:: Ricky Zhou <ricky@fedoraproject.org>\n'''\nfrom itertools import chain\nimport cgi\nimport os\n\nimport cherrypy\nfrom cherrypy import request\nfrom decorator import decorator\nimport pkg_resources\nimport turbogears\nfrom turbogears import flash, redirect, config, identity\nimport turbogears.util as tg_util\nfrom turbogears.controllers import check_app_root\nfrom turbogears.identity.exceptions import RequestRequiredException\nimport six\nfrom six.moves.urllib.parse import urlencode, urlparse, urlunparse\n\n\n# Save this for people who need the original url() function\ntg_url = turbogears.url\n\n\ndef add_custom_stdvars(new_vars):\n    return new_vars.update({'fedora_template': fedora_template})\n\n\ndef url(tgpath, tgparams=None, **kwargs):\n    '''Computes URLs.\n\n    This is a replacement for :func:`turbogears.controllers.url` (aka\n    :func:`tg.url` in the template).  In addition to the functionality that\n    :func:`tg.url` provides, it adds a token to prevent :term:`CSRF` attacks.\n\n    :arg tgpath:  a list or a string. If the path is absolute (starts\n        with a \"/\"), the :attr:`server.webpath`, :envvar:`SCRIPT_NAME` and\n        the approot of the application are prepended to the path. In order for\n        the approot to be detected properly, the root object should extend\n        :class:`turbogears.controllers.RootController`.\n    :kwarg tgparams: See param: ``kwargs``\n    :kwarg kwargs: Query parameters for the URL can be passed in as a\n        dictionary in the second argument *or* as keyword parameters.\n        Values which are a list or a tuple are used to create multiple\n        key-value pairs.\n    :returns: The changed path\n\n    .. versionadded:: 0.3.10\n       Modified from turbogears.controllers.url for :ref:`CSRF-Protection`\n    '''\n    if not isinstance(tgpath, six.string_types):\n        tgpath = '/'.join(list(tgpath))\n    if not tgpath.startswith('/'):\n        # Do not allow the url() function to be used for external urls.\n        # This function is primarily used in redirect() calls, so this prevents\n        # covert redirects and thus CSRF leaking.\n        tgpath = '/'\n    if tgpath.startswith('/'):\n        webpath = (config.get('server.webpath') or '').rstrip('/')\n        if tg_util.request_available():\n            check_app_root()\n            tgpath = request.app_root + tgpath\n            try:\n                webpath += request.wsgi_environ['SCRIPT_NAME'].rstrip('/')\n            except (AttributeError, KeyError):  # pylint: disable-msg=W0704\n                # :W0704: Lack of wsgi environ is fine... we still have\n                # server.webpath\n                pass\n        tgpath = webpath + tgpath\n    if tgparams is None:\n        tgparams = kwargs\n    else:\n        try:\n            tgparams = tgparams.copy()\n            tgparams.update(kwargs)\n        except AttributeError:\n            raise TypeError(\n                'url() expects a dictionary for query parameters')\n    args = []\n    # Add the _csrf_token\n    try:\n        if identity.current.csrf_token:\n            tgparams.update({'_csrf_token': identity.current.csrf_token})\n    except RequestRequiredException:  # pylint: disable-msg=W0704\n        # :W0704: If we are outside of a request (called from non-controller\n        # methods/ templates) just don't set the _csrf_token.\n        pass\n\n    # Check for query params in the current url\n    query_params = six.iteritems(tgparams)\n    scheme, netloc, path, params, query_s, fragment = urlparse(tgpath)\n    if query_s:\n        query_params = chain((p for p in cgi.parse_qsl(query_s) if p[0] !=\n                              '_csrf_token'), query_params)\n\n    for key, value in query_params:\n        if value is None:\n            continue\n        if isinstance(value, (list, tuple)):\n            pairs = [(key, v) for v in value]\n        else:\n            pairs = [(key, value)]\n        for key, value in pairs:\n            if value is None:\n                continue\n            if isinstance(value, unicode):\n                value = value.encode('utf8')\n            args.append((key, str(value)))\n    query_string = urlencode(args, True)\n    tgpath = urlunparse((scheme, netloc, path, params, query_string, fragment))\n    return tgpath\n\n\n# this is taken from turbogears 1.1 branch\ndef _get_server_name():\n    \"\"\"Return name of the server this application runs on.\n\n    Respects 'Host' and 'X-Forwarded-Host' header.\n\n    See the docstring of the 'absolute_url' function for more information.\n\n    .. note:: This comes from turbogears 1.1 branch.  It is only needed for\n        _tg_absolute_url().  If we find that turbogears.get_server_name()\n        exists, we replace this function with that one.\n    \"\"\"\n    get = config.get\n    h = request.headers\n    host = get('tg.url_domain') or h.get('X-Forwarded-Host', h.get('Host'))\n    if not host:\n        host = '%s:%s' % (get('server.socket_host', 'localhost'),\n                          get('server.socket_port', 8080))\n    return host\n\n\n# this is taken from turbogears 1.1 branch\ndef tg_absolute_url(tgpath='/', params=None, **kw):\n    \"\"\"Return absolute URL (including schema and host to this server).\n\n    Tries to account for 'Host' header and reverse proxying\n    ('X-Forwarded-Host').\n\n    The host name is determined this way:\n\n    * If the config setting 'tg.url_domain' is set and non-null, use this\n      value.\n    * Else, if the 'base_url_filter.use_x_forwarded_host' config setting is\n      True, use the value from the 'Host' or 'X-Forwarded-Host' request header.\n    * Else, if config setting 'base_url_filter.on' is True and\n      'base_url_filter.base_url' is non-null, use its value for the host AND\n      scheme part of the URL.\n    * As a last fallback, use the value of 'server.socket_host' and\n      'server.socket_port' config settings (defaults to 'localhost:8080').\n\n    The URL scheme ('http' or 'http') used is determined in the following way:\n\n    * If 'base_url_filter.base_url' is used, use the scheme from this URL.\n    * If there is a 'X-Use-SSL' request header, use 'https'.\n    * Else, if the config setting 'tg.url_scheme' is set, use its value.\n    * Else, use the value of 'cherrypy.request.scheme'.\n\n    .. note:: This comes from turbogears 1.1 branch with one change: we\n        call tg_url() rather than turbogears.url() so that it never adds the\n        csrf_token\n\n    .. versionadded:: 0.3.19\n       Modified from turbogears.absolute_url() for :ref:`CSRF-Protection`\n    \"\"\"\n    get = config.get\n    use_xfh = get('base_url_filter.use_x_forwarded_host', False)\n    if request.headers.get('X-Use-SSL'):\n        scheme = 'https'\n    else:\n        scheme = get('tg.url_scheme')\n    if not scheme:\n        scheme = request.scheme\n    base_url = '%s://%s' % (scheme, _get_server_name())\n    if get('base_url_filter.on', False) and not use_xfh:\n        base_url = get('base_url_filter.base_url').rstrip('/')\n    return '%s%s' % (base_url, tg_url(tgpath, params, **kw))\n\n\ndef absolute_url(tgpath='/', params=None, **kw):\n    \"\"\"Return absolute URL (including schema and host to this server).\n\n    Tries to account for 'Host' header and reverse proxying\n    ('X-Forwarded-Host').\n\n    The host name is determined this way:\n\n    * If the config setting 'tg.url_domain' is set and non-null, use this\n      value.\n    * Else, if the 'base_url_filter.use_x_forwarded_host' config setting is\n      True, use the value from the 'Host' or 'X-Forwarded-Host' request header.\n    * Else, if config setting 'base_url_filter.on' is True and\n      'base_url_filter.base_url' is non-null, use its value for the host AND\n      scheme part of the URL.\n    * As a last fallback, use the value of 'server.socket_host' and\n      'server.socket_port' config settings (defaults to 'localhost:8080').\n\n    The URL scheme ('http' or 'http') used is determined in the following way:\n\n    * If 'base_url_filter.base_url' is used, use the scheme from this URL.\n    * If there is a 'X-Use-SSL' request header, use 'https'.\n    * Else, if the config setting 'tg.url_scheme' is set, use its value.\n    * Else, use the value of 'cherrypy.request.scheme'.\n\n    .. versionadded:: 0.3.19\n       Modified from turbogears.absolute_url() for :ref:`CSRF-Protection`\n    \"\"\"\n    return url(tg_absolute_url(tgpath, params, **kw))\n\n\ndef enable_csrf():\n    '''A startup function to setup :ref:`CSRF-Protection`.\n\n    This should be run at application startup.  Code like the following in the\n    start-APP script or the method in :file:`commands.py` that starts it::\n\n        from turbogears import startup\n        from fedora.tg.util import enable_csrf\n        startup.call_on_startup.append(enable_csrf)\n\n    If we can get the :ref:`CSRF-Protection` into upstream :term:`TurboGears`,\n    we might be able to remove this in the future.\n\n    .. versionadded:: 0.3.10\n       Added to enable :ref:`CSRF-Protection`\n    '''\n    # Override the turbogears.url function with our own\n    # Note, this also changes turbogears.absolute_url since that calls\n    # turbogears.url\n    turbogears.url = url\n    turbogears.controllers.url = url\n\n    # Ignore the _csrf_token parameter\n    ignore = config.get('tg.ignore_parameters', [])\n    if '_csrf_token' not in ignore:\n        ignore.append('_csrf_token')\n        config.update({'tg.ignore_parameters': ignore})\n\n    # Add a function to the template tg stdvars that looks up a template.\n    turbogears.view.variable_providers.append(add_custom_stdvars)\n\n\ndef request_format():\n    '''Return the output format that was requested by the user.\n\n    The user is able to specify a specific output format using either the\n    ``Accept:`` HTTP header or the ``tg_format`` query parameter.  This\n    function checks both of those to determine what format the reply should\n    be in.\n\n    :rtype: string\n    :returns: The requested format.  If none was specified, 'default' is\n        returned\n\n    .. versionchanged:: 0.3.17\n        Return symbolic names for json, html, xhtml, and xml instead of\n        letting raw mime types through\n    '''\n    output_format = cherrypy.request.params.get('tg_format', '').lower()\n    if not output_format:\n        ### TODO: Two problems with this:\n        # 1) TG lets this be extended via as_format and accept_format.  We need\n        #    tie into that as well somehow.\n        # 2) Decide whether to standardize on \"json\" or \"application/json\"\n        accept = tg_util.simplify_http_accept_header(\n            request.headers.get('Accept', 'default').lower())\n        if accept in ('text/javascript', 'application/json'):\n            output_format = 'json'\n        elif accept == 'text/html':\n            output_format = 'html'\n        elif accept == 'text/plain':\n            output_format = 'plain'\n        elif accept == 'text/xhtml':\n            output_format = 'xhtml'\n        elif accept == 'text/xml':\n            output_format = 'xml'\n        else:\n            output_format = accept\n    return output_format\n\n\ndef jsonify_validation_errors():\n    '''Return an error for :term:`JSON` if validation failed.\n\n    This function checks for two things:\n\n    1) We're expected to return :term:`JSON` data.\n    2) There were errors in the validation process.\n\n    If both of those are true, this function constructs a response that\n    will return the validation error messages as :term:`JSON` data.\n\n    All controller methods that are error_handlers need to use this::\n\n        @expose(template='templates.numberform')\n        def enter_number(self, number):\n            errors = fedora.tg.util.jsonify_validation_errors()\n            if errors:\n                return errors\n            [...]\n\n        @expose(allow_json=True)\n        @error_handler(enter_number)\n        @validate(form=number_form)\n        def save(self, number):\n            return dict(success=True)\n\n    :rtype: None or dict\n    :Returns: None if there are no validation errors or :term:`JSON` isn't\n        requested, otherwise a dictionary with the error that's suitable for\n        return from the controller.  The error message is set in tg_flash\n        whether :term:`JSON` was requested or not.\n    '''\n    # Check for validation errors\n    errors = getattr(cherrypy.request, 'validation_errors', None)\n    if not errors:\n        return None\n\n    # Set the message for both html and json output\n    message = u'\\n'.join([u'%s: %s' % (param, msg) for param, msg in\n                          errors.items()])\n    format = request_format()\n    if format in ('html', 'xhtml'):\n        message.translate({ord('\\n'): u'<br />\\n'})\n    flash(message)\n\n    # If json, return additional information to make this an exception\n    if format == 'json':\n        # Note: explicit setting of tg_template is needed in TG < 1.0.4.4\n        # A fix has been applied for TG-1.0.4.5\n        return dict(exc='Invalid', tg_template='json')\n    return None\n\n\ndef json_or_redirect(forward_url):\n    '''If :term:`JSON` is requested, return a dict, otherwise redirect.\n\n    This is a decorator to use with a method that returns :term:`JSON` by\n    default.  If :term:`JSON` is requested, then it will return the dict from\n    the method.  If :term:`JSON` is not requested, it will redirect to the\n    given URL.  The method that is decorated should be constructed so that it\n    calls turbogears.flash() with a message that will be displayed on the\n    forward_url page.\n\n    Use it like this::\n\n        import turbogears\n\n        @json_or_redirect('http://localhost/calc/')\n        @expose(allow_json=True)\n        def divide(self, dividend, divisor):\n            try:\n                answer = dividend * 1.0 / divisor\n            except ZeroDivisionError:\n                turbogears.flash('Division by zero not allowed')\n                return dict(exc='ZeroDivisionError')\n            turbogears.flash('The quotient is %s' % answer)\n            return dict(quotient=answer)\n\n    In the example, we return either an exception or an answer, using\n    :func:`turbogears.flash` to tell people of the result in either case.  If\n    :term:`JSON` data is requested, the user will get back a :term:`JSON`\n    string with the proper information.  If html is requested, we will be\n    redirected to 'http://localhost/calc/' where the flashed message will be\n    displayed.\n\n    :arg forward_url: If :term:`JSON` was not requested, redirect to this URL\n        after.\n\n    .. versionadded:: 0.3.7\n       To make writing methods that use validation easier\n    '''\n    def call(func, *args, **kwargs):\n        if request_format() == 'json':\n            return func(*args, **kwargs)\n        else:\n            func(*args, **kwargs)\n            raise redirect(forward_url)\n    return decorator(call)\n\nif hasattr(turbogears, 'get_server_name'):\n    _get_server_name = turbogears.get_server_name\n\n\ndef fedora_template(template, template_type='genshi'):\n    '''Function to return the path to a template.\n\n    :arg template: filename of the template itself.  Ex: login.html\n    :kwarg template_type: template language we need the template written in\n        Defaults to 'genshi'\n    :returns: filesystem path to the template\n    '''\n    # :E1101: pkg_resources does have resource_filename\n    # pylint: disable-msg=E1101\n    return pkg_resources.resource_filename(\n        'fedora', os.path.join('tg',\n                               'templates', template_type, template))\n\n__all__ = (\n    'add_custom_stdvars', 'absolute_url', 'enable_csrf',\n    'fedora_template', 'jsonify_validation_errors', 'json_or_redirect',\n    'request_format', 'tg_absolute_url', 'tg_url', 'url')\n"], "filenames": ["fedora/tg/utils.py"], "buggy_code_start_loc": [83], "buggy_code_end_loc": [83], "fixing_code_start_loc": [84], "fixing_code_end_loc": [89], "type": "CWE-601", "message": "python-fedora 0.8.0 and lower is vulnerable to an open redirect resulting in loss of CSRF protection", "other": {"cve": {"id": "CVE-2017-1002150", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2017-09-14T13:29:01.403", "lastModified": "2022-12-21T15:01:19.963", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "python-fedora 0.8.0 and lower is vulnerable to an open redirect resulting in loss of CSRF protection"}, {"lang": "es", "value": "python-fedora, en su versi\u00f3n 0.8.0 y anteriores, es vulnerable a una redirecci\u00f3n abierta y, como consecuencia, a una p\u00e9rdida de protecci\u00f3n contra ataques de tipo Cross-Sire Request Forgery (CSRF)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:python-fedora:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.0", "matchCriteriaId": "F3D3853E-7C48-4CD2-BF6E-84798AA44E2B"}]}]}], "references": [{"url": "https://github.com/fedora-infra/python-fedora/commit/b27f38a67573f4c989710c9bfb726dd4c1eeb929", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fedora-infra/python-fedora/commit/b27f38a67573f4c989710c9bfb726dd4c1eeb929.patch", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fedora-infra/python-fedora/commit/b27f38a67573f4c989710c9bfb726dd4c1eeb929"}}