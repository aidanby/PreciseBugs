{"buggy_code": ["# frozen_string_literal: true\n\nmodule ActionDispatch\n  # This middleware guards from DNS rebinding attacks by explicitly permitting\n  # the hosts a request can be sent to, and is passed the options set in\n  # +config.host_authorization+.\n  #\n  # Requests can opt-out of Host Authorization with +exclude+:\n  #\n  #    config.host_authorization = { exclude: ->(request) { request.path =~ /healthcheck/ } }\n  #\n  # When a request comes to an unauthorized host, the +response_app+\n  # application will be executed and rendered. If no +response_app+ is given, a\n  # default one will run.\n  # The default response app logs blocked host info with level 'error' and\n  # responds with <tt>403 Forbidden</tt>. The body of the response contains debug info\n  # if +config.consider_all_requests_local+ is set to true, otherwise the body is empty.\n  class HostAuthorization\n    class Permissions # :nodoc:\n      def initialize(hosts)\n        @hosts = sanitize_hosts(hosts)\n      end\n\n      def empty?\n        @hosts.empty?\n      end\n\n      def allows?(host)\n        @hosts.any? do |allowed|\n          allowed === host\n        rescue\n          # IPAddr#=== raises an error if you give it a hostname instead of\n          # IP. Treat similar errors as blocked access.\n          false\n        end\n      end\n\n      private\n        def sanitize_hosts(hosts)\n          Array(hosts).map do |host|\n            case host\n            when Regexp then sanitize_regexp(host)\n            when String then sanitize_string(host)\n            else host\n            end\n          end\n        end\n\n        def sanitize_regexp(host)\n          /\\A#{host}\\z/\n        end\n\n        def sanitize_string(host)\n          if host.start_with?(\".\")\n            /\\A(.+\\.)?#{Regexp.escape(host[1..-1])}\\z/i\n          else\n            /\\A#{Regexp.escape host}\\z/i\n          end\n        end\n    end\n\n    class DefaultResponseApp # :nodoc:\n      RESPONSE_STATUS = 403\n\n      def call(env)\n        request = Request.new(env)\n        format = request.xhr? ? \"text/plain\" : \"text/html\"\n\n        log_error(request)\n        response(format, response_body(request))\n      end\n\n      private\n        def response_body(request)\n          return \"\" unless request.get_header(\"action_dispatch.show_detailed_exceptions\")\n\n          template = DebugView.new(host: request.host)\n          template.render(template: \"rescues/blocked_host\", layout: \"rescues/layout\")\n        end\n\n        def response(format, body)\n          [RESPONSE_STATUS,\n           { \"Content-Type\" => \"#{format}; charset=#{Response.default_charset}\",\n             \"Content-Length\" => body.bytesize.to_s },\n           [body]]\n        end\n\n        def log_error(request)\n          logger = available_logger(request)\n\n          return unless logger\n\n          logger.error(\"[#{self.class.name}] Blocked host: #{request.host}\")\n        end\n\n        def available_logger(request)\n          request.logger || ActionView::Base.logger\n        end\n    end\n\n    def initialize(app, hosts, exclude: nil, response_app: nil)\n      @app = app\n      @permissions = Permissions.new(hosts)\n      @exclude = exclude\n\n      @response_app = response_app || DefaultResponseApp.new\n    end\n\n    def call(env)\n      return @app.call(env) if @permissions.empty?\n\n      request = Request.new(env)\n\n      if authorized?(request) || excluded?(request)\n        mark_as_authorized(request)\n        @app.call(env)\n      else\n        @response_app.call(env)\n      end\n    end\n\n    private\n      HOSTNAME = /[a-z0-9.-]+|\\[[a-f0-9]*:[a-f0-9.:]+\\]/i\n      VALID_ORIGIN_HOST = /\\A(#{HOSTNAME})(?::\\d+)?\\z/\n      VALID_FORWARDED_HOST = /(?:\\A|,[ ]?)(#{HOSTNAME})(?::\\d+)?\\z/\n\n      def authorized?(request)\n        origin_host = request.get_header(\"HTTP_HOST\")&.slice(VALID_ORIGIN_HOST, 1) || \"\"\n        forwarded_host = request.x_forwarded_host&.slice(VALID_FORWARDED_HOST, 1) || \"\"\n\n        @permissions.allows?(origin_host) && (forwarded_host.blank? || @permissions.allows?(forwarded_host))\n      end\n\n      def excluded?(request)\n        @exclude && @exclude.call(request)\n      end\n\n      def mark_as_authorized(request)\n        request.set_header(\"action_dispatch.authorized_host\", request.host)\n      end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"abstract_unit\"\nrequire \"ipaddr\"\n\nclass HostAuthorizationTest < ActionDispatch::IntegrationTest\n  App = -> env { [200, {}, %w(Success)] }\n\n  test \"blocks requests to unallowed host with empty body\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n\n    get \"/\"\n\n    assert_response :forbidden\n    assert_empty response.body\n  end\n\n  test \"renders debug info when all requests considered as local\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n\n    get \"/\", env: { \"action_dispatch.show_detailed_exceptions\" => true }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", response.body\n  end\n\n  test \"allows all requests if hosts is empty\" do\n    @app = ActionDispatch::HostAuthorization.new(App, nil)\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts can be a single element array\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(www.example.com))\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts can be a string\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"www.example.com\")\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts are matched case insensitive\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"Example.local\")\n\n    get \"/\", env: {\n      \"HOST\" => \"example.local\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts are matched case insensitive with titlecased host\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"example.local\")\n\n    get \"/\", env: {\n      \"HOST\" => \"Example.local\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts are matched case insensitive with hosts array\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [\"Example.local\"])\n\n    get \"/\", env: {\n      \"HOST\" => \"example.local\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"regex matches are not title cased\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [/www.Example.local/])\n\n    get \"/\", env: {\n      \"HOST\" => \"www.example.local\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.local\", response.body\n  end\n\n  test \"passes requests to allowed hosts with domain name notation\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"does not allow domain name notation in the HOST header itself\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\", env: {\n      \"HOST\" => \".example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: .example.com\", response.body\n  end\n\n  test \"checks for requests with #=== to support wider range of host checks\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [-> input { input == \"www.example.com\" }])\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"mark the host when authorized\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\"\n\n    assert_equal \"www.example.com\", request.get_header(\"action_dispatch.authorized_host\")\n  end\n\n  test \"sanitizes regular expressions to prevent accidental matches\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [/w.example.co/])\n\n    get \"/\", env: { \"action_dispatch.show_detailed_exceptions\" => true }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", response.body\n  end\n\n  test \"blocks requests to unallowed host supporting custom responses\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [\"w.example.co\"], response_app: -> env do\n      [401, {}, %w(Custom)]\n    end)\n\n    get \"/\"\n\n    assert_response :unauthorized\n    assert_equal \"Custom\", body\n  end\n\n  test \"blocks requests with spoofed X-FORWARDED-HOST\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [IPAddr.new(\"127.0.0.1\")])\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"127.0.0.1\",\n      \"HOST\" => \"www.example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: 127.0.0.1\", response.body\n  end\n\n  test \"does not consider IP addresses in X-FORWARDED-HOST spoofed when disabled\" do\n    @app = ActionDispatch::HostAuthorization.new(App, nil)\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"127.0.0.1\",\n      \"HOST\" => \"www.example.com\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"detects localhost domain spoofing\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"localhost\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"localhost\",\n      \"HOST\" => \"www.example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: localhost\", response.body\n  end\n\n  test \"forwarded hosts should be permitted\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"domain.com\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"sub.domain.com\",\n      \"HOST\" => \"domain.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: sub.domain.com\", response.body\n  end\n\n  test \"forwarded hosts are allowed when permitted\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".domain.com\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"sub.domain.com\",\n      \"HOST\" => \"domain.com\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"exclude matches allow any host\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"only.com\", exclude: ->(req) { req.path == \"/foo\" })\n\n    get \"/foo\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"exclude misses block unallowed hosts\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"only.com\", exclude: ->(req) { req.path == \"/bar\" })\n\n    get \"/foo\", env: { \"action_dispatch.show_detailed_exceptions\" => true }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", response.body\n  end\n\n  test \"blocks requests with invalid hostnames\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\", env: {\n      \"HOST\" => \"attacker.com#x.example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: attacker.com#x.example.com\", response.body\n  end\n\n  test \"blocks requests to similar host\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"sub.example.com\")\n\n    get \"/\", env: {\n      \"HOST\" => \"sub-example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: sub-example.com\", response.body\n  end\n\n  test \"uses logger from the env\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n    output = StringIO.new\n\n    get \"/\", env: { \"action_dispatch.logger\" => Logger.new(output) }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", output.rewind && output.read\n  end\n\n  test \"uses ActionView::Base logger when no logger in the env\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n    output = StringIO.new\n    logger = Logger.new(output)\n\n    _old, ActionView::Base.logger = ActionView::Base.logger, logger\n    begin\n      get \"/\"\n    ensure\n      ActionView::Base.logger = _old\n    end\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", output.rewind && output.read\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nmodule ActionDispatch\n  # This middleware guards from DNS rebinding attacks by explicitly permitting\n  # the hosts a request can be sent to, and is passed the options set in\n  # +config.host_authorization+.\n  #\n  # Requests can opt-out of Host Authorization with +exclude+:\n  #\n  #    config.host_authorization = { exclude: ->(request) { request.path =~ /healthcheck/ } }\n  #\n  # When a request comes to an unauthorized host, the +response_app+\n  # application will be executed and rendered. If no +response_app+ is given, a\n  # default one will run.\n  # The default response app logs blocked host info with level 'error' and\n  # responds with <tt>403 Forbidden</tt>. The body of the response contains debug info\n  # if +config.consider_all_requests_local+ is set to true, otherwise the body is empty.\n  class HostAuthorization\n    class Permissions # :nodoc:\n      def initialize(hosts)\n        @hosts = sanitize_hosts(hosts)\n      end\n\n      def empty?\n        @hosts.empty?\n      end\n\n      def allows?(host)\n        @hosts.any? do |allowed|\n          allowed === host\n        rescue\n          # IPAddr#=== raises an error if you give it a hostname instead of\n          # IP. Treat similar errors as blocked access.\n          false\n        end\n      end\n\n      private\n        def sanitize_hosts(hosts)\n          Array(hosts).map do |host|\n            case host\n            when Regexp then sanitize_regexp(host)\n            when String then sanitize_string(host)\n            else host\n            end\n          end\n        end\n\n        def sanitize_regexp(host)\n          /\\A#{host}\\z/\n        end\n\n        def sanitize_string(host)\n          if host.start_with?(\".\")\n            /\\A([a-z0-9-]+\\.)?#{Regexp.escape(host[1..-1])}\\z/i\n          else\n            /\\A#{Regexp.escape host}\\z/i\n          end\n        end\n    end\n\n    class DefaultResponseApp # :nodoc:\n      RESPONSE_STATUS = 403\n\n      def call(env)\n        request = Request.new(env)\n        format = request.xhr? ? \"text/plain\" : \"text/html\"\n\n        log_error(request)\n        response(format, response_body(request))\n      end\n\n      private\n        def response_body(request)\n          return \"\" unless request.get_header(\"action_dispatch.show_detailed_exceptions\")\n\n          template = DebugView.new(host: request.host)\n          template.render(template: \"rescues/blocked_host\", layout: \"rescues/layout\")\n        end\n\n        def response(format, body)\n          [RESPONSE_STATUS,\n           { \"Content-Type\" => \"#{format}; charset=#{Response.default_charset}\",\n             \"Content-Length\" => body.bytesize.to_s },\n           [body]]\n        end\n\n        def log_error(request)\n          logger = available_logger(request)\n\n          return unless logger\n\n          logger.error(\"[#{self.class.name}] Blocked host: #{request.host}\")\n        end\n\n        def available_logger(request)\n          request.logger || ActionView::Base.logger\n        end\n    end\n\n    def initialize(app, hosts, exclude: nil, response_app: nil)\n      @app = app\n      @permissions = Permissions.new(hosts)\n      @exclude = exclude\n\n      @response_app = response_app || DefaultResponseApp.new\n    end\n\n    def call(env)\n      return @app.call(env) if @permissions.empty?\n\n      request = Request.new(env)\n\n      if authorized?(request) || excluded?(request)\n        mark_as_authorized(request)\n        @app.call(env)\n      else\n        @response_app.call(env)\n      end\n    end\n\n    private\n      def authorized?(request)\n        origin_host = request.get_header(\"HTTP_HOST\")\n        forwarded_host = request.x_forwarded_host&.split(/,\\s?/)&.last\n\n        @permissions.allows?(origin_host) && (forwarded_host.blank? || @permissions.allows?(forwarded_host))\n      end\n\n      def excluded?(request)\n        @exclude && @exclude.call(request)\n      end\n\n      def mark_as_authorized(request)\n        request.set_header(\"action_dispatch.authorized_host\", request.host)\n      end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"abstract_unit\"\nrequire \"ipaddr\"\n\nclass HostAuthorizationTest < ActionDispatch::IntegrationTest\n  App = -> env { [200, {}, %w(Success)] }\n\n  test \"blocks requests to unallowed host with empty body\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n\n    get \"/\"\n\n    assert_response :forbidden\n    assert_empty response.body\n  end\n\n  test \"renders debug info when all requests considered as local\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n\n    get \"/\", env: { \"action_dispatch.show_detailed_exceptions\" => true }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", response.body\n  end\n\n  test \"allows all requests if hosts is empty\" do\n    @app = ActionDispatch::HostAuthorization.new(App, nil)\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts can be a single element array\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(www.example.com))\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts can be a string\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"www.example.com\")\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts are matched case insensitive\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"Example.local\")\n\n    get \"/\", env: {\n      \"HOST\" => \"example.local\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts are matched case insensitive with titlecased host\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"example.local\")\n\n    get \"/\", env: {\n      \"HOST\" => \"Example.local\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"hosts are matched case insensitive with hosts array\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [\"Example.local\"])\n\n    get \"/\", env: {\n      \"HOST\" => \"example.local\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"regex matches are not title cased\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [/www.Example.local/])\n\n    get \"/\", env: {\n      \"HOST\" => \"www.example.local\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.local\", response.body\n  end\n\n  test \"passes requests to allowed hosts with domain name notation\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"does not allow domain name notation in the HOST header itself\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\", env: {\n      \"HOST\" => \".example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: .example.com\", response.body\n  end\n\n  test \"checks for requests with #=== to support wider range of host checks\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [-> input { input == \"www.example.com\" }])\n\n    get \"/\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"mark the host when authorized\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\"\n\n    assert_equal \"www.example.com\", request.get_header(\"action_dispatch.authorized_host\")\n  end\n\n  test \"sanitizes regular expressions to prevent accidental matches\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [/w.example.co/])\n\n    get \"/\", env: { \"action_dispatch.show_detailed_exceptions\" => true }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", response.body\n  end\n\n  test \"blocks requests to unallowed host supporting custom responses\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [\"w.example.co\"], response_app: -> env do\n      [401, {}, %w(Custom)]\n    end)\n\n    get \"/\"\n\n    assert_response :unauthorized\n    assert_equal \"Custom\", body\n  end\n\n  test \"blocks requests with spoofed X-FORWARDED-HOST\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [IPAddr.new(\"127.0.0.1\")])\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"127.0.0.1\",\n      \"HOST\" => \"www.example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: 127.0.0.1\", response.body\n  end\n\n  test \"blocks requests with spoofed relative X-FORWARDED-HOST\" do\n    @app = ActionDispatch::HostAuthorization.new(App, [\"www.example.com\"])\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"//randomhost.com\",\n      \"HOST\" => \"www.example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: //randomhost.com\", response.body\n  end\n\n  test \"forwarded secondary hosts are allowed when permitted\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".domain.com\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"example.com, my-sub.domain.com\",\n      \"HOST\" => \"domain.com\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"forwarded secondary hosts are blocked when mismatch\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"domain.com\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"domain.com, evil.com\",\n      \"HOST\" => \"domain.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: evil.com\", response.body\n  end\n\n  test \"does not consider IP addresses in X-FORWARDED-HOST spoofed when disabled\" do\n    @app = ActionDispatch::HostAuthorization.new(App, nil)\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"127.0.0.1\",\n      \"HOST\" => \"www.example.com\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"detects localhost domain spoofing\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"localhost\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"localhost\",\n      \"HOST\" => \"www.example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: localhost\", response.body\n  end\n\n  test \"forwarded hosts should be permitted\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"domain.com\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"sub.domain.com\",\n      \"HOST\" => \"domain.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: sub.domain.com\", response.body\n  end\n\n  test \"sub-sub domains should not be permitted\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".domain.com\")\n\n    get \"/\", env: {\n      \"HOST\" => \"secondary.sub.domain.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: secondary.sub.domain.com\", response.body\n  end\n\n  test \"forwarded hosts are allowed when permitted\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".domain.com\")\n\n    get \"/\", env: {\n      \"HTTP_X_FORWARDED_HOST\" => \"my-sub.domain.com\",\n      \"HOST\" => \"domain.com\",\n    }\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"lots of NG hosts\" do\n    ng_hosts = [\n      \"hacker%E3%80%82com\",\n      \"hacker%00.com\",\n      \"www.theirsite.com@yoursite.com\",\n      \"hacker.com/test/\",\n      \"hacker%252ecom\",\n      \".hacker.com\",\n      \"/\\/\\/hacker.com/\",\n      \"/hacker.com\",\n      \"../hacker.com\",\n      \".hacker.com\",\n      \"@hacker.com\",\n      \"hacker.com\",\n      \"hacker.com%23@example.com\",\n      \"hacker.com/.jpg\",\n      \"hacker.com\\texample.com/\",\n      \"hacker.com/example.com\",\n      \"hacker.com\\@example.com\",\n      \"hacker.com/example.com\",\n      \"hacker.com/\"\n    ]\n\n    @app = ActionDispatch::HostAuthorization.new(App, \"example.com\")\n\n    ng_hosts.each do |host|\n      get \"/\", env: {\n        \"HTTP_X_FORWARDED_HOST\" => host,\n        \"HOST\" => \"example.com\",\n        \"action_dispatch.show_detailed_exceptions\" => true\n      }\n\n      assert_response :forbidden\n      assert_match \"Blocked host: #{host}\", response.body\n    end\n  end\n\n  test \"exclude matches allow any host\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"only.com\", exclude: ->(req) { req.path == \"/foo\" })\n\n    get \"/foo\"\n\n    assert_response :ok\n    assert_equal \"Success\", body\n  end\n\n  test \"exclude misses block unallowed hosts\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"only.com\", exclude: ->(req) { req.path == \"/bar\" })\n\n    get \"/foo\", env: { \"action_dispatch.show_detailed_exceptions\" => true }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", response.body\n  end\n\n  test \"blocks requests with invalid hostnames\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \".example.com\")\n\n    get \"/\", env: {\n      \"HOST\" => \"attacker.com#x.example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: attacker.com#x.example.com\", response.body\n  end\n\n  test \"blocks requests to similar host\" do\n    @app = ActionDispatch::HostAuthorization.new(App, \"sub.example.com\")\n\n    get \"/\", env: {\n      \"HOST\" => \"sub-example.com\",\n      \"action_dispatch.show_detailed_exceptions\" => true\n    }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: sub-example.com\", response.body\n  end\n\n  test \"uses logger from the env\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n    output = StringIO.new\n\n    get \"/\", env: { \"action_dispatch.logger\" => Logger.new(output) }\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", output.rewind && output.read\n  end\n\n  test \"uses ActionView::Base logger when no logger in the env\" do\n    @app = ActionDispatch::HostAuthorization.new(App, %w(only.com))\n    output = StringIO.new\n    logger = Logger.new(output)\n\n    _old, ActionView::Base.logger = ActionView::Base.logger, logger\n    begin\n      get \"/\"\n    ensure\n      ActionView::Base.logger = _old\n    end\n\n    assert_response :forbidden\n    assert_match \"Blocked host: www.example.com\", output.rewind && output.read\n  end\nend\n"], "filenames": ["actionpack/lib/action_dispatch/middleware/host_authorization.rb", "actionpack/test/dispatch/host_authorization_test.rb"], "buggy_code_start_loc": [55, 169], "buggy_code_end_loc": [130, 217], "fixing_code_start_loc": [55, 170], "fixing_code_end_loc": [126, 305], "type": "CWE-601", "message": "A open redirect vulnerability exists in Action Pack >= 6.0.0 that could allow an attacker to craft a \"X-Forwarded-Host\" headers in combination with certain \"allowed host\" formats can cause the Host Authorization middleware in Action Pack to redirect users to a malicious website.", "other": {"cve": {"id": "CVE-2021-44528", "sourceIdentifier": "support@hackerone.com", "published": "2022-01-10T14:10:26.117", "lastModified": "2023-03-14T08:15:12.297", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A open redirect vulnerability exists in Action Pack >= 6.0.0 that could allow an attacker to craft a \"X-Forwarded-Host\" headers in combination with certain \"allowed host\" formats can cause the Host Authorization middleware in Action Pack to redirect users to a malicious website."}, {"lang": "es", "value": "Se presenta una vulnerabilidad de redirecci\u00f3n abierta en Action Pack versiones posteriores a 6.0.0 incluy\u00e9ndola, que podr\u00eda permitir a un atacante dise\u00f1ar un encabezado \"X-Forwarded-Host\" en combinaci\u00f3n con determinados formatos de \"allowed host\" puede causar que el middleware Host Authorization en Action Pack redirija a usuarios a un sitio web malicioso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:6.0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "37A3CBC3-83F7-4D43-B1FA-D2694B5AF8BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:6.1.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "4F480555-28ED-4393-BB7D-1380E34B2670"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:7.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "4A5138B9-07DF-4705-A271-E2E1444BAC61"}]}]}], "references": [{"url": "https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5372", "source": "support@hackerone.com"}]}, "github_commit_url": "https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815"}}