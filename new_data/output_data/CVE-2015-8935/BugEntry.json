{"buggy_code": ["--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n--FILE--\n<?php\nheader(\"X-foo: e\\n foo\");\nheader(\"X-Foo6: e\\rSet-Cookie: ID=123\\n d\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nX-foo: e\nfoo\n", "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n--FILE--\n<?php\nheader(\"X-foo: e\\n foo\");\nheader(\"X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain NUL bytes in %s on line %d\nfoo\n--EXPECTHEADERS--\nX-foo: e\nfoo\n", "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), CRLF\n--FILE--\n<?php\nheader(\"X-foo: e\\r\\n foo\");\nheader(\"X-foo: e\\r\\nfoo\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nX-foo: e\n foo\n", "/* \n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2015 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Original design:  Shane Caraveo <shane@caraveo.com>                  |\n   | Authors: Andi Gutmans <andi@zend.com>                                |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n#include <ctype.h>\n#include <sys/stat.h>\n\n#include \"php.h\"\n#include \"SAPI.h\"\n#include \"php_variables.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/php_string.h\"\n#include \"ext/standard/pageinfo.h\"\n#if (HAVE_PCRE || HAVE_BUNDLED_PCRE) && !defined(COMPILE_DL_PCRE)\n#include \"ext/pcre/php_pcre.h\"\n#endif\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#elif defined(PHP_WIN32)\n#include \"win32/time.h\"\n#endif\n\n#include \"rfc1867.h\"\n\n#ifdef PHP_WIN32\n#define STRCASECMP stricmp\n#else\n#define STRCASECMP strcasecmp\n#endif\n\n#include \"php_content_types.h\"\n\n#ifdef ZTS\nSAPI_API int sapi_globals_id;\n#else\nsapi_globals_struct sapi_globals;\n#endif\n\nstatic void sapi_globals_ctor(sapi_globals_struct *sapi_globals TSRMLS_DC)\n{\n\tmemset(sapi_globals, 0, sizeof(*sapi_globals));\n\tzend_hash_init_ex(&sapi_globals->known_post_content_types, 5, NULL, NULL, 1, 0);\n\tphp_setup_sapi_content_types(TSRMLS_C);\n}\n\nstatic void sapi_globals_dtor(sapi_globals_struct *sapi_globals TSRMLS_DC)\n{\n\tzend_hash_destroy(&sapi_globals->known_post_content_types);\n}\n\n/* True globals (no need for thread safety) */\nSAPI_API sapi_module_struct sapi_module;\n\n\nSAPI_API void sapi_startup(sapi_module_struct *sf)\n{\n#ifdef ZEND_SIGNALS\n\tzend_signal_startup();\n#endif\n\n\tsf->ini_entries = NULL;\n\tsapi_module = *sf;\n\n#ifdef ZTS\n\tts_allocate_id(&sapi_globals_id, sizeof(sapi_globals_struct), (ts_allocate_ctor) sapi_globals_ctor, (ts_allocate_dtor) sapi_globals_dtor);\n# ifdef PHP_WIN32\n\t_configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n# endif\n#else\n\tsapi_globals_ctor(&sapi_globals);\n#endif\n\n\tvirtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */\n\n#ifdef PHP_WIN32\n\ttsrm_win32_startup();\n#endif\n\n\treentrancy_startup();\n}\n\nSAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\n\treentrancy_shutdown();\n\n\tvirtual_cwd_shutdown();\n\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}\n\n\nSAPI_API void sapi_free_header(sapi_header_struct *sapi_header)\n{\n\tefree(sapi_header->header);\n}\n\n/* {{{ proto bool header_register_callback(mixed callback)\n   call a header function */\nPHP_FUNCTION(header_register_callback)\n{\n\tzval *callback_func;\n\tchar *callback_name;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &callback_func) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (!zend_is_callable(callback_func, 0, &callback_name TSRMLS_CC)) {\n\t\tefree(callback_name);\n\t\tRETURN_FALSE;\n\t}\n\n\tefree(callback_name);\n\n\tif (SG(callback_func)) {\n\t\tzval_ptr_dtor(&SG(callback_func));\n\t\tSG(fci_cache) = empty_fcall_info_cache;\n\t}\n\n\tSG(callback_func) = callback_func;\n\n\tZ_ADDREF_P(SG(callback_func));\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void sapi_run_header_callback(TSRMLS_D)\n{\n\tint   error;\n\tzend_fcall_info fci;\n\tchar *callback_name = NULL;\n\tchar *callback_error = NULL;\n\tzval *retval_ptr = NULL;\n\t\n\tif (zend_fcall_info_init(SG(callback_func), 0, &fci, &SG(fci_cache), &callback_name, &callback_error TSRMLS_CC) == SUCCESS) {\n\t\tfci.retval_ptr_ptr = &retval_ptr;\n\t\t\n\t\terror = zend_call_function(&fci, &SG(fci_cache) TSRMLS_CC);\n\t\tif (error == FAILURE) {\n\t\t\tgoto callback_failed;\n\t\t} else if (retval_ptr) {\n\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t}\n\t} else {\ncallback_failed:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not call the sapi_header_callback\");\n\t}\n\t\n\tif (callback_name) {\n\t\tefree(callback_name);\n\t}\n\tif (callback_error) {\n\t\tefree(callback_error);\n\t}\t\n}\n\nSAPI_API void sapi_handle_post(void *arg TSRMLS_DC)\n{\n\tif (SG(request_info).post_entry && SG(request_info).content_type_dup) {\n\t\tSG(request_info).post_entry->post_handler(SG(request_info).content_type_dup, arg TSRMLS_CC);\n\t\tif (SG(request_info).post_data) {\n\t\t\tefree(SG(request_info).post_data);\n\t\t\tSG(request_info).post_data = NULL;\n\t\t}\n\t\tefree(SG(request_info).content_type_dup);\n\t\tSG(request_info).content_type_dup = NULL;\n\t}\n}\n\nstatic void sapi_read_post_data(TSRMLS_D)\n{\n\tsapi_post_entry *post_entry;\n\tuint content_type_length = strlen(SG(request_info).content_type);\n\tchar *content_type = estrndup(SG(request_info).content_type, content_type_length);\n\tchar *p;\n\tchar oldchar=0;\n\tvoid (*post_reader_func)(TSRMLS_D) = NULL;\n\n\n\t/* dedicated implementation for increased performance:\n\t * - Make the content type lowercase\n\t * - Trim descriptive data, stay with the content-type only\n\t */\n\tfor (p=content_type; p<content_type+content_type_length; p++) {\n\t\tswitch (*p) {\n\t\t\tcase ';':\n\t\t\tcase ',':\n\t\t\tcase ' ':\n\t\t\t\tcontent_type_length = p-content_type;\n\t\t\t\toldchar = *p;\n\t\t\t\t*p = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*p = tolower(*p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now try to find an appropriate POST content handler */\n\tif (zend_hash_find(&SG(known_post_content_types), content_type,\n\t\t\tcontent_type_length+1, (void **) &post_entry) == SUCCESS) {\n\t\t/* found one, register it for use */\n\t\tSG(request_info).post_entry = post_entry;\n\t\tpost_reader_func = post_entry->post_reader;\n\t} else {\n\t\t/* fallback */\n\t\tSG(request_info).post_entry = NULL;\n\t\tif (!sapi_module.default_post_reader) {\n\t\t\t/* no default reader ? */\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Unsupported content type:  '%s'\", content_type);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (oldchar) {\n\t\t*(p-1) = oldchar;\n\t}\n\n\tSG(request_info).content_type_dup = content_type;\n\n\tif(post_reader_func) {\n\t\tpost_reader_func(TSRMLS_C);\n\t}\n\n\tif(sapi_module.default_post_reader) {\n\t\tsapi_module.default_post_reader(TSRMLS_C);\n\t}\n}\n\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n\n\nstatic inline char *get_default_content_type(uint prefix_len, uint *len TSRMLS_DC)\n{\n\tchar *mimetype, *charset, *content_type;\n\tuint mimetype_len, charset_len;\n\n\tif (SG(default_mimetype)) {\n\t\tmimetype = SG(default_mimetype);\n\t\tmimetype_len = strlen(SG(default_mimetype));\n\t} else {\n\t\tmimetype = SAPI_DEFAULT_MIMETYPE;\n\t\tmimetype_len = sizeof(SAPI_DEFAULT_MIMETYPE) - 1;\n\t}\n\tif (SG(default_charset)) {\n\t\tcharset = SG(default_charset);\n\t\tcharset_len = strlen(SG(default_charset));\n\t} else {\n\t\tcharset = SAPI_DEFAULT_CHARSET;\n\t\tcharset_len = sizeof(SAPI_DEFAULT_CHARSET) - 1;\n\t}\n\n\tif (*charset && strncasecmp(mimetype, \"text/\", 5) == 0) {\n\t\tchar *p;\n\n\t\t*len = prefix_len + mimetype_len + sizeof(\"; charset=\") - 1 + charset_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tp = content_type + prefix_len;\n\t\tmemcpy(p, mimetype, mimetype_len);\n\t\tp += mimetype_len;\n\t\tmemcpy(p, \"; charset=\", sizeof(\"; charset=\") - 1);\n\t\tp += sizeof(\"; charset=\") - 1;\n\t\tmemcpy(p, charset, charset_len + 1);\n\t} else {\n\t\t*len = prefix_len + mimetype_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tmemcpy(content_type + prefix_len, mimetype, mimetype_len + 1);\n\t}\n\treturn content_type;\n}\n\n\nSAPI_API char *sapi_get_default_content_type(TSRMLS_D)\n{\n\tuint len;\n\n\treturn get_default_content_type(0, &len TSRMLS_CC);\n}\n\n\nSAPI_API void sapi_get_default_content_type_header(sapi_header_struct *default_header TSRMLS_DC)\n{\n    uint len;\n\n\tdefault_header->header = get_default_content_type(sizeof(\"Content-type: \")-1, &len TSRMLS_CC);\n\tdefault_header->header_len = len;\n\tmemcpy(default_header->header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n}\n\n/*\n * Add charset on content-type header if the MIME type starts with\n * \"text/\", the default_charset directive is not empty and\n * there is not already a charset option in there.\n *\n * If \"mimetype\" is non-NULL, it should point to a pointer allocated\n * with emalloc().  If a charset is added, the string will be\n * re-allocated and the new length is returned.  If mimetype is\n * unchanged, 0 is returned.\n *\n */\nSAPI_API size_t sapi_apply_default_charset(char **mimetype, size_t len TSRMLS_DC)\n{\n\tchar *charset, *newtype;\n\tsize_t newlen;\n\tcharset = SG(default_charset) ? SG(default_charset) : SAPI_DEFAULT_CHARSET;\n\n\tif (*mimetype != NULL) {\n\t\tif (*charset && strncmp(*mimetype, \"text/\", 5) == 0 && strstr(*mimetype, \"charset=\") == NULL) {\n\t\t\tnewlen = len + (sizeof(\";charset=\")-1) + strlen(charset);\n\t\t\tnewtype = emalloc(newlen + 1);\n\t \t\tPHP_STRLCPY(newtype, *mimetype, newlen + 1, len);\n\t\t\tstrlcat(newtype, \";charset=\", newlen + 1);\n\t\t\tstrlcat(newtype, charset, newlen + 1);\n\t\t\tefree(*mimetype);\n\t\t\t*mimetype = newtype;\n\t\t\treturn newlen;\n\t\t}\n\t}\n\treturn 0;\n}\n\nSAPI_API void sapi_activate_headers_only(TSRMLS_D)\n{\n\tif (SG(request_info).headers_read == 1)\n\t\treturn;\n\tSG(request_info).headers_read = 1;\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), \n\t\t\t(void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/* SG(sapi_headers).http_response_code = 200; */ \n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).post_data = NULL;\n\tSG(request_info).raw_post_data = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(global_request_time) = 0;\n\n\t/*\n\t * It's possible to override this general case in the activate() callback, \n\t * if necessary.\n\t */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tif (SG(server_context)) {\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate(TSRMLS_C);\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init ) {\n\t\tsapi_module.input_filter_init(TSRMLS_C);\n\t}\n}\n\n/*\n * Called from php_request_startup() for every request.\n */\n\nSAPI_API void sapi_activate(TSRMLS_D)\n{\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/*\n\tSG(sapi_headers).http_response_code = 200;\n\t*/\n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(headers_sent) = 0;\n\tSG(callback_run) = 0;\n\tSG(callback_func) = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).post_data = NULL;\n\tSG(request_info).raw_post_data = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(request_info).proto_num = 1000; /* Default to HTTP 1.0 */\n\tSG(global_request_time) = 0;\n\n\t/* It's possible to override this general case in the activate() callback, if necessary. */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tSG(rfc1867_uploaded_files) = NULL;\n\n\t/* Handle request method */\n\tif (SG(server_context)) {\n\t\tif (PG(enable_post_data_reading) && SG(request_info).request_method) {\n\t\t\tif (SG(request_info).content_type && !strcmp(SG(request_info).request_method, \"POST\")) {\n\t\t\t\t/* HTTP POST may contain form data to be processed into variables\n\t\t\t\t * depending on given content type */\n\t\t\t\tsapi_read_post_data(TSRMLS_C);\n\t\t\t} else {\n\t\t\t\t/* Any other method with content payload will fill $HTTP_RAW_POST_DATA \n\t\t\t\t * if it is enabled by always_populate_raw_post_data. \n\t\t\t\t * It's up to the webserver to decide whether to allow a method or not. */\n\t\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\t\tif (sapi_module.default_post_reader) {\n\t\t\t\t\tsapi_module.default_post_reader(TSRMLS_C);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t}\n\n\t\t/* Cookies */\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);\n\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate(TSRMLS_C);\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init) {\n\t\tsapi_module.input_filter_init(TSRMLS_C);\n\t}\n}\n\n\nstatic void sapi_send_headers_free(TSRMLS_D)\n{\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n}\n\t\nSAPI_API void sapi_deactivate(TSRMLS_D)\n{\n\tzend_llist_destroy(&SG(sapi_headers).headers);\n\tif (SG(request_info).post_data) {\n\t\tefree(SG(request_info).post_data);\n\t}  else \tif (SG(server_context)) {\n\t\tif(sapi_module.read_post) { \n\t\t\t/* make sure we've consumed all request input data */\n\t\t\tchar dummy[SAPI_POST_BLOCK_SIZE];\n\t\t\tint read_bytes;\n\n\t\t\twhile((read_bytes = sapi_module.read_post(dummy, sizeof(dummy)-1 TSRMLS_CC)) > 0) {\n\t\t\t\tSG(read_post_bytes) += read_bytes;\n\t\t\t}\n\t\t}\n\t}\n\tif (SG(request_info).raw_post_data) {\n\t\tefree(SG(request_info).raw_post_data);\n\t} \n\tif (SG(request_info).auth_user) {\n\t\tefree(SG(request_info).auth_user);\n\t}\n\tif (SG(request_info).auth_password) {\n\t\tefree(SG(request_info).auth_password);\n\t}\n\tif (SG(request_info).auth_digest) {\n\t\tefree(SG(request_info).auth_digest);\n\t}\n\tif (SG(request_info).content_type_dup) {\n\t\tefree(SG(request_info).content_type_dup);\n\t}\n\tif (SG(request_info).current_user) {\n\t\tefree(SG(request_info).current_user);\n\t}\n\tif (sapi_module.deactivate) {\n\t\tsapi_module.deactivate(TSRMLS_C);\n\t}\n\tif (SG(rfc1867_uploaded_files)) {\n\t\tdestroy_uploaded_files_hash(TSRMLS_C);\n\t}\n\tif (SG(sapi_headers).mimetype) {\n\t\tefree(SG(sapi_headers).mimetype);\n\t\tSG(sapi_headers).mimetype = NULL;\n\t}\n\tsapi_send_headers_free(TSRMLS_C);\n\tSG(sapi_started) = 0;\n\tSG(headers_sent) = 0;\n\tSG(callback_run) = 0;\n\tif (SG(callback_func)) {\n\t\tzval_ptr_dtor(&SG(callback_func));\n\t}\n\tSG(request_info).headers_read = 0;\n\tSG(global_request_time) = 0;\n}\n\n\nSAPI_API void sapi_initialize_empty_request(TSRMLS_D)\n{\n\tSG(server_context) = NULL;\n\tSG(request_info).request_method = NULL;\n\tSG(request_info).auth_digest = SG(request_info).auth_user = SG(request_info).auth_password = NULL;\n\tSG(request_info).content_type_dup = NULL;\n}\n\n\nstatic int sapi_extract_response_code(const char *header_line)\n{\n\tint code = 200;\n\tconst char *ptr;\n\n\tfor (ptr = header_line; *ptr; ptr++) {\n\t\tif (*ptr == ' ' && *(ptr + 1) != ' ') {\n\t\t\tcode = atoi(ptr + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn code;\n}\n\n\nstatic void sapi_update_response_code(int ncode TSRMLS_DC)\n{\n\t/* if the status code did not change, we do not want\n\t   to change the status line, and no need to change the code */\n\tif (SG(sapi_headers).http_response_code == ncode) {\n\t\treturn;\n\t}\n\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n\tSG(sapi_headers).http_response_code = ncode;\n}\n\n/* \n * since zend_llist_del_element only remove one matched item once,\n * we should remove them by ourself\n */\nstatic void sapi_remove_header(zend_llist *l, char *name, uint len) {\n\tsapi_header_struct *header;\n\tzend_llist_element *next;\n\tzend_llist_element *current=l->head;\n\n\twhile (current) {\n\t\theader = (sapi_header_struct *)(current->data);\n\t\tnext = current->next;\n\t\tif (header->header_len > len && header->header[len] == ':'\n\t\t\t\t&& !strncasecmp(header->header, name, len)) {\n\t\t\tif (current->prev) {\n\t\t\t\tcurrent->prev->next = next;\n\t\t\t} else {\n\t\t\t\tl->head = next;\n\t\t\t}\n\t\t\tif (next) {\n\t\t\t\tnext->prev = current->prev;\n\t\t\t} else {\n\t\t\t\tl->tail = current->prev;\n\t\t\t}\n\t\t\tsapi_free_header(header);\n\t\t\tefree(current);\n\t\t\t--l->count;\n\t\t}\n\t\tcurrent = next;\n\t}\n}\n\nSAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\t\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr TSRMLS_CC);\n\n\tif (!duplicate)\n\t\tefree(header_line);\n\n\treturn r;\n}\n\nstatic void sapi_header_add_op(sapi_header_op_enum op, sapi_header_struct *sapi_header TSRMLS_DC)\n{\n\tif (!sapi_module.header_handler ||\n\t\t(SAPI_HEADER_ADD & sapi_module.header_handler(sapi_header, op, &SG(sapi_headers) TSRMLS_CC))) {\n\t\tif (op == SAPI_HEADER_REPLACE) {\n\t\t\tchar *colon_offset = strchr(sapi_header->header, ':');\n\n\t\t\tif (colon_offset) {\n\t\t\t\tchar sav = *colon_offset;\n\n\t\t\t\t*colon_offset = 0;\n\t\t        sapi_remove_header(&SG(sapi_headers).headers, sapi_header->header, strlen(sapi_header->header));\n\t\t\t\t*colon_offset = sav;\n\t\t\t}\n\t\t}\n\t\tzend_llist_add_element(&SG(sapi_headers).headers, (void *) sapi_header);\n\t} else {\n\t\tsapi_free_header(sapi_header);\n\t}\n}\n\nSAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n{\n\tsapi_header_struct sapi_header;\n\tchar *colon_offset;\n\tchar *header_line;\n\tuint header_line_len;\n\tint http_response_code;\n\n\tif (SG(headers_sent) && !SG(request_info).no_headers) {\n\t\tconst char *output_start_filename = php_output_get_start_filename(TSRMLS_C);\n\t\tint output_start_lineno = php_output_get_start_lineno(TSRMLS_C);\n\n\t\tif (output_start_filename) {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent by (output started at %s:%d)\",\n\t\t\t\toutput_start_filename, output_start_lineno);\n\t\t} else {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_SET_STATUS:\n\t\t\tsapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);\n\t\t\treturn SUCCESS;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\tcase SAPI_HEADER_DELETE: {\n\t\t\t\tsapi_header_line *p = arg;\n\n\t\t\t\tif (!p->line || !p->line_len) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\theader_line = p->line;\n\t\t\t\theader_line_len = p->line_len;\n\t\t\t\thttp_response_code = p->response_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tif (sapi_module.header_handler) {\n\t\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_clean(&SG(sapi_headers).headers);\n\t\t\treturn SUCCESS;\n\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n\n\theader_line = estrndup(header_line, header_line_len);\n\n\t/* cut off trailing spaces, linefeeds and carriage-returns */\n\tif (header_line_len && isspace(header_line[header_line_len-1])) {\n\t\tdo {\n\t\t\theader_line_len--;\n\t\t} while(header_line_len && isspace(header_line[header_line_len-1]));\n\t\theader_line[header_line_len]='\\0';\n\t}\n\t\n\tif (op == SAPI_HEADER_DELETE) {\n\t\tif (strchr(header_line, ':')) {\n\t\t\tefree(header_line);\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Header to delete may not contain colon.\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (sapi_module.header_handler) {\n\t\t\tsapi_header.header = header_line;\n\t\t\tsapi_header.header_len = header_line_len;\n\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t}\n\t\tsapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);\n\t\tefree(header_line);\n\t\treturn SUCCESS;\n\t} else {\n\t\t/* new line/NUL character safety check */\n\t\tint i;\n\t\tfor (i = 0; i < header_line_len; i++) {\n\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n\t\t\tint illegal_break =\n\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n\t\t\t\t\t&& (\n\t\t\t\t\t\theader_line[i] == '\\n'\n\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n\t\t\tif (illegal_break) {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n\t\t\t\t\t\t\"more than a single header, new line detected\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (header_line[i] == '\\0') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain NUL bytes\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tsapi_header.header = header_line;\n\tsapi_header.header_len = header_line_len;\n\n\t/* Check the header for a few cases that we have special support for in SAPI */\n\tif (header_line_len>=5 \n\t\t&& !strncasecmp(header_line, \"HTTP/\", 5)) {\n\t\t/* filter out the response code */\n\t\tsapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);\n\t\t/* sapi_update_response_code doesn't free the status line if the code didn't change */\n\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\tefree(SG(sapi_headers).http_status_line);\n\t\t}\n\t\tSG(sapi_headers).http_status_line = header_line;\n\t\treturn SUCCESS;\n\t} else {\n\t\tcolon_offset = strchr(header_line, ':');\n\t\tif (colon_offset) {\n\t\t\t*colon_offset = 0;\n\t\t\tif (!STRCASECMP(header_line, \"Content-Type\")) {\n\t\t\t\tchar *ptr = colon_offset+1, *mimetype = NULL, *newheader;\n\t\t\t\tsize_t len = header_line_len - (ptr - header_line), newlen;\n\t\t\t\twhile (*ptr == ' ') {\n\t\t\t\t\tptr++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\n\t\t\t\t/* Disable possible output compression for images */\n\t\t\t\tif (!strncmp(ptr, \"image/\", sizeof(\"image/\")-1)) {\n\t\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"), \"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t\t}\n\n\t\t\t\tmimetype = estrdup(ptr);\n\t\t\t\tnewlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);\n\t\t\t\tif (!SG(sapi_headers).mimetype){\n\t\t\t\t\tSG(sapi_headers).mimetype = estrdup(mimetype);\n\t\t\t\t}\n\n\t\t\t\tif (newlen != 0) {\n\t\t\t\t\tnewlen += sizeof(\"Content-type: \");\n\t\t\t\t\tnewheader = emalloc(newlen);\n\t\t\t\t\tPHP_STRLCPY(newheader, \"Content-type: \", newlen, sizeof(\"Content-type: \")-1);\n\t\t\t\t\tstrlcat(newheader, mimetype, newlen);\n\t\t\t\t\tsapi_header.header = newheader;\n\t\t\t\t\tsapi_header.header_len = newlen - 1;\n\t\t\t\t\tefree(header_line);\n\t\t\t\t}\n\t\t\t\tefree(mimetype);\n\t\t\t\tSG(sapi_headers).send_default_content_type = 0;\n\t\t\t} else if (!STRCASECMP(header_line, \"Content-Length\")) {\n\t\t\t\t/* Script is setting Content-length. The script cannot reasonably\n\t\t\t\t * know the size of the message body after compression, so it's best\n\t\t\t\t * do disable compression altogether. This contributes to making scripts\n\t\t\t\t * portable between setups that have and don't have zlib compression\n\t\t\t\t * enabled globally. See req #44164 */\n\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"),\n\t\t\t\t\t\"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t} else if (!STRCASECMP(header_line, \"Location\")) {\n\t\t\t\tif ((SG(sapi_headers).http_response_code < 300 ||\n\t\t\t\t\tSG(sapi_headers).http_response_code > 399) &&\n\t\t\t\t\tSG(sapi_headers).http_response_code != 201) {\n\t\t\t\t\t/* Return a Found Redirect if one is not already specified */\n\t\t\t\t\tif (http_response_code) { /* user specified redirect code */\n\t\t\t\t\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t\t\t\t\t} else if (SG(request_info).proto_num > 1000 && \n\t\t\t\t\t   SG(request_info).request_method && \n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"HEAD\") &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"GET\")) {\n\t\t\t\t\t\tsapi_update_response_code(303 TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsapi_update_response_code(302 TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!STRCASECMP(header_line, \"WWW-Authenticate\")) { /* HTTP Authentication */\n\t\t\t\tsapi_update_response_code(401 TSRMLS_CC); /* authentication-required */\n\t\t\t}\n\t\t\tif (sapi_header.header==header_line) {\n\t\t\t\t*colon_offset = ':';\n\t\t\t}\n\t\t}\n\t}\n\tif (http_response_code) {\n\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t}\n\tsapi_header_add_op(op, &sapi_header TSRMLS_CC);\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_send_headers(TSRMLS_D)\n{\n\tint retval;\n\tint ret = FAILURE;\n\n\tif (SG(headers_sent) || SG(request_info).no_headers || SG(callback_run)) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* Success-oriented.  We set headers_sent to 1 here to avoid an infinite loop\n\t * in case of an error situation.\n\t */\n\tif (SG(sapi_headers).send_default_content_type && sapi_module.send_headers) {\n\t\tsapi_header_struct default_header;\n\t    uint len;\n\n\t\tSG(sapi_headers).mimetype = get_default_content_type(0, &len TSRMLS_CC);\n\t\tdefault_header.header_len = sizeof(\"Content-type: \") - 1 + len;\n\t\tdefault_header.header = emalloc(default_header.header_len + 1);\n\t\tmemcpy(default_header.header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n\t\tmemcpy(default_header.header + sizeof(\"Content-type: \") - 1, SG(sapi_headers).mimetype, len + 1);\n\t\tsapi_header_add_op(SAPI_HEADER_ADD, &default_header TSRMLS_CC);\n\t\tSG(sapi_headers).send_default_content_type = 0;\n\t}\n\n\tif (SG(callback_func) && !SG(callback_run)) {\n\t\tSG(callback_run) = 1;\n\t\tsapi_run_header_callback(TSRMLS_C);\n\t}\n\n\tSG(headers_sent) = 1;\n\n\tif (sapi_module.send_headers) {\n\t\tretval = sapi_module.send_headers(&SG(sapi_headers) TSRMLS_CC);\n\t} else {\n\t\tretval = SAPI_HEADER_DO_SEND;\n\t}\n\n\tswitch (retval) {\n\t\tcase SAPI_HEADER_SENT_SUCCESSFULLY:\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_DO_SEND: {\n\t\t\t\tsapi_header_struct http_status_line;\n\t\t\t\tchar buf[255];\n\n\t\t\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\t\t\thttp_status_line.header = SG(sapi_headers).http_status_line;\n\t\t\t\t\thttp_status_line.header_len = strlen(SG(sapi_headers).http_status_line);\n\t\t\t\t} else {\n\t\t\t\t\thttp_status_line.header = buf;\n\t\t\t\t\thttp_status_line.header_len = slprintf(buf, sizeof(buf), \"HTTP/1.0 %d X\", SG(sapi_headers).http_response_code);\n\t\t\t\t}\n\t\t\t\tsapi_module.send_header(&http_status_line, SG(server_context) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_apply_with_argument(&SG(sapi_headers).headers, (llist_apply_with_arg_func_t) sapi_module.send_header, SG(server_context) TSRMLS_CC);\n\t\t\tif(SG(sapi_headers).send_default_content_type) {\n\t\t\t\tsapi_header_struct default_header;\n\n\t\t\t\tsapi_get_default_content_type_header(&default_header TSRMLS_CC);\n\t\t\t\tsapi_module.send_header(&default_header, SG(server_context) TSRMLS_CC);\n\t\t\t\tsapi_free_header(&default_header);\n\t\t\t}\n\t\t\tsapi_module.send_header(NULL, SG(server_context) TSRMLS_CC);\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_SEND_FAILED:\n\t\t\tSG(headers_sent) = 0;\n\t\t\tret = FAILURE;\n\t\t\tbreak;\n\t}\n\n\tsapi_send_headers_free(TSRMLS_C);\n\n\treturn ret;\n}\n\n\nSAPI_API int sapi_register_post_entries(sapi_post_entry *post_entries TSRMLS_DC)\n{\n\tsapi_post_entry *p=post_entries;\n\n\twhile (p->content_type) {\n\t\tif (sapi_register_post_entry(p TSRMLS_CC) == FAILURE) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tp++;\n\t}\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_post_entry(sapi_post_entry *post_entry TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\treturn zend_hash_add(&SG(known_post_content_types),\n\t\t\tpost_entry->content_type, post_entry->content_type_len+1,\n\t\t\t(void *) post_entry, sizeof(sapi_post_entry), NULL);\n}\n\nSAPI_API void sapi_unregister_post_entry(sapi_post_entry *post_entry TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn;\n\t}\n\tzend_hash_del(&SG(known_post_content_types), post_entry->content_type,\n\t\t\tpost_entry->content_type_len+1);\n}\n\n\nSAPI_API int sapi_register_default_post_reader(void (*default_post_reader)(TSRMLS_D) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.default_post_reader = default_post_reader;\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_treat_data(void (*treat_data)(int arg, char *str, zval *destArray TSRMLS_DC) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.treat_data = treat_data;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_register_input_filter(unsigned int (*input_filter)(int arg, char *var, char **val, unsigned int val_len, unsigned int *new_val_len TSRMLS_DC), unsigned int (*input_filter_init)(TSRMLS_D) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.input_filter = input_filter;\n\tsapi_module.input_filter_init = input_filter_init;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_flush(TSRMLS_D)\n{\n\tif (sapi_module.flush) {\n\t\tsapi_module.flush(SG(server_context));\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API struct stat *sapi_get_stat(TSRMLS_D)\n{\n\tif (sapi_module.get_stat) {\n\t\treturn sapi_module.get_stat(TSRMLS_C);\n\t} else {\n\t\tif (!SG(request_info).path_translated || (VCWD_STAT(SG(request_info).path_translated, &SG(global_stat)) == -1)) {\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &SG(global_stat);\n\t}\n}\n\nSAPI_API char *sapi_getenv(char *name, size_t name_len TSRMLS_DC)\n{\n\tif (sapi_module.getenv) { \n\t\tchar *value, *tmp = sapi_module.getenv(name, name_len TSRMLS_CC);\n\t\tif (tmp) {\n\t\t\tvalue = estrdup(tmp);\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (sapi_module.input_filter) {\n\t\t\tsapi_module.input_filter(PARSE_STRING, name, &value, strlen(value), NULL TSRMLS_CC);\n\t\t}\n\t\treturn value;\n\t}\n\treturn NULL;\n}\n\nSAPI_API int sapi_get_fd(int *fd TSRMLS_DC)\n{\n\tif (sapi_module.get_fd) {\n\t\treturn sapi_module.get_fd(fd TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_force_http_10(TSRMLS_D)\n{\n\tif (sapi_module.force_http_10) {\n\t\treturn sapi_module.force_http_10(TSRMLS_C);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\n\nSAPI_API int sapi_get_target_uid(uid_t *obj TSRMLS_DC)\n{\n\tif (sapi_module.get_target_uid) {\n\t\treturn sapi_module.get_target_uid(obj TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_get_target_gid(gid_t *obj TSRMLS_DC)\n{\n\tif (sapi_module.get_target_gid) {\n\t\treturn sapi_module.get_target_gid(obj TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API double sapi_get_request_time(TSRMLS_D)\n{\n\tif(SG(global_request_time)) return SG(global_request_time);\n\n\tif (sapi_module.get_request_time && SG(server_context)) {\n\t\tSG(global_request_time) = sapi_module.get_request_time(TSRMLS_C);\n\t} else {\n\t\tstruct timeval tp = {0};\n\t\tif (!gettimeofday(&tp, NULL)) {\n\t\t\tSG(global_request_time) = (double)(tp.tv_sec + tp.tv_usec / 1000000.00);\n\t\t} else {\n\t\t\tSG(global_request_time) = (double)time(0);\n\t\t}\n\t}\n\treturn SG(global_request_time);\n}\n\nSAPI_API void sapi_terminate_process(TSRMLS_D) {\n\tif (sapi_module.terminate_process) {\n\t\tsapi_module.terminate_process(TSRMLS_C);\n\t}\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "fixing_code": ["--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-foo: e\\n foo\");\necho 'foo';\n?>\n--EXPECTF--\n\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain NUL bytes in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), CRLF\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-foo: e\\r\\nfoo\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "/* \n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2015 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Original design:  Shane Caraveo <shane@caraveo.com>                  |\n   | Authors: Andi Gutmans <andi@zend.com>                                |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n#include <ctype.h>\n#include <sys/stat.h>\n\n#include \"php.h\"\n#include \"SAPI.h\"\n#include \"php_variables.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/php_string.h\"\n#include \"ext/standard/pageinfo.h\"\n#if (HAVE_PCRE || HAVE_BUNDLED_PCRE) && !defined(COMPILE_DL_PCRE)\n#include \"ext/pcre/php_pcre.h\"\n#endif\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#elif defined(PHP_WIN32)\n#include \"win32/time.h\"\n#endif\n\n#include \"rfc1867.h\"\n\n#ifdef PHP_WIN32\n#define STRCASECMP stricmp\n#else\n#define STRCASECMP strcasecmp\n#endif\n\n#include \"php_content_types.h\"\n\n#ifdef ZTS\nSAPI_API int sapi_globals_id;\n#else\nsapi_globals_struct sapi_globals;\n#endif\n\nstatic void sapi_globals_ctor(sapi_globals_struct *sapi_globals TSRMLS_DC)\n{\n\tmemset(sapi_globals, 0, sizeof(*sapi_globals));\n\tzend_hash_init_ex(&sapi_globals->known_post_content_types, 5, NULL, NULL, 1, 0);\n\tphp_setup_sapi_content_types(TSRMLS_C);\n}\n\nstatic void sapi_globals_dtor(sapi_globals_struct *sapi_globals TSRMLS_DC)\n{\n\tzend_hash_destroy(&sapi_globals->known_post_content_types);\n}\n\n/* True globals (no need for thread safety) */\nSAPI_API sapi_module_struct sapi_module;\n\n\nSAPI_API void sapi_startup(sapi_module_struct *sf)\n{\n#ifdef ZEND_SIGNALS\n\tzend_signal_startup();\n#endif\n\n\tsf->ini_entries = NULL;\n\tsapi_module = *sf;\n\n#ifdef ZTS\n\tts_allocate_id(&sapi_globals_id, sizeof(sapi_globals_struct), (ts_allocate_ctor) sapi_globals_ctor, (ts_allocate_dtor) sapi_globals_dtor);\n# ifdef PHP_WIN32\n\t_configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n# endif\n#else\n\tsapi_globals_ctor(&sapi_globals);\n#endif\n\n\tvirtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */\n\n#ifdef PHP_WIN32\n\ttsrm_win32_startup();\n#endif\n\n\treentrancy_startup();\n}\n\nSAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\n\treentrancy_shutdown();\n\n\tvirtual_cwd_shutdown();\n\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}\n\n\nSAPI_API void sapi_free_header(sapi_header_struct *sapi_header)\n{\n\tefree(sapi_header->header);\n}\n\n/* {{{ proto bool header_register_callback(mixed callback)\n   call a header function */\nPHP_FUNCTION(header_register_callback)\n{\n\tzval *callback_func;\n\tchar *callback_name;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &callback_func) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (!zend_is_callable(callback_func, 0, &callback_name TSRMLS_CC)) {\n\t\tefree(callback_name);\n\t\tRETURN_FALSE;\n\t}\n\n\tefree(callback_name);\n\n\tif (SG(callback_func)) {\n\t\tzval_ptr_dtor(&SG(callback_func));\n\t\tSG(fci_cache) = empty_fcall_info_cache;\n\t}\n\n\tSG(callback_func) = callback_func;\n\n\tZ_ADDREF_P(SG(callback_func));\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void sapi_run_header_callback(TSRMLS_D)\n{\n\tint   error;\n\tzend_fcall_info fci;\n\tchar *callback_name = NULL;\n\tchar *callback_error = NULL;\n\tzval *retval_ptr = NULL;\n\t\n\tif (zend_fcall_info_init(SG(callback_func), 0, &fci, &SG(fci_cache), &callback_name, &callback_error TSRMLS_CC) == SUCCESS) {\n\t\tfci.retval_ptr_ptr = &retval_ptr;\n\t\t\n\t\terror = zend_call_function(&fci, &SG(fci_cache) TSRMLS_CC);\n\t\tif (error == FAILURE) {\n\t\t\tgoto callback_failed;\n\t\t} else if (retval_ptr) {\n\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t}\n\t} else {\ncallback_failed:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not call the sapi_header_callback\");\n\t}\n\t\n\tif (callback_name) {\n\t\tefree(callback_name);\n\t}\n\tif (callback_error) {\n\t\tefree(callback_error);\n\t}\t\n}\n\nSAPI_API void sapi_handle_post(void *arg TSRMLS_DC)\n{\n\tif (SG(request_info).post_entry && SG(request_info).content_type_dup) {\n\t\tSG(request_info).post_entry->post_handler(SG(request_info).content_type_dup, arg TSRMLS_CC);\n\t\tif (SG(request_info).post_data) {\n\t\t\tefree(SG(request_info).post_data);\n\t\t\tSG(request_info).post_data = NULL;\n\t\t}\n\t\tefree(SG(request_info).content_type_dup);\n\t\tSG(request_info).content_type_dup = NULL;\n\t}\n}\n\nstatic void sapi_read_post_data(TSRMLS_D)\n{\n\tsapi_post_entry *post_entry;\n\tuint content_type_length = strlen(SG(request_info).content_type);\n\tchar *content_type = estrndup(SG(request_info).content_type, content_type_length);\n\tchar *p;\n\tchar oldchar=0;\n\tvoid (*post_reader_func)(TSRMLS_D) = NULL;\n\n\n\t/* dedicated implementation for increased performance:\n\t * - Make the content type lowercase\n\t * - Trim descriptive data, stay with the content-type only\n\t */\n\tfor (p=content_type; p<content_type+content_type_length; p++) {\n\t\tswitch (*p) {\n\t\t\tcase ';':\n\t\t\tcase ',':\n\t\t\tcase ' ':\n\t\t\t\tcontent_type_length = p-content_type;\n\t\t\t\toldchar = *p;\n\t\t\t\t*p = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*p = tolower(*p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now try to find an appropriate POST content handler */\n\tif (zend_hash_find(&SG(known_post_content_types), content_type,\n\t\t\tcontent_type_length+1, (void **) &post_entry) == SUCCESS) {\n\t\t/* found one, register it for use */\n\t\tSG(request_info).post_entry = post_entry;\n\t\tpost_reader_func = post_entry->post_reader;\n\t} else {\n\t\t/* fallback */\n\t\tSG(request_info).post_entry = NULL;\n\t\tif (!sapi_module.default_post_reader) {\n\t\t\t/* no default reader ? */\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Unsupported content type:  '%s'\", content_type);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (oldchar) {\n\t\t*(p-1) = oldchar;\n\t}\n\n\tSG(request_info).content_type_dup = content_type;\n\n\tif(post_reader_func) {\n\t\tpost_reader_func(TSRMLS_C);\n\t}\n\n\tif(sapi_module.default_post_reader) {\n\t\tsapi_module.default_post_reader(TSRMLS_C);\n\t}\n}\n\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n\n\nstatic inline char *get_default_content_type(uint prefix_len, uint *len TSRMLS_DC)\n{\n\tchar *mimetype, *charset, *content_type;\n\tuint mimetype_len, charset_len;\n\n\tif (SG(default_mimetype)) {\n\t\tmimetype = SG(default_mimetype);\n\t\tmimetype_len = strlen(SG(default_mimetype));\n\t} else {\n\t\tmimetype = SAPI_DEFAULT_MIMETYPE;\n\t\tmimetype_len = sizeof(SAPI_DEFAULT_MIMETYPE) - 1;\n\t}\n\tif (SG(default_charset)) {\n\t\tcharset = SG(default_charset);\n\t\tcharset_len = strlen(SG(default_charset));\n\t} else {\n\t\tcharset = SAPI_DEFAULT_CHARSET;\n\t\tcharset_len = sizeof(SAPI_DEFAULT_CHARSET) - 1;\n\t}\n\n\tif (*charset && strncasecmp(mimetype, \"text/\", 5) == 0) {\n\t\tchar *p;\n\n\t\t*len = prefix_len + mimetype_len + sizeof(\"; charset=\") - 1 + charset_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tp = content_type + prefix_len;\n\t\tmemcpy(p, mimetype, mimetype_len);\n\t\tp += mimetype_len;\n\t\tmemcpy(p, \"; charset=\", sizeof(\"; charset=\") - 1);\n\t\tp += sizeof(\"; charset=\") - 1;\n\t\tmemcpy(p, charset, charset_len + 1);\n\t} else {\n\t\t*len = prefix_len + mimetype_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tmemcpy(content_type + prefix_len, mimetype, mimetype_len + 1);\n\t}\n\treturn content_type;\n}\n\n\nSAPI_API char *sapi_get_default_content_type(TSRMLS_D)\n{\n\tuint len;\n\n\treturn get_default_content_type(0, &len TSRMLS_CC);\n}\n\n\nSAPI_API void sapi_get_default_content_type_header(sapi_header_struct *default_header TSRMLS_DC)\n{\n    uint len;\n\n\tdefault_header->header = get_default_content_type(sizeof(\"Content-type: \")-1, &len TSRMLS_CC);\n\tdefault_header->header_len = len;\n\tmemcpy(default_header->header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n}\n\n/*\n * Add charset on content-type header if the MIME type starts with\n * \"text/\", the default_charset directive is not empty and\n * there is not already a charset option in there.\n *\n * If \"mimetype\" is non-NULL, it should point to a pointer allocated\n * with emalloc().  If a charset is added, the string will be\n * re-allocated and the new length is returned.  If mimetype is\n * unchanged, 0 is returned.\n *\n */\nSAPI_API size_t sapi_apply_default_charset(char **mimetype, size_t len TSRMLS_DC)\n{\n\tchar *charset, *newtype;\n\tsize_t newlen;\n\tcharset = SG(default_charset) ? SG(default_charset) : SAPI_DEFAULT_CHARSET;\n\n\tif (*mimetype != NULL) {\n\t\tif (*charset && strncmp(*mimetype, \"text/\", 5) == 0 && strstr(*mimetype, \"charset=\") == NULL) {\n\t\t\tnewlen = len + (sizeof(\";charset=\")-1) + strlen(charset);\n\t\t\tnewtype = emalloc(newlen + 1);\n\t \t\tPHP_STRLCPY(newtype, *mimetype, newlen + 1, len);\n\t\t\tstrlcat(newtype, \";charset=\", newlen + 1);\n\t\t\tstrlcat(newtype, charset, newlen + 1);\n\t\t\tefree(*mimetype);\n\t\t\t*mimetype = newtype;\n\t\t\treturn newlen;\n\t\t}\n\t}\n\treturn 0;\n}\n\nSAPI_API void sapi_activate_headers_only(TSRMLS_D)\n{\n\tif (SG(request_info).headers_read == 1)\n\t\treturn;\n\tSG(request_info).headers_read = 1;\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), \n\t\t\t(void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/* SG(sapi_headers).http_response_code = 200; */ \n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).post_data = NULL;\n\tSG(request_info).raw_post_data = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(global_request_time) = 0;\n\n\t/*\n\t * It's possible to override this general case in the activate() callback, \n\t * if necessary.\n\t */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tif (SG(server_context)) {\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate(TSRMLS_C);\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init ) {\n\t\tsapi_module.input_filter_init(TSRMLS_C);\n\t}\n}\n\n/*\n * Called from php_request_startup() for every request.\n */\n\nSAPI_API void sapi_activate(TSRMLS_D)\n{\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/*\n\tSG(sapi_headers).http_response_code = 200;\n\t*/\n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(headers_sent) = 0;\n\tSG(callback_run) = 0;\n\tSG(callback_func) = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).post_data = NULL;\n\tSG(request_info).raw_post_data = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(request_info).proto_num = 1000; /* Default to HTTP 1.0 */\n\tSG(global_request_time) = 0;\n\n\t/* It's possible to override this general case in the activate() callback, if necessary. */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tSG(rfc1867_uploaded_files) = NULL;\n\n\t/* Handle request method */\n\tif (SG(server_context)) {\n\t\tif (PG(enable_post_data_reading) && SG(request_info).request_method) {\n\t\t\tif (SG(request_info).content_type && !strcmp(SG(request_info).request_method, \"POST\")) {\n\t\t\t\t/* HTTP POST may contain form data to be processed into variables\n\t\t\t\t * depending on given content type */\n\t\t\t\tsapi_read_post_data(TSRMLS_C);\n\t\t\t} else {\n\t\t\t\t/* Any other method with content payload will fill $HTTP_RAW_POST_DATA \n\t\t\t\t * if it is enabled by always_populate_raw_post_data. \n\t\t\t\t * It's up to the webserver to decide whether to allow a method or not. */\n\t\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\t\tif (sapi_module.default_post_reader) {\n\t\t\t\t\tsapi_module.default_post_reader(TSRMLS_C);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t}\n\n\t\t/* Cookies */\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);\n\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate(TSRMLS_C);\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init) {\n\t\tsapi_module.input_filter_init(TSRMLS_C);\n\t}\n}\n\n\nstatic void sapi_send_headers_free(TSRMLS_D)\n{\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n}\n\t\nSAPI_API void sapi_deactivate(TSRMLS_D)\n{\n\tzend_llist_destroy(&SG(sapi_headers).headers);\n\tif (SG(request_info).post_data) {\n\t\tefree(SG(request_info).post_data);\n\t}  else \tif (SG(server_context)) {\n\t\tif(sapi_module.read_post) { \n\t\t\t/* make sure we've consumed all request input data */\n\t\t\tchar dummy[SAPI_POST_BLOCK_SIZE];\n\t\t\tint read_bytes;\n\n\t\t\twhile((read_bytes = sapi_module.read_post(dummy, sizeof(dummy)-1 TSRMLS_CC)) > 0) {\n\t\t\t\tSG(read_post_bytes) += read_bytes;\n\t\t\t}\n\t\t}\n\t}\n\tif (SG(request_info).raw_post_data) {\n\t\tefree(SG(request_info).raw_post_data);\n\t} \n\tif (SG(request_info).auth_user) {\n\t\tefree(SG(request_info).auth_user);\n\t}\n\tif (SG(request_info).auth_password) {\n\t\tefree(SG(request_info).auth_password);\n\t}\n\tif (SG(request_info).auth_digest) {\n\t\tefree(SG(request_info).auth_digest);\n\t}\n\tif (SG(request_info).content_type_dup) {\n\t\tefree(SG(request_info).content_type_dup);\n\t}\n\tif (SG(request_info).current_user) {\n\t\tefree(SG(request_info).current_user);\n\t}\n\tif (sapi_module.deactivate) {\n\t\tsapi_module.deactivate(TSRMLS_C);\n\t}\n\tif (SG(rfc1867_uploaded_files)) {\n\t\tdestroy_uploaded_files_hash(TSRMLS_C);\n\t}\n\tif (SG(sapi_headers).mimetype) {\n\t\tefree(SG(sapi_headers).mimetype);\n\t\tSG(sapi_headers).mimetype = NULL;\n\t}\n\tsapi_send_headers_free(TSRMLS_C);\n\tSG(sapi_started) = 0;\n\tSG(headers_sent) = 0;\n\tSG(callback_run) = 0;\n\tif (SG(callback_func)) {\n\t\tzval_ptr_dtor(&SG(callback_func));\n\t}\n\tSG(request_info).headers_read = 0;\n\tSG(global_request_time) = 0;\n}\n\n\nSAPI_API void sapi_initialize_empty_request(TSRMLS_D)\n{\n\tSG(server_context) = NULL;\n\tSG(request_info).request_method = NULL;\n\tSG(request_info).auth_digest = SG(request_info).auth_user = SG(request_info).auth_password = NULL;\n\tSG(request_info).content_type_dup = NULL;\n}\n\n\nstatic int sapi_extract_response_code(const char *header_line)\n{\n\tint code = 200;\n\tconst char *ptr;\n\n\tfor (ptr = header_line; *ptr; ptr++) {\n\t\tif (*ptr == ' ' && *(ptr + 1) != ' ') {\n\t\t\tcode = atoi(ptr + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn code;\n}\n\n\nstatic void sapi_update_response_code(int ncode TSRMLS_DC)\n{\n\t/* if the status code did not change, we do not want\n\t   to change the status line, and no need to change the code */\n\tif (SG(sapi_headers).http_response_code == ncode) {\n\t\treturn;\n\t}\n\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n\tSG(sapi_headers).http_response_code = ncode;\n}\n\n/* \n * since zend_llist_del_element only remove one matched item once,\n * we should remove them by ourself\n */\nstatic void sapi_remove_header(zend_llist *l, char *name, uint len) {\n\tsapi_header_struct *header;\n\tzend_llist_element *next;\n\tzend_llist_element *current=l->head;\n\n\twhile (current) {\n\t\theader = (sapi_header_struct *)(current->data);\n\t\tnext = current->next;\n\t\tif (header->header_len > len && header->header[len] == ':'\n\t\t\t\t&& !strncasecmp(header->header, name, len)) {\n\t\t\tif (current->prev) {\n\t\t\t\tcurrent->prev->next = next;\n\t\t\t} else {\n\t\t\t\tl->head = next;\n\t\t\t}\n\t\t\tif (next) {\n\t\t\t\tnext->prev = current->prev;\n\t\t\t} else {\n\t\t\t\tl->tail = current->prev;\n\t\t\t}\n\t\t\tsapi_free_header(header);\n\t\t\tefree(current);\n\t\t\t--l->count;\n\t\t}\n\t\tcurrent = next;\n\t}\n}\n\nSAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\t\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr TSRMLS_CC);\n\n\tif (!duplicate)\n\t\tefree(header_line);\n\n\treturn r;\n}\n\nstatic void sapi_header_add_op(sapi_header_op_enum op, sapi_header_struct *sapi_header TSRMLS_DC)\n{\n\tif (!sapi_module.header_handler ||\n\t\t(SAPI_HEADER_ADD & sapi_module.header_handler(sapi_header, op, &SG(sapi_headers) TSRMLS_CC))) {\n\t\tif (op == SAPI_HEADER_REPLACE) {\n\t\t\tchar *colon_offset = strchr(sapi_header->header, ':');\n\n\t\t\tif (colon_offset) {\n\t\t\t\tchar sav = *colon_offset;\n\n\t\t\t\t*colon_offset = 0;\n\t\t        sapi_remove_header(&SG(sapi_headers).headers, sapi_header->header, strlen(sapi_header->header));\n\t\t\t\t*colon_offset = sav;\n\t\t\t}\n\t\t}\n\t\tzend_llist_add_element(&SG(sapi_headers).headers, (void *) sapi_header);\n\t} else {\n\t\tsapi_free_header(sapi_header);\n\t}\n}\n\nSAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n{\n\tsapi_header_struct sapi_header;\n\tchar *colon_offset;\n\tchar *header_line;\n\tuint header_line_len;\n\tint http_response_code;\n\n\tif (SG(headers_sent) && !SG(request_info).no_headers) {\n\t\tconst char *output_start_filename = php_output_get_start_filename(TSRMLS_C);\n\t\tint output_start_lineno = php_output_get_start_lineno(TSRMLS_C);\n\n\t\tif (output_start_filename) {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent by (output started at %s:%d)\",\n\t\t\t\toutput_start_filename, output_start_lineno);\n\t\t} else {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_SET_STATUS:\n\t\t\tsapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);\n\t\t\treturn SUCCESS;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\tcase SAPI_HEADER_DELETE: {\n\t\t\t\tsapi_header_line *p = arg;\n\n\t\t\t\tif (!p->line || !p->line_len) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\theader_line = p->line;\n\t\t\t\theader_line_len = p->line_len;\n\t\t\t\thttp_response_code = p->response_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tif (sapi_module.header_handler) {\n\t\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_clean(&SG(sapi_headers).headers);\n\t\t\treturn SUCCESS;\n\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n\n\theader_line = estrndup(header_line, header_line_len);\n\n\t/* cut off trailing spaces, linefeeds and carriage-returns */\n\tif (header_line_len && isspace(header_line[header_line_len-1])) {\n\t\tdo {\n\t\t\theader_line_len--;\n\t\t} while(header_line_len && isspace(header_line[header_line_len-1]));\n\t\theader_line[header_line_len]='\\0';\n\t}\n\t\n\tif (op == SAPI_HEADER_DELETE) {\n\t\tif (strchr(header_line, ':')) {\n\t\t\tefree(header_line);\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Header to delete may not contain colon.\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (sapi_module.header_handler) {\n\t\t\tsapi_header.header = header_line;\n\t\t\tsapi_header.header_len = header_line_len;\n\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t}\n\t\tsapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);\n\t\tefree(header_line);\n\t\treturn SUCCESS;\n\t} else {\n\t\t/* new line/NUL character safety check */\n\t\tint i;\n\t\tfor (i = 0; i < header_line_len; i++) {\n\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n\t\t\t\t\t\t\"more than a single header, new line detected\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (header_line[i] == '\\0') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain NUL bytes\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tsapi_header.header = header_line;\n\tsapi_header.header_len = header_line_len;\n\n\t/* Check the header for a few cases that we have special support for in SAPI */\n\tif (header_line_len>=5 \n\t\t&& !strncasecmp(header_line, \"HTTP/\", 5)) {\n\t\t/* filter out the response code */\n\t\tsapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);\n\t\t/* sapi_update_response_code doesn't free the status line if the code didn't change */\n\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\tefree(SG(sapi_headers).http_status_line);\n\t\t}\n\t\tSG(sapi_headers).http_status_line = header_line;\n\t\treturn SUCCESS;\n\t} else {\n\t\tcolon_offset = strchr(header_line, ':');\n\t\tif (colon_offset) {\n\t\t\t*colon_offset = 0;\n\t\t\tif (!STRCASECMP(header_line, \"Content-Type\")) {\n\t\t\t\tchar *ptr = colon_offset+1, *mimetype = NULL, *newheader;\n\t\t\t\tsize_t len = header_line_len - (ptr - header_line), newlen;\n\t\t\t\twhile (*ptr == ' ') {\n\t\t\t\t\tptr++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\n\t\t\t\t/* Disable possible output compression for images */\n\t\t\t\tif (!strncmp(ptr, \"image/\", sizeof(\"image/\")-1)) {\n\t\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"), \"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t\t}\n\n\t\t\t\tmimetype = estrdup(ptr);\n\t\t\t\tnewlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);\n\t\t\t\tif (!SG(sapi_headers).mimetype){\n\t\t\t\t\tSG(sapi_headers).mimetype = estrdup(mimetype);\n\t\t\t\t}\n\n\t\t\t\tif (newlen != 0) {\n\t\t\t\t\tnewlen += sizeof(\"Content-type: \");\n\t\t\t\t\tnewheader = emalloc(newlen);\n\t\t\t\t\tPHP_STRLCPY(newheader, \"Content-type: \", newlen, sizeof(\"Content-type: \")-1);\n\t\t\t\t\tstrlcat(newheader, mimetype, newlen);\n\t\t\t\t\tsapi_header.header = newheader;\n\t\t\t\t\tsapi_header.header_len = newlen - 1;\n\t\t\t\t\tefree(header_line);\n\t\t\t\t}\n\t\t\t\tefree(mimetype);\n\t\t\t\tSG(sapi_headers).send_default_content_type = 0;\n\t\t\t} else if (!STRCASECMP(header_line, \"Content-Length\")) {\n\t\t\t\t/* Script is setting Content-length. The script cannot reasonably\n\t\t\t\t * know the size of the message body after compression, so it's best\n\t\t\t\t * do disable compression altogether. This contributes to making scripts\n\t\t\t\t * portable between setups that have and don't have zlib compression\n\t\t\t\t * enabled globally. See req #44164 */\n\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"),\n\t\t\t\t\t\"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t} else if (!STRCASECMP(header_line, \"Location\")) {\n\t\t\t\tif ((SG(sapi_headers).http_response_code < 300 ||\n\t\t\t\t\tSG(sapi_headers).http_response_code > 399) &&\n\t\t\t\t\tSG(sapi_headers).http_response_code != 201) {\n\t\t\t\t\t/* Return a Found Redirect if one is not already specified */\n\t\t\t\t\tif (http_response_code) { /* user specified redirect code */\n\t\t\t\t\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t\t\t\t\t} else if (SG(request_info).proto_num > 1000 && \n\t\t\t\t\t   SG(request_info).request_method && \n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"HEAD\") &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"GET\")) {\n\t\t\t\t\t\tsapi_update_response_code(303 TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsapi_update_response_code(302 TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!STRCASECMP(header_line, \"WWW-Authenticate\")) { /* HTTP Authentication */\n\t\t\t\tsapi_update_response_code(401 TSRMLS_CC); /* authentication-required */\n\t\t\t}\n\t\t\tif (sapi_header.header==header_line) {\n\t\t\t\t*colon_offset = ':';\n\t\t\t}\n\t\t}\n\t}\n\tif (http_response_code) {\n\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t}\n\tsapi_header_add_op(op, &sapi_header TSRMLS_CC);\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_send_headers(TSRMLS_D)\n{\n\tint retval;\n\tint ret = FAILURE;\n\n\tif (SG(headers_sent) || SG(request_info).no_headers || SG(callback_run)) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* Success-oriented.  We set headers_sent to 1 here to avoid an infinite loop\n\t * in case of an error situation.\n\t */\n\tif (SG(sapi_headers).send_default_content_type && sapi_module.send_headers) {\n\t\tsapi_header_struct default_header;\n\t    uint len;\n\n\t\tSG(sapi_headers).mimetype = get_default_content_type(0, &len TSRMLS_CC);\n\t\tdefault_header.header_len = sizeof(\"Content-type: \") - 1 + len;\n\t\tdefault_header.header = emalloc(default_header.header_len + 1);\n\t\tmemcpy(default_header.header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n\t\tmemcpy(default_header.header + sizeof(\"Content-type: \") - 1, SG(sapi_headers).mimetype, len + 1);\n\t\tsapi_header_add_op(SAPI_HEADER_ADD, &default_header TSRMLS_CC);\n\t\tSG(sapi_headers).send_default_content_type = 0;\n\t}\n\n\tif (SG(callback_func) && !SG(callback_run)) {\n\t\tSG(callback_run) = 1;\n\t\tsapi_run_header_callback(TSRMLS_C);\n\t}\n\n\tSG(headers_sent) = 1;\n\n\tif (sapi_module.send_headers) {\n\t\tretval = sapi_module.send_headers(&SG(sapi_headers) TSRMLS_CC);\n\t} else {\n\t\tretval = SAPI_HEADER_DO_SEND;\n\t}\n\n\tswitch (retval) {\n\t\tcase SAPI_HEADER_SENT_SUCCESSFULLY:\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_DO_SEND: {\n\t\t\t\tsapi_header_struct http_status_line;\n\t\t\t\tchar buf[255];\n\n\t\t\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\t\t\thttp_status_line.header = SG(sapi_headers).http_status_line;\n\t\t\t\t\thttp_status_line.header_len = strlen(SG(sapi_headers).http_status_line);\n\t\t\t\t} else {\n\t\t\t\t\thttp_status_line.header = buf;\n\t\t\t\t\thttp_status_line.header_len = slprintf(buf, sizeof(buf), \"HTTP/1.0 %d X\", SG(sapi_headers).http_response_code);\n\t\t\t\t}\n\t\t\t\tsapi_module.send_header(&http_status_line, SG(server_context) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_apply_with_argument(&SG(sapi_headers).headers, (llist_apply_with_arg_func_t) sapi_module.send_header, SG(server_context) TSRMLS_CC);\n\t\t\tif(SG(sapi_headers).send_default_content_type) {\n\t\t\t\tsapi_header_struct default_header;\n\n\t\t\t\tsapi_get_default_content_type_header(&default_header TSRMLS_CC);\n\t\t\t\tsapi_module.send_header(&default_header, SG(server_context) TSRMLS_CC);\n\t\t\t\tsapi_free_header(&default_header);\n\t\t\t}\n\t\t\tsapi_module.send_header(NULL, SG(server_context) TSRMLS_CC);\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_SEND_FAILED:\n\t\t\tSG(headers_sent) = 0;\n\t\t\tret = FAILURE;\n\t\t\tbreak;\n\t}\n\n\tsapi_send_headers_free(TSRMLS_C);\n\n\treturn ret;\n}\n\n\nSAPI_API int sapi_register_post_entries(sapi_post_entry *post_entries TSRMLS_DC)\n{\n\tsapi_post_entry *p=post_entries;\n\n\twhile (p->content_type) {\n\t\tif (sapi_register_post_entry(p TSRMLS_CC) == FAILURE) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tp++;\n\t}\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_post_entry(sapi_post_entry *post_entry TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\treturn zend_hash_add(&SG(known_post_content_types),\n\t\t\tpost_entry->content_type, post_entry->content_type_len+1,\n\t\t\t(void *) post_entry, sizeof(sapi_post_entry), NULL);\n}\n\nSAPI_API void sapi_unregister_post_entry(sapi_post_entry *post_entry TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn;\n\t}\n\tzend_hash_del(&SG(known_post_content_types), post_entry->content_type,\n\t\t\tpost_entry->content_type_len+1);\n}\n\n\nSAPI_API int sapi_register_default_post_reader(void (*default_post_reader)(TSRMLS_D) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.default_post_reader = default_post_reader;\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_treat_data(void (*treat_data)(int arg, char *str, zval *destArray TSRMLS_DC) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.treat_data = treat_data;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_register_input_filter(unsigned int (*input_filter)(int arg, char *var, char **val, unsigned int val_len, unsigned int *new_val_len TSRMLS_DC), unsigned int (*input_filter_init)(TSRMLS_D) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.input_filter = input_filter;\n\tsapi_module.input_filter_init = input_filter_init;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_flush(TSRMLS_D)\n{\n\tif (sapi_module.flush) {\n\t\tsapi_module.flush(SG(server_context));\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API struct stat *sapi_get_stat(TSRMLS_D)\n{\n\tif (sapi_module.get_stat) {\n\t\treturn sapi_module.get_stat(TSRMLS_C);\n\t} else {\n\t\tif (!SG(request_info).path_translated || (VCWD_STAT(SG(request_info).path_translated, &SG(global_stat)) == -1)) {\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &SG(global_stat);\n\t}\n}\n\nSAPI_API char *sapi_getenv(char *name, size_t name_len TSRMLS_DC)\n{\n\tif (sapi_module.getenv) { \n\t\tchar *value, *tmp = sapi_module.getenv(name, name_len TSRMLS_CC);\n\t\tif (tmp) {\n\t\t\tvalue = estrdup(tmp);\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (sapi_module.input_filter) {\n\t\t\tsapi_module.input_filter(PARSE_STRING, name, &value, strlen(value), NULL TSRMLS_CC);\n\t\t}\n\t\treturn value;\n\t}\n\treturn NULL;\n}\n\nSAPI_API int sapi_get_fd(int *fd TSRMLS_DC)\n{\n\tif (sapi_module.get_fd) {\n\t\treturn sapi_module.get_fd(fd TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_force_http_10(TSRMLS_D)\n{\n\tif (sapi_module.force_http_10) {\n\t\treturn sapi_module.force_http_10(TSRMLS_C);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\n\nSAPI_API int sapi_get_target_uid(uid_t *obj TSRMLS_DC)\n{\n\tif (sapi_module.get_target_uid) {\n\t\treturn sapi_module.get_target_uid(obj TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_get_target_gid(gid_t *obj TSRMLS_DC)\n{\n\tif (sapi_module.get_target_gid) {\n\t\treturn sapi_module.get_target_gid(obj TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API double sapi_get_request_time(TSRMLS_D)\n{\n\tif(SG(global_request_time)) return SG(global_request_time);\n\n\tif (sapi_module.get_request_time && SG(server_context)) {\n\t\tSG(global_request_time) = sapi_module.get_request_time(TSRMLS_C);\n\t} else {\n\t\tstruct timeval tp = {0};\n\t\tif (!gettimeofday(&tp, NULL)) {\n\t\t\tSG(global_request_time) = (double)(tp.tv_sec + tp.tv_usec / 1000000.00);\n\t\t} else {\n\t\t\tSG(global_request_time) = (double)time(0);\n\t\t}\n\t}\n\treturn SG(global_request_time);\n}\n\nSAPI_API void sapi_terminate_process(TSRMLS_D) {\n\tif (sapi_module.terminate_process) {\n\t\tsapi_module.terminate_process(TSRMLS_C);\n\t}\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "filenames": ["ext/standard/tests/general_functions/bug60227_2.phpt", "ext/standard/tests/general_functions/bug60227_3.phpt", "ext/standard/tests/general_functions/bug60227_4.phpt", "main/SAPI.c"], "buggy_code_start_loc": [2, 2, 2, 746], "buggy_code_end_loc": [15, 15, 15, 753], "fixing_code_start_loc": [3, 3, 3, 746], "fixing_code_end_loc": [16, 15, 15, 748], "type": "CWE-79", "message": "The sapi_header_op function in main/SAPI.c in PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6 supports deprecated line folding without considering browser compatibility, which allows remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer by leveraging (1) %0A%20 or (2) %0D%0A%20 mishandling in the header function.", "other": {"cve": {"id": "CVE-2015-8935", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-07T10:59:01.320", "lastModified": "2018-01-05T02:30:25.057", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The sapi_header_op function in main/SAPI.c in PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6 supports deprecated line folding without considering browser compatibility, which allows remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer by leveraging (1) %0A%20 or (2) %0D%0A%20 mishandling in the header function."}, {"lang": "es", "value": "La funci\u00f3n sapi_header_op en main/SAPI en PHP en versiones anteriores a 5.4.38, 5.5.x en versiones anteriores a 5.5.22 y 5.6 en versiones anteriores a 5.6.6 apoya el plegado de linea en de uso sin considerar la compatibilidad del navegador, lo que permite a atacantes remotos llevar a cabo ataques XSS contra Internet Explorer mediante el aprovechamiento de (1) %0A%20 o (2) %0D%0A%20 no manejado adecuadamente en la funci\u00f3n de cabecera."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.4.37", "matchCriteriaId": "E4E665F6-A16B-446F-8048-5E8630967F4A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "9F6D9B19-E64D-4BED-9194-17460CE19E6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "3D25E591-448C-4E3B-8557-6E48F7571796"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "6DA18F3F-B4B5-40C3-BF19-67C1F0C1787D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "3AF783C9-26E7-4E02-BD41-77B9783667E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha4:*:*:*:*:*:*", "matchCriteriaId": "EF49701D-ECE4-4CEB-BDAB-24C09C8AD4B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha5:*:*:*:*:*:*", "matchCriteriaId": "7AEDF6F7-001D-4A35-A26F-417991AD377F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha6:*:*:*:*:*:*", "matchCriteriaId": "4031DB99-B4B4-41EC-B3C1-543D92C575A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "D5450EA7-A398-49D2-AA8E-7C95B074BAB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "04FE0E4E-BC94-4DC9-BE9B-DC57B952B2FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "BB8E09D8-9CBE-4279-88B7-24A214A5A537"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "2D41ECCE-887D-49A2-9BB3-B559495AC55B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "79B418BC-27F4-4443-A0F7-FF4ADA568C1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "8EEBDF62-BA1B-4438-9AEA-8B56AA5713E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "F644EA6C-50C6-4A1C-A4AC-287AA9477B46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "4DD47F30-74F5-48E8-8657-C2373FE2BD22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "0C09527B-6B47-41F8-BDE6-01C47E452286"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "2E454D87-23CB-4D7F-90FE-942EE54D661F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "1031E646-F2CF-4A3E-8E6A-5D4BC950BEDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "130E50C1-D209-4CFF-9399-69D561340FBB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "C1F29948-9417-460B-8B04-D91AE4E8B423"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.8:*:*:*:*:*:*:*", "matchCriteriaId": "A37D00C1-4F41-4400-9CE4-8E8BAA3E4142"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.9:*:*:*:*:*:*:*", "matchCriteriaId": "093D08B7-CC3C-4616-8697-F15B253A7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.10:*:*:*:*:*:*:*", "matchCriteriaId": "E9CD8FEE-DE7B-47CB-9985-4092BFA071D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.11:*:*:*:*:*:*:*", "matchCriteriaId": "A30B2D9E-F289-43C9-BFBC-1CEF284A417E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.12:*:*:*:*:*:*:*", "matchCriteriaId": "FE41CFDF-8ECD-41C1-94A7-5AFD42C5DDEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.13:*:*:*:*:*:*:*", "matchCriteriaId": "6AEAC9BA-AF82-4345-839C-D339DCB962A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.14:*:*:*:*:*:*:*", "matchCriteriaId": "1EFE682F-52E3-48EC-A993-F522FC29712F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.18:*:*:*:*:*:*:*", "matchCriteriaId": "AC63A449-5D92-4F5F-8186-B58FFFBA54FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.19:*:*:*:*:*:*:*", "matchCriteriaId": "F18236F6-2065-4A6A-93E7-FD90E650C689"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.20:*:*:*:*:*:*:*", "matchCriteriaId": "DEFBA84A-A4E4-438B-B9B5-8549809DCECC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.21:*:*:*:*:*:*:*", "matchCriteriaId": "146D3DC9-50F4-430B-B321-68ECE78879A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "5BF4E8FF-A3EC-43E8-A0C1-FD38AFCB77B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "54ADECFC-3C07-43BC-B296-6C25AC7F1C95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "FE192054-2FBB-4388-A52A-422E20DEA2D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha4:*:*:*:*:*:*", "matchCriteriaId": "F0195D48-3B42-4AC0-B9C5-436E01C63879"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha5:*:*:*:*:*:*", "matchCriteriaId": "BF0E5D67-ABC1-41A5-94E1-7DD3CDB51D81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "319E0573-B1AD-40B6-B4BC-8BE67ED3EFDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "1A7C00EB-87B7-4EB7-A4AC-8665D8C78467"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "21BFCF10-786A-4D1E-9C37-50A1EC6056F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "95A6D6C8-5F46-4897-A0B0-778631E8CE6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "F1F13E2D-A8F7-4B74-8D03-7905C81672C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "AE18933A-5FE6-41C7-B1B6-DA3E762C3FB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "9AE1289F-03A6-4621-B387-5F5ADAC4AE92"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "383697F5-D29E-475A-84F3-46B54A928889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "786ED182-5D71-4197-9196-12AB5CF05F85"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2016-07/msg00004.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00025.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00003.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2750.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/20/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "https://bugs.php.net/bug.php?id=68978", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/php/php-src/commit/996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/php/php-src/commit/996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1"}}