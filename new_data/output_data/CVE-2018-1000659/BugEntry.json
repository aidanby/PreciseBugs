{"buggy_code": ["<?php\r\n// --------------------------------------------------------------------------------\r\n// PhpConcept Library - Zip Module 2.8.2\r\n// --------------------------------------------------------------------------------\r\n// License GNU/LGPL - Vincent Blavet - August 2009\r\n// http://www.phpconcept.net\r\n// --------------------------------------------------------------------------------\r\n//\r\n// Presentation :\r\n//   PclZip is a PHP library that manage ZIP archives.\r\n//   So far tests show that archives generated by PclZip are readable by\r\n//   WinZip application and other tools.\r\n//\r\n// Description :\r\n//   See readme.txt and http://www.phpconcept.net\r\n//\r\n// Warning :\r\n//   This library and the associated files are non commercial, non professional\r\n//   work.\r\n//   It should not have unexpected results. However if any damage is caused by\r\n//   this software the author can not be responsible.\r\n//   The use of this software is at the risk of the user.\r\n//\r\n// --------------------------------------------------------------------------------\r\n// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Constants\r\n  if (!defined('PCLZIP_READ_BLOCK_SIZE')) {\r\n    define( 'PCLZIP_READ_BLOCK_SIZE', 2048 );\r\n  }\r\n\r\n  // ----- File list separator\r\n  // In version 1.x of PclZip, the separator for file list is a space\r\n  // (which is not a very smart choice, specifically for windows paths !).\r\n  // A better separator should be a comma (,). This constant gives you the\r\n  // abilty to change that.\r\n  // However notice that changing this value, may have impact on existing\r\n  // scripts, using space separated filenames.\r\n  // Recommanded values for compatibility with older versions :\r\n  //define( 'PCLZIP_SEPARATOR', ' ' );\r\n  // Recommanded values for smart separation of filenames.\r\n  if (!defined('PCLZIP_SEPARATOR')) {\r\n    define( 'PCLZIP_SEPARATOR', ',' );\r\n  }\r\n\r\n  // ----- Error configuration\r\n  // 0 : PclZip Class integrated error handling\r\n  // 1 : PclError external library error handling. By enabling this\r\n  //     you must ensure that you have included PclError library.\r\n  // [2,...] : reserved for futur use\r\n  if (!defined('PCLZIP_ERROR_EXTERNAL')) {\r\n    define( 'PCLZIP_ERROR_EXTERNAL', 0 );\r\n  }\r\n\r\n  // ----- Optional static temporary directory\r\n  //       By default temporary files are generated in the script current\r\n  //       path.\r\n  //       If defined :\r\n  //       - MUST BE terminated by a '/'.\r\n  //       - MUST be a valid, already created directory\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );\r\n  // define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );\r\n  if (!defined('PCLZIP_TEMPORARY_DIR')) {\r\n    define( 'PCLZIP_TEMPORARY_DIR', '' );\r\n  }\r\n\r\n  // ----- Optional threshold ratio for use of temporary files\r\n  //       Pclzip sense the size of the file to add/extract and decide to\r\n  //       use or not temporary file. The algorythm is looking for\r\n  //       memory_limit of PHP and apply a ratio.\r\n  //       threshold = memory_limit * ratio.\r\n  //       Recommended values are under 0.5. Default 0.47.\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );\r\n  if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {\r\n    define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 );\r\n  }\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Global variables\r\n  $g_pclzip_version = \"2.8.2\";\r\n\r\n  // ----- Error codes\r\n  //   -1 : Unable to open file in binary write mode\r\n  //   -2 : Unable to open file in binary read mode\r\n  //   -3 : Invalid parameters\r\n  //   -4 : File does not exist\r\n  //   -5 : Filename is too long (max. 255)\r\n  //   -6 : Not a valid zip file\r\n  //   -7 : Invalid extracted file size\r\n  //   -8 : Unable to create directory\r\n  //   -9 : Invalid archive extension\r\n  //  -10 : Invalid archive format\r\n  //  -11 : Unable to delete file (unlink)\r\n  //  -12 : Unable to rename file (rename)\r\n  //  -13 : Invalid header checksum\r\n  //  -14 : Invalid archive size\r\n  define( 'PCLZIP_ERR_USER_ABORTED', 2 );\r\n  define( 'PCLZIP_ERR_NO_ERROR', 0 );\r\n  define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );\r\n  define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );\r\n  define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );\r\n  define( 'PCLZIP_ERR_MISSING_FILE', -4 );\r\n  define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );\r\n  define( 'PCLZIP_ERR_INVALID_ZIP', -6 );\r\n  define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );\r\n  define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );\r\n  define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );\r\n  define( 'PCLZIP_ERR_BAD_FORMAT', -10 );\r\n  define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );\r\n  define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );\r\n  define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );\r\n  define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );\r\n  define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );\r\n  define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );\r\n  define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );\r\n  define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );\r\n  define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );\r\n\r\n  // ----- Options values\r\n  define( 'PCLZIP_OPT_PATH', 77001 );\r\n  define( 'PCLZIP_OPT_ADD_PATH', 77002 );\r\n  define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );\r\n  define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );\r\n  define( 'PCLZIP_OPT_SET_CHMOD', 77005 );\r\n  define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );\r\n  define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );\r\n  define( 'PCLZIP_OPT_BY_NAME', 77008 );\r\n  define( 'PCLZIP_OPT_BY_INDEX', 77009 );\r\n  define( 'PCLZIP_OPT_BY_EREG', 77010 );\r\n  define( 'PCLZIP_OPT_BY_PREG', 77011 );\r\n  define( 'PCLZIP_OPT_COMMENT', 77012 );\r\n  define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );\r\n  define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );\r\n  define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );\r\n  define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );\r\n  define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );\r\n  // Having big trouble with crypt. Need to multiply 2 long int\r\n  // which is not correctly supported by PHP ...\r\n  //define( 'PCLZIP_OPT_CRYPT', 77018 );\r\n  define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );\r\n  define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022 ); // alias\r\n\r\n  // ----- File description attributes\r\n  define( 'PCLZIP_ATT_FILE_NAME', 79001 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );\r\n  define( 'PCLZIP_ATT_FILE_MTIME', 79004 );\r\n  define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );\r\n  define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );\r\n\r\n  // ----- Call backs values\r\n  define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );\r\n  define( 'PCLZIP_CB_POST_EXTRACT', 78002 );\r\n  define( 'PCLZIP_CB_PRE_ADD', 78003 );\r\n  define( 'PCLZIP_CB_POST_ADD', 78004 );\r\n  /* For futur use\r\n  define( 'PCLZIP_CB_PRE_LIST', 78005 );\r\n  define( 'PCLZIP_CB_POST_LIST', 78006 );\r\n  define( 'PCLZIP_CB_PRE_DELETE', 78007 );\r\n  define( 'PCLZIP_CB_POST_DELETE', 78008 );\r\n  */\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Class : PclZip\r\n  // Description :\r\n  //   PclZip is the class that represent a Zip archive.\r\n  //   The public methods allow the manipulation of the archive.\r\n  // Attributes :\r\n  //   Attributes must not be accessed directly.\r\n  // Methods :\r\n  //   PclZip() : Object creator\r\n  //   create() : Creates the Zip archive\r\n  //   listContent() : List the content of the Zip archive\r\n  //   extract() : Extract the content of the archive\r\n  //   properties() : List the properties of the archive\r\n  // --------------------------------------------------------------------------------\r\n  class PclZip\r\n  {\r\n    // ----- Filename of the zip file\r\n    var $zipname = '';\r\n\r\n    // ----- File descriptor of the zip file\r\n    var $zip_fd = 0;\r\n\r\n    // ----- Internal error handling\r\n    var $error_code = 1;\r\n    var $error_string = '';\r\n\r\n    // ----- Current status of the magic_quotes_runtime\r\n    // This value store the php configuration for magic_quotes\r\n    // The class can then disable the magic_quotes and reset it after\r\n    var $magic_quotes_status;\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZip()\r\n  // Description :\r\n  //   Creates a PclZip object and set the name of the associated Zip archive\r\n  //   filename.\r\n  //   Note that no real action is taken, if the archive does not exist it is not\r\n  //   created. Use create() for that.\r\n  // --------------------------------------------------------------------------------\r\n  public function __construct($p_zipname)\r\n  {\r\n\r\n    // ----- Tests the zlib\r\n    if (!function_exists('gzopen'))\r\n    {\r\n      die('Abort '.basename(__FILE__).' : Missing zlib extensions');\r\n    }\r\n\r\n    // ----- Set the attributes\r\n    $this->zipname = $p_zipname;\r\n    $this->zip_fd = 0;\r\n    $this->magic_quotes_status = -1;\r\n\r\n    // ----- Return\r\n    return;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   create($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   create($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two different synopsis. The first one is historical.\r\n  //   This method creates a Zip Archive. The Zip file is created in the\r\n  //   filesystem. The files and directories indicated in $p_filelist\r\n  //   are added in the archive. See the parameters description for the\r\n  //   supported format of $p_filelist.\r\n  //   When a directory is in the list, the directory and its content is added\r\n  //   in the archive.\r\n  //   In this synopsis, the function takes an optional variable list of\r\n  //   options. See bellow the supported options.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function create($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove from the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                             ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Invalid number / type of arguments\");\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        if ($v_string != '') {\r\n          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   add($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   add($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This methods add the list of files in an existing archive.\r\n  //   If a file with the same name already exists, it is added at the end of the\r\n  //   archive, the first one is still present.\r\n  //   If the archive does not exist, it is created.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_OPT_ADD_COMMENT :\r\n  //   PCLZIP_OPT_PREPEND_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function add($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type '\".gettype($p_filelist).\"' for p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : listContent()\r\n  // Description :\r\n  //   This public method, gives the list of the files and directories, with their\r\n  //   properties.\r\n  //   The properties of each entries in the list are (used also in other functions) :\r\n  //     filename : Name of the file. For a create or add action it is the filename\r\n  //                given by the user. For an extract function it is the filename\r\n  //                of the extracted file.\r\n  //     stored_filename : Name of the file / directory stored in the archive.\r\n  //     size : Size of the stored file.\r\n  //     compressed_size : Size of the file's data compressed in the archive\r\n  //                       (without the headers overhead)\r\n  //     mtime : Last known modification date of the file (UNIX timestamp)\r\n  //     comment : Comment associated with the file\r\n  //     folder : true | false\r\n  //     index : index of the file in the archive\r\n  //     status : status of the action (depending of the action) :\r\n  //              Values are :\r\n  //                ok : OK !\r\n  //                filtered : the file / dir is not extracted (filtered by user)\r\n  //                already_a_directory : the file can not be extracted because a\r\n  //                                      directory with the same name already exists\r\n  //                write_protected : the file can not be extracted because a file\r\n  //                                  with the same name already exists and is\r\n  //                                  write protected\r\n  //                newer_exist : the file was not extracted because a newer file exists\r\n  //                path_creation_fail : the file is not extracted because the folder\r\n  //                                     does not exist and can not be created\r\n  //                write_error : the file was not extracted because there was a\r\n  //                              error while writing the file\r\n  //                read_error : the file was not extracted because there was a error\r\n  //                             while reading the file\r\n  //                invalid_header : the file was not extracted because of an archive\r\n  //                                 format error (bad file header)\r\n  //   Note that each time a method can continue operating when there\r\n  //   is an action error on a file, the error is only logged in the file status.\r\n  // Return Values :\r\n  //   0 on an unrecoverable failure,\r\n  //   The list of the files in the archive.\r\n  // --------------------------------------------------------------------------------\r\n  function listContent()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    if (($v_result = $this->privList($p_list)) != 1)\r\n    {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extract($p_path=\"./\", $p_remove_path=\"\")\r\n  //   extract([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method extract all the files / directories from the archive to the\r\n  //   folder indicated in $p_path.\r\n  //   If you want to ignore the 'root' part of path of the memorized files\r\n  //   you can indicate this in the optional $p_remove_path parameter.\r\n  //   By default, if a newer file with the same name already exists, the\r\n  //   file is not extracted.\r\n  //\r\n  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions\r\n  //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append\r\n  //   at the end of the path value of PCLZIP_OPT_PATH.\r\n  // Parameters :\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 or a negative value on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function extract()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_BY_NAME => 'optional',\r\n                                                   PCLZIP_OPT_BY_EREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_PREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_INDEX => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                    ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path,\r\n                                         $v_remove_all_path, $v_options);\r\n    if ($v_result < 1) {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extractByIndex($p_index, $p_path=\"./\", $p_remove_path=\"\")\r\n  //   extractByIndex($p_index, [$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method is doing a partial extract of the archive.\r\n  //   The extracted files or folders are identified by their index in the\r\n  //   archive (from 0 to n).\r\n  //   Note that if the index identify a folder, only the folder entry is\r\n  //   extracted, not all the files included in the archive.\r\n  // Parameters :\r\n  //   $p_index : A single index (integer) or a string of indexes of files to\r\n  //              extract. The form of the string is \"0,4-6,8-12\" with only numbers\r\n  //              and '-' for range or ',' to separate ranges. No spaces or ';'\r\n  //              are allowed.\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and\r\n  //     not as files.\r\n  //     The resulting content is in a new field 'content' in the file\r\n  //     structure.\r\n  //     This option must be used alone (any other options are ignored).\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  //function extractByIndex($p_index, options...)\r\n  function extractByIndex($p_index)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {\r\n          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Trick\r\n    // Here I want to reuse extractByRule(), so I need to parse the $p_index\r\n    // with privParseOptions()\r\n    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);\r\n    $v_options_trick = array();\r\n    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick,\r\n                                        array (PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n    if ($v_result != 1) {\r\n        return 0;\r\n    }\r\n    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Call the extracting fct\r\n    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {\r\n        return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   delete([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method removes files from the archive.\r\n  //   If no parameters are given, then all the archive is emptied.\r\n  // Parameters :\r\n  //   None or optional arguments.\r\n  // Options :\r\n  //   PCLZIP_OPT_BY_INDEX :\r\n  //   PCLZIP_OPT_BY_NAME :\r\n  //   PCLZIP_OPT_BY_EREG :\r\n  //   PCLZIP_OPT_BY_PREG :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the files which are still present in the archive.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function delete()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Parse the options\r\n      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                        array (PCLZIP_OPT_BY_NAME => 'optional',\r\n                                               PCLZIP_OPT_BY_EREG => 'optional',\r\n                                               PCLZIP_OPT_BY_PREG => 'optional',\r\n                                               PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n      if ($v_result != 1) {\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Call the delete fct\r\n    $v_list = array();\r\n    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {\r\n      $this->privSwapBackMagicQuotes();\r\n      unset($v_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : deleteByIndex()\r\n  // Description :\r\n  //   ***** Deprecated *****\r\n  //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.\r\n  // --------------------------------------------------------------------------------\r\n  function deleteByIndex($p_index)\r\n  {\r\n\r\n    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : properties()\r\n  // Description :\r\n  //   This method gives the properties of the archive.\r\n  //   The properties are :\r\n  //     nb : Number of files in the archive\r\n  //     comment : Comment associated with the archive file\r\n  //     status : not_exist, ok\r\n  // Parameters :\r\n  //   None\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   An array with the archive properties.\r\n  // --------------------------------------------------------------------------------\r\n  function properties()\r\n  {\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      $this->privSwapBackMagicQuotes();\r\n      return(0);\r\n    }\r\n\r\n    // ----- Default properties\r\n    $v_prop = array();\r\n    $v_prop['comment'] = '';\r\n    $v_prop['nb'] = 0;\r\n    $v_prop['status'] = 'not_exist';\r\n\r\n    // ----- Look if file exists\r\n    if (@is_file($this->zipname))\r\n    {\r\n      // ----- Open the zip file\r\n      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n        // ----- Return\r\n        return 0;\r\n      }\r\n\r\n      // ----- Read the central directory informations\r\n      $v_central_dir = array();\r\n      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return 0;\r\n      }\r\n\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Set the user attributes\r\n      $v_prop['comment'] = $v_central_dir['comment'];\r\n      $v_prop['nb'] = $v_central_dir['entries'];\r\n      $v_prop['status'] = 'ok';\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_prop;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : duplicate()\r\n  // Description :\r\n  //   This method creates an archive by copying the content of an other one. If\r\n  //   the archive already exist, it is replaced by the new one without any warning.\r\n  // Parameters :\r\n  //   $p_archive : The filename of a valid archive, or\r\n  //                a valid PclZip object.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 or a negative value on error (error code).\r\n  // --------------------------------------------------------------------------------\r\n  function duplicate($p_archive)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the $p_archive is a PclZip object\r\n    if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Duplicate the archive\r\n      $v_result = $this->privDuplicate($p_archive->zipname);\r\n    }\r\n\r\n    // ----- Look if the $p_archive is a string (so a filename)\r\n    else if (is_string($p_archive))\r\n    {\r\n\r\n      // ----- Check that $p_archive is a valid zip file\r\n      // TBC : Should also check the archive format\r\n      if (!is_file($p_archive)) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"No file with filename '\".$p_archive.\"'\");\r\n        $v_result = PCLZIP_ERR_MISSING_FILE;\r\n      }\r\n      else {\r\n        // ----- Duplicate the archive\r\n        $v_result = $this->privDuplicate($p_archive);\r\n      }\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : merge()\r\n  // Description :\r\n  //   This method merge the $p_archive_to_add archive at the end of the current\r\n  //   one ($this).\r\n  //   If the archive ($this) does not exist, the merge becomes a duplicate.\r\n  //   If the $p_archive_to_add archive does not exist, the merge is a success.\r\n  // Parameters :\r\n  //   $p_archive_to_add : It can be directly the filename of a valid zip archive,\r\n  //                       or a PclZip object archive.\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 or negative values on error (see below).\r\n  // --------------------------------------------------------------------------------\r\n  function merge($p_archive_to_add)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a PclZip object\r\n    if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($p_archive_to_add);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a string (so a filename)\r\n    else if (is_string($p_archive_to_add))\r\n    {\r\n\r\n      // ----- Create a temporary archive\r\n      $v_object_archive = new PclZip($p_archive_to_add);\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($v_object_archive);\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorCode()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorCode()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorCode());\r\n    }\r\n    else {\r\n      return($this->error_code);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorName()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorName($p_with_code=false)\r\n  {\r\n    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',\r\n                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',\r\n                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',\r\n                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',\r\n                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',\r\n                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',\r\n                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',\r\n                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',\r\n                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',\r\n                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',\r\n                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',\r\n                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',\r\n                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',\r\n                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',\r\n                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',\r\n                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',\r\n                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',\r\n                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',\r\n                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'\r\n                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'\r\n                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'\r\n                    );\r\n\r\n    if (isset($v_name[$this->error_code])) {\r\n      $v_value = $v_name[$this->error_code];\r\n    }\r\n    else {\r\n      $v_value = 'NoName';\r\n    }\r\n\r\n    if ($p_with_code) {\r\n      return($v_value.' ('.$this->error_code.')');\r\n    }\r\n    else {\r\n      return($v_value);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorInfo()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorInfo($p_full=false)\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorString());\r\n    }\r\n    else {\r\n      if ($p_full) {\r\n        return($this->errorName(true).\" : \".$this->error_string);\r\n      }\r\n      else {\r\n        return($this->error_string.\" [code \".$this->error_code.\"]\");\r\n      }\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****\r\n// *****                                                        *****\r\n// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****\r\n// --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFormat()\r\n  // Description :\r\n  //   This method check that the archive exists and is a valid zip archive.\r\n  //   Several level of check exists. (futur)\r\n  // Parameters :\r\n  //   $p_level : Level of check. Default 0.\r\n  //              0 : Check the first bytes (magic codes) (default value))\r\n  //              1 : 0 + Check the central directory (futur)\r\n  //              2 : 1 + Check each file header (futur)\r\n  // Return Values :\r\n  //   true on success,\r\n  //   false on error, the error code is set.\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFormat($p_level=0)\r\n  {\r\n    $v_result = true;\r\n\r\n    // ----- Reset the file system cache\r\n    clearstatcache();\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the file exits\r\n    if (!is_file($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"Missing archive file '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check that the file is readeable\r\n    if (!is_readable($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to read archive '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check the magic code\r\n    // TBC\r\n\r\n    // ----- Check the central header\r\n    // TBC\r\n\r\n    // ----- Check each file header\r\n    // TBC\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privParseOptions()\r\n  // Description :\r\n  //   This internal methods reads the variable list of arguments ($p_options_list,\r\n  //   $p_size) and generate an array with the options and values ($v_result_list).\r\n  //   $v_requested_options contains the options that can be present and those that\r\n  //   must be present.\r\n  //   $v_requested_options is an array, with the option value as key, and 'optional',\r\n  //   or 'mandatory' as value.\r\n  // Parameters :\r\n  //   See above.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the options\r\n    $i=0;\r\n    while ($i<$p_size) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$p_options_list[$i]])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid optional parameter '\".$p_options_list[$i].\"' for this method\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for next option\r\n      switch ($p_options_list[$i]) {\r\n        // ----- Look for options that request a path value\r\n        case PCLZIP_OPT_PATH :\r\n        case PCLZIP_OPT_REMOVE_PATH :\r\n        case PCLZIP_OPT_ADD_PATH :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check the value\r\n          $v_value = $p_options_list[$i+1];\r\n          if ((!is_integer($v_value)) || ($v_value<0)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Integer expected for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value (and convert it in bytes)\r\n          $v_result_list[$p_options_list[$i]] = $v_value*1048576;\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_ON :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_OFF :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'\");\r\n            return PclZip::errorCode();\r\n          }\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (   is_string($p_options_list[$i+1])\r\n              && ($p_options_list[$i+1] != '')) {\r\n            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n            $i++;\r\n          }\r\n          else {\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that request an array of string for value\r\n        case PCLZIP_OPT_BY_NAME :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an EREG or PREG expression\r\n        case PCLZIP_OPT_BY_EREG :\r\n          // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG\r\n          // to PCLZIP_OPT_BY_PREG\r\n          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;\r\n        case PCLZIP_OPT_BY_PREG :\r\n        //case PCLZIP_OPT_CRYPT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_OPT_COMMENT :\r\n        case PCLZIP_OPT_ADD_COMMENT :\r\n        case PCLZIP_OPT_PREPEND_COMMENT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE,\r\n                                 \"Missing parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE,\r\n                                 \"Wrong parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an array of index\r\n        case PCLZIP_OPT_BY_INDEX :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_work_list = array();\r\n          if (is_string($p_options_list[$i+1])) {\r\n\r\n              // ----- Remove spaces\r\n              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');\r\n\r\n              // ----- Parse items\r\n              $v_work_list = explode(\",\", $p_options_list[$i+1]);\r\n          }\r\n          else if (is_integer($p_options_list[$i+1])) {\r\n              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_work_list = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Value must be integer, string or array for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Reduce the index list\r\n          // each index item in the list must be a couple with a start and\r\n          // an end value : [0,3], [5-5], [8-10], ...\r\n          // ----- Check the format of each item\r\n          $v_sort_flag=false;\r\n          $v_sort_value=0;\r\n          for ($j=0; $j<sizeof($v_work_list); $j++) {\r\n              // ----- Explode the item\r\n              $v_item_list = explode(\"-\", $v_work_list[$j]);\r\n              $v_size_item_list = sizeof($v_item_list);\r\n\r\n              // ----- TBC : Here we might check that each item is a\r\n              // real integer ...\r\n\r\n              // ----- Look for single value\r\n              if ($v_size_item_list == 1) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];\r\n              }\r\n              elseif ($v_size_item_list == 2) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];\r\n              }\r\n              else {\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Too many values in index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n\r\n\r\n              // ----- Look for list sort\r\n              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {\r\n                  $v_sort_flag=true;\r\n\r\n                  // ----- TBC : An automatic sort should be writen ...\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Invalid order of index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];\r\n          }\r\n\r\n          // ----- Sort the items\r\n          if ($v_sort_flag) {\r\n              // TBC : To Be Completed\r\n          }\r\n\r\n          // ----- Next option\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request no value\r\n        case PCLZIP_OPT_REMOVE_ALL_PATH :\r\n        case PCLZIP_OPT_EXTRACT_AS_STRING :\r\n        case PCLZIP_OPT_NO_COMPRESSION :\r\n        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :\r\n        case PCLZIP_OPT_REPLACE_NEWER :\r\n        case PCLZIP_OPT_STOP_ON_ERROR :\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        // ----- Look for options that request an octal value\r\n        case PCLZIP_OPT_SET_CHMOD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request a call-back\r\n        case PCLZIP_CB_PRE_EXTRACT :\r\n        case PCLZIP_CB_POST_EXTRACT :\r\n        case PCLZIP_CB_PRE_ADD :\r\n        case PCLZIP_CB_POST_ADD :\r\n        /* for futur use\r\n        case PCLZIP_CB_PRE_DELETE :\r\n        case PCLZIP_CB_POST_DELETE :\r\n        case PCLZIP_CB_PRE_LIST :\r\n        case PCLZIP_CB_POST_LIST :\r\n        */\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_function_name = $p_options_list[$i+1];\r\n\r\n          // ----- Check that the value is a valid existing function\r\n          if (!function_exists($v_function_name)) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Function '\".$v_function_name.\"()' is not an existing function for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Set the attribute\r\n          $v_result_list[$p_options_list[$i]] = $v_function_name;\r\n          $i++;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Unknown parameter '\"\r\n                               .$p_options_list[$i].\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Next options\r\n      $i++;\r\n    }\r\n\r\n    // ----- Look for mandatory options\r\n    if ($v_requested_options !== false) {\r\n      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n        // ----- Look for mandatory option\r\n        if ($v_requested_options[$key] == 'mandatory') {\r\n          // ----- Look if present\r\n          if (!isset($v_result_list[$key])) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default values\r\n    if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOptionDefaultThreshold()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privOptionDefaultThreshold(&$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n        || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get 'memory_limit' configuration value\r\n    $v_memory_limit = ini_get('memory_limit');\r\n    $v_memory_limit = trim($v_memory_limit);\r\n    $last = strtolower(substr($v_memory_limit, -1));\r\n\r\n    if($last == 'g') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit)*1073741824;\r\n    }\r\n    if($last == 'm') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit) * 1048576;\r\n    }\r\n    if($last == 'k') {\r\n        $v_memory_limit = ((int) $v_memory_limit)*1024;\r\n    }\r\n\r\n    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);\r\n\r\n\r\n    // ----- Sanity check : No threshold if value lower than 1M\r\n    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {\r\n      unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrParseAtt()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- For each file in the list check the attributes\r\n    foreach ($p_file_list as $v_key => $v_value) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$v_key])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file attribute '\".$v_key.\"' for this file\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for attribute\r\n      switch ($v_key) {\r\n        case PCLZIP_ATT_FILE_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['filename'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_short_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty short filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_FULL_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_full_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty full filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_ATT_FILE_COMMENT :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['comment'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_MTIME :\r\n          if (!is_integer($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". Integer expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['mtime'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_CONTENT :\r\n          $p_filedescr['content'] = $v_value;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                                   \"Unknown parameter '\".$v_key.\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for mandatory options\r\n      if ($v_requested_options !== false) {\r\n        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n          // ----- Look for mandatory option\r\n          if ($v_requested_options[$key] == 'mandatory') {\r\n            // ----- Look if present\r\n            if (!isset($p_file_list[$key])) {\r\n              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n              return PclZip::errorCode();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    // end foreach\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrExpand()\r\n  // Description :\r\n  //   This method look for each item of the list to see if its a file, a folder\r\n  //   or a string to be added as file. For any other type of files (link, other)\r\n  //   just ignore the item.\r\n  //   Then prepare the information that will be stored for that file.\r\n  //   When its a folder, expand the folder with all the files that are in that\r\n  //   folder (recursively).\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrExpand(&$p_filedescr_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Create a result list\r\n    $v_result_list = array();\r\n\r\n    // ----- Look each entry\r\n    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {\r\n\r\n      // ----- Get filedescr\r\n      $v_descr = $p_filedescr_list[$i];\r\n\r\n      // ----- Reduce the filename\r\n      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);\r\n      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);\r\n\r\n      // ----- Look for real file or folder\r\n      if (file_exists($v_descr['filename'])) {\r\n        if (@is_file($v_descr['filename'])) {\r\n          $v_descr['type'] = 'file';\r\n        }\r\n        else if (@is_dir($v_descr['filename'])) {\r\n          $v_descr['type'] = 'folder';\r\n        }\r\n        else if (@is_link($v_descr['filename'])) {\r\n          // skip\r\n          continue;\r\n        }\r\n        else {\r\n          // skip\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // ----- Look for string added as file\r\n      else if (isset($v_descr['content'])) {\r\n        $v_descr['type'] = 'virtual_file';\r\n      }\r\n\r\n      // ----- Missing file\r\n      else {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$v_descr['filename'].\"' does not exist\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Calculate the stored filename\r\n      $this->privCalculateStoredFilename($v_descr, $p_options);\r\n\r\n      // ----- Add the descriptor in result list\r\n      $v_result_list[sizeof($v_result_list)] = $v_descr;\r\n\r\n      // ----- Look for folder\r\n      if ($v_descr['type'] == 'folder') {\r\n        // ----- List of items in folder\r\n        $v_dirlist_descr = array();\r\n        $v_dirlist_nb = 0;\r\n        if ($v_folder_handler = @opendir($v_descr['filename'])) {\r\n          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {\r\n\r\n            // ----- Skip '.' and '..'\r\n            if (($v_item_handler == '.') || ($v_item_handler == '..')) {\r\n                continue;\r\n            }\r\n\r\n            // ----- Compose the full filename\r\n            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;\r\n\r\n            // ----- Look for different stored filename\r\n            // Because the name of the folder was changed, the name of the\r\n            // files/sub-folders also change\r\n            if (($v_descr['stored_filename'] != $v_descr['filename'])\r\n                 && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {\r\n              if ($v_descr['stored_filename'] != '') {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;\r\n              }\r\n              else {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;\r\n              }\r\n            }\r\n\r\n            $v_dirlist_nb++;\r\n          }\r\n\r\n          @closedir($v_folder_handler);\r\n        }\r\n        else {\r\n          // TBC : unable to open folder in read mode\r\n        }\r\n\r\n        // ----- Expand each element of the list\r\n        if ($v_dirlist_nb != 0) {\r\n          // ----- Expand\r\n          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Concat the resulting list\r\n          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);\r\n        }\r\n        else {\r\n        }\r\n\r\n        // ----- Free local array\r\n        unset($v_dirlist_descr);\r\n      }\r\n    }\r\n\r\n    // ----- Get the result list\r\n    $p_filedescr_list = $v_result_list;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCreate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCreate($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the file in write mode\r\n    if (($v_result = $this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the list of files\r\n    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAdd()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAdd($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Look if the archive exists or is empty\r\n    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0))\r\n    {\r\n\r\n      // ----- Do a create\r\n      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      fclose($v_zip_temp_fd);\r\n      $this->privCloseFd();\r\n      @unlink($v_zip_temp_name);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          fclose($v_zip_temp_fd);\r\n          $this->privCloseFd();\r\n          @unlink($v_zip_temp_name);\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = $v_central_dir['comment'];\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {\r\n      $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOpenFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privOpenFd($p_mode)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if already open\r\n    if ($this->zip_fd != 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \\''.$this->zipname.'\\' already open');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in '.$p_mode.' mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCloseFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privCloseFd()\r\n  {\r\n    $v_result=1;\r\n\r\n    if ($this->zip_fd != 0)\r\n      @fclose($this->zip_fd);\r\n    $this->zip_fd = 0;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddList()\r\n  // Description :\r\n  //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is\r\n  //   different from the real path of the file. This is usefull if you want to have PclTar\r\n  //   running in any directory, and memorize relative path from an other directory.\r\n  // Parameters :\r\n  //   $p_list : An array containing the file or directory names to add in the tar\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  //   $p_add_dir : Path to add in the filename path archived\r\n  //   $p_remove_dir : Path to remove in the filename path archived\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)\r\n  function privAddList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = '';\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileList()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_filedescr_list : An array containing the file description\r\n  //                      or directory names to add in the zip\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_header = array();\r\n\r\n    // ----- Recuperate the current number of elt in list\r\n    $v_nb = sizeof($p_result_list);\r\n\r\n    // ----- Loop on the files\r\n    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {\r\n      // ----- Format the filename\r\n      $p_filedescr_list[$j]['filename']\r\n      = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);\r\n\r\n\r\n      // ----- Skip empty file names\r\n      // TBC : Can this be possible ? not checked in DescrParseAtt ?\r\n      if ($p_filedescr_list[$j]['filename'] == \"\") {\r\n        continue;\r\n      }\r\n\r\n      // ----- Check the filename\r\n      if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')\r\n          && (!file_exists($p_filedescr_list[$j]['filename']))) {\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$p_filedescr_list[$j]['filename'].\"' does not exist\");\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look if it is a file or a dir with no all path remove option\r\n      // or a dir with all its path removed\r\n//      if (   (is_file($p_filedescr_list[$j]['filename']))\r\n//          || (   is_dir($p_filedescr_list[$j]['filename'])\r\n      if (   ($p_filedescr_list[$j]['type'] == 'file')\r\n          || ($p_filedescr_list[$j]['type'] == 'virtual_file')\r\n          || (   ($p_filedescr_list[$j]['type'] == 'folder')\r\n              && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])\r\n                  || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))\r\n          ) {\r\n\r\n        // ----- Add the file\r\n        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header,\r\n                                       $p_options);\r\n        if ($v_result != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Store the file infos\r\n        $p_result_list[$v_nb++] = $v_header;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n    // TBC : Already done in the fileAtt check ... ?\r\n    if ($p_filename == \"\") {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file list parameter (invalid or empty list)\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Look for a stored different filename\r\n    /* TBC : Removed\r\n    if (isset($p_filedescr['stored_filename'])) {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    else {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    */\r\n\r\n    // ----- Set the file properties\r\n    clearstatcache();\r\n    $p_header['version'] = 20;\r\n    $p_header['version_extracted'] = 10;\r\n    $p_header['flag'] = 0;\r\n    $p_header['compression'] = 0;\r\n    $p_header['crc'] = 0;\r\n    $p_header['compressed_size'] = 0;\r\n    $p_header['filename_len'] = strlen($p_filename);\r\n    $p_header['extra_len'] = 0;\r\n    $p_header['disk'] = 0;\r\n    $p_header['internal'] = 0;\r\n    $p_header['offset'] = 0;\r\n    $p_header['filename'] = $p_filename;\r\n// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;\r\n    $p_header['stored_filename'] = $p_filedescr['stored_filename'];\r\n    $p_header['extra'] = '';\r\n    $p_header['status'] = 'ok';\r\n    $p_header['index'] = -1;\r\n\r\n    // ----- Look for regular file\r\n    if ($p_filedescr['type']=='file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for regular folder\r\n    else if ($p_filedescr['type']=='folder') {\r\n      $p_header['external'] = 0x00000010;\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for virtual file\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = strlen($p_filedescr['content']);\r\n    }\r\n\r\n\r\n    // ----- Look for filetime\r\n    if (isset($p_filedescr['mtime'])) {\r\n      $p_header['mtime'] = $p_filedescr['mtime'];\r\n    }\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['mtime'] = time();\r\n    }\r\n    else {\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n    }\r\n\r\n    // ------ Look for file comment\r\n    if (isset($p_filedescr['comment'])) {\r\n      $p_header['comment_len'] = strlen($p_filedescr['comment']);\r\n      $p_header['comment'] = $p_filedescr['comment'];\r\n    }\r\n    else {\r\n      $p_header['comment_len'] = 0;\r\n      $p_header['comment'] = '';\r\n    }\r\n\r\n    // ----- Look for pre-add callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_ADD].'(PCLZIP_CB_PRE_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_header['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {\r\n        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);\r\n      }\r\n    }\r\n\r\n    // ----- Look for empty stored filename\r\n    if ($p_header['stored_filename'] == \"\") {\r\n      $p_header['status'] = \"filtered\";\r\n    }\r\n\r\n    // ----- Check the path length\r\n    if (strlen($p_header['stored_filename']) > 0xFF) {\r\n      $p_header['status'] = 'filename_too_long';\r\n    }\r\n\r\n    // ----- Look if no error, or file not skipped\r\n    if ($p_header['status'] == 'ok') {\r\n\r\n      // ----- Look for a file\r\n      if ($p_filedescr['type'] == 'file') {\r\n        // ----- Look for using temporary file to zip\r\n        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {\r\n          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);\r\n          if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n            return $v_result;\r\n          }\r\n        }\r\n\r\n        // ----- Use \"in memory\" zip algo\r\n        else {\r\n\r\n        // ----- Open the source file\r\n        if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Read the file content\r\n        $v_content = @fread($v_file, $p_header['size']);\r\n\r\n        // ----- Close the file\r\n        @fclose($v_file);\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n\r\n        }\r\n\r\n      }\r\n\r\n      // ----- Look for a virtual file (a file from string)\r\n      else if ($p_filedescr['type'] == 'virtual_file') {\r\n\r\n        $v_content = $p_filedescr['content'];\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n      }\r\n\r\n      // ----- Look for a directory\r\n      else if ($p_filedescr['type'] == 'folder') {\r\n        // ----- Look for directory last '/'\r\n        if (@substr($p_header['stored_filename'], -1) != '/') {\r\n          $p_header['stored_filename'] .= '/';\r\n        }\r\n\r\n        // ----- Set the file properties\r\n        $p_header['size'] = 0;\r\n        //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked\r\n        $p_header['external'] = 0x00000010;   // Value for a folder : to be checked\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for post-add callback\r\n    if (isset($p_options[PCLZIP_CB_POST_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_ADD].'(PCLZIP_CB_POST_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Ignored\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Nothing can be modified\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=PCLZIP_ERR_NO_ERROR;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n\r\n    // ----- Open the source file\r\n    if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Creates a compressed temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_file_compressed = @gzopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = filesize($p_filename);\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @gzputs($v_file_compressed, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file);\r\n    @gzclose($v_file_compressed);\r\n\r\n    // ----- Check the minimum file size\r\n    if (filesize($v_gzip_temp_name) < 18) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \\''.$v_gzip_temp_name.'\\' has invalid filesize - should be minimum 18 bytes');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the compressed attributes\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the gzip file header\r\n    $v_binary_data = @fread($v_file_compressed, 10);\r\n    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);\r\n\r\n    // ----- Check some parameters\r\n    $v_data_header['os'] = bin2hex($v_data_header['os']);\r\n\r\n    // ----- Read the gzip file footer\r\n    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);\r\n    $v_binary_data = @fread($v_file_compressed, 8);\r\n    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);\r\n\r\n    // ----- Set the attributes\r\n    $p_header['compression'] = ord($v_data_header['cm']);\r\n    //$p_header['mtime'] = $v_data_header['mtime'];\r\n    $p_header['crc'] = $v_data_footer['crc'];\r\n    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Call the header generation\r\n    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the compressed data\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0)\r\n    {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    fseek($v_file_compressed, 10);\r\n    $v_size = $p_header['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file_compressed, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Unlink the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCalculateStoredFilename()\r\n  // Description :\r\n  //   Based on file descriptor properties and global options, this method\r\n  //   calculate the filename that will be stored in the archive.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCalculateStoredFilename(&$p_filedescr, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variables\r\n    $p_filename = $p_filedescr['filename'];\r\n    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {\r\n      $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];\r\n    }\r\n    else {\r\n      $p_add_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n      $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];\r\n    }\r\n    else {\r\n      $p_remove_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n      $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n    }\r\n    else {\r\n      $p_remove_all_dir = 0;\r\n    }\r\n\r\n\r\n    // ----- Look for full name change\r\n    if (isset($p_filedescr['new_full_name'])) {\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);\r\n    }\r\n\r\n    // ----- Look for path and/or short name change\r\n    else {\r\n\r\n      // ----- Look for short name change\r\n      // Its when we cahnge just the filename but not the path\r\n      if (isset($p_filedescr['new_short_name'])) {\r\n        $v_path_info = pathinfo($p_filename);\r\n        $v_dir = '';\r\n        if ($v_path_info['dirname'] != '') {\r\n          $v_dir = $v_path_info['dirname'].'/';\r\n        }\r\n        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];\r\n      }\r\n      else {\r\n        // ----- Calculate the stored filename\r\n        $v_stored_filename = $p_filename;\r\n      }\r\n\r\n      // ----- Look for all path to remove\r\n      if ($p_remove_all_dir) {\r\n        $v_stored_filename = basename($p_filename);\r\n      }\r\n      // ----- Look for partial path remove\r\n      else if ($p_remove_dir != \"\") {\r\n        if (substr($p_remove_dir, -1) != '/')\r\n          $p_remove_dir .= \"/\";\r\n\r\n        if (   (substr($p_filename, 0, 2) == \"./\")\r\n            || (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n\r\n          if (   (substr($p_filename, 0, 2) == \"./\")\r\n              && (substr($p_remove_dir, 0, 2) != \"./\")) {\r\n            $p_remove_dir = \"./\".$p_remove_dir;\r\n          }\r\n          if (   (substr($p_filename, 0, 2) != \"./\")\r\n              && (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n            $p_remove_dir = substr($p_remove_dir, 2);\r\n          }\r\n        }\r\n\r\n        $v_compare = PclZipUtilPathInclusion($p_remove_dir,\r\n                                             $v_stored_filename);\r\n        if ($v_compare > 0) {\r\n          if ($v_compare == 2) {\r\n            $v_stored_filename = \"\";\r\n          }\r\n          else {\r\n            $v_stored_filename = substr($v_stored_filename,\r\n                                        strlen($p_remove_dir));\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);\r\n\r\n      // ----- Look for path to add\r\n      if ($p_add_dir != \"\") {\r\n        if (substr($p_add_dir, -1) == \"/\")\r\n          $v_stored_filename = $p_add_dir.$v_stored_filename;\r\n        else\r\n          $v_stored_filename = $p_add_dir.\"/\".$v_stored_filename;\r\n      }\r\n    }\r\n\r\n    // ----- Filename (reduce the path of stored name)\r\n    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);\r\n    $p_filedescr['stored_filename'] = $v_stored_filename;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Store the offset position of the file\r\n    $p_header['offset'] = ftell($this->zip_fd);\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvVVVvv\", 0x04034b50,\r\n                          $p_header['version_extracted'], $p_header['flag'],\r\n                          $p_header['compression'], $v_mtime, $v_mdate,\r\n                          $p_header['crc'], $p_header['compressed_size'],\r\n                          $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len']);\r\n\r\n    // ----- Write the first 148 bytes of the header in the archive\r\n    fputs($this->zip_fd, $v_binary_data, 30);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // TBC\r\n    //for(reset($p_header); $key = key($p_header); next($p_header)) {\r\n    //}\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvvVVVvvvvvVV\", 0x02014b50,\r\n                          $p_header['version'], $p_header['version_extracted'],\r\n                          $p_header['flag'], $p_header['compression'],\r\n                          $v_mtime, $v_mdate, $p_header['crc'],\r\n                          $p_header['compressed_size'], $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len'], $p_header['comment_len'],\r\n                          $p_header['disk'], $p_header['internal'],\r\n                          $p_header['external'], $p_header['offset']);\r\n\r\n    // ----- Write the 42 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 46);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n    if ($p_header['comment_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvVVv\", 0x06054b50, 0, 0, $p_nb_entries,\r\n                          $p_nb_entries, $p_size,\r\n                          $p_offset, strlen($p_comment));\r\n\r\n    // ----- Write the 22 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 22);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_comment) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_comment, strlen($p_comment));\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privList()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privList(&$p_list)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of Central Dir\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_central_dir['offset']))\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    for ($i=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n      // ----- Read the file header\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return $v_result;\r\n      }\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Get the only interesting attributes\r\n      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);\r\n      unset($v_header);\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privConvertHeader2FileInfo()\r\n  // Description :\r\n  //   This function takes the file informations from the central directory\r\n  //   entries and extract the interesting parameters that will be given back.\r\n  //   The resulting file infos are set in the array $p_info\r\n  //     $p_info['filename'] : Filename with full path. Given by user (add),\r\n  //                           extracted in the filesystem (extract).\r\n  //     $p_info['stored_filename'] : Stored filename in the archive.\r\n  //     $p_info['size'] = Size of the file.\r\n  //     $p_info['compressed_size'] = Compressed size of the file.\r\n  //     $p_info['mtime'] = Last modification date of the file.\r\n  //     $p_info['comment'] = Comment associated with the file.\r\n  //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.\r\n  //     $p_info['status'] = status of the action on the file.\r\n  //     $p_info['crc'] = CRC of the file content.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privConvertHeader2FileInfo($p_header, &$p_info)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Get the interesting attributes\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);\r\n    $p_info['filename'] = $v_temp_path;\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);\r\n    $p_info['stored_filename'] = $v_temp_path;\r\n    $p_info['size'] = $p_header['size'];\r\n    $p_info['compressed_size'] = $p_header['compressed_size'];\r\n    $p_info['mtime'] = $p_header['mtime'];\r\n    $p_info['comment'] = $p_header['comment'];\r\n    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);\r\n    $p_info['index'] = $p_header['index'];\r\n    $p_info['status'] = $p_header['status'];\r\n    $p_info['crc'] = $p_header['crc'];\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractByRule()\r\n  // Description :\r\n  //   Extract a file or directory depending of rules (by index, by name, ...)\r\n  // Parameters :\r\n  //   $p_file_list : An array where will be placed the properties of each\r\n  //                  extracted file\r\n  //   $p_path : Path to add while writing the extracted files\r\n  //   $p_remove_path : Path to remove (from the file memorized path) while writing the\r\n  //                    extracted files. If the path does not match the file path,\r\n  //                    the file is extracted with its memorized path.\r\n  //                    $p_remove_path does not apply to 'list' mode.\r\n  //                    $p_path and $p_remove_path are commulative.\r\n  // Return Values :\r\n  //   1 on success,0 or less on error (see error code list)\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check the path\r\n    if (   ($p_path == \"\")\r\n        || (   (substr($p_path, 0, 1) != \"/\")\r\n            && (substr($p_path, 0, 3) != \"../\")\r\n            && (substr($p_path,1,2)!=\":/\")))\r\n      $p_path = \"./\".$p_path;\r\n\r\n    // ----- Reduce the path last (and duplicated) '/'\r\n    if (($p_path != \"./\") && ($p_path != \"/\"))\r\n    {\r\n      // ----- Look for the path end '/'\r\n      while (substr($p_path, -1) == \"/\")\r\n      {\r\n        $p_path = substr($p_path, 0, strlen($p_path)-1);\r\n      }\r\n    }\r\n\r\n    // ----- Look for path to remove format (should end by /)\r\n    if (($p_remove_path != \"\") && (substr($p_remove_path, -1) != '/'))\r\n    {\r\n      $p_remove_path .= '/';\r\n    }\r\n    $p_remove_path_size = strlen($p_remove_path);\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result = $this->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n\r\n    // ----- Read each entry\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read next Central dir entry\r\n      @rewind($this->zip_fd);\r\n      if (@fseek($this->zip_fd, $v_pos_entry))\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read the file header\r\n      $v_header = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n      // ----- Store the index\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Store the file position\r\n      $v_pos_entry = ftell($this->zip_fd);\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_extract = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_extract = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_extract = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_extract = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for no rule, which means extract all the archive\r\n      else {\r\n          $v_extract = true;\r\n      }\r\n\r\n      // ----- Check compression method\r\n      if (   ($v_extract)\r\n          && (   ($v_header['compression'] != 8)\r\n              && ($v_header['compression'] != 0))) {\r\n          $v_header['status'] = 'unsupported_compression';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION,\r\n                                   \"Filename '\".$v_header['stored_filename'].\"' is \"\r\n                                       .\"compressed by an unsupported compression \"\r\n                                       .\"method (\".$v_header['compression'].\") \");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n      }\r\n\r\n      // ----- Check encrypted files\r\n      if (($v_extract) && (($v_header['flag'] & 1) == 1)) {\r\n          $v_header['status'] = 'unsupported_encryption';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION,\r\n                                   \"Unsupported encryption for \"\r\n                                       .\" filename '\".$v_header['stored_filename']\r\n                                   .\"'\");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n    }\r\n\r\n      // ----- Look for real extraction\r\n      if (($v_extract) && ($v_header['status'] != 'ok')) {\r\n          $v_result = $this->privConvertHeader2FileInfo($v_header,\r\n                                                $p_file_list[$v_nb_extracted++]);\r\n          if ($v_result != 1) {\r\n              $this->privCloseFd();\r\n              $this->privSwapBackMagicQuotes();\r\n              return $v_result;\r\n          }\r\n\r\n          $v_extract = false;\r\n      }\r\n\r\n      // ----- Look for real extraction\r\n      if ($v_extract)\r\n      {\r\n\r\n        // ----- Go to the file position\r\n        @rewind($this->zip_fd);\r\n        if (@fseek($this->zip_fd, $v_header['offset']))\r\n        {\r\n          // ----- Close the zip file\r\n          $this->privCloseFd();\r\n\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Look for extraction as string\r\n        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {\r\n\r\n          $v_string = '';\r\n\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Set the file content\r\n          $p_file_list[$v_nb_extracted]['content'] = $v_string;\r\n\r\n          // ----- Next extracted file\r\n          $v_nb_extracted++;\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for extraction in standard output\r\n        elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))\r\n                && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {\r\n          // ----- Extracting the file in standard output\r\n          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for normal extraction\r\n        else {\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFile($v_header,\r\n                                              $p_path, $p_remove_path,\r\n                                              $p_remove_all_path,\r\n                                              $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //\r\n  // 1 : ... ?\r\n  // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for all path to remove\r\n    if ($p_remove_all_path == true) {\r\n        // ----- Look for folder entry that not need to be extracted\r\n        if (($p_entry['external']&0x00000010)==0x00000010) {\r\n\r\n            $p_entry['status'] = \"filtered\";\r\n\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Get the basename of the path\r\n        $p_entry['filename'] = basename($p_entry['filename']);\r\n    }\r\n\r\n    // ----- Look for path to remove\r\n    else if ($p_remove_path != \"\")\r\n    {\r\n      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"filtered\";\r\n\r\n        // ----- Return\r\n        return $v_result;\r\n      }\r\n\r\n      $p_remove_path_size = strlen($p_remove_path);\r\n      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)\r\n      {\r\n\r\n        // ----- Remove the path\r\n        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);\r\n\r\n      }\r\n    }\r\n\r\n    // ----- Add the path\r\n    if ($p_path != '') {\r\n      $p_entry['filename'] = $p_path.\"/\".$p_entry['filename'];\r\n    }\r\n\r\n    // ----- Check a base_dir_restriction\r\n    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {\r\n      $v_inclusion\r\n      = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION],\r\n                                $p_entry['filename']);\r\n      if ($v_inclusion == 0) {\r\n\r\n        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION\");\r\n\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n    // ----- Look for specific actions while the file exist\r\n    if (file_exists($p_entry['filename']))\r\n    {\r\n\r\n      // ----- Look if file is a directory\r\n      if (is_dir($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"already_a_directory\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"already used by an existing directory\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n      // ----- Look if file is write protected\r\n      else if (!is_writeable($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"write_protected\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                                 \"Filename '\".$p_entry['filename'].\"' exists \"\r\n                                 .\"and is write protected\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n\r\n      // ----- Look if the extracted file is older\r\n      else if (filemtime($p_entry['filename']) > $p_entry['mtime'])\r\n      {\r\n        // ----- Change the file status\r\n        if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))\r\n            && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {\r\n            }\r\n            else {\r\n            $p_entry['status'] = \"newer_exist\";\r\n\r\n            // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n            // For historical reason first PclZip implementation does not stop\r\n            // when this kind of error occurs.\r\n            if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n                && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                         \"Newer version of '\".$p_entry['filename'].\"' exists \"\r\n                        .\"and option PCLZIP_OPT_REPLACE_NEWER is not selected\");\r\n\r\n                return PclZip::errorCode();\r\n              }\r\n            }\r\n      }\r\n      else {\r\n      }\r\n    }\r\n\r\n    // ----- Check the directory availability and create it if necessary\r\n    else {\r\n      if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))\r\n        $v_dir_to_check = $p_entry['filename'];\r\n      else if (!strstr($p_entry['filename'], \"/\"))\r\n        $v_dir_to_check = \"\";\r\n      else\r\n        $v_dir_to_check = dirname($p_entry['filename']);\r\n\r\n        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {\r\n\r\n          // ----- Change the file status\r\n          $p_entry['status'] = \"path_creation_fail\";\r\n\r\n          // ----- Return\r\n          //return $v_result;\r\n          $v_result = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010))\r\n      {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n              // ----- Opening destination file\r\n          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)\r\n          {\r\n\r\n            // ----- Change the file status\r\n            $p_entry['status'] = \"write_error\";\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n          }\r\n\r\n\r\n          // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n          $v_size = $p_entry['compressed_size'];\r\n          while ($v_size != 0)\r\n          {\r\n            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n            $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n            /* Try to speed up the code\r\n            $v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n            @fwrite($v_dest_file, $v_binary_data, $v_read_size);\r\n            */\r\n            @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n            $v_size -= $v_read_size;\r\n          }\r\n\r\n          // ----- Closing the destination file\r\n          fclose($v_dest_file);\r\n\r\n          // ----- Change the file mtime\r\n          touch($p_entry['filename'], $p_entry['mtime']);\r\n\r\n\r\n        }\r\n        else {\r\n          // ----- TBC\r\n          // Need to be finished\r\n          if (($p_entry['flag'] & 1) == 1) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \\''.$p_entry['filename'].'\\' is encrypted. Encrypted files are not supported.');\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n\r\n          // ----- Look for using temporary file to unzip\r\n          if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n              && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                  || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                      && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {\r\n            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);\r\n            if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n              return $v_result;\r\n            }\r\n          }\r\n\r\n          // ----- Look for extract in memory\r\n          else {\r\n\r\n\r\n            // ----- Read the compressed file in a buffer (one shot)\r\n            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n            // ----- Decompress the file\r\n            $v_file_content = @gzinflate($v_buffer);\r\n            unset($v_buffer);\r\n            if ($v_file_content === FALSE) {\r\n\r\n              // ----- Change the file status\r\n              // TBC\r\n              $p_entry['status'] = \"error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Opening destination file\r\n            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n\r\n              // ----- Change the file status\r\n              $p_entry['status'] = \"write_error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Write the uncompressed data\r\n            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);\r\n            unset($v_file_content);\r\n\r\n            // ----- Closing the destination file\r\n            @fclose($v_dest_file);\r\n\r\n          }\r\n\r\n          // ----- Change the file mtime\r\n          @touch($p_entry['filename'], $p_entry['mtime']);\r\n        }\r\n\r\n        // ----- Look for chmod option\r\n        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {\r\n\r\n          // ----- Change the mode of the file\r\n          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileUsingTempFile(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Creates a temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_dest_file = @fopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Write gz file format header\r\n    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));\r\n    @fwrite($v_dest_file, $v_binary_data, 10);\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Write gz file format footer\r\n    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);\r\n    @fwrite($v_dest_file, $v_binary_data, 8);\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_dest_file);\r\n\r\n    // ----- Opening destination file\r\n    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n      $p_entry['status'] = \"write_error\";\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary gz file\r\n    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {\r\n      @fclose($v_dest_file);\r\n      $p_entry['status'] = \"read_error\";\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['size'];\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @gzread($v_src_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n    @fclose($v_dest_file);\r\n    @gzclose($v_src_file);\r\n\r\n    // ----- Delete the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileInOutput()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileInOutput(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compressed_size'] == $p_entry['size']) {\r\n\r\n          // ----- Read the file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_buffer;\r\n          unset($v_buffer);\r\n        }\r\n        else {\r\n\r\n          // ----- Read the compressed file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          $v_file_content = gzinflate($v_buffer);\r\n          unset($v_buffer);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_file_content;\r\n          unset($v_file_content);\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Change abort status\r\n    if ($p_entry['status'] == \"aborted\") {\r\n      $p_entry['status'] = \"skipped\";\r\n    }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileAsString()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    $v_header = array();\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n  //      if ($p_entry['compressed_size'] == $p_entry['size'])\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n          // ----- Reading the file\r\n          $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n        }\r\n        else {\r\n\r\n          // ----- Reading the file\r\n          $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          if (($p_string = @gzinflate($v_data)) === FALSE) {\r\n              // TBC\r\n          }\r\n        }\r\n\r\n        // ----- Trace\r\n      }\r\n      else {\r\n          // TBC : error : can not extract a folder in a string\r\n      }\r\n\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Swap the content to header\r\n      $v_local_header['content'] = $p_string;\r\n      $p_string = '';\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Swap back the content to header\r\n      $p_string = $v_local_header['content'];\r\n      unset($v_local_header['content']);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x04034b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 26);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 26)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);\r\n\r\n    // ----- Get extra_fields\r\n    if ($v_data['extra_len'] != 0) {\r\n      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);\r\n    }\r\n    else {\r\n      $p_header['extra'] = '';\r\n    }\r\n\r\n    // ----- Extract properties\r\n    $p_header['version_extracted'] = $v_data['version'];\r\n    $p_header['compression'] = $v_data['compression'];\r\n    $p_header['size'] = $v_data['size'];\r\n    $p_header['compressed_size'] = $v_data['compressed_size'];\r\n    $p_header['crc'] = $v_data['crc'];\r\n    $p_header['flag'] = $v_data['flag'];\r\n    $p_header['filename_len'] = $v_data['filename_len'];\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    $p_header['mdate'] = $v_data['mdate'];\r\n    $p_header['mtime'] = $v_data['mtime'];\r\n    if ($p_header['mdate'] && $p_header['mtime'])\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // TBC\r\n    //for(reset($v_data); $key = key($v_data); next($v_data)) {\r\n    //}\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set the status field\r\n    $p_header['status'] = \"ok\";\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x02014b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 42);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 42)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    if ($p_header['filename_len'] != 0)\r\n      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);\r\n    else\r\n      $p_header['filename'] = '';\r\n\r\n    // ----- Get extra\r\n    if ($p_header['extra_len'] != 0)\r\n      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);\r\n    else\r\n      $p_header['extra'] = '';\r\n\r\n    // ----- Get comment\r\n    if ($p_header['comment_len'] != 0)\r\n      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);\r\n    else\r\n      $p_header['comment'] = '';\r\n\r\n    // ----- Extract properties\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    //if ($p_header['mdate'] && $p_header['mtime'])\r\n    // TBC : bug : this was ignoring time with 0/0/0\r\n    if (1)\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set default status to ok\r\n    $p_header['status'] = 'ok';\r\n\r\n    // ----- Look if it is a directory\r\n    if (substr($p_header['filename'], -1) == '/') {\r\n      //$p_header['external'] = 0x41FF0010;\r\n      $p_header['external'] = 0x00000010;\r\n    }\r\n\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFileHeaders()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 on error;\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFileHeaders(&$p_local_header, &$p_central_header)\r\n  {\r\n    $v_result=1;\r\n\r\n      // ----- Check the static values\r\n      // TBC\r\n      if ($p_local_header['filename'] != $p_central_header['filename']) {\r\n      }\r\n      if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {\r\n      }\r\n      if ($p_local_header['flag'] != $p_central_header['flag']) {\r\n      }\r\n      if ($p_local_header['compression'] != $p_central_header['compression']) {\r\n      }\r\n      if ($p_local_header['mtime'] != $p_central_header['mtime']) {\r\n      }\r\n      if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {\r\n      }\r\n\r\n      // ----- Look for flag bit 3\r\n      if (($p_local_header['flag'] & 8) == 8) {\r\n          $p_local_header['size'] = $p_central_header['size'];\r\n          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];\r\n          $p_local_header['crc'] = $p_central_header['crc'];\r\n      }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadEndCentralDir()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadEndCentralDir(&$p_central_dir)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Go to the end of the zip file\r\n    $v_size = filesize($this->zipname);\r\n    @fseek($this->zip_fd, $v_size);\r\n    if (@ftell($this->zip_fd) != $v_size)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \\''.$this->zipname.'\\'');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- First try : look if this is an archive with no commentaries (most of the time)\r\n    // in this case the end of central dir is at 22 bytes of the file end\r\n    $v_found = 0;\r\n    if ($v_size > 26) {\r\n      @fseek($this->zip_fd, $v_size-22);\r\n      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read for bytes\r\n      $v_binary_data = @fread($this->zip_fd, 4);\r\n      $v_data = @unpack('Vid', $v_binary_data);\r\n\r\n      // ----- Check signature\r\n      if ($v_data['id'] == 0x06054b50) {\r\n        $v_found = 1;\r\n      }\r\n\r\n      $v_pos = ftell($this->zip_fd);\r\n    }\r\n\r\n    // ----- Go back to the maximum possible size of the Central Dir End Record\r\n    if (!$v_found) {\r\n      $v_maximum_size = 65557; // 0xFFFF + 22;\r\n      if ($v_maximum_size > $v_size)\r\n        $v_maximum_size = $v_size;\r\n      @fseek($this->zip_fd, $v_size-$v_maximum_size);\r\n      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read byte per byte in order to find the signature\r\n      $v_pos = ftell($this->zip_fd);\r\n      $v_bytes = 0x00000000;\r\n      while ($v_pos < $v_size)\r\n      {\r\n        // ----- Read a byte\r\n        $v_byte = @fread($this->zip_fd, 1);\r\n\r\n        // -----  Add the byte\r\n        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);\r\n        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number\r\n        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.\r\n        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);\r\n\r\n        // ----- Compare the bytes\r\n        if ($v_bytes == 0x504b0506)\r\n        {\r\n          $v_pos++;\r\n          break;\r\n        }\r\n\r\n        $v_pos++;\r\n      }\r\n\r\n      // ----- Look if not found end of central dir\r\n      if ($v_pos == $v_size)\r\n      {\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Unable to find End of Central Dir Record signature\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Read the first 18 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 18);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 18)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid End of Central Dir Record size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);\r\n\r\n    // ----- Check the global size\r\n    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {\r\n\r\n      // ----- Removed in release 2.2 see readme file\r\n      // The check of the file size is a little too strict.\r\n      // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.\r\n      // While decrypted, zip has training 0 bytes\r\n      if (0) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,\r\n                           'The central dir is not at the end of the archive.'\r\n                           .' Some trailing bytes exists after the archive.');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Get comment\r\n    if ($v_data['comment_size'] != 0) {\r\n      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);\r\n    }\r\n    else\r\n      $p_central_dir['comment'] = '';\r\n\r\n    $p_central_dir['entries'] = $v_data['entries'];\r\n    $p_central_dir['disk_entries'] = $v_data['disk_entries'];\r\n    $p_central_dir['offset'] = $v_data['offset'];\r\n    $p_central_dir['size'] = $v_data['size'];\r\n    $p_central_dir['disk'] = $v_data['disk'];\r\n    $p_central_dir['disk_start'] = $v_data['disk_start'];\r\n\r\n    // TBC\r\n    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {\r\n    //}\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDeleteByRule()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDeleteByRule(&$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Scan all the files\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_pos_entry))\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    $v_header_list = array();\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read the file header\r\n      $v_header_list[$v_nb_extracted] = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n\r\n      // ----- Store the index\r\n      $v_header_list[$v_nb_extracted]['index'] = $i;\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_found = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n                  elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /* Indicates a folder */\r\n                          && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_found = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_found = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          $v_found = true;\r\n      }\r\n\r\n      // ----- Look for deletion\r\n      if ($v_found)\r\n      {\r\n        unset($v_header_list[$v_nb_extracted]);\r\n      }\r\n      else\r\n      {\r\n        $v_nb_extracted++;\r\n      }\r\n    }\r\n\r\n    // ----- Look if something need to be deleted\r\n    if ($v_nb_extracted > 0) {\r\n\r\n        // ----- Creates a temporay file\r\n        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n        // ----- Creates a temporary zip archive\r\n        $v_temp_zip = new PclZip($v_zip_temp_name);\r\n\r\n        // ----- Open the temporary zip file in write mode\r\n        if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {\r\n            $this->privCloseFd();\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Look which file need to be kept\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n\r\n            // ----- Calculate the position of the header\r\n            @rewind($this->zip_fd);\r\n            if (@fseek($this->zip_fd,  $v_header_list[$i]['offset'])) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Error log\r\n                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n                // ----- Return\r\n                return PclZip::errorCode();\r\n            }\r\n\r\n            // ----- Read the file header\r\n            $v_local_header = array();\r\n            if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Check that local file header is same as central file header\r\n            if ($this->privCheckFileHeaders($v_local_header,\r\n                                            $v_header_list[$i]) != 1) {\r\n                // TBC\r\n            }\r\n            unset($v_local_header);\r\n\r\n            // ----- Write the file header\r\n            if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Read/write the data block\r\n            if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n        }\r\n\r\n        // ----- Store the offset of the central dir\r\n        $v_offset = @ftell($v_temp_zip->zip_fd);\r\n\r\n        // ----- Re-Create the Central Dir files header\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n            // ----- Create the file header\r\n            if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n                $v_temp_zip->privCloseFd();\r\n                $this->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Transform the header to a 'usable' info\r\n            $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n        }\r\n\r\n\r\n        // ----- Zip file comment\r\n        $v_comment = '';\r\n        if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n          $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n        }\r\n\r\n        // ----- Calculate the size of the central header\r\n        $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset;\r\n\r\n        // ----- Create the central dir footer\r\n        if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {\r\n            // ----- Reset the file list\r\n            unset($v_header_list);\r\n            $v_temp_zip->privCloseFd();\r\n            $this->privCloseFd();\r\n            @unlink($v_zip_temp_name);\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Close\r\n        $v_temp_zip->privCloseFd();\r\n        $this->privCloseFd();\r\n\r\n        // ----- Delete the zip file\r\n        // TBC : I should test the result ...\r\n        @unlink($this->zipname);\r\n\r\n        // ----- Rename the temporary file\r\n        // TBC : I should test the result ...\r\n        //@rename($v_zip_temp_name, $this->zipname);\r\n        PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n        // ----- Destroy the temporary archive\r\n        unset($v_temp_zip);\r\n    }\r\n\r\n    // ----- Remove every files : reset the file\r\n    else if ($v_central_dir['entries'] != 0) {\r\n        $this->privCloseFd();\r\n\r\n        if (($v_result = $this->privOpenFd('wb')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        $this->privCloseFd();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDirCheck()\r\n  // Description :\r\n  //   Check if a directory exists, if not it creates it and all the parents directory\r\n  //   which may be useful.\r\n  // Parameters :\r\n  //   $p_dir : Directory path to check.\r\n  // Return Values :\r\n  //    1 : OK\r\n  //   -1 : Unable to create directory\r\n  // --------------------------------------------------------------------------------\r\n  function privDirCheck($p_dir, $p_is_dir=false)\r\n  {\r\n    $v_result = 1;\r\n\r\n\r\n    // ----- Remove the final '/'\r\n    if (($p_is_dir) && (substr($p_dir, -1)=='/'))\r\n    {\r\n      $p_dir = substr($p_dir, 0, strlen($p_dir)-1);\r\n    }\r\n\r\n    // ----- Check the directory availability\r\n    if ((is_dir($p_dir)) || ($p_dir == \"\"))\r\n    {\r\n      return 1;\r\n    }\r\n\r\n    // ----- Extract parent directory\r\n    $p_parent_dir = dirname($p_dir);\r\n\r\n    // ----- Just a check\r\n    if ($p_parent_dir != $p_dir)\r\n    {\r\n      // ----- Look for parent directory\r\n      if ($p_parent_dir != \"\")\r\n      {\r\n        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Create the directory\r\n    if (!@mkdir($p_dir, 0777))\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, \"Unable to create directory '$p_dir'\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privMerge()\r\n  // Description :\r\n  //   If $p_archive_to_add does not exist, the function exit with a success result.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privMerge(&$p_archive_to_add)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the archive_to_add exists\r\n    if (!is_file($p_archive_to_add->zipname))\r\n    {\r\n\r\n      // ----- Nothing to merge, so merge is a success\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if the archive exists\r\n    if (!is_file($this->zipname))\r\n    {\r\n\r\n      // ----- Do a duplicate\r\n      $v_result = $this->privDuplicate($p_archive_to_add->zipname);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Open the archive_to_add file\r\n    if (($v_result=$p_archive_to_add->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir_to_add = array();\r\n    if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($p_archive_to_add->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the files from the archive_to_add into the temporary file\r\n    $v_size = $v_central_dir_to_add['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($v_zip_temp_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the block of file headers from the archive_to_add\r\n    $v_size = $v_central_dir_to_add['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Merge the file comments\r\n    $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];\r\n\r\n    // ----- Calculate the size of the (new) central header\r\n    $v_size = @ftell($v_zip_temp_fd)-$v_offset;\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive fd\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n      @fclose($v_zip_temp_fd);\r\n      $this->zip_fd = null;\r\n\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n    $p_archive_to_add->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDuplicate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDuplicate($p_archive_filename)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the $p_archive_filename exists\r\n    if (!is_file($p_archive_filename))\r\n    {\r\n\r\n      // ----- Nothing to duplicate, so duplicate is a success.\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \\''.$p_archive_filename.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = filesize($p_archive_filename);\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorLog()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorLog($p_error_code=0, $p_error_string='')\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclError($p_error_code, $p_error_string);\r\n    }\r\n    else {\r\n      $this->error_code = $p_error_code;\r\n      $this->error_string = $p_error_string;\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorReset()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorReset()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclErrorReset();\r\n    }\r\n    else {\r\n      $this->error_code = 0;\r\n      $this->error_string = '';\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDisableMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDisableMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if already done\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get and memorize the magic_quote value\r\n    $this->magic_quotes_status = @get_magic_quotes_runtime();\r\n\r\n    // ----- Disable magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n      @set_magic_quotes_runtime(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privSwapBackMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privSwapBackMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if something to do\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n        @set_magic_quotes_runtime($this->magic_quotes_status);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  }\r\n  // End of class\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathReduction()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathReduction($p_dir)\r\n  {\r\n    $v_result = \"\";\r\n\r\n    // ----- Look for not empty path\r\n    if ($p_dir != \"\") {\r\n      // ----- Explode path by directory names\r\n      $v_list = explode(\"/\", $p_dir);\r\n\r\n      // ----- Study directories from last to first\r\n      $v_skip = 0;\r\n      for ($i=sizeof($v_list)-1; $i>=0; $i--) {\r\n        // ----- Look for current path\r\n        if ($v_list[$i] == \".\") {\r\n          // ----- Ignore this directory\r\n          // Should be the first $i=0, but no check is done\r\n        }\r\n        else if ($v_list[$i] == \"..\") {\r\n          $v_skip++;\r\n        }\r\n        else if ($v_list[$i] == \"\") {\r\n          // ----- First '/' i.e. root slash\r\n          if ($i == 0) {\r\n            $v_result = \"/\".$v_result;\r\n            if ($v_skip > 0) {\r\n                // ----- It is an invalid path, so the path is not modified\r\n                // TBC\r\n                $v_result = $p_dir;\r\n                $v_skip = 0;\r\n            }\r\n          }\r\n          // ----- Last '/' i.e. indicates a directory\r\n          else if ($i == (sizeof($v_list)-1)) {\r\n            $v_result = $v_list[$i];\r\n          }\r\n          // ----- Double '/' inside the path\r\n          else {\r\n            // ----- Ignore only the double '//' in path,\r\n            // but not the first and last '/'\r\n          }\r\n        }\r\n        else {\r\n          // ----- Look for item to skip\r\n          if ($v_skip > 0) {\r\n            $v_skip--;\r\n          }\r\n          else {\r\n            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?\"/\".$v_result:\"\");\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Look for skip\r\n      if ($v_skip > 0) {\r\n        while ($v_skip > 0) {\r\n            $v_result = '../'.$v_result;\r\n            $v_skip--;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathInclusion()\r\n  // Description :\r\n  //   This function indicates if the path $p_path is under the $p_dir tree. Or,\r\n  //   said in an other way, if the file or sub-dir $p_path is inside the dir\r\n  //   $p_dir.\r\n  //   The function indicates also if the path is exactly the same as the dir.\r\n  //   This function supports path with duplicated '/' like '//', but does not\r\n  //   support '.' or '..' statements.\r\n  // Parameters :\r\n  // Return Values :\r\n  //   0 if $p_path is not inside directory $p_dir\r\n  //   1 if $p_path is inside directory $p_dir\r\n  //   2 if $p_path is exactly the same as $p_dir\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathInclusion($p_dir, $p_path)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Look for path beginning by ./\r\n    if (   ($p_dir == '.')\r\n        || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) {\r\n      $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1);\r\n    }\r\n    if (   ($p_path == '.')\r\n        || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) {\r\n      $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1);\r\n    }\r\n\r\n    // ----- Explode dir and path by directory separator\r\n    $v_list_dir = explode(\"/\", $p_dir);\r\n    $v_list_dir_size = sizeof($v_list_dir);\r\n    $v_list_path = explode(\"/\", $p_path);\r\n    $v_list_path_size = sizeof($v_list_path);\r\n\r\n    // ----- Study directories paths\r\n    $i = 0;\r\n    $j = 0;\r\n    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {\r\n\r\n      // ----- Look for empty dir (path reduction)\r\n      if ($v_list_dir[$i] == '') {\r\n        $i++;\r\n        continue;\r\n      }\r\n      if ($v_list_path[$j] == '') {\r\n        $j++;\r\n        continue;\r\n      }\r\n\r\n      // ----- Compare the items\r\n      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {\r\n        $v_result = 0;\r\n      }\r\n\r\n      // ----- Next items\r\n      $i++;\r\n      $j++;\r\n    }\r\n\r\n    // ----- Look if everything seems to be the same\r\n    if ($v_result) {\r\n      // ----- Skip all the empty items\r\n      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;\r\n      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;\r\n\r\n      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {\r\n        // ----- There are exactly the same\r\n        $v_result = 2;\r\n      }\r\n      else if ($i < $v_list_dir_size) {\r\n        // ----- The path is shorter than the dir\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilCopyBlock()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_mode : read/write compression mode\r\n  //             0 : src & dest normal\r\n  //             1 : src gzip, dest normal\r\n  //             2 : src normal, dest gzip\r\n  //             3 : src & dest gzip\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)\r\n  {\r\n    $v_result = 1;\r\n\r\n    if ($p_mode==0)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==1)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==2)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==3)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilRename()\r\n  // Description :\r\n  //   This function tries to do a simple rename() function. If it fails, it\r\n  //   tries to copy the $p_src file in a new $p_dest file and then unlink the\r\n  //   first one.\r\n  // Parameters :\r\n  //   $p_src : Old filename\r\n  //   $p_dest : New filename\r\n  // Return Values :\r\n  //   1 on success, 0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilRename($p_src, $p_dest)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Try to rename the files\r\n    if (!@rename($p_src, $p_dest)) {\r\n\r\n      // ----- Try to copy & unlink the src\r\n      if (!@copy($p_src, $p_dest)) {\r\n        $v_result = 0;\r\n      }\r\n      else if (!@unlink($p_src)) {\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilOptionText()\r\n  // Description :\r\n  //   Translate option value in text. Mainly for debug purpose.\r\n  // Parameters :\r\n  //   $p_option : the option value.\r\n  // Return Values :\r\n  //   The option text value.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilOptionText($p_option)\r\n  {\r\n\r\n    $v_list = get_defined_constants();\r\n    for (reset($v_list); $v_key = key($v_list); next($v_list)) {\r\n        $v_prefix = substr($v_key, 0, 10);\r\n        if ((   ($v_prefix == 'PCLZIP_OPT')\r\n           || ($v_prefix == 'PCLZIP_CB_')\r\n           || ($v_prefix == 'PCLZIP_ATT'))\r\n            && ($v_list[$v_key] == $p_option)) {\r\n        return $v_key;\r\n        }\r\n    }\r\n\r\n    $v_result = 'Unknown';\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilTranslateWinPath()\r\n  // Description :\r\n  //   Translate windows path by replacing '\\' by '/' and optionally removing\r\n  //   drive letter.\r\n  // Parameters :\r\n  //   $p_path : path to translate.\r\n  //   $p_remove_disk_letter : true | false\r\n  // Return Values :\r\n  //   The path translated.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)\r\n  {\r\n    if (stristr(php_uname(), 'windows')) {\r\n      // ----- Look for potential disk letter\r\n      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {\r\n          $p_path = substr($p_path, $v_position+1);\r\n      }\r\n      // ----- Change potential windows directory separator\r\n      if ((strpos($p_path, '\\\\') > 0) || (substr($p_path, 0,1) == '\\\\')) {\r\n          $p_path = strtr($p_path, '\\\\', '/');\r\n      }\r\n    }\r\n    return $p_path;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n?>\r\n"], "fixing_code": ["<?php\r\n// --------------------------------------------------------------------------------\r\n// PhpConcept Library - Zip Module 2.8.2\r\n// --------------------------------------------------------------------------------\r\n// License GNU/LGPL - Vincent Blavet - August 2009\r\n// http://www.phpconcept.net\r\n// --------------------------------------------------------------------------------\r\n//\r\n// Presentation :\r\n//   PclZip is a PHP library that manage ZIP archives.\r\n//   So far tests show that archives generated by PclZip are readable by\r\n//   WinZip application and other tools.\r\n//\r\n// Description :\r\n//   See readme.txt and http://www.phpconcept.net\r\n//\r\n// Warning :\r\n//   This library and the associated files are non commercial, non professional\r\n//   work.\r\n//   It should not have unexpected results. However if any damage is caused by\r\n//   this software the author can not be responsible.\r\n//   The use of this software is at the risk of the user.\r\n//\r\n// --------------------------------------------------------------------------------\r\n// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Constants\r\n  if (!defined('PCLZIP_READ_BLOCK_SIZE')) {\r\n    define( 'PCLZIP_READ_BLOCK_SIZE', 2048 );\r\n  }\r\n\r\n  // ----- File list separator\r\n  // In version 1.x of PclZip, the separator for file list is a space\r\n  // (which is not a very smart choice, specifically for windows paths !).\r\n  // A better separator should be a comma (,). This constant gives you the\r\n  // abilty to change that.\r\n  // However notice that changing this value, may have impact on existing\r\n  // scripts, using space separated filenames.\r\n  // Recommanded values for compatibility with older versions :\r\n  //define( 'PCLZIP_SEPARATOR', ' ' );\r\n  // Recommanded values for smart separation of filenames.\r\n  if (!defined('PCLZIP_SEPARATOR')) {\r\n    define( 'PCLZIP_SEPARATOR', ',' );\r\n  }\r\n\r\n  // ----- Error configuration\r\n  // 0 : PclZip Class integrated error handling\r\n  // 1 : PclError external library error handling. By enabling this\r\n  //     you must ensure that you have included PclError library.\r\n  // [2,...] : reserved for futur use\r\n  if (!defined('PCLZIP_ERROR_EXTERNAL')) {\r\n    define( 'PCLZIP_ERROR_EXTERNAL', 0 );\r\n  }\r\n\r\n  // ----- Optional static temporary directory\r\n  //       By default temporary files are generated in the script current\r\n  //       path.\r\n  //       If defined :\r\n  //       - MUST BE terminated by a '/'.\r\n  //       - MUST be a valid, already created directory\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );\r\n  // define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );\r\n  if (!defined('PCLZIP_TEMPORARY_DIR')) {\r\n    define( 'PCLZIP_TEMPORARY_DIR', '' );\r\n  }\r\n\r\n  // ----- Optional threshold ratio for use of temporary files\r\n  //       Pclzip sense the size of the file to add/extract and decide to\r\n  //       use or not temporary file. The algorythm is looking for\r\n  //       memory_limit of PHP and apply a ratio.\r\n  //       threshold = memory_limit * ratio.\r\n  //       Recommended values are under 0.5. Default 0.47.\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );\r\n  if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {\r\n    define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 );\r\n  }\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Global variables\r\n  $g_pclzip_version = \"2.8.2\";\r\n\r\n  // ----- Error codes\r\n  //   -1 : Unable to open file in binary write mode\r\n  //   -2 : Unable to open file in binary read mode\r\n  //   -3 : Invalid parameters\r\n  //   -4 : File does not exist\r\n  //   -5 : Filename is too long (max. 255)\r\n  //   -6 : Not a valid zip file\r\n  //   -7 : Invalid extracted file size\r\n  //   -8 : Unable to create directory\r\n  //   -9 : Invalid archive extension\r\n  //  -10 : Invalid archive format\r\n  //  -11 : Unable to delete file (unlink)\r\n  //  -12 : Unable to rename file (rename)\r\n  //  -13 : Invalid header checksum\r\n  //  -14 : Invalid archive size\r\n  define( 'PCLZIP_ERR_USER_ABORTED', 2 );\r\n  define( 'PCLZIP_ERR_NO_ERROR', 0 );\r\n  define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );\r\n  define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );\r\n  define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );\r\n  define( 'PCLZIP_ERR_MISSING_FILE', -4 );\r\n  define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );\r\n  define( 'PCLZIP_ERR_INVALID_ZIP', -6 );\r\n  define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );\r\n  define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );\r\n  define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );\r\n  define( 'PCLZIP_ERR_BAD_FORMAT', -10 );\r\n  define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );\r\n  define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );\r\n  define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );\r\n  define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );\r\n  define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );\r\n  define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );\r\n  define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );\r\n  define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );\r\n  define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );\r\n\r\n  // ----- Options values\r\n  define( 'PCLZIP_OPT_PATH', 77001 );\r\n  define( 'PCLZIP_OPT_ADD_PATH', 77002 );\r\n  define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );\r\n  define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );\r\n  define( 'PCLZIP_OPT_SET_CHMOD', 77005 );\r\n  define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );\r\n  define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );\r\n  define( 'PCLZIP_OPT_BY_NAME', 77008 );\r\n  define( 'PCLZIP_OPT_BY_INDEX', 77009 );\r\n  define( 'PCLZIP_OPT_BY_EREG', 77010 );\r\n  define( 'PCLZIP_OPT_BY_PREG', 77011 );\r\n  define( 'PCLZIP_OPT_COMMENT', 77012 );\r\n  define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );\r\n  define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );\r\n  define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );\r\n  define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );\r\n  define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );\r\n  // Having big trouble with crypt. Need to multiply 2 long int\r\n  // which is not correctly supported by PHP ...\r\n  //define( 'PCLZIP_OPT_CRYPT', 77018 );\r\n  define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );\r\n  define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022 ); // alias\r\n\r\n  // ----- File description attributes\r\n  define( 'PCLZIP_ATT_FILE_NAME', 79001 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );\r\n  define( 'PCLZIP_ATT_FILE_MTIME', 79004 );\r\n  define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );\r\n  define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );\r\n\r\n  // ----- Call backs values\r\n  define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );\r\n  define( 'PCLZIP_CB_POST_EXTRACT', 78002 );\r\n  define( 'PCLZIP_CB_PRE_ADD', 78003 );\r\n  define( 'PCLZIP_CB_POST_ADD', 78004 );\r\n  /* For futur use\r\n  define( 'PCLZIP_CB_PRE_LIST', 78005 );\r\n  define( 'PCLZIP_CB_POST_LIST', 78006 );\r\n  define( 'PCLZIP_CB_PRE_DELETE', 78007 );\r\n  define( 'PCLZIP_CB_POST_DELETE', 78008 );\r\n  */\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Class : PclZip\r\n  // Description :\r\n  //   PclZip is the class that represent a Zip archive.\r\n  //   The public methods allow the manipulation of the archive.\r\n  // Attributes :\r\n  //   Attributes must not be accessed directly.\r\n  // Methods :\r\n  //   PclZip() : Object creator\r\n  //   create() : Creates the Zip archive\r\n  //   listContent() : List the content of the Zip archive\r\n  //   extract() : Extract the content of the archive\r\n  //   properties() : List the properties of the archive\r\n  // --------------------------------------------------------------------------------\r\n  class PclZip\r\n  {\r\n    // ----- Filename of the zip file\r\n    var $zipname = '';\r\n\r\n    // ----- File descriptor of the zip file\r\n    var $zip_fd = 0;\r\n\r\n    // ----- Internal error handling\r\n    var $error_code = 1;\r\n    var $error_string = '';\r\n\r\n    // ----- Current status of the magic_quotes_runtime\r\n    // This value store the php configuration for magic_quotes\r\n    // The class can then disable the magic_quotes and reset it after\r\n    var $magic_quotes_status;\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZip()\r\n  // Description :\r\n  //   Creates a PclZip object and set the name of the associated Zip archive\r\n  //   filename.\r\n  //   Note that no real action is taken, if the archive does not exist it is not\r\n  //   created. Use create() for that.\r\n  // --------------------------------------------------------------------------------\r\n  public function __construct($p_zipname)\r\n  {\r\n\r\n    // ----- Tests the zlib\r\n    if (!function_exists('gzopen'))\r\n    {\r\n      die('Abort '.basename(__FILE__).' : Missing zlib extensions');\r\n    }\r\n\r\n    // ----- Set the attributes\r\n    $this->zipname = $p_zipname;\r\n    $this->zip_fd = 0;\r\n    $this->magic_quotes_status = -1;\r\n\r\n    // ----- Return\r\n    return;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   create($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   create($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two different synopsis. The first one is historical.\r\n  //   This method creates a Zip Archive. The Zip file is created in the\r\n  //   filesystem. The files and directories indicated in $p_filelist\r\n  //   are added in the archive. See the parameters description for the\r\n  //   supported format of $p_filelist.\r\n  //   When a directory is in the list, the directory and its content is added\r\n  //   in the archive.\r\n  //   In this synopsis, the function takes an optional variable list of\r\n  //   options. See bellow the supported options.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function create($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove from the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                             ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Invalid number / type of arguments\");\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        if ($v_string != '') {\r\n          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   add($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   add($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This methods add the list of files in an existing archive.\r\n  //   If a file with the same name already exists, it is added at the end of the\r\n  //   archive, the first one is still present.\r\n  //   If the archive does not exist, it is created.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_OPT_ADD_COMMENT :\r\n  //   PCLZIP_OPT_PREPEND_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function add($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type '\".gettype($p_filelist).\"' for p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : listContent()\r\n  // Description :\r\n  //   This public method, gives the list of the files and directories, with their\r\n  //   properties.\r\n  //   The properties of each entries in the list are (used also in other functions) :\r\n  //     filename : Name of the file. For a create or add action it is the filename\r\n  //                given by the user. For an extract function it is the filename\r\n  //                of the extracted file.\r\n  //     stored_filename : Name of the file / directory stored in the archive.\r\n  //     size : Size of the stored file.\r\n  //     compressed_size : Size of the file's data compressed in the archive\r\n  //                       (without the headers overhead)\r\n  //     mtime : Last known modification date of the file (UNIX timestamp)\r\n  //     comment : Comment associated with the file\r\n  //     folder : true | false\r\n  //     index : index of the file in the archive\r\n  //     status : status of the action (depending of the action) :\r\n  //              Values are :\r\n  //                ok : OK !\r\n  //                filtered : the file / dir is not extracted (filtered by user)\r\n  //                already_a_directory : the file can not be extracted because a\r\n  //                                      directory with the same name already exists\r\n  //                write_protected : the file can not be extracted because a file\r\n  //                                  with the same name already exists and is\r\n  //                                  write protected\r\n  //                newer_exist : the file was not extracted because a newer file exists\r\n  //                path_creation_fail : the file is not extracted because the folder\r\n  //                                     does not exist and can not be created\r\n  //                write_error : the file was not extracted because there was a\r\n  //                              error while writing the file\r\n  //                read_error : the file was not extracted because there was a error\r\n  //                             while reading the file\r\n  //                invalid_header : the file was not extracted because of an archive\r\n  //                                 format error (bad file header)\r\n  //   Note that each time a method can continue operating when there\r\n  //   is an action error on a file, the error is only logged in the file status.\r\n  // Return Values :\r\n  //   0 on an unrecoverable failure,\r\n  //   The list of the files in the archive.\r\n  // --------------------------------------------------------------------------------\r\n  function listContent()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    if (($v_result = $this->privList($p_list)) != 1)\r\n    {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extract($p_path=\"./\", $p_remove_path=\"\")\r\n  //   extract([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method extract all the files / directories from the archive to the\r\n  //   folder indicated in $p_path.\r\n  //   If you want to ignore the 'root' part of path of the memorized files\r\n  //   you can indicate this in the optional $p_remove_path parameter.\r\n  //   By default, if a newer file with the same name already exists, the\r\n  //   file is not extracted.\r\n  //\r\n  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions\r\n  //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append\r\n  //   at the end of the path value of PCLZIP_OPT_PATH.\r\n  // Parameters :\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 or a negative value on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function extract()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_BY_NAME => 'optional',\r\n                                                   PCLZIP_OPT_BY_EREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_PREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_INDEX => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                    ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path,\r\n                                         $v_remove_all_path, $v_options);\r\n    if ($v_result < 1) {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extractByIndex($p_index, $p_path=\"./\", $p_remove_path=\"\")\r\n  //   extractByIndex($p_index, [$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method is doing a partial extract of the archive.\r\n  //   The extracted files or folders are identified by their index in the\r\n  //   archive (from 0 to n).\r\n  //   Note that if the index identify a folder, only the folder entry is\r\n  //   extracted, not all the files included in the archive.\r\n  // Parameters :\r\n  //   $p_index : A single index (integer) or a string of indexes of files to\r\n  //              extract. The form of the string is \"0,4-6,8-12\" with only numbers\r\n  //              and '-' for range or ',' to separate ranges. No spaces or ';'\r\n  //              are allowed.\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and\r\n  //     not as files.\r\n  //     The resulting content is in a new field 'content' in the file\r\n  //     structure.\r\n  //     This option must be used alone (any other options are ignored).\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  //function extractByIndex($p_index, options...)\r\n  function extractByIndex($p_index)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {\r\n          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Trick\r\n    // Here I want to reuse extractByRule(), so I need to parse the $p_index\r\n    // with privParseOptions()\r\n    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);\r\n    $v_options_trick = array();\r\n    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick,\r\n                                        array (PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n    if ($v_result != 1) {\r\n        return 0;\r\n    }\r\n    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Call the extracting fct\r\n    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {\r\n        return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   delete([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method removes files from the archive.\r\n  //   If no parameters are given, then all the archive is emptied.\r\n  // Parameters :\r\n  //   None or optional arguments.\r\n  // Options :\r\n  //   PCLZIP_OPT_BY_INDEX :\r\n  //   PCLZIP_OPT_BY_NAME :\r\n  //   PCLZIP_OPT_BY_EREG :\r\n  //   PCLZIP_OPT_BY_PREG :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the files which are still present in the archive.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function delete()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Parse the options\r\n      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                        array (PCLZIP_OPT_BY_NAME => 'optional',\r\n                                               PCLZIP_OPT_BY_EREG => 'optional',\r\n                                               PCLZIP_OPT_BY_PREG => 'optional',\r\n                                               PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n      if ($v_result != 1) {\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Call the delete fct\r\n    $v_list = array();\r\n    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {\r\n      $this->privSwapBackMagicQuotes();\r\n      unset($v_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : deleteByIndex()\r\n  // Description :\r\n  //   ***** Deprecated *****\r\n  //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.\r\n  // --------------------------------------------------------------------------------\r\n  function deleteByIndex($p_index)\r\n  {\r\n\r\n    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : properties()\r\n  // Description :\r\n  //   This method gives the properties of the archive.\r\n  //   The properties are :\r\n  //     nb : Number of files in the archive\r\n  //     comment : Comment associated with the archive file\r\n  //     status : not_exist, ok\r\n  // Parameters :\r\n  //   None\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   An array with the archive properties.\r\n  // --------------------------------------------------------------------------------\r\n  function properties()\r\n  {\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      $this->privSwapBackMagicQuotes();\r\n      return(0);\r\n    }\r\n\r\n    // ----- Default properties\r\n    $v_prop = array();\r\n    $v_prop['comment'] = '';\r\n    $v_prop['nb'] = 0;\r\n    $v_prop['status'] = 'not_exist';\r\n\r\n    // ----- Look if file exists\r\n    if (@is_file($this->zipname))\r\n    {\r\n      // ----- Open the zip file\r\n      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n        // ----- Return\r\n        return 0;\r\n      }\r\n\r\n      // ----- Read the central directory informations\r\n      $v_central_dir = array();\r\n      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return 0;\r\n      }\r\n\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Set the user attributes\r\n      $v_prop['comment'] = $v_central_dir['comment'];\r\n      $v_prop['nb'] = $v_central_dir['entries'];\r\n      $v_prop['status'] = 'ok';\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_prop;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : duplicate()\r\n  // Description :\r\n  //   This method creates an archive by copying the content of an other one. If\r\n  //   the archive already exist, it is replaced by the new one without any warning.\r\n  // Parameters :\r\n  //   $p_archive : The filename of a valid archive, or\r\n  //                a valid PclZip object.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 or a negative value on error (error code).\r\n  // --------------------------------------------------------------------------------\r\n  function duplicate($p_archive)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the $p_archive is a PclZip object\r\n    if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Duplicate the archive\r\n      $v_result = $this->privDuplicate($p_archive->zipname);\r\n    }\r\n\r\n    // ----- Look if the $p_archive is a string (so a filename)\r\n    else if (is_string($p_archive))\r\n    {\r\n\r\n      // ----- Check that $p_archive is a valid zip file\r\n      // TBC : Should also check the archive format\r\n      if (!is_file($p_archive)) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"No file with filename '\".$p_archive.\"'\");\r\n        $v_result = PCLZIP_ERR_MISSING_FILE;\r\n      }\r\n      else {\r\n        // ----- Duplicate the archive\r\n        $v_result = $this->privDuplicate($p_archive);\r\n      }\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : merge()\r\n  // Description :\r\n  //   This method merge the $p_archive_to_add archive at the end of the current\r\n  //   one ($this).\r\n  //   If the archive ($this) does not exist, the merge becomes a duplicate.\r\n  //   If the $p_archive_to_add archive does not exist, the merge is a success.\r\n  // Parameters :\r\n  //   $p_archive_to_add : It can be directly the filename of a valid zip archive,\r\n  //                       or a PclZip object archive.\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 or negative values on error (see below).\r\n  // --------------------------------------------------------------------------------\r\n  function merge($p_archive_to_add)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a PclZip object\r\n    if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($p_archive_to_add);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a string (so a filename)\r\n    else if (is_string($p_archive_to_add))\r\n    {\r\n\r\n      // ----- Create a temporary archive\r\n      $v_object_archive = new PclZip($p_archive_to_add);\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($v_object_archive);\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorCode()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorCode()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorCode());\r\n    }\r\n    else {\r\n      return($this->error_code);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorName()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorName($p_with_code=false)\r\n  {\r\n    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',\r\n                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',\r\n                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',\r\n                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',\r\n                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',\r\n                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',\r\n                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',\r\n                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',\r\n                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',\r\n                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',\r\n                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',\r\n                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',\r\n                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',\r\n                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',\r\n                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',\r\n                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',\r\n                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',\r\n                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',\r\n                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'\r\n                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'\r\n                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'\r\n                    );\r\n\r\n    if (isset($v_name[$this->error_code])) {\r\n      $v_value = $v_name[$this->error_code];\r\n    }\r\n    else {\r\n      $v_value = 'NoName';\r\n    }\r\n\r\n    if ($p_with_code) {\r\n      return($v_value.' ('.$this->error_code.')');\r\n    }\r\n    else {\r\n      return($v_value);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorInfo()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorInfo($p_full=false)\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorString());\r\n    }\r\n    else {\r\n      if ($p_full) {\r\n        return($this->errorName(true).\" : \".$this->error_string);\r\n      }\r\n      else {\r\n        return($this->error_string.\" [code \".$this->error_code.\"]\");\r\n      }\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****\r\n// *****                                                        *****\r\n// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****\r\n// --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFormat()\r\n  // Description :\r\n  //   This method check that the archive exists and is a valid zip archive.\r\n  //   Several level of check exists. (futur)\r\n  // Parameters :\r\n  //   $p_level : Level of check. Default 0.\r\n  //              0 : Check the first bytes (magic codes) (default value))\r\n  //              1 : 0 + Check the central directory (futur)\r\n  //              2 : 1 + Check each file header (futur)\r\n  // Return Values :\r\n  //   true on success,\r\n  //   false on error, the error code is set.\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFormat($p_level=0)\r\n  {\r\n    $v_result = true;\r\n\r\n    // ----- Reset the file system cache\r\n    clearstatcache();\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the file exits\r\n    if (!is_file($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"Missing archive file '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check that the file is readeable\r\n    if (!is_readable($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to read archive '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check the magic code\r\n    // TBC\r\n\r\n    // ----- Check the central header\r\n    // TBC\r\n\r\n    // ----- Check each file header\r\n    // TBC\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privParseOptions()\r\n  // Description :\r\n  //   This internal methods reads the variable list of arguments ($p_options_list,\r\n  //   $p_size) and generate an array with the options and values ($v_result_list).\r\n  //   $v_requested_options contains the options that can be present and those that\r\n  //   must be present.\r\n  //   $v_requested_options is an array, with the option value as key, and 'optional',\r\n  //   or 'mandatory' as value.\r\n  // Parameters :\r\n  //   See above.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the options\r\n    $i=0;\r\n    while ($i<$p_size) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$p_options_list[$i]])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid optional parameter '\".$p_options_list[$i].\"' for this method\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for next option\r\n      switch ($p_options_list[$i]) {\r\n        // ----- Look for options that request a path value\r\n        case PCLZIP_OPT_PATH :\r\n        case PCLZIP_OPT_REMOVE_PATH :\r\n        case PCLZIP_OPT_ADD_PATH :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check the value\r\n          $v_value = $p_options_list[$i+1];\r\n          if ((!is_integer($v_value)) || ($v_value<0)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Integer expected for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value (and convert it in bytes)\r\n          $v_result_list[$p_options_list[$i]] = $v_value*1048576;\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_ON :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_OFF :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'\");\r\n            return PclZip::errorCode();\r\n          }\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (   is_string($p_options_list[$i+1])\r\n              && ($p_options_list[$i+1] != '')) {\r\n            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n            $i++;\r\n          }\r\n          else {\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that request an array of string for value\r\n        case PCLZIP_OPT_BY_NAME :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an EREG or PREG expression\r\n        case PCLZIP_OPT_BY_EREG :\r\n          // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG\r\n          // to PCLZIP_OPT_BY_PREG\r\n          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;\r\n        case PCLZIP_OPT_BY_PREG :\r\n        //case PCLZIP_OPT_CRYPT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_OPT_COMMENT :\r\n        case PCLZIP_OPT_ADD_COMMENT :\r\n        case PCLZIP_OPT_PREPEND_COMMENT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE,\r\n                                 \"Missing parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE,\r\n                                 \"Wrong parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an array of index\r\n        case PCLZIP_OPT_BY_INDEX :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_work_list = array();\r\n          if (is_string($p_options_list[$i+1])) {\r\n\r\n              // ----- Remove spaces\r\n              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');\r\n\r\n              // ----- Parse items\r\n              $v_work_list = explode(\",\", $p_options_list[$i+1]);\r\n          }\r\n          else if (is_integer($p_options_list[$i+1])) {\r\n              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_work_list = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Value must be integer, string or array for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Reduce the index list\r\n          // each index item in the list must be a couple with a start and\r\n          // an end value : [0,3], [5-5], [8-10], ...\r\n          // ----- Check the format of each item\r\n          $v_sort_flag=false;\r\n          $v_sort_value=0;\r\n          for ($j=0; $j<sizeof($v_work_list); $j++) {\r\n              // ----- Explode the item\r\n              $v_item_list = explode(\"-\", $v_work_list[$j]);\r\n              $v_size_item_list = sizeof($v_item_list);\r\n\r\n              // ----- TBC : Here we might check that each item is a\r\n              // real integer ...\r\n\r\n              // ----- Look for single value\r\n              if ($v_size_item_list == 1) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];\r\n              }\r\n              elseif ($v_size_item_list == 2) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];\r\n              }\r\n              else {\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Too many values in index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n\r\n\r\n              // ----- Look for list sort\r\n              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {\r\n                  $v_sort_flag=true;\r\n\r\n                  // ----- TBC : An automatic sort should be writen ...\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Invalid order of index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];\r\n          }\r\n\r\n          // ----- Sort the items\r\n          if ($v_sort_flag) {\r\n              // TBC : To Be Completed\r\n          }\r\n\r\n          // ----- Next option\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request no value\r\n        case PCLZIP_OPT_REMOVE_ALL_PATH :\r\n        case PCLZIP_OPT_EXTRACT_AS_STRING :\r\n        case PCLZIP_OPT_NO_COMPRESSION :\r\n        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :\r\n        case PCLZIP_OPT_REPLACE_NEWER :\r\n        case PCLZIP_OPT_STOP_ON_ERROR :\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        // ----- Look for options that request an octal value\r\n        case PCLZIP_OPT_SET_CHMOD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request a call-back\r\n        case PCLZIP_CB_PRE_EXTRACT :\r\n        case PCLZIP_CB_POST_EXTRACT :\r\n        case PCLZIP_CB_PRE_ADD :\r\n        case PCLZIP_CB_POST_ADD :\r\n        /* for futur use\r\n        case PCLZIP_CB_PRE_DELETE :\r\n        case PCLZIP_CB_POST_DELETE :\r\n        case PCLZIP_CB_PRE_LIST :\r\n        case PCLZIP_CB_POST_LIST :\r\n        */\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_function_name = $p_options_list[$i+1];\r\n\r\n          // ----- Check that the value is a valid existing function\r\n          if (!function_exists($v_function_name)) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Function '\".$v_function_name.\"()' is not an existing function for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Set the attribute\r\n          $v_result_list[$p_options_list[$i]] = $v_function_name;\r\n          $i++;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Unknown parameter '\"\r\n                               .$p_options_list[$i].\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Next options\r\n      $i++;\r\n    }\r\n\r\n    // ----- Look for mandatory options\r\n    if ($v_requested_options !== false) {\r\n      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n        // ----- Look for mandatory option\r\n        if ($v_requested_options[$key] == 'mandatory') {\r\n          // ----- Look if present\r\n          if (!isset($v_result_list[$key])) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default values\r\n    if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOptionDefaultThreshold()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privOptionDefaultThreshold(&$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n        || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get 'memory_limit' configuration value\r\n    $v_memory_limit = ini_get('memory_limit');\r\n    $v_memory_limit = trim($v_memory_limit);\r\n    $last = strtolower(substr($v_memory_limit, -1));\r\n\r\n    if($last == 'g') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit)*1073741824;\r\n    }\r\n    if($last == 'm') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit) * 1048576;\r\n    }\r\n    if($last == 'k') {\r\n        $v_memory_limit = ((int) $v_memory_limit)*1024;\r\n    }\r\n\r\n    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);\r\n\r\n\r\n    // ----- Sanity check : No threshold if value lower than 1M\r\n    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {\r\n      unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrParseAtt()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- For each file in the list check the attributes\r\n    foreach ($p_file_list as $v_key => $v_value) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$v_key])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file attribute '\".$v_key.\"' for this file\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for attribute\r\n      switch ($v_key) {\r\n        case PCLZIP_ATT_FILE_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['filename'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_short_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty short filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_FULL_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_full_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty full filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_ATT_FILE_COMMENT :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['comment'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_MTIME :\r\n          if (!is_integer($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". Integer expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['mtime'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_CONTENT :\r\n          $p_filedescr['content'] = $v_value;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                                   \"Unknown parameter '\".$v_key.\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for mandatory options\r\n      if ($v_requested_options !== false) {\r\n        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n          // ----- Look for mandatory option\r\n          if ($v_requested_options[$key] == 'mandatory') {\r\n            // ----- Look if present\r\n            if (!isset($p_file_list[$key])) {\r\n              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n              return PclZip::errorCode();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    // end foreach\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrExpand()\r\n  // Description :\r\n  //   This method look for each item of the list to see if its a file, a folder\r\n  //   or a string to be added as file. For any other type of files (link, other)\r\n  //   just ignore the item.\r\n  //   Then prepare the information that will be stored for that file.\r\n  //   When its a folder, expand the folder with all the files that are in that\r\n  //   folder (recursively).\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrExpand(&$p_filedescr_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Create a result list\r\n    $v_result_list = array();\r\n\r\n    // ----- Look each entry\r\n    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {\r\n\r\n      // ----- Get filedescr\r\n      $v_descr = $p_filedescr_list[$i];\r\n\r\n      // ----- Reduce the filename\r\n      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);\r\n      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);\r\n\r\n      // ----- Look for real file or folder\r\n      if (file_exists($v_descr['filename'])) {\r\n        if (@is_file($v_descr['filename'])) {\r\n          $v_descr['type'] = 'file';\r\n        }\r\n        else if (@is_dir($v_descr['filename'])) {\r\n          $v_descr['type'] = 'folder';\r\n        }\r\n        else if (@is_link($v_descr['filename'])) {\r\n          // skip\r\n          continue;\r\n        }\r\n        else {\r\n          // skip\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // ----- Look for string added as file\r\n      else if (isset($v_descr['content'])) {\r\n        $v_descr['type'] = 'virtual_file';\r\n      }\r\n\r\n      // ----- Missing file\r\n      else {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$v_descr['filename'].\"' does not exist\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Calculate the stored filename\r\n      $this->privCalculateStoredFilename($v_descr, $p_options);\r\n\r\n      // ----- Add the descriptor in result list\r\n      $v_result_list[sizeof($v_result_list)] = $v_descr;\r\n\r\n      // ----- Look for folder\r\n      if ($v_descr['type'] == 'folder') {\r\n        // ----- List of items in folder\r\n        $v_dirlist_descr = array();\r\n        $v_dirlist_nb = 0;\r\n        if ($v_folder_handler = @opendir($v_descr['filename'])) {\r\n          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {\r\n\r\n            // ----- Skip '.' and '..'\r\n            if (($v_item_handler == '.') || ($v_item_handler == '..')) {\r\n                continue;\r\n            }\r\n\r\n            // ----- Compose the full filename\r\n            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;\r\n\r\n            // ----- Look for different stored filename\r\n            // Because the name of the folder was changed, the name of the\r\n            // files/sub-folders also change\r\n            if (($v_descr['stored_filename'] != $v_descr['filename'])\r\n                 && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {\r\n              if ($v_descr['stored_filename'] != '') {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;\r\n              }\r\n              else {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;\r\n              }\r\n            }\r\n\r\n            $v_dirlist_nb++;\r\n          }\r\n\r\n          @closedir($v_folder_handler);\r\n        }\r\n        else {\r\n          // TBC : unable to open folder in read mode\r\n        }\r\n\r\n        // ----- Expand each element of the list\r\n        if ($v_dirlist_nb != 0) {\r\n          // ----- Expand\r\n          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Concat the resulting list\r\n          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);\r\n        }\r\n        else {\r\n        }\r\n\r\n        // ----- Free local array\r\n        unset($v_dirlist_descr);\r\n      }\r\n    }\r\n\r\n    // ----- Get the result list\r\n    $p_filedescr_list = $v_result_list;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCreate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCreate($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the file in write mode\r\n    if (($v_result = $this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the list of files\r\n    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAdd()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAdd($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Look if the archive exists or is empty\r\n    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0))\r\n    {\r\n\r\n      // ----- Do a create\r\n      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      fclose($v_zip_temp_fd);\r\n      $this->privCloseFd();\r\n      @unlink($v_zip_temp_name);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          fclose($v_zip_temp_fd);\r\n          $this->privCloseFd();\r\n          @unlink($v_zip_temp_name);\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = $v_central_dir['comment'];\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {\r\n      $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOpenFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privOpenFd($p_mode)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if already open\r\n    if ($this->zip_fd != 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \\''.$this->zipname.'\\' already open');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in '.$p_mode.' mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCloseFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privCloseFd()\r\n  {\r\n    $v_result=1;\r\n\r\n    if ($this->zip_fd != 0)\r\n      @fclose($this->zip_fd);\r\n    $this->zip_fd = 0;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddList()\r\n  // Description :\r\n  //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is\r\n  //   different from the real path of the file. This is usefull if you want to have PclTar\r\n  //   running in any directory, and memorize relative path from an other directory.\r\n  // Parameters :\r\n  //   $p_list : An array containing the file or directory names to add in the tar\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  //   $p_add_dir : Path to add in the filename path archived\r\n  //   $p_remove_dir : Path to remove in the filename path archived\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)\r\n  function privAddList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = '';\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileList()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_filedescr_list : An array containing the file description\r\n  //                      or directory names to add in the zip\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_header = array();\r\n\r\n    // ----- Recuperate the current number of elt in list\r\n    $v_nb = sizeof($p_result_list);\r\n\r\n    // ----- Loop on the files\r\n    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {\r\n      // ----- Format the filename\r\n      $p_filedescr_list[$j]['filename']\r\n      = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);\r\n\r\n\r\n      // ----- Skip empty file names\r\n      // TBC : Can this be possible ? not checked in DescrParseAtt ?\r\n      if ($p_filedescr_list[$j]['filename'] == \"\") {\r\n        continue;\r\n      }\r\n\r\n      // ----- Check the filename\r\n      if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')\r\n          && (!file_exists($p_filedescr_list[$j]['filename']))) {\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$p_filedescr_list[$j]['filename'].\"' does not exist\");\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look if it is a file or a dir with no all path remove option\r\n      // or a dir with all its path removed\r\n//      if (   (is_file($p_filedescr_list[$j]['filename']))\r\n//          || (   is_dir($p_filedescr_list[$j]['filename'])\r\n      if (   ($p_filedescr_list[$j]['type'] == 'file')\r\n          || ($p_filedescr_list[$j]['type'] == 'virtual_file')\r\n          || (   ($p_filedescr_list[$j]['type'] == 'folder')\r\n              && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])\r\n                  || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))\r\n          ) {\r\n\r\n        // ----- Add the file\r\n        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header,\r\n                                       $p_options);\r\n        if ($v_result != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Store the file infos\r\n        $p_result_list[$v_nb++] = $v_header;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n    // TBC : Already done in the fileAtt check ... ?\r\n    if ($p_filename == \"\") {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file list parameter (invalid or empty list)\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Look for a stored different filename\r\n    /* TBC : Removed\r\n    if (isset($p_filedescr['stored_filename'])) {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    else {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    */\r\n\r\n    // ----- Set the file properties\r\n    clearstatcache();\r\n    $p_header['version'] = 20;\r\n    $p_header['version_extracted'] = 10;\r\n    $p_header['flag'] = 0;\r\n    $p_header['compression'] = 0;\r\n    $p_header['crc'] = 0;\r\n    $p_header['compressed_size'] = 0;\r\n    $p_header['filename_len'] = strlen($p_filename);\r\n    $p_header['extra_len'] = 0;\r\n    $p_header['disk'] = 0;\r\n    $p_header['internal'] = 0;\r\n    $p_header['offset'] = 0;\r\n    $p_header['filename'] = $p_filename;\r\n// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;\r\n    $p_header['stored_filename'] = $p_filedescr['stored_filename'];\r\n    $p_header['extra'] = '';\r\n    $p_header['status'] = 'ok';\r\n    $p_header['index'] = -1;\r\n\r\n    // ----- Look for regular file\r\n    if ($p_filedescr['type']=='file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for regular folder\r\n    else if ($p_filedescr['type']=='folder') {\r\n      $p_header['external'] = 0x00000010;\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for virtual file\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = strlen($p_filedescr['content']);\r\n    }\r\n\r\n\r\n    // ----- Look for filetime\r\n    if (isset($p_filedescr['mtime'])) {\r\n      $p_header['mtime'] = $p_filedescr['mtime'];\r\n    }\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['mtime'] = time();\r\n    }\r\n    else {\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n    }\r\n\r\n    // ------ Look for file comment\r\n    if (isset($p_filedescr['comment'])) {\r\n      $p_header['comment_len'] = strlen($p_filedescr['comment']);\r\n      $p_header['comment'] = $p_filedescr['comment'];\r\n    }\r\n    else {\r\n      $p_header['comment_len'] = 0;\r\n      $p_header['comment'] = '';\r\n    }\r\n\r\n    // ----- Look for pre-add callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_ADD].'(PCLZIP_CB_PRE_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_header['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {\r\n        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);\r\n      }\r\n    }\r\n\r\n    // ----- Look for empty stored filename\r\n    if ($p_header['stored_filename'] == \"\") {\r\n      $p_header['status'] = \"filtered\";\r\n    }\r\n\r\n    // ----- Check the path length\r\n    if (strlen($p_header['stored_filename']) > 0xFF) {\r\n      $p_header['status'] = 'filename_too_long';\r\n    }\r\n\r\n    // ----- Look if no error, or file not skipped\r\n    if ($p_header['status'] == 'ok') {\r\n\r\n      // ----- Look for a file\r\n      if ($p_filedescr['type'] == 'file') {\r\n        // ----- Look for using temporary file to zip\r\n        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {\r\n          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);\r\n          if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n            return $v_result;\r\n          }\r\n        }\r\n\r\n        // ----- Use \"in memory\" zip algo\r\n        else {\r\n\r\n        // ----- Open the source file\r\n        if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Read the file content\r\n        $v_content = @fread($v_file, $p_header['size']);\r\n\r\n        // ----- Close the file\r\n        @fclose($v_file);\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n\r\n        }\r\n\r\n      }\r\n\r\n      // ----- Look for a virtual file (a file from string)\r\n      else if ($p_filedescr['type'] == 'virtual_file') {\r\n\r\n        $v_content = $p_filedescr['content'];\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n      }\r\n\r\n      // ----- Look for a directory\r\n      else if ($p_filedescr['type'] == 'folder') {\r\n        // ----- Look for directory last '/'\r\n        if (@substr($p_header['stored_filename'], -1) != '/') {\r\n          $p_header['stored_filename'] .= '/';\r\n        }\r\n\r\n        // ----- Set the file properties\r\n        $p_header['size'] = 0;\r\n        //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked\r\n        $p_header['external'] = 0x00000010;   // Value for a folder : to be checked\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for post-add callback\r\n    if (isset($p_options[PCLZIP_CB_POST_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_ADD].'(PCLZIP_CB_POST_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Ignored\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Nothing can be modified\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=PCLZIP_ERR_NO_ERROR;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n\r\n    // ----- Open the source file\r\n    if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Creates a compressed temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_file_compressed = @gzopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = filesize($p_filename);\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @gzputs($v_file_compressed, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file);\r\n    @gzclose($v_file_compressed);\r\n\r\n    // ----- Check the minimum file size\r\n    if (filesize($v_gzip_temp_name) < 18) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \\''.$v_gzip_temp_name.'\\' has invalid filesize - should be minimum 18 bytes');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the compressed attributes\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the gzip file header\r\n    $v_binary_data = @fread($v_file_compressed, 10);\r\n    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);\r\n\r\n    // ----- Check some parameters\r\n    $v_data_header['os'] = bin2hex($v_data_header['os']);\r\n\r\n    // ----- Read the gzip file footer\r\n    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);\r\n    $v_binary_data = @fread($v_file_compressed, 8);\r\n    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);\r\n\r\n    // ----- Set the attributes\r\n    $p_header['compression'] = ord($v_data_header['cm']);\r\n    //$p_header['mtime'] = $v_data_header['mtime'];\r\n    $p_header['crc'] = $v_data_footer['crc'];\r\n    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Call the header generation\r\n    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the compressed data\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0)\r\n    {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    fseek($v_file_compressed, 10);\r\n    $v_size = $p_header['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file_compressed, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Unlink the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCalculateStoredFilename()\r\n  // Description :\r\n  //   Based on file descriptor properties and global options, this method\r\n  //   calculate the filename that will be stored in the archive.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCalculateStoredFilename(&$p_filedescr, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variables\r\n    $p_filename = $p_filedescr['filename'];\r\n    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {\r\n      $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];\r\n    }\r\n    else {\r\n      $p_add_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n      $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];\r\n    }\r\n    else {\r\n      $p_remove_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n      $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n    }\r\n    else {\r\n      $p_remove_all_dir = 0;\r\n    }\r\n\r\n\r\n    // ----- Look for full name change\r\n    if (isset($p_filedescr['new_full_name'])) {\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);\r\n    }\r\n\r\n    // ----- Look for path and/or short name change\r\n    else {\r\n\r\n      // ----- Look for short name change\r\n      // Its when we cahnge just the filename but not the path\r\n      if (isset($p_filedescr['new_short_name'])) {\r\n        $v_path_info = pathinfo($p_filename);\r\n        $v_dir = '';\r\n        if ($v_path_info['dirname'] != '') {\r\n          $v_dir = $v_path_info['dirname'].'/';\r\n        }\r\n        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];\r\n      }\r\n      else {\r\n        // ----- Calculate the stored filename\r\n        $v_stored_filename = $p_filename;\r\n      }\r\n\r\n      // ----- Look for all path to remove\r\n      if ($p_remove_all_dir) {\r\n        $v_stored_filename = basename($p_filename);\r\n      }\r\n      // ----- Look for partial path remove\r\n      else if ($p_remove_dir != \"\") {\r\n        if (substr($p_remove_dir, -1) != '/')\r\n          $p_remove_dir .= \"/\";\r\n\r\n        if (   (substr($p_filename, 0, 2) == \"./\")\r\n            || (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n\r\n          if (   (substr($p_filename, 0, 2) == \"./\")\r\n              && (substr($p_remove_dir, 0, 2) != \"./\")) {\r\n            $p_remove_dir = \"./\".$p_remove_dir;\r\n          }\r\n          if (   (substr($p_filename, 0, 2) != \"./\")\r\n              && (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n            $p_remove_dir = substr($p_remove_dir, 2);\r\n          }\r\n        }\r\n\r\n        $v_compare = PclZipUtilPathInclusion($p_remove_dir,\r\n                                             $v_stored_filename);\r\n        if ($v_compare > 0) {\r\n          if ($v_compare == 2) {\r\n            $v_stored_filename = \"\";\r\n          }\r\n          else {\r\n            $v_stored_filename = substr($v_stored_filename,\r\n                                        strlen($p_remove_dir));\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);\r\n\r\n      // ----- Look for path to add\r\n      if ($p_add_dir != \"\") {\r\n        if (substr($p_add_dir, -1) == \"/\")\r\n          $v_stored_filename = $p_add_dir.$v_stored_filename;\r\n        else\r\n          $v_stored_filename = $p_add_dir.\"/\".$v_stored_filename;\r\n      }\r\n    }\r\n\r\n    // ----- Filename (reduce the path of stored name)\r\n    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);\r\n    $p_filedescr['stored_filename'] = $v_stored_filename;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Store the offset position of the file\r\n    $p_header['offset'] = ftell($this->zip_fd);\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvVVVvv\", 0x04034b50,\r\n                          $p_header['version_extracted'], $p_header['flag'],\r\n                          $p_header['compression'], $v_mtime, $v_mdate,\r\n                          $p_header['crc'], $p_header['compressed_size'],\r\n                          $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len']);\r\n\r\n    // ----- Write the first 148 bytes of the header in the archive\r\n    fputs($this->zip_fd, $v_binary_data, 30);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // TBC\r\n    //for(reset($p_header); $key = key($p_header); next($p_header)) {\r\n    //}\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvvVVVvvvvvVV\", 0x02014b50,\r\n                          $p_header['version'], $p_header['version_extracted'],\r\n                          $p_header['flag'], $p_header['compression'],\r\n                          $v_mtime, $v_mdate, $p_header['crc'],\r\n                          $p_header['compressed_size'], $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len'], $p_header['comment_len'],\r\n                          $p_header['disk'], $p_header['internal'],\r\n                          $p_header['external'], $p_header['offset']);\r\n\r\n    // ----- Write the 42 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 46);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n    if ($p_header['comment_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvVVv\", 0x06054b50, 0, 0, $p_nb_entries,\r\n                          $p_nb_entries, $p_size,\r\n                          $p_offset, strlen($p_comment));\r\n\r\n    // ----- Write the 22 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 22);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_comment) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_comment, strlen($p_comment));\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privList()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privList(&$p_list)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of Central Dir\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_central_dir['offset']))\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    for ($i=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n      // ----- Read the file header\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return $v_result;\r\n      }\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Get the only interesting attributes\r\n      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);\r\n      unset($v_header);\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privConvertHeader2FileInfo()\r\n  // Description :\r\n  //   This function takes the file informations from the central directory\r\n  //   entries and extract the interesting parameters that will be given back.\r\n  //   The resulting file infos are set in the array $p_info\r\n  //     $p_info['filename'] : Filename with full path. Given by user (add),\r\n  //                           extracted in the filesystem (extract).\r\n  //     $p_info['stored_filename'] : Stored filename in the archive.\r\n  //     $p_info['size'] = Size of the file.\r\n  //     $p_info['compressed_size'] = Compressed size of the file.\r\n  //     $p_info['mtime'] = Last modification date of the file.\r\n  //     $p_info['comment'] = Comment associated with the file.\r\n  //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.\r\n  //     $p_info['status'] = status of the action on the file.\r\n  //     $p_info['crc'] = CRC of the file content.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privConvertHeader2FileInfo($p_header, &$p_info)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Get the interesting attributes\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);\r\n    $p_info['filename'] = $v_temp_path;\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);\r\n    $p_info['stored_filename'] = $v_temp_path;\r\n    $p_info['size'] = $p_header['size'];\r\n    $p_info['compressed_size'] = $p_header['compressed_size'];\r\n    $p_info['mtime'] = $p_header['mtime'];\r\n    $p_info['comment'] = $p_header['comment'];\r\n    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);\r\n    $p_info['index'] = $p_header['index'];\r\n    $p_info['status'] = $p_header['status'];\r\n    $p_info['crc'] = $p_header['crc'];\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractByRule()\r\n  // Description :\r\n  //   Extract a file or directory depending of rules (by index, by name, ...)\r\n  // Parameters :\r\n  //   $p_file_list : An array where will be placed the properties of each\r\n  //                  extracted file\r\n  //   $p_path : Path to add while writing the extracted files\r\n  //   $p_remove_path : Path to remove (from the file memorized path) while writing the\r\n  //                    extracted files. If the path does not match the file path,\r\n  //                    the file is extracted with its memorized path.\r\n  //                    $p_remove_path does not apply to 'list' mode.\r\n  //                    $p_path and $p_remove_path are commulative.\r\n  // Return Values :\r\n  //   1 on success,0 or less on error (see error code list)\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check the path\r\n    if (   ($p_path == \"\")\r\n        || (   (substr($p_path, 0, 1) != \"/\")\r\n            && (substr($p_path, 0, 3) != \"../\")\r\n            && (substr($p_path,1,2)!=\":/\")))\r\n      $p_path = \"./\".$p_path;\r\n\r\n    // ----- Reduce the path last (and duplicated) '/'\r\n    if (($p_path != \"./\") && ($p_path != \"/\"))\r\n    {\r\n      // ----- Look for the path end '/'\r\n      while (substr($p_path, -1) == \"/\")\r\n      {\r\n        $p_path = substr($p_path, 0, strlen($p_path)-1);\r\n      }\r\n    }\r\n\r\n    // ----- Look for path to remove format (should end by /)\r\n    if (($p_remove_path != \"\") && (substr($p_remove_path, -1) != '/'))\r\n    {\r\n      $p_remove_path .= '/';\r\n    }\r\n    $p_remove_path_size = strlen($p_remove_path);\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result = $this->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n\r\n    // ----- Read each entry\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read next Central dir entry\r\n      @rewind($this->zip_fd);\r\n      if (@fseek($this->zip_fd, $v_pos_entry))\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read the file header\r\n      $v_header = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n      // ----- Store the index\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Store the file position\r\n      $v_pos_entry = ftell($this->zip_fd);\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_extract = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_extract = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_extract = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_extract = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for no rule, which means extract all the archive\r\n      else {\r\n          $v_extract = true;\r\n      }\r\n\r\n      // ----- Check compression method\r\n      if (   ($v_extract)\r\n          && (   ($v_header['compression'] != 8)\r\n              && ($v_header['compression'] != 0))) {\r\n          $v_header['status'] = 'unsupported_compression';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION,\r\n                                   \"Filename '\".$v_header['stored_filename'].\"' is \"\r\n                                       .\"compressed by an unsupported compression \"\r\n                                       .\"method (\".$v_header['compression'].\") \");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n      }\r\n\r\n      // ----- Check encrypted files\r\n      if (($v_extract) && (($v_header['flag'] & 1) == 1)) {\r\n          $v_header['status'] = 'unsupported_encryption';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION,\r\n                                   \"Unsupported encryption for \"\r\n                                       .\" filename '\".$v_header['stored_filename']\r\n                                   .\"'\");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n    }\r\n\r\n      // ----- Look for real extraction\r\n      if (($v_extract) && ($v_header['status'] != 'ok')) {\r\n          $v_result = $this->privConvertHeader2FileInfo($v_header,\r\n                                                $p_file_list[$v_nb_extracted++]);\r\n          if ($v_result != 1) {\r\n              $this->privCloseFd();\r\n              $this->privSwapBackMagicQuotes();\r\n              return $v_result;\r\n          }\r\n\r\n          $v_extract = false;\r\n      }\r\n\r\n      // ----- Look for real extraction\r\n      if ($v_extract)\r\n      {\r\n\r\n        // ----- Go to the file position\r\n        @rewind($this->zip_fd);\r\n        if (@fseek($this->zip_fd, $v_header['offset']))\r\n        {\r\n          // ----- Close the zip file\r\n          $this->privCloseFd();\r\n\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Look for extraction as string\r\n        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {\r\n\r\n          $v_string = '';\r\n\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Set the file content\r\n          $p_file_list[$v_nb_extracted]['content'] = $v_string;\r\n\r\n          // ----- Next extracted file\r\n          $v_nb_extracted++;\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for extraction in standard output\r\n        elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))\r\n                && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {\r\n          // ----- Extracting the file in standard output\r\n          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for normal extraction\r\n        else {\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFile($v_header,\r\n                                              $p_path, $p_remove_path,\r\n                                              $p_remove_all_path,\r\n                                              $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //\r\n  // 1 : ... ?\r\n  // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for all path to remove\r\n    if ($p_remove_all_path == true) {\r\n        // ----- Look for folder entry that not need to be extracted\r\n        if (($p_entry['external']&0x00000010)==0x00000010) {\r\n\r\n            $p_entry['status'] = \"filtered\";\r\n\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Get the basename of the path\r\n        $p_entry['filename'] = basename($p_entry['filename']);\r\n    }\r\n\r\n    // ----- Look for path to remove\r\n    else if ($p_remove_path != \"\")\r\n    {\r\n      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"filtered\";\r\n\r\n        // ----- Return\r\n        return $v_result;\r\n      }\r\n\r\n      $p_remove_path_size = strlen($p_remove_path);\r\n      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)\r\n      {\r\n\r\n        // ----- Remove the path\r\n        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);\r\n\r\n      }\r\n    }\r\n\r\n    // Added by LS Team to check for invalid paths\r\n    $p_entry['filename'] = get_absolute_path($p_entry['filename']);    \r\n\r\n    // ----- Add the path\r\n    if ($p_path != '') {\r\n      $p_entry['filename'] = $p_path.\"/\".$p_entry['filename'];\r\n    }\r\n\r\n    // ----- Check a base_dir_restriction\r\n    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {\r\n      $v_inclusion\r\n      = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION],\r\n                                $p_entry['filename']);\r\n      if ($v_inclusion == 0) {\r\n\r\n        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION\");\r\n\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n    // ----- Look for specific actions while the file exist\r\n    if (file_exists($p_entry['filename']))\r\n    {\r\n\r\n      // ----- Look if file is a directory\r\n      if (is_dir($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"already_a_directory\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"already used by an existing directory\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n      // ----- Look if file is write protected\r\n      else if (!is_writeable($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"write_protected\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                                 \"Filename '\".$p_entry['filename'].\"' exists \"\r\n                                 .\"and is write protected\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n\r\n      // ----- Look if the extracted file is older\r\n      else if (filemtime($p_entry['filename']) > $p_entry['mtime'])\r\n      {\r\n        // ----- Change the file status\r\n        if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))\r\n            && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {\r\n            }\r\n            else {\r\n            $p_entry['status'] = \"newer_exist\";\r\n\r\n            // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n            // For historical reason first PclZip implementation does not stop\r\n            // when this kind of error occurs.\r\n            if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n                && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                         \"Newer version of '\".$p_entry['filename'].\"' exists \"\r\n                        .\"and option PCLZIP_OPT_REPLACE_NEWER is not selected\");\r\n\r\n                return PclZip::errorCode();\r\n              }\r\n            }\r\n      }\r\n      else {\r\n      }\r\n    }\r\n\r\n    // ----- Check the directory availability and create it if necessary\r\n    else {\r\n      if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))\r\n        $v_dir_to_check = $p_entry['filename'];\r\n      else if (!strstr($p_entry['filename'], \"/\"))\r\n        $v_dir_to_check = \"\";\r\n      else\r\n        $v_dir_to_check = dirname($p_entry['filename']);\r\n\r\n        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {\r\n\r\n          // ----- Change the file status\r\n          $p_entry['status'] = \"path_creation_fail\";\r\n\r\n          // ----- Return\r\n          //return $v_result;\r\n          $v_result = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010))\r\n      {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n              // ----- Opening destination file\r\n          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)\r\n          {\r\n\r\n            // ----- Change the file status\r\n            $p_entry['status'] = \"write_error\";\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n          }\r\n\r\n\r\n          // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n          $v_size = $p_entry['compressed_size'];\r\n          while ($v_size != 0)\r\n          {\r\n            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n            $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n            /* Try to speed up the code\r\n            $v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n            @fwrite($v_dest_file, $v_binary_data, $v_read_size);\r\n            */\r\n            @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n            $v_size -= $v_read_size;\r\n          }\r\n\r\n          // ----- Closing the destination file\r\n          fclose($v_dest_file);\r\n\r\n          // ----- Change the file mtime\r\n          touch($p_entry['filename'], $p_entry['mtime']);\r\n\r\n\r\n        }\r\n        else {\r\n          // ----- TBC\r\n          // Need to be finished\r\n          if (($p_entry['flag'] & 1) == 1) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \\''.$p_entry['filename'].'\\' is encrypted. Encrypted files are not supported.');\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n\r\n          // ----- Look for using temporary file to unzip\r\n          if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n              && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                  || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                      && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {\r\n            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);\r\n            if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n              return $v_result;\r\n            }\r\n          }\r\n\r\n          // ----- Look for extract in memory\r\n          else {\r\n\r\n\r\n            // ----- Read the compressed file in a buffer (one shot)\r\n            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n            // ----- Decompress the file\r\n            $v_file_content = @gzinflate($v_buffer);\r\n            unset($v_buffer);\r\n            if ($v_file_content === FALSE) {\r\n\r\n              // ----- Change the file status\r\n              // TBC\r\n              $p_entry['status'] = \"error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Opening destination file\r\n            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n\r\n              // ----- Change the file status\r\n              $p_entry['status'] = \"write_error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Write the uncompressed data\r\n            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);\r\n            unset($v_file_content);\r\n\r\n            // ----- Closing the destination file\r\n            @fclose($v_dest_file);\r\n\r\n          }\r\n\r\n          // ----- Change the file mtime\r\n          @touch($p_entry['filename'], $p_entry['mtime']);\r\n        }\r\n\r\n        // ----- Look for chmod option\r\n        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {\r\n\r\n          // ----- Change the mode of the file\r\n          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileUsingTempFile(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Creates a temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_dest_file = @fopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Write gz file format header\r\n    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));\r\n    @fwrite($v_dest_file, $v_binary_data, 10);\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Write gz file format footer\r\n    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);\r\n    @fwrite($v_dest_file, $v_binary_data, 8);\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_dest_file);\r\n\r\n    // ----- Opening destination file\r\n    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n      $p_entry['status'] = \"write_error\";\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary gz file\r\n    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {\r\n      @fclose($v_dest_file);\r\n      $p_entry['status'] = \"read_error\";\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['size'];\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @gzread($v_src_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n    @fclose($v_dest_file);\r\n    @gzclose($v_src_file);\r\n\r\n    // ----- Delete the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileInOutput()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileInOutput(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compressed_size'] == $p_entry['size']) {\r\n\r\n          // ----- Read the file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_buffer;\r\n          unset($v_buffer);\r\n        }\r\n        else {\r\n\r\n          // ----- Read the compressed file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          $v_file_content = gzinflate($v_buffer);\r\n          unset($v_buffer);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_file_content;\r\n          unset($v_file_content);\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Change abort status\r\n    if ($p_entry['status'] == \"aborted\") {\r\n      $p_entry['status'] = \"skipped\";\r\n    }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileAsString()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    $v_header = array();\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n  //      if ($p_entry['compressed_size'] == $p_entry['size'])\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n          // ----- Reading the file\r\n          $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n        }\r\n        else {\r\n\r\n          // ----- Reading the file\r\n          $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          if (($p_string = @gzinflate($v_data)) === FALSE) {\r\n              // TBC\r\n          }\r\n        }\r\n\r\n        // ----- Trace\r\n      }\r\n      else {\r\n          // TBC : error : can not extract a folder in a string\r\n      }\r\n\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Swap the content to header\r\n      $v_local_header['content'] = $p_string;\r\n      $p_string = '';\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Swap back the content to header\r\n      $p_string = $v_local_header['content'];\r\n      unset($v_local_header['content']);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x04034b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 26);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 26)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);\r\n\r\n    // ----- Get extra_fields\r\n    if ($v_data['extra_len'] != 0) {\r\n      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);\r\n    }\r\n    else {\r\n      $p_header['extra'] = '';\r\n    }\r\n\r\n    // ----- Extract properties\r\n    $p_header['version_extracted'] = $v_data['version'];\r\n    $p_header['compression'] = $v_data['compression'];\r\n    $p_header['size'] = $v_data['size'];\r\n    $p_header['compressed_size'] = $v_data['compressed_size'];\r\n    $p_header['crc'] = $v_data['crc'];\r\n    $p_header['flag'] = $v_data['flag'];\r\n    $p_header['filename_len'] = $v_data['filename_len'];\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    $p_header['mdate'] = $v_data['mdate'];\r\n    $p_header['mtime'] = $v_data['mtime'];\r\n    if ($p_header['mdate'] && $p_header['mtime'])\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // TBC\r\n    //for(reset($v_data); $key = key($v_data); next($v_data)) {\r\n    //}\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set the status field\r\n    $p_header['status'] = \"ok\";\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x02014b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 42);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 42)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    if ($p_header['filename_len'] != 0)\r\n      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);\r\n    else\r\n      $p_header['filename'] = '';\r\n\r\n    // ----- Get extra\r\n    if ($p_header['extra_len'] != 0)\r\n      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);\r\n    else\r\n      $p_header['extra'] = '';\r\n\r\n    // ----- Get comment\r\n    if ($p_header['comment_len'] != 0)\r\n      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);\r\n    else\r\n      $p_header['comment'] = '';\r\n\r\n    // ----- Extract properties\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    //if ($p_header['mdate'] && $p_header['mtime'])\r\n    // TBC : bug : this was ignoring time with 0/0/0\r\n    if (1)\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set default status to ok\r\n    $p_header['status'] = 'ok';\r\n\r\n    // ----- Look if it is a directory\r\n    if (substr($p_header['filename'], -1) == '/') {\r\n      //$p_header['external'] = 0x41FF0010;\r\n      $p_header['external'] = 0x00000010;\r\n    }\r\n\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFileHeaders()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 on error;\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFileHeaders(&$p_local_header, &$p_central_header)\r\n  {\r\n    $v_result=1;\r\n\r\n      // ----- Check the static values\r\n      // TBC\r\n      if ($p_local_header['filename'] != $p_central_header['filename']) {\r\n      }\r\n      if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {\r\n      }\r\n      if ($p_local_header['flag'] != $p_central_header['flag']) {\r\n      }\r\n      if ($p_local_header['compression'] != $p_central_header['compression']) {\r\n      }\r\n      if ($p_local_header['mtime'] != $p_central_header['mtime']) {\r\n      }\r\n      if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {\r\n      }\r\n\r\n      // ----- Look for flag bit 3\r\n      if (($p_local_header['flag'] & 8) == 8) {\r\n          $p_local_header['size'] = $p_central_header['size'];\r\n          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];\r\n          $p_local_header['crc'] = $p_central_header['crc'];\r\n      }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadEndCentralDir()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadEndCentralDir(&$p_central_dir)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Go to the end of the zip file\r\n    $v_size = filesize($this->zipname);\r\n    @fseek($this->zip_fd, $v_size);\r\n    if (@ftell($this->zip_fd) != $v_size)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \\''.$this->zipname.'\\'');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- First try : look if this is an archive with no commentaries (most of the time)\r\n    // in this case the end of central dir is at 22 bytes of the file end\r\n    $v_found = 0;\r\n    if ($v_size > 26) {\r\n      @fseek($this->zip_fd, $v_size-22);\r\n      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read for bytes\r\n      $v_binary_data = @fread($this->zip_fd, 4);\r\n      $v_data = @unpack('Vid', $v_binary_data);\r\n\r\n      // ----- Check signature\r\n      if ($v_data['id'] == 0x06054b50) {\r\n        $v_found = 1;\r\n      }\r\n\r\n      $v_pos = ftell($this->zip_fd);\r\n    }\r\n\r\n    // ----- Go back to the maximum possible size of the Central Dir End Record\r\n    if (!$v_found) {\r\n      $v_maximum_size = 65557; // 0xFFFF + 22;\r\n      if ($v_maximum_size > $v_size)\r\n        $v_maximum_size = $v_size;\r\n      @fseek($this->zip_fd, $v_size-$v_maximum_size);\r\n      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read byte per byte in order to find the signature\r\n      $v_pos = ftell($this->zip_fd);\r\n      $v_bytes = 0x00000000;\r\n      while ($v_pos < $v_size)\r\n      {\r\n        // ----- Read a byte\r\n        $v_byte = @fread($this->zip_fd, 1);\r\n\r\n        // -----  Add the byte\r\n        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);\r\n        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number\r\n        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.\r\n        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);\r\n\r\n        // ----- Compare the bytes\r\n        if ($v_bytes == 0x504b0506)\r\n        {\r\n          $v_pos++;\r\n          break;\r\n        }\r\n\r\n        $v_pos++;\r\n      }\r\n\r\n      // ----- Look if not found end of central dir\r\n      if ($v_pos == $v_size)\r\n      {\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Unable to find End of Central Dir Record signature\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Read the first 18 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 18);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 18)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid End of Central Dir Record size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);\r\n\r\n    // ----- Check the global size\r\n    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {\r\n\r\n      // ----- Removed in release 2.2 see readme file\r\n      // The check of the file size is a little too strict.\r\n      // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.\r\n      // While decrypted, zip has training 0 bytes\r\n      if (0) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,\r\n                           'The central dir is not at the end of the archive.'\r\n                           .' Some trailing bytes exists after the archive.');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Get comment\r\n    if ($v_data['comment_size'] != 0) {\r\n      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);\r\n    }\r\n    else\r\n      $p_central_dir['comment'] = '';\r\n\r\n    $p_central_dir['entries'] = $v_data['entries'];\r\n    $p_central_dir['disk_entries'] = $v_data['disk_entries'];\r\n    $p_central_dir['offset'] = $v_data['offset'];\r\n    $p_central_dir['size'] = $v_data['size'];\r\n    $p_central_dir['disk'] = $v_data['disk'];\r\n    $p_central_dir['disk_start'] = $v_data['disk_start'];\r\n\r\n    // TBC\r\n    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {\r\n    //}\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDeleteByRule()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDeleteByRule(&$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Scan all the files\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_pos_entry))\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    $v_header_list = array();\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read the file header\r\n      $v_header_list[$v_nb_extracted] = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n\r\n      // ----- Store the index\r\n      $v_header_list[$v_nb_extracted]['index'] = $i;\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_found = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n                  elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /* Indicates a folder */\r\n                          && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_found = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_found = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          $v_found = true;\r\n      }\r\n\r\n      // ----- Look for deletion\r\n      if ($v_found)\r\n      {\r\n        unset($v_header_list[$v_nb_extracted]);\r\n      }\r\n      else\r\n      {\r\n        $v_nb_extracted++;\r\n      }\r\n    }\r\n\r\n    // ----- Look if something need to be deleted\r\n    if ($v_nb_extracted > 0) {\r\n\r\n        // ----- Creates a temporay file\r\n        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n        // ----- Creates a temporary zip archive\r\n        $v_temp_zip = new PclZip($v_zip_temp_name);\r\n\r\n        // ----- Open the temporary zip file in write mode\r\n        if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {\r\n            $this->privCloseFd();\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Look which file need to be kept\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n\r\n            // ----- Calculate the position of the header\r\n            @rewind($this->zip_fd);\r\n            if (@fseek($this->zip_fd,  $v_header_list[$i]['offset'])) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Error log\r\n                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n                // ----- Return\r\n                return PclZip::errorCode();\r\n            }\r\n\r\n            // ----- Read the file header\r\n            $v_local_header = array();\r\n            if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Check that local file header is same as central file header\r\n            if ($this->privCheckFileHeaders($v_local_header,\r\n                                            $v_header_list[$i]) != 1) {\r\n                // TBC\r\n            }\r\n            unset($v_local_header);\r\n\r\n            // ----- Write the file header\r\n            if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Read/write the data block\r\n            if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n        }\r\n\r\n        // ----- Store the offset of the central dir\r\n        $v_offset = @ftell($v_temp_zip->zip_fd);\r\n\r\n        // ----- Re-Create the Central Dir files header\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n            // ----- Create the file header\r\n            if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n                $v_temp_zip->privCloseFd();\r\n                $this->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Transform the header to a 'usable' info\r\n            $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n        }\r\n\r\n\r\n        // ----- Zip file comment\r\n        $v_comment = '';\r\n        if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n          $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n        }\r\n\r\n        // ----- Calculate the size of the central header\r\n        $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset;\r\n\r\n        // ----- Create the central dir footer\r\n        if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {\r\n            // ----- Reset the file list\r\n            unset($v_header_list);\r\n            $v_temp_zip->privCloseFd();\r\n            $this->privCloseFd();\r\n            @unlink($v_zip_temp_name);\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Close\r\n        $v_temp_zip->privCloseFd();\r\n        $this->privCloseFd();\r\n\r\n        // ----- Delete the zip file\r\n        // TBC : I should test the result ...\r\n        @unlink($this->zipname);\r\n\r\n        // ----- Rename the temporary file\r\n        // TBC : I should test the result ...\r\n        //@rename($v_zip_temp_name, $this->zipname);\r\n        PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n        // ----- Destroy the temporary archive\r\n        unset($v_temp_zip);\r\n    }\r\n\r\n    // ----- Remove every files : reset the file\r\n    else if ($v_central_dir['entries'] != 0) {\r\n        $this->privCloseFd();\r\n\r\n        if (($v_result = $this->privOpenFd('wb')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        $this->privCloseFd();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDirCheck()\r\n  // Description :\r\n  //   Check if a directory exists, if not it creates it and all the parents directory\r\n  //   which may be useful.\r\n  // Parameters :\r\n  //   $p_dir : Directory path to check.\r\n  // Return Values :\r\n  //    1 : OK\r\n  //   -1 : Unable to create directory\r\n  // --------------------------------------------------------------------------------\r\n  function privDirCheck($p_dir, $p_is_dir=false)\r\n  {\r\n    $v_result = 1;\r\n\r\n\r\n    // ----- Remove the final '/'\r\n    if (($p_is_dir) && (substr($p_dir, -1)=='/'))\r\n    {\r\n      $p_dir = substr($p_dir, 0, strlen($p_dir)-1);\r\n    }\r\n\r\n    // ----- Check the directory availability\r\n    if ((is_dir($p_dir)) || ($p_dir == \"\"))\r\n    {\r\n      return 1;\r\n    }\r\n\r\n    // ----- Extract parent directory\r\n    $p_parent_dir = dirname($p_dir);\r\n\r\n    // ----- Just a check\r\n    if ($p_parent_dir != $p_dir)\r\n    {\r\n      // ----- Look for parent directory\r\n      if ($p_parent_dir != \"\")\r\n      {\r\n        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Create the directory\r\n    if (!@mkdir($p_dir, 0777))\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, \"Unable to create directory '$p_dir'\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privMerge()\r\n  // Description :\r\n  //   If $p_archive_to_add does not exist, the function exit with a success result.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privMerge(&$p_archive_to_add)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the archive_to_add exists\r\n    if (!is_file($p_archive_to_add->zipname))\r\n    {\r\n\r\n      // ----- Nothing to merge, so merge is a success\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if the archive exists\r\n    if (!is_file($this->zipname))\r\n    {\r\n\r\n      // ----- Do a duplicate\r\n      $v_result = $this->privDuplicate($p_archive_to_add->zipname);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Open the archive_to_add file\r\n    if (($v_result=$p_archive_to_add->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir_to_add = array();\r\n    if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($p_archive_to_add->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the files from the archive_to_add into the temporary file\r\n    $v_size = $v_central_dir_to_add['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($v_zip_temp_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the block of file headers from the archive_to_add\r\n    $v_size = $v_central_dir_to_add['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Merge the file comments\r\n    $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];\r\n\r\n    // ----- Calculate the size of the (new) central header\r\n    $v_size = @ftell($v_zip_temp_fd)-$v_offset;\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive fd\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n      @fclose($v_zip_temp_fd);\r\n      $this->zip_fd = null;\r\n\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n    $p_archive_to_add->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDuplicate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDuplicate($p_archive_filename)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the $p_archive_filename exists\r\n    if (!is_file($p_archive_filename))\r\n    {\r\n\r\n      // ----- Nothing to duplicate, so duplicate is a success.\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \\''.$p_archive_filename.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = filesize($p_archive_filename);\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorLog()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorLog($p_error_code=0, $p_error_string='')\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclError($p_error_code, $p_error_string);\r\n    }\r\n    else {\r\n      $this->error_code = $p_error_code;\r\n      $this->error_string = $p_error_string;\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorReset()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorReset()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclErrorReset();\r\n    }\r\n    else {\r\n      $this->error_code = 0;\r\n      $this->error_string = '';\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDisableMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDisableMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if already done\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get and memorize the magic_quote value\r\n    $this->magic_quotes_status = @get_magic_quotes_runtime();\r\n\r\n    // ----- Disable magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n      @set_magic_quotes_runtime(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privSwapBackMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privSwapBackMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if something to do\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n        @set_magic_quotes_runtime($this->magic_quotes_status);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  }\r\n  // End of class\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathReduction()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathReduction($p_dir)\r\n  {\r\n    $v_result = \"\";\r\n\r\n    // ----- Look for not empty path\r\n    if ($p_dir != \"\") {\r\n      // ----- Explode path by directory names\r\n      $v_list = explode(\"/\", $p_dir);\r\n\r\n      // ----- Study directories from last to first\r\n      $v_skip = 0;\r\n      for ($i=sizeof($v_list)-1; $i>=0; $i--) {\r\n        // ----- Look for current path\r\n        if ($v_list[$i] == \".\") {\r\n          // ----- Ignore this directory\r\n          // Should be the first $i=0, but no check is done\r\n        }\r\n        else if ($v_list[$i] == \"..\") {\r\n          $v_skip++;\r\n        }\r\n        else if ($v_list[$i] == \"\") {\r\n          // ----- First '/' i.e. root slash\r\n          if ($i == 0) {\r\n            $v_result = \"/\".$v_result;\r\n            if ($v_skip > 0) {\r\n                // ----- It is an invalid path, so the path is not modified\r\n                // TBC\r\n                $v_result = $p_dir;\r\n                $v_skip = 0;\r\n            }\r\n          }\r\n          // ----- Last '/' i.e. indicates a directory\r\n          else if ($i == (sizeof($v_list)-1)) {\r\n            $v_result = $v_list[$i];\r\n          }\r\n          // ----- Double '/' inside the path\r\n          else {\r\n            // ----- Ignore only the double '//' in path,\r\n            // but not the first and last '/'\r\n          }\r\n        }\r\n        else {\r\n          // ----- Look for item to skip\r\n          if ($v_skip > 0) {\r\n            $v_skip--;\r\n          }\r\n          else {\r\n            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?\"/\".$v_result:\"\");\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Look for skip\r\n      if ($v_skip > 0) {\r\n        while ($v_skip > 0) {\r\n            $v_result = '../'.$v_result;\r\n            $v_skip--;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathInclusion()\r\n  // Description :\r\n  //   This function indicates if the path $p_path is under the $p_dir tree. Or,\r\n  //   said in an other way, if the file or sub-dir $p_path is inside the dir\r\n  //   $p_dir.\r\n  //   The function indicates also if the path is exactly the same as the dir.\r\n  //   This function supports path with duplicated '/' like '//', but does not\r\n  //   support '.' or '..' statements.\r\n  // Parameters :\r\n  // Return Values :\r\n  //   0 if $p_path is not inside directory $p_dir\r\n  //   1 if $p_path is inside directory $p_dir\r\n  //   2 if $p_path is exactly the same as $p_dir\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathInclusion($p_dir, $p_path)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Look for path beginning by ./\r\n    if (   ($p_dir == '.')\r\n        || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) {\r\n      $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1);\r\n    }\r\n    if (   ($p_path == '.')\r\n        || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) {\r\n      $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1);\r\n    }\r\n\r\n    // ----- Explode dir and path by directory separator\r\n    $v_list_dir = explode(\"/\", $p_dir);\r\n    $v_list_dir_size = sizeof($v_list_dir);\r\n    $v_list_path = explode(\"/\", $p_path);\r\n    $v_list_path_size = sizeof($v_list_path);\r\n\r\n    // ----- Study directories paths\r\n    $i = 0;\r\n    $j = 0;\r\n    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {\r\n\r\n      // ----- Look for empty dir (path reduction)\r\n      if ($v_list_dir[$i] == '') {\r\n        $i++;\r\n        continue;\r\n      }\r\n      if ($v_list_path[$j] == '') {\r\n        $j++;\r\n        continue;\r\n      }\r\n\r\n      // ----- Compare the items\r\n      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {\r\n        $v_result = 0;\r\n      }\r\n\r\n      // ----- Next items\r\n      $i++;\r\n      $j++;\r\n    }\r\n\r\n    // ----- Look if everything seems to be the same\r\n    if ($v_result) {\r\n      // ----- Skip all the empty items\r\n      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;\r\n      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;\r\n\r\n      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {\r\n        // ----- There are exactly the same\r\n        $v_result = 2;\r\n      }\r\n      else if ($i < $v_list_dir_size) {\r\n        // ----- The path is shorter than the dir\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilCopyBlock()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_mode : read/write compression mode\r\n  //             0 : src & dest normal\r\n  //             1 : src gzip, dest normal\r\n  //             2 : src normal, dest gzip\r\n  //             3 : src & dest gzip\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)\r\n  {\r\n    $v_result = 1;\r\n\r\n    if ($p_mode==0)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==1)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==2)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==3)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilRename()\r\n  // Description :\r\n  //   This function tries to do a simple rename() function. If it fails, it\r\n  //   tries to copy the $p_src file in a new $p_dest file and then unlink the\r\n  //   first one.\r\n  // Parameters :\r\n  //   $p_src : Old filename\r\n  //   $p_dest : New filename\r\n  // Return Values :\r\n  //   1 on success, 0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilRename($p_src, $p_dest)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Try to rename the files\r\n    if (!@rename($p_src, $p_dest)) {\r\n\r\n      // ----- Try to copy & unlink the src\r\n      if (!@copy($p_src, $p_dest)) {\r\n        $v_result = 0;\r\n      }\r\n      else if (!@unlink($p_src)) {\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilOptionText()\r\n  // Description :\r\n  //   Translate option value in text. Mainly for debug purpose.\r\n  // Parameters :\r\n  //   $p_option : the option value.\r\n  // Return Values :\r\n  //   The option text value.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilOptionText($p_option)\r\n  {\r\n\r\n    $v_list = get_defined_constants();\r\n    for (reset($v_list); $v_key = key($v_list); next($v_list)) {\r\n        $v_prefix = substr($v_key, 0, 10);\r\n        if ((   ($v_prefix == 'PCLZIP_OPT')\r\n           || ($v_prefix == 'PCLZIP_CB_')\r\n           || ($v_prefix == 'PCLZIP_ATT'))\r\n            && ($v_list[$v_key] == $p_option)) {\r\n        return $v_key;\r\n        }\r\n    }\r\n\r\n    $v_result = 'Unknown';\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilTranslateWinPath()\r\n  // Description :\r\n  //   Translate windows path by replacing '\\' by '/' and optionally removing\r\n  //   drive letter.\r\n  // Parameters :\r\n  //   $p_path : path to translate.\r\n  //   $p_remove_disk_letter : true | false\r\n  // Return Values :\r\n  //   The path translated.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)\r\n  {\r\n    if (stristr(php_uname(), 'windows')) {\r\n      // ----- Look for potential disk letter\r\n      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {\r\n          $p_path = substr($p_path, $v_position+1);\r\n      }\r\n      // ----- Change potential windows directory separator\r\n      if ((strpos($p_path, '\\\\') > 0) || (substr($p_path, 0,1) == '\\\\')) {\r\n          $p_path = strtr($p_path, '\\\\', '/');\r\n      }\r\n    }\r\n    return $p_path;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n?>\r\n"], "filenames": ["application/third_party/pclzip/pclzip.lib.php"], "buggy_code_start_loc": [3671], "buggy_code_end_loc": [3671], "fixing_code_start_loc": [3672], "fixing_code_end_loc": [3675], "type": "CWE-22", "message": "LimeSurvey version 3.14.4 and earlier contains a directory traversal in file upload that allows upload of webshell vulnerability in file upload functionality that can result in remote code execution as authenticated user. This attack appear to be exploitable via An authenticated user can upload a specially crafted zip file to get remote code execution. This vulnerability appears to have been fixed in after commit 72a02ebaaf95a80e26127ee7ee2b123cccce05a7 / version 3.14.4.", "other": {"cve": {"id": "CVE-2018-1000659", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-06T17:29:00.783", "lastModified": "2018-10-26T13:56:42.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LimeSurvey version 3.14.4 and earlier contains a directory traversal in file upload that allows upload of webshell vulnerability in file upload functionality that can result in remote code execution as authenticated user. This attack appear to be exploitable via An authenticated user can upload a specially crafted zip file to get remote code execution. This vulnerability appears to have been fixed in after commit 72a02ebaaf95a80e26127ee7ee2b123cccce05a7 / version 3.14.4."}, {"lang": "es", "value": "LimeSurvey en su versi\u00f3n 3.14.4 y anteriores contiene una vulnerabilidad de salto de directorio en la subida de archivos que permite una vulnerabilidad de subida de shell web en la funcionalidad de subida de archivos que puede resultar en la ejecuci\u00f3n remota de c\u00f3digo como usuario autenticado. El ataque parece ser explotable si un usuario autenticado sube un archivo zip especialmente manipulado para poder ejecutar c\u00f3digo de forma remota. La vulnerabilidad parece haber sido solucionada tras el commit con ID 72a02ebaaf95a80e26127ee7ee2b123cccce05a7 en la versi\u00f3n 3.14.4."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:limesurvey:limesurvey:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.14.4", "matchCriteriaId": "AAFFD5D8-5309-4DFA-A1BE-E94D2B9A807C"}]}]}], "references": [{"url": "https://github.com/LimeSurvey/LimeSurvey/commit/72a02ebaaf95a80e26127ee7ee2b123cccce05a7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LimeSurvey/LimeSurvey/commit/72a02ebaaf95a80e26127ee7ee2b123cccce05a7"}}