{"buggy_code": ["from __future__ import annotations\n\nimport email.utils\nimport errno\nimport os\nimport sys\nimport urllib.parse\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom typing import List, Optional\n\nimport attr\nimport requests\nimport tenacity\n\nfrom .Line import Line\n\n\n@attr.s(auto_attribs=True)\nclass InputContent:\n    rawLines: List[str]\n    date: Optional[datetime.date]\n\n    @property\n    def lines(self) -> List[Line]:\n        return [Line(i, line) for i, line in enumerate(self.rawLines, 1)]\n\n    @property\n    def content(self) -> str:\n        return \"\".join(self.rawLines)\n\n\nclass InputSource:\n    \"\"\"Represents a thing that can produce specification input text.\n\n    Input can be read from stdin (\"-\"), an HTTPS URL, or a file. Other\n    InputSources can be found relative to URLs and files, and there's a context\n    manager for temporarily switching to the directory of a file InputSource.\n    \"\"\"\n\n    def __new__(cls, sourceName: str):\n        \"\"\"Dispatches to the right subclass.\"\"\"\n        if cls != InputSource:\n            # Only take control of calls to InputSource(...) itself.\n            return super().__new__(cls)\n\n        if sourceName == \"-\":\n            return StdinInputSource(sourceName)\n        if sourceName.startswith(\"https:\"):\n            return UrlInputSource(sourceName)\n        return FileInputSource(sourceName)\n\n    @abstractmethod\n    def __str__(self) -> str:\n        pass\n\n    def __repr__(self) -> str:\n        return \"{}({!r})\".format(self.__class__.__name__, str(self))\n\n    def __hash__(self):\n        return hash(str(self))\n\n    def __eq__(self, other):\n        return str(self) == str(other)\n\n    @abstractmethod\n    def read(self) -> InputContent:\n        \"\"\"Fully reads the source.\"\"\"\n\n    def hasDirectory(self) -> bool:\n        \"\"\"Only some InputSources have a directory.\"\"\"\n        return False\n\n    def directory(self) -> str:\n        \"\"\"Suitable for passing to subprocess(cwd=).\"\"\"\n        raise TypeError(\"{} instances don't have directories.\".format(type(self)))\n\n    def relative(self, _) -> Optional[InputSource]:\n        \"\"\"Resolves relativePath relative to this InputSource.\n\n        For example, InputSource(\"/foo/bar/baz.txt\").relative(\"quux/fuzzy.txt\")\n        will be InputSource(\"/foo/bar/quux/fuzzy.txt\").\n\n        If this source type can't find others relative to itself, returns None.\n        \"\"\"\n        return None\n\n    def mtime(self) -> Optional[float]:\n        \"\"\"Returns the last modification time of this source, if that's known.\"\"\"\n        return None\n\n    def cheaplyExists(self, _) -> Optional[bool]:\n        \"\"\"If it's cheap to determine, returns whether relativePath exists.\n\n        Otherwise, returns None.\n        \"\"\"\n        return None\n\n    def __getattr__(self, name):\n        \"\"\"Hack to make pylint happy, since all the attrs are defined\n        on the subclasses that __new__ dynamically dispatches to.\n        See https://stackoverflow.com/a/60731663/455535\n        \"\"\"\n        print(f\"No member '{name}' contained in InputSource.\")\n        return \"\"\n\n\nclass StdinInputSource(InputSource):\n    def __init__(self, sourceName: str):\n        assert sourceName == \"-\"\n        self.type = \"stdin\"\n        self.sourceName = sourceName\n        self.content = None\n\n    def __str__(self) -> str:\n        return \"-\"\n\n    def read(self) -> InputContent:\n        return InputContent(sys.stdin.readlines(), None)\n\n\nclass UrlInputSource(InputSource):\n    def __init__(self, sourceName: str):\n        assert sourceName.startswith(\"https:\")\n        self.sourceName = sourceName\n        self.type = \"url\"\n\n    def __str__(self) -> str:\n        return self.sourceName\n\n    @tenacity.retry(\n        reraise=True,\n        stop=tenacity.stop_after_attempt(3),\n        wait=tenacity.wait_random(1, 2),\n    )\n    def _fetch(self):\n        response = requests.get(self.sourceName, timeout=10)\n        if response.status_code == 404:\n            # This matches the OSErrors expected by older uses of\n            # FileInputSource. It skips the retry, since the server has given us\n            # a concrete, expected answer.\n            raise FileNotFoundError(errno.ENOENT, response.text, self.sourceName)\n        response.raise_for_status()\n        return response\n\n    def read(self) -> InputContent:\n        response = self._fetch()\n        date = None\n        if \"Date\" in response.headers:\n            # Use the response's Date header, although servers don't always set\n            # this according to the last change to the file.\n            date = email.utils.parsedate_to_datetime(response.headers[\"Date\"]).date()\n        return InputContent(response.text.splitlines(True), date)\n\n    def relative(self, relativePath) -> UrlInputSource:\n        return UrlInputSource(urllib.parse.urljoin(self.sourceName, relativePath))\n\n\nclass FileInputSource(InputSource):\n    def __init__(self, sourceName: str):\n        self.sourceName = sourceName\n        self.type = \"file\"\n        self.content = None\n\n    def __str__(self) -> str:\n        return self.sourceName\n\n    def read(self) -> InputContent:\n        with open(self.sourceName, encoding=\"utf-8\") as f:\n            return InputContent(\n                f.readlines(),\n                datetime.fromtimestamp(os.path.getmtime(self.sourceName)).date(),\n            )\n\n    def hasDirectory(self) -> bool:\n        return True\n\n    def directory(self) -> str:\n        return os.path.dirname(os.path.abspath(self.sourceName))\n\n    def relative(self, relativePath) -> FileInputSource:\n        return FileInputSource(os.path.join(self.directory(), relativePath))\n\n    def cheaplyExists(self, relativePath) -> bool:\n        return os.access(self.relative(relativePath).sourceName, os.R_OK)\n\n    def mtime(self) -> Optional[float]:\n        \"\"\"Returns the last modification time of this file, or None if it doesn't exist.\"\"\"\n        try:\n            return os.stat(self.sourceName).st_mtime\n        except FileNotFoundError:\n            return None\n", "import glob\nimport os\nimport sys\nfrom collections import defaultdict\nfrom functools import partial as curry\n\nfrom . import (\n    biblio,\n    boilerplate,\n    caniuse,\n    conditional,\n    config,\n    constants,\n    datablocks,\n    dfns,\n    extensions,\n    fingerprinting,\n    h,\n    headings,\n    highlight,\n    idl,\n    includes,\n    inlineTags,\n    lint,\n    markdown,\n    mdnspeclinks,\n    metadata,\n    shorthands,\n    wpt,\n)\nfrom .func import Functor\nfrom .h import *\nfrom .InputSource import FileInputSource, InputSource\nfrom .messages import *\nfrom .refs import ReferenceManager\nfrom .unsortedJunk import *\n\n\nclass Spec:\n    def __init__(\n        self,\n        inputFilename,\n        debug=False,\n        token=None,\n        lineNumbers=False,\n        fileRequester=None,\n        testing=False,\n    ):\n        self.valid = False\n        self.lineNumbers = lineNumbers\n        if lineNumbers:\n            # line-numbers are too hacky, so force this to be a dry run\n            constants.dryRun = True\n        if inputFilename is None:\n            inputFilename = findImplicitInputFile()\n        if inputFilename is None:  # still\n            die(\n                \"No input file specified, and no *.bs or *.src.html files found in current directory.\\nPlease specify an input file, or use - to pipe from STDIN.\"\n            )\n            return\n        self.inputSource = InputSource(inputFilename)\n        self.transitiveDependencies = set()\n        self.debug = debug\n        self.token = token\n        self.testing = testing\n        if fileRequester is None:\n            self.dataFile = config.defaultRequester\n        else:\n            self.dataFile = fileRequester\n\n        self.md = None\n        self.mdBaseline = None\n        self.mdDocument = None\n        self.mdCommandLine = None\n        self.mdDefaults = None\n        self.mdOverridingDefaults = None\n        self.lines = []\n        self.document = None\n        self.html = None\n        self.head = None\n        self.body = None\n        self.fillContainers = None\n        self.valid = self.initializeState()\n\n    def initializeState(self):\n        self.normativeRefs = {}\n        self.informativeRefs = {}\n        self.refs = ReferenceManager(fileRequester=self.dataFile, testing=self.testing)\n        self.externalRefsUsed = defaultdict(lambda: defaultdict(dict))\n        self.md = None\n        self.mdBaseline = metadata.MetadataManager()\n        self.mdDocument = None\n        self.mdCommandLine = metadata.MetadataManager()\n        self.mdDefaults = None\n        self.mdOverridingDefaults = None\n        self.biblios = {}\n        self.typeExpansions = {}\n        self.macros = defaultdict(lambda x: \"???\")\n        self.canIUse = {}\n        self.mdnSpecLinks = {}\n        self.widl = idl.getParser()\n        self.testSuites = json.loads(self.dataFile.fetch(\"test-suites.json\", str=True))\n        self.languages = json.loads(self.dataFile.fetch(\"languages.json\", str=True))\n        self.extraStyles = defaultdict(str)\n        self.extraStyles[\"style-colors\"] = styleColors\n        self.extraStyles[\"style-darkmode\"] = styleDarkMode\n        self.extraStyles[\"style-md-lists\"] = styleMdLists\n        self.extraStyles[\"style-autolinks\"] = styleAutolinks\n        self.extraStyles[\"style-selflinks\"] = styleSelflinks\n        self.extraStyles[\"style-counters\"] = styleCounters\n        self.extraScripts = defaultdict(str)\n\n        try:\n            inputContent = self.inputSource.read()\n            self.lines = inputContent.lines\n            if inputContent.date is not None:\n                self.mdBaseline.addParsedData(\"Date\", inputContent.date)\n        except FileNotFoundError:\n            die(\n                \"Couldn't find the input file at the specified location '{0}'.\",\n                self.inputSource,\n            )\n            return False\n        except OSError:\n            die(\"Couldn't open the input file '{0}'.\", self.inputSource)\n            return False\n\n        return True\n\n    def recordDependencies(self, *inputSources):\n        self.transitiveDependencies.update(inputSources)\n\n    def preprocess(self):\n        self.transitiveDependencies.clear()\n        self.assembleDocument()\n        self.processDocument()\n\n    def assembleDocument(self):\n        # Textual hacks\n        stripBOM(self)\n        if self.lineNumbers:\n            self.lines = hackyLineNumbers(self.lines)\n        self.lines = markdown.stripComments(self.lines)\n        self.recordDependencies(self.inputSource)\n        # Extract and process metadata\n        self.lines, self.mdDocument = metadata.parse(lines=self.lines)\n        # First load the metadata sources from 'local' data\n        self.md = metadata.join(self.mdBaseline, self.mdDocument, self.mdCommandLine)\n        # Using that to determine the Group and Status, load the correct defaults.include boilerplate\n        self.mdDefaults = metadata.fromJson(\n            data=config.retrieveBoilerplateFile(self, \"defaults\", error=True),\n            source=\"defaults\",\n        )\n        self.md = metadata.join(\n            self.mdBaseline, self.mdDefaults, self.mdDocument, self.mdCommandLine\n        )\n        # Using all of that, load up the text macros so I can sub them into the computed-metadata file.\n        self.md.fillTextMacros(self.macros, doc=self)\n        jsonEscapedMacros = {k: json.dumps(v)[1:-1] for k, v in self.macros.items()}\n        computedMdText = replaceMacros(\n            config.retrieveBoilerplateFile(self, \"computed-metadata\", error=True),\n            macros=jsonEscapedMacros,\n        )\n        self.mdOverridingDefaults = metadata.fromJson(\n            data=computedMdText, source=\"computed-metadata\"\n        )\n        self.md = metadata.join(\n            self.mdBaseline,\n            self.mdDefaults,\n            self.mdOverridingDefaults,\n            self.mdDocument,\n            self.mdCommandLine,\n        )\n        # Finally, compute the \"implicit\" things.\n        self.md.computeImplicitMetadata(doc=self)\n        # And compute macros again, in case the preceding steps changed them.\n        self.md.fillTextMacros(self.macros, doc=self)\n        self.md.validate()\n        extensions.load(self)\n\n        # Initialize things\n        self.refs.initializeRefs(self)\n        self.refs.initializeBiblio()\n\n        # Deal with further <pre> blocks, and markdown\n        self.lines = datablocks.transformDataBlocks(self, self.lines)\n        self.lines = markdown.parse(\n            self.lines,\n            self.md.indent,\n            opaqueElements=self.md.opaqueElements,\n            blockElements=self.md.blockElements,\n        )\n        # Note that, currently, markdown.parse returns an array of strings, not of Line objects.\n\n        self.refs.setSpecData(self.md)\n\n        # Convert to a single string of html now, for convenience.\n        self.html = \"\".join(line.text for line in self.lines)\n        boilerplate.addHeaderFooter(self)\n        self.html = self.fixText(self.html)\n\n        # Build the document\n        self.document = parseDocument(self.html)\n        self.head = find(\"head\", self)\n        self.body = find(\"body\", self)\n        correctH1(self)\n        includes.processInclusions(self)\n        metadata.parseDoc(self)\n\n    def processDocument(self):\n        # Fill in and clean up a bunch of data\n        conditional.processConditionals(self)\n        self.fillContainers = locateFillContainers(self)\n        lint.exampleIDs(self)\n        boilerplate.addBikeshedVersion(self)\n        boilerplate.addCanonicalURL(self)\n        boilerplate.addFavicon(self)\n        boilerplate.addSpecVersion(self)\n        boilerplate.addStatusSection(self)\n        boilerplate.addLogo(self)\n        boilerplate.addCopyright(self)\n        boilerplate.addSpecMetadataSection(self)\n        boilerplate.addAbstract(self)\n        boilerplate.addExpiryNotice(self)\n        boilerplate.addObsoletionNotice(self)\n        boilerplate.addAtRisk(self)\n        addNoteHeaders(self)\n        boilerplate.removeUnwantedBoilerplate(self)\n        wpt.processWptElements(self)\n        shorthands.run(self)\n        inlineTags.processTags(self)\n        canonicalizeShortcuts(self)\n        addImplicitAlgorithms(self)\n        fixManualDefTables(self)\n        headings.processHeadings(self)\n        checkVarHygiene(self)\n        processIssuesAndExamples(self)\n        idl.markupIDL(self)\n        inlineRemoteIssues(self)\n        addImageSize(self)\n\n        # Handle all the links\n        processBiblioLinks(self)\n        processDfns(self)\n        idl.processIDL(self)\n        dfns.annotateDfns(self)\n        formatArgumentdefTables(self)\n        formatElementdefTables(self)\n        processAutolinks(self)\n        biblio.dedupBiblioReferences(self)\n        verifyUsageOfAllLocalBiblios(self)\n        caniuse.addCanIUsePanels(self)\n        boilerplate.addIndexSection(self)\n        boilerplate.addExplicitIndexes(self)\n        boilerplate.addStyles(self)\n        boilerplate.addReferencesSection(self)\n        boilerplate.addPropertyIndex(self)\n        boilerplate.addIDLSection(self)\n        boilerplate.addIssuesSection(self)\n        boilerplate.addCustomBoilerplate(self)\n        headings.processHeadings(self, \"all\")  # again\n        boilerplate.removeUnwantedBoilerplate(self)\n        boilerplate.addTOCSection(self)\n        addSelfLinks(self)\n        processAutolinks(self)\n        boilerplate.addAnnotations(self)\n        boilerplate.removeUnwantedBoilerplate(self)\n        # Add MDN panels after all IDs/anchors have been added\n        mdnspeclinks.addMdnPanels(self)\n        highlight.addSyntaxHighlighting(self)\n        boilerplate.addBikeshedBoilerplate(self)\n        fingerprinting.addTrackingVector(self)\n        fixIntraDocumentReferences(self)\n        fixInterDocumentReferences(self)\n        removeMultipleLinks(self)\n        forceCrossorigin(self)\n        lint.brokenLinks(self)\n        lint.accidental2119(self)\n        lint.missingExposed(self)\n        lint.requiredIDs(self)\n        lint.unusedInternalDfns(self)\n\n        # Any final HTML cleanups\n        cleanupHTML(self)\n        if self.md.prepTR:\n            # Don't try and override the W3C's icon.\n            for el in findAll(\"[rel ~= 'icon']\", self):\n                removeNode(el)\n            # Make sure the W3C stylesheet is after all other styles.\n            for el in findAll(\"link\", self):\n                if el.get(\"href\").startswith(\"https://www.w3.org/StyleSheets/TR\"):\n                    appendChild(find(\"head\", self), el)\n            # Ensure that all W3C links are https.\n            for el in findAll(\"a\", self):\n                href = el.get(\"href\", \"\")\n                if href.startswith(\"http://www.w3.org\") or href.startswith(\n                    \"http://lists.w3.org\"\n                ):\n                    el.set(\"href\", \"https\" + href[4:])\n                text = el.text or \"\"\n                if text.startswith(\"http://www.w3.org\") or text.startswith(\n                    \"http://lists.w3.org\"\n                ):\n                    el.text = \"https\" + text[4:]\n            # Loaded from .include files\n            extensions.BSPrepTR(self)  # pylint: disable=no-member\n\n        return self\n\n    def serialize(self):\n        try:\n            rendered = h.Serializer(\n                self.md.opaqueElements, self.md.blockElements\n            ).serialize(self.document)\n        except Exception as e:\n            die(\"{0}\", e)\n            return\n        rendered = finalHackyCleanup(rendered)\n        return rendered\n\n    def fixMissingOutputFilename(self, outputFilename):\n        if outputFilename is None:\n            # More sensible defaults!\n            if not isinstance(self.inputSource, FileInputSource):\n                outputFilename = \"-\"\n            elif self.inputSource.sourceName.endswith(\".bs\"):\n                outputFilename = self.inputSource.sourceName[0:-3] + \".html\"\n            elif self.inputSource.sourceName.endswith(\".src.html\"):\n                outputFilename = self.inputSource.sourceName[0:-9] + \".html\"\n            else:\n                outputFilename = \"-\"\n        return outputFilename\n\n    def finish(self, outputFilename=None, newline=None):\n        self.printResultMessage()\n        outputFilename = self.fixMissingOutputFilename(outputFilename)\n        rendered = self.serialize()\n        if not constants.dryRun:\n            try:\n                if outputFilename == \"-\":\n                    sys.stdout.write(rendered)\n                else:\n                    with open(\n                        outputFilename, \"w\", encoding=\"utf-8\", newline=newline\n                    ) as f:\n                        f.write(rendered)\n            except Exception as e:\n                die(\n                    \"Something prevented me from saving the output document to {0}:\\n{1}\",\n                    outputFilename,\n                    e,\n                )\n\n    def printResultMessage(self):\n        # If I reach this point, I've succeeded, but maybe with reservations.\n        fatals = messageCounts[\"fatal\"]\n        links = messageCounts[\"linkerror\"]\n        warnings = messageCounts[\"warning\"]\n        if self.lineNumbers:\n            warn(\"Because --line-numbers was used, no output was saved.\")\n        if fatals:\n            success(\"Successfully generated, but fatal errors were suppressed\")\n            return\n        if links:\n            success(\"Successfully generated, with {0} linking errors\", links)\n            return\n        if warnings:\n            success(\"Successfully generated, with warnings\")\n            return\n\n    def watch(self, outputFilename, port=None, localhost=False):\n        import time\n\n        outputFilename = self.fixMissingOutputFilename(outputFilename)\n        if self.inputSource.mtime() is None:\n            die(f\"Watch mode doesn't support {self.inputSource}\")\n        if outputFilename == \"-\":\n            die(\"Watch mode doesn't support streaming to STDOUT.\")\n            return\n\n        if port:\n            # Serve the folder on an HTTP server\n            import http.server\n            import socketserver\n            import threading\n\n            class SilentServer(http.server.SimpleHTTPRequestHandler):\n                def log_message(self, format, *args):\n                    pass\n\n            socketserver.TCPServer.allow_reuse_address = True\n            server = socketserver.TCPServer(\n                (\"localhost\" if localhost else \"\", port), SilentServer\n            )\n\n            print(f\"Serving at port {port}\")\n            thread = threading.Thread(target=server.serve_forever)\n            thread.daemon = True\n            thread.start()\n        else:\n            server = None\n\n        mdCommandLine = self.mdCommandLine\n\n        try:\n            self.preprocess()\n            self.finish(outputFilename)\n            lastInputModified = {\n                dep: dep.mtime() for dep in self.transitiveDependencies\n            }\n            p(\"==============DONE==============\")\n            try:\n                while True:\n                    # Comparing mtimes with \"!=\" handles when a file starts or\n                    # stops existing, and it's fine to rebuild if an mtime\n                    # somehow gets older.\n                    if any(\n                        input.mtime() != lastModified\n                        for input, lastModified in lastInputModified.items()\n                    ):\n                        resetSeenMessages()\n                        p(\"Source file modified. Rebuilding...\")\n                        self.initializeState()\n                        self.mdCommandLine = mdCommandLine\n                        self.preprocess()\n                        self.finish(outputFilename)\n                        lastInputModified = {\n                            dep: dep.mtime() for dep in self.transitiveDependencies\n                        }\n                        p(\"==============DONE==============\")\n                    time.sleep(1)\n            except KeyboardInterrupt:\n                p(\"Exiting~\")\n                if server:\n                    server.shutdown()\n                    thread.join()\n                sys.exit(0)\n        except Exception as e:\n            die(\"Something went wrong while watching the file:\\n{0}\", e)\n\n    def fixText(self, text, moreMacros={}):\n        # Do several textual replacements that need to happen *before* the document is parsed as h.\n\n        # If markdown shorthands are on, remove all `foo`s while processing,\n        # so their contents don't accidentally trigger other stuff.\n        # Also handle markdown escapes.\n        if \"markdown\" in self.md.markupShorthands:\n            textFunctor = MarkdownCodeSpans(text)\n        else:\n            textFunctor = Functor(text)\n\n        macros = dict(self.macros, **moreMacros)\n        textFunctor = textFunctor.map(curry(replaceMacros, macros=macros))\n        textFunctor = textFunctor.map(fixTypography)\n        if \"css\" in self.md.markupShorthands:\n            textFunctor = textFunctor.map(replaceAwkwardCSSShorthands)\n\n        return textFunctor.extract()\n\n    def printTargets(self):\n        p(\"Exported terms:\")\n        for el in findAll(\"[data-export]\", self):\n            for term in config.linkTextsFromElement(el):\n                p(\"  \" + term)\n        p(\"Unexported terms:\")\n        for el in findAll(\"[data-noexport]\", self):\n            for term in config.linkTextsFromElement(el):\n                p(\"  \" + term)\n\n    def isOpaqueElement(self, el):\n        if el.tag in self.md.opaqueElements:\n            return True\n        if el.get(\"data-opaque\") is not None:\n            return True\n        return False\n\n\ndef findImplicitInputFile():\n    \"\"\"\n    Find what input file the user *probably* wants to use,\n    by scanning the current folder.\n    In preference order:\n    1. index.bs\n    2. Overview.bs\n    3. the first file with a .bs extension\n    4. the first file with a .src.html extension\n    \"\"\"\n\n    if os.path.isfile(\"index.bs\"):\n        return \"index.bs\"\n    if os.path.isfile(\"Overview.bs\"):\n        return \"Overview.bs\"\n\n    allBs = glob.glob(\"*.bs\")\n    if allBs:\n        return allBs[0]\n\n    allHtml = glob.glob(\"*.src.html\")\n    if allHtml:\n        return allHtml[0]\n\n    return None\n\n\nconstants.specClass = Spec\n\nstyleColors = \"\"\"\n/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */\n:root {\n    color-scheme: light dark;\n\n    --text: black;\n    --bg: white;\n\n    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);\n\n    --logo-bg: #1a5e9a;\n    --logo-active-bg: #c00;\n    --logo-text: white;\n\n    --tocnav-normal-text: #707070;\n    --tocnav-normal-bg: var(--bg);\n    --tocnav-hover-text: var(--tocnav-normal-text);\n    --tocnav-hover-bg: #f8f8f8;\n    --tocnav-active-text: #c00;\n    --tocnav-active-bg: var(--tocnav-normal-bg);\n\n    --tocsidebar-text: var(--text);\n    --tocsidebar-bg: #f7f8f9;\n    --tocsidebar-shadow: rgba(0,0,0,.1);\n    --tocsidebar-heading-text: hsla(203,20%,40%,.7);\n\n    --toclink-text: var(--text);\n    --toclink-underline: #3980b5;\n    --toclink-visited-text: var(--toclink-text);\n    --toclink-visited-underline: #054572;\n\n    --heading-text: #005a9c;\n\n    --hr-text: var(--text);\n\n    --algo-border: #def;\n\n    --del-text: red;\n    --del-bg: transparent;\n    --ins-text: #080;\n    --ins-bg: transparent;\n\n    --a-normal-text: #034575;\n    --a-normal-underline: #bbb;\n    --a-visited-text: var(--a-normal-text);\n    --a-visited-underline: #707070;\n    --a-hover-bg: rgba(75%, 75%, 75%, .25);\n    --a-active-text: #c00;\n    --a-active-underline: #c00;\n\n    --blockquote-border: silver;\n    --blockquote-bg: transparent;\n    --blockquote-text: currentcolor;\n\n    --issue-border: #e05252;\n    --issue-bg: #fbe9e9;\n    --issue-text: var(--text);\n    --issueheading-text: #831616;\n\n    --example-border: #e0cb52;\n    --example-bg: #fcfaee;\n    --example-text: var(--text);\n    --exampleheading-text: #574b0f;\n\n    --note-border: #52e052;\n    --note-bg: #e9fbe9;\n    --note-text: var(--text);\n    --noteheading-text: hsl(120, 70%, 30%);\n    --notesummary-underline: silver;\n\n    --assertion-border: #aaa;\n    --assertion-bg: #eee;\n    --assertion-text: black;\n\n    --advisement-border: orange;\n    --advisement-bg: #fec;\n    --advisement-text: var(--text);\n    --advisementheading-text: #b35f00;\n\n    --warning-border: red;\n    --warning-bg: hsla(40,100%,50%,0.95);\n    --warning-text: var(--text);\n\n    --amendment-border: #330099;\n    --amendment-bg: #F5F0FF;\n    --amendment-text: var(--text);\n    --amendmentheading-text: #220066;\n\n    --def-border: #8ccbf2;\n    --def-bg: #def;\n    --def-text: var(--text);\n    --defrow-border: #bbd7e9;\n\n    --datacell-border: silver;\n\n    --indexinfo-text: #707070;\n\n    --indextable-hover-text: black;\n    --indextable-hover-bg: #f7f8f9;\n\n    --outdatedspec-bg: rgba(0, 0, 0, .5);\n    --outdatedspec-text: black;\n    --outdated-bg: maroon;\n    --outdated-text: white;\n    --outdated-shadow: red;\n\n    --editedrec-bg: darkorange;\n}\"\"\"\n\nstyleDarkMode = \"\"\"\n@media (prefers-color-scheme: dark) {\n    :root {\n        --text: #ddd;\n        --bg: black;\n\n        --unofficial-watermark: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E\");\n\n        --logo-bg: #1a5e9a;\n        --logo-active-bg: #c00;\n        --logo-text: white;\n\n        --tocnav-normal-text: #999;\n        --tocnav-normal-bg: var(--bg);\n        --tocnav-hover-text: var(--tocnav-normal-text);\n        --tocnav-hover-bg: #080808;\n        --tocnav-active-text: #f44;\n        --tocnav-active-bg: var(--tocnav-normal-bg);\n\n        --tocsidebar-text: var(--text);\n        --tocsidebar-bg: #080808;\n        --tocsidebar-shadow: rgba(255,255,255,.1);\n        --tocsidebar-heading-text: hsla(203,20%,40%,.7);\n\n        --toclink-text: var(--text);\n        --toclink-underline: #6af;\n        --toclink-visited-text: var(--toclink-text);\n        --toclink-visited-underline: #054572;\n\n        --heading-text: #8af;\n\n        --hr-text: var(--text);\n\n        --algo-border: #456;\n\n        --del-text: #f44;\n        --del-bg: transparent;\n        --ins-text: #4a4;\n        --ins-bg: transparent;\n\n        --a-normal-text: #6af;\n        --a-normal-underline: #555;\n        --a-visited-text: var(--a-normal-text);\n        --a-visited-underline: var(--a-normal-underline);\n        --a-hover-bg: rgba(25%, 25%, 25%, .2);\n        --a-active-text: #f44;\n        --a-active-underline: var(--a-active-text);\n\n        --borderedblock-bg: rgba(255, 255, 255, .05);\n\n        --blockquote-border: silver;\n        --blockquote-bg: var(--borderedblock-bg);\n        --blockquote-text: currentcolor;\n\n        --issue-border: #e05252;\n        --issue-bg: var(--borderedblock-bg);\n        --issue-text: var(--text);\n        --issueheading-text: hsl(0deg, 70%, 70%);\n\n        --example-border: hsl(50deg, 90%, 60%);\n        --example-bg: var(--borderedblock-bg);\n        --example-text: var(--text);\n        --exampleheading-text: hsl(50deg, 70%, 70%);\n\n        --note-border: hsl(120deg, 100%, 35%);\n        --note-bg: var(--borderedblock-bg);\n        --note-text: var(--text);\n        --noteheading-text: hsl(120, 70%, 70%);\n        --notesummary-underline: silver;\n\n        --assertion-border: #444;\n        --assertion-bg: var(--borderedblock-bg);\n        --assertion-text: var(--text);\n\n        --advisement-border: orange;\n        --advisement-bg: #222218;\n        --advisement-text: var(--text);\n        --advisementheading-text: #f84;\n\n        --warning-border: red;\n        --warning-bg: hsla(40,100%,20%,0.95);\n        --warning-text: var(--text);\n\n        --amendment-border: #330099;\n        --amendment-bg: #080010;\n        --amendment-text: var(--text);\n        --amendmentheading-text: #cc00ff;\n\n        --def-border: #8ccbf2;\n        --def-bg: #080818;\n        --def-text: var(--text);\n        --defrow-border: #136;\n\n        --datacell-border: silver;\n\n        --indexinfo-text: #aaa;\n\n        --indextable-hover-text: var(--text);\n        --indextable-hover-bg: #181818;\n\n        --outdatedspec-bg: rgba(255, 255, 255, .5);\n        --outdatedspec-text: black;\n        --outdated-bg: maroon;\n        --outdated-text: white;\n        --outdated-shadow: red;\n\n        --editedrec-bg: darkorange;\n    }\n    /* In case a transparent-bg image doesn't expect to be on a dark bg,\n       which is quite common in practice... */\n    img { background: white; }\n}\"\"\"\n\nstyleMdLists = \"\"\"\n/* This is a weird hack for me not yet following the commonmark spec\n   regarding paragraph and lists. */\n[data-md] > :first-child {\n    margin-top: 0;\n}\n[data-md] > :last-child {\n    margin-bottom: 0;\n}\"\"\"\n\nstyleAutolinks = \"\"\"\n.css.css, .property.property, .descriptor.descriptor {\n    color: var(--a-normal-text);\n    font-size: inherit;\n    font-family: inherit;\n}\n.css::before, .property::before, .descriptor::before {\n    content: \"\u2018\";\n}\n.css::after, .property::after, .descriptor::after {\n    content: \"\u2019\";\n}\n.property, .descriptor {\n    /* Don't wrap property and descriptor names */\n    white-space: nowrap;\n}\n.type { /* CSS value <type> */\n    font-style: italic;\n}\npre .property::before, pre .property::after {\n    content: \"\";\n}\n[data-link-type=\"property\"]::before,\n[data-link-type=\"propdesc\"]::before,\n[data-link-type=\"descriptor\"]::before,\n[data-link-type=\"value\"]::before,\n[data-link-type=\"function\"]::before,\n[data-link-type=\"at-rule\"]::before,\n[data-link-type=\"selector\"]::before,\n[data-link-type=\"maybe\"]::before {\n    content: \"\u2018\";\n}\n[data-link-type=\"property\"]::after,\n[data-link-type=\"propdesc\"]::after,\n[data-link-type=\"descriptor\"]::after,\n[data-link-type=\"value\"]::after,\n[data-link-type=\"function\"]::after,\n[data-link-type=\"at-rule\"]::after,\n[data-link-type=\"selector\"]::after,\n[data-link-type=\"maybe\"]::after {\n    content: \"\u2019\";\n}\n\n[data-link-type].production::before,\n[data-link-type].production::after,\n.prod [data-link-type]::before,\n.prod [data-link-type]::after {\n    content: \"\";\n}\n\n[data-link-type=element],\n[data-link-type=element-attr] {\n    font-family: Menlo, Consolas, \"DejaVu Sans Mono\", monospace;\n    font-size: .9em;\n}\n[data-link-type=element]::before { content: \"<\" }\n[data-link-type=element]::after  { content: \">\" }\n\n[data-link-type=biblio] {\n    white-space: pre;\n}\"\"\"\n\nstyleSelflinks = \"\"\"\n:root {\n    --selflink-text: white;\n    --selflink-bg: gray;\n    --selflink-hover-text: black;\n}\n.heading, .issue, .note, .example, li, dt {\n    position: relative;\n}\na.self-link {\n    position: absolute;\n    top: 0;\n    left: calc(-1 * (3.5rem - 26px));\n    width: calc(3.5rem - 26px);\n    height: 2em;\n    text-align: center;\n    border: none;\n    transition: opacity .2s;\n    opacity: .5;\n}\na.self-link:hover {\n    opacity: 1;\n}\n.heading > a.self-link {\n    font-size: 83%;\n}\nli > a.self-link {\n    left: calc(-1 * (3.5rem - 26px) - 2em);\n}\ndfn > a.self-link {\n    top: auto;\n    left: auto;\n    opacity: 0;\n    width: 1.5em;\n    height: 1.5em;\n    background: var(--selflink-bg);\n    color: var(--selflink-text);\n    font-style: normal;\n    transition: opacity .2s, background-color .2s, color .2s;\n}\ndfn:hover > a.self-link {\n    opacity: 1;\n}\ndfn > a.self-link:hover {\n    color: var(--selflink-hover-text);\n}\n\na.self-link::before            { content: \"\u00b6\"; }\n.heading > a.self-link::before { content: \"\u00a7\"; }\ndfn > a.self-link::before      { content: \"#\"; }\n\"\"\"\nstyleDarkMode += \"\"\"\n@media (prefers-color-scheme: dark) {\n    :root {\n        --selflink-text: black;\n        --selflink-bg: silver;\n        --selflink-hover-text: white;\n    }\n}\n\"\"\"\n\n\nstyleCounters = \"\"\"\nbody {\n    counter-reset: example figure issue;\n}\n.issue {\n    counter-increment: issue;\n}\n.issue:not(.no-marker)::before {\n    content: \"Issue \" counter(issue);\n}\n\n.example {\n    counter-increment: example;\n}\n.example:not(.no-marker)::before {\n    content: \"Example \" counter(example);\n}\n.invalid.example:not(.no-marker)::before,\n.illegal.example:not(.no-marker)::before {\n    content: \"Invalid Example\" counter(example);\n}\n\nfigcaption {\n    counter-increment: figure;\n}\nfigcaption:not(.no-marker)::before {\n    content: \"Figure \" counter(figure) \" \";\n}\"\"\"\n", "import argparse\nimport json\nimport os\nimport sys\n\nfrom . import config, constants, update\nfrom .config.printjson import getjson\nfrom .messages import *\n\n\ndef main():\n    # Hack around argparse's lack of optional subparsers\n    if len(sys.argv) == 1:\n        sys.argv.append(\"spec\")\n\n    try:\n        with open(config.scriptPath(\"..\", \"semver.txt\")) as fh:\n            semver = fh.read().strip()\n            semverText = f\"Bikeshed v{semver}: \"\n    except FileNotFoundError:\n        semver = \"???\"\n        semverText = \"\"\n\n    argparser = argparse.ArgumentParser(\n        description=f\"{semverText}Processes spec source files into valid HTML.\"\n    )\n    argparser.add_argument(\"--version\", action=\"version\", version=semver)\n    argparser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        dest=\"quiet\",\n        action=\"count\",\n        default=0,\n        help=\"Silences one level of message, least-important first.\",\n    )\n    argparser.add_argument(\n        \"-s\",\n        \"--silent\",\n        dest=\"silent\",\n        action=\"store_true\",\n        help=\"Shorthand for 'as many -q as you need to shut it up'\",\n    )\n    argparser.add_argument(\n        \"-f\",\n        \"--force\",\n        dest=\"errorLevel\",\n        action=\"store_const\",\n        const=\"nothing\",\n        help=\"Force the preprocessor to run to completion; fatal errors don't stop processing.\",\n    )\n    argparser.add_argument(\n        \"-d\",\n        \"--dry-run\",\n        dest=\"dryRun\",\n        action=\"store_true\",\n        help=\"Prevents the processor from actually saving anything to disk, but otherwise fully runs.\",\n    )\n    argparser.add_argument(\n        \"-a\",\n        \"--ascii-only\",\n        dest=\"asciiOnly\",\n        action=\"store_true\",\n        help=\"Force all Bikeshed messages to be ASCII-only.\",\n    )\n    argparser.add_argument(\n        \"--print\",\n        dest=\"printMode\",\n        action=\"store\",\n        default=None,\n        help=\"Print mode. Options are 'plain' (just text), 'console' (colored with console color codes), 'markup', and 'json'. Defaults to 'console'.\",\n    )\n    argparser.add_argument(\n        \"--die-on\",\n        dest=\"errorLevel\",\n        choices=[\"nothing\", \"fatal\", \"link-error\", \"warning\", \"everything\"],\n        help=\"Determines what sorts of errors cause Bikeshed to die (quit immediately with an error status code). Default is 'fatal'; the -f flag is a shorthand for 'nothing'\",\n    )\n\n    subparsers = argparser.add_subparsers(title=\"Subcommands\", dest=\"subparserName\")\n\n    specParser = subparsers.add_parser(\n        \"spec\", help=\"Process a spec source file into a valid output file.\"\n    )\n    specParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    specParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n    specParser.add_argument(\n        \"--debug\",\n        dest=\"debug\",\n        action=\"store_true\",\n        help=\"Switches on some debugging tools. Don't use for production!\",\n    )\n    specParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    specParser.add_argument(\n        \"--byos\",\n        dest=\"byos\",\n        action=\"store_true\",\n        help=\"Bring-Your-Own-Spec: turns off all the Bikeshed auto-niceties, so you can piecemeal its features into your existing doc instead. Experimental, let me know if things get crashy or weird.\",\n    )\n    specParser.add_argument(\n        \"-l\",\n        \"--line-numbers\",\n        dest=\"lineNumbers\",\n        action=\"store_true\",\n        help=\"Hacky support for outputting line numbers on all error messages. Disables output, as this is hacky and might mess up your source.\",\n    )\n\n    echidnaParser = subparsers.add_parser(\n        \"echidna\",\n        help=\"Process a spec source file into a valid output file and publish it according to certain automatic protocols.\",\n    )\n    echidnaParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    echidnaParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    echidnaParser.add_argument(\n        \"--u\", dest=\"un\", metavar=\"USERNAME\", required=False, help=\"W3C username.\"\n    )\n    echidnaParser.add_argument(\n        \"--p\", dest=\"pw\", metavar=\"PASSWORD\", required=False, help=\"W3C password.\"\n    )\n    echidnaParser.add_argument(\n        \"--decision\",\n        dest=\"decision\",\n        metavar=\"DECISION_URL\",\n        required=False,\n        help=\"URL recording the decision to publish.\",\n    )\n    echidnaParser.add_argument(\n        \"--editorial\",\n        dest=\"editorial\",\n        action=\"store_true\",\n        required=False,\n        help=\"Flags update as editorial.\",\n    )\n    echidnaParser.add_argument(\n        \"--cc\",\n        dest=\"cc\",\n        metavar=\"EMAIL\",\n        required=False,\n        help=\"Comma-separated list of email addresses to ping with the publication status when complete.\",\n    )\n    echidnaParser.add_argument(\n        \"--additional-directories\",\n        dest=\"additionalDirectories\",\n        required=False,\n        nargs=\"*\",\n        help=\"Directories to bundle in the tar file. Defaults to examples/, diagrams/, and images/.\",\n    )\n    echidnaParser.add_argument(\n        \"--self-contained\",\n        dest=\"selfContained\",\n        action=\"store_true\",\n        help=\"The spec is self-contained, do not bundle any extra directories in the tar file.\",\n    )\n    echidnaParser.add_argument(\"--just-tar\", dest=\"justTar\", action=\"store_true\")\n\n    watchParser = subparsers.add_parser(\n        \"watch\",\n        help=\"Process a spec source file into a valid output file, automatically rebuilding when it changes.\",\n    )\n    watchParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    watchParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n    watchParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    watchParser.add_argument(\n        \"--byos\",\n        dest=\"byos\",\n        action=\"store_true\",\n        help=\"Bring-Your-Own-Spec: turns off all the Bikeshed auto-niceties, so you can piecemeal its features into your existing doc instead. Experimental, let me know if things get crashy or weird.\",\n    )\n\n    serveParser = subparsers.add_parser(\n        \"serve\", help=\"Identical to 'watch', but also serves the folder on localhost.\"\n    )\n    serveParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    serveParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n    serveParser.add_argument(\n        \"--port\",\n        dest=\"port\",\n        nargs=\"?\",\n        default=\"8000\",\n        help=\"Specify the port to serve it over.\",\n    )\n    serveParser.add_argument(\n        \"--localhost\",\n        dest=\"localhost\",\n        action=\"store_true\",\n        help=\"Only allow connections from localhost.\",\n    )\n    serveParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    serveParser.add_argument(\n        \"--byos\",\n        dest=\"byos\",\n        action=\"store_true\",\n        help=\"Bring-Your-Own-Spec: turns off all the Bikeshed auto-niceties, so you can piecemeal its features into your existing doc instead. Experimental, let me know if things get crashy or weird.\",\n    )\n\n    updateParser = subparsers.add_parser(\n        \"update\",\n        help=\"Update supporting files (those in /spec-data).\",\n        epilog=\"If no options are specified, everything is downloaded.\",\n    )\n    updateParser.add_argument(\n        \"--skip-manifest\",\n        dest=\"force\",\n        action=\"store_true\",\n        help=\"Forces Bikeshed to do a full update manually, rather than using the manifest to get the preprocessed update (which can be several minutes old).\",\n    )\n    updateParser.add_argument(\n        \"--anchors\", action=\"store_true\", help=\"Download crossref anchor data.\"\n    )\n    updateParser.add_argument(\n        \"--backrefs\", action=\"store_true\", help=\"Download link backref data.\"\n    )\n    updateParser.add_argument(\n        \"--biblio\", action=\"store_true\", help=\"Download biblio data.\"\n    )\n    updateParser.add_argument(\n        \"--caniuse\", action=\"store_true\", help=\"Download Can I Use... data.\"\n    )\n    updateParser.add_argument(\n        \"--mdn\", action=\"store_true\", help=\"Download MDN Spec Links... data.\"\n    )\n    updateParser.add_argument(\n        \"--link-defaults\",\n        dest=\"linkDefaults\",\n        action=\"store_true\",\n        help=\"Download link default data.\",\n    )\n    updateParser.add_argument(\n        \"--test-suites\",\n        dest=\"testSuites\",\n        action=\"store_true\",\n        help=\"Download test suite data.\",\n    )\n    updateParser.add_argument(\n        \"--languages\",\n        dest=\"languages\",\n        action=\"store_true\",\n        help=\"Download language/translation data.\",\n    )\n    updateParser.add_argument(\n        \"--wpt\",\n        dest=\"wpt\",\n        action=\"store_true\",\n        help=\"Download web-platform-tests data.\",\n    )\n\n    issueParser = subparsers.add_parser(\n        \"issues-list\",\n        help=\"Process a plain-text issues file into HTML. Call with no args to see an example input text.\",\n    )\n    issueParser.add_argument(\n        \"-t\",\n        dest=\"printTemplate\",\n        action=\"store_true\",\n        help=\"Output example Issues List template.\",\n    )\n    issueParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the plain-text issue file.\"\n    )\n    issueParser.add_argument(\n        \"outfile\",\n        nargs=\"?\",\n        default=None,\n        help=\"Path to the output file. Default is file of the same name as input, with .html.\",\n    )\n\n    debugParser = subparsers.add_parser(\"debug\", help=\"Run various debugging commands.\")\n    debugParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    debugCommands = debugParser.add_mutually_exclusive_group(required=True)\n    debugCommands.add_argument(\n        \"--print-exports\",\n        dest=\"printExports\",\n        action=\"store_true\",\n        help=\"Prints those terms that will be exported for cross-ref purposes.\",\n    )\n    debugCommands.add_argument(\n        \"--print-refs-for\",\n        dest=\"linkText\",\n        help=\"Prints the ref data for a given link text.\",\n    )\n    debugCommands.add_argument(\n        \"--print\", dest=\"code\", help=\"Runs the specified code and prints it.\"\n    )\n    debugCommands.add_argument(\n        \"--print-json\",\n        dest=\"jsonCode\",\n        help=\"Runs the specified code and prints it as formatted JSON.\",\n    )\n    debugCommands.add_argument(\n        \"--refresh-data\",\n        dest=\"refreshData\",\n        action=\"store_true\",\n        help=\"Clobbers the readonly data files with the mutable ones.\",\n    )\n\n    refParser = subparsers.add_parser(\"refs\", help=\"Search Bikeshed's ref database.\")\n    refParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    refParser.add_argument(\"--text\", dest=\"text\", default=None)\n    refParser.add_argument(\"--type\", dest=\"linkType\", default=None)\n    refParser.add_argument(\"--for\", dest=\"linkFor\", default=None)\n    refParser.add_argument(\"--spec\", dest=\"spec\", default=None)\n    refParser.add_argument(\"--status\", dest=\"status\", default=None)\n    refParser.add_argument(\n        \"--exact\",\n        dest=\"exact\",\n        action=\"store_true\",\n        help=\"Only search for the exact text provided; don't apply Bikeshed's automatic conjugation help for plurals/etc.\",\n    )\n    refParser.add_argument(\n        \"--latest-only\",\n        dest=\"latestOnly\",\n        action=\"store_true\",\n        help=\"Apply Bikeshed's logic for only returning the latest version of a given ref when it exists in multiple levels of a spec.\",\n    )\n\n    sourceParser = subparsers.add_parser(\n        \"source\", help=\"Tools for formatting the *source* document.\"\n    )\n    sourceParser.add_argument(\n        \"--big-text\",\n        dest=\"bigText\",\n        action=\"store_true\",\n        help=\"Finds HTML comments containing 'Big Text: foo' and turns them into comments containing 'foo' in big text.\",\n    )\n    sourceParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    sourceParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n\n    testParser = subparsers.add_parser(\n        \"test\", help=\"Tools for running Bikeshed's testsuite.\"\n    )\n    testParser.add_argument(\n        \"--rebase\",\n        default=False,\n        action=\"store_true\",\n        help=\"Rebase the specified files.\",\n    )\n    testParser.add_argument(\n        \"--manual-only\",\n        dest=\"manualOnly\",\n        default=False,\n        action=\"store_true\",\n        help=\"Skip testing the real-world files in the repo, and only run the manually-written ones.\",\n    )\n    testParser.add_argument(\n        \"testFiles\",\n        default=[],\n        metavar=\"FILE\",\n        nargs=\"*\",\n        help=\"Run these tests. If called with no args, tests everything.\",\n    )\n\n    profileParser = subparsers.add_parser(\n        \"profile\",\n        help=\"Profiling Bikeshed. Needs graphviz, gprof2dot, and xdot installed.\",\n    )\n    profileParser.add_argument(\n        \"--root\",\n        dest=\"root\",\n        default=None,\n        metavar=\"ROOTFUNC\",\n        help=\"Prune the graph to start with the specified root node.\",\n    )\n    profileParser.add_argument(\n        \"--leaf\",\n        dest=\"leaf\",\n        default=None,\n        metavar=\"LEAFFUNC\",\n        help=\"Prune the graph to only show ancestors of the specified leaf node.\",\n    )\n    profileParser.add_argument(\n        \"--svg\",\n        dest=\"svgFile\",\n        default=None,\n        help=\"Save the graph to a specified SVG file, rather than outputting with xdot immediately.\",\n    )\n\n    subparsers.add_parser(\n        \"template\", help=\"Outputs a skeleton .bs file for you to start with.\"\n    )\n\n    wptParser = subparsers.add_parser(\n        \"wpt\", help=\"Tools for writing Web Platform Tests.\"\n    )\n    wptParser.add_argument(\n        \"--template\",\n        default=False,\n        action=\"store_true\",\n        help=\"Outputs a skeleton WPT file for you to start with.\",\n    )\n\n    options, extras = argparser.parse_known_args()\n\n    constants.quiet = options.quiet\n    if options.silent:\n        constants.quiet = float(\"infinity\")\n    constants.setErrorLevel(options.errorLevel)\n    constants.dryRun = options.dryRun\n    constants.asciiOnly = options.asciiOnly\n    if options.printMode is None:\n        if \"NO_COLOR\" in os.environ or os.environ.get(\"TERM\") == \"dumb\":\n            constants.printMode = \"plain\"\n        else:\n            constants.printMode = \"console\"\n    else:\n        constants.printMode = options.printMode\n\n    update.fixupDataFiles()\n    if options.subparserName == \"update\":\n        handleUpdate(options)\n    elif options.subparserName == \"spec\":\n        handleSpec(options, extras)\n    elif options.subparserName == \"echidna\":\n        handleEchidna(options, extras)\n    elif options.subparserName == \"watch\":\n        handleWatch(options, extras)\n    elif options.subparserName == \"serve\":\n        handleServe(options, extras)\n    elif options.subparserName == \"debug\":\n        handleDebug(options, extras)\n    elif options.subparserName == \"refs\":\n        handleRefs(options, extras)\n    elif options.subparserName == \"issues-list\":\n        handleIssuesList(options)\n    elif options.subparserName == \"source\":\n        handleSource(options)\n    elif options.subparserName == \"test\":\n        handleTest(options, extras)\n    elif options.subparserName == \"profile\":\n        handleProfile(options)\n    elif options.subparserName == \"template\":\n        handleTemplate()\n    elif options.subparserName == \"wpt\":\n        handleWpt(options)\n\n\ndef handleUpdate(options):\n    update.update(\n        anchors=options.anchors,\n        backrefs=options.backrefs,\n        biblio=options.biblio,\n        caniuse=options.caniuse,\n        mdn=options.mdn,\n        linkDefaults=options.linkDefaults,\n        testSuites=options.testSuites,\n        languages=options.languages,\n        wpt=options.wpt,\n        dryRun=constants.dryRun,\n        force=options.force,\n    )\n\n\ndef handleSpec(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    doc = Spec(\n        inputFilename=options.infile,\n        debug=options.debug,\n        token=options.ghToken,\n        lineNumbers=options.lineNumbers,\n    )\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    if options.byos:\n        doc.mdCommandLine.addData(\"Group\", \"byos\")\n    doc.preprocess()\n    doc.finish(outputFilename=options.outfile)\n\n\ndef handleEchidna(options, extras):\n    from . import metadata, publish\n    from .Spec import Spec\n\n    doc = Spec(inputFilename=options.infile, token=options.ghToken)\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    doc.mdCommandLine.addData(\"Prepare For TR\", \"yes\")\n    doc.preprocess()\n    addDirs = [] if options.selfContained else options.additionalDirectories\n    if options.justTar:\n        publish.prepareTar(doc, visibleTar=True, additionalDirectories=addDirs)\n    else:\n        publish.publishEchidna(\n            doc,\n            username=options.un,\n            password=options.pw,\n            decision=options.decision,\n            additionalDirectories=addDirs,\n            cc=options.cc,\n            editorial=options.editorial,\n        )\n\n\ndef handleWatch(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    # Can't have an error killing the watcher\n    constants.setErrorLevel(\"nothing\")\n    doc = Spec(inputFilename=options.infile, token=options.ghToken)\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    if options.byos:\n        doc.mdCommandLine.addData(\"Group\", \"byos\")\n    doc.watch(outputFilename=options.outfile)\n\n\ndef handleServe(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    constants.setErrorLevel(\"nothing\")\n    doc = Spec(inputFilename=options.infile, token=options.ghToken)\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    if options.byos:\n        doc.mdCommandLine.addData(\"Group\", \"byos\")\n    doc.watch(outputFilename=options.outfile, port=int(options.port))\n\n\ndef handleDebug(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    constants.setErrorLevel(\"nothing\")\n    constants.quiet = 2\n    if options.printExports:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        doc.printTargets()\n    elif options.jsonCode:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        exec(f\"print(config.printjson({options.jsonCode}))\")\n    elif options.code:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        exec(f\"print({options.code})\")\n    elif options.linkText:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        refs = doc.refs[options.linkText] + doc.refs[options.linkText + \"\\n\"]\n        constants.quiet = options.quiet\n        if not constants.quiet:\n            p(f\"Refs for '{options.linkText}':\")\n        # Get ready for JSONing\n        for ref in refs:\n            ref[\"level\"] = str(ref[\"level\"])\n        p(config.printjson(refs))\n    elif options.refreshData:\n        constants.quiet = 0\n        update.updateReadonlyDataFiles()\n        warn(\"Don't forget to bump the version number!\")\n\n\ndef handleRefs(options, extras):\n    from . import metadata\n    from .refs.ReferenceManager import ReferenceManager\n    from .Spec import Spec\n\n    constants.setErrorLevel(\"nothing\")\n    constants.quiet = 10\n    doc = Spec(inputFilename=options.infile)\n    if doc.valid:\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        rm = doc.refs\n    else:\n        rm = ReferenceManager()\n        rm.initializeRefs()\n    if options.text:\n        options.text = options.text\n    refs = rm.queryAllRefs(\n        text=options.text,\n        linkFor=options.linkFor,\n        linkType=options.linkType,\n        status=options.status,\n        spec=options.spec,\n        latestOnly=options.latestOnly,\n        exact=options.exact,\n    )\n    if constants.printMode == \"json\":\n        p(json.dumps(refs, indent=2, default=getjson))\n    else:\n        p(config.printjson(refs))\n\n\ndef handleIssuesList(options):\n    from . import issuelist\n\n    if options.printTemplate:\n        issuelist.printHelpMessage()\n    else:\n        issuelist.printIssueList(options.infile, options.outfile)\n\n\ndef handleSource(options):\n    if not options.bigText:  # If no options are given, do all options.\n        options.bigText = True\n    if options.bigText:\n        from . import fonts\n\n        font = fonts.Font()\n        fonts.replaceComments(\n            font=font, inputFilename=options.infile, outputFilename=options.outfile\n        )\n\n\ndef handleTest(options, extras):\n    from . import metadata, test\n\n    md = metadata.fromCommandLine(extras)\n    constants.setErrorLevel(\"nothing\")\n    constants.quiet = 100\n    if options.rebase:\n        test.rebase(options.testFiles, md=md)\n    else:\n        result = test.runAllTests(\n            options.testFiles, manualOnly=options.manualOnly, md=md\n        )\n        sys.exit(0 if result else 1)\n\n\ndef handleProfile(options):\n    root = f'--root=\"{options.root}\"' if options.root else \"\"\n    leaf = f'--leaf=\"{options.leaf}\"' if options.leaf else \"\"\n    if options.svgFile:\n        os.system(\n            \"time python -m cProfile -o stat.prof -m bikeshed -f spec && gprof2dot -f pstats --skew=.0001 {root} {leaf} stat.prof | dot -Tsvg -o {svg} && rm stat.prof\".format(\n                root=root, leaf=leaf, svg=options.svgFile\n            )\n        )\n    else:\n        os.system(\n            \"time python -m cProfile -o /tmp/stat.prof -m bikeshed -f spec && gprof2dot -f pstats --skew=.0001 {root} {leaf} /tmp/stat.prof | xdot &\".format(\n                root=root, leaf=leaf\n            )\n        )\n\n\ndef handleTemplate():\n    p(\n        \"\"\"<pre class='metadata'>\nTitle: Your Spec Title\nShortname: your-spec\nLevel: 1\nStatus: ED\nGroup: WGNAMEORWHATEVER\nURL: http://example.com/url-this-spec-will-live-at\nEditor: Your Name, Your Company http://example.com/your-company, your-email@example.com, http://example.com/your-personal-website\nAbstract: A short description of your spec, one or two sentences.\n</pre>\n\nIntroduction {#intro}\n=====================\n\nIntroduction here.\n\"\"\"\n    )\n\n\ndef handleWpt(options):\n    if options.template:\n        p(\n            \"\"\"\n<!DOCTYPE html>\n<meta charset=utf-8>\n<title>window.offscreenBuffering</title>\n<link rel=author title=\"AUTHOR NAME HERE\" href=\"mailto:AUTHOR EMAIL HERE\">\n<link rel=help href=\"LINK TO ROUGHLY WHAT'S BEING TESTED HERE\">\n<script src=\"/resources/testharness.js\"></script>\n<script src=\"/resources/testharnessreport.js\"></script>\n<script>\n/* Choose the test type you want: */\n\n\n/* Standard, synchronous test */\ntest(function() {\n    /* test code here */\n}, \"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\n\n\n/* Async test */\nlet t = async_test(\"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\nsomethingWithACallback( function(){ t.step(()=>{ /* test code here */}) );\nsomething.addEventListener('foo', t.step_func(()=>{ /* test code here */}));\nt.done(); // when all tests are finished running\n// or call the following if there's only one test, automatically does .done() for you\nsomething.addEventListener('foo', t.step_func_done(()=>{ /* test code here */}));\n\n\n/* Promise test */\npromise_test(function(){\n    return somePromiseFunc().then(()=>{ /* test code here */ });\n}, \"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\n// auto-finishes when the returned promise fulfills\n// or if promise should reject:\npromise_test(function(t){\n    return promise_rejects(t, new ExpectedError(), somePromiseCode());\n}, \"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\n\n\n/* \"test code here\" Asserts */\n// Only use inside of /* test code here */ regions\nassert_true(VALUE HERE, \"TEST DESCRIPTION\");\nassert_equals(ACTUAL VALUE HERE, EXPECTED VALUE HERE, \"TEST DESCRIPTION\");\n// lots more at http://web-platform-tests.org/writing-tests/testharness-api.html#list-of-assertions\n</script>\n\"\"\"\n        )\n", "import collections\nimport os\nimport re\n\nimport lxml\n\n\ndef englishFromList(items, conjunction=\"or\"):\n    # Format a list of strings into an English list.\n    items = list(items)\n    if len(items) == 1:\n        return items[0]\n    if len(items) == 2:\n        return \"{0} {2} {1}\".format(items[0], items[1], conjunction)\n    return \"{0}, {2} {1}\".format(\", \".join(items[:-1]), items[-1], conjunction)\n\n\ndef intersperse(iterable, delimiter):\n    it = iter(iterable)\n    yield next(it)\n    for x in it:\n        yield delimiter\n        yield x\n\n\ndef processTextNodes(nodes, regex, replacer):\n    \"\"\"\n    Takes an array of alternating text/objects,\n    and runs reSubObject on the text parts,\n    splicing them into the passed-in array.\n    Mutates!\n    \"\"\"\n    for i, node in enumerate(nodes):\n        # Node list always alternates between text and elements\n        if i % 2 == 0:\n            nodes[i : i + 1] = reSubObject(regex, node, replacer)\n    return nodes\n\n\ndef reSubObject(pattern, string, repl=None):\n    \"\"\"\n    like re.sub, but replacements don't have to be text;\n    returns an array of alternating unmatched text and match objects instead.\n    If repl is specified, it's called with each match object,\n    and the result then shows up in the array instead.\n    \"\"\"\n    lastEnd = 0\n    pieces = []\n    for match in pattern.finditer(string):\n        pieces.append(string[lastEnd : match.start()])\n        if repl:\n            pieces.append(repl(match))\n        else:\n            pieces.append(match)\n        lastEnd = match.end()\n    pieces.append(string[lastEnd:])\n    return pieces\n\n\ndef simplifyText(text):\n    # Remove anything that's not a name character.\n    text = text.strip().lower()\n    # I convert ( to - so foo(bar) becomes foo-bar,\n    # but then I have to remove () because there's nothing to separate,\n    # otherwise I get a double-dash in some cases.\n    text = re.sub(r\"\\(\\)\", \"\", text)\n    text = re.sub(r\"[\\s/(,]+\", \"-\", text)\n    text = re.sub(r\"[^a-z0-9_-]\", \"\", text)\n    text = text.rstrip(\"-\")\n    return text\n\n\ndef linkTextsFromElement(el):\n    from ..h import find, textContent\n\n    if el.get(\"data-lt\") == \"\":\n        return []\n    elif el.get(\"data-lt\"):\n        rawText = el.get(\"data-lt\")\n        if rawText in [\"|\", \"||\", \"|||\"]:\n            texts = [rawText]\n        else:\n            texts = [x.strip() for x in rawText.split(\"|\")]\n    else:\n        if el.tag in (\"dfn\", \"a\"):\n            texts = [textContent(el).strip()]\n        elif el.tag in (\"h2\", \"h3\", \"h4\", \"h5\", \"h6\"):\n            texts = [textContent(find(\".content\", el)).strip()]\n    if el.get(\"data-local-lt\"):\n        localTexts = [x.strip() for x in el.get(\"data-local-lt\").split(\"|\")]\n        for text in localTexts:\n            if text in texts:\n                # lt and local-lt both specify the same thing\n                raise DuplicatedLinkText(text, texts + localTexts, el)\n        texts += localTexts\n\n    texts = [re.sub(r\"\\s+\", \" \", x) for x in texts if x != \"\"]\n    return texts\n\n\nclass DuplicatedLinkText(Exception):\n    def __init__(self, offendingText, allTexts, el):\n        super().__init__()\n        self.offendingText = offendingText\n        self.allTexts = allTexts\n        self.el = el\n\n    def __unicode__(self):\n        return f\"<Text '{self.offendingText}' shows up in both lt and local-lt>\"\n\n\ndef firstLinkTextFromElement(el):\n    try:\n        texts = linkTextsFromElement(el)\n    except DuplicatedLinkText as e:\n        texts = e.allTexts\n    return texts[0] if len(texts) > 0 else None\n\n\ndef splitForValues(forValues):\n    \"\"\"\n    Splits a string of 1+ \"for\" values into an array of individual value.\n    Respects function args, etc.\n    Currently, for values are separated by commas.\n    \"\"\"\n    if forValues is None:\n        return None\n    forValues = re.sub(r\"\\s+\", \" \", forValues)\n    return [\n        value.strip()\n        for value in re.split(r\",(?![^()]*\\))\", forValues)\n        if value.strip()\n    ]\n\n\ndef groupFromKey(key, length=2):\n    \"\"\"Generates a filename-safe \"group\" from a key, of a specified length.\"\"\"\n    if key in _groupFromKeyCache:\n        return _groupFromKeyCache[key]\n    safeChars = frozenset(\"abcdefghijklmnopqrstuvwxyz0123456789\")\n    group = \"\"\n    for char in key.lower():\n        if len(group) == length:\n            _groupFromKeyCache[key] = group\n            return group\n        if char in safeChars:\n            group += char\n    else:\n        group = group.ljust(length, \"_\")\n        _groupFromKeyCache[key] = group\n        return group\n\n\n_groupFromKeyCache = {}\n\n\ndef flatten(arr):\n    for el in arr:\n        if (\n            isinstance(el, collections.Iterable)\n            and not isinstance(el, str)\n            and not lxml.etree.iselement(el)\n        ):\n            yield from flatten(el)\n        else:\n            yield el\n\n\ndef scriptPath(*pathSegs):\n    startPath = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\n    return os.path.join(startPath, *pathSegs)\n\n\ndef doEvery(s, action, lastTime=None):\n    # Takes an action every N seconds.\n    # Pass it the duration and the last time it took the action;\n    # it returns the time it last took the action\n    # (possibly just now).\n    # If you want to take action on first call,\n    # pass 0 as lastTime;\n    # otherwise it won't take action until N seconds.\n    import time\n\n    newTime = time.time()\n    if lastTime is None:\n        lastTime = newTime\n    if lastTime == 0 or newTime - lastTime > s:\n        action()\n        return newTime\n    return lastTime\n", "# pylint: disable=R1732\n\nimport io\nimport os\n\nfrom ..InputSource import InputSource\nfrom ..messages import *\nfrom .main import scriptPath\nfrom .status import splitStatus\n\n\nclass DataFileRequester:\n    def __init__(self, type=None, fallback=None):\n        self.type = type\n        if self.type not in (\"readonly\", \"latest\"):\n            raise Exception(f\"Bad value for DataFileRequester.type, got '{type}'.\")\n        # fallback is another requester, used if the main one fails.\n        self.fallback = fallback\n\n    def fetch(self, *segs, **kwargs):\n        str = kwargs.get(\"str\", False)\n        okayToFail = kwargs.get(\"okayToFail\", False)\n        fileType = kwargs.get(\"type\", self.type)\n        location = self._buildPath(segs=segs, fileType=fileType)\n        try:\n            if str:\n                with open(location, encoding=\"utf-8\") as fh:\n                    return fh.read()\n            else:\n                return open(location, encoding=\"utf-8\")\n        except OSError:\n            if self.fallback:\n                try:\n                    return self.fallback.fetch(*segs, str=str, okayToFail=okayToFail)\n                except OSError:\n                    return self._fail(location, str, okayToFail)\n            return self._fail(location, str, okayToFail)\n\n    def walkFiles(self, *segs, **kwargs):\n        fileType = kwargs.get(\"type\", self.type)\n        for _, _, files in os.walk(self._buildPath(segs, fileType=fileType)):\n            yield from files\n\n    def _buildPath(self, segs, fileType=None):\n        if fileType is None:\n            fileType = self.type\n        if fileType == \"readonly\":\n            return scriptPath(\"spec-data\", \"readonly\", *segs)\n        else:\n            return scriptPath(\"spec-data\", *segs)\n\n    def _fail(self, location, str, okayToFail):\n        if okayToFail:\n            if str:\n                return \"\"\n            else:\n                return io.StringIO(\"\")\n        raise OSError(f\"Couldn't find file '{location}'\")\n\n\ndefaultRequester = DataFileRequester(\n    type=\"latest\", fallback=DataFileRequester(type=\"readonly\")\n)\n\n\ndef retrieveBoilerplateFile(doc, name, group=None, status=None, error=True):\n    # Looks in three or four locations, in order:\n    # the folder the spec source is in, the group's boilerplate folder, the megagroup's boilerplate folder, and the generic boilerplate folder.\n    # In each location, it first looks for the file specialized on status, and then for the generic file.\n    # Filenames must be of the format NAME.include or NAME-STATUS.include\n    if group is None and doc.md.group is not None:\n        group = doc.md.group.lower()\n    if status is None:\n        if doc.md.status is not None:\n            status = doc.md.status\n        elif doc.md.rawStatus is not None:\n            status = doc.md.rawStatus\n    megaGroup, status = splitStatus(status)\n\n    searchLocally = doc.md.localBoilerplate[name]\n\n    def boilerplatePath(*segs):\n        return scriptPath(\"boilerplate\", *segs)\n\n    statusFile = f\"{name}-{status}.include\"\n    genericFile = f\"{name}.include\"\n    sources = []\n    if searchLocally:\n        sources.append(doc.inputSource.relative(statusFile))  # Can be None.\n        sources.append(doc.inputSource.relative(genericFile))\n    else:\n        for f in (statusFile, genericFile):\n            if doc.inputSource.cheaplyExists(f):\n                warn(\n                    (\n                        \"Found {0} next to the specification without a matching\\n\"\n                        + \"Local Boilerplate: {1} yes\\n\"\n                        + \"in the metadata. This include won't be found when building via a URL.\"\n                    ).format(f, name)\n                )\n                # We should remove this after giving specs time to react to the warning:\n                sources.append(doc.inputSource.relative(f))\n    if group:\n        sources.append(InputSource(boilerplatePath(group, statusFile)))\n        sources.append(InputSource(boilerplatePath(group, genericFile)))\n    if megaGroup:\n        sources.append(InputSource(boilerplatePath(megaGroup, statusFile)))\n        sources.append(InputSource(boilerplatePath(megaGroup, genericFile)))\n    sources.append(InputSource(boilerplatePath(statusFile)))\n    sources.append(InputSource(boilerplatePath(genericFile)))\n\n    # Watch all the possible sources, not just the one that got used, because if\n    # an earlier one appears, we want to rebuild.\n    doc.recordDependencies(*sources)\n\n    for source in sources:\n        if source is not None:\n            try:\n                return source.read().content\n            except OSError:\n                # That input doesn't exist.\n                pass\n    else:\n        if error:\n            die(\n                \"Couldn't find an appropriate include file for the {0} inclusion, given group='{1}' and status='{2}'.\",\n                name,\n                group,\n                status,\n            )\n        return \"\"\n", "from .stringEnum import StringEnum\n\ndryRun = False\nerrorLevel = [\"fatal\"]\nprintMode = \"console\"\nquiet = True\nasciiOnly = False\nrefStatus = StringEnum(\"current\", \"snapshot\")\nbiblioDisplay = StringEnum(\"index\", \"inline\")\nspecClass = None\ntestAnnotationURL = \"https://test.csswg.org/harness/annotate.js\"\n\n\ndef errorLevelAt(target):\n    levels = {\n        \"nothing\": 0,\n        \"fatal\": 1,\n        \"link-error\": 2,\n        \"warning\": 3,\n        \"everything\": 1000,\n    }\n    currentLevel = levels[errorLevel[0]]\n    targetLevel = levels[target]\n    return currentLevel >= targetLevel\n\n\ndef setErrorLevel(level=None):\n    if level is None:\n        level = \"fatal\"\n    errorLevel[0] = level\n", "from . import config\nfrom .h import *  # noqa: F401\nfrom .messages import *  # noqa: F401\n\n\ndef load(doc):\n    code = config.retrieveBoilerplateFile(doc, \"bs-extensions\")\n    exec(code, globals())\n", "from subprocess import PIPE, Popen\n\nfrom ..h import *\nfrom ..messages import *\n\n\ndef processTags(doc):\n    for el in findAll(\"[data-span-tag]\", doc):\n        tag = el.get(\"data-span-tag\")\n        if tag not in doc.md.inlineTagCommands:\n            die(\"Unknown inline tag '{0}' found:\\n  {1}\", tag, outerHTML(el), el=el)\n            continue\n        command = doc.md.inlineTagCommands[tag]\n        with Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True) as p:\n            out, err = p.communicate(innerHTML(el).encode(\"utf-8\"))\n            try:\n                out = out.decode(\"utf-8\")\n            except UnicodeDecodeError as e:\n                die(\n                    \"When trying to process {0}, got invalid unicode in stdout:\\n{1}\",\n                    outerHTML(el),\n                    e,\n                    el=el,\n                )\n            try:\n                err = err.decode(\"utf-8\")\n            except UnicodeDecodeError as e:\n                die(\n                    \"When trying to process {0}, got invalid unicode in stderr:\\n{1}\",\n                    outerHTML(el),\n                    e,\n                    el=el,\n                )\n            if p.returncode:\n                die(\n                    \"When trying to process {0}, got return code {1} and the following stderr:\\n{2}\",\n                    outerHTML(el),\n                    p.returncode,\n                    err,\n                    el=el,\n                )\n                continue\n            replaceContents(el, parseHTML(out))\n"], "fixing_code": ["from __future__ import annotations\n\nimport email.utils\nimport errno\nimport os\nimport sys\nimport urllib.parse\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom typing import List, Optional\n\nimport attr\nimport requests\nimport tenacity\n\nfrom . import config\nfrom .Line import Line\n\n\n@attr.s(auto_attribs=True)\nclass InputContent:\n    rawLines: List[str]\n    date: Optional[datetime.date]\n\n    @property\n    def lines(self) -> List[Line]:\n        return [Line(i, line) for i, line in enumerate(self.rawLines, 1)]\n\n    @property\n    def content(self) -> str:\n        return \"\".join(self.rawLines)\n\n\nclass InputSource:\n    \"\"\"Represents a thing that can produce specification input text.\n\n    Input can be read from stdin (\"-\"), an HTTPS URL, or a file. Other\n    InputSources can be found relative to URLs and files, and there's a context\n    manager for temporarily switching to the directory of a file InputSource.\n    \"\"\"\n\n    def __new__(cls, sourceName: str, **kwargs):\n        \"\"\"Dispatches to the right subclass.\"\"\"\n        if cls != InputSource:\n            # Only take control of calls to InputSource(...) itself.\n            return super().__new__(cls)\n\n        if sourceName == \"-\":\n            return StdinInputSource(sourceName, **kwargs)\n        if sourceName.startswith(\"https:\"):\n            return UrlInputSource(sourceName, **kwargs)\n        return FileInputSource(sourceName, **kwargs)\n\n    @abstractmethod\n    def __str__(self) -> str:\n        pass\n\n    def __repr__(self) -> str:\n        return \"{}({!r})\".format(self.__class__.__name__, str(self))\n\n    def __hash__(self):\n        return hash(str(self))\n\n    def __eq__(self, other):\n        return str(self) == str(other)\n\n    @abstractmethod\n    def read(self) -> InputContent:\n        \"\"\"Fully reads the source.\"\"\"\n\n    def hasDirectory(self) -> bool:\n        \"\"\"Only some InputSources have a directory.\"\"\"\n        return False\n\n    def directory(self) -> str:\n        \"\"\"Suitable for passing to subprocess(cwd=).\"\"\"\n        raise TypeError(\"{} instances don't have directories.\".format(type(self)))\n\n    def relative(self, _) -> Optional[InputSource]:\n        \"\"\"Resolves relativePath relative to this InputSource.\n\n        For example, InputSource(\"/foo/bar/baz.txt\").relative(\"quux/fuzzy.txt\")\n        will be InputSource(\"/foo/bar/quux/fuzzy.txt\").\n\n        If this source type can't find others relative to itself, returns None.\n        \"\"\"\n        return None\n\n    def mtime(self) -> Optional[float]:\n        \"\"\"Returns the last modification time of this source, if that's known.\"\"\"\n        return None\n\n    def cheaplyExists(self, _) -> Optional[bool]:\n        \"\"\"If it's cheap to determine, returns whether relativePath exists.\n\n        Otherwise, returns None.\n        \"\"\"\n        return None\n\n    def __getattr__(self, name):\n        \"\"\"Hack to make pylint happy, since all the attrs are defined\n        on the subclasses that __new__ dynamically dispatches to.\n        See https://stackoverflow.com/a/60731663/455535\n        \"\"\"\n        print(f\"No member '{name}' contained in InputSource.\")\n        return \"\"\n\n\nclass StdinInputSource(InputSource):\n    def __init__(self, sourceName: str):\n        assert sourceName == \"-\"\n        self.type = \"stdin\"\n        self.sourceName = sourceName\n        self.content = None\n\n    def __str__(self) -> str:\n        return \"-\"\n\n    def read(self) -> InputContent:\n        return InputContent(sys.stdin.readlines(), None)\n\n\nclass UrlInputSource(InputSource):\n    def __init__(self, sourceName: str):\n        assert sourceName.startswith(\"https:\")\n        self.sourceName = sourceName\n        self.type = \"url\"\n\n    def __str__(self) -> str:\n        return self.sourceName\n\n    @tenacity.retry(\n        reraise=True,\n        stop=tenacity.stop_after_attempt(3),\n        wait=tenacity.wait_random(1, 2),\n    )\n    def _fetch(self):\n        response = requests.get(self.sourceName, timeout=10)\n        if response.status_code == 404:\n            # This matches the OSErrors expected by older uses of\n            # FileInputSource. It skips the retry, since the server has given us\n            # a concrete, expected answer.\n            raise FileNotFoundError(errno.ENOENT, response.text, self.sourceName)\n        response.raise_for_status()\n        return response\n\n    def read(self) -> InputContent:\n        response = self._fetch()\n        date = None\n        if \"Date\" in response.headers:\n            # Use the response's Date header, although servers don't always set\n            # this according to the last change to the file.\n            date = email.utils.parsedate_to_datetime(response.headers[\"Date\"]).date()\n        return InputContent(response.text.splitlines(True), date)\n\n    def relative(self, relativePath) -> UrlInputSource:\n        return UrlInputSource(urllib.parse.urljoin(self.sourceName, relativePath))\n\n\nclass FileInputSource(InputSource):\n    def __init__(self, sourceName: str, *, chroot: bool, chrootPath: Optional[str] = None):\n        self.sourceName = sourceName\n        self.chrootPath = chrootPath\n        self.type = \"file\"\n        self.content = None\n\n        if chroot and self.chrootPath is None:\n            self.chrootPath = self.directory()\n        if self.chrootPath is not None:\n            self.sourceName = config.chrootPath(self.chrootPath, self.sourceName)\n\n    def __str__(self) -> str:\n        return self.sourceName\n\n    def read(self) -> InputContent:\n        with open(self.sourceName, encoding=\"utf-8\") as f:\n            return InputContent(\n                f.readlines(),\n                datetime.fromtimestamp(os.path.getmtime(self.sourceName)).date(),\n            )\n\n    def hasDirectory(self) -> bool:\n        return True\n\n    def directory(self) -> str:\n        return os.path.dirname(os.path.abspath(self.sourceName))\n\n    def relative(self, relativePath) -> FileInputSource:\n        return FileInputSource(os.path.join(self.directory(), relativePath), chroot=False, chrootPath=self.chrootPath)\n\n    def cheaplyExists(self, relativePath) -> bool:\n        return os.access(self.relative(relativePath).sourceName, os.R_OK)\n\n    def mtime(self) -> Optional[float]:\n        \"\"\"Returns the last modification time of this file, or None if it doesn't exist.\"\"\"\n        try:\n            return os.stat(self.sourceName).st_mtime\n        except FileNotFoundError:\n            return None\n", "import glob\nimport os\nimport sys\nfrom collections import defaultdict\nfrom functools import partial as curry\n\nfrom . import (\n    biblio,\n    boilerplate,\n    caniuse,\n    conditional,\n    config,\n    constants,\n    datablocks,\n    dfns,\n    extensions,\n    fingerprinting,\n    h,\n    headings,\n    highlight,\n    idl,\n    includes,\n    inlineTags,\n    lint,\n    markdown,\n    mdnspeclinks,\n    metadata,\n    shorthands,\n    wpt,\n)\nfrom .func import Functor\nfrom .h import *\nfrom .InputSource import FileInputSource, InputSource\nfrom .messages import *\nfrom .refs import ReferenceManager\nfrom .unsortedJunk import *\n\n\nclass Spec:\n    def __init__(\n        self,\n        inputFilename,\n        debug=False,\n        token=None,\n        lineNumbers=False,\n        fileRequester=None,\n        testing=False,\n    ):\n        self.valid = False\n        self.lineNumbers = lineNumbers\n        if lineNumbers:\n            # line-numbers are too hacky, so force this to be a dry run\n            constants.dryRun = True\n        if inputFilename is None:\n            inputFilename = findImplicitInputFile()\n        if inputFilename is None:  # still\n            die(\n                \"No input file specified, and no *.bs or *.src.html files found in current directory.\\nPlease specify an input file, or use - to pipe from STDIN.\"\n            )\n            return\n        self.inputSource = InputSource(inputFilename, chroot=constants.chroot)\n        self.transitiveDependencies = set()\n        self.debug = debug\n        self.token = token\n        self.testing = testing\n        if fileRequester is None:\n            self.dataFile = config.defaultRequester\n        else:\n            self.dataFile = fileRequester\n\n        self.md = None\n        self.mdBaseline = None\n        self.mdDocument = None\n        self.mdCommandLine = None\n        self.mdDefaults = None\n        self.mdOverridingDefaults = None\n        self.lines = []\n        self.document = None\n        self.html = None\n        self.head = None\n        self.body = None\n        self.fillContainers = None\n        self.valid = self.initializeState()\n\n    def initializeState(self):\n        self.normativeRefs = {}\n        self.informativeRefs = {}\n        self.refs = ReferenceManager(fileRequester=self.dataFile, testing=self.testing)\n        self.externalRefsUsed = defaultdict(lambda: defaultdict(dict))\n        self.md = None\n        self.mdBaseline = metadata.MetadataManager()\n        self.mdDocument = None\n        self.mdCommandLine = metadata.MetadataManager()\n        self.mdDefaults = None\n        self.mdOverridingDefaults = None\n        self.biblios = {}\n        self.typeExpansions = {}\n        self.macros = defaultdict(lambda x: \"???\")\n        self.canIUse = {}\n        self.mdnSpecLinks = {}\n        self.widl = idl.getParser()\n        self.testSuites = json.loads(self.dataFile.fetch(\"test-suites.json\", str=True))\n        self.languages = json.loads(self.dataFile.fetch(\"languages.json\", str=True))\n        self.extraStyles = defaultdict(str)\n        self.extraStyles[\"style-colors\"] = styleColors\n        self.extraStyles[\"style-darkmode\"] = styleDarkMode\n        self.extraStyles[\"style-md-lists\"] = styleMdLists\n        self.extraStyles[\"style-autolinks\"] = styleAutolinks\n        self.extraStyles[\"style-selflinks\"] = styleSelflinks\n        self.extraStyles[\"style-counters\"] = styleCounters\n        self.extraScripts = defaultdict(str)\n\n        try:\n            inputContent = self.inputSource.read()\n            self.lines = inputContent.lines\n            if inputContent.date is not None:\n                self.mdBaseline.addParsedData(\"Date\", inputContent.date)\n        except FileNotFoundError:\n            die(\n                \"Couldn't find the input file at the specified location '{0}'.\",\n                self.inputSource,\n            )\n            return False\n        except OSError:\n            die(\"Couldn't open the input file '{0}'.\", self.inputSource)\n            return False\n\n        return True\n\n    def recordDependencies(self, *inputSources):\n        self.transitiveDependencies.update(inputSources)\n\n    def preprocess(self):\n        self.transitiveDependencies.clear()\n        self.assembleDocument()\n        self.processDocument()\n\n    def assembleDocument(self):\n        # Textual hacks\n        stripBOM(self)\n        if self.lineNumbers:\n            self.lines = hackyLineNumbers(self.lines)\n        self.lines = markdown.stripComments(self.lines)\n        self.recordDependencies(self.inputSource)\n        # Extract and process metadata\n        self.lines, self.mdDocument = metadata.parse(lines=self.lines)\n        # First load the metadata sources from 'local' data\n        self.md = metadata.join(self.mdBaseline, self.mdDocument, self.mdCommandLine)\n        # Using that to determine the Group and Status, load the correct defaults.include boilerplate\n        self.mdDefaults = metadata.fromJson(\n            data=config.retrieveBoilerplateFile(self, \"defaults\", error=True),\n            source=\"defaults\",\n        )\n        self.md = metadata.join(\n            self.mdBaseline, self.mdDefaults, self.mdDocument, self.mdCommandLine\n        )\n        # Using all of that, load up the text macros so I can sub them into the computed-metadata file.\n        self.md.fillTextMacros(self.macros, doc=self)\n        jsonEscapedMacros = {k: json.dumps(v)[1:-1] for k, v in self.macros.items()}\n        computedMdText = replaceMacros(\n            config.retrieveBoilerplateFile(self, \"computed-metadata\", error=True),\n            macros=jsonEscapedMacros,\n        )\n        self.mdOverridingDefaults = metadata.fromJson(\n            data=computedMdText, source=\"computed-metadata\"\n        )\n        self.md = metadata.join(\n            self.mdBaseline,\n            self.mdDefaults,\n            self.mdOverridingDefaults,\n            self.mdDocument,\n            self.mdCommandLine,\n        )\n        # Finally, compute the \"implicit\" things.\n        self.md.computeImplicitMetadata(doc=self)\n        # And compute macros again, in case the preceding steps changed them.\n        self.md.fillTextMacros(self.macros, doc=self)\n        self.md.validate()\n        extensions.load(self)\n\n        # Initialize things\n        self.refs.initializeRefs(self)\n        self.refs.initializeBiblio()\n\n        # Deal with further <pre> blocks, and markdown\n        self.lines = datablocks.transformDataBlocks(self, self.lines)\n        self.lines = markdown.parse(\n            self.lines,\n            self.md.indent,\n            opaqueElements=self.md.opaqueElements,\n            blockElements=self.md.blockElements,\n        )\n        # Note that, currently, markdown.parse returns an array of strings, not of Line objects.\n\n        self.refs.setSpecData(self.md)\n\n        # Convert to a single string of html now, for convenience.\n        self.html = \"\".join(line.text for line in self.lines)\n        boilerplate.addHeaderFooter(self)\n        self.html = self.fixText(self.html)\n\n        # Build the document\n        self.document = parseDocument(self.html)\n        self.head = find(\"head\", self)\n        self.body = find(\"body\", self)\n        correctH1(self)\n        includes.processInclusions(self)\n        metadata.parseDoc(self)\n\n    def processDocument(self):\n        # Fill in and clean up a bunch of data\n        conditional.processConditionals(self)\n        self.fillContainers = locateFillContainers(self)\n        lint.exampleIDs(self)\n        boilerplate.addBikeshedVersion(self)\n        boilerplate.addCanonicalURL(self)\n        boilerplate.addFavicon(self)\n        boilerplate.addSpecVersion(self)\n        boilerplate.addStatusSection(self)\n        boilerplate.addLogo(self)\n        boilerplate.addCopyright(self)\n        boilerplate.addSpecMetadataSection(self)\n        boilerplate.addAbstract(self)\n        boilerplate.addExpiryNotice(self)\n        boilerplate.addObsoletionNotice(self)\n        boilerplate.addAtRisk(self)\n        addNoteHeaders(self)\n        boilerplate.removeUnwantedBoilerplate(self)\n        wpt.processWptElements(self)\n        shorthands.run(self)\n        inlineTags.processTags(self)\n        canonicalizeShortcuts(self)\n        addImplicitAlgorithms(self)\n        fixManualDefTables(self)\n        headings.processHeadings(self)\n        checkVarHygiene(self)\n        processIssuesAndExamples(self)\n        idl.markupIDL(self)\n        inlineRemoteIssues(self)\n        addImageSize(self)\n\n        # Handle all the links\n        processBiblioLinks(self)\n        processDfns(self)\n        idl.processIDL(self)\n        dfns.annotateDfns(self)\n        formatArgumentdefTables(self)\n        formatElementdefTables(self)\n        processAutolinks(self)\n        biblio.dedupBiblioReferences(self)\n        verifyUsageOfAllLocalBiblios(self)\n        caniuse.addCanIUsePanels(self)\n        boilerplate.addIndexSection(self)\n        boilerplate.addExplicitIndexes(self)\n        boilerplate.addStyles(self)\n        boilerplate.addReferencesSection(self)\n        boilerplate.addPropertyIndex(self)\n        boilerplate.addIDLSection(self)\n        boilerplate.addIssuesSection(self)\n        boilerplate.addCustomBoilerplate(self)\n        headings.processHeadings(self, \"all\")  # again\n        boilerplate.removeUnwantedBoilerplate(self)\n        boilerplate.addTOCSection(self)\n        addSelfLinks(self)\n        processAutolinks(self)\n        boilerplate.addAnnotations(self)\n        boilerplate.removeUnwantedBoilerplate(self)\n        # Add MDN panels after all IDs/anchors have been added\n        mdnspeclinks.addMdnPanels(self)\n        highlight.addSyntaxHighlighting(self)\n        boilerplate.addBikeshedBoilerplate(self)\n        fingerprinting.addTrackingVector(self)\n        fixIntraDocumentReferences(self)\n        fixInterDocumentReferences(self)\n        removeMultipleLinks(self)\n        forceCrossorigin(self)\n        lint.brokenLinks(self)\n        lint.accidental2119(self)\n        lint.missingExposed(self)\n        lint.requiredIDs(self)\n        lint.unusedInternalDfns(self)\n\n        # Any final HTML cleanups\n        cleanupHTML(self)\n        if self.md.prepTR:\n            # Don't try and override the W3C's icon.\n            for el in findAll(\"[rel ~= 'icon']\", self):\n                removeNode(el)\n            # Make sure the W3C stylesheet is after all other styles.\n            for el in findAll(\"link\", self):\n                if el.get(\"href\").startswith(\"https://www.w3.org/StyleSheets/TR\"):\n                    appendChild(find(\"head\", self), el)\n            # Ensure that all W3C links are https.\n            for el in findAll(\"a\", self):\n                href = el.get(\"href\", \"\")\n                if href.startswith(\"http://www.w3.org\") or href.startswith(\n                    \"http://lists.w3.org\"\n                ):\n                    el.set(\"href\", \"https\" + href[4:])\n                text = el.text or \"\"\n                if text.startswith(\"http://www.w3.org\") or text.startswith(\n                    \"http://lists.w3.org\"\n                ):\n                    el.text = \"https\" + text[4:]\n            # Loaded from .include files\n            extensions.BSPrepTR(self)  # pylint: disable=no-member\n\n        return self\n\n    def serialize(self):\n        try:\n            rendered = h.Serializer(\n                self.md.opaqueElements, self.md.blockElements\n            ).serialize(self.document)\n        except Exception as e:\n            die(\"{0}\", e)\n            return\n        rendered = finalHackyCleanup(rendered)\n        return rendered\n\n    def fixMissingOutputFilename(self, outputFilename):\n        if outputFilename is None:\n            # More sensible defaults!\n            if not isinstance(self.inputSource, FileInputSource):\n                outputFilename = \"-\"\n            elif self.inputSource.sourceName.endswith(\".bs\"):\n                outputFilename = self.inputSource.sourceName[0:-3] + \".html\"\n            elif self.inputSource.sourceName.endswith(\".src.html\"):\n                outputFilename = self.inputSource.sourceName[0:-9] + \".html\"\n            else:\n                outputFilename = \"-\"\n        return outputFilename\n\n    def finish(self, outputFilename=None, newline=None):\n        self.printResultMessage()\n        outputFilename = self.fixMissingOutputFilename(outputFilename)\n        rendered = self.serialize()\n        if not constants.dryRun:\n            try:\n                if outputFilename == \"-\":\n                    sys.stdout.write(rendered)\n                else:\n                    with open(\n                        outputFilename, \"w\", encoding=\"utf-8\", newline=newline\n                    ) as f:\n                        f.write(rendered)\n            except Exception as e:\n                die(\n                    \"Something prevented me from saving the output document to {0}:\\n{1}\",\n                    outputFilename,\n                    e,\n                )\n\n    def printResultMessage(self):\n        # If I reach this point, I've succeeded, but maybe with reservations.\n        fatals = messageCounts[\"fatal\"]\n        links = messageCounts[\"linkerror\"]\n        warnings = messageCounts[\"warning\"]\n        if self.lineNumbers:\n            warn(\"Because --line-numbers was used, no output was saved.\")\n        if fatals:\n            success(\"Successfully generated, but fatal errors were suppressed\")\n            return\n        if links:\n            success(\"Successfully generated, with {0} linking errors\", links)\n            return\n        if warnings:\n            success(\"Successfully generated, with warnings\")\n            return\n\n    def watch(self, outputFilename, port=None, localhost=False):\n        import time\n\n        outputFilename = self.fixMissingOutputFilename(outputFilename)\n        if self.inputSource.mtime() is None:\n            die(f\"Watch mode doesn't support {self.inputSource}\")\n        if outputFilename == \"-\":\n            die(\"Watch mode doesn't support streaming to STDOUT.\")\n            return\n\n        if port:\n            # Serve the folder on an HTTP server\n            import http.server\n            import socketserver\n            import threading\n\n            class SilentServer(http.server.SimpleHTTPRequestHandler):\n                def log_message(self, format, *args):\n                    pass\n\n            socketserver.TCPServer.allow_reuse_address = True\n            server = socketserver.TCPServer(\n                (\"localhost\" if localhost else \"\", port), SilentServer\n            )\n\n            print(f\"Serving at port {port}\")\n            thread = threading.Thread(target=server.serve_forever)\n            thread.daemon = True\n            thread.start()\n        else:\n            server = None\n\n        mdCommandLine = self.mdCommandLine\n\n        try:\n            self.preprocess()\n            self.finish(outputFilename)\n            lastInputModified = {\n                dep: dep.mtime() for dep in self.transitiveDependencies\n            }\n            p(\"==============DONE==============\")\n            try:\n                while True:\n                    # Comparing mtimes with \"!=\" handles when a file starts or\n                    # stops existing, and it's fine to rebuild if an mtime\n                    # somehow gets older.\n                    if any(\n                        input.mtime() != lastModified\n                        for input, lastModified in lastInputModified.items()\n                    ):\n                        resetSeenMessages()\n                        p(\"Source file modified. Rebuilding...\")\n                        self.initializeState()\n                        self.mdCommandLine = mdCommandLine\n                        self.preprocess()\n                        self.finish(outputFilename)\n                        lastInputModified = {\n                            dep: dep.mtime() for dep in self.transitiveDependencies\n                        }\n                        p(\"==============DONE==============\")\n                    time.sleep(1)\n            except KeyboardInterrupt:\n                p(\"Exiting~\")\n                if server:\n                    server.shutdown()\n                    thread.join()\n                sys.exit(0)\n        except Exception as e:\n            die(\"Something went wrong while watching the file:\\n{0}\", e)\n\n    def fixText(self, text, moreMacros={}):\n        # Do several textual replacements that need to happen *before* the document is parsed as h.\n\n        # If markdown shorthands are on, remove all `foo`s while processing,\n        # so their contents don't accidentally trigger other stuff.\n        # Also handle markdown escapes.\n        if \"markdown\" in self.md.markupShorthands:\n            textFunctor = MarkdownCodeSpans(text)\n        else:\n            textFunctor = Functor(text)\n\n        macros = dict(self.macros, **moreMacros)\n        textFunctor = textFunctor.map(curry(replaceMacros, macros=macros))\n        textFunctor = textFunctor.map(fixTypography)\n        if \"css\" in self.md.markupShorthands:\n            textFunctor = textFunctor.map(replaceAwkwardCSSShorthands)\n\n        return textFunctor.extract()\n\n    def printTargets(self):\n        p(\"Exported terms:\")\n        for el in findAll(\"[data-export]\", self):\n            for term in config.linkTextsFromElement(el):\n                p(\"  \" + term)\n        p(\"Unexported terms:\")\n        for el in findAll(\"[data-noexport]\", self):\n            for term in config.linkTextsFromElement(el):\n                p(\"  \" + term)\n\n    def isOpaqueElement(self, el):\n        if el.tag in self.md.opaqueElements:\n            return True\n        if el.get(\"data-opaque\") is not None:\n            return True\n        return False\n\n\ndef findImplicitInputFile():\n    \"\"\"\n    Find what input file the user *probably* wants to use,\n    by scanning the current folder.\n    In preference order:\n    1. index.bs\n    2. Overview.bs\n    3. the first file with a .bs extension\n    4. the first file with a .src.html extension\n    \"\"\"\n\n    if os.path.isfile(\"index.bs\"):\n        return \"index.bs\"\n    if os.path.isfile(\"Overview.bs\"):\n        return \"Overview.bs\"\n\n    allBs = glob.glob(\"*.bs\")\n    if allBs:\n        return allBs[0]\n\n    allHtml = glob.glob(\"*.src.html\")\n    if allHtml:\n        return allHtml[0]\n\n    return None\n\n\nconstants.specClass = Spec\n\nstyleColors = \"\"\"\n/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */\n:root {\n    color-scheme: light dark;\n\n    --text: black;\n    --bg: white;\n\n    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);\n\n    --logo-bg: #1a5e9a;\n    --logo-active-bg: #c00;\n    --logo-text: white;\n\n    --tocnav-normal-text: #707070;\n    --tocnav-normal-bg: var(--bg);\n    --tocnav-hover-text: var(--tocnav-normal-text);\n    --tocnav-hover-bg: #f8f8f8;\n    --tocnav-active-text: #c00;\n    --tocnav-active-bg: var(--tocnav-normal-bg);\n\n    --tocsidebar-text: var(--text);\n    --tocsidebar-bg: #f7f8f9;\n    --tocsidebar-shadow: rgba(0,0,0,.1);\n    --tocsidebar-heading-text: hsla(203,20%,40%,.7);\n\n    --toclink-text: var(--text);\n    --toclink-underline: #3980b5;\n    --toclink-visited-text: var(--toclink-text);\n    --toclink-visited-underline: #054572;\n\n    --heading-text: #005a9c;\n\n    --hr-text: var(--text);\n\n    --algo-border: #def;\n\n    --del-text: red;\n    --del-bg: transparent;\n    --ins-text: #080;\n    --ins-bg: transparent;\n\n    --a-normal-text: #034575;\n    --a-normal-underline: #bbb;\n    --a-visited-text: var(--a-normal-text);\n    --a-visited-underline: #707070;\n    --a-hover-bg: rgba(75%, 75%, 75%, .25);\n    --a-active-text: #c00;\n    --a-active-underline: #c00;\n\n    --blockquote-border: silver;\n    --blockquote-bg: transparent;\n    --blockquote-text: currentcolor;\n\n    --issue-border: #e05252;\n    --issue-bg: #fbe9e9;\n    --issue-text: var(--text);\n    --issueheading-text: #831616;\n\n    --example-border: #e0cb52;\n    --example-bg: #fcfaee;\n    --example-text: var(--text);\n    --exampleheading-text: #574b0f;\n\n    --note-border: #52e052;\n    --note-bg: #e9fbe9;\n    --note-text: var(--text);\n    --noteheading-text: hsl(120, 70%, 30%);\n    --notesummary-underline: silver;\n\n    --assertion-border: #aaa;\n    --assertion-bg: #eee;\n    --assertion-text: black;\n\n    --advisement-border: orange;\n    --advisement-bg: #fec;\n    --advisement-text: var(--text);\n    --advisementheading-text: #b35f00;\n\n    --warning-border: red;\n    --warning-bg: hsla(40,100%,50%,0.95);\n    --warning-text: var(--text);\n\n    --amendment-border: #330099;\n    --amendment-bg: #F5F0FF;\n    --amendment-text: var(--text);\n    --amendmentheading-text: #220066;\n\n    --def-border: #8ccbf2;\n    --def-bg: #def;\n    --def-text: var(--text);\n    --defrow-border: #bbd7e9;\n\n    --datacell-border: silver;\n\n    --indexinfo-text: #707070;\n\n    --indextable-hover-text: black;\n    --indextable-hover-bg: #f7f8f9;\n\n    --outdatedspec-bg: rgba(0, 0, 0, .5);\n    --outdatedspec-text: black;\n    --outdated-bg: maroon;\n    --outdated-text: white;\n    --outdated-shadow: red;\n\n    --editedrec-bg: darkorange;\n}\"\"\"\n\nstyleDarkMode = \"\"\"\n@media (prefers-color-scheme: dark) {\n    :root {\n        --text: #ddd;\n        --bg: black;\n\n        --unofficial-watermark: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E\");\n\n        --logo-bg: #1a5e9a;\n        --logo-active-bg: #c00;\n        --logo-text: white;\n\n        --tocnav-normal-text: #999;\n        --tocnav-normal-bg: var(--bg);\n        --tocnav-hover-text: var(--tocnav-normal-text);\n        --tocnav-hover-bg: #080808;\n        --tocnav-active-text: #f44;\n        --tocnav-active-bg: var(--tocnav-normal-bg);\n\n        --tocsidebar-text: var(--text);\n        --tocsidebar-bg: #080808;\n        --tocsidebar-shadow: rgba(255,255,255,.1);\n        --tocsidebar-heading-text: hsla(203,20%,40%,.7);\n\n        --toclink-text: var(--text);\n        --toclink-underline: #6af;\n        --toclink-visited-text: var(--toclink-text);\n        --toclink-visited-underline: #054572;\n\n        --heading-text: #8af;\n\n        --hr-text: var(--text);\n\n        --algo-border: #456;\n\n        --del-text: #f44;\n        --del-bg: transparent;\n        --ins-text: #4a4;\n        --ins-bg: transparent;\n\n        --a-normal-text: #6af;\n        --a-normal-underline: #555;\n        --a-visited-text: var(--a-normal-text);\n        --a-visited-underline: var(--a-normal-underline);\n        --a-hover-bg: rgba(25%, 25%, 25%, .2);\n        --a-active-text: #f44;\n        --a-active-underline: var(--a-active-text);\n\n        --borderedblock-bg: rgba(255, 255, 255, .05);\n\n        --blockquote-border: silver;\n        --blockquote-bg: var(--borderedblock-bg);\n        --blockquote-text: currentcolor;\n\n        --issue-border: #e05252;\n        --issue-bg: var(--borderedblock-bg);\n        --issue-text: var(--text);\n        --issueheading-text: hsl(0deg, 70%, 70%);\n\n        --example-border: hsl(50deg, 90%, 60%);\n        --example-bg: var(--borderedblock-bg);\n        --example-text: var(--text);\n        --exampleheading-text: hsl(50deg, 70%, 70%);\n\n        --note-border: hsl(120deg, 100%, 35%);\n        --note-bg: var(--borderedblock-bg);\n        --note-text: var(--text);\n        --noteheading-text: hsl(120, 70%, 70%);\n        --notesummary-underline: silver;\n\n        --assertion-border: #444;\n        --assertion-bg: var(--borderedblock-bg);\n        --assertion-text: var(--text);\n\n        --advisement-border: orange;\n        --advisement-bg: #222218;\n        --advisement-text: var(--text);\n        --advisementheading-text: #f84;\n\n        --warning-border: red;\n        --warning-bg: hsla(40,100%,20%,0.95);\n        --warning-text: var(--text);\n\n        --amendment-border: #330099;\n        --amendment-bg: #080010;\n        --amendment-text: var(--text);\n        --amendmentheading-text: #cc00ff;\n\n        --def-border: #8ccbf2;\n        --def-bg: #080818;\n        --def-text: var(--text);\n        --defrow-border: #136;\n\n        --datacell-border: silver;\n\n        --indexinfo-text: #aaa;\n\n        --indextable-hover-text: var(--text);\n        --indextable-hover-bg: #181818;\n\n        --outdatedspec-bg: rgba(255, 255, 255, .5);\n        --outdatedspec-text: black;\n        --outdated-bg: maroon;\n        --outdated-text: white;\n        --outdated-shadow: red;\n\n        --editedrec-bg: darkorange;\n    }\n    /* In case a transparent-bg image doesn't expect to be on a dark bg,\n       which is quite common in practice... */\n    img { background: white; }\n}\"\"\"\n\nstyleMdLists = \"\"\"\n/* This is a weird hack for me not yet following the commonmark spec\n   regarding paragraph and lists. */\n[data-md] > :first-child {\n    margin-top: 0;\n}\n[data-md] > :last-child {\n    margin-bottom: 0;\n}\"\"\"\n\nstyleAutolinks = \"\"\"\n.css.css, .property.property, .descriptor.descriptor {\n    color: var(--a-normal-text);\n    font-size: inherit;\n    font-family: inherit;\n}\n.css::before, .property::before, .descriptor::before {\n    content: \"\u2018\";\n}\n.css::after, .property::after, .descriptor::after {\n    content: \"\u2019\";\n}\n.property, .descriptor {\n    /* Don't wrap property and descriptor names */\n    white-space: nowrap;\n}\n.type { /* CSS value <type> */\n    font-style: italic;\n}\npre .property::before, pre .property::after {\n    content: \"\";\n}\n[data-link-type=\"property\"]::before,\n[data-link-type=\"propdesc\"]::before,\n[data-link-type=\"descriptor\"]::before,\n[data-link-type=\"value\"]::before,\n[data-link-type=\"function\"]::before,\n[data-link-type=\"at-rule\"]::before,\n[data-link-type=\"selector\"]::before,\n[data-link-type=\"maybe\"]::before {\n    content: \"\u2018\";\n}\n[data-link-type=\"property\"]::after,\n[data-link-type=\"propdesc\"]::after,\n[data-link-type=\"descriptor\"]::after,\n[data-link-type=\"value\"]::after,\n[data-link-type=\"function\"]::after,\n[data-link-type=\"at-rule\"]::after,\n[data-link-type=\"selector\"]::after,\n[data-link-type=\"maybe\"]::after {\n    content: \"\u2019\";\n}\n\n[data-link-type].production::before,\n[data-link-type].production::after,\n.prod [data-link-type]::before,\n.prod [data-link-type]::after {\n    content: \"\";\n}\n\n[data-link-type=element],\n[data-link-type=element-attr] {\n    font-family: Menlo, Consolas, \"DejaVu Sans Mono\", monospace;\n    font-size: .9em;\n}\n[data-link-type=element]::before { content: \"<\" }\n[data-link-type=element]::after  { content: \">\" }\n\n[data-link-type=biblio] {\n    white-space: pre;\n}\"\"\"\n\nstyleSelflinks = \"\"\"\n:root {\n    --selflink-text: white;\n    --selflink-bg: gray;\n    --selflink-hover-text: black;\n}\n.heading, .issue, .note, .example, li, dt {\n    position: relative;\n}\na.self-link {\n    position: absolute;\n    top: 0;\n    left: calc(-1 * (3.5rem - 26px));\n    width: calc(3.5rem - 26px);\n    height: 2em;\n    text-align: center;\n    border: none;\n    transition: opacity .2s;\n    opacity: .5;\n}\na.self-link:hover {\n    opacity: 1;\n}\n.heading > a.self-link {\n    font-size: 83%;\n}\nli > a.self-link {\n    left: calc(-1 * (3.5rem - 26px) - 2em);\n}\ndfn > a.self-link {\n    top: auto;\n    left: auto;\n    opacity: 0;\n    width: 1.5em;\n    height: 1.5em;\n    background: var(--selflink-bg);\n    color: var(--selflink-text);\n    font-style: normal;\n    transition: opacity .2s, background-color .2s, color .2s;\n}\ndfn:hover > a.self-link {\n    opacity: 1;\n}\ndfn > a.self-link:hover {\n    color: var(--selflink-hover-text);\n}\n\na.self-link::before            { content: \"\u00b6\"; }\n.heading > a.self-link::before { content: \"\u00a7\"; }\ndfn > a.self-link::before      { content: \"#\"; }\n\"\"\"\nstyleDarkMode += \"\"\"\n@media (prefers-color-scheme: dark) {\n    :root {\n        --selflink-text: black;\n        --selflink-bg: silver;\n        --selflink-hover-text: white;\n    }\n}\n\"\"\"\n\n\nstyleCounters = \"\"\"\nbody {\n    counter-reset: example figure issue;\n}\n.issue {\n    counter-increment: issue;\n}\n.issue:not(.no-marker)::before {\n    content: \"Issue \" counter(issue);\n}\n\n.example {\n    counter-increment: example;\n}\n.example:not(.no-marker)::before {\n    content: \"Example \" counter(example);\n}\n.invalid.example:not(.no-marker)::before,\n.illegal.example:not(.no-marker)::before {\n    content: \"Invalid Example\" counter(example);\n}\n\nfigcaption {\n    counter-increment: figure;\n}\nfigcaption:not(.no-marker)::before {\n    content: \"Figure \" counter(figure) \" \";\n}\"\"\"\n", "import argparse\nimport json\nimport os\nimport sys\n\nfrom . import config, constants, update\nfrom .config.printjson import getjson\nfrom .messages import *\n\n\ndef main():\n    # Hack around argparse's lack of optional subparsers\n    if len(sys.argv) == 1:\n        sys.argv.append(\"spec\")\n\n    try:\n        with open(config.scriptPath(\"..\", \"semver.txt\")) as fh:\n            semver = fh.read().strip()\n            semverText = f\"Bikeshed v{semver}: \"\n    except FileNotFoundError:\n        semver = \"???\"\n        semverText = \"\"\n\n    argparser = argparse.ArgumentParser(\n        description=f\"{semverText}Processes spec source files into valid HTML.\"\n    )\n    argparser.add_argument(\"--version\", action=\"version\", version=semver)\n    argparser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        dest=\"quiet\",\n        action=\"count\",\n        default=0,\n        help=\"Silences one level of message, least-important first.\",\n    )\n    argparser.add_argument(\n        \"-s\",\n        \"--silent\",\n        dest=\"silent\",\n        action=\"store_true\",\n        help=\"Shorthand for 'as many -q as you need to shut it up'\",\n    )\n    argparser.add_argument(\n        \"-f\",\n        \"--force\",\n        dest=\"errorLevel\",\n        action=\"store_const\",\n        const=\"nothing\",\n        help=\"Force the preprocessor to run to completion; fatal errors don't stop processing.\",\n    )\n    argparser.add_argument(\n        \"-d\",\n        \"--dry-run\",\n        dest=\"dryRun\",\n        action=\"store_true\",\n        help=\"Prevents the processor from actually saving anything to disk, but otherwise fully runs.\",\n    )\n    argparser.add_argument(\n        \"-a\",\n        \"--ascii-only\",\n        dest=\"asciiOnly\",\n        action=\"store_true\",\n        help=\"Force all Bikeshed messages to be ASCII-only.\",\n    )\n    argparser.add_argument(\n        \"--print\",\n        dest=\"printMode\",\n        action=\"store\",\n        default=None,\n        help=\"Print mode. Options are 'plain' (just text), 'console' (colored with console color codes), 'markup', and 'json'. Defaults to 'console'.\",\n    )\n    argparser.add_argument(\n        \"--die-on\",\n        dest=\"errorLevel\",\n        choices=[\"nothing\", \"fatal\", \"link-error\", \"warning\", \"everything\"],\n        help=\"Determines what sorts of errors cause Bikeshed to die (quit immediately with an error status code). Default is 'fatal'; the -f flag is a shorthand for 'nothing'\",\n    )\n    argparser.add_argument(\n        \"--allow-nonlocal-files\",\n        dest=\"allowNonlocalFiles\",\n        action=\"store_true\",\n        help=\"Allows Bikeshed to see/include files from folders higher than the one your source document is in.\"\n    )\n    argparser.add_argument(\n        \"--allow-execute\",\n        dest=\"allowExecute\",\n        action=\"store_true\",\n        help=\"Allow some features to execute arbitrary code from outside the Bikeshed codebase.\"\n    )\n\n    subparsers = argparser.add_subparsers(title=\"Subcommands\", dest=\"subparserName\")\n\n    specParser = subparsers.add_parser(\n        \"spec\", help=\"Process a spec source file into a valid output file.\"\n    )\n    specParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    specParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n    specParser.add_argument(\n        \"--debug\",\n        dest=\"debug\",\n        action=\"store_true\",\n        help=\"Switches on some debugging tools. Don't use for production!\",\n    )\n    specParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    specParser.add_argument(\n        \"--byos\",\n        dest=\"byos\",\n        action=\"store_true\",\n        help=\"Bring-Your-Own-Spec: turns off all the Bikeshed auto-niceties, so you can piecemeal its features into your existing doc instead. Experimental, let me know if things get crashy or weird.\",\n    )\n    specParser.add_argument(\n        \"-l\",\n        \"--line-numbers\",\n        dest=\"lineNumbers\",\n        action=\"store_true\",\n        help=\"Hacky support for outputting line numbers on all error messages. Disables output, as this is hacky and might mess up your source.\",\n    )\n\n    echidnaParser = subparsers.add_parser(\n        \"echidna\",\n        help=\"Process a spec source file into a valid output file and publish it according to certain automatic protocols.\",\n    )\n    echidnaParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    echidnaParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    echidnaParser.add_argument(\n        \"--u\", dest=\"un\", metavar=\"USERNAME\", required=False, help=\"W3C username.\"\n    )\n    echidnaParser.add_argument(\n        \"--p\", dest=\"pw\", metavar=\"PASSWORD\", required=False, help=\"W3C password.\"\n    )\n    echidnaParser.add_argument(\n        \"--decision\",\n        dest=\"decision\",\n        metavar=\"DECISION_URL\",\n        required=False,\n        help=\"URL recording the decision to publish.\",\n    )\n    echidnaParser.add_argument(\n        \"--editorial\",\n        dest=\"editorial\",\n        action=\"store_true\",\n        required=False,\n        help=\"Flags update as editorial.\",\n    )\n    echidnaParser.add_argument(\n        \"--cc\",\n        dest=\"cc\",\n        metavar=\"EMAIL\",\n        required=False,\n        help=\"Comma-separated list of email addresses to ping with the publication status when complete.\",\n    )\n    echidnaParser.add_argument(\n        \"--additional-directories\",\n        dest=\"additionalDirectories\",\n        required=False,\n        nargs=\"*\",\n        help=\"Directories to bundle in the tar file. Defaults to examples/, diagrams/, and images/.\",\n    )\n    echidnaParser.add_argument(\n        \"--self-contained\",\n        dest=\"selfContained\",\n        action=\"store_true\",\n        help=\"The spec is self-contained, do not bundle any extra directories in the tar file.\",\n    )\n    echidnaParser.add_argument(\"--just-tar\", dest=\"justTar\", action=\"store_true\")\n\n    watchParser = subparsers.add_parser(\n        \"watch\",\n        help=\"Process a spec source file into a valid output file, automatically rebuilding when it changes.\",\n    )\n    watchParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    watchParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n    watchParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    watchParser.add_argument(\n        \"--byos\",\n        dest=\"byos\",\n        action=\"store_true\",\n        help=\"Bring-Your-Own-Spec: turns off all the Bikeshed auto-niceties, so you can piecemeal its features into your existing doc instead. Experimental, let me know if things get crashy or weird.\",\n    )\n\n    serveParser = subparsers.add_parser(\n        \"serve\", help=\"Identical to 'watch', but also serves the folder on localhost.\"\n    )\n    serveParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    serveParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n    serveParser.add_argument(\n        \"--port\",\n        dest=\"port\",\n        nargs=\"?\",\n        default=\"8000\",\n        help=\"Specify the port to serve it over.\",\n    )\n    serveParser.add_argument(\n        \"--localhost\",\n        dest=\"localhost\",\n        action=\"store_true\",\n        help=\"Only allow connections from localhost.\",\n    )\n    serveParser.add_argument(\n        \"--gh-token\",\n        dest=\"ghToken\",\n        nargs=\"?\",\n        help=\"GitHub access token. Useful to avoid API rate limits. Generate tokens: https://github.com/settings/tokens.\",\n    )\n    serveParser.add_argument(\n        \"--byos\",\n        dest=\"byos\",\n        action=\"store_true\",\n        help=\"Bring-Your-Own-Spec: turns off all the Bikeshed auto-niceties, so you can piecemeal its features into your existing doc instead. Experimental, let me know if things get crashy or weird.\",\n    )\n\n    updateParser = subparsers.add_parser(\n        \"update\",\n        help=\"Update supporting files (those in /spec-data).\",\n        epilog=\"If no options are specified, everything is downloaded.\",\n    )\n    updateParser.add_argument(\n        \"--skip-manifest\",\n        dest=\"force\",\n        action=\"store_true\",\n        help=\"Forces Bikeshed to do a full update manually, rather than using the manifest to get the preprocessed update (which can be several minutes old).\",\n    )\n    updateParser.add_argument(\n        \"--anchors\", action=\"store_true\", help=\"Download crossref anchor data.\"\n    )\n    updateParser.add_argument(\n        \"--backrefs\", action=\"store_true\", help=\"Download link backref data.\"\n    )\n    updateParser.add_argument(\n        \"--biblio\", action=\"store_true\", help=\"Download biblio data.\"\n    )\n    updateParser.add_argument(\n        \"--caniuse\", action=\"store_true\", help=\"Download Can I Use... data.\"\n    )\n    updateParser.add_argument(\n        \"--mdn\", action=\"store_true\", help=\"Download MDN Spec Links... data.\"\n    )\n    updateParser.add_argument(\n        \"--link-defaults\",\n        dest=\"linkDefaults\",\n        action=\"store_true\",\n        help=\"Download link default data.\",\n    )\n    updateParser.add_argument(\n        \"--test-suites\",\n        dest=\"testSuites\",\n        action=\"store_true\",\n        help=\"Download test suite data.\",\n    )\n    updateParser.add_argument(\n        \"--languages\",\n        dest=\"languages\",\n        action=\"store_true\",\n        help=\"Download language/translation data.\",\n    )\n    updateParser.add_argument(\n        \"--wpt\",\n        dest=\"wpt\",\n        action=\"store_true\",\n        help=\"Download web-platform-tests data.\",\n    )\n\n    issueParser = subparsers.add_parser(\n        \"issues-list\",\n        help=\"Process a plain-text issues file into HTML. Call with no args to see an example input text.\",\n    )\n    issueParser.add_argument(\n        \"-t\",\n        dest=\"printTemplate\",\n        action=\"store_true\",\n        help=\"Output example Issues List template.\",\n    )\n    issueParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the plain-text issue file.\"\n    )\n    issueParser.add_argument(\n        \"outfile\",\n        nargs=\"?\",\n        default=None,\n        help=\"Path to the output file. Default is file of the same name as input, with .html.\",\n    )\n\n    debugParser = subparsers.add_parser(\"debug\", help=\"Run various debugging commands.\")\n    debugParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    debugCommands = debugParser.add_mutually_exclusive_group(required=True)\n    debugCommands.add_argument(\n        \"--print-exports\",\n        dest=\"printExports\",\n        action=\"store_true\",\n        help=\"Prints those terms that will be exported for cross-ref purposes.\",\n    )\n    debugCommands.add_argument(\n        \"--print-refs-for\",\n        dest=\"linkText\",\n        help=\"Prints the ref data for a given link text.\",\n    )\n    debugCommands.add_argument(\n        \"--print\", dest=\"code\", help=\"Runs the specified code and prints it.\"\n    )\n    debugCommands.add_argument(\n        \"--print-json\",\n        dest=\"jsonCode\",\n        help=\"Runs the specified code and prints it as formatted JSON.\",\n    )\n    debugCommands.add_argument(\n        \"--refresh-data\",\n        dest=\"refreshData\",\n        action=\"store_true\",\n        help=\"Clobbers the readonly data files with the mutable ones.\",\n    )\n\n    refParser = subparsers.add_parser(\"refs\", help=\"Search Bikeshed's ref database.\")\n    refParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    refParser.add_argument(\"--text\", dest=\"text\", default=None)\n    refParser.add_argument(\"--type\", dest=\"linkType\", default=None)\n    refParser.add_argument(\"--for\", dest=\"linkFor\", default=None)\n    refParser.add_argument(\"--spec\", dest=\"spec\", default=None)\n    refParser.add_argument(\"--status\", dest=\"status\", default=None)\n    refParser.add_argument(\n        \"--exact\",\n        dest=\"exact\",\n        action=\"store_true\",\n        help=\"Only search for the exact text provided; don't apply Bikeshed's automatic conjugation help for plurals/etc.\",\n    )\n    refParser.add_argument(\n        \"--latest-only\",\n        dest=\"latestOnly\",\n        action=\"store_true\",\n        help=\"Apply Bikeshed's logic for only returning the latest version of a given ref when it exists in multiple levels of a spec.\",\n    )\n\n    sourceParser = subparsers.add_parser(\n        \"source\", help=\"Tools for formatting the *source* document.\"\n    )\n    sourceParser.add_argument(\n        \"--big-text\",\n        dest=\"bigText\",\n        action=\"store_true\",\n        help=\"Finds HTML comments containing 'Big Text: foo' and turns them into comments containing 'foo' in big text.\",\n    )\n    sourceParser.add_argument(\n        \"infile\", nargs=\"?\", default=None, help=\"Path to the source file.\"\n    )\n    sourceParser.add_argument(\n        \"outfile\", nargs=\"?\", default=None, help=\"Path to the output file.\"\n    )\n\n    testParser = subparsers.add_parser(\n        \"test\", help=\"Tools for running Bikeshed's testsuite.\"\n    )\n    testParser.add_argument(\n        \"--rebase\",\n        default=False,\n        action=\"store_true\",\n        help=\"Rebase the specified files.\",\n    )\n    testParser.add_argument(\n        \"--manual-only\",\n        dest=\"manualOnly\",\n        default=False,\n        action=\"store_true\",\n        help=\"Skip testing the real-world files in the repo, and only run the manually-written ones.\",\n    )\n    testParser.add_argument(\n        \"testFiles\",\n        default=[],\n        metavar=\"FILE\",\n        nargs=\"*\",\n        help=\"Run these tests. If called with no args, tests everything.\",\n    )\n\n    profileParser = subparsers.add_parser(\n        \"profile\",\n        help=\"Profiling Bikeshed. Needs graphviz, gprof2dot, and xdot installed.\",\n    )\n    profileParser.add_argument(\n        \"--root\",\n        dest=\"root\",\n        default=None,\n        metavar=\"ROOTFUNC\",\n        help=\"Prune the graph to start with the specified root node.\",\n    )\n    profileParser.add_argument(\n        \"--leaf\",\n        dest=\"leaf\",\n        default=None,\n        metavar=\"LEAFFUNC\",\n        help=\"Prune the graph to only show ancestors of the specified leaf node.\",\n    )\n    profileParser.add_argument(\n        \"--svg\",\n        dest=\"svgFile\",\n        default=None,\n        help=\"Save the graph to a specified SVG file, rather than outputting with xdot immediately.\",\n    )\n\n    subparsers.add_parser(\n        \"template\", help=\"Outputs a skeleton .bs file for you to start with.\"\n    )\n\n    wptParser = subparsers.add_parser(\n        \"wpt\", help=\"Tools for writing Web Platform Tests.\"\n    )\n    wptParser.add_argument(\n        \"--template\",\n        default=False,\n        action=\"store_true\",\n        help=\"Outputs a skeleton WPT file for you to start with.\",\n    )\n\n    options, extras = argparser.parse_known_args()\n\n    constants.quiet = options.quiet\n    if options.silent:\n        constants.quiet = float(\"infinity\")\n    constants.setErrorLevel(options.errorLevel)\n    constants.dryRun = options.dryRun\n    constants.asciiOnly = options.asciiOnly\n    if options.printMode is None:\n        if \"NO_COLOR\" in os.environ or os.environ.get(\"TERM\") == \"dumb\":\n            constants.printMode = \"plain\"\n        else:\n            constants.printMode = \"console\"\n    else:\n        constants.printMode = options.printMode\n    constants.chroot = not options.allowNonlocalFiles\n    constants.executeCode = options.allowExecute\n\n    update.fixupDataFiles()\n    if options.subparserName == \"update\":\n        handleUpdate(options)\n    elif options.subparserName == \"spec\":\n        handleSpec(options, extras)\n    elif options.subparserName == \"echidna\":\n        handleEchidna(options, extras)\n    elif options.subparserName == \"watch\":\n        handleWatch(options, extras)\n    elif options.subparserName == \"serve\":\n        handleServe(options, extras)\n    elif options.subparserName == \"debug\":\n        handleDebug(options, extras)\n    elif options.subparserName == \"refs\":\n        handleRefs(options, extras)\n    elif options.subparserName == \"issues-list\":\n        handleIssuesList(options)\n    elif options.subparserName == \"source\":\n        handleSource(options)\n    elif options.subparserName == \"test\":\n        handleTest(options, extras)\n    elif options.subparserName == \"profile\":\n        handleProfile(options)\n    elif options.subparserName == \"template\":\n        handleTemplate()\n    elif options.subparserName == \"wpt\":\n        handleWpt(options)\n\n\ndef handleUpdate(options):\n    update.update(\n        anchors=options.anchors,\n        backrefs=options.backrefs,\n        biblio=options.biblio,\n        caniuse=options.caniuse,\n        mdn=options.mdn,\n        linkDefaults=options.linkDefaults,\n        testSuites=options.testSuites,\n        languages=options.languages,\n        wpt=options.wpt,\n        dryRun=constants.dryRun,\n        force=options.force,\n    )\n\n\ndef handleSpec(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    doc = Spec(\n        inputFilename=options.infile,\n        debug=options.debug,\n        token=options.ghToken,\n        lineNumbers=options.lineNumbers,\n    )\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    if options.byos:\n        doc.mdCommandLine.addData(\"Group\", \"byos\")\n    doc.preprocess()\n    doc.finish(outputFilename=options.outfile)\n\n\ndef handleEchidna(options, extras):\n    from . import metadata, publish\n    from .Spec import Spec\n\n    doc = Spec(inputFilename=options.infile, token=options.ghToken)\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    doc.mdCommandLine.addData(\"Prepare For TR\", \"yes\")\n    doc.preprocess()\n    addDirs = [] if options.selfContained else options.additionalDirectories\n    if options.justTar:\n        publish.prepareTar(doc, visibleTar=True, additionalDirectories=addDirs)\n    else:\n        publish.publishEchidna(\n            doc,\n            username=options.un,\n            password=options.pw,\n            decision=options.decision,\n            additionalDirectories=addDirs,\n            cc=options.cc,\n            editorial=options.editorial,\n        )\n\n\ndef handleWatch(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    # Can't have an error killing the watcher\n    constants.setErrorLevel(\"nothing\")\n    doc = Spec(inputFilename=options.infile, token=options.ghToken)\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    if options.byos:\n        doc.mdCommandLine.addData(\"Group\", \"byos\")\n    doc.watch(outputFilename=options.outfile)\n\n\ndef handleServe(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    constants.setErrorLevel(\"nothing\")\n    doc = Spec(inputFilename=options.infile, token=options.ghToken)\n    doc.mdCommandLine = metadata.fromCommandLine(extras)\n    if options.byos:\n        doc.mdCommandLine.addData(\"Group\", \"byos\")\n    doc.watch(outputFilename=options.outfile, port=int(options.port))\n\n\ndef handleDebug(options, extras):\n    from . import metadata\n    from .Spec import Spec\n\n    constants.setErrorLevel(\"nothing\")\n    constants.quiet = 2\n    if options.printExports:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        doc.printTargets()\n    elif options.jsonCode:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        exec(f\"print(config.printjson({options.jsonCode}))\")\n    elif options.code:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        exec(f\"print({options.code})\")\n    elif options.linkText:\n        doc = Spec(inputFilename=options.infile)\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        refs = doc.refs[options.linkText] + doc.refs[options.linkText + \"\\n\"]\n        constants.quiet = options.quiet\n        if not constants.quiet:\n            p(f\"Refs for '{options.linkText}':\")\n        # Get ready for JSONing\n        for ref in refs:\n            ref[\"level\"] = str(ref[\"level\"])\n        p(config.printjson(refs))\n    elif options.refreshData:\n        constants.quiet = 0\n        update.updateReadonlyDataFiles()\n        warn(\"Don't forget to bump the version number!\")\n\n\ndef handleRefs(options, extras):\n    from . import metadata\n    from .refs.ReferenceManager import ReferenceManager\n    from .Spec import Spec\n\n    constants.setErrorLevel(\"nothing\")\n    constants.quiet = 10\n    doc = Spec(inputFilename=options.infile)\n    if doc.valid:\n        doc.mdCommandLine = metadata.fromCommandLine(extras)\n        doc.preprocess()\n        rm = doc.refs\n    else:\n        rm = ReferenceManager()\n        rm.initializeRefs()\n    if options.text:\n        options.text = options.text\n    refs = rm.queryAllRefs(\n        text=options.text,\n        linkFor=options.linkFor,\n        linkType=options.linkType,\n        status=options.status,\n        spec=options.spec,\n        latestOnly=options.latestOnly,\n        exact=options.exact,\n    )\n    if constants.printMode == \"json\":\n        p(json.dumps(refs, indent=2, default=getjson))\n    else:\n        p(config.printjson(refs))\n\n\ndef handleIssuesList(options):\n    from . import issuelist\n\n    if options.printTemplate:\n        issuelist.printHelpMessage()\n    else:\n        issuelist.printIssueList(options.infile, options.outfile)\n\n\ndef handleSource(options):\n    if not options.bigText:  # If no options are given, do all options.\n        options.bigText = True\n    if options.bigText:\n        from . import fonts\n\n        font = fonts.Font()\n        fonts.replaceComments(\n            font=font, inputFilename=options.infile, outputFilename=options.outfile\n        )\n\n\ndef handleTest(options, extras):\n    from . import metadata, test\n\n    md = metadata.fromCommandLine(extras)\n    constants.setErrorLevel(\"nothing\")\n    constants.quiet = 100\n    if options.rebase:\n        test.rebase(options.testFiles, md=md)\n    else:\n        result = test.runAllTests(\n            options.testFiles, manualOnly=options.manualOnly, md=md\n        )\n        sys.exit(0 if result else 1)\n\n\ndef handleProfile(options):\n    root = f'--root=\"{options.root}\"' if options.root else \"\"\n    leaf = f'--leaf=\"{options.leaf}\"' if options.leaf else \"\"\n    if options.svgFile:\n        os.system(\n            \"time python -m cProfile -o stat.prof -m bikeshed -f spec && gprof2dot -f pstats --skew=.0001 {root} {leaf} stat.prof | dot -Tsvg -o {svg} && rm stat.prof\".format(\n                root=root, leaf=leaf, svg=options.svgFile\n            )\n        )\n    else:\n        os.system(\n            \"time python -m cProfile -o /tmp/stat.prof -m bikeshed -f spec && gprof2dot -f pstats --skew=.0001 {root} {leaf} /tmp/stat.prof | xdot &\".format(\n                root=root, leaf=leaf\n            )\n        )\n\n\ndef handleTemplate():\n    p(\n        \"\"\"<pre class='metadata'>\nTitle: Your Spec Title\nShortname: your-spec\nLevel: 1\nStatus: ED\nGroup: WGNAMEORWHATEVER\nURL: http://example.com/url-this-spec-will-live-at\nEditor: Your Name, Your Company http://example.com/your-company, your-email@example.com, http://example.com/your-personal-website\nAbstract: A short description of your spec, one or two sentences.\n</pre>\n\nIntroduction {#intro}\n=====================\n\nIntroduction here.\n\"\"\"\n    )\n\n\ndef handleWpt(options):\n    if options.template:\n        p(\n            \"\"\"\n<!DOCTYPE html>\n<meta charset=utf-8>\n<title>window.offscreenBuffering</title>\n<link rel=author title=\"AUTHOR NAME HERE\" href=\"mailto:AUTHOR EMAIL HERE\">\n<link rel=help href=\"LINK TO ROUGHLY WHAT'S BEING TESTED HERE\">\n<script src=\"/resources/testharness.js\"></script>\n<script src=\"/resources/testharnessreport.js\"></script>\n<script>\n/* Choose the test type you want: */\n\n\n/* Standard, synchronous test */\ntest(function() {\n    /* test code here */\n}, \"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\n\n\n/* Async test */\nlet t = async_test(\"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\nsomethingWithACallback( function(){ t.step(()=>{ /* test code here */}) );\nsomething.addEventListener('foo', t.step_func(()=>{ /* test code here */}));\nt.done(); // when all tests are finished running\n// or call the following if there's only one test, automatically does .done() for you\nsomething.addEventListener('foo', t.step_func_done(()=>{ /* test code here */}));\n\n\n/* Promise test */\npromise_test(function(){\n    return somePromiseFunc().then(()=>{ /* test code here */ });\n}, \"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\n// auto-finishes when the returned promise fulfills\n// or if promise should reject:\npromise_test(function(t){\n    return promise_rejects(t, new ExpectedError(), somePromiseCode());\n}, \"TEST NAME HERE / SHORT DESCRIPTION PHRASE\");\n\n\n/* \"test code here\" Asserts */\n// Only use inside of /* test code here */ regions\nassert_true(VALUE HERE, \"TEST DESCRIPTION\");\nassert_equals(ACTUAL VALUE HERE, EXPECTED VALUE HERE, \"TEST DESCRIPTION\");\n// lots more at http://web-platform-tests.org/writing-tests/testharness-api.html#list-of-assertions\n</script>\n\"\"\"\n        )\n", "import collections\nimport os\nimport re\n\nimport lxml\n\nfrom .. import constants\nfrom .. import messages\n\n\ndef englishFromList(items, conjunction=\"or\"):\n    # Format a list of strings into an English list.\n    items = list(items)\n    if len(items) == 1:\n        return items[0]\n    if len(items) == 2:\n        return \"{0} {2} {1}\".format(items[0], items[1], conjunction)\n    return \"{0}, {2} {1}\".format(\", \".join(items[:-1]), items[-1], conjunction)\n\n\ndef intersperse(iterable, delimiter):\n    it = iter(iterable)\n    yield next(it)\n    for x in it:\n        yield delimiter\n        yield x\n\n\ndef processTextNodes(nodes, regex, replacer):\n    \"\"\"\n    Takes an array of alternating text/objects,\n    and runs reSubObject on the text parts,\n    splicing them into the passed-in array.\n    Mutates!\n    \"\"\"\n    for i, node in enumerate(nodes):\n        # Node list always alternates between text and elements\n        if i % 2 == 0:\n            nodes[i : i + 1] = reSubObject(regex, node, replacer)\n    return nodes\n\n\ndef reSubObject(pattern, string, repl=None):\n    \"\"\"\n    like re.sub, but replacements don't have to be text;\n    returns an array of alternating unmatched text and match objects instead.\n    If repl is specified, it's called with each match object,\n    and the result then shows up in the array instead.\n    \"\"\"\n    lastEnd = 0\n    pieces = []\n    for match in pattern.finditer(string):\n        pieces.append(string[lastEnd : match.start()])\n        if repl:\n            pieces.append(repl(match))\n        else:\n            pieces.append(match)\n        lastEnd = match.end()\n    pieces.append(string[lastEnd:])\n    return pieces\n\n\ndef simplifyText(text):\n    # Remove anything that's not a name character.\n    text = text.strip().lower()\n    # I convert ( to - so foo(bar) becomes foo-bar,\n    # but then I have to remove () because there's nothing to separate,\n    # otherwise I get a double-dash in some cases.\n    text = re.sub(r\"\\(\\)\", \"\", text)\n    text = re.sub(r\"[\\s/(,]+\", \"-\", text)\n    text = re.sub(r\"[^a-z0-9_-]\", \"\", text)\n    text = text.rstrip(\"-\")\n    return text\n\n\ndef linkTextsFromElement(el):\n    from ..h import find, textContent\n\n    if el.get(\"data-lt\") == \"\":\n        return []\n    elif el.get(\"data-lt\"):\n        rawText = el.get(\"data-lt\")\n        if rawText in [\"|\", \"||\", \"|||\"]:\n            texts = [rawText]\n        else:\n            texts = [x.strip() for x in rawText.split(\"|\")]\n    else:\n        if el.tag in (\"dfn\", \"a\"):\n            texts = [textContent(el).strip()]\n        elif el.tag in (\"h2\", \"h3\", \"h4\", \"h5\", \"h6\"):\n            texts = [textContent(find(\".content\", el)).strip()]\n    if el.get(\"data-local-lt\"):\n        localTexts = [x.strip() for x in el.get(\"data-local-lt\").split(\"|\")]\n        for text in localTexts:\n            if text in texts:\n                # lt and local-lt both specify the same thing\n                raise DuplicatedLinkText(text, texts + localTexts, el)\n        texts += localTexts\n\n    texts = [re.sub(r\"\\s+\", \" \", x) for x in texts if x != \"\"]\n    return texts\n\n\nclass DuplicatedLinkText(Exception):\n    def __init__(self, offendingText, allTexts, el):\n        super().__init__()\n        self.offendingText = offendingText\n        self.allTexts = allTexts\n        self.el = el\n\n    def __unicode__(self):\n        return f\"<Text '{self.offendingText}' shows up in both lt and local-lt>\"\n\n\ndef firstLinkTextFromElement(el):\n    try:\n        texts = linkTextsFromElement(el)\n    except DuplicatedLinkText as e:\n        texts = e.allTexts\n    return texts[0] if len(texts) > 0 else None\n\n\ndef splitForValues(forValues):\n    \"\"\"\n    Splits a string of 1+ \"for\" values into an array of individual value.\n    Respects function args, etc.\n    Currently, for values are separated by commas.\n    \"\"\"\n    if forValues is None:\n        return None\n    forValues = re.sub(r\"\\s+\", \" \", forValues)\n    return [\n        value.strip()\n        for value in re.split(r\",(?![^()]*\\))\", forValues)\n        if value.strip()\n    ]\n\n\ndef groupFromKey(key, length=2):\n    \"\"\"Generates a filename-safe \"group\" from a key, of a specified length.\"\"\"\n    if key in _groupFromKeyCache:\n        return _groupFromKeyCache[key]\n    safeChars = frozenset(\"abcdefghijklmnopqrstuvwxyz0123456789\")\n    group = \"\"\n    for char in key.lower():\n        if len(group) == length:\n            _groupFromKeyCache[key] = group\n            return group\n        if char in safeChars:\n            group += char\n    else:\n        group = group.ljust(length, \"_\")\n        _groupFromKeyCache[key] = group\n        return group\n\n\n_groupFromKeyCache = {}\n\n\ndef flatten(arr):\n    for el in arr:\n        if (\n            isinstance(el, collections.Iterable)\n            and not isinstance(el, str)\n            and not lxml.etree.iselement(el)\n        ):\n            yield from flatten(el)\n        else:\n            yield el\n\n\ndef scriptPath(*pathSegs):\n    startPath = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\n    path = os.path.join(startPath, *pathSegs)\n    return path\n\n\ndef chrootPath(chrootPath, path):\n    chrootPath = os.path.abspath(chrootPath)\n    path = os.path.abspath(path)\n    if not path.startswith(chrootPath):\n        messages.die(f\"Attempted to access a file ({path}) outside the source document's directory ({chrootPath}). See --allow-nonlocal-files.\")\n        raise Exception()\n    else:\n        return path\n\n\n\ndef doEvery(s, action, lastTime=None):\n    # Takes an action every N seconds.\n    # Pass it the duration and the last time it took the action;\n    # it returns the time it last took the action\n    # (possibly just now).\n    # If you want to take action on first call,\n    # pass 0 as lastTime;\n    # otherwise it won't take action until N seconds.\n    import time\n\n    newTime = time.time()\n    if lastTime is None:\n        lastTime = newTime\n    if lastTime == 0 or newTime - lastTime > s:\n        action()\n        return newTime\n    return lastTime\n", "# pylint: disable=R1732\n\nimport io\nimport os\n\nfrom ..InputSource import InputSource\nfrom ..messages import *\nfrom .main import scriptPath\nfrom .status import splitStatus\n\n\nclass DataFileRequester:\n    def __init__(self, type=None, fallback=None):\n        self.type = type\n        if self.type not in (\"readonly\", \"latest\"):\n            raise Exception(f\"Bad value for DataFileRequester.type, got '{type}'.\")\n        # fallback is another requester, used if the main one fails.\n        self.fallback = fallback\n\n    def fetch(self, *segs, **kwargs):\n        str = kwargs.get(\"str\", False)\n        okayToFail = kwargs.get(\"okayToFail\", False)\n        fileType = kwargs.get(\"type\", self.type)\n        location = self._buildPath(segs=segs, fileType=fileType)\n        try:\n            if str:\n                with open(location, encoding=\"utf-8\") as fh:\n                    return fh.read()\n            else:\n                return open(location, encoding=\"utf-8\")\n        except OSError:\n            if self.fallback:\n                try:\n                    return self.fallback.fetch(*segs, str=str, okayToFail=okayToFail)\n                except OSError:\n                    return self._fail(location, str, okayToFail)\n            return self._fail(location, str, okayToFail)\n\n    def walkFiles(self, *segs, **kwargs):\n        fileType = kwargs.get(\"type\", self.type)\n        for _, _, files in os.walk(self._buildPath(segs, fileType=fileType)):\n            yield from files\n\n    def _buildPath(self, segs, fileType=None):\n        if fileType is None:\n            fileType = self.type\n        if fileType == \"readonly\":\n            return scriptPath(\"spec-data\", \"readonly\", *segs)\n        else:\n            return scriptPath(\"spec-data\", *segs)\n\n    def _fail(self, location, str, okayToFail):\n        if okayToFail:\n            if str:\n                return \"\"\n            else:\n                return io.StringIO(\"\")\n        raise OSError(f\"Couldn't find file '{location}'\")\n\n\ndefaultRequester = DataFileRequester(\n    type=\"latest\", fallback=DataFileRequester(type=\"readonly\")\n)\n\n\ndef retrieveBoilerplateFile(doc, name, group=None, status=None, error=True, allowLocal=True):\n    # Looks in three or four locations, in order:\n    # the folder the spec source is in, the group's boilerplate folder, the megagroup's boilerplate folder, and the generic boilerplate folder.\n    # In each location, it first looks for the file specialized on status, and then for the generic file.\n    # Filenames must be of the format NAME.include or NAME-STATUS.include\n    if group is None and doc.md.group is not None:\n        group = doc.md.group.lower()\n    if status is None:\n        if doc.md.status is not None:\n            status = doc.md.status\n        elif doc.md.rawStatus is not None:\n            status = doc.md.rawStatus\n    megaGroup, status = splitStatus(status)\n\n    searchLocally = allowLocal and doc.md.localBoilerplate[name]\n\n    def boilerplatePath(*segs):\n        return scriptPath(\"boilerplate\", *segs)\n\n    statusFile = f\"{name}-{status}.include\"\n    genericFile = f\"{name}.include\"\n    sources = []\n    if searchLocally:\n        sources.append(doc.inputSource.relative(statusFile))  # Can be None.\n        sources.append(doc.inputSource.relative(genericFile))\n    else:\n        for f in (statusFile, genericFile):\n            if doc.inputSource.cheaplyExists(f):\n                warn(\n                    (\n                        \"Found {0} next to the specification without a matching\\n\"\n                        + \"Local Boilerplate: {1} yes\\n\"\n                        + \"in the metadata. This include won't be found when building via a URL.\"\n                    ).format(f, name)\n                )\n                # We should remove this after giving specs time to react to the warning:\n                sources.append(doc.inputSource.relative(f))\n    if group:\n        sources.append(InputSource(boilerplatePath(group, statusFile), chroot=False))\n        sources.append(InputSource(boilerplatePath(group, genericFile), chroot=False))\n    if megaGroup:\n        sources.append(InputSource(boilerplatePath(megaGroup, statusFile), chroot=False))\n        sources.append(InputSource(boilerplatePath(megaGroup, genericFile), chroot=False))\n    sources.append(InputSource(boilerplatePath(statusFile), chroot=False))\n    sources.append(InputSource(boilerplatePath(genericFile), chroot=False))\n\n    # Watch all the possible sources, not just the one that got used, because if\n    # an earlier one appears, we want to rebuild.\n    doc.recordDependencies(*sources)\n\n    for source in sources:\n        if source is not None:\n            try:\n                return source.read().content\n            except OSError:\n                # That input doesn't exist.\n                pass\n    else:\n        if error:\n            die(\n                \"Couldn't find an appropriate include file for the {0} inclusion, given group='{1}' and status='{2}'.\",\n                name,\n                group,\n                status,\n            )\n        return \"\"\n", "from .stringEnum import StringEnum\n\ndryRun = False\nerrorLevel = [\"fatal\"]\nprintMode = \"console\"\nquiet = True\nasciiOnly = False\nrefStatus = StringEnum(\"current\", \"snapshot\")\nbiblioDisplay = StringEnum(\"index\", \"inline\")\nspecClass = None\ntestAnnotationURL = \"https://test.csswg.org/harness/annotate.js\"\nchroot = True\nexecuteCode = False\n\n\ndef errorLevelAt(target):\n    levels = {\n        \"nothing\": 0,\n        \"fatal\": 1,\n        \"link-error\": 2,\n        \"warning\": 3,\n        \"everything\": 1000,\n    }\n    currentLevel = levels[errorLevel[0]]\n    targetLevel = levels[target]\n    return currentLevel >= targetLevel\n\n\ndef setErrorLevel(level=None):\n    if level is None:\n        level = \"fatal\"\n    errorLevel[0] = level\n", "from . import config\nfrom . import constants\nfrom .h import *  # noqa: F401\nfrom .messages import *  # noqa: F401\n\n\ndef load(doc):\n    code = config.retrieveBoilerplateFile(doc, \"bs-extensions\", allowLocal=constants.executeCode)\n    exec(code, globals())\n", "from subprocess import PIPE, Popen\n\nfrom .. import constants\nfrom ..h import *\nfrom ..messages import *\n\n\ndef processTags(doc):\n    for el in findAll(\"[data-span-tag]\", doc):\n        if not constants.executeCode:\n            die(\"Found an inline code tag, but arbitrary code execution isn't allowed. See the --allow-execute flag.\")\n            return\n        tag = el.get(\"data-span-tag\")\n        if tag not in doc.md.inlineTagCommands:\n            die(\"Unknown inline tag '{0}' found:\\n  {1}\", tag, outerHTML(el), el=el)\n            continue\n        command = doc.md.inlineTagCommands[tag]\n        with Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True) as p:\n            out, err = p.communicate(innerHTML(el).encode(\"utf-8\"))\n            try:\n                out = out.decode(\"utf-8\")\n            except UnicodeDecodeError as e:\n                die(\n                    \"When trying to process {0}, got invalid unicode in stdout:\\n{1}\",\n                    outerHTML(el),\n                    e,\n                    el=el,\n                )\n            try:\n                err = err.decode(\"utf-8\")\n            except UnicodeDecodeError as e:\n                die(\n                    \"When trying to process {0}, got invalid unicode in stderr:\\n{1}\",\n                    outerHTML(el),\n                    e,\n                    el=el,\n                )\n            if p.returncode:\n                die(\n                    \"When trying to process {0}, got return code {1} and the following stderr:\\n{2}\",\n                    outerHTML(el),\n                    p.returncode,\n                    err,\n                    el=el,\n                )\n                continue\n            replaceContents(el, parseHTML(out))\n"], "filenames": ["bikeshed/InputSource.py", "bikeshed/Spec.py", "bikeshed/cli.py", "bikeshed/config/main.py", "bikeshed/config/retrieve.py", "bikeshed/constants.py", "bikeshed/extensions.py", "bikeshed/inlineTags/__init__.py"], "buggy_code_start_loc": [15, 61, 76, 5, 66, 11, 1, 2], "buggy_code_end_loc": [183, 62, 446, 172, 111, 11, 8, 8], "fixing_code_start_loc": [16, 61, 77, 6, 66, 12, 2, 3], "fixing_code_end_loc": [190, 62, 461, 187, 111, 14, 9, 13], "type": "CWE-78", "message": "This affects the package bikeshed before 3.0.0. This can occur when an untrusted source file containing Inline Tag Command metadata is processed. When an arbitrary OS command is executed, the command output would be included in the HTML output.", "other": {"cve": {"id": "CVE-2021-23422", "sourceIdentifier": "report@snyk.io", "published": "2021-08-16T08:15:11.287", "lastModified": "2021-08-23T19:02:28.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package bikeshed before 3.0.0. This can occur when an untrusted source file containing Inline Tag Command metadata is processed. When an arbitrary OS command is executed, the command output would be included in the HTML output."}, {"lang": "es", "value": "Esto afecta al paquete bikeshed versiones anteriores a 3.0.0. Esto puede ocurrir cuando se procesa un archivo fuente no confiable que contiene metadatos de comandos de etiquetas en l\u00ednea. Cuando es ejecutado un comando arbitrario del Sistema Operativo, la salida del comando se incluir\u00eda en la salida HTML."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bikeshed_project:bikeshed:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.0", "matchCriteriaId": "1C121594-2CCF-4690-AB04-CD38AD675AC2"}]}]}], "references": [{"url": "https://github.com/tabatkins/bikeshed/commit/b2f668fca204260b1cad28d5078e93471cb6b2dd", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-PYTHON-BIKESHED-1537646", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tabatkins/bikeshed/commit/b2f668fca204260b1cad28d5078e93471cb6b2dd"}}