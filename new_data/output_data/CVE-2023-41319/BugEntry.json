{"buggy_code": ["import {\n  Box,\n  Button,\n  ButtonGroup,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n  Text,\n  useToast,\n} from \"@fidesui/react\";\nimport { FetchBaseQueryError } from \"@reduxjs/toolkit/dist/query/fetchBaseQuery\";\nimport React, { useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { useDispatch } from \"react-redux\";\n\nimport { getErrorMessage } from \"~/features/common/helpers\";\nimport { errorToastParams, successToastParams } from \"~/features/common/toast\";\nimport {\n  setConnectionOptions,\n  useGetAllConnectionTypesQuery,\n} from \"~/features/connection-type\";\n\nimport { useRegisterConnectorTemplateMutation } from \"./connector-template.slice\";\n\ntype RequestModalProps = {\n  isOpen: boolean;\n  onClose: () => void;\n  testId?: String;\n};\n\nconst ConnectorTemplateUploadModal: React.FC<RequestModalProps> = ({\n  isOpen,\n  onClose,\n  testId = \"connector-template-modal\",\n}) => {\n  const dispatch = useDispatch();\n  const [uploadedFile, setUploadedFile] = useState<File | null>(null);\n  const toast = useToast();\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop: (acceptedFiles: File[]) => {\n      const file = acceptedFiles[0];\n      const fileExtension = file.name.split(\".\").pop()?.toLowerCase();\n\n      if (fileExtension !== \"zip\") {\n        toast(errorToastParams(\"Only zip files are allowed.\"));\n        return;\n      }\n\n      setUploadedFile(acceptedFiles[0]);\n    },\n  });\n\n  const [registerConnectorTemplate, { isLoading }] =\n    useRegisterConnectorTemplateMutation();\n  const { refetch: refetchConnectionTypes } = useGetAllConnectionTypesQuery(\n    {\n      search: \"\",\n    },\n    {\n      skip: false,\n    }\n  );\n\n  const handleSubmit = async () => {\n    if (uploadedFile) {\n      try {\n        await registerConnectorTemplate(uploadedFile).unwrap();\n        toast(\n          successToastParams(\"Integration template uploaded successfully.\")\n        );\n\n        // refresh the connection types\n        const { data } = await refetchConnectionTypes();\n        dispatch(setConnectionOptions(data?.items ?? []));\n        onClose();\n      } catch (error) {\n        toast(errorToastParams(getErrorMessage(error as FetchBaseQueryError)));\n      } finally {\n        setUploadedFile(null);\n      }\n    }\n  };\n\n  const renderFileText = () => {\n    if (uploadedFile) {\n      return <Text>{uploadedFile.name}</Text>;\n    }\n    if (isDragActive) {\n      return <Text>Drop the file here...</Text>;\n    }\n    return <Text>Click or drag and drop your file here.</Text>;\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} size=\"2xl\">\n      <ModalOverlay />\n      <ModalContent textAlign=\"left\" p={2} data-testid={testId}>\n        <ModalHeader>Upload integration template</ModalHeader>\n        <ModalBody>\n          <Text fontSize=\"sm\" mb={4}>\n            Drag and drop your integration template zip file here, or click to\n            browse your files.\n          </Text>\n          <Box\n            {...getRootProps()}\n            bg={isDragActive ? \"gray.100\" : \"gray.50\"}\n            border=\"2px dashed\"\n            borderColor={isDragActive ? \"gray.300\" : \"gray.200\"}\n            borderRadius=\"md\"\n            cursor=\"pointer\"\n            minHeight=\"150px\"\n            display=\"flex\"\n            alignItems=\"center\"\n            justifyContent=\"center\"\n            textAlign=\"center\"\n          >\n            <input {...getInputProps()} />\n            {renderFileText()}\n          </Box>\n          <Text fontSize=\"sm\" mt={4}>\n            An integration template zip file must include a SaaS config and\n            dataset, but may also contain an icon (.svg) and custom functions\n            (.py) as optional files.\n          </Text>\n        </ModalBody>\n        <ModalFooter>\n          <ButtonGroup\n            size=\"sm\"\n            spacing=\"2\"\n            width=\"100%\"\n            display=\"flex\"\n            justifyContent=\"right\"\n          >\n            <Button\n              variant=\"outline\"\n              onClick={onClose}\n              data-testid=\"cancel-btn\"\n              isDisabled={isLoading}\n            >\n              Cancel\n            </Button>\n            <Button\n              colorScheme=\"primary\"\n              type=\"submit\"\n              isDisabled={!uploadedFile || isLoading}\n              onClick={handleSubmit}\n              data-testid=\"submit-btn\"\n            >\n              Submit\n            </Button>\n          </ButtonGroup>\n        </ModalFooter>\n      </ModalContent>\n    </Modal>\n  );\n};\n\nexport default ConnectorTemplateUploadModal;\n", "services:\n  fides:\n    container_name: fides\n    image: ethyca/fides:local\n    command: uvicorn --host 0.0.0.0 --port 8080 --reload --reload-dir src --reload-dir data --reload-include='*.yml' fides.api.main:app\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://0.0.0.0:8080/health\"]\n      interval: 20s\n      timeout: 5s\n      retries: 10\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      fides-db:\n        condition: service_healthy\n      redis:\n        condition: service_started\n    expose:\n      - 8080\n    env_file:\n      - .env\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n      FIDES__CLI__SERVER_HOST: \"fides\"\n      FIDES__CLI__SERVER_PORT: \"8080\"\n      FIDES__DATABASE__SERVER: \"fides-db\"\n      FIDES__DEV_MODE: \"True\"\n      FIDES__LOGGING__COLORIZE: \"True\"\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n      FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS: \"True\"\n      FIDES__SECURITY__BASTION_SERVER_HOST: ${FIDES__SECURITY__BASTION_SERVER_HOST-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME: ${FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY: ${FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY-}\n      VAULT_ADDR: ${VAULT_ADDR-}\n      VAULT_NAMESPACE: ${VAULT_NAMESPACE-}\n      VAULT_TOKEN: ${VAULT_TOKEN-}\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n\n  fides-ui:\n    image: ethyca/fides:local-ui\n    command: npm run dev-admin-ui\n    expose:\n      - 3000\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/admin-ui/node_modules\n    environment:\n      - NEXT_PUBLIC_FIDESCTL_API_SERVER=http://fides:8080\n\n  fides-pc:\n    image: ethyca/fides:local-pc\n    command: npm run dev-pc\n    expose:\n      - 3000\n    ports:\n      - \"3001:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/privacy-center/node_modules\n\n  fides-db:\n    image: postgres:12\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 15s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - postgres:/var/lib/postgresql/data\n    expose:\n      - 5432\n    ports:\n      - \"5432:5432\"\n    environment:\n      POSTGRES_USER: \"postgres\"\n      POSTGRES_PASSWORD: \"fides\"\n      POSTGRES_DB: \"fides\"\n    deploy:\n      placement:\n        constraints:\n          - node.labels.fides.app-db-data == true\n\n  docs:\n    build:\n      context: .\n      dockerfile: docs/fides/Dockerfile\n    volumes:\n      - ./docs/fides:/docs\n      - ./:/fides\n    expose:\n      - 8000\n    ports:\n      - \"8000:8000\"\n    environment:\n      FIDES__DEV_MODE: True\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n\n      # Required security env vars\n      FIDES__SECURITY__APP_ENCRYPTION_KEY: OLMkv91j8DHiDAULnK5Lxx3kSCov30b3\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_ID: fidesadmin\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_SECRET: fidesadminsecret\n      FIDES__SECURITY__DRP_JWT_SECRET: secret\n\n  worker:\n    image: ethyca/fides:local\n    command: fides worker\n    depends_on:\n      redis:\n        condition: service_started\n    restart: always\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n    volumes:\n      - type: bind\n        source: ./\n        target: /fides\n        read_only: False\n      - /fides/src/fides.egg-info\n\n  redis:\n    image: \"redis:6.2.5-alpine\"\n    # AUTH option #1: no authentication at all\n    # command: redis-server\n    # AUTH option #2: require password\n    command: redis-server --requirepass redispassword\n    # AUTH option #3: Redis ACL defined in redis.conf\n    # command: redis-server /usr/local/etc/redis/redis.conf\n    expose:\n      - 6379\n    ports:\n      - \"0.0.0.0:6379:6379\"\n    volumes:\n      # Mount a redis.conf file for configuration\n      # NOTE: Only used by \"AUTH option #3\" above!\n      - type: bind\n        source: ./docker/redis\n        target: /usr/local/etc/redis\n        read_only: False\n\nvolumes:\n  postgres: null\n\nnetworks:\n  fides_network:\n", "AccessControl==6.0\nalembic==1.8.1\nAPScheduler==3.9.1.post1\nasyncpg==0.27.0\nboto3==1.26.1\ncelery[pytest]==5.2.7\ncolorama>=0.4.3\ncryptography==38.0.3\ndask==2022.9.2\ndeepdiff==6.3.0\ndefusedxml==0.7.1\nexpandvars==0.9.0\nfastapi[all]==0.89.1\nfastapi-caching[redis]==0.3.0\nfastapi-pagination[sqlalchemy]==0.11.4\nfideslang==1.4.5\nfideslog==1.2.10\nfirebase-admin==5.3.0\nGitPython==3.1.31\nhttpx==0.23.1\nhvac==0.11.2\nimportlib_resources==5.12.0\nJinja2==3.1.2\nloguru==0.6.0\nmultidimensional_urlencode==0.0.4\nokta==2.7.0\nopenpyxl==3.0.9\npackaging==23.0\npandas==1.4.3\nparamiko==3.1.0\npasslib[bcrypt]==1.7.4\nplotly==5.13.1\npyarrow==6.0.0\npyinstrument==4.5.1\npsycopg2-binary==2.9.6\npydantic==1.10.9\npydash==6.0.2\nPyJWT==2.4.0\npymongo==3.13.0\nPyMySQL==1.0.2\npymssql==2.2.8\npython-jose[cryptography]==3.3.0\npyyaml==6.0.1\nredis==3.5.3\nRestrictedPython==6.0.0\nrich-click==1.6.1\nsendgrid==6.9.7\nslowapi==0.1.8\nsnowflake-sqlalchemy==1.4.3\nsqlalchemy[asyncio]==1.4.27\nsqlalchemy-citext==1.8.0\nsqlalchemy-bigquery==1.4.4\nsqlalchemy-redshift==0.8.11\nsqlalchemy-stubs==0.4\nSQLAlchemy-Utils==0.38.3\nsshtunnel==0.4.0\ntoml==0.10.2\ntwilio==7.15.0\ntyping_extensions==4.5.0 # pinned to work around https://github.com/pydantic/pydantic/issues/5821\nUnidecode==1.3.4\nvalidators==0.20.0\nversioneer==0.19\n", "from typing import Optional\n\nfrom fideslang.models import Dataset\nfrom pydantic import BaseModel, validator\n\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.service.authentication.authentication_strategy_oauth2_authorization_code import (\n    OAuth2AuthorizationCodeAuthenticationStrategy,\n)\nfrom fides.api.util.saas_util import load_config_from_string, load_dataset_from_string\n\n\nclass ConnectorTemplate(BaseModel):\n    \"\"\"\n    A collection of artifacts that make up a complete\n    SaaS connector (SaaS config, dataset, icon, functions, etc.)\n    \"\"\"\n\n    config: str\n    dataset: str\n    icon: Optional[str]\n    functions: Optional[str]\n    human_readable: str\n\n    @validator(\"config\")\n    def validate_config(cls, config: str) -> str:\n        \"\"\"Validates the config at the given path\"\"\"\n        saas_config = SaaSConfig(**load_config_from_string(config))\n        if saas_config.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"\n            )\n        return config\n\n    @validator(\"dataset\")\n    def validate_dataset(cls, dataset: str) -> str:\n        \"\"\"Validates the dataset at the given path\"\"\"\n        saas_dataset = Dataset(**load_dataset_from_string(dataset))\n        if saas_dataset.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"\n            )\n        return dataset\n\n    @property\n    def authorization_required(self) -> bool:\n        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"\n\n        config = SaaSConfig(**load_config_from_string(self.config))\n        authentication = config.client_config.authentication\n        return (\n            authentication.strategy\n            == OAuth2AuthorizationCodeAuthenticationStrategy.name\n            if authentication\n            else False\n        )\n\n    @property\n    def user_guide(self) -> Optional[str]:\n        config = SaaSConfig(**load_config_from_string(self.config))\n        return config.user_guide\n", "# pylint: disable=protected-access\nimport os\nfrom abc import ABC, abstractmethod\nfrom ast import AST, AnnAssign\nfrom operator import getitem\nfrom typing import Any, Dict, Iterable, List, Optional, Tuple, Type\nfrom zipfile import ZipFile\n\nfrom AccessControl.ZopeGuards import safe_builtins\nfrom fideslang.models import Dataset\nfrom loguru import logger\nfrom packaging.version import Version\nfrom packaging.version import parse as parse_version\nfrom RestrictedPython import compile_restricted\nfrom RestrictedPython.transformer import RestrictingNodeTransformer\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.common_exceptions import FidesopsException, ValidationError\nfrom fides.api.cryptography.cryptographic_util import str_to_b64_str\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.schemas.connection_configuration.saas_config_template_values import (\n    SaasConnectionTemplateValues,\n)\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config,\n    load_config_from_string,\n    load_dataset_from_string,\n    load_yaml_as_string,\n    replace_config_placeholders,\n    replace_dataset_placeholders,\n    replace_version,\n)\nfrom fides.api.util.unsafe_file_util import verify_svg, verify_zip\nfrom fides.config import CONFIG\n\n\nclass ConnectorTemplateLoader(ABC):\n    _instance: Optional[\"ConnectorTemplateLoader\"] = None\n\n    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._templates = {}  # type: ignore[attr-defined]\n            cls._instance._load_connector_templates()\n        return cls._instance\n\n    @classmethod\n    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"Returns a map of connection templates.\"\"\"\n        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]\n\n    @abstractmethod\n    def _load_connector_templates(self) -> None:\n        \"\"\"Load connector templates into the _templates dictionary\"\"\"\n\n\nclass FileConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads SaaS connector templates from the data/saas directory.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the data/saas directory\")\n        for file in os.listdir(\"data/saas/config\"):\n            if file.endswith(\".yml\"):\n                config_file = os.path.join(\"data/saas/config\", file)\n                config_dict = load_config(config_file)\n                connector_type = config_dict[\"type\"]\n                human_readable = config_dict[\"name\"]\n\n                try:\n                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")\n                except FileNotFoundError:\n                    logger.debug(\n                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"\n                    )\n                    icon = encode_file_contents(\"data/saas/icon/default.svg\")\n\n                # store connector template for retrieval\n                try:\n                    FileConnectorTemplateLoader.get_connector_templates()[\n                        connector_type\n                    ] = ConnectorTemplate(\n                        config=load_yaml_as_string(config_file),\n                        dataset=load_yaml_as_string(\n                            f\"data/saas/dataset/{connector_type}_dataset.yml\"\n                        ),\n                        icon=icon,\n                        functions=None,\n                        human_readable=human_readable,\n                    )\n                except Exception:\n                    logger.exception(\"Unable to load {} connector\", connector_type)\n\n\nclass CustomConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads custom connector templates defined in the custom_connector_template database table.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the database.\")\n        db = get_api_session()\n        for template in CustomConnectorTemplate.all(db=db):\n            if (\n                template.replaceable\n                and CustomConnectorTemplateLoader._replacement_available(template)\n            ):\n                logger.info(\n                    f\"Replacing {template.key} connector template with newer version.\"\n                )\n                template.delete(db=db)\n                continue\n            try:\n                CustomConnectorTemplateLoader._register_template(template)\n            except Exception:\n                logger.exception(\"Unable to load {} connector\", template.key)\n\n    @staticmethod\n    def _replacement_available(template: CustomConnectorTemplate) -> bool:\n        \"\"\"\n        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.\n        \"\"\"\n        replacement_connector = (\n            FileConnectorTemplateLoader.get_connector_templates().get(template.key)\n        )\n        if not replacement_connector:\n            return False\n\n        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))\n        replacement_saas_config = SaaSConfig(\n            **load_config_from_string(replacement_connector.config)\n        )\n        return parse_version(replacement_saas_config.version) > parse_version(\n            custom_saas_config.version\n        )\n\n    @classmethod\n    def _register_template(\n        cls,\n        template: CustomConnectorTemplate,\n    ) -> None:\n        \"\"\"\n        Registers a custom connector template by converting it to a ConnectorTemplate,\n        registering any custom functions, and adding it to the loader's template dictionary.\n        \"\"\"\n        connector_template = ConnectorTemplate(\n            config=template.config,\n            dataset=template.dataset,\n            icon=template.icon,\n            functions=template.functions,\n            human_readable=template.name,\n        )\n\n        # register custom functions if available\n        if template.functions:\n            register_custom_functions(template.functions)\n            logger.info(\n                f\"Loaded functions from the custom connector template '{template.key}'\"\n            )\n\n        # register the template in the loader's template dictionary\n        CustomConnectorTemplateLoader.get_connector_templates()[\n            template.key\n        ] = connector_template\n\n    # pylint: disable=too-many-branches\n    @classmethod\n    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    verify_svg(file_contents)\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n\n\nclass ConnectorRegistry:\n    @classmethod\n    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"\n        Returns a combined map of connector templates from all registered loaders.\n        The resulting map is an aggregation of templates from the file loader and the custom loader,\n        with custom loader templates taking precedence in case of conflicts.\n        \"\"\"\n        return {\n            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n        }\n\n    @classmethod\n    def connector_types(cls) -> List[str]:\n        \"\"\"List of registered SaaS connector types\"\"\"\n        return list(cls._get_combined_templates().keys())\n\n    @classmethod\n    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:\n        \"\"\"\n        Returns an object containing the various SaaS connector artifacts\n        \"\"\"\n        return cls._get_combined_templates().get(connector_type)\n\n\ndef create_connection_config_from_template_no_save(\n    db: Session,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n    system_id: Optional[str] = None,\n) -> ConnectionConfig:\n    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"\n    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_values.instance_key\n    )\n\n    data = {\n        \"key\": template_values.key\n        if template_values.key\n        else template_values.instance_key,\n        \"description\": template_values.description,\n        \"connection_type\": ConnectionType.saas,\n        \"access\": AccessLevel.write,\n        \"saas_config\": config_from_template,\n    }\n    if template_values.name:\n        data[\"name\"] = template_values.name\n\n    if system_id:\n        data[\"system_id\"] = system_id\n\n    # Create SaaS ConnectionConfig\n    connection_config = ConnectionConfig.create_without_saving(db, data=data)\n\n    return connection_config\n\n\ndef upsert_dataset_config_from_template(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n) -> DatasetConfig:\n    \"\"\"\n    Creates a `DatasetConfig` from a template\n    and associates it with a ConnectionConfig.\n    If the `DatasetConfig` already exists in the db,\n    then the existing record is updated.\n    \"\"\"\n    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    dataset_from_template: Dict = replace_dataset_placeholders(\n        template.dataset, \"<instance_fides_key>\", template_values.instance_key\n    )\n    data = {\n        \"connection_config_id\": connection_config.id,\n        \"fides_key\": template_values.instance_key,\n        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset\n    }\n    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)\n    return dataset_config\n\n\ndef update_saas_configs(db: Session) -> None:\n    \"\"\"\n    Updates SaaS config instances currently in the DB if to the\n    corresponding template in the registry are found.\n\n    Effectively an \"update script\" for SaaS config instances,\n    to be run on server bootstrap.\n    \"\"\"\n    for connector_type in ConnectorRegistry.connector_types():\n        logger.debug(\n            \"Determining if any updates are needed for connectors of type {} based on templates...\",\n            connector_type,\n        )\n        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore\n            connector_type\n        )\n        saas_config = SaaSConfig(**load_config_from_string(template.config))\n        template_version: Version = parse_version(saas_config.version)\n\n        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(\n            db=db,\n            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),\n        ).all()\n        for connection_config in connection_configs:\n            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)\n            if parse_version(saas_config_instance.version) < template_version:\n                logger.info(\n                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",\n                    saas_config_instance.fides_key,\n                    connector_type,\n                    saas_config_instance.version,\n                    template_version,\n                )\n                try:\n                    update_saas_instance(\n                        db,\n                        connection_config,\n                        template,\n                        saas_config_instance,\n                    )\n                except Exception:\n                    logger.exception(\n                        \"Encountered error attempting to update SaaS config instance {}\",\n                        saas_config_instance.fides_key,\n                    )\n\n\ndef update_saas_instance(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    saas_config_instance: SaaSConfig,\n) -> None:\n    \"\"\"\n    Replace in the DB the existing SaaS instance configuration data\n    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig\n    with new instance configuration data based on the given ConnectorTemplate\n    \"\"\"\n    template_vals = SaasConnectionTemplateValues(\n        name=connection_config.name,\n        key=connection_config.key,\n        description=connection_config.description,\n        secrets=connection_config.secrets,\n        instance_key=saas_config_instance.fides_key,\n    )\n\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_vals.instance_key\n    )\n\n    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))\n\n    upsert_dataset_config_from_template(db, connection_config, template, template_vals)\n\n\ndef register_custom_functions(script: str) -> None:\n    \"\"\"\n    Registers custom functions by executing the given script in a restricted environment.\n\n    The script is compiled and executed with RestrictedPython, which is designed to reduce\n    the risk of executing untrusted code. It provides a set of safe builtins to prevent\n    malicious or unintended behavior.\n\n    Args:\n        script (str): The Python script containing the custom functions to be registered.\n\n    Raises:\n        FidesopsException: If allow_custom_connector_functions is disabled.\n        SyntaxError: If the script contains a syntax error or uses restricted language features.\n        Exception: If an exception occurs during the execution of the script.\n    \"\"\"\n\n    if CONFIG.security.allow_custom_connector_functions:\n        restricted_code = compile_restricted(\n            script, \"<string>\", \"exec\", policy=CustomRestrictingNodeTransformer\n        )\n        safe_builtins[\"__import__\"] = custom_guarded_import\n        safe_builtins[\"_getitem_\"] = getitem\n        safe_builtins[\"staticmethod\"] = staticmethod\n\n        # pylint: disable=exec-used\n        exec(\n            restricted_code,\n            {\n                \"__metaclass__\": type,\n                \"__name__\": \"restricted_module\",\n                \"__builtins__\": safe_builtins,\n            },\n        )\n    else:\n        raise FidesopsException(\n            message=\"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n        )\n\n\nclass CustomRestrictingNodeTransformer(RestrictingNodeTransformer):\n    \"\"\"\n    Custom node transformer class that extends RestrictedPython's RestrictingNodeTransformer\n    to allow the use of type annotations (AnnAssign) in restricted code.\n    \"\"\"\n\n    def visit_AnnAssign(self, node: AnnAssign) -> AST:\n        return self.node_contents_visit(node)\n\n\ndef custom_guarded_import(\n    name: str,\n    _globals: Optional[dict] = None,\n    _locals: Optional[dict] = None,\n    fromlist: Optional[Tuple[str, ...]] = None,\n    level: int = 0,\n) -> Any:\n    \"\"\"\n    A custom import function that prevents the import of certain potentially unsafe modules.\n    \"\"\"\n    if name in [\n        \"os\",\n        \"sys\",\n        \"subprocess\",\n        \"shutil\",\n        \"socket\",\n        \"importlib\",\n        \"tempfile\",\n        \"glob\",\n    ]:\n        # raising SyntaxError to be consistent with exceptions thrown from other guarded functions\n        raise SyntaxError(f\"Import of '{name}' module is not allowed.\")\n    if fromlist is None:\n        fromlist = ()\n    return __import__(name, _globals, _locals, fromlist, level)\n", "\"\"\"This module handles finding and parsing fides configuration files.\"\"\"\n\n# pylint: disable=C0115,C0116, E0213\nfrom typing import Dict, List, Optional, Pattern, Tuple, Union\n\nimport validators\nfrom pydantic import Field, validator\nfrom slowapi.wrappers import parse_many  # type: ignore\n\nfrom fides.api.cryptography.cryptographic_util import generate_salt, hash_with_salt\nfrom fides.api.oauth.roles import OWNER\nfrom fides.common.api.scope_registry import SCOPE_REGISTRY\n\nfrom .fides_settings import FidesSettings\n\nENV_PREFIX = \"FIDES__SECURITY__\"\n\n\nclass SecuritySettings(FidesSettings):\n    \"\"\"Configuration settings for application security.\"\"\"\n\n    aes_encryption_key_length: int = Field(\n        default=16,\n        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",\n    )\n    aes_gcm_nonce_length: int = Field(\n        default=12,\n        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",\n    )\n    app_encryption_key: str = Field(\n        default=\"\", description=\"The key used to sign Fides API access tokens.\"\n    )\n    cors_origins: List[str] = Field(\n        default=[],\n        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",\n    )\n    cors_origin_regex: Optional[Pattern] = Field(\n        default=None,\n        description=\"A regex pattern used to set the CORS origin allowlist.\",\n    )\n    drp_jwt_secret: Optional[str] = Field(\n        default=None,\n        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",\n    )\n    encoding: str = Field(\n        default=\"UTF-8\", description=\"Text encoding to use for the application.\"\n    )\n    env: str = Field(\n        default=\"dev\",\n        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",\n    )\n    identity_verification_attempt_limit: int = Field(\n        default=3,\n        description=\"The number of times identity verification will be attempted before raising an error.\",\n    )\n    oauth_root_client_id: str = Field(\n        default=\"\",\n        description=\"The value used to identify the Fides application root API client.\",\n    )\n    oauth_root_client_secret: str = Field(\n        default=\"\",\n        description=\"The secret value used to authenticate the Fides application root API client.\",\n    )\n    oauth_root_client_secret_hash: Optional[Tuple] = Field(\n        default=None,\n        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",\n    )\n    oauth_access_token_expire_minutes: int = Field(\n        default=11520,\n        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",\n    )\n    oauth_client_id_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client id used for oauth.\",\n    )\n    oauth_client_secret_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client secret used for oauth.\",\n    )\n    parent_server_password: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",\n    )\n    parent_server_username: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",\n    )\n    public_request_rate_limit: str = Field(\n        default=\"2000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",\n    )\n    rate_limit_prefix: str = Field(\n        default=\"fides-\",\n        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",\n    )\n    request_rate_limit: str = Field(\n        default=\"1000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",\n    )\n    root_user_scopes: List[str] = Field(\n        default=SCOPE_REGISTRY,\n        description=\"The list of scopes that are given to the root user.\",\n    )\n    root_user_roles: List[str] = Field(\n        default=[OWNER],\n        description=\"The list of roles that are given to the root user.\",\n    )\n    root_password: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",\n    )\n\n    root_username: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",\n    )\n    subject_request_download_link_ttl_seconds: int = Field(\n        default=432000,\n        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",\n    )\n    allow_custom_connector_functions: Optional[bool] = Field(\n        default=False,\n        description=\"Enables or disables the ability to import connector templates with custom functions. When enabled, custom functions which will be loaded in a restricted environment to minimize security risks.\",\n    )\n    enable_audit_log_resource_middleware: Optional[bool] = Field(\n        default=False,\n        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",\n    )\n\n    bastion_server_host: Optional[str] = Field(\n        default=None, description=\"An optional field to store the bastion server host\"\n    )\n    bastion_server_ssh_username: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the username used to access the bastion server\",\n    )\n    bastion_server_ssh_private_key: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the key used to SSH into the bastion server.\",\n    )\n    bastion_server_ssh_timeout: float = Field(\n        default=0.1,\n        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",\n    )\n    bastion_server_ssh_tunnel_timeout: float = Field(\n        default=10,\n        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",\n    )\n\n    @validator(\"app_encryption_key\")\n    @classmethod\n    def validate_encryption_key_length(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[str]:\n        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"\n\n        # If the value is the default value, return immediately to prevent unwanted errors\n        if v == \"\":\n            return v\n\n        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:\n            raise ValueError(\n                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"\n            )\n        return v\n\n    @validator(\"cors_origins\", pre=True)\n    @classmethod\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        \"\"\"Return a list of valid origins for CORS requests\"\"\"\n\n        def validate(values: List[str]) -> None:\n            for value in values:\n                if value != \"*\":\n                    if not validators.url(value):\n                        raise ValueError(f\"{value} is not a valid url\")\n\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            values = [i.strip() for i in v.split(\",\")]\n            validate(values)\n\n            return values\n        if isinstance(v, (list, str)):\n            validate(v)  # type: ignore\n\n            return v\n        raise ValueError(v)\n\n    @validator(\"oauth_root_client_secret_hash\")\n    @classmethod\n    def assemble_root_access_token(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[Tuple]:\n        \"\"\"\n        Sets a hashed value of the root access key.\n        This is hashed as it is not wise to return a plaintext for of the\n        root credential anywhere in the system.\n        \"\"\"\n        value = values.get(\"oauth_root_client_secret\", \"\")\n\n        if not value:\n            return None\n\n        encoding = values.get(\"encoding\", \"UTF-8\")\n\n        salt = generate_salt()\n        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))\n        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore\n        return oauth_root_client_secret_hash\n\n    @validator(\"request_rate_limit\")\n    @classmethod\n    def validate_request_rate_limit(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        try:\n            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many\n            parse_many(v)\n        except ValueError:\n            message = \"\"\"\n            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]\n            e.g. 10 per hour\n            e.g. 10/hour\n            e.g. 10/hour;100/day;2000 per year\n            e.g. 100/day, 500/7days\n            \"\"\"\n            raise ValueError(message)\n        return v\n\n    @validator(\"env\")\n    @classmethod\n    def validate_env(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        if v not in [\"dev\", \"prod\"]:\n            message = \"Security environment must be either 'dev' or 'prod'.\"\n            raise ValueError(message)\n        return v\n\n    class Config:\n        env_prefix = ENV_PREFIX\n", "import json\nfrom typing import Optional\nfrom unittest import mock\nfrom unittest.mock import MagicMock\n\nimport pytest\nfrom sqlalchemy.orm import Session\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.common.api.scope_registry import (\n    CLIENT_READ,\n    CONNECTION_AUTHORIZE,\n    CONNECTOR_TEMPLATE_REGISTER,\n    SAAS_CONFIG_CREATE_OR_UPDATE,\n    SAAS_CONFIG_DELETE,\n    SAAS_CONFIG_READ,\n)\nfrom fides.common.api.v1.urn_registry import (\n    AUTHORIZE,\n    REGISTER_CONNECTOR_TEMPLATE,\n    SAAS_CONFIG,\n    SAAS_CONFIG_VALIDATE,\n    V1_URL_PREFIX,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.api.v1.endpoints.test_dataset_endpoints import _reject_key\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\n@pytest.mark.unit_saas\nclass TestValidateSaaSConfig:\n    @pytest.fixture\n    def validate_saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG_VALIDATE\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_put_validate_saas_config_not_authenticated(\n        self, saas_example_config, validate_saas_config_url: str, api_client\n    ) -> None:\n        response = api_client.put(\n            validate_saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_put_validate_dataset_wrong_scope(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.put(\n            validate_saas_config_url,\n            headers=auth_header,\n            json=saas_example_config,\n        )\n        assert response.status_code == 403\n\n    def test_put_validate_saas_config_missing_key(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"fides_key\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"fides_key\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_missing_endpoints(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"endpoints\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"endpoints\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_reference_and_identity(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"identity\"] = \"email\"\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"from\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"Must have exactly one of 'identity', 'references', or 'connector_param'\"\n        )\n\n    def test_put_validate_saas_config_wrong_reference_direction(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"to\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"References can only have a direction of 'from', found 'to'\"\n        )\n\n\n@pytest.mark.unit_saas\nclass TestPutSaaSConfig:\n    @pytest.fixture\n    def saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_patch_saas_config_not_authenticated(\n        self, saas_example_config, saas_config_url, api_client\n    ) -> None:\n        response = api_client.patch(\n            saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_patch_saas_config_wrong_scope(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 403\n\n    def test_patch_saas_config_invalid_connection_key(\n        self, saas_example_config, api_client: TestClient, generate_auth_header\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": \"nonexistent_key\"}\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 404\n\n    def test_patch_saas_config_create(\n        self,\n        saas_example_connection_config_without_saas_config,\n        saas_example_config,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\n            \"connection_key\": saas_example_connection_config_without_saas_config.key\n        }\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        updated_config = ConnectionConfig.get_by(\n            db=db,\n            field=\"key\",\n            value=saas_example_connection_config_without_saas_config.key,\n        )\n        db.expire(updated_config)\n        saas_config = updated_config.saas_config\n        assert saas_config is not None\n\n    def test_patch_saas_config_update(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        saas_example_config[\"endpoints\"].pop()\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        connection_config = ConnectionConfig.get_by(\n            db=db, field=\"key\", value=saas_example_config[\"fides_key\"]\n        )\n        saas_config = connection_config.saas_config\n        assert saas_config is not None\n        assert len(saas_config[\"endpoints\"]) == 11\n\n\ndef get_saas_config_url(connection_config: Optional[ConnectionConfig] = None) -> str:\n    \"\"\"Helper to construct the SAAS_CONFIG URL, substituting valid/invalid keys in the path\"\"\"\n    path = V1_URL_PREFIX + SAAS_CONFIG\n    connection_key = \"nonexistent_key\"\n    if connection_config:\n        connection_key = connection_config.key\n    path_params = {\"connection_key\": connection_key}\n    return path.format(**path_params)\n\n\n@pytest.mark.unit_saas\nclass TestGetSaaSConfig:\n    def test_get_saas_config_not_authenticated(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.get(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_get_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_get_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 200\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"fides_key\"]\n            == saas_example_connection_config.get_saas_config().fides_key\n        )\n        assert len(response_body[\"endpoints\"]) == 12\n        assert response_body[\"type\"] == \"custom\"\n\n\n@pytest.mark.unit_saas\nclass TestDeleteSaaSConfig:\n    def test_delete_saas_config_not_authenticated(\n        self, saas_example_connection_config, api_client\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.delete(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_delete_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_delete_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config(\n        self,\n        db: Session,\n        saas_example_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        # Create a new connection config so we don't run into issues trying to clean up an\n        # already deleted fixture\n        fides_key = \"saas_config_for_deletion_test\"\n        saas_example_config[\"fides_key\"] = fides_key\n        config_to_delete = ConnectionConfig.create(\n            db=db,\n            data={\n                \"key\": fides_key,\n                \"name\": fides_key,\n                \"connection_type\": ConnectionType.saas,\n                \"access\": AccessLevel.read,\n                \"saas_config\": saas_example_config,\n            },\n        )\n        saas_config_url = get_saas_config_url(config_to_delete)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 204\n\n        updated_config = ConnectionConfig.get_by(db=db, field=\"key\", value=fides_key)\n        db.expire(updated_config)\n        assert updated_config.saas_config is None\n\n    def test_delete_saas_config_with_dataset_and_secrets(\n        self,\n        saas_example_connection_config,\n        saas_example_dataset_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 400\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"detail\"]\n            == f\"Must delete the dataset with fides_key '{saas_example_dataset_config.fides_key}' \"\n            \"before deleting this SaaS config. Must clear the secrets from this connection \"\n            \"config before deleting the SaaS config.\"\n        )\n\n\nclass TestAuthorizeConnection:\n    @pytest.fixture\n    def authorize_url(self, oauth2_authorization_code_connection_config) -> str:\n        path = V1_URL_PREFIX + AUTHORIZE\n        path_params = {\n            \"connection_key\": oauth2_authorization_code_connection_config.key\n        }\n        return path.format(**path_params)\n\n    def test_client_not_authenticated(self, api_client: TestClient, authorize_url):\n        response = api_client.get(authorize_url)\n        assert response.status_code == 401\n\n    def test_client_wrong_scope(\n        self, api_client: TestClient, authorize_url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header([CLIENT_READ])\n        response = api_client.get(authorize_url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.saas_config_endpoints.OAuth2AuthorizationCodeAuthenticationStrategy.get_authorization_url\"\n    )\n    def test_get_authorize_url(\n        self,\n        authorization_url_mock: MagicMock,\n        api_client: TestClient,\n        authorize_url,\n        generate_auth_header,\n    ):\n        authorization_url = \"https://localhost/auth/authorize\"\n        authorization_url_mock.return_value = authorization_url\n        auth_header = generate_auth_header([CONNECTION_AUTHORIZE])\n        response = api_client.get(authorize_url, headers=auth_header)\n        response.raise_for_status()\n        assert response.text == f'\"{authorization_url}\"'\n\n\nclass TestRegisterConnectorTemplate:\n    @pytest.fixture\n    def register_connector_template_url(self) -> str:\n        return V1_URL_PREFIX + REGISTER_CONNECTOR_TEMPLATE\n\n    @pytest.fixture\n    def complete_connector_template(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_config(\n        self,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_config(\n        self,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": \"planet_express_config\",\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_config(\n        self,\n        planet_express_invalid_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_invalid_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_dataset(\n        self,\n        planet_express_config,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_dataset(\n        self,\n        planet_express_config,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": \"planet_express_dataset\",\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_dataset(\n        self,\n        planet_express_config,\n        planet_express_invalid_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_invalid_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_functions(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_icon(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_configs(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"1_config.yml\": planet_express_config,\n                \"2_config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_datasets(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"1_dataset.yml\": planet_express_dataset,\n                \"2_dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_functions(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"1_functions.py\": planet_express_functions,\n                \"2_functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_icons(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"1_icon.svg\": planet_express_icon,\n                \"2_icon.svg\": planet_express_icon,\n            }\n        )\n\n    def test_register_connector_template_wrong_scope(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        complete_connector_template,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n        auth_header = generate_auth_header(scopes=[CLIENT_READ])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    complete_connector_template,\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_missing_config\",\n                400,\n                {\"detail\": \"Zip file does not contain a config.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_config\",\n                400,\n                {\n                    \"detail\": \"Config contents do not contain a 'saas_config' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_config\",\n                400,\n                {\n                    \"detail\": \"1 validation error for SaaSConfig\\ntest_request\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_missing_dataset\",\n                400,\n                {\"detail\": \"Zip file does not contain a dataset.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_dataset\",\n                400,\n                {\n                    \"detail\": \"Dataset contents do not contain a 'dataset' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_dataset\",\n                400,\n                {\n                    \"detail\": \"1 validation error for Dataset\\ncollections -> 0 -> name\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_no_functions\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_no_icon\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_duplicate_configs\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with config.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_datasets\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_functions\",\n                400,\n                {\"detail\": \"Multiple Python (.py) files found, only one is allowed.\"},\n            ),\n            (\n                \"connector_template_duplicate_icons\",\n                400,\n                {\"detail\": \"Multiple svg files found, only one is allowed.\"},\n            ),\n        ],\n    )\n    @mock.patch(\n        \"fides.api.service.connectors.saas.connector_registry_service.register_custom_functions\"\n    )  # prevent functions from being registered to avoid test conflicts\n    def test_register_connector_template_allow_custom_connector_functions(\n        self,\n        mock_register_custom_functions: MagicMock,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                400,\n                {\n                    \"detail\": \"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n                },\n            ),\n            (\n                \"connector_template_no_functions\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n        ],\n    )\n    def test_register_connector_template_disallow_custom_connector_functions(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        CONFIG.security.allow_custom_connector_functions = False\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details\n", "from typing import Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\n\n\nclass TestCustomConnectorTemplate:\n    def test_create_custom_connector_template(\n        self,\n        db: Session,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ) -> None:\n        template = CustomConnectorTemplate(\n            key=\"planet_express\",\n            name=\"Planet Express\",\n            config=planet_express_config,\n            dataset=planet_express_dataset,\n            icon=planet_express_icon,\n            functions=planet_express_functions,\n        )\n        template.save(db=db)\n\n        # assert we can retrieve a connector template by key and\n        # that the values are the same as what we persisted\n        custom_connector: Optional[\n            CustomConnectorTemplate\n        ] = CustomConnectorTemplate.get_by_key_or_id(\n            db=db, data={\"key\": \"planet_express\"}\n        )\n        assert custom_connector\n        assert custom_connector.name == \"Planet Express\"\n        assert custom_connector.config == planet_express_config\n        assert custom_connector.dataset == planet_express_dataset\n        assert custom_connector.icon == planet_express_icon\n        assert custom_connector.functions == planet_express_functions\n", "import os\nfrom io import BytesIO\nfrom unittest import mock\nfrom unittest.mock import MagicMock\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom fides.api.common_exceptions import NoSuchSaaSRequestOverrideException\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.service.authentication.authentication_strategy import (\n    AuthenticationStrategy,\n)\nfrom fides.api.service.connectors.saas.connector_registry_service import (\n    ConnectorRegistry,\n    CustomConnectorTemplateLoader,\n    FileConnectorTemplateLoader,\n    register_custom_functions,\n)\nfrom fides.api.service.saas_request.saas_request_override_factory import (\n    SaaSRequestOverrideFactory,\n    SaaSRequestType,\n)\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config_from_string,\n    load_yaml_as_string,\n    replace_version,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\nclass TestFileConnectorTemplateLoader:\n    def test_file_connector_template_loader(self):\n        loader = FileConnectorTemplateLoader()\n        connector_templates = loader.get_connector_templates()\n\n        assert connector_templates\n\n        mailchimp_connector = connector_templates.get(\"mailchimp\")\n        assert mailchimp_connector\n\n        assert mailchimp_connector.config == load_yaml_as_string(\n            \"data/saas/config/mailchimp_config.yml\"\n        )\n        assert mailchimp_connector.dataset == load_yaml_as_string(\n            \"data/saas/dataset/mailchimp_dataset.yml\"\n        )\n        assert mailchimp_connector.icon == encode_file_contents(\n            \"data/saas/icon/mailchimp.svg\"\n        )\n        assert mailchimp_connector.human_readable == \"Mailchimp\"\n\n    def test_file_connector_template_loader_connector_not_found(self):\n        connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n\n        assert connector_templates.get(\"not_found\") is None\n\n\nclass TestCustomConnectorTemplateLoader:\n    @pytest.fixture(autouse=True)\n    def reset_connector_template_loaders(self):\n        \"\"\"\n        Resets the loader singleton instances before each test\n        \"\"\"\n        FileConnectorTemplateLoader._instance = None\n        CustomConnectorTemplateLoader._instance = None\n\n    @pytest.fixture\n    def zendesk_config(self) -> str:\n        return load_yaml_as_string(\"data/saas/config/zendesk_config.yml\")\n\n    @pytest.fixture\n    def zendesk_dataset(self) -> str:\n        return load_yaml_as_string(\"data/saas/dataset/zendesk_dataset.yml\")\n\n    @pytest.fixture\n    def replaceable_zendesk_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/replaceable_zendesk_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/planet_express/replaceable_planet_express_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_zendesk_zip(\n        self, replaceable_zendesk_config, zendesk_dataset\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(replaceable_zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_zip(\n        self,\n        replaceable_planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replaceable_planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n                \"functions.py\": planet_express_functions,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    def test_custom_connector_template_loader_no_templates(self):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_template(\n        self,\n        mock_all: MagicMock,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=\"planet_express_config\",\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # verify the custom functions aren't loaded if the template is invalid\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n        with pytest.raises(NoSuchSaaSRequestOverrideException):\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.READ\n            )\n\n        # assert the strategy was not registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_functions(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        # save custom connector template to the database\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=\"planet_express_functions\",\n            )\n        ]\n\n        # verify nothing is loaded if the custom functions fail to load\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_custom_connector_functions_disabled(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = False\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n        with pytest.raises(NoSuchSaaSRequestOverrideException):\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.READ\n            )\n\n        # assert the strategy was not registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_custom_connector_functions_disabled_custom_functions(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        \"\"\"\n        A connector template with no custom functions should still be loaded\n        even if allow_custom_connector_functions is set to false\n        \"\"\"\n\n        CONFIG.security.allow_custom_connector_functions = False\n\n        # save custom connector template to the database\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=None,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n\n        # verify that the template in the registry is the same as the one in the database\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n        # assert the request override was registered\n        SaaSRequestOverrideFactory.get_override(\n            \"planet_express_user_access\", SaaSRequestType.READ\n        )\n\n        # assert the strategy was registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_loaders_have_separate_instances(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        file_connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n        custom_connector_templates = (\n            CustomConnectorTemplateLoader.get_connector_templates()\n        )\n\n        assert file_connector_templates != custom_connector_templates\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # verify that a connector template can updated with no issue\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n        assert mock_create_or_update.call_count == 2\n\n    def test_custom_connector_template_loader_disallowed_modules(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        with pytest.raises(SyntaxError) as exc:\n            CustomConnectorTemplateLoader.save_template(\n                MagicMock(),\n                ZipFile(\n                    create_zip_file(\n                        {\n                            \"config.yml\": planet_express_config,\n                            \"dataset.yml\": planet_express_dataset,\n                            \"functions.py\": \"import os\",\n                            \"icon.svg\": planet_express_icon,\n                        }\n                    )\n                ),\n            )\n        assert \"Import of 'os' module is not allowed.\" == str(exc.value)\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        deleted when a newer version of the connector template is found in\n        the FileConnectorTemplateLoader.\n        \"\"\"\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=replace_version(zendesk_config, \"0.0.0\"),\n                dataset=zendesk_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert (\n            saas_config[\"version\"] == load_config_from_string(zendesk_config)[\"version\"]\n        )\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {}\n        mock_delete.assert_called_once()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_not_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        not deleted if a newer version of the connector template is not found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        planet_express_config = replace_version(planet_express_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"planet_express\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                human_readable=\"Planet Express\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_not_replaceable(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing custom connector template flagged as not replaceable is\n        not deleted even if a newer version of the connector template is found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        zendesk_config = replace_version(zendesk_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                replaceable=False,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"zendesk\": ConnectorTemplate(\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                human_readable=\"Zendesk\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_existing_template(\n        self, mock_create_or_update: MagicMock, zendesk_config, replaceable_zendesk_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template takes on the version of the existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_zendesk_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        existing_config = load_config_from_string(zendesk_config)\n        assert custom_config[\"version\"] == existing_config[\"version\"]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_new_template(\n        self, mock_create_or_update: MagicMock, replaceable_planet_express_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template keeps its version if there is no existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_planet_express_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.1\"\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_non_replaceable_template(\n        self,\n        mock_create_or_update: MagicMock,\n        non_replaceable_zendesk_zip,\n    ):\n        \"\"\"\n        Verify that a non replaceable connector template keeps its version even if there is an existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(non_replaceable_zendesk_zip)\n        )\n        assert not mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.0\"\n\n\nclass TestRegisterCustomFunctions:\n    def test_function_loader(self):\n        \"\"\"Verify that all override implementations can be loaded by RestrictedPython\"\"\"\n\n        overrides_path = \"src/fides/api/service/saas_request/override_implementations\"\n\n        for filename in os.listdir(overrides_path):\n            if filename.endswith(\".py\") and filename != \"__init__.py\":\n                file_path = os.path.join(overrides_path, filename)\n                with open(file_path, \"r\") as file:\n                    register_custom_functions(file.read())\n"], "fixing_code": ["import {\n  Box,\n  Button,\n  ButtonGroup,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n  Text,\n  useToast,\n} from \"@fidesui/react\";\nimport { FetchBaseQueryError } from \"@reduxjs/toolkit/dist/query/fetchBaseQuery\";\nimport React, { useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { useDispatch } from \"react-redux\";\n\nimport { getErrorMessage } from \"~/features/common/helpers\";\nimport { errorToastParams, successToastParams } from \"~/features/common/toast\";\nimport {\n  setConnectionOptions,\n  useGetAllConnectionTypesQuery,\n} from \"~/features/connection-type\";\n\nimport { useRegisterConnectorTemplateMutation } from \"./connector-template.slice\";\n\ntype RequestModalProps = {\n  isOpen: boolean;\n  onClose: () => void;\n  testId?: String;\n};\n\nconst ConnectorTemplateUploadModal: React.FC<RequestModalProps> = ({\n  isOpen,\n  onClose,\n  testId = \"connector-template-modal\",\n}) => {\n  const dispatch = useDispatch();\n  const [uploadedFile, setUploadedFile] = useState<File | null>(null);\n  const toast = useToast();\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop: (acceptedFiles: File[]) => {\n      const file = acceptedFiles[0];\n      const fileExtension = file.name.split(\".\").pop()?.toLowerCase();\n\n      if (fileExtension !== \"zip\") {\n        toast(errorToastParams(\"Only zip files are allowed.\"));\n        return;\n      }\n\n      setUploadedFile(acceptedFiles[0]);\n    },\n  });\n\n  const [registerConnectorTemplate, { isLoading }] =\n    useRegisterConnectorTemplateMutation();\n  const { refetch: refetchConnectionTypes } = useGetAllConnectionTypesQuery(\n    {\n      search: \"\",\n    },\n    {\n      skip: false,\n    }\n  );\n\n  const handleSubmit = async () => {\n    if (uploadedFile) {\n      try {\n        await registerConnectorTemplate(uploadedFile).unwrap();\n        toast(\n          successToastParams(\"Integration template uploaded successfully.\")\n        );\n\n        // refresh the connection types\n        const { data } = await refetchConnectionTypes();\n        dispatch(setConnectionOptions(data?.items ?? []));\n        onClose();\n      } catch (error) {\n        toast(errorToastParams(getErrorMessage(error as FetchBaseQueryError)));\n      } finally {\n        setUploadedFile(null);\n      }\n    }\n  };\n\n  const renderFileText = () => {\n    if (uploadedFile) {\n      return <Text>{uploadedFile.name}</Text>;\n    }\n    if (isDragActive) {\n      return <Text>Drop the file here...</Text>;\n    }\n    return <Text>Click or drag and drop your file here.</Text>;\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} size=\"2xl\">\n      <ModalOverlay />\n      <ModalContent textAlign=\"left\" p={2} data-testid={testId}>\n        <ModalHeader>Upload integration template</ModalHeader>\n        <ModalBody>\n          <Text fontSize=\"sm\" mb={4}>\n            Drag and drop your integration template zip file here, or click to\n            browse your files.\n          </Text>\n          <Box\n            {...getRootProps()}\n            bg={isDragActive ? \"gray.100\" : \"gray.50\"}\n            border=\"2px dashed\"\n            borderColor={isDragActive ? \"gray.300\" : \"gray.200\"}\n            borderRadius=\"md\"\n            cursor=\"pointer\"\n            minHeight=\"150px\"\n            display=\"flex\"\n            alignItems=\"center\"\n            justifyContent=\"center\"\n            textAlign=\"center\"\n          >\n            <input {...getInputProps()} />\n            {renderFileText()}\n          </Box>\n          <Text fontSize=\"sm\" mt={4}>\n            An integration template zip file must include a SaaS config and\n            dataset, but may also contain an icon (.svg) as an optional file.\n          </Text>\n        </ModalBody>\n        <ModalFooter>\n          <ButtonGroup\n            size=\"sm\"\n            spacing=\"2\"\n            width=\"100%\"\n            display=\"flex\"\n            justifyContent=\"right\"\n          >\n            <Button\n              variant=\"outline\"\n              onClick={onClose}\n              data-testid=\"cancel-btn\"\n              isDisabled={isLoading}\n            >\n              Cancel\n            </Button>\n            <Button\n              colorScheme=\"primary\"\n              type=\"submit\"\n              isDisabled={!uploadedFile || isLoading}\n              onClick={handleSubmit}\n              data-testid=\"submit-btn\"\n            >\n              Submit\n            </Button>\n          </ButtonGroup>\n        </ModalFooter>\n      </ModalContent>\n    </Modal>\n  );\n};\n\nexport default ConnectorTemplateUploadModal;\n", "services:\n  fides:\n    container_name: fides\n    image: ethyca/fides:local\n    command: uvicorn --host 0.0.0.0 --port 8080 --reload --reload-dir src --reload-dir data --reload-include='*.yml' fides.api.main:app\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://0.0.0.0:8080/health\"]\n      interval: 20s\n      timeout: 5s\n      retries: 10\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      fides-db:\n        condition: service_healthy\n      redis:\n        condition: service_started\n    expose:\n      - 8080\n    env_file:\n      - .env\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n      FIDES__CLI__SERVER_HOST: \"fides\"\n      FIDES__CLI__SERVER_PORT: \"8080\"\n      FIDES__DATABASE__SERVER: \"fides-db\"\n      FIDES__DEV_MODE: \"True\"\n      FIDES__LOGGING__COLORIZE: \"True\"\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n      FIDES__SECURITY__BASTION_SERVER_HOST: ${FIDES__SECURITY__BASTION_SERVER_HOST-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME: ${FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY: ${FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY-}\n      VAULT_ADDR: ${VAULT_ADDR-}\n      VAULT_NAMESPACE: ${VAULT_NAMESPACE-}\n      VAULT_TOKEN: ${VAULT_TOKEN-}\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n\n  fides-ui:\n    image: ethyca/fides:local-ui\n    command: npm run dev-admin-ui\n    expose:\n      - 3000\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/admin-ui/node_modules\n    environment:\n      - NEXT_PUBLIC_FIDESCTL_API_SERVER=http://fides:8080\n\n  fides-pc:\n    image: ethyca/fides:local-pc\n    command: npm run dev-pc\n    expose:\n      - 3000\n    ports:\n      - \"3001:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/privacy-center/node_modules\n\n  fides-db:\n    image: postgres:12\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 15s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - postgres:/var/lib/postgresql/data\n    expose:\n      - 5432\n    ports:\n      - \"5432:5432\"\n    environment:\n      POSTGRES_USER: \"postgres\"\n      POSTGRES_PASSWORD: \"fides\"\n      POSTGRES_DB: \"fides\"\n    deploy:\n      placement:\n        constraints:\n          - node.labels.fides.app-db-data == true\n\n  docs:\n    build:\n      context: .\n      dockerfile: docs/fides/Dockerfile\n    volumes:\n      - ./docs/fides:/docs\n      - ./:/fides\n    expose:\n      - 8000\n    ports:\n      - \"8000:8000\"\n    environment:\n      FIDES__DEV_MODE: True\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n\n      # Required security env vars\n      FIDES__SECURITY__APP_ENCRYPTION_KEY: OLMkv91j8DHiDAULnK5Lxx3kSCov30b3\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_ID: fidesadmin\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_SECRET: fidesadminsecret\n      FIDES__SECURITY__DRP_JWT_SECRET: secret\n\n  worker:\n    image: ethyca/fides:local\n    command: fides worker\n    depends_on:\n      redis:\n        condition: service_started\n    restart: always\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n    volumes:\n      - type: bind\n        source: ./\n        target: /fides\n        read_only: False\n      - /fides/src/fides.egg-info\n\n  redis:\n    image: \"redis:6.2.5-alpine\"\n    # AUTH option #1: no authentication at all\n    # command: redis-server\n    # AUTH option #2: require password\n    command: redis-server --requirepass redispassword\n    # AUTH option #3: Redis ACL defined in redis.conf\n    # command: redis-server /usr/local/etc/redis/redis.conf\n    expose:\n      - 6379\n    ports:\n      - \"0.0.0.0:6379:6379\"\n    volumes:\n      # Mount a redis.conf file for configuration\n      # NOTE: Only used by \"AUTH option #3\" above!\n      - type: bind\n        source: ./docker/redis\n        target: /usr/local/etc/redis\n        read_only: False\n\nvolumes:\n  postgres: null\n\nnetworks:\n  fides_network:\n", "alembic==1.8.1\nAPScheduler==3.9.1.post1\nasyncpg==0.27.0\nboto3==1.26.1\ncelery[pytest]==5.2.7\ncolorama>=0.4.3\ncryptography==38.0.3\ndask==2022.9.2\ndeepdiff==6.3.0\ndefusedxml==0.7.1\nexpandvars==0.9.0\nfastapi[all]==0.89.1\nfastapi-caching[redis]==0.3.0\nfastapi-pagination[sqlalchemy]==0.11.4\nfideslang==1.4.5\nfideslog==1.2.10\nfirebase-admin==5.3.0\nGitPython==3.1.31\nhttpx==0.23.1\nhvac==0.11.2\nimportlib_resources==5.12.0\nJinja2==3.1.2\nloguru==0.6.0\nmultidimensional_urlencode==0.0.4\nokta==2.7.0\nopenpyxl==3.0.9\npackaging==23.0\npandas==1.4.3\nparamiko==3.1.0\npasslib[bcrypt]==1.7.4\nplotly==5.13.1\npyarrow==6.0.0\npyinstrument==4.5.1\npsycopg2-binary==2.9.6\npydantic==1.10.9\npydash==6.0.2\nPyJWT==2.4.0\npymongo==3.13.0\nPyMySQL==1.0.2\npymssql==2.2.8\npython-jose[cryptography]==3.3.0\npyyaml==6.0.1\nredis==3.5.3\nrich-click==1.6.1\nsendgrid==6.9.7\nslowapi==0.1.8\nsnowflake-sqlalchemy==1.4.3\nsqlalchemy[asyncio]==1.4.27\nsqlalchemy-citext==1.8.0\nsqlalchemy-bigquery==1.4.4\nsqlalchemy-redshift==0.8.11\nsqlalchemy-stubs==0.4\nSQLAlchemy-Utils==0.38.3\nsshtunnel==0.4.0\ntoml==0.10.2\ntwilio==7.15.0\ntyping_extensions==4.5.0 # pinned to work around https://github.com/pydantic/pydantic/issues/5821\nUnidecode==1.3.4\nvalidators==0.20.0\nversioneer==0.19\n", "from typing import Optional\n\nfrom fideslang.models import Dataset\nfrom pydantic import BaseModel, validator\n\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.service.authentication.authentication_strategy_oauth2_authorization_code import (\n    OAuth2AuthorizationCodeAuthenticationStrategy,\n)\nfrom fides.api.util.saas_util import load_config_from_string, load_dataset_from_string\n\n\nclass ConnectorTemplate(BaseModel):\n    \"\"\"\n    A collection of artifacts that make up a complete\n    SaaS connector (SaaS config, dataset, icon, etc.)\n    \"\"\"\n\n    config: str\n    dataset: str\n    icon: Optional[str]\n    human_readable: str\n\n    @validator(\"config\")\n    def validate_config(cls, config: str) -> str:\n        \"\"\"Validates the config at the given path\"\"\"\n        saas_config = SaaSConfig(**load_config_from_string(config))\n        if saas_config.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"\n            )\n        return config\n\n    @validator(\"dataset\")\n    def validate_dataset(cls, dataset: str) -> str:\n        \"\"\"Validates the dataset at the given path\"\"\"\n        saas_dataset = Dataset(**load_dataset_from_string(dataset))\n        if saas_dataset.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"\n            )\n        return dataset\n\n    @property\n    def authorization_required(self) -> bool:\n        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"\n\n        config = SaaSConfig(**load_config_from_string(self.config))\n        authentication = config.client_config.authentication\n        return (\n            authentication.strategy\n            == OAuth2AuthorizationCodeAuthenticationStrategy.name\n            if authentication\n            else False\n        )\n\n    @property\n    def user_guide(self) -> Optional[str]:\n        config = SaaSConfig(**load_config_from_string(self.config))\n        return config.user_guide\n", "# pylint: disable=protected-access\nimport os\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Iterable, List, Optional, Type\nfrom zipfile import ZipFile\n\nfrom fideslang.models import Dataset\nfrom loguru import logger\nfrom packaging.version import Version\nfrom packaging.version import parse as parse_version\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.common_exceptions import ValidationError\nfrom fides.api.cryptography.cryptographic_util import str_to_b64_str\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.schemas.connection_configuration.saas_config_template_values import (\n    SaasConnectionTemplateValues,\n)\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config,\n    load_config_from_string,\n    load_dataset_from_string,\n    load_yaml_as_string,\n    replace_config_placeholders,\n    replace_dataset_placeholders,\n    replace_version,\n)\nfrom fides.api.util.unsafe_file_util import verify_svg, verify_zip\n\n\nclass ConnectorTemplateLoader(ABC):\n    _instance: Optional[\"ConnectorTemplateLoader\"] = None\n\n    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._templates = {}  # type: ignore[attr-defined]\n            cls._instance._load_connector_templates()\n        return cls._instance\n\n    @classmethod\n    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"Returns a map of connection templates.\"\"\"\n        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]\n\n    @abstractmethod\n    def _load_connector_templates(self) -> None:\n        \"\"\"Load connector templates into the _templates dictionary\"\"\"\n\n\nclass FileConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads SaaS connector templates from the data/saas directory.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the data/saas directory\")\n        for file in os.listdir(\"data/saas/config\"):\n            if file.endswith(\".yml\"):\n                config_file = os.path.join(\"data/saas/config\", file)\n                config_dict = load_config(config_file)\n                connector_type = config_dict[\"type\"]\n                human_readable = config_dict[\"name\"]\n\n                try:\n                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")\n                except FileNotFoundError:\n                    logger.debug(\n                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"\n                    )\n                    icon = encode_file_contents(\"data/saas/icon/default.svg\")\n\n                # store connector template for retrieval\n                try:\n                    FileConnectorTemplateLoader.get_connector_templates()[\n                        connector_type\n                    ] = ConnectorTemplate(\n                        config=load_yaml_as_string(config_file),\n                        dataset=load_yaml_as_string(\n                            f\"data/saas/dataset/{connector_type}_dataset.yml\"\n                        ),\n                        icon=icon,\n                        human_readable=human_readable,\n                    )\n                except Exception:\n                    logger.exception(\"Unable to load {} connector\", connector_type)\n\n\nclass CustomConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads custom connector templates defined in the custom_connector_template database table.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the database.\")\n        db = get_api_session()\n        for template in CustomConnectorTemplate.all(db=db):\n            if (\n                template.replaceable\n                and CustomConnectorTemplateLoader._replacement_available(template)\n            ):\n                logger.info(\n                    f\"Replacing {template.key} connector template with newer version.\"\n                )\n                template.delete(db=db)\n                continue\n            try:\n                CustomConnectorTemplateLoader._register_template(template)\n            except Exception:\n                logger.exception(\"Unable to load {} connector\", template.key)\n\n    @staticmethod\n    def _replacement_available(template: CustomConnectorTemplate) -> bool:\n        \"\"\"\n        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.\n        \"\"\"\n        replacement_connector = (\n            FileConnectorTemplateLoader.get_connector_templates().get(template.key)\n        )\n        if not replacement_connector:\n            return False\n\n        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))\n        replacement_saas_config = SaaSConfig(\n            **load_config_from_string(replacement_connector.config)\n        )\n        return parse_version(replacement_saas_config.version) > parse_version(\n            custom_saas_config.version\n        )\n\n    @classmethod\n    def _register_template(\n        cls,\n        template: CustomConnectorTemplate,\n    ) -> None:\n        \"\"\"\n        Registers a custom connector template by converting it to a ConnectorTemplate\n        and adding it to the loader's template dictionary.\n        \"\"\"\n        connector_template = ConnectorTemplate(\n            config=template.config,\n            dataset=template.dataset,\n            icon=template.icon,\n            human_readable=template.name,\n        )\n\n        # register the template in the loader's template dictionary\n        CustomConnectorTemplateLoader.get_connector_templates()[\n            template.key\n        ] = connector_template\n\n    # pylint: disable=too-many-branches\n    @classmethod\n    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    verify_svg(file_contents)\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n\n\nclass ConnectorRegistry:\n    @classmethod\n    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"\n        Returns a combined map of connector templates from all registered loaders.\n        The resulting map is an aggregation of templates from the file loader and the custom loader,\n        with custom loader templates taking precedence in case of conflicts.\n        \"\"\"\n        return {\n            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n        }\n\n    @classmethod\n    def connector_types(cls) -> List[str]:\n        \"\"\"List of registered SaaS connector types\"\"\"\n        return list(cls._get_combined_templates().keys())\n\n    @classmethod\n    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:\n        \"\"\"\n        Returns an object containing the various SaaS connector artifacts\n        \"\"\"\n        return cls._get_combined_templates().get(connector_type)\n\n\ndef create_connection_config_from_template_no_save(\n    db: Session,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n    system_id: Optional[str] = None,\n) -> ConnectionConfig:\n    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"\n    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_values.instance_key\n    )\n\n    data = {\n        \"key\": template_values.key\n        if template_values.key\n        else template_values.instance_key,\n        \"description\": template_values.description,\n        \"connection_type\": ConnectionType.saas,\n        \"access\": AccessLevel.write,\n        \"saas_config\": config_from_template,\n    }\n    if template_values.name:\n        data[\"name\"] = template_values.name\n\n    if system_id:\n        data[\"system_id\"] = system_id\n\n    # Create SaaS ConnectionConfig\n    connection_config = ConnectionConfig.create_without_saving(db, data=data)\n\n    return connection_config\n\n\ndef upsert_dataset_config_from_template(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n) -> DatasetConfig:\n    \"\"\"\n    Creates a `DatasetConfig` from a template\n    and associates it with a ConnectionConfig.\n    If the `DatasetConfig` already exists in the db,\n    then the existing record is updated.\n    \"\"\"\n    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    dataset_from_template: Dict = replace_dataset_placeholders(\n        template.dataset, \"<instance_fides_key>\", template_values.instance_key\n    )\n    data = {\n        \"connection_config_id\": connection_config.id,\n        \"fides_key\": template_values.instance_key,\n        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset\n    }\n    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)\n    return dataset_config\n\n\ndef update_saas_configs(db: Session) -> None:\n    \"\"\"\n    Updates SaaS config instances currently in the DB if to the\n    corresponding template in the registry are found.\n\n    Effectively an \"update script\" for SaaS config instances,\n    to be run on server bootstrap.\n    \"\"\"\n    for connector_type in ConnectorRegistry.connector_types():\n        logger.debug(\n            \"Determining if any updates are needed for connectors of type {} based on templates...\",\n            connector_type,\n        )\n        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore\n            connector_type\n        )\n        saas_config = SaaSConfig(**load_config_from_string(template.config))\n        template_version: Version = parse_version(saas_config.version)\n\n        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(\n            db=db,\n            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),\n        ).all()\n        for connection_config in connection_configs:\n            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)\n            if parse_version(saas_config_instance.version) < template_version:\n                logger.info(\n                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",\n                    saas_config_instance.fides_key,\n                    connector_type,\n                    saas_config_instance.version,\n                    template_version,\n                )\n                try:\n                    update_saas_instance(\n                        db,\n                        connection_config,\n                        template,\n                        saas_config_instance,\n                    )\n                except Exception:\n                    logger.exception(\n                        \"Encountered error attempting to update SaaS config instance {}\",\n                        saas_config_instance.fides_key,\n                    )\n\n\ndef update_saas_instance(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    saas_config_instance: SaaSConfig,\n) -> None:\n    \"\"\"\n    Replace in the DB the existing SaaS instance configuration data\n    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig\n    with new instance configuration data based on the given ConnectorTemplate\n    \"\"\"\n    template_vals = SaasConnectionTemplateValues(\n        name=connection_config.name,\n        key=connection_config.key,\n        description=connection_config.description,\n        secrets=connection_config.secrets,\n        instance_key=saas_config_instance.fides_key,\n    )\n\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_vals.instance_key\n    )\n\n    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))\n\n    upsert_dataset_config_from_template(db, connection_config, template, template_vals)\n", "\"\"\"This module handles finding and parsing fides configuration files.\"\"\"\n\n# pylint: disable=C0115,C0116, E0213\nfrom typing import Dict, List, Optional, Pattern, Tuple, Union\n\nimport validators\nfrom pydantic import Field, validator\nfrom slowapi.wrappers import parse_many  # type: ignore\n\nfrom fides.api.cryptography.cryptographic_util import generate_salt, hash_with_salt\nfrom fides.api.oauth.roles import OWNER\nfrom fides.common.api.scope_registry import SCOPE_REGISTRY\n\nfrom .fides_settings import FidesSettings\n\nENV_PREFIX = \"FIDES__SECURITY__\"\n\n\nclass SecuritySettings(FidesSettings):\n    \"\"\"Configuration settings for application security.\"\"\"\n\n    aes_encryption_key_length: int = Field(\n        default=16,\n        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",\n    )\n    aes_gcm_nonce_length: int = Field(\n        default=12,\n        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",\n    )\n    app_encryption_key: str = Field(\n        default=\"\", description=\"The key used to sign Fides API access tokens.\"\n    )\n    cors_origins: List[str] = Field(\n        default=[],\n        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",\n    )\n    cors_origin_regex: Optional[Pattern] = Field(\n        default=None,\n        description=\"A regex pattern used to set the CORS origin allowlist.\",\n    )\n    drp_jwt_secret: Optional[str] = Field(\n        default=None,\n        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",\n    )\n    encoding: str = Field(\n        default=\"UTF-8\", description=\"Text encoding to use for the application.\"\n    )\n    env: str = Field(\n        default=\"dev\",\n        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",\n    )\n    identity_verification_attempt_limit: int = Field(\n        default=3,\n        description=\"The number of times identity verification will be attempted before raising an error.\",\n    )\n    oauth_root_client_id: str = Field(\n        default=\"\",\n        description=\"The value used to identify the Fides application root API client.\",\n    )\n    oauth_root_client_secret: str = Field(\n        default=\"\",\n        description=\"The secret value used to authenticate the Fides application root API client.\",\n    )\n    oauth_root_client_secret_hash: Optional[Tuple] = Field(\n        default=None,\n        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",\n    )\n    oauth_access_token_expire_minutes: int = Field(\n        default=11520,\n        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",\n    )\n    oauth_client_id_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client id used for oauth.\",\n    )\n    oauth_client_secret_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client secret used for oauth.\",\n    )\n    parent_server_password: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",\n    )\n    parent_server_username: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",\n    )\n    public_request_rate_limit: str = Field(\n        default=\"2000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",\n    )\n    rate_limit_prefix: str = Field(\n        default=\"fides-\",\n        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",\n    )\n    request_rate_limit: str = Field(\n        default=\"1000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",\n    )\n    root_user_scopes: List[str] = Field(\n        default=SCOPE_REGISTRY,\n        description=\"The list of scopes that are given to the root user.\",\n    )\n    root_user_roles: List[str] = Field(\n        default=[OWNER],\n        description=\"The list of roles that are given to the root user.\",\n    )\n    root_password: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",\n    )\n\n    root_username: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",\n    )\n    subject_request_download_link_ttl_seconds: int = Field(\n        default=432000,\n        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",\n    )\n    enable_audit_log_resource_middleware: Optional[bool] = Field(\n        default=False,\n        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",\n    )\n\n    bastion_server_host: Optional[str] = Field(\n        default=None, description=\"An optional field to store the bastion server host\"\n    )\n    bastion_server_ssh_username: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the username used to access the bastion server\",\n    )\n    bastion_server_ssh_private_key: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the key used to SSH into the bastion server.\",\n    )\n    bastion_server_ssh_timeout: float = Field(\n        default=0.1,\n        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",\n    )\n    bastion_server_ssh_tunnel_timeout: float = Field(\n        default=10,\n        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",\n    )\n\n    @validator(\"app_encryption_key\")\n    @classmethod\n    def validate_encryption_key_length(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[str]:\n        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"\n\n        # If the value is the default value, return immediately to prevent unwanted errors\n        if v == \"\":\n            return v\n\n        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:\n            raise ValueError(\n                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"\n            )\n        return v\n\n    @validator(\"cors_origins\", pre=True)\n    @classmethod\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        \"\"\"Return a list of valid origins for CORS requests\"\"\"\n\n        def validate(values: List[str]) -> None:\n            for value in values:\n                if value != \"*\":\n                    if not validators.url(value):\n                        raise ValueError(f\"{value} is not a valid url\")\n\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            values = [i.strip() for i in v.split(\",\")]\n            validate(values)\n\n            return values\n        if isinstance(v, (list, str)):\n            validate(v)  # type: ignore\n\n            return v\n        raise ValueError(v)\n\n    @validator(\"oauth_root_client_secret_hash\")\n    @classmethod\n    def assemble_root_access_token(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[Tuple]:\n        \"\"\"\n        Sets a hashed value of the root access key.\n        This is hashed as it is not wise to return a plaintext for of the\n        root credential anywhere in the system.\n        \"\"\"\n        value = values.get(\"oauth_root_client_secret\", \"\")\n\n        if not value:\n            return None\n\n        encoding = values.get(\"encoding\", \"UTF-8\")\n\n        salt = generate_salt()\n        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))\n        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore\n        return oauth_root_client_secret_hash\n\n    @validator(\"request_rate_limit\")\n    @classmethod\n    def validate_request_rate_limit(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        try:\n            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many\n            parse_many(v)\n        except ValueError:\n            message = \"\"\"\n            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]\n            e.g. 10 per hour\n            e.g. 10/hour\n            e.g. 10/hour;100/day;2000 per year\n            e.g. 100/day, 500/7days\n            \"\"\"\n            raise ValueError(message)\n        return v\n\n    @validator(\"env\")\n    @classmethod\n    def validate_env(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        if v not in [\"dev\", \"prod\"]:\n            message = \"Security environment must be either 'dev' or 'prod'.\"\n            raise ValueError(message)\n        return v\n\n    class Config:\n        env_prefix = ENV_PREFIX\n", "import json\nfrom typing import Optional\nfrom unittest import mock\nfrom unittest.mock import MagicMock\n\nimport pytest\nfrom sqlalchemy.orm import Session\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.common.api.scope_registry import (\n    CLIENT_READ,\n    CONNECTION_AUTHORIZE,\n    CONNECTOR_TEMPLATE_REGISTER,\n    SAAS_CONFIG_CREATE_OR_UPDATE,\n    SAAS_CONFIG_DELETE,\n    SAAS_CONFIG_READ,\n)\nfrom fides.common.api.v1.urn_registry import (\n    AUTHORIZE,\n    REGISTER_CONNECTOR_TEMPLATE,\n    SAAS_CONFIG,\n    SAAS_CONFIG_VALIDATE,\n    V1_URL_PREFIX,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.api.v1.endpoints.test_dataset_endpoints import _reject_key\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\n@pytest.mark.unit_saas\nclass TestValidateSaaSConfig:\n    @pytest.fixture\n    def validate_saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG_VALIDATE\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_put_validate_saas_config_not_authenticated(\n        self, saas_example_config, validate_saas_config_url: str, api_client\n    ) -> None:\n        response = api_client.put(\n            validate_saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_put_validate_dataset_wrong_scope(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.put(\n            validate_saas_config_url,\n            headers=auth_header,\n            json=saas_example_config,\n        )\n        assert response.status_code == 403\n\n    def test_put_validate_saas_config_missing_key(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"fides_key\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"fides_key\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_missing_endpoints(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"endpoints\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"endpoints\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_reference_and_identity(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"identity\"] = \"email\"\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"from\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"Must have exactly one of 'identity', 'references', or 'connector_param'\"\n        )\n\n    def test_put_validate_saas_config_wrong_reference_direction(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"to\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"References can only have a direction of 'from', found 'to'\"\n        )\n\n\n@pytest.mark.unit_saas\nclass TestPutSaaSConfig:\n    @pytest.fixture\n    def saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_patch_saas_config_not_authenticated(\n        self, saas_example_config, saas_config_url, api_client\n    ) -> None:\n        response = api_client.patch(\n            saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_patch_saas_config_wrong_scope(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 403\n\n    def test_patch_saas_config_invalid_connection_key(\n        self, saas_example_config, api_client: TestClient, generate_auth_header\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": \"nonexistent_key\"}\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 404\n\n    def test_patch_saas_config_create(\n        self,\n        saas_example_connection_config_without_saas_config,\n        saas_example_config,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\n            \"connection_key\": saas_example_connection_config_without_saas_config.key\n        }\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        updated_config = ConnectionConfig.get_by(\n            db=db,\n            field=\"key\",\n            value=saas_example_connection_config_without_saas_config.key,\n        )\n        db.expire(updated_config)\n        saas_config = updated_config.saas_config\n        assert saas_config is not None\n\n    def test_patch_saas_config_update(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        saas_example_config[\"endpoints\"].pop()\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        connection_config = ConnectionConfig.get_by(\n            db=db, field=\"key\", value=saas_example_config[\"fides_key\"]\n        )\n        saas_config = connection_config.saas_config\n        assert saas_config is not None\n        assert len(saas_config[\"endpoints\"]) == 11\n\n\ndef get_saas_config_url(connection_config: Optional[ConnectionConfig] = None) -> str:\n    \"\"\"Helper to construct the SAAS_CONFIG URL, substituting valid/invalid keys in the path\"\"\"\n    path = V1_URL_PREFIX + SAAS_CONFIG\n    connection_key = \"nonexistent_key\"\n    if connection_config:\n        connection_key = connection_config.key\n    path_params = {\"connection_key\": connection_key}\n    return path.format(**path_params)\n\n\n@pytest.mark.unit_saas\nclass TestGetSaaSConfig:\n    def test_get_saas_config_not_authenticated(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.get(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_get_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_get_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 200\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"fides_key\"]\n            == saas_example_connection_config.get_saas_config().fides_key\n        )\n        assert len(response_body[\"endpoints\"]) == 12\n        assert response_body[\"type\"] == \"custom\"\n\n\n@pytest.mark.unit_saas\nclass TestDeleteSaaSConfig:\n    def test_delete_saas_config_not_authenticated(\n        self, saas_example_connection_config, api_client\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.delete(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_delete_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_delete_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config(\n        self,\n        db: Session,\n        saas_example_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        # Create a new connection config so we don't run into issues trying to clean up an\n        # already deleted fixture\n        fides_key = \"saas_config_for_deletion_test\"\n        saas_example_config[\"fides_key\"] = fides_key\n        config_to_delete = ConnectionConfig.create(\n            db=db,\n            data={\n                \"key\": fides_key,\n                \"name\": fides_key,\n                \"connection_type\": ConnectionType.saas,\n                \"access\": AccessLevel.read,\n                \"saas_config\": saas_example_config,\n            },\n        )\n        saas_config_url = get_saas_config_url(config_to_delete)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 204\n\n        updated_config = ConnectionConfig.get_by(db=db, field=\"key\", value=fides_key)\n        db.expire(updated_config)\n        assert updated_config.saas_config is None\n\n    def test_delete_saas_config_with_dataset_and_secrets(\n        self,\n        saas_example_connection_config,\n        saas_example_dataset_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 400\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"detail\"]\n            == f\"Must delete the dataset with fides_key '{saas_example_dataset_config.fides_key}' \"\n            \"before deleting this SaaS config. Must clear the secrets from this connection \"\n            \"config before deleting the SaaS config.\"\n        )\n\n\nclass TestAuthorizeConnection:\n    @pytest.fixture\n    def authorize_url(self, oauth2_authorization_code_connection_config) -> str:\n        path = V1_URL_PREFIX + AUTHORIZE\n        path_params = {\n            \"connection_key\": oauth2_authorization_code_connection_config.key\n        }\n        return path.format(**path_params)\n\n    def test_client_not_authenticated(self, api_client: TestClient, authorize_url):\n        response = api_client.get(authorize_url)\n        assert response.status_code == 401\n\n    def test_client_wrong_scope(\n        self, api_client: TestClient, authorize_url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header([CLIENT_READ])\n        response = api_client.get(authorize_url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.saas_config_endpoints.OAuth2AuthorizationCodeAuthenticationStrategy.get_authorization_url\"\n    )\n    def test_get_authorize_url(\n        self,\n        authorization_url_mock: MagicMock,\n        api_client: TestClient,\n        authorize_url,\n        generate_auth_header,\n    ):\n        authorization_url = \"https://localhost/auth/authorize\"\n        authorization_url_mock.return_value = authorization_url\n        auth_header = generate_auth_header([CONNECTION_AUTHORIZE])\n        response = api_client.get(authorize_url, headers=auth_header)\n        response.raise_for_status()\n        assert response.text == f'\"{authorization_url}\"'\n\n\nclass TestRegisterConnectorTemplate:\n    @pytest.fixture\n    def register_connector_template_url(self) -> str:\n        return V1_URL_PREFIX + REGISTER_CONNECTOR_TEMPLATE\n\n    @pytest.fixture\n    def complete_connector_template(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_config(\n        self,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_config(\n        self,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": \"planet_express_config\",\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_config(\n        self,\n        planet_express_invalid_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_invalid_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_dataset(\n        self,\n        planet_express_config,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_dataset(\n        self,\n        planet_express_config,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": \"planet_express_dataset\",\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_dataset(\n        self,\n        planet_express_config,\n        planet_express_invalid_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_invalid_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_icon(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_configs(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"1_config.yml\": planet_express_config,\n                \"2_config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_datasets(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"1_dataset.yml\": planet_express_dataset,\n                \"2_dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_icons(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"1_icon.svg\": planet_express_icon,\n                \"2_icon.svg\": planet_express_icon,\n            }\n        )\n\n    def test_register_connector_template_wrong_scope(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        complete_connector_template,\n    ):\n        auth_header = generate_auth_header(scopes=[CLIENT_READ])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    complete_connector_template,\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_missing_config\",\n                400,\n                {\"detail\": \"Zip file does not contain a config.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_config\",\n                400,\n                {\n                    \"detail\": \"Config contents do not contain a 'saas_config' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_config\",\n                400,\n                {\n                    \"detail\": \"1 validation error for SaaSConfig\\ntest_request\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_missing_dataset\",\n                400,\n                {\"detail\": \"Zip file does not contain a dataset.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_dataset\",\n                400,\n                {\n                    \"detail\": \"Dataset contents do not contain a 'dataset' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_dataset\",\n                400,\n                {\n                    \"detail\": \"1 validation error for Dataset\\ncollections -> 0 -> name\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_no_icon\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_duplicate_configs\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with config.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_datasets\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_icons\",\n                400,\n                {\"detail\": \"Multiple svg files found, only one is allowed.\"},\n            ),\n        ],\n    )\n    def test_register_connector_template(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details\n", "from typing import Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\n\n\nclass TestCustomConnectorTemplate:\n    def test_create_custom_connector_template(\n        self,\n        db: Session,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ) -> None:\n        template = CustomConnectorTemplate(\n            key=\"planet_express\",\n            name=\"Planet Express\",\n            config=planet_express_config,\n            dataset=planet_express_dataset,\n            icon=planet_express_icon,\n        )\n        template.save(db=db)\n\n        # assert we can retrieve a connector template by key and\n        # that the values are the same as what we persisted\n        custom_connector: Optional[\n            CustomConnectorTemplate\n        ] = CustomConnectorTemplate.get_by_key_or_id(\n            db=db, data={\"key\": \"planet_express\"}\n        )\n        assert custom_connector\n        assert custom_connector.name == \"Planet Express\"\n        assert custom_connector.config == planet_express_config\n        assert custom_connector.dataset == planet_express_dataset\n        assert custom_connector.icon == planet_express_icon\n", "import os\nfrom io import BytesIO\nfrom unittest import mock\nfrom unittest.mock import MagicMock\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom fides.api.common_exceptions import NoSuchSaaSRequestOverrideException\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.service.authentication.authentication_strategy import (\n    AuthenticationStrategy,\n)\nfrom fides.api.service.connectors.saas.connector_registry_service import (\n    ConnectorRegistry,\n    CustomConnectorTemplateLoader,\n    FileConnectorTemplateLoader,\n)\nfrom fides.api.service.saas_request.saas_request_override_factory import (\n    SaaSRequestOverrideFactory,\n    SaaSRequestType,\n)\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config_from_string,\n    load_yaml_as_string,\n    replace_version,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\nclass TestFileConnectorTemplateLoader:\n    def test_file_connector_template_loader(self):\n        loader = FileConnectorTemplateLoader()\n        connector_templates = loader.get_connector_templates()\n\n        assert connector_templates\n\n        mailchimp_connector = connector_templates.get(\"mailchimp\")\n        assert mailchimp_connector\n\n        assert mailchimp_connector.config == load_yaml_as_string(\n            \"data/saas/config/mailchimp_config.yml\"\n        )\n        assert mailchimp_connector.dataset == load_yaml_as_string(\n            \"data/saas/dataset/mailchimp_dataset.yml\"\n        )\n        assert mailchimp_connector.icon == encode_file_contents(\n            \"data/saas/icon/mailchimp.svg\"\n        )\n        assert mailchimp_connector.human_readable == \"Mailchimp\"\n\n    def test_file_connector_template_loader_connector_not_found(self):\n        connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n\n        assert connector_templates.get(\"not_found\") is None\n\n\nclass TestCustomConnectorTemplateLoader:\n    @pytest.fixture(autouse=True)\n    def reset_connector_template_loaders(self):\n        \"\"\"\n        Resets the loader singleton instances before each test\n        \"\"\"\n        FileConnectorTemplateLoader._instance = None\n        CustomConnectorTemplateLoader._instance = None\n\n    @pytest.fixture\n    def zendesk_config(self) -> str:\n        return load_yaml_as_string(\"data/saas/config/zendesk_config.yml\")\n\n    @pytest.fixture\n    def zendesk_dataset(self) -> str:\n        return load_yaml_as_string(\"data/saas/dataset/zendesk_dataset.yml\")\n\n    @pytest.fixture\n    def replaceable_zendesk_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/replaceable_zendesk_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/planet_express/replaceable_planet_express_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_zendesk_zip(\n        self, replaceable_zendesk_config, zendesk_dataset\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(replaceable_zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_zip(\n        self,\n        replaceable_planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replaceable_planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    def test_custom_connector_template_loader_no_templates(self):\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_template(\n        self,\n        mock_all: MagicMock,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=\"planet_express_config\",\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n\n        # verify that the template in the registry is the same as the one in the database\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_loaders_have_separate_instances(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        # load custom connector templates from the database\n        file_connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n        custom_connector_templates = (\n            CustomConnectorTemplateLoader.get_connector_templates()\n        )\n\n        assert file_connector_templates != custom_connector_templates\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # verify that a connector template can updated with no issue\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n        assert mock_create_or_update.call_count == 2\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template_with_functions(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # assert the request override was ignored\n        with pytest.raises(NoSuchSaaSRequestOverrideException) as exc:\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.UPDATE\n            )\n        assert (\n            f\"Custom SaaS override 'planet_express_user_access' does not exist.\"\n            in str(exc.value)\n        )\n\n        # assert the strategy was ignored\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        deleted when a newer version of the connector template is found in\n        the FileConnectorTemplateLoader.\n        \"\"\"\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=replace_version(zendesk_config, \"0.0.0\"),\n                dataset=zendesk_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert (\n            saas_config[\"version\"] == load_config_from_string(zendesk_config)[\"version\"]\n        )\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {}\n        mock_delete.assert_called_once()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_not_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        not deleted if a newer version of the connector template is not found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        planet_express_config = replace_version(planet_express_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"planet_express\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                human_readable=\"Planet Express\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_not_replaceable(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing custom connector template flagged as not replaceable is\n        not deleted even if a newer version of the connector template is found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        zendesk_config = replace_version(zendesk_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                replaceable=False,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"zendesk\": ConnectorTemplate(\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                human_readable=\"Zendesk\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_existing_template(\n        self, mock_create_or_update: MagicMock, zendesk_config, replaceable_zendesk_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template takes on the version of the existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_zendesk_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        existing_config = load_config_from_string(zendesk_config)\n        assert custom_config[\"version\"] == existing_config[\"version\"]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_new_template(\n        self, mock_create_or_update: MagicMock, replaceable_planet_express_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template keeps its version if there is no existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_planet_express_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.1\"\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_non_replaceable_template(\n        self,\n        mock_create_or_update: MagicMock,\n        non_replaceable_zendesk_zip,\n    ):\n        \"\"\"\n        Verify that a non replaceable connector template keeps its version even if there is an existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(non_replaceable_zendesk_zip)\n        )\n        assert not mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.0\"\n"], "filenames": ["clients/admin-ui/src/features/connector-templates/ConnectorTemplateUploadModal.tsx", "docker-compose.yml", "requirements.txt", "src/fides/api/schemas/saas/connector_template.py", "src/fides/api/service/connectors/saas/connector_registry_service.py", "src/fides/config/security_settings.py", "tests/ops/api/v1/endpoints/test_saas_config_endpoints.py", "tests/ops/models/test_custom_connector_template.py", "tests/ops/service/connectors/test_connector_template_loaders.py"], "buggy_code_start_loc": [125, 31, 1, 16, 4, 120, 471, 15, 19], "buggy_code_end_loc": [127, 32, 46, 23, 527, 124, 857, 40, 630], "fixing_code_start_loc": [125, 30, 0, 16, 4, 119, 470, 14, 18], "fixing_code_end_loc": [126, 30, 43, 21, 426, 119, 742, 36, 484], "type": "CWE-693", "message": "Fides is an open-source privacy engineering platform for managing the fulfillment of data privacy requests in a runtime environment, and the enforcement of privacy regulations in code. The Fides webserver API allows custom integrations to be uploaded as a ZIP file. This ZIP file must contain YAML files, but Fides can be configured to also accept the inclusion of custom Python code in it. The custom code is executed in a restricted, sandboxed environment, but the sandbox can be bypassed to execute any arbitrary code. The vulnerability allows the execution of arbitrary code on the target system within the context of the webserver python process owner on the webserver container, which by default is `root`, and leverage that access to attack underlying infrastructure and integrated systems. This vulnerability affects Fides versions `2.11.0` through `2.19.0`. Exploitation is limited to API clients with the `CONNECTOR_TEMPLATE_REGISTER` authorization scope. In the Fides Admin UI this scope is restricted to highly privileged users, specifically root users and users with the owner role.  Exploitation is only possible if the security configuration parameter `allow_custom_connector_functions` is enabled by the user deploying the Fides webserver container, either in `fides.toml` or by setting the env var `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS=True`. By default this configuration parameter is disabled. The vulnerability has been patched in Fides version `2.19.0`. Users are advised to upgrade to this version or later to secure their systems against this threat. Users unable to upgrade should ensure that `allow_custom_connector_functions` in `fides.toml` and the `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS` are both either unset or explicit set to `False`.", "other": {"cve": {"id": "CVE-2023-41319", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-06T18:15:08.937", "lastModified": "2023-09-13T14:25:28.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fides is an open-source privacy engineering platform for managing the fulfillment of data privacy requests in a runtime environment, and the enforcement of privacy regulations in code. The Fides webserver API allows custom integrations to be uploaded as a ZIP file. This ZIP file must contain YAML files, but Fides can be configured to also accept the inclusion of custom Python code in it. The custom code is executed in a restricted, sandboxed environment, but the sandbox can be bypassed to execute any arbitrary code. The vulnerability allows the execution of arbitrary code on the target system within the context of the webserver python process owner on the webserver container, which by default is `root`, and leverage that access to attack underlying infrastructure and integrated systems. This vulnerability affects Fides versions `2.11.0` through `2.19.0`. Exploitation is limited to API clients with the `CONNECTOR_TEMPLATE_REGISTER` authorization scope. In the Fides Admin UI this scope is restricted to highly privileged users, specifically root users and users with the owner role.  Exploitation is only possible if the security configuration parameter `allow_custom_connector_functions` is enabled by the user deploying the Fides webserver container, either in `fides.toml` or by setting the env var `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS=True`. By default this configuration parameter is disabled. The vulnerability has been patched in Fides version `2.19.0`. Users are advised to upgrade to this version or later to secure their systems against this threat. Users unable to upgrade should ensure that `allow_custom_connector_functions` in `fides.toml` and the `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS` are both either unset or explicit set to `False`."}, {"lang": "es", "value": "Fides es una plataforma de ingenier\u00eda de privacidad de c\u00f3digo abierto para gestionar el cumplimiento de solicitudes de privacidad de datos en un entorno de ejecuci\u00f3n y la aplicaci\u00f3n de regulaciones de privacidad en c\u00f3digo. La API del servidor web de Fides permite cargar integraciones personalizadas como un archivo ZIP. Este archivo ZIP debe contener archivos YAML, pero Fides se puede configurar para que tambi\u00e9n acepte la inclusi\u00f3n de c\u00f3digo Python personalizado. El c\u00f3digo personalizado se ejecuta en un entorno restringido y aislado, pero el entorno aislado se puede omitir para ejecutar cualquier c\u00f3digo arbitrario. La vulnerabilidad permite la ejecuci\u00f3n de c\u00f3digo arbitrario en el sistema de destino dentro del contexto del propietario del proceso Python del servidor web en el contenedor del servidor web, que de forma predeterminada es \"root\", y aprovecha ese acceso para atacar la infraestructura subyacente y los sistemas integrados. Esta vulnerabilidad afecta a las versiones de Fides `2.11.0` hasta la `2.19.0`. La explotaci\u00f3n est\u00e1 limitada a clientes API con el alcance de autorizaci\u00f3n `CONNECTOR_TEMPLATE_REGISTER`. En la interfaz de usuario de administraci\u00f3n de Fides, este alcance est\u00e1 restringido a usuarios con privilegios elevados, espec\u00edficamente usuarios root y usuarios con rol de propietario. La explotaci\u00f3n solo es posible si el par\u00e1metro de configuraci\u00f3n de seguridad `allow_custom_connector_functions` est\u00e1 habilitado por el usuario que implementa el contenedor del servidor web Fides, ya sea en `fides.toml` o estableciendo la variable env `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS=True`. Por defecto este par\u00e1metro de configuraci\u00f3n est\u00e1 deshabilitado. La vulnerabilidad ha sido parcheada en la versi\u00f3n `2.19.0` de Fides. Se recomienda a los usuarios que actualicen a esta versi\u00f3n o posterior para proteger sus sistemas contra esta amenaza. Los usuarios que no puedan actualizar deben asegurarse de que `allow_custom_connector_functions` en `fides.toml` y `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS` no est\u00e9n configurados o est\u00e9n configurados expl\u00edcitamente en `False`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-693"}, {"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ethyca:fides:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.11.0", "versionEndExcluding": "2.19.0", "matchCriteriaId": "7987098A-C17F-4C91-9406-7B5BAD1786DD"}]}]}], "references": [{"url": "https://github.com/ethyca/fides/commit/5989b5fa744c8d8c340963b895a054883549358a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ethyca/fides/security/advisories/GHSA-p6p2-qq95-vq5h", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ethyca/fides/commit/5989b5fa744c8d8c340963b895a054883549358a"}}