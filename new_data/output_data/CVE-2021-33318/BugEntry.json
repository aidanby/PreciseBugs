{"buggy_code": ["<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFrameworks>netstandard2.0;netstandard2.1;netcoreapp3.1;net452;net5.0</TargetFrameworks>\n    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>\n    <Version>1.0.4.1</Version>\n    <Authors>Joel Christner</Authors>\n    <Description>Library for maintaining a match list of IP addresses and networks and comparing inputs to see if a match exists.</Description>\n    <Copyright>(c)2021 Joel Christner</Copyright>\n    <PackageProjectUrl>https://github.com/jchristn/ipmatcher</PackageProjectUrl>\n    <RepositoryUrl>https://github.com/jchristn/ipmatcher</RepositoryUrl>\n    <RepositoryType>Github</RepositoryType>\n    <PackageLicenseUrl></PackageLicenseUrl>\n    <PackageReleaseNotes>XML documentation</PackageReleaseNotes>\n    <PackageTags>ip address match netmask network mask subnet cidr</PackageTags>\n    <PackageLicenseFile>LICENSE.md</PackageLicenseFile>\n  </PropertyGroup>\n\n  <PropertyGroup Condition=\"'$(Configuration)|$(TargetFramework)|$(Platform)'=='Release|netstandard2.0|AnyCPU'\">\n    <DocumentationFile>C:\\Code\\Misc\\IpMatcher\\IpMatcher\\IpMatcher.xml</DocumentationFile>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <None Include=\"..\\LICENSE.md\">\n      <Pack>True</Pack>\n      <PackagePath></PackagePath>\n    </None>\n  </ItemGroup>\n\n</Project>\n", "<?xml version=\"1.0\"?>\n<doc>\n    <assembly>\n        <name>IpMatcher</name>\n    </assembly>\n    <members>\n        <member name=\"T:IpMatcher.Matcher\">\n            <summary>\n            IP address matcher.\n            </summary>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.#ctor\">\n            <summary>\n            Instantiate the IP address matcher.\n            </summary>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.Add(System.String,System.String)\">\n            <summary>\n            Add a node to the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n            <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.Exists(System.String,System.String)\">\n            <summary>\n            Check if an entry exists in the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n            <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n            <returns>True if entry exists.</returns>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.Remove(System.String)\">\n            <summary>\n            Remove an entry from the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e 192.168.1.0.</param>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.MatchExists(System.String)\">\n            <summary>\n            Check if an IP address matches something in the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e. 192.168.1.34.</param>\n            <returns>True if a match is found.</returns>\n        </member>\n    </members>\n</doc>\n", "using System;\nusing System.Collections;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace IpMatcher\n{\n    /// <summary>\n    /// IP address matcher.\n    /// </summary>\n    public class Matcher\n    {\n        #region Public-Members\n\n        /// <summary>\n        /// Method to invoke to send log messages.\n        /// </summary>\n        public Action<string> Logger = null;\n\n        #endregion\n\n        #region Private-Members\n\n        private string _Header = \"[IpMatcher] \";\n        private readonly object _AddressLock = new object();\n        private List<Address> _Addresses = new List<Address>();\n        private readonly object _CacheLock = new object();\n        private Dictionary<string, DateTime> _Cache = new Dictionary<string, DateTime>();\n        private static readonly byte[] _ContiguousPatterns = { 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };\n\n        #endregion\n\n        #region Constructors-and-Factories\n\n        /// <summary>\n        /// Instantiate the IP address matcher.\n        /// </summary>\n        public Matcher()\n        { \n\n        }\n\n        #endregion\n\n        #region Public-Methods\n\n        /// <summary>\n        /// Add a node to the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n        /// <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n        public void Add(string ip, string netmask)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n            if (String.IsNullOrEmpty(netmask)) throw new ArgumentNullException(nameof(netmask));\n\n            string baseAddress = GetBaseIpAddress(ip, netmask);\n            IPAddress parsed = IPAddress.Parse(baseAddress);\n            if (Exists(baseAddress, netmask)) return;\n\n            lock (_AddressLock)\n            {\n                _Addresses.Add(new Address(baseAddress, netmask));\n            }\n\n            Log(baseAddress + \" \" + netmask + \" added\");\n            return;\n        }\n\n        /// <summary>\n        /// Check if an entry exists in the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n        /// <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n        /// <returns>True if entry exists.</returns>\n        public bool Exists(string ip, string netmask)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n            if (String.IsNullOrEmpty(netmask)) throw new ArgumentNullException(nameof(netmask));\n\n            lock (_CacheLock)\n            {\n                if (_Cache.ContainsKey(ip))\n                {\n                    Log(ip + \" \" + netmask + \" exists in cache\");\n                    return true;\n                }\n            }\n\n            lock (_AddressLock)\n            {\n                Address curr = _Addresses.Where(d => d.Ip.Equals(ip) && d.Netmask.Equals(netmask)).FirstOrDefault();\n                if (curr == default(Address))\n                {\n                    Log(ip + \" \" + netmask + \" does not exist in address list\");\n                    return false;\n                }\n                else\n                {\n                    Log(ip + \" \" + netmask + \" exists in address list\");\n                    return true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Remove an entry from the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e 192.168.1.0.</param>\n        public void Remove(string ip)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n\n            lock (_CacheLock)\n            {\n                _Cache = _Cache.Where(d => !d.Key.Equals(ip)).ToDictionary(d => d.Key, d => d.Value);\n                Log(ip + \" removed from cache\");\n            }\n\n            lock (_AddressLock)\n            {\n                _Addresses = _Addresses.Where(d => !d.Ip.Equals(ip)).ToList();\n                Log(ip + \" removed from address list\");\n            }\n\n            return;\n        }\n\n        /// <summary>\n        /// Check if an IP address matches something in the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e. 192.168.1.34.</param>\n        /// <returns>True if a match is found.</returns>\n        public bool MatchExists(string ip)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n\n            IPAddress parsed = IPAddress.Parse(ip);\n\n            lock (_CacheLock)\n            {\n                if (_Cache.ContainsKey(ip))\n                {\n                    Log(ip + \" found in cache\");\n                    return true;\n                }\n            }\n\n            List<Address> networks = new List<Address>();\n\n            lock (_AddressLock)\n            {\n                Address directMatch = _Addresses.Where(d => d.Ip.Equals(ip) && d.Netmask.Equals(\"255.255.255.255\")).FirstOrDefault();\n                if (directMatch != default(Address))\n                {\n                    Log(ip + \" found in address list\");\n                    return true;\n                }\n\n                networks = _Addresses.Where(d => !d.Netmask.Equals(\"255.255.255.255\")).ToList();\n            }\n\n            if (networks.Count < 1) return false;\n\n            foreach (Address curr in networks)\n            {\n                IPAddress maskedAddress;\n                if (!ApplySubnetMask(parsed, curr.ParsedNetmask, out maskedAddress)) continue;\n\n                if (curr.ParsedAddress.Equals(maskedAddress))\n                {\n                    Log(ip + \" matched from address list\");\n\n                    lock (_CacheLock)\n                    {\n                        if (!_Cache.ContainsKey(ip)) _Cache.Add(ip, DateTime.Now);\n                        Log(ip + \" added to cache\");\n                    }\n\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Retrieve all stored addresses.\n        /// </summary>\n        /// <returns></returns>\n        public List<string> All()\n        {\n            List<string> ret = new List<string>();\n\n            lock (_AddressLock)\n            {\n                foreach (Address addr in _Addresses)\n                {\n                    ret.Add(addr.Ip + \"/\" + addr.Netmask);\n                }\n            }\n\n            return ret;\n        }\n\n        #endregion\n\n        #region Private-Methods\n\n        private void Log(string msg)\n        {\n            Logger?.Invoke(_Header + msg);\n        }\n\n        private bool ApplySubnetMask(IPAddress address, IPAddress mask, out IPAddress masked)\n        {\n            masked = null;\n            byte[] addrBytes = address.GetAddressBytes();\n            byte[] maskBytes = mask.GetAddressBytes();\n\n            byte[] maskedAddressBytes = null;\n            if (!ApplySubnetMask(addrBytes, maskBytes, out maskedAddressBytes))\n            {\n                return false;\n            }\n\n            masked = new IPAddress(maskedAddressBytes);\n            return true;\n        }\n\n        private bool ApplySubnetMask(byte[] value, byte[] mask, out byte[] masked)\n        {\n            masked = new byte[value.Length];\n            for (int i = 0; i < value.Length; i++) masked[i] = 0x00;\n\n            if (!VerifyContiguousMask(mask)) return false;\n\n            for (int i = 0; i < masked.Length; ++i)\n            {\n                masked[i] = (byte)(value[i] & mask[i]);\n            }\n\n            return true;\n        }\n\n        private bool VerifyContiguousMask(byte[] mask)\n        {\n            int i;\n\n            // Check leading one bits \n            for (i = 0; i < mask.Length; ++i)\n            {\n                byte curByte = mask[i];\n                if (curByte == 0xFF)\n                {\n                    // Full 8-bits, check next bytes. \n                }\n                else if (curByte == 0)\n                {\n                    // A full byte of 0s. \n                    // Check subsequent bytes are all zeros. \n                    break;\n                }\n                else if (Array.IndexOf<byte>(_ContiguousPatterns, curByte) != -1)\n                {\n                    // A bit-wise contiguous ending in zeros. \n                    // Check subsequent bytes are all zeros. \n                    break;\n                }\n                else\n                {\n                    // A non-contiguous pattern -> Fail. \n                    return false;\n                }\n            }\n\n            // Now check that all the subsequent bytes are all zeros. \n            for (i += 1/*next*/; i < mask.Length; ++i)\n            {\n                byte curByte = mask[i];\n                if (curByte != 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private string GetBaseIpAddress(string ip, string netmask)\n        {\n            IPAddress ipAddr = IPAddress.Parse(ip);\n            IPAddress mask = IPAddress.Parse(netmask);\n\n            byte[] ipAddrBytes = ipAddr.GetAddressBytes();\n            byte[] maskBytes = mask.GetAddressBytes();\n\n            byte[] afterAnd = And(ipAddrBytes, maskBytes);\n            IPAddress baseAddr = new IPAddress(afterAnd);\n            return baseAddr.ToString();\n        }\n\n        private byte[] And(byte[] addr, byte[] mask)\n        {\n            if (addr.Length != mask.Length)\n                throw new ArgumentException(\"Supplied arrays are not of the same length.\");\n             \n            BitArray baAddr = new BitArray(addr);\n            BitArray baMask = new BitArray(mask);\n            BitArray baResult = baAddr.And(baMask);\n            byte[] result = new byte[addr.Length];\n            baResult.CopyTo(result, 0);\n\n            /*\n            Console.WriteLine(\"Address : \" + ByteArrayToHexString(addr));\n            Console.WriteLine(\"Netmask : \" + ByteArrayToHexString(mask));\n            Console.WriteLine(\"Result  : \" + ByteArrayToHexString(result));\n            */\n\n            return result;\n        }\n\n        private byte[] ExclusiveOr(byte[] addr, byte[] mask)\n        {\n            if (addr.Length != mask.Length)\n                throw new ArgumentException(\"Supplied arrays are not of the same length.\");\n\n            /*\n            Console.WriteLine(\"Address: \" + ByteArrayToHexString(addr));\n            Console.WriteLine(\"Netmask: \" + ByteArrayToHexString(mask));\n            */\n\n            byte[] result = new byte[addr.Length];\n\n            for (int i = 0; i < addr.Length; ++i)\n                result[i] = (byte)(addr[i] ^ mask[i]);\n\n            BitArray baAddr = new BitArray(addr);\n            \n            return result;\n        }\n\n        private string ByteArrayToHexString(byte[] Bytes)\n        {\n            StringBuilder Result = new StringBuilder(Bytes.Length * 2);\n            string HexAlphabet = \"0123456789ABCDEF\";\n\n            foreach (byte B in Bytes)\n            {\n                Result.Append(HexAlphabet[(int)(B >> 4)]);\n                Result.Append(HexAlphabet[(int)(B & 0xF)]);\n            }\n\n            return Result.ToString();\n        }\n\n        #endregion\n\n        #region Private-Subordinate-Classes\n\n        internal class Address\n        {\n            internal string GUID { get; set; }\n            internal string Ip { get; set; }\n            internal string Netmask { get; set; }\n            internal IPAddress ParsedAddress { get; set; }\n            internal IPAddress ParsedNetmask { get; set; }\n\n            internal Address(string ip, string netmask)\n            {\n                GUID = Guid.NewGuid().ToString();\n                Ip = ip;\n                Netmask = netmask;\n                ParsedAddress = IPAddress.Parse(ip);\n                ParsedNetmask = IPAddress.Parse(netmask);\n            }\n        }\n\n        #endregion\n    }\n}\n"], "fixing_code": ["<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFrameworks>netstandard2.0;netstandard2.1;netcoreapp3.1;net452;net5.0</TargetFrameworks>\n    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>\n    <Version>1.0.4.2</Version>\n    <Authors>Joel Christner</Authors>\n    <Description>Library for maintaining a match list of IP addresses and networks and comparing inputs to see if a match exists.</Description>\n    <Copyright>(c)2021 Joel Christner</Copyright>\n    <PackageProjectUrl>https://github.com/jchristn/ipmatcher</PackageProjectUrl>\n    <RepositoryUrl>https://github.com/jchristn/ipmatcher</RepositoryUrl>\n    <RepositoryType>Github</RepositoryType>\n    <PackageLicenseUrl></PackageLicenseUrl>\n    <PackageReleaseNotes>Fix for SICK-2021-060</PackageReleaseNotes>\n    <PackageTags>ip address match netmask network mask subnet cidr</PackageTags>\n    <PackageLicenseFile>LICENSE.md</PackageLicenseFile>\n  </PropertyGroup>\n\n  <PropertyGroup Condition=\"'$(Configuration)|$(TargetFramework)|$(Platform)'=='Release|netstandard2.0|AnyCPU'\">\n    <DocumentationFile>IpMatcher.xml</DocumentationFile>\n  </PropertyGroup>\n\n  <PropertyGroup Condition=\"'$(Configuration)|$(TargetFramework)|$(Platform)'=='Debug|netstandard2.0|AnyCPU'\">\n    <DocumentationFile>IpMatcher.xml</DocumentationFile>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <None Include=\"..\\LICENSE.md\">\n      <Pack>True</Pack>\n      <PackagePath></PackagePath>\n    </None>\n  </ItemGroup>\n\n</Project>\n", "<?xml version=\"1.0\"?>\n<doc>\n    <assembly>\n        <name>IpMatcher</name>\n    </assembly>\n    <members>\n        <member name=\"T:IpMatcher.Matcher\">\n            <summary>\n            IP address matcher.\n            </summary>\n        </member>\n        <member name=\"F:IpMatcher.Matcher.Logger\">\n            <summary>\n            Method to invoke to send log messages.\n            </summary>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.#ctor\">\n            <summary>\n            Instantiate the IP address matcher.\n            </summary>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.Add(System.String,System.String)\">\n            <summary>\n            Add a node to the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n            <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.Exists(System.String,System.String)\">\n            <summary>\n            Check if an entry exists in the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n            <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n            <returns>True if entry exists.</returns>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.Remove(System.String)\">\n            <summary>\n            Remove an entry from the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e 192.168.1.0.</param>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.MatchExists(System.String)\">\n            <summary>\n            Check if an IP address matches something in the match list.\n            </summary>\n            <param name=\"ip\">The IP address, i.e. 192.168.1.34.</param>\n            <returns>True if a match is found.</returns>\n        </member>\n        <member name=\"M:IpMatcher.Matcher.All\">\n            <summary>\n            Retrieve all stored addresses.\n            </summary>\n            <returns></returns>\n        </member>\n    </members>\n</doc>\n", "using System;\nusing System.Collections;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace IpMatcher\n{\n    /// <summary>\n    /// IP address matcher.\n    /// </summary>\n    public class Matcher\n    {\n        #region Public-Members\n\n        /// <summary>\n        /// Method to invoke to send log messages.\n        /// </summary>\n        public Action<string> Logger = null;\n\n        #endregion\n\n        #region Private-Members\n\n        private string _Header = \"[IpMatcher] \";\n        private readonly object _AddressLock = new object();\n        private List<Address> _Addresses = new List<Address>();\n        private readonly object _CacheLock = new object();\n        private Dictionary<string, DateTime> _Cache = new Dictionary<string, DateTime>();\n        private static readonly byte[] _ContiguousPatterns = { 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };\n\n        #endregion\n\n        #region Constructors-and-Factories\n\n        /// <summary>\n        /// Instantiate the IP address matcher.\n        /// </summary>\n        public Matcher()\n        { \n\n        }\n\n        #endregion\n\n        #region Public-Methods\n\n        /// <summary>\n        /// Add a node to the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n        /// <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n        public void Add(string ip, string netmask)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n            if (String.IsNullOrEmpty(netmask)) throw new ArgumentNullException(nameof(netmask));\n\n            ip = IPAddress.Parse(ip).ToString();\n            netmask = IPAddress.Parse(netmask).ToString();\n\n            string baseAddress = GetBaseIpAddress(ip, netmask);\n            IPAddress parsed = IPAddress.Parse(baseAddress);\n            if (Exists(baseAddress, netmask)) return;\n\n            lock (_AddressLock)\n            {\n                _Addresses.Add(new Address(baseAddress, netmask));\n            }\n\n            Log(baseAddress + \" \" + netmask + \" added\");\n            return;\n        }\n\n        /// <summary>\n        /// Check if an entry exists in the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e. 192.168.1.0.</param>\n        /// <param name=\"netmask\">The netmask, i.e. 255.255.255.0.</param>\n        /// <returns>True if entry exists.</returns>\n        public bool Exists(string ip, string netmask)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n            if (String.IsNullOrEmpty(netmask)) throw new ArgumentNullException(nameof(netmask));\n\n            ip = IPAddress.Parse(ip).ToString();\n            netmask = IPAddress.Parse(netmask).ToString();\n\n            lock (_CacheLock)\n            {\n                if (_Cache.ContainsKey(ip))\n                {\n                    Log(ip + \" \" + netmask + \" exists in cache\");\n                    return true;\n                }\n            }\n\n            lock (_AddressLock)\n            {\n                Address curr = _Addresses.Where(d => d.Ip.Equals(ip) && d.Netmask.Equals(netmask)).FirstOrDefault();\n                if (curr == default(Address))\n                {\n                    Log(ip + \" \" + netmask + \" does not exist in address list\");\n                    return false;\n                }\n                else\n                {\n                    Log(ip + \" \" + netmask + \" exists in address list\");\n                    return true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Remove an entry from the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e 192.168.1.0.</param>\n        public void Remove(string ip)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n\n            ip = IPAddress.Parse(ip).ToString();\n\n            lock (_CacheLock)\n            {\n                _Cache = _Cache.Where(d => !d.Key.Equals(ip)).ToDictionary(d => d.Key, d => d.Value);\n                Log(ip + \" removed from cache\");\n            }\n\n            lock (_AddressLock)\n            {\n                _Addresses = _Addresses.Where(d => !d.Ip.Equals(ip)).ToList();\n                Log(ip + \" removed from address list\");\n            }\n\n            return;\n        }\n\n        /// <summary>\n        /// Check if an IP address matches something in the match list.\n        /// </summary>\n        /// <param name=\"ip\">The IP address, i.e. 192.168.1.34.</param>\n        /// <returns>True if a match is found.</returns>\n        public bool MatchExists(string ip)\n        {\n            if (String.IsNullOrEmpty(ip)) throw new ArgumentNullException(nameof(ip));\n\n            ip = IPAddress.Parse(ip).ToString();\n\n            IPAddress parsed = IPAddress.Parse(ip);\n\n            lock (_CacheLock)\n            {\n                if (_Cache.ContainsKey(ip))\n                {\n                    Log(ip + \" found in cache\");\n                    return true;\n                }\n            }\n\n            List<Address> networks = new List<Address>();\n\n            lock (_AddressLock)\n            {\n                Address directMatch = _Addresses.Where(d => d.Ip.Equals(ip) && d.Netmask.Equals(\"255.255.255.255\")).FirstOrDefault();\n                if (directMatch != default(Address))\n                {\n                    Log(ip + \" found in address list\");\n                    return true;\n                }\n\n                networks = _Addresses.Where(d => !d.Netmask.Equals(\"255.255.255.255\")).ToList();\n            }\n\n            if (networks.Count < 1) return false;\n\n            foreach (Address curr in networks)\n            {\n                IPAddress maskedAddress;\n                if (!ApplySubnetMask(parsed, curr.ParsedNetmask, out maskedAddress)) continue;\n\n                if (curr.ParsedAddress.Equals(maskedAddress))\n                {\n                    Log(ip + \" matched from address list\");\n\n                    lock (_CacheLock)\n                    {\n                        if (!_Cache.ContainsKey(ip)) _Cache.Add(ip, DateTime.Now);\n                        Log(ip + \" added to cache\");\n                    }\n\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Retrieve all stored addresses.\n        /// </summary>\n        /// <returns></returns>\n        public List<string> All()\n        {\n            List<string> ret = new List<string>();\n\n            lock (_AddressLock)\n            {\n                foreach (Address addr in _Addresses)\n                {\n                    ret.Add(addr.Ip + \"/\" + addr.Netmask);\n                }\n            }\n\n            return ret;\n        }\n\n        #endregion\n\n        #region Private-Methods\n\n        private void Log(string msg)\n        {\n            Logger?.Invoke(_Header + msg);\n        }\n\n        private bool ApplySubnetMask(IPAddress address, IPAddress mask, out IPAddress masked)\n        {\n            masked = null;\n            byte[] addrBytes = address.GetAddressBytes();\n            byte[] maskBytes = mask.GetAddressBytes();\n\n            byte[] maskedAddressBytes = null;\n            if (!ApplySubnetMask(addrBytes, maskBytes, out maskedAddressBytes))\n            {\n                return false;\n            }\n\n            masked = new IPAddress(maskedAddressBytes);\n            return true;\n        }\n\n        private bool ApplySubnetMask(byte[] value, byte[] mask, out byte[] masked)\n        {\n            masked = new byte[value.Length];\n            for (int i = 0; i < value.Length; i++) masked[i] = 0x00;\n\n            if (!VerifyContiguousMask(mask)) return false;\n\n            for (int i = 0; i < masked.Length; ++i)\n            {\n                masked[i] = (byte)(value[i] & mask[i]);\n            }\n\n            return true;\n        }\n\n        private bool VerifyContiguousMask(byte[] mask)\n        {\n            int i;\n\n            // Check leading one bits \n            for (i = 0; i < mask.Length; ++i)\n            {\n                byte curByte = mask[i];\n                if (curByte == 0xFF)\n                {\n                    // Full 8-bits, check next bytes. \n                }\n                else if (curByte == 0)\n                {\n                    // A full byte of 0s. \n                    // Check subsequent bytes are all zeros. \n                    break;\n                }\n                else if (Array.IndexOf<byte>(_ContiguousPatterns, curByte) != -1)\n                {\n                    // A bit-wise contiguous ending in zeros. \n                    // Check subsequent bytes are all zeros. \n                    break;\n                }\n                else\n                {\n                    // A non-contiguous pattern -> Fail. \n                    return false;\n                }\n            }\n\n            // Now check that all the subsequent bytes are all zeros. \n            for (i += 1/*next*/; i < mask.Length; ++i)\n            {\n                byte curByte = mask[i];\n                if (curByte != 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private string GetBaseIpAddress(string ip, string netmask)\n        {\n            IPAddress ipAddr = IPAddress.Parse(ip);\n            IPAddress mask = IPAddress.Parse(netmask);\n\n            byte[] ipAddrBytes = ipAddr.GetAddressBytes();\n            byte[] maskBytes = mask.GetAddressBytes();\n\n            byte[] afterAnd = And(ipAddrBytes, maskBytes);\n            IPAddress baseAddr = new IPAddress(afterAnd);\n            return baseAddr.ToString();\n        }\n\n        private byte[] And(byte[] addr, byte[] mask)\n        {\n            if (addr.Length != mask.Length)\n                throw new ArgumentException(\"Supplied arrays are not of the same length.\");\n             \n            BitArray baAddr = new BitArray(addr);\n            BitArray baMask = new BitArray(mask);\n            BitArray baResult = baAddr.And(baMask);\n            byte[] result = new byte[addr.Length];\n            baResult.CopyTo(result, 0);\n\n            /*\n            Console.WriteLine(\"Address : \" + ByteArrayToHexString(addr));\n            Console.WriteLine(\"Netmask : \" + ByteArrayToHexString(mask));\n            Console.WriteLine(\"Result  : \" + ByteArrayToHexString(result));\n            */\n\n            return result;\n        }\n\n        private byte[] ExclusiveOr(byte[] addr, byte[] mask)\n        {\n            if (addr.Length != mask.Length)\n                throw new ArgumentException(\"Supplied arrays are not of the same length.\");\n\n            /*\n            Console.WriteLine(\"Address: \" + ByteArrayToHexString(addr));\n            Console.WriteLine(\"Netmask: \" + ByteArrayToHexString(mask));\n            */\n\n            byte[] result = new byte[addr.Length];\n\n            for (int i = 0; i < addr.Length; ++i)\n                result[i] = (byte)(addr[i] ^ mask[i]);\n\n            BitArray baAddr = new BitArray(addr);\n            \n            return result;\n        }\n\n        private string ByteArrayToHexString(byte[] Bytes)\n        {\n            StringBuilder Result = new StringBuilder(Bytes.Length * 2);\n            string HexAlphabet = \"0123456789ABCDEF\";\n\n            foreach (byte B in Bytes)\n            {\n                Result.Append(HexAlphabet[(int)(B >> 4)]);\n                Result.Append(HexAlphabet[(int)(B & 0xF)]);\n            }\n\n            return Result.ToString();\n        }\n\n        #endregion\n\n        #region Private-Subordinate-Classes\n\n        internal class Address\n        {\n            internal string GUID { get; set; }\n            internal string Ip { get; set; }\n            internal string Netmask { get; set; }\n            internal IPAddress ParsedAddress { get; set; }\n            internal IPAddress ParsedNetmask { get; set; }\n\n            internal Address(string ip, string netmask)\n            {\n                GUID = Guid.NewGuid().ToString();\n                Ip = ip;\n                Netmask = netmask;\n                ParsedAddress = IPAddress.Parse(ip);\n                ParsedNetmask = IPAddress.Parse(netmask);\n            }\n        }\n\n        #endregion\n    }\n}\n"], "filenames": ["IpMatcher/IpMatcher.csproj", "IpMatcher/IpMatcher.xml", "IpMatcher/Matcher.cs"], "buggy_code_start_loc": [6, 9, 61], "buggy_code_end_loc": [21, 44, 141], "fixing_code_start_loc": [6, 10, 62], "fixing_code_end_loc": [25, 56, 152], "type": "CWE-20", "message": "An Input Validation Vulnerability exists in Joel Christner .NET C# packages WatsonWebserver, IpMatcher 1.0.4.1 and below (IpMatcher) and 4.1.3 and below (WatsonWebserver) due to insufficient validation of input IP addresses and netmasks against the internal Matcher list of IP addresses and subnets.", "other": {"cve": {"id": "CVE-2021-33318", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-16T16:15:07.810", "lastModified": "2022-05-25T14:03:53.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An Input Validation Vulnerability exists in Joel Christner .NET C# packages WatsonWebserver, IpMatcher 1.0.4.1 and below (IpMatcher) and 4.1.3 and below (WatsonWebserver) due to insufficient validation of input IP addresses and netmasks against the internal Matcher list of IP addresses and subnets."}, {"lang": "es", "value": "Se presenta una vulnerabilidad de comprobaci\u00f3n de entrada en los paquetes C# de Joel Christner .NET WatsonWebserver, IpMatcher 1.0.4.1 y anteriores (IpMatcher) y 4.1.3 y anteriores (WatsonWebserver) debido a la insuficiente comprobaci\u00f3n de las direcciones IP y m\u00e1scaras de red de entrada con respecto a la lista interna de direcciones IP y subredes de Matcher"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ipmatcher_project:ipmatcher:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.4.1", "matchCriteriaId": "118A5A14-11EB-4C37-ABCC-857404717695"}, {"vulnerable": true, "criteria": "cpe:2.3:a:watsonwebserver_project:watsonwebserver:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.1.3", "matchCriteriaId": "6C057037-0EC7-44C9-B614-0D5FD3256277"}]}]}], "references": [{"url": "https://github.com/jchristn/IpMatcher", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/jchristn/IpMatcher/commit/81d77c2f33aa912dbd032b34b9e184fc6e041d89", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jchristn/WatsonWebserver", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/kaoudis/advisories/blob/main/0-2021.md", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jchristn/IpMatcher/commit/81d77c2f33aa912dbd032b34b9e184fc6e041d89"}}