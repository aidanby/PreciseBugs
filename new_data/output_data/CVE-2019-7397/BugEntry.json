{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   DDDD   FFFFF                              %\n%                            P   P  D   D  F                                  %\n%                            PPPP   D   D  FFF                                %\n%                            P      D   D  F                                  %\n%                            P      DDDD   F                                  %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Portable Document Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/delegate-private.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n#define CCITTParam  \"-1\"\n#else\n#define CCITTParam  \"0\"\n#endif\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePDFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e P D F D e l e g a t e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokePDFDelegate() executes the PDF interpreter with the specified command.\n%\n%  The format of the InvokePDFDelegate method is:\n%\n%      MagickBooleanType InvokePDFDelegate(const MagickBooleanType verbose,\n%        const char *command,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o verbose: A value other than zero displays the command prior to\n%      executing it.\n%\n%    o command: the address of a character string containing the command to\n%      execute.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\nstatic int MagickDLLCall PDFDelegateMessage(void *handle,const char *message,\n  int length)\n{\n  char\n    **messages;\n\n  ssize_t\n    offset;\n\n  offset=0;\n  messages=(char **) handle;\n  if (*messages == (char *) NULL)\n    *messages=(char *) AcquireQuantumMemory(length+1,sizeof(char *));\n  else\n    {\n      offset=strlen(*messages);\n      *messages=(char *) ResizeQuantumMemory(*messages,offset+length+1,\n        sizeof(char *));\n    }\n  if (*messages == (char *) NULL)\n    return(0);\n  (void) memcpy(*messages+offset,message,length);\n  (*messages)[length+offset] ='\\0';\n  return(length);\n}\n#endif\n\nstatic MagickBooleanType InvokePDFDelegate(const MagickBooleanType verbose,\n  const char *command,char *message,ExceptionInfo *exception)\n{\n  int\n    status;\n\n#define ExecuteGhostscriptCommand(command,status) \\\n{ \\\n  status=ExternalDelegateCommand(MagickFalse,verbose,command,message, \\\n    exception); \\\n  if (status == 0) \\\n    return(MagickTrue); \\\n  if (status < 0) \\\n    return(MagickFalse); \\\n  (void) ThrowMagickException(exception,GetMagickModule(),DelegateError, \\\n    \"FailedToExecuteCommand\",\"`%s' (%d)\",command,status); \\\n  return(MagickFalse); \\\n}\n\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\n#define SetArgsStart(command,args_start) \\\n  if (args_start == (const char *) NULL) \\\n    { \\\n      if (*command != '\"') \\\n        args_start=strchr(command,' '); \\\n      else \\\n        { \\\n          args_start=strchr(command+1,'\"'); \\\n          if (args_start != (const char *) NULL) \\\n            args_start++; \\\n        } \\\n    }\n\n  char\n    **argv,\n    *errors;\n\n  const char\n    *args_start = (const char *) NULL;\n\n  const GhostInfo\n    *ghost_info;\n\n  gs_main_instance\n    *interpreter;\n\n  gsapi_revision_t\n    revision;\n\n  int\n    argc,\n    code;\n\n  register ssize_t\n    i;\n\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  ghost_info=NTGhostscriptDLLVectors();\n#else\n  GhostInfo\n    ghost_info_struct;\n\n  ghost_info=(&ghost_info_struct);\n  (void) memset(&ghost_info_struct,0,sizeof(ghost_info_struct));\n  ghost_info_struct.delete_instance=(void (*)(gs_main_instance *))\n    gsapi_delete_instance;\n  ghost_info_struct.exit=(int (*)(gs_main_instance *)) gsapi_exit;\n  ghost_info_struct.new_instance=(int (*)(gs_main_instance **,void *))\n    gsapi_new_instance;\n  ghost_info_struct.init_with_args=(int (*)(gs_main_instance *,int,char **))\n    gsapi_init_with_args;\n  ghost_info_struct.run_string=(int (*)(gs_main_instance *,const char *,int,\n    int *)) gsapi_run_string;\n  ghost_info_struct.set_stdio=(int (*)(gs_main_instance *,int (*)(void *,char *,\n    int),int (*)(void *,const char *,int),int (*)(void *, const char *, int)))\n    gsapi_set_stdio;\n  ghost_info_struct.revision=(int (*)(gsapi_revision_t *,int)) gsapi_revision;\n#endif\n  if (ghost_info == (GhostInfo *) NULL)\n    ExecuteGhostscriptCommand(command,status);\n  if ((ghost_info->revision)(&revision,sizeof(revision)) != 0)\n    revision.revision=0;\n  if (verbose != MagickFalse)\n    {\n      (void) fprintf(stdout,\"[ghostscript library %.2f]\",(double)\n        revision.revision/100.0);\n      SetArgsStart(command,args_start);\n      (void) fputs(args_start,stdout);\n    }\n  errors=(char *) NULL;\n  status=(ghost_info->new_instance)(&interpreter,(void *) &errors);\n  if (status < 0)\n    ExecuteGhostscriptCommand(command,status);\n  code=0;\n  argv=StringToArgv(command,&argc);\n  if (argv == (char **) NULL)\n    {\n      (ghost_info->delete_instance)(interpreter);\n      return(MagickFalse);\n    }\n  (void) (ghost_info->set_stdio)(interpreter,(int (MagickDLLCall *)(void *,\n    char *,int)) NULL,PDFDelegateMessage,PDFDelegateMessage);\n  status=(ghost_info->init_with_args)(interpreter,argc-1,argv+1);\n  if (status == 0)\n    status=(ghost_info->run_string)(interpreter,\"systemdict /start get exec\\n\",\n      0,&code);\n  (ghost_info->exit)(interpreter);\n  (ghost_info->delete_instance)(interpreter);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  if (status != 0)\n    {\n      SetArgsStart(command,args_start);\n      if (status == -101) /* quit */\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"[ghostscript library %.2f]%s: %s\",(double) revision.revision/100.0,\n          args_start,errors);\n      else\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"PDFDelegateFailed\",\"`[ghostscript library %.2f]%s': %s\",(double)\n            revision.revision/100.0,args_start,errors);\n          if (errors != (char *) NULL)\n            errors=DestroyString(errors);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Ghostscript returns status %d, exit code %d\",status,code);\n          return(MagickFalse);\n        }\n    }\n  if (errors != (char *) NULL)\n    errors=DestroyString(errors);\n  return(MagickTrue);\n#else\n  ExecuteGhostscriptCommand(command,status);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P D F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPDF() returns MagickTrue if the image format type, identified by the\n%  magick string, is PDF.\n%\n%  The format of the IsPDF method is:\n%\n%      MagickBooleanType IsPDF(const unsigned char *magick,const size_t offset)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o offset: Specifies the offset of the magick string.\n%\n*/\nstatic MagickBooleanType IsPDF(const unsigned char *magick,const size_t offset)\n{\n  if (offset < 5)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"%PDF-\",5) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P D F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPDFImage() reads a Portable Document Format image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadPDFImage method is:\n%\n%      Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType IsPDFRendered(const char *path)\n{\n  MagickBooleanType\n    status;\n\n  struct stat\n    attributes;\n\n  if ((path == (const char *) NULL) || (*path == '\\0'))\n    return(MagickFalse);\n  status=GetPathAttributes(path,&attributes);\n  if ((status != MagickFalse) && S_ISREG(attributes.st_mode) &&\n      (attributes.st_size > 0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define CMYKProcessColor  \"CMYKProcessColor\"\n#define CropBox  \"CropBox\"\n#define DefaultCMYK  \"DefaultCMYK\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define MediaBox  \"MediaBox\"\n#define RenderPostscriptText  \"Rendering Postscript...  \"\n#define PDFRotate  \"Rotate\"\n#define SpotColor  \"Separation\"\n#define TrimBox  \"TrimBox\"\n#define PDFVersion  \"PDF-\"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  double\n    angle;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *pdf_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    cropbox,\n    fitPage,\n    status,\n    stop_on_error,\n    trimbox;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  size_t\n    scene,\n    spotcolor;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) memset(&page,0,sizeof(page));\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)-\n    0.5);\n  page.height=(size_t) ceil((double) (page.height*image->resolution.y/delta.y)-\n    0.5);\n  /*\n    Determine page geometry from the PDF media box.\n  */\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  cropbox=IsStringTrue(GetImageOption(image_info,\"pdf:use-cropbox\"));\n  stop_on_error=IsStringTrue(GetImageOption(image_info,\"pdf:stop-on-error\"));\n  trimbox=IsStringTrue(GetImageOption(image_info,\"pdf:use-trimbox\"));\n  count=0;\n  spotcolor=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&hires_bounds,0,sizeof(hires_bounds));\n  (void) memset(command,0,sizeof(command));\n  angle=0.0;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note PDF elements.\n    */\n    if (c == '\\n')\n      c=' ';\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != (int) '%') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *(--p)='\\0';\n    p=command;\n    if (LocaleNCompare(PDFRotate,command,strlen(PDFRotate)) == 0)\n      count=(ssize_t) sscanf(command,\"Rotate %lf\",&angle);\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DefaultCMYK,command,strlen(DefaultCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0)\n      {\n        char\n          name[MagickPathExtent],\n          property[MagickPathExtent],\n          *value;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \"pdf:SpotColor-%.20g\",(double) spotcolor++);\n        i=0;\n        for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n        {\n          if ((isspace(c) != 0) || (c == '/') || ((i+1) == MagickPathExtent))\n            break;\n          name[i++]=(char) c;\n        }\n        name[i]='\\0';\n        value=ConstantString(name);\n        (void) SubstituteString(&value,\"#20\",\" \");\n        if (*value != '\\0')\n          (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (LocaleNCompare(PDFVersion,command,strlen(PDFVersion)) == 0)\n      (void) SetImageProperty(image,\"pdf:Version\",command,exception);\n    if (image_info->page != (char *) NULL)\n      continue;\n    count=0;\n    if (cropbox != MagickFalse)\n      {\n        if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n          {\n            /*\n              Note region defined by crop box.\n            */\n            count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n              &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n            if (count != 4)\n              count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n                &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n          }\n      }\n    else\n      if (trimbox != MagickFalse)\n        {\n          if (LocaleNCompare(TrimBox,command,strlen(TrimBox)) == 0)\n            {\n              /*\n                Note region defined by trim box.\n              */\n              count=(ssize_t) sscanf(command,\"TrimBox [%lf %lf %lf %lf\",\n                &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n              if (count != 4)\n                count=(ssize_t) sscanf(command,\"TrimBox[%lf %lf %lf %lf\",\n                  &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n            }\n        }\n      else\n        if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n          {\n            /*\n              Note region defined by media box.\n            */\n            count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n              &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n            if (count != 4)\n              count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n                &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n          }\n    if (count != 4)\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      continue;\n    hires_bounds=bounds;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set PDF render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"pdf:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        image->resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        image->resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"pdf:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      page_geometry=DestroyString(page_geometry);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n        -0.5);\n      page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n        delta.y) -0.5);\n      fitPage=MagickTrue;\n    }\n  if ((fabs(angle) == 90.0) || (fabs(angle) == 270.0))\n    {\n      size_t\n        swap;\n\n      swap=page.width;\n      page.width=page.height;\n      page.height=swap;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  count=write(file,\" \",1);\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if ((image_info->page != (char *) NULL) || (fitPage != MagickFalse))\n    (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n      page.width,(double) page.height);\n  if (fitPage != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPSFitPage \",MagickPathExtent);\n  if (cmyk != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseCIEColor \",MagickPathExtent);\n  if (cropbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseCropBox \",MagickPathExtent);\n  if (stop_on_error != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPDFSTOPONERROR \",\n      MagickPathExtent);\n  if (trimbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseTrimBox \",MagickPathExtent);\n  option=GetImageOption(image_info,\"authenticate\");\n  if (option != (char *) NULL)\n    {\n      char\n        passphrase[MagickPathExtent];\n\n      (void) FormatLocaleString(passphrase,MagickPathExtent,\n        \"\\\"-sPDFPassword=%s\\\" \",option);\n      (void) ConcatenateMagickString(options,passphrase,MagickPathExtent);\n    }\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g\",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePDFDelegate(read_info->verbose,command,message,exception);\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  pdf_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPDFRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPDFRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&pdf_image,next);\n    }\n  read_info=DestroyImageInfo(read_info);\n  if (pdf_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n          \"PDFDelegateFailed\",\"`%s'\",message);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(pdf_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(pdf_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          pdf_image=DestroyImageList(pdf_image);\n          pdf_image=cmyk_image;\n        }\n    }\n  (void) SeekBlob(image,0,SEEK_SET);\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        StringInfo\n          *profile;\n\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=(ssize_t) GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,(size_t) (i+1));\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,(size_t) i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(pdf_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&pdf_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(pdf_image->filename,filename,MagickPathExtent);\n    (void) CopyMagickString(pdf_image->magick,image->magick,MagickPathExtent);\n    pdf_image->page=page;\n    (void) CloneImageProfiles(pdf_image,image);\n    (void) CloneImageProperties(pdf_image,image);\n    next=SyncNextImageInList(pdf_image);\n    if (next != (Image *) NULL)\n      pdf_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImage(image);\n  scene=0;\n  for (next=GetFirstImageInList(pdf_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(pdf_image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P D F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPDFImage() adds properties for the PDF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPDFImage method is:\n%\n%      size_t RegisterPDFImage(void)\n%\n*/\nModuleExport size_t RegisterPDFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PDF\",\"AI\",\"Adobe Illustrator CS2\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"EPDF\",\n    \"Encapsulated Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDF\",\"Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDFA\",\"Portable Document Archive Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P D F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPDFImage() removes format registrations made by the\n%  PDF module from the list of supported formats.\n%\n%  The format of the UnregisterPDFImage method is:\n%\n%      UnregisterPDFImage(void)\n%\n*/\nModuleExport void UnregisterPDFImage(void)\n{\n  (void) UnregisterMagickInfo(\"AI\");\n  (void) UnregisterMagickInfo(\"EPDF\");\n  (void) UnregisterMagickInfo(\"PDF\");\n  (void) UnregisterMagickInfo(\"PDFA\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P D F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePDFImage() writes an image in the Portable Document image\n%  format.\n%\n%  The format of the WritePDFImage method is:\n%\n%      MagickBooleanType WritePDFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n\nstatic size_t UTF8ToUTF16(const unsigned char *utf8,wchar_t *utf16)\n{\n  register const unsigned char\n    *p;\n\n  if (utf16 != (wchar_t *) NULL)\n    {\n      register wchar_t\n        *q;\n\n      wchar_t\n        c;\n\n      /*\n        Convert UTF-8 to UTF-16.\n      */\n      q=utf16;\n      for (p=utf8; *p != '\\0'; p++)\n      {\n        if ((*p & 0x80) == 0)\n          *q=(*p);\n        else\n          if ((*p & 0xE0) == 0xC0)\n            {\n              c=(*p);\n              *q=(c & 0x1F) << 6;\n              p++;\n              if ((*p & 0xC0) != 0x80)\n                return(0);\n              *q|=(*p & 0x3F);\n            }\n          else\n            if ((*p & 0xF0) == 0xE0)\n              {\n                c=(*p);\n                *q=c << 12;\n                p++;\n                if ((*p & 0xC0) != 0x80)\n                  return(0);\n                c=(*p);\n                *q|=(c & 0x3F) << 6;\n                p++;\n                if ((*p & 0xC0) != 0x80)\n                  return(0);\n                *q|=(*p & 0x3F);\n              }\n            else\n              return(0);\n        q++;\n      }\n      *q++=(wchar_t) '\\0';\n      return((size_t) (q-utf16));\n    }\n  /*\n    Compute UTF-16 string length.\n  */\n  for (p=utf8; *p != '\\0'; p++)\n  {\n    if ((*p & 0x80) == 0)\n      ;\n    else\n      if ((*p & 0xE0) == 0xC0)\n        {\n          p++;\n          if ((*p & 0xC0) != 0x80)\n            return(0);\n        }\n      else\n        if ((*p & 0xF0) == 0xE0)\n          {\n            p++;\n            if ((*p & 0xC0) != 0x80)\n              return(0);\n            p++;\n            if ((*p & 0xC0) != 0x80)\n              return(0);\n         }\n       else\n         return(0);\n  }\n  return((size_t) (p-utf8));\n}\n\nstatic wchar_t *ConvertUTF8ToUTF16(const unsigned char *source,size_t *length)\n{\n  wchar_t\n    *utf16;\n\n  *length=UTF8ToUTF16(source,(wchar_t *) NULL);\n  if (*length == 0)\n    {\n      register ssize_t\n        i;\n\n      /*\n        Not UTF-8, just copy.\n      */\n      *length=strlen((const char *) source);\n      utf16=(wchar_t *) AcquireQuantumMemory(*length+1,sizeof(*utf16));\n      if (utf16 == (wchar_t *) NULL)\n        return((wchar_t *) NULL);\n      for (i=0; i <= (ssize_t) *length; i++)\n        utf16[i]=source[i];\n      return(utf16);\n    }\n  utf16=(wchar_t *) AcquireQuantumMemory(*length+1,sizeof(*utf16));\n  if (utf16 == (wchar_t *) NULL)\n    return((wchar_t *) NULL);\n  *length=UTF8ToUTF16(source,utf16);\n  return(utf16);\n}\n\nstatic MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}\n\nstatic MagickBooleanType WritePDFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define CFormat  \"/Filter [ /%s ]\\n\"\n#define ObjectsPerImage  14\n#define ThrowPDFException(exception,message) \\\n{ \\\n  if (xref != (MagickOffsetType *) NULL) \\\n    xref=(MagickOffsetType *) RelinquishMagickMemory(xref); \\\n  ThrowWriterException((exception),(message)); \\\n}\n\nDisableMSCWarning(4310)\n  static const char\n    XMPProfile[]=\n    {\n      \"<?xpacket begin=\\\"%s\\\" id=\\\"W5M0MpCehiHzreSzNTczkc9d\\\"?>\\n\"\n      \"<x:xmpmeta xmlns:x=\\\"adobe:ns:meta/\\\" x:xmptk=\\\"Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:08:23\\\">\\n\"\n      \"   <rdf:RDF xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\">\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xap=\\\"http://ns.adobe.com/xap/1.0/\\\">\\n\"\n      \"         <xap:ModifyDate>%s</xap:ModifyDate>\\n\"\n      \"         <xap:CreateDate>%s</xap:CreateDate>\\n\"\n      \"         <xap:MetadataDate>%s</xap:MetadataDate>\\n\"\n      \"         <xap:CreatorTool>%s</xap:CreatorTool>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\">\\n\"\n      \"         <dc:format>application/pdf</dc:format>\\n\"\n      \"         <dc:title>\\n\"\n      \"           <rdf:Alt>\\n\"\n      \"              <rdf:li xml:lang=\\\"x-default\\\">%s</rdf:li>\\n\"\n      \"           </rdf:Alt>\\n\"\n      \"         </dc:title>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xapMM=\\\"http://ns.adobe.com/xap/1.0/mm/\\\">\\n\"\n      \"         <xapMM:DocumentID>uuid:6ec119d7-7982-4f56-808d-dfe64f5b35cf</xapMM:DocumentID>\\n\"\n      \"         <xapMM:InstanceID>uuid:a79b99b4-6235-447f-9f6c-ec18ef7555cb</xapMM:InstanceID>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdf=\\\"http://ns.adobe.com/pdf/1.3/\\\">\\n\"\n      \"         <pdf:Producer>%s</pdf:Producer>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdfaid=\\\"http://www.aiim.org/pdfa/ns/id/\\\">\\n\"\n      \"         <pdfaid:part>3</pdfaid:part>\\n\"\n      \"         <pdfaid:conformance>B</pdfaid:conformance>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"   </rdf:RDF>\\n\"\n      \"</x:xmpmeta>\\n\"\n      \"<?xpacket end=\\\"w\\\"?>\\n\"\n    },\n    XMPProfileMagick[4]= { (char) 0xef, (char) 0xbb, (char) 0xbf, (char) 0x00 };\nRestoreMSCWarning\n\n  char\n    basename[MagickPathExtent],\n    buffer[MagickPathExtent],\n    *escape,\n    date[MagickPathExtent],\n    **labels,\n    page_geometry[MagickPathExtent],\n    *url;\n\n  CompressionType\n    compression;\n\n  const char\n    *device,\n    *option,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  double\n    pointsize;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *next,\n    *tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene,\n    *xref;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution,\n    scale;\n\n  RectangleInfo\n    geometry,\n    media_info,\n    page_info;\n\n  register const Quantum\n    *p;\n\n  register unsigned char\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    channels,\n    imageListLength,\n    info_id,\n    length,\n    object,\n    pages_id,\n    root_id,\n    text_size,\n    version;\n\n  ssize_t\n    count,\n    page_count,\n    y;\n\n  struct tm\n    local_time;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate X ref memory.\n  */\n  xref=(MagickOffsetType *) AcquireQuantumMemory(2048UL,sizeof(*xref));\n  if (xref == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(xref,0,2048UL*sizeof(*xref));\n  /*\n    Write Info object.\n  */\n  object=0;\n  version=3;\n  if (image_info->compression == JPEG2000Compression)\n    version=(size_t) MagickMax(version,5);\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n    if (next->alpha_trait != UndefinedPixelTrait)\n      version=(size_t) MagickMax(version,4);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    version=(size_t) MagickMax(version,6);\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    version=(size_t) MagickMax(version,7);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%%PDF-1.%.20g \\n\",(double)\n    version);\n  (void) WriteBlobString(image,buffer);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      (void) WriteBlobByte(image,'%');\n      (void) WriteBlobByte(image,0xe2);\n      (void) WriteBlobByte(image,0xe3);\n      (void) WriteBlobByte(image,0xcf);\n      (void) WriteBlobByte(image,0xd3);\n      (void) WriteBlobByte(image,'\\n');\n    }\n  /*\n    Write Catalog object.\n  */\n  xref[object++]=TellBlob(image);\n  root_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") != 0)\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n      (double) object+1);\n  else\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Metadata %.20g 0 R\\n\",\n        (double) object+1);\n      (void) WriteBlobString(image,buffer);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n        (double) object+2);\n    }\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/Type /Catalog\");\n  option=GetImageOption(image_info,\"pdf:page-direction\");\n  if ((option != (const char *) NULL) &&\n      (LocaleCompare(option,\"right-to-left\") == 0))\n    (void) WriteBlobString(image,\"/ViewerPreferences<</PageDirection/R2L>>\\n\");\n  (void) WriteBlobString(image,\"\\n\");\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  GetPathComponent(image->filename,BasePath,basename);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      char\n        create_date[MagickPathExtent],\n        modify_date[MagickPathExtent],\n        timestamp[MagickPathExtent],\n        *url,\n        xmp_profile[MagickPathExtent];\n\n      /*\n        Write XMP object.\n      */\n      xref[object++]=TellBlob(image);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n        object);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"<<\\n\");\n      (void) WriteBlobString(image,\"/Subtype /XML\\n\");\n      *modify_date='\\0';\n      value=GetImageProperty(image,\"date:modify\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(modify_date,value,MagickPathExtent);\n      *create_date='\\0';\n      value=GetImageProperty(image,\"date:create\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(create_date,value,MagickPathExtent);\n      (void) FormatMagickTime(time((time_t *) NULL),MagickPathExtent,timestamp);\n      url=(char *) MagickAuthoritativeURL;\n      escape=EscapeParenthesis(basename);\n      i=FormatLocaleString(xmp_profile,MagickPathExtent,XMPProfile,\n        XMPProfileMagick,modify_date,create_date,timestamp,url,escape,url);\n      escape=DestroyString(escape);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g\\n\",\n        (double) i);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"/Type /Metadata\\n\");\n      (void) WriteBlobString(image,\">>\\nstream\\n\");\n      (void) WriteBlobString(image,xmp_profile);\n      (void) WriteBlobString(image,\"\\nendstream\\n\");\n      (void) WriteBlobString(image,\"endobj\\n\");\n    }\n  /*\n    Write Pages object.\n  */\n  xref[object++]=TellBlob(image);\n  pages_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) WriteBlobString(image,\"/Type /Pages\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Kids [ %.20g 0 R \",\n    (double) object+1);\n  (void) WriteBlobString(image,buffer);\n  count=(ssize_t) (pages_id+ObjectsPerImage+1);\n  page_count=1;\n  if (image_info->adjoin != MagickFalse)\n    {\n      Image\n        *kid_image;\n\n      /*\n        Predict page object id's.\n      */\n      kid_image=image;\n      for ( ; GetNextImageInList(kid_image) != (Image *) NULL; count+=ObjectsPerImage)\n      {\n        page_count++;\n        profile=GetImageProfile(kid_image,\"icc\");\n        if (profile != (StringInfo *) NULL)\n          count+=2;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 R \",(double)\n          count);\n        (void) WriteBlobString(image,buffer);\n        kid_image=GetNextImageInList(kid_image);\n      }\n      xref=(MagickOffsetType *) ResizeQuantumMemory(xref,(size_t) count+2048UL,\n        sizeof(*xref));\n      if (xref == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) WriteBlobString(image,\"]\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Count %.20g\\n\",(double)\n    page_count);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    MagickBooleanType\n      has_icc_profile;\n\n    profile=GetImageProfile(image,\"icc\");\n    has_icc_profile=(profile != (StringInfo *) NULL) ? MagickTrue : MagickFalse;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if ((SetImageMonochrome(image,exception) == MagickFalse) ||\n            (image->alpha_trait != UndefinedPixelTrait))\n          compression=RLECompression;\n        break;\n      }\n#if !defined(MAGICKCORE_JPEG_DELEGATE)\n      case JPEGCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JPEG)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n      case JPEG2000Compression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JP2)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_ZLIB_DELEGATE)\n      case ZipCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (ZLIB)\",\n          image->filename);\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression;  /* LZW compression is forbidden */\n        break;\n      }\n      case NoCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression; /* ASCII 85 compression is forbidden */\n        break;\n      }\n      default:\n        break;\n    }\n    if (compression == JPEG2000Compression)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    /*\n      Scale relative to dots-per-inch.\n    */\n    delta.x=DefaultResolution;\n    delta.y=DefaultResolution;\n    resolution.x=image->resolution.x;\n    resolution.y=image->resolution.y;\n    if ((resolution.x == 0.0) || (resolution.y == 0.0))\n      {\n        flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image_info->density != (char *) NULL)\n      {\n        flags=ParseGeometry(image_info->density,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image->units == PixelsPerCentimeterResolution)\n      {\n        resolution.x=(double) ((size_t) (100.0*2.54*resolution.x+0.5)/100.0);\n        resolution.y=(double) ((size_t) (100.0*2.54*resolution.y+0.5)/100.0);\n      }\n    SetGeometry(image,&geometry);\n    (void) FormatLocaleString(page_geometry,MagickPathExtent,\"%.20gx%.20g\",\n      (double) image->columns,(double) image->rows);\n    if (image_info->page != (char *) NULL)\n      (void) CopyMagickString(page_geometry,image_info->page,MagickPathExtent);\n    else\n      if ((image->page.width != 0) && (image->page.height != 0))\n        (void) FormatLocaleString(page_geometry,MagickPathExtent,\n          \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n      else\n        if ((image->gravity != UndefinedGravity) &&\n            (LocaleCompare(image_info->magick,\"PDF\") == 0))\n          (void) CopyMagickString(page_geometry,PSPageGeometry,\n            MagickPathExtent);\n    (void) ConcatenateMagickString(page_geometry,\">\",MagickPathExtent);\n    (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    scale.x=(double) (geometry.width*delta.x)/resolution.x;\n    geometry.width=(size_t) floor(scale.x+0.5);\n    scale.y=(double) (geometry.height*delta.y)/resolution.y;\n    geometry.height=(size_t) floor(scale.y+0.5);\n    (void) ParseAbsoluteGeometry(page_geometry,&media_info);\n    (void) ParseGravityGeometry(image,page_geometry,&page_info,exception);\n    if (image->gravity != UndefinedGravity)\n      {\n        geometry.x=(-page_info.x);\n        geometry.y=(ssize_t) (media_info.height+page_info.y-image->rows);\n      }\n    pointsize=12.0;\n    if (image_info->pointsize != 0.0)\n      pointsize=image_info->pointsize;\n    text_size=0;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      text_size=(size_t) (MultilineCensus(value)*pointsize+12);\n    (void) text_size;\n    /*\n      Write Page object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /Page\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Parent %.20g 0 R\\n\",\n      (double) pages_id);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"/Resources <<\\n\");\n    labels=(char **) NULL;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      labels=StringToList(value);\n    if (labels != (char **) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/Font << /F%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n          object+4);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/XObject << /Im%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n      object+5);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ProcSet %.20g 0 R >>\\n\",\n      (double) object+3);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/MediaBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/CropBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Contents %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Thumb %.20g 0 R\\n\",\n      (double) object+(has_icc_profile != MagickFalse ? 10 : 8));\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Contents object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    (void) WriteBlobString(image,\"q\\n\");\n    if (labels != (char **) NULL)\n      for (i=0; labels[i] != (char *) NULL; i++)\n      {\n        (void) WriteBlobString(image,\"BT\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/F%.20g %g Tf\\n\",\n          (double) image->scene,pointsize);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g Td\\n\",\n          (double) geometry.x,(double) (geometry.y+geometry.height+i*pointsize+\n          12));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"(%s) Tj\\n\",\n           labels[i]);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"ET\\n\");\n        labels[i]=DestroyString(labels[i]);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"%g 0 0 %g %.20g %.20g cm\\n\",scale.x,scale.y,(double) geometry.x,\n      (double) geometry.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Im%.20g Do\\n\",(double)\n      image->scene);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"Q\\n\");\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Procset object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageC\",MagickPathExtent);\n    else\n      if ((compression == FaxCompression) || (compression == Group4Compression))\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageB\",MagickPathExtent);\n      else\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageI\",MagickPathExtent);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\" ]\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Font object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (labels != (char **) NULL)\n      {\n        (void) WriteBlobString(image,\"/Type /Font\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Type1\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /F%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/BaseFont /Helvetica\\n\");\n        (void) WriteBlobString(image,\"/Encoding /MacRomanEncoding\\n\");\n        labels=(char **) RelinquishMagickMemory(labels);\n      }\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write XObject object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /XObject\\n\");\n    (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Im%.20g\\n\",\n      (double) image->scene);\n    (void) WriteBlobString(image,buffer);\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) image->columns,(double) image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object+2);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/SMask %.20g 0 R\\n\",\n          (double) object+(has_icc_profile != MagickFalse ? 9 : 7));\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (MagickSizeType) ((size_t) (4*number_pixels)))\n      ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((compression == FaxCompression) || (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,image,exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(image,p))));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n          (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runoffset encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                if (image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelRed(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelGreen(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelBlue(image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                {\n                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                  ThrowPDFException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                }\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump Runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  *q++=(unsigned char) GetPixelIndex(image,p);\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char) GetPixelIndex(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Colorspace object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    device=\"DeviceRGB\";\n    channels=0;\n    if (image->colorspace == CMYKColorspace)\n      {\n        device=\"DeviceCMYK\";\n        channels=4;\n      }\n    else\n      if ((compression == FaxCompression) ||\n          (compression == Group4Compression) ||\n          ((image_info->type != TrueColorType) &&\n           (SetImageGray(image,exception) != MagickFalse)))\n        {\n          device=\"DeviceGray\";\n          channels=1;\n        }\n      else\n        if ((image->storage_class == DirectClass) ||\n            (image->colors > 256) || (compression == JPEGCompression) ||\n            (compression == JPEG2000Compression))\n          {\n            device=\"DeviceRGB\";\n            channels=3;\n          }\n    profile=GetImageProfile(image,\"icc\");\n    if ((profile == (StringInfo *) NULL) || (channels == 0))\n      {\n        if (channels != 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/%s\\n\",device);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"[ /Indexed /%s %.20g %.20g 0 R ]\\n\",device,(double) image->colors-\n            1,(double) object+3);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        const unsigned char\n          *p;\n\n        /*\n          Write ICC profile. \n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"[/ICCBased %.20g 0 R]\\n\",(double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"endobj\\n\");\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"<<\\n/N %.20g\\n\"\n          \"/Filter /ASCII85Decode\\n/Length %.20g 0 R\\n/Alternate /%s\\n>>\\n\"\n          \"stream\\n\",(double) channels,(double) object+1,device);\n        (void) WriteBlobString(image,buffer);\n        offset=TellBlob(image);\n        Ascii85Initialize(image);\n        p=GetStringInfoDatum(profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n          Ascii85Encode(image,(unsigned char) *p++);\n        Ascii85Flush(image);\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"endstream\\n\");\n        (void) WriteBlobString(image,\"endobj\\n\");\n        /*\n          Write Length object.\n        */\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          offset);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Thumb object.\n    */\n    SetGeometry(image,&geometry);\n    (void) ParseMetaGeometry(\"106x106+0+0>\",&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    tile_image=ThumbnailImage(image,geometry.width,geometry.height,exception);\n    if (tile_image == (Image *) NULL)\n      return(MagickFalse);\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) tile_image->columns,(double) tile_image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      tile_image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      tile_image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object-(has_icc_profile != MagickFalse ? 3 : 1));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) tile_image->columns*tile_image->rows;\n    if ((compression == FaxCompression) ||\n        (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(tile_image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,tile_image,\n                  exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,tile_image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                  tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(tile_image,p))));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((tile_image->storage_class == DirectClass) ||\n          (tile_image->colors > 256) || (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=tile_image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(tile_image,p));\n                if (tile_image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(tile_image,p));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelRed(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelGreen(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelBlue(tile_image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowPDFException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                }\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  *q++=(unsigned char) GetPixelIndex(tile_image,p);\n                  p+=GetPixelChannels(tile_image);\n                }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char)\n                    GetPixelIndex(tile_image,p));\n                  p+=GetPixelChannels(image);\n                }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    tile_image=DestroyImage(tile_image);\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n        (compression == FaxCompression) || (compression == Group4Compression))\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        /*\n          Write Colormap object.\n        */\n        if (compression == NoCompression)\n          (void) WriteBlobString(image,\"/Filter [ /ASCII85Decode ]\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        if (compression == NoCompression)\n          Ascii85Initialize(image);\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          if (compression == NoCompression)\n            {\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].red)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].green)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].blue)));\n              continue;\n            }\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].red)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].green)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].blue)));\n        }\n        if (compression == NoCompression)\n          Ascii85Flush(image);\n       offset=TellBlob(image)-offset;\n       (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write softmask object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (image->alpha_trait == UndefinedPixelTrait)\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        (void) WriteBlobString(image,\"/Type /XObject\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Ma%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        switch (compression)\n        {\n          case NoCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"ASCII85Decode\");\n            break;\n          }\n          case LZWCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"LZWDecode\");\n            break;\n          }\n          case ZipCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"FlateDecode\");\n            break;\n          }\n          default:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"RunLengthDecode\");\n            break;\n          }\n        }\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",\n          (double) image->columns);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",\n          (double) image->rows);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/ColorSpace /DeviceGray\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/BitsPerComponent %d\\n\",(compression == FaxCompression) ||\n          (compression == Group4Compression) ? 1 : 8);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        switch (compression)\n        {\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                image=DestroyImage(image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n                p+=GetPixelChannels(image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));\n                p+=GetPixelChannels(image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  /*\n    Write Metadata object.\n  */\n  xref[object++]=TellBlob(image);\n  info_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title (%s)\\n\",\n      EscapeParenthesis(basename));\n  else\n    {\n      wchar_t\n        *utf16;\n\n      utf16=ConvertUTF8ToUTF16((unsigned char *) basename,&length);\n      if (utf16 != (wchar_t *) NULL)\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title (\\xfe\\xff\");\n          (void) WriteBlobString(image,buffer);\n          for (i=0; i < (ssize_t) length; i++)\n            (void) WriteBlobMSBShort(image,(unsigned short) utf16[i]);\n          (void) FormatLocaleString(buffer,MagickPathExtent,\")\\n\");\n          utf16=(wchar_t *) RelinquishMagickMemory(utf16);\n        }\n    }\n  (void) WriteBlobString(image,buffer);\n  seconds=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&seconds,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&seconds),sizeof(local_time));\n#endif\n  (void) FormatLocaleString(date,MagickPathExtent,\"D:%04d%02d%02d%02d%02d%02d\",\n    local_time.tm_year+1900,local_time.tm_mon+1,local_time.tm_mday,\n    local_time.tm_hour,local_time.tm_min,local_time.tm_sec);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/CreationDate (%s)\\n\",\n    date);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ModDate (%s)\\n\",date);\n  (void) WriteBlobString(image,buffer);\n  url=(char *) MagickAuthoritativeURL;\n  escape=EscapeParenthesis(url);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Producer (%s)\\n\",escape);\n  escape=DestroyString(escape);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  /*\n    Write Xref object.\n  */\n  offset=TellBlob(image)-xref[0]+\n   (LocaleCompare(image_info->magick,\"PDFA\") == 0 ? 6 : 0)+10;\n  (void) WriteBlobString(image,\"xref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"0 %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"0000000000 65535 f \\n\");\n  for (i=0; i < (ssize_t) object; i++)\n  {\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%010lu 00000 n \\n\",\n      (unsigned long) xref[i]);\n    (void) WriteBlobString(image,buffer);\n  }\n  (void) WriteBlobString(image,\"trailer\\n\");\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Size %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Info %.20g 0 R\\n\",(double)\n    info_id);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Root %.20g 0 R\\n\",(double)\n    root_id);\n  (void) WriteBlobString(image,buffer);\n  (void) SignatureImage(image,exception);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ID [<%s> <%s>]\\n\",\n    GetImageProperty(image,\"signature\",exception),\n    GetImageProperty(image,\"signature\",exception));\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"startxref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double) offset);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"%%EOF\\n\");\n  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   DDDD   FFFFF                              %\n%                            P   P  D   D  F                                  %\n%                            PPPP   D   D  FFF                                %\n%                            P      D   D  F                                  %\n%                            P      DDDD   F                                  %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Portable Document Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/delegate-private.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n#define CCITTParam  \"-1\"\n#else\n#define CCITTParam  \"0\"\n#endif\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePDFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e P D F D e l e g a t e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokePDFDelegate() executes the PDF interpreter with the specified command.\n%\n%  The format of the InvokePDFDelegate method is:\n%\n%      MagickBooleanType InvokePDFDelegate(const MagickBooleanType verbose,\n%        const char *command,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o verbose: A value other than zero displays the command prior to\n%      executing it.\n%\n%    o command: the address of a character string containing the command to\n%      execute.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\nstatic int MagickDLLCall PDFDelegateMessage(void *handle,const char *message,\n  int length)\n{\n  char\n    **messages;\n\n  ssize_t\n    offset;\n\n  offset=0;\n  messages=(char **) handle;\n  if (*messages == (char *) NULL)\n    *messages=(char *) AcquireQuantumMemory(length+1,sizeof(char *));\n  else\n    {\n      offset=strlen(*messages);\n      *messages=(char *) ResizeQuantumMemory(*messages,offset+length+1,\n        sizeof(char *));\n    }\n  if (*messages == (char *) NULL)\n    return(0);\n  (void) memcpy(*messages+offset,message,length);\n  (*messages)[length+offset] ='\\0';\n  return(length);\n}\n#endif\n\nstatic MagickBooleanType InvokePDFDelegate(const MagickBooleanType verbose,\n  const char *command,char *message,ExceptionInfo *exception)\n{\n  int\n    status;\n\n#define ExecuteGhostscriptCommand(command,status) \\\n{ \\\n  status=ExternalDelegateCommand(MagickFalse,verbose,command,message, \\\n    exception); \\\n  if (status == 0) \\\n    return(MagickTrue); \\\n  if (status < 0) \\\n    return(MagickFalse); \\\n  (void) ThrowMagickException(exception,GetMagickModule(),DelegateError, \\\n    \"FailedToExecuteCommand\",\"`%s' (%d)\",command,status); \\\n  return(MagickFalse); \\\n}\n\n#if defined(MAGICKCORE_GS_DELEGATE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\n#define SetArgsStart(command,args_start) \\\n  if (args_start == (const char *) NULL) \\\n    { \\\n      if (*command != '\"') \\\n        args_start=strchr(command,' '); \\\n      else \\\n        { \\\n          args_start=strchr(command+1,'\"'); \\\n          if (args_start != (const char *) NULL) \\\n            args_start++; \\\n        } \\\n    }\n\n  char\n    **argv,\n    *errors;\n\n  const char\n    *args_start = (const char *) NULL;\n\n  const GhostInfo\n    *ghost_info;\n\n  gs_main_instance\n    *interpreter;\n\n  gsapi_revision_t\n    revision;\n\n  int\n    argc,\n    code;\n\n  register ssize_t\n    i;\n\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  ghost_info=NTGhostscriptDLLVectors();\n#else\n  GhostInfo\n    ghost_info_struct;\n\n  ghost_info=(&ghost_info_struct);\n  (void) memset(&ghost_info_struct,0,sizeof(ghost_info_struct));\n  ghost_info_struct.delete_instance=(void (*)(gs_main_instance *))\n    gsapi_delete_instance;\n  ghost_info_struct.exit=(int (*)(gs_main_instance *)) gsapi_exit;\n  ghost_info_struct.new_instance=(int (*)(gs_main_instance **,void *))\n    gsapi_new_instance;\n  ghost_info_struct.init_with_args=(int (*)(gs_main_instance *,int,char **))\n    gsapi_init_with_args;\n  ghost_info_struct.run_string=(int (*)(gs_main_instance *,const char *,int,\n    int *)) gsapi_run_string;\n  ghost_info_struct.set_stdio=(int (*)(gs_main_instance *,int (*)(void *,char *,\n    int),int (*)(void *,const char *,int),int (*)(void *, const char *, int)))\n    gsapi_set_stdio;\n  ghost_info_struct.revision=(int (*)(gsapi_revision_t *,int)) gsapi_revision;\n#endif\n  if (ghost_info == (GhostInfo *) NULL)\n    ExecuteGhostscriptCommand(command,status);\n  if ((ghost_info->revision)(&revision,sizeof(revision)) != 0)\n    revision.revision=0;\n  if (verbose != MagickFalse)\n    {\n      (void) fprintf(stdout,\"[ghostscript library %.2f]\",(double)\n        revision.revision/100.0);\n      SetArgsStart(command,args_start);\n      (void) fputs(args_start,stdout);\n    }\n  errors=(char *) NULL;\n  status=(ghost_info->new_instance)(&interpreter,(void *) &errors);\n  if (status < 0)\n    ExecuteGhostscriptCommand(command,status);\n  code=0;\n  argv=StringToArgv(command,&argc);\n  if (argv == (char **) NULL)\n    {\n      (ghost_info->delete_instance)(interpreter);\n      return(MagickFalse);\n    }\n  (void) (ghost_info->set_stdio)(interpreter,(int (MagickDLLCall *)(void *,\n    char *,int)) NULL,PDFDelegateMessage,PDFDelegateMessage);\n  status=(ghost_info->init_with_args)(interpreter,argc-1,argv+1);\n  if (status == 0)\n    status=(ghost_info->run_string)(interpreter,\"systemdict /start get exec\\n\",\n      0,&code);\n  (ghost_info->exit)(interpreter);\n  (ghost_info->delete_instance)(interpreter);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  if (status != 0)\n    {\n      SetArgsStart(command,args_start);\n      if (status == -101) /* quit */\n        (void) FormatLocaleString(message,MagickPathExtent,\n          \"[ghostscript library %.2f]%s: %s\",(double) revision.revision/100.0,\n          args_start,errors);\n      else\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"PDFDelegateFailed\",\"`[ghostscript library %.2f]%s': %s\",(double)\n            revision.revision/100.0,args_start,errors);\n          if (errors != (char *) NULL)\n            errors=DestroyString(errors);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Ghostscript returns status %d, exit code %d\",status,code);\n          return(MagickFalse);\n        }\n    }\n  if (errors != (char *) NULL)\n    errors=DestroyString(errors);\n  return(MagickTrue);\n#else\n  ExecuteGhostscriptCommand(command,status);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P D F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPDF() returns MagickTrue if the image format type, identified by the\n%  magick string, is PDF.\n%\n%  The format of the IsPDF method is:\n%\n%      MagickBooleanType IsPDF(const unsigned char *magick,const size_t offset)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o offset: Specifies the offset of the magick string.\n%\n*/\nstatic MagickBooleanType IsPDF(const unsigned char *magick,const size_t offset)\n{\n  if (offset < 5)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"%PDF-\",5) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P D F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPDFImage() reads a Portable Document Format image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadPDFImage method is:\n%\n%      Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType IsPDFRendered(const char *path)\n{\n  MagickBooleanType\n    status;\n\n  struct stat\n    attributes;\n\n  if ((path == (const char *) NULL) || (*path == '\\0'))\n    return(MagickFalse);\n  status=GetPathAttributes(path,&attributes);\n  if ((status != MagickFalse) && S_ISREG(attributes.st_mode) &&\n      (attributes.st_size > 0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define CMYKProcessColor  \"CMYKProcessColor\"\n#define CropBox  \"CropBox\"\n#define DefaultCMYK  \"DefaultCMYK\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define MediaBox  \"MediaBox\"\n#define RenderPostscriptText  \"Rendering Postscript...  \"\n#define PDFRotate  \"Rotate\"\n#define SpotColor  \"Separation\"\n#define TrimBox  \"TrimBox\"\n#define PDFVersion  \"PDF-\"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  double\n    angle;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *pdf_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    cropbox,\n    fitPage,\n    status,\n    stop_on_error,\n    trimbox;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  size_t\n    scene,\n    spotcolor;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) memset(&page,0,sizeof(page));\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)-\n    0.5);\n  page.height=(size_t) ceil((double) (page.height*image->resolution.y/delta.y)-\n    0.5);\n  /*\n    Determine page geometry from the PDF media box.\n  */\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  cropbox=IsStringTrue(GetImageOption(image_info,\"pdf:use-cropbox\"));\n  stop_on_error=IsStringTrue(GetImageOption(image_info,\"pdf:stop-on-error\"));\n  trimbox=IsStringTrue(GetImageOption(image_info,\"pdf:use-trimbox\"));\n  count=0;\n  spotcolor=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&hires_bounds,0,sizeof(hires_bounds));\n  (void) memset(command,0,sizeof(command));\n  angle=0.0;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note PDF elements.\n    */\n    if (c == '\\n')\n      c=' ';\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != (int) '%') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *(--p)='\\0';\n    p=command;\n    if (LocaleNCompare(PDFRotate,command,strlen(PDFRotate)) == 0)\n      count=(ssize_t) sscanf(command,\"Rotate %lf\",&angle);\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DefaultCMYK,command,strlen(DefaultCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0)\n      {\n        char\n          name[MagickPathExtent],\n          property[MagickPathExtent],\n          *value;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \"pdf:SpotColor-%.20g\",(double) spotcolor++);\n        i=0;\n        for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n        {\n          if ((isspace(c) != 0) || (c == '/') || ((i+1) == MagickPathExtent))\n            break;\n          name[i++]=(char) c;\n        }\n        name[i]='\\0';\n        value=ConstantString(name);\n        (void) SubstituteString(&value,\"#20\",\" \");\n        if (*value != '\\0')\n          (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (LocaleNCompare(PDFVersion,command,strlen(PDFVersion)) == 0)\n      (void) SetImageProperty(image,\"pdf:Version\",command,exception);\n    if (image_info->page != (char *) NULL)\n      continue;\n    count=0;\n    if (cropbox != MagickFalse)\n      {\n        if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n          {\n            /*\n              Note region defined by crop box.\n            */\n            count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n              &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n            if (count != 4)\n              count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n                &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n          }\n      }\n    else\n      if (trimbox != MagickFalse)\n        {\n          if (LocaleNCompare(TrimBox,command,strlen(TrimBox)) == 0)\n            {\n              /*\n                Note region defined by trim box.\n              */\n              count=(ssize_t) sscanf(command,\"TrimBox [%lf %lf %lf %lf\",\n                &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n              if (count != 4)\n                count=(ssize_t) sscanf(command,\"TrimBox[%lf %lf %lf %lf\",\n                  &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n            }\n        }\n      else\n        if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n          {\n            /*\n              Note region defined by media box.\n            */\n            count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n              &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n            if (count != 4)\n              count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n                &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n          }\n    if (count != 4)\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      continue;\n    hires_bounds=bounds;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set PDF render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"pdf:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        image->resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        image->resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"pdf:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      page_geometry=DestroyString(page_geometry);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n        -0.5);\n      page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n        delta.y) -0.5);\n      fitPage=MagickTrue;\n    }\n  if ((fabs(angle) == 90.0) || (fabs(angle) == 270.0))\n    {\n      size_t\n        swap;\n\n      swap=page.width;\n      page.width=page.height;\n      page.height=swap;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  count=write(file,\" \",1);\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if ((image_info->page != (char *) NULL) || (fitPage != MagickFalse))\n    (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n      page.width,(double) page.height);\n  if (fitPage != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPSFitPage \",MagickPathExtent);\n  if (cmyk != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseCIEColor \",MagickPathExtent);\n  if (cropbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseCropBox \",MagickPathExtent);\n  if (stop_on_error != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPDFSTOPONERROR \",\n      MagickPathExtent);\n  if (trimbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseTrimBox \",MagickPathExtent);\n  option=GetImageOption(image_info,\"authenticate\");\n  if (option != (char *) NULL)\n    {\n      char\n        passphrase[MagickPathExtent];\n\n      (void) FormatLocaleString(passphrase,MagickPathExtent,\n        \"\\\"-sPDFPassword=%s\\\" \",option);\n      (void) ConcatenateMagickString(options,passphrase,MagickPathExtent);\n    }\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g\",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePDFDelegate(read_info->verbose,command,message,exception);\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  pdf_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPDFRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPDFRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&pdf_image,next);\n    }\n  read_info=DestroyImageInfo(read_info);\n  if (pdf_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n          \"PDFDelegateFailed\",\"`%s'\",message);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(pdf_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(pdf_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          pdf_image=DestroyImageList(pdf_image);\n          pdf_image=cmyk_image;\n        }\n    }\n  (void) SeekBlob(image,0,SEEK_SET);\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        StringInfo\n          *profile;\n\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=(ssize_t) GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,(size_t) (i+1));\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,(size_t) i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(pdf_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&pdf_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(pdf_image->filename,filename,MagickPathExtent);\n    (void) CopyMagickString(pdf_image->magick,image->magick,MagickPathExtent);\n    pdf_image->page=page;\n    (void) CloneImageProfiles(pdf_image,image);\n    (void) CloneImageProperties(pdf_image,image);\n    next=SyncNextImageInList(pdf_image);\n    if (next != (Image *) NULL)\n      pdf_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImage(image);\n  scene=0;\n  for (next=GetFirstImageInList(pdf_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(pdf_image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P D F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPDFImage() adds properties for the PDF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPDFImage method is:\n%\n%      size_t RegisterPDFImage(void)\n%\n*/\nModuleExport size_t RegisterPDFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PDF\",\"AI\",\"Adobe Illustrator CS2\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"EPDF\",\n    \"Encapsulated Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDF\",\"Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDFA\",\"Portable Document Archive Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P D F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPDFImage() removes format registrations made by the\n%  PDF module from the list of supported formats.\n%\n%  The format of the UnregisterPDFImage method is:\n%\n%      UnregisterPDFImage(void)\n%\n*/\nModuleExport void UnregisterPDFImage(void)\n{\n  (void) UnregisterMagickInfo(\"AI\");\n  (void) UnregisterMagickInfo(\"EPDF\");\n  (void) UnregisterMagickInfo(\"PDF\");\n  (void) UnregisterMagickInfo(\"PDFA\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P D F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePDFImage() writes an image in the Portable Document image\n%  format.\n%\n%  The format of the WritePDFImage method is:\n%\n%      MagickBooleanType WritePDFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n\nstatic size_t UTF8ToUTF16(const unsigned char *utf8,wchar_t *utf16)\n{\n  register const unsigned char\n    *p;\n\n  if (utf16 != (wchar_t *) NULL)\n    {\n      register wchar_t\n        *q;\n\n      wchar_t\n        c;\n\n      /*\n        Convert UTF-8 to UTF-16.\n      */\n      q=utf16;\n      for (p=utf8; *p != '\\0'; p++)\n      {\n        if ((*p & 0x80) == 0)\n          *q=(*p);\n        else\n          if ((*p & 0xE0) == 0xC0)\n            {\n              c=(*p);\n              *q=(c & 0x1F) << 6;\n              p++;\n              if ((*p & 0xC0) != 0x80)\n                return(0);\n              *q|=(*p & 0x3F);\n            }\n          else\n            if ((*p & 0xF0) == 0xE0)\n              {\n                c=(*p);\n                *q=c << 12;\n                p++;\n                if ((*p & 0xC0) != 0x80)\n                  return(0);\n                c=(*p);\n                *q|=(c & 0x3F) << 6;\n                p++;\n                if ((*p & 0xC0) != 0x80)\n                  return(0);\n                *q|=(*p & 0x3F);\n              }\n            else\n              return(0);\n        q++;\n      }\n      *q++=(wchar_t) '\\0';\n      return((size_t) (q-utf16));\n    }\n  /*\n    Compute UTF-16 string length.\n  */\n  for (p=utf8; *p != '\\0'; p++)\n  {\n    if ((*p & 0x80) == 0)\n      ;\n    else\n      if ((*p & 0xE0) == 0xC0)\n        {\n          p++;\n          if ((*p & 0xC0) != 0x80)\n            return(0);\n        }\n      else\n        if ((*p & 0xF0) == 0xE0)\n          {\n            p++;\n            if ((*p & 0xC0) != 0x80)\n              return(0);\n            p++;\n            if ((*p & 0xC0) != 0x80)\n              return(0);\n         }\n       else\n         return(0);\n  }\n  return((size_t) (p-utf8));\n}\n\nstatic wchar_t *ConvertUTF8ToUTF16(const unsigned char *source,size_t *length)\n{\n  wchar_t\n    *utf16;\n\n  *length=UTF8ToUTF16(source,(wchar_t *) NULL);\n  if (*length == 0)\n    {\n      register ssize_t\n        i;\n\n      /*\n        Not UTF-8, just copy.\n      */\n      *length=strlen((const char *) source);\n      utf16=(wchar_t *) AcquireQuantumMemory(*length+1,sizeof(*utf16));\n      if (utf16 == (wchar_t *) NULL)\n        return((wchar_t *) NULL);\n      for (i=0; i <= (ssize_t) *length; i++)\n        utf16[i]=source[i];\n      return(utf16);\n    }\n  utf16=(wchar_t *) AcquireQuantumMemory(*length+1,sizeof(*utf16));\n  if (utf16 == (wchar_t *) NULL)\n    return((wchar_t *) NULL);\n  *length=UTF8ToUTF16(source,utf16);\n  return(utf16);\n}\n\nstatic MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}\n\nstatic MagickBooleanType WritePDFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define CFormat  \"/Filter [ /%s ]\\n\"\n#define ObjectsPerImage  14\n#define ThrowPDFException(exception,message) \\\n{ \\\n  if (xref != (MagickOffsetType *) NULL) \\\n    xref=(MagickOffsetType *) RelinquishMagickMemory(xref); \\\n  ThrowWriterException((exception),(message)); \\\n}\n\nDisableMSCWarning(4310)\n  static const char\n    XMPProfile[]=\n    {\n      \"<?xpacket begin=\\\"%s\\\" id=\\\"W5M0MpCehiHzreSzNTczkc9d\\\"?>\\n\"\n      \"<x:xmpmeta xmlns:x=\\\"adobe:ns:meta/\\\" x:xmptk=\\\"Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:08:23\\\">\\n\"\n      \"   <rdf:RDF xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\">\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xap=\\\"http://ns.adobe.com/xap/1.0/\\\">\\n\"\n      \"         <xap:ModifyDate>%s</xap:ModifyDate>\\n\"\n      \"         <xap:CreateDate>%s</xap:CreateDate>\\n\"\n      \"         <xap:MetadataDate>%s</xap:MetadataDate>\\n\"\n      \"         <xap:CreatorTool>%s</xap:CreatorTool>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\">\\n\"\n      \"         <dc:format>application/pdf</dc:format>\\n\"\n      \"         <dc:title>\\n\"\n      \"           <rdf:Alt>\\n\"\n      \"              <rdf:li xml:lang=\\\"x-default\\\">%s</rdf:li>\\n\"\n      \"           </rdf:Alt>\\n\"\n      \"         </dc:title>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:xapMM=\\\"http://ns.adobe.com/xap/1.0/mm/\\\">\\n\"\n      \"         <xapMM:DocumentID>uuid:6ec119d7-7982-4f56-808d-dfe64f5b35cf</xapMM:DocumentID>\\n\"\n      \"         <xapMM:InstanceID>uuid:a79b99b4-6235-447f-9f6c-ec18ef7555cb</xapMM:InstanceID>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdf=\\\"http://ns.adobe.com/pdf/1.3/\\\">\\n\"\n      \"         <pdf:Producer>%s</pdf:Producer>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"      <rdf:Description rdf:about=\\\"\\\"\\n\"\n      \"            xmlns:pdfaid=\\\"http://www.aiim.org/pdfa/ns/id/\\\">\\n\"\n      \"         <pdfaid:part>3</pdfaid:part>\\n\"\n      \"         <pdfaid:conformance>B</pdfaid:conformance>\\n\"\n      \"      </rdf:Description>\\n\"\n      \"   </rdf:RDF>\\n\"\n      \"</x:xmpmeta>\\n\"\n      \"<?xpacket end=\\\"w\\\"?>\\n\"\n    },\n    XMPProfileMagick[4]= { (char) 0xef, (char) 0xbb, (char) 0xbf, (char) 0x00 };\nRestoreMSCWarning\n\n  char\n    basename[MagickPathExtent],\n    buffer[MagickPathExtent],\n    *escape,\n    date[MagickPathExtent],\n    **labels,\n    page_geometry[MagickPathExtent],\n    *url;\n\n  CompressionType\n    compression;\n\n  const char\n    *device,\n    *option,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  double\n    pointsize;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *next,\n    *tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene,\n    *xref;\n\n  MagickSizeType\n    number_pixels;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution,\n    scale;\n\n  RectangleInfo\n    geometry,\n    media_info,\n    page_info;\n\n  register const Quantum\n    *p;\n\n  register unsigned char\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    channels,\n    imageListLength,\n    info_id,\n    length,\n    object,\n    pages_id,\n    root_id,\n    text_size,\n    version;\n\n  ssize_t\n    count,\n    page_count,\n    y;\n\n  struct tm\n    local_time;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate X ref memory.\n  */\n  xref=(MagickOffsetType *) AcquireQuantumMemory(2048UL,sizeof(*xref));\n  if (xref == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(xref,0,2048UL*sizeof(*xref));\n  /*\n    Write Info object.\n  */\n  object=0;\n  version=3;\n  if (image_info->compression == JPEG2000Compression)\n    version=(size_t) MagickMax(version,5);\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n    if (next->alpha_trait != UndefinedPixelTrait)\n      version=(size_t) MagickMax(version,4);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    version=(size_t) MagickMax(version,6);\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    version=(size_t) MagickMax(version,7);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%%PDF-1.%.20g \\n\",(double)\n    version);\n  (void) WriteBlobString(image,buffer);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      (void) WriteBlobByte(image,'%');\n      (void) WriteBlobByte(image,0xe2);\n      (void) WriteBlobByte(image,0xe3);\n      (void) WriteBlobByte(image,0xcf);\n      (void) WriteBlobByte(image,0xd3);\n      (void) WriteBlobByte(image,'\\n');\n    }\n  /*\n    Write Catalog object.\n  */\n  xref[object++]=TellBlob(image);\n  root_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") != 0)\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n      (double) object+1);\n  else\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Metadata %.20g 0 R\\n\",\n        (double) object+1);\n      (void) WriteBlobString(image,buffer);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Pages %.20g 0 R\\n\",\n        (double) object+2);\n    }\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/Type /Catalog\");\n  option=GetImageOption(image_info,\"pdf:page-direction\");\n  if ((option != (const char *) NULL) &&\n      (LocaleCompare(option,\"right-to-left\") == 0))\n    (void) WriteBlobString(image,\"/ViewerPreferences<</PageDirection/R2L>>\\n\");\n  (void) WriteBlobString(image,\"\\n\");\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  GetPathComponent(image->filename,BasePath,basename);\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    {\n      char\n        create_date[MagickPathExtent],\n        modify_date[MagickPathExtent],\n        timestamp[MagickPathExtent],\n        *url,\n        xmp_profile[MagickPathExtent];\n\n      /*\n        Write XMP object.\n      */\n      xref[object++]=TellBlob(image);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n        object);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"<<\\n\");\n      (void) WriteBlobString(image,\"/Subtype /XML\\n\");\n      *modify_date='\\0';\n      value=GetImageProperty(image,\"date:modify\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(modify_date,value,MagickPathExtent);\n      *create_date='\\0';\n      value=GetImageProperty(image,\"date:create\",exception);\n      if (value != (const char *) NULL)\n        (void) CopyMagickString(create_date,value,MagickPathExtent);\n      (void) FormatMagickTime(time((time_t *) NULL),MagickPathExtent,timestamp);\n      url=(char *) MagickAuthoritativeURL;\n      escape=EscapeParenthesis(basename);\n      i=FormatLocaleString(xmp_profile,MagickPathExtent,XMPProfile,\n        XMPProfileMagick,modify_date,create_date,timestamp,url,escape,url);\n      escape=DestroyString(escape);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g\\n\",\n        (double) i);\n      (void) WriteBlobString(image,buffer);\n      (void) WriteBlobString(image,\"/Type /Metadata\\n\");\n      (void) WriteBlobString(image,\">>\\nstream\\n\");\n      (void) WriteBlobString(image,xmp_profile);\n      (void) WriteBlobString(image,\"\\nendstream\\n\");\n      (void) WriteBlobString(image,\"endobj\\n\");\n    }\n  /*\n    Write Pages object.\n  */\n  xref[object++]=TellBlob(image);\n  pages_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) WriteBlobString(image,\"/Type /Pages\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Kids [ %.20g 0 R \",\n    (double) object+1);\n  (void) WriteBlobString(image,buffer);\n  count=(ssize_t) (pages_id+ObjectsPerImage+1);\n  page_count=1;\n  if (image_info->adjoin != MagickFalse)\n    {\n      Image\n        *kid_image;\n\n      /*\n        Predict page object id's.\n      */\n      kid_image=image;\n      for ( ; GetNextImageInList(kid_image) != (Image *) NULL; count+=ObjectsPerImage)\n      {\n        page_count++;\n        profile=GetImageProfile(kid_image,\"icc\");\n        if (profile != (StringInfo *) NULL)\n          count+=2;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 R \",(double)\n          count);\n        (void) WriteBlobString(image,buffer);\n        kid_image=GetNextImageInList(kid_image);\n      }\n      xref=(MagickOffsetType *) ResizeQuantumMemory(xref,(size_t) count+2048UL,\n        sizeof(*xref));\n      if (xref == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) WriteBlobString(image,\"]\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Count %.20g\\n\",(double)\n    page_count);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    MagickBooleanType\n      has_icc_profile;\n\n    profile=GetImageProfile(image,\"icc\");\n    has_icc_profile=(profile != (StringInfo *) NULL) ? MagickTrue : MagickFalse;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        if ((SetImageMonochrome(image,exception) == MagickFalse) ||\n            (image->alpha_trait != UndefinedPixelTrait))\n          compression=RLECompression;\n        break;\n      }\n#if !defined(MAGICKCORE_JPEG_DELEGATE)\n      case JPEGCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JPEG)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n      case JPEG2000Compression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (JP2)\",\n          image->filename);\n        break;\n      }\n#endif\n#if !defined(MAGICKCORE_ZLIB_DELEGATE)\n      case ZipCompression:\n      {\n        compression=RLECompression;\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateError,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (ZLIB)\",\n          image->filename);\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression;  /* LZW compression is forbidden */\n        break;\n      }\n      case NoCompression:\n      {\n        if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n          compression=RLECompression; /* ASCII 85 compression is forbidden */\n        break;\n      }\n      default:\n        break;\n    }\n    if (compression == JPEG2000Compression)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    /*\n      Scale relative to dots-per-inch.\n    */\n    delta.x=DefaultResolution;\n    delta.y=DefaultResolution;\n    resolution.x=image->resolution.x;\n    resolution.y=image->resolution.y;\n    if ((resolution.x == 0.0) || (resolution.y == 0.0))\n      {\n        flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image_info->density != (char *) NULL)\n      {\n        flags=ParseGeometry(image_info->density,&geometry_info);\n        resolution.x=geometry_info.rho;\n        resolution.y=geometry_info.sigma;\n        if ((flags & SigmaValue) == 0)\n          resolution.y=resolution.x;\n      }\n    if (image->units == PixelsPerCentimeterResolution)\n      {\n        resolution.x=(double) ((size_t) (100.0*2.54*resolution.x+0.5)/100.0);\n        resolution.y=(double) ((size_t) (100.0*2.54*resolution.y+0.5)/100.0);\n      }\n    SetGeometry(image,&geometry);\n    (void) FormatLocaleString(page_geometry,MagickPathExtent,\"%.20gx%.20g\",\n      (double) image->columns,(double) image->rows);\n    if (image_info->page != (char *) NULL)\n      (void) CopyMagickString(page_geometry,image_info->page,MagickPathExtent);\n    else\n      if ((image->page.width != 0) && (image->page.height != 0))\n        (void) FormatLocaleString(page_geometry,MagickPathExtent,\n          \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n      else\n        if ((image->gravity != UndefinedGravity) &&\n            (LocaleCompare(image_info->magick,\"PDF\") == 0))\n          (void) CopyMagickString(page_geometry,PSPageGeometry,\n            MagickPathExtent);\n    (void) ConcatenateMagickString(page_geometry,\">\",MagickPathExtent);\n    (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    scale.x=(double) (geometry.width*delta.x)/resolution.x;\n    geometry.width=(size_t) floor(scale.x+0.5);\n    scale.y=(double) (geometry.height*delta.y)/resolution.y;\n    geometry.height=(size_t) floor(scale.y+0.5);\n    (void) ParseAbsoluteGeometry(page_geometry,&media_info);\n    (void) ParseGravityGeometry(image,page_geometry,&page_info,exception);\n    if (image->gravity != UndefinedGravity)\n      {\n        geometry.x=(-page_info.x);\n        geometry.y=(ssize_t) (media_info.height+page_info.y-image->rows);\n      }\n    pointsize=12.0;\n    if (image_info->pointsize != 0.0)\n      pointsize=image_info->pointsize;\n    text_size=0;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      text_size=(size_t) (MultilineCensus(value)*pointsize+12);\n    (void) text_size;\n    /*\n      Write Page object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /Page\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Parent %.20g 0 R\\n\",\n      (double) pages_id);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"/Resources <<\\n\");\n    labels=(char **) NULL;\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      labels=StringToList(value);\n    if (labels != (char **) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/Font << /F%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n          object+4);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/XObject << /Im%.20g %.20g 0 R >>\\n\",(double) image->scene,(double)\n      object+5);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ProcSet %.20g 0 R >>\\n\",\n      (double) object+3);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/MediaBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"/CropBox [0 0 %g %g]\\n\",72.0*media_info.width/resolution.x,\n      72.0*media_info.height/resolution.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Contents %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Thumb %.20g 0 R\\n\",\n      (double) object+(has_icc_profile != MagickFalse ? 10 : 8));\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Contents object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    (void) WriteBlobString(image,\"q\\n\");\n    if (labels != (char **) NULL)\n      for (i=0; labels[i] != (char *) NULL; i++)\n      {\n        (void) WriteBlobString(image,\"BT\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/F%.20g %g Tf\\n\",\n          (double) image->scene,pointsize);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g Td\\n\",\n          (double) geometry.x,(double) (geometry.y+geometry.height+i*pointsize+\n          12));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"(%s) Tj\\n\",\n           labels[i]);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"ET\\n\");\n        labels[i]=DestroyString(labels[i]);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"%g 0 0 %g %.20g %.20g cm\\n\",scale.x,scale.y,(double) geometry.x,\n      (double) geometry.y);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Im%.20g Do\\n\",(double)\n      image->scene);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"Q\\n\");\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Procset object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageC\",MagickPathExtent);\n    else\n      if ((compression == FaxCompression) || (compression == Group4Compression))\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageB\",MagickPathExtent);\n      else\n        (void) CopyMagickString(buffer,\"[ /PDF /Text /ImageI\",MagickPathExtent);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\" ]\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Font object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (labels != (char **) NULL)\n      {\n        (void) WriteBlobString(image,\"/Type /Font\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Type1\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /F%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/BaseFont /Helvetica\\n\");\n        (void) WriteBlobString(image,\"/Encoding /MacRomanEncoding\\n\");\n        labels=(char **) RelinquishMagickMemory(labels);\n      }\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write XObject object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    (void) WriteBlobString(image,\"/Type /XObject\\n\");\n    (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Im%.20g\\n\",\n      (double) image->scene);\n    (void) WriteBlobString(image,buffer);\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) image->columns,(double) image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object+2);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/SMask %.20g 0 R\\n\",\n          (double) object+(has_icc_profile != MagickFalse ? 9 : 7));\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (MagickSizeType) ((size_t) (4*number_pixels)))\n      ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((compression == FaxCompression) || (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,image,exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(image,p))));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n          (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runoffset encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                if (image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelRed(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelGreen(image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelBlue(image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(image,p)));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump Runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  *q++=(unsigned char) GetPixelIndex(image,p);\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char) GetPixelIndex(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                if (image->previous == (Image *) NULL)\n                  {\n                    status=SetImageProgress(image,SaveImageTag,\n                      (MagickOffsetType) y,image->rows);\n                    if (status == MagickFalse)\n                      break;\n                  }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Colorspace object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    device=\"DeviceRGB\";\n    channels=0;\n    if (image->colorspace == CMYKColorspace)\n      {\n        device=\"DeviceCMYK\";\n        channels=4;\n      }\n    else\n      if ((compression == FaxCompression) ||\n          (compression == Group4Compression) ||\n          ((image_info->type != TrueColorType) &&\n           (SetImageGray(image,exception) != MagickFalse)))\n        {\n          device=\"DeviceGray\";\n          channels=1;\n        }\n      else\n        if ((image->storage_class == DirectClass) ||\n            (image->colors > 256) || (compression == JPEGCompression) ||\n            (compression == JPEG2000Compression))\n          {\n            device=\"DeviceRGB\";\n            channels=3;\n          }\n    profile=GetImageProfile(image,\"icc\");\n    if ((profile == (StringInfo *) NULL) || (channels == 0))\n      {\n        if (channels != 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/%s\\n\",device);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"[ /Indexed /%s %.20g %.20g 0 R ]\\n\",device,(double) image->colors-\n            1,(double) object+3);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        const unsigned char\n          *p;\n\n        /*\n          Write ICC profile. \n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"[/ICCBased %.20g 0 R]\\n\",(double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"endobj\\n\");\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"<<\\n/N %.20g\\n\"\n          \"/Filter /ASCII85Decode\\n/Length %.20g 0 R\\n/Alternate /%s\\n>>\\n\"\n          \"stream\\n\",(double) channels,(double) object+1,device);\n        (void) WriteBlobString(image,buffer);\n        offset=TellBlob(image);\n        Ascii85Initialize(image);\n        p=GetStringInfoDatum(profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n          Ascii85Encode(image,(unsigned char) *p++);\n        Ascii85Flush(image);\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"endstream\\n\");\n        (void) WriteBlobString(image,\"endobj\\n\");\n        /*\n          Write Length object.\n        */\n        xref[object++]=TellBlob(image);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",\n          (double) object);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          offset);\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Thumb object.\n    */\n    SetGeometry(image,&geometry);\n    (void) ParseMetaGeometry(\"106x106+0+0>\",&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    tile_image=ThumbnailImage(image,geometry.width,geometry.height,exception);\n    if (tile_image == (Image *) NULL)\n      return(MagickFalse);\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"ASCII85Decode\");\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"DCTDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case JPEG2000Compression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"JPXDecode\");\n        if (image->colorspace != CMYKColorspace)\n          break;\n        (void) WriteBlobString(image,buffer);\n        (void) CopyMagickString(buffer,\"/Decode [1 0 1 0 1 0 1 0]\\n\",\n          MagickPathExtent);\n        break;\n      }\n      case LZWCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\"LZWDecode\");\n        break;\n      }\n      case ZipCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"FlateDecode\");\n        break;\n      }\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) CopyMagickString(buffer,\"/Filter [ /CCITTFaxDecode ]\\n\",\n          MagickPathExtent);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/DecodeParms [ << \"\n          \"/K %s /BlackIs1 false /Columns %.20g /Rows %.20g >> ]\\n\",CCITTParam,\n          (double) tile_image->columns,(double) tile_image->rows);\n        break;\n      }\n      default:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n          \"RunLengthDecode\");\n        break;\n      }\n    }\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",(double)\n      tile_image->columns);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",(double)\n      tile_image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/ColorSpace %.20g 0 R\\n\",\n      (double) object-(has_icc_profile != MagickFalse ? 3 : 1));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/BitsPerComponent %d\\n\",\n      (compression == FaxCompression) || (compression == Group4Compression) ?\n      1 : 8);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n      (double) object+1);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\">>\\n\");\n    (void) WriteBlobString(image,\"stream\\n\");\n    offset=TellBlob(image);\n    number_pixels=(MagickSizeType) tile_image->columns*tile_image->rows;\n    if ((compression == FaxCompression) ||\n        (compression == Group4Compression) ||\n        ((image_info->type != TrueColorType) &&\n         (SetImageGray(tile_image,exception) != MagickFalse)))\n      {\n        switch (compression)\n        {\n          case FaxCompression:\n          case Group4Compression:\n          {\n            if (LocaleCompare(CCITTParam,\"0\") == 0)\n              {\n                (void) HuffmanEncodeImage(image_info,image,tile_image,\n                  exception);\n                break;\n              }\n            (void) Huffman2DEncodeImage(image_info,image,tile_image,exception);\n            break;\n          }\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                  tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                  GetPixelLuma(tile_image,p))));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      }\n    else\n      if ((tile_image->storage_class == DirectClass) ||\n          (tile_image->colors > 256) || (compression == JPEGCompression) ||\n          (compression == JPEG2000Compression))\n        switch (compression)\n        {\n          case JPEGCompression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jpeg\",\n              exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case JPEG2000Compression:\n          {\n            status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            length*=tile_image->colorspace == CMYKColorspace ? 4UL : 3UL;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelRed(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelGreen(tile_image,p));\n                *q++=ScaleQuantumToChar(GetPixelBlue(tile_image,p));\n                if (tile_image->colorspace == CMYKColorspace)\n                  *q++=ScaleQuantumToChar(GetPixelBlack(tile_image,p));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed DirectColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelRed(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelGreen(tile_image,p)));\n                Ascii85Encode(image,ScaleQuantumToChar(\n                  GetPixelBlue(tile_image,p)));\n                if (image->colorspace == CMYKColorspace)\n                  Ascii85Encode(image,ScaleQuantumToChar(\n                    GetPixelBlack(tile_image,p)));\n                p+=GetPixelChannels(tile_image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n      else\n        {\n          /*\n            Dump number of colors and colormap.\n          */\n          switch (compression)\n          {\n            case RLECompression:\n            default:\n            {\n              MemoryInfo\n                *pixel_info;\n\n              /*\n                Allocate pixel array.\n              */\n              length=(size_t) number_pixels;\n              pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n              if (pixel_info == (MemoryInfo *) NULL)\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowPDFException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                }\n              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n              /*\n                Dump runlength encoded pixels.\n              */\n              q=pixels;\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  *q++=(unsigned char) GetPixelIndex(tile_image,p);\n                  p+=GetPixelChannels(tile_image);\n                }\n              }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n              if (compression == ZipCompression)\n                status=ZLIBEncodeImage(image,length,pixels,exception);\n              else\n#endif\n                if (compression == LZWCompression)\n                  status=LZWEncodeImage(image,length,pixels,exception);\n                else\n                  status=PackbitsEncodeImage(image,length,pixels,exception);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              if (status == MagickFalse)\n                {\n                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                  (void) CloseBlob(image);\n                  return(MagickFalse);\n                }\n              break;\n            }\n            case NoCompression:\n            {\n              /*\n                Dump uncompressed PseudoColor packets.\n              */\n              Ascii85Initialize(image);\n              for (y=0; y < (ssize_t) tile_image->rows; y++)\n              {\n                p=GetVirtualPixels(tile_image,0,y,tile_image->columns,1,\n                  exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) tile_image->columns; x++)\n                {\n                  Ascii85Encode(image,(unsigned char)\n                    GetPixelIndex(tile_image,p));\n                  p+=GetPixelChannels(image);\n                }\n              }\n              Ascii85Flush(image);\n              break;\n            }\n          }\n        }\n    tile_image=DestroyImage(tile_image);\n    offset=TellBlob(image)-offset;\n    (void) WriteBlobString(image,\"\\nendstream\\n\");\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if ((image->storage_class == DirectClass) || (image->colors > 256) ||\n        (compression == FaxCompression) || (compression == Group4Compression))\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        /*\n          Write Colormap object.\n        */\n        if (compression == NoCompression)\n          (void) WriteBlobString(image,\"/Filter [ /ASCII85Decode ]\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        if (compression == NoCompression)\n          Ascii85Initialize(image);\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          if (compression == NoCompression)\n            {\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].red)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].green)));\n              Ascii85Encode(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].blue)));\n              continue;\n            }\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].red)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].green)));\n          (void) WriteBlobByte(image,ScaleQuantumToChar(\n             ClampToQuantum(image->colormap[i].blue)));\n        }\n        if (compression == NoCompression)\n          Ascii85Flush(image);\n       offset=TellBlob(image)-offset;\n       (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write softmask object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"<<\\n\");\n    if (image->alpha_trait == UndefinedPixelTrait)\n      (void) WriteBlobString(image,\">>\\n\");\n    else\n      {\n        (void) WriteBlobString(image,\"/Type /XObject\\n\");\n        (void) WriteBlobString(image,\"/Subtype /Image\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Name /Ma%.20g\\n\",\n          (double) image->scene);\n        (void) WriteBlobString(image,buffer);\n        switch (compression)\n        {\n          case NoCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"ASCII85Decode\");\n            break;\n          }\n          case LZWCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"LZWDecode\");\n            break;\n          }\n          case ZipCompression:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"FlateDecode\");\n            break;\n          }\n          default:\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,CFormat,\n              \"RunLengthDecode\");\n            break;\n          }\n        }\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Width %.20g\\n\",\n          (double) image->columns);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Height %.20g\\n\",\n          (double) image->rows);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"/ColorSpace /DeviceGray\\n\");\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"/BitsPerComponent %d\\n\",(compression == FaxCompression) ||\n          (compression == Group4Compression) ? 1 : 8);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"/Length %.20g 0 R\\n\",\n          (double) object+1);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\">>\\n\");\n        (void) WriteBlobString(image,\"stream\\n\");\n        offset=TellBlob(image);\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        switch (compression)\n        {\n          case RLECompression:\n          default:\n          {\n            MemoryInfo\n              *pixel_info;\n\n            /*\n              Allocate pixel array.\n            */\n            length=(size_t) number_pixels;\n            pixel_info=AcquireVirtualMemory(length,4*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                image=DestroyImage(image);\n                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n            /*\n              Dump Runlength encoded pixels.\n            */\n            q=pixels;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n                p+=GetPixelChannels(image);\n              }\n            }\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (compression == ZipCompression)\n              status=ZLIBEncodeImage(image,length,pixels,exception);\n            else\n#endif\n              if (compression == LZWCompression)\n                status=LZWEncodeImage(image,length,pixels,exception);\n              else\n                status=PackbitsEncodeImage(image,length,pixels,exception);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            if (status == MagickFalse)\n              {\n                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                (void) CloseBlob(image);\n                return(MagickFalse);\n              }\n            break;\n          }\n          case NoCompression:\n          {\n            /*\n              Dump uncompressed PseudoColor packets.\n            */\n            Ascii85Initialize(image);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                Ascii85Encode(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));\n                p+=GetPixelChannels(image);\n              }\n            }\n            Ascii85Flush(image);\n            break;\n          }\n        }\n        offset=TellBlob(image)-offset;\n        (void) WriteBlobString(image,\"\\nendstream\\n\");\n      }\n    (void) WriteBlobString(image,\"endobj\\n\");\n    /*\n      Write Length object.\n    */\n    xref[object++]=TellBlob(image);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n      object);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n      offset);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"endobj\\n\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  /*\n    Write Metadata object.\n  */\n  xref[object++]=TellBlob(image);\n  info_id=object;\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g 0 obj\\n\",(double)\n    object);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"<<\\n\");\n  if (LocaleCompare(image_info->magick,\"PDFA\") == 0)\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title (%s)\\n\",\n      EscapeParenthesis(basename));\n  else\n    {\n      wchar_t\n        *utf16;\n\n      utf16=ConvertUTF8ToUTF16((unsigned char *) basename,&length);\n      if (utf16 != (wchar_t *) NULL)\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"/Title (\\xfe\\xff\");\n          (void) WriteBlobString(image,buffer);\n          for (i=0; i < (ssize_t) length; i++)\n            (void) WriteBlobMSBShort(image,(unsigned short) utf16[i]);\n          (void) FormatLocaleString(buffer,MagickPathExtent,\")\\n\");\n          utf16=(wchar_t *) RelinquishMagickMemory(utf16);\n        }\n    }\n  (void) WriteBlobString(image,buffer);\n  seconds=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&seconds,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&seconds),sizeof(local_time));\n#endif\n  (void) FormatLocaleString(date,MagickPathExtent,\"D:%04d%02d%02d%02d%02d%02d\",\n    local_time.tm_year+1900,local_time.tm_mon+1,local_time.tm_mday,\n    local_time.tm_hour,local_time.tm_min,local_time.tm_sec);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/CreationDate (%s)\\n\",\n    date);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ModDate (%s)\\n\",date);\n  (void) WriteBlobString(image,buffer);\n  url=(char *) MagickAuthoritativeURL;\n  escape=EscapeParenthesis(url);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Producer (%s)\\n\",escape);\n  escape=DestroyString(escape);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"endobj\\n\");\n  /*\n    Write Xref object.\n  */\n  offset=TellBlob(image)-xref[0]+\n   (LocaleCompare(image_info->magick,\"PDFA\") == 0 ? 6 : 0)+10;\n  (void) WriteBlobString(image,\"xref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"0 %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"0000000000 65535 f \\n\");\n  for (i=0; i < (ssize_t) object; i++)\n  {\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"%010lu 00000 n \\n\",\n      (unsigned long) xref[i]);\n    (void) WriteBlobString(image,buffer);\n  }\n  (void) WriteBlobString(image,\"trailer\\n\");\n  (void) WriteBlobString(image,\"<<\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Size %.20g\\n\",(double)\n    object+1);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Info %.20g 0 R\\n\",(double)\n    info_id);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/Root %.20g 0 R\\n\",(double)\n    root_id);\n  (void) WriteBlobString(image,buffer);\n  (void) SignatureImage(image,exception);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"/ID [<%s> <%s>]\\n\",\n    GetImageProperty(image,\"signature\",exception),\n    GetImageProperty(image,\"signature\",exception));\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\">>\\n\");\n  (void) WriteBlobString(image,\"startxref\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double) offset);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"%%EOF\\n\");\n  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/pdf.c"], "buggy_code_start_loc": [1912], "buggy_code_end_loc": [2904], "fixing_code_start_loc": [1913], "fixing_code_end_loc": [2913], "type": "CWE-401", "message": "In ImageMagick before 7.0.8-25 and GraphicsMagick through 1.3.31, several memory leaks exist in WritePDFImage in coders/pdf.c.", "other": {"cve": {"id": "CVE-2019-7397", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-05T00:29:00.510", "lastModified": "2021-04-28T17:30:09.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ImageMagick before 7.0.8-25 and GraphicsMagick through 1.3.31, several memory leaks exist in WritePDFImage in coders/pdf.c."}, {"lang": "es", "value": "En ImageMagick, en versiones anteriores a la 7.0.8-25, y GraphicsMagick, hasta la versi\u00f3n 1.3.31, existen varias vulnerabilidades de fuga de memoria en WritePDFImage en coders/pdf.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-25", "matchCriteriaId": "E982CE9C-89F7-4A5D-B036-A9A483493D5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-25", "matchCriteriaId": "2F7DF2A1-ADDE-48C4-BD39-CCA15D0D767A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:graphicsmagick:graphicsmagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.3.31", "matchCriteriaId": "DA564A9F-4001-4846-A8BB-EAD95674C890"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "http://hg.graphicsmagick.org/hg/GraphicsMagick/rev/11ad3aeb8ab1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00034.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00006.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://www.securityfocus.com/bid/106847", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/306c1f0fa5754ca78efd16ab752f0e981d4f6b82", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1454", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4034-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/306c1f0fa5754ca78efd16ab752f0e981d4f6b82"}}