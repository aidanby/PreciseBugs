{"buggy_code": ["/*\n** proc.c - Proc class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n#include <mruby/opcode.h>\n#include <mruby/data.h>\n#include <mruby/presym.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n\nstatic const mrb_code call_iseq[] = {\n  OP_CALL,\n};\n\nstatic const mrb_irep call_irep = {\n  0,                                   /* nlocals */\n  2,                                   /* nregs */\n  0,                                   /* clen */\n  MRB_ISEQ_NO_FREE | MRB_IREP_NO_FREE, /* flags */\n  call_iseq,                           /* iseq */\n  NULL,                                /* pool */\n  NULL,                                /* syms */\n  NULL,                                /* reps */\n  NULL,                                /* lv */\n  NULL,                                /* debug_info */\n  1,                                   /* ilen */\n  0,                                   /* plen */\n  0,                                   /* slen */\n  1,                                   /* rlen */\n  0,                                   /* refcnt */\n};\n\nstatic const struct RProc call_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &call_irep }, NULL, { NULL }\n};\n\nstruct RProc*\nmrb_proc_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p;\n  mrb_callinfo *ci = mrb->c->ci;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  if (ci) {\n    struct RClass *tc = NULL;\n\n    if (ci->proc) {\n      if (ci->proc->color != MRB_GC_RED) {\n        tc = MRB_PROC_TARGET_CLASS(ci->proc);\n      }\n      else {\n        tc = mrb_vm_ci_target_class(ci);\n        if (tc && tc->tt == MRB_TT_ICLASS) {\n          tc = tc->c;\n        }\n      }\n    }\n    if (tc == NULL) {\n      tc = mrb_vm_ci_target_class(ci);\n    }\n    p->upper = ci->proc;\n    p->e.target_class = tc;\n  }\n  p->body.irep = irep;\n  if (irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)irep);\n  }\n\n  return p;\n}\n\nstruct REnv*\nmrb_env_new(mrb_state *mrb, struct mrb_context *c, mrb_callinfo *ci, int nstacks, mrb_value *stack, struct RClass *tc)\n{\n  struct REnv *e;\n  mrb_int bidx = 1;\n  int n = ci->n;\n  int nk = ci->nk;\n\n  e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n  e->c = tc;\n  MRB_ENV_SET_LEN(e, nstacks);\n  bidx += (n == 15) ? 1 : n;\n  bidx += (nk == 15) ? 1 : (2*nk);\n  MRB_ENV_SET_BIDX(e, bidx);\n  e->mid = ci->mid;\n  e->stack = stack;\n  e->cxt = c;\n\n  return e;\n}\n\nstatic void\nclosure_setup(mrb_state *mrb, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  const struct RProc *up = p->upper;\n  struct REnv *e = NULL;\n\n  if (ci && (e = mrb_vm_ci_env(ci)) != NULL) {\n    /* do nothing, because e is assigned already */\n  }\n  else if (up) {\n    struct RClass *tc = ci->u.target_class;\n\n    e = mrb_env_new(mrb, mrb->c, ci, up->body.irep->nlocals, ci->stack, tc);\n    ci->u.env = e;\n    if (MRB_PROC_ENV_P(up) && MRB_PROC_ENV(up)->cxt == NULL) {\n      e->mid = MRB_PROC_ENV(up)->mid;\n    }\n  }\n  if (e) {\n    p->e.env = e;\n    p->flags |= MRB_PROC_ENVSET;\n    mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  }\n}\n\nstruct RProc*\nmrb_closure_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p = mrb_proc_new(mrb, irep);\n\n  closure_setup(mrb, p);\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc(mrb_state *mrb, mrb_func_t func)\n{\n  struct RProc *p;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  p->body.func = func;\n  p->flags |= MRB_PROC_CFUNC_FL;\n  p->upper = 0;\n  p->e.target_class = 0;\n\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc_with_env(mrb_state *mrb, mrb_func_t func, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p = mrb_proc_new_cfunc(mrb, func);\n  struct REnv *e;\n  int i;\n\n  p->e.env = e = mrb_env_new(mrb, mrb->c, mrb->c->ci, 0, NULL, NULL);\n  p->flags |= MRB_PROC_ENVSET;\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  MRB_ENV_CLOSE(e);\n\n  e->stack = (mrb_value*)mrb_malloc(mrb, sizeof(mrb_value) * argc);\n  MRB_ENV_SET_LEN(e, argc);\n\n  if (argv) {\n    for (i = 0; i < argc; ++i) {\n      e->stack[i] = argv[i];\n    }\n  }\n  else {\n    for (i = 0; i < argc; ++i) {\n      SET_NIL_VALUE(e->stack[i]);\n    }\n  }\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals)\n{\n  return mrb_proc_new_cfunc_with_env(mrb, func, nlocals, NULL);\n}\n\nMRB_API mrb_value\nmrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)\n{\n  const struct RProc *p = mrb->c->ci->proc;\n  struct REnv *e;\n\n  if (!p || !MRB_PROC_CFUNC_P(p)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from non-cfunc proc\");\n  }\n  e = MRB_PROC_ENV(p);\n  if (!e) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from cfunc Proc without REnv\");\n  }\n  if (idx < 0 || MRB_ENV_LEN(e) <= idx) {\n    mrb_raisef(mrb, E_INDEX_ERROR, \"Env index out of range: %i (expected: 0 <= index < %i)\",\n               idx, MRB_ENV_LEN(e));\n  }\n\n  return e->stack[idx];\n}\n\nvoid\nmrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}\n\nstatic mrb_value\nmrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}\n\nstatic mrb_value\nmrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}\n\n/* 15.2.17.4.2 */\nstatic mrb_value\nproc_arity(mrb_state *mrb, mrb_value self)\n{\n  return mrb_int_value(mrb, mrb_proc_arity(mrb_proc_ptr(self)));\n}\n\n/* 15.3.1.2.6  */\n/* 15.3.1.3.27 */\n/*\n * call-seq:\n *   lambda { |...| block }  -> a_proc\n *\n * Equivalent to <code>Proc.new</code>, except the resulting Proc objects\n * check the number of parameters passed when called.\n */\nstatic mrb_value\nproc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(mrb, p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}\n\nmrb_int\nmrb_proc_arity(const struct RProc *p)\n{\n  const mrb_irep *irep;\n  const mrb_code *pc;\n  mrb_aspec aspec;\n  int ma, op, ra, pa, arity;\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    /* TODO cfunc aspec not implemented yet */\n    return -1;\n  }\n\n  irep = p->body.irep;\n  if (!irep) {\n    return 0;\n  }\n\n  pc = irep->iseq;\n  /* arity is depend on OP_ENTER */\n  if (*pc != OP_ENTER) {\n    return 0;\n  }\n\n  aspec = PEEK_W(pc+1);\n  ma = MRB_ASPEC_REQ(aspec);\n  op = MRB_ASPEC_OPT(aspec);\n  ra = MRB_ASPEC_REST(aspec);\n  pa = MRB_ASPEC_POST(aspec);\n  arity = ra || (MRB_PROC_STRICT_P(p) && op) ? -(ma + pa + 1) : ma + pa;\n\n  return arity;\n}\n\nmrb_value\nmrb_proc_local_variables(mrb_state *mrb, const struct RProc *proc)\n{\n  const mrb_irep *irep;\n  mrb_value vars;\n  size_t i;\n\n  if (proc == NULL || MRB_PROC_CFUNC_P(proc)) {\n    return mrb_ary_new(mrb);\n  }\n  vars = mrb_hash_new(mrb);\n  while (proc) {\n    if (MRB_PROC_CFUNC_P(proc)) break;\n    irep = proc->body.irep;\n    if (irep->lv) {\n      for (i = 0; i + 1 < irep->nlocals; ++i) {\n        if (irep->lv[i]) {\n          mrb_sym sym = irep->lv[i];\n          const char *name = mrb_sym_name(mrb, sym);\n          switch (name[0]) {\n          case '*': case '&':\n            break;\n          default:\n            mrb_hash_set(mrb, vars, mrb_symbol_value(sym), mrb_true_value());\n            break;\n          }\n        }\n      }\n    }\n    if (MRB_PROC_SCOPE_P(proc)) break;\n    proc = proc->upper;\n  }\n\n  return mrb_hash_keys(mrb, vars);\n}\n\nconst struct RProc *\nmrb_proc_get_caller(mrb_state *mrb, struct REnv **envp)\n{\n  struct mrb_context *c = mrb->c;\n  mrb_callinfo *ci = (c->ci > c->cibase) ? c->ci - 1 : c->cibase;\n  const struct RProc *proc = ci->proc;\n\n  if (!proc || MRB_PROC_CFUNC_P(proc)) {\n    if (envp) *envp = NULL;\n  }\n  else {\n    struct RClass *tc = MRB_PROC_TARGET_CLASS(proc);\n    struct REnv *e = mrb_vm_ci_env(ci);\n\n    if (e == NULL) {\n      int nstacks = proc->body.irep->nlocals;\n      e = mrb_env_new(mrb, c, ci, nstacks, ci->stack, tc);\n      ci->u.env = e;\n    }\n    else if (tc) {\n      e->c = tc;\n      mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n    }\n    if (envp) *envp = e;\n  }\n\n  return proc;\n}\n\n#define IREP_LVAR_MERGE_DEFAULT  50\n#define IREP_LVAR_MERGE_MINIMUM   8\n#define IREP_LVAR_MERGE_MAXIMUM 240\n\n#ifdef MRB_IREP_LVAR_MERGE_LIMIT\n# define IREP_LVAR_MERGE_LIMIT \\\n  ((MRB_IREP_LVAR_MERGE_LIMIT) < IREP_LVAR_MERGE_MINIMUM ? IREP_LVAR_MERGE_MINIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT) > IREP_LVAR_MERGE_MAXIMUM ? IREP_LVAR_MERGE_MAXIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT))\n#else\n# define IREP_LVAR_MERGE_LIMIT IREP_LVAR_MERGE_DEFAULT\n#endif\n\nvoid\nmrb_proc_merge_lvar(mrb_state *mrb, mrb_irep *irep, struct REnv *env, int num, const mrb_sym *lv, const mrb_value *stack)\n{\n  mrb_assert(!(irep->flags & MRB_IREP_NO_FREE));\n\n  if ((irep->nlocals + num) > IREP_LVAR_MERGE_LIMIT) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"too many local variables for binding (mruby limitation)\");\n  }\n\n  if (!lv) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"unavailable local variable names\");\n  }\n\n  irep->lv = (mrb_sym*)mrb_realloc(mrb, (mrb_sym*)irep->lv, sizeof(mrb_sym) * (irep->nlocals + num));\n  env->stack = (mrb_value*)mrb_realloc(mrb, env->stack, sizeof(mrb_value) * (irep->nlocals + 1 /* self */ + num));\n\n  mrb_sym *destlv = (mrb_sym*)irep->lv + irep->nlocals - 1 /* self */;\n  mrb_value *destst = env->stack + irep->nlocals;\n  memmove(destlv, lv, sizeof(mrb_sym) * num);\n  if (stack) {\n    memmove(destst, stack, sizeof(mrb_value) * num);\n    for (int i = 0; i < num; i++) {\n      if (!mrb_immediate_p(stack[i])) {\n        mrb_field_write_barrier(mrb, (struct RBasic*)env, (struct RBasic*)mrb_obj_ptr(stack[i]));\n      }\n    }\n  }\n  else {\n    for (int i = num; i > 0; i--, destst++) {\n      *destst = mrb_nil_value();\n    }\n  }\n  irep->nlocals += num;\n  irep->nregs = irep->nlocals;\n  MRB_ENV_SET_LEN(env, irep->nlocals);\n}\n\nvoid\nmrb_init_proc(mrb_state *mrb)\n{\n  mrb_method_t m;\n\n  mrb_define_class_method(mrb, mrb->proc_class, \"new\", mrb_proc_s_new, MRB_ARGS_NONE()|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, mrb->proc_class, \"initialize_copy\", mrb_proc_init_copy, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mrb->proc_class, \"arity\", proc_arity, MRB_ARGS_NONE());\n\n  MRB_METHOD_FROM_PROC(m, &call_proc);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_SYM(call), m);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_OPSYM(aref), m);\n\n  mrb_define_class_method(mrb, mrb->kernel_module, \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.2.6  */\n  mrb_define_method(mrb, mrb->kernel_module,       \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.3.27 */\n}\n"], "fixing_code": ["/*\n** proc.c - Proc class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n#include <mruby/opcode.h>\n#include <mruby/data.h>\n#include <mruby/presym.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n\nstatic const mrb_code call_iseq[] = {\n  OP_CALL,\n};\n\nstatic const mrb_irep call_irep = {\n  0,                                   /* nlocals */\n  2,                                   /* nregs */\n  0,                                   /* clen */\n  MRB_ISEQ_NO_FREE | MRB_IREP_NO_FREE, /* flags */\n  call_iseq,                           /* iseq */\n  NULL,                                /* pool */\n  NULL,                                /* syms */\n  NULL,                                /* reps */\n  NULL,                                /* lv */\n  NULL,                                /* debug_info */\n  1,                                   /* ilen */\n  0,                                   /* plen */\n  0,                                   /* slen */\n  1,                                   /* rlen */\n  0,                                   /* refcnt */\n};\n\nstatic const struct RProc call_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &call_irep }, NULL, { NULL }\n};\n\nstruct RProc*\nmrb_proc_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p;\n  mrb_callinfo *ci = mrb->c->ci;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  if (ci) {\n    struct RClass *tc = NULL;\n\n    if (ci->proc) {\n      if (ci->proc->color != MRB_GC_RED) {\n        tc = MRB_PROC_TARGET_CLASS(ci->proc);\n      }\n      else {\n        tc = mrb_vm_ci_target_class(ci);\n        if (tc && tc->tt == MRB_TT_ICLASS) {\n          tc = tc->c;\n        }\n      }\n    }\n    if (tc == NULL) {\n      tc = mrb_vm_ci_target_class(ci);\n    }\n    p->upper = ci->proc;\n    p->e.target_class = tc;\n  }\n  p->body.irep = irep;\n  if (irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)irep);\n  }\n\n  return p;\n}\n\nstruct REnv*\nmrb_env_new(mrb_state *mrb, struct mrb_context *c, mrb_callinfo *ci, int nstacks, mrb_value *stack, struct RClass *tc)\n{\n  struct REnv *e;\n  mrb_int bidx = 1;\n  int n = ci->n;\n  int nk = ci->nk;\n\n  e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);\n  e->c = tc;\n  MRB_ENV_SET_LEN(e, nstacks);\n  bidx += (n == 15) ? 1 : n;\n  bidx += (nk == 15) ? 1 : (2*nk);\n  MRB_ENV_SET_BIDX(e, bidx);\n  e->mid = ci->mid;\n  e->stack = stack;\n  e->cxt = c;\n\n  return e;\n}\n\nstatic void\nclosure_setup(mrb_state *mrb, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  const struct RProc *up = p->upper;\n  struct REnv *e = NULL;\n\n  if (ci && (e = mrb_vm_ci_env(ci)) != NULL) {\n    /* do nothing, because e is assigned already */\n  }\n  else if (up) {\n    struct RClass *tc = ci->u.target_class;\n\n    e = mrb_env_new(mrb, mrb->c, ci, up->body.irep->nlocals, ci->stack, tc);\n    ci->u.env = e;\n    if (MRB_PROC_ENV_P(up) && MRB_PROC_ENV(up)->cxt == NULL) {\n      e->mid = MRB_PROC_ENV(up)->mid;\n    }\n  }\n  if (e) {\n    p->e.env = e;\n    p->flags |= MRB_PROC_ENVSET;\n    mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  }\n}\n\nstruct RProc*\nmrb_closure_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p = mrb_proc_new(mrb, irep);\n\n  closure_setup(mrb, p);\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc(mrb_state *mrb, mrb_func_t func)\n{\n  struct RProc *p;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  p->body.func = func;\n  p->flags |= MRB_PROC_CFUNC_FL;\n  p->upper = 0;\n  p->e.target_class = 0;\n\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_proc_new_cfunc_with_env(mrb_state *mrb, mrb_func_t func, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p = mrb_proc_new_cfunc(mrb, func);\n  struct REnv *e;\n  int i;\n\n  p->e.env = e = mrb_env_new(mrb, mrb->c, mrb->c->ci, 0, NULL, NULL);\n  p->flags |= MRB_PROC_ENVSET;\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);\n  MRB_ENV_CLOSE(e);\n\n  e->stack = (mrb_value*)mrb_malloc(mrb, sizeof(mrb_value) * argc);\n  MRB_ENV_SET_LEN(e, argc);\n\n  if (argv) {\n    for (i = 0; i < argc; ++i) {\n      e->stack[i] = argv[i];\n    }\n  }\n  else {\n    for (i = 0; i < argc; ++i) {\n      SET_NIL_VALUE(e->stack[i]);\n    }\n  }\n  return p;\n}\n\nMRB_API struct RProc*\nmrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals)\n{\n  return mrb_proc_new_cfunc_with_env(mrb, func, nlocals, NULL);\n}\n\nMRB_API mrb_value\nmrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)\n{\n  const struct RProc *p = mrb->c->ci->proc;\n  struct REnv *e;\n\n  if (!p || !MRB_PROC_CFUNC_P(p)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from non-cfunc proc\");\n  }\n  e = MRB_PROC_ENV(p);\n  if (!e) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"Can't get cfunc env from cfunc Proc without REnv\");\n  }\n  if (idx < 0 || MRB_ENV_LEN(e) <= idx) {\n    mrb_raisef(mrb, E_INDEX_ERROR, \"Env index out of range: %i (expected: 0 <= index < %i)\",\n               idx, MRB_ENV_LEN(e));\n  }\n\n  return e->stack[idx];\n}\n\nvoid\nmrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}\n\nstatic mrb_value\nmrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}\n\nstatic mrb_value\nmrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}\n\n/* 15.2.17.4.2 */\nstatic mrb_value\nproc_arity(mrb_state *mrb, mrb_value self)\n{\n  return mrb_int_value(mrb, mrb_proc_arity(mrb_proc_ptr(self)));\n}\n\n/* 15.3.1.2.6  */\n/* 15.3.1.3.27 */\n/*\n * call-seq:\n *   lambda { |...| block }  -> a_proc\n *\n * Equivalent to <code>Proc.new</code>, except the resulting Proc objects\n * check the number of parameters passed when called.\n */\nstatic mrb_value\nproc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(mrb, p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}\n\nmrb_int\nmrb_proc_arity(const struct RProc *p)\n{\n  const mrb_irep *irep;\n  const mrb_code *pc;\n  mrb_aspec aspec;\n  int ma, op, ra, pa, arity;\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    /* TODO cfunc aspec not implemented yet */\n    return -1;\n  }\n\n  irep = p->body.irep;\n  if (!irep) {\n    return 0;\n  }\n\n  pc = irep->iseq;\n  /* arity is depend on OP_ENTER */\n  if (*pc != OP_ENTER) {\n    return 0;\n  }\n\n  aspec = PEEK_W(pc+1);\n  ma = MRB_ASPEC_REQ(aspec);\n  op = MRB_ASPEC_OPT(aspec);\n  ra = MRB_ASPEC_REST(aspec);\n  pa = MRB_ASPEC_POST(aspec);\n  arity = ra || (MRB_PROC_STRICT_P(p) && op) ? -(ma + pa + 1) : ma + pa;\n\n  return arity;\n}\n\nmrb_value\nmrb_proc_local_variables(mrb_state *mrb, const struct RProc *proc)\n{\n  const mrb_irep *irep;\n  mrb_value vars;\n  size_t i;\n\n  if (proc == NULL || MRB_PROC_CFUNC_P(proc)) {\n    return mrb_ary_new(mrb);\n  }\n  vars = mrb_hash_new(mrb);\n  while (proc) {\n    if (MRB_PROC_CFUNC_P(proc)) break;\n    irep = proc->body.irep;\n    if (irep->lv) {\n      for (i = 0; i + 1 < irep->nlocals; ++i) {\n        if (irep->lv[i]) {\n          mrb_sym sym = irep->lv[i];\n          const char *name = mrb_sym_name(mrb, sym);\n          switch (name[0]) {\n          case '*': case '&':\n            break;\n          default:\n            mrb_hash_set(mrb, vars, mrb_symbol_value(sym), mrb_true_value());\n            break;\n          }\n        }\n      }\n    }\n    if (MRB_PROC_SCOPE_P(proc)) break;\n    proc = proc->upper;\n  }\n\n  return mrb_hash_keys(mrb, vars);\n}\n\nconst struct RProc *\nmrb_proc_get_caller(mrb_state *mrb, struct REnv **envp)\n{\n  struct mrb_context *c = mrb->c;\n  mrb_callinfo *ci = (c->ci > c->cibase) ? c->ci - 1 : c->cibase;\n  const struct RProc *proc = ci->proc;\n\n  if (!proc || MRB_PROC_CFUNC_P(proc)) {\n    if (envp) *envp = NULL;\n  }\n  else {\n    struct RClass *tc = MRB_PROC_TARGET_CLASS(proc);\n    struct REnv *e = mrb_vm_ci_env(ci);\n\n    if (e == NULL) {\n      int nstacks = proc->body.irep->nlocals;\n      e = mrb_env_new(mrb, c, ci, nstacks, ci->stack, tc);\n      ci->u.env = e;\n    }\n    else if (tc) {\n      e->c = tc;\n      mrb_field_write_barrier(mrb, (struct RBasic*)e, (struct RBasic*)tc);\n    }\n    if (envp) *envp = e;\n  }\n\n  return proc;\n}\n\n#define IREP_LVAR_MERGE_DEFAULT  50\n#define IREP_LVAR_MERGE_MINIMUM   8\n#define IREP_LVAR_MERGE_MAXIMUM 240\n\n#ifdef MRB_IREP_LVAR_MERGE_LIMIT\n# define IREP_LVAR_MERGE_LIMIT \\\n  ((MRB_IREP_LVAR_MERGE_LIMIT) < IREP_LVAR_MERGE_MINIMUM ? IREP_LVAR_MERGE_MINIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT) > IREP_LVAR_MERGE_MAXIMUM ? IREP_LVAR_MERGE_MAXIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT))\n#else\n# define IREP_LVAR_MERGE_LIMIT IREP_LVAR_MERGE_DEFAULT\n#endif\n\nvoid\nmrb_proc_merge_lvar(mrb_state *mrb, mrb_irep *irep, struct REnv *env, int num, const mrb_sym *lv, const mrb_value *stack)\n{\n  mrb_assert(!(irep->flags & MRB_IREP_NO_FREE));\n\n  if ((irep->nlocals + num) > IREP_LVAR_MERGE_LIMIT) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"too many local variables for binding (mruby limitation)\");\n  }\n\n  if (!lv) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"unavailable local variable names\");\n  }\n\n  irep->lv = (mrb_sym*)mrb_realloc(mrb, (mrb_sym*)irep->lv, sizeof(mrb_sym) * (irep->nlocals + num));\n  env->stack = (mrb_value*)mrb_realloc(mrb, env->stack, sizeof(mrb_value) * (irep->nlocals + 1 /* self */ + num));\n\n  mrb_sym *destlv = (mrb_sym*)irep->lv + irep->nlocals - 1 /* self */;\n  mrb_value *destst = env->stack + irep->nlocals;\n  memmove(destlv, lv, sizeof(mrb_sym) * num);\n  if (stack) {\n    memmove(destst, stack, sizeof(mrb_value) * num);\n    for (int i = 0; i < num; i++) {\n      if (!mrb_immediate_p(stack[i])) {\n        mrb_field_write_barrier(mrb, (struct RBasic*)env, (struct RBasic*)mrb_obj_ptr(stack[i]));\n      }\n    }\n  }\n  else {\n    for (int i = num; i > 0; i--, destst++) {\n      *destst = mrb_nil_value();\n    }\n  }\n  irep->nlocals += num;\n  irep->nregs = irep->nlocals;\n  MRB_ENV_SET_LEN(env, irep->nlocals);\n}\n\nvoid\nmrb_init_proc(mrb_state *mrb)\n{\n  mrb_method_t m;\n\n  mrb_define_class_method(mrb, mrb->proc_class, \"new\", mrb_proc_s_new, MRB_ARGS_NONE()|MRB_ARGS_BLOCK());\n  mrb_define_method(mrb, mrb->proc_class, \"initialize_copy\", mrb_proc_init_copy, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mrb->proc_class, \"arity\", proc_arity, MRB_ARGS_NONE());\n\n  MRB_METHOD_FROM_PROC(m, &call_proc);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_SYM(call), m);\n  mrb_define_method_raw(mrb, mrb->proc_class, MRB_OPSYM(aref), m);\n\n  mrb_define_class_method(mrb, mrb->kernel_module, \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.2.6  */\n  mrb_define_method(mrb, mrb->kernel_module,       \"lambda\", proc_lambda, MRB_ARGS_NONE()|MRB_ARGS_BLOCK()); /* 15.3.1.3.27 */\n}\n"], "filenames": ["src/proc.c"], "buggy_code_start_loc": [209], "buggy_code_end_loc": [216], "fixing_code_start_loc": [210], "fixing_code_end_loc": [215], "type": "CWE-122", "message": "mruby is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2022-0080", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-02T12:15:07.690", "lastModified": "2022-01-11T14:22:16.563", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mruby is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "mruby es vulnerable al desbordamiento del b\u00fafer en la regi\u00f3n Heap de la memoria.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.0", "matchCriteriaId": "E65F5997-52F0-4937-AFA2-D56A5DACBD6C"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/59a70392-4864-4ce3-8e35-6ac2111d1e2e", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6"}}