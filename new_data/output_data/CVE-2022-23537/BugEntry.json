{"buggy_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJNATH_STUN_MSG_H__\n#define __PJNATH_STUN_MSG_H__\n\n/**\n * @file stun_msg.h\n * @brief STUN message components.\n */\n\n#include <pjnath/types.h>\n#include <pj/sock.h>\n\n\nPJ_BEGIN_DECL\n\n\n/* **************************************************************************/\n/**\n * @defgroup PJNATH_STUN_MSG STUN Message Representation and Parsing\n * @ingroup PJNATH_STUN_BASE\n * @brief Low-level representation and parsing of STUN messages.\n * @{\n */\n\n\n/**\n * STUN magic cookie.\n */\n#define PJ_STUN_MAGIC                       0x2112A442\n\n\n/**\n * STUN method constants.\n */\nenum pj_stun_method_e\n{\n    /**\n     * STUN Binding method as defined by RFC 3489-bis.\n     */\n    PJ_STUN_BINDING_METHOD                  = 1,\n\n    /**\n     * STUN Shared Secret method as defined by RFC 3489-bis.\n     */\n    PJ_STUN_SHARED_SECRET_METHOD            = 2,\n\n    /**\n     * STUN/TURN Allocate method as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_ALLOCATE_METHOD                 = 3,\n\n    /**\n     * STUN/TURN Refresh method as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_REFRESH_METHOD                  = 4,\n\n    /**\n     * STUN/TURN Send indication as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_SEND_METHOD                     = 6,\n\n    /**\n     * STUN/TURN Data indication as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_DATA_METHOD                     = 7,\n\n    /**\n     * STUN/TURN CreatePermission method as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_CREATE_PERM_METHOD              = 8,\n\n    /**\n     * STUN/TURN ChannelBind as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_CHANNEL_BIND_METHOD             = 9,\n\n    /**\n     * STUN/TURN Connect as defined by RFC 6062\n     */\n    PJ_STUN_CONNECT_METHOD                  = 10,\n\n    /**\n     * STUN/TURN ConnectionBind as defined by RFC 6062\n     */\n    PJ_STUN_CONNECTION_BIND_METHOD          = 11,\n\n    /**\n     * STUN/TURN ConnectionAttempt as defined by RFC 6062\n     */\n    PJ_STUN_CONNECTION_ATTEMPT_METHOD       = 12,\n\n    /**\n     * All known methods.\n     */\n    PJ_STUN_METHOD_MAX\n};\n\n\n/**\n * Retrieve the STUN method from the message-type field of the STUN\n * message.\n */\n#define PJ_STUN_GET_METHOD(msg_type)    ((msg_type) & 0xFEEF)\n\n\n/**\n * STUN message classes constants.\n */\nenum pj_stun_msg_class_e\n{\n    /**\n     * This specifies that the message type is a STUN request message.\n     */\n    PJ_STUN_REQUEST_CLASS           = 0,\n\n    /**\n     * This specifies that the message type is a STUN indication message.\n     */\n    PJ_STUN_INDICATION_CLASS        = 1,\n\n    /**\n     * This specifies that the message type is a STUN successful response.\n     */\n    PJ_STUN_SUCCESS_CLASS           = 2,\n\n    /**\n     * This specifies that the message type is a STUN error response.\n     */\n    PJ_STUN_ERROR_CLASS             = 3\n};\n\n\n/**\n * Determine if the message type is a request.\n */\n#define PJ_STUN_IS_REQUEST(msg_type)    (((msg_type) & 0x0110) == 0x0000)\n\n\n/**\n * Determine if the message type is a successful response.\n */\n#define PJ_STUN_IS_SUCCESS_RESPONSE(msg_type) (((msg_type) & 0x0110) == 0x0100)\n\n/**\n * The response bit in the message type.\n */\n#define PJ_STUN_SUCCESS_RESPONSE_BIT    (0x0100)\n\n\n/**\n * Determine if the message type is an error response.\n */\n#define PJ_STUN_IS_ERROR_RESPONSE(msg_type) (((msg_type) & 0x0110) == 0x0110)\n\n/**\n * The error response bit in the message type.\n */\n#define PJ_STUN_ERROR_RESPONSE_BIT      (0x0110)\n\n/**\n * Determine if the message type is a response.\n */\n#define PJ_STUN_IS_RESPONSE(msg_type) (((msg_type) & 0x0100) == 0x0100)\n\n\n/**\n * Determine if the message type is an indication message.\n */\n#define PJ_STUN_IS_INDICATION(msg_type) (((msg_type) & 0x0110) == 0x0010)\n\n/**\n * The error response bit in the message type.\n */\n#define PJ_STUN_INDICATION_BIT          (0x0010)\n\n\n/**\n * This enumeration describes STUN message types.\n */\ntypedef enum pj_stun_msg_type\n{\n    /**\n     * STUN BINDING request.\n     */\n    PJ_STUN_BINDING_REQUEST                 = 0x0001,\n\n    /**\n     * Successful response to STUN BINDING-REQUEST.\n     */\n    PJ_STUN_BINDING_RESPONSE                = 0x0101,\n\n    /**\n     * Error response to STUN BINDING-REQUEST.\n     */\n    PJ_STUN_BINDING_ERROR_RESPONSE          = 0x0111,\n\n    /**\n     * Binding Indication (ICE)\n     */\n    PJ_STUN_BINDING_INDICATION              = 0x0011,\n\n    /**\n     * STUN SHARED-SECRET reqeust.\n     */\n    PJ_STUN_SHARED_SECRET_REQUEST           = 0x0002,\n\n    /**\n     * Successful response to STUN SHARED-SECRET reqeust.\n     */\n    PJ_STUN_SHARED_SECRET_RESPONSE          = 0x0102,\n\n    /**\n     * Error response to STUN SHARED-SECRET reqeust.\n     */\n    PJ_STUN_SHARED_SECRET_ERROR_RESPONSE    = 0x0112,\n\n\n    /**\n     * STUN/TURN Allocate Request\n     */\n    PJ_STUN_ALLOCATE_REQUEST                = 0x0003,\n\n    /**\n     * Successful response to STUN/TURN Allocate Request\n     */\n    PJ_STUN_ALLOCATE_RESPONSE               = 0x0103,\n\n    /**\n     * Failure response to STUN/TURN Allocate Request\n     */\n    PJ_STUN_ALLOCATE_ERROR_RESPONSE         = 0x0113,\n\n\n    /**\n     * STUN/TURN REFRESH Request\n     */\n    PJ_STUN_REFRESH_REQUEST                 = 0x0004,\n\n    /**\n     * Successful response to STUN REFRESH request\n     */\n    PJ_STUN_REFRESH_RESPONSE                = 0x0104,\n\n    /**\n     * Error response to STUN REFRESH request.\n     */\n    PJ_STUN_REFRESH_ERROR_RESPONSE          = 0x0114,\n\n\n    /**\n     * TURN Send indication\n     */\n    PJ_STUN_SEND_INDICATION                 = 0x0016,\n\n\n    /**\n     * TURN Data indication\n     */\n    PJ_STUN_DATA_INDICATION                 = 0x0017,\n\n\n    /**\n     * TURN CreatePermission request\n     */\n    PJ_STUN_CREATE_PERM_REQUEST             = 0x0008,\n\n    /**\n     * TURN CreatePermission successful response.\n     */\n    PJ_STUN_CREATE_PERM_RESPONSE            = 0x0108,\n\n    /**\n     * TURN CreatePermission failure response\n     */\n    PJ_STUN_CREATE_PERM_ERROR_RESPONSE      = 0x0118,\n\n\n    /**\n     * STUN/TURN ChannelBind Request\n     */\n    PJ_STUN_CHANNEL_BIND_REQUEST            = 0x0009,\n\n    /**\n     * Successful response to STUN ChannelBind request\n     */\n    PJ_STUN_CHANNEL_BIND_RESPONSE           = 0x0109,\n\n    /**\n     * Error response to STUN ChannelBind request.\n     */\n    PJ_STUN_CHANNEL_BIND_ERROR_RESPONSE     = 0x0119,\n\n    /**\n     * STUN/TURN Connect Request\n     */\n    PJ_STUN_CONNECT_REQUEST                 = 0x000a,\n\n    /**\n     * STUN/TURN ConnectBind Request\n     */\n    PJ_STUN_CONNECTION_BIND_REQUEST         = 0x000b,\n\n    /**\n     * TURN ConnectionAttempt indication\n     */\n    PJ_STUN_CONNECTION_ATTEMPT_INDICATION   = 0x001c,\n\n} pj_stun_msg_type;\n\n\n\n/**\n * This enumeration describes STUN attribute types.\n */\ntypedef enum pj_stun_attr_type\n{\n    PJ_STUN_ATTR_MAPPED_ADDR        = 0x0001,/**< MAPPED-ADDRESS.           */\n    PJ_STUN_ATTR_RESPONSE_ADDR      = 0x0002,/**< RESPONSE-ADDRESS (deprcatd)*/\n    PJ_STUN_ATTR_CHANGE_REQUEST     = 0x0003,/**< CHANGE-REQUEST (deprecated)*/\n    PJ_STUN_ATTR_SOURCE_ADDR        = 0x0004,/**< SOURCE-ADDRESS (deprecated)*/\n    PJ_STUN_ATTR_CHANGED_ADDR       = 0x0005,/**< CHANGED-ADDRESS (deprecatd)*/\n    PJ_STUN_ATTR_USERNAME           = 0x0006,/**< USERNAME attribute.       */\n    PJ_STUN_ATTR_PASSWORD           = 0x0007,/**< was PASSWORD attribute.   */\n    PJ_STUN_ATTR_MESSAGE_INTEGRITY  = 0x0008,/**< MESSAGE-INTEGRITY.        */\n    PJ_STUN_ATTR_ERROR_CODE         = 0x0009,/**< ERROR-CODE.               */\n    PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES = 0x000A,/**< UNKNOWN-ATTRIBUTES.       */\n    PJ_STUN_ATTR_REFLECTED_FROM     = 0x000B,/**< REFLECTED-FROM (deprecatd)*/\n    PJ_STUN_ATTR_CHANNEL_NUMBER     = 0x000C,/**< TURN CHANNEL-NUMBER       */\n    PJ_STUN_ATTR_LIFETIME           = 0x000D,/**< TURN LIFETIME attr.       */\n    PJ_STUN_ATTR_MAGIC_COOKIE       = 0x000F,/**< MAGIC-COOKIE attr (deprec)*/\n    PJ_STUN_ATTR_BANDWIDTH          = 0x0010,/**< TURN BANDWIDTH (deprec)   */\n    PJ_STUN_ATTR_XOR_PEER_ADDR      = 0x0012,/**< TURN XOR-PEER-ADDRESS     */\n    PJ_STUN_ATTR_DATA               = 0x0013,/**< DATA attribute.           */\n    PJ_STUN_ATTR_REALM              = 0x0014,/**< REALM attribute.          */\n    PJ_STUN_ATTR_NONCE              = 0x0015,/**< NONCE attribute.          */\n    PJ_STUN_ATTR_XOR_RELAYED_ADDR   = 0x0016,/**< TURN XOR-RELAYED-ADDRESS  */\n    PJ_STUN_ATTR_REQ_ADDR_TYPE      = 0x0017,/**< REQUESTED-ADDRESS-TYPE    */\n    PJ_STUN_ATTR_REQ_ADDR_FAMILY    = 0x0017,/**< REQUESTED-ADDRESS-FAMILY  */\n    PJ_STUN_ATTR_EVEN_PORT          = 0x0018,/**< TURN EVEN-PORT            */\n    PJ_STUN_ATTR_REQ_TRANSPORT      = 0x0019,/**< TURN REQUESTED-TRANSPORT  */\n    PJ_STUN_ATTR_DONT_FRAGMENT      = 0x001A,/**< TURN DONT-FRAGMENT        */\n    PJ_STUN_ATTR_XOR_MAPPED_ADDR    = 0x0020,/**< XOR-MAPPED-ADDRESS        */\n    PJ_STUN_ATTR_TIMER_VAL          = 0x0021,/**< TIMER-VAL attribute.      */\n    PJ_STUN_ATTR_RESERVATION_TOKEN  = 0x0022,/**< TURN RESERVATION-TOKEN    */\n    PJ_STUN_ATTR_XOR_REFLECTED_FROM = 0x0023,/**< XOR-REFLECTED-FROM        */\n    PJ_STUN_ATTR_PRIORITY           = 0x0024,/**< PRIORITY                  */\n    PJ_STUN_ATTR_USE_CANDIDATE      = 0x0025,/**< USE-CANDIDATE             */\n    PJ_STUN_ATTR_CONNECTION_ID      = 0x002a,/**< CONNECTION-ID             */\n    PJ_STUN_ATTR_ICMP               = 0x0030,/**< ICMP (TURN)               */\n\n    PJ_STUN_ATTR_END_MANDATORY_ATTR,\n\n    PJ_STUN_ATTR_START_EXTENDED_ATTR= 0x8021,\n\n    PJ_STUN_ATTR_SOFTWARE           = 0x8022,/**< SOFTWARE attribute.       */\n    PJ_STUN_ATTR_ALTERNATE_SERVER   = 0x8023,/**< ALTERNATE-SERVER.         */\n    PJ_STUN_ATTR_REFRESH_INTERVAL   = 0x8024,/**< REFRESH-INTERVAL.         */\n    PJ_STUN_ATTR_FINGERPRINT        = 0x8028,/**< FINGERPRINT attribute.    */\n    PJ_STUN_ATTR_ICE_CONTROLLED     = 0x8029,/**< ICE-CCONTROLLED attribute.*/\n    PJ_STUN_ATTR_ICE_CONTROLLING    = 0x802a,/**< ICE-CCONTROLLING attribute*/\n\n    PJ_STUN_ATTR_END_EXTENDED_ATTR\n\n} pj_stun_attr_type;\n\n\n/**\n * STUN error codes, which goes into STUN ERROR-CODE attribute.\n */\ntypedef enum pj_stun_status\n{\n    PJ_STUN_SC_TRY_ALTERNATE            = 300,  /**< Try Alternate          */\n    PJ_STUN_SC_BAD_REQUEST              = 400,  /**< Bad Request            */\n    PJ_STUN_SC_UNAUTHORIZED             = 401,  /**< Unauthorized           */\n    PJ_STUN_SC_FORBIDDEN                = 403,  /**< Forbidden (TURN)       */\n    PJ_STUN_SC_UNKNOWN_ATTRIBUTE        = 420,  /**< Unknown Attribute      */\n#if 0\n    /* These were obsolete in recent rfc3489bis */\n    //PJ_STUN_SC_STALE_CREDENTIALS      = 430,  /**< Stale Credentials      */\n    //PJ_STUN_SC_INTEGRITY_CHECK_FAILURE= 431,  /**< Integrity Chk Fail     */\n    //PJ_STUN_SC_MISSING_USERNAME       = 432,  /**< Missing Username       */\n    //PJ_STUN_SC_USE_TLS                = 433,  /**< Use TLS                */\n    //PJ_STUN_SC_MISSING_REALM          = 434,  /**< Missing Realm          */\n    //PJ_STUN_SC_MISSING_NONCE          = 435,  /**< Missing Nonce          */\n    //PJ_STUN_SC_UNKNOWN_USERNAME       = 436,  /**< Unknown Username       */\n#endif\n    PJ_STUN_SC_ALLOCATION_MISMATCH      = 437,  /**< TURN Alloc Mismatch    */\n    PJ_STUN_SC_STALE_NONCE              = 438,  /**< Stale Nonce            */\n    PJ_STUN_SC_TRANSITIONING            = 439,  /**< Transitioning.         */\n    PJ_STUN_SC_WRONG_CREDENTIALS        = 441,  /**< TURN Wrong Credentials */\n    PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO   = 442,  /**< Unsupported Transport or\n                                                     Protocol (TURN) */\n    PJ_STUN_SC_OPER_TCP_ONLY            = 445,  /**< Operation for TCP Only */\n    PJ_STUN_SC_CONNECTION_FAILURE       = 446,  /**< Connection Failure     */\n    PJ_STUN_SC_CONNECTION_TIMEOUT       = 447,  /**< Connection Timeout     */\n    PJ_STUN_SC_ALLOCATION_QUOTA_REACHED = 486,  /**< Allocation Quota Reached\n                                                     (TURN) */\n    PJ_STUN_SC_ROLE_CONFLICT            = 487,  /**< Role Conflict          */\n    PJ_STUN_SC_SERVER_ERROR             = 500,  /**< Server Error           */\n    PJ_STUN_SC_INSUFFICIENT_CAPACITY    = 508,  /**< Insufficient Capacity \n                                                     (TURN) */\n    PJ_STUN_SC_GLOBAL_FAILURE           = 600   /**< Global Failure         */\n} pj_stun_status;\n\n\n/**\n * This structure describes STUN message header. A STUN message has the \n * following format:\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |0 0|     STUN Message Type     |         Message Length        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                         Magic Cookie                          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                Transaction ID\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                                                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   \\endverbatim\n */\ntypedef struct pj_stun_msg_hdr\n{\n    /**\n     * STUN message type, which the first two bits must be zeroes.\n     */\n    pj_uint16_t         type;\n\n    /**\n     * The message length is the size, in bytes, of the message not\n     * including the 20 byte STUN header.\n     */\n    pj_uint16_t         length;\n\n    /**\n     * The magic cookie is a fixed value, 0x2112A442 (PJ_STUN_MAGIC constant).\n     * In the previous version of this specification [15] this field was part \n     * of the transaction ID.\n     */\n    pj_uint32_t         magic;\n\n    /**\n     * The transaction ID is a 96 bit identifier.  STUN transactions are\n     * identified by their unique 96-bit transaction ID.  For request/\n     * response transactions, the transaction ID is chosen by the STUN\n     * client and MUST be unique for each new STUN transaction generated by\n     * that STUN client.  The transaction ID MUST be uniformly and randomly\n     * distributed between 0 and 2**96 - 1. \n     */\n    pj_uint8_t          tsx_id[12];\n\n} pj_stun_msg_hdr;\n\n\n/**\n * This structre describes STUN attribute header. Each attribute is\n * TLV encoded, with a 16 bit type, 16 bit length, and variable value.\n * Each STUN attribute ends on a 32 bit boundary:\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |         Type                  |            Length             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   \\endverbatim\n */\ntypedef struct pj_stun_attr_hdr\n{\n    /**\n     * STUN attribute type.\n     */\n    pj_uint16_t         type;\n\n    /**\n     * The Length refers to the length of the actual useful content of the\n     * Value portion of the attribute, measured in bytes. The value\n     * in the Length field refers to the length of the Value part of the\n     * attribute prior to padding - i.e., the useful content.\n     */\n    pj_uint16_t         length;\n\n} pj_stun_attr_hdr;\n\n\n/**\n * This structure describes STUN generic IP address attribute, used for\n * example to represent STUN MAPPED-ADDRESS attribute.\n *\n * The generic IP address attribute indicates the transport address.\n * It consists of an eight bit address family, and a sixteen bit port,\n * followed by a fixed length value representing the IP address.  If the\n * address family is IPv4, the address is 32 bits, in network byte\n * order.  If the address family is IPv6, the address is 128 bits in\n * network byte order.\n *\n * The format of the generic IP address attribute is:\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |x x x x x x x x|    Family     |           Port                |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                   Address  (variable)\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   \\endverbatim\n */\ntypedef struct pj_stun_sockaddr_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * Flag to indicate whether this attribute should be sent in XOR-ed\n     * format, or has been received in XOR-ed format.\n     */\n    pj_bool_t           xor_ed;\n\n    /**\n     * The socket address\n     */\n    pj_sockaddr         sockaddr;\n\n} pj_stun_sockaddr_attr;\n\n\n/**\n * This structure represents a generic STUN attributes with no payload,\n * and it is used for example by ICE USE-CANDIDATE attribute.\n */\ntypedef struct pj_stun_empty_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n} pj_stun_empty_attr;\n\n\n/**\n * This structure represents generic STUN string attributes, such as STUN\n * USERNAME, PASSWORD, SOFTWARE, REALM, and NONCE attributes.\n */\ntypedef struct pj_stun_string_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * The string value.\n     */\n    pj_str_t            value;\n\n} pj_stun_string_attr;\n\n\n/**\n * This structure represents a generic STUN attributes with 32bit (unsigned)\n * integer value, such as STUN FINGERPRINT and REFRESH-INTERVAL attributes.\n */\ntypedef struct pj_stun_uint_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n    \n    /**\n     * The 32bit value, in host byte order.\n     */\n    pj_uint32_t         value;\n\n} pj_stun_uint_attr;\n\n\n/**\n * This structure represents a generic STUN attributes with 64bit (unsigned)\n * integer value, such as ICE-CONTROLLED and ICE-CONTROLLING attributes.\n */\ntypedef struct pj_stun_uint64_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n    \n    /**\n     * The 64bit value, in host byte order, represented with pj_timestamp.\n     */\n    pj_timestamp        value;\n\n} pj_stun_uint64_attr;\n\n\n/**\n * This structure represents generic STUN attributes to hold a raw binary\n * data.\n */\ntypedef struct pj_stun_binary_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n    \n    /**\n     * Special signature to indicate that this is a valid attribute even\n     * though we don't have meta-data to describe this attribute.\n     */\n    pj_uint32_t         magic;\n\n    /**\n     * Length of the data.\n     */\n    unsigned            length;\n\n    /**\n     * The raw data.\n     */\n    pj_uint8_t         *data;\n\n} pj_stun_binary_attr;\n\n\n/**\n * This structure describes STUN MESSAGE-INTEGRITY attribute.\n * The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [10] of the\n * STUN message.  The MESSAGE-INTEGRITY attribute can be present in any\n * STUN message type.  Since it uses the SHA1 hash, the HMAC will be 20\n * bytes.\n */\ntypedef struct pj_stun_msgint_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * The 20 bytes hmac value.\n     */\n    pj_uint8_t          hmac[20];\n\n} pj_stun_msgint_attr;\n\n\n/**\n * This structure describes STUN FINGERPRINT attribute. The FINGERPRINT \n * attribute can be present in all STUN messages.  It is computed as \n * the CRC-32 of the STUN message up to (but excluding) the FINGERPRINT \n * attribute itself, xor-d with the 32 bit value 0x5354554e\n */\ntypedef struct pj_stun_uint_attr pj_stun_fingerprint_attr;\n\n\n/**\n * This structure represents STUN ERROR-CODE attribute. The ERROR-CODE \n * attribute is present in the Binding Error Response and Shared Secret \n * Error Response.  It is a numeric value in the range of 100 to 699 \n * plus a textual reason phrase encoded in UTF-8\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                   0                     |Class|     Number    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |      Reason Phrase (variable)                                ..\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n \\endverbatim\n */\ntypedef struct pj_stun_errcode_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * STUN error code.\n     */\n    int                 err_code;\n\n    /**\n     * The reason phrase.\n     */\n    pj_str_t            reason;\n\n} pj_stun_errcode_attr;\n\n\n/**\n * This describes STUN REALM attribute.\n * The REALM attribute is present in requests and responses.  It\n * contains text which meets the grammar for \"realm\" as described in RFC\n * 3261 [11], and will thus contain a quoted string (including the\n * quotes).\n */\ntypedef struct pj_stun_string_attr pj_stun_realm_attr;\n\n\n/**\n * This describes STUN NONCE attribute. \n * The NONCE attribute is present in requests and in error responses.\n * It contains a sequence of qdtext or quoted-pair, which are defined in\n * RFC 3261 [11].  See RFC 2617 [7] for guidance on selection of nonce\n * values in a server.\n */\ntypedef struct pj_stun_string_attr pj_stun_nonce_attr;\n\n\n/**\n * This describes STUN UNKNOWN-ATTRIBUTES attribute.\n * The UNKNOWN-ATTRIBUTES attribute is present only in an error response\n * when the response code in the ERROR-CODE attribute is 420.\n * The attribute contains a list of 16 bit values, each of which\n * represents an attribute type that was not understood by the server.\n * If the number of unknown attributes is an odd number, one of the\n * attributes MUST be repeated in the list, so that the total length of\n * the list is a multiple of 4 bytes.\n */\ntypedef struct pj_stun_unknown_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * Number of unknown attributes in the array.\n     */\n    unsigned            attr_count;\n\n    /**\n     * Array of unknown attribute IDs.\n     */\n    pj_uint16_t         attrs[PJ_STUN_MAX_ATTR];\n\n} pj_stun_unknown_attr;\n\n\n/**\n * This structure describes STUN MAPPED-ADDRESS attribute.\n * The MAPPED-ADDRESS attribute indicates the mapped transport address.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_mapped_addr_attr;\n\n\n/**\n * This describes STUN XOR-MAPPED-ADDRESS attribute (which has the same\n * format as STUN MAPPED-ADDRESS attribute).\n * The XOR-MAPPED-ADDRESS attribute is present in responses.  It\n * provides the same information that would present in the MAPPED-\n * ADDRESS attribute but because the NAT's public IP address is\n * obfuscated through the XOR function, STUN messages are able to pass\n * through NATs which would otherwise interfere with STUN.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_mapped_addr_attr;\n\n\n/**\n * This describes STUN SOFTWARE attribute.\n * The SOFTWARE attribute contains a textual description of the software\n * being used by the agent sending the message.  It is used by clients\n * and servers.  Its value SHOULD include manufacturer and version\n * number. */\ntypedef struct pj_stun_string_attr pj_stun_software_attr;\n\n\n/**\n * This describes STUN ALTERNATE-SERVER attribute.\n * The alternate server represents an alternate transport address for a\n * different STUN server to try.  It is encoded in the same way as\n * MAPPED-ADDRESS.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_alt_server_attr;\n\n\n/**\n * This describes STUN REFRESH-INTERVAL attribute.\n * The REFRESH-INTERVAL indicates the number of milliseconds that the\n * server suggests the client should use between refreshes of the NAT\n * bindings between the client and server.\n */\ntypedef struct pj_stun_uint_attr pj_stun_refresh_interval_attr;\n\n\n/**\n * This structure describes STUN RESPONSE-ADDRESS attribute.\n * The RESPONSE-ADDRESS attribute indicates where the response to a\n * Binding Request should be sent.  Its syntax is identical to MAPPED-\n * ADDRESS.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_response_addr_attr;\n\n\n/**\n * This structure describes STUN CHANGED-ADDRESS attribute.\n * The CHANGED-ADDRESS attribute indicates the IP address and port where\n * responses would have been sent from if the \"change IP\" and \"change\n * port\" flags had been set in the CHANGE-REQUEST attribute of the\n * Binding Request.  The attribute is always present in a Binding\n * Response, independent of the value of the flags.  Its syntax is\n * identical to MAPPED-ADDRESS.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_changed_addr_attr;\n\n\n/**\n * This structure describes STUN CHANGE-REQUEST attribute.\n * The CHANGE-REQUEST attribute is used by the client to request that\n * the server use a different address and/or port when sending the\n * response. \n *\n * Bit 29 of the value is the \"change IP\" flag.  If true, it requests \n * the server to send the Binding Response with a different IP address \n * than the one the Binding Request was received on.\n *\n * Bit 30 of the value is the \"change port\" flag.  If true, it requests \n * the server to send the Binding Response with a different port than \n * the one the Binding Request was received on.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_uint_attr pj_stun_change_request_attr;\n\n/**\n * This structure describes STUN SOURCE-ADDRESS attribute.\n * The SOURCE-ADDRESS attribute is present in Binding Responses.  It\n * indicates the source IP address and port that the server is sending\n * the response from.  Its syntax is identical to that of MAPPED-\n * ADDRESS.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_src_addr_attr;\n\n\n/**\n * This describes the STUN REFLECTED-FROM attribute.\n * The REFLECTED-FROM attribute is present only in Binding Responses,\n * when the Binding Request contained a RESPONSE-ADDRESS attribute.  The\n * attribute contains the identity (in terms of IP address) of the\n * source where the request came from.  Its purpose is to provide\n * traceability, so that a STUN server cannot be used as a reflector for\n * denial-of-service attacks.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_reflected_from_attr;\n\n\n/**\n * This describes STUN USERNAME attribute.\n * The USERNAME attribute is used for message integrity.  It identifies\n * the shared secret used in the message integrity check.  Consequently,\n * the USERNAME MUST be included in any request that contains the\n * MESSAGE-INTEGRITY attribute.\n */\ntypedef struct pj_stun_string_attr pj_stun_username_attr;\n\n\n/**\n * This describes STUN PASSWORD attribute.\n * If the message type is Shared Secret Response it MUST include the\n * PASSWORD attribute.\n */\ntypedef struct pj_stun_string_attr pj_stun_password_attr;\n\n\n/**\n * This describes TURN CHANNEL-NUMBER attribute. In this library,\n * this attribute is represented with 32bit integer. Application may\n * use #PJ_STUN_GET_CH_NB() and #PJ_STUN_SET_CH_NB() to extract/set\n * channel number value from the 32bit integral value.\n *\n * The CHANNEL-NUMBER attribute contains the number of the channel.\n * It is a 16-bit unsigned integer, followed by a two-octet RFFU field\n * which MUST be set to 0 on transmission and ignored on reception.\n  \n \\verbatim\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |        Channel Number         |         RFFU                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \\endverbatim\n */\ntypedef struct pj_stun_uint_attr pj_stun_channel_number_attr;\n\n/**\n * Get 16bit channel number from 32bit integral value.\n * Note that uint32 attributes are always stored in host byte order\n * after they have been parsed from the PDU, so no need to do ntohs()\n * here.\n */\n#define PJ_STUN_GET_CH_NB(u32)      ((pj_uint16_t)(u32>>16))\n\n/**\n * Convert 16bit channel number into 32bit integral value.\n * Note that uint32 attributes will be converted to network byte order\n * when the attribute is written to packet, so no need to do htons()\n * here.\n */\n#define PJ_STUN_SET_CH_NB(chnum)    (((pj_uint32_t)chnum) << 16)\n\n\n/**\n * This describes STUN LIFETIME attribute.\n * The lifetime attribute represents the duration for which the server\n * will maintain an allocation in the absence of data traffic either\n * from or to the client.  It is a 32 bit value representing the number\n * of seconds remaining until expiration.\n */\ntypedef struct pj_stun_uint_attr pj_stun_lifetime_attr;\n\n\n/**\n * This describes STUN BANDWIDTH attribute.\n * The bandwidth attribute represents the peak bandwidth, measured in\n * kbits per second, that the client expects to use on the binding.  The\n * value represents the sum in the receive and send directions.\n */\ntypedef struct pj_stun_uint_attr pj_stun_bandwidth_attr;\n\n\n/**\n * This describes the STUN XOR-PEER-ADDRESS attribute.\n * The XOR-PEER-ADDRESS specifies the address and port of the peer as seen\n * from the TURN server.  It is encoded in the same way as XOR-MAPPED-\n * ADDRESS. \n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_peer_addr_attr;\n\n\n/**\n * This describes the STUN DATA attribute.\n * The DATA attribute is present in Send Indications and Data\n * Indications.  It contains raw payload data that is to be sent (in the\n * case of a Send Request) or was received (in the case of a Data\n * Indication)..\n */\ntypedef struct pj_stun_binary_attr pj_stun_data_attr;\n\n\n/**\n * This describes the STUN XOR-RELAYED-ADDRESS attribute. The \n * XOR-RELAYED-ADDRESS is present in Allocate responses.  It specifies the\n * address and port that the server allocated to the client.  It is\n * encoded in the same way as XOR-MAPPED-ADDRESS.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_relayed_addr_attr;\n\n\n/**\n * According to RFC 6156, this describes the REQUESTED-ADDRESS-FAMILY\n * attribute (formerly known as REQUESTED-ADDRESS-TYPE in the draft).\n * The REQUESTED-ADDRESS-FAMILY attribute is used by clients to request\n * the allocation of a specific address type from a server.  The\n * following is the format of the REQUESTED-ADDRESS-FAMILY attribute.\n\n \\verbatim\n\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |        Family                 |           Reserved            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n \\endverbatim\n */\ntypedef struct pj_stun_uint_attr pj_stun_req_addr_type_attr;\n\n\n/**\n * This describes the TURN REQUESTED-TRANSPORT attribute, encoded in\n * STUN generic integer attribute.\n *\n * This attribute allows the client to request that the port in the\n * relayed-transport-address be even, and (optionally) that the server\n * reserve the next-higher port number.  The attribute is 8 bits long.\n * Its format is:\n\n\\verbatim\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |R|    RFFU     |\n     +-+-+-+-+-+-+-+-+\n\n\\endverbatim\n\n * The attribute contains a single 1-bit flag:\n * \n * R: If 1, the server is requested to reserve the next higher port\n *    number (on the same IP address) for a subsequent allocation.  If\n *    0, no such reservation is requested.\n * \n * The other 7 bits of the attribute must be set to zero on transmission\n * and ignored on reception.\n */\ntypedef struct pj_stun_uint_attr pj_stun_even_port_attr;\n\n\n/**\n * This describes the TURN REQUESTED-TRANSPORT attribute, encoded in\n * STUN generic integer attribute.\n *\n * This attribute is used by the client to request a specific transport\n * protocol for the allocated transport address.  It has the following\n * format:\n\n \\verbatim\n\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |    Protocol   |                    RFFU                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n \\endverbatim\n\n * The Protocol field specifies the desired protocol.  The codepoints\n * used in this field are taken from those allowed in the Protocol field\n * in the IPv4 header and the NextHeader field in the IPv6 header\n * [Protocol-Numbers].  This specification only allows the use of\n * codepoint 17 (User Datagram Protocol).\n * \n * The RFFU field is set to zero on transmission and ignored on\n * receiption.  It is reserved for future uses.\n */\ntypedef struct pj_stun_uint_attr pj_stun_req_transport_attr;\n\n/**\n * Get protocol value from 32bit TURN REQUESTED-TRANSPORT attribute.\n */\n#define PJ_STUN_GET_RT_PROTO(u32)   (u32 >> 24)\n\n/**\n * Convert protocol value to be placed in 32bit TURN REQUESTED-TRANSPORT\n * attribute.\n */\n#define PJ_STUN_SET_RT_PROTO(proto)   (((pj_uint32_t)(proto)) << 24)\n\n\n/**\n * This describes the TURN DONT-FRAGMENT attribute.\n *\n * This attribute is used by the client to request that the server set\n * the DF (Don't Fragment) bit in the IP header when relaying the\n * application data onward to the peer.  This attribute has no value\n * part and thus the attribute length field is 0.\n */\ntypedef struct pj_stun_empty_attr pj_stun_dont_fragment_attr;\n\n\n/**\n * This describes the TURN RESERVATION-TOKEN attribute.\n * The RESERVATION-TOKEN attribute contains a token that uniquely\n * identifies a relayed transport address being held in reserve by the\n * server.  The server includes this attribute in a success response to\n * tell the client about the token, and the client includes this\n * attribute in a subsequent Allocate request to request the server use\n * that relayed transport address for the allocation.\n * \n * The attribute value is a 64-bit-long field containing the token\n * value. \n */\ntypedef struct pj_stun_uint64_attr pj_stun_res_token_attr;\n\n/**\n * This describes the XOR-REFLECTED-FROM attribute, as described by\n * draft-macdonald-behave-nat-behavior-discovery-00.\n * The XOR-REFLECTED-FROM attribute is used in place of the REFLECTED-\n * FROM attribute.  It provides the same information, but because the\n * NAT's public address is obfuscated through the XOR function, It can\n * pass through a NAT that would otherwise attempt to translate it to\n * the private network address.  XOR-REFLECTED-FROM has identical syntax\n * to XOR-MAPPED-ADDRESS.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_reflected_from_attr;\n\n/**\n * This describes the PRIORITY attribute from draft-ietf-mmusic-ice-13.\n * The PRIORITY attribute indicates the priority that is to be\n * associated with a peer reflexive candidate, should one be discovered\n * by this check.  It is a 32 bit unsigned integer, and has an attribute\n * type of 0x0024.\n */\ntypedef struct pj_stun_uint_attr pj_stun_priority_attr;\n\n/**\n * This describes the USE-CANDIDATE attribute from draft-ietf-mmusic-ice-13.\n * The USE-CANDIDATE attribute indicates that the candidate pair\n * resulting from this check should be used for transmission of media.\n * The attribute has no content (the Length field of the attribute is\n * zero); it serves as a flag.\n */\ntypedef struct pj_stun_empty_attr pj_stun_use_candidate_attr;\n\n/**\n * This describes the STUN TIMER-VAL attribute.\n * The TIMER-VAL attribute is used only in conjunction with the Set\n * Active Destination response.  It conveys from the server, to the\n * client, the value of the timer used in the server state machine.\n */\ntypedef struct pj_stun_uint_attr pj_stun_timer_val_attr;\n\n/**\n * This describes ICE-CONTROLLING attribute.\n */\ntypedef struct pj_stun_uint64_attr pj_stun_ice_controlling_attr;\n\n/**\n * This describes ICE-CONTROLLED attribute.\n */\ntypedef struct pj_stun_uint64_attr pj_stun_ice_controlled_attr;\n\n/**\n * This describes TURN ICMP attribute\n */\ntypedef struct pj_stun_uint_attr pj_stun_icmp_attr;\n\n/**\n * This structure describes a parsed STUN message. All integral fields\n * in this structure (including IP addresses) will be in the host\n * byte order.\n */\ntypedef struct pj_stun_msg\n{\n    /**\n     * STUN message header.\n     */\n    pj_stun_msg_hdr     hdr;\n\n    /**\n     * Number of attributes in the STUN message.\n     */\n    unsigned            attr_count;\n\n    /**\n     * Array of STUN attributes.\n     */\n    pj_stun_attr_hdr   *attr[PJ_STUN_MAX_ATTR];\n\n} pj_stun_msg;\n\n\n/** STUN decoding options */\nenum pj_stun_decode_options\n{\n    /** \n     * Tell the decoder that the message was received from datagram\n     * oriented transport (such as UDP).\n     */\n    PJ_STUN_IS_DATAGRAM     = 1,\n\n    /**\n     * Tell pj_stun_msg_decode() to check the validity of the STUN\n     * message by calling pj_stun_msg_check() before starting to\n     * decode the packet.\n     */\n    PJ_STUN_CHECK_PACKET    = 2,\n\n    /**\n     * This option current is only valid for #pj_stun_session_on_rx_pkt().\n     * When specified, it tells the session NOT to authenticate the\n     * message.\n     */\n    PJ_STUN_NO_AUTHENTICATE = 4,\n\n    /**\n     * Disable FINGERPRINT verification. This option can be used when calling\n     * #pj_stun_msg_check() and #pj_stun_msg_decode() to disable the \n     * verification of FINGERPRINT, for example when the STUN usage says when\n     * FINGERPRINT mechanism shall not be used.\n     */\n    PJ_STUN_NO_FINGERPRINT_CHECK = 8\n};\n\n\n/**\n * Get STUN message method name.\n *\n * @param msg_type      The STUN message type (in host byte order)\n *\n * @return              The STUN message method name string.\n */\nPJ_DECL(const char*) pj_stun_get_method_name(unsigned msg_type);\n\n\n/**\n * Get STUN message class name.\n *\n * @param msg_type      The STUN message type (in host byte order)\n *\n * @return              The STUN message class name string.\n */\nPJ_DECL(const char*) pj_stun_get_class_name(unsigned msg_type);\n\n\n/**\n * Get STUN attribute name.\n *\n * @return attr_type    The STUN attribute type (in host byte order).\n *\n * @return              The STUN attribute type name string.\n */\nPJ_DECL(const char*) pj_stun_get_attr_name(unsigned attr_type);\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n *\n * @param err_code      The STUN error code.\n *\n * @return              The STUN error reason phrase.\n */\nPJ_DECL(pj_str_t) pj_stun_get_err_reason(int err_code);\n\n\n/**\n * Internal: set the padding character for string attribute.\n * The default padding character is PJ_STUN_STRING_ATTR_PAD_CHR.\n *\n * @return              The previous padding character.\n */\nPJ_DECL(int) pj_stun_set_padding_char(int chr);\n\n\n/**\n * Initialize a generic STUN message.\n *\n * @param msg           The message structure to be initialized.\n * @param msg_type      The 14bit message type (see pj_stun_msg_type \n *                      constants).\n * @param magic         Magic value to be put to the mesage; for requests,\n *                      the value normally should be PJ_STUN_MAGIC.\n * @param tsx_id        Optional transaction ID, or NULL to let the\n *                      function generates a random transaction ID.\n *\n * @return              PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_init(pj_stun_msg *msg,\n                                      unsigned msg_type,\n                                      pj_uint32_t magic,\n                                      const pj_uint8_t tsx_id[12]);\n\n/**\n * Create a generic STUN message.\n *\n * @param pool          Pool to create the STUN message.\n * @param msg_type      The 14bit message type.\n * @param magic         Magic value to be put to the mesage; for requests,\n *                      the value should be PJ_STUN_MAGIC.\n * @param tsx_id        Optional transaction ID, or NULL to let the\n *                      function generates a random transaction ID.\n * @param p_msg         Pointer to receive the message.\n *\n * @return              PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_create(pj_pool_t *pool,\n                                        unsigned msg_type,\n                                        pj_uint32_t magic,\n                                        const pj_uint8_t tsx_id[12],\n                                        pj_stun_msg **p_msg);\n\n/**\n * Clone a STUN message with all of its attributes.\n *\n * @param pool          Pool to allocate memory for the new message.\n * @param msg           The message to be cloned.\n *\n * @return              The duplicate message.\n */\nPJ_DECL(pj_stun_msg*) pj_stun_msg_clone(pj_pool_t *pool,\n                                        const pj_stun_msg *msg);\n\n/**\n * Create STUN response message. \n *\n * @param pool          Pool to create the mesage.\n * @param req_msg       The request message.\n * @param err_code      STUN error code. If this value is not zero,\n *                      then error response will be created, otherwise\n *                      successful response will be created.\n * @param err_msg       Optional error message to explain err_code.\n *                      If this value is NULL and err_code is not zero,\n *                      the error string will be taken from the default\n *                      STUN error message.\n * @param p_response    Pointer to receive the response.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n                                                 const pj_stun_msg *req_msg,\n                                                 unsigned err_code,\n                                                 const pj_str_t *err_msg,\n                                                 pj_stun_msg **p_response);\n\n\n/**\n * Add STUN attribute to STUN message.\n *\n * @param msg           The STUN message.\n * @param attr          The STUN attribute to be added to the message.\n *\n * @return              PJ_SUCCESS on success, or PJ_ETOOMANY if there are\n *                      already too many attributes in the message.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n                                          pj_stun_attr_hdr *attr);\n\n\n/**\n * Print the STUN message structure to a packet buffer, ready to be \n * sent to remote destination. This function will take care about \n * calculating the MESSAGE-INTEGRITY digest as well as FINGERPRINT\n * value, if these attributes are present in the message.\n *\n * If application wants to apply credential to the message, it MUST\n * include a blank MESSAGE-INTEGRITY attribute in the message as the\n * last attribute or the attribute before FINGERPRINT. This function will\n * calculate the HMAC digest from the message using  the supplied key in\n * the parameter. The key should be set to the password if short term \n * credential is used, or calculated from the MD5 hash of the realm, \n * username, and password using #pj_stun_create_key() if long term \n * credential is used.\n *\n * If FINGERPRINT attribute is present, this function will calculate\n * the FINGERPRINT CRC attribute for the message. The FINGERPRINT MUST\n * be added as the last attribute of the message.\n *\n * @param msg           The STUN message to be printed. Upon return,\n *                      some fields in the header (such as message\n *                      length) will be updated.\n * @param pkt_buf       The buffer to be filled with the packet.\n * @param buf_size      Size of the buffer.\n * @param options       Options, which currently must be zero.\n * @param key           Authentication key to calculate MESSAGE-INTEGRITY\n *                      value. Application can create this key by using\n *                      #pj_stun_create_key() function.\n * @param p_msg_len     Upon return, it will be filed with the size of \n *                      the packet in bytes, or negative value on error.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n                                        pj_uint8_t *pkt_buf,\n                                        pj_size_t buf_size,\n                                        unsigned options,\n                                        const pj_str_t *key,\n                                        pj_size_t *p_msg_len);\n\n/**\n * Check that the PDU is potentially a valid STUN message. This function\n * is useful when application needs to multiplex STUN packets with other\n * application traffic. When this function returns PJ_SUCCESS, there is a\n * big chance that the packet is a STUN packet.\n *\n * Note that we cannot be sure that the PDU is a really valid STUN message \n * until we actually parse the PDU.\n *\n * @param pdu           The packet buffer.\n * @param pdu_len       The length of the packet buffer.\n * @param options       Additional options to be applied in the checking,\n *                      which can be taken from pj_stun_decode_options. One \n *                      of the useful option is PJ_STUN_IS_DATAGRAM which \n *                      means that the pdu represents a whole STUN packet.\n *\n * @return              PJ_SUCCESS if the PDU is a potentially valid STUN\n *                      message.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, \n                                       pj_size_t pdu_len, unsigned options);\n\n\n/**\n * Decode incoming packet into STUN message.\n *\n * @param pool          Pool to allocate the message.\n * @param pdu           The incoming packet to be parsed.\n * @param pdu_len       The length of the incoming packet.\n * @param options       Parsing flags, according to pj_stun_decode_options.\n * @param p_msg         Pointer to receive the parsed message.\n * @param p_parsed_len  Optional pointer to receive how many bytes have\n *                      been parsed for the STUN message. This is useful\n *                      when the packet is received over stream oriented\n *                      transport.\n * @param p_response    Optional pointer to receive an instance of response\n *                      message, if one can be created. If the packet being\n *                      decoded is a request message, and it contains error,\n *                      and a response can be created, then the STUN \n *                      response message will be returned on this argument.\n *\n * @return              PJ_SUCCESS if a STUN message has been successfully\n *                      decoded.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                        const pj_uint8_t *pdu,\n                                        pj_size_t pdu_len,\n                                        unsigned options,\n                                        pj_stun_msg **p_msg,\n                                        pj_size_t *p_parsed_len,\n                                        pj_stun_msg **p_response);\n\n/**\n * Dump STUN message to a printable string output.\n *\n * @param msg           The STUN message\n * @param buffer        Buffer where the printable string output will\n *                      be printed on.\n * @param length        Specify the maximum length of the buffer.\n * @param printed_len   Optional pointer, which on output will be filled\n *                      up with the actual length of the output string.\n *\n * @return              The message string output.\n */\n#if PJ_LOG_MAX_LEVEL > 0\nPJ_DECL(char*) pj_stun_msg_dump(const pj_stun_msg *msg,\n                                char *buffer,\n                                unsigned length,\n                                unsigned *printed_len);\n#else\n#   define pj_stun_msg_dump(msg, buf, length, printed_len)  \"\"\n#endif\n\n\n/**\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n *\n * @param msg           The STUN message.\n * @param attr_type     The attribute type to be found, from pj_stun_attr_type.\n * @param start_index   The start index of the attribute in the message.\n *                      Specify zero to start searching from the first\n *                      attribute.\n *\n * @return              The attribute instance, or NULL if it cannot be\n *                      found.\n */\nPJ_DECL(pj_stun_attr_hdr*) pj_stun_msg_find_attr(const pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 unsigned start_index);\n\n\n/**\n * Clone a STUN attribute.\n *\n * @param pool          Pool to allocate memory.\n * @param attr          Attribute to clone.\n *\n * @return              Duplicate attribute.\n */\nPJ_DECL(pj_stun_attr_hdr*) pj_stun_attr_clone(pj_pool_t *pool,\n                                              const pj_stun_attr_hdr *attr);\n\n\n/**\n * Initialize generic STUN IP address attribute. The \\a addr_len and\n * \\a addr parameters specify whether the address is IPv4 or IPv4\n * address.\n *\n * @param attr          The socket address attribute to initialize.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param xor_ed        If non-zero, the port and address will be XOR-ed\n *                      with magic, to make the XOR-MAPPED-ADDRESS attribute.\n * @param addr          A pj_sockaddr_in or pj_sockaddr_in6 structure.\n * @param addr_len      Length of \\a addr parameter.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_sockaddr_attr_init(pj_stun_sockaddr_attr *attr,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len);\n\n/**\n * Create a generic STUN IP address attribute. The \\a addr_len and\n * \\a addr parameters specify whether the address is IPv4 or IPv4\n * address.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param xor_ed        If non-zero, the port and address will be XOR-ed\n *                      with magic, to make the XOR-MAPPED-ADDRESS attribute.\n * @param addr          A pj_sockaddr_in or pj_sockaddr_in6 structure.\n * @param addr_len      Length of \\a addr parameter.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len,\n                                                pj_stun_sockaddr_attr **p_attr);\n\n\n/**\n * Create and add generic STUN IP address attribute to a STUN message.\n * The \\a addr_len and \\a addr parameters specify whether the address is \n * IPv4 or IPv4 address.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param xor_ed        If non-zero, the port and address will be XOR-ed\n *                      with magic, to make the XOR-MAPPED-ADDRESS attribute.\n * @param addr          A pj_sockaddr_in or pj_sockaddr_in6 structure.\n * @param addr_len      Length of \\a addr parameter.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type, \n                                                  pj_bool_t xor_ed,\n                                                  const pj_sockaddr_t *addr,\n                                                  unsigned addr_len);\n\n/**\n * Initialize a STUN generic string attribute.\n *\n * @param attr          The string attribute to be initialized.\n * @param pool          Pool to duplicate the value into the attribute,\n *                      if value is not NULL or empty.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The string value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_string_attr_init(pj_stun_string_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_str_t *value);\n\n/**\n * Create a STUN generic string attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The string value to be assigned to the attribute.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n                                                int attr_type,\n                                                const pj_str_t *value,\n                                                pj_stun_string_attr **p_attr);\n\n/**\n * Create and add STUN generic string attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The string value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_str_t *value);\n\n/**\n * Create a STUN generic 32bit value attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The 32bit value to be assigned to the attribute.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n                                              int attr_type,\n                                              pj_uint32_t value,\n                                              pj_stun_uint_attr **p_attr);\n\n/**\n * Create and add STUN generic 32bit value attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The 32bit value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n                                               pj_stun_msg *msg,\n                                               int attr_type,\n                                               pj_uint32_t value);\n\n\n/**\n * Create a STUN generic 64bit value attribute.\n *\n * @param pool          Pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         Optional value to be assigned.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t)  pj_stun_uint64_attr_create(pj_pool_t *pool,\n                                                int attr_type,\n                                                const pj_timestamp *value,\n                                                pj_stun_uint64_attr **p_attr);\n\n\n/**\n *  Create and add STUN generic 64bit value attribute to the message. \n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The 64bit value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type,\n                                                  const pj_timestamp *value);\n\n/**\n * Create a STUN MESSAGE-INTEGRITY attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n                                                pj_stun_msgint_attr **p_attr);\n\n/** \n * Create and add STUN MESSAGE-INTEGRITY attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg);\n\n/**\n * Create a STUN ERROR-CODE attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param err_code      STUN error code.\n * @param err_reason    Optional STUN error reason. If NULL is given, the\n *                      standard error reason will be given.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n                                                int err_code,\n                                                const pj_str_t *err_reason,\n                                                pj_stun_errcode_attr **p_attr);\n\n\n/**\n * Create and add STUN ERROR-CODE attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN mesage.\n * @param err_code      STUN error code.\n * @param err_reason    Optional STUN error reason. If NULL is given, the\n *                      standard error reason will be given.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int err_code,\n                                                  const pj_str_t *err_reason);\n\n/**\n * Create instance of STUN UNKNOWN-ATTRIBUTES attribute and copy the\n * unknown attribute array to the attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_cnt      Number of attributes in the array (can be zero).\n * @param attr          Optional array of attributes.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n                                                unsigned attr_cnt,\n                                                const pj_uint16_t attr[],\n                                                pj_stun_unknown_attr **p_attr);\n\n/**\n * Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_cnt      Number of attributes in the array (can be zero).\n * @param attr          Optional array of attribute types.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  unsigned attr_cnt,\n                                                  const pj_uint16_t attr[]);\n\n/**\n * Initialize STUN binary attribute.\n *\n * @param attr          The attribute to be initialized.\n * @param pool          Pool to copy data, if the data and length are set.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param data          Data to be coped to the attribute, or NULL\n *                      if no data to be copied now.\n * @param length        Length of data, or zero if no data is to be\n *                      copied now.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_binary_attr_init(pj_stun_binary_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_uint8_t *data,\n                                              unsigned length);\n\n/**\n * Create STUN binary attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param data          Data to be coped to the attribute, or NULL\n *                      if no data to be copied now.\n * @param length        Length of data, or zero if no data is to be\n *                      copied now.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n                                                int attr_type,\n                                                const pj_uint8_t *data,\n                                                unsigned length,\n                                                pj_stun_binary_attr **p_attr);\n\n/**\n * Create STUN binary attribute and add the attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param data          Data to be coped to the attribute, or NULL\n *                      if no data to be copied now.\n * @param length        Length of data, or zero if no data is to be\n *                      copied now.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_uint8_t *data,\n                                                 unsigned length);\n\n/**\n * Create STUN empty attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               pj_stun_empty_attr **p_attr);\n\n/**\n * Create STUN empty attribute and add the attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_empty_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type);\n\n/**\n * @}\n */\n\n\nPJ_END_DECL\n\n\n#endif  /* __PJNATH_STUN_MSG_H__ */\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjnath/stun_msg.h>\n#include <pjnath/errno.h>\n#include <pjlib-util/crc32.h>\n#include <pjlib-util/hmac_sha1.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n#define THIS_FILE               \"stun_msg.c\"\n#define STUN_XOR_FINGERPRINT    0x5354554eL\n\nstatic int padding_char;\n\nstatic const char *stun_method_names[PJ_STUN_METHOD_MAX] = \n{\n    \"Unknown\",                  /* 0 */\n    \"Binding\",                  /* 1 */\n    \"SharedSecret\",             /* 2 */\n    \"Allocate\",                 /* 3 */\n    \"Refresh\",                  /* 4 */\n    \"???\",                      /* 5 */\n    \"Send\",                     /* 6 */\n    \"Data\",                     /* 7 */\n    \"CreatePermission\",         /* 8 */\n    \"ChannelBind\",              /* 9 */\n    \"Connect\",                  /* 10 */\n    \"ConnectionBind\",           /* 11 */\n    \"ConnectionAttempt\",        /* 12 */\n};\n\nstatic struct\n{\n    int err_code;\n    const char *err_msg;\n} stun_err_msg_map[] = \n{\n    { PJ_STUN_SC_TRY_ALTERNATE,             \"Try Alternate\"}, \n    { PJ_STUN_SC_BAD_REQUEST,               \"Bad Request\"},\n    { PJ_STUN_SC_UNAUTHORIZED,              \"Unauthorized\"},\n    { PJ_STUN_SC_FORBIDDEN,                 \"Forbidden\"},\n    { PJ_STUN_SC_UNKNOWN_ATTRIBUTE,         \"Unknown Attribute\"},\n    //{ PJ_STUN_SC_STALE_CREDENTIALS,       \"Stale Credentials\"},\n    //{ PJ_STUN_SC_INTEGRITY_CHECK_FAILURE, \"Integrity Check Failure\"},\n    //{ PJ_STUN_SC_MISSING_USERNAME,        \"Missing Username\"},\n    //{ PJ_STUN_SC_USE_TLS,                 \"Use TLS\"},\n    //{ PJ_STUN_SC_MISSING_REALM,           \"Missing Realm\"},\n    //{ PJ_STUN_SC_MISSING_NONCE,           \"Missing Nonce\"},\n    //{ PJ_STUN_SC_UNKNOWN_USERNAME,        \"Unknown Username\"},\n    { PJ_STUN_SC_ALLOCATION_MISMATCH,       \"Allocation Mismatch\"},\n    { PJ_STUN_SC_STALE_NONCE,               \"Stale Nonce\"},\n    { PJ_STUN_SC_TRANSITIONING,             \"Active Destination Already Set\"},\n    { PJ_STUN_SC_WRONG_CREDENTIALS,         \"Wrong Credentials\"},\n    { PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO,    \"Unsupported Transport Protocol\"},\n    { PJ_STUN_SC_OPER_TCP_ONLY,             \"Operation for TCP Only\"},\n    { PJ_STUN_SC_CONNECTION_FAILURE,        \"Connection Failure\"},\n    { PJ_STUN_SC_CONNECTION_TIMEOUT,        \"Connection Timeout\"},\n    { PJ_STUN_SC_ALLOCATION_QUOTA_REACHED,  \"Allocation Quota Reached\"},\n    { PJ_STUN_SC_ROLE_CONFLICT,             \"Role Conflict\"},\n    { PJ_STUN_SC_SERVER_ERROR,              \"Server Error\"},\n    { PJ_STUN_SC_INSUFFICIENT_CAPACITY,     \"Insufficient Capacity\"},\n    { PJ_STUN_SC_GLOBAL_FAILURE,            \"Global Failure\"}\n};\n\n\n\nstruct attr_desc\n{\n    const char   *name;\n    pj_status_t (*decode_attr)(pj_pool_t *pool, const pj_uint8_t *buf, \n                               const pj_stun_msg_hdr *msghdr, void **p_attr);\n    pj_status_t (*encode_attr)(const void *a, pj_uint8_t *buf, \n                               unsigned len, const pj_stun_msg_hdr *msghdr,\n                               unsigned *printed);\n    void*       (*clone_attr)(pj_pool_t *pool, const void *src);\n};\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        void **p_attr);\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr);\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed);\nstatic void*       clone_sockaddr_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_string_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_msgint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_errcode_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_unknown_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr);\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed);\nstatic void*       clone_uint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_uint64_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_binary_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr, \n                                     void **p_attr);\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed);\nstatic void*       clone_empty_attr(pj_pool_t *pool, const void *src);\n\nstatic struct attr_desc mandatory_attr_desc[] = \n{\n    {\n        /* type zero */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAPPED_ADDR, */\n        \"MAPPED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESPONSE_ADDR, */\n        \"RESPONSE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGE_REQUEST, */\n        \"CHANGE-REQUEST\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_SOURCE_ADDR, */\n        \"SOURCE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGED_ADDR, */\n        \"CHANGED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USERNAME, */\n        \"USERNAME\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PASSWORD, */\n        \"PASSWORD\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_MESSAGE_INTEGRITY, */\n        \"MESSAGE-INTEGRITY\",\n        &decode_msgint_attr,\n        &encode_msgint_attr,\n        &clone_msgint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ERROR_CODE, */\n        \"ERROR-CODE\",\n        &decode_errcode_attr,\n        &encode_errcode_attr,\n        &clone_errcode_attr\n    },\n    {\n        /* PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, */\n        \"UNKNOWN-ATTRIBUTES\",\n        &decode_unknown_attr,\n        &encode_unknown_attr,\n        &clone_unknown_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFLECTED_FROM, */\n        \"REFLECTED-FROM\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANNEL_NUMBER (0x000C) */\n        \"CHANNEL-NUMBER\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_LIFETIME, */\n        \"LIFETIME\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x000E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAGIC_COOKIE */\n        \"MAGIC-COOKIE\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_BANDWIDTH, */\n        \"BANDWIDTH\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x0011 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_PEER_ADDRESS, */\n        \"XOR-PEER-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DATA, */\n        \"DATA\",\n        &decode_binary_attr,\n        &encode_binary_attr,\n        &clone_binary_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REALM, */\n        \"REALM\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_NONCE, */\n        \"NONCE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_RELAYED_ADDR, */\n        \"XOR-RELAYED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_ADDR_FAMILY, */\n        \"REQUESTED-ADDRESS-FAMILY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_EVEN_PORT, */\n        \"EVEN-PORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_TRANSPORT, */\n        \"REQUESTED-TRANSPORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DONT_FRAGMENT */\n        \"DONT-FRAGMENT\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x001B is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001C is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001D is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001F is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_MAPPED_ADDRESS, */\n        \"XOR-MAPPED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_TIMER_VAL, */\n        \"TIMER-VAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESERVATION_TOKEN, */\n        \"RESERVATION-TOKEN\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_REFLECTED_FROM, */\n        \"XOR-REFLECTED-FROM\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PRIORITY, */\n        \"PRIORITY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USE_CANDIDATE, */\n        \"USE-CANDIDATE\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x0026 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0027 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0028 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0029 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_CONNECTION_ID, */\n        \"CONNECTION-ID\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x002b is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002c is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002d is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002e is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002f is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_ICMP, */\n        \"ICMP\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n\n    /* Sentinel */\n    {\n        /* PJ_STUN_ATTR_END_MANDATORY_ATTR */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    }\n};\n\nstatic struct attr_desc extended_attr_desc[] =\n{\n    {\n        /* ID 0x8021 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_SOFTWARE, */\n        \"SOFTWARE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ALTERNATE_SERVER, */\n        \"ALTERNATE-SERVER\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFRESH_INTERVAL, */\n        \"REFRESH-INTERVAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x8025 is not assigned*/\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PADDING, 0x8026 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* CACHE-TIMEOUT, 0x8027 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_FINGERPRINT, */\n        \"FINGERPRINT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLED, */\n        \"ICE-CONTROLLED\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLING, */\n        \"ICE-CONTROLLING\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    }\n};\n\n\n\n/*\n * Get STUN message type name.\n */\nPJ_DEF(const char*) pj_stun_get_method_name(unsigned msg_type)\n{\n    unsigned method = PJ_STUN_GET_METHOD(msg_type);\n\n    if (method >= PJ_ARRAY_SIZE(stun_method_names))\n        return \"???\";\n\n    return stun_method_names[method];\n}\n\n\n/*\n * Get STUN message class name.\n */\nPJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type)\n{\n    if (PJ_STUN_IS_REQUEST(msg_type))\n        return \"request\";\n    else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type))\n        return \"success response\";\n    else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type))\n        return \"error response\";\n    else if (PJ_STUN_IS_INDICATION(msg_type))\n        return \"indication\";\n    else\n        return \"???\";\n}\n\n\nstatic const struct attr_desc *find_attr_desc(unsigned attr_type)\n{\n    struct attr_desc *desc;\n\n    /* Check that attr_desc array is valid */\n    pj_assert(PJ_ARRAY_SIZE(mandatory_attr_desc)==\n              PJ_STUN_ATTR_END_MANDATORY_ATTR+1);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_END_MANDATORY_ATTR].decode_attr\n              == NULL);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_USE_CANDIDATE].decode_attr \n              == &decode_empty_attr);\n    pj_assert(PJ_ARRAY_SIZE(extended_attr_desc) ==\n              PJ_STUN_ATTR_END_EXTENDED_ATTR-PJ_STUN_ATTR_START_EXTENDED_ATTR);\n\n    if (attr_type < PJ_STUN_ATTR_END_MANDATORY_ATTR)\n        desc = &mandatory_attr_desc[attr_type];\n    else if (attr_type >= PJ_STUN_ATTR_START_EXTENDED_ATTR &&\n             attr_type < PJ_STUN_ATTR_END_EXTENDED_ATTR)\n        desc = &extended_attr_desc[attr_type-PJ_STUN_ATTR_START_EXTENDED_ATTR];\n    else\n        return NULL;\n\n    return desc->decode_attr == NULL ? NULL : desc;\n}\n\n\n/*\n * Get STUN attribute name.\n */\nPJ_DEF(const char*) pj_stun_get_attr_name(unsigned attr_type)\n{\n    const struct attr_desc *attr_desc;\n\n    attr_desc = find_attr_desc(attr_type);\n    if (!attr_desc || attr_desc->name==NULL)\n        return \"???\";\n\n    return attr_desc->name;\n}\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n */\nPJ_DEF(pj_str_t) pj_stun_get_err_reason(int err_code)\n{\n#if 0\n    /* Find error using linear search */\n    unsigned i;\n\n    for (i=0; i<PJ_ARRAY_SIZE(stun_err_msg_map); ++i) {\n        if (stun_err_msg_map[i].err_code == err_code)\n            return pj_str((char*)stun_err_msg_map[i].err_msg);\n    }\n    return pj_str(NULL);\n#else\n    /* Find error message using binary search */\n    int first = 0;\n    int n = PJ_ARRAY_SIZE(stun_err_msg_map);\n\n    while (n > 0) {\n        int half = n/2;\n        int mid = first + half;\n\n        if (stun_err_msg_map[mid].err_code < err_code) {\n            first = mid+1;\n            n -= (half+1);\n        } else if (stun_err_msg_map[mid].err_code > err_code) {\n            n = half;\n        } else {\n            first = mid;\n            break;\n        }\n    }\n\n\n    if (stun_err_msg_map[first].err_code == err_code) {\n        return pj_str((char*)stun_err_msg_map[first].err_msg);\n    } else {\n        return pj_str(NULL);\n    }\n#endif\n}\n\n\n/*\n * Set padding character.\n */\nPJ_DEF(int) pj_stun_set_padding_char(int chr)\n{\n    int old_pad = padding_char;\n    padding_char = chr;\n    return old_pad;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n\n#define INIT_ATTR(a,t,l)    (a)->hdr.type=(pj_uint16_t)(t), \\\n                            (a)->hdr.length=(pj_uint16_t)(l)\n#define ATTR_HDR_LEN        4\n\nstatic pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint16_t) ((buf[pos + 0] << 8) | \\\n                          (buf[pos + 1] << 0));\n}\n\n/*unused PJ_INLINE(pj_uint16_t) GETVAL16N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htons(GETVAL16H(buf,pos));\n}*/\n\nstatic void PUTVAL16H(pj_uint8_t *buf, unsigned pos, pj_uint16_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF00) >> 8);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF) >> 0);\n}\n\nPJ_INLINE(pj_uint32_t) GETVAL32H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint32_t) ((buf[pos + 0] << 24UL) | \\\n                          (buf[pos + 1] << 16UL) | \\\n                          (buf[pos + 2] <<  8UL) | \\\n                          (buf[pos + 3] <<  0UL));\n}\n\n/*unused PJ_INLINE(pj_uint32_t) GETVAL32N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htonl(GETVAL32H(buf,pos));\n}*/\n\nstatic void PUTVAL32H(pj_uint8_t *buf, unsigned pos, pj_uint32_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF000000UL) >> 24);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF0000UL) >> 16);\n    buf[pos+2] = (pj_uint8_t) ((hval & 0x0000FF00UL) >>  8);\n    buf[pos+3] = (pj_uint8_t) ((hval & 0x000000FFUL) >>  0);\n}\n\nstatic void GETVAL64H(const pj_uint8_t *buf, unsigned pos, pj_timestamp *ts)\n{\n    ts->u32.hi = GETVAL32H(buf, pos);\n    ts->u32.lo = GETVAL32H(buf, pos+4);\n}\n\nstatic void PUTVAL64H(pj_uint8_t *buf, unsigned pos, const pj_timestamp *ts)\n{\n    PUTVAL32H(buf, pos, ts->u32.hi);\n    PUTVAL32H(buf, pos+4, ts->u32.lo);\n}\n\n\nstatic void GETATTRHDR(const pj_uint8_t *buf, pj_stun_attr_hdr *hdr)\n{\n    hdr->type = GETVAL16H(buf, 0);\n    hdr->length = GETVAL16H(buf, 2);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic IP address container\n */\n#define STUN_GENERIC_IPV4_ADDR_LEN      8\n#define STUN_GENERIC_IPV6_ADDR_LEN      20\n\n/*\n * Init sockaddr attr\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_init( pj_stun_sockaddr_attr *attr,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len)\n{\n    unsigned attr_len;\n\n    PJ_ASSERT_RETURN(attr && addr_len && addr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(addr_len == sizeof(pj_sockaddr_in) ||\n                     addr_len == sizeof(pj_sockaddr_in6), PJ_EINVAL);\n\n    attr_len = pj_sockaddr_get_addr_len(addr) + 4;\n    INIT_ATTR(attr, attr_type, attr_len);\n\n    pj_memcpy(&attr->sockaddr, addr, addr_len);\n    attr->xor_ed = xor_ed;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a generic STUN IP address attribute for IPv4 address.\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n                                                 int attr_type,\n                                                 pj_bool_t xor_ed,\n                                                 const pj_sockaddr_t *addr,\n                                                 unsigned addr_len,\n                                                 pj_stun_sockaddr_attr **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    *p_attr = attr;\n    return pj_stun_sockaddr_attr_init(attr, attr_type, xor_ed, \n                                      addr, addr_len);\n}\n\n\n/*\n * Create and add generic STUN IP address attribute to a STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type, \n                                                  pj_bool_t xor_ed,\n                                                  const pj_sockaddr_t *addr,\n                                                  unsigned addr_len)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = pj_stun_sockaddr_attr_create(pool, attr_type, xor_ed,\n                                                 addr, addr_len, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr, \n                                        void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    int af;\n    unsigned addr_len;\n    pj_uint32_t val;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN &&\n        attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n    {\n        return PJNATH_ESTUNINATTRLEN;\n    }\n\n    /* Check address family */\n    val = *(pj_uint8_t*)(buf + ATTR_HDR_LEN + 1);\n\n    /* Check address family is valid */\n    if (val == 1) {\n        if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET();\n        addr_len = 4;\n    } else if (val == 2) {\n        if (attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET6();\n        addr_len = 16;\n    } else {\n        /* Invalid address family */\n        return PJNATH_EINVAF;\n    }\n\n    /* Get port and address */\n    pj_sockaddr_init(af, &attr->sockaddr, NULL, 0);\n    pj_sockaddr_set_port(&attr->sockaddr, \n                         GETVAL16H(buf, ATTR_HDR_LEN+2));\n    pj_memcpy(pj_sockaddr_get_addr(&attr->sockaddr),\n              buf+ATTR_HDR_LEN+4,\n              addr_len);\n\n    /* Done */\n    *p_attr = (void*)attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = decode_sockaddr_attr(pool, buf, msghdr, p_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    attr = *(pj_stun_sockaddr_attr**)p_attr;\n\n    attr->xor_ed = PJ_TRUE;\n\n    if (attr->sockaddr.addr.sa_family == pj_AF_INET()) {\n        attr->sockaddr.ipv4.sin_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n        attr->sockaddr.ipv4.sin_addr.s_addr ^= pj_htonl(PJ_STUN_MAGIC);\n    } else if (attr->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        unsigned i;\n        pj_uint8_t *dst = (pj_uint8_t*) &attr->sockaddr.ipv6.sin6_addr;\n        pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\n        attr->sockaddr.ipv6.sin6_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\n        /* If the IP address family is IPv6, X-Address is computed by\n         * taking the mapped IP address in host byte order, XOR'ing it\n         * with the concatenation of the magic cookie and the 96-bit \n         * transaction ID, and converting the result to network byte \n         * order.\n         */\n        for (i=0; i<4; ++i) {\n            dst[i] ^= ((const pj_uint8_t*)&magic)[i];\n        }\n        pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n        for (i=0; i<12; ++i) {\n            dst[i+4] ^= msghdr->tsx_id[i];\n        }\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed)\n{\n    pj_uint8_t *start_buf = buf;\n    const pj_stun_sockaddr_attr *ca = \n        (const pj_stun_sockaddr_attr *)a;\n\n    PJ_CHECK_STACK();\n    \n    /* Common: attribute type */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    if (ca->sockaddr.addr.sa_family == pj_AF_INET()) {\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV4_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV4_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 1 for IPv4 */\n        *buf++ = 1;\n\n        /* IPv4 address */\n        if (ca->xor_ed) {\n            pj_uint32_t addr;\n            pj_uint16_t port;\n\n            addr = ca->sockaddr.ipv4.sin_addr.s_addr;\n            port = ca->sockaddr.ipv4.sin_port;\n\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            addr ^= pj_htonl(PJ_STUN_MAGIC);\n\n            /* Port */\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &addr, 4);\n            buf += 4;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_addr, 4);\n            buf += 4;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else if (ca->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        /* IPv6 address */\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV6_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV6_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 2 for IPv6 */\n        *buf++ = 2;\n\n        /* IPv6 address */\n        if (ca->xor_ed) {\n            unsigned i;\n            pj_uint8_t *dst;\n            const pj_uint8_t *src;\n            pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n            pj_uint16_t port = ca->sockaddr.ipv6.sin6_port;\n\n            /* Port */\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            dst = buf;\n            src = (const pj_uint8_t*) &ca->sockaddr.ipv6.sin6_addr;\n            for (i=0; i<4; ++i) {\n                dst[i] = (pj_uint8_t)(src[i] ^ ((const pj_uint8_t*)&magic)[i]);\n            }\n            pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n            for (i=0; i<12; ++i) {\n                dst[i+4] = (pj_uint8_t)(src[i+4] ^ msghdr->tsx_id[i]);\n            }\n\n            buf += 16;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_addr, 16);\n            buf += 16;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *printed = (unsigned)(buf - start_buf);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_sockaddr_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_sockaddr_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_sockaddr_attr);\n    pj_memcpy(dst, src, sizeof(pj_stun_sockaddr_attr));\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic string attribute\n */\n\n/*\n * Initialize a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_init( pj_stun_string_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_str_t *value)\n{\n    if (value && value->slen) {\n        INIT_ATTR(attr, attr_type, value->slen);\n        attr->value.slen = value->slen;\n        pj_strdup(pool, &attr->value, value);\n    } else {\n        INIT_ATTR(attr, attr_type, 0);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_str_t *value,\n                                               pj_stun_string_attr **p_attr)\n{\n    pj_stun_string_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && value && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    *p_attr = attr;\n\n    return pj_stun_string_attr_init(attr, pool, attr_type, value);\n}\n\n\n/*\n * Create and add STUN generic string attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_str_t *value)\n{\n    pj_stun_string_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_string_attr_create(pool, attr_type, value, \n                                                &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_string_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN);\n    value.slen = attr->hdr.length;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->value, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_string_attr *ca = \n        (const pj_stun_string_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = ((unsigned)ca->value.slen + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed) {\n        *printed = 0;\n        return PJ_ETOOSMALL;\n    }\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    /* Special treatment for SOFTWARE attribute:\n     * This attribute had caused interop problem when talking to \n     * legacy RFC 3489 STUN servers, due to different \"length\"\n     * rules with RFC 5389.\n     */\n    if (msghdr->magic != PJ_STUN_MAGIC ||\n        ca->hdr.type == PJ_STUN_ATTR_SOFTWARE)\n    {\n        /* Set the length to be 4-bytes aligned so that we can\n         * communicate with RFC 3489 endpoints\n         */\n        PUTVAL16H(buf, 2, (pj_uint16_t)((ca->value.slen + 3) & (~3)));\n    } else {\n        /* Use RFC 5389 rule */\n        PUTVAL16H(buf, 2, (pj_uint16_t)ca->value.slen);\n    }\n\n    /* Copy the string */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->value.ptr, ca->value.slen);\n\n    /* Add padding character, if string is not 4-bytes aligned. */\n    if (ca->value.slen & 0x03) {\n        pj_uint8_t pad[3];\n        pj_memset(pad, padding_char, sizeof(pad));\n        pj_memcpy(buf+ATTR_HDR_LEN+ca->value.slen, pad,\n                  4-(ca->value.slen & 0x03));\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_string_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_string_attr *asrc = (const pj_stun_string_attr*)src;\n    pj_stun_string_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_string_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_attr_hdr));\n    pj_strdup(pool, &dst->value, &asrc->value);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN empty attribute (used by USE-CANDIDATE).\n */\n\n/*\n * Create a STUN empty attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n                                              int attr_type,\n                                              pj_stun_empty_attr **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    INIT_ATTR(attr, attr_type, 0);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create STUN empty attribute and add the attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_empty_attr( pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type)\n{\n    pj_stun_empty_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_empty_attr_create(pool, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     void **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that the struct address is valid */\n    pj_assert(sizeof(pj_stun_empty_attr) == ATTR_HDR_LEN);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 0)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed)\n{\n    const pj_stun_empty_attr *ca = (pj_stun_empty_attr*)a;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, 0);\n\n    /* Done */\n    *printed = ATTR_HDR_LEN;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_empty_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_empty_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_empty_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_empty_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic 32bit integer attribute.\n */\n\n/*\n * Create a STUN generic 32bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n                                             int attr_type,\n                                             pj_uint32_t value,\n                                             pj_stun_uint_attr **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    INIT_ATTR(attr, attr_type, 4);\n    attr->value = value;\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 32bit value attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n                                              pj_stun_msg *msg,\n                                              int attr_type,\n                                              pj_uint32_t value)\n{\n    pj_stun_uint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed)\n{\n    const pj_stun_uint_attr *ca = (const pj_stun_uint_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 8) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)4);\n    PUTVAL32H(buf, 4, ca->value);\n    \n    /* Done */\n    *printed = 8;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint_attr));\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Create a STUN generic 64bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint64_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_timestamp *value,\n                                               pj_stun_uint64_attr **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    INIT_ATTR(attr, attr_type, 8);\n\n    if (value) {\n        attr->value.u32.hi = value->u32.hi;\n        attr->value.u32.lo = value->u32.lo;\n    }\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 64bit value attribute to the message. */\nPJ_DEF(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_timestamp *value)\n{\n    pj_stun_uint64_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint64_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    if (attr->hdr.length != 8)\n        return PJNATH_ESTUNINATTRLEN;\n\n    GETVAL64H(buf, 4, &attr->value);    \n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_uint64_attr *ca = (const pj_stun_uint64_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 12) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)8);\n    PUTVAL64H(buf, 4, &ca->value);\n\n    /* Done */\n    *printed = 12;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint64_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint64_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint64_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint64_attr));\n\n    return (void*)dst;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN MESSAGE-INTEGRITY attribute.\n */\n\n/*\n * Create a STUN MESSAGE-INTEGRITY attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n                                               pj_stun_msgint_attr **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_MESSAGE_INTEGRITY, 20);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg)\n{\n    pj_stun_msgint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_msgint_attr_create(pool, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 20)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Copy hmac */\n    pj_memcpy(attr->hmac, buf+4, 20);\n\n    /* Done */\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_msgint_attr *ca = (const pj_stun_msgint_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < 24) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, ca->hdr.length);\n\n    pj_memcpy(buf+4, ca->hmac, 20);\n\n    /* Done */\n    *printed = 24;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_msgint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_msgint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_msgint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_msgint_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN ERROR-CODE\n */\n\n/*\n * Create a STUN ERROR-CODE attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n                                                int err_code,\n                                                const pj_str_t *err_reason,\n                                                pj_stun_errcode_attr **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    char err_buf[80];\n    pj_str_t str;\n\n    PJ_ASSERT_RETURN(pool && err_code && p_attr, PJ_EINVAL);\n\n    if (err_reason == NULL) {\n        str = pj_stun_get_err_reason(err_code);\n        if (str.slen == 0) {\n            str.slen = pj_ansi_snprintf(err_buf, sizeof(err_buf),\n                                        \"Unknown error %d\", err_code);\n            str.ptr = err_buf;\n        }\n        err_reason = &str;\n    }\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_ERROR_CODE, 4+err_reason->slen);\n    attr->err_code = err_code;\n    pj_strdup(pool, &attr->reason, err_reason);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int err_code,\n                                                 const pj_str_t *err_reason)\n{\n    pj_stun_errcode_attr *err_attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_errcode_attr_create(pool, err_code, err_reason,\n                                         &err_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &err_attr->hdr);\n}\n\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    /* Make sure the length is never negative */\n    if (value.slen < 0)\n        value.slen = 0;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_errcode_attr *ca = \n        (const pj_stun_errcode_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(4 + ca->reason.slen));\n    PUTVAL16H(buf, 4, 0);\n    buf[6] = (pj_uint8_t)(ca->err_code / 100);\n    buf[7] = (pj_uint8_t)(ca->err_code % 100);\n\n    /* Copy error string */\n    pj_memcpy(buf + ATTR_HDR_LEN + 4, ca->reason.ptr, ca->reason.slen);\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_errcode_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_errcode_attr *asrc = (const pj_stun_errcode_attr*)src;\n    pj_stun_errcode_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_errcode_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_errcode_attr));\n    pj_strdup(pool, &dst->reason, &asrc->reason);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN UNKNOWN-ATTRIBUTES attribute\n */\n\n/*\n * Create an empty instance of STUN UNKNOWN-ATTRIBUTES attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n                                                unsigned attr_cnt,\n                                                const pj_uint16_t attr_array[],\n                                                pj_stun_unknown_attr **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && attr_cnt < PJ_STUN_MAX_ATTR && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, attr_cnt * 2);\n\n    attr->attr_count = attr_cnt;\n    for (i=0; i<attr_cnt; ++i) {\n        attr->attrs[i] = attr_array[i];\n    }\n\n    /* If the number of unknown attributes is an odd number, one of the\n     * attributes MUST be repeated in the list.\n     */\n    /* No longer necessary\n    if ((attr_cnt & 0x01)) {\n        attr->attrs[attr_cnt] = attr_array[attr_cnt-1];\n    }\n    */\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 unsigned attr_cnt,\n                                                 const pj_uint16_t attr_type[])\n{\n    pj_stun_unknown_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_unknown_attr_create(pool, attr_cnt, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    const pj_uint16_t *punk_attr;\n    unsigned i;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    GETATTRHDR(buf, &attr->hdr);\n \n    attr->attr_count = (attr->hdr.length >> 1);\n    if (attr->attr_count > PJ_STUN_MAX_ATTR)\n        return PJ_ETOOMANY;\n\n    punk_attr = (const pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i<attr->attr_count; ++i) {\n        attr->attrs[i] = pj_ntohs(punk_attr[i]);\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_unknown_attr *ca = (const pj_stun_unknown_attr*) a;\n    pj_uint16_t *dst_unk_attr;\n    unsigned i;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that buffer is enough */\n    if (len < ATTR_HDR_LEN + (ca->attr_count << 1))\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(ca->attr_count << 1));\n\n    /* Copy individual attribute */\n    dst_unk_attr = (pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i < ca->attr_count; ++i, ++dst_unk_attr) {\n        *dst_unk_attr = pj_htons(ca->attrs[i]);\n    }\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + (ca->attr_count << 1) + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_unknown_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_unknown_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_unknown_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_unknown_attr));\n    \n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic binary attribute\n */\n\n/*\n * Initialize STUN binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_init( pj_stun_binary_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_uint8_t *data,\n                                              unsigned length)\n{\n    PJ_ASSERT_RETURN(attr_type, PJ_EINVAL);\n\n    INIT_ATTR(attr, attr_type, length);\n\n    attr->magic = PJ_STUN_MAGIC;\n\n    if (data && length) {\n        attr->length = length;\n        attr->data = (pj_uint8_t*) pj_pool_alloc(pool, length);\n        pj_memcpy(attr->data, data, length);\n    } else {\n        attr->data = NULL;\n        attr->length = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_uint8_t *data,\n                                               unsigned length,\n                                               pj_stun_binary_attr **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && attr_type && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    *p_attr = attr;\n    return pj_stun_binary_attr_init(attr, pool, attr_type, data, length);\n}\n\n\n/* Create and add binary attr. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_uint8_t *data,\n                                                unsigned length)\n{\n    pj_stun_binary_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_binary_attr_create(pool, attr_type,\n                                        data, length, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr,\n                                      void **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Copy the data to the attribute */\n    attr->length = attr->hdr.length;\n    attr->data = (pj_uint8_t*) pj_pool_alloc(pool, attr->length);\n    pj_memcpy(attr->data, buf+ATTR_HDR_LEN, attr->length);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_binary_attr *ca = (const pj_stun_binary_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = (ca->length + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed)\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t) ca->length);\n\n    /* Copy the data */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->data, ca->length);\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_binary_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_binary_attr *asrc = (const pj_stun_binary_attr*)src;\n    pj_stun_binary_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_binary_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_binary_attr));\n\n    if (asrc->length) {\n        dst->data = (pj_uint8_t*) pj_pool_alloc(pool, asrc->length);\n        pj_memcpy(dst->data, asrc->data, asrc->length);\n    }\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Initialize a generic STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_init( pj_stun_msg *msg,\n                                      unsigned msg_type,\n                                      pj_uint32_t magic,\n                                      const pj_uint8_t tsx_id[12])\n{\n    PJ_ASSERT_RETURN(msg && msg_type, PJ_EINVAL);\n\n    msg->hdr.type = (pj_uint16_t) msg_type;\n    msg->hdr.length = 0;\n    msg->hdr.magic = magic;\n    msg->attr_count = 0;\n\n    if (tsx_id) {\n        pj_memcpy(&msg->hdr.tsx_id, tsx_id, sizeof(msg->hdr.tsx_id));\n    } else {\n        struct transaction_id\n        {\n            pj_uint32_t     proc_id;\n            pj_uint32_t     random;\n            pj_uint32_t     counter;\n        } id;\n        static pj_uint32_t pj_stun_tsx_id_counter;\n\n        if (!pj_stun_tsx_id_counter)\n            pj_stun_tsx_id_counter = pj_rand();\n\n        id.proc_id = pj_getpid();\n        id.random = pj_rand();\n        id.counter = pj_stun_tsx_id_counter++;\n\n        pj_memcpy(&msg->hdr.tsx_id, &id, sizeof(msg->hdr.tsx_id));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_create( pj_pool_t *pool,\n                                        unsigned msg_type,\n                                        pj_uint32_t magic,\n                                        const pj_uint8_t tsx_id[12],\n                                        pj_stun_msg **p_msg)\n{\n    pj_stun_msg *msg;\n\n    PJ_ASSERT_RETURN(pool && msg_type && p_msg, PJ_EINVAL);\n\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    *p_msg = msg;\n    return pj_stun_msg_init(msg, msg_type, magic, tsx_id);\n}\n\n\n/*\n * Clone a STUN message with all of its attributes.\n */\nPJ_DEF(pj_stun_msg*) pj_stun_msg_clone( pj_pool_t *pool,\n                                        const pj_stun_msg *src)\n{\n    pj_stun_msg *dst;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && src, NULL);\n\n    dst = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(dst, src, sizeof(pj_stun_msg));\n\n    /* Duplicate the attributes */\n    for (i=0, dst->attr_count=0; i<src->attr_count; ++i) {\n        dst->attr[dst->attr_count] = pj_stun_attr_clone(pool, src->attr[i]);\n        if (dst->attr[dst->attr_count])\n            ++dst->attr_count;\n    }\n\n    return dst;\n}\n\n\n/*\n * Add STUN attribute to STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n                                         pj_stun_attr_hdr *attr)\n{\n    PJ_ASSERT_RETURN(msg && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->attr_count < PJ_STUN_MAX_ATTR, PJ_ETOOMANY);\n\n    msg->attr[msg->attr_count++] = attr;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check that the PDU is potentially a valid STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, pj_size_t pdu_len,\n                                      unsigned options)\n{\n    pj_uint32_t msg_len;\n\n    PJ_ASSERT_RETURN(pdu, PJ_EINVAL);\n\n    if (pdu_len < sizeof(pj_stun_msg_hdr))\n        return PJNATH_EINSTUNMSGLEN;\n\n    /* First byte of STUN message is always 0x00 or 0x01. */\n    if (*pdu != 0x00 && *pdu != 0x01)\n        return PJNATH_EINSTUNMSGTYPE;\n\n    /* Check the PDU length */\n    msg_len = GETVAL16H(pdu, 2);\n    if ((msg_len + 20 > pdu_len) || \n        ((options & PJ_STUN_IS_DATAGRAM) && msg_len + 20 != pdu_len))\n    {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* STUN message is always padded to the nearest 4 bytes, thus\n     * the last two bits of the length field are always zero.\n     */\n    if ((msg_len & 0x03) != 0) {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* If magic is set, then there is great possibility that this is\n     * a STUN message.\n     */\n    if (GETVAL32H(pdu, 4) == PJ_STUN_MAGIC) {\n\n        /* Check if FINGERPRINT attribute is present */\n        if ((options & PJ_STUN_NO_FINGERPRINT_CHECK )==0 && \n            GETVAL16H(pdu, msg_len + 20 - 8) == PJ_STUN_ATTR_FINGERPRINT) \n        {\n            pj_uint16_t attr_len = GETVAL16H(pdu, msg_len + 20 - 8 + 2);\n            pj_uint32_t fingerprint = GETVAL32H(pdu, msg_len + 20 - 8 + 4);\n            pj_uint32_t crc;\n\n            if (attr_len != 4)\n                return PJNATH_ESTUNINATTRLEN;\n\n            crc = pj_crc32_calc(pdu, msg_len + 20 - 8);\n            crc ^= STUN_XOR_FINGERPRINT;\n\n            if (crc != fingerprint)\n                return PJNATH_ESTUNFINGERPRINT;\n        }\n    }\n\n    /* Could be a STUN message */\n    return PJ_SUCCESS;\n}\n\n\n/* Create error response */\nPJ_DEF(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n                                                const pj_stun_msg *req_msg,\n                                                unsigned err_code,\n                                                const pj_str_t *err_msg,\n                                                pj_stun_msg **p_response)\n{\n    unsigned msg_type = req_msg->hdr.type;\n    pj_stun_msg *response = NULL;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_response, PJ_EINVAL);\n\n    PJ_ASSERT_RETURN(PJ_STUN_IS_REQUEST(msg_type), \n                     PJNATH_EINSTUNMSGTYPE);\n\n    /* Create response or error response */\n    if (err_code)\n        msg_type |= PJ_STUN_ERROR_RESPONSE_BIT;\n    else\n        msg_type |= PJ_STUN_SUCCESS_RESPONSE_BIT;\n\n    status = pj_stun_msg_create(pool, msg_type, req_msg->hdr.magic, \n                                req_msg->hdr.tsx_id, &response);\n    if (status != PJ_SUCCESS) {\n        return status;\n    }\n\n    /* Add error code attribute */\n    if (err_code) {\n        status = pj_stun_msg_add_errcode_attr(pool, response, \n                                              err_code, err_msg);\n        if (status != PJ_SUCCESS) {\n            return status;\n        }\n    }\n\n    *p_response = response;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse incoming packet into STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                       const pj_uint8_t *pdu,\n                                       pj_size_t pdu_len,\n                                       unsigned options,\n                                       pj_stun_msg **p_msg,\n                                       pj_size_t *p_parsed_len,\n                                       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n        *p_parsed_len = 0;\n    if (p_response)\n        *p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n        status = pj_stun_msg_check(pdu, pdu_len, options);\n        if (status != PJ_SUCCESS)\n            return status;\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n        p_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= 4) {\n        unsigned attr_type, attr_val_len;\n        const struct attr_desc *adesc;\n\n        /* Get attribute type and length. If length is not aligned\n         * to 4 bytes boundary, add padding.\n         */\n        attr_type = GETVAL16H(pdu, 0);\n        attr_val_len = GETVAL16H(pdu, 2);\n        attr_val_len = (attr_val_len + 3) & (~3);\n\n        /* Check length */\n        if (pdu_len < attr_val_len) {\n            pj_str_t err_msg;\n            char err_msg_buf[80];\n\n            err_msg.ptr = err_msg_buf;\n            err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n                                            \"Attribute %s has invalid length\",\n                                            pj_stun_get_attr_name(attr_type));\n\n            PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n                      (int)err_msg.slen, err_msg.ptr));\n\n            if (p_response) {\n                pj_stun_msg_create_response(pool, msg, \n                                            PJ_STUN_SC_BAD_REQUEST, \n                                            &err_msg, p_response);\n            }\n            return PJNATH_ESTUNINATTRLEN;\n        }\n\n        /* Get the attribute descriptor */\n        adesc = find_attr_desc(attr_type);\n\n        if (adesc == NULL) {\n            /* Unrecognized attribute */\n            pj_stun_binary_attr *attr = NULL;\n\n            PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n                      attr_type));\n\n            /* Is this a fatal condition? */\n            if (attr_type <= 0x7FFF) {\n                /* This is a mandatory attribute, we must return error\n                 * if we don't understand the attribute.\n                 */\n                if (p_response) {\n                    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n                    status = pj_stun_msg_create_response(pool, msg,\n                                                         err_code, NULL, \n                                                         p_response);\n                    if (status==PJ_SUCCESS) {\n                        pj_uint16_t d = (pj_uint16_t)attr_type;\n                        pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n                    }\n                }\n\n                return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Create binary attribute to represent this */\n            status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n                                                GETVAL16H(pdu, 2), &attr);\n            if (status != PJ_SUCCESS) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing unknown STUN attribute type %d\",\n                          attr_type));\n\n                return status;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = &attr->hdr;\n\n        } else {\n            void *attr;\n            char err_msg1[PJ_ERR_MSG_SIZE],\n                 err_msg2[PJ_ERR_MSG_SIZE];\n\n            /* Parse the attribute */\n            status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n            if (status != PJ_SUCCESS) {\n                pj_strerror(status, err_msg1, sizeof(err_msg1));\n\n                if (p_response) {\n                    pj_str_t e;\n\n                    e.ptr = err_msg2;\n                    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n                                             \"%s in %s\",\n                                             err_msg1,\n                                             pj_stun_get_attr_name(attr_type));\n                    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n                        e.slen = sizeof(err_msg2) - 1;\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_BAD_REQUEST,\n                                                &e, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing STUN attribute %s: %s\",\n                          pj_stun_get_attr_name(attr_type), \n                          err_msg1));\n\n                return status;\n            }\n\n            if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n                !has_fingerprint) \n            {\n                if (has_msg_int) {\n                    /* Already has MESSAGE-INTEGRITY */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_msg_int = PJ_TRUE;\n\n            } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n                if (has_fingerprint) {\n                    /* Already has FINGERPRINT */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_fingerprint = PJ_TRUE;\n            } else {\n                if (has_fingerprint) {\n                    /* Another attribute is found which is not FINGERPRINT\n                     * after FINGERPRINT. Note that non-FINGERPRINT is\n                     * allowed to appear after M-I\n                     */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNFINGERPOS;\n                }\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n        }\n\n        /* Next attribute */\n        if (attr_val_len + 4 >= pdu_len) {\n            pdu += pdu_len;\n            pdu_len = 0;\n        } else {\n            pdu += (attr_val_len + 4);\n            pdu_len -= (attr_val_len + 4);\n        }\n    }\n\n    if (pdu_len > 0) {\n        /* Stray trailing bytes */\n        PJ_LOG(4,(THIS_FILE, \n                  \"Error decoding STUN message: unparsed trailing %d bytes\",\n                  pdu_len));\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n        *p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}\n\n/*\nstatic char *print_binary(const pj_uint8_t *data, unsigned data_len)\n{\n    static char static_buffer[1024];\n    char *buffer = static_buffer;\n    unsigned length=sizeof(static_buffer), i;\n\n    if (length < data_len * 2 + 8)\n        return \"\";\n\n    pj_ansi_sprintf(buffer, \", data=\");\n    buffer += 7;\n\n    for (i=0; i<data_len; ++i) {\n        pj_ansi_sprintf(buffer, \"%02x\", (*data) & 0xFF);\n        buffer += 2;\n        data++;\n    }\n\n    pj_ansi_sprintf(buffer, \"\\n\");\n    buffer++;\n\n    return static_buffer;\n}\n*/\n\n/*\n * Print the message structure to a buffer.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n                                       pj_uint8_t *buf, pj_size_t buf_size,\n                                       unsigned options,\n                                       const pj_str_t *key,\n                                       pj_size_t *p_msg_len)\n{\n    pj_uint8_t *start = buf;\n    pj_stun_msgint_attr *amsgint = NULL;\n    pj_stun_fingerprint_attr *afingerprint = NULL;\n    unsigned printed = 0, body_len;\n    pj_status_t status;\n    unsigned i;\n\n\n    PJ_ASSERT_RETURN(msg && buf && buf_size, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(options);\n    PJ_ASSERT_RETURN(options == 0, PJ_EINVAL);\n\n    /* Copy the message header part and convert the header fields to\n     * network byte order\n     */\n    if (buf_size < sizeof(pj_stun_msg_hdr))\n        return PJ_ETOOSMALL;\n    \n    PUTVAL16H(buf, 0, msg->hdr.type);\n    PUTVAL16H(buf, 2, 0);   /* length will be calculated later */\n    PUTVAL32H(buf, 4, msg->hdr.magic);\n    pj_memcpy(buf+8, msg->hdr.tsx_id, sizeof(msg->hdr.tsx_id));\n\n    buf += sizeof(pj_stun_msg_hdr);\n    buf_size -= sizeof(pj_stun_msg_hdr);\n\n    /* Encode each attribute to the message */\n    for (i=0; i<msg->attr_count; ++i) {\n        const struct attr_desc *adesc;\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            pj_assert(amsgint == NULL);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n            /* Stop when encountering MESSAGE-INTEGRITY */\n            break;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n            break;\n        }\n\n        adesc = find_attr_desc(attr_hdr->type);\n        if (adesc) {\n            status = adesc->encode_attr(attr_hdr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        } else {\n            /* This may be a generic attribute */\n            const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*) \n                                                   attr_hdr;\n            PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, PJ_EBUG);\n            status = encode_binary_attr(bin_attr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        }\n\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* We may have stopped printing attribute because we found\n     * MESSAGE-INTEGRITY or FINGERPRINT. Scan the rest of the\n     * attributes.\n     */\n    for ( ++i; i<msg->attr_count; ++i) {\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        /* There mustn't any attribute after FINGERPRINT */\n        PJ_ASSERT_RETURN(afingerprint == NULL, PJNATH_ESTUNFINGERPOS);\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            /* There mustn't be MESSAGE-INTEGRITY before */\n            PJ_ASSERT_RETURN(amsgint == NULL, \n                             PJNATH_ESTUNMSGINTPOS);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n        }\n    }\n\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n    /*\n     * This is the old style MESSAGE-INTEGRITY and FINGERPRINT\n     * calculation, used in rfc3489bis-06 and older.\n     */\n    /* We MUST update the message length in the header NOW before\n     * calculating MESSAGE-INTEGRITY and FINGERPRINT. \n     * Note that length is not including the 20 bytes header.\n      */\n    if (amsgint && afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24 + 8);\n    } else if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else if (afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 8);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#else\n    /* If MESSAGE-INTEGRITY is present, include the M-I attribute\n     * in message length before calculating M-I\n     */\n    if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\n    /* hdr->length = pj_htons(length); */\n    PUTVAL16H(start, 2, (pj_uint16_t)body_len);\n\n    /* Calculate message integrity, if present */\n    if (amsgint != NULL) {\n        pj_hmac_sha1_context ctx;\n\n        /* Key MUST be specified */\n        PJ_ASSERT_RETURN(key, PJ_EINVALIDOP);\n\n        /* MESSAGE-INTEGRITY must be the last attribute in the message, or\n         * the last attribute before FINGERPRINT.\n         */\n        if (msg->attr_count>1 && i < msg->attr_count-2) {\n            /* Should not happen for message generated by us */\n            pj_assert(PJ_FALSE);\n            return PJNATH_ESTUNMSGINTPOS;\n\n        } else if (i == msg->attr_count-2)  {\n            if (msg->attr[i+1]->type != PJ_STUN_ATTR_FINGERPRINT) {\n                /* Should not happen for message generated by us */\n                pj_assert(PJ_FALSE);\n                return PJNATH_ESTUNMSGINTPOS;\n            } else {\n                afingerprint = (pj_stun_fingerprint_attr*) msg->attr[i+1];\n            }\n        }\n\n        /* Calculate HMAC-SHA1 digest, add zero padding to input\n         * if necessary to make the input 64 bytes aligned.\n         */\n        pj_hmac_sha1_init(&ctx, (const pj_uint8_t*)key->ptr, \n                          (unsigned)key->slen);\n        pj_hmac_sha1_update(&ctx, (const pj_uint8_t*)start, \n                            (unsigned)(buf-start));\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        // These are obsoleted in rfc3489bis-08\n        if ((buf-start) & 0x3F) {\n            pj_uint8_t zeroes[64];\n            pj_bzero(zeroes, sizeof(zeroes));\n            pj_hmac_sha1_update(&ctx, zeroes, 64-((buf-start) & 0x3F));\n        }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n        pj_hmac_sha1_final(&ctx, amsgint->hmac);\n\n        /* Put this attribute in the message */\n        status = encode_msgint_attr(amsgint, buf, (unsigned)buf_size, \n                                    &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Calculate FINGERPRINT if present */\n    if (afingerprint != NULL) {\n\n#if !PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        /* Update message length */\n        PUTVAL16H(start, 2, \n                 (pj_uint16_t)(GETVAL16H(start, 2)+8));\n#endif\n\n        afingerprint->value = pj_crc32_calc(start, buf-start);\n        afingerprint->value ^= STUN_XOR_FINGERPRINT;\n\n        /* Put this attribute in the message */\n        status = encode_uint_attr(afingerprint, buf, (unsigned)buf_size, \n                                  &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Update message length. */\n    msg->hdr.length = (pj_uint16_t) ((buf - start) - 20);\n\n    /* Return the length */\n    if (p_msg_len)\n        *p_msg_len = (buf - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_msg_find_attr( const pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 unsigned index)\n{\n    PJ_ASSERT_RETURN(msg, NULL);\n\n    for (; index < msg->attr_count; ++index) {\n        if (msg->attr[index]->type == attr_type)\n            return (pj_stun_attr_hdr*) msg->attr[index];\n    }\n\n    return NULL;\n}\n\n\n/*\n * Clone a STUN attribute.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_attr_clone( pj_pool_t *pool,\n                                              const pj_stun_attr_hdr *attr)\n{\n    const struct attr_desc *adesc;\n\n    /* Get the attribute descriptor */\n    adesc = find_attr_desc(attr->type);\n    if (adesc) {\n        return (pj_stun_attr_hdr*) (*adesc->clone_attr)(pool, attr);\n    } else {\n        /* Clone generic attribute */\n        const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*)\n                                               attr;\n        PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, NULL);\n        if (bin_attr->magic == PJ_STUN_MAGIC) {\n            return (pj_stun_attr_hdr*) clone_binary_attr(pool, attr);\n        } else {\n            return NULL;\n        }\n    }\n}\n\n\n"], "fixing_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJNATH_STUN_MSG_H__\n#define __PJNATH_STUN_MSG_H__\n\n/**\n * @file stun_msg.h\n * @brief STUN message components.\n */\n\n#include <pjnath/types.h>\n#include <pj/sock.h>\n\n\nPJ_BEGIN_DECL\n\n\n/* **************************************************************************/\n/**\n * @defgroup PJNATH_STUN_MSG STUN Message Representation and Parsing\n * @ingroup PJNATH_STUN_BASE\n * @brief Low-level representation and parsing of STUN messages.\n * @{\n */\n\n\n/**\n * STUN magic cookie.\n */\n#define PJ_STUN_MAGIC                       0x2112A442\n\n\n/**\n * STUN method constants.\n */\nenum pj_stun_method_e\n{\n    /**\n     * STUN Binding method as defined by RFC 3489-bis.\n     */\n    PJ_STUN_BINDING_METHOD                  = 1,\n\n    /**\n     * STUN Shared Secret method as defined by RFC 3489-bis.\n     */\n    PJ_STUN_SHARED_SECRET_METHOD            = 2,\n\n    /**\n     * STUN/TURN Allocate method as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_ALLOCATE_METHOD                 = 3,\n\n    /**\n     * STUN/TURN Refresh method as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_REFRESH_METHOD                  = 4,\n\n    /**\n     * STUN/TURN Send indication as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_SEND_METHOD                     = 6,\n\n    /**\n     * STUN/TURN Data indication as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_DATA_METHOD                     = 7,\n\n    /**\n     * STUN/TURN CreatePermission method as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_CREATE_PERM_METHOD              = 8,\n\n    /**\n     * STUN/TURN ChannelBind as defined by draft-ietf-behave-turn\n     */\n    PJ_STUN_CHANNEL_BIND_METHOD             = 9,\n\n    /**\n     * STUN/TURN Connect as defined by RFC 6062\n     */\n    PJ_STUN_CONNECT_METHOD                  = 10,\n\n    /**\n     * STUN/TURN ConnectionBind as defined by RFC 6062\n     */\n    PJ_STUN_CONNECTION_BIND_METHOD          = 11,\n\n    /**\n     * STUN/TURN ConnectionAttempt as defined by RFC 6062\n     */\n    PJ_STUN_CONNECTION_ATTEMPT_METHOD       = 12,\n\n    /**\n     * All known methods.\n     */\n    PJ_STUN_METHOD_MAX\n};\n\n\n/**\n * Retrieve the STUN method from the message-type field of the STUN\n * message.\n */\n#define PJ_STUN_GET_METHOD(msg_type)    ((msg_type) & 0xFEEF)\n\n\n/**\n * STUN message classes constants.\n */\nenum pj_stun_msg_class_e\n{\n    /**\n     * This specifies that the message type is a STUN request message.\n     */\n    PJ_STUN_REQUEST_CLASS           = 0,\n\n    /**\n     * This specifies that the message type is a STUN indication message.\n     */\n    PJ_STUN_INDICATION_CLASS        = 1,\n\n    /**\n     * This specifies that the message type is a STUN successful response.\n     */\n    PJ_STUN_SUCCESS_CLASS           = 2,\n\n    /**\n     * This specifies that the message type is a STUN error response.\n     */\n    PJ_STUN_ERROR_CLASS             = 3\n};\n\n\n/**\n * Determine if the message type is a request.\n */\n#define PJ_STUN_IS_REQUEST(msg_type)    (((msg_type) & 0x0110) == 0x0000)\n\n\n/**\n * Determine if the message type is a successful response.\n */\n#define PJ_STUN_IS_SUCCESS_RESPONSE(msg_type) (((msg_type) & 0x0110) == 0x0100)\n\n/**\n * The response bit in the message type.\n */\n#define PJ_STUN_SUCCESS_RESPONSE_BIT    (0x0100)\n\n\n/**\n * Determine if the message type is an error response.\n */\n#define PJ_STUN_IS_ERROR_RESPONSE(msg_type) (((msg_type) & 0x0110) == 0x0110)\n\n/**\n * The error response bit in the message type.\n */\n#define PJ_STUN_ERROR_RESPONSE_BIT      (0x0110)\n\n/**\n * Determine if the message type is a response.\n */\n#define PJ_STUN_IS_RESPONSE(msg_type) (((msg_type) & 0x0100) == 0x0100)\n\n\n/**\n * Determine if the message type is an indication message.\n */\n#define PJ_STUN_IS_INDICATION(msg_type) (((msg_type) & 0x0110) == 0x0010)\n\n/**\n * The error response bit in the message type.\n */\n#define PJ_STUN_INDICATION_BIT          (0x0010)\n\n\n/**\n * This enumeration describes STUN message types.\n */\ntypedef enum pj_stun_msg_type\n{\n    /**\n     * STUN BINDING request.\n     */\n    PJ_STUN_BINDING_REQUEST                 = 0x0001,\n\n    /**\n     * Successful response to STUN BINDING-REQUEST.\n     */\n    PJ_STUN_BINDING_RESPONSE                = 0x0101,\n\n    /**\n     * Error response to STUN BINDING-REQUEST.\n     */\n    PJ_STUN_BINDING_ERROR_RESPONSE          = 0x0111,\n\n    /**\n     * Binding Indication (ICE)\n     */\n    PJ_STUN_BINDING_INDICATION              = 0x0011,\n\n    /**\n     * STUN SHARED-SECRET reqeust.\n     */\n    PJ_STUN_SHARED_SECRET_REQUEST           = 0x0002,\n\n    /**\n     * Successful response to STUN SHARED-SECRET reqeust.\n     */\n    PJ_STUN_SHARED_SECRET_RESPONSE          = 0x0102,\n\n    /**\n     * Error response to STUN SHARED-SECRET reqeust.\n     */\n    PJ_STUN_SHARED_SECRET_ERROR_RESPONSE    = 0x0112,\n\n\n    /**\n     * STUN/TURN Allocate Request\n     */\n    PJ_STUN_ALLOCATE_REQUEST                = 0x0003,\n\n    /**\n     * Successful response to STUN/TURN Allocate Request\n     */\n    PJ_STUN_ALLOCATE_RESPONSE               = 0x0103,\n\n    /**\n     * Failure response to STUN/TURN Allocate Request\n     */\n    PJ_STUN_ALLOCATE_ERROR_RESPONSE         = 0x0113,\n\n\n    /**\n     * STUN/TURN REFRESH Request\n     */\n    PJ_STUN_REFRESH_REQUEST                 = 0x0004,\n\n    /**\n     * Successful response to STUN REFRESH request\n     */\n    PJ_STUN_REFRESH_RESPONSE                = 0x0104,\n\n    /**\n     * Error response to STUN REFRESH request.\n     */\n    PJ_STUN_REFRESH_ERROR_RESPONSE          = 0x0114,\n\n\n    /**\n     * TURN Send indication\n     */\n    PJ_STUN_SEND_INDICATION                 = 0x0016,\n\n\n    /**\n     * TURN Data indication\n     */\n    PJ_STUN_DATA_INDICATION                 = 0x0017,\n\n\n    /**\n     * TURN CreatePermission request\n     */\n    PJ_STUN_CREATE_PERM_REQUEST             = 0x0008,\n\n    /**\n     * TURN CreatePermission successful response.\n     */\n    PJ_STUN_CREATE_PERM_RESPONSE            = 0x0108,\n\n    /**\n     * TURN CreatePermission failure response\n     */\n    PJ_STUN_CREATE_PERM_ERROR_RESPONSE      = 0x0118,\n\n\n    /**\n     * STUN/TURN ChannelBind Request\n     */\n    PJ_STUN_CHANNEL_BIND_REQUEST            = 0x0009,\n\n    /**\n     * Successful response to STUN ChannelBind request\n     */\n    PJ_STUN_CHANNEL_BIND_RESPONSE           = 0x0109,\n\n    /**\n     * Error response to STUN ChannelBind request.\n     */\n    PJ_STUN_CHANNEL_BIND_ERROR_RESPONSE     = 0x0119,\n\n    /**\n     * STUN/TURN Connect Request\n     */\n    PJ_STUN_CONNECT_REQUEST                 = 0x000a,\n\n    /**\n     * STUN/TURN ConnectBind Request\n     */\n    PJ_STUN_CONNECTION_BIND_REQUEST         = 0x000b,\n\n    /**\n     * TURN ConnectionAttempt indication\n     */\n    PJ_STUN_CONNECTION_ATTEMPT_INDICATION   = 0x001c,\n\n} pj_stun_msg_type;\n\n\n\n/**\n * This enumeration describes STUN attribute types.\n */\ntypedef enum pj_stun_attr_type\n{\n    PJ_STUN_ATTR_MAPPED_ADDR        = 0x0001,/**< MAPPED-ADDRESS.           */\n    PJ_STUN_ATTR_RESPONSE_ADDR      = 0x0002,/**< RESPONSE-ADDRESS (deprcatd)*/\n    PJ_STUN_ATTR_CHANGE_REQUEST     = 0x0003,/**< CHANGE-REQUEST (deprecated)*/\n    PJ_STUN_ATTR_SOURCE_ADDR        = 0x0004,/**< SOURCE-ADDRESS (deprecated)*/\n    PJ_STUN_ATTR_CHANGED_ADDR       = 0x0005,/**< CHANGED-ADDRESS (deprecatd)*/\n    PJ_STUN_ATTR_USERNAME           = 0x0006,/**< USERNAME attribute.       */\n    PJ_STUN_ATTR_PASSWORD           = 0x0007,/**< was PASSWORD attribute.   */\n    PJ_STUN_ATTR_MESSAGE_INTEGRITY  = 0x0008,/**< MESSAGE-INTEGRITY.        */\n    PJ_STUN_ATTR_ERROR_CODE         = 0x0009,/**< ERROR-CODE.               */\n    PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES = 0x000A,/**< UNKNOWN-ATTRIBUTES.       */\n    PJ_STUN_ATTR_REFLECTED_FROM     = 0x000B,/**< REFLECTED-FROM (deprecatd)*/\n    PJ_STUN_ATTR_CHANNEL_NUMBER     = 0x000C,/**< TURN CHANNEL-NUMBER       */\n    PJ_STUN_ATTR_LIFETIME           = 0x000D,/**< TURN LIFETIME attr.       */\n    PJ_STUN_ATTR_MAGIC_COOKIE       = 0x000F,/**< MAGIC-COOKIE attr (deprec)*/\n    PJ_STUN_ATTR_BANDWIDTH          = 0x0010,/**< TURN BANDWIDTH (deprec)   */\n    PJ_STUN_ATTR_XOR_PEER_ADDR      = 0x0012,/**< TURN XOR-PEER-ADDRESS     */\n    PJ_STUN_ATTR_DATA               = 0x0013,/**< DATA attribute.           */\n    PJ_STUN_ATTR_REALM              = 0x0014,/**< REALM attribute.          */\n    PJ_STUN_ATTR_NONCE              = 0x0015,/**< NONCE attribute.          */\n    PJ_STUN_ATTR_XOR_RELAYED_ADDR   = 0x0016,/**< TURN XOR-RELAYED-ADDRESS  */\n    PJ_STUN_ATTR_REQ_ADDR_TYPE      = 0x0017,/**< REQUESTED-ADDRESS-TYPE    */\n    PJ_STUN_ATTR_REQ_ADDR_FAMILY    = 0x0017,/**< REQUESTED-ADDRESS-FAMILY  */\n    PJ_STUN_ATTR_EVEN_PORT          = 0x0018,/**< TURN EVEN-PORT            */\n    PJ_STUN_ATTR_REQ_TRANSPORT      = 0x0019,/**< TURN REQUESTED-TRANSPORT  */\n    PJ_STUN_ATTR_DONT_FRAGMENT      = 0x001A,/**< TURN DONT-FRAGMENT        */\n    PJ_STUN_ATTR_XOR_MAPPED_ADDR    = 0x0020,/**< XOR-MAPPED-ADDRESS        */\n    PJ_STUN_ATTR_TIMER_VAL          = 0x0021,/**< TIMER-VAL attribute.      */\n    PJ_STUN_ATTR_RESERVATION_TOKEN  = 0x0022,/**< TURN RESERVATION-TOKEN    */\n    PJ_STUN_ATTR_XOR_REFLECTED_FROM = 0x0023,/**< XOR-REFLECTED-FROM        */\n    PJ_STUN_ATTR_PRIORITY           = 0x0024,/**< PRIORITY                  */\n    PJ_STUN_ATTR_USE_CANDIDATE      = 0x0025,/**< USE-CANDIDATE             */\n    PJ_STUN_ATTR_CONNECTION_ID      = 0x002a,/**< CONNECTION-ID             */\n    PJ_STUN_ATTR_ICMP               = 0x0030,/**< ICMP (TURN)               */\n\n    PJ_STUN_ATTR_END_MANDATORY_ATTR,\n\n    PJ_STUN_ATTR_START_EXTENDED_ATTR= 0x8021,\n\n    PJ_STUN_ATTR_SOFTWARE           = 0x8022,/**< SOFTWARE attribute.       */\n    PJ_STUN_ATTR_ALTERNATE_SERVER   = 0x8023,/**< ALTERNATE-SERVER.         */\n    PJ_STUN_ATTR_REFRESH_INTERVAL   = 0x8024,/**< REFRESH-INTERVAL.         */\n    PJ_STUN_ATTR_FINGERPRINT        = 0x8028,/**< FINGERPRINT attribute.    */\n    PJ_STUN_ATTR_ICE_CONTROLLED     = 0x8029,/**< ICE-CCONTROLLED attribute.*/\n    PJ_STUN_ATTR_ICE_CONTROLLING    = 0x802a,/**< ICE-CCONTROLLING attribute*/\n\n    PJ_STUN_ATTR_END_EXTENDED_ATTR\n\n} pj_stun_attr_type;\n\n\n/**\n * STUN error codes, which goes into STUN ERROR-CODE attribute.\n */\ntypedef enum pj_stun_status\n{\n    PJ_STUN_SC_TRY_ALTERNATE            = 300,  /**< Try Alternate          */\n    PJ_STUN_SC_BAD_REQUEST              = 400,  /**< Bad Request            */\n    PJ_STUN_SC_UNAUTHORIZED             = 401,  /**< Unauthorized           */\n    PJ_STUN_SC_FORBIDDEN                = 403,  /**< Forbidden (TURN)       */\n    PJ_STUN_SC_UNKNOWN_ATTRIBUTE        = 420,  /**< Unknown Attribute      */\n#if 0\n    /* These were obsolete in recent rfc3489bis */\n    //PJ_STUN_SC_STALE_CREDENTIALS      = 430,  /**< Stale Credentials      */\n    //PJ_STUN_SC_INTEGRITY_CHECK_FAILURE= 431,  /**< Integrity Chk Fail     */\n    //PJ_STUN_SC_MISSING_USERNAME       = 432,  /**< Missing Username       */\n    //PJ_STUN_SC_USE_TLS                = 433,  /**< Use TLS                */\n    //PJ_STUN_SC_MISSING_REALM          = 434,  /**< Missing Realm          */\n    //PJ_STUN_SC_MISSING_NONCE          = 435,  /**< Missing Nonce          */\n    //PJ_STUN_SC_UNKNOWN_USERNAME       = 436,  /**< Unknown Username       */\n#endif\n    PJ_STUN_SC_ALLOCATION_MISMATCH      = 437,  /**< TURN Alloc Mismatch    */\n    PJ_STUN_SC_STALE_NONCE              = 438,  /**< Stale Nonce            */\n    PJ_STUN_SC_TRANSITIONING            = 439,  /**< Transitioning.         */\n    PJ_STUN_SC_WRONG_CREDENTIALS        = 441,  /**< TURN Wrong Credentials */\n    PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO   = 442,  /**< Unsupported Transport or\n                                                     Protocol (TURN) */\n    PJ_STUN_SC_OPER_TCP_ONLY            = 445,  /**< Operation for TCP Only */\n    PJ_STUN_SC_CONNECTION_FAILURE       = 446,  /**< Connection Failure     */\n    PJ_STUN_SC_CONNECTION_TIMEOUT       = 447,  /**< Connection Timeout     */\n    PJ_STUN_SC_ALLOCATION_QUOTA_REACHED = 486,  /**< Allocation Quota Reached\n                                                     (TURN) */\n    PJ_STUN_SC_ROLE_CONFLICT            = 487,  /**< Role Conflict          */\n    PJ_STUN_SC_SERVER_ERROR             = 500,  /**< Server Error           */\n    PJ_STUN_SC_INSUFFICIENT_CAPACITY    = 508,  /**< Insufficient Capacity \n                                                     (TURN) */\n    PJ_STUN_SC_GLOBAL_FAILURE           = 600   /**< Global Failure         */\n} pj_stun_status;\n\n\n/**\n * This structure describes STUN message header. A STUN message has the \n * following format:\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |0 0|     STUN Message Type     |         Message Length        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                         Magic Cookie                          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                Transaction ID\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                                                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   \\endverbatim\n */\n#pragma pack(1)\ntypedef struct pj_stun_msg_hdr\n{\n    /**\n     * STUN message type, which the first two bits must be zeroes.\n     */\n    pj_uint16_t         type;\n\n    /**\n     * The message length is the size, in bytes, of the message not\n     * including the 20 byte STUN header.\n     */\n    pj_uint16_t         length;\n\n    /**\n     * The magic cookie is a fixed value, 0x2112A442 (PJ_STUN_MAGIC constant).\n     * In the previous version of this specification [15] this field was part \n     * of the transaction ID.\n     */\n    pj_uint32_t         magic;\n\n    /**\n     * The transaction ID is a 96 bit identifier.  STUN transactions are\n     * identified by their unique 96-bit transaction ID.  For request/\n     * response transactions, the transaction ID is chosen by the STUN\n     * client and MUST be unique for each new STUN transaction generated by\n     * that STUN client.  The transaction ID MUST be uniformly and randomly\n     * distributed between 0 and 2**96 - 1. \n     */\n    pj_uint8_t          tsx_id[12];\n\n} pj_stun_msg_hdr;\n#pragma pack()\n\n\n/**\n * This structre describes STUN attribute header. Each attribute is\n * TLV encoded, with a 16 bit type, 16 bit length, and variable value.\n * Each STUN attribute ends on a 32 bit boundary:\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |         Type                  |            Length             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   \\endverbatim\n */\n#pragma pack(1)\ntypedef struct pj_stun_attr_hdr\n{\n    /**\n     * STUN attribute type.\n     */\n    pj_uint16_t         type;\n\n    /**\n     * The Length refers to the length of the actual useful content of the\n     * Value portion of the attribute, measured in bytes. The value\n     * in the Length field refers to the length of the Value part of the\n     * attribute prior to padding - i.e., the useful content.\n     */\n    pj_uint16_t         length;\n\n} pj_stun_attr_hdr;\n#pragma pack()\n\n\n/**\n * This structure describes STUN generic IP address attribute, used for\n * example to represent STUN MAPPED-ADDRESS attribute.\n *\n * The generic IP address attribute indicates the transport address.\n * It consists of an eight bit address family, and a sixteen bit port,\n * followed by a fixed length value representing the IP address.  If the\n * address family is IPv4, the address is 32 bits, in network byte\n * order.  If the address family is IPv6, the address is 128 bits in\n * network byte order.\n *\n * The format of the generic IP address attribute is:\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |x x x x x x x x|    Family     |           Port                |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                   Address  (variable)\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   \\endverbatim\n */\ntypedef struct pj_stun_sockaddr_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * Flag to indicate whether this attribute should be sent in XOR-ed\n     * format, or has been received in XOR-ed format.\n     */\n    pj_bool_t           xor_ed;\n\n    /**\n     * The socket address\n     */\n    pj_sockaddr         sockaddr;\n\n} pj_stun_sockaddr_attr;\n\n\n/**\n * This structure represents a generic STUN attributes with no payload,\n * and it is used for example by ICE USE-CANDIDATE attribute.\n */\ntypedef struct pj_stun_empty_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n} pj_stun_empty_attr;\n\n\n/**\n * This structure represents generic STUN string attributes, such as STUN\n * USERNAME, PASSWORD, SOFTWARE, REALM, and NONCE attributes.\n */\ntypedef struct pj_stun_string_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * The string value.\n     */\n    pj_str_t            value;\n\n} pj_stun_string_attr;\n\n\n/**\n * This structure represents a generic STUN attributes with 32bit (unsigned)\n * integer value, such as STUN FINGERPRINT and REFRESH-INTERVAL attributes.\n */\ntypedef struct pj_stun_uint_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n    \n    /**\n     * The 32bit value, in host byte order.\n     */\n    pj_uint32_t         value;\n\n} pj_stun_uint_attr;\n\n\n/**\n * This structure represents a generic STUN attributes with 64bit (unsigned)\n * integer value, such as ICE-CONTROLLED and ICE-CONTROLLING attributes.\n */\ntypedef struct pj_stun_uint64_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n    \n    /**\n     * The 64bit value, in host byte order, represented with pj_timestamp.\n     */\n    pj_timestamp        value;\n\n} pj_stun_uint64_attr;\n\n\n/**\n * This structure represents generic STUN attributes to hold a raw binary\n * data.\n */\ntypedef struct pj_stun_binary_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n    \n    /**\n     * Special signature to indicate that this is a valid attribute even\n     * though we don't have meta-data to describe this attribute.\n     */\n    pj_uint32_t         magic;\n\n    /**\n     * Length of the data.\n     */\n    unsigned            length;\n\n    /**\n     * The raw data.\n     */\n    pj_uint8_t         *data;\n\n} pj_stun_binary_attr;\n\n\n/**\n * This structure describes STUN MESSAGE-INTEGRITY attribute.\n * The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [10] of the\n * STUN message.  The MESSAGE-INTEGRITY attribute can be present in any\n * STUN message type.  Since it uses the SHA1 hash, the HMAC will be 20\n * bytes.\n */\ntypedef struct pj_stun_msgint_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * The 20 bytes hmac value.\n     */\n    pj_uint8_t          hmac[20];\n\n} pj_stun_msgint_attr;\n\n\n/**\n * This structure describes STUN FINGERPRINT attribute. The FINGERPRINT \n * attribute can be present in all STUN messages.  It is computed as \n * the CRC-32 of the STUN message up to (but excluding) the FINGERPRINT \n * attribute itself, xor-d with the 32 bit value 0x5354554e\n */\ntypedef struct pj_stun_uint_attr pj_stun_fingerprint_attr;\n\n\n/**\n * This structure represents STUN ERROR-CODE attribute. The ERROR-CODE \n * attribute is present in the Binding Error Response and Shared Secret \n * Error Response.  It is a numeric value in the range of 100 to 699 \n * plus a textual reason phrase encoded in UTF-8\n *\n * \\verbatim\n\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                   0                     |Class|     Number    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |      Reason Phrase (variable)                                ..\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n \\endverbatim\n */\ntypedef struct pj_stun_errcode_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * STUN error code.\n     */\n    int                 err_code;\n\n    /**\n     * The reason phrase.\n     */\n    pj_str_t            reason;\n\n} pj_stun_errcode_attr;\n\n\n/**\n * This describes STUN REALM attribute.\n * The REALM attribute is present in requests and responses.  It\n * contains text which meets the grammar for \"realm\" as described in RFC\n * 3261 [11], and will thus contain a quoted string (including the\n * quotes).\n */\ntypedef struct pj_stun_string_attr pj_stun_realm_attr;\n\n\n/**\n * This describes STUN NONCE attribute. \n * The NONCE attribute is present in requests and in error responses.\n * It contains a sequence of qdtext or quoted-pair, which are defined in\n * RFC 3261 [11].  See RFC 2617 [7] for guidance on selection of nonce\n * values in a server.\n */\ntypedef struct pj_stun_string_attr pj_stun_nonce_attr;\n\n\n/**\n * This describes STUN UNKNOWN-ATTRIBUTES attribute.\n * The UNKNOWN-ATTRIBUTES attribute is present only in an error response\n * when the response code in the ERROR-CODE attribute is 420.\n * The attribute contains a list of 16 bit values, each of which\n * represents an attribute type that was not understood by the server.\n * If the number of unknown attributes is an odd number, one of the\n * attributes MUST be repeated in the list, so that the total length of\n * the list is a multiple of 4 bytes.\n */\ntypedef struct pj_stun_unknown_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr    hdr;\n\n    /**\n     * Number of unknown attributes in the array.\n     */\n    unsigned            attr_count;\n\n    /**\n     * Array of unknown attribute IDs.\n     */\n    pj_uint16_t         attrs[PJ_STUN_MAX_ATTR];\n\n} pj_stun_unknown_attr;\n\n\n/**\n * This structure describes STUN MAPPED-ADDRESS attribute.\n * The MAPPED-ADDRESS attribute indicates the mapped transport address.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_mapped_addr_attr;\n\n\n/**\n * This describes STUN XOR-MAPPED-ADDRESS attribute (which has the same\n * format as STUN MAPPED-ADDRESS attribute).\n * The XOR-MAPPED-ADDRESS attribute is present in responses.  It\n * provides the same information that would present in the MAPPED-\n * ADDRESS attribute but because the NAT's public IP address is\n * obfuscated through the XOR function, STUN messages are able to pass\n * through NATs which would otherwise interfere with STUN.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_mapped_addr_attr;\n\n\n/**\n * This describes STUN SOFTWARE attribute.\n * The SOFTWARE attribute contains a textual description of the software\n * being used by the agent sending the message.  It is used by clients\n * and servers.  Its value SHOULD include manufacturer and version\n * number. */\ntypedef struct pj_stun_string_attr pj_stun_software_attr;\n\n\n/**\n * This describes STUN ALTERNATE-SERVER attribute.\n * The alternate server represents an alternate transport address for a\n * different STUN server to try.  It is encoded in the same way as\n * MAPPED-ADDRESS.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_alt_server_attr;\n\n\n/**\n * This describes STUN REFRESH-INTERVAL attribute.\n * The REFRESH-INTERVAL indicates the number of milliseconds that the\n * server suggests the client should use between refreshes of the NAT\n * bindings between the client and server.\n */\ntypedef struct pj_stun_uint_attr pj_stun_refresh_interval_attr;\n\n\n/**\n * This structure describes STUN RESPONSE-ADDRESS attribute.\n * The RESPONSE-ADDRESS attribute indicates where the response to a\n * Binding Request should be sent.  Its syntax is identical to MAPPED-\n * ADDRESS.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_response_addr_attr;\n\n\n/**\n * This structure describes STUN CHANGED-ADDRESS attribute.\n * The CHANGED-ADDRESS attribute indicates the IP address and port where\n * responses would have been sent from if the \"change IP\" and \"change\n * port\" flags had been set in the CHANGE-REQUEST attribute of the\n * Binding Request.  The attribute is always present in a Binding\n * Response, independent of the value of the flags.  Its syntax is\n * identical to MAPPED-ADDRESS.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_changed_addr_attr;\n\n\n/**\n * This structure describes STUN CHANGE-REQUEST attribute.\n * The CHANGE-REQUEST attribute is used by the client to request that\n * the server use a different address and/or port when sending the\n * response. \n *\n * Bit 29 of the value is the \"change IP\" flag.  If true, it requests \n * the server to send the Binding Response with a different IP address \n * than the one the Binding Request was received on.\n *\n * Bit 30 of the value is the \"change port\" flag.  If true, it requests \n * the server to send the Binding Response with a different port than \n * the one the Binding Request was received on.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_uint_attr pj_stun_change_request_attr;\n\n/**\n * This structure describes STUN SOURCE-ADDRESS attribute.\n * The SOURCE-ADDRESS attribute is present in Binding Responses.  It\n * indicates the source IP address and port that the server is sending\n * the response from.  Its syntax is identical to that of MAPPED-\n * ADDRESS.\n *\n * Note that the usage of this attribute has been deprecated by the \n * RFC 3489-bis standard.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_src_addr_attr;\n\n\n/**\n * This describes the STUN REFLECTED-FROM attribute.\n * The REFLECTED-FROM attribute is present only in Binding Responses,\n * when the Binding Request contained a RESPONSE-ADDRESS attribute.  The\n * attribute contains the identity (in terms of IP address) of the\n * source where the request came from.  Its purpose is to provide\n * traceability, so that a STUN server cannot be used as a reflector for\n * denial-of-service attacks.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_reflected_from_attr;\n\n\n/**\n * This describes STUN USERNAME attribute.\n * The USERNAME attribute is used for message integrity.  It identifies\n * the shared secret used in the message integrity check.  Consequently,\n * the USERNAME MUST be included in any request that contains the\n * MESSAGE-INTEGRITY attribute.\n */\ntypedef struct pj_stun_string_attr pj_stun_username_attr;\n\n\n/**\n * This describes STUN PASSWORD attribute.\n * If the message type is Shared Secret Response it MUST include the\n * PASSWORD attribute.\n */\ntypedef struct pj_stun_string_attr pj_stun_password_attr;\n\n\n/**\n * This describes TURN CHANNEL-NUMBER attribute. In this library,\n * this attribute is represented with 32bit integer. Application may\n * use #PJ_STUN_GET_CH_NB() and #PJ_STUN_SET_CH_NB() to extract/set\n * channel number value from the 32bit integral value.\n *\n * The CHANNEL-NUMBER attribute contains the number of the channel.\n * It is a 16-bit unsigned integer, followed by a two-octet RFFU field\n * which MUST be set to 0 on transmission and ignored on reception.\n  \n \\verbatim\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |        Channel Number         |         RFFU                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \\endverbatim\n */\ntypedef struct pj_stun_uint_attr pj_stun_channel_number_attr;\n\n/**\n * Get 16bit channel number from 32bit integral value.\n * Note that uint32 attributes are always stored in host byte order\n * after they have been parsed from the PDU, so no need to do ntohs()\n * here.\n */\n#define PJ_STUN_GET_CH_NB(u32)      ((pj_uint16_t)(u32>>16))\n\n/**\n * Convert 16bit channel number into 32bit integral value.\n * Note that uint32 attributes will be converted to network byte order\n * when the attribute is written to packet, so no need to do htons()\n * here.\n */\n#define PJ_STUN_SET_CH_NB(chnum)    (((pj_uint32_t)chnum) << 16)\n\n\n/**\n * This describes STUN LIFETIME attribute.\n * The lifetime attribute represents the duration for which the server\n * will maintain an allocation in the absence of data traffic either\n * from or to the client.  It is a 32 bit value representing the number\n * of seconds remaining until expiration.\n */\ntypedef struct pj_stun_uint_attr pj_stun_lifetime_attr;\n\n\n/**\n * This describes STUN BANDWIDTH attribute.\n * The bandwidth attribute represents the peak bandwidth, measured in\n * kbits per second, that the client expects to use on the binding.  The\n * value represents the sum in the receive and send directions.\n */\ntypedef struct pj_stun_uint_attr pj_stun_bandwidth_attr;\n\n\n/**\n * This describes the STUN XOR-PEER-ADDRESS attribute.\n * The XOR-PEER-ADDRESS specifies the address and port of the peer as seen\n * from the TURN server.  It is encoded in the same way as XOR-MAPPED-\n * ADDRESS. \n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_peer_addr_attr;\n\n\n/**\n * This describes the STUN DATA attribute.\n * The DATA attribute is present in Send Indications and Data\n * Indications.  It contains raw payload data that is to be sent (in the\n * case of a Send Request) or was received (in the case of a Data\n * Indication)..\n */\ntypedef struct pj_stun_binary_attr pj_stun_data_attr;\n\n\n/**\n * This describes the STUN XOR-RELAYED-ADDRESS attribute. The \n * XOR-RELAYED-ADDRESS is present in Allocate responses.  It specifies the\n * address and port that the server allocated to the client.  It is\n * encoded in the same way as XOR-MAPPED-ADDRESS.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_relayed_addr_attr;\n\n\n/**\n * According to RFC 6156, this describes the REQUESTED-ADDRESS-FAMILY\n * attribute (formerly known as REQUESTED-ADDRESS-TYPE in the draft).\n * The REQUESTED-ADDRESS-FAMILY attribute is used by clients to request\n * the allocation of a specific address type from a server.  The\n * following is the format of the REQUESTED-ADDRESS-FAMILY attribute.\n\n \\verbatim\n\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |        Family                 |           Reserved            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n \\endverbatim\n */\ntypedef struct pj_stun_uint_attr pj_stun_req_addr_type_attr;\n\n\n/**\n * This describes the TURN REQUESTED-TRANSPORT attribute, encoded in\n * STUN generic integer attribute.\n *\n * This attribute allows the client to request that the port in the\n * relayed-transport-address be even, and (optionally) that the server\n * reserve the next-higher port number.  The attribute is 8 bits long.\n * Its format is:\n\n\\verbatim\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |R|    RFFU     |\n     +-+-+-+-+-+-+-+-+\n\n\\endverbatim\n\n * The attribute contains a single 1-bit flag:\n * \n * R: If 1, the server is requested to reserve the next higher port\n *    number (on the same IP address) for a subsequent allocation.  If\n *    0, no such reservation is requested.\n * \n * The other 7 bits of the attribute must be set to zero on transmission\n * and ignored on reception.\n */\ntypedef struct pj_stun_uint_attr pj_stun_even_port_attr;\n\n\n/**\n * This describes the TURN REQUESTED-TRANSPORT attribute, encoded in\n * STUN generic integer attribute.\n *\n * This attribute is used by the client to request a specific transport\n * protocol for the allocated transport address.  It has the following\n * format:\n\n \\verbatim\n\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |    Protocol   |                    RFFU                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n \\endverbatim\n\n * The Protocol field specifies the desired protocol.  The codepoints\n * used in this field are taken from those allowed in the Protocol field\n * in the IPv4 header and the NextHeader field in the IPv6 header\n * [Protocol-Numbers].  This specification only allows the use of\n * codepoint 17 (User Datagram Protocol).\n * \n * The RFFU field is set to zero on transmission and ignored on\n * receiption.  It is reserved for future uses.\n */\ntypedef struct pj_stun_uint_attr pj_stun_req_transport_attr;\n\n/**\n * Get protocol value from 32bit TURN REQUESTED-TRANSPORT attribute.\n */\n#define PJ_STUN_GET_RT_PROTO(u32)   (u32 >> 24)\n\n/**\n * Convert protocol value to be placed in 32bit TURN REQUESTED-TRANSPORT\n * attribute.\n */\n#define PJ_STUN_SET_RT_PROTO(proto)   (((pj_uint32_t)(proto)) << 24)\n\n\n/**\n * This describes the TURN DONT-FRAGMENT attribute.\n *\n * This attribute is used by the client to request that the server set\n * the DF (Don't Fragment) bit in the IP header when relaying the\n * application data onward to the peer.  This attribute has no value\n * part and thus the attribute length field is 0.\n */\ntypedef struct pj_stun_empty_attr pj_stun_dont_fragment_attr;\n\n\n/**\n * This describes the TURN RESERVATION-TOKEN attribute.\n * The RESERVATION-TOKEN attribute contains a token that uniquely\n * identifies a relayed transport address being held in reserve by the\n * server.  The server includes this attribute in a success response to\n * tell the client about the token, and the client includes this\n * attribute in a subsequent Allocate request to request the server use\n * that relayed transport address for the allocation.\n * \n * The attribute value is a 64-bit-long field containing the token\n * value. \n */\ntypedef struct pj_stun_uint64_attr pj_stun_res_token_attr;\n\n/**\n * This describes the XOR-REFLECTED-FROM attribute, as described by\n * draft-macdonald-behave-nat-behavior-discovery-00.\n * The XOR-REFLECTED-FROM attribute is used in place of the REFLECTED-\n * FROM attribute.  It provides the same information, but because the\n * NAT's public address is obfuscated through the XOR function, It can\n * pass through a NAT that would otherwise attempt to translate it to\n * the private network address.  XOR-REFLECTED-FROM has identical syntax\n * to XOR-MAPPED-ADDRESS.\n */\ntypedef struct pj_stun_sockaddr_attr pj_stun_xor_reflected_from_attr;\n\n/**\n * This describes the PRIORITY attribute from draft-ietf-mmusic-ice-13.\n * The PRIORITY attribute indicates the priority that is to be\n * associated with a peer reflexive candidate, should one be discovered\n * by this check.  It is a 32 bit unsigned integer, and has an attribute\n * type of 0x0024.\n */\ntypedef struct pj_stun_uint_attr pj_stun_priority_attr;\n\n/**\n * This describes the USE-CANDIDATE attribute from draft-ietf-mmusic-ice-13.\n * The USE-CANDIDATE attribute indicates that the candidate pair\n * resulting from this check should be used for transmission of media.\n * The attribute has no content (the Length field of the attribute is\n * zero); it serves as a flag.\n */\ntypedef struct pj_stun_empty_attr pj_stun_use_candidate_attr;\n\n/**\n * This describes the STUN TIMER-VAL attribute.\n * The TIMER-VAL attribute is used only in conjunction with the Set\n * Active Destination response.  It conveys from the server, to the\n * client, the value of the timer used in the server state machine.\n */\ntypedef struct pj_stun_uint_attr pj_stun_timer_val_attr;\n\n/**\n * This describes ICE-CONTROLLING attribute.\n */\ntypedef struct pj_stun_uint64_attr pj_stun_ice_controlling_attr;\n\n/**\n * This describes ICE-CONTROLLED attribute.\n */\ntypedef struct pj_stun_uint64_attr pj_stun_ice_controlled_attr;\n\n/**\n * This describes TURN ICMP attribute\n */\ntypedef struct pj_stun_uint_attr pj_stun_icmp_attr;\n\n/**\n * This structure describes a parsed STUN message. All integral fields\n * in this structure (including IP addresses) will be in the host\n * byte order.\n */\ntypedef struct pj_stun_msg\n{\n    /**\n     * STUN message header.\n     */\n    pj_stun_msg_hdr     hdr;\n\n    /**\n     * Number of attributes in the STUN message.\n     */\n    unsigned            attr_count;\n\n    /**\n     * Array of STUN attributes.\n     */\n    pj_stun_attr_hdr   *attr[PJ_STUN_MAX_ATTR];\n\n} pj_stun_msg;\n\n\n/** STUN decoding options */\nenum pj_stun_decode_options\n{\n    /** \n     * Tell the decoder that the message was received from datagram\n     * oriented transport (such as UDP).\n     */\n    PJ_STUN_IS_DATAGRAM     = 1,\n\n    /**\n     * Tell pj_stun_msg_decode() to check the validity of the STUN\n     * message by calling pj_stun_msg_check() before starting to\n     * decode the packet.\n     */\n    PJ_STUN_CHECK_PACKET    = 2,\n\n    /**\n     * This option current is only valid for #pj_stun_session_on_rx_pkt().\n     * When specified, it tells the session NOT to authenticate the\n     * message.\n     */\n    PJ_STUN_NO_AUTHENTICATE = 4,\n\n    /**\n     * Disable FINGERPRINT verification. This option can be used when calling\n     * #pj_stun_msg_check() and #pj_stun_msg_decode() to disable the \n     * verification of FINGERPRINT, for example when the STUN usage says when\n     * FINGERPRINT mechanism shall not be used.\n     */\n    PJ_STUN_NO_FINGERPRINT_CHECK = 8\n};\n\n\n/**\n * Get STUN message method name.\n *\n * @param msg_type      The STUN message type (in host byte order)\n *\n * @return              The STUN message method name string.\n */\nPJ_DECL(const char*) pj_stun_get_method_name(unsigned msg_type);\n\n\n/**\n * Get STUN message class name.\n *\n * @param msg_type      The STUN message type (in host byte order)\n *\n * @return              The STUN message class name string.\n */\nPJ_DECL(const char*) pj_stun_get_class_name(unsigned msg_type);\n\n\n/**\n * Get STUN attribute name.\n *\n * @return attr_type    The STUN attribute type (in host byte order).\n *\n * @return              The STUN attribute type name string.\n */\nPJ_DECL(const char*) pj_stun_get_attr_name(unsigned attr_type);\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n *\n * @param err_code      The STUN error code.\n *\n * @return              The STUN error reason phrase.\n */\nPJ_DECL(pj_str_t) pj_stun_get_err_reason(int err_code);\n\n\n/**\n * Internal: set the padding character for string attribute.\n * The default padding character is PJ_STUN_STRING_ATTR_PAD_CHR.\n *\n * @return              The previous padding character.\n */\nPJ_DECL(int) pj_stun_set_padding_char(int chr);\n\n\n/**\n * Initialize a generic STUN message.\n *\n * @param msg           The message structure to be initialized.\n * @param msg_type      The 14bit message type (see pj_stun_msg_type \n *                      constants).\n * @param magic         Magic value to be put to the mesage; for requests,\n *                      the value normally should be PJ_STUN_MAGIC.\n * @param tsx_id        Optional transaction ID, or NULL to let the\n *                      function generates a random transaction ID.\n *\n * @return              PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_init(pj_stun_msg *msg,\n                                      unsigned msg_type,\n                                      pj_uint32_t magic,\n                                      const pj_uint8_t tsx_id[12]);\n\n/**\n * Create a generic STUN message.\n *\n * @param pool          Pool to create the STUN message.\n * @param msg_type      The 14bit message type.\n * @param magic         Magic value to be put to the mesage; for requests,\n *                      the value should be PJ_STUN_MAGIC.\n * @param tsx_id        Optional transaction ID, or NULL to let the\n *                      function generates a random transaction ID.\n * @param p_msg         Pointer to receive the message.\n *\n * @return              PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_create(pj_pool_t *pool,\n                                        unsigned msg_type,\n                                        pj_uint32_t magic,\n                                        const pj_uint8_t tsx_id[12],\n                                        pj_stun_msg **p_msg);\n\n/**\n * Clone a STUN message with all of its attributes.\n *\n * @param pool          Pool to allocate memory for the new message.\n * @param msg           The message to be cloned.\n *\n * @return              The duplicate message.\n */\nPJ_DECL(pj_stun_msg*) pj_stun_msg_clone(pj_pool_t *pool,\n                                        const pj_stun_msg *msg);\n\n/**\n * Create STUN response message. \n *\n * @param pool          Pool to create the mesage.\n * @param req_msg       The request message.\n * @param err_code      STUN error code. If this value is not zero,\n *                      then error response will be created, otherwise\n *                      successful response will be created.\n * @param err_msg       Optional error message to explain err_code.\n *                      If this value is NULL and err_code is not zero,\n *                      the error string will be taken from the default\n *                      STUN error message.\n * @param p_response    Pointer to receive the response.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n                                                 const pj_stun_msg *req_msg,\n                                                 unsigned err_code,\n                                                 const pj_str_t *err_msg,\n                                                 pj_stun_msg **p_response);\n\n\n/**\n * Add STUN attribute to STUN message.\n *\n * @param msg           The STUN message.\n * @param attr          The STUN attribute to be added to the message.\n *\n * @return              PJ_SUCCESS on success, or PJ_ETOOMANY if there are\n *                      already too many attributes in the message.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n                                          pj_stun_attr_hdr *attr);\n\n\n/**\n * Print the STUN message structure to a packet buffer, ready to be \n * sent to remote destination. This function will take care about \n * calculating the MESSAGE-INTEGRITY digest as well as FINGERPRINT\n * value, if these attributes are present in the message.\n *\n * If application wants to apply credential to the message, it MUST\n * include a blank MESSAGE-INTEGRITY attribute in the message as the\n * last attribute or the attribute before FINGERPRINT. This function will\n * calculate the HMAC digest from the message using  the supplied key in\n * the parameter. The key should be set to the password if short term \n * credential is used, or calculated from the MD5 hash of the realm, \n * username, and password using #pj_stun_create_key() if long term \n * credential is used.\n *\n * If FINGERPRINT attribute is present, this function will calculate\n * the FINGERPRINT CRC attribute for the message. The FINGERPRINT MUST\n * be added as the last attribute of the message.\n *\n * @param msg           The STUN message to be printed. Upon return,\n *                      some fields in the header (such as message\n *                      length) will be updated.\n * @param pkt_buf       The buffer to be filled with the packet.\n * @param buf_size      Size of the buffer.\n * @param options       Options, which currently must be zero.\n * @param key           Authentication key to calculate MESSAGE-INTEGRITY\n *                      value. Application can create this key by using\n *                      #pj_stun_create_key() function.\n * @param p_msg_len     Upon return, it will be filed with the size of \n *                      the packet in bytes, or negative value on error.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n                                        pj_uint8_t *pkt_buf,\n                                        pj_size_t buf_size,\n                                        unsigned options,\n                                        const pj_str_t *key,\n                                        pj_size_t *p_msg_len);\n\n/**\n * Check that the PDU is potentially a valid STUN message. This function\n * is useful when application needs to multiplex STUN packets with other\n * application traffic. When this function returns PJ_SUCCESS, there is a\n * big chance that the packet is a STUN packet.\n *\n * Note that we cannot be sure that the PDU is a really valid STUN message \n * until we actually parse the PDU.\n *\n * @param pdu           The packet buffer.\n * @param pdu_len       The length of the packet buffer.\n * @param options       Additional options to be applied in the checking,\n *                      which can be taken from pj_stun_decode_options. One \n *                      of the useful option is PJ_STUN_IS_DATAGRAM which \n *                      means that the pdu represents a whole STUN packet.\n *\n * @return              PJ_SUCCESS if the PDU is a potentially valid STUN\n *                      message.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, \n                                       pj_size_t pdu_len, unsigned options);\n\n\n/**\n * Decode incoming packet into STUN message.\n *\n * @param pool          Pool to allocate the message.\n * @param pdu           The incoming packet to be parsed.\n * @param pdu_len       The length of the incoming packet.\n * @param options       Parsing flags, according to pj_stun_decode_options.\n * @param p_msg         Pointer to receive the parsed message.\n * @param p_parsed_len  Optional pointer to receive how many bytes have\n *                      been parsed for the STUN message. This is useful\n *                      when the packet is received over stream oriented\n *                      transport.\n * @param p_response    Optional pointer to receive an instance of response\n *                      message, if one can be created. If the packet being\n *                      decoded is a request message, and it contains error,\n *                      and a response can be created, then the STUN \n *                      response message will be returned on this argument.\n *\n * @return              PJ_SUCCESS if a STUN message has been successfully\n *                      decoded.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                        const pj_uint8_t *pdu,\n                                        pj_size_t pdu_len,\n                                        unsigned options,\n                                        pj_stun_msg **p_msg,\n                                        pj_size_t *p_parsed_len,\n                                        pj_stun_msg **p_response);\n\n/**\n * Dump STUN message to a printable string output.\n *\n * @param msg           The STUN message\n * @param buffer        Buffer where the printable string output will\n *                      be printed on.\n * @param length        Specify the maximum length of the buffer.\n * @param printed_len   Optional pointer, which on output will be filled\n *                      up with the actual length of the output string.\n *\n * @return              The message string output.\n */\n#if PJ_LOG_MAX_LEVEL > 0\nPJ_DECL(char*) pj_stun_msg_dump(const pj_stun_msg *msg,\n                                char *buffer,\n                                unsigned length,\n                                unsigned *printed_len);\n#else\n#   define pj_stun_msg_dump(msg, buf, length, printed_len)  \"\"\n#endif\n\n\n/**\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n *\n * @param msg           The STUN message.\n * @param attr_type     The attribute type to be found, from pj_stun_attr_type.\n * @param start_index   The start index of the attribute in the message.\n *                      Specify zero to start searching from the first\n *                      attribute.\n *\n * @return              The attribute instance, or NULL if it cannot be\n *                      found.\n */\nPJ_DECL(pj_stun_attr_hdr*) pj_stun_msg_find_attr(const pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 unsigned start_index);\n\n\n/**\n * Clone a STUN attribute.\n *\n * @param pool          Pool to allocate memory.\n * @param attr          Attribute to clone.\n *\n * @return              Duplicate attribute.\n */\nPJ_DECL(pj_stun_attr_hdr*) pj_stun_attr_clone(pj_pool_t *pool,\n                                              const pj_stun_attr_hdr *attr);\n\n\n/**\n * Initialize generic STUN IP address attribute. The \\a addr_len and\n * \\a addr parameters specify whether the address is IPv4 or IPv4\n * address.\n *\n * @param attr          The socket address attribute to initialize.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param xor_ed        If non-zero, the port and address will be XOR-ed\n *                      with magic, to make the XOR-MAPPED-ADDRESS attribute.\n * @param addr          A pj_sockaddr_in or pj_sockaddr_in6 structure.\n * @param addr_len      Length of \\a addr parameter.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_sockaddr_attr_init(pj_stun_sockaddr_attr *attr,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len);\n\n/**\n * Create a generic STUN IP address attribute. The \\a addr_len and\n * \\a addr parameters specify whether the address is IPv4 or IPv4\n * address.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param xor_ed        If non-zero, the port and address will be XOR-ed\n *                      with magic, to make the XOR-MAPPED-ADDRESS attribute.\n * @param addr          A pj_sockaddr_in or pj_sockaddr_in6 structure.\n * @param addr_len      Length of \\a addr parameter.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len,\n                                                pj_stun_sockaddr_attr **p_attr);\n\n\n/**\n * Create and add generic STUN IP address attribute to a STUN message.\n * The \\a addr_len and \\a addr parameters specify whether the address is \n * IPv4 or IPv4 address.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param xor_ed        If non-zero, the port and address will be XOR-ed\n *                      with magic, to make the XOR-MAPPED-ADDRESS attribute.\n * @param addr          A pj_sockaddr_in or pj_sockaddr_in6 structure.\n * @param addr_len      Length of \\a addr parameter.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type, \n                                                  pj_bool_t xor_ed,\n                                                  const pj_sockaddr_t *addr,\n                                                  unsigned addr_len);\n\n/**\n * Initialize a STUN generic string attribute.\n *\n * @param attr          The string attribute to be initialized.\n * @param pool          Pool to duplicate the value into the attribute,\n *                      if value is not NULL or empty.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The string value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_string_attr_init(pj_stun_string_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_str_t *value);\n\n/**\n * Create a STUN generic string attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The string value to be assigned to the attribute.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n                                                int attr_type,\n                                                const pj_str_t *value,\n                                                pj_stun_string_attr **p_attr);\n\n/**\n * Create and add STUN generic string attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The string value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_str_t *value);\n\n/**\n * Create a STUN generic 32bit value attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The 32bit value to be assigned to the attribute.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n                                              int attr_type,\n                                              pj_uint32_t value,\n                                              pj_stun_uint_attr **p_attr);\n\n/**\n * Create and add STUN generic 32bit value attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The 32bit value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n                                               pj_stun_msg *msg,\n                                               int attr_type,\n                                               pj_uint32_t value);\n\n\n/**\n * Create a STUN generic 64bit value attribute.\n *\n * @param pool          Pool to allocate memory from.\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         Optional value to be assigned.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t)  pj_stun_uint64_attr_create(pj_pool_t *pool,\n                                                int attr_type,\n                                                const pj_timestamp *value,\n                                                pj_stun_uint64_attr **p_attr);\n\n\n/**\n *  Create and add STUN generic 64bit value attribute to the message. \n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message\n * @param attr_type     Attribute type, from #pj_stun_attr_type.\n * @param value         The 64bit value to be assigned to the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type,\n                                                  const pj_timestamp *value);\n\n/**\n * Create a STUN MESSAGE-INTEGRITY attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n                                                pj_stun_msgint_attr **p_attr);\n\n/** \n * Create and add STUN MESSAGE-INTEGRITY attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg);\n\n/**\n * Create a STUN ERROR-CODE attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param err_code      STUN error code.\n * @param err_reason    Optional STUN error reason. If NULL is given, the\n *                      standard error reason will be given.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n                                                int err_code,\n                                                const pj_str_t *err_reason,\n                                                pj_stun_errcode_attr **p_attr);\n\n\n/**\n * Create and add STUN ERROR-CODE attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN mesage.\n * @param err_code      STUN error code.\n * @param err_reason    Optional STUN error reason. If NULL is given, the\n *                      standard error reason will be given.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int err_code,\n                                                  const pj_str_t *err_reason);\n\n/**\n * Create instance of STUN UNKNOWN-ATTRIBUTES attribute and copy the\n * unknown attribute array to the attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_cnt      Number of attributes in the array (can be zero).\n * @param attr          Optional array of attributes.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n                                                unsigned attr_cnt,\n                                                const pj_uint16_t attr[],\n                                                pj_stun_unknown_attr **p_attr);\n\n/**\n * Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_cnt      Number of attributes in the array (can be zero).\n * @param attr          Optional array of attribute types.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  unsigned attr_cnt,\n                                                  const pj_uint16_t attr[]);\n\n/**\n * Initialize STUN binary attribute.\n *\n * @param attr          The attribute to be initialized.\n * @param pool          Pool to copy data, if the data and length are set.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param data          Data to be coped to the attribute, or NULL\n *                      if no data to be copied now.\n * @param length        Length of data, or zero if no data is to be\n *                      copied now.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_binary_attr_init(pj_stun_binary_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_uint8_t *data,\n                                              unsigned length);\n\n/**\n * Create STUN binary attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param data          Data to be coped to the attribute, or NULL\n *                      if no data to be copied now.\n * @param length        Length of data, or zero if no data is to be\n *                      copied now.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n                                                int attr_type,\n                                                const pj_uint8_t *data,\n                                                unsigned length,\n                                                pj_stun_binary_attr **p_attr);\n\n/**\n * Create STUN binary attribute and add the attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param data          Data to be coped to the attribute, or NULL\n *                      if no data to be copied now.\n * @param length        Length of data, or zero if no data is to be\n *                      copied now.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_uint8_t *data,\n                                                 unsigned length);\n\n/**\n * Create STUN empty attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               pj_stun_empty_attr **p_attr);\n\n/**\n * Create STUN empty attribute and add the attribute to the message.\n *\n * @param pool          The pool to allocate memory from.\n * @param msg           The STUN message.\n * @param attr_type     The attribute type, from #pj_stun_attr_type.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pj_stun_msg_add_empty_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type);\n\n/**\n * @}\n */\n\n\nPJ_END_DECL\n\n\n#endif  /* __PJNATH_STUN_MSG_H__ */\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjnath/stun_msg.h>\n#include <pjnath/errno.h>\n#include <pjlib-util/crc32.h>\n#include <pjlib-util/hmac_sha1.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n#define THIS_FILE               \"stun_msg.c\"\n#define STUN_XOR_FINGERPRINT    0x5354554eL\n\nstatic int padding_char;\n\nstatic const char *stun_method_names[PJ_STUN_METHOD_MAX] = \n{\n    \"Unknown\",                  /* 0 */\n    \"Binding\",                  /* 1 */\n    \"SharedSecret\",             /* 2 */\n    \"Allocate\",                 /* 3 */\n    \"Refresh\",                  /* 4 */\n    \"???\",                      /* 5 */\n    \"Send\",                     /* 6 */\n    \"Data\",                     /* 7 */\n    \"CreatePermission\",         /* 8 */\n    \"ChannelBind\",              /* 9 */\n    \"Connect\",                  /* 10 */\n    \"ConnectionBind\",           /* 11 */\n    \"ConnectionAttempt\",        /* 12 */\n};\n\nstatic struct\n{\n    int err_code;\n    const char *err_msg;\n} stun_err_msg_map[] = \n{\n    { PJ_STUN_SC_TRY_ALTERNATE,             \"Try Alternate\"}, \n    { PJ_STUN_SC_BAD_REQUEST,               \"Bad Request\"},\n    { PJ_STUN_SC_UNAUTHORIZED,              \"Unauthorized\"},\n    { PJ_STUN_SC_FORBIDDEN,                 \"Forbidden\"},\n    { PJ_STUN_SC_UNKNOWN_ATTRIBUTE,         \"Unknown Attribute\"},\n    //{ PJ_STUN_SC_STALE_CREDENTIALS,       \"Stale Credentials\"},\n    //{ PJ_STUN_SC_INTEGRITY_CHECK_FAILURE, \"Integrity Check Failure\"},\n    //{ PJ_STUN_SC_MISSING_USERNAME,        \"Missing Username\"},\n    //{ PJ_STUN_SC_USE_TLS,                 \"Use TLS\"},\n    //{ PJ_STUN_SC_MISSING_REALM,           \"Missing Realm\"},\n    //{ PJ_STUN_SC_MISSING_NONCE,           \"Missing Nonce\"},\n    //{ PJ_STUN_SC_UNKNOWN_USERNAME,        \"Unknown Username\"},\n    { PJ_STUN_SC_ALLOCATION_MISMATCH,       \"Allocation Mismatch\"},\n    { PJ_STUN_SC_STALE_NONCE,               \"Stale Nonce\"},\n    { PJ_STUN_SC_TRANSITIONING,             \"Active Destination Already Set\"},\n    { PJ_STUN_SC_WRONG_CREDENTIALS,         \"Wrong Credentials\"},\n    { PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO,    \"Unsupported Transport Protocol\"},\n    { PJ_STUN_SC_OPER_TCP_ONLY,             \"Operation for TCP Only\"},\n    { PJ_STUN_SC_CONNECTION_FAILURE,        \"Connection Failure\"},\n    { PJ_STUN_SC_CONNECTION_TIMEOUT,        \"Connection Timeout\"},\n    { PJ_STUN_SC_ALLOCATION_QUOTA_REACHED,  \"Allocation Quota Reached\"},\n    { PJ_STUN_SC_ROLE_CONFLICT,             \"Role Conflict\"},\n    { PJ_STUN_SC_SERVER_ERROR,              \"Server Error\"},\n    { PJ_STUN_SC_INSUFFICIENT_CAPACITY,     \"Insufficient Capacity\"},\n    { PJ_STUN_SC_GLOBAL_FAILURE,            \"Global Failure\"}\n};\n\n\n\nstruct attr_desc\n{\n    const char   *name;\n    pj_status_t (*decode_attr)(pj_pool_t *pool, const pj_uint8_t *buf, \n                               const pj_stun_msg_hdr *msghdr, void **p_attr);\n    pj_status_t (*encode_attr)(const void *a, pj_uint8_t *buf, \n                               unsigned len, const pj_stun_msg_hdr *msghdr,\n                               unsigned *printed);\n    void*       (*clone_attr)(pj_pool_t *pool, const void *src);\n};\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        void **p_attr);\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr);\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed);\nstatic void*       clone_sockaddr_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_string_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_msgint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_errcode_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr);\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed);\nstatic void*       clone_unknown_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr);\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed);\nstatic void*       clone_uint_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_uint64_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr);\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed);\nstatic void*       clone_binary_attr(pj_pool_t *pool, const void *src);\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr, \n                                     void **p_attr);\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed);\nstatic void*       clone_empty_attr(pj_pool_t *pool, const void *src);\n\nstatic struct attr_desc mandatory_attr_desc[] = \n{\n    {\n        /* type zero */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAPPED_ADDR, */\n        \"MAPPED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESPONSE_ADDR, */\n        \"RESPONSE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGE_REQUEST, */\n        \"CHANGE-REQUEST\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_SOURCE_ADDR, */\n        \"SOURCE-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANGED_ADDR, */\n        \"CHANGED-ADDRESS\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USERNAME, */\n        \"USERNAME\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PASSWORD, */\n        \"PASSWORD\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_MESSAGE_INTEGRITY, */\n        \"MESSAGE-INTEGRITY\",\n        &decode_msgint_attr,\n        &encode_msgint_attr,\n        &clone_msgint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ERROR_CODE, */\n        \"ERROR-CODE\",\n        &decode_errcode_attr,\n        &encode_errcode_attr,\n        &clone_errcode_attr\n    },\n    {\n        /* PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, */\n        \"UNKNOWN-ATTRIBUTES\",\n        &decode_unknown_attr,\n        &encode_unknown_attr,\n        &clone_unknown_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFLECTED_FROM, */\n        \"REFLECTED-FROM\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_CHANNEL_NUMBER (0x000C) */\n        \"CHANNEL-NUMBER\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_LIFETIME, */\n        \"LIFETIME\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x000E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_MAGIC_COOKIE */\n        \"MAGIC-COOKIE\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_BANDWIDTH, */\n        \"BANDWIDTH\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x0011 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_PEER_ADDRESS, */\n        \"XOR-PEER-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DATA, */\n        \"DATA\",\n        &decode_binary_attr,\n        &encode_binary_attr,\n        &clone_binary_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REALM, */\n        \"REALM\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_NONCE, */\n        \"NONCE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_RELAYED_ADDR, */\n        \"XOR-RELAYED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_ADDR_FAMILY, */\n        \"REQUESTED-ADDRESS-FAMILY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_EVEN_PORT, */\n        \"EVEN-PORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REQUESTED_TRANSPORT, */\n        \"REQUESTED-TRANSPORT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_DONT_FRAGMENT */\n        \"DONT-FRAGMENT\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x001B is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001C is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001D is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001E is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x001F is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_MAPPED_ADDRESS, */\n        \"XOR-MAPPED-ADDRESS\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_TIMER_VAL, */\n        \"TIMER-VAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_RESERVATION_TOKEN, */\n        \"RESERVATION-TOKEN\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_XOR_REFLECTED_FROM, */\n        \"XOR-REFLECTED-FROM\",\n        &decode_xored_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_PRIORITY, */\n        \"PRIORITY\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_USE_CANDIDATE, */\n        \"USE-CANDIDATE\",\n        &decode_empty_attr,\n        &encode_empty_attr,\n        &clone_empty_attr\n    },\n    {\n        /* ID 0x0026 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0027 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0028 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x0029 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_CONNECTION_ID, */\n        \"CONNECTION-ID\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x002b is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002c is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002d is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002e is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* ID 0x002f is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_ICMP, */\n        \"ICMP\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n\n    /* Sentinel */\n    {\n        /* PJ_STUN_ATTR_END_MANDATORY_ATTR */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    }\n};\n\nstatic struct attr_desc extended_attr_desc[] =\n{\n    {\n        /* ID 0x8021 is not assigned */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_SOFTWARE, */\n        \"SOFTWARE\",\n        &decode_string_attr,\n        &encode_string_attr,\n        &clone_string_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ALTERNATE_SERVER, */\n        \"ALTERNATE-SERVER\",\n        &decode_sockaddr_attr,\n        &encode_sockaddr_attr,\n        &clone_sockaddr_attr\n    },\n    {\n        /* PJ_STUN_ATTR_REFRESH_INTERVAL, */\n        \"REFRESH-INTERVAL\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* ID 0x8025 is not assigned*/\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PADDING, 0x8026 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* CACHE-TIMEOUT, 0x8027 */\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    },\n    {\n        /* PJ_STUN_ATTR_FINGERPRINT, */\n        \"FINGERPRINT\",\n        &decode_uint_attr,\n        &encode_uint_attr,\n        &clone_uint_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLED, */\n        \"ICE-CONTROLLED\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    },\n    {\n        /* PJ_STUN_ATTR_ICE_CONTROLLING, */\n        \"ICE-CONTROLLING\",\n        &decode_uint64_attr,\n        &encode_uint64_attr,\n        &clone_uint64_attr\n    }\n};\n\n\n\n/*\n * Get STUN message type name.\n */\nPJ_DEF(const char*) pj_stun_get_method_name(unsigned msg_type)\n{\n    unsigned method = PJ_STUN_GET_METHOD(msg_type);\n\n    if (method >= PJ_ARRAY_SIZE(stun_method_names))\n        return \"???\";\n\n    return stun_method_names[method];\n}\n\n\n/*\n * Get STUN message class name.\n */\nPJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type)\n{\n    if (PJ_STUN_IS_REQUEST(msg_type))\n        return \"request\";\n    else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type))\n        return \"success response\";\n    else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type))\n        return \"error response\";\n    else if (PJ_STUN_IS_INDICATION(msg_type))\n        return \"indication\";\n    else\n        return \"???\";\n}\n\n\nstatic const struct attr_desc *find_attr_desc(unsigned attr_type)\n{\n    struct attr_desc *desc;\n\n    /* Check that attr_desc array is valid */\n    pj_assert(PJ_ARRAY_SIZE(mandatory_attr_desc)==\n              PJ_STUN_ATTR_END_MANDATORY_ATTR+1);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_END_MANDATORY_ATTR].decode_attr\n              == NULL);\n    pj_assert(mandatory_attr_desc[PJ_STUN_ATTR_USE_CANDIDATE].decode_attr \n              == &decode_empty_attr);\n    pj_assert(PJ_ARRAY_SIZE(extended_attr_desc) ==\n              PJ_STUN_ATTR_END_EXTENDED_ATTR-PJ_STUN_ATTR_START_EXTENDED_ATTR);\n\n    if (attr_type < PJ_STUN_ATTR_END_MANDATORY_ATTR)\n        desc = &mandatory_attr_desc[attr_type];\n    else if (attr_type >= PJ_STUN_ATTR_START_EXTENDED_ATTR &&\n             attr_type < PJ_STUN_ATTR_END_EXTENDED_ATTR)\n        desc = &extended_attr_desc[attr_type-PJ_STUN_ATTR_START_EXTENDED_ATTR];\n    else\n        return NULL;\n\n    return desc->decode_attr == NULL ? NULL : desc;\n}\n\n\n/*\n * Get STUN attribute name.\n */\nPJ_DEF(const char*) pj_stun_get_attr_name(unsigned attr_type)\n{\n    const struct attr_desc *attr_desc;\n\n    attr_desc = find_attr_desc(attr_type);\n    if (!attr_desc || attr_desc->name==NULL)\n        return \"???\";\n\n    return attr_desc->name;\n}\n\n\n/**\n * Get STUN standard reason phrase for the specified error code.\n */\nPJ_DEF(pj_str_t) pj_stun_get_err_reason(int err_code)\n{\n#if 0\n    /* Find error using linear search */\n    unsigned i;\n\n    for (i=0; i<PJ_ARRAY_SIZE(stun_err_msg_map); ++i) {\n        if (stun_err_msg_map[i].err_code == err_code)\n            return pj_str((char*)stun_err_msg_map[i].err_msg);\n    }\n    return pj_str(NULL);\n#else\n    /* Find error message using binary search */\n    int first = 0;\n    int n = PJ_ARRAY_SIZE(stun_err_msg_map);\n\n    while (n > 0) {\n        int half = n/2;\n        int mid = first + half;\n\n        if (stun_err_msg_map[mid].err_code < err_code) {\n            first = mid+1;\n            n -= (half+1);\n        } else if (stun_err_msg_map[mid].err_code > err_code) {\n            n = half;\n        } else {\n            first = mid;\n            break;\n        }\n    }\n\n\n    if (stun_err_msg_map[first].err_code == err_code) {\n        return pj_str((char*)stun_err_msg_map[first].err_msg);\n    } else {\n        return pj_str(NULL);\n    }\n#endif\n}\n\n\n/*\n * Set padding character.\n */\nPJ_DEF(int) pj_stun_set_padding_char(int chr)\n{\n    int old_pad = padding_char;\n    padding_char = chr;\n    return old_pad;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n\n#define INIT_ATTR(a,t,l)    (a)->hdr.type=(pj_uint16_t)(t), \\\n                            (a)->hdr.length=(pj_uint16_t)(l)\n#define ATTR_HDR_LEN        sizeof(pj_stun_attr_hdr)\n\nstatic pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint16_t) ((buf[pos + 0] << 8) | \\\n                          (buf[pos + 1] << 0));\n}\n\n/*unused PJ_INLINE(pj_uint16_t) GETVAL16N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htons(GETVAL16H(buf,pos));\n}*/\n\nstatic void PUTVAL16H(pj_uint8_t *buf, unsigned pos, pj_uint16_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF00) >> 8);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF) >> 0);\n}\n\nPJ_INLINE(pj_uint32_t) GETVAL32H(const pj_uint8_t *buf, unsigned pos)\n{\n    return (pj_uint32_t) ((buf[pos + 0] << 24UL) | \\\n                          (buf[pos + 1] << 16UL) | \\\n                          (buf[pos + 2] <<  8UL) | \\\n                          (buf[pos + 3] <<  0UL));\n}\n\n/*unused PJ_INLINE(pj_uint32_t) GETVAL32N(const pj_uint8_t *buf, unsigned pos)\n{\n    return pj_htonl(GETVAL32H(buf,pos));\n}*/\n\nstatic void PUTVAL32H(pj_uint8_t *buf, unsigned pos, pj_uint32_t hval)\n{\n    buf[pos+0] = (pj_uint8_t) ((hval & 0xFF000000UL) >> 24);\n    buf[pos+1] = (pj_uint8_t) ((hval & 0x00FF0000UL) >> 16);\n    buf[pos+2] = (pj_uint8_t) ((hval & 0x0000FF00UL) >>  8);\n    buf[pos+3] = (pj_uint8_t) ((hval & 0x000000FFUL) >>  0);\n}\n\nstatic void GETVAL64H(const pj_uint8_t *buf, unsigned pos, pj_timestamp *ts)\n{\n    ts->u32.hi = GETVAL32H(buf, pos);\n    ts->u32.lo = GETVAL32H(buf, pos+4);\n}\n\nstatic void PUTVAL64H(pj_uint8_t *buf, unsigned pos, const pj_timestamp *ts)\n{\n    PUTVAL32H(buf, pos, ts->u32.hi);\n    PUTVAL32H(buf, pos+4, ts->u32.lo);\n}\n\n\nstatic void GETATTRHDR(const pj_uint8_t *buf, pj_stun_attr_hdr *hdr)\n{\n    hdr->type = GETVAL16H(buf, 0);\n    hdr->length = GETVAL16H(buf, 2);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic IP address container\n */\n#define STUN_GENERIC_IPV4_ADDR_LEN      8\n#define STUN_GENERIC_IPV6_ADDR_LEN      20\n\n/*\n * Init sockaddr attr\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_init( pj_stun_sockaddr_attr *attr,\n                                                int attr_type, \n                                                pj_bool_t xor_ed,\n                                                const pj_sockaddr_t *addr,\n                                                unsigned addr_len)\n{\n    unsigned attr_len;\n\n    PJ_ASSERT_RETURN(attr && addr_len && addr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(addr_len == sizeof(pj_sockaddr_in) ||\n                     addr_len == sizeof(pj_sockaddr_in6), PJ_EINVAL);\n\n    attr_len = pj_sockaddr_get_addr_len(addr) + 4;\n    INIT_ATTR(attr, attr_type, attr_len);\n\n    pj_memcpy(&attr->sockaddr, addr, addr_len);\n    attr->xor_ed = xor_ed;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a generic STUN IP address attribute for IPv4 address.\n */\nPJ_DEF(pj_status_t) pj_stun_sockaddr_attr_create(pj_pool_t *pool,\n                                                 int attr_type,\n                                                 pj_bool_t xor_ed,\n                                                 const pj_sockaddr_t *addr,\n                                                 unsigned addr_len,\n                                                 pj_stun_sockaddr_attr **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    *p_attr = attr;\n    return pj_stun_sockaddr_attr_init(attr, attr_type, xor_ed, \n                                      addr, addr_len);\n}\n\n\n/*\n * Create and add generic STUN IP address attribute to a STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_sockaddr_attr(pj_pool_t *pool,\n                                                  pj_stun_msg *msg,\n                                                  int attr_type, \n                                                  pj_bool_t xor_ed,\n                                                  const pj_sockaddr_t *addr,\n                                                  unsigned addr_len)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = pj_stun_sockaddr_attr_create(pool, attr_type, xor_ed,\n                                                 addr, addr_len, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_sockaddr_attr(pj_pool_t *pool, \n                                        const pj_uint8_t *buf, \n                                        const pj_stun_msg_hdr *msghdr, \n                                        void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    int af;\n    unsigned addr_len;\n    pj_uint32_t val;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_sockaddr_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN &&\n        attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n    {\n        return PJNATH_ESTUNINATTRLEN;\n    }\n\n    /* Check address family */\n    val = *(pj_uint8_t*)(buf + ATTR_HDR_LEN + 1);\n\n    /* Check address family is valid */\n    if (val == 1) {\n        if (attr->hdr.length != STUN_GENERIC_IPV4_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET();\n        addr_len = 4;\n    } else if (val == 2) {\n        if (attr->hdr.length != STUN_GENERIC_IPV6_ADDR_LEN)\n            return PJNATH_ESTUNINATTRLEN;\n        af = pj_AF_INET6();\n        addr_len = 16;\n    } else {\n        /* Invalid address family */\n        return PJNATH_EINVAF;\n    }\n\n    /* Get port and address */\n    pj_sockaddr_init(af, &attr->sockaddr, NULL, 0);\n    pj_sockaddr_set_port(&attr->sockaddr, \n                         GETVAL16H(buf, ATTR_HDR_LEN+2));\n    pj_memcpy(pj_sockaddr_get_addr(&attr->sockaddr),\n              buf+ATTR_HDR_LEN+4,\n              addr_len);\n\n    /* Done */\n    *p_attr = (void*)attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t decode_xored_sockaddr_attr(pj_pool_t *pool, \n                                              const pj_uint8_t *buf, \n                                              const pj_stun_msg_hdr *msghdr, \n                                              void **p_attr)\n{\n    pj_stun_sockaddr_attr *attr;\n    pj_status_t status;\n\n    status = decode_sockaddr_attr(pool, buf, msghdr, p_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    attr = *(pj_stun_sockaddr_attr**)p_attr;\n\n    attr->xor_ed = PJ_TRUE;\n\n    if (attr->sockaddr.addr.sa_family == pj_AF_INET()) {\n        attr->sockaddr.ipv4.sin_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n        attr->sockaddr.ipv4.sin_addr.s_addr ^= pj_htonl(PJ_STUN_MAGIC);\n    } else if (attr->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        unsigned i;\n        pj_uint8_t *dst = (pj_uint8_t*) &attr->sockaddr.ipv6.sin6_addr;\n        pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n\n        attr->sockaddr.ipv6.sin6_port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n\n        /* If the IP address family is IPv6, X-Address is computed by\n         * taking the mapped IP address in host byte order, XOR'ing it\n         * with the concatenation of the magic cookie and the 96-bit \n         * transaction ID, and converting the result to network byte \n         * order.\n         */\n        for (i=0; i<4; ++i) {\n            dst[i] ^= ((const pj_uint8_t*)&magic)[i];\n        }\n        pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n        for (i=0; i<12; ++i) {\n            dst[i+4] ^= msghdr->tsx_id[i];\n        }\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_sockaddr_attr(const void *a, pj_uint8_t *buf, \n                                        unsigned len, \n                                        const pj_stun_msg_hdr *msghdr,\n                                        unsigned *printed)\n{\n    pj_uint8_t *start_buf = buf;\n    const pj_stun_sockaddr_attr *ca = \n        (const pj_stun_sockaddr_attr *)a;\n\n    PJ_CHECK_STACK();\n    \n    /* Common: attribute type */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    if (ca->sockaddr.addr.sa_family == pj_AF_INET()) {\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV4_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV4_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 1 for IPv4 */\n        *buf++ = 1;\n\n        /* IPv4 address */\n        if (ca->xor_ed) {\n            pj_uint32_t addr;\n            pj_uint16_t port;\n\n            addr = ca->sockaddr.ipv4.sin_addr.s_addr;\n            port = ca->sockaddr.ipv4.sin_port;\n\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            addr ^= pj_htonl(PJ_STUN_MAGIC);\n\n            /* Port */\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &addr, 4);\n            buf += 4;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv4.sin_addr, 4);\n            buf += 4;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else if (ca->sockaddr.addr.sa_family == pj_AF_INET6()) {\n        /* IPv6 address */\n        enum {\n            ATTR_LEN = ATTR_HDR_LEN + STUN_GENERIC_IPV6_ADDR_LEN\n        };\n\n        if (len < ATTR_LEN) \n            return PJ_ETOOSMALL;\n\n        /* attribute len */\n        PUTVAL16H(buf, 2, STUN_GENERIC_IPV6_ADDR_LEN);\n        buf += ATTR_HDR_LEN;\n    \n        /* Ignored */\n        *buf++ = '\\0';\n\n        /* Address family, 2 for IPv6 */\n        *buf++ = 2;\n\n        /* IPv6 address */\n        if (ca->xor_ed) {\n            unsigned i;\n            pj_uint8_t *dst;\n            const pj_uint8_t *src;\n            pj_uint32_t magic = pj_htonl(PJ_STUN_MAGIC);\n            pj_uint16_t port = ca->sockaddr.ipv6.sin6_port;\n\n            /* Port */\n            port ^= pj_htons(PJ_STUN_MAGIC >> 16);\n            pj_memcpy(buf, &port, 2);\n            buf += 2;\n\n            /* Address */\n            dst = buf;\n            src = (const pj_uint8_t*) &ca->sockaddr.ipv6.sin6_addr;\n            for (i=0; i<4; ++i) {\n                dst[i] = (pj_uint8_t)(src[i] ^ ((const pj_uint8_t*)&magic)[i]);\n            }\n            pj_assert(sizeof(msghdr->tsx_id[0]) == 1);\n            for (i=0; i<12; ++i) {\n                dst[i+4] = (pj_uint8_t)(src[i+4] ^ msghdr->tsx_id[i]);\n            }\n\n            buf += 16;\n\n        } else {\n            /* Port */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_port, 2);\n            buf += 2;\n\n            /* Address */\n            pj_memcpy(buf, &ca->sockaddr.ipv6.sin6_addr, 16);\n            buf += 16;\n        }\n\n        pj_assert(buf - start_buf == ATTR_LEN);\n\n    } else {\n        return PJNATH_EINVAF;\n    }\n\n    /* Done */\n    *printed = (unsigned)(buf - start_buf);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_sockaddr_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_sockaddr_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_sockaddr_attr);\n    pj_memcpy(dst, src, sizeof(pj_stun_sockaddr_attr));\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic string attribute\n */\n\n/*\n * Initialize a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_init( pj_stun_string_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_str_t *value)\n{\n    if (value && value->slen) {\n        INIT_ATTR(attr, attr_type, value->slen);\n        attr->value.slen = value->slen;\n        pj_strdup(pool, &attr->value, value);\n    } else {\n        INIT_ATTR(attr, attr_type, 0);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a STUN generic string attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_string_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_str_t *value,\n                                               pj_stun_string_attr **p_attr)\n{\n    pj_stun_string_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && value && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    *p_attr = attr;\n\n    return pj_stun_string_attr_init(attr, pool, attr_type, value);\n}\n\n\n/*\n * Create and add STUN generic string attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_string_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_str_t *value)\n{\n    pj_stun_string_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_string_attr_create(pool, attr_type, value, \n                                                &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_string_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_string_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_string_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN);\n    value.slen = attr->hdr.length;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->value, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_string_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_string_attr *ca = \n        (const pj_stun_string_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = ((unsigned)ca->value.slen + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed) {\n        *printed = 0;\n        return PJ_ETOOSMALL;\n    }\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n\n    /* Special treatment for SOFTWARE attribute:\n     * This attribute had caused interop problem when talking to \n     * legacy RFC 3489 STUN servers, due to different \"length\"\n     * rules with RFC 5389.\n     */\n    if (msghdr->magic != PJ_STUN_MAGIC ||\n        ca->hdr.type == PJ_STUN_ATTR_SOFTWARE)\n    {\n        /* Set the length to be 4-bytes aligned so that we can\n         * communicate with RFC 3489 endpoints\n         */\n        PUTVAL16H(buf, 2, (pj_uint16_t)((ca->value.slen + 3) & (~3)));\n    } else {\n        /* Use RFC 5389 rule */\n        PUTVAL16H(buf, 2, (pj_uint16_t)ca->value.slen);\n    }\n\n    /* Copy the string */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->value.ptr, ca->value.slen);\n\n    /* Add padding character, if string is not 4-bytes aligned. */\n    if (ca->value.slen & 0x03) {\n        pj_uint8_t pad[3];\n        pj_memset(pad, padding_char, sizeof(pad));\n        pj_memcpy(buf+ATTR_HDR_LEN+ca->value.slen, pad,\n                  4-(ca->value.slen & 0x03));\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_string_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_string_attr *asrc = (const pj_stun_string_attr*)src;\n    pj_stun_string_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_string_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_attr_hdr));\n    pj_strdup(pool, &dst->value, &asrc->value);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN empty attribute (used by USE-CANDIDATE).\n */\n\n/*\n * Create a STUN empty attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_empty_attr_create(pj_pool_t *pool,\n                                              int attr_type,\n                                              pj_stun_empty_attr **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    INIT_ATTR(attr, attr_type, 0);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create STUN empty attribute and add the attribute to the message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_empty_attr( pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type)\n{\n    pj_stun_empty_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_empty_attr_create(pool, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_empty_attr(pj_pool_t *pool, \n                                     const pj_uint8_t *buf, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     void **p_attr)\n{\n    pj_stun_empty_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that the struct address is valid */\n    pj_assert(sizeof(pj_stun_empty_attr) == ATTR_HDR_LEN);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_empty_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 0)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_empty_attr(const void *a, pj_uint8_t *buf, \n                                     unsigned len, \n                                     const pj_stun_msg_hdr *msghdr,\n                                     unsigned *printed)\n{\n    const pj_stun_empty_attr *ca = (pj_stun_empty_attr*)a;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, 0);\n\n    /* Done */\n    *printed = ATTR_HDR_LEN;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_empty_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_empty_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_empty_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_empty_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic 32bit integer attribute.\n */\n\n/*\n * Create a STUN generic 32bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint_attr_create(pj_pool_t *pool,\n                                             int attr_type,\n                                             pj_uint32_t value,\n                                             pj_stun_uint_attr **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    INIT_ATTR(attr, attr_type, 4);\n    attr->value = value;\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 32bit value attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_uint_attr(pj_pool_t *pool,\n                                              pj_stun_msg *msg,\n                                              int attr_type,\n                                              pj_uint32_t value)\n{\n    pj_stun_uint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint_attr(const void *a, pj_uint8_t *buf, \n                                    unsigned len, \n                                    const pj_stun_msg_hdr *msghdr,\n                                    unsigned *printed)\n{\n    const pj_stun_uint_attr *ca = (const pj_stun_uint_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 8) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)4);\n    PUTVAL32H(buf, 4, ca->value);\n    \n    /* Done */\n    *printed = 8;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint_attr));\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Create a STUN generic 64bit value attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_uint64_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_timestamp *value,\n                                               pj_stun_uint64_attr **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    INIT_ATTR(attr, attr_type, 8);\n\n    if (value) {\n        attr->value.u32.hi = value->u32.hi;\n        attr->value.u32.lo = value->u32.lo;\n    }\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n/* Create and add STUN generic 64bit value attribute to the message. */\nPJ_DEF(pj_status_t)  pj_stun_msg_add_uint64_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 const pj_timestamp *value)\n{\n    pj_stun_uint64_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_uint64_attr_create(pool, attr_type, value, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_uint64_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf, \n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_uint64_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint64_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    if (attr->hdr.length != 8)\n        return PJNATH_ESTUNINATTRLEN;\n\n    GETVAL64H(buf, 4, &attr->value);    \n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_uint64_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_uint64_attr *ca = (const pj_stun_uint64_attr*)a;\n\n    PJ_CHECK_STACK();\n\n    PJ_UNUSED_ARG(msghdr);\n    \n    if (len < 12) \n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)8);\n    PUTVAL64H(buf, 4, &ca->value);\n\n    /* Done */\n    *printed = 12;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_uint64_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_uint64_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_uint64_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_uint64_attr));\n\n    return (void*)dst;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN MESSAGE-INTEGRITY attribute.\n */\n\n/*\n * Create a STUN MESSAGE-INTEGRITY attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_msgint_attr_create(pj_pool_t *pool,\n                                               pj_stun_msgint_attr **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_MESSAGE_INTEGRITY, 20);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_msgint_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg)\n{\n    pj_stun_msgint_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_msgint_attr_create(pool, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_msgint_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr, \n                                      void **p_attr)\n{\n    pj_stun_msgint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_msgint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 20)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Copy hmac */\n    pj_memcpy(attr->hmac, buf+4, 20);\n\n    /* Done */\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_msgint_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_msgint_attr *ca = (const pj_stun_msgint_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < 24) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, ca->hdr.length);\n\n    pj_memcpy(buf+4, ca->hmac, 20);\n\n    /* Done */\n    *printed = 24;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_msgint_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_msgint_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_msgint_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_msgint_attr));\n\n    return (void*) dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN ERROR-CODE\n */\n\n/*\n * Create a STUN ERROR-CODE attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_errcode_attr_create(pj_pool_t *pool,\n                                                int err_code,\n                                                const pj_str_t *err_reason,\n                                                pj_stun_errcode_attr **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    char err_buf[80];\n    pj_str_t str;\n\n    PJ_ASSERT_RETURN(pool && err_code && p_attr, PJ_EINVAL);\n\n    if (err_reason == NULL) {\n        str = pj_stun_get_err_reason(err_code);\n        if (str.slen == 0) {\n            str.slen = pj_ansi_snprintf(err_buf, sizeof(err_buf),\n                                        \"Unknown error %d\", err_code);\n            str.ptr = err_buf;\n        }\n        err_reason = &str;\n    }\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_ERROR_CODE, 4+err_reason->slen);\n    attr->err_code = err_code;\n    pj_strdup(pool, &attr->reason, err_reason);\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pj_stun_msg_add_errcode_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 int err_code,\n                                                 const pj_str_t *err_reason)\n{\n    pj_stun_errcode_attr *err_attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_errcode_attr_create(pool, err_code, err_reason,\n                                         &err_attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &err_attr->hdr);\n}\n\nstatic pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    /* Make sure the length is never negative */\n    if (value.slen < 0)\n        value.slen = 0;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_errcode_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_errcode_attr *ca = \n        (const pj_stun_errcode_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    if (len < ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen) \n        return PJ_ETOOSMALL;\n\n    /* Copy and convert attribute to network byte order */\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(4 + ca->reason.slen));\n    PUTVAL16H(buf, 4, 0);\n    buf[6] = (pj_uint8_t)(ca->err_code / 100);\n    buf[7] = (pj_uint8_t)(ca->err_code % 100);\n\n    /* Copy error string */\n    pj_memcpy(buf + ATTR_HDR_LEN + 4, ca->reason.ptr, ca->reason.slen);\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + 4 + (unsigned)ca->reason.slen + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_errcode_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_errcode_attr *asrc = (const pj_stun_errcode_attr*)src;\n    pj_stun_errcode_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_errcode_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_errcode_attr));\n    pj_strdup(pool, &dst->reason, &asrc->reason);\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN UNKNOWN-ATTRIBUTES attribute\n */\n\n/*\n * Create an empty instance of STUN UNKNOWN-ATTRIBUTES attribute.\n *\n * @param pool          The pool to allocate memory from.\n * @param p_attr        Pointer to receive the attribute.\n *\n * @return              PJ_SUCCESS on success or the appropriate error code.\n */\nPJ_DEF(pj_status_t) pj_stun_unknown_attr_create(pj_pool_t *pool,\n                                                unsigned attr_cnt,\n                                                const pj_uint16_t attr_array[],\n                                                pj_stun_unknown_attr **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && attr_cnt < PJ_STUN_MAX_ATTR && p_attr, PJ_EINVAL);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    INIT_ATTR(attr, PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES, attr_cnt * 2);\n\n    attr->attr_count = attr_cnt;\n    for (i=0; i<attr_cnt; ++i) {\n        attr->attrs[i] = attr_array[i];\n    }\n\n    /* If the number of unknown attributes is an odd number, one of the\n     * attributes MUST be repeated in the list.\n     */\n    /* No longer necessary\n    if ((attr_cnt & 0x01)) {\n        attr->attrs[attr_cnt] = attr_array[attr_cnt-1];\n    }\n    */\n\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create and add STUN UNKNOWN-ATTRIBUTES attribute to the message. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_unknown_attr(pj_pool_t *pool,\n                                                 pj_stun_msg *msg,\n                                                 unsigned attr_cnt,\n                                                 const pj_uint16_t attr_type[])\n{\n    pj_stun_unknown_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_unknown_attr_create(pool, attr_cnt, attr_type, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\nstatic pj_status_t decode_unknown_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf, \n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_unknown_attr *attr;\n    const pj_uint16_t *punk_attr;\n    unsigned i;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_unknown_attr);\n    GETATTRHDR(buf, &attr->hdr);\n \n    attr->attr_count = (attr->hdr.length >> 1);\n    if (attr->attr_count > PJ_STUN_MAX_ATTR)\n        return PJ_ETOOMANY;\n\n    punk_attr = (const pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i<attr->attr_count; ++i) {\n        attr->attrs[i] = pj_ntohs(punk_attr[i]);\n    }\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t encode_unknown_attr(const void *a, pj_uint8_t *buf, \n                                       unsigned len, \n                                       const pj_stun_msg_hdr *msghdr,\n                                       unsigned *printed)\n{\n    const pj_stun_unknown_attr *ca = (const pj_stun_unknown_attr*) a;\n    pj_uint16_t *dst_unk_attr;\n    unsigned i;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Check that buffer is enough */\n    if (len < ATTR_HDR_LEN + (ca->attr_count << 1))\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t)(ca->attr_count << 1));\n\n    /* Copy individual attribute */\n    dst_unk_attr = (pj_uint16_t*)(buf + ATTR_HDR_LEN);\n    for (i=0; i < ca->attr_count; ++i, ++dst_unk_attr) {\n        *dst_unk_attr = pj_htons(ca->attrs[i]);\n    }\n\n    /* Done */\n    *printed = (ATTR_HDR_LEN + (ca->attr_count << 1) + 3) & (~3);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_unknown_attr(pj_pool_t *pool, const void *src)\n{\n    pj_stun_unknown_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_unknown_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_unknown_attr));\n    \n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * STUN generic binary attribute\n */\n\n/*\n * Initialize STUN binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_init( pj_stun_binary_attr *attr,\n                                              pj_pool_t *pool,\n                                              int attr_type,\n                                              const pj_uint8_t *data,\n                                              unsigned length)\n{\n    PJ_ASSERT_RETURN(attr_type, PJ_EINVAL);\n\n    INIT_ATTR(attr, attr_type, length);\n\n    attr->magic = PJ_STUN_MAGIC;\n\n    if (data && length) {\n        attr->length = length;\n        attr->data = (pj_uint8_t*) pj_pool_alloc(pool, length);\n        pj_memcpy(attr->data, data, length);\n    } else {\n        attr->data = NULL;\n        attr->length = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank binary attribute.\n */\nPJ_DEF(pj_status_t) pj_stun_binary_attr_create(pj_pool_t *pool,\n                                               int attr_type,\n                                               const pj_uint8_t *data,\n                                               unsigned length,\n                                               pj_stun_binary_attr **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && attr_type && p_attr, PJ_EINVAL);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    *p_attr = attr;\n    return pj_stun_binary_attr_init(attr, pool, attr_type, data, length);\n}\n\n\n/* Create and add binary attr. */\nPJ_DEF(pj_status_t) pj_stun_msg_add_binary_attr(pj_pool_t *pool,\n                                                pj_stun_msg *msg,\n                                                int attr_type,\n                                                const pj_uint8_t *data,\n                                                unsigned length)\n{\n    pj_stun_binary_attr *attr = NULL;\n    pj_status_t status;\n\n    status = pj_stun_binary_attr_create(pool, attr_type,\n                                        data, length, &attr);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    return pj_stun_msg_add_attr(msg, &attr->hdr);\n}\n\n\nstatic pj_status_t decode_binary_attr(pj_pool_t *pool, \n                                      const pj_uint8_t *buf,\n                                      const pj_stun_msg_hdr *msghdr,\n                                      void **p_attr)\n{\n    pj_stun_binary_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_binary_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Copy the data to the attribute */\n    attr->length = attr->hdr.length;\n    attr->data = (pj_uint8_t*) pj_pool_alloc(pool, attr->length);\n    pj_memcpy(attr->data, buf+ATTR_HDR_LEN, attr->length);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n\n}\n\n\nstatic pj_status_t encode_binary_attr(const void *a, pj_uint8_t *buf, \n                                      unsigned len, \n                                      const pj_stun_msg_hdr *msghdr,\n                                      unsigned *printed)\n{\n    const pj_stun_binary_attr *ca = (const pj_stun_binary_attr*)a;\n\n    PJ_CHECK_STACK();\n    \n    PJ_UNUSED_ARG(msghdr);\n\n    /* Calculated total attr_len (add padding if necessary) */\n    *printed = (ca->length + ATTR_HDR_LEN + 3) & (~3);\n    if (len < *printed)\n        return PJ_ETOOSMALL;\n\n    PUTVAL16H(buf, 0, ca->hdr.type);\n    PUTVAL16H(buf, 2, (pj_uint16_t) ca->length);\n\n    /* Copy the data */\n    pj_memcpy(buf+ATTR_HDR_LEN, ca->data, ca->length);\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\n\nstatic void* clone_binary_attr(pj_pool_t *pool, const void *src)\n{\n    const pj_stun_binary_attr *asrc = (const pj_stun_binary_attr*)src;\n    pj_stun_binary_attr *dst = PJ_POOL_ALLOC_T(pool, pj_stun_binary_attr);\n\n    pj_memcpy(dst, src, sizeof(pj_stun_binary_attr));\n\n    if (asrc->length) {\n        dst->data = (pj_uint8_t*) pj_pool_alloc(pool, asrc->length);\n        pj_memcpy(dst->data, asrc->data, asrc->length);\n    }\n\n    return (void*)dst;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n/*\n * Initialize a generic STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_init( pj_stun_msg *msg,\n                                      unsigned msg_type,\n                                      pj_uint32_t magic,\n                                      const pj_uint8_t tsx_id[12])\n{\n    PJ_ASSERT_RETURN(msg && msg_type, PJ_EINVAL);\n\n    msg->hdr.type = (pj_uint16_t) msg_type;\n    msg->hdr.length = 0;\n    msg->hdr.magic = magic;\n    msg->attr_count = 0;\n\n    if (tsx_id) {\n        pj_memcpy(&msg->hdr.tsx_id, tsx_id, sizeof(msg->hdr.tsx_id));\n    } else {\n        struct transaction_id\n        {\n            pj_uint32_t     proc_id;\n            pj_uint32_t     random;\n            pj_uint32_t     counter;\n        } id;\n        static pj_uint32_t pj_stun_tsx_id_counter;\n\n        if (!pj_stun_tsx_id_counter)\n            pj_stun_tsx_id_counter = pj_rand();\n\n        id.proc_id = pj_getpid();\n        id.random = pj_rand();\n        id.counter = pj_stun_tsx_id_counter++;\n\n        pj_memcpy(&msg->hdr.tsx_id, &id, sizeof(msg->hdr.tsx_id));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create a blank STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_create( pj_pool_t *pool,\n                                        unsigned msg_type,\n                                        pj_uint32_t magic,\n                                        const pj_uint8_t tsx_id[12],\n                                        pj_stun_msg **p_msg)\n{\n    pj_stun_msg *msg;\n\n    PJ_ASSERT_RETURN(pool && msg_type && p_msg, PJ_EINVAL);\n\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    *p_msg = msg;\n    return pj_stun_msg_init(msg, msg_type, magic, tsx_id);\n}\n\n\n/*\n * Clone a STUN message with all of its attributes.\n */\nPJ_DEF(pj_stun_msg*) pj_stun_msg_clone( pj_pool_t *pool,\n                                        const pj_stun_msg *src)\n{\n    pj_stun_msg *dst;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && src, NULL);\n\n    dst = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(dst, src, sizeof(pj_stun_msg));\n\n    /* Duplicate the attributes */\n    for (i=0, dst->attr_count=0; i<src->attr_count; ++i) {\n        dst->attr[dst->attr_count] = pj_stun_attr_clone(pool, src->attr[i]);\n        if (dst->attr[dst->attr_count])\n            ++dst->attr_count;\n    }\n\n    return dst;\n}\n\n\n/*\n * Add STUN attribute to STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_add_attr(pj_stun_msg *msg,\n                                         pj_stun_attr_hdr *attr)\n{\n    PJ_ASSERT_RETURN(msg && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(msg->attr_count < PJ_STUN_MAX_ATTR, PJ_ETOOMANY);\n\n    msg->attr[msg->attr_count++] = attr;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Check that the PDU is potentially a valid STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_check(const pj_uint8_t *pdu, pj_size_t pdu_len,\n                                      unsigned options)\n{\n    pj_uint32_t msg_len;\n\n    PJ_ASSERT_RETURN(pdu, PJ_EINVAL);\n\n    if (pdu_len < sizeof(pj_stun_msg_hdr))\n        return PJNATH_EINSTUNMSGLEN;\n\n    /* First byte of STUN message is always 0x00 or 0x01. */\n    if (*pdu != 0x00 && *pdu != 0x01)\n        return PJNATH_EINSTUNMSGTYPE;\n\n    /* Check the PDU length */\n    msg_len = GETVAL16H(pdu, 2);\n    if ((msg_len + 20 > pdu_len) || \n        ((options & PJ_STUN_IS_DATAGRAM) && msg_len + 20 != pdu_len))\n    {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* STUN message is always padded to the nearest 4 bytes, thus\n     * the last two bits of the length field are always zero.\n     */\n    if ((msg_len & 0x03) != 0) {\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    /* If magic is set, then there is great possibility that this is\n     * a STUN message.\n     */\n    if (GETVAL32H(pdu, 4) == PJ_STUN_MAGIC) {\n\n        /* Check if FINGERPRINT attribute is present */\n        if ((options & PJ_STUN_NO_FINGERPRINT_CHECK )==0 && \n            GETVAL16H(pdu, msg_len + 20 - 8) == PJ_STUN_ATTR_FINGERPRINT) \n        {\n            pj_uint16_t attr_len = GETVAL16H(pdu, msg_len + 20 - 8 + 2);\n            pj_uint32_t fingerprint = GETVAL32H(pdu, msg_len + 20 - 8 + 4);\n            pj_uint32_t crc;\n\n            if (attr_len != 4)\n                return PJNATH_ESTUNINATTRLEN;\n\n            crc = pj_crc32_calc(pdu, msg_len + 20 - 8);\n            crc ^= STUN_XOR_FINGERPRINT;\n\n            if (crc != fingerprint)\n                return PJNATH_ESTUNFINGERPRINT;\n        }\n    }\n\n    /* Could be a STUN message */\n    return PJ_SUCCESS;\n}\n\n\n/* Create error response */\nPJ_DEF(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,\n                                                const pj_stun_msg *req_msg,\n                                                unsigned err_code,\n                                                const pj_str_t *err_msg,\n                                                pj_stun_msg **p_response)\n{\n    unsigned msg_type = req_msg->hdr.type;\n    pj_stun_msg *response = NULL;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_response, PJ_EINVAL);\n\n    PJ_ASSERT_RETURN(PJ_STUN_IS_REQUEST(msg_type), \n                     PJNATH_EINSTUNMSGTYPE);\n\n    /* Create response or error response */\n    if (err_code)\n        msg_type |= PJ_STUN_ERROR_RESPONSE_BIT;\n    else\n        msg_type |= PJ_STUN_SUCCESS_RESPONSE_BIT;\n\n    status = pj_stun_msg_create(pool, msg_type, req_msg->hdr.magic, \n                                req_msg->hdr.tsx_id, &response);\n    if (status != PJ_SUCCESS) {\n        return status;\n    }\n\n    /* Add error code attribute */\n    if (err_code) {\n        status = pj_stun_msg_add_errcode_attr(pool, response, \n                                              err_code, err_msg);\n        if (status != PJ_SUCCESS) {\n            return status;\n        }\n    }\n\n    *p_response = response;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse incoming packet into STUN message.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                       const pj_uint8_t *pdu,\n                                       pj_size_t pdu_len,\n                                       unsigned options,\n                                       pj_stun_msg **p_msg,\n                                       pj_size_t *p_parsed_len,\n                                       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n        *p_parsed_len = 0;\n    if (p_response)\n        *p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n        status = pj_stun_msg_check(pdu, pdu_len, options);\n        if (status != PJ_SUCCESS)\n            return status;\n    } else {\n        /* For safety, verify packet length at least */\n        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;\n        if (msg_len > pdu_len ||\n            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))\n        {\n            return PJNATH_EINSTUNMSGLEN;\n        }\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n        p_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= ATTR_HDR_LEN) {\n        unsigned attr_type, attr_val_len;\n        const struct attr_desc *adesc;\n\n        /* Get attribute type and length. If length is not aligned\n         * to 4 bytes boundary, add padding.\n         */\n        attr_type = GETVAL16H(pdu, 0);\n        attr_val_len = GETVAL16H(pdu, 2);\n        attr_val_len = (attr_val_len + 3) & (~3);\n\n        /* Check length */\n        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {\n            pj_str_t err_msg;\n            char err_msg_buf[80];\n\n            err_msg.ptr = err_msg_buf;\n            err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n                                            \"Attribute %s has invalid length\",\n                                            pj_stun_get_attr_name(attr_type));\n\n            PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n                      (int)err_msg.slen, err_msg.ptr));\n\n            if (p_response) {\n                pj_stun_msg_create_response(pool, msg, \n                                            PJ_STUN_SC_BAD_REQUEST, \n                                            &err_msg, p_response);\n            }\n            return PJNATH_ESTUNINATTRLEN;\n        }\n\n        /* Get the attribute descriptor */\n        adesc = find_attr_desc(attr_type);\n\n        if (adesc == NULL) {\n            /* Unrecognized attribute */\n            pj_stun_binary_attr *attr = NULL;\n\n            PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n                      attr_type));\n\n            /* Is this a fatal condition? */\n            if (attr_type <= 0x7FFF) {\n                /* This is a mandatory attribute, we must return error\n                 * if we don't understand the attribute.\n                 */\n                if (p_response) {\n                    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n                    status = pj_stun_msg_create_response(pool, msg,\n                                                         err_code, NULL, \n                                                         p_response);\n                    if (status==PJ_SUCCESS) {\n                        pj_uint16_t d = (pj_uint16_t)attr_type;\n                        pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n                    }\n                }\n\n                return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Create binary attribute to represent this */\n            status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n                                                GETVAL16H(pdu, 2), &attr);\n            if (status != PJ_SUCCESS) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing unknown STUN attribute type %d\",\n                          attr_type));\n\n                return status;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = &attr->hdr;\n\n        } else {\n            void *attr;\n            char err_msg1[PJ_ERR_MSG_SIZE],\n                 err_msg2[PJ_ERR_MSG_SIZE];\n\n            /* Parse the attribute */\n            status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n            if (status != PJ_SUCCESS) {\n                pj_strerror(status, err_msg1, sizeof(err_msg1));\n\n                if (p_response) {\n                    pj_str_t e;\n\n                    e.ptr = err_msg2;\n                    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n                                             \"%s in %s\",\n                                             err_msg1,\n                                             pj_stun_get_attr_name(attr_type));\n                    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n                        e.slen = sizeof(err_msg2) - 1;\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_BAD_REQUEST,\n                                                &e, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing STUN attribute %s: %s\",\n                          pj_stun_get_attr_name(attr_type), \n                          err_msg1));\n\n                return status;\n            }\n\n            if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n                !has_fingerprint) \n            {\n                if (has_msg_int) {\n                    /* Already has MESSAGE-INTEGRITY */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_msg_int = PJ_TRUE;\n\n            } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n                if (has_fingerprint) {\n                    /* Already has FINGERPRINT */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_fingerprint = PJ_TRUE;\n            } else {\n                if (has_fingerprint) {\n                    /* Another attribute is found which is not FINGERPRINT\n                     * after FINGERPRINT. Note that non-FINGERPRINT is\n                     * allowed to appear after M-I\n                     */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNFINGERPOS;\n                }\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n        }\n\n        /* Next attribute */\n        if (attr_val_len + 4 >= pdu_len) {\n            pdu += pdu_len;\n            pdu_len = 0;\n        } else {\n            pdu += (attr_val_len + 4);\n            pdu_len -= (attr_val_len + 4);\n        }\n    }\n\n    if (pdu_len > 0) {\n        /* Stray trailing bytes */\n        PJ_LOG(4,(THIS_FILE, \n                  \"Error decoding STUN message: unparsed trailing %d bytes\",\n                  pdu_len));\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n        *p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}\n\n/*\nstatic char *print_binary(const pj_uint8_t *data, unsigned data_len)\n{\n    static char static_buffer[1024];\n    char *buffer = static_buffer;\n    unsigned length=sizeof(static_buffer), i;\n\n    if (length < data_len * 2 + 8)\n        return \"\";\n\n    pj_ansi_sprintf(buffer, \", data=\");\n    buffer += 7;\n\n    for (i=0; i<data_len; ++i) {\n        pj_ansi_sprintf(buffer, \"%02x\", (*data) & 0xFF);\n        buffer += 2;\n        data++;\n    }\n\n    pj_ansi_sprintf(buffer, \"\\n\");\n    buffer++;\n\n    return static_buffer;\n}\n*/\n\n/*\n * Print the message structure to a buffer.\n */\nPJ_DEF(pj_status_t) pj_stun_msg_encode(pj_stun_msg *msg,\n                                       pj_uint8_t *buf, pj_size_t buf_size,\n                                       unsigned options,\n                                       const pj_str_t *key,\n                                       pj_size_t *p_msg_len)\n{\n    pj_uint8_t *start = buf;\n    pj_stun_msgint_attr *amsgint = NULL;\n    pj_stun_fingerprint_attr *afingerprint = NULL;\n    unsigned printed = 0, body_len;\n    pj_status_t status;\n    unsigned i;\n\n\n    PJ_ASSERT_RETURN(msg && buf && buf_size, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(options);\n    PJ_ASSERT_RETURN(options == 0, PJ_EINVAL);\n\n    /* Copy the message header part and convert the header fields to\n     * network byte order\n     */\n    if (buf_size < sizeof(pj_stun_msg_hdr))\n        return PJ_ETOOSMALL;\n    \n    PUTVAL16H(buf, 0, msg->hdr.type);\n    PUTVAL16H(buf, 2, 0);   /* length will be calculated later */\n    PUTVAL32H(buf, 4, msg->hdr.magic);\n    pj_memcpy(buf+8, msg->hdr.tsx_id, sizeof(msg->hdr.tsx_id));\n\n    buf += sizeof(pj_stun_msg_hdr);\n    buf_size -= sizeof(pj_stun_msg_hdr);\n\n    /* Encode each attribute to the message */\n    for (i=0; i<msg->attr_count; ++i) {\n        const struct attr_desc *adesc;\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            pj_assert(amsgint == NULL);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n            /* Stop when encountering MESSAGE-INTEGRITY */\n            break;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n            break;\n        }\n\n        adesc = find_attr_desc(attr_hdr->type);\n        if (adesc) {\n            status = adesc->encode_attr(attr_hdr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        } else {\n            /* This may be a generic attribute */\n            const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*) \n                                                   attr_hdr;\n            PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, PJ_EBUG);\n            status = encode_binary_attr(bin_attr, buf, (unsigned)buf_size, \n                                        &msg->hdr, &printed);\n        }\n\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* We may have stopped printing attribute because we found\n     * MESSAGE-INTEGRITY or FINGERPRINT. Scan the rest of the\n     * attributes.\n     */\n    for ( ++i; i<msg->attr_count; ++i) {\n        const pj_stun_attr_hdr *attr_hdr = msg->attr[i];\n\n        /* There mustn't any attribute after FINGERPRINT */\n        PJ_ASSERT_RETURN(afingerprint == NULL, PJNATH_ESTUNFINGERPOS);\n\n        if (attr_hdr->type == PJ_STUN_ATTR_MESSAGE_INTEGRITY) {\n            /* There mustn't be MESSAGE-INTEGRITY before */\n            PJ_ASSERT_RETURN(amsgint == NULL, \n                             PJNATH_ESTUNMSGINTPOS);\n            amsgint = (pj_stun_msgint_attr*) attr_hdr;\n\n        } else if (attr_hdr->type == PJ_STUN_ATTR_FINGERPRINT) {\n            afingerprint = (pj_stun_fingerprint_attr*) attr_hdr;\n        }\n    }\n\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n    /*\n     * This is the old style MESSAGE-INTEGRITY and FINGERPRINT\n     * calculation, used in rfc3489bis-06 and older.\n     */\n    /* We MUST update the message length in the header NOW before\n     * calculating MESSAGE-INTEGRITY and FINGERPRINT. \n     * Note that length is not including the 20 bytes header.\n      */\n    if (amsgint && afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24 + 8);\n    } else if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else if (afingerprint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 8);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#else\n    /* If MESSAGE-INTEGRITY is present, include the M-I attribute\n     * in message length before calculating M-I\n     */\n    if (amsgint) {\n        body_len = (pj_uint16_t)((buf - start) - 20 + 24);\n    } else {\n        body_len = (pj_uint16_t)((buf - start) - 20);\n    }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n\n    /* hdr->length = pj_htons(length); */\n    PUTVAL16H(start, 2, (pj_uint16_t)body_len);\n\n    /* Calculate message integrity, if present */\n    if (amsgint != NULL) {\n        pj_hmac_sha1_context ctx;\n\n        /* Key MUST be specified */\n        PJ_ASSERT_RETURN(key, PJ_EINVALIDOP);\n\n        /* MESSAGE-INTEGRITY must be the last attribute in the message, or\n         * the last attribute before FINGERPRINT.\n         */\n        if (msg->attr_count>1 && i < msg->attr_count-2) {\n            /* Should not happen for message generated by us */\n            pj_assert(PJ_FALSE);\n            return PJNATH_ESTUNMSGINTPOS;\n\n        } else if (i == msg->attr_count-2)  {\n            if (msg->attr[i+1]->type != PJ_STUN_ATTR_FINGERPRINT) {\n                /* Should not happen for message generated by us */\n                pj_assert(PJ_FALSE);\n                return PJNATH_ESTUNMSGINTPOS;\n            } else {\n                afingerprint = (pj_stun_fingerprint_attr*) msg->attr[i+1];\n            }\n        }\n\n        /* Calculate HMAC-SHA1 digest, add zero padding to input\n         * if necessary to make the input 64 bytes aligned.\n         */\n        pj_hmac_sha1_init(&ctx, (const pj_uint8_t*)key->ptr, \n                          (unsigned)key->slen);\n        pj_hmac_sha1_update(&ctx, (const pj_uint8_t*)start, \n                            (unsigned)(buf-start));\n#if PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        // These are obsoleted in rfc3489bis-08\n        if ((buf-start) & 0x3F) {\n            pj_uint8_t zeroes[64];\n            pj_bzero(zeroes, sizeof(zeroes));\n            pj_hmac_sha1_update(&ctx, zeroes, 64-((buf-start) & 0x3F));\n        }\n#endif  /* PJ_STUN_OLD_STYLE_MI_FINGERPRINT */\n        pj_hmac_sha1_final(&ctx, amsgint->hmac);\n\n        /* Put this attribute in the message */\n        status = encode_msgint_attr(amsgint, buf, (unsigned)buf_size, \n                                    &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Calculate FINGERPRINT if present */\n    if (afingerprint != NULL) {\n\n#if !PJ_STUN_OLD_STYLE_MI_FINGERPRINT\n        /* Update message length */\n        PUTVAL16H(start, 2, \n                 (pj_uint16_t)(GETVAL16H(start, 2)+8));\n#endif\n\n        afingerprint->value = pj_crc32_calc(start, buf-start);\n        afingerprint->value ^= STUN_XOR_FINGERPRINT;\n\n        /* Put this attribute in the message */\n        status = encode_uint_attr(afingerprint, buf, (unsigned)buf_size, \n                                  &msg->hdr, &printed);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        buf += printed;\n        buf_size -= printed;\n    }\n\n    /* Update message length. */\n    msg->hdr.length = (pj_uint16_t) ((buf - start) - 20);\n\n    /* Return the length */\n    if (p_msg_len)\n        *p_msg_len = (buf - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find STUN attribute in the STUN message, starting from the specified\n * index.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_msg_find_attr( const pj_stun_msg *msg,\n                                                 int attr_type,\n                                                 unsigned index)\n{\n    PJ_ASSERT_RETURN(msg, NULL);\n\n    for (; index < msg->attr_count; ++index) {\n        if (msg->attr[index]->type == attr_type)\n            return (pj_stun_attr_hdr*) msg->attr[index];\n    }\n\n    return NULL;\n}\n\n\n/*\n * Clone a STUN attribute.\n */\nPJ_DEF(pj_stun_attr_hdr*) pj_stun_attr_clone( pj_pool_t *pool,\n                                              const pj_stun_attr_hdr *attr)\n{\n    const struct attr_desc *adesc;\n\n    /* Get the attribute descriptor */\n    adesc = find_attr_desc(attr->type);\n    if (adesc) {\n        return (pj_stun_attr_hdr*) (*adesc->clone_attr)(pool, attr);\n    } else {\n        /* Clone generic attribute */\n        const pj_stun_binary_attr *bin_attr = (const pj_stun_binary_attr*)\n                                               attr;\n        PJ_ASSERT_RETURN(bin_attr->magic == PJ_STUN_MAGIC, NULL);\n        if (bin_attr->magic == PJ_STUN_MAGIC) {\n            return (pj_stun_attr_hdr*) clone_binary_attr(pool, attr);\n        } else {\n            return NULL;\n        }\n    }\n}\n\n\n"], "filenames": ["pjnath/include/pjnath/stun_msg.h", "pjnath/src/pjnath/stun_msg.c"], "buggy_code_start_loc": [444, 749], "buggy_code_end_loc": [508, 2361], "fixing_code_start_loc": [445, 749], "fixing_code_end_loc": [513, 2369], "type": "CWE-787", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. Buffer overread is possible when parsing a specially crafted STUN message with unknown attribute. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as a commit in the master branch (2.13.1).", "other": {"cve": {"id": "CVE-2022-23537", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-20T19:15:24.663", "lastModified": "2022-12-29T17:33:12.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. Buffer overread is possible when parsing a specially crafted STUN message with unknown attribute. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as a commit in the master branch (2.13.1)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.13.1", "matchCriteriaId": "A196AF4D-F474-4139-B534-17CB457CF2D5"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/d8440f4d711a654b511f50f79c0445b26f9dd1e1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-9pfh-r8x4-w26w", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/d8440f4d711a654b511f50f79c0445b26f9dd1e1"}}