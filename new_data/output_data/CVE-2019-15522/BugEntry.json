{"buggy_code": ["/*\n *  csync2 - cluster synchronization tool, 2nd generation\n *  Copyright (C) 2004 - 2015 LINBIT Information Technologies GmbH\n *  http://www.linbit.com; see also AUTHORS\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"csync2.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <fnmatch.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <utime.h>\n#include <errno.h>\n#include <netdb.h>\n#include <fcntl.h>\n\n#ifdef __CYGWIN__\n#include <w32api/windows.h>\n#endif\n\nstatic const char *cmd_error;\n\nint csync_setBackupFileStatus(char *filename, int backupDirLength);\n\n\nint csync_unlink(const char *filename, int ign)\n{\n\tstruct stat st;\n\tint rc;\n\n\tif ( lstat_strict(prefixsubst(filename), &st) != 0 ) return 0;\n\tif ( ign==2 && S_ISREG(st.st_mode) ) return 0;\n\trc = S_ISDIR(st.st_mode) ? rmdir(prefixsubst(filename)) : unlink(prefixsubst(filename));\n\n\tif ( rc && !ign ) cmd_error = strerror(errno);\n\treturn rc;\n}\n\nint csync_check_dirty(const char *filename, const char *peername, int isflush)\n{\n\tint rc = 0;\n\tcsync_check(filename, 0, 0);\n\tif (isflush) return 0;\n\tSQL_BEGIN(\"Check if file is dirty\",\n\t\t\"SELECT 1 FROM dirty WHERE filename = '%s' LIMIT 1\",\n\t\turl_encode(filename))\n\t{\n\t\trc = 1;\n\t\tcmd_error = conn_response(CR_ERR_ALSO_DIRTY_HERE);\n\t} SQL_END;\n\tif (rc && peername)\n\t\tcsync_mark(filename, peername, 0);\n\treturn rc;\n}\n\nvoid csync_file_update(const char *filename, const char *peername)\n{\n\tstruct stat st;\n\tSQL(\"Removing file from dirty db\",\n\t\t\t\"delete from dirty where filename = '%s' and peername = '%s'\",\n\t\t\turl_encode(filename), peername);\n\tif ( lstat_strict(prefixsubst(filename), &st) != 0 || csync_check_pure(filename) ) {\n\t\tSQL(\"Removing file from file db\",\n\t\t\t\"delete from file where filename = '%s'\",\n\t\t\turl_encode(filename));\n\t} else {\n\t\tconst char *checktxt = csync_genchecktxt(&st, filename, 0);\n\n\t\tSQL(\"Deleting old record from file db\",\n\t\t\t\"DELETE FROM file WHERE filename = '%s'\",\n\t\t\turl_encode(filename));\n\n\t\tSQL(\"Insert record to file db\",\n\t\t\t\"INSERT INTO file (filename, checktxt) values \"\n\t\t\t\"('%s', '%s')\", url_encode(filename),\n\t\t\turl_encode(checktxt));\n\t}\n}\n\nvoid csync_file_flush(const char *filename)\n{\n\tSQL(\"Removing file from dirty db\",\n\t\t\"delete from dirty where filename ='%s'\",\n\t\turl_encode(filename));\n}\n\nint csync_file_backup(const char *filepath)\n{\n\tstatic char error_buffer[1024];\n\tconst struct csync_group *g = NULL;\n\tstruct stat buf;\n\tint rc;\n\t/* ==============================================================================================\n\t * As of now, filepath may only contain prefixes but we may need to resolve other\n\t * dynamic references like environment variables, symbolic links, etc in future\n\t * if we plan to support those in later releases\n\t *==============================================================================================*/\n\tconst char *filename = prefixsubst(filepath);\n\tint filename_len = strlen(filename);\t//can filename be null?\n\n\twhile ((g = csync_find_next(g, filepath))) {\n\t\tif (g->backup_directory && g->backup_generations > 1) {\n\t\t\tunsigned int bak_dir_len = strlen(g->backup_directory);\n\t\t\tchar backup_filename[bak_dir_len + filename_len + 12];\n\t\t\tchar backup_otherfilename[bak_dir_len + filename_len + 12];\n\t\t\tint fd_in, fd_out;\n\t\t\tunsigned int i, lastSlash = 0;\n\t\t\tmode_t mode;\n\n\t\t\tcsync_debug(1, \"backup %s for group %s\\n\", filename, g->gname);\n\n\t\t\tif (stat(g->backup_directory, &buf) != 0) {\n\t\t\t\tcsync_debug(3, \"backup directory configured is not present, so creating it\");\n\t\t\t\tif (mkpath(g->backup_directory, 0700)) {\n\t\t\t\t\tcsync_debug(1,\n\t\t\t\t\t\t    \"ERROR : unable to create backup directory %s ; backup failed \\n\",\n\t\t\t\t\t\t    g->backup_directory);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else if (!S_ISDIR(buf.st_mode)) {\n\t\t\t\tcsync_debug(1,\n\t\t\t\t\t    \"ERROR : location configured for backup %s is not a directory; backup failed \\n\",\n\t\t\t\t\t    g->backup_directory);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// Skip generation of directories\n\t\t\trc = stat(filename, &buf);\n\t\t\tif (S_ISDIR(buf.st_mode)) {\n\t\t\t\tcsync_debug(1, \"directory. Skip generation \\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfd_in = open(filename, O_RDONLY);\n\t\t\tif (fd_in < 0)\n\t\t\t\treturn 0;\n\n\t\t\tmemcpy(backup_filename, g->backup_directory, bak_dir_len);\n\t\t\tbackup_filename[bak_dir_len] = 0;\n\t\t\tmode = 0700;\n\n\t\t\t/* open coded strrchr?? why? */\n\t\t\tfor (i = filename_len; i > 0; i--)\n\t\t\t\tif (filename[i] == '/') {\n\t\t\t\t\tlastSlash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tfor (i = 0; i < filename_len; i++) {\n\t\t\t\t// Create directories in filename\n\t\t\t\t// TODO: Get the mode from the orig. dir\n\t\t\t\tif (filename[i] == '/' && i <= lastSlash) {\n\n\t\t\t\t\tbackup_filename[bak_dir_len + i] = 0;\n\n\t\t\t\t\tcsync_debug(1, \"mkdir %s \\n\", backup_filename);\n\n\t\t\t\t\tmkdir(backup_filename, mode);\n\t\t\t\t\t// Dont check the empty string.\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tcsync_setBackupFileStatus(backup_filename, bak_dir_len);\n\n\t\t\t\t}\n\t\t\t\tbackup_filename[bak_dir_len + i] = filename[i];\n\t\t\t}\n\n\t\t\tbackup_filename[bak_dir_len + filename_len] = 0;\n\t\t\tbackup_filename[bak_dir_len] = '/';\n\t\t\tmemcpy(backup_otherfilename, backup_filename, bak_dir_len + filename_len);\n\n\t\t\tfor (i = g->backup_generations - 1; i; i--) {\n\n\t\t\t\tif (i != 1)\n\t\t\t\t\tsnprintf(backup_filename + bak_dir_len + filename_len, 12, \".%u\", i - 1);\n\t\t\t\tbackup_filename[bak_dir_len + filename_len] = '\\0';\n\t\t\t\tsnprintf(backup_otherfilename + bak_dir_len + filename_len, 12, \".%u\", i);\n\n\t\t\t\trc = rename(backup_filename, backup_otherfilename);\n\t\t\t\tcsync_debug(1,\n\t\t\t\t\t    \"renaming backup files '%s' to '%s'. rc = %d\\n\",\n\t\t\t\t\t    backup_filename, backup_otherfilename, rc);\n\t\t\t}\n\n\t\t\t/* strcpy(backup_filename+bak_dir_len+filename_len, \"\"); */\n\n\t\t\tfd_out = open(backup_filename, O_WRONLY | O_CREAT, 0600);\n\n\t\t\tif (fd_out < 0) {\n\t\t\t\tsnprintf(error_buffer, 1024, \"Open error while backing up '%s': %s\\n\", filename, strerror(errno));\n\t\t\t\tcmd_error = error_buffer;\n\t\t\t\tclose(fd_in);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tcsync_debug(1, \"Copying data from %s to backup file %s \\n\", filename, backup_filename);\n\n\t\t\trc = csync_copy_file(fd_in, fd_out);\n\t\t\tif (rc != 0) {\n\t\t\t\tcsync_debug(1, \"csync_backup error 2\\n\");\n\n\t\t\t\tsnprintf(error_buffer, 1024, \"Write error while backing up '%s': %s\\n\", filename, strerror(errno));\n\n\t\t\t\tcmd_error = error_buffer;\n\t\t\t\t// TODO verify file disapeared ?\n\t\t\t\t//\n\t\t\t\t// return 1;\n\t\t\t}\n\t\t\tcsync_setBackupFileStatus(backup_filename, bak_dir_len);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint csync_copy_file(int fd_in, int fd_out)\n{\n\tchar buffer[512];\n\tint read_len = read(fd_in, buffer, 512);\n\n\twhile (read_len > 0) {\n\t\tint write_len = 0;\n\n\t\twhile (write_len < read_len) {\n\t\t\tint rc = write(fd_out, buffer + write_len,\n\t\t\t\t       read_len - write_len);\n\t\t\tif (rc == -1) {\n\t\t\t\tclose(fd_in);\n\t\t\t\tclose(fd_out);\n\t\t\t\t//TODO verify return code.\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t\twrite_len += rc;\n\t\t}\n\t\tread_len = read(fd_in, buffer, 512);\n\t}\n\tclose(fd_in);\n\tclose(fd_out);\n\treturn 0;\n}\n\n/* get the mode from the orig directory.\n   Looking from the back_dir_len should produce the original dir.\n*/\nint csync_setBackupFileStatus(char *filename, int backupDirLength)\n{\n\n\tstruct stat buf;\n\tint rc = stat((filename + backupDirLength), &buf);\n\tif (rc == 0) {\n\t\tcsync_debug(1, \"Stating original file %s rc: %d mode: %o \\n\", (filename + backupDirLength), rc, buf.st_mode);\n\n\t\trc = chown(filename, buf.st_uid, buf.st_gid);\n\t\tcsync_debug(rc == 0, \"Changing owner of %s to user %d and group %d, rc= %d \\n\", filename, buf.st_uid, buf.st_gid, rc);\n\n\t\trc = chmod(filename, buf.st_mode);\n\t\tcsync_debug(rc == 0, \"Changing mode of %s to mode %o, rc= %d \\n\", filename, buf.st_mode, rc);\n\n\t} else {\n\t\tcsync_debug(0, \"Error getting mode and owner ship from %s \\n\", (filename + backupDirLength));\n\t\treturn -1;\n\t}\n\treturn 0;\n};\n\nstruct csync_command {\n\tchar *text;\n\tint check_perm;\n\tint check_dirty;\n\tint unlink;\n\tint update;\n\tint need_ident;\n\tint action;\n};\n\nenum {\n\tA_SIG, A_FLUSH, A_MARK, A_TYPE, A_GETTM, A_GETSZ, A_DEL, A_PATCH,\n\tA_MKDIR, A_MKCHR, A_MKBLK, A_MKFIFO, A_MKLINK, A_MKSOCK,\n\tA_SETOWN, A_SETMOD, A_SETIME, A_LIST, A_GROUP,\n\tA_DEBUG, A_HELLO, A_BYE\n};\n\nstruct csync_command cmdtab[] = {\n\t{ \"sig\",\t1, 0, 0, 0, 1, A_SIG\t},\n\t{ \"mark\",\t1, 0, 0, 0, 1, A_MARK\t},\n\t{ \"type\",\t2, 0, 0, 0, 1, A_TYPE\t},\n\t{ \"gettm\",\t1, 0, 0, 0, 1, A_GETTM\t},\n\t{ \"getsz\",\t1, 0, 0, 0, 1, A_GETSZ\t},\n\t{ \"flush\",\t1, 1, 0, 0, 1, A_FLUSH\t},\n\t{ \"del\",\t1, 1, 0, 1, 1, A_DEL\t},\n\t{ \"patch\",\t1, 1, 2, 1, 1, A_PATCH\t},\n\t{ \"mkdir\",\t1, 1, 1, 1, 1, A_MKDIR\t},\n\t{ \"mkchr\",\t1, 1, 1, 1, 1, A_MKCHR\t},\n\t{ \"mkblk\",\t1, 1, 1, 1, 1, A_MKBLK\t},\n\t{ \"mkfifo\",\t1, 1, 1, 1, 1, A_MKFIFO\t},\n\t{ \"mklink\",\t1, 1, 1, 1, 1, A_MKLINK\t},\n\t{ \"mksock\",\t1, 1, 1, 1, 1, A_MKSOCK\t},\n\t{ \"setown\",\t1, 1, 0, 2, 1, A_SETOWN\t},\n\t{ \"setmod\",\t1, 1, 0, 2, 1, A_SETMOD\t},\n\t{ \"setime\",\t1, 0, 0, 2, 1, A_SETIME\t},\n\t{ \"list\",\t0, 0, 0, 0, 1, A_LIST\t},\n#if 0\n\t{ \"debug\",\t0, 0, 0, 0, 1, A_DEBUG\t},\n#endif\n\t{ \"group\",\t0, 0, 0, 0, 0, A_GROUP\t},\n\t{ \"hello\",\t0, 0, 0, 0, 0, A_HELLO\t},\n\t{ \"bye\",\t0, 0, 0, 0, 0, A_BYE\t},\n\t{ 0,\t\t0, 0, 0, 0, 0, 0\t}\n};\n\ntypedef union address {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in sa_in;\n\tstruct sockaddr_in6 sa_in6;\n\tstruct sockaddr_storage ss;\n} address_t;\n\nconst char *csync_inet_ntop(address_t *addr)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\tsa_family_t af = addr->sa.sa_family;\n\treturn inet_ntop(af,\n\t\taf == AF_INET  ? (void*)&addr->sa_in.sin_addr :\n\t\taf == AF_INET6 ? (void*)&addr->sa_in6.sin6_addr : NULL,\n\t\tbuf, sizeof(buf));\n}\n\n/*\n * Loops (to cater for multihomed peers) through the address list returned by\n * gethostbyname(), returns 1 if any match with the address obtained from\n * getpeername() during session startup.\n * Otherwise returns 0 (-> identification failed).\n *\n * TODO switch to a getnameinfo in conn_open.\n * TODO add a \"pre-authenticated\" pipe mode for use over ssh */\nint verify_peername(const char *name, address_t *peeraddr)\n{\n\tsa_family_t af = peeraddr->sa.sa_family;\n\tstruct addrinfo hints;\n\tstruct addrinfo *result, *rp;\n\tint try_mapped_ipv4;\n\tint s;\n\n\t/* Obtain address(es) matching host */\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = AF_UNSPEC;     /* Allow IPv4 or IPv6 */\n\thints.ai_socktype = SOCK_STREAM; /* Datagram socket */\n\n\ts = getaddrinfo(name, NULL, &hints, &result);\n\tif (s != 0) {\n\t\tcsync_debug(1, \"getaddrinfo: %s\\n\", gai_strerror(s));\n\t\treturn 0;\n\t}\n\n\ttry_mapped_ipv4 =\n\t\taf == AF_INET6 &&\n\t\t!memcmp(&peeraddr->sa_in6.sin6_addr,\n\t\t\t\"\\0\\0\\0\\0\" \"\\0\\0\\0\\0\" \"\\0\\0\\xff\\xff\", 12);\n\n\t/* getaddrinfo() returns a list of address structures.\n\t * Try each address. */\n\n\tfor (rp = result; rp != NULL; rp = rp->ai_next) {\n\t\t/* both IPv4 */\n\t\tif (af == AF_INET && rp->ai_family == AF_INET &&\n\t\t    !memcmp(&((struct sockaddr_in*)rp->ai_addr)->sin_addr,\n\t\t\t    &peeraddr->sa_in.sin_addr, sizeof(struct in_addr)))\n\t\t\tbreak;\n\t\t/* both IPv6 */\n\t\tif (af == AF_INET6 && rp->ai_family == AF_INET6 &&\n\t\t    !memcmp(&((struct sockaddr_in6*)rp->ai_addr)->sin6_addr,\n\t\t\t    &peeraddr->sa_in6.sin6_addr, sizeof(struct in6_addr)))\n\t\t\tbreak;\n\t\t/* peeraddr IPv6, but actually ::ffff:I.P.v.4,\n\t\t * and forward lookup returned IPv4 only */\n\t\tif (af == AF_INET6 && rp->ai_family == AF_INET &&\n\t\t    try_mapped_ipv4 &&\n\t\t    !memcmp(&((struct sockaddr_in*)rp->ai_addr)->sin_addr,\n\t\t\t    (unsigned char*)&peeraddr->sa_in6.sin6_addr + 12,\n\t\t\t    sizeof(struct in_addr)))\n\t\t\tbreak;\n\t}\n\tfreeaddrinfo(result);\n\tif (rp != NULL) /* memcmp found a match */\n\t\treturn conn_check_peer_cert(name, 0);\n\treturn 0;\n}\n\n/* Why do all this fuzz, and not simply --assume-authenticated?\n * To limit the impact of an accidental misconfiguration.\n */\nvoid set_peername_from_env(address_t *p, const char *env)\n{\n\tstruct addrinfo hints = {\n\t\t.ai_family = AF_UNSPEC,\n\t\t.ai_socktype = SOCK_STREAM,\n\t\t.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV,\n\t};\n\tstruct addrinfo *result;\n\tchar *c;\n\tint s;\n\n\tchar *val = getenv(env);\n\tcsync_debug(3, \"getenv(%s): >>%s<<\\n\", env, val ?: \"\");\n\tif (!val)\n\t\treturn;\n\tval = strdup(val);\n\tif (!val)\n\t\treturn;\n\n\tc = strchr(val, ' ');\n\tif (!c)\n\t\treturn;\n\t*c = '\\0';\n\n\ts = getaddrinfo(val, NULL, &hints, &result);\n\tif (s != 0) {\n\t\tcsync_debug(1, \"getaddrinfo: %s\\n\", gai_strerror(s));\n\t\treturn;\n\t}\n\n\t/* getaddrinfo() may return a list of address structures.\n\t * Use the first one. */\n\tif (result)\n\t\tmemcpy(p, result->ai_addr, result->ai_addrlen);\n\tfreeaddrinfo(result);\n}\n\nstatic int setup_tag(char *tag[32], char *line)\n{\n\tint i = 0;\n\tchar *context;\n\n\ttag[0] = strtok_r(line, \"\\t \\r\\n\", &context);\n\n\twhile (tag[i] && i < 31) {\n\t\ttag[++i] = strtok_r(NULL, \"\\t \\r\\n\", &context);\n\t}\n\twhile (i < 32) {\n\t\ttag[i++] = \"\";\n\t}\n\n\tif (!tag[0][0]) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttag[i] = strdup(url_decode(tag[i]));\n\t}\n\n\treturn 1;\n}\n\nstatic void destroy_tag(char *tag[32])\n{\n\tint i = 0;\n\tfor (i = 0; i < 32; i++)\n\t\tfree(tag[i]);\n}\nvoid csync_daemon_session()\n{\n\tstatic char line[4 * 4096];\n\tstruct stat sb;\n\taddress_t peername = { .sa.sa_family = AF_UNSPEC, };\n\tsocklen_t peerlen = sizeof(peername);\n\tchar *peer=0, *tag[32];\n\tint i;\n\n\n\tif (fstat(0, &sb))\n\t\tcsync_fatal(\"Can't run fstat on fd 0: %s\", strerror(errno));\n\n\tswitch (sb.st_mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tif ( getpeername(0, &peername.sa, &peerlen) == -1 )\n\t\t\tcsync_fatal(\"Can't run getpeername on fd 0: %s\", strerror(errno));\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tset_peername_from_env(&peername, \"SSH_CLIENT\");\n\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tcsync_fatal(\"I'm only talking to sockets or pipes! %x\\n\", sb.st_mode & S_IFMT);\n\t\tbreak;\n\t}\n\n\twhile ( conn_gets(line, sizeof(line)) ) {\n\t\tint cmdnr;\n\n\t\tif (!setup_tag(tag, line))\n\t\t\tcontinue;\n\n\t\tfor (cmdnr=0; cmdtab[cmdnr].text; cmdnr++)\n\t\t\tif ( !strcasecmp(cmdtab[cmdnr].text, tag[0]) ) break;\n\n\t\tif ( !cmdtab[cmdnr].text ) {\n\t\t\tcmd_error = conn_response(CR_ERR_UNKNOWN_COMMAND);\n\t\t\tgoto abort_cmd;\n\t\t}\n\n\t\tcmd_error = 0;\n\n\t\tif ( cmdtab[cmdnr].need_ident && !peer ) {\n\t\t\tconn_printf(\"Dear %s, please identify first.\\n\",\n\t\t\t\t    csync_inet_ntop(&peername) ?: \"stranger\");\n\t\t\tgoto next_cmd;\n\t\t}\n\n\t\tif ( cmdtab[cmdnr].check_perm )\n\t\t\ton_cygwin_lowercase(tag[2]);\n\n\t\tif ( cmdtab[cmdnr].check_perm ) {\n\t\t\tif ( cmdtab[cmdnr].check_perm == 2 )\n\t\t\t\tcsync_compare_mode = 1;\n\t\t\tint perm = csync_perm(tag[2], tag[1], peer);\n\t\t\tif ( cmdtab[cmdnr].check_perm == 2 )\n\t\t\t\tcsync_compare_mode = 0;\n\t\t\tif ( perm ) {\n\t\t\t\tif ( perm == 2 ) {\n\t\t\t\t\tcsync_mark(tag[2], peer, 0);\n\t\t\t\t\tcmd_error = conn_response(CR_ERR_PERM_DENIED_FOR_SLAVE);\n\t\t\t\t} else\n\t\t\t\t\tcmd_error = conn_response(CR_ERR_PERM_DENIED);\n\t\t\t\tgoto abort_cmd;\n\t\t\t}\n\t\t}\n\n\t\tif ( cmdtab[cmdnr].check_dirty &&\n\t\t\tcsync_check_dirty(tag[2], peer, cmdtab[cmdnr].action == A_FLUSH) )\n\t\t\tgoto abort_cmd;\n\n\t\tif ( cmdtab[cmdnr].unlink )\n\t\t\tcsync_unlink(tag[2], cmdtab[cmdnr].unlink);\n\n\t\tswitch ( cmdtab[cmdnr].action )\n\t\t{\n\t\tcase A_SIG:\n\t\t\t{\n\t\t\t\tstruct stat st;\n\n\t\t\t\tif ( lstat_strict(prefixsubst(tag[2]), &st) != 0 ) {\n\t\t\t\t\tif ( errno == ENOENT ) {\n\t\t\t\t\t\tstruct stat sb;\n\t\t\t\t\t\tchar parent_dirname[strlen(tag[2])];\n\t\t\t\t\t\tsplit_dirname_basename(parent_dirname, NULL, tag[2]);\n\t\t\t\t\t\tif ( lstat_strict(prefixsubst(parent_dirname), &sb) != 0 )\n\t\t\t\t\t\t\tcmd_error = conn_response(CR_ERR_PARENT_DIR_MISSING);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tconn_resp_zero(CR_OK_PATH_NOT_FOUND);\n\t\t\t\t\t} else\n\t\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tif ( csync_check_pure(tag[2]) ) {\n\t\t\t\t\t\tconn_resp_zero(CR_OK_NOT_FOUND);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tconn_resp(CR_OK_DATA_FOLLOWS);\n\t\t\t\tconn_printf(\"%s\\n\", csync_genchecktxt(&st, tag[2], 1));\n\n\t\t\t\tif ( S_ISREG(st.st_mode) )\n\t\t\t\t\tcsync_rs_sig(tag[2]);\n\t\t\t\telse\n\t\t\t\t\tconn_printf(\"octet-stream 0\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_MARK:\n\t\t\tcsync_mark(tag[2], peer, 0);\n\t\t\tbreak;\n\t\tcase A_TYPE:\n\t\t\t{\n\t\t\t\tFILE *f = fopen(prefixsubst(tag[2]), \"rb\");\n\n\t\t\t\tif (!f && errno == ENOENT)\n\t\t\t\t\tf = fopen(\"/dev/null\", \"rb\");\n\n\t\t\t\tif (f) {\n\t\t\t\t\tchar buffer[512];\n\t\t\t\t\tsize_t rc;\n\n\t\t\t\t\tconn_resp(CR_OK_DATA_FOLLOWS);\n\t\t\t\t\twhile ( (rc=fread(buffer, 1, 512, f)) > 0 )\n\t\t\t\t\t\tif ( conn_write(buffer, rc) != rc ) {\n\t\t\t\t\t\t\tconn_printf(\"[[ %s ]]\", strerror(errno));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tfclose(f);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_GETTM:\n\t\tcase A_GETSZ:\n\t\t\t{\n\t\t\t\tstruct stat sbuf;\n\t\t\t\tconn_resp(CR_OK_DATA_FOLLOWS);\n\t\t\t\tif (!lstat_strict(prefixsubst(tag[2]), &sbuf))\n\t\t\t\t\tconn_printf(\"%ld\\n\", cmdtab[cmdnr].action == A_GETTM ?\n\t\t\t\t\t\t\t(long)sbuf.st_mtime : (long)sbuf.st_size);\n\t\t\t\telse\n\t\t\t\t\tconn_printf(\"-1\\n\");\n\t\t\t\tgoto next_cmd;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_FLUSH:\n\t\t\tSQL(\"Flushing dirty entry (if any) for file\",\n\t\t\t\t\"DELETE FROM dirty WHERE filename = '%s'\",\n\t\t\t\turl_encode(tag[2]));\n\t\t\tbreak;\n\t\tcase A_DEL:\n\t\t\tif (!csync_file_backup(tag[2]))\n\t\t\t\tcsync_unlink(tag[2], 0);\n\t\t\tbreak;\n\t\tcase A_PATCH:\n\t\t\tif (!csync_file_backup(tag[2])) {\n\t\t\t\tconn_resp(CR_OK_SEND_DATA);\n\t\t\t\tcsync_rs_sig(tag[2]);\n\t\t\t\tif (csync_rs_patch(tag[2]))\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_MKDIR:\n\t\t\t/* ignore errors on creating directories if the\n\t\t\t * directory does exist already. we don't need such\n\t\t\t * a check for the other file types, because they\n\t\t\t * will simply be unlinked if already present.\n\t\t\t */\n#ifdef __CYGWIN__\n\t\t\t// This creates the file using the native windows API, bypassing\n\t\t\t// the cygwin wrappers and so making sure that we do not mess up the\n\t\t\t// permissions..\n\t\t\t{\n\t\t\t\tchar winfilename[MAX_PATH];\n\t\t\t\tcygwin_conv_to_win32_path(prefixsubst(tag[2]), winfilename);\n\n\t\t\t\tif ( !CreateDirectory(TEXT(winfilename), NULL) ) {\n\t\t\t\t\tstruct stat st;\n\t\t\t\t\tif ( lstat_strict(prefixsubst(tag[2]), &st) != 0 || !S_ISDIR(st.st_mode)) {\n\t\t\t\t\t\tcsync_debug(1, \"Win32 I/O Error %d in mkdir command: %s\\n\",\n\t\t\t\t\t\t\t\t(int)GetLastError(), winfilename);\n\t\t\t\t\t\tcmd_error = conn_response(CR_ERR_WIN32_EIO_CREATE_DIR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif ( mkdir(prefixsubst(tag[2]), 0700) ) {\n\t\t\t\tstruct stat st;\n\t\t\t\tif ( lstat_strict((prefixsubst(tag[2])), &st) != 0 || !S_ISDIR(st.st_mode))\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase A_MKCHR:\n\t\t\tif ( mknod(prefixsubst(tag[2]), 0700|S_IFCHR, atoi(tag[3])) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKBLK:\n\t\t\tif ( mknod(prefixsubst(tag[2]), 0700|S_IFBLK, atoi(tag[3])) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKFIFO:\n\t\t\tif ( mknod(prefixsubst(tag[2]), 0700|S_IFIFO, 0) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKLINK:\n\t\t\tif ( symlink(tag[3], prefixsubst(tag[2])) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKSOCK:\n\t\t\t/* just ignore socket files */\n\t\t\tbreak;\n\t\tcase A_SETOWN:\n\t\t\tif ( !csync_ignore_uid || !csync_ignore_gid ) {\n\t\t\t\tint uid = csync_ignore_uid ? -1 : atoi(tag[3]);\n\t\t\t\tint gid = csync_ignore_gid ? -1 : atoi(tag[4]);\n\t\t\t\tif ( lchown(prefixsubst(tag[2]), uid, gid) )\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_SETMOD:\n\t\t\tif ( !csync_ignore_mod ) {\n\t\t\t\tif ( chmod(prefixsubst(tag[2]), atoi(tag[3])) )\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_SETIME:\n\t\t\t{\n\t\t\t\tstruct utimbuf utb;\n\t\t\t\tutb.actime = atoll(tag[3]);\n\t\t\t\tutb.modtime = atoll(tag[3]);\n\t\t\t\tif ( utime(prefixsubst(tag[2]), &utb) )\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_LIST:\n\t\t\tSQL_BEGIN(\"DB Dump - Files for sync pair\",\n\t\t\t\t\"SELECT checktxt, filename FROM file %s%s%s ORDER BY filename\",\n\t\t\t\t\tstrcmp(tag[2], \"-\") ? \"WHERE filename = '\" : \"\",\n\t\t\t\t\tstrcmp(tag[2], \"-\") ? url_encode(tag[2]) : \"\",\n\t\t\t\t\tstrcmp(tag[2], \"-\") ? \"'\" : \"\")\n\t\t\t{\n\t\t\t\tif ( csync_match_file_host(url_decode(SQL_V(1)), tag[1], peer, (const char **)&tag[3]) )\n\t\t\t\t\tconn_printf(\"%s\\t%s\\n\", SQL_V(0), SQL_V(1));\n\t\t\t} SQL_END;\n\t\t\tbreak;\n\n\t\tcase A_DEBUG:\n\t\t\tcsync_debug_out = stdout;\n\t\t\tif ( tag[1][0] )\n\t\t\t\tcsync_debug_level = atoi(tag[1]);\n\t\t\tbreak;\n\t\tcase A_HELLO:\n\t\t\tif (peer) {\n\t\t\t\tfree(peer);\n\t\t\t\tpeer = NULL;\n\t\t\t}\n\t\t\tif (verify_peername(tag[1], &peername)) {\n\t\t\t\tpeer = strdup(tag[1]);\n\t\t\t} else {\n\t\t\t\tpeer = NULL;\n\t\t\t\tcmd_error = conn_response(CR_ERR_IDENTIFICATION_FAILED);\n\t\t\t\tbreak;\n\t\t\t}\n#ifdef HAVE_LIBGNUTLS\n\t\t\tif (!csync_conn_usessl) {\n\t\t\t\tstruct csync_nossl *t;\n\t\t\t\tfor (t = csync_nossl; t; t=t->next) {\n\t\t\t\t\tif ( !fnmatch(t->pattern_from, myhostname, 0) &&\n\t\t\t\t\t     !fnmatch(t->pattern_to, peer, 0) )\n\t\t\t\t\t\tgoto conn_without_ssl_ok;\n\t\t\t\t}\n\t\t\t\tcmd_error = conn_response(CR_ERR_SSL_EXPECTED);\n\t\t\t}\nconn_without_ssl_ok:;\n#endif\n\t\t\tbreak;\n\t\tcase A_GROUP:\n\t\t\tif (active_grouplist) {\n\t\t\t\tcmd_error = conn_response(CR_ERR_GROUP_LIST_ALREADY_SET);\n\t\t\t} else {\n\t\t\t\tconst struct csync_group *g;\n\t\t\t\tint i, gnamelen;\n\n\t\t\t\tactive_grouplist = strdup(tag[1]);\n\t\t\t\tfor (g=csync_group; g; g=g->next) {\n\t\t\t\t\tif (!g->myname) continue;\n\n\t\t\t\t\ti=0;\n\t\t\t\t\tgnamelen = strlen(csync_group->gname);\n\t\t\t\t\twhile (active_grouplist[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( !strncmp(active_grouplist+i, csync_group->gname, gnamelen) &&\n\t\t\t\t\t\t\t\t(active_grouplist[i+gnamelen] == ',' ||\n\t\t\t\t\t\t\t\t !active_grouplist[i+gnamelen]) )\n\t\t\t\t\t\t\tgoto found_asactive;\n\t\t\t\t\t\twhile (active_grouplist[i])\n\t\t\t\t\t\t\tif (active_grouplist[i++]==',') break;\n\t\t\t\t\t}\n\t\t\t\t\tcsync_group->myname = 0;\nfound_asactive: ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_BYE:\n\t\t\tfor (i=0; i<32; i++)\n\t\t\t\tfree(tag[i]);\n\t\t\tconn_resp(CR_OK_CU_LATER);\n\t\t\treturn;\n\t\t}\n\n\t\tif ( cmdtab[cmdnr].update )\n\t\t\tcsync_file_update(tag[2], peer);\n\n\t\tif ( cmdtab[cmdnr].update == 1 ) {\n\t\t\tcsync_debug(1, \"Updated %s from %s.\\n\",\n\t\t\t\t\ttag[2], peer ? peer : \"???\");\n\t\t\tcsync_schedule_commands(tag[2], 0);\n\t\t}\n\nabort_cmd:\n\t\tif ( cmd_error )\n\t\t\tconn_printf(\"%s\\n\", cmd_error);\n\t\telse\n\t\t\tconn_resp(CR_OK_CMD_FINISHED);\n\nnext_cmd:\n\t\tdestroy_tag(tag);\n\t}\n}\n"], "fixing_code": ["/*\n *  csync2 - cluster synchronization tool, 2nd generation\n *  Copyright (C) 2004 - 2015 LINBIT Information Technologies GmbH\n *  http://www.linbit.com; see also AUTHORS\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"csync2.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <fnmatch.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <utime.h>\n#include <errno.h>\n#include <netdb.h>\n#include <fcntl.h>\n\n#ifdef __CYGWIN__\n#include <w32api/windows.h>\n#endif\n\nstatic const char *cmd_error;\n\nint csync_setBackupFileStatus(char *filename, int backupDirLength);\n\n\nint csync_unlink(const char *filename, int ign)\n{\n\tstruct stat st;\n\tint rc;\n\n\tif ( lstat_strict(prefixsubst(filename), &st) != 0 ) return 0;\n\tif ( ign==2 && S_ISREG(st.st_mode) ) return 0;\n\trc = S_ISDIR(st.st_mode) ? rmdir(prefixsubst(filename)) : unlink(prefixsubst(filename));\n\n\tif ( rc && !ign ) cmd_error = strerror(errno);\n\treturn rc;\n}\n\nint csync_check_dirty(const char *filename, const char *peername, int isflush)\n{\n\tint rc = 0;\n\tcsync_check(filename, 0, 0);\n\tif (isflush) return 0;\n\tSQL_BEGIN(\"Check if file is dirty\",\n\t\t\"SELECT 1 FROM dirty WHERE filename = '%s' LIMIT 1\",\n\t\turl_encode(filename))\n\t{\n\t\trc = 1;\n\t\tcmd_error = conn_response(CR_ERR_ALSO_DIRTY_HERE);\n\t} SQL_END;\n\tif (rc && peername)\n\t\tcsync_mark(filename, peername, 0);\n\treturn rc;\n}\n\nvoid csync_file_update(const char *filename, const char *peername)\n{\n\tstruct stat st;\n\tSQL(\"Removing file from dirty db\",\n\t\t\t\"delete from dirty where filename = '%s' and peername = '%s'\",\n\t\t\turl_encode(filename), peername);\n\tif ( lstat_strict(prefixsubst(filename), &st) != 0 || csync_check_pure(filename) ) {\n\t\tSQL(\"Removing file from file db\",\n\t\t\t\"delete from file where filename = '%s'\",\n\t\t\turl_encode(filename));\n\t} else {\n\t\tconst char *checktxt = csync_genchecktxt(&st, filename, 0);\n\n\t\tSQL(\"Deleting old record from file db\",\n\t\t\t\"DELETE FROM file WHERE filename = '%s'\",\n\t\t\turl_encode(filename));\n\n\t\tSQL(\"Insert record to file db\",\n\t\t\t\"INSERT INTO file (filename, checktxt) values \"\n\t\t\t\"('%s', '%s')\", url_encode(filename),\n\t\t\turl_encode(checktxt));\n\t}\n}\n\nvoid csync_file_flush(const char *filename)\n{\n\tSQL(\"Removing file from dirty db\",\n\t\t\"delete from dirty where filename ='%s'\",\n\t\turl_encode(filename));\n}\n\nint csync_file_backup(const char *filepath)\n{\n\tstatic char error_buffer[1024];\n\tconst struct csync_group *g = NULL;\n\tstruct stat buf;\n\tint rc;\n\t/* ==============================================================================================\n\t * As of now, filepath may only contain prefixes but we may need to resolve other\n\t * dynamic references like environment variables, symbolic links, etc in future\n\t * if we plan to support those in later releases\n\t *==============================================================================================*/\n\tconst char *filename = prefixsubst(filepath);\n\tint filename_len = strlen(filename);\t//can filename be null?\n\n\twhile ((g = csync_find_next(g, filepath))) {\n\t\tif (g->backup_directory && g->backup_generations > 1) {\n\t\t\tunsigned int bak_dir_len = strlen(g->backup_directory);\n\t\t\tchar backup_filename[bak_dir_len + filename_len + 12];\n\t\t\tchar backup_otherfilename[bak_dir_len + filename_len + 12];\n\t\t\tint fd_in, fd_out;\n\t\t\tunsigned int i, lastSlash = 0;\n\t\t\tmode_t mode;\n\n\t\t\tcsync_debug(1, \"backup %s for group %s\\n\", filename, g->gname);\n\n\t\t\tif (stat(g->backup_directory, &buf) != 0) {\n\t\t\t\tcsync_debug(3, \"backup directory configured is not present, so creating it\");\n\t\t\t\tif (mkpath(g->backup_directory, 0700)) {\n\t\t\t\t\tcsync_debug(1,\n\t\t\t\t\t\t    \"ERROR : unable to create backup directory %s ; backup failed \\n\",\n\t\t\t\t\t\t    g->backup_directory);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else if (!S_ISDIR(buf.st_mode)) {\n\t\t\t\tcsync_debug(1,\n\t\t\t\t\t    \"ERROR : location configured for backup %s is not a directory; backup failed \\n\",\n\t\t\t\t\t    g->backup_directory);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// Skip generation of directories\n\t\t\trc = stat(filename, &buf);\n\t\t\tif (S_ISDIR(buf.st_mode)) {\n\t\t\t\tcsync_debug(1, \"directory. Skip generation \\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfd_in = open(filename, O_RDONLY);\n\t\t\tif (fd_in < 0)\n\t\t\t\treturn 0;\n\n\t\t\tmemcpy(backup_filename, g->backup_directory, bak_dir_len);\n\t\t\tbackup_filename[bak_dir_len] = 0;\n\t\t\tmode = 0700;\n\n\t\t\t/* open coded strrchr?? why? */\n\t\t\tfor (i = filename_len; i > 0; i--)\n\t\t\t\tif (filename[i] == '/') {\n\t\t\t\t\tlastSlash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tfor (i = 0; i < filename_len; i++) {\n\t\t\t\t// Create directories in filename\n\t\t\t\t// TODO: Get the mode from the orig. dir\n\t\t\t\tif (filename[i] == '/' && i <= lastSlash) {\n\n\t\t\t\t\tbackup_filename[bak_dir_len + i] = 0;\n\n\t\t\t\t\tcsync_debug(1, \"mkdir %s \\n\", backup_filename);\n\n\t\t\t\t\tmkdir(backup_filename, mode);\n\t\t\t\t\t// Dont check the empty string.\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tcsync_setBackupFileStatus(backup_filename, bak_dir_len);\n\n\t\t\t\t}\n\t\t\t\tbackup_filename[bak_dir_len + i] = filename[i];\n\t\t\t}\n\n\t\t\tbackup_filename[bak_dir_len + filename_len] = 0;\n\t\t\tbackup_filename[bak_dir_len] = '/';\n\t\t\tmemcpy(backup_otherfilename, backup_filename, bak_dir_len + filename_len);\n\n\t\t\tfor (i = g->backup_generations - 1; i; i--) {\n\n\t\t\t\tif (i != 1)\n\t\t\t\t\tsnprintf(backup_filename + bak_dir_len + filename_len, 12, \".%u\", i - 1);\n\t\t\t\tbackup_filename[bak_dir_len + filename_len] = '\\0';\n\t\t\t\tsnprintf(backup_otherfilename + bak_dir_len + filename_len, 12, \".%u\", i);\n\n\t\t\t\trc = rename(backup_filename, backup_otherfilename);\n\t\t\t\tcsync_debug(1,\n\t\t\t\t\t    \"renaming backup files '%s' to '%s'. rc = %d\\n\",\n\t\t\t\t\t    backup_filename, backup_otherfilename, rc);\n\t\t\t}\n\n\t\t\t/* strcpy(backup_filename+bak_dir_len+filename_len, \"\"); */\n\n\t\t\tfd_out = open(backup_filename, O_WRONLY | O_CREAT, 0600);\n\n\t\t\tif (fd_out < 0) {\n\t\t\t\tsnprintf(error_buffer, 1024, \"Open error while backing up '%s': %s\\n\", filename, strerror(errno));\n\t\t\t\tcmd_error = error_buffer;\n\t\t\t\tclose(fd_in);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tcsync_debug(1, \"Copying data from %s to backup file %s \\n\", filename, backup_filename);\n\n\t\t\trc = csync_copy_file(fd_in, fd_out);\n\t\t\tif (rc != 0) {\n\t\t\t\tcsync_debug(1, \"csync_backup error 2\\n\");\n\n\t\t\t\tsnprintf(error_buffer, 1024, \"Write error while backing up '%s': %s\\n\", filename, strerror(errno));\n\n\t\t\t\tcmd_error = error_buffer;\n\t\t\t\t// TODO verify file disapeared ?\n\t\t\t\t//\n\t\t\t\t// return 1;\n\t\t\t}\n\t\t\tcsync_setBackupFileStatus(backup_filename, bak_dir_len);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint csync_copy_file(int fd_in, int fd_out)\n{\n\tchar buffer[512];\n\tint read_len = read(fd_in, buffer, 512);\n\n\twhile (read_len > 0) {\n\t\tint write_len = 0;\n\n\t\twhile (write_len < read_len) {\n\t\t\tint rc = write(fd_out, buffer + write_len,\n\t\t\t\t       read_len - write_len);\n\t\t\tif (rc == -1) {\n\t\t\t\tclose(fd_in);\n\t\t\t\tclose(fd_out);\n\t\t\t\t//TODO verify return code.\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t\twrite_len += rc;\n\t\t}\n\t\tread_len = read(fd_in, buffer, 512);\n\t}\n\tclose(fd_in);\n\tclose(fd_out);\n\treturn 0;\n}\n\n/* get the mode from the orig directory.\n   Looking from the back_dir_len should produce the original dir.\n*/\nint csync_setBackupFileStatus(char *filename, int backupDirLength)\n{\n\n\tstruct stat buf;\n\tint rc = stat((filename + backupDirLength), &buf);\n\tif (rc == 0) {\n\t\tcsync_debug(1, \"Stating original file %s rc: %d mode: %o \\n\", (filename + backupDirLength), rc, buf.st_mode);\n\n\t\trc = chown(filename, buf.st_uid, buf.st_gid);\n\t\tcsync_debug(rc == 0, \"Changing owner of %s to user %d and group %d, rc= %d \\n\", filename, buf.st_uid, buf.st_gid, rc);\n\n\t\trc = chmod(filename, buf.st_mode);\n\t\tcsync_debug(rc == 0, \"Changing mode of %s to mode %o, rc= %d \\n\", filename, buf.st_mode, rc);\n\n\t} else {\n\t\tcsync_debug(0, \"Error getting mode and owner ship from %s \\n\", (filename + backupDirLength));\n\t\treturn -1;\n\t}\n\treturn 0;\n};\n\nstruct csync_command {\n\tchar *text;\n\tint check_perm;\n\tint check_dirty;\n\tint unlink;\n\tint update;\n\tint need_ident;\n\tint action;\n};\n\nenum {\n\tA_SIG, A_FLUSH, A_MARK, A_TYPE, A_GETTM, A_GETSZ, A_DEL, A_PATCH,\n\tA_MKDIR, A_MKCHR, A_MKBLK, A_MKFIFO, A_MKLINK, A_MKSOCK,\n\tA_SETOWN, A_SETMOD, A_SETIME, A_LIST, A_GROUP,\n\tA_DEBUG, A_HELLO, A_BYE\n};\n\nstruct csync_command cmdtab[] = {\n\t{ \"sig\",\t1, 0, 0, 0, 1, A_SIG\t},\n\t{ \"mark\",\t1, 0, 0, 0, 1, A_MARK\t},\n\t{ \"type\",\t2, 0, 0, 0, 1, A_TYPE\t},\n\t{ \"gettm\",\t1, 0, 0, 0, 1, A_GETTM\t},\n\t{ \"getsz\",\t1, 0, 0, 0, 1, A_GETSZ\t},\n\t{ \"flush\",\t1, 1, 0, 0, 1, A_FLUSH\t},\n\t{ \"del\",\t1, 1, 0, 1, 1, A_DEL\t},\n\t{ \"patch\",\t1, 1, 2, 1, 1, A_PATCH\t},\n\t{ \"mkdir\",\t1, 1, 1, 1, 1, A_MKDIR\t},\n\t{ \"mkchr\",\t1, 1, 1, 1, 1, A_MKCHR\t},\n\t{ \"mkblk\",\t1, 1, 1, 1, 1, A_MKBLK\t},\n\t{ \"mkfifo\",\t1, 1, 1, 1, 1, A_MKFIFO\t},\n\t{ \"mklink\",\t1, 1, 1, 1, 1, A_MKLINK\t},\n\t{ \"mksock\",\t1, 1, 1, 1, 1, A_MKSOCK\t},\n\t{ \"setown\",\t1, 1, 0, 2, 1, A_SETOWN\t},\n\t{ \"setmod\",\t1, 1, 0, 2, 1, A_SETMOD\t},\n\t{ \"setime\",\t1, 0, 0, 2, 1, A_SETIME\t},\n\t{ \"list\",\t0, 0, 0, 0, 1, A_LIST\t},\n#if 0\n\t{ \"debug\",\t0, 0, 0, 0, 1, A_DEBUG\t},\n#endif\n\t{ \"group\",\t0, 0, 0, 0, 0, A_GROUP\t},\n\t{ \"hello\",\t0, 0, 0, 0, 0, A_HELLO\t},\n\t{ \"bye\",\t0, 0, 0, 0, 0, A_BYE\t},\n\t{ 0,\t\t0, 0, 0, 0, 0, 0\t}\n};\n\ntypedef union address {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in sa_in;\n\tstruct sockaddr_in6 sa_in6;\n\tstruct sockaddr_storage ss;\n} address_t;\n\nconst char *csync_inet_ntop(address_t *addr)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\tsa_family_t af = addr->sa.sa_family;\n\treturn inet_ntop(af,\n\t\taf == AF_INET  ? (void*)&addr->sa_in.sin_addr :\n\t\taf == AF_INET6 ? (void*)&addr->sa_in6.sin6_addr : NULL,\n\t\tbuf, sizeof(buf));\n}\n\n/*\n * Loops (to cater for multihomed peers) through the address list returned by\n * gethostbyname(), returns 1 if any match with the address obtained from\n * getpeername() during session startup.\n * Otherwise returns 0 (-> identification failed).\n *\n * TODO switch to a getnameinfo in conn_open.\n * TODO add a \"pre-authenticated\" pipe mode for use over ssh */\nint verify_peername(const char *name, address_t *peeraddr)\n{\n\tsa_family_t af = peeraddr->sa.sa_family;\n\tstruct addrinfo hints;\n\tstruct addrinfo *result, *rp;\n\tint try_mapped_ipv4;\n\tint s;\n\n\t/* Obtain address(es) matching host */\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = AF_UNSPEC;     /* Allow IPv4 or IPv6 */\n\thints.ai_socktype = SOCK_STREAM; /* Datagram socket */\n\n\ts = getaddrinfo(name, NULL, &hints, &result);\n\tif (s != 0) {\n\t\tcsync_debug(1, \"getaddrinfo: %s\\n\", gai_strerror(s));\n\t\treturn 0;\n\t}\n\n\ttry_mapped_ipv4 =\n\t\taf == AF_INET6 &&\n\t\t!memcmp(&peeraddr->sa_in6.sin6_addr,\n\t\t\t\"\\0\\0\\0\\0\" \"\\0\\0\\0\\0\" \"\\0\\0\\xff\\xff\", 12);\n\n\t/* getaddrinfo() returns a list of address structures.\n\t * Try each address. */\n\n\tfor (rp = result; rp != NULL; rp = rp->ai_next) {\n\t\t/* both IPv4 */\n\t\tif (af == AF_INET && rp->ai_family == AF_INET &&\n\t\t    !memcmp(&((struct sockaddr_in*)rp->ai_addr)->sin_addr,\n\t\t\t    &peeraddr->sa_in.sin_addr, sizeof(struct in_addr)))\n\t\t\tbreak;\n\t\t/* both IPv6 */\n\t\tif (af == AF_INET6 && rp->ai_family == AF_INET6 &&\n\t\t    !memcmp(&((struct sockaddr_in6*)rp->ai_addr)->sin6_addr,\n\t\t\t    &peeraddr->sa_in6.sin6_addr, sizeof(struct in6_addr)))\n\t\t\tbreak;\n\t\t/* peeraddr IPv6, but actually ::ffff:I.P.v.4,\n\t\t * and forward lookup returned IPv4 only */\n\t\tif (af == AF_INET6 && rp->ai_family == AF_INET &&\n\t\t    try_mapped_ipv4 &&\n\t\t    !memcmp(&((struct sockaddr_in*)rp->ai_addr)->sin_addr,\n\t\t\t    (unsigned char*)&peeraddr->sa_in6.sin6_addr + 12,\n\t\t\t    sizeof(struct in_addr)))\n\t\t\tbreak;\n\t}\n\tfreeaddrinfo(result);\n\tif (rp != NULL) /* memcmp found a match */\n\t\treturn conn_check_peer_cert(name, 0);\n\treturn 0;\n}\n\n/* Why do all this fuzz, and not simply --assume-authenticated?\n * To limit the impact of an accidental misconfiguration.\n */\nvoid set_peername_from_env(address_t *p, const char *env)\n{\n\tstruct addrinfo hints = {\n\t\t.ai_family = AF_UNSPEC,\n\t\t.ai_socktype = SOCK_STREAM,\n\t\t.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV,\n\t};\n\tstruct addrinfo *result;\n\tchar *c;\n\tint s;\n\n\tchar *val = getenv(env);\n\tcsync_debug(3, \"getenv(%s): >>%s<<\\n\", env, val ?: \"\");\n\tif (!val)\n\t\treturn;\n\tval = strdup(val);\n\tif (!val)\n\t\treturn;\n\n\tc = strchr(val, ' ');\n\tif (!c)\n\t\treturn;\n\t*c = '\\0';\n\n\ts = getaddrinfo(val, NULL, &hints, &result);\n\tif (s != 0) {\n\t\tcsync_debug(1, \"getaddrinfo: %s\\n\", gai_strerror(s));\n\t\treturn;\n\t}\n\n\t/* getaddrinfo() may return a list of address structures.\n\t * Use the first one. */\n\tif (result)\n\t\tmemcpy(p, result->ai_addr, result->ai_addrlen);\n\tfreeaddrinfo(result);\n}\n\nstatic int setup_tag(char *tag[32], char *line)\n{\n\tint i = 0;\n\tchar *context;\n\n\ttag[0] = strtok_r(line, \"\\t \\r\\n\", &context);\n\n\twhile (tag[i] && i < 31) {\n\t\ttag[++i] = strtok_r(NULL, \"\\t \\r\\n\", &context);\n\t}\n\twhile (i < 32) {\n\t\ttag[i++] = \"\";\n\t}\n\n\tif (!tag[0][0]) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 32; i++) {\n\t\ttag[i] = strdup(url_decode(tag[i]));\n\t}\n\n\treturn 1;\n}\n\nstatic void destroy_tag(char *tag[32])\n{\n\tint i = 0;\n\tfor (i = 0; i < 32; i++)\n\t\tfree(tag[i]);\n}\nvoid csync_daemon_session()\n{\n\tstatic char line[4 * 4096];\n\tstruct stat sb;\n\taddress_t peername = { .sa.sa_family = AF_UNSPEC, };\n\tsocklen_t peerlen = sizeof(peername);\n\tchar *peer=0, *tag[32];\n\tint i;\n\n\n\tif (fstat(0, &sb))\n\t\tcsync_fatal(\"Can't run fstat on fd 0: %s\", strerror(errno));\n\n\tswitch (sb.st_mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tif ( getpeername(0, &peername.sa, &peerlen) == -1 )\n\t\t\tcsync_fatal(\"Can't run getpeername on fd 0: %s\", strerror(errno));\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tset_peername_from_env(&peername, \"SSH_CLIENT\");\n\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tcsync_fatal(\"I'm only talking to sockets or pipes! %x\\n\", sb.st_mode & S_IFMT);\n\t\tbreak;\n\t}\n\n\twhile ( conn_gets(line, sizeof(line)) ) {\n\t\tint cmdnr;\n\n\t\tif (!setup_tag(tag, line))\n\t\t\tcontinue;\n\n\t\tfor (cmdnr=0; cmdtab[cmdnr].text; cmdnr++)\n\t\t\tif ( !strcasecmp(cmdtab[cmdnr].text, tag[0]) ) break;\n\n\t\tif ( !cmdtab[cmdnr].text ) {\n\t\t\tcmd_error = conn_response(CR_ERR_UNKNOWN_COMMAND);\n\t\t\tgoto abort_cmd;\n\t\t}\n\n\t\tcmd_error = 0;\n\n\t\tif ( cmdtab[cmdnr].need_ident && !peer ) {\n\t\t\tconn_printf(\"Dear %s, please identify first.\\n\",\n\t\t\t\t    csync_inet_ntop(&peername) ?: \"stranger\");\n\t\t\tgoto next_cmd;\n\t\t}\n\n\t\tif ( cmdtab[cmdnr].check_perm )\n\t\t\ton_cygwin_lowercase(tag[2]);\n\n\t\tif ( cmdtab[cmdnr].check_perm ) {\n\t\t\tif ( cmdtab[cmdnr].check_perm == 2 )\n\t\t\t\tcsync_compare_mode = 1;\n\t\t\tint perm = csync_perm(tag[2], tag[1], peer);\n\t\t\tif ( cmdtab[cmdnr].check_perm == 2 )\n\t\t\t\tcsync_compare_mode = 0;\n\t\t\tif ( perm ) {\n\t\t\t\tif ( perm == 2 ) {\n\t\t\t\t\tcsync_mark(tag[2], peer, 0);\n\t\t\t\t\tcmd_error = conn_response(CR_ERR_PERM_DENIED_FOR_SLAVE);\n\t\t\t\t} else\n\t\t\t\t\tcmd_error = conn_response(CR_ERR_PERM_DENIED);\n\t\t\t\tgoto abort_cmd;\n\t\t\t}\n\t\t}\n\n\t\tif ( cmdtab[cmdnr].check_dirty &&\n\t\t\tcsync_check_dirty(tag[2], peer, cmdtab[cmdnr].action == A_FLUSH) )\n\t\t\tgoto abort_cmd;\n\n\t\tif ( cmdtab[cmdnr].unlink )\n\t\t\tcsync_unlink(tag[2], cmdtab[cmdnr].unlink);\n\n\t\tswitch ( cmdtab[cmdnr].action )\n\t\t{\n\t\tcase A_SIG:\n\t\t\t{\n\t\t\t\tstruct stat st;\n\n\t\t\t\tif ( lstat_strict(prefixsubst(tag[2]), &st) != 0 ) {\n\t\t\t\t\tif ( errno == ENOENT ) {\n\t\t\t\t\t\tstruct stat sb;\n\t\t\t\t\t\tchar parent_dirname[strlen(tag[2])];\n\t\t\t\t\t\tsplit_dirname_basename(parent_dirname, NULL, tag[2]);\n\t\t\t\t\t\tif ( lstat_strict(prefixsubst(parent_dirname), &sb) != 0 )\n\t\t\t\t\t\t\tcmd_error = conn_response(CR_ERR_PARENT_DIR_MISSING);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tconn_resp_zero(CR_OK_PATH_NOT_FOUND);\n\t\t\t\t\t} else\n\t\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tif ( csync_check_pure(tag[2]) ) {\n\t\t\t\t\t\tconn_resp_zero(CR_OK_NOT_FOUND);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tconn_resp(CR_OK_DATA_FOLLOWS);\n\t\t\t\tconn_printf(\"%s\\n\", csync_genchecktxt(&st, tag[2], 1));\n\n\t\t\t\tif ( S_ISREG(st.st_mode) )\n\t\t\t\t\tcsync_rs_sig(tag[2]);\n\t\t\t\telse\n\t\t\t\t\tconn_printf(\"octet-stream 0\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_MARK:\n\t\t\tcsync_mark(tag[2], peer, 0);\n\t\t\tbreak;\n\t\tcase A_TYPE:\n\t\t\t{\n\t\t\t\tFILE *f = fopen(prefixsubst(tag[2]), \"rb\");\n\n\t\t\t\tif (!f && errno == ENOENT)\n\t\t\t\t\tf = fopen(\"/dev/null\", \"rb\");\n\n\t\t\t\tif (f) {\n\t\t\t\t\tchar buffer[512];\n\t\t\t\t\tsize_t rc;\n\n\t\t\t\t\tconn_resp(CR_OK_DATA_FOLLOWS);\n\t\t\t\t\twhile ( (rc=fread(buffer, 1, 512, f)) > 0 )\n\t\t\t\t\t\tif ( conn_write(buffer, rc) != rc ) {\n\t\t\t\t\t\t\tconn_printf(\"[[ %s ]]\", strerror(errno));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tfclose(f);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_GETTM:\n\t\tcase A_GETSZ:\n\t\t\t{\n\t\t\t\tstruct stat sbuf;\n\t\t\t\tconn_resp(CR_OK_DATA_FOLLOWS);\n\t\t\t\tif (!lstat_strict(prefixsubst(tag[2]), &sbuf))\n\t\t\t\t\tconn_printf(\"%ld\\n\", cmdtab[cmdnr].action == A_GETTM ?\n\t\t\t\t\t\t\t(long)sbuf.st_mtime : (long)sbuf.st_size);\n\t\t\t\telse\n\t\t\t\t\tconn_printf(\"-1\\n\");\n\t\t\t\tgoto next_cmd;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_FLUSH:\n\t\t\tSQL(\"Flushing dirty entry (if any) for file\",\n\t\t\t\t\"DELETE FROM dirty WHERE filename = '%s'\",\n\t\t\t\turl_encode(tag[2]));\n\t\t\tbreak;\n\t\tcase A_DEL:\n\t\t\tif (!csync_file_backup(tag[2]))\n\t\t\t\tcsync_unlink(tag[2], 0);\n\t\t\tbreak;\n\t\tcase A_PATCH:\n\t\t\tif (!csync_file_backup(tag[2])) {\n\t\t\t\tconn_resp(CR_OK_SEND_DATA);\n\t\t\t\tcsync_rs_sig(tag[2]);\n\t\t\t\tif (csync_rs_patch(tag[2]))\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_MKDIR:\n\t\t\t/* ignore errors on creating directories if the\n\t\t\t * directory does exist already. we don't need such\n\t\t\t * a check for the other file types, because they\n\t\t\t * will simply be unlinked if already present.\n\t\t\t */\n#ifdef __CYGWIN__\n\t\t\t// This creates the file using the native windows API, bypassing\n\t\t\t// the cygwin wrappers and so making sure that we do not mess up the\n\t\t\t// permissions..\n\t\t\t{\n\t\t\t\tchar winfilename[MAX_PATH];\n\t\t\t\tcygwin_conv_to_win32_path(prefixsubst(tag[2]), winfilename);\n\n\t\t\t\tif ( !CreateDirectory(TEXT(winfilename), NULL) ) {\n\t\t\t\t\tstruct stat st;\n\t\t\t\t\tif ( lstat_strict(prefixsubst(tag[2]), &st) != 0 || !S_ISDIR(st.st_mode)) {\n\t\t\t\t\t\tcsync_debug(1, \"Win32 I/O Error %d in mkdir command: %s\\n\",\n\t\t\t\t\t\t\t\t(int)GetLastError(), winfilename);\n\t\t\t\t\t\tcmd_error = conn_response(CR_ERR_WIN32_EIO_CREATE_DIR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif ( mkdir(prefixsubst(tag[2]), 0700) ) {\n\t\t\t\tstruct stat st;\n\t\t\t\tif ( lstat_strict((prefixsubst(tag[2])), &st) != 0 || !S_ISDIR(st.st_mode))\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase A_MKCHR:\n\t\t\tif ( mknod(prefixsubst(tag[2]), 0700|S_IFCHR, atoi(tag[3])) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKBLK:\n\t\t\tif ( mknod(prefixsubst(tag[2]), 0700|S_IFBLK, atoi(tag[3])) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKFIFO:\n\t\t\tif ( mknod(prefixsubst(tag[2]), 0700|S_IFIFO, 0) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKLINK:\n\t\t\tif ( symlink(tag[3], prefixsubst(tag[2])) )\n\t\t\t\tcmd_error = strerror(errno);\n\t\t\tbreak;\n\t\tcase A_MKSOCK:\n\t\t\t/* just ignore socket files */\n\t\t\tbreak;\n\t\tcase A_SETOWN:\n\t\t\tif ( !csync_ignore_uid || !csync_ignore_gid ) {\n\t\t\t\tint uid = csync_ignore_uid ? -1 : atoi(tag[3]);\n\t\t\t\tint gid = csync_ignore_gid ? -1 : atoi(tag[4]);\n\t\t\t\tif ( lchown(prefixsubst(tag[2]), uid, gid) )\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_SETMOD:\n\t\t\tif ( !csync_ignore_mod ) {\n\t\t\t\tif ( chmod(prefixsubst(tag[2]), atoi(tag[3])) )\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_SETIME:\n\t\t\t{\n\t\t\t\tstruct utimbuf utb;\n\t\t\t\tutb.actime = atoll(tag[3]);\n\t\t\t\tutb.modtime = atoll(tag[3]);\n\t\t\t\tif ( utime(prefixsubst(tag[2]), &utb) )\n\t\t\t\t\tcmd_error = strerror(errno);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_LIST:\n\t\t\tSQL_BEGIN(\"DB Dump - Files for sync pair\",\n\t\t\t\t\"SELECT checktxt, filename FROM file %s%s%s ORDER BY filename\",\n\t\t\t\t\tstrcmp(tag[2], \"-\") ? \"WHERE filename = '\" : \"\",\n\t\t\t\t\tstrcmp(tag[2], \"-\") ? url_encode(tag[2]) : \"\",\n\t\t\t\t\tstrcmp(tag[2], \"-\") ? \"'\" : \"\")\n\t\t\t{\n\t\t\t\tif ( csync_match_file_host(url_decode(SQL_V(1)), tag[1], peer, (const char **)&tag[3]) )\n\t\t\t\t\tconn_printf(\"%s\\t%s\\n\", SQL_V(0), SQL_V(1));\n\t\t\t} SQL_END;\n\t\t\tbreak;\n\n\t\tcase A_DEBUG:\n\t\t\tcsync_debug_out = stdout;\n\t\t\tif ( tag[1][0] )\n\t\t\t\tcsync_debug_level = atoi(tag[1]);\n\t\t\tbreak;\n\t\tcase A_HELLO:\n\t\t\tif (peer) {\n\t\t\t\tfree(peer);\n\t\t\t\tpeer = NULL;\n\t\t\t}\n\t\t\tif (verify_peername(tag[1], &peername)) {\n\t\t\t\tpeer = strdup(tag[1]);\n\t\t\t} else {\n\t\t\t\tpeer = NULL;\n\t\t\t\tcmd_error = conn_response(CR_ERR_IDENTIFICATION_FAILED);\n\t\t\t\tbreak;\n\t\t\t}\n#ifdef HAVE_LIBGNUTLS\n\t\t\tif (!csync_conn_usessl) {\n\t\t\t\tstruct csync_nossl *t;\n\t\t\t\tfor (t = csync_nossl; t; t=t->next) {\n\t\t\t\t\tif ( !fnmatch(t->pattern_from, myhostname, 0) &&\n\t\t\t\t\t     !fnmatch(t->pattern_to, peer, 0) )\n\t\t\t\t\t\tgoto conn_without_ssl_ok;\n\t\t\t\t}\n\t\t\t\tcmd_error = conn_response(CR_ERR_SSL_EXPECTED);\n\t\t\t\tpeer = NULL;\n\t\t\t}\nconn_without_ssl_ok:;\n#endif\n\t\t\tbreak;\n\t\tcase A_GROUP:\n\t\t\tif (active_grouplist) {\n\t\t\t\tcmd_error = conn_response(CR_ERR_GROUP_LIST_ALREADY_SET);\n\t\t\t} else {\n\t\t\t\tconst struct csync_group *g;\n\t\t\t\tint i, gnamelen;\n\n\t\t\t\tactive_grouplist = strdup(tag[1]);\n\t\t\t\tfor (g=csync_group; g; g=g->next) {\n\t\t\t\t\tif (!g->myname) continue;\n\n\t\t\t\t\ti=0;\n\t\t\t\t\tgnamelen = strlen(csync_group->gname);\n\t\t\t\t\twhile (active_grouplist[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( !strncmp(active_grouplist+i, csync_group->gname, gnamelen) &&\n\t\t\t\t\t\t\t\t(active_grouplist[i+gnamelen] == ',' ||\n\t\t\t\t\t\t\t\t !active_grouplist[i+gnamelen]) )\n\t\t\t\t\t\t\tgoto found_asactive;\n\t\t\t\t\t\twhile (active_grouplist[i])\n\t\t\t\t\t\t\tif (active_grouplist[i++]==',') break;\n\t\t\t\t\t}\n\t\t\t\t\tcsync_group->myname = 0;\nfound_asactive: ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase A_BYE:\n\t\t\tfor (i=0; i<32; i++)\n\t\t\t\tfree(tag[i]);\n\t\t\tconn_resp(CR_OK_CU_LATER);\n\t\t\treturn;\n\t\t}\n\n\t\tif ( cmdtab[cmdnr].update )\n\t\t\tcsync_file_update(tag[2], peer);\n\n\t\tif ( cmdtab[cmdnr].update == 1 ) {\n\t\t\tcsync_debug(1, \"Updated %s from %s.\\n\",\n\t\t\t\t\ttag[2], peer ? peer : \"???\");\n\t\t\tcsync_schedule_commands(tag[2], 0);\n\t\t}\n\nabort_cmd:\n\t\tif ( cmd_error )\n\t\t\tconn_printf(\"%s\\n\", cmd_error);\n\t\telse\n\t\t\tconn_resp(CR_OK_CMD_FINISHED);\n\nnext_cmd:\n\t\tdestroy_tag(tag);\n\t}\n}\n"], "filenames": ["daemon.c"], "buggy_code_start_loc": [749], "buggy_code_end_loc": [749], "fixing_code_start_loc": [750], "fixing_code_end_loc": [751], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in LINBIT csync2 through 2.0. csync_daemon_session in daemon.c neglects to force a failure of a hello command when the configuration requires use of SSL.", "other": {"cve": {"id": "CVE-2019-15522", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-20T21:15:15.313", "lastModified": "2020-10-14T17:28:04.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LINBIT csync2 through 2.0. csync_daemon_session in daemon.c neglects to force a failure of a hello command when the configuration requires use of SSL."}, {"lang": "es", "value": "Se detect\u00f3 un problema en LINBIT csync2 versiones hasta 2.0. La funci\u00f3n csync_daemon_session en el archivo daemon.c olvida forzar un fallo de un comando hello cuando la configuraci\u00f3n requiere un uso de SSL."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linbit:csync2:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0", "matchCriteriaId": "5D4174BD-CA62-4D18-BB53-B9CEEC66FFDC"}]}]}], "references": [{"url": "https://github.com/LINBIT/csync2/commit/416f1de878ef97e27e27508914f7ba8599a0be22", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/LINBIT/csync2/commit/416f1de878ef97e27e27508914f7ba8599a0be22"}}