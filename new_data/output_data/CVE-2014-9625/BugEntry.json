{"buggy_code": ["/*****************************************************************************\n * update.c: VLC update checking and downloading\n *****************************************************************************\n * Copyright \u00a9 2005-2008 VLC authors and VideoLAN\n * $Id$\n *\n * Authors: Antoine Cellerier <dionoea -at- videolan -dot- org>\n *          R\u00e9mi Duraffort <ivoire at via.ecp.fr>\n            Rafa\u00ebl Carr\u00e9 <funman@videolanorg>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either release 2 of the License, or\n * (at your option) any later release.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n/**\n *   \\file\n *   This file contains functions related to VLC update management\n */\n\n/*****************************************************************************\n * Preamble\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <vlc_common.h>\n#include <vlc_update.h>\n\n#ifdef UPDATE_CHECK\n\n#include <assert.h>\n\n#include <vlc_pgpkey.h>\n#include <vlc_stream.h>\n#include <vlc_strings.h>\n#include <vlc_fs.h>\n#include <vlc_dialog.h>\n#include <vlc_interface.h>\n\n#include <gcrypt.h>\n#include <vlc_gcrypt.h>\n#ifdef _WIN32\n#include <shellapi.h>\n#endif\n#include \"update.h\"\n#include \"../libvlc.h\"\n\n/*****************************************************************************\n * Misc defines\n *****************************************************************************/\n\n/*\n * Here is the format of these \"status files\" :\n * First line is the last version: \"X.Y.Z.E\" where:\n *      * X is the major number\n *      * Y is the minor number\n *      * Z is the revision number\n *      * .E is an OPTIONAL extra number\n *      * IE \"1.2.0\" or \"1.1.10.1\"\n * Second line is a url of the binary for this last version\n * Remaining text is a required description of the update\n */\n\n#if defined( _WIN64 )\n# define UPDATE_OS_SUFFIX \"-win-x64\"\n#elif defined( _WIN32 )\n# define UPDATE_OS_SUFFIX \"-win-x86\"\n#else\n# define UPDATE_OS_SUFFIX \"\"\n#endif\n\n#ifndef NDEBUG\n# define UPDATE_VLC_STATUS_URL \"http://update-test.videolan.org/vlc/status-win-x86\"\n#else\n# define UPDATE_VLC_STATUS_URL \"http://update.videolan.org/vlc/status\" UPDATE_OS_SUFFIX\n#endif\n\n/*****************************************************************************\n * Update_t functions\n *****************************************************************************/\n\n#undef update_New\n/**\n * Create a new update VLC struct\n *\n * \\param p_this the calling vlc_object\n * \\return pointer to new update_t or NULL\n */\nupdate_t *update_New( vlc_object_t *p_this )\n{\n    update_t *p_update;\n    assert( p_this );\n\n    p_update = (update_t *)malloc( sizeof( update_t ) );\n    if( !p_update ) return NULL;\n\n    vlc_mutex_init( &p_update->lock );\n\n    p_update->p_libvlc = p_this->p_libvlc;\n\n    p_update->release.psz_url = NULL;\n    p_update->release.psz_desc = NULL;\n\n    p_update->p_download = NULL;\n    p_update->p_check = NULL;\n\n    p_update->p_pkey = NULL;\n    vlc_gcrypt_init();\n\n    return p_update;\n}\n\n/**\n * Delete an update_t struct\n *\n * \\param p_update update_t* pointer\n * \\return nothing\n */\nvoid update_Delete( update_t *p_update )\n{\n    assert( p_update );\n\n    if( p_update->p_check )\n    {\n        vlc_join( p_update->p_check->thread, NULL );\n        free( p_update->p_check );\n    }\n\n    if( p_update->p_download )\n    {\n        atomic_store( &p_update->p_download->aborted, true );\n        vlc_join( p_update->p_download->thread, NULL );\n        vlc_object_release( p_update->p_download );\n    }\n\n    vlc_mutex_destroy( &p_update->lock );\n\n    free( p_update->release.psz_url );\n    free( p_update->release.psz_desc );\n    free( p_update->p_pkey );\n\n    free( p_update );\n}\n\n/**\n * Empty the release struct\n *\n * \\param p_update update_t* pointer\n * \\return nothing\n */\nstatic void EmptyRelease( update_t *p_update )\n{\n    p_update->release.i_major = 0;\n    p_update->release.i_minor = 0;\n    p_update->release.i_revision = 0;\n\n    FREENULL( p_update->release.psz_url );\n    FREENULL( p_update->release.psz_desc );\n}\n\n/**\n * Get the update file and parse it\n * p_update has to be locked when calling this function\n *\n * \\param p_update pointer to update struct\n * \\return true if the update is valid and authenticated\n */\nstatic bool GetUpdateFile( update_t *p_update )\n{\n    stream_t *p_stream = NULL;\n    char *psz_version_line = NULL;\n    char *psz_update_data = NULL;\n\n    p_stream = stream_UrlNew( p_update->p_libvlc, UPDATE_VLC_STATUS_URL );\n    if( !p_stream )\n    {\n        msg_Err( p_update->p_libvlc, \"Failed to open %s for reading\",\n                 UPDATE_VLC_STATUS_URL );\n        goto error;\n    }\n\n    const int64_t i_read = stream_Size( p_stream );\n    psz_update_data = malloc( i_read + 1 ); /* terminating '\\0' */\n    if( !psz_update_data )\n        goto error;\n\n    if( stream_Read( p_stream, psz_update_data, i_read ) != i_read )\n    {\n        msg_Err( p_update->p_libvlc, \"Couldn't download update file %s\",\n                UPDATE_VLC_STATUS_URL );\n        goto error;\n    }\n    psz_update_data[i_read] = '\\0';\n\n    stream_Delete( p_stream );\n    p_stream = NULL;\n\n    /* first line : version number */\n    char *psz_update_data_parser = psz_update_data;\n    size_t i_len = strcspn( psz_update_data, \"\\r\\n\" );\n    psz_update_data_parser += i_len;\n    while( *psz_update_data_parser == '\\r' || *psz_update_data_parser == '\\n' )\n        psz_update_data_parser++;\n\n    if( !(psz_version_line = malloc( i_len + 1)) )\n        goto error;\n    strncpy( psz_version_line, psz_update_data, i_len );\n    psz_version_line[i_len] = '\\0';\n\n    p_update->release.i_extra = 0;\n    int ret = sscanf( psz_version_line, \"%i.%i.%i.%i\",\n                    &p_update->release.i_major, &p_update->release.i_minor,\n                    &p_update->release.i_revision, &p_update->release.i_extra);\n    if( ret != 3 && ret != 4 )\n    {\n            msg_Err( p_update->p_libvlc, \"Update version false formated\" );\n            goto error;\n    }\n\n    /* second line : URL */\n    i_len = strcspn( psz_update_data_parser, \"\\r\\n\" );\n    if( i_len == 0 )\n    {\n        msg_Err( p_update->p_libvlc, \"Update file %s is corrupted: URL missing\",\n                 UPDATE_VLC_STATUS_URL );\n\n        goto error;\n    }\n\n    if( !(p_update->release.psz_url = malloc( i_len + 1)) )\n        goto error;\n    strncpy( p_update->release.psz_url, psz_update_data_parser, i_len );\n    p_update->release.psz_url[i_len] = '\\0';\n\n    psz_update_data_parser += i_len;\n    while( *psz_update_data_parser == '\\r' || *psz_update_data_parser == '\\n' )\n        psz_update_data_parser++;\n\n    /* Remaining data : description */\n    i_len = strlen( psz_update_data_parser );\n    if( i_len == 0 )\n    {\n        msg_Err( p_update->p_libvlc,\n                \"Update file %s is corrupted: description missing\",\n                UPDATE_VLC_STATUS_URL );\n        goto error;\n    }\n\n    if( !(p_update->release.psz_desc = malloc( i_len + 1)) )\n        goto error;\n    strncpy( p_update->release.psz_desc, psz_update_data_parser, i_len );\n    p_update->release.psz_desc[i_len] = '\\0';\n\n    /* Now that we know the status is valid, we must download its signature\n     * to authenticate it */\n    signature_packet_t sign;\n    if( download_signature( VLC_OBJECT( p_update->p_libvlc ), &sign,\n            UPDATE_VLC_STATUS_URL ) != VLC_SUCCESS )\n    {\n        msg_Err( p_update->p_libvlc, \"Couldn't download signature of status file\" );\n        goto error;\n    }\n\n    if( sign.type != BINARY_SIGNATURE && sign.type != TEXT_SIGNATURE )\n    {\n        msg_Err( p_update->p_libvlc, \"Invalid signature type\" );\n        goto error;\n    }\n\n    p_update->p_pkey = (public_key_t*)malloc( sizeof( public_key_t ) );\n    if( !p_update->p_pkey )\n        goto error;\n\n    if( parse_public_key( videolan_public_key, sizeof( videolan_public_key ),\n                        p_update->p_pkey, NULL ) != VLC_SUCCESS )\n    {\n        msg_Err( p_update->p_libvlc, \"Couldn't parse embedded public key, something went really wrong...\" );\n        FREENULL( p_update->p_pkey );\n        goto error;\n    }\n\n    memcpy( p_update->p_pkey->longid, videolan_public_key_longid, 8 );\n\n    if( memcmp( sign.issuer_longid, p_update->p_pkey->longid , 8 ) != 0 )\n    {\n        msg_Dbg( p_update->p_libvlc, \"Need to download the GPG key\" );\n        public_key_t *p_new_pkey = download_key(\n                VLC_OBJECT(p_update->p_libvlc),\n                sign.issuer_longid, videolan_public_key_longid );\n        if( !p_new_pkey )\n        {\n            msg_Err( p_update->p_libvlc, \"Couldn't download GPG key\" );\n            FREENULL( p_update->p_pkey );\n            goto error;\n        }\n\n        uint8_t *p_hash = hash_from_public_key( p_new_pkey );\n        if( !p_hash )\n        {\n            msg_Err( p_update->p_libvlc, \"Failed to hash signature\" );\n            free( p_new_pkey );\n            FREENULL( p_update->p_pkey );\n            goto error;\n        }\n\n        if( verify_signature( &p_new_pkey->sig,\n                    &p_update->p_pkey->key, p_hash ) == VLC_SUCCESS )\n        {\n            free( p_hash );\n            msg_Info( p_update->p_libvlc, \"Key authenticated\" );\n            free( p_update->p_pkey );\n            p_update->p_pkey = p_new_pkey;\n        }\n        else\n        {\n            free( p_hash );\n            msg_Err( p_update->p_libvlc, \"Key signature invalid !\" );\n            goto error;\n        }\n    }\n\n    uint8_t *p_hash = hash_from_text( psz_update_data, &sign );\n    if( !p_hash )\n    {\n        msg_Warn( p_update->p_libvlc, \"Can't compute hash for status file\" );\n        goto error;\n    }\n\n    else if( p_hash[0] != sign.hash_verification[0] ||\n        p_hash[1] != sign.hash_verification[1] )\n    {\n        msg_Warn( p_update->p_libvlc, \"Bad hash for status file\" );\n        free( p_hash );\n        goto error;\n    }\n\n    else if( verify_signature( &sign, &p_update->p_pkey->key, p_hash )\n            != VLC_SUCCESS )\n    {\n        msg_Err( p_update->p_libvlc, \"BAD SIGNATURE for status file\" );\n        free( p_hash );\n        goto error;\n    }\n\n    else\n    {\n        msg_Info( p_update->p_libvlc, \"Status file authenticated\" );\n        free( p_hash );\n        free( psz_version_line );\n        free( psz_update_data );\n        return true;\n    }\n\nerror:\n    if( p_stream )\n        stream_Delete( p_stream );\n    free( psz_version_line );\n    free( psz_update_data );\n    return false;\n}\n\nstatic void* update_CheckReal( void * );\n\n/**\n * Check for updates\n *\n * \\param p_update pointer to update struct\n * \\param pf_callback pointer to a function to call when the update_check is finished\n * \\param p_data pointer to some datas to give to the callback\n * \\returns nothing\n */\nvoid update_Check( update_t *p_update, void (*pf_callback)( void*, bool ), void *p_data )\n{\n    assert( p_update );\n\n    // If the object already exist, destroy it\n    if( p_update->p_check )\n    {\n        vlc_join( p_update->p_check->thread, NULL );\n        free( p_update->p_check );\n    }\n\n    update_check_thread_t *p_uct = calloc( 1, sizeof( *p_uct ) );\n    if( !p_uct ) return;\n\n    p_uct->p_update = p_update;\n    p_update->p_check = p_uct;\n    p_uct->pf_callback = pf_callback;\n    p_uct->p_data = p_data;\n\n    vlc_clone( &p_uct->thread, update_CheckReal, p_uct, VLC_THREAD_PRIORITY_LOW );\n}\n\nvoid* update_CheckReal( void *obj )\n{\n    update_check_thread_t *p_uct = (update_check_thread_t *)obj;\n    bool b_ret;\n    int canc;\n\n    canc = vlc_savecancel ();\n    vlc_mutex_lock( &p_uct->p_update->lock );\n\n    EmptyRelease( p_uct->p_update );\n    b_ret = GetUpdateFile( p_uct->p_update );\n    vlc_mutex_unlock( &p_uct->p_update->lock );\n\n    if( p_uct->pf_callback )\n        (p_uct->pf_callback)( p_uct->p_data, b_ret );\n\n    vlc_restorecancel (canc);\n    return NULL;\n}\n\nbool update_NeedUpgrade( update_t *p_update )\n{\n    assert( p_update );\n\n    static const int current[4] = {\n        PACKAGE_VERSION_MAJOR,\n        PACKAGE_VERSION_MINOR,\n        PACKAGE_VERSION_REVISION,\n        PACKAGE_VERSION_EXTRA\n    };\n    const int latest[4] = {\n        p_update->release.i_major,\n        p_update->release.i_minor,\n        p_update->release.i_revision,\n        p_update->release.i_extra\n    };\n\n    for (unsigned i = 0; i < sizeof latest / sizeof *latest; i++) {\n        /* there is a new version available */\n        if (latest[i] > current[i])\n            return true;\n\n        /* current version is more recent than the latest version ?! */\n        if (latest[i] < current[i])\n            return false;\n    }\n\n    /* current version is not a release, it's a -git or -rc version */\n    if (*PACKAGE_VERSION_DEV)\n        return true;\n\n    /* current version is latest version */\n    return false;\n}\n\n/**\n * Convert a long int size in bytes to a string\n *\n * \\param l_size the size in bytes\n * \\return the size as a string\n */\nstatic char *size_str( long int l_size )\n{\n    char *psz_tmp = NULL;\n    int i_retval = 0;\n    if( l_size >> 30 )\n        i_retval = asprintf( &psz_tmp, _(\"%.1f GiB\"), (float)l_size/(1<<30) );\n    else if( l_size >> 20 )\n        i_retval = asprintf( &psz_tmp, _(\"%.1f MiB\"), (float)l_size/(1<<20) );\n    else if( l_size >> 10 )\n        i_retval = asprintf( &psz_tmp, _(\"%.1f KiB\"), (float)l_size/(1<<10) );\n    else\n        i_retval = asprintf( &psz_tmp, _(\"%ld B\"), l_size );\n\n    return i_retval == -1 ? NULL : psz_tmp;\n}\n\nstatic void* update_DownloadReal( void * );\n\n/**\n * Download the file given in the update_t\n *\n * \\param p_update structure\n * \\param dir to store the download file\n * \\return nothing\n */\nvoid update_Download( update_t *p_update, const char *psz_destdir )\n{\n    assert( p_update );\n\n    // If the object already exist, destroy it\n    if( p_update->p_download )\n    {\n        atomic_store( &p_update->p_download->aborted, true );\n        vlc_join( p_update->p_download->thread, NULL );\n        vlc_object_release( p_update->p_download );\n    }\n\n    update_download_thread_t *p_udt =\n        vlc_custom_create( p_update->p_libvlc, sizeof( *p_udt ),\n                           \"update download\" );\n    if( !p_udt )\n        return;\n\n    p_udt->p_update = p_update;\n    p_update->p_download = p_udt;\n    p_udt->psz_destdir = psz_destdir ? strdup( psz_destdir ) : NULL;\n\n    atomic_store(&p_udt->aborted, false);\n    vlc_clone( &p_udt->thread, update_DownloadReal, p_udt, VLC_THREAD_PRIORITY_LOW );\n}\n\nstatic void* update_DownloadReal( void *obj )\n{\n    update_download_thread_t *p_udt = (update_download_thread_t *)obj;\n    dialog_progress_bar_t *p_progress = NULL;\n    long int l_size;\n    long int l_downloaded = 0;\n    float f_progress;\n    char *psz_status;\n    char *psz_downloaded = NULL;\n    char *psz_size = NULL;\n    char *psz_destfile = NULL;\n    char *psz_tmpdestfile = NULL;\n\n    FILE *p_file = NULL;\n    stream_t *p_stream = NULL;\n    void* p_buffer = NULL;\n    int i_read;\n    int canc;\n\n    update_t *p_update = p_udt->p_update;\n    char *psz_destdir = p_udt->psz_destdir;\n\n    msg_Dbg( p_udt, \"Opening Stream '%s'\", p_update->release.psz_url );\n    canc = vlc_savecancel ();\n\n    /* Open the stream */\n    p_stream = stream_UrlNew( p_udt, p_update->release.psz_url );\n    if( !p_stream )\n    {\n        msg_Err( p_udt, \"Failed to open %s for reading\", p_update->release.psz_url );\n        goto end;\n    }\n\n    /* Get the stream size */\n    l_size = stream_Size( p_stream );\n\n    /* Get the file name and open it*/\n    psz_tmpdestfile = strrchr( p_update->release.psz_url, '/' );\n    if( !psz_tmpdestfile )\n    {\n        msg_Err( p_udt, \"The URL %s is badly formated\",\n                 p_update->release.psz_url );\n        goto end;\n    }\n    psz_tmpdestfile++;\n    if( asprintf( &psz_destfile, \"%s%s\", psz_destdir, psz_tmpdestfile ) == -1 )\n        goto end;\n\n    p_file = vlc_fopen( psz_destfile, \"w\" );\n    if( !p_file )\n    {\n        msg_Err( p_udt, \"Failed to open %s for writing\", psz_destfile );\n        dialog_FatalWait( p_udt, _(\"Saving file failed\"),\n            _(\"Failed to open \\\"%s\\\" for writing\"),\n             psz_destfile );\n        goto end;\n    }\n\n    /* Create a buffer and fill it with the downloaded file */\n    p_buffer = (void *)malloc( 1 << 10 );\n    if( unlikely(p_buffer == NULL) )\n        goto end;\n\n    msg_Dbg( p_udt, \"Downloading Stream '%s'\", p_update->release.psz_url );\n\n    psz_size = size_str( l_size );\n    if( asprintf( &psz_status, _(\"%s\\nDownloading... %s/%s %.1f%% done\"),\n        p_update->release.psz_url, \"0.0\", psz_size, 0.0 ) == -1 )\n        goto end;\n\n    p_progress = dialog_ProgressCreate( p_udt, _( \"Downloading ...\"),\n                                        psz_status, _(\"Cancel\") );\n\n    free( psz_status );\n    if( p_progress == NULL )\n        goto end;\n\n    while( !atomic_load( &p_udt->aborted ) &&\n           ( i_read = stream_Read( p_stream, p_buffer, 1 << 10 ) ) &&\n           !dialog_ProgressCancelled( p_progress ) )\n    {\n        if( fwrite( p_buffer, i_read, 1, p_file ) < 1 )\n        {\n            msg_Err( p_udt, \"Failed to write into %s\", psz_destfile );\n            break;\n        }\n\n        l_downloaded += i_read;\n        psz_downloaded = size_str( l_downloaded );\n        f_progress = (float)l_downloaded/(float)l_size;\n\n        if( asprintf( &psz_status, _( \"%s\\nDownloading... %s/%s - %.1f%% done\" ),\n                      p_update->release.psz_url, psz_downloaded, psz_size,\n                      f_progress*100 ) != -1 )\n        {\n            dialog_ProgressSet( p_progress, psz_status, f_progress );\n            free( psz_status );\n        }\n        free( psz_downloaded );\n    }\n\n    /* Finish the progress bar or delete the file if the user had canceled */\n    fclose( p_file );\n    p_file = NULL;\n\n    if( !atomic_load( &p_udt->aborted ) &&\n        !dialog_ProgressCancelled( p_progress ) )\n    {\n        dialog_ProgressDestroy( p_progress );\n        p_progress = NULL;\n    }\n    else\n    {\n        vlc_unlink( psz_destfile );\n        goto end;\n    }\n\n    signature_packet_t sign;\n    if( download_signature( VLC_OBJECT( p_udt ), &sign,\n            p_update->release.psz_url ) != VLC_SUCCESS )\n    {\n        vlc_unlink( psz_destfile );\n\n        dialog_FatalWait( p_udt, _(\"File could not be verified\"),\n            _(\"It was not possible to download a cryptographic signature for \"\n              \"the downloaded file \\\"%s\\\". Thus, it was deleted.\"),\n            psz_destfile );\n        msg_Err( p_udt, \"Couldn't download signature of downloaded file\" );\n        goto end;\n    }\n\n    if( memcmp( sign.issuer_longid, p_update->p_pkey->longid, 8 ) )\n    {\n        vlc_unlink( psz_destfile );\n        msg_Err( p_udt, \"Invalid signature issuer\" );\n        dialog_FatalWait( p_udt, _(\"Invalid signature\"),\n            _(\"The cryptographic signature for the downloaded file \\\"%s\\\" was \"\n              \"invalid and could not be used to securely verify it. Thus, the \"\n              \"file was deleted.\"),\n            psz_destfile );\n        goto end;\n    }\n\n    if( sign.type != BINARY_SIGNATURE )\n    {\n        vlc_unlink( psz_destfile );\n        msg_Err( p_udt, \"Invalid signature type\" );\n        dialog_FatalWait( p_udt, _(\"Invalid signature\"),\n            _(\"The cryptographic signature for the downloaded file \\\"%s\\\" was \"\n              \"invalid and could not be used to securely verify it. Thus, the \"\n              \"file was deleted.\"),\n            psz_destfile );\n        goto end;\n    }\n\n    uint8_t *p_hash = hash_from_file( psz_destfile, &sign );\n    if( !p_hash )\n    {\n        msg_Err( p_udt, \"Unable to hash %s\", psz_destfile );\n        vlc_unlink( psz_destfile );\n        dialog_FatalWait( p_udt, _(\"File not verifiable\"),\n            _(\"It was not possible to securely verify the downloaded file\"\n              \" \\\"%s\\\". Thus, it was deleted.\"),\n            psz_destfile );\n\n        goto end;\n    }\n\n    if( p_hash[0] != sign.hash_verification[0] ||\n        p_hash[1] != sign.hash_verification[1] )\n    {\n        vlc_unlink( psz_destfile );\n        dialog_FatalWait( p_udt, _(\"File corrupted\"),\n            _(\"Downloaded file \\\"%s\\\" was corrupted. Thus, it was deleted.\"),\n             psz_destfile );\n        msg_Err( p_udt, \"Bad hash for %s\", psz_destfile );\n        free( p_hash );\n        goto end;\n    }\n\n    if( verify_signature( &sign, &p_update->p_pkey->key, p_hash )\n            != VLC_SUCCESS )\n    {\n        vlc_unlink( psz_destfile );\n        dialog_FatalWait( p_udt, _(\"File corrupted\"),\n            _(\"Downloaded file \\\"%s\\\" was corrupted. Thus, it was deleted.\"),\n             psz_destfile );\n        msg_Err( p_udt, \"BAD SIGNATURE for %s\", psz_destfile );\n        free( p_hash );\n        goto end;\n    }\n\n    msg_Info( p_udt, \"%s authenticated\", psz_destfile );\n    free( p_hash );\n\n#ifdef _WIN32\n    int answer = dialog_Question( p_udt, _(\"Update VLC media player\"),\n    _(\"The new version was successfully downloaded. Do you want to close VLC and install it now?\"),\n    _(\"Install\"), _(\"Cancel\"), NULL);\n\n    if(answer == 1)\n    {\n        wchar_t psz_wdestfile[MAX_PATH];\n        MultiByteToWideChar( CP_UTF8, 0, psz_destfile, -1, psz_wdestfile, MAX_PATH );\n        answer = (int)ShellExecuteW( NULL, L\"open\", psz_wdestfile, NULL, NULL, SW_SHOW);\n        if(answer > 32)\n            libvlc_Quit(p_udt->p_libvlc);\n    }\n#endif\nend:\n    if( p_progress )\n        dialog_ProgressDestroy( p_progress );\n    if( p_stream )\n        stream_Delete( p_stream );\n    if( p_file )\n        fclose( p_file );\n    free( psz_destdir );\n    free( psz_destfile );\n    free( p_buffer );\n    free( psz_size );\n\n    vlc_restorecancel( canc );\n    return NULL;\n}\n\nupdate_release_t *update_GetRelease( update_t *p_update )\n{\n    return &p_update->release;\n}\n\n#else\n#undef update_New\nupdate_t *update_New( vlc_object_t *p_this )\n{\n    (void)p_this;\n    return NULL;\n}\n\nvoid update_Delete( update_t *p_update )\n{\n    (void)p_update;\n}\n\nvoid update_Check( update_t *p_update, void (*pf_callback)( void*, bool ),\n                   void *p_data )\n{\n    (void)p_update; (void)pf_callback; (void)p_data;\n}\n\nbool update_NeedUpgrade( update_t *p_update )\n{\n    (void)p_update;\n    return false;\n}\n\nvoid update_Download( update_t *p_update, const char *psz_destdir )\n{\n    (void)p_update; (void)psz_destdir;\n}\n\nupdate_release_t *update_GetRelease( update_t *p_update )\n{\n    (void)p_update;\n    return NULL;\n}\n#endif\n"], "fixing_code": ["/*****************************************************************************\n * update.c: VLC update checking and downloading\n *****************************************************************************\n * Copyright \u00a9 2005-2008 VLC authors and VideoLAN\n * $Id$\n *\n * Authors: Antoine Cellerier <dionoea -at- videolan -dot- org>\n *          R\u00e9mi Duraffort <ivoire at via.ecp.fr>\n            Rafa\u00ebl Carr\u00e9 <funman@videolanorg>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either release 2 of the License, or\n * (at your option) any later release.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n/**\n *   \\file\n *   This file contains functions related to VLC update management\n */\n\n/*****************************************************************************\n * Preamble\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <vlc_common.h>\n#include <vlc_update.h>\n\n#ifdef UPDATE_CHECK\n\n#include <assert.h>\n\n#include <vlc_pgpkey.h>\n#include <vlc_stream.h>\n#include <vlc_strings.h>\n#include <vlc_fs.h>\n#include <vlc_dialog.h>\n#include <vlc_interface.h>\n\n#include <gcrypt.h>\n#include <vlc_gcrypt.h>\n#ifdef _WIN32\n#include <shellapi.h>\n#endif\n#include \"update.h\"\n#include \"../libvlc.h\"\n\n/*****************************************************************************\n * Misc defines\n *****************************************************************************/\n\n/*\n * Here is the format of these \"status files\" :\n * First line is the last version: \"X.Y.Z.E\" where:\n *      * X is the major number\n *      * Y is the minor number\n *      * Z is the revision number\n *      * .E is an OPTIONAL extra number\n *      * IE \"1.2.0\" or \"1.1.10.1\"\n * Second line is a url of the binary for this last version\n * Remaining text is a required description of the update\n */\n\n#if defined( _WIN64 )\n# define UPDATE_OS_SUFFIX \"-win-x64\"\n#elif defined( _WIN32 )\n# define UPDATE_OS_SUFFIX \"-win-x86\"\n#else\n# define UPDATE_OS_SUFFIX \"\"\n#endif\n\n#ifndef NDEBUG\n# define UPDATE_VLC_STATUS_URL \"http://update-test.videolan.org/vlc/status-win-x86\"\n#else\n# define UPDATE_VLC_STATUS_URL \"http://update.videolan.org/vlc/status\" UPDATE_OS_SUFFIX\n#endif\n\n/*****************************************************************************\n * Update_t functions\n *****************************************************************************/\n\n#undef update_New\n/**\n * Create a new update VLC struct\n *\n * \\param p_this the calling vlc_object\n * \\return pointer to new update_t or NULL\n */\nupdate_t *update_New( vlc_object_t *p_this )\n{\n    update_t *p_update;\n    assert( p_this );\n\n    p_update = (update_t *)malloc( sizeof( update_t ) );\n    if( !p_update ) return NULL;\n\n    vlc_mutex_init( &p_update->lock );\n\n    p_update->p_libvlc = p_this->p_libvlc;\n\n    p_update->release.psz_url = NULL;\n    p_update->release.psz_desc = NULL;\n\n    p_update->p_download = NULL;\n    p_update->p_check = NULL;\n\n    p_update->p_pkey = NULL;\n    vlc_gcrypt_init();\n\n    return p_update;\n}\n\n/**\n * Delete an update_t struct\n *\n * \\param p_update update_t* pointer\n * \\return nothing\n */\nvoid update_Delete( update_t *p_update )\n{\n    assert( p_update );\n\n    if( p_update->p_check )\n    {\n        vlc_join( p_update->p_check->thread, NULL );\n        free( p_update->p_check );\n    }\n\n    if( p_update->p_download )\n    {\n        atomic_store( &p_update->p_download->aborted, true );\n        vlc_join( p_update->p_download->thread, NULL );\n        vlc_object_release( p_update->p_download );\n    }\n\n    vlc_mutex_destroy( &p_update->lock );\n\n    free( p_update->release.psz_url );\n    free( p_update->release.psz_desc );\n    free( p_update->p_pkey );\n\n    free( p_update );\n}\n\n/**\n * Empty the release struct\n *\n * \\param p_update update_t* pointer\n * \\return nothing\n */\nstatic void EmptyRelease( update_t *p_update )\n{\n    p_update->release.i_major = 0;\n    p_update->release.i_minor = 0;\n    p_update->release.i_revision = 0;\n\n    FREENULL( p_update->release.psz_url );\n    FREENULL( p_update->release.psz_desc );\n}\n\n/**\n * Get the update file and parse it\n * p_update has to be locked when calling this function\n *\n * \\param p_update pointer to update struct\n * \\return true if the update is valid and authenticated\n */\nstatic bool GetUpdateFile( update_t *p_update )\n{\n    stream_t *p_stream = NULL;\n    char *psz_version_line = NULL;\n    char *psz_update_data = NULL;\n\n    p_stream = stream_UrlNew( p_update->p_libvlc, UPDATE_VLC_STATUS_URL );\n    if( !p_stream )\n    {\n        msg_Err( p_update->p_libvlc, \"Failed to open %s for reading\",\n                 UPDATE_VLC_STATUS_URL );\n        goto error;\n    }\n\n    const int64_t i_read = stream_Size( p_stream );\n\n    if( i_read < 0 || i_read >= UINT16_MAX)\n    {\n        msg_Err(p_update->p_libvlc, \"Status file too large\");\n        goto error;\n    }\n\n    psz_update_data = malloc( i_read + 1 ); /* terminating '\\0' */\n    if( !psz_update_data )\n        goto error;\n\n    if( stream_Read( p_stream, psz_update_data, i_read ) != i_read )\n    {\n        msg_Err( p_update->p_libvlc, \"Couldn't download update file %s\",\n                UPDATE_VLC_STATUS_URL );\n        goto error;\n    }\n    psz_update_data[i_read] = '\\0';\n\n    stream_Delete( p_stream );\n    p_stream = NULL;\n\n    /* first line : version number */\n    char *psz_update_data_parser = psz_update_data;\n    size_t i_len = strcspn( psz_update_data, \"\\r\\n\" );\n    psz_update_data_parser += i_len;\n    while( *psz_update_data_parser == '\\r' || *psz_update_data_parser == '\\n' )\n        psz_update_data_parser++;\n\n    if( !(psz_version_line = malloc( i_len + 1)) )\n        goto error;\n    strncpy( psz_version_line, psz_update_data, i_len );\n    psz_version_line[i_len] = '\\0';\n\n    p_update->release.i_extra = 0;\n    int ret = sscanf( psz_version_line, \"%i.%i.%i.%i\",\n                    &p_update->release.i_major, &p_update->release.i_minor,\n                    &p_update->release.i_revision, &p_update->release.i_extra);\n    if( ret != 3 && ret != 4 )\n    {\n            msg_Err( p_update->p_libvlc, \"Update version false formated\" );\n            goto error;\n    }\n\n    /* second line : URL */\n    i_len = strcspn( psz_update_data_parser, \"\\r\\n\" );\n    if( i_len == 0 )\n    {\n        msg_Err( p_update->p_libvlc, \"Update file %s is corrupted: URL missing\",\n                 UPDATE_VLC_STATUS_URL );\n\n        goto error;\n    }\n\n    if( !(p_update->release.psz_url = malloc( i_len + 1)) )\n        goto error;\n    strncpy( p_update->release.psz_url, psz_update_data_parser, i_len );\n    p_update->release.psz_url[i_len] = '\\0';\n\n    psz_update_data_parser += i_len;\n    while( *psz_update_data_parser == '\\r' || *psz_update_data_parser == '\\n' )\n        psz_update_data_parser++;\n\n    /* Remaining data : description */\n    i_len = strlen( psz_update_data_parser );\n    if( i_len == 0 )\n    {\n        msg_Err( p_update->p_libvlc,\n                \"Update file %s is corrupted: description missing\",\n                UPDATE_VLC_STATUS_URL );\n        goto error;\n    }\n\n    if( !(p_update->release.psz_desc = malloc( i_len + 1)) )\n        goto error;\n    strncpy( p_update->release.psz_desc, psz_update_data_parser, i_len );\n    p_update->release.psz_desc[i_len] = '\\0';\n\n    /* Now that we know the status is valid, we must download its signature\n     * to authenticate it */\n    signature_packet_t sign;\n    if( download_signature( VLC_OBJECT( p_update->p_libvlc ), &sign,\n            UPDATE_VLC_STATUS_URL ) != VLC_SUCCESS )\n    {\n        msg_Err( p_update->p_libvlc, \"Couldn't download signature of status file\" );\n        goto error;\n    }\n\n    if( sign.type != BINARY_SIGNATURE && sign.type != TEXT_SIGNATURE )\n    {\n        msg_Err( p_update->p_libvlc, \"Invalid signature type\" );\n        goto error;\n    }\n\n    p_update->p_pkey = (public_key_t*)malloc( sizeof( public_key_t ) );\n    if( !p_update->p_pkey )\n        goto error;\n\n    if( parse_public_key( videolan_public_key, sizeof( videolan_public_key ),\n                        p_update->p_pkey, NULL ) != VLC_SUCCESS )\n    {\n        msg_Err( p_update->p_libvlc, \"Couldn't parse embedded public key, something went really wrong...\" );\n        FREENULL( p_update->p_pkey );\n        goto error;\n    }\n\n    memcpy( p_update->p_pkey->longid, videolan_public_key_longid, 8 );\n\n    if( memcmp( sign.issuer_longid, p_update->p_pkey->longid , 8 ) != 0 )\n    {\n        msg_Dbg( p_update->p_libvlc, \"Need to download the GPG key\" );\n        public_key_t *p_new_pkey = download_key(\n                VLC_OBJECT(p_update->p_libvlc),\n                sign.issuer_longid, videolan_public_key_longid );\n        if( !p_new_pkey )\n        {\n            msg_Err( p_update->p_libvlc, \"Couldn't download GPG key\" );\n            FREENULL( p_update->p_pkey );\n            goto error;\n        }\n\n        uint8_t *p_hash = hash_from_public_key( p_new_pkey );\n        if( !p_hash )\n        {\n            msg_Err( p_update->p_libvlc, \"Failed to hash signature\" );\n            free( p_new_pkey );\n            FREENULL( p_update->p_pkey );\n            goto error;\n        }\n\n        if( verify_signature( &p_new_pkey->sig,\n                    &p_update->p_pkey->key, p_hash ) == VLC_SUCCESS )\n        {\n            free( p_hash );\n            msg_Info( p_update->p_libvlc, \"Key authenticated\" );\n            free( p_update->p_pkey );\n            p_update->p_pkey = p_new_pkey;\n        }\n        else\n        {\n            free( p_hash );\n            msg_Err( p_update->p_libvlc, \"Key signature invalid !\" );\n            goto error;\n        }\n    }\n\n    uint8_t *p_hash = hash_from_text( psz_update_data, &sign );\n    if( !p_hash )\n    {\n        msg_Warn( p_update->p_libvlc, \"Can't compute hash for status file\" );\n        goto error;\n    }\n\n    else if( p_hash[0] != sign.hash_verification[0] ||\n        p_hash[1] != sign.hash_verification[1] )\n    {\n        msg_Warn( p_update->p_libvlc, \"Bad hash for status file\" );\n        free( p_hash );\n        goto error;\n    }\n\n    else if( verify_signature( &sign, &p_update->p_pkey->key, p_hash )\n            != VLC_SUCCESS )\n    {\n        msg_Err( p_update->p_libvlc, \"BAD SIGNATURE for status file\" );\n        free( p_hash );\n        goto error;\n    }\n\n    else\n    {\n        msg_Info( p_update->p_libvlc, \"Status file authenticated\" );\n        free( p_hash );\n        free( psz_version_line );\n        free( psz_update_data );\n        return true;\n    }\n\nerror:\n    if( p_stream )\n        stream_Delete( p_stream );\n    free( psz_version_line );\n    free( psz_update_data );\n    return false;\n}\n\nstatic void* update_CheckReal( void * );\n\n/**\n * Check for updates\n *\n * \\param p_update pointer to update struct\n * \\param pf_callback pointer to a function to call when the update_check is finished\n * \\param p_data pointer to some datas to give to the callback\n * \\returns nothing\n */\nvoid update_Check( update_t *p_update, void (*pf_callback)( void*, bool ), void *p_data )\n{\n    assert( p_update );\n\n    // If the object already exist, destroy it\n    if( p_update->p_check )\n    {\n        vlc_join( p_update->p_check->thread, NULL );\n        free( p_update->p_check );\n    }\n\n    update_check_thread_t *p_uct = calloc( 1, sizeof( *p_uct ) );\n    if( !p_uct ) return;\n\n    p_uct->p_update = p_update;\n    p_update->p_check = p_uct;\n    p_uct->pf_callback = pf_callback;\n    p_uct->p_data = p_data;\n\n    vlc_clone( &p_uct->thread, update_CheckReal, p_uct, VLC_THREAD_PRIORITY_LOW );\n}\n\nvoid* update_CheckReal( void *obj )\n{\n    update_check_thread_t *p_uct = (update_check_thread_t *)obj;\n    bool b_ret;\n    int canc;\n\n    canc = vlc_savecancel ();\n    vlc_mutex_lock( &p_uct->p_update->lock );\n\n    EmptyRelease( p_uct->p_update );\n    b_ret = GetUpdateFile( p_uct->p_update );\n    vlc_mutex_unlock( &p_uct->p_update->lock );\n\n    if( p_uct->pf_callback )\n        (p_uct->pf_callback)( p_uct->p_data, b_ret );\n\n    vlc_restorecancel (canc);\n    return NULL;\n}\n\nbool update_NeedUpgrade( update_t *p_update )\n{\n    assert( p_update );\n\n    static const int current[4] = {\n        PACKAGE_VERSION_MAJOR,\n        PACKAGE_VERSION_MINOR,\n        PACKAGE_VERSION_REVISION,\n        PACKAGE_VERSION_EXTRA\n    };\n    const int latest[4] = {\n        p_update->release.i_major,\n        p_update->release.i_minor,\n        p_update->release.i_revision,\n        p_update->release.i_extra\n    };\n\n    for (unsigned i = 0; i < sizeof latest / sizeof *latest; i++) {\n        /* there is a new version available */\n        if (latest[i] > current[i])\n            return true;\n\n        /* current version is more recent than the latest version ?! */\n        if (latest[i] < current[i])\n            return false;\n    }\n\n    /* current version is not a release, it's a -git or -rc version */\n    if (*PACKAGE_VERSION_DEV)\n        return true;\n\n    /* current version is latest version */\n    return false;\n}\n\n/**\n * Convert a long int size in bytes to a string\n *\n * \\param l_size the size in bytes\n * \\return the size as a string\n */\nstatic char *size_str( long int l_size )\n{\n    char *psz_tmp = NULL;\n    int i_retval = 0;\n    if( l_size >> 30 )\n        i_retval = asprintf( &psz_tmp, _(\"%.1f GiB\"), (float)l_size/(1<<30) );\n    else if( l_size >> 20 )\n        i_retval = asprintf( &psz_tmp, _(\"%.1f MiB\"), (float)l_size/(1<<20) );\n    else if( l_size >> 10 )\n        i_retval = asprintf( &psz_tmp, _(\"%.1f KiB\"), (float)l_size/(1<<10) );\n    else\n        i_retval = asprintf( &psz_tmp, _(\"%ld B\"), l_size );\n\n    return i_retval == -1 ? NULL : psz_tmp;\n}\n\nstatic void* update_DownloadReal( void * );\n\n/**\n * Download the file given in the update_t\n *\n * \\param p_update structure\n * \\param dir to store the download file\n * \\return nothing\n */\nvoid update_Download( update_t *p_update, const char *psz_destdir )\n{\n    assert( p_update );\n\n    // If the object already exist, destroy it\n    if( p_update->p_download )\n    {\n        atomic_store( &p_update->p_download->aborted, true );\n        vlc_join( p_update->p_download->thread, NULL );\n        vlc_object_release( p_update->p_download );\n    }\n\n    update_download_thread_t *p_udt =\n        vlc_custom_create( p_update->p_libvlc, sizeof( *p_udt ),\n                           \"update download\" );\n    if( !p_udt )\n        return;\n\n    p_udt->p_update = p_update;\n    p_update->p_download = p_udt;\n    p_udt->psz_destdir = psz_destdir ? strdup( psz_destdir ) : NULL;\n\n    atomic_store(&p_udt->aborted, false);\n    vlc_clone( &p_udt->thread, update_DownloadReal, p_udt, VLC_THREAD_PRIORITY_LOW );\n}\n\nstatic void* update_DownloadReal( void *obj )\n{\n    update_download_thread_t *p_udt = (update_download_thread_t *)obj;\n    dialog_progress_bar_t *p_progress = NULL;\n    long int l_size;\n    long int l_downloaded = 0;\n    float f_progress;\n    char *psz_status;\n    char *psz_downloaded = NULL;\n    char *psz_size = NULL;\n    char *psz_destfile = NULL;\n    char *psz_tmpdestfile = NULL;\n\n    FILE *p_file = NULL;\n    stream_t *p_stream = NULL;\n    void* p_buffer = NULL;\n    int i_read;\n    int canc;\n\n    update_t *p_update = p_udt->p_update;\n    char *psz_destdir = p_udt->psz_destdir;\n\n    msg_Dbg( p_udt, \"Opening Stream '%s'\", p_update->release.psz_url );\n    canc = vlc_savecancel ();\n\n    /* Open the stream */\n    p_stream = stream_UrlNew( p_udt, p_update->release.psz_url );\n    if( !p_stream )\n    {\n        msg_Err( p_udt, \"Failed to open %s for reading\", p_update->release.psz_url );\n        goto end;\n    }\n\n    /* Get the stream size */\n    l_size = stream_Size( p_stream );\n\n    /* Get the file name and open it*/\n    psz_tmpdestfile = strrchr( p_update->release.psz_url, '/' );\n    if( !psz_tmpdestfile )\n    {\n        msg_Err( p_udt, \"The URL %s is badly formated\",\n                 p_update->release.psz_url );\n        goto end;\n    }\n    psz_tmpdestfile++;\n    if( asprintf( &psz_destfile, \"%s%s\", psz_destdir, psz_tmpdestfile ) == -1 )\n        goto end;\n\n    p_file = vlc_fopen( psz_destfile, \"w\" );\n    if( !p_file )\n    {\n        msg_Err( p_udt, \"Failed to open %s for writing\", psz_destfile );\n        dialog_FatalWait( p_udt, _(\"Saving file failed\"),\n            _(\"Failed to open \\\"%s\\\" for writing\"),\n             psz_destfile );\n        goto end;\n    }\n\n    /* Create a buffer and fill it with the downloaded file */\n    p_buffer = (void *)malloc( 1 << 10 );\n    if( unlikely(p_buffer == NULL) )\n        goto end;\n\n    msg_Dbg( p_udt, \"Downloading Stream '%s'\", p_update->release.psz_url );\n\n    psz_size = size_str( l_size );\n    if( asprintf( &psz_status, _(\"%s\\nDownloading... %s/%s %.1f%% done\"),\n        p_update->release.psz_url, \"0.0\", psz_size, 0.0 ) == -1 )\n        goto end;\n\n    p_progress = dialog_ProgressCreate( p_udt, _( \"Downloading ...\"),\n                                        psz_status, _(\"Cancel\") );\n\n    free( psz_status );\n    if( p_progress == NULL )\n        goto end;\n\n    while( !atomic_load( &p_udt->aborted ) &&\n           ( i_read = stream_Read( p_stream, p_buffer, 1 << 10 ) ) &&\n           !dialog_ProgressCancelled( p_progress ) )\n    {\n        if( fwrite( p_buffer, i_read, 1, p_file ) < 1 )\n        {\n            msg_Err( p_udt, \"Failed to write into %s\", psz_destfile );\n            break;\n        }\n\n        l_downloaded += i_read;\n        psz_downloaded = size_str( l_downloaded );\n        f_progress = (float)l_downloaded/(float)l_size;\n\n        if( asprintf( &psz_status, _( \"%s\\nDownloading... %s/%s - %.1f%% done\" ),\n                      p_update->release.psz_url, psz_downloaded, psz_size,\n                      f_progress*100 ) != -1 )\n        {\n            dialog_ProgressSet( p_progress, psz_status, f_progress );\n            free( psz_status );\n        }\n        free( psz_downloaded );\n    }\n\n    /* Finish the progress bar or delete the file if the user had canceled */\n    fclose( p_file );\n    p_file = NULL;\n\n    if( !atomic_load( &p_udt->aborted ) &&\n        !dialog_ProgressCancelled( p_progress ) )\n    {\n        dialog_ProgressDestroy( p_progress );\n        p_progress = NULL;\n    }\n    else\n    {\n        vlc_unlink( psz_destfile );\n        goto end;\n    }\n\n    signature_packet_t sign;\n    if( download_signature( VLC_OBJECT( p_udt ), &sign,\n            p_update->release.psz_url ) != VLC_SUCCESS )\n    {\n        vlc_unlink( psz_destfile );\n\n        dialog_FatalWait( p_udt, _(\"File could not be verified\"),\n            _(\"It was not possible to download a cryptographic signature for \"\n              \"the downloaded file \\\"%s\\\". Thus, it was deleted.\"),\n            psz_destfile );\n        msg_Err( p_udt, \"Couldn't download signature of downloaded file\" );\n        goto end;\n    }\n\n    if( memcmp( sign.issuer_longid, p_update->p_pkey->longid, 8 ) )\n    {\n        vlc_unlink( psz_destfile );\n        msg_Err( p_udt, \"Invalid signature issuer\" );\n        dialog_FatalWait( p_udt, _(\"Invalid signature\"),\n            _(\"The cryptographic signature for the downloaded file \\\"%s\\\" was \"\n              \"invalid and could not be used to securely verify it. Thus, the \"\n              \"file was deleted.\"),\n            psz_destfile );\n        goto end;\n    }\n\n    if( sign.type != BINARY_SIGNATURE )\n    {\n        vlc_unlink( psz_destfile );\n        msg_Err( p_udt, \"Invalid signature type\" );\n        dialog_FatalWait( p_udt, _(\"Invalid signature\"),\n            _(\"The cryptographic signature for the downloaded file \\\"%s\\\" was \"\n              \"invalid and could not be used to securely verify it. Thus, the \"\n              \"file was deleted.\"),\n            psz_destfile );\n        goto end;\n    }\n\n    uint8_t *p_hash = hash_from_file( psz_destfile, &sign );\n    if( !p_hash )\n    {\n        msg_Err( p_udt, \"Unable to hash %s\", psz_destfile );\n        vlc_unlink( psz_destfile );\n        dialog_FatalWait( p_udt, _(\"File not verifiable\"),\n            _(\"It was not possible to securely verify the downloaded file\"\n              \" \\\"%s\\\". Thus, it was deleted.\"),\n            psz_destfile );\n\n        goto end;\n    }\n\n    if( p_hash[0] != sign.hash_verification[0] ||\n        p_hash[1] != sign.hash_verification[1] )\n    {\n        vlc_unlink( psz_destfile );\n        dialog_FatalWait( p_udt, _(\"File corrupted\"),\n            _(\"Downloaded file \\\"%s\\\" was corrupted. Thus, it was deleted.\"),\n             psz_destfile );\n        msg_Err( p_udt, \"Bad hash for %s\", psz_destfile );\n        free( p_hash );\n        goto end;\n    }\n\n    if( verify_signature( &sign, &p_update->p_pkey->key, p_hash )\n            != VLC_SUCCESS )\n    {\n        vlc_unlink( psz_destfile );\n        dialog_FatalWait( p_udt, _(\"File corrupted\"),\n            _(\"Downloaded file \\\"%s\\\" was corrupted. Thus, it was deleted.\"),\n             psz_destfile );\n        msg_Err( p_udt, \"BAD SIGNATURE for %s\", psz_destfile );\n        free( p_hash );\n        goto end;\n    }\n\n    msg_Info( p_udt, \"%s authenticated\", psz_destfile );\n    free( p_hash );\n\n#ifdef _WIN32\n    int answer = dialog_Question( p_udt, _(\"Update VLC media player\"),\n    _(\"The new version was successfully downloaded. Do you want to close VLC and install it now?\"),\n    _(\"Install\"), _(\"Cancel\"), NULL);\n\n    if(answer == 1)\n    {\n        wchar_t psz_wdestfile[MAX_PATH];\n        MultiByteToWideChar( CP_UTF8, 0, psz_destfile, -1, psz_wdestfile, MAX_PATH );\n        answer = (int)ShellExecuteW( NULL, L\"open\", psz_wdestfile, NULL, NULL, SW_SHOW);\n        if(answer > 32)\n            libvlc_Quit(p_udt->p_libvlc);\n    }\n#endif\nend:\n    if( p_progress )\n        dialog_ProgressDestroy( p_progress );\n    if( p_stream )\n        stream_Delete( p_stream );\n    if( p_file )\n        fclose( p_file );\n    free( psz_destdir );\n    free( psz_destfile );\n    free( p_buffer );\n    free( psz_size );\n\n    vlc_restorecancel( canc );\n    return NULL;\n}\n\nupdate_release_t *update_GetRelease( update_t *p_update )\n{\n    return &p_update->release;\n}\n\n#else\n#undef update_New\nupdate_t *update_New( vlc_object_t *p_this )\n{\n    (void)p_this;\n    return NULL;\n}\n\nvoid update_Delete( update_t *p_update )\n{\n    (void)p_update;\n}\n\nvoid update_Check( update_t *p_update, void (*pf_callback)( void*, bool ),\n                   void *p_data )\n{\n    (void)p_update; (void)pf_callback; (void)p_data;\n}\n\nbool update_NeedUpgrade( update_t *p_update )\n{\n    (void)p_update;\n    return false;\n}\n\nvoid update_Download( update_t *p_update, const char *psz_destdir )\n{\n    (void)p_update; (void)psz_destdir;\n}\n\nupdate_release_t *update_GetRelease( update_t *p_update )\n{\n    (void)p_update;\n    return NULL;\n}\n#endif\n"], "filenames": ["src/misc/update.c"], "buggy_code_start_loc": [195], "buggy_code_end_loc": [195], "fixing_code_start_loc": [196], "fixing_code_end_loc": [203], "type": "CWE-120", "message": "The GetUpdateFile function in misc/update.c in the Updater in VideoLAN VLC media player before 2.1.6 performs an incorrect cast operation from a 64-bit integer to a 32-bit integer, which allows remote attackers to conduct buffer overflow attacks and execute arbitrary code via a crafted update status file, aka an \"integer truncation\" vulnerability.", "other": {"cve": {"id": "CVE-2014-9625", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-24T22:15:12.333", "lastModified": "2020-01-29T16:46:14.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The GetUpdateFile function in misc/update.c in the Updater in VideoLAN VLC media player before 2.1.6 performs an incorrect cast operation from a 64-bit integer to a 32-bit integer, which allows remote attackers to conduct buffer overflow attacks and execute arbitrary code via a crafted update status file, aka an \"integer truncation\" vulnerability."}, {"lang": "es", "value": "La funci\u00f3n GetUpdateFile en el archivo misc/update.c en el Updater en el reproductor multimedia VLC de VideoLAN versiones anteriores a 2.1.6, realiza una operaci\u00f3n de conversi\u00f3n incorrecta de un entero de 64 bits a un entero de 32 bits, lo que permite a atacantes remotos llevar a cabo ataques de desbordamiento de b\u00fafer y ejecutar c\u00f3digo arbitrario por medio de un archivo de estado de actualizaci\u00f3n dise\u00f1ado, tambi\u00e9n se conoce como vulnerabilidad de tipo \"integer truncation\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:videolan:vlc_media_player:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.6", "matchCriteriaId": "6E9B8F06-93FB-4A2B-B550-A30BD8F1C5D6"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2015/01/20/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/videolan/vlc/commit/fbe2837bc80f155c001781041a54c58b5524fc14", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.videolan.org/security/sa1501.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/videolan/vlc/commit/fbe2837bc80f155c001781041a54c58b5524fc14"}}