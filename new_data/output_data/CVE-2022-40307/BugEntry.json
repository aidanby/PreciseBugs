{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * EFI capsule loader driver.\n *\n * Copyright 2015 Intel Corporation\n */\n\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/highmem.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/efi.h>\n#include <linux/vmalloc.h>\n\n#define NO_FURTHER_WRITE_ACTION -1\n\n/**\n * efi_free_all_buff_pages - free all previous allocated buffer pages\n * @cap_info: pointer to current instance of capsule_info structure\n *\n *\tIn addition to freeing buffer pages, it flags NO_FURTHER_WRITE_ACTION\n *\tto cease processing data in subsequent write(2) calls until close(2)\n *\tis called.\n **/\nstatic void efi_free_all_buff_pages(struct capsule_info *cap_info)\n{\n\twhile (cap_info->index > 0)\n\t\t__free_page(cap_info->pages[--cap_info->index]);\n\n\tcap_info->index = NO_FURTHER_WRITE_ACTION;\n}\n\nint __efi_capsule_setup_info(struct capsule_info *cap_info)\n{\n\tsize_t pages_needed;\n\tint ret;\n\tvoid *temp_page;\n\n\tpages_needed = ALIGN(cap_info->total_size, PAGE_SIZE) / PAGE_SIZE;\n\n\tif (pages_needed == 0) {\n\t\tpr_err(\"invalid capsule size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the capsule binary supported */\n\tret = efi_capsule_supported(cap_info->header.guid,\n\t\t\t\t    cap_info->header.flags,\n\t\t\t\t    cap_info->header.imagesize,\n\t\t\t\t    &cap_info->reset_type);\n\tif (ret) {\n\t\tpr_err(\"capsule not supported\\n\");\n\t\treturn ret;\n\t}\n\n\ttemp_page = krealloc(cap_info->pages,\n\t\t\t     pages_needed * sizeof(void *),\n\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!temp_page)\n\t\treturn -ENOMEM;\n\n\tcap_info->pages = temp_page;\n\n\ttemp_page = krealloc(cap_info->phys,\n\t\t\t     pages_needed * sizeof(phys_addr_t *),\n\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!temp_page)\n\t\treturn -ENOMEM;\n\n\tcap_info->phys = temp_page;\n\n\treturn 0;\n}\n\n/**\n * efi_capsule_setup_info - obtain the efi capsule header in the binary and\n *\t\t\t    setup capsule_info structure\n * @cap_info: pointer to current instance of capsule_info structure\n * @kbuff: a mapped first page buffer pointer\n * @hdr_bytes: the total received number of bytes for efi header\n *\n * Platforms with non-standard capsule update mechanisms can override\n * this __weak function so they can perform any required capsule\n * image munging. See quark_quirk_function() for an example.\n **/\nint __weak efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,\n\t\t\t\t  size_t hdr_bytes)\n{\n\t/* Only process data block that is larger than efi header size */\n\tif (hdr_bytes < sizeof(efi_capsule_header_t))\n\t\treturn 0;\n\n\tmemcpy(&cap_info->header, kbuff, sizeof(cap_info->header));\n\tcap_info->total_size = cap_info->header.imagesize;\n\n\treturn __efi_capsule_setup_info(cap_info);\n}\n\n/**\n * efi_capsule_submit_update - invoke the efi_capsule_update API once binary\n *\t\t\t       upload done\n * @cap_info: pointer to current instance of capsule_info structure\n **/\nstatic ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)\n{\n\tbool do_vunmap = false;\n\tint ret;\n\n\t/*\n\t * cap_info->capsule may have been assigned already by a quirk\n\t * handler, so only overwrite it if it is NULL\n\t */\n\tif (!cap_info->capsule) {\n\t\tcap_info->capsule = vmap(cap_info->pages, cap_info->index,\n\t\t\t\t\t VM_MAP, PAGE_KERNEL);\n\t\tif (!cap_info->capsule)\n\t\t\treturn -ENOMEM;\n\t\tdo_vunmap = true;\n\t}\n\n\tret = efi_capsule_update(cap_info->capsule, cap_info->phys);\n\tif (do_vunmap)\n\t\tvunmap(cap_info->capsule);\n\tif (ret) {\n\t\tpr_err(\"capsule update failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Indicate capsule binary uploading is done */\n\tcap_info->index = NO_FURTHER_WRITE_ACTION;\n\n\tif (cap_info->header.flags & EFI_CAPSULE_PERSIST_ACROSS_RESET) {\n\t\tpr_info(\"Successfully uploaded capsule file with reboot type '%s'\\n\",\n\t\t\t!cap_info->reset_type ? \"RESET_COLD\" :\n\t\t\tcap_info->reset_type == 1 ? \"RESET_WARM\" :\n\t\t\t\"RESET_SHUTDOWN\");\n\t} else {\n\t\tpr_info(\"Successfully processed capsule file\\n\");\n\t}\n\n\treturn 0;\n}\n\n/**\n * efi_capsule_write - store the capsule binary and pass it to\n *\t\t       efi_capsule_update() API\n * @file: file pointer\n * @buff: buffer pointer\n * @count: number of bytes in @buff\n * @offp: not used\n *\n *\tExpectation:\n *\t- A user space tool should start at the beginning of capsule binary and\n *\t  pass data in sequentially.\n *\t- Users should close and re-open this file note in order to upload more\n *\t  capsules.\n *\t- After an error returned, user should close the file and restart the\n *\t  operation for the next try otherwise -EIO will be returned until the\n *\t  file is closed.\n *\t- An EFI capsule header must be located at the beginning of capsule\n *\t  binary file and passed in as first block data of write operation.\n **/\nstatic ssize_t efi_capsule_write(struct file *file, const char __user *buff,\n\t\t\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tstruct capsule_info *cap_info = file->private_data;\n\tstruct page *page;\n\tvoid *kbuff = NULL;\n\tsize_t write_byte;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\t/* Return error while NO_FURTHER_WRITE_ACTION is flagged */\n\tif (cap_info->index < 0)\n\t\treturn -EIO;\n\n\t/* Only alloc a new page when previous page is full */\n\tif (!cap_info->page_bytes_remain) {\n\t\tpage = alloc_page(GFP_KERNEL);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tcap_info->pages[cap_info->index] = page;\n\t\tcap_info->phys[cap_info->index] = page_to_phys(page);\n\t\tcap_info->page_bytes_remain = PAGE_SIZE;\n\t\tcap_info->index++;\n\t} else {\n\t\tpage = cap_info->pages[cap_info->index - 1];\n\t}\n\n\tkbuff = kmap(page);\n\tkbuff += PAGE_SIZE - cap_info->page_bytes_remain;\n\n\t/* Copy capsule binary data from user space to kernel space buffer */\n\twrite_byte = min_t(size_t, count, cap_info->page_bytes_remain);\n\tif (copy_from_user(kbuff, buff, write_byte)) {\n\t\tret = -EFAULT;\n\t\tgoto fail_unmap;\n\t}\n\tcap_info->page_bytes_remain -= write_byte;\n\n\t/* Setup capsule binary info structure */\n\tif (cap_info->header.headersize == 0) {\n\t\tret = efi_capsule_setup_info(cap_info, kbuff - cap_info->count,\n\t\t\t\t\t     cap_info->count + write_byte);\n\t\tif (ret)\n\t\t\tgoto fail_unmap;\n\t}\n\n\tcap_info->count += write_byte;\n\tkunmap(page);\n\n\t/* Submit the full binary to efi_capsule_update() API */\n\tif (cap_info->header.headersize > 0 &&\n\t    cap_info->count >= cap_info->total_size) {\n\t\tif (cap_info->count > cap_info->total_size) {\n\t\t\tpr_err(\"capsule upload size exceeded header defined size\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = efi_capsule_submit_update(cap_info);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\treturn write_byte;\n\nfail_unmap:\n\tkunmap(page);\nfailed:\n\tefi_free_all_buff_pages(cap_info);\n\treturn ret;\n}\n\n/**\n * efi_capsule_flush - called by file close or file flush\n * @file: file pointer\n * @id: not used\n *\n *\tIf a capsule is being partially uploaded then calling this function\n *\twill be treated as upload termination and will free those completed\n *\tbuffer pages and -ECANCELED will be returned.\n **/\nstatic int efi_capsule_flush(struct file *file, fl_owner_t id)\n{\n\tint ret = 0;\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tif (cap_info->index > 0) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t\tret = -ECANCELED;\n\t}\n\n\treturn ret;\n}\n\n/**\n * efi_capsule_release - called by file close\n * @inode: not used\n * @file: file pointer\n *\n *\tWe will not free successfully submitted pages since efi update\n *\trequires data to be maintained across system reboot.\n **/\nstatic int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\n/**\n * efi_capsule_open - called by file open\n * @inode: not used\n * @file: file pointer\n *\n *\tWill allocate each capsule_info memory for each file open call.\n *\tThis provided the capability to support multiple file open feature\n *\twhere user is not needed to wait for others to finish in order to\n *\tupload their capsule binary.\n **/\nstatic int efi_capsule_open(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info;\n\n\tcap_info = kzalloc(sizeof(*cap_info), GFP_KERNEL);\n\tif (!cap_info)\n\t\treturn -ENOMEM;\n\n\tcap_info->pages = kzalloc(sizeof(void *), GFP_KERNEL);\n\tif (!cap_info->pages) {\n\t\tkfree(cap_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tcap_info->phys = kzalloc(sizeof(void *), GFP_KERNEL);\n\tif (!cap_info->phys) {\n\t\tkfree(cap_info->pages);\n\t\tkfree(cap_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = cap_info;\n\n\treturn 0;\n}\n\nstatic const struct file_operations efi_capsule_fops = {\n\t.owner = THIS_MODULE,\n\t.open = efi_capsule_open,\n\t.write = efi_capsule_write,\n\t.flush = efi_capsule_flush,\n\t.release = efi_capsule_release,\n\t.llseek = no_llseek,\n};\n\nstatic struct miscdevice efi_capsule_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"efi_capsule_loader\",\n\t.fops = &efi_capsule_fops,\n};\n\nstatic int __init efi_capsule_loader_init(void)\n{\n\tint ret;\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn -ENODEV;\n\n\tret = misc_register(&efi_capsule_misc);\n\tif (ret)\n\t\tpr_err(\"Unable to register capsule loader device\\n\");\n\n\treturn ret;\n}\nmodule_init(efi_capsule_loader_init);\n\nstatic void __exit efi_capsule_loader_exit(void)\n{\n\tmisc_deregister(&efi_capsule_misc);\n}\nmodule_exit(efi_capsule_loader_exit);\n\nMODULE_DESCRIPTION(\"EFI capsule firmware binary loader\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * EFI capsule loader driver.\n *\n * Copyright 2015 Intel Corporation\n */\n\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/highmem.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/efi.h>\n#include <linux/vmalloc.h>\n\n#define NO_FURTHER_WRITE_ACTION -1\n\n/**\n * efi_free_all_buff_pages - free all previous allocated buffer pages\n * @cap_info: pointer to current instance of capsule_info structure\n *\n *\tIn addition to freeing buffer pages, it flags NO_FURTHER_WRITE_ACTION\n *\tto cease processing data in subsequent write(2) calls until close(2)\n *\tis called.\n **/\nstatic void efi_free_all_buff_pages(struct capsule_info *cap_info)\n{\n\twhile (cap_info->index > 0)\n\t\t__free_page(cap_info->pages[--cap_info->index]);\n\n\tcap_info->index = NO_FURTHER_WRITE_ACTION;\n}\n\nint __efi_capsule_setup_info(struct capsule_info *cap_info)\n{\n\tsize_t pages_needed;\n\tint ret;\n\tvoid *temp_page;\n\n\tpages_needed = ALIGN(cap_info->total_size, PAGE_SIZE) / PAGE_SIZE;\n\n\tif (pages_needed == 0) {\n\t\tpr_err(\"invalid capsule size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the capsule binary supported */\n\tret = efi_capsule_supported(cap_info->header.guid,\n\t\t\t\t    cap_info->header.flags,\n\t\t\t\t    cap_info->header.imagesize,\n\t\t\t\t    &cap_info->reset_type);\n\tif (ret) {\n\t\tpr_err(\"capsule not supported\\n\");\n\t\treturn ret;\n\t}\n\n\ttemp_page = krealloc(cap_info->pages,\n\t\t\t     pages_needed * sizeof(void *),\n\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!temp_page)\n\t\treturn -ENOMEM;\n\n\tcap_info->pages = temp_page;\n\n\ttemp_page = krealloc(cap_info->phys,\n\t\t\t     pages_needed * sizeof(phys_addr_t *),\n\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!temp_page)\n\t\treturn -ENOMEM;\n\n\tcap_info->phys = temp_page;\n\n\treturn 0;\n}\n\n/**\n * efi_capsule_setup_info - obtain the efi capsule header in the binary and\n *\t\t\t    setup capsule_info structure\n * @cap_info: pointer to current instance of capsule_info structure\n * @kbuff: a mapped first page buffer pointer\n * @hdr_bytes: the total received number of bytes for efi header\n *\n * Platforms with non-standard capsule update mechanisms can override\n * this __weak function so they can perform any required capsule\n * image munging. See quark_quirk_function() for an example.\n **/\nint __weak efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,\n\t\t\t\t  size_t hdr_bytes)\n{\n\t/* Only process data block that is larger than efi header size */\n\tif (hdr_bytes < sizeof(efi_capsule_header_t))\n\t\treturn 0;\n\n\tmemcpy(&cap_info->header, kbuff, sizeof(cap_info->header));\n\tcap_info->total_size = cap_info->header.imagesize;\n\n\treturn __efi_capsule_setup_info(cap_info);\n}\n\n/**\n * efi_capsule_submit_update - invoke the efi_capsule_update API once binary\n *\t\t\t       upload done\n * @cap_info: pointer to current instance of capsule_info structure\n **/\nstatic ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)\n{\n\tbool do_vunmap = false;\n\tint ret;\n\n\t/*\n\t * cap_info->capsule may have been assigned already by a quirk\n\t * handler, so only overwrite it if it is NULL\n\t */\n\tif (!cap_info->capsule) {\n\t\tcap_info->capsule = vmap(cap_info->pages, cap_info->index,\n\t\t\t\t\t VM_MAP, PAGE_KERNEL);\n\t\tif (!cap_info->capsule)\n\t\t\treturn -ENOMEM;\n\t\tdo_vunmap = true;\n\t}\n\n\tret = efi_capsule_update(cap_info->capsule, cap_info->phys);\n\tif (do_vunmap)\n\t\tvunmap(cap_info->capsule);\n\tif (ret) {\n\t\tpr_err(\"capsule update failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Indicate capsule binary uploading is done */\n\tcap_info->index = NO_FURTHER_WRITE_ACTION;\n\n\tif (cap_info->header.flags & EFI_CAPSULE_PERSIST_ACROSS_RESET) {\n\t\tpr_info(\"Successfully uploaded capsule file with reboot type '%s'\\n\",\n\t\t\t!cap_info->reset_type ? \"RESET_COLD\" :\n\t\t\tcap_info->reset_type == 1 ? \"RESET_WARM\" :\n\t\t\t\"RESET_SHUTDOWN\");\n\t} else {\n\t\tpr_info(\"Successfully processed capsule file\\n\");\n\t}\n\n\treturn 0;\n}\n\n/**\n * efi_capsule_write - store the capsule binary and pass it to\n *\t\t       efi_capsule_update() API\n * @file: file pointer\n * @buff: buffer pointer\n * @count: number of bytes in @buff\n * @offp: not used\n *\n *\tExpectation:\n *\t- A user space tool should start at the beginning of capsule binary and\n *\t  pass data in sequentially.\n *\t- Users should close and re-open this file note in order to upload more\n *\t  capsules.\n *\t- After an error returned, user should close the file and restart the\n *\t  operation for the next try otherwise -EIO will be returned until the\n *\t  file is closed.\n *\t- An EFI capsule header must be located at the beginning of capsule\n *\t  binary file and passed in as first block data of write operation.\n **/\nstatic ssize_t efi_capsule_write(struct file *file, const char __user *buff,\n\t\t\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tstruct capsule_info *cap_info = file->private_data;\n\tstruct page *page;\n\tvoid *kbuff = NULL;\n\tsize_t write_byte;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\t/* Return error while NO_FURTHER_WRITE_ACTION is flagged */\n\tif (cap_info->index < 0)\n\t\treturn -EIO;\n\n\t/* Only alloc a new page when previous page is full */\n\tif (!cap_info->page_bytes_remain) {\n\t\tpage = alloc_page(GFP_KERNEL);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tcap_info->pages[cap_info->index] = page;\n\t\tcap_info->phys[cap_info->index] = page_to_phys(page);\n\t\tcap_info->page_bytes_remain = PAGE_SIZE;\n\t\tcap_info->index++;\n\t} else {\n\t\tpage = cap_info->pages[cap_info->index - 1];\n\t}\n\n\tkbuff = kmap(page);\n\tkbuff += PAGE_SIZE - cap_info->page_bytes_remain;\n\n\t/* Copy capsule binary data from user space to kernel space buffer */\n\twrite_byte = min_t(size_t, count, cap_info->page_bytes_remain);\n\tif (copy_from_user(kbuff, buff, write_byte)) {\n\t\tret = -EFAULT;\n\t\tgoto fail_unmap;\n\t}\n\tcap_info->page_bytes_remain -= write_byte;\n\n\t/* Setup capsule binary info structure */\n\tif (cap_info->header.headersize == 0) {\n\t\tret = efi_capsule_setup_info(cap_info, kbuff - cap_info->count,\n\t\t\t\t\t     cap_info->count + write_byte);\n\t\tif (ret)\n\t\t\tgoto fail_unmap;\n\t}\n\n\tcap_info->count += write_byte;\n\tkunmap(page);\n\n\t/* Submit the full binary to efi_capsule_update() API */\n\tif (cap_info->header.headersize > 0 &&\n\t    cap_info->count >= cap_info->total_size) {\n\t\tif (cap_info->count > cap_info->total_size) {\n\t\t\tpr_err(\"capsule upload size exceeded header defined size\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = efi_capsule_submit_update(cap_info);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\treturn write_byte;\n\nfail_unmap:\n\tkunmap(page);\nfailed:\n\tefi_free_all_buff_pages(cap_info);\n\treturn ret;\n}\n\n/**\n * efi_capsule_release - called by file close\n * @inode: not used\n * @file: file pointer\n *\n *\tWe will not free successfully submitted pages since efi update\n *\trequires data to be maintained across system reboot.\n **/\nstatic int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\n/**\n * efi_capsule_open - called by file open\n * @inode: not used\n * @file: file pointer\n *\n *\tWill allocate each capsule_info memory for each file open call.\n *\tThis provided the capability to support multiple file open feature\n *\twhere user is not needed to wait for others to finish in order to\n *\tupload their capsule binary.\n **/\nstatic int efi_capsule_open(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info;\n\n\tcap_info = kzalloc(sizeof(*cap_info), GFP_KERNEL);\n\tif (!cap_info)\n\t\treturn -ENOMEM;\n\n\tcap_info->pages = kzalloc(sizeof(void *), GFP_KERNEL);\n\tif (!cap_info->pages) {\n\t\tkfree(cap_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tcap_info->phys = kzalloc(sizeof(void *), GFP_KERNEL);\n\tif (!cap_info->phys) {\n\t\tkfree(cap_info->pages);\n\t\tkfree(cap_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = cap_info;\n\n\treturn 0;\n}\n\nstatic const struct file_operations efi_capsule_fops = {\n\t.owner = THIS_MODULE,\n\t.open = efi_capsule_open,\n\t.write = efi_capsule_write,\n\t.release = efi_capsule_release,\n\t.llseek = no_llseek,\n};\n\nstatic struct miscdevice efi_capsule_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"efi_capsule_loader\",\n\t.fops = &efi_capsule_fops,\n};\n\nstatic int __init efi_capsule_loader_init(void)\n{\n\tint ret;\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn -ENODEV;\n\n\tret = misc_register(&efi_capsule_misc);\n\tif (ret)\n\t\tpr_err(\"Unable to register capsule loader device\\n\");\n\n\treturn ret;\n}\nmodule_init(efi_capsule_loader_init);\n\nstatic void __exit efi_capsule_loader_exit(void)\n{\n\tmisc_deregister(&efi_capsule_misc);\n}\nmodule_exit(efi_capsule_loader_exit);\n\nMODULE_DESCRIPTION(\"EFI capsule firmware binary loader\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/firmware/efi/capsule-loader.c"], "buggy_code_start_loc": [246], "buggy_code_end_loc": [328], "fixing_code_start_loc": [245], "fixing_code_end_loc": [310], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free.", "other": {"cve": {"id": "CVE-2022-40307", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-09T05:15:07.877", "lastModified": "2022-11-21T19:44:59.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free."}, {"lang": "es", "value": "Se ha detectado un problema en el kernel de Linux versiones hasta 5.19.8. El archivo drivers/firmware/efi/capsule-loader.c presenta una condici\u00f3n de carrera con un uso de memoria previamente liberada resultante"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.19.8", "matchCriteriaId": "5EB1A769-EB57-4441-A657-8E0EBC5243C1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/9cb636b5f6a8cc6d1b50809ec8f8d33ae0c84c95", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5257", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9cb636b5f6a8cc6d1b50809ec8f8d33ae0c84c95"}}