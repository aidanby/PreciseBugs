{"buggy_code": ["/* dvb-usb-firmware.c is part of the DVB USB library.\n *\n * Copyright (C) 2004-6 Patrick Boettcher (patrick.boettcher@posteo.de)\n * see dvb-usb-init.c for copyright information.\n *\n * This file contains functions for downloading the firmware to Cypress FX 1 and 2 based devices.\n *\n * FIXME: This part does actually not belong to dvb-usb, but to the usb-subsystem.\n */\n#include \"dvb-usb-common.h\"\n\n#include <linux/usb.h>\n\nstruct usb_cypress_controller {\n\tint id;\n\tconst char *name;       /* name of the usb controller */\n\tu16 cpu_cs_register;    /* needs to be restarted, when the firmware has been downloaded. */\n};\n\nstatic struct usb_cypress_controller cypress[] = {\n\t{ .id = DEVICE_SPECIFIC, .name = \"Device specific\", .cpu_cs_register = 0 },\n\t{ .id = CYPRESS_AN2135,  .name = \"Cypress AN2135\",  .cpu_cs_register = 0x7f92 },\n\t{ .id = CYPRESS_AN2235,  .name = \"Cypress AN2235\",  .cpu_cs_register = 0x7f92 },\n\t{ .id = CYPRESS_FX2,     .name = \"Cypress FX2\",     .cpu_cs_register = 0xe600 },\n};\n\n/*\n * load a firmware packet to the device\n */\nstatic int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 len)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev,0),\n\t\t\t0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5000);\n}\n\nint usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\n\t/* stop the CPU */\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(hx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(usb_cypress_load_firmware);\n\nint dvb_usb_download_firmware(struct usb_device *udev, struct dvb_usb_device_properties *props)\n{\n\tint ret;\n\tconst struct firmware *fw = NULL;\n\n\tif ((ret = request_firmware(&fw, props->firmware, &udev->dev)) != 0) {\n\t\terr(\"did not find the firmware file. (%s) Please see linux/Documentation/dvb/ for more details on firmware-problems. (%d)\",\n\t\t\tprops->firmware,ret);\n\t\treturn ret;\n\t}\n\n\tinfo(\"downloading firmware from file '%s'\",props->firmware);\n\n\tswitch (props->usb_ctrl) {\n\t\tcase CYPRESS_AN2135:\n\t\tcase CYPRESS_AN2235:\n\t\tcase CYPRESS_FX2:\n\t\t\tret = usb_cypress_load_firmware(udev, fw, props->usb_ctrl);\n\t\t\tbreak;\n\t\tcase DEVICE_SPECIFIC:\n\t\t\tif (props->download_firmware)\n\t\t\t\tret = props->download_firmware(udev,fw);\n\t\t\telse {\n\t\t\t\terr(\"BUG: driver didn't specified a download_firmware-callback, although it claims to have a DEVICE_SPECIFIC one.\");\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nint dvb_usb_get_hexline(const struct firmware *fw, struct hexline *hx,\n\t\t\t       int *pos)\n{\n\tu8 *b = (u8 *) &fw->data[*pos];\n\tint data_offs = 4;\n\tif (*pos >= fw->size)\n\t\treturn 0;\n\n\tmemset(hx,0,sizeof(struct hexline));\n\n\thx->len  = b[0];\n\n\tif ((*pos + hx->len + 4) >= fw->size)\n\t\treturn -EINVAL;\n\n\thx->addr = b[1] | (b[2] << 8);\n\thx->type = b[3];\n\n\tif (hx->type == 0x04) {\n\t\t/* b[4] and b[5] are the Extended linear address record data field */\n\t\thx->addr |= (b[4] << 24) | (b[5] << 16);\n/*\t\thx->len -= 2;\n\t\tdata_offs += 2; */\n\t}\n\tmemcpy(hx->data,&b[data_offs],hx->len);\n\thx->chk = b[hx->len + data_offs];\n\n\t*pos += hx->len + 5;\n\n\treturn *pos;\n}\nEXPORT_SYMBOL(dvb_usb_get_hexline);\n"], "fixing_code": ["/* dvb-usb-firmware.c is part of the DVB USB library.\n *\n * Copyright (C) 2004-6 Patrick Boettcher (patrick.boettcher@posteo.de)\n * see dvb-usb-init.c for copyright information.\n *\n * This file contains functions for downloading the firmware to Cypress FX 1 and 2 based devices.\n *\n * FIXME: This part does actually not belong to dvb-usb, but to the usb-subsystem.\n */\n#include \"dvb-usb-common.h\"\n\n#include <linux/usb.h>\n\nstruct usb_cypress_controller {\n\tint id;\n\tconst char *name;       /* name of the usb controller */\n\tu16 cpu_cs_register;    /* needs to be restarted, when the firmware has been downloaded. */\n};\n\nstatic struct usb_cypress_controller cypress[] = {\n\t{ .id = DEVICE_SPECIFIC, .name = \"Device specific\", .cpu_cs_register = 0 },\n\t{ .id = CYPRESS_AN2135,  .name = \"Cypress AN2135\",  .cpu_cs_register = 0x7f92 },\n\t{ .id = CYPRESS_AN2235,  .name = \"Cypress AN2235\",  .cpu_cs_register = 0x7f92 },\n\t{ .id = CYPRESS_FX2,     .name = \"Cypress FX2\",     .cpu_cs_register = 0xe600 },\n};\n\n/*\n * load a firmware packet to the device\n */\nstatic int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 len)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev,0),\n\t\t\t0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5000);\n}\n\nint usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 *buf;\n\tint ret, pos = 0;\n\tu16 cpu_cs_register = cypress[type].cpu_cs_register;\n\n\tbuf = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\thx = (struct hexline *)buf;\n\n\t/* stop the CPU */\n\tbuf[0] = 1;\n\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\tbuf[0] = 0;\n\t\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(usb_cypress_load_firmware);\n\nint dvb_usb_download_firmware(struct usb_device *udev, struct dvb_usb_device_properties *props)\n{\n\tint ret;\n\tconst struct firmware *fw = NULL;\n\n\tif ((ret = request_firmware(&fw, props->firmware, &udev->dev)) != 0) {\n\t\terr(\"did not find the firmware file. (%s) Please see linux/Documentation/dvb/ for more details on firmware-problems. (%d)\",\n\t\t\tprops->firmware,ret);\n\t\treturn ret;\n\t}\n\n\tinfo(\"downloading firmware from file '%s'\",props->firmware);\n\n\tswitch (props->usb_ctrl) {\n\t\tcase CYPRESS_AN2135:\n\t\tcase CYPRESS_AN2235:\n\t\tcase CYPRESS_FX2:\n\t\t\tret = usb_cypress_load_firmware(udev, fw, props->usb_ctrl);\n\t\t\tbreak;\n\t\tcase DEVICE_SPECIFIC:\n\t\t\tif (props->download_firmware)\n\t\t\t\tret = props->download_firmware(udev,fw);\n\t\t\telse {\n\t\t\t\terr(\"BUG: driver didn't specified a download_firmware-callback, although it claims to have a DEVICE_SPECIFIC one.\");\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nint dvb_usb_get_hexline(const struct firmware *fw, struct hexline *hx,\n\t\t\t       int *pos)\n{\n\tu8 *b = (u8 *) &fw->data[*pos];\n\tint data_offs = 4;\n\tif (*pos >= fw->size)\n\t\treturn 0;\n\n\tmemset(hx,0,sizeof(struct hexline));\n\n\thx->len  = b[0];\n\n\tif ((*pos + hx->len + 4) >= fw->size)\n\t\treturn -EINVAL;\n\n\thx->addr = b[1] | (b[2] << 8);\n\thx->type = b[3];\n\n\tif (hx->type == 0x04) {\n\t\t/* b[4] and b[5] are the Extended linear address record data field */\n\t\thx->addr |= (b[4] << 24) | (b[5] << 16);\n/*\t\thx->len -= 2;\n\t\tdata_offs += 2; */\n\t}\n\tmemcpy(hx->data,&b[data_offs],hx->len);\n\thx->chk = b[hx->len + data_offs];\n\n\t*pos += hx->len + 5;\n\n\treturn *pos;\n}\nEXPORT_SYMBOL(dvb_usb_get_hexline);\n"], "filenames": ["drivers/media/usb/dvb-usb/dvb-usb-firmware.c"], "buggy_code_start_loc": [39], "buggy_code_end_loc": [79], "fixing_code_start_loc": [39], "fixing_code_end_loc": [81], "type": "CWE-119", "message": "drivers/media/usb/dvb-usb/dvb-usb-firmware.c in the Linux kernel 4.9.x and 4.10.x before 4.10.7 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8061", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.177", "lastModified": "2017-04-27T19:05:41.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/media/usb/dvb-usb/dvb-usb-firmware.c in the Linux kernel 4.9.x and 4.10.x before 4.10.7 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/media/usb/dvb-usb/dvb-usb-firmware.c en el kernel de Linux 4.9.x y 4.10.x en versiones anteriores a 4.10.7 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "8A944C6C-C1BF-472D-8BC2-B112EEDF3BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "29F4F9E6-4EE0-43C4-9B72-03D773AF5719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "D249C5D2-9186-498C-9AF7-100162D856EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "783F5C9D-D179-4194-965E-F9A153EAE3B1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "79EC10DA-54C8-405F-B0AC-A0E8130B5AA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.12:*:*:*:*:*:*:*", "matchCriteriaId": "7AD95130-C8F6-4372-BB45-15C664D4E941"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.13:*:*:*:*:*:*:*", "matchCriteriaId": "BBB9620C-F4B3-47D1-951F-33E8CD39D516"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.14:*:*:*:*:*:*:*", "matchCriteriaId": "99E1E52C-8A19-4D3D-B890-8A7DE0745E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.15:*:*:*:*:*:*:*", "matchCriteriaId": "341DB6BF-E05C-478B-86E7-4466B9A64745"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.16:*:*:*:*:*:*:*", "matchCriteriaId": "26B28AFB-C8D8-401F-A7A1-F47A66B74CD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.17:*:*:*:*:*:*:*", "matchCriteriaId": "70525107-9C8E-4694-B7F3-98E0FA401C0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.18:*:*:*:*:*:*:*", "matchCriteriaId": "E41C688F-5EE3-4C71-9A76-3A7E12769335"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.19:*:*:*:*:*:*:*", "matchCriteriaId": "C3B8B635-4125-4BB7-92FE-E5AEBBB3730A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10:*:*:*:*:*:*:*", "matchCriteriaId": "1DCB26E2-5F19-4F9C-9FF3-184EF7262D6D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "3B614F17-FC57-4689-B875-33C2915432CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "4F8E178C-5E11-4335-94B5-8FBBF1EA0634"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "6B0C1F4E-9C54-4FC2-AD07-0D3B26CC2B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "C386C15E-74D2-47C7-802D-87B67D9EE1F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "59169334-1EA3-4E94-BBDD-49DAC1EC2CC2"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97972", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=67b0503db9c29b04eadfeede6bebbfe5ddad94ef", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/67b0503db9c29b04eadfeede6bebbfe5ddad94ef", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/67b0503db9c29b04eadfeede6bebbfe5ddad94ef"}}