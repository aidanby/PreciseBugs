{"buggy_code": ["package schema\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// UserVerifyEmailReq user verify email request\ntype UserVerifyEmailReq struct {\n\t// code\n\tCode string `validate:\"required,gt=0,lte=500\" form:\"code\"`\n\t// content\n\tContent string `json:\"-\"`\n}\n\n// GetUserResp get user response\ntype GetUserResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\tEMail string `json:\"e_mail\"`\n\t// mail status(1 pass 2 to be verified)\n\tMailStatus int `json:\"mail_status\"`\n\t// notice status(1 on 2off)\n\tNoticeStatus int `json:\"notice_status\"`\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// authority group\n\tAuthorityGroup int `json:\"authority_group\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation string `json:\"location\"`\n\t// ip info\n\tIPInfo string `json:\"ip_info\"`\n\t// language\n\tLanguage string `json:\"language\"`\n\t// access token\n\tAccessToken string `json:\"access_token\"`\n\t// is admin\n\tIsAdmin bool `json:\"is_admin\"`\n\t// user status\n\tStatus string `json:\"status\"`\n}\n\nfunc (r *GetUserResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.Avatar = FormatAvatarInfo(userInfo.Avatar)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n}\n\ntype GetUserToSetShowResp struct {\n\t*GetUserResp\n\tAvatar *AvatarInfo `json:\"avatar\"`\n}\n\nfunc (r *GetUserToSetShowResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tavatarInfo := &AvatarInfo{}\n\t_ = json.Unmarshal([]byte(userInfo.Avatar), avatarInfo)\n\t// if json.Unmarshal Error avatarInfo.Type is Empty\n\tr.Avatar = avatarInfo\n}\n\nfunc FormatAvatarInfo(avatarJson string) string {\n\tif avatarJson == \"\" {\n\t\treturn \"\"\n\t}\n\tavatarInfo := &AvatarInfo{}\n\terr := json.Unmarshal([]byte(avatarJson), avatarInfo)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tswitch avatarInfo.Type {\n\tcase \"gravatar\":\n\t\treturn avatarInfo.Gravatar\n\tcase \"custom\":\n\t\treturn avatarInfo.Custom\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// GetUserStatusResp get user status info\ntype GetUserStatusResp struct {\n\t// user status\n\tStatus string `json:\"status\"`\n}\n\n// GetOtherUserInfoByUsernameResp get user response\ntype GetOtherUserInfoByUsernameResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation string `json:\"location\"`\n\t// ip info\n\tIPInfo string `json:\"ip_info\"`\n\t// is admin\n\tIsAdmin   bool   `json:\"is_admin\"`\n\tStatus    string `json:\"status\"`\n\tStatusMsg string `json:\"status_msg,omitempty\"`\n}\n\nfunc (r *GetOtherUserInfoByUsernameResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tAvatar := FormatAvatarInfo(userInfo.Avatar)\n\tr.Avatar = Avatar\n\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[11]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t} else {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[userInfo.Status]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t}\n}\n\nconst (\n\tMailStatePass   = 1\n\tMailStateVerifi = 2\n\n\tNoticeStatusOn  = 1\n\tNoticeStatusOff = 2\n\n\tActionRecordTypeLogin    = \"login\"\n\tActionRecordTypeEmail    = \"e_mail\"\n\tActionRecordTypeFindPass = \"find_pass\"\n)\n\nvar UserStatusShow = map[int]string{\n\t1:  \"normal\",\n\t9:  \"forbidden\",\n\t10: \"deleted\",\n}\n\nvar UserStatusShowMsg = map[int]string{\n\t1:  \"\",\n\t9:  \"<strong>This user was suspended forever.</strong> This user doesn\u2019t meet a community guideline.\",\n\t10: \"This user was deleted.\",\n\t11: \"This user is inactive.\",\n}\n\n// EmailLogin\ntype UserEmailLogin struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"` // e_mail\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`         // password\n\tCaptchaID   string `json:\"captcha_id\"`                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"`                                  // captcha_code\n}\n\n// UserRegisterReq user register request\ntype UserRegisterReq struct {\n\t// name\n\tName string `validate:\"required,gt=3,lte=30\" json:\"name\"`\n\t// email\n\tEmail string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" `\n\t// password\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`\n\tIP          string `json:\"-\" `\n\tCaptchaID   string `json:\"captcha_id\"`   // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"` // captcha_code\n}\n\nfunc (u *UserRegisterReq) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\n// UserModifyPassWordRequest\ntype UserModifyPassWordRequest struct {\n\tUserID  string `json:\"-\" `        // user_id\n\tOldPass string `json:\"old_pass\" ` // old password\n\tPass    string `json:\"pass\" `     // password\n}\n\nfunc (u *UserModifyPassWordRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UpdateInfoRequest struct {\n\t// display_name\n\tDisplayName string `validate:\"required,gt=0,lte=30\" json:\"display_name\"`\n\t// username\n\tUsername string `validate:\"omitempty,gt=3,lte=30\" json:\"username\"`\n\t// avatar\n\tAvatar AvatarInfo `json:\"avatar\"`\n\t// bio\n\tBio string `validate:\"omitempty,gt=0,lte=4096\" json:\"bio\"`\n\t// bio\n\tBioHTML string `json:\"-\"`\n\t// website\n\tWebsite string `validate:\"omitempty,gt=0,lte=500\" json:\"website\"`\n\t// location\n\tLocation string `validate:\"omitempty,gt=0,lte=100\" json:\"location\"`\n\t// user id\n\tUserID string `json:\"-\" `\n}\n\ntype AvatarInfo struct {\n\tType     string `validate:\"omitempty,gt=0,lte=100\"  json:\"type\"`\n\tGravatar string `validate:\"omitempty,gt=0,lte=200\"  json:\"gravatar\"`\n\tCustom   string `validate:\"omitempty,gt=0,lte=200\"  json:\"custom\"`\n}\n\nfunc (req *UpdateInfoRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tif checker.IsInvalidUsername(req.Username) {\n\t\t\terrField := &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t}\n\t\t\terrFields = append(errFields, errField)\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\treq.BioHTML = converter.Markdown2HTML(req.Bio)\n\treturn nil, nil\n}\n\n// UpdateUserInterfaceRequest update user interface request\ntype UpdateUserInterfaceRequest struct {\n\t// language\n\tLanguage string `validate:\"required,gt=1,lte=100\" json:\"language\"`\n\t// user id\n\tUserId string `json:\"-\" `\n}\n\ntype UserRetrievePassWordRequest struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" ` // e_mail\n\tCaptchaID   string `json:\"captcha_id\" `                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\" `                                  // captcha_code\n}\n\ntype UserRePassWordRequest struct {\n\tCode    string `validate:\"required,gt=0,lte=100\" json:\"code\" ` // code\n\tPass    string `validate:\"required,gt=0,lte=32\" json:\"pass\" `  // Password\n\tContent string `json:\"-\"`\n}\n\nfunc (u *UserRePassWordRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UserNoticeSetRequest struct {\n\tNoticeSwitch bool   `json:\"notice_switch\"`\n\tUserID       string `json:\"-\"`\n}\n\ntype UserNoticeSetResp struct {\n\tNoticeSwitch bool `json:\"notice_switch\"`\n}\n\ntype ActionRecordReq struct {\n\t// action\n\tAction string `validate:\"required,oneof=login e_mail find_pass\" form:\"action\"`\n\tIP     string `json:\"-\"`\n}\n\ntype ActionRecordResp struct {\n\tCaptchaID  string `json:\"captcha_id\"`\n\tCaptchaImg string `json:\"captcha_img\"`\n\tVerify     bool   `json:\"verify\"`\n}\n\ntype UserBasicInfo struct {\n\tID          string `json:\"id\"`           // user_id\n\tUsername    string `json:\"username\" `    // name\n\tRank        int    `json:\"rank\" `        // rank\n\tDisplayName string `json:\"display_name\"` // display_name\n\tAvatar      string `json:\"avatar\" `      // avatar\n\tWebsite     string `json:\"website\" `     // website\n\tLocation    string `json:\"location\" `    // location\n\tIPInfo      string `json:\"ip_info\"`      // ip info\n\tStatus      string `json:\"status\"`       // status\n}\n\ntype GetOtherUserInfoByUsernameReq struct {\n\tUsername string `validate:\"required,gt=0,lte=500\" form:\"username\"`\n}\n\ntype GetOtherUserInfoResp struct {\n\tInfo *GetOtherUserInfoByUsernameResp `json:\"info\"`\n\tHas  bool                            `json:\"has\"`\n}\n\ntype UserChangeEmailSendCodeReq struct {\n\tUserVerifyEmailSendReq\n\tEmail  string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"`\n\tUserID string `json:\"-\"`\n}\n\ntype UserChangeEmailVerifyReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n\ntype UserVerifyEmailSendReq struct {\n\tCaptchaID   string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_id\"`\n\tCaptchaCode string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_code\"`\n}\n\n// UserRankingResp user ranking response\ntype UserRankingResp struct {\n\tUsersWithTheMostReputation []*UserRankingSimpleInfo `json:\"users_with_the_most_reputation\"`\n\tUsersWithTheMostVote       []*UserRankingSimpleInfo `json:\"users_with_the_most_vote\"`\n\tStaffs                     []*UserRankingSimpleInfo `json:\"staffs\"`\n}\n\n// UserRankingSimpleInfo user ranking simple info\ntype UserRankingSimpleInfo struct {\n\t// username\n\tUsername string `json:\"username\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// vote\n\tVoteCount int `json:\"vote_count\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n}\n\n// UserUnsubscribeEmailNotificationReq user unsubscribe email notification request\ntype UserUnsubscribeEmailNotificationReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n", "package converter\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/asaskevich/govalidator\"\n\t\"github.com/microcosm-cc/bluemonday\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"github.com/yuin/goldmark\"\n\t\"github.com/yuin/goldmark/ast\"\n\t\"github.com/yuin/goldmark/extension\"\n\t\"github.com/yuin/goldmark/parser\"\n\t\"github.com/yuin/goldmark/renderer\"\n\t\"github.com/yuin/goldmark/renderer/html\"\n\tgoldmarkHTML \"github.com/yuin/goldmark/renderer/html\"\n\t\"github.com/yuin/goldmark/util\"\n)\n\n// Markdown2HTML convert markdown to html\nfunc Markdown2HTML(source string) string {\n\tmdConverter := goldmark.New(\n\t\tgoldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),\n\t\tgoldmark.WithParserOptions(\n\t\t\tparser.WithAutoHeadingID(),\n\t\t),\n\t\tgoldmark.WithRendererOptions(\n\t\t\tgoldmarkHTML.WithHardWraps(),\n\t\t),\n\t)\n\tvar buf bytes.Buffer\n\tif err := mdConverter.Convert([]byte(source), &buf); err != nil {\n\t\tlog.Error(err)\n\t\treturn source\n\t}\n\treturn buf.String()\n}\n\ntype DangerousHTMLFilterExtension struct {\n}\n\nfunc (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {\n\tm.Renderer().AddOptions(renderer.WithNodeRenderers(\n\t\tutil.Prioritized(&DangerousHTMLRenderer{\n\t\t\tConfig: goldmarkHTML.NewConfig(),\n\t\t\tFilter: bluemonday.UGCPolicy(),\n\t\t}, 1),\n\t))\n}\n\ntype DangerousHTMLRenderer struct {\n\tgoldmarkHTML.Config\n\tFilter *bluemonday.Policy\n}\n\n// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.\nfunc (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {\n\treg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)\n\treg.Register(ast.KindRawHTML, r.renderRawHTML)\n\treg.Register(ast.KindLink, r.renderLink)\n\treg.Register(ast.KindAutoLink, r.renderAutoLink)\n\n}\n\nfunc (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tif !entering {\n\t\treturn ast.WalkSkipChildren, nil\n\t}\n\tn := node.(*ast.RawHTML)\n\tl := n.Segments.Len()\n\tfor i := 0; i < l; i++ {\n\t\tsegment := n.Segments.At(i)\n\t\t_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))\n\t}\n\treturn ast.WalkSkipChildren, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.HTMLBlock)\n\tif entering {\n\t\tl := n.Lines().Len()\n\t\tfor i := 0; i < l; i++ {\n\t\t\tline := n.Lines().At(i)\n\t\t\tr.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))\n\t\t}\n\t} else {\n\t\tif n.HasClosure() {\n\t\t\tclosure := n.ClosureLine\n\t\t\tr.Writer.SecureWrite(w, closure.Value(source))\n\t\t}\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\n\tn := node.(*ast.Link)\n\tif entering && r.renderLinkIsUrl(string(n.Destination)) {\n\t\t_, _ = w.WriteString(\"<a href=\\\"\")\n\t\tif r.Unsafe || !html.IsDangerousURL(n.Destination) {\n\t\t\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))\n\t\t}\n\t\t_ = w.WriteByte('\"')\n\t\tif n.Title != nil {\n\t\t\t_, _ = w.WriteString(` title=\"`)\n\t\t\tr.Writer.Write(w, n.Title)\n\t\t\t_ = w.WriteByte('\"')\n\t\t}\n\t\tif n.Attributes() != nil {\n\t\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t}\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(\"</a>\")\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.AutoLink)\n\n\tif !entering || !r.renderLinkIsUrl(string(n.URL(source))) {\n\t\treturn ast.WalkContinue, nil\n\t}\n\t_, _ = w.WriteString(`<a href=\"`)\n\turl := n.URL(source)\n\tlabel := n.Label(source)\n\tif n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(\"mailto:\")) {\n\t\t_, _ = w.WriteString(\"mailto:\")\n\t}\n\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))\n\tif n.Attributes() != nil {\n\t\t_ = w.WriteByte('\"')\n\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(`\">`)\n\t}\n\t_, _ = w.Write(util.EscapeHTML(label))\n\t_, _ = w.WriteString(`</a>`)\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {\n\treturn govalidator.IsURL(verifyUrl)\n}\n"], "fixing_code": ["package schema\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// UserVerifyEmailReq user verify email request\ntype UserVerifyEmailReq struct {\n\t// code\n\tCode string `validate:\"required,gt=0,lte=500\" form:\"code\"`\n\t// content\n\tContent string `json:\"-\"`\n}\n\n// GetUserResp get user response\ntype GetUserResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\tEMail string `json:\"e_mail\"`\n\t// mail status(1 pass 2 to be verified)\n\tMailStatus int `json:\"mail_status\"`\n\t// notice status(1 on 2off)\n\tNoticeStatus int `json:\"notice_status\"`\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// authority group\n\tAuthorityGroup int `json:\"authority_group\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation string `json:\"location\"`\n\t// ip info\n\tIPInfo string `json:\"ip_info\"`\n\t// language\n\tLanguage string `json:\"language\"`\n\t// access token\n\tAccessToken string `json:\"access_token\"`\n\t// is admin\n\tIsAdmin bool `json:\"is_admin\"`\n\t// user status\n\tStatus string `json:\"status\"`\n}\n\nfunc (r *GetUserResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.Avatar = FormatAvatarInfo(userInfo.Avatar)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n}\n\ntype GetUserToSetShowResp struct {\n\t*GetUserResp\n\tAvatar *AvatarInfo `json:\"avatar\"`\n}\n\nfunc (r *GetUserToSetShowResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tavatarInfo := &AvatarInfo{}\n\t_ = json.Unmarshal([]byte(userInfo.Avatar), avatarInfo)\n\t// if json.Unmarshal Error avatarInfo.Type is Empty\n\tr.Avatar = avatarInfo\n}\n\nfunc FormatAvatarInfo(avatarJson string) string {\n\tif avatarJson == \"\" {\n\t\treturn \"\"\n\t}\n\tavatarInfo := &AvatarInfo{}\n\terr := json.Unmarshal([]byte(avatarJson), avatarInfo)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tswitch avatarInfo.Type {\n\tcase \"gravatar\":\n\t\treturn avatarInfo.Gravatar\n\tcase \"custom\":\n\t\treturn avatarInfo.Custom\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// GetUserStatusResp get user status info\ntype GetUserStatusResp struct {\n\t// user status\n\tStatus string `json:\"status\"`\n}\n\n// GetOtherUserInfoByUsernameResp get user response\ntype GetOtherUserInfoByUsernameResp struct {\n\t// user id\n\tID string `json:\"id\"`\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// last login date\n\tLastLoginDate int64 `json:\"last_login_date\"`\n\t// username\n\tUsername string `json:\"username\"`\n\t// email\n\t// follow count\n\tFollowCount int `json:\"follow_count\"`\n\t// answer count\n\tAnswerCount int `json:\"answer_count\"`\n\t// question count\n\tQuestionCount int `json:\"question_count\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n\t// mobile\n\tMobile string `json:\"mobile\"`\n\t// bio markdown\n\tBio string `json:\"bio\"`\n\t// bio html\n\tBioHTML string `json:\"bio_html\"`\n\t// website\n\tWebsite string `json:\"website\"`\n\t// location\n\tLocation string `json:\"location\"`\n\t// ip info\n\tIPInfo string `json:\"ip_info\"`\n\t// is admin\n\tIsAdmin   bool   `json:\"is_admin\"`\n\tStatus    string `json:\"status\"`\n\tStatusMsg string `json:\"status_msg,omitempty\"`\n}\n\nfunc (r *GetOtherUserInfoByUsernameResp) GetFromUserEntity(userInfo *entity.User) {\n\t_ = copier.Copy(r, userInfo)\n\tAvatar := FormatAvatarInfo(userInfo.Avatar)\n\tr.Avatar = Avatar\n\n\tr.CreatedAt = userInfo.CreatedAt.Unix()\n\tr.LastLoginDate = userInfo.LastLoginDate.Unix()\n\tstatusShow, ok := UserStatusShow[userInfo.Status]\n\tif ok {\n\t\tr.Status = statusShow\n\t}\n\tif userInfo.MailStatus == entity.EmailStatusToBeVerified {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[11]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t} else {\n\t\tstatusMsgShow, ok := UserStatusShowMsg[userInfo.Status]\n\t\tif ok {\n\t\t\tr.StatusMsg = statusMsgShow\n\t\t}\n\t}\n}\n\nconst (\n\tMailStatePass   = 1\n\tMailStateVerifi = 2\n\n\tNoticeStatusOn  = 1\n\tNoticeStatusOff = 2\n\n\tActionRecordTypeLogin    = \"login\"\n\tActionRecordTypeEmail    = \"e_mail\"\n\tActionRecordTypeFindPass = \"find_pass\"\n)\n\nvar UserStatusShow = map[int]string{\n\t1:  \"normal\",\n\t9:  \"forbidden\",\n\t10: \"deleted\",\n}\n\nvar UserStatusShowMsg = map[int]string{\n\t1:  \"\",\n\t9:  \"<strong>This user was suspended forever.</strong> This user doesn\u2019t meet a community guideline.\",\n\t10: \"This user was deleted.\",\n\t11: \"This user is inactive.\",\n}\n\n// EmailLogin\ntype UserEmailLogin struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"` // e_mail\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`         // password\n\tCaptchaID   string `json:\"captcha_id\"`                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"`                                  // captcha_code\n}\n\n// UserRegisterReq user register request\ntype UserRegisterReq struct {\n\t// name\n\tName string `validate:\"required,gt=3,lte=30\" json:\"name\"`\n\t// email\n\tEmail string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" `\n\t// password\n\tPass        string `validate:\"required,gte=8,lte=32\" json:\"pass\"`\n\tIP          string `json:\"-\" `\n\tCaptchaID   string `json:\"captcha_id\"`   // captcha_id\n\tCaptchaCode string `json:\"captcha_code\"` // captcha_code\n}\n\nfunc (u *UserRegisterReq) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\n// UserModifyPassWordRequest\ntype UserModifyPassWordRequest struct {\n\tUserID  string `json:\"-\" `        // user_id\n\tOldPass string `json:\"old_pass\" ` // old password\n\tPass    string `json:\"pass\" `     // password\n}\n\nfunc (u *UserModifyPassWordRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UpdateInfoRequest struct {\n\t// display_name\n\tDisplayName string `validate:\"required,gt=0,lte=30\" json:\"display_name\"`\n\t// username\n\tUsername string `validate:\"omitempty,gt=3,lte=30\" json:\"username\"`\n\t// avatar\n\tAvatar AvatarInfo `json:\"avatar\"`\n\t// bio\n\tBio string `validate:\"omitempty,gt=0,lte=4096\" json:\"bio\"`\n\t// bio\n\tBioHTML string `json:\"-\"`\n\t// website\n\tWebsite string `validate:\"omitempty,gt=0,lte=500\" json:\"website\"`\n\t// location\n\tLocation string `validate:\"omitempty,gt=0,lte=100\" json:\"location\"`\n\t// user id\n\tUserID string `json:\"-\" `\n}\n\ntype AvatarInfo struct {\n\tType     string `validate:\"omitempty,gt=0,lte=100\"  json:\"type\"`\n\tGravatar string `validate:\"omitempty,gt=0,lte=200\"  json:\"gravatar\"`\n\tCustom   string `validate:\"omitempty,gt=0,lte=200\"  json:\"custom\"`\n}\n\nfunc (req *UpdateInfoRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(req.Username) > 0 {\n\t\tif checker.IsInvalidUsername(req.Username) {\n\t\t\terrField := &validator.FormErrorField{\n\t\t\t\tErrorField: \"username\",\n\t\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t\t}\n\t\t\terrFields = append(errFields, errField)\n\t\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t\t}\n\t}\n\treq.BioHTML = converter.Markdown2BasicHTML(req.Bio)\n\treturn nil, nil\n}\n\n// UpdateUserInterfaceRequest update user interface request\ntype UpdateUserInterfaceRequest struct {\n\t// language\n\tLanguage string `validate:\"required,gt=1,lte=100\" json:\"language\"`\n\t// user id\n\tUserId string `json:\"-\" `\n}\n\ntype UserRetrievePassWordRequest struct {\n\tEmail       string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\" ` // e_mail\n\tCaptchaID   string `json:\"captcha_id\" `                                    // captcha_id\n\tCaptchaCode string `json:\"captcha_code\" `                                  // captcha_code\n}\n\ntype UserRePassWordRequest struct {\n\tCode    string `validate:\"required,gt=0,lte=100\" json:\"code\" ` // code\n\tPass    string `validate:\"required,gt=0,lte=32\" json:\"pass\" `  // Password\n\tContent string `json:\"-\"`\n}\n\nfunc (u *UserRePassWordRequest) Check() (errFields []*validator.FormErrorField, err error) {\n\t// TODO i18n\n\terr = checker.CheckPassword(8, 32, 0, u.Pass)\n\tif err != nil {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   err.Error(),\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, err\n\t}\n\treturn nil, nil\n}\n\ntype UserNoticeSetRequest struct {\n\tNoticeSwitch bool   `json:\"notice_switch\"`\n\tUserID       string `json:\"-\"`\n}\n\ntype UserNoticeSetResp struct {\n\tNoticeSwitch bool `json:\"notice_switch\"`\n}\n\ntype ActionRecordReq struct {\n\t// action\n\tAction string `validate:\"required,oneof=login e_mail find_pass\" form:\"action\"`\n\tIP     string `json:\"-\"`\n}\n\ntype ActionRecordResp struct {\n\tCaptchaID  string `json:\"captcha_id\"`\n\tCaptchaImg string `json:\"captcha_img\"`\n\tVerify     bool   `json:\"verify\"`\n}\n\ntype UserBasicInfo struct {\n\tID          string `json:\"id\"`           // user_id\n\tUsername    string `json:\"username\" `    // name\n\tRank        int    `json:\"rank\" `        // rank\n\tDisplayName string `json:\"display_name\"` // display_name\n\tAvatar      string `json:\"avatar\" `      // avatar\n\tWebsite     string `json:\"website\" `     // website\n\tLocation    string `json:\"location\" `    // location\n\tIPInfo      string `json:\"ip_info\"`      // ip info\n\tStatus      string `json:\"status\"`       // status\n}\n\ntype GetOtherUserInfoByUsernameReq struct {\n\tUsername string `validate:\"required,gt=0,lte=500\" form:\"username\"`\n}\n\ntype GetOtherUserInfoResp struct {\n\tInfo *GetOtherUserInfoByUsernameResp `json:\"info\"`\n\tHas  bool                            `json:\"has\"`\n}\n\ntype UserChangeEmailSendCodeReq struct {\n\tUserVerifyEmailSendReq\n\tEmail  string `validate:\"required,email,gt=0,lte=500\" json:\"e_mail\"`\n\tUserID string `json:\"-\"`\n}\n\ntype UserChangeEmailVerifyReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n\ntype UserVerifyEmailSendReq struct {\n\tCaptchaID   string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_id\"`\n\tCaptchaCode string `validate:\"omitempty,gt=0,lte=500\" json:\"captcha_code\"`\n}\n\n// UserRankingResp user ranking response\ntype UserRankingResp struct {\n\tUsersWithTheMostReputation []*UserRankingSimpleInfo `json:\"users_with_the_most_reputation\"`\n\tUsersWithTheMostVote       []*UserRankingSimpleInfo `json:\"users_with_the_most_vote\"`\n\tStaffs                     []*UserRankingSimpleInfo `json:\"staffs\"`\n}\n\n// UserRankingSimpleInfo user ranking simple info\ntype UserRankingSimpleInfo struct {\n\t// username\n\tUsername string `json:\"username\"`\n\t// rank\n\tRank int `json:\"rank\"`\n\t// vote\n\tVoteCount int `json:\"vote_count\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// avatar\n\tAvatar string `json:\"avatar\"`\n}\n\n// UserUnsubscribeEmailNotificationReq user unsubscribe email notification request\ntype UserUnsubscribeEmailNotificationReq struct {\n\tCode    string `validate:\"required,gt=0,lte=500\" json:\"code\"`\n\tContent string `json:\"-\"`\n}\n", "package converter\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/asaskevich/govalidator\"\n\t\"github.com/microcosm-cc/bluemonday\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"github.com/yuin/goldmark\"\n\t\"github.com/yuin/goldmark/ast\"\n\t\"github.com/yuin/goldmark/extension\"\n\t\"github.com/yuin/goldmark/parser\"\n\t\"github.com/yuin/goldmark/renderer\"\n\t\"github.com/yuin/goldmark/renderer/html\"\n\tgoldmarkHTML \"github.com/yuin/goldmark/renderer/html\"\n\t\"github.com/yuin/goldmark/util\"\n)\n\n// Markdown2HTML convert markdown to html\nfunc Markdown2HTML(source string) string {\n\tmdConverter := goldmark.New(\n\t\tgoldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),\n\t\tgoldmark.WithParserOptions(\n\t\t\tparser.WithAutoHeadingID(),\n\t\t),\n\t\tgoldmark.WithRendererOptions(\n\t\t\tgoldmarkHTML.WithHardWraps(),\n\t\t),\n\t)\n\tvar buf bytes.Buffer\n\tif err := mdConverter.Convert([]byte(source), &buf); err != nil {\n\t\tlog.Error(err)\n\t\treturn source\n\t}\n\treturn buf.String()\n}\n\n// Markdown2BasicHTML convert markdown to html ,Only basic syntax can be used\nfunc Markdown2BasicHTML(source string) string {\n\tcontent := Markdown2HTML(source)\n\tfilter := bluemonday.NewPolicy()\n\tfilter.AllowElements(\"p\", \"b\", \"br\")\n\tfilter.AllowAttrs(\"src\").OnElements(\"img\")\n\tfilter.AddSpaceWhenStrippingTag(true)\n\tcontent = filter.Sanitize(content)\n\treturn content\n}\n\ntype DangerousHTMLFilterExtension struct {\n}\n\nfunc (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {\n\tm.Renderer().AddOptions(renderer.WithNodeRenderers(\n\t\tutil.Prioritized(&DangerousHTMLRenderer{\n\t\t\tConfig: goldmarkHTML.NewConfig(),\n\t\t\tFilter: bluemonday.UGCPolicy(),\n\t\t}, 1),\n\t))\n}\n\ntype DangerousHTMLRenderer struct {\n\tgoldmarkHTML.Config\n\tFilter *bluemonday.Policy\n}\n\n// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.\nfunc (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {\n\treg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)\n\treg.Register(ast.KindRawHTML, r.renderRawHTML)\n\treg.Register(ast.KindLink, r.renderLink)\n\treg.Register(ast.KindAutoLink, r.renderAutoLink)\n\n}\n\nfunc (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tif !entering {\n\t\treturn ast.WalkSkipChildren, nil\n\t}\n\tn := node.(*ast.RawHTML)\n\tl := n.Segments.Len()\n\tfor i := 0; i < l; i++ {\n\t\tsegment := n.Segments.At(i)\n\t\t_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))\n\t}\n\treturn ast.WalkSkipChildren, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.HTMLBlock)\n\tif entering {\n\t\tl := n.Lines().Len()\n\t\tfor i := 0; i < l; i++ {\n\t\t\tline := n.Lines().At(i)\n\t\t\tr.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))\n\t\t}\n\t} else {\n\t\tif n.HasClosure() {\n\t\t\tclosure := n.ClosureLine\n\t\t\tr.Writer.SecureWrite(w, closure.Value(source))\n\t\t}\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\n\tn := node.(*ast.Link)\n\tif entering && r.renderLinkIsUrl(string(n.Destination)) {\n\t\t_, _ = w.WriteString(\"<a href=\\\"\")\n\t\tif r.Unsafe || !html.IsDangerousURL(n.Destination) {\n\t\t\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))\n\t\t}\n\t\t_ = w.WriteByte('\"')\n\t\tif n.Title != nil {\n\t\t\t_, _ = w.WriteString(` title=\"`)\n\t\t\tr.Writer.Write(w, n.Title)\n\t\t\t_ = w.WriteByte('\"')\n\t\t}\n\t\tif n.Attributes() != nil {\n\t\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t}\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(\"</a>\")\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.AutoLink)\n\n\tif !entering || !r.renderLinkIsUrl(string(n.URL(source))) {\n\t\treturn ast.WalkContinue, nil\n\t}\n\t_, _ = w.WriteString(`<a href=\"`)\n\turl := n.URL(source)\n\tlabel := n.Label(source)\n\tif n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(\"mailto:\")) {\n\t\t_, _ = w.WriteString(\"mailto:\")\n\t}\n\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))\n\tif n.Attributes() != nil {\n\t\t_ = w.WriteByte('\"')\n\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(`\">`)\n\t}\n\t_, _ = w.Write(util.EscapeHTML(label))\n\t_, _ = w.WriteString(`</a>`)\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {\n\treturn govalidator.IsURL(verifyUrl)\n}\n"], "filenames": ["internal/schema/user_schema.go", "pkg/converter/markdown.go"], "buggy_code_start_loc": [312, 35], "buggy_code_end_loc": [313, 35], "fixing_code_start_loc": [312, 36], "fixing_code_end_loc": [313, 47], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository answerdev/answer prior to 1.0.6.", "other": {"cve": {"id": "CVE-2023-1245", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-07T08:15:10.013", "lastModified": "2023-03-13T15:13:29.733", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository answerdev/answer prior to 1.0.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.6", "matchCriteriaId": "BC30C65B-0A27-4181-94A2-75BDAD7D7145"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/71a4cdac81112975969129d308899edd155c0e80", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/f8011bb3-8212-4937-aa58-79f4b73be004", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/71a4cdac81112975969129d308899edd155c0e80"}}