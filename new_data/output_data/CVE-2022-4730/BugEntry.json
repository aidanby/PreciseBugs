{"buggy_code": ["// From Ext library\n/*global Ext*/\n// Defined in dashboard.html\n/*global AUTOCOMPLETE_DELAY CALENDAR_ICON CLOCK_ICON CONTEXT_FIELD_WIDTH FINDER_QUERY_DELAY*/\n/*global HELP_ICON NEW_DASHBOARD_REMOVE_GRAPHS REFRESH_ICON REMOVE_ICON RESIZE_ICON*/\n/*global SHARE_ICON UI_CONFIG initialState initialError permissions queryString userName*/\n/*global UP_ICON DOWN_ICON TRASH_ICON permissionsUnauthenticated schemes*/\n// Defined in composer_widgets.js\n/*global createFunctionsMenu createOptionsMenu updateCheckItems*/\n\n// Global object names\nvar viewport;\nvar contextSelector;\nvar contextSelectorFields = [];\nvar selectedScheme = null;\nvar selectedRecord = null;\nvar metricSelector;\nvar metricSelectorMode;\nvar metricSelectorGrid;\nvar metricSelectorTextField;\nvar graphArea;\nvar graphStore;\nvar graphView;\nvar navBar;\nvar dashboardName;\nvar dashboardURL;\nvar refreshTask;\nvar spacer;\nvar justClosedGraph = false;\nvar NOT_EDITABLE = ['from', 'until', 'width', 'height', 'target', 'uniq', '_uniq'];\nvar editor = null;\n\nvar cookieProvider = new Ext.state.CookieProvider({\n  path: document.body.dataset.baseUrl + 'dashboard'\n});\n\nvar NAV_BAR_REGION = cookieProvider.get('navbar-region') || 'north';\n\nvar CONFIRM_REMOVE_ALL = cookieProvider.get('confirm-remove-all') != 'false';\n\nvar currentlySettingHash = false;\n\nfunction changeHash(hash){\n    currentlySettingHash = true;\n    window.location.hash = hash;\n}\n\nif ('onhashchange' in window) // does the browser support the hashchange event?\n  window.onhashchange = function () {\n    if (currentlySettingHash){\n      currentlySettingHash = false;\n      return;\n    }\n    location.reload();\n  }\n\n/* Nav Bar configuration */\nvar navBarNorthConfig = {\n  region: 'north',\n  layout: 'hbox',\n  layoutConfig: { align: 'stretch' },\n  collapsible: true,\n  collapseMode: 'mini',\n  collapsed: false,\n  split: true,\n  title: 'untitled',\n  height: 350,\n  listeners: {\n    expand: function() { focusCompleter(); } // defined below\n  }\n};\n\nvar navBarWestConfig = Ext.apply({}, navBarNorthConfig);\ndelete navBarWestConfig.height;\nnavBarWestConfig.region = 'west';\nnavBarWestConfig.layout = 'vbox';\nnavBarWestConfig.width = 338;\n\n\n// Record types and stores\nvar SchemeRecord = Ext.data.Record.create([\n  {name: 'name'},\n  {name: 'pattern'},\n  {name: 'fields', type: 'auto'}\n]);\n\nvar schemeRecords = [];\n\nvar schemesStore = new Ext.data.Store({\n  fields: SchemeRecord\n});\n\n\nvar ContextFieldValueRecord = Ext.data.Record.create([\n  {name: 'name'},\n  {path: 'path'}\n]);\n\nvar contextFieldStore = new Ext.data.JsonStore({\n  url: document.body.dataset.baseUrl + 'metrics/find/',\n  root: 'metrics',\n  idProperty: 'name',\n  fields: ContextFieldValueRecord,\n  baseParams: {format: 'completer', wildcards: '1'}\n});\n\n\nvar GraphRecord = new Ext.data.Record.create([\n  {name: 'target'},\n  {name: 'params', type: 'auto'},\n  {name: 'url'},\n  {name: 'width', type: 'auto'},\n  {name: 'height', type: 'auto'},\n  {name: 'loading'},\n]);\n\nvar graphStore;\nfunction graphStoreUpdated() {\n  if (metricSelectorGrid) metricSelectorGrid.getView().refresh();\n}\n\ngraphStore = new Ext.data.ArrayStore({\n  fields: GraphRecord,\n  listeners: {\n    add: graphStoreUpdated,\n    remove: graphStoreUpdated,\n    update: graphStoreUpdated\n  }\n});\n\nvar originalDefaultGraphParams = {\n  from: '-2hours',\n  until: 'now',\n  width: UI_CONFIG.default_graph_width,\n  height: UI_CONFIG.default_graph_height\n};\nvar defaultGraphParams;\n//XXX\n// Per-session default graph params\nvar sessionDefaultParamsJson = cookieProvider.get('defaultGraphParams');\nif (sessionDefaultParamsJson && sessionDefaultParamsJson.length > 0) {\n  defaultGraphParams = Ext.decode(sessionDefaultParamsJson);\n} else {\n  defaultGraphParams = Ext.apply({}, originalDefaultGraphParams);\n}\n\nfunction isLoggedIn() {\n  return userName != null;\n}\n\nfunction hasPermission(permission) {\n  for (const i in permissions) {\n    if (permissions[i] === permission) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction htmlEncode(input) {\n  return input.replace(/[^a-zA-Z0-9 ]/g, function (chr) {\n    return '&#' + chr.charCodeAt() + ';';\n  });\n}\n\nfunction initDashboard () {\n\n  // Populate naming-scheme based datastructures\n  Ext.each(schemes, function (schemeInfo) {\n    schemeInfo.id = schemeInfo.name;\n    schemeRecords.push( new SchemeRecord(schemeInfo) );\n\n    Ext.each(schemeInfo.fields, function (field) {\n\n      // Context Field configuration\n      contextSelectorFields.push( new Ext.form.ComboBox({\n        id: schemeInfo.name + '-' + field.name,\n        fieldLabel: field.label,\n        width: CONTEXT_FIELD_WIDTH,\n        mode: 'remote',\n        triggerAction: 'all',\n        editable: true,\n        forceSelection: false,\n        store: contextFieldStore,\n        displayField: 'name',\n        queryDelay: 100,\n        queryParam: 'query',\n        minChars: 1,\n        typeAhead: false,\n        value: queryString[field.name] || getContextFieldCookie(field.name) || '*',\n        listeners: {\n          beforequery: buildQuery,\n          change: contextFieldChanged,\n          select: function (thisField) { thisField.triggerBlur(); focusCompleter(); },\n          afterrender: function (thisField) { thisField.hide(); },\n          hide: function (thisField) { thisField.getEl().up('.x-form-item').setDisplayed(false); },\n          show: function (thisField) { thisField.getEl().up('.x-form-item').setDisplayed(true); }\n        }\n      }) );\n\n    });\n\n  });\n  schemesStore.add(schemeRecords);\n\n  spacer = new Ext.form.TextField({\n    hidden: true,\n    hideMode: 'visibility'\n  });\n\n  var metricTypeCombo = new Ext.form.ComboBox({\n    id: 'metric-type-field',\n    fieldLabel: 'Metric Type',\n    width: CONTEXT_FIELD_WIDTH,\n    mode: 'local',\n    triggerAction: 'all',\n    editable: false,\n    store: schemesStore,\n    displayField: 'name',\n    listeners: {\n      afterrender: function (combo) {\n        var value = (queryString.metricType) ? queryString.metricType : getContextFieldCookie('metric-type');\n\n        if (!value) {\n          value = 'Everything';\n        }\n        var index = combo.store.find('name', value);\n        if (index > -1) {\n          var record = combo.store.getAt(index);\n          combo.setValue(value);\n          metricTypeSelected.defer(250, this, [combo, record, index]);\n        }\n      },\n      select: metricTypeSelected\n    }\n  });\n\n  contextSelector = new Ext.form.FormPanel({\n    flex: 1,\n    autoScroll: true,\n    labelAlign: 'right',\n    items: [\n      spacer,\n      metricTypeCombo\n    ].concat(contextSelectorFields)\n  });\n\n  function expandNode(node, recurse) {\n    function addAll () {\n      Ext.each(node.childNodes, function (child) {\n        if (child.leaf) {\n          graphAreaToggle(child.id, {dontRemove: true});\n        } else if (recurse) {\n          expandNode(child, recurse);\n        }\n      });\n    }\n\n    if (node.isExpanded()) {\n      addAll();\n    } else {\n      node.expand(false, false, addAll);\n    }\n  }\n\n  var folderContextMenu = new Ext.menu.Menu({\n    items: [{\n      text: 'Add All Metrics',\n      handler: function (item, e) {\n                 expandNode(item.parentMenu.node, false);\n               }\n    }, {\n      text: 'Add All Metrics (recursively)',\n      handler: function (item, e) {\n                 expandNode(item.parentMenu.node, true);\n               }\n    }]\n  });\n\n  if (NAV_BAR_REGION == 'west') {\n    metricSelectorMode = 'tree';\n    metricSelector = new Ext.tree.TreePanel({\n      root: new Ext.tree.TreeNode({}),\n      containerScroll: true,\n      autoScroll: true,\n      flex: 3.0,\n      pathSeparator: '.',\n      rootVisible: false,\n      singleExpand: false,\n      trackMouseOver: true,\n      listeners: {\n      click: metricTreeSelectorNodeClicked,\n      contextmenu: function (node, e) {\n                     if (!node.leaf) {\n                       folderContextMenu.node = node;\n                       folderContextMenu.showAt( e.getXY() );\n                     }\n                   }\n      }\n    });\n  } else { // NAV_BAR_REGION == 'north'\n    metricSelectorMode = 'text';\n    metricSelectorGrid = new Ext.grid.GridPanel({\n      region: 'center',\n      hideHeaders: true,\n      loadMask: true,\n      bodyCssClass: 'metric-result',\n\n      colModel: new Ext.grid.ColumnModel({\n        defaults: {\n          sortable: false,\n          menuDisabled: true\n        },\n        columns: [\n          {header: 'Metric Path', width: 1.0, dataIndex: 'path'}\n        ]\n      }),\n      viewConfig: {\n        forceFit: true,\n        rowOverCls: '',\n        bodyCssClass: 'metric-result',\n        getRowClass: function(record, index) {\n          var toggledClass = (\n             graphStore.findExact('target', 'target=' + record.data.path) == -1\n            ) ? 'metric-not-toggled' : 'metric-toggled';\n          var branchClass = (\n            record.data['is_leaf'] == '0'\n          ) ? 'result-is-branch-node' : '';\n          return toggledClass + ' ' + branchClass + ' metric-result';\n        }\n      },\n      selModel: new Ext.grid.RowSelectionModel({\n        singleSelect: false\n      }),\n      store: new Ext.data.JsonStore({\n        method: 'GET',\n        url: document.body.dataset.baseUrl + 'metrics/find/',\n        autoLoad: true,\n        baseParams: {\n          query: '*',\n          format: 'completer',\n          automatic_variants: (UI_CONFIG.automatic_variants) ? '1' : '0'\n        },\n        fields: ['path', 'is_leaf'],\n        root: 'metrics'\n      }),\n      listeners: {\n        rowclick: function (thisGrid, rowIndex, e) {\n                    var record = thisGrid.getStore().getAt(rowIndex);\n                    if (record.data['is_leaf'] == '1') {\n                      graphAreaToggle(record.data.path);\n                      thisGrid.getView().refresh();\n                    } else {\n                      metricSelectorTextField.setValue(record.data.path);\n                    }\n                    autocompleteTask.delay(50);\n                    focusCompleter();\n                  }\n      }\n    });\n\n    function completerKeyPress(thisField, e) {\n      var charCode = e.getCharCode();\n      if (charCode == 8 ||  //backspace\n          charCode >= 46 || //delete and all printables\n          charCode == 36 || //home\n          charCode == 35) { //end\n        autocompleteTask.delay(AUTOCOMPLETE_DELAY);\n      }\n    }\n\n    metricSelectorTextField = new Ext.form.TextField({\n      region: 'south',\n      enableKeyEvents: true,\n      cls: 'completer-input-field',\n      listeners: {\n        keydown: completerKeyPress,\n        afterrender: focusCompleter\n      }\n    });\n    metricSelector = new Ext.Panel({\n      flex: 1.5,\n      layout: 'border',\n      items: [metricSelectorGrid, metricSelectorTextField]\n    });\n  }\n\n  var autocompleteTask = new Ext.util.DelayedTask(function () {\n    var query = metricSelectorTextField.getValue();\n    var store = metricSelectorGrid.getStore();\n    if (query === '') {\n      query = '*'\n    }\n    store.setBaseParam('query', query);\n    store.load();\n  });\n\n  var graphTemplate = new Ext.XTemplate(\n    '<tpl for=\".\">',\n      '<div class=\"graph-container\">',\n        '<div class=\"graph-overlay\">',\n          '<img class=\"graph-img{loading}\" src=\"{url}\" width=\"{width}\" height=\"{height}\" id=\"graph{index}\">',\n          '<div class=\"overlay-close-button\" onclick=\"javascript: graphStore.removeAt(\\'{index}\\'); updateGraphRecords(); justClosedGraph = true;\">X</div>',\n        '</div>',\n      '</div>',\n    '</tpl>',\n    '<div class=\"x-clear\"></div>'\n  );\n\n  function setupGraphDD () {\n    graphView.dragZone = new Ext.dd.DragZone(graphView.getEl(), {\n      containerScroll: true,\n      ddGroup: 'graphs',\n\n      getDragData: function (e) {\n        var sourceEl = e.getTarget(graphView.itemSelector, 10);\n        if (sourceEl) {\n          var dupe = sourceEl.cloneNode(true);\n          dupe.id = Ext.id();\n          return {\n            ddel: dupe,\n            sourceEl: sourceEl,\n            repairXY: Ext.fly(sourceEl).getXY(),\n            sourceStore: graphStore,\n            draggedRecord: graphView.getRecord(sourceEl)\n          }\n        }\n      },\n\n      getRepairXY: function () {\n        return this.dragData.repairXY;\n      }\n\n    });\n\n    graphView.dropZone = new Ext.dd.DropZone(graphView.getEl(), {\n      ddGroup: 'graphs',\n      dropAction: 'reorder',\n      mergeEl: Ext.get('merge'),\n\n      getTargetFromEvent: function (e) {\n        return e.getTarget(graphView.itemSelector);\n      },\n\n      onNodeEnter: function (target, dd, e, data) {\n        //Ext.fly(target).addClass('graph-highlight');\n        this.setDropAction('reorder');\n        this.mergeTarget = Ext.get(target);\n        this.mergeSwitchTimeout = this.setDropAction.defer(UI_CONFIG.merge_hover_delay, this, ['merge']);\n      },\n\n      onNodeOut: function (target, dd, e, data) {\n        //Ext.fly(target).removeClass('graph-highlight');\n        this.mergeEl.hide();\n        //this.setDropAction('reorder');\n      },\n\n      onNodeOver: function (target, dd, e, data) {\n        return Ext.dd.DropZone.prototype.dropAllowed;\n      },\n\n      setDropAction: function (action) {\n        if (this.mergeSwitchTimeout != null) {\n          clearTimeout(this.mergeSwitchTimeout);\n          this.mergeSwitchTimeout = null;\n        }\n\n        this.dropAction = action;\n        if (action == 'reorder') {\n          //revert merge ui change\n          this.mergeEl.hide();\n        } else if (action == 'merge') {\n          //apply merge ui change\n          this.mergeEl.show();\n          var targetXY = this.mergeTarget.getXY();\n          var mergeElWidth = Math.max(GraphSize.width * 0.75, 20);\n          var xOffset = (GraphSize.width - mergeElWidth) / 2;\n          var yOffset = -14;\n          this.mergeEl.setXY([targetXY[0] + xOffset, targetXY[1] + yOffset]);\n          this.mergeEl.setWidth(mergeElWidth);\n        }\n      },\n\n      onNodeDrop: function (target, dd, e, data){\n        var nodes = graphView.getNodes();\n        var dropIndex = nodes.indexOf(target);\n        var dragIndex = graphStore.indexOf(data.draggedRecord);\n\n        if (dragIndex == dropIndex) {\n          return false;\n        }\n\n        if (this.dropAction == 'reorder') {\n          graphStore.removeAt(dragIndex);\n          graphStore.insert(dropIndex, data.draggedRecord);\n          updateGraphRecords();\n          return true;\n        } else if (this.dropAction == 'merge') {\n          var dragRecord = data.draggedRecord;\n          var dropRecord = graphView.getRecord(target);\n          if (dropRecord.data.params.target.length == 1) {\n            if (dropRecord.data.params.target[0] == dropRecord.data.params.title) {\n              delete dropRecord.data.params.title;\n            }\n          }\n\n          var mergedTargets = uniq( dragRecord.data.params.target.concat(dropRecord.data.params.target) );\n          dropRecord.data.params.target = mergedTargets;\n          dropRecord.data.target = Ext.urlEncode({target: mergedTargets});\n          dropRecord.commit();\n          graphStore.remove(dragRecord);\n          updateGraphRecords();\n          return true;\n        }\n        return false;\n      }\n    });\n  }\n\n  graphView = new Ext.DataView({\n    store: graphStore,\n    tpl: graphTemplate,\n    overClass: 'graph-over',\n    itemSelector: 'div.graph-container',\n    emptyText: 'Configure your context above, and then select some metrics.',\n    autoScroll: true,\n//    plugins: [\n//      new Ext.ux.DataViewTransition({\n//        duration: 750,\n//        idProperty: 'target'\n//      })\n//    ],\n    listeners: {\n      click: graphClicked,\n      render: setupGraphDD\n    }\n  });\n\n  /* Toolbar items */\n  var relativeTimeRange = {\n          icon: CLOCK_ICON,\n          text: 'Relative Time Range',\n          tooltip: 'View Recent Data',\n          handler: selectRelativeTime,\n          scope: this\n  };\n\n  var absoluteTimeRange = {\n    icon: CALENDAR_ICON,\n    text: 'Absolute Time Range',\n    tooltip: 'View Specific Time Range',\n    handler: selectAbsoluteTime,\n    scope: this\n  };\n\n  var timeRangeText = {\n    id: 'time-range-text',\n    xtype: 'tbtext',\n    text: getTimeText()\n  };\n\n  // Note that some of these items are changed in postLoginMenuAdjust() after login/logout\n  var dashboardMenu = {\n    text: 'Dashboard',\n    menu: {\n      items: [\n        {\n          text: 'New',\n          handler: function (item, e) {\n                     setDashboardName(null);\n                     if (NEW_DASHBOARD_REMOVE_GRAPHS) {\n                       graphStore.removeAll();\n                     }\n                     refreshGraphs();\n                   }\n        }, {\n          text: 'Finder',\n          handler: showDashboardFinder\n        }, {\n          text: 'Template Finder',\n          handler: showTemplateFinder\n        }, {\n          text: 'Save As Template',\n          handler: saveTemplate,\n          disabled: !hasPermission('change')\n        }, {\n          id: 'dashboard-save-button',\n          text: 'Save',\n          handler: function (item, e) {\n                     sendSaveRequest(dashboardName);\n                   },\n          disabled: dashboardName == null || !hasPermission('change')\n        }, {\n          id: 'dashboard-save-as-button',\n          text: 'Save As',\n          handler: saveDashboard,\n          disabled: !hasPermission('change')\n        }, {\n          text: 'Configure UI',\n          handler: configureUI\n        }, {\n          text: 'Edit Dashboard',\n          handler: editDashboard\n        }, {\n          id: 'dashboard-login-button',\n          text: getLoginMenuItemText(),\n          handler: function (item, e) {\n                     if (isLoggedIn()) {\n                       logout();\n                     } else {\n                       showLoginForm();\n                     }\n                   }\n        }\n      ]\n    }\n  };\n\n  var graphsMenu = {\n    text: 'Graphs',\n    menu: {\n      items: [\n        { text: 'New Graph',\n          menu: {\n            items: [\n              { text: 'Empty Graph',\n                handler: newEmptyGraph\n              },\n              { text: 'From URL',\n                handler: newFromUrl\n              },\n              { text: 'From Saved Graph',\n                handler: newFromSavedGraph\n              },\n              { text: 'From Metric',\n                handler: newFromMetric\n              }\n            ]\n          }\n        },\n        {\n          text: 'Edit Default Parameters',\n          handler: editDefaultGraphParameters\n        }, {\n          text: 'Resize',\n          handler: selectGraphSize\n        }, {\n          text: 'Remove All',\n          handler: removeAllGraphs\n        }\n      ]\n    }\n  };\n\n  var shareButton = {\n    icon: SHARE_ICON,\n    tooltip: 'Share This Dashboard',\n    text: 'Share',\n    handler: doShare\n  };\n\n  var helpButton = {\n    icon: HELP_ICON,\n    tooltip: 'Keyboard Shortcuts',\n    handler: showHelp\n  };\n\n  var resizeButton = {\n    icon: RESIZE_ICON,\n    tooltip: 'Resize Graphs',\n    handler: selectGraphSize\n  };\n\n  var removeAllButton = {\n    icon: REMOVE_ICON,\n    tooltip: 'Remove All Graphs',\n    handler: removeAllGraphs\n  };\n\n  var refreshButton = {\n    icon: REFRESH_ICON,\n    tooltip: 'Refresh Graphs',\n    handler: refreshGraphs\n  };\n\n  var autoRefreshButton = {\n    xtype: 'button',\n    id: 'auto-refresh-button',\n    text: 'Auto-Refresh',\n    enableToggle: true,\n    pressed: false,\n    tooltip: 'Toggle auto-refresh',\n    toggleHandler: function (button, pressed) {\n                     if (pressed) {\n                       startTask(refreshTask);\n                     } else {\n                       stopTask(refreshTask);\n                     }\n                   }\n  };\n\n  var every = {\n    xtype: 'tbtext',\n    text: 'every'\n  };\n\n  var seconds = {\n    xtype: 'tbtext',\n    text: 'seconds'\n  };\n\n  var autoRefreshField = {\n    id: 'auto-refresh-field',\n    xtype: 'textfield',\n    width: 25,\n    value: UI_CONFIG.refresh_interval,\n    enableKeyEvents: true,\n    disableKeyFilter: true,\n    listeners: {\n      change: function (field, newValue) { updateAutoRefresh(newValue); },\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      if (field.getValue() >= 1) {\n                        updateAutoRefresh( field.getValue() );\n                      }\n                    }\n                  }\n    }\n  };\n\n  var lastRefreshed = {\n    xtype: 'tbtext',\n    text: 'Last Refreshed: '\n  };\n\n  var lastRefreshedText = {\n    id: 'last-refreshed-text',\n    xtype: 'tbtext',\n    text: ( new Date() ).format('g:i:s A')\n  };\n\n  graphArea = new Ext.Panel({\n    region: 'center',\n    layout: 'fit',\n    autoScroll: false,\n    bodyCssClass: 'graph-area-body',\n    items: [graphView],\n    tbar: new Ext.Toolbar({\n      items: [\n        dashboardMenu,\n        graphsMenu,\n        '-',\n        shareButton,\n        '-',\n        relativeTimeRange,\n        absoluteTimeRange,\n        ' ',\n        timeRangeText,\n        '->',\n        helpButton,\n        resizeButton,\n        removeAllButton,\n        refreshButton,\n        autoRefreshButton,\n        every, autoRefreshField, seconds,\n        '-',\n        lastRefreshed, lastRefreshedText\n      ]\n    })\n  });\n\n  /* Nav Bar */\n  navBarNorthConfig.items = [metricSelector];\n  navBarWestConfig.items = [contextSelector, metricSelector];\n  var navBarConfig = (NAV_BAR_REGION == 'north') ? navBarNorthConfig : navBarWestConfig;\n  navBar = new Ext.Panel(navBarConfig);\n\n  viewport = new Ext.Viewport({\n    layout: 'border',\n    items: [\n      navBar,\n      graphArea\n    ]\n  });\n\n  refreshTask = {\n    run: refreshGraphs,\n    interval: UI_CONFIG.refresh_interval * 1000\n  };\n\n  // Load initial dashboard state if it was passed in\n  if (initialState) {\n    applyState(initialState);\n    navBar.collapse(false);\n  }\n\n  if(window.location.hash != '')\n  {\n    if (window.location.hash.indexOf('/') != -1) {\n      var nameVal = window.location.hash.substr(1).split('/');\n      sendLoadTemplateRequest(nameVal[0],nameVal[1]);\n    } else {\n      sendLoadRequest(window.location.hash.substr(1));\n    }\n    navBar.collapse(false);\n  }\n\n  if (initialError) {\n    Ext.Msg.alert('Error', htmlEncode(initialError));\n  }\n}\n\nfunction showHelp() {\n  var win = new Ext.Window({\n    title: 'Keyboard Shortcuts',\n    modal: true,\n    width: 550,\n    height: 300,\n    autoLoad: document.body.dataset.baseUrl + 'dashboard/help/'\n  });\n  win.show();\n}\n\nfunction metricTypeSelected (combo, record, index) {\n  selectedScheme = record;\n\n  // Show only the fields for the selected context\n  Ext.each(contextSelectorFields, function (field) {\n    if (field.getId().indexOf( selectedScheme.get('name') ) == 0) {\n      field.show();\n    } else {\n      field.hide();\n    }\n  });\n\n  setContextFieldCookie('metric-type', combo.getValue());\n  contextFieldChanged();\n  focusCompleter();\n}\n\n\nfunction buildQuery (queryEvent) {\n  var queryString = '';\n  var parts = selectedScheme.get('pattern').split('.');\n  var schemeName = selectedScheme.get('name');\n\n  // Clear cached records to force JSON queries every time\n  contextFieldStore.removeAll();\n  delete queryEvent.combo.lastQuery;\n\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i];\n    var field = part.match(/^<[^>]+>$/) ? part.substr(1, part.length - 2) : null;\n\n    if (field == null) {\n      queryString += part + '.';\n      continue;\n    }\n\n    var combo = Ext.getCmp(schemeName + '-' + field);\n    var value = combo.getValue();\n\n    if (UI_CONFIG.automatic_variants) {\n      if (value.indexOf(',') > -1 && value.search(/[{}]/) == -1) {\n        value = '{' + value + '}';\n      }\n    }\n\n    if (combo === queryEvent.combo) {\n      queryEvent.query = queryString + queryEvent.query + '*';\n      return;\n    } else {\n      if (value) {\n        queryString += value + '.';\n      } else {\n        Ext.Msg.alert('Missing Context', 'Please fill out all of the fields above first.');\n        queryEvent.cancel = true;\n        return;\n      }\n    }\n  }\n\n  Ext.Msg.alert('Error', htmlEncode('Failed to build query, could not find \"' + queryEvent.combo.getId() + '\" field'));\n  queryEvent.cancel = true;\n}\n\n\nfunction contextFieldChanged() {\n  var pattern = getContextFieldsPattern();\n  if (pattern) metricSelectorShow(pattern);\n}\n\nfunction getContextFieldsPattern() {\n  var schemeName = selectedScheme.get('name');\n  var pattern = selectedScheme.get('pattern');\n  var fields = selectedScheme.get('fields');\n  var missingFields = false;\n\n  Ext.each(fields, function (field) {\n    var id = schemeName + '-' + field.name;\n    var value = Ext.getCmp(id).getValue();\n\n    // Update context field cookies\n    setContextFieldCookie(field.name, value);\n\n    if (UI_CONFIG.automatic_variants) {\n      if (value.indexOf(',') > -1 && value.search(/[{}]/) == -1) {\n        value = '{' + value + '}';\n      }\n    }\n\n    if (value.trim() == '') {\n      missingFields = true;\n    } else {\n      pattern = pattern.replace('<' + field.name + '>', value);\n    }\n  });\n\n  if (missingFields) {\n    return;\n  }\n\n  return pattern;\n}\n\nfunction metricSelectorShow(pattern) {\n  if (metricSelectorMode == 'tree') {\n    metricTreeSelectorShow(pattern);\n  } else {\n    metricTextSelectorShow(pattern);\n  }\n}\n\nfunction metricTreeSelectorShow(pattern) {\n  var baseParts = pattern.split('.');\n\n  function setParams (loader, node, callback) {\n    loader.baseParams.format = 'treejson';\n\n    if (node.id == 'rootMetricSelectorNode') {\n      loader.baseParams.query = pattern + '.*';\n    } else {\n      var idParts = node.id.split('.');\n      idParts.splice(0, baseParts.length); //make it relative\n      var relativeId = idParts.join('.');\n      loader.baseParams.query = pattern + '.' + relativeId + '.*';\n    }\n  }\n\n  var loader = new Ext.tree.TreeLoader({\n    url: document.body.dataset.baseUrl + 'metrics/find/',\n    requestMethod: 'GET',\n    listeners: {beforeload: setParams}\n  });\n\n  try {\n    var oldRoot = Ext.getCmp('rootMetricSelectorNode');\n    oldRoot.destroy();\n  } catch (err) { }\n\n  var root = new Ext.tree.AsyncTreeNode({\n    id: 'rootMetricSelectorNode',\n    loader: loader\n  });\n\n  metricSelector.setRootNode(root);\n  root.expand();\n}\n\nfunction metricTextSelectorShow(pattern) {\n  var store = metricSelectorGrid.getStore();\n  store.setBaseParam('query', pattern);\n  store.load();\n}\n\n\nfunction metricTreeSelectorNodeClicked (node, e) {\n  if (!node.leaf) {\n    if (node.expanded) {\n      node.collapse();\n    } else {\n      node.loaded = false;\n      node.expand();\n    }\n    return;\n  }\n\n  graphAreaToggle(node.id);\n}\n\n\nfunction graphAreaToggle(target, options) {\n  /* The GraphRecord's id is their URL-encoded target=...&target=... string\n     This function can get called with either the encoded string or just a raw\n     metric path, eg. \"foo.bar.baz\".\n  */\n  var graphTargetString;\n  if (target.substr(0,7) == 'target=') {\n    graphTargetString = target;\n  } else {\n    graphTargetString = 'target=' + target;\n  }\n  var graphTargetList = Ext.urlDecode(graphTargetString)['target'];\n  if (typeof graphTargetList == 'string') {\n    graphTargetList = [graphTargetList];\n  }\n\n  var existingIndex = graphStore.findExact('target', graphTargetString);\n\n  if (existingIndex > -1) {\n    if ( (options === undefined) || (!options.dontRemove) ) {\n      graphStore.removeAt(existingIndex);\n    }\n  } else if ( (options === undefined) || (!options.onlyRemove) ) {\n    // Add it\n    var myParams = {\n      target: graphTargetList\n    };\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    if (options && options.defaultParams) {\n      Ext.apply(urlParams, options.defaultParams);\n    }\n    Ext.apply(urlParams, GraphSize);\n    Ext.apply(urlParams, myParams);\n\n    var record = new GraphRecord({\n      target: graphTargetString,\n      params: myParams,\n      url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n    });\n    graphStore.add([record]);\n    updateGraphRecords();\n  }\n}\n\nfunction importGraphUrl(targetUrl, options) {\n  var fullUrl = targetUrl;\n  var i = fullUrl.indexOf('?');\n  if (i == -1) {\n    return;\n  }\n\n  var queryString = fullUrl.substr(i+1);\n  var params = Ext.urlDecode(queryString);\n\n  var graphTargetList = params['target'];\n  if (typeof graphTargetList == 'string') {\n    graphTargetList = [graphTargetList];\n  }\n  params['target'] = graphTargetList;\n\n  if (graphTargetList.length == 0) {\n    return;\n  }\n\n  var graphTargetString = Ext.urlEncode({target: graphTargetList});\n  var existingIndex = graphStore.findExact('target', graphTargetString);\n\n  if (existingIndex > -1) {\n    if ( (options === undefined) || (!options.dontRemove) ) {\n      graphStore.removeAt(existingIndex);\n    }\n  } else {\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    Ext.apply(urlParams, params);\n    Ext.apply(urlParams, GraphSize);\n\n    var record = new GraphRecord({\n      target: graphTargetString,\n      params: params,\n      url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n      });\n      graphStore.add([record]);\n      updateGraphRecords();\n  }\n}\n\nfunction updateGraphRecords() {\n  graphStore.each(function (item, index) {\n    var params = {};\n    Ext.apply(params, defaultGraphParams);\n    Ext.apply(params, item.data.params);\n    Ext.apply(params, GraphSize);\n    params._uniq = Math.random();\n    if (params.title === undefined && params.target.length == 1) {\n      params.title = params.target[0];\n    }\n    if (!params.uniq === undefined) {\n        delete params['uniq'];\n    }\n\n    //Preload the image and set it into the UI once it is available.\n    item.set('loading','-loading');\n    var img = new Image();\n    img.onload = function() {\n      item.set('url',img.src);\n      item.set('loading','');\n    };\n    img.src = document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(params);\n\n    item.set('width', GraphSize.width);\n    item.set('height', GraphSize.height);\n    item.set('index', index);\n  });\n}\n\nfunction refreshGraphs() {\n  updateGraphRecords();\n  graphView.refresh();\n  graphArea.getTopToolbar().get('last-refreshed-text').setText( (new Date()).format('g:i:s A') );\n}\n\n/*\nfunction refreshGraph(index) {\n  var node = graphView.getNode(index);\n  var record = graphView.getRecord(node);\n  record.data.params.uniq = Math.random();\n  record.set('url', '/render?' + Ext.urlEncode(record.get('params')));\n\n  // This refreshNode method only refreshes the record data, it doesn't re-render\n  // the template. Which is pretty useless... It would be more efficient if we\n  // could simply re-render the template. Need to see if thats feasible.\n  //graphView.refreshNode(node);\n\n  // This is *slightly* better than just calling refreshGraphs() because we're only\n  // updating the URL of one graph, so caching should save us from re-rendering each\n  // graph.\n  //graphView.refresh();\n}\n*/\n\nfunction updateAutoRefresh (newValue) {\n  Ext.getCmp('auto-refresh-field').setValue(newValue);\n\n  var value = parseInt(newValue);\n  if ( isNaN(value) ) {\n    return;\n  }\n\n  if (Ext.getCmp('auto-refresh-button').pressed) {\n    stopTask(refreshTask);\n    refreshTask.interval = value * 1000;\n    startTask(refreshTask);\n  } else {\n    refreshTask.interval = value * 1000;\n  }\n}\n\n/* Task management */\nfunction stopTask(task) {\n  if (task.running) {\n    Ext.TaskMgr.stop(task);\n    task.running = false;\n  }\n}\n\nfunction startTask(task) {\n  if (!task.running) {\n    Ext.TaskMgr.start(task);\n    task.running = true;\n  }\n}\n\n/* Time Range management */\ndefaultGraphParams['from'].match(/([0-9]+)([^0-9]+)/);\nvar defaultRelativeQuantity = RegExp.$1;\nvar defaultRelativeUnits = RegExp.$2;\nvar TimeRange = {\n  // Default to a relative time range\n  type: 'relative',\n  relativeStartQuantity: defaultRelativeQuantity,\n  relativeStartUnits: defaultRelativeUnits,\n  relativeUntilQuantity: '',\n  relativeUntilUnits: 'now',\n  // Absolute time range\n  startDate: new Date(),\n  startTime: '9:00 AM',\n  endDate: new Date(),\n  endTime: '5:00 PM'\n};\n\nfunction getTimeText() {\n  if (TimeRange.type == 'relative') {\n    var text = 'Now showing the past ' + TimeRange.relativeStartQuantity + ' ' + TimeRange.relativeStartUnits;\n    if (TimeRange.relativeUntilUnits !== 'now' && TimeRange.relativeUntilUnits !== '') {\n      text = text + ' until ' + TimeRange.relativeUntilQuantity + ' ' + TimeRange.relativeUntilUnits + ' ago';\n    }\n    return text;\n  } else {\n    var fmt = 'g:ia F jS Y';\n    return 'Now Showing ' + TimeRange.startDate.format(fmt) + ' through ' + TimeRange.endDate.format(fmt);\n  }\n}\n\nfunction updateTimeText() {\n  graphArea.getTopToolbar().get('time-range-text').setText( getTimeText() );\n}\n\nfunction timeRangeUpdated() {\n  if (TimeRange.type == 'relative') {\n    var fromParam = '-' + TimeRange.relativeStartQuantity + TimeRange.relativeStartUnits;\n    if (TimeRange.relativeUntilUnits == 'now') {\n      var untilParam = 'now';\n    } else {\n      var untilParam = '-' + TimeRange.relativeUntilQuantity + TimeRange.relativeUntilUnits;\n    }\n  } else {\n    var fromParam = TimeRange.startDate.format('H:i_Ymd');\n    var untilParam = TimeRange.endDate.format('H:i_Ymd');\n  }\n  defaultGraphParams.from = fromParam;\n  defaultGraphParams.until = untilParam;\n  saveDefaultGraphParams();\n\n  graphStore.each(function () {\n    this.data.params.from = fromParam;\n    this.data.params.until = untilParam;\n  });\n\n  updateTimeText();\n  refreshGraphs();\n}\n\n\nfunction selectRelativeTime() {\n  var quantityField = new Ext.form.TextField({\n    fieldLabel: 'Show the past',\n    width: 90,\n    allowBlank: false,\n    regex: /\\d+/,\n    regexText: 'Please enter a number',\n    value: TimeRange.relativeStartQuantity\n  });\n\n  var unitField = new Ext.form.ComboBox({\n    fieldLabel: '',\n    width: 90,\n    mode: 'local',\n    editable: false,\n    triggerAction: 'all',\n    allowBlank: false,\n    forceSelection: true,\n    store: ['minutes', 'hours', 'days', 'weeks', 'months'],\n    value: TimeRange.relativeStartUnits\n  });\n\n  var untilQuantityField = new Ext.form.TextField({\n    id: 'until-quantity-field',\n    fieldLabel: 'Until',\n    width: 90,\n    allowBlank: true,\n    regex: /\\d+/,\n    regexText: 'Please enter a number',\n    value: TimeRange.relativeUntilQuantity\n  });\n\n  var untilUnitField = new Ext.form.ComboBox({\n    fieldLabel: '',\n    width: 90,\n    mode: 'local',\n    editable: false,\n    triggerAction: 'all',\n    allowBlank: true,\n    forceSelection: false,\n    store: ['now', 'minutes', 'hours', 'days', 'weeks', 'months'],\n    value: TimeRange.relativeUntilUnits,\n    listeners: {\n      select: function(combo, record, index) {\n                  if (index == 0) {\n                    Ext.getCmp('until-quantity-field').setValue('');\n                    Ext.getCmp('until-quantity-field').setDisabled(true);\n                  } else {\n                    Ext.getCmp('until-quantity-field').setDisabled(false);\n                  }\n                },\n      render: function(combo) {\n                if (combo.getValue() == 'now') {\n                  Ext.getCmp('until-quantity-field').setValue('');\n                  Ext.getCmp('until-quantity-field').setDisabled(true);\n                } else {\n                  Ext.getCmp('until-quantity-field').setDisabled(false);\n                }\n              }\n    }\n  });\n\n\n  var win;\n\n  function updateTimeRange() {\n    TimeRange.type = 'relative';\n    TimeRange.relativeStartQuantity = quantityField.getValue();\n    TimeRange.relativeStartUnits = unitField.getValue();\n    TimeRange.relativeUntilQuantity = untilQuantityField.getValue();\n    TimeRange.relativeUntilUnits = untilUnitField.getValue();\n    win.close();\n    timeRangeUpdated();\n  }\n\n  win = new Ext.Window({\n    title: 'Select Relative Time Range',\n    width: 205,\n    height: 170,\n    resizable: false,\n    modal: true,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 90,\n    items: [quantityField, unitField, untilQuantityField, untilUnitField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: updateTimeRange},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\nfunction selectAbsoluteTime() {\n  var startDateField = new Ext.form.DateField({\n    fieldLabel: 'Start Date',\n    width: 125,\n    value: TimeRange.startDate || ''\n  });\n\n  var startTimeField = new Ext.form.TimeField({\n    fieldLabel: 'Start Time',\n    width: 125,\n    allowBlank: false,\n    increment: 30,\n    value: TimeRange.startTime || ''\n  });\n\n  var endDateField = new Ext.form.DateField({\n    fieldLabel: 'End Date',\n    width: 125,\n    value: TimeRange.endDate || ''\n  });\n\n  var endTimeField = new Ext.form.TimeField({\n    fieldLabel: 'End Time',\n    width: 125,\n    allowBlank: false,\n    increment: 30,\n    value: TimeRange.endTime || ''\n  });\n\n  var win;\n\n  function updateTimeRange() {\n    TimeRange.type = 'absolute';\n    TimeRange.startDate = new Date(startDateField.getValue().format('Y/m/d ') + startTimeField.getValue());\n    TimeRange.startTime = startTimeField.getValue();\n    TimeRange.endDate = new Date(endDateField.getValue().format('Y/m/d ') + endTimeField.getValue());\n    TimeRange.endTime = endTimeField.getValue();\n    win.close();\n    timeRangeUpdated();\n  }\n\n  win = new Ext.Window({\n    title: 'Select Absolute Time Range',\n    width: 225,\n    height: 180,\n    resizable: false,\n    modal: true,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 70,\n    items: [startDateField, startTimeField, endDateField, endTimeField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: updateTimeRange},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\n\n/* Graph size stuff */\nvar GraphSize = {\n  width: UI_CONFIG.default_graph_width,\n  height: UI_CONFIG.default_graph_height\n};\n\n\n// New empty Graph\nfunction newEmptyGraph() {\n\n  var myParams = {\n    target: []\n  };\n\n  var graphTargetString = Ext.urlEncode({target: ''});\n\n  var urlParams = {};\n  Ext.apply(urlParams, defaultGraphParams);\n  Ext.apply(urlParams, myParams);\n  Ext.apply(urlParams, GraphSize);\n  myParams['from'] = urlParams.from;\n  myParams['until'] = urlParams.until;\n\n  var record = new GraphRecord({\n   target: graphTargetString,\n    params: myParams,\n    url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams),\n   'width': GraphSize.width,\n   'height': GraphSize.height,\n    });\n  graphStore.add([record]);\n  var canvasId = graphStore.indexOf(record);\n  graphStore.getAt(canvasId).data.index = canvasId;\n  updateGraphRecords();\n}\n\nfunction newFromUrl() {\n  function applyUrl() {\n    var inputUrl = Ext.getCmp('import-url-field').getValue();\n    importGraphUrl(inputUrl);\n    win.close();\n  }\n\n  var urlField = new Ext.form.TextField({\n    id: 'import-url-field',\n    fieldLabel: 'Graph URL',\n    region: 'center',\n    width: '100%',\n    listeners: {\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      applyUrl();\n                    }\n                  },\n      afterrender: function (field) { field.focus(false, 100); }\n    }\n  });\n\n  var win = new Ext.Window({\n    title: 'Import Graph From URL',\n    width: 470,\n    height: 87,\n    layout: 'form',\n    resizable: true,\n    modal: true,\n    items: [urlField],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        text: 'OK',\n        handler: applyUrl\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n\n}\n\nfunction newFromSavedGraph() {\n  function setParams(loader, node) {\n    var nodeId = node.id.replace(/^[A-Za-z]+Tree\\.?/,'');\n    loader.baseParams.query = (nodeId == '') ? '*' : (nodeId + '.*');\n    loader.baseParams.format = 'treejson';\n    loader.baseParams.contexts = '1';\n    loader.baseParams.path = nodeId;\n    if (node.parentNode && node.parentNode.id == 'UserGraphsTree') {\n      loader.baseParams.user = node.id;\n    }\n  }\n\n  var userGraphsNode = new Ext.tree.AsyncTreeNode({\n    id: 'UserGraphsTree',\n    leaf: false,\n    allowChildren: true,\n    expandable: true,\n    allowDrag: false,\n    loader: new Ext.tree.TreeLoader({\n      url: document.body.dataset.baseUrl + 'browser/usergraph/',\n      requestMethod: 'GET',\n      listeners: {beforeload: setParams}\n    })\n  });\n\n  function handleSelects(selModel, nodes) {\n    Ext.each(nodes, function (node, index) {\n      if (!node.leaf) {\n        node.unselect();\n        node.toggle();\n      }\n    });\n\n    if (selModel.getSelectedNodes().length == 0) {\n      Ext.getCmp('user-graphs-select-button').setDisabled(true);\n    } else {\n      Ext.getCmp('user-graphs-select-button').setDisabled(false);\n    }\n  }\n\n  var treePanel = new Ext.tree.TreePanel({\n    id: 'user-graphs-tree',\n    header: false,\n    region: 'center',\n    root: userGraphsNode,\n    containerScroll: true,\n    autoScroll: true,\n    pathSeparator: '.',\n    rootVisible: false,\n    singleExpand: false,\n    trackMouseOver: true,\n    selModel: new Ext.tree.MultiSelectionModel({\n      listeners: {\n        selectionchange: handleSelects\n      }\n    })\n  });\n\n  function selectUserGraphs(selectedNodes) {\n    Ext.each(selectedNodes, function (node, index) {\n      importGraphUrl(node.attributes.graphUrl);\n    });\n  }\n\n  var win = new Ext.Window({\n    title: 'Import From User Graphs',\n    width: 300,\n    height: 400,\n    layout: 'border',\n    resizable: true,\n    modal: true,\n    items: [treePanel],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        id: 'user-graphs-select-button',\n        text: 'Select',\n        disabled: true,\n        handler: function () {\n          selectUserGraphs(Ext.getCmp('user-graphs-tree').getSelectionModel().getSelectedNodes());\n          win.close();\n        }\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n}\n\nfunction newFromMetric() {\n  function applyMetric() {\n    var inputMetric = Ext.getCmp('import-metric-field').getValue();\n    if (inputMetric == '') {\n      return;\n    }\n    var graphTargetString = Ext.urlEncode({target: inputMetric});\n\n    var myParams = {\n      target: [inputMetric]\n    };\n\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    Ext.apply(urlParams, myParams);\n    Ext.apply(urlParams, GraphSize);\n\n    var record = new GraphRecord({\n      target: graphTargetString,\n      params: myParams,\n      url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n      });\n    graphStore.add([record]);\n    updateGraphRecords();\n    win.close();\n  }\n\n  var urlField = new Ext.form.TextField({\n    id: 'import-metric-field',\n    fieldLabel: 'Metric',\n    region: 'center',\n    width: '100%',\n    listeners: {\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      applyMetric();\n                    }\n                  },\n      afterrender: function (field) { field.focus(false, 100); }\n    }\n  });\n\n  var win = new Ext.Window({\n    title: 'Import Graph From Metric',\n    width: 470,\n    height: 87,\n    layout: 'form',\n    resizable: true,\n    modal: true,\n    items: [urlField],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        text: 'OK',\n        handler: applyMetric\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n}\n\n\nfunction editDefaultGraphParameters() {\n  var editParams = Ext.apply({}, defaultGraphParams);\n  removeUneditable(editParams);\n\n  function applyParams() {\n    var paramsString = Ext.getCmp('default-params-field').getValue();\n    var params = Ext.urlDecode(paramsString);\n    copyUneditable(defaultGraphParams, params);\n    defaultGraphParams = params;\n    saveDefaultGraphParams();\n    refreshGraphs();\n    win.close();\n  }\n\n  var paramsField = new Ext.form.TextField({\n    id: 'default-params-field',\n    region: 'center',\n    value: Ext.urlEncode(editParams),\n    listeners: {\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      applyParams();\n                    }\n                  },\n      afterrender: function (field) { field.focus(false, 100); }\n    }\n  });\n\n  var win = new Ext.Window({\n    title: 'Default Graph Parameters',\n    width: 470,\n    height: 87,\n    layout: 'border',\n    resizable: true,\n    modal: true,\n    items: [paramsField],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        text: 'OK',\n        handler: applyParams\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n}\n\nfunction selectGraphSize() {\n  var presetCombo = new Ext.form.ComboBox({\n    fieldLabel: 'Preset',\n    width: 80,\n    editable: false,\n    forceSelection: true,\n    triggerAction: 'all',\n    mode: 'local',\n    value: 'Custom',\n    store: ['Custom', 'Small', 'Medium', 'Large'],\n    listeners: {\n      select: function (combo, record, index) {\n                var w = '';\n                var h = '';\n                if (index == 1) { //small\n                  w = 300;\n                  h = 230;\n                } else if (index == 2) { //medium\n                  w = 400;\n                  h = 300;\n                } else if (index == 3) { //large\n                  w = 500;\n                  h = 400;\n                }\n                Ext.getCmp('width-field').setValue(w);\n                Ext.getCmp('height-field').setValue(h);\n              }\n    }\n  });\n\n  var widthField = new Ext.form.TextField({\n    id: 'width-field',\n    fieldLabel: 'Width',\n    width: 80,\n    regex: /\\d+/,\n    regexText: 'Please enter a number',\n    allowBlank: false,\n    value: GraphSize.width || UI_CONFIG.default_graph_width\n  });\n\n  var heightField = new Ext.form.TextField({\n    id: 'height-field',\n    fieldLabel: 'Height',\n    width: 80,\n    regex: /\\d+/,\n    regexText: 'Please enter a number',\n    allowBlank: false,\n    value: GraphSize.height || UI_CONFIG.default_graph_height\n  })\n\n  var win;\n\n  function resize() {\n    GraphSize.width = defaultGraphParams.width = widthField.getValue();\n    GraphSize.height = defaultGraphParams.height = heightField.getValue();\n    saveDefaultGraphParams();\n    win.close();\n    refreshGraphs();\n  }\n\n  win = new Ext.Window({\n    title: 'Change Graph Size',\n    width: 185,\n    height: 160,\n    resizable: false,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 80,\n    modal: true,\n    items: [presetCombo, widthField, heightField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: resize},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\nfunction doShare() {\n  if (dashboardName == null) {\n    Ext.Ajax.request({\n      url: document.body.dataset.baseUrl + 'dashboard/create-temporary/',\n      method: 'POST',\n      params: {\n        state: Ext.encode( getState() )\n      },\n      callback: function (options, success, response) {\n                  var result = Ext.decode(response.responseText);\n                  if (result.error) {\n                    Ext.Msg.alert('Error', htmlEncode('There was an error saving this dashboard: ' + result.error));\n                  } else {\n                    setDashboardName(result.name);\n                    sendSaveRequest(result.name); // Resave the state with the proper dashboardName now\n                    showShareWindow();\n                  }\n                }\n    });\n  } else {\n    // Prompt the user to save their dashboard so they are aware only saved changes get shared\n    Ext.Msg.show({\n      title: 'Save Dashboard And Share',\n      msg: 'You must save changes to your dashboard in order to share it.',\n      buttons: Ext.Msg.OKCANCEL,\n      fn: function (button) {\n            if (button == 'ok') {\n              sendSaveRequest(dashboardName);\n              showShareWindow();\n            }\n          }\n    });\n\n  }\n}\n\nfunction showShareWindow() {\n  var win = new Ext.Window({\n    title: 'Share Dashboard',\n    width: 600,\n    height: 125,\n    layout: 'border',\n    modal: true,\n    items: [\n      {\n        xtype: 'label',\n        region: 'north',\n        style: 'text-align: center;',\n        text: 'You can use this URL to access the current dashboard.'\n      }, {\n        xtype: 'textfield',\n        region: 'center',\n        value: dashboardURL,\n        editable: false,\n        style: 'text-align: center; font-size: large;',\n        listeners: {\n          focus: function (field) { field.selectText(); }\n        }\n      }\n    ],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Close', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\n/* Other stuff */\nvar targetGrid;\nvar activeMenu;\n\nfunction graphClicked(graphView, graphIndex, element, evt) {\n  Ext.get('merge').hide();\n  var record = graphStore.getAt(graphIndex);\n  if (!record) {\n    return;\n  }\n\n  if (justClosedGraph) {\n    justClosedGraph = false;\n    return;\n  }\n\n  if ( (activeMenu != null) && (selectedRecord == record) ) {\n    activeMenu.destroy();\n    activeMenu = null;\n    return;\n  }\n\n  selectedRecord = record; // global state hack for graph options API\n\n  var menu;\n  var menuItems = [];\n\n  function applyChanges (field, e) {\n    if (e.getKey() != e.ENTER) {\n      return;\n    }\n\n    var targets = [];\n    Ext.each(menuItems, function (field) {\n      if ((!field.getXType) || field.getXType() != 'textfield') {\n        return;\n      }\n      if (field.initialConfig.isTargetField) {\n        targets.push( field.getValue() );\n      } else {\n        var newParams = Ext.urlDecode( field.getValue() );\n        copyUneditable(record.data.params, newParams);\n        record.data.params = newParams;\n      }\n    });\n    record.data.target = Ext.urlEncode( {target: targets} );\n    record.data.params.target = targets;\n\n    refreshGraphs();\n    menu.destroy();\n  }\n\n  function syncGraphs(thisStore, record, operation) {\n    var targets = [];\n    thisStore.each(function (rec) { targets.push(rec.data.target.replace(/'/g, '\"')); });\n    selectedRecord.data.params.target = targets;\n    selectedRecord.data.target = Ext.urlEncode({target: targets});\n    refreshGraphs();\n  }\n\n\n  /* Inline store definition hackery*/\n  var functionsButton;\n  var targets = record.data.params.target;\n  targets = map(targets, function (t) { return {target: t}; });\n  var targetStore = new Ext.data.JsonStore({\n    fields: ['target'],\n    data: targets,\n    listeners: {\n      update: syncGraphs,\n      remove: syncGraphs,\n      add: syncGraphs,\n    }\n  });\n\n  var buttonWidth = 115;\n  var rowHeight = 21;\n  var maxRows = 6;\n  var frameHeight = 5;\n  var gridWidth = (buttonWidth * 4) + 2;\n  var gridHeight = (rowHeight * Math.min(targets.length, maxRows)) + frameHeight;\n\n  targetGrid = new Ext.grid.EditorGridPanel({\n    //frame: true,\n    width: gridWidth,\n    height: gridHeight,\n    store: targetStore,\n    hideHeaders: true,\n    viewConfig: {\n                  markDirty: false,\n                  forceFit: true,\n                  autoFill: true,\n                  scrollOffset: 0\n                },\n    colModel: new Ext.grid.ColumnModel({\n      columns: [\n        {\n          id: 'target',\n          header: 'Target',\n          dataIndex: 'target',\n          width: gridWidth - 90,\n          renderer: 'htmlEncode',\n          editor: {xtype: 'textfield'}\n        },\n        {\n            xtype: 'actioncolumn',\n            width: 30,\n            sortable: false,\n            items: [{\n                icon: UP_ICON,\n                tooltip: 'Move Up',\n                handler: function(grid, rowIndex, colIndex) {\n                    var record = targetStore.getAt(rowIndex);\n                    var target = record.data.target;\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0targetStore.remove(record);\n                    if(rowIndex > 0) {\n                        targetStore.insert(rowIndex-1, record);\n                    } else {\n                        targetStore.add(record);\n                    }\n                }\n            }]\n        },\n        {\n            xtype: 'actioncolumn',\n            width: 30,\n            sortable: false,\n            items: [{\n                icon: DOWN_ICON,\n                tooltip: 'Move Down',\n                handler: function(grid, rowIndex, colIndex) {\n                    var record = targetStore.getAt(rowIndex);\n                    var target = record.data.target;\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0targetStore.remove(record);\n                    if(rowIndex < targetStore.getTotalCount()-1) {\n                        targetStore.insert(rowIndex+1, record);\n                    } else {\n                        targetStore.insert(0, record);\n                    }\n                }\n            }]\n        },\n        {\n            xtype: 'actioncolumn',\n            width: 30,\n            sortable: false,\n            items: [{\n                icon: TRASH_ICON,\n                tooltip: 'Delete Row',\n                handler: function(grid, rowIndex, colIndex) {\n                    var record = targetStore.getAt(rowIndex);\n                    var target = record.data.target;\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0targetStore.remove(record);\n                    targets.remove(target);\n                }\n            }]\n        },\n      ]\n    }),\n    selModel: new Ext.grid.RowSelectionModel({\n      singleSelect: false,\n      listeners: {\n        selectionchange: function (thisSelModel) {\n          functionsButton.setDisabled(thisSelModel.getCount() == 0);\n        }\n      }\n    }),\n    clicksToEdit: 2,\n    listeners: {\n      afterrender: function (thisGrid) {\n        thisGrid.getSelectionModel().selectFirstRow.defer(50, thisGrid.getSelectionModel());\n      },\n      resize: function (thisGrid) {\n        thisGrid.findParentByType('menu').doLayout();\n      }\n    }\n  });\n  menuItems.push(targetGrid);\n\n  /* Setup our menus */\n  var functionsMenu = new Ext.menu.Menu({\n    allowOtherMenus: true,\n    items: createFunctionsMenu().concat([ {text: 'Remove Outer Call', handler: removeOuterCall} ])\n  });\n\n  functionsButton = new Ext.Button({\n    text: 'Apply Function',\n    disabled: true,\n    width: buttonWidth,\n    handler: function (thisButton) {\n               if (functionsMenu.isVisible()) {\n                 functionsMenu.hide();\n               } else {\n                 operationsMenu.hide();\n                 optionsMenu.doHide(); // private method... yuck\n                 functionsMenu.show(thisButton.getEl());\n               }\n             }\n  });\n\n\n  var optionsMenuConfig = createOptionsMenu(); // defined in composer_widgets.js\n  optionsMenuConfig.allowOtherMenus = true;\n  var optionsMenu = new Ext.menu.Menu(optionsMenuConfig);\n  optionsMenu.on('hide', function () { menu.hide(); });\n  updateCheckItems();\n\n  var operationsMenu = new Ext.menu.Menu({\n    allowOtherMenus: true,\n    items: [{\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Breakout',\n      width: 100,\n      handler: function () { menu.destroy(); breakoutGraph(record); }\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Clone',\n      width: 100,\n      handler: function () { menu.destroy(); cloneGraph(record); }\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Email',\n      width: 100,\n      handler: function () { menu.destroy(); mailGraph(record); }\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Direct URL',\n      width: 100,\n      handler: function () {\n        menu.destroy();\n        var win = new Ext.Window({\n          title: 'Graph URL',\n          width: 600,\n          height: 125,\n          layout: 'border',\n          modal: true,\n          items: [\n            {\n              xtype: 'label',\n              region: 'north',\n              style: 'text-align: center;',\n              text: 'Direct URL to this graph'\n            }, {\n              xtype: 'textfield',\n              region: 'center',\n              value:  record.data.url,\n              editable: false,\n              style: 'text-align: center; font-size: large;',\n              listeners: {\n                focus: function (field) { field.selectText(); }\n              }\n            }\n          ],\n          buttonAlign: 'center',\n          buttons: [\n            {text: 'Close', handler: function () { win.close(); } }\n          ]\n        });\n        win.show();\n      },\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Short Direct URL',\n      width: 100,\n      handler: function () {\n        menu.destroy();\n        var showUrl = function(options, success, response) {\n            if(success) {\n              var win = new Ext.Window({\n                title: 'Graph URL',\n                width: 600,\n                height: 125,\n                layout: 'border',\n                modal: true,\n                items: [\n                  {\n                    xtype: 'label',\n                    region: 'north',\n                    style: 'text-align: center;',\n                    text: 'Short Direct URL to this graph'\n                  }, {\n                    xtype: 'textfield',\n                    region: 'center',\n                    value:  window.location.origin + response.responseText,\n                    editable: false,\n                    style: 'text-align: center; font-size: large;',\n                    listeners: {\n                      focus: function (field) { field.selectText(); }\n                    }\n                  }\n                ],\n                buttonAlign: 'center',\n                buttons: [\n                  {text: 'Close', handler: function () { win.close(); } }\n                ]\n              });\n              win.show();\n           }\n        }\n        Ext.Ajax.request({\n          method: 'GET',\n          url: document.body.dataset.baseUrl + 's' + record.data.url,\n          callback: showUrl,\n        });\n      }\n    }, {\n        xtype: 'button',\n        text: 'History',\n        width: 100,\n        handler: function () { menu.destroy(); historyGraph(record);}\n    }]\n  });\n\n  var buttons = [functionsButton];\n\n  buttons.push({\n    xtype: 'button',\n    text: 'Render Options',\n    width: buttonWidth,\n    handler: function (thisButton) {\n               if (optionsMenu.isVisible()) {\n                 optionsMenu.doHide(); // private method... yuck (no other way to hide w/out trigging hide event handler)\n               } else {\n                 operationsMenu.hide();\n                 functionsMenu.hide();\n                 optionsMenu.show(thisButton.getEl());\n               }\n             }\n  });\n\n  buttons.push({\n    xtype: 'button',\n    text: 'Graph Operations',\n    width: buttonWidth,\n    handler: function (thisButton) {\n               if (operationsMenu.isVisible()) {\n                 operationsMenu.hide();\n               } else {\n                 optionsMenu.doHide(); // private method... yuck\n                 functionsMenu.hide();\n                 operationsMenu.show(thisButton.getEl());\n               }\n             }\n  });\n\n  //create new row\n\u00a0\u00a0buttons.push({\n    xtype: 'button',\n\u00a0\u00a0\u00a0\u00a0text: 'Add Target',\n    width: buttonWidth,\n\u00a0\u00a0\u00a0\u00a0handler: function() {\n               // Hide the other menus\n               operationsMenu.hide();\n               optionsMenu.doHide(); // private method... yuck\n               functionsMenu.hide();\n\n               targetStore.add([ new targetStore.recordType({target: 'Edit to save'}) ]);\n               targets.push('Edit to save');\n               targetGrid.setHeight((rowHeight * Math.min(targets.length, maxRows)) + frameHeight);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0});\n\n\n  menuItems.push({\n    xtype: 'panel',\n    layout: 'hbox',\n    items: buttons\n  });\n\n  menu = new Ext.menu.Menu({\n    layout: 'anchor',\n    allowOtherMenus: true,\n    items: menuItems\n  });\n  activeMenu = menu;\n  var position = evt.getXY();\n  position[0] -= (buttonWidth * 1.5) + 10; //horizontally center menu with the mouse\n  menu.showAt(position);\n  menu.get(0).focus(false, 50);\n  menu.keyNav.disable();\n  menu.on('hide', function () {\n                    var graphMenuParams = Ext.getCmp('graphMenuParams');\n                    if (graphMenuParams) {\n                      graphMenuParams.destroy();\n                    }\n                  }\n  );\n  menu.on('destroy', function () {\n                       optionsMenu.destroy();\n                       operationsMenu.destroy();\n                       functionsMenu.destroy();\n                     }\n  );\n}\n\n\nfunction removeUneditable (obj) {\n  Ext.each(NOT_EDITABLE, function (p) {\n    delete obj[p];\n  });\n  return obj;\n}\n\nfunction copyUneditable (src, dst) {\n  Ext.each(NOT_EDITABLE, function (p) {\n    if (src[p] === undefined) {\n      delete dst[p];\n    } else {\n      dst[p] = src[p];\n    }\n  });\n}\n\nfunction breakoutGraph(record) {\n  /* We have to gather some context from the\n     graph target's expressions so we can reapply\n     functions after the expressions get expanded. */\n  var pathExpressions = [];\n  var exprInfo = {};\n\n  try {\n    Ext.each(record.data.params.target, function(target) {\n      var exprsInThisTarget = 0;\n      map(target.split(','), function (arg) {\n        var arglets = arg.split('(');\n        map(arglets[arglets.length-1].split(')'), function (expr) {\n          expr = expr.replace(/^\\s*(.+?)\\s*$/, '$1');\n          if (expr.length == 0 || expr[0] == '\"' || expr[0] == '\\'') return;\n\n          if (expr.match(/[a-z].*\\..*[a-z]/i)) {\n            exprsInThisTarget++;\n            if (exprsInThisTarget > 1) {\n              throw 'arrr!';\n            }\n\n            pathExpressions.push(expr);\n            var i = target.indexOf(expr);\n            exprInfo[expr] = {\n              expr: expr,\n              pre: target.substr(0, i),\n              post: target.substr(i + expr.length)\n            }\n\n          }\n\n        }); //map arglets\n      }); //map args\n    }); //each target\n  } catch (err) {\n    Ext.Msg.alert('Graph contains unbreakable target', 'Graph targets containing more than one metric expression cannot be broken out.');\n    return;\n  }\n\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'metrics/expand/',\n    params: {\n      groupByExpr: '1',\n      leavesOnly: '1',\n      query: pathExpressions\n    },\n    callback: function (options, success, response) {\n                var responseObj = Ext.decode(response.responseText);\n                graphStore.remove(record);\n                for (var expr in responseObj.results) {\n                  var pre = exprInfo[expr].pre;\n                  var post = exprInfo[expr].post;\n                  map(responseObj.results[expr], function (metricPath) {\n                    metricPath = pre + metricPath + post;\n                    graphAreaToggle(metricPath, {dontRemove: true, defaultParams: record.data.params});\n                  });\n                }\n              }\n  });\n}\n\nfunction mailGraph(record) {\n  var mygraphParams = record.get('params');\n  var newparams = Ext.encode(Ext.apply(mygraphParams, defaultGraphParams));\n\n  var fromField = new Ext.form.TextField({\n    fieldLabel: 'From',\n    name: 'sender',\n    width: 300,\n    allowBlank: false\n  });\n\n  var toField = new Ext.form.TextField({\n    fieldLabel: 'To',\n    name: 'recipients',\n    width: 300,\n    allowBlank: false\n  });\n\n  var subjectField = new Ext.form.TextField({\n    fieldLabel: 'Subject',\n    name: 'subject',\n    width: 300,\n    allowBlank: false\n  });\n\n  var msgField = new Ext.form.TextArea({\n    fieldLabel: 'Message',\n    name: 'message',\n    width: 300,\n    height: 75\n  });\n\n  var graphParamsField = new Ext.form.TextField({\n     name: 'graph_params',\n     hidden: true,\n     value: newparams\n  });\n\n  var contactForm = new Ext.form.FormPanel({\n    width: 300,\n    labelWidth: 90,\n    items: [fromField, toField, subjectField, msgField, graphParamsField],\n    buttons: [{\n      text: 'Cancel',\n      handler: function(){win.close();}\n    }, {\n         text: 'Send',\n         handler: function(){\n           if(contactForm.getForm().isValid()){\n             contactForm.getForm().submit({\n               url: document.body.dataset.baseUrl + 'dashboard/email',\n               waitMsg: 'Processing Request',\n               success: function (contactForm, response) {\n                 win.close();\n               }\n             });\n           }\n         }\n     }]\n  });\n\n  var win;\n\n  win = new Ext.Window({\n    title: 'Send graph via email',\n    width: 450,\n    height: 230,\n    resizable: true,\n    modal: true,\n    layout: 'fit',\n    items: [contactForm]\n  });\n  win.show();\n}\n\n\nfunction cloneGraph(record) {\n  var index = graphStore.indexOf(record);\n  var clone = cloneGraphRecord(record);\n  graphStore.insert(index+1, [clone]);\n  refreshGraphs();\n}\n\nfunction cloneGraphRecord(record) {\n  //ensure we are working with copies, not references\n  var props = {\n    url: record.data.url,\n    target: record.data.target,\n    params: Ext.apply({}, record.data.params)\n  };\n  props.params.target = Ext.urlDecode(props.target).target;\n  if (typeof props.params.target == 'string') {\n    props.params.target = [props.params.target];\n  }\n  return new GraphRecord(props);\n}\n\nfunction historyGraph(record){\n\n    var graphHistoryStore = new Ext.data.ArrayStore({\n      fields: GraphRecord,\n      listeners: {\n        add: graphStoreUpdated,\n        remove: graphStoreUpdated,\n        update: graphStoreUpdated\n      }\n    });\n\n    function getProps(record){\n        var props = {\n          url: record.data.url,\n          target: record.data.target,\n          params: Ext.apply({}, record.data.params)\n        };\n        props.params.target = Ext.urlDecode(props.target).target;\n        if (typeof props.params.target == 'string') {\n          props.params.target = [props.params.target];\n        }\n\n        props.params.width = '750';\n        props.params.height = '300';\n        props.params.until = '-';\n\n        return props;\n    }\n\n    var props = getProps(record);\n    var title = '';\n    title = (props.params.title != undefined) ? props.params.title : '';\n\n    props = getProps(record);\n    props.params.title = title + ' 1 hour';\n    props.params.from = '-1hour';\n    graphHistoryStore.insert(0,new GraphRecord(props));\n\n    props = getProps(record);\n    props.params.title = title + ' 1 day';\n    props.params.from = '-1day';\n    graphHistoryStore.insert(1,new GraphRecord(props));\n\n    props = getProps(record);\n    props.params.title = title + ' 7 day';\n    props.params.from = '-7day';\n    graphHistoryStore.insert(2,new GraphRecord(props));\n\n    props = getProps(record);\n    props.params.title = title + ' 30 day';\n    props.params.from = '-30day';\n    graphHistoryStore.insert(3,new GraphRecord(props));\n\n    var graphTemplate = new Ext.XTemplate(\n      '<tpl for=\".\">',\n        '<div class=\"graph-container\">',\n          '<div class=\"graph-overlay\">',\n            '<img class=\"graph-img\" src=\"{url}\" width=\"{width}\" height=\"{height}\" id=\"graph{index}\">',\n          '</div>',\n        '</div>',\n      '</tpl>',\n      '<div class=\"x-clear\"></div>'\n    );\n\n    updateDataHistory();\n\n    function updateDataHistory(){\n        graphHistoryStore.each(function (item, index) {\n          var params = {};\n          Ext.apply(params, defaultGraphParams);\n          Ext.apply(params, item.data.params);\n          //Ext.apply(params, GraphSize);\n          params._uniq = Math.random();\n          if (params.title === undefined && params.target.length == 1) {\n            params.title = params.target[0];\n          }\n\n          if (!params.uniq === undefined) {\n              delete params['uniq'];\n          }\n          item.set('url', '/render?' + Ext.urlEncode(params));\n          item.set('width', item.data.params.width);\n          item.set('height', item.data.params.height);\n          item.set('index', index);\n        });\n    }\n\n    var graphHistoryView = new Ext.DataView({\n      store: graphHistoryStore,\n      tpl: graphTemplate,\n      overClass: 'graph-over',\n      itemSelector: 'div.graph-container',\n      emptyText: 'Configure your context above, and then select some metrics.',\n      autoScroll: true,\n      listeners: {\n      }\n    });\n\n    var win = new Ext.Window({\n      title: 'Graph History',\n      width: 800,\n      height: 800,\n      resizable: true,\n      modal: true,\n      layout: 'fit',\n      items: graphHistoryView\n    });\n    win.show();\n\n}\nfunction removeAllGraphs() {\n  if (CONFIRM_REMOVE_ALL) {\n    /*\n    Ext.Msg.confirm(\n      \"Are you sure?\",\n      \"Are you sure you want to remove all the graphs?\",\n      function (choice) {\n        if (choice == 'yes') {\n          graphStore.removeAll();\n          refreshGraphs();\n        }\n      }\n    );\n    */\n    var win;\n    win = new Ext.Window({\n      title: 'Remove All Graphs',\n      width: 200,\n      height: 120,\n      modal: true,\n      layout: 'vbox',\n      layoutConfig: { align: 'center' },\n      items: [\n        {\n          xtype: 'label',\n          text: 'Are You Sure?',\n          style: 'font-size: large;'\n        }, {\n          id: 'always-ask-me',\n          xtype: 'checkbox',\n          boxLabel: 'Always Ask Me',\n          name: 'ask-me',\n          inputValue: 'yes',\n          checked: true\n        }\n      ],\n      buttonAlign: 'center',\n      buttons: [\n        {\n          text: 'Yes',\n          handler: function () {\n                     if (Ext.getCmp('always-ask-me').getValue()) {\n                       CONFIRM_REMOVE_ALL = true;\n                       cookieProvider.set('confirm-remove-all', 'true');\n                     } else {\n                       CONFIRM_REMOVE_ALL = false;\n                       cookieProvider.set('confirm-remove-all', 'false');\n                     }\n                     graphStore.removeAll();\n                     refreshGraphs();\n                     win.close();\n                   }\n        }, {\n          text: 'No',\n          handler: function () { win.close(); }\n        }\n      ]\n    });\n    win.show();\n  } else {\n    graphStore.removeAll();\n    refreshGraphs();\n  }\n}\n\n\nfunction toggleToolbar() {\n  var tbar = graphArea.getTopToolbar();\n  tbar.setVisible( ! tbar.isVisible() );\n  graphArea.doLayout();\n}\n\nfunction toggleNavBar() {\n  navBar.toggleCollapse(true);\n}\n\nfunction focusCompleter() {\n  if (metricSelectorTextField) metricSelectorTextField.focus(false, 50);\n}\n\n/* Keyboard shortcuts */\nvar keyEventHandlers = {\n  toggle_toolbar: toggleToolbar,\n  toggle_metrics_panel: toggleNavBar,\n  give_completer_focus: focusCompleter,\n  erase_all_graphs: function () {\n      graphStore.removeAll();\n      refreshGraphs();\n      graphStoreUpdated();\n    },\n  completer_add_metrics: function () {\n      if (metricSelectorGrid) {\n        metricSelectorGrid.getStore().each(function (record) {\n          if (record.data.path[ record.data.path.length - 1] != '.') {\n            graphAreaToggle(record.data.path, {dontRemove: true});\n          }\n        });\n        focusCompleter();\n      }\n    },\n  completer_del_metrics: function () {\n      if (metricSelectorGrid) {\n        metricSelectorGrid.getStore().each(function (record) {\n          graphAreaToggle(record.data.path, {onlyRemove: true});\n        });\n        focusCompleter();\n      }\n    },\n  save_dashboard: function () {\n      if (dashboardName == null) {\n        saveDashboard();\n      } else {\n        sendSaveRequest(dashboardName);\n      }\n    }\n};\n\nvar specialKeys = {\n  space: 32,\n  enter: Ext.EventObject.ENTER,\n  backspace: Ext.EventObject.BACKSPACE\n};\n\nvar keyMapConfigs = [];\n\nfor (var event_name in UI_CONFIG.keyboard_shortcuts) {\n  var config = {handler: keyEventHandlers[event_name]};\n  if (!config.handler) {\n    continue;\n  }\n  var keyString = UI_CONFIG.keyboard_shortcuts[event_name];\n  var keys = keyString.split('-');\n  config.ctrl = keys.indexOf('ctrl') > -1;\n  config.alt = keys.indexOf('alt') > -1;\n  config.shift = keys.indexOf('shift') > -1;\n  config.key = keys[keys.length - 1];\n  if (specialKeys[config.key]) {\n    config.key = specialKeys[config.key];\n  }\n  keyMapConfigs.push(config);\n}\n\nvar keyMap = new Ext.KeyMap(document, keyMapConfigs);\n\n\n/* Dashboard functions */\nfunction editDashboard() {\n  var editDashboardWin = new Ext.Window({\n    title: 'Edit Dashboard',\n    id: 'editor-window',\n    width: 700,\n    height: 500,\n    layout: 'vbox',\n    layoutConfig: {align: 'stretch', pack: 'start'},\n    modal: true,\n    items: [\n      {\n        xtype: 'container',\n        flex: 1,\n        id: 'editor',\n        title: 'ace',\n        listeners: { resize: function () { if (editor) editor.resize(); } }\n      }\n    ],\n    listeners: {\n      afterrender: {\n        scope: this,\n        fn: function (obj) { setupEditor(obj.body.dom); getInitialState() }\n      }\n    },\n    buttons: [\n      {text: 'Update (doesn\\'t save)', handler: updateAfterEdit},\n      {text: 'Cancel', handler: function () { editDashboardWin.close(); } }\n    ]\n  });\n  function updateAfterEdit(btn, target) {\n    var graphString = editor.getSession().getValue();\n    var targets = JSON.parse(graphString);\n    graphStore.removeAll();\n    var graphs = [];\n    for (var i = 0; i < targets.length; i++) {\n      var myParams = {};\n      Ext.apply(myParams, targets[i]);\n      var urlParams = {};\n      Ext.apply(urlParams, defaultGraphParams);\n      Ext.apply(urlParams, GraphSize);\n      Ext.apply(urlParams, myParams);\n      graphs.push([\n        Ext.urlEncode({target: targets[i].target}),\n        myParams,\n        document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n      ]);\n    }\n    graphStore.loadData(graphs);\n    refreshGraphs();\n    editDashboardWin.close();\n  }\n  function getInitialState() {\n    var graphs = [];\n    graphStore.each(function () {\n      var params = {};\n      Ext.apply(params, this.data.params);\n      delete params['from'];\n      delete params['until'];\n      graphs.push(params);\n    });\n    editor.getSession().setValue(JSON.stringify(graphs, null, 2));\n  }\n  function setupEditor(obj) {\n    editor = ace.edit('editor');\n    editor.setTheme('ace/theme/textmate');\n    var JSONMode = require('ace/mode/json').Mode;\n    var session = editor.getSession();\n    session.setMode(new JSONMode());\n    session.setUseSoftTabs(true);\n    session.setTabSize(2);\n  }\n  editDashboardWin.show();\n}\n\nfunction saveDashboard() {\n  Ext.Msg.prompt(\n    'Save Dashboard',\n    'Enter the name to save this dashboard as',\n    function (button, text) {\n      if (button == 'ok') {\n        setDashboardName(text);\n        sendSaveRequest(text);\n      }\n    },\n    this,\n    false,\n    (dashboardName) ? dashboardName : ''\n  );\n}\n\nfunction saveTemplate() {\n  var nameField = new Ext.form.TextField({\n    id: 'dashboard-save-template-name',\n    fieldLabel: 'Template Name',\n    width: 240,\n    allowBlank: false,\n    align: 'center',\n    value: dashboardName ? dashboardName.split('/')[0]: '',\n  });\n\n  var keyField = new Ext.form.TextField({\n    id: 'dashboard-save-template-key',\n    fieldLabel: 'String to replace',\n    width: 240,\n    allowBlank: false,\n    align: 'center',\n  });\n\n  var win;\n\n  function save() {\n    sendSaveTemplateRequest(nameField.getValue(), keyField.getValue());\n    win.close();\n  }\n\n  win = new Ext.Window({\n    title: 'Save dashboard as a template',\n    width: 400,\n    height: 120,\n    resizable: false,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 120,\n    items: [nameField,keyField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: save},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\nfunction sendSaveTemplateRequest(name, key) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/save_template/' + name + '/' + key,\n    method: 'POST',\n    params: {\n      state: Ext.encode( getState() )\n    },\n    success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error', htmlEncode('There was an error saving this dashboard as a template: ' + result.error));\n               }\n             },\n    failure: failedAjaxCall\n  });\n}\n\nfunction sendSaveRequest(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/save/' + name,\n    method: 'POST',\n    params: {\n      state: Ext.encode( getState() )\n    },\n    success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error', htmlEncode('There was an error saving this dashboard: ' + result.error));\n               }\n               if(newURL) {\n                 window.location = newURL;\n               } else {\n                 changeHash(name);\n               }\n             },\n    failure: failedAjaxCall\n  });\n}\n\nfunction sendLoadRequest(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/load/' + name,\n    success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error Loading Dashboard', htmlEncode(result.error));\n               } else {\n                 applyState(result.state);\n                 navBar.collapse(false);\n               }\n             },\n    failure: failedAjaxCall\n  });\n}\n\nfunction sendLoadTemplateRequest(name, value) {\n  var urlparts = window.location.href.split('#')\n  if(urlparts[0].split('?')[1]) {\n    var newLocation = urlparts[0].split('?')[0] + '#'+name+'/'+value;\n    window.location.href = newLocation;\n  } else {\n    Ext.Ajax.request({\n      url: document.body.dataset.baseUrl + 'dashboard/load_template/' + name + '/' + value,\n      success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error Loading Template', htmlEncode(result.error));\n               } else {\n                 applyState(result.state);\n                 navBar.collapse(false);\n               }\n             },\n      failure: failedAjaxCall\n    });\n  }\n}\n\nfunction getState() {\n  var graphs = [];\n  graphStore.each(\n    function (record) {\n      graphs.push([\n        record.data.id,\n        record.data.target,\n        record.data.params,\n        record.data.url\n      ]);\n    }\n  );\n\n  return {\n    name: dashboardName,\n    timeConfig: TimeRange,\n    refreshConfig: {\n      enabled: Ext.getCmp('auto-refresh-button').pressed,\n      interval: refreshTask.interval\n    },\n    graphSize: GraphSize,\n    defaultGraphParams: defaultGraphParams,\n    graphs: graphs\n  };\n}\n\nfunction applyState(state) {\n  setDashboardName(state.name);\n\n  //state.timeConfig = {type, quantity, units, untilQuantity, untilUnits, startDate, startTime, endDate, endTime}\n  var timeConfig = state.timeConfig\n  TimeRange.type = timeConfig.type;\n  TimeRange.relativeStartQuantity = timeConfig.relativeStartQuantity;\n  TimeRange.relativeStartUnits = timeConfig.relativeStartUnits;\n  TimeRange.relativeUntilQuantity = timeConfig.relativeUntilQuantity;\n  TimeRange.relativeUntilUnits = timeConfig.relativeUntilUnits;\n  TimeRange.startDate = new Date(timeConfig.startDate);\n  TimeRange.startTime = timeConfig.startTime;\n  TimeRange.endDate = new Date(timeConfig.endDate);\n  TimeRange.endTime = timeConfig.endTime;\n\n  if (queryString.from && queryString.until) {\n    // The URL contains a \"from\" and \"until\" parameters (format \"YYYY-MM-DDThh:mm:ss\") => use the timestamps as default absolute range of the dashboard\n    var from = new Date(queryString.from);\n    var until = new Date(queryString.until);\n\n    TimeRange.startDate = from;\n    TimeRange.startTime = from.format('H:m');\n    TimeRange.endDate = until;\n    TimeRange.endTime = until.format('H:m');\n    TimeRange.type = 'absolute';\n\n    state.timeConfig = TimeRange;\n\n    state.defaultGraphParams.from = from.format('H:i_Ymd');\n    state.defaultGraphParams.until = until.format('H:i_Ymd');\n  }\n\n  updateTimeText();\n\n\n\n  //state.refreshConfig = {enabled, interval}\n  var refreshConfig = state.refreshConfig;\n  if (refreshConfig.enabled) {\n    stopTask(refreshTask);\n    startTask(refreshTask);\n    Ext.getCmp('auto-refresh-button').toggle(true);\n  } else {\n    stopTask(refreshTask);\n    Ext.getCmp('auto-refresh-button').toggle(false);\n  }\n  //refreshTask.interval = refreshConfig.interval;\n  updateAutoRefresh(refreshConfig.interval / 1000);\n\n  //state.graphSize = {width, height}\n  var graphSize = state.graphSize;\n  GraphSize.width = graphSize.width;\n  GraphSize.height = graphSize.height;\n\n  //state.defaultGraphParams = {...}\n  defaultGraphParams = state.defaultGraphParams || originalDefaultGraphParams;\n\n  //state.graphs = [ [id, target, params, url], ... ]\n  //Fix url param to be correct for this document.body.dataset.baseUrl\n  var graphs = [];\n  for (var i = 0; i < state.graphs.length; i++) {\n    var myParams = {};\n    var renderType = state.graphs[i][3];\n    Ext.apply(myParams, state.graphs[i][1]);\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    Ext.apply(urlParams, GraphSize);\n    Ext.apply(urlParams, myParams);\n    graphs.push([\n      state.graphs[i][0],\n      myParams,\n      document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams),\n      renderType\n    ]);\n  }\n  graphStore.loadData(graphs);\n\n  refreshGraphs();\n}\n\nfunction deleteDashboard(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/delete/' + name,\n    success: function (response) {\n      var result = Ext.decode(response.responseText);\n      if (result.error) {\n        Ext.Msg.alert('Error', htmlEncode('Failed to delete dashboard \\'' + name + '\\': ' + result.error));\n      } else {\n        Ext.Msg.alert('Dashboard Deleted', htmlEncode('The ' + name + ' dashboard was deleted successfully.'));\n      }\n    },\n    failure: failedAjaxCall\n  });\n}\n\nfunction deleteTemplate(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/delete_template/' + name,\n    success: function (response) {\n      var result = Ext.decode(response.responseText);\n      if (result.error) {\n        Ext.Msg.alert('Error', htmlEncode('Failed to delete template \\'' + name + '\\': ' + result.error));\n      } else {\n        Ext.Msg.alert('Template Deleted', htmlEncode('The ' + name + ' template was deleted successfully.'));\n      }\n    },\n    failure: failedAjaxCall\n  });\n}\n\nfunction setDashboardName(name) {\n  dashboardName = name;\n  var saveButton = Ext.getCmp('dashboard-save-button');\n\n  if (name == null || !hasPermission('change')) {\n    dashboardURL = null;\n    document.title = 'untitled - Graphite Dashboard';\n    navBar.setTitle('untitled');\n    saveButton.setText('Save');\n    saveButton.disable();\n  } else {\n    var urlparts = location.href.split('#')[0].split('/');\n    var i = urlparts.indexOf('dashboard');\n    if (i == -1) {\n      Ext.Msg.alert('Error', htmlEncode('urlparts = ' + Ext.encode(urlparts) + ' and indexOf(dashboard) = ' + i));\n      return;\n    }\n    urlparts = urlparts.slice(0, i+1);\n    urlparts.push( encodeURI(name) )\n    dashboardURL = urlparts.join('/');\n\n    document.title = name + ' - Graphite Dashboard';\n    changeHash(name);\n    navBar.setTitle(htmlEncode(name + ' - (' + dashboardURL + ')'));\n    saveButton.setText(htmlEncode('Save \"' + name + '\"'));\n    saveButton.enable();\n  }\n}\n\nfunction failedAjaxCall(response, options) {\n  Ext.Msg.alert(\n    'Ajax Error',\n    htmlEncode('Ajax call failed, response was :' + response.responseText)\n  );\n}\n\nvar configureUIWin;\nfunction configureUI() {\n\n  if (configureUIWin) {\n    configureUIWin.close();\n  }\n\n  function updateOrientation() {\n    if (Ext.getCmp('navbar-left-radio').getValue()) {\n      updateNavBar('west');\n    } else {\n      updateNavBar('north');\n    }\n    configureUIWin.close();\n    configureUIWin = null;\n  }\n\n  configureUIWin = new Ext.Window({\n    title: 'Configure UI',\n    layout: 'form',\n    width: 300,\n    height: 125,\n    labelWidth: 120,\n    labelAlign: 'right',\n    items: [\n      {\n        id: 'navbar-left-radio',\n        xtype: 'radio',\n        fieldLabel: 'Navigation Mode',\n        boxLabel: 'Tree (left nav)',\n        name: 'navbar-position',\n        inputValue: 'left',\n        checked: (NAV_BAR_REGION == 'west')\n      }, {\n        id: 'navbar-top-radio',\n        xtype: 'radio',\n        fieldLabel: '',\n        boxLabel: 'Completer (top nav)',\n        name: 'navbar-position',\n        inputValue: 'top',\n        checked: (NAV_BAR_REGION == 'north')\n      }\n    ],\n    buttons: [\n      {text: 'Ok', handler: updateOrientation},\n      {text: 'Cancel', handler: function () { configureUIWin.close(); configureUIWin = null; } }\n    ]\n  });\n  configureUIWin.show();\n}\n\nfunction updateNavBar(region) {\n  if (region == NAV_BAR_REGION) {\n    return;\n  }\n\n  cookieProvider.set('navbar-region', region);\n  NAV_BAR_REGION = region;\n\n  if (graphStore.getCount() == 0) {\n    window.location.reload()\n  } else {\n    Ext.Msg.alert('Cookie Updated', 'You must refresh the page to update the nav bar\\'s location.');\n    //TODO prompt the user to save their dashboard and refresh for them\n  }\n}\n\n// Dashboard Finder\nfunction showDashboardFinder() {\n  var win;\n  var dashboardsList;\n  var queryField;\n  var dashboardsStore = new Ext.data.JsonStore({\n    url: document.body.dataset.baseUrl + 'dashboard/find/',\n    method: 'GET',\n    params: {query: 'e'},\n    fields: [{\n      name: 'name',\n      sortType: function(value) {\n        // Make sorting case-insensitive\n        return value.toLowerCase();\n      }\n    }],\n    root: 'dashboards',\n    sortInfo: {\n      field: 'name',\n      direction: 'ASC'\n    },\n    listeners: {\n      beforeload: function (store) {\n                    store.setBaseParam('query', queryField.getValue());\n      }\n    }\n  });\n\n  function openSelected() {\n    var selected = dashboardsList.getSelectedRecords();\n    if (selected.length > 0) {\n      sendLoadRequest(selected[0].data.name);\n    }\n    win.close();\n  }\n\n  function deleteSelected() {\n    var selected = dashboardsList.getSelectedRecords();\n    if (selected.length > 0) {\n      var record = selected[0];\n      var name = record.data.name;\n\n      Ext.Msg.confirm(\n       'Delete Dashboard',\n        htmlEncode('Are you sure you want to delete the ' + name + ' dashboard?'),\n        function (button) {\n          if (button == 'yes') {\n            deleteDashboard(name);\n            dashboardsStore.remove(record);\n            dashboardsList.refresh();\n          }\n        }\n      );\n    }\n  }\n\n  dashboardsList = new Ext.list.ListView({\n    columns: [\n      {header: 'Dashboard', width: 1.0, dataIndex: 'name', sortable: false, tpl:'{name:htmlEncode}'}\n    ],\n    columnSort: false,\n    emptyText: 'No dashboards found',\n    hideHeaders: true,\n    listeners: {\n      selectionchange: function (listView, selections) {\n                         if (listView.getSelectedRecords().length == 0) {\n                           Ext.getCmp('finder-open-button').disable();\n                           Ext.getCmp('finder-delete-button').disable();\n                         } else {\n                           Ext.getCmp('finder-open-button').enable();\n                           if (hasPermission('delete')) {\n                             Ext.getCmp('finder-delete-button').enable();\n                           } else {\n                             Ext.getCmp('finder-delete-button').disable();\n                           }\n                         }\n                       },\n\n      dblclick: function (listView, index, node, e) {\n                  var record = dashboardsStore.getAt(index);\n                  sendLoadRequest(record.data.name);\n                  win.close();\n                }\n    },\n    overClass: '',\n    region: 'center',\n    reserveScrollOffset: true,\n    singleSelect: true,\n    store: dashboardsStore,\n    style: 'background-color: white;'\n  });\n\n  var lastQuery = null;\n  var queryUpdateTask = new Ext.util.DelayedTask(\n    function () {\n      var currentQuery = queryField.getValue();\n      if (lastQuery != currentQuery) {\n        dashboardsStore.load();\n      }\n      lastQuery = currentQuery;\n    }\n  );\n\n  queryField = new Ext.form.TextField({\n    region: 'south',\n    emptyText: 'filter dashboard listing',\n    enableKeyEvents: true,\n    listeners: {\n      keyup: function (field, e) {\n                  if (e.getKey() == e.ENTER) {\n                    sendLoadRequest(field.getValue());\n                    win.close();\n                  } else {\n                    queryUpdateTask.delay(FINDER_QUERY_DELAY);\n                  }\n                }\n    }\n  });\n\n  win = new Ext.Window({\n    title: 'Dashboard Finder',\n    width: 400,\n    height: 500,\n    layout: 'border',\n    modal: true,\n    items: [\n      dashboardsList,\n      queryField\n    ],\n    buttons: [\n      {\n        id: 'finder-open-button',\n        text: 'Open',\n        disabled: true,\n        handler: openSelected\n      }, {\n        id: 'finder-delete-button',\n        text: 'Delete',\n        disabled: true,\n        handler: deleteSelected\n      }, {\n        text: 'Close',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  dashboardsStore.load();\n  win.show();\n}\n\n// Template Finder\nfunction showTemplateFinder() {\n  var win;\n  var templatesList;\n  var queryField;\n  var valueField;\n  var templatesStore = new Ext.data.JsonStore({\n    url: document.body.dataset.baseUrl + 'dashboard/find_template/',\n    method: 'GET',\n    params: {query: 'e'},\n    fields: ['name'],\n    root: 'templates',\n    listeners: {\n      beforeload: function (store) {\n                    store.setBaseParam('query', queryField.getValue());\n                  }\n    }\n  });\n\n  function openSelected() {\n    var selected = templatesList.getSelectedRecords();\n    if (selected.length > 0) {\n      sendLoadTemplateRequest(selected[0].data.name, valueField.getValue());\n    }\n    win.close();\n  }\n\n  function deleteSelected() {\n    var selected = templatesList.getSelectedRecords();\n    if (selected.length > 0) {\n      var record = selected[0];\n      var name = record.data.name;\n\n      Ext.Msg.confirm(\n        'Delete Template',\n        htmlEncode('Are you sure you want to delete the ' + name + ' template?'),\n        function (button) {\n          if (button == 'yes') {\n            deleteTemplate(name);\n            templatesStore.remove(record);\n            templatesList.refresh();\n          }\n        }\n      );\n    }\n  }\n\n  templatesList = new Ext.list.ListView({\n    columns: [\n      {header: 'Template', width: 1.0, dataIndex: 'name', sortable: false}\n    ],\n    columnSort: false,\n    emptyText: 'No templates found',\n    hideHeaders: true,\n    listeners: {\n      selectionchange: function (listView, selections) {\n                         if (listView.getSelectedRecords().length == 0) {\n                           Ext.getCmp('finder-open-button').disable();\n                           Ext.getCmp('finder-delete-button').disable();\n                         } else {\n                           if (valueField.getValue()) {\n                             Ext.getCmp('finder-open-button').enable();\n                           }\n                           Ext.getCmp('finder-delete-button').enable();\n                         }\n                       },\n\n    },\n    overClass: '',\n    region: 'center',\n    reserveScrollOffset: true,\n    singleSelect: true,\n    store: templatesStore,\n    style: 'background-color: white;'\n  });\n\n  var lastQuery = null;\n  var queryUpdateTask = new Ext.util.DelayedTask(\n    function () {\n      var currentQuery = queryField.getValue();\n      if (lastQuery != currentQuery) {\n        templatesStore.load();\n      }\n      lastQuery = currentQuery;\n    }\n  );\n\n  queryField = new Ext.form.TextField({\n    region: 'south',\n    emptyText: 'filter template listing',\n    enableKeyEvents: true,\n    listeners: {\n      keyup: function (field, e) {\n                  if (e.getKey() == e.ENTER) {\n                    sendLoadRequest(field.getValue(), reset_params=true);\n                    win.close();\n                  } else {\n                    queryUpdateTask.delay(FINDER_QUERY_DELAY);\n                  }\n                }\n    }\n  });\n\n  valueField = new Ext.form.TextField({\n    region: 'north',\n    emptyText: 'Value to use'\n  });\n\n  win = new Ext.Window({\n    title: 'Template Finder',\n    width: 400,\n    height: 500,\n    layout: 'border',\n    modal: true,\n    items: [\n      valueField,\n      templatesList,\n      queryField,\n    ],\n    buttons: [\n      {\n        id: 'finder-open-button',\n        text: 'Open',\n        disabled: true,\n        handler: openSelected\n      }, {\n        id: 'finder-delete-button',\n        text: 'Delete',\n        disabled: true,\n        handler: deleteSelected\n      }, {\n        text: 'Close',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  templatesStore.load();\n  win.show();\n}\n\n/* Graph Options API (to reuse createOptionsMenu from composer_widgets.js) */\nfunction updateGraph() {\n  refreshGraphs();\n  var graphMenuParams = Ext.getCmp('graphMenuParams');\n  if (graphMenuParams) {\n    var editParams = Ext.apply({}, selectedRecord.data.params);\n    removeUneditable(editParams);\n    graphMenuParams.setValue( Ext.urlEncode(editParams) );\n  }\n}\n\nfunction getParam(param) {\n  return selectedRecord.data.params[param];\n}\n\nfunction setParam(param, value) {\n  selectedRecord.data.params[param] = value;\n  selectedRecord.commit();\n}\n\nfunction removeParam(param) {\n  delete selectedRecord.data.params[param];\n  selectedRecord.commit();\n}\n\n\nfunction removeTargetFromSelectedGraph(target) {\n  selectedRecord.data.params.target.remove(target);\n  selectedRecord.data.target = Ext.urlEncode({target: selectedRecord.data.params.target});\n}\n\nfunction getSelectedTargets() {\n  if (targetGrid) {\n    return map(targetGrid.getSelectionModel().getSelections(), function (r) {\n      return r.data.target;\n    });\n  }\n  return [];\n}\n\nfunction applyFuncToEach(funcName, extraArg) {\n\n  function applyFunc() {\n    Ext.each(targetGrid.getSelectionModel().getSelections(),\n      function (record) {\n        var target = record.data.target;\n        var newTarget;\n        var targetStore = targetGrid.getStore();\n\n        targetStore.remove(record);\n        removeTargetFromSelectedGraph(target);\n\n        if (extraArg) {\n          newTarget = funcName + '(' + target + ',' + extraArg + ')';\n        } else {\n          newTarget = funcName + '(' + target + ')';\n        }\n\n        // Add newTarget to selectedRecord\n        targetStore.add([ new targetStore.recordType({target: newTarget}, newTarget) ]);\n        targetGrid.getSelectionModel().selectRow(targetStore.findExact('target', newTarget), true);\n      }\n    );\n    refreshGraphs();\n  }\n  return applyFunc;\n}\n\nfunction applyFuncToEachWithInput (funcName, question, options) {\n  if (options == null) {\n    options = {};\n  }\n\n function applyFunc() {\n    Ext.MessageBox.prompt(\n      'Input Required', //title\n      question, //message\n      function (button, inputValue) { //handler\n        if (button == 'ok' && (options.allowBlank || inputValue != '')) {\n          if (options.quote) {\n            inputValue = '\"' + inputValue + '\"';\n          }\n          applyFuncToEach(funcName, inputValue)();\n        }\n      },\n      this, //scope\n      false, //multiline\n      '' //initial value\n    );\n  }\n  applyFunc = applyFunc.createDelegate(this);\n  return applyFunc;\n}\n\nfunction applyFuncToAll (funcName) {\n  function applyFunc() {\n    var args = getSelectedTargets().join(',');\n    var newTarget = funcName + '(' + args + ')';\n    var targetStore = targetGrid.getStore();\n\n    Ext.each(targetGrid.getSelectionModel().getSelections(),\n      function (record) {\n        targetStore.remove(record);\n        removeTargetFromSelectedGraph(record.data.target);\n      }\n    );\n    targetStore.add([ new targetStore.recordType({target: newTarget}, newTarget) ]);\n    targetGrid.getSelectionModel().selectRow(targetStore.findExact('target', newTarget), true);\n    refreshGraphs();\n  }\n  applyFunc = applyFunc.createDelegate(this);\n  return applyFunc;\n}\n\nfunction removeOuterCall() { // blatantly repurposed from composer_widgets.js (don't hate)\n  Ext.each(targetGrid.getSelectionModel().getSelections(), function (record) {\n    var target = record.data.target;\n    var targetStore = targetGrid.getStore();\n    var args = [];\n    var i, c;\n    var lastArg = 0;\n    var depth = 0;\n    var argString = target.replace(/^[^(]+\\((.+)\\)/, '$1'); //First we strip it down to just args\n\n    for (i = 0; i < argString.length; i++) {\n      switch (argString.charAt(i)) {\n        case '(': depth += 1; break;\n        case '{': depth += 1; break;\n        case ')': depth -= 1; break;\n        case '}': depth -= 1; break;\n        case ',':\n          if (depth > 0) { continue; }\n          if (depth < 0) { Ext.Msg.alert('Malformed target, cannot remove outer call.'); return; }\n          args.push( argString.substring(lastArg, i).replace(/^\\s+/, '').replace(/\\s+$/, '') );\n          lastArg = i + 1;\n          break;\n      }\n    }\n    args.push( argString.substring(lastArg, i) );\n\n    targetStore.remove(record);\n    selectedRecord.data.params.target.remove(target);\n\n    Ext.each(args, function (arg) {\n      if (!arg.match(/^([0123456789\\.]+|\".+\")$/)) { //Skip string and number literals\n        targetStore.add([ new targetStore.recordType({target: arg}) ]);\n        targetGrid.getSelectionModel().selectRow(targetStore.findExact('target', arg), true);\n      }\n    });\n  });\n  refreshGraphs();\n}\n\nfunction saveDefaultGraphParams() {\n  cookieProvider.set('defaultGraphParams', Ext.encode(defaultGraphParams));\n}\n\n\n/* Cookie stuff */\nfunction getContextFieldCookie(field) {\n  return cookieProvider.get(field);\n}\n\nfunction setContextFieldCookie(field, value) {\n  cookieProvider.set(field, value);\n}\n\n/* Misc */\nfunction uniq(myArray) {\n  var uniqArray = [];\n  for (var i=0; i<myArray.length; i++) {\n    if (uniqArray.indexOf(myArray[i]) == -1) {\n      uniqArray.push(myArray[i]);\n    }\n  }\n  return uniqArray;\n}\n\nfunction map(myArray, myFunc) {\n  var results = [];\n  for (var i=0; i<myArray.length; i++) {\n    results.push( myFunc(myArray[i]) );\n  }\n  return results;\n}\n\nfunction getLoginMenuItemText() {\n  if (isLoggedIn()) {\n    return 'Log Out From \"' + userName + '\"';\n  } else {\n    return 'Log In';\n  }\n}\n\n/* After login/logout, make any necessary adjustments to Dashboard menu items (text and/or disabled) */\nfunction postLoginMenuAdjust() {\n  Ext.getCmp('dashboard-login-button').setText(getLoginMenuItemText());\n  Ext.getCmp('dashboard-save-button').setDisabled(dashboardName == null || !hasPermission('change'));\n  Ext.getCmp('dashboard-save-as-button').setDisabled(!hasPermission('change'));\n}\n\nfunction showLoginForm() {\n  var login = new Ext.FormPanel({\n    labelWidth: 80,\n    frame: true,\n    title: 'Please Login',\n    defaultType: 'textfield',\n    monitorValid: true,\n\n    items: [{\n        fieldLabel: 'Username',\n        name: 'username',\n        allowBlank: false,\n        listeners: {\n          afterrender: function(field) { field.focus(false, 100); }\n        }\n      },{\n        fieldLabel: 'Password',\n        name: 'password',\n        inputType: 'password',\n        allowBlank: false\n      }\n    ],\n    buttons: [\n      {text: 'Login', formBind: true, handler: doLogin},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n\n  function doLogin() {\n    login.getForm().submit({\n      method: 'POST',\n      url: document.body.dataset.baseUrl + 'dashboard/login',\n      waitMsg: 'Authenticating...',\n      success: function(form, action) {\n        userName = form.findField('username').getValue();\n        permissions = action.result.permissions;\n        postLoginMenuAdjust();\n        win.close();\n      },\n      failure: function(form, action) {\n        if (action.failureType == 'server') {\n          var obj = Ext.util.JSON.decode(action.response.responseText);\n          Ext.Msg.alert('Login Failed!', htmlEncode(obj.errors.reason));\n        } else {\n          Ext.Msg.alert('Warning!', htmlEncode('Authentication server is unreachable : ' + action.response.responseText));\n        }\n        login.getForm().reset();\n      }\n    });\n  }\n\n  var win = new Ext.Window({\n    layout: 'fit',\n    width: 300,\n    height: 150,\n    closable: false,\n    resizable: false,\n    plain: true,\n    border: false,\n    items: [login]\n  });\n  win.show();\n}\n\nfunction logout() {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/logout',\n    method: 'POST',\n    success: function() {\n      userName = null;\n      permissions = permissionsUnauthenticated;\n      postLoginMenuAdjust();\n    },\n    failure: function() {\n      // Probably because they no longer have a valid session - assume they're now logged out\n      userName = null;\n      permissions = permissionsUnauthenticated;\n      postLoginMenuAdjust();\n    }\n  });\n}\n", "import re\nimport errno\n\nfrom os.path import getmtime\nfrom six.moves.urllib.parse import urlencode\nfrom six.moves.configparser import ConfigParser\nfrom django.shortcuts import render\nfrom django.http import QueryDict\nfrom django.conf import settings\nfrom django.contrib.auth import login, authenticate, logout\nfrom django.contrib.staticfiles import finders\nfrom django.utils.safestring import mark_safe\nfrom graphite.compat import HttpResponse\nfrom graphite.dashboard.models import Dashboard, Template\nfrom graphite.dashboard.send_graph import send_graph_email\nfrom graphite.render.views import renderView\nfrom graphite.util import json\nfrom graphite.user_util import isAuthenticated\n\nfieldRegex = re.compile(r'<([^>]+)>')\ndefaultScheme = {\n  'name' : 'Everything',\n  'pattern' : '<category>',\n  'fields' : [ dict(name='category', label='Category') ],\n}\ndefaultUIConfig = {\n  'default_graph_width'  : 400,\n  'default_graph_height' : 250,\n  'refresh_interval'     :  60,\n  'autocomplete_delay'   : 375,\n  'merge_hover_delay'    : 700,\n  'theme'                : 'default',\n}\ndefaultKeyboardShortcuts = {\n  'toggle_toolbar' : 'ctrl-z',\n  'toggle_metrics_panel' : 'ctrl-space',\n  'erase_all_graphs' : 'alt-x',\n  'save_dashboard' : 'alt-s',\n  'completer_add_metrics' : 'alt-enter',\n  'completer_del_metrics' : 'alt-backspace',\n  'give_completer_focus' : 'shift-space',\n}\n\nALL_PERMISSIONS = ['change', 'delete']\n\n\nclass DashboardConfig:\n  def __init__(self):\n    self.last_read = 0\n    self.schemes = [defaultScheme]\n    self.ui_config = defaultUIConfig.copy()\n\n  def check(self):\n    if getmtime(settings.DASHBOARD_CONF) > self.last_read:\n      self.load()\n\n  def load(self):\n    schemes = [defaultScheme]\n    parser = ConfigParser()\n    parser.read(settings.DASHBOARD_CONF)\n\n    for option, default_value in defaultUIConfig.items():\n      if parser.has_option('ui', option):\n        try:\n          self.ui_config[option] = parser.getint('ui', option)\n        except ValueError:\n          self.ui_config[option] = parser.get('ui', option)\n      else:\n        self.ui_config[option] = default_value\n\n    if parser.has_option('ui', 'automatic_variants'):\n      self.ui_config['automatic_variants']   = parser.getboolean('ui', 'automatic_variants')\n    else:\n      self.ui_config['automatic_variants'] = True\n\n    self.ui_config['keyboard_shortcuts'] = defaultKeyboardShortcuts.copy()\n    if parser.has_section('keyboard-shortcuts'):\n      self.ui_config['keyboard_shortcuts'].update( parser.items('keyboard-shortcuts') )\n\n    for section in parser.sections():\n      if section in ('ui', 'keyboard-shortcuts'):\n        continue\n\n      scheme = parser.get(section, 'scheme')\n      fields = []\n\n      for match in fieldRegex.finditer(scheme):\n        field = match.group(1)\n        if parser.has_option(section, '%s.label' % field):\n          label = parser.get(section, '%s.label' % field)\n        else:\n          label = field\n\n        fields.append({\n          'name' : field,\n          'label' : label\n        })\n\n      schemes.append({\n        'name' : section,\n        'pattern' : scheme,\n        'fields' : fields,\n      })\n\n    self.schemes = schemes\n\n\nconfig = DashboardConfig()\n\n\ndef dashboard(request, name=None):\n  dashboard_conf_missing = False\n\n  try:\n    config.check()\n  except OSError as e:\n    if e.errno == errno.ENOENT:\n      dashboard_conf_missing = True\n    else:\n      raise\n\n  initialError = None\n  debug = request.GET.get('debug', False)\n  theme = request.GET.get('theme', config.ui_config['theme'])\n  css_file = finders.find('css/dashboard-%s.css' % theme)\n  if css_file is None:\n    initialError = \"Invalid theme '%s'\" % theme\n    theme = config.ui_config['theme']\n\n  context = {\n    'schemes_json': mark_safe(json.dumps(config.schemes)),\n    'ui_config_json': mark_safe(json.dumps(config.ui_config)),\n    'jsdebug': debug or settings.JAVASCRIPT_DEBUG,\n    'debug': debug,\n    'theme': theme,\n    'initialError': initialError,\n    'querystring': mark_safe(json.dumps(dict(request.GET.items()))),\n    'dashboard_conf_missing': dashboard_conf_missing,\n    'userName': '',\n    'permissions': mark_safe(json.dumps(getPermissions(request.user))),\n    'permissionsUnauthenticated': mark_safe(json.dumps(getPermissions(None)))\n  }\n  user = request.user\n  if user:\n      context['userName'] = user.username\n\n  if name is not None:\n    try:\n      dashboard = Dashboard.objects.get(name=name)\n    except Dashboard.DoesNotExist:\n      context['initialError'] = \"Dashboard '%s' does not exist.\" % name\n    else:\n      context['initialState'] = dashboard.state\n\n  return render(request, \"dashboard.html\", context)\n\n\ndef template(request, name, val):\n  template_conf_missing = False\n\n  try:\n    config.check()\n  except OSError as e:\n    if e.errno == errno.ENOENT:\n      template_conf_missing = True\n    else:\n      raise\n\n  initialError = None\n  debug = request.GET.get('debug', False)\n  theme = request.GET.get('theme', config.ui_config['theme'])\n  css_file = finders.find('css/dashboard-%s.css' % theme)\n  if css_file is None:\n    initialError = \"Invalid theme '%s'\" % theme\n    theme = config.ui_config['theme']\n\n  context = {\n    'schemes_json' : json.dumps(config.schemes),\n    'ui_config_json' : json.dumps(config.ui_config),\n    'jsdebug' : debug or settings.JAVASCRIPT_DEBUG,\n    'debug' : debug,\n    'theme' : theme,\n    'initialError' : initialError,\n    'querystring' : json.dumps( dict( request.GET.items() ) ),\n    'template_conf_missing' : template_conf_missing,\n    'userName': '',\n    'permissions': json.dumps(getPermissions(request.user)),\n    'permissionsUnauthenticated': json.dumps(getPermissions(None))\n  }\n\n  user = request.user\n  if user:\n      context['userName'] = user.username\n\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    context['initialError'] = \"Template '%s' does not exist.\" % name\n  else:\n    state = json.loads(template.loadState(val))\n    state['name'] = '%s/%s' % (name, val)\n    context['initialState'] = json.dumps(state)\n  return render(request, \"dashboard.html\", context)\n\n\ndef getPermissions(user):\n  \"\"\"Return [change, delete] based on authorisation model and user privileges/groups\"\"\"\n  if user and not isAuthenticated(user):\n    user = None\n  if not settings.DASHBOARD_REQUIRE_AUTHENTICATION:\n    return ALL_PERMISSIONS      # don't require login\n  if not user:\n      return []\n  # from here on, we have a user\n  permissions = ALL_PERMISSIONS\n  if settings.DASHBOARD_REQUIRE_PERMISSIONS:\n    permissions = [permission for permission in ALL_PERMISSIONS if user.has_perm('dashboard.%s_dashboard' % permission)]\n  editGroup = settings.DASHBOARD_REQUIRE_EDIT_GROUP\n  if editGroup and len(user.groups.filter(name = editGroup)) == 0:\n    permissions = []\n  return permissions\n\n\ndef save(request, name):\n  if 'change' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to save\") )\n  # Deserialize and reserialize as a validation step\n  state = str( json.dumps( json.loads( request.POST['state'] ) ) )\n\n  try:\n    dashboard = Dashboard.objects.get(name=name)\n  except Dashboard.DoesNotExist:\n    dashboard = Dashboard.objects.create(name=name, state=state)\n  else:\n    dashboard.state = state\n    dashboard.save()\n\n  return json_response( dict(success=True) )\n\n\ndef save_template(request, name, key):\n  if 'change' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to save the template\") )\n  # Deserialize and reserialize as a validation step\n  state = str( json.dumps( json.loads( request.POST['state'] ) ) )\n\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    template = Template.objects.create(name=name)\n    template.setState(state, key)\n    template.save()\n  else:\n    template.setState(state, key)\n    template.save()\n\n  return json_response( dict(success=True) )\n\n\ndef load(request, name):\n  try:\n    dashboard = Dashboard.objects.get(name=name)\n  except Dashboard.DoesNotExist:\n    return json_response( dict(error=\"Dashboard '%s' does not exist. \" % name) )\n\n  return json_response( dict(state=json.loads(dashboard.state)) )\n\n\ndef load_template(request, name, val):\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    return json_response( dict(error=\"Template '%s' does not exist. \" % name) )\n\n  state = json.loads(template.loadState(val))\n  state['name'] = '%s/%s' % (name, val)\n  return json_response( dict(state=state) )\n\n\ndef delete(request, name):\n  if 'delete' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to delete\") )\n\n  try:\n    dashboard = Dashboard.objects.get(name=name)\n  except Dashboard.DoesNotExist:\n    return json_response( dict(error=\"Dashboard '%s' does not exist. \" % name) )\n  else:\n    dashboard.delete()\n    return json_response( dict(success=True) )\n\n\ndef delete_template(request, name):\n  if 'delete' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to delete the template\") )\n\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    return json_response( dict(error=\"Template '%s' does not exist. \" % name) )\n  else:\n    template.delete()\n    return json_response( dict(success=True) )\n\n\ndef find(request):\n  queryParams = request.GET.copy()\n  queryParams.update(request.POST)\n\n  query = queryParams.get('query', False)\n  query_terms = set( query.lower().split() )\n  results = []\n\n  # Find all dashboard names that contain each of our query terms as a substring\n  for dashboard_name in Dashboard.objects.order_by('name').values_list('name', flat=True):\n    name = dashboard_name.lower()\n\n    if name.startswith('temporary-'):\n      continue\n\n    found = True # blank queries return everything\n    for term in query_terms:\n      if term in name:\n        found = True\n      else:\n        found = False\n        break\n\n    if found:\n      results.append( dict(name=dashboard_name) )\n\n  return json_response( dict(dashboards=results) )\n\n\ndef find_template(request):\n  queryParams = request.GET.copy()\n  queryParams.update(request.POST)\n\n  query = queryParams.get('query', False)\n  query_terms = set( query.lower().split() )\n  results = []\n\n  # Find all dashboard names that contain each of our query terms as a substring\n  for template in Template.objects.all():\n    name = template.name.lower()\n\n    found = True # blank queries return everything\n    for term in query_terms:\n      if term in name:\n        found = True\n      else:\n        found = False\n        break\n\n    if found:\n      results.append( dict(name=template.name) )\n\n  return json_response( dict(templates=results) )\n\n\ndef help(request):\n  context = {}\n  return render(request, \"dashboardHelp.html\", context)\n\n\ndef email(request):\n    sender = request.POST['sender']\n    recipients = request.POST['recipients'].split()\n    subject = request.POST['subject']\n    message = request.POST['message']\n\n    # these need to be passed to the render function in an HTTP request.\n    graph_params = json.loads(request.POST['graph_params'], parse_int=str)\n    target = QueryDict(urlencode({'target': graph_params.pop('target')}))\n    graph_params = QueryDict(urlencode(graph_params))\n\n    new_post = request.POST.copy()\n    new_post.update(graph_params)\n    new_post.update(target)\n    request.POST = new_post\n\n    resp = renderView(request)\n    img = resp.content\n\n    if img:\n        attachments = [('graph.png', img, 'image/png')]\n        send_graph_email(subject, sender, recipients, attachments, message)\n\n    return json_response(dict(success=True))\n\n\ndef create_temporary(request):\n  state = str( json.dumps( json.loads( request.POST['state'] ) ) )\n  i = 0\n  while True:\n    name = \"temporary-%d\" % i\n    try:\n      Dashboard.objects.get(name=name)\n    except Dashboard.DoesNotExist:\n      dashboard = Dashboard.objects.create(name=name, state=state)\n      break\n    else:\n      i += 1\n\n  return json_response( dict(name=dashboard.name) )\n\n\ndef json_response(obj):\n  return HttpResponse(content_type='application/json', content=json.dumps(obj))\n\n\ndef user_login(request):\n  response = dict(errors={}, text={}, success=False, permissions=[])\n  user = authenticate(username=request.POST['username'],\n                      password=request.POST['password'])\n  if user is not None:\n    if user.is_active:\n      login(request, user)\n      response['success'] = True\n      response['permissions'].extend(getPermissions(user))\n    else:\n      response['errors']['reason'] = 'Account disabled.'\n  else:\n    response['errors']['reason'] = 'Username and/or password invalid.'\n  return json_response(response)\n\n\ndef user_logout(request):\n  response = dict(errors={}, text={}, success=True)\n  logout(request)\n  return json_response(response)\n", "from django.http import HttpResponseBadRequest\nfrom graphite.logger import log\n\n\nclass NormalizeEmptyResultError(Exception):\n    # throw error for normalize() when empty\n    pass\n\n\nclass InputParameterError(ValueError):\n\n    def __init__(self, *args, **kwargs):\n        super(InputParameterError, self).__init__(*args, **kwargs)\n        self.context = {}\n\n    def setSourceIdHeaders(self, newHeaders):\n        headers = self.context.get('sourceIdHeaders', {})\n        headers.update(newHeaders)\n        self.context['sourceIdHeaders'] = headers\n\n    @property\n    def sourceIdHeaders(self):\n        sourceIdHeaders = self.context.get('sourceIdHeaders', {})\n        headers = list(sourceIdHeaders.keys())\n        headers.sort()\n        source = ''\n\n        for name in headers:\n            if source:\n                source += ', '\n            source += '{name}: {value}'.format(\n                name=name,\n                value=sourceIdHeaders[name])\n\n        return source\n\n    def setTargets(self, targets):\n        self.context['targets'] = targets\n\n    @property\n    def targets(self):\n        return ', '.join(self.context.get('targets', []))\n\n    def setFunction(self, name, args, kwargs):\n        self.context['function'] = {\n            'name': name,\n            'args': args,\n            'kwargs': kwargs,\n        }\n\n    @property\n    def function(self):\n        func = self.context.get('function', None)\n        if not func:\n            return ''\n\n        funcName = func.get('name', '')\n        if not funcName:\n            return ''\n\n        kwargs = func.get('kwargs', {})\n        kwargKeys = list(kwargs.keys())\n\n        # keep kwargs sorted in message, for consistency and testability\n        kwargKeys.sort()\n\n        # generate string of args and kwargs\n        args = ', '.join(\n            argList\n            for argList in [\n                ', '.join(repr(arg) for arg in func.get('args', [])),\n                ', '.join('{k}={v}'.format(k=str(k), v=repr(kwargs[k])) for k in kwargKeys),\n            ] if argList\n        )\n\n        return '{func}({args})'.format(func=funcName, args=args)\n\n    def __str__(self):\n        msg = 'Invalid parameters ({msg})'.format(msg=str(super(InputParameterError, self).__str__()))\n        targets = self.targets\n        if targets:\n            msg += '; targets: \"{targets}\"'.format(targets=targets)\n\n        source = self.sourceIdHeaders\n        if source:\n            msg += '; source: \"{source}\"'.format(source=source)\n\n        # needs to be last because the string \"args\" may potentially be thousands\n        # of chars long after expanding the globbing patterns\n        func = self.function\n        if func:\n            msg += '; func: \"{func}\"'.format(func=func)\n\n        return msg\n\n\n# Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\ndef escape(s):\n    s = s.replace(\"&\", \"&amp;\")  # Must be done first!\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n\n    return s\n\n\n# decorator which turns InputParameterExceptions into Django's HttpResponseBadRequest\ndef handleInputParameterError(f):\n    def new_f(*args, **kwargs):\n        try:\n            return f(*args, **kwargs)\n        except InputParameterError as e:\n            msgStr = str(e)\n            log.warning('%s', msgStr)\n            return HttpResponseBadRequest(escape(msgStr))\n\n    return new_f\n", "\"\"\"Copyright 2008 Orbitz WorldWide\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\"\"\"\n\nimport imp\nimport io\nimport json as _json\nimport socket\nimport time\nimport sys\nimport calendar\nimport pytz\nimport six\nimport traceback\n\nfrom datetime import datetime\nfrom functools import wraps\nfrom os.path import splitext, basename\n\nfrom django.conf import settings\nfrom django.utils.timezone import make_aware\n\nfrom graphite.compat import HttpResponse\nfrom graphite.logger import log\n\n# BytesIO is needed on py3 as StringIO does not operate on byte input anymore\n# We could use BytesIO on py2 as well but it is slower than StringIO\nif sys.version_info >= (3, 0):\n  PY3 = True\n  import pickle\n  from io import BytesIO\nelse:\n  PY3 = False\n  import cPickle as pickle\n  from cStringIO import StringIO as BytesIO\n\n# use https://github.com/msgpack/msgpack-python if available\ntry:\n  import msgpack  # NOQA\n# otherwise fall back to bundled https://github.com/vsergeev/u-msgpack-python\nexcept ImportError:\n  import graphite.umsgpack as msgpack  # NOQA\n\n\ndef epoch(dt):\n  \"\"\"\n  Returns the epoch timestamp of a timezone-aware datetime object.\n  \"\"\"\n  if not dt.tzinfo:\n    tb = traceback.extract_stack(None, 2)\n    log.warning('epoch() called with non-timezone-aware datetime in %s at %s:%d' % (tb[0][2], tb[0][0], tb[0][1]))\n    return calendar.timegm(make_aware(dt, pytz.timezone(settings.TIME_ZONE)).astimezone(pytz.utc).timetuple())\n  return calendar.timegm(dt.astimezone(pytz.utc).timetuple())\n\n\ndef epoch_to_dt(timestamp):\n    \"\"\"\n    Returns the timezone-aware datetime of an epoch timestamp.\n    \"\"\"\n    return make_aware(datetime.utcfromtimestamp(timestamp), pytz.utc)\n\n\ndef timebounds(requestContext):\n  startTime = int(epoch(requestContext['startTime']))\n  endTime = int(epoch(requestContext['endTime']))\n  now = int(epoch(requestContext['now']))\n\n  return (startTime, endTime, now)\n\n\ndef is_local_interface(host):\n  is_ipv6 = False\n  if ':' not in host:\n    pass\n  elif host.count(':') == 1:\n    host = host.split(':', 1)[0]\n  else:\n    is_ipv6 = True\n\n    if host.find('[', 0, 2) != -1:\n      last_bracket_position  = host.rfind(']')\n      last_colon_position = host.rfind(':')\n      if last_colon_position > last_bracket_position:\n        host = host.rsplit(':', 1)[0]\n      host = host.strip('[]')\n\n  try:\n    if is_ipv6:\n      sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n    else:\n      sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind( (host, 0) )\n  except socket.error:\n    return False\n  finally:\n    sock.close()\n\n  return True\n\n\ndef is_pattern(s):\n   return '*' in s or '?' in s or '[' in s or '{' in s\n\n\ndef is_escaped_pattern(s):\n  for symbol in '*?[{':\n    i = s.find(symbol)\n    if i > 0:\n      if s[i-1] == '\\\\':\n        return True\n  return False\n\n\ndef find_escaped_pattern_fields(pattern_string):\n  pattern_parts = pattern_string.split('.')\n  for index,part in enumerate(pattern_parts):\n    if is_escaped_pattern(part):\n      yield index\n\n\ndef load_module(module_path, member=None):\n  module_name = splitext(basename(module_path))[0]\n  try:  # 'U' is default from Python 3.0 and deprecated since 3.9\n    module_file = open(module_path, 'U')\n  except ValueError:\n    module_file = open(module_path, 'rt')\n  description = ('.py', 'U', imp.PY_SOURCE)\n  module = imp.load_module(module_name, module_file, module_path, description)\n  if member:\n    return getattr(module, member)\n  else:\n    return module\n\n\ndef timestamp(dt):\n  \"Convert a datetime object into epoch time\"\n  return time.mktime(dt.timetuple())\n\n\ndef deltaseconds(timedelta):\n  \"Convert a timedelta object into seconds (same as timedelta.total_seconds() in Python 2.7+)\"\n  return (timedelta.microseconds + (timedelta.seconds + timedelta.days * 24 * 3600) * 10**6) / 10**6\n\n\n# This whole song & dance is due to pickle being insecure\n# The SafeUnpickler classes were largely derived from\n# http://nadiana.com/python-pickle-insecure\n# This code also lives in carbon.util\nif not PY3:\n  class SafeUnpickler(object):\n    PICKLE_SAFE = {\n      'copy_reg': set(['_reconstructor']),\n      '__builtin__': set(['object', 'list', 'set']),\n      'collections': set(['deque']),\n      'graphite.render.datalib': set(['TimeSeries', 'Tags']),\n      'graphite.intervals': set(['Interval', 'IntervalSet']),\n    }\n\n    @classmethod\n    def find_class(cls, module, name):\n      if module not in cls.PICKLE_SAFE:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe module %s' % module)\n      __import__(module)\n      mod = sys.modules[module]\n      if name not in cls.PICKLE_SAFE[module]:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe class %s' % name)\n      return getattr(mod, name)\n\n    @classmethod\n    def loads(cls, pickle_string):\n      pickle_obj = pickle.Unpickler(BytesIO(pickle_string))\n      pickle_obj.find_global = cls.find_class\n      return pickle_obj.load()\n\n    @classmethod\n    def load(cls, file):\n      pickle_obj = pickle.Unpickler(file)\n      pickle_obj.find_global = cls.find_class\n      return pickle_obj.load()\n\n  unpickle = SafeUnpickler\n\nelse:\n  class SafeUnpickler(pickle.Unpickler):\n    PICKLE_SAFE = {\n      'copy_reg': set(['_reconstructor']),\n      'builtins': set(['object', 'list', 'set']),\n      'collections': set(['deque']),\n      'graphite.render.datalib': set(['TimeSeries', 'Tags']),\n      'graphite.intervals': set(['Interval', 'IntervalSet']),\n    }\n\n    def __init__(self, file):\n        super().__init__(file, encoding='utf8')\n\n    def find_class(self, module, name):\n      if module not in self.PICKLE_SAFE:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe module %s' % module)\n      __import__(module)\n      mod = sys.modules[module]\n      if name not in self.PICKLE_SAFE[module]:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe class %s' % name)\n      return getattr(mod, name)\n\n  class unpickle(object):\n    @staticmethod\n    def loads(pickle_string):\n      return SafeUnpickler(BytesIO(pickle_string)).load()\n\n    @staticmethod\n    def load(file):\n      return SafeUnpickler(file).load()\n\n\nclass json(object):\n  JSONEncoder = _json.JSONEncoder\n  JSONDecoder = _json.JSONDecoder\n\n  @staticmethod\n  def dump(*args, **kwargs):\n    return _json.dump(*args, **kwargs)\n\n  @staticmethod\n  def dumps(*args, **kwargs):\n    return _json.dumps(*args, **kwargs)\n\n  @staticmethod\n  def load(fp, *args, **kwargs):\n    return _json.load(fp, *args, **kwargs)\n\n  @staticmethod\n  def loads(s, *args, **kwargs):\n    if isinstance(s, six.binary_type):\n      return _json.loads(s.decode('utf-8'), *args, **kwargs)\n    return _json.loads(s, *args, **kwargs)\n\n\nclass Timer(object):\n  __slots__ = ('msg', 'name', 'start_time')\n\n  def __init__(self, name):\n    self.name = name\n    self.msg = 'completed in'\n    self.start_time = time.time()\n\n  def set_msg(self, msg):\n    self.msg = msg\n\n  def set_name(self, name):\n    self.name = name\n\n  def stop(self):\n    log.info(\n      '{name} :: {msg} {sec:.6}s'.format(\n        name=self.name,\n        msg=self.msg,\n        sec=time.time() - self.start_time,\n      )\n    )\n\n\ndef logtime(f):\n  @wraps(f)\n  def wrapped_f(*args, **kwargs):\n    timer = Timer(f.__module__ + '.' + f.__name__)\n    kwargs['timer'] = timer\n\n    try:\n      return f(*args, **kwargs)\n    except Exception:\n      timer.msg = 'failed in'\n      raise\n    finally:\n      timer.stop()\n\n  return wrapped_f\n\n\nclass BufferedHTTPReader(io.FileIO):\n  def __init__(self, response, buffer_size=1048576):\n    self.response = response\n    self.buffer_size = buffer_size\n    self.buffer = b''\n    self.pos = 0\n\n  def read(self, amt=None):\n    if amt is None:\n      return self.response.read()\n    if len(self.buffer) - self.pos < amt:\n      self.buffer = self.buffer[self.pos:]\n      self.pos = 0\n      self.buffer += self.response.read(self.buffer_size)\n    data = self.buffer[self.pos:self.pos + amt]\n    self.pos += amt\n    if self.pos >= len(self.buffer):\n      self.pos = 0\n      self.buffer = b''\n    return data\n\n\ndef jsonResponse(*args, **kwargs):\n  encoder = kwargs.get('encoder')\n  default = kwargs.get('default')\n\n  def decorator(f):\n    @wraps(f)\n    def wrapped_f(request, *args, **kwargs):\n      if request.method == 'GET':\n        queryParams = request.GET.copy()\n      elif request.method == 'POST':\n        queryParams = request.GET.copy()\n        queryParams.update(request.POST)\n      else:\n        queryParams = {}\n\n      try:\n        return _jsonResponse(\n          f(request, queryParams, *args, **kwargs), queryParams, encoder=encoder, default=default)\n      except ValueError as err:\n        return _jsonError(\n          str(err), queryParams, status=getattr(err, 'status', 400), encoder=encoder, default=default)\n      except Exception as err:\n        return _jsonError(\n          str(err), queryParams, status=getattr(err, 'status', 500), encoder=encoder, default=default)\n\n    return wrapped_f\n\n  # used like @jsonResponse\n  if args:\n    return decorator(args[0])\n\n  # used like @jsonResponse(encoder=DjangoJSONEncoder)\n  return decorator\n\n\nclass HttpError(Exception):\n  def __init__(self, message, status=500):\n    super(HttpError, self).__init__(message)\n    self.status=status\n\n\ndef _jsonResponse(data, queryParams, status=200, encoder=None, default=None):\n  if isinstance(data, HttpResponse):\n    return data\n\n  if not queryParams:\n    queryParams = {}\n\n  return HttpResponse(\n    json.dumps(\n      data,\n      indent=(2 if queryParams.get('pretty') else None),\n      sort_keys=bool(queryParams.get('pretty')),\n      cls=encoder,\n      default=default\n    ),\n    content_type='application/json',\n    status=status\n  )\n\n\ndef _jsonError(message, queryParams, status=500, encoder=None, default=None):\n  return _jsonResponse(\n    {'error': message}, queryParams, status=status, encoder=encoder, default=default)\n\n\ndef parseHost(host_string):\n    s = host_string.strip()\n    bidx = s.rfind(']:')    # find closing bracket and following colon.\n    cidx = s.find(':')\n    if s.startswith('[') and bidx is not None:\n        server = s[1:bidx]\n        port = s[bidx + 2:]\n    elif cidx is not None:\n        server = s[:cidx]\n        port = s[cidx + 1:]\n    else:\n        raise ValueError(\"Invalid host string \\\"%s\\\"\" % host_string)\n\n    if ':' in port:\n        port, _, instance = port.partition(':')\n    else:\n        instance = None\n\n    return server, int(port), instance\n\n\ndef parseHosts(host_strings):\n    return [parseHost(host_string) for host_string in host_strings]\n", "from django.test import TestCase as OriginalTestCase\nfrom graphite.worker_pool.pool import stop_pools\n\n\nclass TestCase(OriginalTestCase):\n    def tearDown(self):\n        stop_pools()\n\n    # Assert that a response is unsanitized (for check XSS issues)\n    def assertXSS(self, response, status_code=200, msg_prefix=''):\n        if status_code is not None:\n            self.assertEqual(\n                response.status_code, status_code,\n                msg_prefix + \"Couldn't retrieve content: Response code was %d\"\n                \" (expected %d)\" % (response.status_code, status_code)\n            )\n\n        xss = response.content.find(b\"<\") != -1 or response.content.find(b\">\") != -1\n        self.assertFalse(xss, msg=msg_prefix+str(response.content))\n", "import copy\nimport errno\nimport mock\nimport os\n\nfrom . import TEST_CONF_DIR\n\nfrom django.conf import settings\ntry:\n    from django.urls import reverse\nexcept ImportError:  # Django < 1.10\n    from django.core.urlresolvers import reverse\nfrom django.http import HttpResponse\nfrom .base import TestCase\nfrom django.test.utils import override_settings\nfrom graphite.util import json\ntry:\n    from django.contrib.auth import get_user_model\n    User = get_user_model()\nexcept ImportError:\n    from django.contrib.auth.models import User\n\n\nclass DashboardTest(TestCase):\n    # Set config to the test config file\n    settings.DASHBOARD_CONF = os.path.join(TEST_CONF_DIR, 'dashboard.conf')\n\n    # Define a testtemplate\n    testtemplate = {\"state\": '{\"graphs\": [[ \"target=a.b.c.*.__VALUE__.d\", {  \"from\":\"-2days\", \"target\":[  \"a.b.c.*.__VALUE__.d\" ], \"until\":\"now\" }, \"/render?width=400&from=-2days&until=now&height=250&target=a.b.c.*.__VALUE__.d&_uniq=0.6526056618895382&title=a.b.c.*.__VALUE__.d\" ]]}'}\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing'))\n    def test_dashboard_missing_conf(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing'))\n    def test_dashboard_template_missing_template(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @mock.patch('graphite.dashboard.views.DashboardConfig.check')\n    def test_dashboard_conf_read_failure(self, check):\n        check.side_effect = OSError(errno.EPERM, 'Operation not permitted')\n        url = reverse('dashboard')\n        with self.assertRaises(Exception):\n            _ = self.client.get(url)\n\n    @mock.patch('graphite.dashboard.views.DashboardConfig.check')\n    def test_dashboard_template_conf_read_failure(self, check):\n        check.side_effect = OSError(errno.EPERM, 'Operation not permitted')\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        with self.assertRaises(Exception):\n            _ = self.client.get(url)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_ui'))\n    def test_dashboard_conf_missing_ui(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_ui'))\n    def test_dashboard_template_missing_ui(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_keyboard-shortcuts'))\n    def test_dashboard_conf_missing_keyboard_shortcuts(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_keyboard-shortcuts'))\n    def test_dashboard_template_missing_keyboard_shortcuts(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.invalid_theme'))\n    def test_dashboard_conf_invalid_theme(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.invalid_theme'))\n    def test_dashboard_template_invalid_theme(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_no_user(self):\n        url = reverse('dashboard')\n        request = {\"user\": '', \"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_pass_valid(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_pass_invalid_name(self):\n        url = reverse('dashboard', args=['bogusdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_find_empty(self):\n        url = reverse('dashboard_find')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_save_empty(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_save_overwrite(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_find_existing(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find')\n        request = {\"query\": \"test\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": [{\"name\": \"testdashboard\"}]}')\n\n    def test_dashboard_find_not_existing(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find')\n        request = {\"query\": \"not here\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_load_not_existing(self):\n        url = reverse('dashboard_load', args=['bogusdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Dashboard \\'bogusdashboard\\' does not exist. \"}')\n\n    def test_dashboard_load_existing(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_load', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"state\": {}}')\n\n    def test_dashboard_delete_nonexisting(self):\n        url = reverse('dashboard_delete', args=['bogusdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Dashboard \\'bogusdashboard\\' does not exist. \"}')\n\n    def test_dashboard_delete_existing(self):\n        # Create a dashboard entry\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        # Delete it\n        url = reverse('dashboard_delete', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n        # Confirm it was deleted\n        url = reverse('dashboard_find')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_create_temporary(self):\n        url = reverse('dashboard_create_temporary')\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"name\": \"temporary-0\"}')\n\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"name\": \"temporary-1\"}')\n\n        url = reverse('dashboard_find')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_template_pass_invalid(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_template_pass_valid(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_template', args=['testtemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_find_template_empty(self):\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": []}')\n\n    def test_dashboard_save_template(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        # Save again after it now exists\n    def test_dashboard_save_template_overwrite(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_find_template(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"test\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": [{\"name\": \"testtemplate\"}]}')\n\n    def test_dashboard_find_template_nonexistent(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"not here\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": []}')\n\n    def test_dashboard_load_template_nonexistent(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_load_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Template \\'bogustemplate\\' does not exist. \"}')\n\n    def test_dashboard_load_template_existing(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_load_template', args=['testtemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        graph_data = json.loads(self.testtemplate[\"state\"].replace('__VALUE__', 'testkey'))\n        self.assertEqual(data, json.loads('{\"state\": {\"name\": \"testtemplate/testkey\", \"graphs\": ' + json.dumps(graph_data['graphs']) + '}}'))\n\n    def test_dashboard_delete_template_nonexisting(self):\n        # Delete nonexistent template\n        url = reverse('dashboard_delete_template', args=['bogustemplate'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Template \\'bogustemplate\\' does not exist. \"}')\n\n    def test_dashboard_delete_template_existing(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_delete_template', args=['testtemplate'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": []}')\n\n    def test_dashboard_help(self):\n        url = reverse('dashboard_help')\n        request = {}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_email(self):\n        url = reverse('dashboard_email')\n        request = {\"sender\": \"noreply@localhost\",\n                   \"recipients\": \"noreply@localhost\",\n                   \"subject\": \"Test email\",\n                   \"message\": \"Here is the test graph\",\n                   \"graph_params\": '{\"target\":[\"sumSeries(a.b.c.d)\"],\"title\":\"Test\",\"width\":\"500\",\"from\":\"-55minutes\",\"until\":\"now\",\"height\":\"400\"}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n    @mock.patch('graphite.dashboard.views.renderView')\n    def test_dashboard_email_mock_renderView(self, rv):\n        url = reverse('dashboard_email')\n        request = {\"sender\": \"noreply@localhost\",\n                   \"recipients\": \"noreply@localhost\",\n                   \"subject\": \"Test email\",\n                   \"message\": \"Here is the test graph\",\n                   \"graph_params\": '{\"target\":[\"sumSeries(a.b.c.d)\"],\"title\":\"Test\",\"width\":\"500\",\"from\":\"-55minutes\",\"until\":\"now\",\"height\":\"400\"}'}\n        responseObject = HttpResponse()\n        responseObject.content = ''\n        rv.return_value = responseObject\n        response = self.client.post(url, request)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n    def test_dashboard_login_invalid_authenticate(self):\n        url = reverse('dashboard_login')\n        request = {\"username\": \"testuser\",\n                   \"password\": \"testpassword\"}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"errors\": {\"reason\": \"Username and/or password invalid.\"}, \"success\": false, \"text\": {}, \"permissions\": []}'))\n\n    @mock.patch('graphite.dashboard.views.authenticate')\n    def test_dashboard_login_valid_authenticate(self, authenticate):\n        url = reverse('dashboard_login')\n        request = {\"username\": \"testuser\",\n                   \"password\": \"testpassword\"}\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        authenticate.return_value = user\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"permissions\": [\"change\", \"delete\"], \"success\": true, \"text\": {}, \"errors\": {}}'))\n\n    @mock.patch('graphite.dashboard.views.authenticate')\n    def test_dashboard_login_valid_authenticate_not_active(self, authenticate):\n        url = reverse('dashboard_login')\n        request = {\"username\": \"testuser\",\n                   \"password\": \"testpassword\"}\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        user.is_active = False\n        authenticate.return_value = user\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"permissions\": [], \"success\": false, \"errors\": {\"reason\": \"Account disabled.\"}, \"text\": {}}'))\n\n    def test_dashboard_logout(self):\n        url = reverse('dashboard_logout')\n        request = {\"username\": \"testuser\"}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"errors\": {}, \"success\": true, \"text\": {}}'))\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_save_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to save\"}')\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_delete_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_delete', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to delete\"}')\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_save_template_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to save the template\"}')\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_delete_template_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_delete_template', args=['testtemplate'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to delete the template\"}')\n\n    def test_getPermissions_no_user(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=False\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        self.assertEqual(getPermissions(False), ['change', 'delete'])\n\n    def test_getPermissions_no_user_require_auth(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        self.assertEqual(getPermissions(False), [])\n\n    def test_getPermissions_valid_user(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), ['change', 'delete'])\n\n    def test_getPermissions_valid_user_require_perm(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=True\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), [])\n\n    def test_getPermissions_valid_user_edit_group(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=True\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), [])\n\n    def test_getPermissions_valid_user_require_perms_edit_group(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=True\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=True\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), [])\n"], "fixing_code": ["// From Ext library\n/*global Ext*/\n// Defined in dashboard.html\n/*global AUTOCOMPLETE_DELAY CALENDAR_ICON CLOCK_ICON CONTEXT_FIELD_WIDTH FINDER_QUERY_DELAY*/\n/*global HELP_ICON NEW_DASHBOARD_REMOVE_GRAPHS REFRESH_ICON REMOVE_ICON RESIZE_ICON*/\n/*global SHARE_ICON UI_CONFIG initialState initialError permissions queryString userName*/\n/*global UP_ICON DOWN_ICON TRASH_ICON permissionsUnauthenticated schemes*/\n// Defined in composer_widgets.js\n/*global createFunctionsMenu createOptionsMenu updateCheckItems*/\n\n// Global object names\nvar viewport;\nvar contextSelector;\nvar contextSelectorFields = [];\nvar selectedScheme = null;\nvar selectedRecord = null;\nvar metricSelector;\nvar metricSelectorMode;\nvar metricSelectorGrid;\nvar metricSelectorTextField;\nvar graphArea;\nvar graphStore;\nvar graphView;\nvar navBar;\nvar dashboardName;\nvar dashboardURL;\nvar refreshTask;\nvar spacer;\nvar justClosedGraph = false;\nvar NOT_EDITABLE = ['from', 'until', 'width', 'height', 'target', 'uniq', '_uniq'];\nvar editor = null;\n\nvar cookieProvider = new Ext.state.CookieProvider({\n  path: document.body.dataset.baseUrl + 'dashboard'\n});\n\nvar NAV_BAR_REGION = cookieProvider.get('navbar-region') || 'north';\n\nvar CONFIRM_REMOVE_ALL = cookieProvider.get('confirm-remove-all') != 'false';\n\nvar currentlySettingHash = false;\n\nfunction changeHash(hash){\n    currentlySettingHash = true;\n    window.location.hash = hash;\n}\n\nif ('onhashchange' in window) // does the browser support the hashchange event?\n  window.onhashchange = function () {\n    if (currentlySettingHash){\n      currentlySettingHash = false;\n      return;\n    }\n    location.reload();\n  }\n\n/* Nav Bar configuration */\nvar navBarNorthConfig = {\n  region: 'north',\n  layout: 'hbox',\n  layoutConfig: { align: 'stretch' },\n  collapsible: true,\n  collapseMode: 'mini',\n  collapsed: false,\n  split: true,\n  title: 'untitled',\n  height: 350,\n  listeners: {\n    expand: function() { focusCompleter(); } // defined below\n  }\n};\n\nvar navBarWestConfig = Ext.apply({}, navBarNorthConfig);\ndelete navBarWestConfig.height;\nnavBarWestConfig.region = 'west';\nnavBarWestConfig.layout = 'vbox';\nnavBarWestConfig.width = 338;\n\n\n// Record types and stores\nvar SchemeRecord = Ext.data.Record.create([\n  {name: 'name'},\n  {name: 'pattern'},\n  {name: 'fields', type: 'auto'}\n]);\n\nvar schemeRecords = [];\n\nvar schemesStore = new Ext.data.Store({\n  fields: SchemeRecord\n});\n\n\nvar ContextFieldValueRecord = Ext.data.Record.create([\n  {name: 'name'},\n  {path: 'path'}\n]);\n\nvar contextFieldStore = new Ext.data.JsonStore({\n  url: document.body.dataset.baseUrl + 'metrics/find/',\n  root: 'metrics',\n  idProperty: 'name',\n  fields: ContextFieldValueRecord,\n  baseParams: {format: 'completer', wildcards: '1'}\n});\n\n\nvar GraphRecord = new Ext.data.Record.create([\n  {name: 'target'},\n  {name: 'params', type: 'auto'},\n  {name: 'url'},\n  {name: 'width', type: 'auto'},\n  {name: 'height', type: 'auto'},\n  {name: 'loading'},\n]);\n\nvar graphStore;\nfunction graphStoreUpdated() {\n  if (metricSelectorGrid) metricSelectorGrid.getView().refresh();\n}\n\ngraphStore = new Ext.data.ArrayStore({\n  fields: GraphRecord,\n  listeners: {\n    add: graphStoreUpdated,\n    remove: graphStoreUpdated,\n    update: graphStoreUpdated\n  }\n});\n\nvar originalDefaultGraphParams = {\n  from: '-2hours',\n  until: 'now',\n  width: UI_CONFIG.default_graph_width,\n  height: UI_CONFIG.default_graph_height\n};\nvar defaultGraphParams;\n//XXX\n// Per-session default graph params\nvar sessionDefaultParamsJson = cookieProvider.get('defaultGraphParams');\nif (sessionDefaultParamsJson && sessionDefaultParamsJson.length > 0) {\n  defaultGraphParams = Ext.decode(sessionDefaultParamsJson);\n} else {\n  defaultGraphParams = Ext.apply({}, originalDefaultGraphParams);\n}\n\nfunction isLoggedIn() {\n  return userName != null;\n}\n\nfunction hasPermission(permission) {\n  for (const i in permissions) {\n    if (permissions[i] === permission) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction htmlEncode(input) {\n  return input.replace(/[^a-zA-Z0-9 ]/g, function (chr) {\n    return '&#' + chr.charCodeAt() + ';';\n  });\n}\n\nfunction htmlStriped(input) {\n  return htmlEncode(input).replace(/\\s/g, '_')\n}\n\nfunction initDashboard () {\n\n  // Populate naming-scheme based datastructures\n  Ext.each(schemes, function (schemeInfo) {\n    schemeInfo.id = schemeInfo.name;\n    schemeRecords.push( new SchemeRecord(schemeInfo) );\n\n    Ext.each(schemeInfo.fields, function (field) {\n\n      // Context Field configuration\n      contextSelectorFields.push( new Ext.form.ComboBox({\n        id: schemeInfo.name + '-' + field.name,\n        fieldLabel: field.label,\n        width: CONTEXT_FIELD_WIDTH,\n        mode: 'remote',\n        triggerAction: 'all',\n        editable: true,\n        forceSelection: false,\n        store: contextFieldStore,\n        displayField: 'name',\n        queryDelay: 100,\n        queryParam: 'query',\n        minChars: 1,\n        typeAhead: false,\n        value: queryString[field.name] || getContextFieldCookie(field.name) || '*',\n        listeners: {\n          beforequery: buildQuery,\n          change: contextFieldChanged,\n          select: function (thisField) { thisField.triggerBlur(); focusCompleter(); },\n          afterrender: function (thisField) { thisField.hide(); },\n          hide: function (thisField) { thisField.getEl().up('.x-form-item').setDisplayed(false); },\n          show: function (thisField) { thisField.getEl().up('.x-form-item').setDisplayed(true); }\n        }\n      }) );\n\n    });\n\n  });\n  schemesStore.add(schemeRecords);\n\n  spacer = new Ext.form.TextField({\n    hidden: true,\n    hideMode: 'visibility'\n  });\n\n  var metricTypeCombo = new Ext.form.ComboBox({\n    id: 'metric-type-field',\n    fieldLabel: 'Metric Type',\n    width: CONTEXT_FIELD_WIDTH,\n    mode: 'local',\n    triggerAction: 'all',\n    editable: false,\n    store: schemesStore,\n    displayField: 'name',\n    listeners: {\n      afterrender: function (combo) {\n        var value = (queryString.metricType) ? queryString.metricType : getContextFieldCookie('metric-type');\n\n        if (!value) {\n          value = 'Everything';\n        }\n        var index = combo.store.find('name', value);\n        if (index > -1) {\n          var record = combo.store.getAt(index);\n          combo.setValue(value);\n          metricTypeSelected.defer(250, this, [combo, record, index]);\n        }\n      },\n      select: metricTypeSelected\n    }\n  });\n\n  contextSelector = new Ext.form.FormPanel({\n    flex: 1,\n    autoScroll: true,\n    labelAlign: 'right',\n    items: [\n      spacer,\n      metricTypeCombo\n    ].concat(contextSelectorFields)\n  });\n\n  function expandNode(node, recurse) {\n    function addAll () {\n      Ext.each(node.childNodes, function (child) {\n        if (child.leaf) {\n          graphAreaToggle(child.id, {dontRemove: true});\n        } else if (recurse) {\n          expandNode(child, recurse);\n        }\n      });\n    }\n\n    if (node.isExpanded()) {\n      addAll();\n    } else {\n      node.expand(false, false, addAll);\n    }\n  }\n\n  var folderContextMenu = new Ext.menu.Menu({\n    items: [{\n      text: 'Add All Metrics',\n      handler: function (item, e) {\n                 expandNode(item.parentMenu.node, false);\n               }\n    }, {\n      text: 'Add All Metrics (recursively)',\n      handler: function (item, e) {\n                 expandNode(item.parentMenu.node, true);\n               }\n    }]\n  });\n\n  if (NAV_BAR_REGION == 'west') {\n    metricSelectorMode = 'tree';\n    metricSelector = new Ext.tree.TreePanel({\n      root: new Ext.tree.TreeNode({}),\n      containerScroll: true,\n      autoScroll: true,\n      flex: 3.0,\n      pathSeparator: '.',\n      rootVisible: false,\n      singleExpand: false,\n      trackMouseOver: true,\n      listeners: {\n      click: metricTreeSelectorNodeClicked,\n      contextmenu: function (node, e) {\n                     if (!node.leaf) {\n                       folderContextMenu.node = node;\n                       folderContextMenu.showAt( e.getXY() );\n                     }\n                   }\n      }\n    });\n  } else { // NAV_BAR_REGION == 'north'\n    metricSelectorMode = 'text';\n    metricSelectorGrid = new Ext.grid.GridPanel({\n      region: 'center',\n      hideHeaders: true,\n      loadMask: true,\n      bodyCssClass: 'metric-result',\n\n      colModel: new Ext.grid.ColumnModel({\n        defaults: {\n          sortable: false,\n          menuDisabled: true\n        },\n        columns: [\n          {header: 'Metric Path', width: 1.0, dataIndex: 'path'}\n        ]\n      }),\n      viewConfig: {\n        forceFit: true,\n        rowOverCls: '',\n        bodyCssClass: 'metric-result',\n        getRowClass: function(record, index) {\n          var toggledClass = (\n             graphStore.findExact('target', 'target=' + record.data.path) == -1\n            ) ? 'metric-not-toggled' : 'metric-toggled';\n          var branchClass = (\n            record.data['is_leaf'] == '0'\n          ) ? 'result-is-branch-node' : '';\n          return toggledClass + ' ' + branchClass + ' metric-result';\n        }\n      },\n      selModel: new Ext.grid.RowSelectionModel({\n        singleSelect: false\n      }),\n      store: new Ext.data.JsonStore({\n        method: 'GET',\n        url: document.body.dataset.baseUrl + 'metrics/find/',\n        autoLoad: true,\n        baseParams: {\n          query: '*',\n          format: 'completer',\n          automatic_variants: (UI_CONFIG.automatic_variants) ? '1' : '0'\n        },\n        fields: ['path', 'is_leaf'],\n        root: 'metrics'\n      }),\n      listeners: {\n        rowclick: function (thisGrid, rowIndex, e) {\n                    var record = thisGrid.getStore().getAt(rowIndex);\n                    if (record.data['is_leaf'] == '1') {\n                      graphAreaToggle(record.data.path);\n                      thisGrid.getView().refresh();\n                    } else {\n                      metricSelectorTextField.setValue(record.data.path);\n                    }\n                    autocompleteTask.delay(50);\n                    focusCompleter();\n                  }\n      }\n    });\n\n    function completerKeyPress(thisField, e) {\n      var charCode = e.getCharCode();\n      if (charCode == 8 ||  //backspace\n          charCode >= 46 || //delete and all printables\n          charCode == 36 || //home\n          charCode == 35) { //end\n        autocompleteTask.delay(AUTOCOMPLETE_DELAY);\n      }\n    }\n\n    metricSelectorTextField = new Ext.form.TextField({\n      region: 'south',\n      enableKeyEvents: true,\n      cls: 'completer-input-field',\n      listeners: {\n        keydown: completerKeyPress,\n        afterrender: focusCompleter\n      }\n    });\n    metricSelector = new Ext.Panel({\n      flex: 1.5,\n      layout: 'border',\n      items: [metricSelectorGrid, metricSelectorTextField]\n    });\n  }\n\n  var autocompleteTask = new Ext.util.DelayedTask(function () {\n    var query = metricSelectorTextField.getValue();\n    var store = metricSelectorGrid.getStore();\n    if (query === '') {\n      query = '*'\n    }\n    store.setBaseParam('query', query);\n    store.load();\n  });\n\n  var graphTemplate = new Ext.XTemplate(\n    '<tpl for=\".\">',\n      '<div class=\"graph-container\">',\n        '<div class=\"graph-overlay\">',\n          '<img class=\"graph-img{loading}\" src=\"{url}\" width=\"{width}\" height=\"{height}\" id=\"graph{index}\">',\n          '<div class=\"overlay-close-button\" onclick=\"javascript: graphStore.removeAt(\\'{index}\\'); updateGraphRecords(); justClosedGraph = true;\">X</div>',\n        '</div>',\n      '</div>',\n    '</tpl>',\n    '<div class=\"x-clear\"></div>'\n  );\n\n  function setupGraphDD () {\n    graphView.dragZone = new Ext.dd.DragZone(graphView.getEl(), {\n      containerScroll: true,\n      ddGroup: 'graphs',\n\n      getDragData: function (e) {\n        var sourceEl = e.getTarget(graphView.itemSelector, 10);\n        if (sourceEl) {\n          var dupe = sourceEl.cloneNode(true);\n          dupe.id = Ext.id();\n          return {\n            ddel: dupe,\n            sourceEl: sourceEl,\n            repairXY: Ext.fly(sourceEl).getXY(),\n            sourceStore: graphStore,\n            draggedRecord: graphView.getRecord(sourceEl)\n          }\n        }\n      },\n\n      getRepairXY: function () {\n        return this.dragData.repairXY;\n      }\n\n    });\n\n    graphView.dropZone = new Ext.dd.DropZone(graphView.getEl(), {\n      ddGroup: 'graphs',\n      dropAction: 'reorder',\n      mergeEl: Ext.get('merge'),\n\n      getTargetFromEvent: function (e) {\n        return e.getTarget(graphView.itemSelector);\n      },\n\n      onNodeEnter: function (target, dd, e, data) {\n        //Ext.fly(target).addClass('graph-highlight');\n        this.setDropAction('reorder');\n        this.mergeTarget = Ext.get(target);\n        this.mergeSwitchTimeout = this.setDropAction.defer(UI_CONFIG.merge_hover_delay, this, ['merge']);\n      },\n\n      onNodeOut: function (target, dd, e, data) {\n        //Ext.fly(target).removeClass('graph-highlight');\n        this.mergeEl.hide();\n        //this.setDropAction('reorder');\n      },\n\n      onNodeOver: function (target, dd, e, data) {\n        return Ext.dd.DropZone.prototype.dropAllowed;\n      },\n\n      setDropAction: function (action) {\n        if (this.mergeSwitchTimeout != null) {\n          clearTimeout(this.mergeSwitchTimeout);\n          this.mergeSwitchTimeout = null;\n        }\n\n        this.dropAction = action;\n        if (action == 'reorder') {\n          //revert merge ui change\n          this.mergeEl.hide();\n        } else if (action == 'merge') {\n          //apply merge ui change\n          this.mergeEl.show();\n          var targetXY = this.mergeTarget.getXY();\n          var mergeElWidth = Math.max(GraphSize.width * 0.75, 20);\n          var xOffset = (GraphSize.width - mergeElWidth) / 2;\n          var yOffset = -14;\n          this.mergeEl.setXY([targetXY[0] + xOffset, targetXY[1] + yOffset]);\n          this.mergeEl.setWidth(mergeElWidth);\n        }\n      },\n\n      onNodeDrop: function (target, dd, e, data){\n        var nodes = graphView.getNodes();\n        var dropIndex = nodes.indexOf(target);\n        var dragIndex = graphStore.indexOf(data.draggedRecord);\n\n        if (dragIndex == dropIndex) {\n          return false;\n        }\n\n        if (this.dropAction == 'reorder') {\n          graphStore.removeAt(dragIndex);\n          graphStore.insert(dropIndex, data.draggedRecord);\n          updateGraphRecords();\n          return true;\n        } else if (this.dropAction == 'merge') {\n          var dragRecord = data.draggedRecord;\n          var dropRecord = graphView.getRecord(target);\n          if (dropRecord.data.params.target.length == 1) {\n            if (dropRecord.data.params.target[0] == dropRecord.data.params.title) {\n              delete dropRecord.data.params.title;\n            }\n          }\n\n          var mergedTargets = uniq( dragRecord.data.params.target.concat(dropRecord.data.params.target) );\n          dropRecord.data.params.target = mergedTargets;\n          dropRecord.data.target = Ext.urlEncode({target: mergedTargets});\n          dropRecord.commit();\n          graphStore.remove(dragRecord);\n          updateGraphRecords();\n          return true;\n        }\n        return false;\n      }\n    });\n  }\n\n  graphView = new Ext.DataView({\n    store: graphStore,\n    tpl: graphTemplate,\n    overClass: 'graph-over',\n    itemSelector: 'div.graph-container',\n    emptyText: 'Configure your context above, and then select some metrics.',\n    autoScroll: true,\n//    plugins: [\n//      new Ext.ux.DataViewTransition({\n//        duration: 750,\n//        idProperty: 'target'\n//      })\n//    ],\n    listeners: {\n      click: graphClicked,\n      render: setupGraphDD\n    }\n  });\n\n  /* Toolbar items */\n  var relativeTimeRange = {\n          icon: CLOCK_ICON,\n          text: 'Relative Time Range',\n          tooltip: 'View Recent Data',\n          handler: selectRelativeTime,\n          scope: this\n  };\n\n  var absoluteTimeRange = {\n    icon: CALENDAR_ICON,\n    text: 'Absolute Time Range',\n    tooltip: 'View Specific Time Range',\n    handler: selectAbsoluteTime,\n    scope: this\n  };\n\n  var timeRangeText = {\n    id: 'time-range-text',\n    xtype: 'tbtext',\n    text: getTimeText()\n  };\n\n  // Note that some of these items are changed in postLoginMenuAdjust() after login/logout\n  var dashboardMenu = {\n    text: 'Dashboard',\n    menu: {\n      items: [\n        {\n          text: 'New',\n          handler: function (item, e) {\n                     setDashboardName(null);\n                     if (NEW_DASHBOARD_REMOVE_GRAPHS) {\n                       graphStore.removeAll();\n                     }\n                     refreshGraphs();\n                   }\n        }, {\n          text: 'Finder',\n          handler: showDashboardFinder\n        }, {\n          text: 'Template Finder',\n          handler: showTemplateFinder\n        }, {\n          text: 'Save As Template',\n          handler: saveTemplate,\n          disabled: !hasPermission('change')\n        }, {\n          id: 'dashboard-save-button',\n          text: 'Save',\n          handler: function (item, e) {\n                     sendSaveRequest(dashboardName);\n                   },\n          disabled: dashboardName == null || !hasPermission('change')\n        }, {\n          id: 'dashboard-save-as-button',\n          text: 'Save As',\n          handler: saveDashboard,\n          disabled: !hasPermission('change')\n        }, {\n          text: 'Configure UI',\n          handler: configureUI\n        }, {\n          text: 'Edit Dashboard',\n          handler: editDashboard\n        }, {\n          id: 'dashboard-login-button',\n          text: getLoginMenuItemText(),\n          handler: function (item, e) {\n                     if (isLoggedIn()) {\n                       logout();\n                     } else {\n                       showLoginForm();\n                     }\n                   }\n        }\n      ]\n    }\n  };\n\n  var graphsMenu = {\n    text: 'Graphs',\n    menu: {\n      items: [\n        { text: 'New Graph',\n          menu: {\n            items: [\n              { text: 'Empty Graph',\n                handler: newEmptyGraph\n              },\n              { text: 'From URL',\n                handler: newFromUrl\n              },\n              { text: 'From Saved Graph',\n                handler: newFromSavedGraph\n              },\n              { text: 'From Metric',\n                handler: newFromMetric\n              }\n            ]\n          }\n        },\n        {\n          text: 'Edit Default Parameters',\n          handler: editDefaultGraphParameters\n        }, {\n          text: 'Resize',\n          handler: selectGraphSize\n        }, {\n          text: 'Remove All',\n          handler: removeAllGraphs\n        }\n      ]\n    }\n  };\n\n  var shareButton = {\n    icon: SHARE_ICON,\n    tooltip: 'Share This Dashboard',\n    text: 'Share',\n    handler: doShare\n  };\n\n  var helpButton = {\n    icon: HELP_ICON,\n    tooltip: 'Keyboard Shortcuts',\n    handler: showHelp\n  };\n\n  var resizeButton = {\n    icon: RESIZE_ICON,\n    tooltip: 'Resize Graphs',\n    handler: selectGraphSize\n  };\n\n  var removeAllButton = {\n    icon: REMOVE_ICON,\n    tooltip: 'Remove All Graphs',\n    handler: removeAllGraphs\n  };\n\n  var refreshButton = {\n    icon: REFRESH_ICON,\n    tooltip: 'Refresh Graphs',\n    handler: refreshGraphs\n  };\n\n  var autoRefreshButton = {\n    xtype: 'button',\n    id: 'auto-refresh-button',\n    text: 'Auto-Refresh',\n    enableToggle: true,\n    pressed: false,\n    tooltip: 'Toggle auto-refresh',\n    toggleHandler: function (button, pressed) {\n                     if (pressed) {\n                       startTask(refreshTask);\n                     } else {\n                       stopTask(refreshTask);\n                     }\n                   }\n  };\n\n  var every = {\n    xtype: 'tbtext',\n    text: 'every'\n  };\n\n  var seconds = {\n    xtype: 'tbtext',\n    text: 'seconds'\n  };\n\n  var autoRefreshField = {\n    id: 'auto-refresh-field',\n    xtype: 'textfield',\n    width: 25,\n    value: UI_CONFIG.refresh_interval,\n    enableKeyEvents: true,\n    disableKeyFilter: true,\n    listeners: {\n      change: function (field, newValue) { updateAutoRefresh(newValue); },\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      if (field.getValue() >= 1) {\n                        updateAutoRefresh( field.getValue() );\n                      }\n                    }\n                  }\n    }\n  };\n\n  var lastRefreshed = {\n    xtype: 'tbtext',\n    text: 'Last Refreshed: '\n  };\n\n  var lastRefreshedText = {\n    id: 'last-refreshed-text',\n    xtype: 'tbtext',\n    text: ( new Date() ).format('g:i:s A')\n  };\n\n  graphArea = new Ext.Panel({\n    region: 'center',\n    layout: 'fit',\n    autoScroll: false,\n    bodyCssClass: 'graph-area-body',\n    items: [graphView],\n    tbar: new Ext.Toolbar({\n      items: [\n        dashboardMenu,\n        graphsMenu,\n        '-',\n        shareButton,\n        '-',\n        relativeTimeRange,\n        absoluteTimeRange,\n        ' ',\n        timeRangeText,\n        '->',\n        helpButton,\n        resizeButton,\n        removeAllButton,\n        refreshButton,\n        autoRefreshButton,\n        every, autoRefreshField, seconds,\n        '-',\n        lastRefreshed, lastRefreshedText\n      ]\n    })\n  });\n\n  /* Nav Bar */\n  navBarNorthConfig.items = [metricSelector];\n  navBarWestConfig.items = [contextSelector, metricSelector];\n  var navBarConfig = (NAV_BAR_REGION == 'north') ? navBarNorthConfig : navBarWestConfig;\n  navBar = new Ext.Panel(navBarConfig);\n\n  viewport = new Ext.Viewport({\n    layout: 'border',\n    items: [\n      navBar,\n      graphArea\n    ]\n  });\n\n  refreshTask = {\n    run: refreshGraphs,\n    interval: UI_CONFIG.refresh_interval * 1000\n  };\n\n  // Load initial dashboard state if it was passed in\n  if (initialState) {\n    applyState(initialState);\n    navBar.collapse(false);\n  }\n\n  if(window.location.hash != '')\n  {\n    if (window.location.hash.indexOf('/') != -1) {\n      var nameVal = window.location.hash.substr(1).split('/');\n      sendLoadTemplateRequest(nameVal[0],nameVal[1]);\n    } else {\n      sendLoadRequest(window.location.hash.substr(1));\n    }\n    navBar.collapse(false);\n  }\n\n  if (initialError) {\n    Ext.Msg.alert('Error', htmlEncode(initialError));\n  }\n}\n\nfunction showHelp() {\n  var win = new Ext.Window({\n    title: 'Keyboard Shortcuts',\n    modal: true,\n    width: 550,\n    height: 300,\n    autoLoad: document.body.dataset.baseUrl + 'dashboard/help/'\n  });\n  win.show();\n}\n\nfunction metricTypeSelected (combo, record, index) {\n  selectedScheme = record;\n\n  // Show only the fields for the selected context\n  Ext.each(contextSelectorFields, function (field) {\n    if (field.getId().indexOf( selectedScheme.get('name') ) == 0) {\n      field.show();\n    } else {\n      field.hide();\n    }\n  });\n\n  setContextFieldCookie('metric-type', combo.getValue());\n  contextFieldChanged();\n  focusCompleter();\n}\n\n\nfunction buildQuery (queryEvent) {\n  var queryString = '';\n  var parts = selectedScheme.get('pattern').split('.');\n  var schemeName = selectedScheme.get('name');\n\n  // Clear cached records to force JSON queries every time\n  contextFieldStore.removeAll();\n  delete queryEvent.combo.lastQuery;\n\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i];\n    var field = part.match(/^<[^>]+>$/) ? part.substr(1, part.length - 2) : null;\n\n    if (field == null) {\n      queryString += part + '.';\n      continue;\n    }\n\n    var combo = Ext.getCmp(schemeName + '-' + field);\n    var value = combo.getValue();\n\n    if (UI_CONFIG.automatic_variants) {\n      if (value.indexOf(',') > -1 && value.search(/[{}]/) == -1) {\n        value = '{' + value + '}';\n      }\n    }\n\n    if (combo === queryEvent.combo) {\n      queryEvent.query = queryString + queryEvent.query + '*';\n      return;\n    } else {\n      if (value) {\n        queryString += value + '.';\n      } else {\n        Ext.Msg.alert('Missing Context', 'Please fill out all of the fields above first.');\n        queryEvent.cancel = true;\n        return;\n      }\n    }\n  }\n\n  Ext.Msg.alert('Error', htmlEncode('Failed to build query, could not find \"' + queryEvent.combo.getId() + '\" field'));\n  queryEvent.cancel = true;\n}\n\n\nfunction contextFieldChanged() {\n  var pattern = getContextFieldsPattern();\n  if (pattern) metricSelectorShow(pattern);\n}\n\nfunction getContextFieldsPattern() {\n  var schemeName = selectedScheme.get('name');\n  var pattern = selectedScheme.get('pattern');\n  var fields = selectedScheme.get('fields');\n  var missingFields = false;\n\n  Ext.each(fields, function (field) {\n    var id = schemeName + '-' + field.name;\n    var value = Ext.getCmp(id).getValue();\n\n    // Update context field cookies\n    setContextFieldCookie(field.name, value);\n\n    if (UI_CONFIG.automatic_variants) {\n      if (value.indexOf(',') > -1 && value.search(/[{}]/) == -1) {\n        value = '{' + value + '}';\n      }\n    }\n\n    if (value.trim() == '') {\n      missingFields = true;\n    } else {\n      pattern = pattern.replace('<' + field.name + '>', value);\n    }\n  });\n\n  if (missingFields) {\n    return;\n  }\n\n  return pattern;\n}\n\nfunction metricSelectorShow(pattern) {\n  if (metricSelectorMode == 'tree') {\n    metricTreeSelectorShow(pattern);\n  } else {\n    metricTextSelectorShow(pattern);\n  }\n}\n\nfunction metricTreeSelectorShow(pattern) {\n  var baseParts = pattern.split('.');\n\n  function setParams (loader, node, callback) {\n    loader.baseParams.format = 'treejson';\n\n    if (node.id == 'rootMetricSelectorNode') {\n      loader.baseParams.query = pattern + '.*';\n    } else {\n      var idParts = node.id.split('.');\n      idParts.splice(0, baseParts.length); //make it relative\n      var relativeId = idParts.join('.');\n      loader.baseParams.query = pattern + '.' + relativeId + '.*';\n    }\n  }\n\n  var loader = new Ext.tree.TreeLoader({\n    url: document.body.dataset.baseUrl + 'metrics/find/',\n    requestMethod: 'GET',\n    listeners: {beforeload: setParams}\n  });\n\n  try {\n    var oldRoot = Ext.getCmp('rootMetricSelectorNode');\n    oldRoot.destroy();\n  } catch (err) { }\n\n  var root = new Ext.tree.AsyncTreeNode({\n    id: 'rootMetricSelectorNode',\n    loader: loader\n  });\n\n  metricSelector.setRootNode(root);\n  root.expand();\n}\n\nfunction metricTextSelectorShow(pattern) {\n  var store = metricSelectorGrid.getStore();\n  store.setBaseParam('query', pattern);\n  store.load();\n}\n\n\nfunction metricTreeSelectorNodeClicked (node, e) {\n  if (!node.leaf) {\n    if (node.expanded) {\n      node.collapse();\n    } else {\n      node.loaded = false;\n      node.expand();\n    }\n    return;\n  }\n\n  graphAreaToggle(node.id);\n}\n\n\nfunction graphAreaToggle(target, options) {\n  /* The GraphRecord's id is their URL-encoded target=...&target=... string\n     This function can get called with either the encoded string or just a raw\n     metric path, eg. \"foo.bar.baz\".\n  */\n  var graphTargetString;\n  if (target.substr(0,7) == 'target=') {\n    graphTargetString = target;\n  } else {\n    graphTargetString = 'target=' + target;\n  }\n  var graphTargetList = Ext.urlDecode(graphTargetString)['target'];\n  if (typeof graphTargetList == 'string') {\n    graphTargetList = [graphTargetList];\n  }\n\n  var existingIndex = graphStore.findExact('target', graphTargetString);\n\n  if (existingIndex > -1) {\n    if ( (options === undefined) || (!options.dontRemove) ) {\n      graphStore.removeAt(existingIndex);\n    }\n  } else if ( (options === undefined) || (!options.onlyRemove) ) {\n    // Add it\n    var myParams = {\n      target: graphTargetList\n    };\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    if (options && options.defaultParams) {\n      Ext.apply(urlParams, options.defaultParams);\n    }\n    Ext.apply(urlParams, GraphSize);\n    Ext.apply(urlParams, myParams);\n\n    var record = new GraphRecord({\n      target: graphTargetString,\n      params: myParams,\n      url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n    });\n    graphStore.add([record]);\n    updateGraphRecords();\n  }\n}\n\nfunction importGraphUrl(targetUrl, options) {\n  var fullUrl = targetUrl;\n  var i = fullUrl.indexOf('?');\n  if (i == -1) {\n    return;\n  }\n\n  var queryString = fullUrl.substr(i+1);\n  var params = Ext.urlDecode(queryString);\n\n  var graphTargetList = params['target'];\n  if (typeof graphTargetList == 'string') {\n    graphTargetList = [graphTargetList];\n  }\n  params['target'] = graphTargetList;\n\n  if (graphTargetList.length == 0) {\n    return;\n  }\n\n  var graphTargetString = Ext.urlEncode({target: graphTargetList});\n  var existingIndex = graphStore.findExact('target', graphTargetString);\n\n  if (existingIndex > -1) {\n    if ( (options === undefined) || (!options.dontRemove) ) {\n      graphStore.removeAt(existingIndex);\n    }\n  } else {\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    Ext.apply(urlParams, params);\n    Ext.apply(urlParams, GraphSize);\n\n    var record = new GraphRecord({\n      target: graphTargetString,\n      params: params,\n      url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n      });\n      graphStore.add([record]);\n      updateGraphRecords();\n  }\n}\n\nfunction updateGraphRecords() {\n  graphStore.each(function (item, index) {\n    var params = {};\n    Ext.apply(params, defaultGraphParams);\n    Ext.apply(params, item.data.params);\n    Ext.apply(params, GraphSize);\n    params._uniq = Math.random();\n    if (params.title === undefined && params.target.length == 1) {\n      params.title = params.target[0];\n    }\n    if (!params.uniq === undefined) {\n        delete params['uniq'];\n    }\n\n    //Preload the image and set it into the UI once it is available.\n    item.set('loading','-loading');\n    var img = new Image();\n    img.onload = function() {\n      item.set('url',img.src);\n      item.set('loading','');\n    };\n    img.src = document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(params);\n\n    item.set('width', GraphSize.width);\n    item.set('height', GraphSize.height);\n    item.set('index', index);\n  });\n}\n\nfunction refreshGraphs() {\n  updateGraphRecords();\n  graphView.refresh();\n  graphArea.getTopToolbar().get('last-refreshed-text').setText( (new Date()).format('g:i:s A') );\n}\n\n/*\nfunction refreshGraph(index) {\n  var node = graphView.getNode(index);\n  var record = graphView.getRecord(node);\n  record.data.params.uniq = Math.random();\n  record.set('url', '/render?' + Ext.urlEncode(record.get('params')));\n\n  // This refreshNode method only refreshes the record data, it doesn't re-render\n  // the template. Which is pretty useless... It would be more efficient if we\n  // could simply re-render the template. Need to see if thats feasible.\n  //graphView.refreshNode(node);\n\n  // This is *slightly* better than just calling refreshGraphs() because we're only\n  // updating the URL of one graph, so caching should save us from re-rendering each\n  // graph.\n  //graphView.refresh();\n}\n*/\n\nfunction updateAutoRefresh (newValue) {\n  Ext.getCmp('auto-refresh-field').setValue(newValue);\n\n  var value = parseInt(newValue);\n  if ( isNaN(value) ) {\n    return;\n  }\n\n  if (Ext.getCmp('auto-refresh-button').pressed) {\n    stopTask(refreshTask);\n    refreshTask.interval = value * 1000;\n    startTask(refreshTask);\n  } else {\n    refreshTask.interval = value * 1000;\n  }\n}\n\n/* Task management */\nfunction stopTask(task) {\n  if (task.running) {\n    Ext.TaskMgr.stop(task);\n    task.running = false;\n  }\n}\n\nfunction startTask(task) {\n  if (!task.running) {\n    Ext.TaskMgr.start(task);\n    task.running = true;\n  }\n}\n\n/* Time Range management */\ndefaultGraphParams['from'].match(/([0-9]+)([^0-9]+)/);\nvar defaultRelativeQuantity = RegExp.$1;\nvar defaultRelativeUnits = RegExp.$2;\nvar TimeRange = {\n  // Default to a relative time range\n  type: 'relative',\n  relativeStartQuantity: defaultRelativeQuantity,\n  relativeStartUnits: defaultRelativeUnits,\n  relativeUntilQuantity: '',\n  relativeUntilUnits: 'now',\n  // Absolute time range\n  startDate: new Date(),\n  startTime: '9:00 AM',\n  endDate: new Date(),\n  endTime: '5:00 PM'\n};\n\nfunction getTimeText() {\n  if (TimeRange.type == 'relative') {\n    var text = 'Now showing the past ' + TimeRange.relativeStartQuantity + ' ' + TimeRange.relativeStartUnits;\n    if (TimeRange.relativeUntilUnits !== 'now' && TimeRange.relativeUntilUnits !== '') {\n      text = text + ' until ' + TimeRange.relativeUntilQuantity + ' ' + TimeRange.relativeUntilUnits + ' ago';\n    }\n    return text;\n  } else {\n    var fmt = 'g:ia F jS Y';\n    return 'Now Showing ' + TimeRange.startDate.format(fmt) + ' through ' + TimeRange.endDate.format(fmt);\n  }\n}\n\nfunction updateTimeText() {\n  graphArea.getTopToolbar().get('time-range-text').setText( getTimeText() );\n}\n\nfunction timeRangeUpdated() {\n  if (TimeRange.type == 'relative') {\n    var fromParam = '-' + TimeRange.relativeStartQuantity + TimeRange.relativeStartUnits;\n    if (TimeRange.relativeUntilUnits == 'now') {\n      var untilParam = 'now';\n    } else {\n      var untilParam = '-' + TimeRange.relativeUntilQuantity + TimeRange.relativeUntilUnits;\n    }\n  } else {\n    var fromParam = TimeRange.startDate.format('H:i_Ymd');\n    var untilParam = TimeRange.endDate.format('H:i_Ymd');\n  }\n  defaultGraphParams.from = fromParam;\n  defaultGraphParams.until = untilParam;\n  saveDefaultGraphParams();\n\n  graphStore.each(function () {\n    this.data.params.from = fromParam;\n    this.data.params.until = untilParam;\n  });\n\n  updateTimeText();\n  refreshGraphs();\n}\n\n\nfunction selectRelativeTime() {\n  var quantityField = new Ext.form.TextField({\n    fieldLabel: 'Show the past',\n    width: 90,\n    allowBlank: false,\n    regex: /^\\d+$/,\n    regexText: 'Please enter a number',\n    value: TimeRange.relativeStartQuantity\n  });\n\n  var unitField = new Ext.form.ComboBox({\n    fieldLabel: '',\n    width: 90,\n    mode: 'local',\n    editable: false,\n    triggerAction: 'all',\n    allowBlank: false,\n    forceSelection: true,\n    store: ['minutes', 'hours', 'days', 'weeks', 'months'],\n    value: TimeRange.relativeStartUnits\n  });\n\n  var untilQuantityField = new Ext.form.TextField({\n    id: 'until-quantity-field',\n    fieldLabel: 'Until',\n    width: 90,\n    allowBlank: true,\n    regex: /^\\d+$/,\n    regexText: 'Please enter a number',\n    value: TimeRange.relativeUntilQuantity\n  });\n\n  var untilUnitField = new Ext.form.ComboBox({\n    fieldLabel: '',\n    width: 90,\n    mode: 'local',\n    editable: false,\n    triggerAction: 'all',\n    allowBlank: true,\n    forceSelection: false,\n    store: ['now', 'minutes', 'hours', 'days', 'weeks', 'months'],\n    value: TimeRange.relativeUntilUnits,\n    listeners: {\n      select: function(combo, record, index) {\n                  if (index == 0) {\n                    Ext.getCmp('until-quantity-field').setValue('');\n                    Ext.getCmp('until-quantity-field').setDisabled(true);\n                  } else {\n                    Ext.getCmp('until-quantity-field').setDisabled(false);\n                  }\n                },\n      render: function(combo) {\n                if (combo.getValue() == 'now') {\n                  Ext.getCmp('until-quantity-field').setValue('');\n                  Ext.getCmp('until-quantity-field').setDisabled(true);\n                } else {\n                  Ext.getCmp('until-quantity-field').setDisabled(false);\n                }\n              }\n    }\n  });\n\n\n  var win;\n\n  function updateTimeRange() {\n    TimeRange.type = 'relative';\n    TimeRange.relativeStartQuantity = htmlStriped(quantityField.getValue());\n    TimeRange.relativeStartUnits = htmlStriped(unitField.getValue());\n    TimeRange.relativeUntilQuantity = htmlStriped(untilQuantityField.getValue());\n    TimeRange.relativeUntilUnits = htmlStriped(untilUnitField.getValue());\n    win.close();\n    timeRangeUpdated();\n  }\n\n  win = new Ext.Window({\n    title: 'Select Relative Time Range',\n    width: 205,\n    height: 170,\n    resizable: false,\n    modal: true,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 90,\n    items: [quantityField, unitField, untilQuantityField, untilUnitField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: updateTimeRange},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\nfunction selectAbsoluteTime() {\n  var startDateField = new Ext.form.DateField({\n    fieldLabel: 'Start Date',\n    width: 125,\n    value: TimeRange.startDate || ''\n  });\n\n  var startTimeField = new Ext.form.TimeField({\n    fieldLabel: 'Start Time',\n    width: 125,\n    allowBlank: false,\n    increment: 30,\n    value: TimeRange.startTime || ''\n  });\n\n  var endDateField = new Ext.form.DateField({\n    fieldLabel: 'End Date',\n    width: 125,\n    value: TimeRange.endDate || ''\n  });\n\n  var endTimeField = new Ext.form.TimeField({\n    fieldLabel: 'End Time',\n    width: 125,\n    allowBlank: false,\n    increment: 30,\n    value: TimeRange.endTime || ''\n  });\n\n  var win;\n\n  function updateTimeRange() {\n    TimeRange.type = 'absolute';\n    TimeRange.startDate = new Date(startDateField.getValue().format('Y/m/d ') + startTimeField.getValue());\n    TimeRange.startTime = startTimeField.getValue();\n    TimeRange.endDate = new Date(endDateField.getValue().format('Y/m/d ') + endTimeField.getValue());\n    TimeRange.endTime = endTimeField.getValue();\n    win.close();\n    timeRangeUpdated();\n  }\n\n  win = new Ext.Window({\n    title: 'Select Absolute Time Range',\n    width: 225,\n    height: 180,\n    resizable: false,\n    modal: true,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 70,\n    items: [startDateField, startTimeField, endDateField, endTimeField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: updateTimeRange},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\n\n/* Graph size stuff */\nvar GraphSize = {\n  width: UI_CONFIG.default_graph_width,\n  height: UI_CONFIG.default_graph_height\n};\n\n\n// New empty Graph\nfunction newEmptyGraph() {\n\n  var myParams = {\n    target: []\n  };\n\n  var graphTargetString = Ext.urlEncode({target: ''});\n\n  var urlParams = {};\n  Ext.apply(urlParams, defaultGraphParams);\n  Ext.apply(urlParams, myParams);\n  Ext.apply(urlParams, GraphSize);\n  myParams['from'] = urlParams.from;\n  myParams['until'] = urlParams.until;\n\n  var record = new GraphRecord({\n   target: graphTargetString,\n    params: myParams,\n    url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams),\n   'width': GraphSize.width,\n   'height': GraphSize.height,\n    });\n  graphStore.add([record]);\n  var canvasId = graphStore.indexOf(record);\n  graphStore.getAt(canvasId).data.index = canvasId;\n  updateGraphRecords();\n}\n\nfunction newFromUrl() {\n  function applyUrl() {\n    var inputUrl = Ext.getCmp('import-url-field').getValue();\n    importGraphUrl(inputUrl);\n    win.close();\n  }\n\n  var urlField = new Ext.form.TextField({\n    id: 'import-url-field',\n    fieldLabel: 'Graph URL',\n    region: 'center',\n    width: '100%',\n    listeners: {\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      applyUrl();\n                    }\n                  },\n      afterrender: function (field) { field.focus(false, 100); }\n    }\n  });\n\n  var win = new Ext.Window({\n    title: 'Import Graph From URL',\n    width: 470,\n    height: 87,\n    layout: 'form',\n    resizable: true,\n    modal: true,\n    items: [urlField],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        text: 'OK',\n        handler: applyUrl\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n\n}\n\nfunction newFromSavedGraph() {\n  function setParams(loader, node) {\n    var nodeId = node.id.replace(/^[A-Za-z]+Tree\\.?/,'');\n    loader.baseParams.query = (nodeId == '') ? '*' : (nodeId + '.*');\n    loader.baseParams.format = 'treejson';\n    loader.baseParams.contexts = '1';\n    loader.baseParams.path = nodeId;\n    if (node.parentNode && node.parentNode.id == 'UserGraphsTree') {\n      loader.baseParams.user = node.id;\n    }\n  }\n\n  var userGraphsNode = new Ext.tree.AsyncTreeNode({\n    id: 'UserGraphsTree',\n    leaf: false,\n    allowChildren: true,\n    expandable: true,\n    allowDrag: false,\n    loader: new Ext.tree.TreeLoader({\n      url: document.body.dataset.baseUrl + 'browser/usergraph/',\n      requestMethod: 'GET',\n      listeners: {beforeload: setParams}\n    })\n  });\n\n  function handleSelects(selModel, nodes) {\n    Ext.each(nodes, function (node, index) {\n      if (!node.leaf) {\n        node.unselect();\n        node.toggle();\n      }\n    });\n\n    if (selModel.getSelectedNodes().length == 0) {\n      Ext.getCmp('user-graphs-select-button').setDisabled(true);\n    } else {\n      Ext.getCmp('user-graphs-select-button').setDisabled(false);\n    }\n  }\n\n  var treePanel = new Ext.tree.TreePanel({\n    id: 'user-graphs-tree',\n    header: false,\n    region: 'center',\n    root: userGraphsNode,\n    containerScroll: true,\n    autoScroll: true,\n    pathSeparator: '.',\n    rootVisible: false,\n    singleExpand: false,\n    trackMouseOver: true,\n    selModel: new Ext.tree.MultiSelectionModel({\n      listeners: {\n        selectionchange: handleSelects\n      }\n    })\n  });\n\n  function selectUserGraphs(selectedNodes) {\n    Ext.each(selectedNodes, function (node, index) {\n      importGraphUrl(node.attributes.graphUrl);\n    });\n  }\n\n  var win = new Ext.Window({\n    title: 'Import From User Graphs',\n    width: 300,\n    height: 400,\n    layout: 'border',\n    resizable: true,\n    modal: true,\n    items: [treePanel],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        id: 'user-graphs-select-button',\n        text: 'Select',\n        disabled: true,\n        handler: function () {\n          selectUserGraphs(Ext.getCmp('user-graphs-tree').getSelectionModel().getSelectedNodes());\n          win.close();\n        }\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n}\n\nfunction newFromMetric() {\n  function applyMetric() {\n    var inputMetric = Ext.getCmp('import-metric-field').getValue();\n    if (inputMetric == '') {\n      return;\n    }\n    var graphTargetString = Ext.urlEncode({target: inputMetric});\n\n    var myParams = {\n      target: [inputMetric]\n    };\n\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    Ext.apply(urlParams, myParams);\n    Ext.apply(urlParams, GraphSize);\n\n    var record = new GraphRecord({\n      target: graphTargetString,\n      params: myParams,\n      url: document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n      });\n    graphStore.add([record]);\n    updateGraphRecords();\n    win.close();\n  }\n\n  var urlField = new Ext.form.TextField({\n    id: 'import-metric-field',\n    fieldLabel: 'Metric',\n    region: 'center',\n    width: '100%',\n    listeners: {\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      applyMetric();\n                    }\n                  },\n      afterrender: function (field) { field.focus(false, 100); }\n    }\n  });\n\n  var win = new Ext.Window({\n    title: 'Import Graph From Metric',\n    width: 470,\n    height: 87,\n    layout: 'form',\n    resizable: true,\n    modal: true,\n    items: [urlField],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        text: 'OK',\n        handler: applyMetric\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n}\n\n\nfunction editDefaultGraphParameters() {\n  var editParams = Ext.apply({}, defaultGraphParams);\n  removeUneditable(editParams);\n\n  function applyParams() {\n    var paramsString = Ext.getCmp('default-params-field').getValue();\n    var params = Ext.urlDecode(paramsString);\n    copyUneditable(defaultGraphParams, params);\n    defaultGraphParams = params;\n    saveDefaultGraphParams();\n    refreshGraphs();\n    win.close();\n  }\n\n  var paramsField = new Ext.form.TextField({\n    id: 'default-params-field',\n    region: 'center',\n    value: Ext.urlEncode(editParams),\n    listeners: {\n      specialkey: function (field, e) {\n                    if (e.getKey() == e.ENTER) {\n                      applyParams();\n                    }\n                  },\n      afterrender: function (field) { field.focus(false, 100); }\n    }\n  });\n\n  var win = new Ext.Window({\n    title: 'Default Graph Parameters',\n    width: 470,\n    height: 87,\n    layout: 'border',\n    resizable: true,\n    modal: true,\n    items: [paramsField],\n    buttonAlign: 'center',\n    buttons: [\n      {\n        text: 'OK',\n        handler: applyParams\n      }, {\n        text: 'Cancel',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  win.show();\n}\n\nfunction selectGraphSize() {\n  var presetCombo = new Ext.form.ComboBox({\n    fieldLabel: 'Preset',\n    width: 80,\n    editable: false,\n    forceSelection: true,\n    triggerAction: 'all',\n    mode: 'local',\n    value: 'Custom',\n    store: ['Custom', 'Small', 'Medium', 'Large'],\n    listeners: {\n      select: function (combo, record, index) {\n                var w = '';\n                var h = '';\n                if (index == 1) { //small\n                  w = 300;\n                  h = 230;\n                } else if (index == 2) { //medium\n                  w = 400;\n                  h = 300;\n                } else if (index == 3) { //large\n                  w = 500;\n                  h = 400;\n                }\n                Ext.getCmp('width-field').setValue(w);\n                Ext.getCmp('height-field').setValue(h);\n              }\n    }\n  });\n\n  var widthField = new Ext.form.TextField({\n    id: 'width-field',\n    fieldLabel: 'Width',\n    width: 80,\n    regex: /\\d+/,\n    regexText: 'Please enter a number',\n    allowBlank: false,\n    value: GraphSize.width || UI_CONFIG.default_graph_width\n  });\n\n  var heightField = new Ext.form.TextField({\n    id: 'height-field',\n    fieldLabel: 'Height',\n    width: 80,\n    regex: /\\d+/,\n    regexText: 'Please enter a number',\n    allowBlank: false,\n    value: GraphSize.height || UI_CONFIG.default_graph_height\n  })\n\n  var win;\n\n  function resize() {\n    GraphSize.width = defaultGraphParams.width = widthField.getValue();\n    GraphSize.height = defaultGraphParams.height = heightField.getValue();\n    saveDefaultGraphParams();\n    win.close();\n    refreshGraphs();\n  }\n\n  win = new Ext.Window({\n    title: 'Change Graph Size',\n    width: 185,\n    height: 160,\n    resizable: false,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 80,\n    modal: true,\n    items: [presetCombo, widthField, heightField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: resize},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\nfunction doShare() {\n  if (dashboardName == null) {\n    Ext.Ajax.request({\n      url: document.body.dataset.baseUrl + 'dashboard/create-temporary/',\n      method: 'POST',\n      params: {\n        state: Ext.encode( getState() )\n      },\n      callback: function (options, success, response) {\n                  var result = Ext.decode(response.responseText);\n                  if (result.error) {\n                    Ext.Msg.alert('Error', htmlEncode('There was an error saving this dashboard: ' + result.error));\n                  } else {\n                    setDashboardName(result.name);\n                    sendSaveRequest(result.name); // Resave the state with the proper dashboardName now\n                    showShareWindow();\n                  }\n                }\n    });\n  } else {\n    // Prompt the user to save their dashboard so they are aware only saved changes get shared\n    Ext.Msg.show({\n      title: 'Save Dashboard And Share',\n      msg: 'You must save changes to your dashboard in order to share it.',\n      buttons: Ext.Msg.OKCANCEL,\n      fn: function (button) {\n            if (button == 'ok') {\n              sendSaveRequest(dashboardName);\n              showShareWindow();\n            }\n          }\n    });\n\n  }\n}\n\nfunction showShareWindow() {\n  var win = new Ext.Window({\n    title: 'Share Dashboard',\n    width: 600,\n    height: 125,\n    layout: 'border',\n    modal: true,\n    items: [\n      {\n        xtype: 'label',\n        region: 'north',\n        style: 'text-align: center;',\n        text: 'You can use this URL to access the current dashboard.'\n      }, {\n        xtype: 'textfield',\n        region: 'center',\n        value: dashboardURL,\n        editable: false,\n        style: 'text-align: center; font-size: large;',\n        listeners: {\n          focus: function (field) { field.selectText(); }\n        }\n      }\n    ],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Close', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\n/* Other stuff */\nvar targetGrid;\nvar activeMenu;\n\nfunction graphClicked(graphView, graphIndex, element, evt) {\n  Ext.get('merge').hide();\n  var record = graphStore.getAt(graphIndex);\n  if (!record) {\n    return;\n  }\n\n  if (justClosedGraph) {\n    justClosedGraph = false;\n    return;\n  }\n\n  if ( (activeMenu != null) && (selectedRecord == record) ) {\n    activeMenu.destroy();\n    activeMenu = null;\n    return;\n  }\n\n  selectedRecord = record; // global state hack for graph options API\n\n  var menu;\n  var menuItems = [];\n\n  function applyChanges (field, e) {\n    if (e.getKey() != e.ENTER) {\n      return;\n    }\n\n    var targets = [];\n    Ext.each(menuItems, function (field) {\n      if ((!field.getXType) || field.getXType() != 'textfield') {\n        return;\n      }\n      if (field.initialConfig.isTargetField) {\n        targets.push( field.getValue() );\n      } else {\n        var newParams = Ext.urlDecode( field.getValue() );\n        copyUneditable(record.data.params, newParams);\n        record.data.params = newParams;\n      }\n    });\n    record.data.target = Ext.urlEncode( {target: targets} );\n    record.data.params.target = targets;\n\n    refreshGraphs();\n    menu.destroy();\n  }\n\n  function syncGraphs(thisStore, record, operation) {\n    var targets = [];\n    thisStore.each(function (rec) { targets.push(rec.data.target.replace(/'/g, '\"')); });\n    selectedRecord.data.params.target = targets;\n    selectedRecord.data.target = Ext.urlEncode({target: targets});\n    refreshGraphs();\n  }\n\n\n  /* Inline store definition hackery*/\n  var functionsButton;\n  var targets = record.data.params.target;\n  targets = map(targets, function (t) { return {target: t}; });\n  var targetStore = new Ext.data.JsonStore({\n    fields: ['target'],\n    data: targets,\n    listeners: {\n      update: syncGraphs,\n      remove: syncGraphs,\n      add: syncGraphs,\n    }\n  });\n\n  var buttonWidth = 115;\n  var rowHeight = 21;\n  var maxRows = 6;\n  var frameHeight = 5;\n  var gridWidth = (buttonWidth * 4) + 2;\n  var gridHeight = (rowHeight * Math.min(targets.length, maxRows)) + frameHeight;\n\n  targetGrid = new Ext.grid.EditorGridPanel({\n    //frame: true,\n    width: gridWidth,\n    height: gridHeight,\n    store: targetStore,\n    hideHeaders: true,\n    viewConfig: {\n                  markDirty: false,\n                  forceFit: true,\n                  autoFill: true,\n                  scrollOffset: 0\n                },\n    colModel: new Ext.grid.ColumnModel({\n      columns: [\n        {\n          id: 'target',\n          header: 'Target',\n          dataIndex: 'target',\n          width: gridWidth - 90,\n          renderer: 'htmlEncode',\n          editor: {xtype: 'textfield'}\n        },\n        {\n            xtype: 'actioncolumn',\n            width: 30,\n            sortable: false,\n            items: [{\n                icon: UP_ICON,\n                tooltip: 'Move Up',\n                handler: function(grid, rowIndex, colIndex) {\n                    var record = targetStore.getAt(rowIndex);\n                    var target = record.data.target;\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0targetStore.remove(record);\n                    if(rowIndex > 0) {\n                        targetStore.insert(rowIndex-1, record);\n                    } else {\n                        targetStore.add(record);\n                    }\n                }\n            }]\n        },\n        {\n            xtype: 'actioncolumn',\n            width: 30,\n            sortable: false,\n            items: [{\n                icon: DOWN_ICON,\n                tooltip: 'Move Down',\n                handler: function(grid, rowIndex, colIndex) {\n                    var record = targetStore.getAt(rowIndex);\n                    var target = record.data.target;\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0targetStore.remove(record);\n                    if(rowIndex < targetStore.getTotalCount()-1) {\n                        targetStore.insert(rowIndex+1, record);\n                    } else {\n                        targetStore.insert(0, record);\n                    }\n                }\n            }]\n        },\n        {\n            xtype: 'actioncolumn',\n            width: 30,\n            sortable: false,\n            items: [{\n                icon: TRASH_ICON,\n                tooltip: 'Delete Row',\n                handler: function(grid, rowIndex, colIndex) {\n                    var record = targetStore.getAt(rowIndex);\n                    var target = record.data.target;\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0targetStore.remove(record);\n                    targets.remove(target);\n                }\n            }]\n        },\n      ]\n    }),\n    selModel: new Ext.grid.RowSelectionModel({\n      singleSelect: false,\n      listeners: {\n        selectionchange: function (thisSelModel) {\n          functionsButton.setDisabled(thisSelModel.getCount() == 0);\n        }\n      }\n    }),\n    clicksToEdit: 2,\n    listeners: {\n      afterrender: function (thisGrid) {\n        thisGrid.getSelectionModel().selectFirstRow.defer(50, thisGrid.getSelectionModel());\n      },\n      resize: function (thisGrid) {\n        thisGrid.findParentByType('menu').doLayout();\n      }\n    }\n  });\n  menuItems.push(targetGrid);\n\n  /* Setup our menus */\n  var functionsMenu = new Ext.menu.Menu({\n    allowOtherMenus: true,\n    items: createFunctionsMenu().concat([ {text: 'Remove Outer Call', handler: removeOuterCall} ])\n  });\n\n  functionsButton = new Ext.Button({\n    text: 'Apply Function',\n    disabled: true,\n    width: buttonWidth,\n    handler: function (thisButton) {\n               if (functionsMenu.isVisible()) {\n                 functionsMenu.hide();\n               } else {\n                 operationsMenu.hide();\n                 optionsMenu.doHide(); // private method... yuck\n                 functionsMenu.show(thisButton.getEl());\n               }\n             }\n  });\n\n\n  var optionsMenuConfig = createOptionsMenu(); // defined in composer_widgets.js\n  optionsMenuConfig.allowOtherMenus = true;\n  var optionsMenu = new Ext.menu.Menu(optionsMenuConfig);\n  optionsMenu.on('hide', function () { menu.hide(); });\n  updateCheckItems();\n\n  var operationsMenu = new Ext.menu.Menu({\n    allowOtherMenus: true,\n    items: [{\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Breakout',\n      width: 100,\n      handler: function () { menu.destroy(); breakoutGraph(record); }\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Clone',\n      width: 100,\n      handler: function () { menu.destroy(); cloneGraph(record); }\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Email',\n      width: 100,\n      handler: function () { menu.destroy(); mailGraph(record); }\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Direct URL',\n      width: 100,\n      handler: function () {\n        menu.destroy();\n        var win = new Ext.Window({\n          title: 'Graph URL',\n          width: 600,\n          height: 125,\n          layout: 'border',\n          modal: true,\n          items: [\n            {\n              xtype: 'label',\n              region: 'north',\n              style: 'text-align: center;',\n              text: 'Direct URL to this graph'\n            }, {\n              xtype: 'textfield',\n              region: 'center',\n              value:  record.data.url,\n              editable: false,\n              style: 'text-align: center; font-size: large;',\n              listeners: {\n                focus: function (field) { field.selectText(); }\n              }\n            }\n          ],\n          buttonAlign: 'center',\n          buttons: [\n            {text: 'Close', handler: function () { win.close(); } }\n          ]\n        });\n        win.show();\n      },\n    }, {\n      xtype: 'button',\n      fieldLabel: '<span style=\\'visibility: hidden\\'>',\n      text: 'Short Direct URL',\n      width: 100,\n      handler: function () {\n        menu.destroy();\n        var showUrl = function(options, success, response) {\n            if(success) {\n              var win = new Ext.Window({\n                title: 'Graph URL',\n                width: 600,\n                height: 125,\n                layout: 'border',\n                modal: true,\n                items: [\n                  {\n                    xtype: 'label',\n                    region: 'north',\n                    style: 'text-align: center;',\n                    text: 'Short Direct URL to this graph'\n                  }, {\n                    xtype: 'textfield',\n                    region: 'center',\n                    value:  window.location.origin + response.responseText,\n                    editable: false,\n                    style: 'text-align: center; font-size: large;',\n                    listeners: {\n                      focus: function (field) { field.selectText(); }\n                    }\n                  }\n                ],\n                buttonAlign: 'center',\n                buttons: [\n                  {text: 'Close', handler: function () { win.close(); } }\n                ]\n              });\n              win.show();\n           }\n        }\n        Ext.Ajax.request({\n          method: 'GET',\n          url: document.body.dataset.baseUrl + 's' + record.data.url,\n          callback: showUrl,\n        });\n      }\n    }, {\n        xtype: 'button',\n        text: 'History',\n        width: 100,\n        handler: function () { menu.destroy(); historyGraph(record);}\n    }]\n  });\n\n  var buttons = [functionsButton];\n\n  buttons.push({\n    xtype: 'button',\n    text: 'Render Options',\n    width: buttonWidth,\n    handler: function (thisButton) {\n               if (optionsMenu.isVisible()) {\n                 optionsMenu.doHide(); // private method... yuck (no other way to hide w/out trigging hide event handler)\n               } else {\n                 operationsMenu.hide();\n                 functionsMenu.hide();\n                 optionsMenu.show(thisButton.getEl());\n               }\n             }\n  });\n\n  buttons.push({\n    xtype: 'button',\n    text: 'Graph Operations',\n    width: buttonWidth,\n    handler: function (thisButton) {\n               if (operationsMenu.isVisible()) {\n                 operationsMenu.hide();\n               } else {\n                 optionsMenu.doHide(); // private method... yuck\n                 functionsMenu.hide();\n                 operationsMenu.show(thisButton.getEl());\n               }\n             }\n  });\n\n  //create new row\n\u00a0\u00a0buttons.push({\n    xtype: 'button',\n\u00a0\u00a0\u00a0\u00a0text: 'Add Target',\n    width: buttonWidth,\n\u00a0\u00a0\u00a0\u00a0handler: function() {\n               // Hide the other menus\n               operationsMenu.hide();\n               optionsMenu.doHide(); // private method... yuck\n               functionsMenu.hide();\n\n               targetStore.add([ new targetStore.recordType({target: 'Edit to save'}) ]);\n               targets.push('Edit to save');\n               targetGrid.setHeight((rowHeight * Math.min(targets.length, maxRows)) + frameHeight);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0});\n\n\n  menuItems.push({\n    xtype: 'panel',\n    layout: 'hbox',\n    items: buttons\n  });\n\n  menu = new Ext.menu.Menu({\n    layout: 'anchor',\n    allowOtherMenus: true,\n    items: menuItems\n  });\n  activeMenu = menu;\n  var position = evt.getXY();\n  position[0] -= (buttonWidth * 1.5) + 10; //horizontally center menu with the mouse\n  menu.showAt(position);\n  menu.get(0).focus(false, 50);\n  menu.keyNav.disable();\n  menu.on('hide', function () {\n                    var graphMenuParams = Ext.getCmp('graphMenuParams');\n                    if (graphMenuParams) {\n                      graphMenuParams.destroy();\n                    }\n                  }\n  );\n  menu.on('destroy', function () {\n                       optionsMenu.destroy();\n                       operationsMenu.destroy();\n                       functionsMenu.destroy();\n                     }\n  );\n}\n\n\nfunction removeUneditable (obj) {\n  Ext.each(NOT_EDITABLE, function (p) {\n    delete obj[p];\n  });\n  return obj;\n}\n\nfunction copyUneditable (src, dst) {\n  Ext.each(NOT_EDITABLE, function (p) {\n    if (src[p] === undefined) {\n      delete dst[p];\n    } else {\n      dst[p] = src[p];\n    }\n  });\n}\n\nfunction breakoutGraph(record) {\n  /* We have to gather some context from the\n     graph target's expressions so we can reapply\n     functions after the expressions get expanded. */\n  var pathExpressions = [];\n  var exprInfo = {};\n\n  try {\n    Ext.each(record.data.params.target, function(target) {\n      var exprsInThisTarget = 0;\n      map(target.split(','), function (arg) {\n        var arglets = arg.split('(');\n        map(arglets[arglets.length-1].split(')'), function (expr) {\n          expr = expr.replace(/^\\s*(.+?)\\s*$/, '$1');\n          if (expr.length == 0 || expr[0] == '\"' || expr[0] == '\\'') return;\n\n          if (expr.match(/[a-z].*\\..*[a-z]/i)) {\n            exprsInThisTarget++;\n            if (exprsInThisTarget > 1) {\n              throw 'arrr!';\n            }\n\n            pathExpressions.push(expr);\n            var i = target.indexOf(expr);\n            exprInfo[expr] = {\n              expr: expr,\n              pre: target.substr(0, i),\n              post: target.substr(i + expr.length)\n            }\n\n          }\n\n        }); //map arglets\n      }); //map args\n    }); //each target\n  } catch (err) {\n    Ext.Msg.alert('Graph contains unbreakable target', 'Graph targets containing more than one metric expression cannot be broken out.');\n    return;\n  }\n\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'metrics/expand/',\n    params: {\n      groupByExpr: '1',\n      leavesOnly: '1',\n      query: pathExpressions\n    },\n    callback: function (options, success, response) {\n                var responseObj = Ext.decode(response.responseText);\n                graphStore.remove(record);\n                for (var expr in responseObj.results) {\n                  var pre = exprInfo[expr].pre;\n                  var post = exprInfo[expr].post;\n                  map(responseObj.results[expr], function (metricPath) {\n                    metricPath = pre + metricPath + post;\n                    graphAreaToggle(metricPath, {dontRemove: true, defaultParams: record.data.params});\n                  });\n                }\n              }\n  });\n}\n\nfunction mailGraph(record) {\n  var mygraphParams = record.get('params');\n  var newparams = Ext.encode(Ext.apply(mygraphParams, defaultGraphParams));\n\n  var fromField = new Ext.form.TextField({\n    fieldLabel: 'From',\n    name: 'sender',\n    width: 300,\n    allowBlank: false\n  });\n\n  var toField = new Ext.form.TextField({\n    fieldLabel: 'To',\n    name: 'recipients',\n    width: 300,\n    allowBlank: false\n  });\n\n  var subjectField = new Ext.form.TextField({\n    fieldLabel: 'Subject',\n    name: 'subject',\n    width: 300,\n    allowBlank: false\n  });\n\n  var msgField = new Ext.form.TextArea({\n    fieldLabel: 'Message',\n    name: 'message',\n    width: 300,\n    height: 75\n  });\n\n  var graphParamsField = new Ext.form.TextField({\n     name: 'graph_params',\n     hidden: true,\n     value: newparams\n  });\n\n  var contactForm = new Ext.form.FormPanel({\n    width: 300,\n    labelWidth: 90,\n    items: [fromField, toField, subjectField, msgField, graphParamsField],\n    buttons: [{\n      text: 'Cancel',\n      handler: function(){win.close();}\n    }, {\n         text: 'Send',\n         handler: function(){\n           if(contactForm.getForm().isValid()){\n             contactForm.getForm().submit({\n               url: document.body.dataset.baseUrl + 'dashboard/email',\n               waitMsg: 'Processing Request',\n               success: function (contactForm, response) {\n                 win.close();\n               }\n             });\n           }\n         }\n     }]\n  });\n\n  var win;\n\n  win = new Ext.Window({\n    title: 'Send graph via email',\n    width: 450,\n    height: 230,\n    resizable: true,\n    modal: true,\n    layout: 'fit',\n    items: [contactForm]\n  });\n  win.show();\n}\n\n\nfunction cloneGraph(record) {\n  var index = graphStore.indexOf(record);\n  var clone = cloneGraphRecord(record);\n  graphStore.insert(index+1, [clone]);\n  refreshGraphs();\n}\n\nfunction cloneGraphRecord(record) {\n  //ensure we are working with copies, not references\n  var props = {\n    url: record.data.url,\n    target: record.data.target,\n    params: Ext.apply({}, record.data.params)\n  };\n  props.params.target = Ext.urlDecode(props.target).target;\n  if (typeof props.params.target == 'string') {\n    props.params.target = [props.params.target];\n  }\n  return new GraphRecord(props);\n}\n\nfunction historyGraph(record){\n\n    var graphHistoryStore = new Ext.data.ArrayStore({\n      fields: GraphRecord,\n      listeners: {\n        add: graphStoreUpdated,\n        remove: graphStoreUpdated,\n        update: graphStoreUpdated\n      }\n    });\n\n    function getProps(record){\n        var props = {\n          url: record.data.url,\n          target: record.data.target,\n          params: Ext.apply({}, record.data.params)\n        };\n        props.params.target = Ext.urlDecode(props.target).target;\n        if (typeof props.params.target == 'string') {\n          props.params.target = [props.params.target];\n        }\n\n        props.params.width = '750';\n        props.params.height = '300';\n        props.params.until = '-';\n\n        return props;\n    }\n\n    var props = getProps(record);\n    var title = '';\n    title = (props.params.title != undefined) ? props.params.title : '';\n\n    props = getProps(record);\n    props.params.title = title + ' 1 hour';\n    props.params.from = '-1hour';\n    graphHistoryStore.insert(0,new GraphRecord(props));\n\n    props = getProps(record);\n    props.params.title = title + ' 1 day';\n    props.params.from = '-1day';\n    graphHistoryStore.insert(1,new GraphRecord(props));\n\n    props = getProps(record);\n    props.params.title = title + ' 7 day';\n    props.params.from = '-7day';\n    graphHistoryStore.insert(2,new GraphRecord(props));\n\n    props = getProps(record);\n    props.params.title = title + ' 30 day';\n    props.params.from = '-30day';\n    graphHistoryStore.insert(3,new GraphRecord(props));\n\n    var graphTemplate = new Ext.XTemplate(\n      '<tpl for=\".\">',\n        '<div class=\"graph-container\">',\n          '<div class=\"graph-overlay\">',\n            '<img class=\"graph-img\" src=\"{url}\" width=\"{width}\" height=\"{height}\" id=\"graph{index}\">',\n          '</div>',\n        '</div>',\n      '</tpl>',\n      '<div class=\"x-clear\"></div>'\n    );\n\n    updateDataHistory();\n\n    function updateDataHistory(){\n        graphHistoryStore.each(function (item, index) {\n          var params = {};\n          Ext.apply(params, defaultGraphParams);\n          Ext.apply(params, item.data.params);\n          //Ext.apply(params, GraphSize);\n          params._uniq = Math.random();\n          if (params.title === undefined && params.target.length == 1) {\n            params.title = params.target[0];\n          }\n\n          if (!params.uniq === undefined) {\n              delete params['uniq'];\n          }\n          item.set('url', '/render?' + Ext.urlEncode(params));\n          item.set('width', item.data.params.width);\n          item.set('height', item.data.params.height);\n          item.set('index', index);\n        });\n    }\n\n    var graphHistoryView = new Ext.DataView({\n      store: graphHistoryStore,\n      tpl: graphTemplate,\n      overClass: 'graph-over',\n      itemSelector: 'div.graph-container',\n      emptyText: 'Configure your context above, and then select some metrics.',\n      autoScroll: true,\n      listeners: {\n      }\n    });\n\n    var win = new Ext.Window({\n      title: 'Graph History',\n      width: 800,\n      height: 800,\n      resizable: true,\n      modal: true,\n      layout: 'fit',\n      items: graphHistoryView\n    });\n    win.show();\n\n}\nfunction removeAllGraphs() {\n  if (CONFIRM_REMOVE_ALL) {\n    /*\n    Ext.Msg.confirm(\n      \"Are you sure?\",\n      \"Are you sure you want to remove all the graphs?\",\n      function (choice) {\n        if (choice == 'yes') {\n          graphStore.removeAll();\n          refreshGraphs();\n        }\n      }\n    );\n    */\n    var win;\n    win = new Ext.Window({\n      title: 'Remove All Graphs',\n      width: 200,\n      height: 120,\n      modal: true,\n      layout: 'vbox',\n      layoutConfig: { align: 'center' },\n      items: [\n        {\n          xtype: 'label',\n          text: 'Are You Sure?',\n          style: 'font-size: large;'\n        }, {\n          id: 'always-ask-me',\n          xtype: 'checkbox',\n          boxLabel: 'Always Ask Me',\n          name: 'ask-me',\n          inputValue: 'yes',\n          checked: true\n        }\n      ],\n      buttonAlign: 'center',\n      buttons: [\n        {\n          text: 'Yes',\n          handler: function () {\n                     if (Ext.getCmp('always-ask-me').getValue()) {\n                       CONFIRM_REMOVE_ALL = true;\n                       cookieProvider.set('confirm-remove-all', 'true');\n                     } else {\n                       CONFIRM_REMOVE_ALL = false;\n                       cookieProvider.set('confirm-remove-all', 'false');\n                     }\n                     graphStore.removeAll();\n                     refreshGraphs();\n                     win.close();\n                   }\n        }, {\n          text: 'No',\n          handler: function () { win.close(); }\n        }\n      ]\n    });\n    win.show();\n  } else {\n    graphStore.removeAll();\n    refreshGraphs();\n  }\n}\n\n\nfunction toggleToolbar() {\n  var tbar = graphArea.getTopToolbar();\n  tbar.setVisible( ! tbar.isVisible() );\n  graphArea.doLayout();\n}\n\nfunction toggleNavBar() {\n  navBar.toggleCollapse(true);\n}\n\nfunction focusCompleter() {\n  if (metricSelectorTextField) metricSelectorTextField.focus(false, 50);\n}\n\n/* Keyboard shortcuts */\nvar keyEventHandlers = {\n  toggle_toolbar: toggleToolbar,\n  toggle_metrics_panel: toggleNavBar,\n  give_completer_focus: focusCompleter,\n  erase_all_graphs: function () {\n      graphStore.removeAll();\n      refreshGraphs();\n      graphStoreUpdated();\n    },\n  completer_add_metrics: function () {\n      if (metricSelectorGrid) {\n        metricSelectorGrid.getStore().each(function (record) {\n          if (record.data.path[ record.data.path.length - 1] != '.') {\n            graphAreaToggle(record.data.path, {dontRemove: true});\n          }\n        });\n        focusCompleter();\n      }\n    },\n  completer_del_metrics: function () {\n      if (metricSelectorGrid) {\n        metricSelectorGrid.getStore().each(function (record) {\n          graphAreaToggle(record.data.path, {onlyRemove: true});\n        });\n        focusCompleter();\n      }\n    },\n  save_dashboard: function () {\n      if (dashboardName == null) {\n        saveDashboard();\n      } else {\n        sendSaveRequest(dashboardName);\n      }\n    }\n};\n\nvar specialKeys = {\n  space: 32,\n  enter: Ext.EventObject.ENTER,\n  backspace: Ext.EventObject.BACKSPACE\n};\n\nvar keyMapConfigs = [];\n\nfor (var event_name in UI_CONFIG.keyboard_shortcuts) {\n  var config = {handler: keyEventHandlers[event_name]};\n  if (!config.handler) {\n    continue;\n  }\n  var keyString = UI_CONFIG.keyboard_shortcuts[event_name];\n  var keys = keyString.split('-');\n  config.ctrl = keys.indexOf('ctrl') > -1;\n  config.alt = keys.indexOf('alt') > -1;\n  config.shift = keys.indexOf('shift') > -1;\n  config.key = keys[keys.length - 1];\n  if (specialKeys[config.key]) {\n    config.key = specialKeys[config.key];\n  }\n  keyMapConfigs.push(config);\n}\n\nvar keyMap = new Ext.KeyMap(document, keyMapConfigs);\n\n\n/* Dashboard functions */\nfunction editDashboard() {\n  var editDashboardWin = new Ext.Window({\n    title: 'Edit Dashboard',\n    id: 'editor-window',\n    width: 700,\n    height: 500,\n    layout: 'vbox',\n    layoutConfig: {align: 'stretch', pack: 'start'},\n    modal: true,\n    items: [\n      {\n        xtype: 'container',\n        flex: 1,\n        id: 'editor',\n        title: 'ace',\n        listeners: { resize: function () { if (editor) editor.resize(); } }\n      }\n    ],\n    listeners: {\n      afterrender: {\n        scope: this,\n        fn: function (obj) { setupEditor(obj.body.dom); getInitialState() }\n      }\n    },\n    buttons: [\n      {text: 'Update (doesn\\'t save)', handler: updateAfterEdit},\n      {text: 'Cancel', handler: function () { editDashboardWin.close(); } }\n    ]\n  });\n  function updateAfterEdit(btn, target) {\n    var graphString = editor.getSession().getValue();\n    var targets = JSON.parse(graphString);\n    graphStore.removeAll();\n    var graphs = [];\n    for (var i = 0; i < targets.length; i++) {\n      var myParams = {};\n      Ext.apply(myParams, targets[i]);\n      var urlParams = {};\n      Ext.apply(urlParams, defaultGraphParams);\n      Ext.apply(urlParams, GraphSize);\n      Ext.apply(urlParams, myParams);\n      graphs.push([\n        Ext.urlEncode({target: targets[i].target}),\n        myParams,\n        document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams)\n      ]);\n    }\n    graphStore.loadData(graphs);\n    refreshGraphs();\n    editDashboardWin.close();\n  }\n  function getInitialState() {\n    var graphs = [];\n    graphStore.each(function () {\n      var params = {};\n      Ext.apply(params, this.data.params);\n      delete params['from'];\n      delete params['until'];\n      graphs.push(params);\n    });\n    editor.getSession().setValue(JSON.stringify(graphs, null, 2));\n  }\n  function setupEditor(obj) {\n    editor = ace.edit('editor');\n    editor.setTheme('ace/theme/textmate');\n    var JSONMode = require('ace/mode/json').Mode;\n    var session = editor.getSession();\n    session.setMode(new JSONMode());\n    session.setUseSoftTabs(true);\n    session.setTabSize(2);\n  }\n  editDashboardWin.show();\n}\n\nfunction saveDashboard() {\n  Ext.Msg.prompt(\n    'Save Dashboard',\n    'Enter the name to save this dashboard as',\n    function (button, text) {\n      if (button == 'ok') {\n        setDashboardName(text);\n        sendSaveRequest(text);\n      }\n    },\n    this,\n    false,\n    (dashboardName) ? dashboardName : ''\n  );\n}\n\nfunction saveTemplate() {\n  var nameField = new Ext.form.TextField({\n    id: 'dashboard-save-template-name',\n    fieldLabel: 'Template Name',\n    width: 240,\n    allowBlank: false,\n    align: 'center',\n    value: dashboardName ? dashboardName.split('/')[0]: '',\n  });\n\n  var keyField = new Ext.form.TextField({\n    id: 'dashboard-save-template-key',\n    fieldLabel: 'String to replace',\n    width: 240,\n    allowBlank: false,\n    align: 'center',\n  });\n\n  var win;\n\n  function save() {\n    sendSaveTemplateRequest(nameField.getValue(), keyField.getValue());\n    win.close();\n  }\n\n  win = new Ext.Window({\n    title: 'Save dashboard as a template',\n    width: 400,\n    height: 120,\n    resizable: false,\n    layout: 'form',\n    labelAlign: 'right',\n    labelWidth: 120,\n    items: [nameField,keyField],\n    buttonAlign: 'center',\n    buttons: [\n      {text: 'Ok', handler: save},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n  win.show();\n}\n\nfunction sendSaveTemplateRequest(name, key) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/save_template/' + name + '/' + key,\n    method: 'POST',\n    params: {\n      state: Ext.encode( getState() )\n    },\n    success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error', htmlEncode('There was an error saving this dashboard as a template: ' + result.error));\n               }\n             },\n    failure: failedAjaxCall\n  });\n}\n\nfunction sendSaveRequest(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/save/' + name,\n    method: 'POST',\n    params: {\n      state: Ext.encode( getState() )\n    },\n    success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error', htmlEncode('There was an error saving this dashboard: ' + result.error));\n               }\n               if(newURL) {\n                 window.location = newURL;\n               } else {\n                 changeHash(name);\n               }\n             },\n    failure: failedAjaxCall\n  });\n}\n\nfunction sendLoadRequest(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/load/' + name,\n    success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error Loading Dashboard', htmlEncode(result.error));\n               } else {\n                 applyState(result.state);\n                 navBar.collapse(false);\n               }\n             },\n    failure: failedAjaxCall\n  });\n}\n\nfunction sendLoadTemplateRequest(name, value) {\n  var urlparts = window.location.href.split('#')\n  if(urlparts[0].split('?')[1]) {\n    var newLocation = urlparts[0].split('?')[0] + '#'+name+'/'+value;\n    window.location.href = newLocation;\n  } else {\n    Ext.Ajax.request({\n      url: document.body.dataset.baseUrl + 'dashboard/load_template/' + name + '/' + value,\n      success: function (response) {\n               var result = Ext.decode(response.responseText);\n               if (result.error) {\n                 Ext.Msg.alert('Error Loading Template', htmlEncode(result.error));\n               } else {\n                 applyState(result.state);\n                 navBar.collapse(false);\n               }\n             },\n      failure: failedAjaxCall\n    });\n  }\n}\n\nfunction getState() {\n  var graphs = [];\n  graphStore.each(\n    function (record) {\n      graphs.push([\n        record.data.id,\n        record.data.target,\n        record.data.params,\n        record.data.url\n      ]);\n    }\n  );\n\n  return {\n    name: dashboardName,\n    timeConfig: TimeRange,\n    refreshConfig: {\n      enabled: Ext.getCmp('auto-refresh-button').pressed,\n      interval: refreshTask.interval\n    },\n    graphSize: GraphSize,\n    defaultGraphParams: defaultGraphParams,\n    graphs: graphs\n  };\n}\n\nfunction applyState(state) {\n  setDashboardName(state.name);\n\n  //state.timeConfig = {type, quantity, units, untilQuantity, untilUnits, startDate, startTime, endDate, endTime}\n  var timeConfig = state.timeConfig\n  TimeRange.type = timeConfig.type;\n  TimeRange.relativeStartQuantity = timeConfig.relativeStartQuantity;\n  TimeRange.relativeStartUnits = timeConfig.relativeStartUnits;\n  TimeRange.relativeUntilQuantity = timeConfig.relativeUntilQuantity;\n  TimeRange.relativeUntilUnits = timeConfig.relativeUntilUnits;\n  TimeRange.startDate = new Date(timeConfig.startDate);\n  TimeRange.startTime = timeConfig.startTime;\n  TimeRange.endDate = new Date(timeConfig.endDate);\n  TimeRange.endTime = timeConfig.endTime;\n\n  if (queryString.from && queryString.until) {\n    // The URL contains a \"from\" and \"until\" parameters (format \"YYYY-MM-DDThh:mm:ss\") => use the timestamps as default absolute range of the dashboard\n    var from = new Date(queryString.from);\n    var until = new Date(queryString.until);\n\n    TimeRange.startDate = from;\n    TimeRange.startTime = from.format('H:m');\n    TimeRange.endDate = until;\n    TimeRange.endTime = until.format('H:m');\n    TimeRange.type = 'absolute';\n\n    state.timeConfig = TimeRange;\n\n    state.defaultGraphParams.from = from.format('H:i_Ymd');\n    state.defaultGraphParams.until = until.format('H:i_Ymd');\n  }\n\n  updateTimeText();\n\n\n\n  //state.refreshConfig = {enabled, interval}\n  var refreshConfig = state.refreshConfig;\n  if (refreshConfig.enabled) {\n    stopTask(refreshTask);\n    startTask(refreshTask);\n    Ext.getCmp('auto-refresh-button').toggle(true);\n  } else {\n    stopTask(refreshTask);\n    Ext.getCmp('auto-refresh-button').toggle(false);\n  }\n  //refreshTask.interval = refreshConfig.interval;\n  updateAutoRefresh(refreshConfig.interval / 1000);\n\n  //state.graphSize = {width, height}\n  var graphSize = state.graphSize;\n  GraphSize.width = graphSize.width;\n  GraphSize.height = graphSize.height;\n\n  //state.defaultGraphParams = {...}\n  defaultGraphParams = state.defaultGraphParams || originalDefaultGraphParams;\n\n  //state.graphs = [ [id, target, params, url], ... ]\n  //Fix url param to be correct for this document.body.dataset.baseUrl\n  var graphs = [];\n  for (var i = 0; i < state.graphs.length; i++) {\n    var myParams = {};\n    var renderType = state.graphs[i][3];\n    Ext.apply(myParams, state.graphs[i][1]);\n    var urlParams = {};\n    Ext.apply(urlParams, defaultGraphParams);\n    Ext.apply(urlParams, GraphSize);\n    Ext.apply(urlParams, myParams);\n    graphs.push([\n      state.graphs[i][0],\n      myParams,\n      document.body.dataset.baseUrl + 'render?' + Ext.urlEncode(urlParams),\n      renderType\n    ]);\n  }\n  graphStore.loadData(graphs);\n\n  refreshGraphs();\n}\n\nfunction deleteDashboard(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/delete/' + name,\n    success: function (response) {\n      var result = Ext.decode(response.responseText);\n      if (result.error) {\n        Ext.Msg.alert('Error', htmlEncode('Failed to delete dashboard \\'' + name + '\\': ' + result.error));\n      } else {\n        Ext.Msg.alert('Dashboard Deleted', htmlEncode('The ' + name + ' dashboard was deleted successfully.'));\n      }\n    },\n    failure: failedAjaxCall\n  });\n}\n\nfunction deleteTemplate(name) {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/delete_template/' + name,\n    success: function (response) {\n      var result = Ext.decode(response.responseText);\n      if (result.error) {\n        Ext.Msg.alert('Error', htmlEncode('Failed to delete template \\'' + name + '\\': ' + result.error));\n      } else {\n        Ext.Msg.alert('Template Deleted', htmlEncode('The ' + name + ' template was deleted successfully.'));\n      }\n    },\n    failure: failedAjaxCall\n  });\n}\n\nfunction setDashboardName(name) {\n  dashboardName = name;\n  var saveButton = Ext.getCmp('dashboard-save-button');\n\n  if (name == null || !hasPermission('change')) {\n    dashboardURL = null;\n    document.title = 'untitled - Graphite Dashboard';\n    navBar.setTitle('untitled');\n    saveButton.setText('Save');\n    saveButton.disable();\n  } else {\n    var urlparts = location.href.split('#')[0].split('/');\n    var i = urlparts.indexOf('dashboard');\n    if (i == -1) {\n      Ext.Msg.alert('Error', htmlEncode('urlparts = ' + Ext.encode(urlparts) + ' and indexOf(dashboard) = ' + i));\n      return;\n    }\n    urlparts = urlparts.slice(0, i+1);\n    urlparts.push( encodeURI(name) )\n    dashboardURL = urlparts.join('/');\n\n    document.title = name + ' - Graphite Dashboard';\n    changeHash(name);\n    navBar.setTitle(htmlEncode(name + ' - (' + dashboardURL + ')'));\n    saveButton.setText(htmlEncode('Save \"' + name + '\"'));\n    saveButton.enable();\n  }\n}\n\nfunction failedAjaxCall(response, options) {\n  Ext.Msg.alert(\n    'Ajax Error',\n    htmlEncode('Ajax call failed, response was :' + response.responseText)\n  );\n}\n\nvar configureUIWin;\nfunction configureUI() {\n\n  if (configureUIWin) {\n    configureUIWin.close();\n  }\n\n  function updateOrientation() {\n    if (Ext.getCmp('navbar-left-radio').getValue()) {\n      updateNavBar('west');\n    } else {\n      updateNavBar('north');\n    }\n    configureUIWin.close();\n    configureUIWin = null;\n  }\n\n  configureUIWin = new Ext.Window({\n    title: 'Configure UI',\n    layout: 'form',\n    width: 300,\n    height: 125,\n    labelWidth: 120,\n    labelAlign: 'right',\n    items: [\n      {\n        id: 'navbar-left-radio',\n        xtype: 'radio',\n        fieldLabel: 'Navigation Mode',\n        boxLabel: 'Tree (left nav)',\n        name: 'navbar-position',\n        inputValue: 'left',\n        checked: (NAV_BAR_REGION == 'west')\n      }, {\n        id: 'navbar-top-radio',\n        xtype: 'radio',\n        fieldLabel: '',\n        boxLabel: 'Completer (top nav)',\n        name: 'navbar-position',\n        inputValue: 'top',\n        checked: (NAV_BAR_REGION == 'north')\n      }\n    ],\n    buttons: [\n      {text: 'Ok', handler: updateOrientation},\n      {text: 'Cancel', handler: function () { configureUIWin.close(); configureUIWin = null; } }\n    ]\n  });\n  configureUIWin.show();\n}\n\nfunction updateNavBar(region) {\n  if (region == NAV_BAR_REGION) {\n    return;\n  }\n\n  cookieProvider.set('navbar-region', region);\n  NAV_BAR_REGION = region;\n\n  if (graphStore.getCount() == 0) {\n    window.location.reload()\n  } else {\n    Ext.Msg.alert('Cookie Updated', 'You must refresh the page to update the nav bar\\'s location.');\n    //TODO prompt the user to save their dashboard and refresh for them\n  }\n}\n\n// Dashboard Finder\nfunction showDashboardFinder() {\n  var win;\n  var dashboardsList;\n  var queryField;\n  var dashboardsStore = new Ext.data.JsonStore({\n    url: document.body.dataset.baseUrl + 'dashboard/find/',\n    method: 'GET',\n    params: {query: 'e'},\n    fields: [{\n      name: 'name',\n      sortType: function(value) {\n        // Make sorting case-insensitive\n        return value.toLowerCase();\n      }\n    }],\n    root: 'dashboards',\n    sortInfo: {\n      field: 'name',\n      direction: 'ASC'\n    },\n    listeners: {\n      beforeload: function (store) {\n                    store.setBaseParam('query', queryField.getValue());\n      }\n    }\n  });\n\n  function openSelected() {\n    var selected = dashboardsList.getSelectedRecords();\n    if (selected.length > 0) {\n      sendLoadRequest(selected[0].data.name);\n    }\n    win.close();\n  }\n\n  function deleteSelected() {\n    var selected = dashboardsList.getSelectedRecords();\n    if (selected.length > 0) {\n      var record = selected[0];\n      var name = record.data.name;\n\n      Ext.Msg.confirm(\n       'Delete Dashboard',\n        htmlEncode('Are you sure you want to delete the ' + name + ' dashboard?'),\n        function (button) {\n          if (button == 'yes') {\n            deleteDashboard(name);\n            dashboardsStore.remove(record);\n            dashboardsList.refresh();\n          }\n        }\n      );\n    }\n  }\n\n  dashboardsList = new Ext.list.ListView({\n    columns: [\n      {header: 'Dashboard', width: 1.0, dataIndex: 'name', sortable: false, tpl:'{name:htmlEncode}'}\n    ],\n    columnSort: false,\n    emptyText: 'No dashboards found',\n    hideHeaders: true,\n    listeners: {\n      selectionchange: function (listView, selections) {\n                         if (listView.getSelectedRecords().length == 0) {\n                           Ext.getCmp('finder-open-button').disable();\n                           Ext.getCmp('finder-delete-button').disable();\n                         } else {\n                           Ext.getCmp('finder-open-button').enable();\n                           if (hasPermission('delete')) {\n                             Ext.getCmp('finder-delete-button').enable();\n                           } else {\n                             Ext.getCmp('finder-delete-button').disable();\n                           }\n                         }\n                       },\n\n      dblclick: function (listView, index, node, e) {\n                  var record = dashboardsStore.getAt(index);\n                  sendLoadRequest(record.data.name);\n                  win.close();\n                }\n    },\n    overClass: '',\n    region: 'center',\n    reserveScrollOffset: true,\n    singleSelect: true,\n    store: dashboardsStore,\n    style: 'background-color: white;'\n  });\n\n  var lastQuery = null;\n  var queryUpdateTask = new Ext.util.DelayedTask(\n    function () {\n      var currentQuery = queryField.getValue();\n      if (lastQuery != currentQuery) {\n        dashboardsStore.load();\n      }\n      lastQuery = currentQuery;\n    }\n  );\n\n  queryField = new Ext.form.TextField({\n    region: 'south',\n    emptyText: 'filter dashboard listing',\n    enableKeyEvents: true,\n    listeners: {\n      keyup: function (field, e) {\n                  if (e.getKey() == e.ENTER) {\n                    sendLoadRequest(field.getValue());\n                    win.close();\n                  } else {\n                    queryUpdateTask.delay(FINDER_QUERY_DELAY);\n                  }\n                }\n    }\n  });\n\n  win = new Ext.Window({\n    title: 'Dashboard Finder',\n    width: 400,\n    height: 500,\n    layout: 'border',\n    modal: true,\n    items: [\n      dashboardsList,\n      queryField\n    ],\n    buttons: [\n      {\n        id: 'finder-open-button',\n        text: 'Open',\n        disabled: true,\n        handler: openSelected\n      }, {\n        id: 'finder-delete-button',\n        text: 'Delete',\n        disabled: true,\n        handler: deleteSelected\n      }, {\n        text: 'Close',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  dashboardsStore.load();\n  win.show();\n}\n\n// Template Finder\nfunction showTemplateFinder() {\n  var win;\n  var templatesList;\n  var queryField;\n  var valueField;\n  var templatesStore = new Ext.data.JsonStore({\n    url: document.body.dataset.baseUrl + 'dashboard/find_template/',\n    method: 'GET',\n    params: {query: 'e'},\n    fields: ['name'],\n    root: 'templates',\n    listeners: {\n      beforeload: function (store) {\n                    store.setBaseParam('query', queryField.getValue());\n                  }\n    }\n  });\n\n  function openSelected() {\n    var selected = templatesList.getSelectedRecords();\n    if (selected.length > 0) {\n      sendLoadTemplateRequest(selected[0].data.name, valueField.getValue());\n    }\n    win.close();\n  }\n\n  function deleteSelected() {\n    var selected = templatesList.getSelectedRecords();\n    if (selected.length > 0) {\n      var record = selected[0];\n      var name = record.data.name;\n\n      Ext.Msg.confirm(\n        'Delete Template',\n        htmlEncode('Are you sure you want to delete the ' + name + ' template?'),\n        function (button) {\n          if (button == 'yes') {\n            deleteTemplate(name);\n            templatesStore.remove(record);\n            templatesList.refresh();\n          }\n        }\n      );\n    }\n  }\n\n  templatesList = new Ext.list.ListView({\n    columns: [\n      {header: 'Template', width: 1.0, dataIndex: 'name', sortable: false}\n    ],\n    columnSort: false,\n    emptyText: 'No templates found',\n    hideHeaders: true,\n    listeners: {\n      selectionchange: function (listView, selections) {\n                         if (listView.getSelectedRecords().length == 0) {\n                           Ext.getCmp('finder-open-button').disable();\n                           Ext.getCmp('finder-delete-button').disable();\n                         } else {\n                           if (valueField.getValue()) {\n                             Ext.getCmp('finder-open-button').enable();\n                           }\n                           Ext.getCmp('finder-delete-button').enable();\n                         }\n                       },\n\n    },\n    overClass: '',\n    region: 'center',\n    reserveScrollOffset: true,\n    singleSelect: true,\n    store: templatesStore,\n    style: 'background-color: white;'\n  });\n\n  var lastQuery = null;\n  var queryUpdateTask = new Ext.util.DelayedTask(\n    function () {\n      var currentQuery = queryField.getValue();\n      if (lastQuery != currentQuery) {\n        templatesStore.load();\n      }\n      lastQuery = currentQuery;\n    }\n  );\n\n  queryField = new Ext.form.TextField({\n    region: 'south',\n    emptyText: 'filter template listing',\n    enableKeyEvents: true,\n    listeners: {\n      keyup: function (field, e) {\n                  if (e.getKey() == e.ENTER) {\n                    sendLoadRequest(field.getValue(), reset_params=true);\n                    win.close();\n                  } else {\n                    queryUpdateTask.delay(FINDER_QUERY_DELAY);\n                  }\n                }\n    }\n  });\n\n  valueField = new Ext.form.TextField({\n    region: 'north',\n    emptyText: 'Value to use'\n  });\n\n  win = new Ext.Window({\n    title: 'Template Finder',\n    width: 400,\n    height: 500,\n    layout: 'border',\n    modal: true,\n    items: [\n      valueField,\n      templatesList,\n      queryField,\n    ],\n    buttons: [\n      {\n        id: 'finder-open-button',\n        text: 'Open',\n        disabled: true,\n        handler: openSelected\n      }, {\n        id: 'finder-delete-button',\n        text: 'Delete',\n        disabled: true,\n        handler: deleteSelected\n      }, {\n        text: 'Close',\n        handler: function () { win.close(); }\n      }\n    ]\n  });\n  templatesStore.load();\n  win.show();\n}\n\n/* Graph Options API (to reuse createOptionsMenu from composer_widgets.js) */\nfunction updateGraph() {\n  refreshGraphs();\n  var graphMenuParams = Ext.getCmp('graphMenuParams');\n  if (graphMenuParams) {\n    var editParams = Ext.apply({}, selectedRecord.data.params);\n    removeUneditable(editParams);\n    graphMenuParams.setValue( Ext.urlEncode(editParams) );\n  }\n}\n\nfunction getParam(param) {\n  return selectedRecord.data.params[param];\n}\n\nfunction setParam(param, value) {\n  selectedRecord.data.params[param] = value;\n  selectedRecord.commit();\n}\n\nfunction removeParam(param) {\n  delete selectedRecord.data.params[param];\n  selectedRecord.commit();\n}\n\n\nfunction removeTargetFromSelectedGraph(target) {\n  selectedRecord.data.params.target.remove(target);\n  selectedRecord.data.target = Ext.urlEncode({target: selectedRecord.data.params.target});\n}\n\nfunction getSelectedTargets() {\n  if (targetGrid) {\n    return map(targetGrid.getSelectionModel().getSelections(), function (r) {\n      return r.data.target;\n    });\n  }\n  return [];\n}\n\nfunction applyFuncToEach(funcName, extraArg) {\n\n  function applyFunc() {\n    Ext.each(targetGrid.getSelectionModel().getSelections(),\n      function (record) {\n        var target = record.data.target;\n        var newTarget;\n        var targetStore = targetGrid.getStore();\n\n        targetStore.remove(record);\n        removeTargetFromSelectedGraph(target);\n\n        if (extraArg) {\n          newTarget = funcName + '(' + target + ',' + extraArg + ')';\n        } else {\n          newTarget = funcName + '(' + target + ')';\n        }\n\n        // Add newTarget to selectedRecord\n        targetStore.add([ new targetStore.recordType({target: newTarget}, newTarget) ]);\n        targetGrid.getSelectionModel().selectRow(targetStore.findExact('target', newTarget), true);\n      }\n    );\n    refreshGraphs();\n  }\n  return applyFunc;\n}\n\nfunction applyFuncToEachWithInput (funcName, question, options) {\n  if (options == null) {\n    options = {};\n  }\n\n function applyFunc() {\n    Ext.MessageBox.prompt(\n      'Input Required', //title\n      question, //message\n      function (button, inputValue) { //handler\n        if (button == 'ok' && (options.allowBlank || inputValue != '')) {\n          if (options.quote) {\n            inputValue = '\"' + inputValue + '\"';\n          }\n          applyFuncToEach(funcName, inputValue)();\n        }\n      },\n      this, //scope\n      false, //multiline\n      '' //initial value\n    );\n  }\n  applyFunc = applyFunc.createDelegate(this);\n  return applyFunc;\n}\n\nfunction applyFuncToAll (funcName) {\n  function applyFunc() {\n    var args = getSelectedTargets().join(',');\n    var newTarget = funcName + '(' + args + ')';\n    var targetStore = targetGrid.getStore();\n\n    Ext.each(targetGrid.getSelectionModel().getSelections(),\n      function (record) {\n        targetStore.remove(record);\n        removeTargetFromSelectedGraph(record.data.target);\n      }\n    );\n    targetStore.add([ new targetStore.recordType({target: newTarget}, newTarget) ]);\n    targetGrid.getSelectionModel().selectRow(targetStore.findExact('target', newTarget), true);\n    refreshGraphs();\n  }\n  applyFunc = applyFunc.createDelegate(this);\n  return applyFunc;\n}\n\nfunction removeOuterCall() { // blatantly repurposed from composer_widgets.js (don't hate)\n  Ext.each(targetGrid.getSelectionModel().getSelections(), function (record) {\n    var target = record.data.target;\n    var targetStore = targetGrid.getStore();\n    var args = [];\n    var i, c;\n    var lastArg = 0;\n    var depth = 0;\n    var argString = target.replace(/^[^(]+\\((.+)\\)/, '$1'); //First we strip it down to just args\n\n    for (i = 0; i < argString.length; i++) {\n      switch (argString.charAt(i)) {\n        case '(': depth += 1; break;\n        case '{': depth += 1; break;\n        case ')': depth -= 1; break;\n        case '}': depth -= 1; break;\n        case ',':\n          if (depth > 0) { continue; }\n          if (depth < 0) { Ext.Msg.alert('Malformed target, cannot remove outer call.'); return; }\n          args.push( argString.substring(lastArg, i).replace(/^\\s+/, '').replace(/\\s+$/, '') );\n          lastArg = i + 1;\n          break;\n      }\n    }\n    args.push( argString.substring(lastArg, i) );\n\n    targetStore.remove(record);\n    selectedRecord.data.params.target.remove(target);\n\n    Ext.each(args, function (arg) {\n      if (!arg.match(/^([0123456789\\.]+|\".+\")$/)) { //Skip string and number literals\n        targetStore.add([ new targetStore.recordType({target: arg}) ]);\n        targetGrid.getSelectionModel().selectRow(targetStore.findExact('target', arg), true);\n      }\n    });\n  });\n  refreshGraphs();\n}\n\nfunction saveDefaultGraphParams() {\n  cookieProvider.set('defaultGraphParams', Ext.encode(defaultGraphParams));\n}\n\n\n/* Cookie stuff */\nfunction getContextFieldCookie(field) {\n  return cookieProvider.get(field);\n}\n\nfunction setContextFieldCookie(field, value) {\n  cookieProvider.set(field, value);\n}\n\n/* Misc */\nfunction uniq(myArray) {\n  var uniqArray = [];\n  for (var i=0; i<myArray.length; i++) {\n    if (uniqArray.indexOf(myArray[i]) == -1) {\n      uniqArray.push(myArray[i]);\n    }\n  }\n  return uniqArray;\n}\n\nfunction map(myArray, myFunc) {\n  var results = [];\n  for (var i=0; i<myArray.length; i++) {\n    results.push( myFunc(myArray[i]) );\n  }\n  return results;\n}\n\nfunction getLoginMenuItemText() {\n  if (isLoggedIn()) {\n    return 'Log Out From \"' + userName + '\"';\n  } else {\n    return 'Log In';\n  }\n}\n\n/* After login/logout, make any necessary adjustments to Dashboard menu items (text and/or disabled) */\nfunction postLoginMenuAdjust() {\n  Ext.getCmp('dashboard-login-button').setText(getLoginMenuItemText());\n  Ext.getCmp('dashboard-save-button').setDisabled(dashboardName == null || !hasPermission('change'));\n  Ext.getCmp('dashboard-save-as-button').setDisabled(!hasPermission('change'));\n}\n\nfunction showLoginForm() {\n  var login = new Ext.FormPanel({\n    labelWidth: 80,\n    frame: true,\n    title: 'Please Login',\n    defaultType: 'textfield',\n    monitorValid: true,\n\n    items: [{\n        fieldLabel: 'Username',\n        name: 'username',\n        allowBlank: false,\n        listeners: {\n          afterrender: function(field) { field.focus(false, 100); }\n        }\n      },{\n        fieldLabel: 'Password',\n        name: 'password',\n        inputType: 'password',\n        allowBlank: false\n      }\n    ],\n    buttons: [\n      {text: 'Login', formBind: true, handler: doLogin},\n      {text: 'Cancel', handler: function () { win.close(); } }\n    ]\n  });\n\n  function doLogin() {\n    login.getForm().submit({\n      method: 'POST',\n      url: document.body.dataset.baseUrl + 'dashboard/login',\n      waitMsg: 'Authenticating...',\n      success: function(form, action) {\n        userName = form.findField('username').getValue();\n        permissions = action.result.permissions;\n        postLoginMenuAdjust();\n        win.close();\n      },\n      failure: function(form, action) {\n        if (action.failureType == 'server') {\n          var obj = Ext.util.JSON.decode(action.response.responseText);\n          Ext.Msg.alert('Login Failed!', htmlEncode(obj.errors.reason));\n        } else {\n          Ext.Msg.alert('Warning!', htmlEncode('Authentication server is unreachable : ' + action.response.responseText));\n        }\n        login.getForm().reset();\n      }\n    });\n  }\n\n  var win = new Ext.Window({\n    layout: 'fit',\n    width: 300,\n    height: 150,\n    closable: false,\n    resizable: false,\n    plain: true,\n    border: false,\n    items: [login]\n  });\n  win.show();\n}\n\nfunction logout() {\n  Ext.Ajax.request({\n    url: document.body.dataset.baseUrl + 'dashboard/logout',\n    method: 'POST',\n    success: function() {\n      userName = null;\n      permissions = permissionsUnauthenticated;\n      postLoginMenuAdjust();\n    },\n    failure: function() {\n      // Probably because they no longer have a valid session - assume they're now logged out\n      userName = null;\n      permissions = permissionsUnauthenticated;\n      postLoginMenuAdjust();\n    }\n  });\n}\n", "import re\nimport errno\n\nfrom os.path import getmtime\nfrom six.moves.urllib.parse import urlencode\nfrom six.moves.configparser import ConfigParser\nfrom django.shortcuts import render\nfrom django.http import QueryDict\nfrom django.conf import settings\nfrom django.contrib.auth import login, authenticate, logout\nfrom django.contrib.staticfiles import finders\nfrom django.utils.safestring import mark_safe\nfrom graphite.compat import HttpResponse\nfrom graphite.dashboard.models import Dashboard, Template\nfrom graphite.dashboard.send_graph import send_graph_email\nfrom graphite.render.views import renderView\nfrom graphite.util import json\nfrom graphite.user_util import isAuthenticated\nfrom graphite.errors import handleInputParameterError, str_param\n\nfieldRegex = re.compile(r'<([^>]+)>')\ndefaultScheme = {\n  'name' : 'Everything',\n  'pattern' : '<category>',\n  'fields' : [ dict(name='category', label='Category') ],\n}\ndefaultUIConfig = {\n  'default_graph_width'  : 400,\n  'default_graph_height' : 250,\n  'refresh_interval'     :  60,\n  'autocomplete_delay'   : 375,\n  'merge_hover_delay'    : 700,\n  'theme'                : 'default',\n}\ndefaultKeyboardShortcuts = {\n  'toggle_toolbar' : 'ctrl-z',\n  'toggle_metrics_panel' : 'ctrl-space',\n  'erase_all_graphs' : 'alt-x',\n  'save_dashboard' : 'alt-s',\n  'completer_add_metrics' : 'alt-enter',\n  'completer_del_metrics' : 'alt-backspace',\n  'give_completer_focus' : 'shift-space',\n}\n\nALL_PERMISSIONS = ['change', 'delete']\n\n\nclass DashboardConfig:\n  def __init__(self):\n    self.last_read = 0\n    self.schemes = [defaultScheme]\n    self.ui_config = defaultUIConfig.copy()\n\n  def check(self):\n    if getmtime(settings.DASHBOARD_CONF) > self.last_read:\n      self.load()\n\n  def load(self):\n    schemes = [defaultScheme]\n    parser = ConfigParser()\n    parser.read(settings.DASHBOARD_CONF)\n\n    for option, default_value in defaultUIConfig.items():\n      if parser.has_option('ui', option):\n        try:\n          self.ui_config[option] = parser.getint('ui', option)\n        except ValueError:\n          self.ui_config[option] = parser.get('ui', option)\n      else:\n        self.ui_config[option] = default_value\n\n    if parser.has_option('ui', 'automatic_variants'):\n      self.ui_config['automatic_variants']   = parser.getboolean('ui', 'automatic_variants')\n    else:\n      self.ui_config['automatic_variants'] = True\n\n    self.ui_config['keyboard_shortcuts'] = defaultKeyboardShortcuts.copy()\n    if parser.has_section('keyboard-shortcuts'):\n      self.ui_config['keyboard_shortcuts'].update( parser.items('keyboard-shortcuts') )\n\n    for section in parser.sections():\n      if section in ('ui', 'keyboard-shortcuts'):\n        continue\n\n      scheme = parser.get(section, 'scheme')\n      fields = []\n\n      for match in fieldRegex.finditer(scheme):\n        field = match.group(1)\n        if parser.has_option(section, '%s.label' % field):\n          label = parser.get(section, '%s.label' % field)\n        else:\n          label = field\n\n        fields.append({\n          'name' : field,\n          'label' : label\n        })\n\n      schemes.append({\n        'name' : section,\n        'pattern' : scheme,\n        'fields' : fields,\n      })\n\n    self.schemes = schemes\n\n\nconfig = DashboardConfig()\n\n\n@handleInputParameterError\ndef dashboard(request, name=None):\n  name = str_param('name', name)\n  dashboard_conf_missing = False\n\n  try:\n    config.check()\n  except OSError as e:\n    if e.errno == errno.ENOENT:\n      dashboard_conf_missing = True\n    else:\n      raise\n\n  initialError = None\n  debug = request.GET.get('debug', False)\n  theme = request.GET.get('theme', config.ui_config['theme'])\n  css_file = finders.find('css/dashboard-%s.css' % theme)\n  if css_file is None:\n    initialError = \"Invalid theme '%s'\" % theme\n    theme = config.ui_config['theme']\n\n  context = {\n    'schemes_json': mark_safe(json.dumps(config.schemes)),\n    'ui_config_json': mark_safe(json.dumps(config.ui_config)),\n    'jsdebug': debug or settings.JAVASCRIPT_DEBUG,\n    'debug': debug,\n    'theme': theme,\n    'initialError': initialError,\n    'querystring': mark_safe(json.dumps(dict(request.GET.items()))),\n    'dashboard_conf_missing': dashboard_conf_missing,\n    'userName': '',\n    'permissions': mark_safe(json.dumps(getPermissions(request.user))),\n    'permissionsUnauthenticated': mark_safe(json.dumps(getPermissions(None)))\n  }\n  user = request.user\n  if user:\n      context['userName'] = user.username\n\n  if name is not None:\n    try:\n      dashboard = Dashboard.objects.get(name=name)\n    except Dashboard.DoesNotExist:\n      context['initialError'] = \"Dashboard '%s' does not exist.\" % name\n    else:\n      context['initialState'] = dashboard.state\n\n  return render(request, \"dashboard.html\", context)\n\n\n@handleInputParameterError\ndef template(request, name, val):\n  name = str_param('name', name)\n  template_conf_missing = False\n\n  try:\n    config.check()\n  except OSError as e:\n    if e.errno == errno.ENOENT:\n      template_conf_missing = True\n    else:\n      raise\n\n  initialError = None\n  debug = request.GET.get('debug', False)\n  theme = request.GET.get('theme', config.ui_config['theme'])\n  css_file = finders.find('css/dashboard-%s.css' % theme)\n  if css_file is None:\n    initialError = \"Invalid theme '%s'\" % theme\n    theme = config.ui_config['theme']\n\n  context = {\n    'schemes_json' : json.dumps(config.schemes),\n    'ui_config_json' : json.dumps(config.ui_config),\n    'jsdebug' : debug or settings.JAVASCRIPT_DEBUG,\n    'debug' : debug,\n    'theme' : theme,\n    'initialError' : initialError,\n    'querystring' : json.dumps( dict( request.GET.items() ) ),\n    'template_conf_missing' : template_conf_missing,\n    'userName': '',\n    'permissions': json.dumps(getPermissions(request.user)),\n    'permissionsUnauthenticated': json.dumps(getPermissions(None))\n  }\n\n  user = request.user\n  if user:\n      context['userName'] = user.username\n\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    context['initialError'] = \"Template '%s' does not exist.\" % name\n  else:\n    state = json.loads(template.loadState(val))\n    state['name'] = '%s/%s' % (name, val)\n    context['initialState'] = json.dumps(state)\n  return render(request, \"dashboard.html\", context)\n\n\ndef getPermissions(user):\n  \"\"\"Return [change, delete] based on authorisation model and user privileges/groups\"\"\"\n  if user and not isAuthenticated(user):\n    user = None\n  if not settings.DASHBOARD_REQUIRE_AUTHENTICATION:\n    return ALL_PERMISSIONS      # don't require login\n  if not user:\n      return []\n  # from here on, we have a user\n  permissions = ALL_PERMISSIONS\n  if settings.DASHBOARD_REQUIRE_PERMISSIONS:\n    permissions = [permission for permission in ALL_PERMISSIONS if user.has_perm('dashboard.%s_dashboard' % permission)]\n  editGroup = settings.DASHBOARD_REQUIRE_EDIT_GROUP\n  if editGroup and len(user.groups.filter(name = editGroup)) == 0:\n    permissions = []\n  return permissions\n\n\n@handleInputParameterError\ndef save(request, name):\n  name = str_param('name', name)\n\n  if 'change' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to save\") )\n  # Deserialize and reserialize as a validation step\n  state = str( json.dumps( json.loads( request.POST['state'] ) ) )\n\n  try:\n    dashboard = Dashboard.objects.get(name=name)\n  except Dashboard.DoesNotExist:\n    dashboard = Dashboard.objects.create(name=name, state=state)\n  else:\n    dashboard.state = state\n    dashboard.save()\n\n  return json_response( dict(success=True) )\n\n\n@handleInputParameterError\ndef save_template(request, name, key):\n  name = str_param('name', name)\n  key = str_param('key', key)\n\n  if 'change' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to save the template\") )\n  # Deserialize and reserialize as a validation step\n  state = str( json.dumps( json.loads( request.POST['state'] ) ) )\n\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    template = Template.objects.create(name=name)\n    template.setState(state, key)\n    template.save()\n  else:\n    template.setState(state, key)\n    template.save()\n\n  return json_response( dict(success=True) )\n\n\n@handleInputParameterError\ndef load(request, name):\n  name = str_param('name', name)\n  try:\n    dashboard = Dashboard.objects.get(name=name)\n  except Dashboard.DoesNotExist:\n    return json_response( dict(error=\"Dashboard '%s' does not exist. \" % name) )\n\n  return json_response( dict(state=json.loads(dashboard.state)) )\n\n\n@handleInputParameterError\ndef load_template(request, name, val):\n  name = str_param('name', name)\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    return json_response( dict(error=\"Template '%s' does not exist. \" % name) )\n\n  state = json.loads(template.loadState(val))\n  state['name'] = '%s/%s' % (name, val)\n  return json_response( dict(state=state) )\n\n\n@handleInputParameterError\ndef delete(request, name):\n  name = str_param('name', name)\n  if 'delete' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to delete\") )\n\n  try:\n    dashboard = Dashboard.objects.get(name=name)\n  except Dashboard.DoesNotExist:\n    return json_response( dict(error=\"Dashboard '%s' does not exist. \" % name) )\n  else:\n    dashboard.delete()\n    return json_response( dict(success=True) )\n\n\n@handleInputParameterError\ndef delete_template(request, name):\n  name = str_param('name', name)\n  if 'delete' not in getPermissions(request.user):\n    return json_response( dict(error=\"Must be logged in with appropriate permissions to delete the template\") )\n\n  try:\n    template = Template.objects.get(name=name)\n  except Template.DoesNotExist:\n    return json_response( dict(error=\"Template '%s' does not exist. \" % name) )\n  else:\n    template.delete()\n    return json_response( dict(success=True) )\n\n\ndef find(request):\n  queryParams = request.GET.copy()\n  queryParams.update(request.POST)\n\n  query = queryParams.get('query', False)\n  query_terms = set( query.lower().split() )\n  results = []\n\n  # Find all dashboard names that contain each of our query terms as a substring\n  for dashboard_name in Dashboard.objects.order_by('name').values_list('name', flat=True):\n    name = dashboard_name.lower()\n\n    if name.startswith('temporary-'):\n      continue\n\n    found = True # blank queries return everything\n    for term in query_terms:\n      if term in name:\n        found = True\n      else:\n        found = False\n        break\n\n    if found:\n      results.append( dict(name=dashboard_name) )\n\n  return json_response( dict(dashboards=results) )\n\n\ndef find_template(request):\n  queryParams = request.GET.copy()\n  queryParams.update(request.POST)\n\n  query = queryParams.get('query', False)\n  query_terms = set( query.lower().split() )\n  results = []\n\n  # Find all dashboard names that contain each of our query terms as a substring\n  for template in Template.objects.all():\n    name = template.name.lower()\n\n    found = True # blank queries return everything\n    for term in query_terms:\n      if term in name:\n        found = True\n      else:\n        found = False\n        break\n\n    if found:\n      results.append( dict(name=template.name) )\n\n  return json_response( dict(templates=results) )\n\n\ndef help(request):\n  context = {}\n  return render(request, \"dashboardHelp.html\", context)\n\n\ndef email(request):\n    sender = request.POST['sender']\n    recipients = request.POST['recipients'].split()\n    subject = request.POST['subject']\n    message = request.POST['message']\n\n    # these need to be passed to the render function in an HTTP request.\n    graph_params = json.loads(request.POST['graph_params'], parse_int=str)\n    target = QueryDict(urlencode({'target': graph_params.pop('target')}))\n    graph_params = QueryDict(urlencode(graph_params))\n\n    new_post = request.POST.copy()\n    new_post.update(graph_params)\n    new_post.update(target)\n    request.POST = new_post\n\n    resp = renderView(request)\n    img = resp.content\n\n    if img:\n        attachments = [('graph.png', img, 'image/png')]\n        send_graph_email(subject, sender, recipients, attachments, message)\n\n    return json_response(dict(success=True))\n\n\ndef create_temporary(request):\n  state = str( json.dumps( json.loads( request.POST['state'] ) ) )\n  i = 0\n  while True:\n    name = \"temporary-%d\" % i\n    try:\n      Dashboard.objects.get(name=name)\n    except Dashboard.DoesNotExist:\n      dashboard = Dashboard.objects.create(name=name, state=state)\n      break\n    else:\n      i += 1\n\n  return json_response( dict(name=dashboard.name) )\n\n\ndef json_response(obj):\n  return HttpResponse(content_type='application/json', content=json.dumps(obj))\n\n\ndef user_login(request):\n  response = dict(errors={}, text={}, success=False, permissions=[])\n  user = authenticate(username=request.POST['username'],\n                      password=request.POST['password'])\n  if user is not None:\n    if user.is_active:\n      login(request, user)\n      response['success'] = True\n      response['permissions'].extend(getPermissions(user))\n    else:\n      response['errors']['reason'] = 'Account disabled.'\n  else:\n    response['errors']['reason'] = 'Username and/or password invalid.'\n  return json_response(response)\n\n\ndef user_logout(request):\n  response = dict(errors={}, text={}, success=True)\n  logout(request)\n  return json_response(response)\n", "from django.http import HttpResponseBadRequest\nfrom graphite.logger import log\nfrom graphite.util import htmlEscape, is_unsafe_str\n\n\nclass NormalizeEmptyResultError(Exception):\n    # throw error for normalize() when empty\n    pass\n\n\nclass InputParameterError(ValueError):\n\n    def __init__(self, *args, **kwargs):\n        super(InputParameterError, self).__init__(*args, **kwargs)\n        self.context = {}\n\n    def setSourceIdHeaders(self, newHeaders):\n        headers = self.context.get('sourceIdHeaders', {})\n        headers.update(newHeaders)\n        self.context['sourceIdHeaders'] = headers\n\n    @property\n    def sourceIdHeaders(self):\n        sourceIdHeaders = self.context.get('sourceIdHeaders', {})\n        headers = list(sourceIdHeaders.keys())\n        headers.sort()\n        source = ''\n\n        for name in headers:\n            if source:\n                source += ', '\n            source += '{name}: {value}'.format(\n                name=name,\n                value=sourceIdHeaders[name])\n\n        return source\n\n    def setTargets(self, targets):\n        self.context['targets'] = targets\n\n    @property\n    def targets(self):\n        return ', '.join(self.context.get('targets', []))\n\n    def setFunction(self, name, args, kwargs):\n        self.context['function'] = {\n            'name': name,\n            'args': args,\n            'kwargs': kwargs,\n        }\n\n    @property\n    def function(self):\n        func = self.context.get('function', None)\n        if not func:\n            return ''\n\n        funcName = func.get('name', '')\n        if not funcName:\n            return ''\n\n        kwargs = func.get('kwargs', {})\n        kwargKeys = list(kwargs.keys())\n\n        # keep kwargs sorted in message, for consistency and testability\n        kwargKeys.sort()\n\n        # generate string of args and kwargs\n        args = ', '.join(\n            argList\n            for argList in [\n                ', '.join(repr(arg) for arg in func.get('args', [])),\n                ', '.join('{k}={v}'.format(k=str(k), v=repr(kwargs[k])) for k in kwargKeys),\n            ] if argList\n        )\n\n        return '{func}({args})'.format(func=funcName, args=args)\n\n    def __str__(self):\n        msg = 'Invalid parameters ({msg})'.format(msg=str(super(InputParameterError, self).__str__()))\n        targets = self.targets\n        if targets:\n            msg += '; targets: \"{targets}\"'.format(targets=targets)\n\n        source = self.sourceIdHeaders\n        if source:\n            msg += '; source: \"{source}\"'.format(source=source)\n\n        # needs to be last because the string \"args\" may potentially be thousands\n        # of chars long after expanding the globbing patterns\n        func = self.function\n        if func:\n            msg += '; func: \"{func}\"'.format(func=func)\n\n        return msg\n\n\ndef safe_param(name, s):\n    if is_unsafe_str(s):\n        raise InputParameterError(\"{} contain unsafe symbols\".format(name))\n    return s\n\n\ndef is_unclean_str(s):\n    for symbol in '&<>~!@#$%^*()`':\n        if s.find(symbol) >= 0:\n            return True\n    return False\n\n\ndef str_param(name, s):\n    if s is not None and is_unclean_str(s):\n        raise InputParameterError(\"{} contain restricted symbols\".format(name))\n    return s\n\n\n# decorator which turns InputParameterExceptions into Django's HttpResponseBadRequest\ndef handleInputParameterError(f):\n    def new_f(*args, **kwargs):\n        try:\n            return f(*args, **kwargs)\n        except InputParameterError as e:\n            msgStr = str(e)\n            log.warning('%s', msgStr)\n            return HttpResponseBadRequest(htmlEscape(msgStr))\n\n    return new_f\n", "\"\"\"Copyright 2008 Orbitz WorldWide\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\"\"\"\n\nimport imp\nimport io\nimport json as _json\nimport socket\nimport time\nimport sys\nimport calendar\nimport pytz\nimport six\nimport traceback\n\nfrom datetime import datetime\nfrom functools import wraps\nfrom os.path import splitext, basename\n\nfrom django.conf import settings\nfrom django.utils.timezone import make_aware\n\nfrom graphite.compat import HttpResponse\nfrom graphite.logger import log\n\n# BytesIO is needed on py3 as StringIO does not operate on byte input anymore\n# We could use BytesIO on py2 as well but it is slower than StringIO\nif sys.version_info >= (3, 0):\n  PY3 = True\n  import pickle\n  from io import BytesIO\nelse:\n  PY3 = False\n  import cPickle as pickle\n  from cStringIO import StringIO as BytesIO\n\n# use https://github.com/msgpack/msgpack-python if available\ntry:\n  import msgpack  # NOQA\n# otherwise fall back to bundled https://github.com/vsergeev/u-msgpack-python\nexcept ImportError:\n  import graphite.umsgpack as msgpack  # NOQA\n\n\ndef epoch(dt):\n  \"\"\"\n  Returns the epoch timestamp of a timezone-aware datetime object.\n  \"\"\"\n  if not dt.tzinfo:\n    tb = traceback.extract_stack(None, 2)\n    log.warning('epoch() called with non-timezone-aware datetime in %s at %s:%d' % (tb[0][2], tb[0][0], tb[0][1]))\n    return calendar.timegm(make_aware(dt, pytz.timezone(settings.TIME_ZONE)).astimezone(pytz.utc).timetuple())\n  return calendar.timegm(dt.astimezone(pytz.utc).timetuple())\n\n\ndef epoch_to_dt(timestamp):\n    \"\"\"\n    Returns the timezone-aware datetime of an epoch timestamp.\n    \"\"\"\n    return make_aware(datetime.utcfromtimestamp(timestamp), pytz.utc)\n\n\ndef timebounds(requestContext):\n  startTime = int(epoch(requestContext['startTime']))\n  endTime = int(epoch(requestContext['endTime']))\n  now = int(epoch(requestContext['now']))\n\n  return (startTime, endTime, now)\n\n\ndef is_local_interface(host):\n  is_ipv6 = False\n  if ':' not in host:\n    pass\n  elif host.count(':') == 1:\n    host = host.split(':', 1)[0]\n  else:\n    is_ipv6 = True\n\n    if host.find('[', 0, 2) != -1:\n      last_bracket_position  = host.rfind(']')\n      last_colon_position = host.rfind(':')\n      if last_colon_position > last_bracket_position:\n        host = host.rsplit(':', 1)[0]\n      host = host.strip('[]')\n\n  try:\n    if is_ipv6:\n      sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n    else:\n      sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind( (host, 0) )\n  except socket.error:\n    return False\n  finally:\n    sock.close()\n\n  return True\n\n\ndef is_pattern(s):\n   return '*' in s or '?' in s or '[' in s or '{' in s\n\n\ndef is_escaped_pattern(s):\n  for symbol in '*?[{':\n    i = s.find(symbol)\n    if i > 0:\n      if s[i-1] == '\\\\':\n        return True\n  return False\n\n\ndef find_escaped_pattern_fields(pattern_string):\n  pattern_parts = pattern_string.split('.')\n  for index,part in enumerate(pattern_parts):\n    if is_escaped_pattern(part):\n      yield index\n\n\n# Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\ndef htmlEscape(s):\n    s = s.replace(\"&\", \"&amp;\")  # Must be done first!\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n    return s\n\n\ndef is_unsafe_str(s):\n    for symbol in '<>':\n        if s.find(symbol) >= 0:\n            return True\n    return False\n\n\ndef load_module(module_path, member=None):\n  module_name = splitext(basename(module_path))[0]\n  try:  # 'U' is default from Python 3.0 and deprecated since 3.9\n    module_file = open(module_path, 'U')\n  except ValueError:\n    module_file = open(module_path, 'rt')\n  description = ('.py', 'U', imp.PY_SOURCE)\n  module = imp.load_module(module_name, module_file, module_path, description)\n  if member:\n    return getattr(module, member)\n  else:\n    return module\n\n\ndef timestamp(dt):\n  \"Convert a datetime object into epoch time\"\n  return time.mktime(dt.timetuple())\n\n\ndef deltaseconds(timedelta):\n  \"Convert a timedelta object into seconds (same as timedelta.total_seconds() in Python 2.7+)\"\n  return (timedelta.microseconds + (timedelta.seconds + timedelta.days * 24 * 3600) * 10**6) / 10**6\n\n\n# This whole song & dance is due to pickle being insecure\n# The SafeUnpickler classes were largely derived from\n# http://nadiana.com/python-pickle-insecure\n# This code also lives in carbon.util\nif not PY3:\n  class SafeUnpickler(object):\n    PICKLE_SAFE = {\n      'copy_reg': set(['_reconstructor']),\n      '__builtin__': set(['object', 'list', 'set']),\n      'collections': set(['deque']),\n      'graphite.render.datalib': set(['TimeSeries', 'Tags']),\n      'graphite.intervals': set(['Interval', 'IntervalSet']),\n    }\n\n    @classmethod\n    def find_class(cls, module, name):\n      if module not in cls.PICKLE_SAFE:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe module %s' % module)\n      __import__(module)\n      mod = sys.modules[module]\n      if name not in cls.PICKLE_SAFE[module]:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe class %s' % name)\n      return getattr(mod, name)\n\n    @classmethod\n    def loads(cls, pickle_string):\n      pickle_obj = pickle.Unpickler(BytesIO(pickle_string))\n      pickle_obj.find_global = cls.find_class\n      return pickle_obj.load()\n\n    @classmethod\n    def load(cls, file):\n      pickle_obj = pickle.Unpickler(file)\n      pickle_obj.find_global = cls.find_class\n      return pickle_obj.load()\n\n  unpickle = SafeUnpickler\n\nelse:\n  class SafeUnpickler(pickle.Unpickler):\n    PICKLE_SAFE = {\n      'copy_reg': set(['_reconstructor']),\n      'builtins': set(['object', 'list', 'set']),\n      'collections': set(['deque']),\n      'graphite.render.datalib': set(['TimeSeries', 'Tags']),\n      'graphite.intervals': set(['Interval', 'IntervalSet']),\n    }\n\n    def __init__(self, file):\n        super().__init__(file, encoding='utf8')\n\n    def find_class(self, module, name):\n      if module not in self.PICKLE_SAFE:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe module %s' % module)\n      __import__(module)\n      mod = sys.modules[module]\n      if name not in self.PICKLE_SAFE[module]:\n        raise pickle.UnpicklingError('Attempting to unpickle unsafe class %s' % name)\n      return getattr(mod, name)\n\n  class unpickle(object):\n    @staticmethod\n    def loads(pickle_string):\n      return SafeUnpickler(BytesIO(pickle_string)).load()\n\n    @staticmethod\n    def load(file):\n      return SafeUnpickler(file).load()\n\n\nclass json(object):\n  JSONEncoder = _json.JSONEncoder\n  JSONDecoder = _json.JSONDecoder\n\n  @staticmethod\n  def dump(*args, **kwargs):\n    return _json.dump(*args, **kwargs)\n\n  @staticmethod\n  def dumps(*args, **kwargs):\n    return _json.dumps(*args, **kwargs)\n\n  @staticmethod\n  def load(fp, *args, **kwargs):\n    return _json.load(fp, *args, **kwargs)\n\n  @staticmethod\n  def loads(s, *args, **kwargs):\n    if isinstance(s, six.binary_type):\n      return _json.loads(s.decode('utf-8'), *args, **kwargs)\n    return _json.loads(s, *args, **kwargs)\n\n\nclass Timer(object):\n  __slots__ = ('msg', 'name', 'start_time')\n\n  def __init__(self, name):\n    self.name = name\n    self.msg = 'completed in'\n    self.start_time = time.time()\n\n  def set_msg(self, msg):\n    self.msg = msg\n\n  def set_name(self, name):\n    self.name = name\n\n  def stop(self):\n    log.info(\n      '{name} :: {msg} {sec:.6}s'.format(\n        name=self.name,\n        msg=self.msg,\n        sec=time.time() - self.start_time,\n      )\n    )\n\n\ndef logtime(f):\n  @wraps(f)\n  def wrapped_f(*args, **kwargs):\n    timer = Timer(f.__module__ + '.' + f.__name__)\n    kwargs['timer'] = timer\n\n    try:\n      return f(*args, **kwargs)\n    except Exception:\n      timer.msg = 'failed in'\n      raise\n    finally:\n      timer.stop()\n\n  return wrapped_f\n\n\nclass BufferedHTTPReader(io.FileIO):\n  def __init__(self, response, buffer_size=1048576):\n    self.response = response\n    self.buffer_size = buffer_size\n    self.buffer = b''\n    self.pos = 0\n\n  def read(self, amt=None):\n    if amt is None:\n      return self.response.read()\n    if len(self.buffer) - self.pos < amt:\n      self.buffer = self.buffer[self.pos:]\n      self.pos = 0\n      self.buffer += self.response.read(self.buffer_size)\n    data = self.buffer[self.pos:self.pos + amt]\n    self.pos += amt\n    if self.pos >= len(self.buffer):\n      self.pos = 0\n      self.buffer = b''\n    return data\n\n\ndef jsonResponse(*args, **kwargs):\n  encoder = kwargs.get('encoder')\n  default = kwargs.get('default')\n\n  def decorator(f):\n    @wraps(f)\n    def wrapped_f(request, *args, **kwargs):\n      if request.method == 'GET':\n        queryParams = request.GET.copy()\n      elif request.method == 'POST':\n        queryParams = request.GET.copy()\n        queryParams.update(request.POST)\n      else:\n        queryParams = {}\n\n      try:\n        return _jsonResponse(\n          f(request, queryParams, *args, **kwargs), queryParams, encoder=encoder, default=default)\n      except ValueError as err:\n        return _jsonError(\n          str(err), queryParams, status=getattr(err, 'status', 400), encoder=encoder, default=default)\n      except Exception as err:\n        return _jsonError(\n          str(err), queryParams, status=getattr(err, 'status', 500), encoder=encoder, default=default)\n\n    return wrapped_f\n\n  # used like @jsonResponse\n  if args:\n    return decorator(args[0])\n\n  # used like @jsonResponse(encoder=DjangoJSONEncoder)\n  return decorator\n\n\nclass HttpError(Exception):\n  def __init__(self, message, status=500):\n    super(HttpError, self).__init__(message)\n    self.status=status\n\n\ndef _jsonResponse(data, queryParams, status=200, encoder=None, default=None):\n  if isinstance(data, HttpResponse):\n    return data\n\n  if not queryParams:\n    queryParams = {}\n\n  return HttpResponse(\n    json.dumps(\n      data,\n      indent=(2 if queryParams.get('pretty') else None),\n      sort_keys=bool(queryParams.get('pretty')),\n      cls=encoder,\n      default=default\n    ),\n    content_type='application/json',\n    status=status\n  )\n\n\ndef _jsonError(message, queryParams, status=500, encoder=None, default=None):\n  return _jsonResponse(\n    {'error': message}, queryParams, status=status, encoder=encoder, default=default)\n\n\ndef parseHost(host_string):\n    s = host_string.strip()\n    bidx = s.rfind(']:')    # find closing bracket and following colon.\n    cidx = s.find(':')\n    if s.startswith('[') and bidx is not None:\n        server = s[1:bidx]\n        port = s[bidx + 2:]\n    elif cidx is not None:\n        server = s[:cidx]\n        port = s[cidx + 1:]\n    else:\n        raise ValueError(\"Invalid host string \\\"%s\\\"\" % host_string)\n\n    if ':' in port:\n        port, _, instance = port.partition(':')\n    else:\n        instance = None\n\n    return server, int(port), instance\n\n\ndef parseHosts(host_strings):\n    return [parseHost(host_string) for host_string in host_strings]\n", "from django.test import TestCase as OriginalTestCase\nfrom graphite.worker_pool.pool import stop_pools\n\n\ndef is_unsafe_str(s):\n    for symbol in '<>':\n        if s.find(symbol) > 0:\n            return True\n        return False\n\n\nclass TestCase(OriginalTestCase):\n    def tearDown(self):\n        stop_pools()\n\n    # Assert that a response is unsanitized (for check XSS issues)\n    def assertXSS(self, response, status_code=200, msg_prefix=''):\n        if status_code is not None:\n            self.assertEqual(\n                response.status_code, status_code,\n                msg_prefix + \"Couldn't retrieve content: Response code was %d\"\n                \" (expected %d)\" % (response.status_code, status_code)\n            )\n\n        content = str(response.content)\n        xss = is_unsafe_str(content)\n        self.assertFalse(xss, msg=msg_prefix+content)\n", "import copy\nimport errno\nimport mock\nimport os\n\nfrom . import TEST_CONF_DIR\n\nfrom django.conf import settings\ntry:\n    from django.urls import reverse\nexcept ImportError:  # Django < 1.10\n    from django.core.urlresolvers import reverse\nfrom django.http import HttpResponse\nfrom .base import TestCase\nfrom django.test.utils import override_settings\nfrom graphite.util import json\ntry:\n    from django.contrib.auth import get_user_model\n    User = get_user_model()\nexcept ImportError:\n    from django.contrib.auth.models import User\n\nfrom graphite.util import htmlEscape\n\n\nclass DashboardTest(TestCase):\n    # Set config to the test config file\n    settings.DASHBOARD_CONF = os.path.join(TEST_CONF_DIR, 'dashboard.conf')\n\n    # Define a testtemplate\n    testtemplate = {\"state\": '{\"graphs\": [[ \"target=a.b.c.*.__VALUE__.d\", {  \"from\":\"-2days\", \"target\":[  \"a.b.c.*.__VALUE__.d\" ], \"until\":\"now\" }, \"/render?width=400&from=-2days&until=now&height=250&target=a.b.c.*.__VALUE__.d&_uniq=0.6526056618895382&title=a.b.c.*.__VALUE__.d\" ]]}'}\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing'))\n    def test_dashboard_missing_conf(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing'))\n    def test_dashboard_template_missing_template(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @mock.patch('graphite.dashboard.views.DashboardConfig.check')\n    def test_dashboard_conf_read_failure(self, check):\n        check.side_effect = OSError(errno.EPERM, 'Operation not permitted')\n        url = reverse('dashboard')\n        with self.assertRaises(Exception):\n            _ = self.client.get(url)\n\n    @mock.patch('graphite.dashboard.views.DashboardConfig.check')\n    def test_dashboard_template_conf_read_failure(self, check):\n        check.side_effect = OSError(errno.EPERM, 'Operation not permitted')\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        with self.assertRaises(Exception):\n            _ = self.client.get(url)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_ui'))\n    def test_dashboard_conf_missing_ui(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_ui'))\n    def test_dashboard_template_missing_ui(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_keyboard-shortcuts'))\n    def test_dashboard_conf_missing_keyboard_shortcuts(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.missing_keyboard-shortcuts'))\n    def test_dashboard_template_missing_keyboard_shortcuts(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.invalid_theme'))\n    def test_dashboard_conf_invalid_theme(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(DASHBOARD_CONF=os.path.join(TEST_CONF_DIR, 'dashboard.conf.invalid_theme'))\n    def test_dashboard_template_invalid_theme(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard(self):\n        url = reverse('dashboard')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_no_user(self):\n        url = reverse('dashboard')\n        request = {\"user\": '', \"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_pass_valid(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_pass_invalid_name(self):\n        url = reverse('dashboard', args=['bogusdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_find_empty(self):\n        url = reverse('dashboard_find')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_save_empty(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_save_overwrite(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_find_existing(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find')\n        request = {\"query\": \"test\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": [{\"name\": \"testdashboard\"}]}')\n\n    def test_dashboard_find_not_existing(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find')\n        request = {\"query\": \"not here\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_load_not_existing(self):\n        url = reverse('dashboard_load', args=['bogusdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Dashboard \\'bogusdashboard\\' does not exist. \"}')\n\n    def test_dashboard_load_existing(self):\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_load', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"state\": {}}')\n\n    def test_dashboard_delete_nonexisting(self):\n        url = reverse('dashboard_delete', args=['bogusdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Dashboard \\'bogusdashboard\\' does not exist. \"}')\n\n    def test_dashboard_delete_existing(self):\n        # Create a dashboard entry\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        # Delete it\n        url = reverse('dashboard_delete', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n        # Confirm it was deleted\n        url = reverse('dashboard_find')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_create_temporary(self):\n        url = reverse('dashboard_create_temporary')\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"name\": \"temporary-0\"}')\n\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"name\": \"temporary-1\"}')\n\n        url = reverse('dashboard_find')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"dashboards\": []}')\n\n    def test_dashboard_template_pass_invalid(self):\n        url = reverse('dashboard_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_template_pass_valid(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_template', args=['testtemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_find_template_empty(self):\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": []}')\n\n    def test_dashboard_save_temporary_xss_name(self):\n        xssStr = htmlEscape('<img src=1 onerror=alert(1)>')\n        url = '/graphite/dashboard/save_template/' + xssStr + '/testkey'\n\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertContains(response, 'name contain restricted symbols', status_code=400)\n\n    def test_dashboard_save_temporary_xss_key(self):\n        xssStr = htmlEscape('<img src=1 onerror=alert(1)>')\n        url = '/graphite/dashboard/save_template/testtemplate/' + xssStr\n\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertContains(response, 'key contain restricted symbols', status_code=400)\n\n    def test_dashboard_save_template(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n    # Save again after it now exists\n    def test_dashboard_save_template_overwrite(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n    def test_dashboard_find_template(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"test\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": [{\"name\": \"testtemplate\"}]}')\n\n    def test_dashboard_find_template_nonexistent(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"not here\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": []}')\n\n    def test_dashboard_load_template_nonexistent(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_load_template', args=['bogustemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Template \\'bogustemplate\\' does not exist. \"}')\n\n    def test_dashboard_load_template_existing(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_load_template', args=['testtemplate', 'testkey'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.content)\n        graph_data = json.loads(self.testtemplate[\"state\"].replace('__VALUE__', 'testkey'))\n        self.assertEqual(data, json.loads('{\"state\": {\"name\": \"testtemplate/testkey\", \"graphs\": ' + json.dumps(graph_data['graphs']) + '}}'))\n\n    def test_dashboard_delete_template_nonexisting(self):\n        # Delete nonexistent template\n        url = reverse('dashboard_delete_template', args=['bogustemplate'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Template \\'bogustemplate\\' does not exist. \"}')\n\n    def test_dashboard_delete_template_existing(self):\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n\n        url = reverse('dashboard_delete_template', args=['testtemplate'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n        url = reverse('dashboard_find_template')\n        request = {\"query\": \"\"}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"templates\": []}')\n\n    def test_dashboard_help(self):\n        url = reverse('dashboard_help')\n        request = {}\n        response = self.client.get(url, request)\n        self.assertEqual(response.status_code, 200)\n\n    def test_dashboard_email(self):\n        url = reverse('dashboard_email')\n        request = {\"sender\": \"noreply@localhost\",\n                   \"recipients\": \"noreply@localhost\",\n                   \"subject\": \"Test email\",\n                   \"message\": \"Here is the test graph\",\n                   \"graph_params\": '{\"target\":[\"sumSeries(a.b.c.d)\"],\"title\":\"Test\",\"width\":\"500\",\"from\":\"-55minutes\",\"until\":\"now\",\"height\":\"400\"}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n    @mock.patch('graphite.dashboard.views.renderView')\n    def test_dashboard_email_mock_renderView(self, rv):\n        url = reverse('dashboard_email')\n        request = {\"sender\": \"noreply@localhost\",\n                   \"recipients\": \"noreply@localhost\",\n                   \"subject\": \"Test email\",\n                   \"message\": \"Here is the test graph\",\n                   \"graph_params\": '{\"target\":[\"sumSeries(a.b.c.d)\"],\"title\":\"Test\",\"width\":\"500\",\"from\":\"-55minutes\",\"until\":\"now\",\"height\":\"400\"}'}\n        responseObject = HttpResponse()\n        responseObject.content = ''\n        rv.return_value = responseObject\n        response = self.client.post(url, request)\n        self.assertEqual(response.content, b'{\"success\": true}')\n\n    def test_dashboard_login_invalid_authenticate(self):\n        url = reverse('dashboard_login')\n        request = {\"username\": \"testuser\",\n                   \"password\": \"testpassword\"}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"errors\": {\"reason\": \"Username and/or password invalid.\"}, \"success\": false, \"text\": {}, \"permissions\": []}'))\n\n    @mock.patch('graphite.dashboard.views.authenticate')\n    def test_dashboard_login_valid_authenticate(self, authenticate):\n        url = reverse('dashboard_login')\n        request = {\"username\": \"testuser\",\n                   \"password\": \"testpassword\"}\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        authenticate.return_value = user\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"permissions\": [\"change\", \"delete\"], \"success\": true, \"text\": {}, \"errors\": {}}'))\n\n    @mock.patch('graphite.dashboard.views.authenticate')\n    def test_dashboard_login_valid_authenticate_not_active(self, authenticate):\n        url = reverse('dashboard_login')\n        request = {\"username\": \"testuser\",\n                   \"password\": \"testpassword\"}\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        user.is_active = False\n        authenticate.return_value = user\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"permissions\": [], \"success\": false, \"errors\": {\"reason\": \"Account disabled.\"}, \"text\": {}}'))\n\n    def test_dashboard_logout(self):\n        url = reverse('dashboard_logout')\n        request = {\"username\": \"testuser\"}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(json.loads(response.content), json.loads('{\"errors\": {}, \"success\": true, \"text\": {}}'))\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_save_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_save', args=['testdashboard'])\n        request = {\"state\": '{}'}\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to save\"}')\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_delete_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_delete', args=['testdashboard'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to delete\"}')\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_save_template_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_save_template', args=['testtemplate', 'testkey'])\n        request = copy.deepcopy(self.testtemplate)\n        response = self.client.post(url, request)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to save the template\"}')\n\n    @mock.patch('graphite.dashboard.views.getPermissions')\n    def test_dashboard_delete_template_no_permissions(self, gp):\n        gp.return_value = [None]\n        url = reverse('dashboard_delete_template', args=['testtemplate'])\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b'{\"error\": \"Must be logged in with appropriate permissions to delete the template\"}')\n\n    def test_getPermissions_no_user(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=False\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        self.assertEqual(getPermissions(False), ['change', 'delete'])\n\n    def test_getPermissions_no_user_require_auth(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        self.assertEqual(getPermissions(False), [])\n\n    def test_getPermissions_valid_user(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), ['change', 'delete'])\n\n    def test_getPermissions_valid_user_require_perm(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=True\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=False\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), [])\n\n    def test_getPermissions_valid_user_edit_group(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=False\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=True\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), [])\n\n    def test_getPermissions_valid_user_require_perms_edit_group(self):\n        settings.DASHBOARD_REQUIRE_AUTHENTICATION=True\n        settings.DASHBOARD_REQUIRE_PERMISSIONS=True\n        settings.DASHBOARD_REQUIRE_EDIT_GROUP=True\n        from graphite.dashboard.views import getPermissions\n        user = User.objects.create(email='testuser@test.com')\n        user.backend = ''\n        self.assertEqual(getPermissions(user), [])\n"], "filenames": ["webapp/content/js/dashboard.js", "webapp/graphite/dashboard/views.py", "webapp/graphite/errors.py", "webapp/graphite/util.py", "webapp/tests/base.py", "webapp/tests/test_dashboard.py"], "buggy_code_start_loc": [163, 18, 2, 128, 2, 22], "buggy_code_end_loc": [1298, 293, 115, 128, 20, 264], "fixing_code_start_loc": [164, 19, 3, 129, 3, 23], "fixing_code_end_loc": [1302, 314, 126, 144, 28, 285], "type": "CWE-79", "message": "A vulnerability was found in Graphite Web. It has been classified as problematic. Affected is an unknown function of the component Absolute Time Range Handler. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 2f178f490e10efc03cd1d27c72f64ecab224eb23. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216744.", "other": {"cve": {"id": "CVE-2022-4730", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T15:15:12.543", "lastModified": "2023-01-05T18:48:53.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Graphite Web. It has been classified as problematic. Affected is an unknown function of the component Absolute Time Range Handler. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 2f178f490e10efc03cd1d27c72f64ecab224eb23. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216744."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-707"}, {"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:graphite_project:graphite:-:*:*:*:*:*:*:*", "matchCriteriaId": "3EFF3851-87AE-4730-9FC1-42E7715294B3"}]}]}], "references": [{"url": "https://github.com/graphite-project/graphite-web/commit/2f178f490e10efc03cd1d27c72f64ecab224eb23", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/graphite-project/graphite-web/issues/2746", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/graphite-project/graphite-web/pull/2785", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216744", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/graphite-project/graphite-web/commit/2f178f490e10efc03cd1d27c72f64ecab224eb23"}}