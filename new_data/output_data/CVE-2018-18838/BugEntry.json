{"buggy_code": ["// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"../libnetdata.h\"\n\n// ----------------------------------------------------------------------------\n// URL encode / decode\n// code from: http://www.geekhideout.com/urlcode.shtml\n\n/* Converts a hex character to its integer value */\nchar from_hex(char ch) {\n    return (char)(isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10);\n}\n\n/* Converts an integer value to its hex character*/\nchar to_hex(char code) {\n    static char hex[] = \"0123456789abcdef\";\n    return hex[code & 15];\n}\n\n/* Returns a url-encoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nchar *url_encode(char *str) {\n    char *buf, *pbuf;\n\n    pbuf = buf = mallocz(strlen(str) * 3 + 1);\n\n    while (*str) {\n        if (isalnum(*str) || *str == '-' || *str == '_' || *str == '.' || *str == '~')\n            *pbuf++ = *str;\n\n        else if (*str == ' ')\n            *pbuf++ = '+';\n\n        else\n            *pbuf++ = '%', *pbuf++ = to_hex(*str >> 4), *pbuf++ = to_hex(*str & 15);\n\n        str++;\n    }\n    *pbuf = '\\0';\n\n    pbuf = strdupz(buf);\n    freez(buf);\n    return pbuf;\n}\n\n/* Returns a url-decoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nchar *url_decode(char *str) {\n    size_t size = strlen(str) + 1;\n\n    char *buf = mallocz(size);\n    return url_decode_r(buf, str, size);\n}\n\nchar *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &to[size - 1]; // destination end\n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}\n", "// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"web_api_v1.h\"\n\nstatic struct {\n    const char *name;\n    uint32_t hash;\n    RRDR_OPTIONS value;\n} api_v1_data_options[] = {\n        {  \"nonzero\"         , 0    , RRDR_OPTION_NONZERO}\n        , {\"flip\"            , 0    , RRDR_OPTION_REVERSED}\n        , {\"reversed\"        , 0    , RRDR_OPTION_REVERSED}\n        , {\"reverse\"         , 0    , RRDR_OPTION_REVERSED}\n        , {\"jsonwrap\"        , 0    , RRDR_OPTION_JSON_WRAP}\n        , {\"min2max\"         , 0    , RRDR_OPTION_MIN2MAX}\n        , {\"ms\"              , 0    , RRDR_OPTION_MILLISECONDS}\n        , {\"milliseconds\"    , 0    , RRDR_OPTION_MILLISECONDS}\n        , {\"abs\"             , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"absolute\"        , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"absolute_sum\"    , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"absolute-sum\"    , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"display_absolute\", 0    , RRDR_OPTION_DISPLAY_ABS}\n        , {\"display-absolute\", 0    , RRDR_OPTION_DISPLAY_ABS}\n        , {\"seconds\"         , 0    , RRDR_OPTION_SECONDS}\n        , {\"null2zero\"       , 0    , RRDR_OPTION_NULL2ZERO}\n        , {\"objectrows\"      , 0    , RRDR_OPTION_OBJECTSROWS}\n        , {\"google_json\"     , 0    , RRDR_OPTION_GOOGLE_JSON}\n        , {\"google-json\"     , 0    , RRDR_OPTION_GOOGLE_JSON}\n        , {\"percentage\"      , 0    , RRDR_OPTION_PERCENTAGE}\n        , {\"unaligned\"       , 0    , RRDR_OPTION_NOT_ALIGNED}\n        , {\"match_ids\"       , 0    , RRDR_OPTION_MATCH_IDS}\n        , {\"match-ids\"       , 0    , RRDR_OPTION_MATCH_IDS}\n        , {\"match_names\"     , 0    , RRDR_OPTION_MATCH_NAMES}\n        , {\"match-names\"     , 0    , RRDR_OPTION_MATCH_NAMES}\n        , {                  NULL, 0, 0}\n};\n\nstatic struct {\n    const char *name;\n    uint32_t hash;\n    uint32_t value;\n} api_v1_data_formats[] = {\n        {  DATASOURCE_FORMAT_DATATABLE_JSON , 0 , DATASOURCE_DATATABLE_JSON}\n        , {DATASOURCE_FORMAT_DATATABLE_JSONP, 0 , DATASOURCE_DATATABLE_JSONP}\n        , {DATASOURCE_FORMAT_JSON           , 0 , DATASOURCE_JSON}\n        , {DATASOURCE_FORMAT_JSONP          , 0 , DATASOURCE_JSONP}\n        , {DATASOURCE_FORMAT_SSV            , 0 , DATASOURCE_SSV}\n        , {DATASOURCE_FORMAT_CSV            , 0 , DATASOURCE_CSV}\n        , {DATASOURCE_FORMAT_TSV            , 0 , DATASOURCE_TSV}\n        , {\"tsv-excel\"                      , 0 , DATASOURCE_TSV}\n        , {DATASOURCE_FORMAT_HTML           , 0 , DATASOURCE_HTML}\n        , {DATASOURCE_FORMAT_JS_ARRAY       , 0 , DATASOURCE_JS_ARRAY}\n        , {DATASOURCE_FORMAT_SSV_COMMA      , 0 , DATASOURCE_SSV_COMMA}\n        , {DATASOURCE_FORMAT_CSV_JSON_ARRAY , 0 , DATASOURCE_CSV_JSON_ARRAY}\n        , {DATASOURCE_FORMAT_CSV_MARKDOWN   , 0 , DATASOURCE_CSV_MARKDOWN}\n        , {                                 NULL, 0, 0}\n};\n\nstatic struct {\n    const char *name;\n    uint32_t hash;\n    uint32_t value;\n} api_v1_data_google_formats[] = {\n        // this is not error - when google requests json, it expects javascript\n        // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source#responseformat\n        {  \"json\"     , 0    , DATASOURCE_DATATABLE_JSONP}\n        , {\"html\"     , 0    , DATASOURCE_HTML}\n        , {\"csv\"      , 0    , DATASOURCE_CSV}\n        , {\"tsv-excel\", 0    , DATASOURCE_TSV}\n        , {           NULL, 0, 0}\n};\n\nvoid web_client_api_v1_init(void) {\n    int i;\n\n    for(i = 0; api_v1_data_options[i].name ; i++)\n        api_v1_data_options[i].hash = simple_hash(api_v1_data_options[i].name);\n\n    for(i = 0; api_v1_data_formats[i].name ; i++)\n        api_v1_data_formats[i].hash = simple_hash(api_v1_data_formats[i].name);\n\n    for(i = 0; api_v1_data_google_formats[i].name ; i++)\n        api_v1_data_google_formats[i].hash = simple_hash(api_v1_data_google_formats[i].name);\n\n    web_client_api_v1_init_grouping();\n}\n\ninline uint32_t web_client_api_request_v1_data_options(char *o) {\n    uint32_t ret = 0x00000000;\n    char *tok;\n\n    while(o && *o && (tok = mystrsep(&o, \", |\"))) {\n        if(!*tok) continue;\n\n        uint32_t hash = simple_hash(tok);\n        int i;\n        for(i = 0; api_v1_data_options[i].name ; i++) {\n            if (unlikely(hash == api_v1_data_options[i].hash && !strcmp(tok, api_v1_data_options[i].name))) {\n                ret |= api_v1_data_options[i].value;\n                break;\n            }\n        }\n    }\n\n    return ret;\n}\n\ninline uint32_t web_client_api_request_v1_data_format(char *name) {\n    uint32_t hash = simple_hash(name);\n    int i;\n\n    for(i = 0; api_v1_data_formats[i].name ; i++) {\n        if (unlikely(hash == api_v1_data_formats[i].hash && !strcmp(name, api_v1_data_formats[i].name))) {\n            return api_v1_data_formats[i].value;\n        }\n    }\n\n    return DATASOURCE_JSON;\n}\n\ninline uint32_t web_client_api_request_v1_data_google_format(char *name) {\n    uint32_t hash = simple_hash(name);\n    int i;\n\n    for(i = 0; api_v1_data_google_formats[i].name ; i++) {\n        if (unlikely(hash == api_v1_data_google_formats[i].hash && !strcmp(name, api_v1_data_google_formats[i].name))) {\n            return api_v1_data_google_formats[i].value;\n        }\n    }\n\n    return DATASOURCE_JSON;\n}\n\n\ninline int web_client_api_request_v1_alarms(RRDHOST *host, struct web_client *w, char *url) {\n    int all = 0;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if (!value || !*value) continue;\n\n        if(!strcmp(value, \"all\")) all = 1;\n        else if(!strcmp(value, \"active\")) all = 0;\n    }\n\n    buffer_flush(w->response.data);\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    health_alarms2json(host, w->response.data, all);\n    return 200;\n}\n\ninline int web_client_api_request_v1_alarm_log(RRDHOST *host, struct web_client *w, char *url) {\n    uint32_t after = 0;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if (!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        if(!strcmp(name, \"after\")) after = (uint32_t)strtoul(value, NULL, 0);\n    }\n\n    buffer_flush(w->response.data);\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    health_alarm_log2json(host, w->response.data, after);\n    return 200;\n}\n\ninline int web_client_api_request_single_chart(RRDHOST *host, struct web_client *w, char *url, void callback(RRDSET *st, BUFFER *buf)) {\n    int ret = 400;\n    char *chart = NULL;\n\n    buffer_flush(w->response.data);\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        //else {\n        /// buffer_sprintf(w->response.data, \"Unknown parameter '%s' in request.\", name);\n        //  goto cleanup;\n        //}\n    }\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    st->last_accessed_time = now_realtime_sec();\n    callback(st, w->response.data);\n    return 200;\n\n    cleanup:\n    return ret;\n}\n\ninline int web_client_api_request_v1_alarm_variables(RRDHOST *host, struct web_client *w, char *url) {\n    return web_client_api_request_single_chart(host, w, url, health_api_v1_chart_variables2json);\n}\n\ninline int web_client_api_request_v1_charts(RRDHOST *host, struct web_client *w, char *url) {\n    (void)url;\n\n    buffer_flush(w->response.data);\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    charts2json(host, w->response.data);\n    return 200;\n}\n\ninline int web_client_api_request_v1_chart(RRDHOST *host, struct web_client *w, char *url) {\n    return web_client_api_request_single_chart(host, w, url, rrd_stats_api_v1_chart);\n}\n\n// returns the HTTP code\ninline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}\n\ninline int web_client_api_request_v1_registry(RRDHOST *host, struct web_client *w, char *url) {\n    static uint32_t hash_action = 0, hash_access = 0, hash_hello = 0, hash_delete = 0, hash_search = 0,\n            hash_switch = 0, hash_machine = 0, hash_url = 0, hash_name = 0, hash_delete_url = 0, hash_for = 0,\n            hash_to = 0 /*, hash_redirects = 0 */;\n\n    if(unlikely(!hash_action)) {\n        hash_action = simple_hash(\"action\");\n        hash_access = simple_hash(\"access\");\n        hash_hello = simple_hash(\"hello\");\n        hash_delete = simple_hash(\"delete\");\n        hash_search = simple_hash(\"search\");\n        hash_switch = simple_hash(\"switch\");\n        hash_machine = simple_hash(\"machine\");\n        hash_url = simple_hash(\"url\");\n        hash_name = simple_hash(\"name\");\n        hash_delete_url = simple_hash(\"delete_url\");\n        hash_for = simple_hash(\"for\");\n        hash_to = simple_hash(\"to\");\n/*\n        hash_redirects = simple_hash(\"redirects\");\n*/\n    }\n\n    char person_guid[GUID_LEN + 1] = \"\";\n\n    debug(D_WEB_CLIENT, \"%llu: API v1 registry with URL '%s'\", w->id, url);\n\n    // TODO\n    // The browser may send multiple cookies with our id\n\n    char *cookie = strstr(w->response.data->buffer, NETDATA_REGISTRY_COOKIE_NAME \"=\");\n    if(cookie)\n        strncpyz(person_guid, &cookie[sizeof(NETDATA_REGISTRY_COOKIE_NAME)], 36);\n\n    char action = '\\0';\n    char *machine_guid = NULL,\n            *machine_url = NULL,\n            *url_name = NULL,\n            *search_machine_guid = NULL,\n            *delete_url = NULL,\n            *to_person_guid = NULL;\n/*\n    int redirects = 0;\n*/\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if (!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if (!name || !*name) continue;\n        if (!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 registry query param '%s' with value '%s'\", w->id, name, value);\n\n        uint32_t hash = simple_hash(name);\n\n        if(hash == hash_action && !strcmp(name, \"action\")) {\n            uint32_t vhash = simple_hash(value);\n\n            if(vhash == hash_access && !strcmp(value, \"access\")) action = 'A';\n            else if(vhash == hash_hello && !strcmp(value, \"hello\")) action = 'H';\n            else if(vhash == hash_delete && !strcmp(value, \"delete\")) action = 'D';\n            else if(vhash == hash_search && !strcmp(value, \"search\")) action = 'S';\n            else if(vhash == hash_switch && !strcmp(value, \"switch\")) action = 'W';\n#ifdef NETDATA_INTERNAL_CHECKS\n            else error(\"unknown registry action '%s'\", value);\n#endif /* NETDATA_INTERNAL_CHECKS */\n        }\n/*\n        else if(hash == hash_redirects && !strcmp(name, \"redirects\"))\n            redirects = atoi(value);\n*/\n        else if(hash == hash_machine && !strcmp(name, \"machine\"))\n            machine_guid = value;\n\n        else if(hash == hash_url && !strcmp(name, \"url\"))\n            machine_url = value;\n\n        else if(action == 'A') {\n            if(hash == hash_name && !strcmp(name, \"name\"))\n                url_name = value;\n        }\n        else if(action == 'D') {\n            if(hash == hash_delete_url && !strcmp(name, \"delete_url\"))\n                delete_url = value;\n        }\n        else if(action == 'S') {\n            if(hash == hash_for && !strcmp(name, \"for\"))\n                search_machine_guid = value;\n        }\n        else if(action == 'W') {\n            if(hash == hash_to && !strcmp(name, \"to\"))\n                to_person_guid = value;\n        }\n#ifdef NETDATA_INTERNAL_CHECKS\n        else error(\"unused registry URL parameter '%s' with value '%s'\", name, value);\n#endif /* NETDATA_INTERNAL_CHECKS */\n    }\n\n    if(unlikely(respect_web_browser_do_not_track_policy && web_client_has_donottrack(w))) {\n        buffer_flush(w->response.data);\n        buffer_sprintf(w->response.data, \"Your web browser is sending 'DNT: 1' (Do Not Track). The registry requires persistent cookies on your browser to work.\");\n        return 400;\n    }\n\n    if(unlikely(action == 'H')) {\n        // HELLO request, dashboard ACL\n        if(unlikely(!web_client_can_access_dashboard(w)))\n            return web_client_permission_denied(w);\n    }\n    else {\n        // everything else, registry ACL\n        if(unlikely(!web_client_can_access_registry(w)))\n            return web_client_permission_denied(w);\n    }\n\n    switch(action) {\n        case 'A':\n            if(unlikely(!machine_guid || !machine_url || !url_name)) {\n                error(\"Invalid registry request - access requires these parameters: machine ('%s'), url ('%s'), name ('%s')\", machine_guid ? machine_guid : \"UNSET\", machine_url ? machine_url : \"UNSET\", url_name ? url_name : \"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Access request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_access_json(host, w, person_guid, machine_guid, machine_url, url_name, now_realtime_sec());\n\n        case 'D':\n            if(unlikely(!machine_guid || !machine_url || !delete_url)) {\n                error(\"Invalid registry request - delete requires these parameters: machine ('%s'), url ('%s'), delete_url ('%s')\", machine_guid?machine_guid:\"UNSET\", machine_url?machine_url:\"UNSET\", delete_url?delete_url:\"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Delete request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_delete_json(host, w, person_guid, machine_guid, machine_url, delete_url, now_realtime_sec());\n\n        case 'S':\n            if(unlikely(!machine_guid || !machine_url || !search_machine_guid)) {\n                error(\"Invalid registry request - search requires these parameters: machine ('%s'), url ('%s'), for ('%s')\", machine_guid?machine_guid:\"UNSET\", machine_url?machine_url:\"UNSET\", search_machine_guid?search_machine_guid:\"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Search request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_search_json(host, w, person_guid, machine_guid, machine_url, search_machine_guid, now_realtime_sec());\n\n        case 'W':\n            if(unlikely(!machine_guid || !machine_url || !to_person_guid)) {\n                error(\"Invalid registry request - switching identity requires these parameters: machine ('%s'), url ('%s'), to ('%s')\", machine_guid?machine_guid:\"UNSET\", machine_url?machine_url:\"UNSET\", to_person_guid?to_person_guid:\"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Switch request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_switch_json(host, w, person_guid, machine_guid, machine_url, to_person_guid, now_realtime_sec());\n\n        case 'H':\n            return registry_request_hello_json(host, w);\n\n        default:\n            buffer_flush(w->response.data);\n            buffer_strcat(w->response.data, \"Invalid registry request - you need to set an action: hello, access, delete, search\");\n            return 400;\n    }\n}\n\nstatic struct api_command {\n    const char *command;\n    uint32_t hash;\n    WEB_CLIENT_ACL acl;\n    int (*callback)(RRDHOST *host, struct web_client *w, char *url);\n} api_commands[] = {\n        { \"data\",            0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_data            },\n        { \"chart\",           0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_chart           },\n        { \"charts\",          0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_charts          },\n\n        // registry checks the ACL by itself, so we allow everything\n        { \"registry\",        0, WEB_CLIENT_ACL_NOCHECK,   web_client_api_request_v1_registry        },\n\n        // badges can be fetched with both dashboard and badge permissions\n        { \"badge.svg\",       0, WEB_CLIENT_ACL_DASHBOARD|WEB_CLIENT_ACL_BADGE, web_client_api_request_v1_badge },\n\n        { \"alarms\",          0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_alarms          },\n        { \"alarm_log\",       0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_alarm_log       },\n        { \"alarm_variables\", 0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_alarm_variables },\n        { \"allmetrics\",      0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_allmetrics      },\n\n        // terminator\n        { NULL,              0, WEB_CLIENT_ACL_NONE,      NULL                                      },\n};\n\ninline int web_client_api_request_v1(RRDHOST *host, struct web_client *w, char *url) {\n    static int initialized = 0;\n    int i;\n\n    if(unlikely(initialized == 0)) {\n        initialized = 1;\n\n        for(i = 0; api_commands[i].command ; i++)\n            api_commands[i].hash = simple_hash(api_commands[i].command);\n    }\n\n    // get the command\n    char *tok = mystrsep(&url, \"/?&\");\n    if(tok && *tok) {\n        debug(D_WEB_CLIENT, \"%llu: Searching for API v1 command '%s'.\", w->id, tok);\n        uint32_t hash = simple_hash(tok);\n\n        for(i = 0; api_commands[i].command ;i++) {\n            if(unlikely(hash == api_commands[i].hash && !strcmp(tok, api_commands[i].command))) {\n                if(unlikely(api_commands[i].acl != WEB_CLIENT_ACL_NOCHECK) && !(w->acl & api_commands[i].acl))\n                    return web_client_permission_denied(w);\n\n                return api_commands[i].callback(host, w, url);\n            }\n        }\n\n        buffer_flush(w->response.data);\n        buffer_strcat(w->response.data, \"Unsupported v1 API command: \");\n        buffer_strcat_htmlescape(w->response.data, tok);\n        return 404;\n    }\n    else {\n        buffer_flush(w->response.data);\n        buffer_sprintf(w->response.data, \"Which API v1 command?\");\n        return 400;\n    }\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"../libnetdata.h\"\n\n// ----------------------------------------------------------------------------\n// URL encode / decode\n// code from: http://www.geekhideout.com/urlcode.shtml\n\n/* Converts a hex character to its integer value */\nchar from_hex(char ch) {\n    return (char)(isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10);\n}\n\n/* Converts an integer value to its hex character*/\nchar to_hex(char code) {\n    static char hex[] = \"0123456789abcdef\";\n    return hex[code & 15];\n}\n\n/* Returns a url-encoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nchar *url_encode(char *str) {\n    char *buf, *pbuf;\n\n    pbuf = buf = mallocz(strlen(str) * 3 + 1);\n\n    while (*str) {\n        if (isalnum(*str) || *str == '-' || *str == '_' || *str == '.' || *str == '~')\n            *pbuf++ = *str;\n\n        else if (*str == ' ')\n            *pbuf++ = '+';\n\n        else\n            *pbuf++ = '%', *pbuf++ = to_hex(*str >> 4), *pbuf++ = to_hex(*str & 15);\n\n        str++;\n    }\n    *pbuf = '\\0';\n\n    pbuf = strdupz(buf);\n    freez(buf);\n    return pbuf;\n}\n\n/* Returns a url-decoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nchar *url_decode(char *str) {\n    size_t size = strlen(str) + 1;\n\n    char *buf = mallocz(size);\n    return url_decode_r(buf, str, size);\n}\n\nchar *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &to[size - 1]; // destination end\n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                char t = from_hex(s[1]) << 4 | from_hex(s[2]);\n                // avoid HTTP header injection\n                *d++ = (char)((isprint(t))? t : ' ');\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}\n", "// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"web_api_v1.h\"\n\nstatic struct {\n    const char *name;\n    uint32_t hash;\n    RRDR_OPTIONS value;\n} api_v1_data_options[] = {\n        {  \"nonzero\"         , 0    , RRDR_OPTION_NONZERO}\n        , {\"flip\"            , 0    , RRDR_OPTION_REVERSED}\n        , {\"reversed\"        , 0    , RRDR_OPTION_REVERSED}\n        , {\"reverse\"         , 0    , RRDR_OPTION_REVERSED}\n        , {\"jsonwrap\"        , 0    , RRDR_OPTION_JSON_WRAP}\n        , {\"min2max\"         , 0    , RRDR_OPTION_MIN2MAX}\n        , {\"ms\"              , 0    , RRDR_OPTION_MILLISECONDS}\n        , {\"milliseconds\"    , 0    , RRDR_OPTION_MILLISECONDS}\n        , {\"abs\"             , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"absolute\"        , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"absolute_sum\"    , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"absolute-sum\"    , 0    , RRDR_OPTION_ABSOLUTE}\n        , {\"display_absolute\", 0    , RRDR_OPTION_DISPLAY_ABS}\n        , {\"display-absolute\", 0    , RRDR_OPTION_DISPLAY_ABS}\n        , {\"seconds\"         , 0    , RRDR_OPTION_SECONDS}\n        , {\"null2zero\"       , 0    , RRDR_OPTION_NULL2ZERO}\n        , {\"objectrows\"      , 0    , RRDR_OPTION_OBJECTSROWS}\n        , {\"google_json\"     , 0    , RRDR_OPTION_GOOGLE_JSON}\n        , {\"google-json\"     , 0    , RRDR_OPTION_GOOGLE_JSON}\n        , {\"percentage\"      , 0    , RRDR_OPTION_PERCENTAGE}\n        , {\"unaligned\"       , 0    , RRDR_OPTION_NOT_ALIGNED}\n        , {\"match_ids\"       , 0    , RRDR_OPTION_MATCH_IDS}\n        , {\"match-ids\"       , 0    , RRDR_OPTION_MATCH_IDS}\n        , {\"match_names\"     , 0    , RRDR_OPTION_MATCH_NAMES}\n        , {\"match-names\"     , 0    , RRDR_OPTION_MATCH_NAMES}\n        , {                  NULL, 0, 0}\n};\n\nstatic struct {\n    const char *name;\n    uint32_t hash;\n    uint32_t value;\n} api_v1_data_formats[] = {\n        {  DATASOURCE_FORMAT_DATATABLE_JSON , 0 , DATASOURCE_DATATABLE_JSON}\n        , {DATASOURCE_FORMAT_DATATABLE_JSONP, 0 , DATASOURCE_DATATABLE_JSONP}\n        , {DATASOURCE_FORMAT_JSON           , 0 , DATASOURCE_JSON}\n        , {DATASOURCE_FORMAT_JSONP          , 0 , DATASOURCE_JSONP}\n        , {DATASOURCE_FORMAT_SSV            , 0 , DATASOURCE_SSV}\n        , {DATASOURCE_FORMAT_CSV            , 0 , DATASOURCE_CSV}\n        , {DATASOURCE_FORMAT_TSV            , 0 , DATASOURCE_TSV}\n        , {\"tsv-excel\"                      , 0 , DATASOURCE_TSV}\n        , {DATASOURCE_FORMAT_HTML           , 0 , DATASOURCE_HTML}\n        , {DATASOURCE_FORMAT_JS_ARRAY       , 0 , DATASOURCE_JS_ARRAY}\n        , {DATASOURCE_FORMAT_SSV_COMMA      , 0 , DATASOURCE_SSV_COMMA}\n        , {DATASOURCE_FORMAT_CSV_JSON_ARRAY , 0 , DATASOURCE_CSV_JSON_ARRAY}\n        , {DATASOURCE_FORMAT_CSV_MARKDOWN   , 0 , DATASOURCE_CSV_MARKDOWN}\n        , {                                 NULL, 0, 0}\n};\n\nstatic struct {\n    const char *name;\n    uint32_t hash;\n    uint32_t value;\n} api_v1_data_google_formats[] = {\n        // this is not error - when google requests json, it expects javascript\n        // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source#responseformat\n        {  \"json\"     , 0    , DATASOURCE_DATATABLE_JSONP}\n        , {\"html\"     , 0    , DATASOURCE_HTML}\n        , {\"csv\"      , 0    , DATASOURCE_CSV}\n        , {\"tsv-excel\", 0    , DATASOURCE_TSV}\n        , {           NULL, 0, 0}\n};\n\nvoid web_client_api_v1_init(void) {\n    int i;\n\n    for(i = 0; api_v1_data_options[i].name ; i++)\n        api_v1_data_options[i].hash = simple_hash(api_v1_data_options[i].name);\n\n    for(i = 0; api_v1_data_formats[i].name ; i++)\n        api_v1_data_formats[i].hash = simple_hash(api_v1_data_formats[i].name);\n\n    for(i = 0; api_v1_data_google_formats[i].name ; i++)\n        api_v1_data_google_formats[i].hash = simple_hash(api_v1_data_google_formats[i].name);\n\n    web_client_api_v1_init_grouping();\n}\n\ninline uint32_t web_client_api_request_v1_data_options(char *o) {\n    uint32_t ret = 0x00000000;\n    char *tok;\n\n    while(o && *o && (tok = mystrsep(&o, \", |\"))) {\n        if(!*tok) continue;\n\n        uint32_t hash = simple_hash(tok);\n        int i;\n        for(i = 0; api_v1_data_options[i].name ; i++) {\n            if (unlikely(hash == api_v1_data_options[i].hash && !strcmp(tok, api_v1_data_options[i].name))) {\n                ret |= api_v1_data_options[i].value;\n                break;\n            }\n        }\n    }\n\n    return ret;\n}\n\ninline uint32_t web_client_api_request_v1_data_format(char *name) {\n    uint32_t hash = simple_hash(name);\n    int i;\n\n    for(i = 0; api_v1_data_formats[i].name ; i++) {\n        if (unlikely(hash == api_v1_data_formats[i].hash && !strcmp(name, api_v1_data_formats[i].name))) {\n            return api_v1_data_formats[i].value;\n        }\n    }\n\n    return DATASOURCE_JSON;\n}\n\ninline uint32_t web_client_api_request_v1_data_google_format(char *name) {\n    uint32_t hash = simple_hash(name);\n    int i;\n\n    for(i = 0; api_v1_data_google_formats[i].name ; i++) {\n        if (unlikely(hash == api_v1_data_google_formats[i].hash && !strcmp(name, api_v1_data_google_formats[i].name))) {\n            return api_v1_data_google_formats[i].value;\n        }\n    }\n\n    return DATASOURCE_JSON;\n}\n\n\ninline int web_client_api_request_v1_alarms(RRDHOST *host, struct web_client *w, char *url) {\n    int all = 0;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if (!value || !*value) continue;\n\n        if(!strcmp(value, \"all\")) all = 1;\n        else if(!strcmp(value, \"active\")) all = 0;\n    }\n\n    buffer_flush(w->response.data);\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    health_alarms2json(host, w->response.data, all);\n    return 200;\n}\n\ninline int web_client_api_request_v1_alarm_log(RRDHOST *host, struct web_client *w, char *url) {\n    uint32_t after = 0;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if (!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        if(!strcmp(name, \"after\")) after = (uint32_t)strtoul(value, NULL, 0);\n    }\n\n    buffer_flush(w->response.data);\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    health_alarm_log2json(host, w->response.data, after);\n    return 200;\n}\n\ninline int web_client_api_request_single_chart(RRDHOST *host, struct web_client *w, char *url, void callback(RRDSET *st, BUFFER *buf)) {\n    int ret = 400;\n    char *chart = NULL;\n\n    buffer_flush(w->response.data);\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        //else {\n        /// buffer_sprintf(w->response.data, \"Unknown parameter '%s' in request.\", name);\n        //  goto cleanup;\n        //}\n    }\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    st->last_accessed_time = now_realtime_sec();\n    callback(st, w->response.data);\n    return 200;\n\n    cleanup:\n    return ret;\n}\n\ninline int web_client_api_request_v1_alarm_variables(RRDHOST *host, struct web_client *w, char *url) {\n    return web_client_api_request_single_chart(host, w, url, health_api_v1_chart_variables2json);\n}\n\ninline int web_client_api_request_v1_charts(RRDHOST *host, struct web_client *w, char *url) {\n    (void)url;\n\n    buffer_flush(w->response.data);\n    w->response.data->contenttype = CT_APPLICATION_JSON;\n    charts2json(host, w->response.data);\n    return 200;\n}\n\ninline int web_client_api_request_v1_chart(RRDHOST *host, struct web_client *w, char *url) {\n    return web_client_api_request_single_chart(host, w, url, rrd_stats_api_v1_chart);\n}\n\nvoid fix_google_param(char *s) {\n    if(unlikely(!s)) return;\n\n    for( ; *s ;s++) {\n        if(!isalnum(*s) && *s != '.' && *s != '_' && *s != '-')\n            *s = '_';\n    }\n}\n\n// returns the HTTP code\ninline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    // validate the google parameters given\n    fix_google_param(google_out);\n    fix_google_param(google_sig);\n    fix_google_param(google_reqId);\n    fix_google_param(google_version);\n    fix_google_param(responseHandler);\n    fix_google_param(outFileName);\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}\n\ninline int web_client_api_request_v1_registry(RRDHOST *host, struct web_client *w, char *url) {\n    static uint32_t hash_action = 0, hash_access = 0, hash_hello = 0, hash_delete = 0, hash_search = 0,\n            hash_switch = 0, hash_machine = 0, hash_url = 0, hash_name = 0, hash_delete_url = 0, hash_for = 0,\n            hash_to = 0 /*, hash_redirects = 0 */;\n\n    if(unlikely(!hash_action)) {\n        hash_action = simple_hash(\"action\");\n        hash_access = simple_hash(\"access\");\n        hash_hello = simple_hash(\"hello\");\n        hash_delete = simple_hash(\"delete\");\n        hash_search = simple_hash(\"search\");\n        hash_switch = simple_hash(\"switch\");\n        hash_machine = simple_hash(\"machine\");\n        hash_url = simple_hash(\"url\");\n        hash_name = simple_hash(\"name\");\n        hash_delete_url = simple_hash(\"delete_url\");\n        hash_for = simple_hash(\"for\");\n        hash_to = simple_hash(\"to\");\n/*\n        hash_redirects = simple_hash(\"redirects\");\n*/\n    }\n\n    char person_guid[GUID_LEN + 1] = \"\";\n\n    debug(D_WEB_CLIENT, \"%llu: API v1 registry with URL '%s'\", w->id, url);\n\n    // TODO\n    // The browser may send multiple cookies with our id\n\n    char *cookie = strstr(w->response.data->buffer, NETDATA_REGISTRY_COOKIE_NAME \"=\");\n    if(cookie)\n        strncpyz(person_guid, &cookie[sizeof(NETDATA_REGISTRY_COOKIE_NAME)], 36);\n\n    char action = '\\0';\n    char *machine_guid = NULL,\n            *machine_url = NULL,\n            *url_name = NULL,\n            *search_machine_guid = NULL,\n            *delete_url = NULL,\n            *to_person_guid = NULL;\n/*\n    int redirects = 0;\n*/\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if (!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if (!name || !*name) continue;\n        if (!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 registry query param '%s' with value '%s'\", w->id, name, value);\n\n        uint32_t hash = simple_hash(name);\n\n        if(hash == hash_action && !strcmp(name, \"action\")) {\n            uint32_t vhash = simple_hash(value);\n\n            if(vhash == hash_access && !strcmp(value, \"access\")) action = 'A';\n            else if(vhash == hash_hello && !strcmp(value, \"hello\")) action = 'H';\n            else if(vhash == hash_delete && !strcmp(value, \"delete\")) action = 'D';\n            else if(vhash == hash_search && !strcmp(value, \"search\")) action = 'S';\n            else if(vhash == hash_switch && !strcmp(value, \"switch\")) action = 'W';\n#ifdef NETDATA_INTERNAL_CHECKS\n            else error(\"unknown registry action '%s'\", value);\n#endif /* NETDATA_INTERNAL_CHECKS */\n        }\n/*\n        else if(hash == hash_redirects && !strcmp(name, \"redirects\"))\n            redirects = atoi(value);\n*/\n        else if(hash == hash_machine && !strcmp(name, \"machine\"))\n            machine_guid = value;\n\n        else if(hash == hash_url && !strcmp(name, \"url\"))\n            machine_url = value;\n\n        else if(action == 'A') {\n            if(hash == hash_name && !strcmp(name, \"name\"))\n                url_name = value;\n        }\n        else if(action == 'D') {\n            if(hash == hash_delete_url && !strcmp(name, \"delete_url\"))\n                delete_url = value;\n        }\n        else if(action == 'S') {\n            if(hash == hash_for && !strcmp(name, \"for\"))\n                search_machine_guid = value;\n        }\n        else if(action == 'W') {\n            if(hash == hash_to && !strcmp(name, \"to\"))\n                to_person_guid = value;\n        }\n#ifdef NETDATA_INTERNAL_CHECKS\n        else error(\"unused registry URL parameter '%s' with value '%s'\", name, value);\n#endif /* NETDATA_INTERNAL_CHECKS */\n    }\n\n    if(unlikely(respect_web_browser_do_not_track_policy && web_client_has_donottrack(w))) {\n        buffer_flush(w->response.data);\n        buffer_sprintf(w->response.data, \"Your web browser is sending 'DNT: 1' (Do Not Track). The registry requires persistent cookies on your browser to work.\");\n        return 400;\n    }\n\n    if(unlikely(action == 'H')) {\n        // HELLO request, dashboard ACL\n        if(unlikely(!web_client_can_access_dashboard(w)))\n            return web_client_permission_denied(w);\n    }\n    else {\n        // everything else, registry ACL\n        if(unlikely(!web_client_can_access_registry(w)))\n            return web_client_permission_denied(w);\n    }\n\n    switch(action) {\n        case 'A':\n            if(unlikely(!machine_guid || !machine_url || !url_name)) {\n                error(\"Invalid registry request - access requires these parameters: machine ('%s'), url ('%s'), name ('%s')\", machine_guid ? machine_guid : \"UNSET\", machine_url ? machine_url : \"UNSET\", url_name ? url_name : \"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Access request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_access_json(host, w, person_guid, machine_guid, machine_url, url_name, now_realtime_sec());\n\n        case 'D':\n            if(unlikely(!machine_guid || !machine_url || !delete_url)) {\n                error(\"Invalid registry request - delete requires these parameters: machine ('%s'), url ('%s'), delete_url ('%s')\", machine_guid?machine_guid:\"UNSET\", machine_url?machine_url:\"UNSET\", delete_url?delete_url:\"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Delete request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_delete_json(host, w, person_guid, machine_guid, machine_url, delete_url, now_realtime_sec());\n\n        case 'S':\n            if(unlikely(!machine_guid || !machine_url || !search_machine_guid)) {\n                error(\"Invalid registry request - search requires these parameters: machine ('%s'), url ('%s'), for ('%s')\", machine_guid?machine_guid:\"UNSET\", machine_url?machine_url:\"UNSET\", search_machine_guid?search_machine_guid:\"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Search request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_search_json(host, w, person_guid, machine_guid, machine_url, search_machine_guid, now_realtime_sec());\n\n        case 'W':\n            if(unlikely(!machine_guid || !machine_url || !to_person_guid)) {\n                error(\"Invalid registry request - switching identity requires these parameters: machine ('%s'), url ('%s'), to ('%s')\", machine_guid?machine_guid:\"UNSET\", machine_url?machine_url:\"UNSET\", to_person_guid?to_person_guid:\"UNSET\");\n                buffer_flush(w->response.data);\n                buffer_strcat(w->response.data, \"Invalid registry Switch request.\");\n                return 400;\n            }\n\n            web_client_enable_tracking_required(w);\n            return registry_request_switch_json(host, w, person_guid, machine_guid, machine_url, to_person_guid, now_realtime_sec());\n\n        case 'H':\n            return registry_request_hello_json(host, w);\n\n        default:\n            buffer_flush(w->response.data);\n            buffer_strcat(w->response.data, \"Invalid registry request - you need to set an action: hello, access, delete, search\");\n            return 400;\n    }\n}\n\nstatic struct api_command {\n    const char *command;\n    uint32_t hash;\n    WEB_CLIENT_ACL acl;\n    int (*callback)(RRDHOST *host, struct web_client *w, char *url);\n} api_commands[] = {\n        { \"data\",            0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_data            },\n        { \"chart\",           0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_chart           },\n        { \"charts\",          0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_charts          },\n\n        // registry checks the ACL by itself, so we allow everything\n        { \"registry\",        0, WEB_CLIENT_ACL_NOCHECK,   web_client_api_request_v1_registry        },\n\n        // badges can be fetched with both dashboard and badge permissions\n        { \"badge.svg\",       0, WEB_CLIENT_ACL_DASHBOARD|WEB_CLIENT_ACL_BADGE, web_client_api_request_v1_badge },\n\n        { \"alarms\",          0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_alarms          },\n        { \"alarm_log\",       0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_alarm_log       },\n        { \"alarm_variables\", 0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_alarm_variables },\n        { \"allmetrics\",      0, WEB_CLIENT_ACL_DASHBOARD, web_client_api_request_v1_allmetrics      },\n\n        // terminator\n        { NULL,              0, WEB_CLIENT_ACL_NONE,      NULL                                      },\n};\n\ninline int web_client_api_request_v1(RRDHOST *host, struct web_client *w, char *url) {\n    static int initialized = 0;\n    int i;\n\n    if(unlikely(initialized == 0)) {\n        initialized = 1;\n\n        for(i = 0; api_commands[i].command ; i++)\n            api_commands[i].hash = simple_hash(api_commands[i].command);\n    }\n\n    // get the command\n    char *tok = mystrsep(&url, \"/?&\");\n    if(tok && *tok) {\n        debug(D_WEB_CLIENT, \"%llu: Searching for API v1 command '%s'.\", w->id, tok);\n        uint32_t hash = simple_hash(tok);\n\n        for(i = 0; api_commands[i].command ;i++) {\n            if(unlikely(hash == api_commands[i].hash && !strcmp(tok, api_commands[i].command))) {\n                if(unlikely(api_commands[i].acl != WEB_CLIENT_ACL_NOCHECK) && !(w->acl & api_commands[i].acl))\n                    return web_client_permission_denied(w);\n\n                return api_commands[i].callback(host, w, url);\n            }\n        }\n\n        buffer_flush(w->response.data);\n        buffer_strcat(w->response.data, \"Unsupported v1 API command: \");\n        buffer_strcat_htmlescape(w->response.data, tok);\n        return 404;\n    }\n    else {\n        buffer_flush(w->response.data);\n        buffer_sprintf(w->response.data, \"Which API v1 command?\");\n        return 400;\n    }\n}\n"], "filenames": ["libnetdata/url/url.c", "web/api/web_api_v1.c"], "buggy_code_start_loc": [63, 235], "buggy_code_end_loc": [64, 334], "fixing_code_start_loc": [63, 236], "fixing_code_end_loc": [66, 352], "type": "CWE-116", "message": "An issue was discovered in Netdata 1.10.0. Log Injection (or Log Forgery) exists via a %0a sequence in the url parameter to api/v1/registry.", "other": {"cve": {"id": "CVE-2018-18838", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-18T16:15:10.680", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Netdata 1.10.0. Log Injection (or Log Forgery) exists via a %0a sequence in the url parameter to api/v1/registry."}, {"lang": "es", "value": "Un problema fue descubierto en Netdata 1.10.0. La inyecci\u00f3n de registro (o la falsificaci\u00f3n de registro) existe a trav\u00e9s de una secuencia% 0a en el par\u00e1metro url para api / v1 / registry."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:my-netdata:netdata:1.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "16D5826B-3CFF-4A59-8CE1-226FACF34F9A"}]}]}], "references": [{"url": "https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netdata/netdata/pull/4521", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.red4sec.com/cve/netdata_log_injection.txt", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca"}}