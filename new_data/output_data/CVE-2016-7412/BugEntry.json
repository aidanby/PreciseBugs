{"buggy_code": ["/*\n  +----------------------------------------------------------------------+\n  | PHP Version 5                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 2006-2016 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Authors: Andrey Hristov <andrey@mysql.com>                           |\n  |          Ulf Wendel <uwendel@mysql.com>                              |\n  |          Georg Richter <georg@mysql.com>                             |\n  +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n#include \"php.h\"\n#include \"php_globals.h\"\n#include \"mysqlnd.h\"\n#include \"mysqlnd_priv.h\"\n#include \"mysqlnd_wireprotocol.h\"\n#include \"mysqlnd_statistics.h\"\n#include \"mysqlnd_debug.h\"\n#include \"zend_ini.h\"\n\n#define MYSQLND_SILENT 1\n\n#define MYSQLND_DUMP_HEADER_N_BODY\n\n#define\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_size, packet_type_as_text, packet_type) \\\n\t{ \\\n\t\tDBG_INF_FMT(\"buf=%p size=%u\", (buf), (buf_size)); \\\n\t\tif (FAIL == mysqlnd_read_header((conn)->net, &((packet)->header), (conn)->stats, ((conn)->error_info) TSRMLS_CC)) {\\\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT); \\\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\\\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", mysqlnd_server_gone); \\\n\t\t\tDBG_ERR_FMT(\"Can't read %s's header\", (packet_type_as_text)); \\\n\t\t\tDBG_RETURN(FAIL);\\\n\t\t}\\\n\t\tif ((buf_size) < (packet)->header.size) { \\\n\t\t\tDBG_ERR_FMT(\"Packet buffer %u wasn't big enough %u, %u bytes will be unread\", \\\n\t\t\t\t\t\t(buf_size), (packet)->header.size, (packet)->header.size - (buf_size)); \\\n\t\t\t\t\t\tDBG_RETURN(FAIL); \\\n\t\t}\\\n\t\tif (FAIL == conn->net->data->m.receive_ex((conn)->net, (buf), (packet)->header.size, (conn)->stats, ((conn)->error_info) TSRMLS_CC)) { \\\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT); \\\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\\\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", mysqlnd_server_gone); \\\n\t\t\tDBG_ERR_FMT(\"Empty '%s' packet body\", (packet_type_as_text)); \\\n\t\t\tDBG_RETURN(FAIL);\\\n\t\t} \\\n\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, packet_type_to_statistic_byte_count[packet_type], \\\n\t\t\t\t\t\t\t\t\t\t\tMYSQLND_HEADER_SIZE + (packet)->header.size, \\\n\t\t\t\t\t\t\t\t\t\t\tpacket_type_to_statistic_packet_count[packet_type], \\\n\t\t\t\t\t\t\t\t\t\t\t1); \\\n\t}\n\n\n#define BAIL_IF_NO_MORE_DATA \\\n\tif ((size_t)(p - begin) > packet->header.size) { \\\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Premature end of data (mysqlnd_wireprotocol.c:%u)\", __LINE__); \\\n\t\tgoto premature_end; \\\n\t} \\\n\n\nstatic const char *unknown_sqlstate= \"HY000\";\n\nconst char * const mysqlnd_empty_string = \"\";\n\n/* Used in mysqlnd_debug.c */\nconst char mysqlnd_read_header_name[]\t= \"mysqlnd_read_header\";\nconst char mysqlnd_read_body_name[]\t\t= \"mysqlnd_read_body\";\n\n\n#define ERROR_MARKER 0xFF\n#define EODATA_MARKER 0xFE\n\n/* {{{ mysqlnd_command_to_text\n */\nconst char * const mysqlnd_command_to_text[COM_END] =\n{\n  \"SLEEP\", \"QUIT\", \"INIT_DB\", \"QUERY\", \"FIELD_LIST\",\n  \"CREATE_DB\", \"DROP_DB\", \"REFRESH\", \"SHUTDOWN\", \"STATISTICS\",\n  \"PROCESS_INFO\", \"CONNECT\", \"PROCESS_KILL\", \"DEBUG\", \"PING\",\n  \"TIME\", \"DELAYED_INSERT\", \"CHANGE_USER\", \"BINLOG_DUMP\",\n  \"TABLE_DUMP\", \"CONNECT_OUT\", \"REGISTER_SLAVE\",\n  \"STMT_PREPARE\", \"STMT_EXECUTE\", \"STMT_SEND_LONG_DATA\", \"STMT_CLOSE\",\n  \"STMT_RESET\", \"SET_OPTION\", \"STMT_FETCH\", \"DAEMON\", \"BINLOG_DUMP_GTID\",\n  \"RESET_CONNECTION\"\n};\n/* }}} */\n\n\n\nstatic enum_mysqlnd_collected_stats packet_type_to_statistic_byte_count[PROT_LAST] =\n{\n\tSTAT_LAST,\n\tSTAT_LAST,\n\tSTAT_BYTES_RECEIVED_OK,\n\tSTAT_BYTES_RECEIVED_EOF,\n\tSTAT_LAST,\n\tSTAT_BYTES_RECEIVED_RSET_HEADER,\n\tSTAT_BYTES_RECEIVED_RSET_FIELD_META,\n\tSTAT_BYTES_RECEIVED_RSET_ROW,\n\tSTAT_BYTES_RECEIVED_PREPARE_RESPONSE,\n\tSTAT_BYTES_RECEIVED_CHANGE_USER,\n};\n\nstatic enum_mysqlnd_collected_stats packet_type_to_statistic_packet_count[PROT_LAST] =\n{\n\tSTAT_LAST,\n\tSTAT_LAST,\n\tSTAT_PACKETS_RECEIVED_OK,\n\tSTAT_PACKETS_RECEIVED_EOF,\n\tSTAT_LAST,\n\tSTAT_PACKETS_RECEIVED_RSET_HEADER,\n\tSTAT_PACKETS_RECEIVED_RSET_FIELD_META,\n\tSTAT_PACKETS_RECEIVED_RSET_ROW,\n\tSTAT_PACKETS_RECEIVED_PREPARE_RESPONSE,\n\tSTAT_PACKETS_RECEIVED_CHANGE_USER,\n};\n\n\n/* {{{ php_mysqlnd_net_field_length\n   Get next field's length */\nunsigned long\nphp_mysqlnd_net_field_length(zend_uchar **packet)\n{\n\tregister zend_uchar *p= (zend_uchar *)*packet;\n\n\tif (*p < 251) {\n\t\t(*packet)++;\n\t\treturn (unsigned long) *p;\n\t}\n\n\tswitch (*p) {\n\t\tcase 251:\n\t\t\t(*packet)++;\n\t\t\treturn MYSQLND_NULL_LENGTH;\n\t\tcase 252:\n\t\t\t(*packet) += 3;\n\t\t\treturn (unsigned long) uint2korr(p+1);\n\t\tcase 253:\n\t\t\t(*packet) += 4;\n\t\t\treturn (unsigned long) uint3korr(p+1);\n\t\tdefault:\n\t\t\t(*packet) += 9;\n\t\t\treturn (unsigned long) uint4korr(p+1);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_net_field_length_ll\n   Get next field's length */\nuint64_t\nphp_mysqlnd_net_field_length_ll(zend_uchar **packet)\n{\n\tregister zend_uchar *p= (zend_uchar *)*packet;\n\n\tif (*p < 251) {\n\t\t(*packet)++;\n\t\treturn (uint64_t) *p;\n\t}\n\n\tswitch (*p) {\n\t\tcase 251:\n\t\t\t(*packet)++;\n\t\t\treturn (uint64_t) MYSQLND_NULL_LENGTH;\n\t\tcase 252:\n\t\t\t(*packet) += 3;\n\t\t\treturn (uint64_t) uint2korr(p + 1);\n\t\tcase 253:\n\t\t\t(*packet) += 4;\n\t\t\treturn (uint64_t) uint3korr(p + 1);\n\t\tdefault:\n\t\t\t(*packet) += 9;\n\t\t\treturn (uint64_t) uint8korr(p + 1);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_net_store_length */\nzend_uchar *\nphp_mysqlnd_net_store_length(zend_uchar *packet, uint64_t length)\n{\n\tif (length < (uint64_t) L64(251)) {\n\t\t*packet = (zend_uchar) length;\n\t\treturn packet + 1;\n\t}\n\n\tif (length < (uint64_t) L64(65536)) {\n\t\t*packet++ = 252;\n\t\tint2store(packet,(unsigned int) length);\n\t\treturn packet + 2;\n\t}\n\n\tif (length < (uint64_t) L64(16777216)) {\n\t\t*packet++ = 253;\n\t\tint3store(packet,(ulong) length);\n\t\treturn packet + 3;\n\t}\n\t*packet++ = 254;\n\tint8store(packet, length);\n\treturn packet + 8;\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_net_store_length_size */\nsize_t \nphp_mysqlnd_net_store_length_size(uint64_t length)\n{\n\tif (length < (uint64_t) L64(251)) {\n\t\treturn 1;\n\t}\n\tif (length < (uint64_t) L64(65536)) {\n\t\treturn 3;\n\t}\n\tif (length < (uint64_t) L64(16777216)) {\n\t\treturn 4;\n\t}\n\treturn 9;\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_read_error_from_line */\nstatic enum_func_status\nphp_mysqlnd_read_error_from_line(zend_uchar *buf, size_t buf_len,\n\t\t\t\t\t\t\t\tchar *error, int error_buf_len,\n\t\t\t\t\t\t\t\tunsigned int *error_no, char *sqlstate TSRMLS_DC)\n{\n\tzend_uchar *p = buf;\n\tint error_msg_len= 0;\n\n\tDBG_ENTER(\"php_mysqlnd_read_error_from_line\");\n\n\t*error_no = CR_UNKNOWN_ERROR;\n\tmemcpy(sqlstate, unknown_sqlstate, MYSQLND_SQLSTATE_LENGTH);\n\n\tif (buf_len > 2) {\n\t\t*error_no = uint2korr(p);\n\t\tp+= 2;\n\t\t/*\n\t\t  sqlstate is following. No need to check for buf_left_len as we checked > 2 above,\n\t\t  if it was >=2 then we would need a check\n\t\t*/\n\t\tif (*p == '#') {\n\t\t\t++p;\n\t\t\tif ((buf_len - (p - buf)) >= MYSQLND_SQLSTATE_LENGTH) {\n\t\t\t\tmemcpy(sqlstate, p, MYSQLND_SQLSTATE_LENGTH);\n\t\t\t\tp+= MYSQLND_SQLSTATE_LENGTH;\n\t\t\t} else {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tif ((buf_len - (p - buf)) > 0) {\n\t\t\terror_msg_len = MIN((int)((buf_len - (p - buf))), (int) (error_buf_len - 1));\n\t\t\tmemcpy(error, p, error_msg_len);\n\t\t}\n\t}\nend:\n\tsqlstate[MYSQLND_SQLSTATE_LENGTH] = '\\0';\n\terror[error_msg_len]= '\\0';\n\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_read_header */\nstatic enum_func_status\nmysqlnd_read_header(MYSQLND_NET * net, MYSQLND_PACKET_HEADER * header,\n\t\t\t\t\tMYSQLND_STATS * conn_stats, MYSQLND_ERROR_INFO * error_info TSRMLS_DC)\n{\n\tzend_uchar buffer[MYSQLND_HEADER_SIZE];\n\n\tDBG_ENTER(mysqlnd_read_header_name);\n\tDBG_INF_FMT(\"compressed=%u\", net->data->compressed);\n\tif (FAIL == net->data->m.receive_ex(net, buffer, MYSQLND_HEADER_SIZE, conn_stats, error_info TSRMLS_CC)) {\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\theader->size = uint3korr(buffer);\n\theader->packet_no = uint1korr(buffer + 3);\n\n#ifdef MYSQLND_DUMP_HEADER_N_BODY\n\tDBG_INF_FMT(\"HEADER: prot_packet_no=%u size=%3u\", header->packet_no, header->size);\n#endif\n\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn_stats,\n\t\t\t\t\t\t\tSTAT_PROTOCOL_OVERHEAD_IN, MYSQLND_HEADER_SIZE,\n\t\t\t\t\t\t\tSTAT_PACKETS_RECEIVED, 1);\n\n\tif (net->data->compressed || net->packet_no == header->packet_no) {\n\t\t/*\n\t\t  Have to increase the number, so we can send correct number back. It will\n\t\t  round at 255 as this is unsigned char. The server needs this for simple\n\t\t  flow control checking.\n\t\t*/\n\t\tnet->packet_no++;\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tDBG_ERR_FMT(\"Logical link: packets out of order. Expected %u received %u. Packet size=\"MYSQLND_SZ_T_SPEC,\n\t\t\t\tnet->packet_no, header->packet_no, header->size);\n\n\tphp_error(E_WARNING, \"Packets out of order. Expected %u received %u. Packet size=\"MYSQLND_SZ_T_SPEC,\n\t\t\t  net->packet_no, header->packet_no, header->size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_greet_read */\nstatic enum_func_status\nphp_mysqlnd_greet_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buf[2048];\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tzend_uchar *pad_start = NULL;\n\tMYSQLND_PACKET_GREET *packet= (MYSQLND_PACKET_GREET *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_greet_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, sizeof(buf), \"greeting\", PROT_GREET_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->auth_plugin_data = packet->intern_auth_plugin_data;\n\tpacket->auth_plugin_data_len = sizeof(packet->intern_auth_plugin_data);\n\n\tif (packet->header.size < sizeof(buf)) {\n\t\t/*\n\t\t  Null-terminate the string, so strdup can work even if the packets have a string at the end,\n\t\t  which is not ASCIIZ\n\t\t*/\n\t\tbuf[packet->header.size] = '\\0'; \n\t}\n\n\tpacket->protocol_version = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->protocol_version) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\t/*\n\t\t  The server doesn't send sqlstate in the greet packet.\n\t\t  It's a bug#26426 , so we have to set it correctly ourselves.\n\t\t  It's probably \"Too many connections, which has SQL state 08004\".\n\t\t*/\n\t\tif (packet->error_no == 1040) {\n\t\t\tmemcpy(packet->sqlstate, \"08004\", MYSQLND_SQLSTATE_LENGTH);\n\t\t}\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tpacket->server_version = estrdup((char *)p);\n\tp+= strlen(packet->server_version) + 1; /* eat the '\\0' */\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->thread_id = uint4korr(p);\n\tp+=4;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmemcpy(packet->auth_plugin_data, p, SCRAMBLE_LENGTH_323);\n\tp+= SCRAMBLE_LENGTH_323;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* pad1 */\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->server_capabilities = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->charset_no = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->server_status = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* pad2 */\n\tpad_start = p;\n\tp+= 13;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif ((size_t) (p - buf) < packet->header.size) {\n\t\t/* auth_plugin_data is split into two parts */\n\t\tmemcpy(packet->auth_plugin_data + SCRAMBLE_LENGTH_323, p, SCRAMBLE_LENGTH - SCRAMBLE_LENGTH_323);\n\t\tp+= SCRAMBLE_LENGTH - SCRAMBLE_LENGTH_323;\n\t\tp++; /* 0x0 at the end of the scramble and thus last byte in the packet in 5.1 and previous */\n\t} else {\n\t\tpacket->pre41 = TRUE;\n\t}\n\n\t/* Is this a 5.5+ server ? */\n\tif ((size_t) (p - buf) < packet->header.size) {\n\t\t /* backtrack one byte, the 0x0 at the end of the scramble in 5.1 and previous */\n\t\tp--;\n\n    \t/* Additional 16 bits for server capabilities */\n\t\tpacket->server_capabilities |= uint2korr(pad_start) << 16;\n\t\t/* And a length of the server scramble in one byte */\n\t\tpacket->auth_plugin_data_len = uint1korr(pad_start + 2);\n\t\tif (packet->auth_plugin_data_len > SCRAMBLE_LENGTH) {\n\t\t\t/* more data*/\n\t\t\tzend_uchar * new_auth_plugin_data = emalloc(packet->auth_plugin_data_len);\n\t\t\tif (!new_auth_plugin_data) {\n\t\t\t\tgoto premature_end;\n\t\t\t}\n\t\t\t/* copy what we already have */\n\t\t\tmemcpy(new_auth_plugin_data, packet->auth_plugin_data, SCRAMBLE_LENGTH);\n\t\t\t/* add additional scramble data 5.5+ sent us */\n\t\t\tmemcpy(new_auth_plugin_data + SCRAMBLE_LENGTH, p, packet->auth_plugin_data_len - SCRAMBLE_LENGTH);\n\t\t\tp+= (packet->auth_plugin_data_len - SCRAMBLE_LENGTH);\n\t\t\tpacket->auth_plugin_data = new_auth_plugin_data;\n\t\t}\n\t}\n\n\tif (packet->server_capabilities & CLIENT_PLUGIN_AUTH) {\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\t/* The server is 5.5.x and supports authentication plugins */\n\t\tpacket->auth_protocol = estrdup((char *)p);\n\t\tp+= strlen(packet->auth_protocol) + 1; /* eat the '\\0' */\n\t}\n\n\tDBG_INF_FMT(\"proto=%u server=%s thread_id=%u\",\n\t\t\t\tpacket->protocol_version, packet->server_version, packet->thread_id);\n\n\tDBG_INF_FMT(\"server_capabilities=%u charset_no=%u server_status=%i auth_protocol=%s scramble_length=%u\",\n\t\t\t\tpacket->server_capabilities, packet->charset_no, packet->server_status,\n\t\t\t\tpacket->auth_protocol? packet->auth_protocol:\"n/a\", packet->auth_plugin_data_len);\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"GREET packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"GREET packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_greet_free_mem */\nstatic\nvoid php_mysqlnd_greet_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_GREET *p= (MYSQLND_PACKET_GREET *) _packet;\n\tif (p->server_version) {\n\t\tefree(p->server_version);\n\t\tp->server_version = NULL;\n\t}\n\tif (p->auth_plugin_data && p->auth_plugin_data != p->intern_auth_plugin_data) {\n\t\tefree(p->auth_plugin_data);\n\t\tp->auth_plugin_data = NULL;\n\t}\n\tif (p->auth_protocol) {\n\t\tefree(p->auth_protocol);\n\t\tp->auth_protocol = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define AUTH_WRITE_BUFFER_LEN (MYSQLND_HEADER_SIZE + MYSQLND_MAX_ALLOWED_USER_LEN + SCRAMBLE_LENGTH + MYSQLND_MAX_ALLOWED_DB_LEN + 1 + 4096)\n\n/* {{{ php_mysqlnd_auth_write */\nstatic\nsize_t php_mysqlnd_auth_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buffer[AUTH_WRITE_BUFFER_LEN];\n\tzend_uchar *p = buffer + MYSQLND_HEADER_SIZE; /* start after the header */\n\tint len;\n\tMYSQLND_PACKET_AUTH * packet= (MYSQLND_PACKET_AUTH *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_auth_write\");\n\n\tif (!packet->is_change_user_packet) {\n\t\tint4store(p, packet->client_flags);\n\t\tp+= 4;\n\n\t\tint4store(p, packet->max_packet_size);\n\t\tp+= 4;\n\n\t\tint1store(p, packet->charset_no);\n\t\tp++;\n\n\t\tmemset(p, 0, 23); /* filler */\n\t\tp+= 23;\n\t}\n\n\tif (packet->send_auth_data || packet->is_change_user_packet) {\n\t\tlen = MIN(strlen(packet->user), MYSQLND_MAX_ALLOWED_USER_LEN);\n\t\tmemcpy(p, packet->user, len);\n\t\tp+= len;\n\t\t*p++ = '\\0';\n\n\t\t/* defensive coding */\n\t\tif (packet->auth_data == NULL) {\n\t\t\tpacket->auth_data_len = 0;\n\t\t}\n\t\tif (packet->auth_data_len > 0xFF) {\n\t\t\tconst char * const msg = \"Authentication data too long. \"\n\t\t\t\t\"Won't fit into the buffer and will be truncated. Authentication will thus fail\";\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_UNKNOWN_ERROR, UNKNOWN_SQLSTATE, msg);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", msg);\n\t\t\tDBG_RETURN(0);\n\t\t}\t\t\n\t\t\n\t\tint1store(p, packet->auth_data_len);\n\t\t++p;\n/*!!!!! is the buffer big enough ??? */\n\t\tif ((sizeof(buffer) - (p - buffer)) < packet->auth_data_len) {\n\t\t\tDBG_ERR(\"the stack buffer was not enough!!\");\n\t\t\tDBG_RETURN(0);\n\t\t}\n\t\tif (packet->auth_data_len) {\n\t\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\t\tp+= packet->auth_data_len;\n\t\t}\n\n\t\tif (packet->db) {\n\t\t\t/* CLIENT_CONNECT_WITH_DB should have been set */\n\t\t\tsize_t real_db_len = MIN(MYSQLND_MAX_ALLOWED_DB_LEN, packet->db_len);\n\t\t\tmemcpy(p, packet->db, real_db_len);\n\t\t\tp+= real_db_len;\n\t\t\t*p++= '\\0';\n\t\t} else if (packet->is_change_user_packet) {\n\t\t\t*p++= '\\0';\t\t\n\t\t}\n\t\t/* no \\0 for no DB */\n\n\t\tif (packet->is_change_user_packet) {\n\t\t\tif (packet->charset_no) {\n\t\t\t\tint2store(p, packet->charset_no);\n\t\t\t\tp+= 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (packet->auth_plugin_name) {\n\t\t\tsize_t len = MIN(strlen(packet->auth_plugin_name), sizeof(buffer) - (p - buffer) - 1);\n\t\t\tmemcpy(p, packet->auth_plugin_name, len);\n\t\t\tp+= len;\n\t\t\t*p++= '\\0';\n\t\t}\n\n\t\tif (packet->connect_attr && zend_hash_num_elements(packet->connect_attr)) {\n\t\t\tHashPosition pos_value;\n\t\t\tconst char ** entry_value;\n\t\t\tsize_t ca_payload_len = 0;\n\t\t\tzend_hash_internal_pointer_reset_ex(packet->connect_attr, &pos_value);\n\t\t\twhile (SUCCESS == zend_hash_get_current_data_ex(packet->connect_attr, (void **)&entry_value, &pos_value)) {\n\t\t\t\tchar *s_key;\n\t\t\t\tunsigned int s_len;\n\t\t\t\tunsigned long num_key;\n\t\t\t\tsize_t value_len = strlen(*entry_value);\n\t\t\t\t\n\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(packet->connect_attr, &s_key, &s_len, &num_key, 0, &pos_value)) {\n\t\t\t\t\tca_payload_len += php_mysqlnd_net_store_length_size(s_len);\n\t\t\t\t\tca_payload_len += s_len;\n\t\t\t\t\tca_payload_len += php_mysqlnd_net_store_length_size(value_len);\n\t\t\t\t\tca_payload_len += value_len;\n\t\t\t\t}\n\t\t\t\tzend_hash_move_forward_ex(conn->options->connect_attr, &pos_value);\n\t\t\t}\n\n\t\t\tif ((sizeof(buffer) - (p - buffer)) >= (ca_payload_len + php_mysqlnd_net_store_length_size(ca_payload_len))) {\n\t\t\t\tp = php_mysqlnd_net_store_length(p, ca_payload_len);\n\n\t\t\t\tzend_hash_internal_pointer_reset_ex(packet->connect_attr, &pos_value);\n\t\t\t\twhile (SUCCESS == zend_hash_get_current_data_ex(packet->connect_attr, (void **)&entry_value, &pos_value)) {\n\t\t\t\t\tchar *s_key;\n\t\t\t\t\tunsigned int s_len;\n\t\t\t\t\tunsigned long num_key;\n\t\t\t\t\tsize_t value_len = strlen(*entry_value);\n\t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(packet->connect_attr, &s_key, &s_len, &num_key, 0, &pos_value)) {\n\t\t\t\t\t\t/* copy key */\n\t\t\t\t\t\tp = php_mysqlnd_net_store_length(p, s_len);\n\t\t\t\t\t\tmemcpy(p, s_key, s_len);\n\t\t\t\t\t\tp+= s_len;\n\t\t\t\t\t\t/* copy value */\n\t\t\t\t\t\tp = php_mysqlnd_net_store_length(p, value_len);\n\t\t\t\t\t\tmemcpy(p, *entry_value, value_len);\n\t\t\t\t\t\tp+= value_len;\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward_ex(conn->options->connect_attr, &pos_value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* cannot put the data - skip */\n\t\t\t}\n\t\t}\n\t}\n\tif (packet->is_change_user_packet) {\n\t\tif (PASS != conn->m->simple_command(conn, COM_CHANGE_USER, buffer + MYSQLND_HEADER_SIZE, p - buffer - MYSQLND_HEADER_SIZE,\n\t\t\t\t\t\t\t\t\t\t   PROT_LAST /* the caller will handle the OK packet */,\n\t\t\t\t\t\t\t\t\t\t   packet->silent, TRUE TSRMLS_CC)) {\n\t\t\tDBG_RETURN(0);\n\t\t}\n\t\tDBG_RETURN(p - buffer - MYSQLND_HEADER_SIZE);\n\t} else {\n\t\tsize_t sent = conn->net->data->m.send_ex(conn->net, buffer, p - buffer - MYSQLND_HEADER_SIZE, conn->stats, conn->error_info TSRMLS_CC);\n\t\tif (!sent) {\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_auth_free_mem */\nstatic\nvoid php_mysqlnd_auth_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_AUTH * p = (MYSQLND_PACKET_AUTH *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define AUTH_RESP_BUFFER_SIZE 2048\n\n/* {{{ php_mysqlnd_auth_response_read */\nstatic enum_func_status\nphp_mysqlnd_auth_response_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar local_buf[AUTH_RESP_BUFFER_SIZE];\n\tsize_t buf_len = conn->net->cmd_buffer.buffer? conn->net->cmd_buffer.length: AUTH_RESP_BUFFER_SIZE;\n\tzend_uchar *buf = conn->net->cmd_buffer.buffer? (zend_uchar *) conn->net->cmd_buffer.buffer : local_buf;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tunsigned long i;\n\tregister MYSQLND_PACKET_AUTH_RESPONSE * packet= (MYSQLND_PACKET_AUTH_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_auth_response_read\");\n\n\t/* leave space for terminating safety \\0 */\n\tbuf_len--;\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"OK\", PROT_OK_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/*\n\t  zero-terminate the buffer for safety. We are sure there is place for the \\0\n\t  because buf_len is -1 the size of the buffer pointed\n\t*/\n\tbuf[packet->header.size] = '\\0';\n\t\n\t/* Should be always 0x0 or ERROR_MARKER for error */\n\tpacket->response_code = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->response_code) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_RETURN(PASS);\n\t}\n\tif (0xFE == packet->response_code) {\n\t\t/* Authentication Switch Response */\n\t\tif (packet->header.size > (size_t) (p - buf)) {\n\t\t\tpacket->new_auth_protocol = mnd_pestrdup((char *)p, FALSE);\n\t\t\tpacket->new_auth_protocol_len = strlen(packet->new_auth_protocol);\n\t\t\tp+= packet->new_auth_protocol_len + 1; /* +1 for the \\0 */\n\n\t\t\tpacket->new_auth_protocol_data_len = packet->header.size - (size_t) (p - buf);\n\t\t\tif (packet->new_auth_protocol_data_len) {\n\t\t\t\tpacket->new_auth_protocol_data = mnd_emalloc(packet->new_auth_protocol_data_len);\n\t\t\t\tmemcpy(packet->new_auth_protocol_data, p, packet->new_auth_protocol_data_len);\n\t\t\t}\n\t\t\tDBG_INF_FMT(\"The server requested switching auth plugin to : %s\", packet->new_auth_protocol);\n\t\t\tDBG_INF_FMT(\"Server salt : [%d][%.*s]\", packet->new_auth_protocol_data_len, packet->new_auth_protocol_data_len, packet->new_auth_protocol_data);\n\t\t}\n\t} else {\n\t\t/* Everything was fine! */\n\t\tpacket->affected_rows  = php_mysqlnd_net_field_length_ll(&p);\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->last_insert_id = php_mysqlnd_net_field_length_ll(&p);\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->server_status = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->warning_count = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t/* There is a message */\n\t\tif (packet->header.size > (size_t) (p - buf) && (i = php_mysqlnd_net_field_length(&p))) {\n\t\t\tpacket->message_len = MIN(i, buf_len - (p - begin));\n\t\t\tpacket->message = mnd_pestrndup((char *)p, packet->message_len, FALSE);\n\t\t} else {\n\t\t\tpacket->message = NULL;\n\t\t\tpacket->message_len = 0;\n\t\t}\n\n\t\tDBG_INF_FMT(\"OK packet: aff_rows=%lld last_ins_id=%ld server_status=%u warnings=%u\",\n\t\t\t\t\tpacket->affected_rows, packet->last_insert_id, packet->server_status,\n\t\t\t\t\tpacket->warning_count);\n\t}\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"OK packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"AUTH_RESPONSE packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_auth_response_free_mem */\nstatic void\nphp_mysqlnd_auth_response_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_AUTH_RESPONSE * p = (MYSQLND_PACKET_AUTH_RESPONSE *) _packet;\n\tif (p->message) {\n\t\tmnd_efree(p->message);\n\t\tp->message = NULL;\n\t}\n\tif (p->new_auth_protocol) {\n\t\tmnd_efree(p->new_auth_protocol);\n\t\tp->new_auth_protocol = NULL;\n\t}\n\tp->new_auth_protocol_len = 0;\n\n\tif (p->new_auth_protocol_data) {\n\t\tmnd_efree(p->new_auth_protocol_data);\n\t\tp->new_auth_protocol_data = NULL;\n\t}\n\tp->new_auth_protocol_data_len = 0;\n\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_change_auth_response_write */\nstatic size_t\nphp_mysqlnd_change_auth_response_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tzend_uchar * buffer = conn->net->cmd_buffer.length >= packet->auth_data_len? conn->net->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar *p = buffer + MYSQLND_HEADER_SIZE; /* start after the header */\n\n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\n\t{\n\t\tsize_t sent = conn->net->data->m.send_ex(conn->net, buffer, p - buffer - MYSQLND_HEADER_SIZE, conn->stats, conn->error_info TSRMLS_CC);\n\t\tif (buffer != conn->net->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_change_auth_response_free_mem */\nstatic void\nphp_mysqlnd_change_auth_response_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE * p = (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define OK_BUFFER_SIZE 2048\n\n/* {{{ php_mysqlnd_ok_read */\nstatic enum_func_status\nphp_mysqlnd_ok_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar local_buf[OK_BUFFER_SIZE];\n\tsize_t buf_len = conn->net->cmd_buffer.buffer? conn->net->cmd_buffer.length : OK_BUFFER_SIZE;\n\tzend_uchar *buf = conn->net->cmd_buffer.buffer? (zend_uchar *) conn->net->cmd_buffer.buffer : local_buf;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tunsigned long i;\n\tregister MYSQLND_PACKET_OK *packet= (MYSQLND_PACKET_OK *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_ok_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"OK\", PROT_OK_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Should be always 0x0 or ERROR_MARKER for error */\n\tpacket->field_count = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->field_count) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_INF_FMT(\"conn->server_status=%u\", conn->upsert_status->server_status);\n\t\tDBG_RETURN(PASS);\n\t}\n\t/* Everything was fine! */\n\tpacket->affected_rows  = php_mysqlnd_net_field_length_ll(&p);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->last_insert_id = php_mysqlnd_net_field_length_ll(&p);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->server_status = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->warning_count = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* There is a message */\n\tif (packet->header.size > (size_t) (p - buf) && (i = php_mysqlnd_net_field_length(&p))) {\n\t\tpacket->message_len = MIN(i, buf_len - (p - begin));\n\t\tpacket->message = mnd_pestrndup((char *)p, packet->message_len, FALSE);\n\t} else {\n\t\tpacket->message = NULL;\n\t\tpacket->message_len = 0;\n\t}\n\n\tDBG_INF_FMT(\"OK packet: aff_rows=%lld last_ins_id=%ld server_status=%u warnings=%u\",\n\t\t\t\tpacket->affected_rows, packet->last_insert_id, packet->server_status,\n\t\t\t\tpacket->warning_count);\n\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"OK packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"OK packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_ok_free_mem */\nstatic void\nphp_mysqlnd_ok_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_OK *p= (MYSQLND_PACKET_OK *) _packet;\n\tif (p->message) {\n\t\tmnd_efree(p->message);\n\t\tp->message = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_eof_read */\nstatic enum_func_status\nphp_mysqlnd_eof_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/*\n\t  EOF packet is since 4.1 five bytes long,\n\t  but we can get also an error, make it bigger.\n\n\t  Error : error_code + '#' + sqlstate + MYSQLND_ERRMSG_SIZE\n\t*/\n\tMYSQLND_PACKET_EOF *packet= (MYSQLND_PACKET_EOF *) _packet;\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\n\tDBG_ENTER(\"php_mysqlnd_eof_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"EOF\", PROT_EOF_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Should be always EODATA_MARKER */\n\tpacket->field_count = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->field_count) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_RETURN(PASS);\n\t}\n\n\t/*\n\t\t4.1 sends 1 byte EOF packet after metadata of\n\t\tPREPARE/EXECUTE but 5 bytes after the result. This is not\n\t\taccording to the Docs@Forge!!!\n\t*/\n\tif (packet->header.size > 1) {\n\t\tpacket->warning_count = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->server_status = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\t} else {\n\t\tpacket->warning_count = 0;\n\t\tpacket->server_status = 0;\n\t}\n\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_INF_FMT(\"EOF packet: fields=%u status=%u warnings=%u\",\n\t\t\t\tpacket->field_count, packet->server_status, packet->warning_count);\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"EOF packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"EOF packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_eof_free_mem */\nstatic\nvoid php_mysqlnd_eof_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tmnd_pefree(_packet, ((MYSQLND_PACKET_EOF *)_packet)->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_cmd_write */\nsize_t php_mysqlnd_cmd_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* Let's have some space, which we can use, if not enough, we will allocate new buffer */\n\tMYSQLND_PACKET_COMMAND * packet= (MYSQLND_PACKET_COMMAND *) _packet;\n\tMYSQLND_NET * net = conn->net;\n\tunsigned int error_reporting = EG(error_reporting);\n\tsize_t sent = 0;\n\n\tDBG_ENTER(\"php_mysqlnd_cmd_write\");\n\t/*\n\t  Reset packet_no, or we will get bad handshake!\n\t  Every command starts a new TX and packet numbers are reset to 0.\n\t*/\n\tnet->packet_no = 0;\n\tnet->compressed_envelope_packet_no = 0; /* this is for the response */\n\n\tif (error_reporting) {\n\t\tEG(error_reporting) = 0;\n\t}\n\n\tMYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_PACKETS_SENT_CMD);\n\n#ifdef MYSQLND_DO_WIRE_CHECK_BEFORE_COMMAND\n\tnet->data->m.consume_uneaten_data(net, packet->command TSRMLS_CC);\n#endif\n\n\tif (!packet->argument || !packet->arg_len) {\n\t\tzend_uchar buffer[MYSQLND_HEADER_SIZE + 1];\n\n\t\tint1store(buffer + MYSQLND_HEADER_SIZE, packet->command);\n\t\tsent = net->data->m.send_ex(net, buffer, 1, conn->stats, conn->error_info TSRMLS_CC);\n\t} else {\n\t\tsize_t tmp_len = packet->arg_len + 1 + MYSQLND_HEADER_SIZE;\n\t\tzend_uchar *tmp, *p;\n\t\ttmp = (tmp_len > net->cmd_buffer.length)? mnd_emalloc(tmp_len):net->cmd_buffer.buffer;\n\t\tif (!tmp) {\n\t\t\tgoto end;\n\t\t}\n\t\tp = tmp + MYSQLND_HEADER_SIZE; /* skip the header */\n\n\t\tint1store(p, packet->command);\n\t\tp++;\n\n\t\tmemcpy(p, packet->argument, packet->arg_len);\n\n\t\tsent = net->data->m.send_ex(net, tmp, tmp_len - MYSQLND_HEADER_SIZE, conn->stats, conn->error_info TSRMLS_CC);\n\t\tif (tmp != net->cmd_buffer.buffer) {\n\t\t\tMYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_CMD_BUFFER_TOO_SMALL);\n\t\t\tmnd_efree(tmp);\n\t\t}\n\t}\nend:\n\tif (error_reporting) {\n\t\t/* restore error reporting */\n\t\tEG(error_reporting) = error_reporting;\n\t}\n\tif (!sent) {\n\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\t}\n\tDBG_RETURN(sent);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_cmd_free_mem */\nstatic\nvoid php_mysqlnd_cmd_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_COMMAND * p = (MYSQLND_PACKET_COMMAND *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rset_header_read */\nstatic enum_func_status\nphp_mysqlnd_rset_header_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tenum_func_status ret = PASS;\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tsize_t len;\n\tMYSQLND_PACKET_RSET_HEADER *packet= (MYSQLND_PACKET_RSET_HEADER *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_rset_header_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"resultset header\", PROT_RSET_HEADER_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/*\n\t  Don't increment. First byte is ERROR_MARKER on error, but otherwise is starting byte\n\t  of encoded sequence for length.\n\t*/\n\tif (ERROR_MARKER == *p) {\n\t\t/* Error */\n\t\tp++;\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error, sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no, packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_INF_FMT(\"conn->server_status=%u\", conn->upsert_status->server_status);\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tpacket->field_count = php_mysqlnd_net_field_length(&p);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tswitch (packet->field_count) {\n\t\tcase MYSQLND_NULL_LENGTH:\n\t\t\tDBG_INF(\"LOAD LOCAL\");\n\t\t\t/*\n\t\t\t  First byte in the packet is the field count.\n\t\t\t  Thus, the name is size - 1. And we add 1 for a trailing \\0.\n\t\t\t  Because we have BAIL_IF_NO_MORE_DATA before the switch, we are guaranteed\n\t\t\t  that packet->header.size is > 0. Which means that len can't underflow, that\n\t\t\t  would lead to 0 byte allocation but 2^32 or 2^64 bytes copied.\n\t\t\t*/\n\t\t\tlen = packet->header.size - 1;\n\t\t\tpacket->info_or_local_file = mnd_emalloc(len + 1);\n\t\t\tif (packet->info_or_local_file) {\n\t\t\t\tmemcpy(packet->info_or_local_file, p, len);\n\t\t\t\tpacket->info_or_local_file[len] = '\\0';\n\t\t\t\tpacket->info_or_local_file_len = len;\n\t\t\t} else {\n\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\tret = FAIL;\t\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\tDBG_INF(\"UPSERT\");\n\t\t\tpacket->affected_rows = php_mysqlnd_net_field_length_ll(&p);\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t\tpacket->last_insert_id = php_mysqlnd_net_field_length_ll(&p);\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t\tpacket->server_status = uint2korr(p);\n\t\t\tp+=2;\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t\tpacket->warning_count = uint2korr(p);\n\t\t\tp+=2;\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\t\t\t/* Check for additional textual data */\n\t\t\tif (packet->header.size  > (size_t) (p - buf) && (len = php_mysqlnd_net_field_length(&p))) {\n\t\t\t\tpacket->info_or_local_file = mnd_emalloc(len + 1);\n\t\t\t\tif (packet->info_or_local_file) {\n\t\t\t\t\tmemcpy(packet->info_or_local_file, p, len);\n\t\t\t\t\tpacket->info_or_local_file[len] = '\\0';\n\t\t\t\t\tpacket->info_or_local_file_len = len;\n\t\t\t\t} else {\n\t\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\t\tret = FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_INF_FMT(\"affected_rows=%llu last_insert_id=%llu server_status=%u warning_count=%u\",\n\t\t\t\t\t\tpacket->affected_rows, packet->last_insert_id,\n\t\t\t\t\t\tpacket->server_status, packet->warning_count);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG_INF(\"SELECT\");\n\t\t\t/* Result set */\n\t\t\tbreak;\n\t}\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_RETURN(ret);\npremature_end:\n\tDBG_ERR_FMT(\"RSET_HEADER packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"RSET_HEADER packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rset_header_free_mem */\nstatic\nvoid php_mysqlnd_rset_header_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_RSET_HEADER *p= (MYSQLND_PACKET_RSET_HEADER *) _packet;\n\tDBG_ENTER(\"php_mysqlnd_rset_header_free_mem\");\n\tif (p->info_or_local_file) {\n\t\tmnd_efree(p->info_or_local_file);\n\t\tp->info_or_local_file = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n\tDBG_VOID_RETURN;\n}\n/* }}} */\n\nstatic size_t rset_field_offsets[] =\n{\n\tSTRUCT_OFFSET(MYSQLND_FIELD, catalog),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, catalog_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, db),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, db_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, table),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, table_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_table),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_table_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, name),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, name_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_name),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_name_length)\n};\n\n\n/* {{{ php_mysqlnd_rset_field_read */\nstatic enum_func_status\nphp_mysqlnd_rset_field_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* Should be enough for the metadata of a single row */\n\tMYSQLND_PACKET_RES_FIELD *packet= (MYSQLND_PACKET_RES_FIELD *) _packet;\n\tsize_t buf_len = conn->net->cmd_buffer.length, total_len = 0;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tchar *root_ptr;\n\tunsigned long len;\n\tMYSQLND_FIELD *meta;\n\tunsigned int i, field_count = sizeof(rset_field_offsets)/sizeof(size_t);\n\n\tDBG_ENTER(\"php_mysqlnd_rset_field_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"field\", PROT_RSET_FLD_PACKET);\n\n\tif (packet->skip_parsing) {\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tBAIL_IF_NO_MORE_DATA;\n\tif (ERROR_MARKER == *p) {\n\t\t/* Error */\n\t\tp++;\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error, sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no, packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_ERR_FMT(\"Server error : (%u) %s\", packet->error_info.error_no, packet->error_info.error);\n\t\tDBG_RETURN(PASS);\n\t} else if (EODATA_MARKER == *p && packet->header.size < 8) {\n\t\t/* Premature EOF. That should be COM_FIELD_LIST */\n\t\tDBG_INF(\"Premature EOF. That should be COM_FIELD_LIST\");\n\t\tpacket->stupid_list_fields_eof = TRUE;\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tmeta = packet->metadata;\n\n\tfor (i = 0; i < field_count; i += 2) {\n\t\tlen = php_mysqlnd_net_field_length(&p);\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tswitch ((len)) {\n\t\t\tcase 0:\n\t\t\t\t*(const char **)(((char*)meta) + rset_field_offsets[i]) = mysqlnd_empty_string;\n\t\t\t\t*(unsigned int *)(((char*)meta) + rset_field_offsets[i+1]) = 0;\n\t\t\t\tbreak;\n\t\t\tcase MYSQLND_NULL_LENGTH:\n\t\t\t\tgoto faulty_or_fake;\n\t\t\tdefault:\n\t\t\t\t*(const char **)(((char *)meta) + rset_field_offsets[i]) = (const char *)p;\n\t\t\t\t*(unsigned int *)(((char*)meta) + rset_field_offsets[i+1]) = len;\n\t\t\t\tp += len;\n\t\t\t\ttotal_len += len + 1;\n\t\t\t\tbreak;\n\t\t}\n\t\tBAIL_IF_NO_MORE_DATA;\n\t}\n\n\t/* 1 byte length */\n\tif (12 != *p) {\n\t\tDBG_ERR_FMT(\"Protocol error. Server sent false length. Expected 12 got %d\", (int) *p);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Protocol error. Server sent false length. Expected 12\");\n\t}\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->charsetnr = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->length = uint4korr(p);\n\tp += 4;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->type = uint1korr(p);\n\tp += 1;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->flags = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->decimals = uint1korr(p);\n\tp += 1;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* 2 byte filler */\n\tp +=2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Should we set NUM_FLAG (libmysql does it) ? */\n\tif (\n\t\t(meta->type <= MYSQL_TYPE_INT24 &&\n\t\t\t(meta->type != MYSQL_TYPE_TIMESTAMP || meta->length == 14 || meta->length == 8)\n\t\t) || meta->type == MYSQL_TYPE_YEAR)\n\t{\n\t\tmeta->flags |= NUM_FLAG;\n\t}\n\n\n\t/*\n\t  def could be empty, thus don't allocate on the root.\n\t  NULL_LENGTH (0xFB) comes from COM_FIELD_LIST when the default value is NULL.\n\t  Otherwise the string is length encoded.\n\t*/\n\tif (packet->header.size > (size_t) (p - buf) &&\n\t\t(len = php_mysqlnd_net_field_length(&p)) &&\n\t\tlen != MYSQLND_NULL_LENGTH)\n\t{\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tDBG_INF_FMT(\"Def found, length %lu, persistent=%u\", len, packet->persistent_alloc);\n\t\tmeta->def = mnd_pemalloc(len + 1, packet->persistent_alloc);\n\t\tif (!meta->def) {\n\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\tDBG_RETURN(FAIL);\t\t\n\t\t}\n\t\tmemcpy(meta->def, p, len);\n\t\tmeta->def[len] = '\\0';\n\t\tmeta->def_length = len;\n\t\tp += len;\n\t}\n\n\tDBG_INF_FMT(\"allocing root. persistent=%u\", packet->persistent_alloc);\n\troot_ptr = meta->root = mnd_pemalloc(total_len, packet->persistent_alloc);\n\tif (!root_ptr) {\n\t\tSET_OOM_ERROR(*conn->error_info);\n\t\tDBG_RETURN(FAIL);\t\n\t}\n\t\n\tmeta->root_len = total_len;\n\t/* Now do allocs */\n\tif (meta->catalog && meta->catalog != mysqlnd_empty_string) {\n\t\tlen = meta->catalog_length;\n\t\tmeta->catalog = memcpy(root_ptr, meta->catalog, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->db && meta->db != mysqlnd_empty_string) {\n\t\tlen = meta->db_length;\n\t\tmeta->db = memcpy(root_ptr, meta->db, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->table && meta->table != mysqlnd_empty_string) {\n\t\tlen = meta->table_length;\n\t\tmeta->table = memcpy(root_ptr, meta->table, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->org_table && meta->org_table != mysqlnd_empty_string) {\n\t\tlen = meta->org_table_length;\n\t\tmeta->org_table = memcpy(root_ptr, meta->org_table, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->name && meta->name != mysqlnd_empty_string) {\n\t\tlen = meta->name_length;\n\t\tmeta->name = memcpy(root_ptr, meta->name, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->org_name && meta->org_name != mysqlnd_empty_string) {\n\t\tlen = meta->org_name_length;\n\t\tmeta->org_name = memcpy(root_ptr, meta->org_name, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tDBG_INF_FMT(\"FIELD=[%s.%s.%s]\", meta->db? meta->db:\"*NA*\", meta->table? meta->table:\"*NA*\",\n\t\t\t\tmeta->name? meta->name:\"*NA*\");\n\n\tDBG_RETURN(PASS);\n\nfaulty_or_fake:\n\tDBG_ERR_FMT(\"Protocol error. Server sent NULL_LENGTH. The server is faulty\");\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Protocol error. Server sent NULL_LENGTH.\"\n\t\t\t\t\t \" The server is faulty\");\n\tDBG_RETURN(FAIL);\npremature_end:\n\tDBG_ERR_FMT(\"RSET field packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Result set field packet \"MYSQLND_SZ_T_SPEC\" bytes \"\n\t\t\t \t\t\"shorter than expected\", p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rset_field_free_mem */\nstatic\nvoid php_mysqlnd_rset_field_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_RES_FIELD *p= (MYSQLND_PACKET_RES_FIELD *) _packet;\n\t/* p->metadata was passed to us as temporal buffer */\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_read_row_ex */\nstatic enum_func_status\nphp_mysqlnd_read_row_ex(MYSQLND_CONN_DATA * conn, MYSQLND_MEMORY_POOL * result_set_memory_pool,\n\t\t\t\t\t\tMYSQLND_MEMORY_POOL_CHUNK ** buffer,\n\t\t\t\t\t\tsize_t * data_size, zend_bool persistent_alloc,\n\t\t\t\t\t\tunsigned int prealloc_more_bytes TSRMLS_DC)\n{\n\tenum_func_status ret = PASS;\n\tMYSQLND_PACKET_HEADER header;\n\tzend_uchar * p = NULL;\n\tzend_bool first_iteration = TRUE;\n\n\tDBG_ENTER(\"php_mysqlnd_read_row_ex\");\n\n\t/*\n\t  To ease the process the server splits everything in packets up to 2^24 - 1.\n\t  Even in the case the payload is evenly divisible by this value, the last\n\t  packet will be empty, namely 0 bytes. Thus, we can read every packet and ask\n\t  for next one if they have 2^24 - 1 sizes. But just read the header of a\n\t  zero-length byte, don't read the body, there is no such.\n\t*/\n\n\t*data_size = prealloc_more_bytes;\n\twhile (1) {\n\t\tif (FAIL == mysqlnd_read_header(conn->net, &header, conn->stats, conn->error_info TSRMLS_CC)) {\n\t\t\tret = FAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\t*data_size += header.size;\n\n\t\tif (first_iteration) {\n\t\t\tfirst_iteration = FALSE;\n\t\t\t/*\n\t\t\t  We need a trailing \\0 for the last string, in case of text-mode,\n\t\t\t  to be able to implement read-only variables. Thus, we add + 1.\n\t\t\t*/\n\t\t\t*buffer = result_set_memory_pool->get_chunk(result_set_memory_pool, *data_size + 1 TSRMLS_CC);\n\t\t\tif (!*buffer) {\n\t\t\t\tret = FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = (*buffer)->ptr;\n\t\t} else if (!first_iteration) {\n\t\t\t/* Empty packet after MYSQLND_MAX_PACKET_SIZE packet. That's ok, break */\n\t\t\tif (!header.size) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t  We have to realloc the buffer.\n\n\t\t\t  We need a trailing \\0 for the last string, in case of text-mode,\n\t\t\t  to be able to implement read-only variables.\n\t\t\t*/\n\t\t\tif (FAIL == (*buffer)->resize_chunk((*buffer), *data_size + 1 TSRMLS_CC)) {\n\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\tret = FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* The position could have changed, recalculate */\n\t\t\tp = (*buffer)->ptr + (*data_size - header.size);\n\t\t}\n\n\t\tif (PASS != (ret = conn->net->data->m.receive_ex(conn->net, p, header.size, conn->stats, conn->error_info TSRMLS_CC))) {\n\t\t\tDBG_ERR(\"Empty row packet body\");\n\t\t\tphp_error(E_WARNING, \"Empty row packet body\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header.size < MYSQLND_MAX_PACKET_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret == FAIL && *buffer) {\n\t\t(*buffer)->free_chunk((*buffer) TSRMLS_CC);\n\t\t*buffer = NULL;\n\t}\n\t*data_size -= prealloc_more_bytes;\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_read_binary_protocol */\nenum_func_status\nphp_mysqlnd_rowp_read_binary_protocol(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\t  unsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\t  zend_bool as_int_or_float, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\tunsigned int i;\n\tzend_uchar * p = row_buffer->ptr;\n\tzend_uchar * null_ptr, bit;\n\tzval **current_field, **end_field, **start_field;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_binary_protocol\");\n\n\tif (!fields) {\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tend_field = (start_field = fields) + field_count;\n\n\t/* skip the first byte, not EODATA_MARKER -> 0x0, status */\n\tp++;\n\tnull_ptr= p;\n\tp += (field_count + 9)/8;\t/* skip null bits */\n\tbit\t= 4;\t\t\t\t\t/* first 2 bits are reserved */\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\tDBG_INF(\"Directly creating zval\");\n\t\tMAKE_STD_ZVAL(*current_field);\n\t\tif (!*current_field) {\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n\t}\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\tenum_mysqlnd_collected_stats statistic;\n\t\tzend_uchar * orig_p = p;\n\n\t\tDBG_INF_FMT(\"Into zval=%p decoding column %u [%s.%s.%s] type=%u field->flags&unsigned=%u flags=%u is_bit=%u\",\n\t\t\t*current_field, i,\n\t\t\tfields_metadata[i].db, fields_metadata[i].table, fields_metadata[i].name, fields_metadata[i].type,\n\t\t\tfields_metadata[i].flags & UNSIGNED_FLAG, fields_metadata[i].flags, fields_metadata[i].type == MYSQL_TYPE_BIT);\n\t\tif (*null_ptr & bit) {\n\t\t\tDBG_INF(\"It's null\");\n\t\t\tZVAL_NULL(*current_field);\n\t\t\tstatistic = STAT_BINARY_TYPE_FETCHED_NULL;\n\t\t} else {\n\t\t\tenum_mysqlnd_field_types type = fields_metadata[i].type;\n\t\t\tmysqlnd_ps_fetch_functions[type].func(*current_field, &fields_metadata[i], 0, &p TSRMLS_CC);\n\n\t\t\tif (MYSQLND_G(collect_statistics)) {\n\t\t\t\tswitch (fields_metadata[i].type) {\n\t\t\t\t\tcase MYSQL_TYPE_DECIMAL:\tstatistic = STAT_BINARY_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT8; break;\n\t\t\t\t\tcase MYSQL_TYPE_SHORT:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT16; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT32; break;\n\t\t\t\t\tcase MYSQL_TYPE_FLOAT:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_FLOAT; break;\n\t\t\t\t\tcase MYSQL_TYPE_DOUBLE:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_DOUBLE; break;\n\t\t\t\t\tcase MYSQL_TYPE_NULL:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_NULL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIMESTAMP:\tstatistic = STAT_BINARY_TYPE_FETCHED_TIMESTAMP; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONGLONG:\tstatistic = STAT_BINARY_TYPE_FETCHED_INT64; break;\n\t\t\t\t\tcase MYSQL_TYPE_INT24:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT24; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATE:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIME:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_TIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATETIME:\tstatistic = STAT_BINARY_TYPE_FETCHED_DATETIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_YEAR:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_YEAR; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDATE:\tstatistic = STAT_BINARY_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_VARCHAR:\tstatistic = STAT_BINARY_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_BIT:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_BIT; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDECIMAL:\tstatistic = STAT_BINARY_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_ENUM:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_ENUM; break;\n\t\t\t\t\tcase MYSQL_TYPE_SET:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_SET; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY_BLOB:\tstatistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG_BLOB:\tstatistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_BLOB:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_VAR_STRING:\tstatistic = STAT_BINARY_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_STRING:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_GEOMETRY:\tstatistic = STAT_BINARY_TYPE_FETCHED_GEOMETRY; break;\n\t\t\t\t\tdefault: statistic = STAT_BINARY_TYPE_FETCHED_OTHER; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1,\n\t\t\t\t\t\t\t\t\t\tSTAT_BYTES_RECEIVED_PURE_DATA_PS,\n\t\t\t\t\t\t\t\t\t\t(Z_TYPE_PP(current_field) == IS_STRING)?\n\t\t\t\t\t\t\t\t\t\t\tZ_STRLEN_PP(current_field) : (p - orig_p));\n\n\t\tif (!((bit<<=1) & 255)) {\n\t\t\tbit = 1;\t/* to the following byte */\n\t\t\tnull_ptr++;\n\t\t}\n\t}\n\n\tDBG_RETURN(PASS);\n}\n/* }}} */\n\n/* {{{ php_mysqlnd_rowp_read_text_protocol */\nenum_func_status\nphp_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, zend_bool copy_data, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\t\n\tunsigned int i;\n\tzend_bool last_field_was_string = FALSE;\n\tzval **current_field, **end_field, **start_field;\n\tzend_uchar * p = row_buffer->ptr;\n\tsize_t data_size = row_buffer->app;\n\tzend_uchar * bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1; /* we allocate from here */\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_aux\");\n\n\tif (!fields) {\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tend_field = (start_field = fields) + field_count;\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\tDBG_INF(\"Directly creating zval\");\n\t\tMAKE_STD_ZVAL(*current_field);\n\t\tif (!*current_field) {\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n\t}\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\t/* Don't reverse the order. It is significant!*/\n\t\tzend_uchar *this_field_len_pos = p;\n\t\t/* php_mysqlnd_net_field_length() call should be after *this_field_len_pos = p; */\n\t\tunsigned long len = php_mysqlnd_net_field_length(&p);\n\n\t\tif (copy_data == FALSE && current_field > start_field && last_field_was_string) {\n\t\t\t/*\n\t\t\t  Normal queries:\n\t\t\t  We have to put \\0 now to the end of the previous field, if it was\n\t\t\t  a string. IS_NULL doesn't matter. Because we have already read our\n\t\t\t  length, then we can overwrite it in the row buffer.\n\t\t\t  This statement terminates the previous field, not the current one.\n\n\t\t\t  NULL_LENGTH is encoded in one byte, so we can stick a \\0 there.\n\t\t\t  Any string's length is encoded in at least one byte, so we can stick\n\t\t\t  a \\0 there.\n\t\t\t*/\n\n\t\t\t*this_field_len_pos = '\\0';\n\t\t}\n\n\t\t/* NULL or NOT NULL, this is the question! */\n\t\tif (len == MYSQLND_NULL_LENGTH) {\n\t\t\tZVAL_NULL(*current_field);\n\t\t\tlast_field_was_string = FALSE;\n\t\t} else {\n#if defined(MYSQLND_STRING_TO_INT_CONVERSION)\n\t\t\tstruct st_mysqlnd_perm_bind perm_bind =\n\t\t\t\t\tmysqlnd_ps_fetch_functions[fields_metadata[i].type];\n#endif\n\t\t\tif (MYSQLND_G(collect_statistics)) {\n\t\t\t\tenum_mysqlnd_collected_stats statistic;\n\t\t\t\tswitch (fields_metadata[i].type) {\n\t\t\t\t\tcase MYSQL_TYPE_DECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT8; break;\n\t\t\t\t\tcase MYSQL_TYPE_SHORT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT16; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT32; break;\n\t\t\t\t\tcase MYSQL_TYPE_FLOAT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_FLOAT; break;\n\t\t\t\t\tcase MYSQL_TYPE_DOUBLE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DOUBLE; break;\n\t\t\t\t\tcase MYSQL_TYPE_NULL:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_NULL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIMESTAMP:\tstatistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONGLONG:\tstatistic = STAT_TEXT_TYPE_FETCHED_INT64; break;\n\t\t\t\t\tcase MYSQL_TYPE_INT24:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT24; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIME:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_TIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATETIME:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATETIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_YEAR:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_YEAR; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDATE:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_VARCHAR:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_BIT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BIT; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_ENUM:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_ENUM; break;\n\t\t\t\t\tcase MYSQL_TYPE_SET:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_SET; break;\n\t\t\t\t\tcase MYSQL_TYPE_JSON:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_JSON; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_BLOB:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_VAR_STRING:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_STRING:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_GEOMETRY:\tstatistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY; break;\n\t\t\t\t\tdefault: statistic = STAT_TEXT_TYPE_FETCHED_OTHER; break;\n\t\t\t\t}\n\t\t\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1, STAT_BYTES_RECEIVED_PURE_DATA_TEXT, len);\n\t\t\t}\n#ifdef MYSQLND_STRING_TO_INT_CONVERSION\n\t\t\tif (as_int_or_float && perm_bind.php_type == IS_LONG) {\n\t\t\t\tzend_uchar save = *(p + len);\n\t\t\t\t/* We have to make it ASCIIZ temporarily */\n\t\t\t\t*(p + len) = '\\0';\n\t\t\t\tif (perm_bind.pack_len < SIZEOF_LONG) {\n\t\t\t\t\t/* direct conversion */\n\t\t\t\t\tint64_t v =\n#ifndef PHP_WIN32\n\t\t\t\t\t\tatoll((char *) p);\n#else\n\t\t\t\t\t\t_atoi64((char *) p);\n#endif\n\t\t\t\t\tZVAL_LONG(*current_field, (long) v); /* the cast is safe */\n\t\t\t\t} else {\n\t\t\t\t\tuint64_t v =\n#ifndef PHP_WIN32\n\t\t\t\t\t\t(uint64_t) atoll((char *) p);\n#else\n\t\t\t\t\t\t(uint64_t) _atoi64((char *) p);\n#endif\n\t\t\t\t\tzend_bool uns = fields_metadata[i].flags & UNSIGNED_FLAG? TRUE:FALSE;\n\t\t\t\t\t/* We have to make it ASCIIZ temporarily */\n#if SIZEOF_LONG==8\n\t\t\t\t\tif (uns == TRUE && v > 9223372036854775807L)\n#elif SIZEOF_LONG==4\n\t\t\t\t\tif ((uns == TRUE && v > L64(2147483647)) ||\n\t\t\t\t\t\t(uns == FALSE && (( L64(2147483647) < (int64_t) v) ||\n\t\t\t\t\t\t(L64(-2147483648) > (int64_t) v))))\n#else\n#error Need fix for this architecture\n#endif /* SIZEOF */\n\t\t\t\t\t{\n\t\t\t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tZVAL_LONG(*current_field, (long) v); /* the cast is safe */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*(p + len) = save;\n\t\t\t} else if (as_int_or_float && perm_bind.php_type == IS_DOUBLE) {\n\t\t\t\tzend_uchar save = *(p + len);\n\t\t\t\t/* We have to make it ASCIIZ temporarily */\n\t\t\t\t*(p + len) = '\\0';\n\t\t\t\tZVAL_DOUBLE(*current_field, atof((char *) p));\n\t\t\t\t*(p + len) = save;\n\t\t\t} else\n#endif /* MYSQLND_STRING_TO_INT_CONVERSION */\n\t\t\tif (fields_metadata[i].type == MYSQL_TYPE_BIT) {\n\t\t\t\t/*\n\t\t\t\t  BIT fields are specially handled. As they come as bit mask, we have\n\t\t\t\t  to convert it to human-readable representation. As the bits take\n\t\t\t\t  less space in the protocol than the numbers they represent, we don't\n\t\t\t\t  have enough space in the packet buffer to overwrite inside.\n\t\t\t\t  Thus, a bit more space is pre-allocated at the end of the buffer,\n\t\t\t\t  see php_mysqlnd_rowp_read(). And we add the strings at the end.\n\t\t\t\t  Definitely not nice, _hackish_ :(, but works.\n\t\t\t\t*/\n\t\t\t\tzend_uchar *start = bit_area;\n\t\t\t\tps_fetch_from_1_to_8_bytes(*current_field, &(fields_metadata[i]), 0, &p, len TSRMLS_CC);\n\t\t\t\t/*\n\t\t\t\t  We have advanced in ps_fetch_from_1_to_8_bytes. We should go back because\n\t\t\t\t  later in this function there will be an advancement.\n\t\t\t\t*/\n\t\t\t\tp -= len;\n\t\t\t\tif (Z_TYPE_PP(current_field) == IS_LONG) {\n\t\t\t\t\tbit_area += 1 + sprintf((char *)start, \"%ld\", Z_LVAL_PP(current_field));\n\t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n\t\t\t\t} else if (Z_TYPE_PP(current_field) == IS_STRING){\n\t\t\t\t\tmemcpy(bit_area, Z_STRVAL_PP(current_field), Z_STRLEN_PP(current_field));\n\t\t\t\t\tbit_area += Z_STRLEN_PP(current_field);\n\t\t\t\t\t*bit_area++ = '\\0';\n\t\t\t\t\tzval_dtor(*current_field);\n\t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, copy_data);\n\t\t\t}\n\t\t\tp += len;\n\t\t\tlast_field_was_string = TRUE;\n\t\t}\n\t}\n\tif (copy_data == FALSE && last_field_was_string) {\n\t\t/* Normal queries: The buffer has one more byte at the end, because we need it */\n\t\trow_buffer->ptr[data_size] = '\\0';\n\t}\n\n\tDBG_RETURN(PASS);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_read_text_protocol_zval */\nenum_func_status\nphp_mysqlnd_rowp_read_text_protocol_zval(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\tenum_func_status ret;\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_zval\");\n\tret = php_mysqlnd_rowp_read_text_protocol_aux(row_buffer, fields, field_count, fields_metadata, as_int_or_float, FALSE, stats TSRMLS_CC);\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_read_text_protocol_c */\nenum_func_status\nphp_mysqlnd_rowp_read_text_protocol_c(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\tenum_func_status ret;\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_c\");\n\tret = php_mysqlnd_rowp_read_text_protocol_aux(row_buffer, fields, field_count, fields_metadata, as_int_or_float, TRUE, stats TSRMLS_CC);\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n\n\n/* {{{ php_mysqlnd_rowp_read */\n/*\n  if normal statements => packet->fields is created by this function,\n  if PS => packet->fields is passed from outside\n*/\nstatic enum_func_status\nphp_mysqlnd_rowp_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar *p;\n\tenum_func_status ret = PASS;\n\tMYSQLND_PACKET_ROW *packet= (MYSQLND_PACKET_ROW *) _packet;\n\tsize_t post_alloc_for_bit_fields = 0;\n\tsize_t data_size = 0;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_read\");\n\n\tif (!packet->binary_protocol && packet->bit_fields_count) {\n\t\t/* For every field we need terminating \\0 */\n\t\tpost_alloc_for_bit_fields = packet->bit_fields_total_len + packet->bit_fields_count;\n\t}\n\n\tret = php_mysqlnd_read_row_ex(conn, packet->result_set_memory_pool, &packet->row_buffer, &data_size,\n\t\t\t\t\t\t\t\t  packet->persistent_alloc, post_alloc_for_bit_fields\n\t\t\t\t\t\t\t\t  TSRMLS_CC);\n\tif (FAIL == ret) {\n\t\tgoto end;\n\t}\n\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, packet_type_to_statistic_byte_count[PROT_ROW_PACKET],\n\t\t\t\t\t\t\t\t\t\tMYSQLND_HEADER_SIZE + packet->header.size,\n\t\t\t\t\t\t\t\t\t\tpacket_type_to_statistic_packet_count[PROT_ROW_PACKET],\n\t\t\t\t\t\t\t\t\t\t1);\n\n\t/* packet->row_buffer->ptr is of size 'data_size + 1' */\n\tpacket->header.size = data_size;\n\tpacket->row_buffer->app = data_size;\n\n\tif (ERROR_MARKER == (*(p = packet->row_buffer->ptr))) {\n\t\t/*\n\t\t   Error message as part of the result set,\n\t\t   not good but we should not hang. See:\n\t\t   Bug #27876 : SF with cyrillic variable name fails during execution\n\t\t*/\n\t\tret = FAIL;\n\t\tphp_mysqlnd_read_error_from_line(p + 1, data_size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error,\n\t\t\t\t\t\t\t\t\t\t sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t} else if (EODATA_MARKER == *p && data_size < 8) { /* EOF */\n\t\tpacket->eof = TRUE;\n\t\tp++;\n\t\tif (data_size > 1) {\n\t\t\tpacket->warning_count = uint2korr(p);\n\t\t\tp += 2;\n\t\t\tpacket->server_status = uint2korr(p);\n\t\t\t/* Seems we have 3 bytes reserved for future use */\n\t\t\tDBG_INF_FMT(\"server_status=%u warning_count=%u\", packet->server_status, packet->warning_count);\n\t\t}\n\t} else {\n\t\tMYSQLND_INC_CONN_STATISTIC(conn->stats,\n\t\t\t\t\t\t\t\t\tpacket->binary_protocol? STAT_ROWS_FETCHED_FROM_SERVER_PS:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t STAT_ROWS_FETCHED_FROM_SERVER_NORMAL);\n\n\t\tpacket->eof = FALSE;\n\t\t/* packet->field_count is set by the user of the packet */\n\n\t\tif (!packet->skip_extraction) {\n\t\t\tif (!packet->fields) {\n\t\t\t\tDBG_INF(\"Allocating packet->fields\");\n\t\t\t\t/*\n\t\t\t\t  old-API will probably set packet->fields to NULL every time, though for\n\t\t\t\t  unbuffered sets it makes not much sense as the zvals in this buffer matter,\n\t\t\t\t  not the buffer. Constantly allocating and deallocating brings nothing.\n\n\t\t\t\t  For PS - if stmt_store() is performed, thus we don't have a cursor, it will\n\t\t\t\t  behave just like old-API buffered. Cursors will behave like a bit different,\n\t\t\t\t  but mostly like old-API unbuffered and thus will populate this array with\n\t\t\t\t  value.\n\t\t\t\t*/\n\t\t\t\tpacket->fields = (zval **) mnd_pecalloc(packet->field_count, sizeof(zval *),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpacket->persistent_alloc);\n\t\t\t}\n\t\t} else {\n\t\t\tMYSQLND_INC_CONN_STATISTIC(conn->stats,\n\t\t\t\t\t\t\t\t\t\tpacket->binary_protocol? STAT_ROWS_SKIPPED_PS:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t STAT_ROWS_SKIPPED_NORMAL);\n\t\t}\n\t}\n\nend:\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_free_mem */\nstatic void\nphp_mysqlnd_rowp_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_ROW *p;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_free_mem\");\n\tp = (MYSQLND_PACKET_ROW *) _packet;\n\tif (p->row_buffer) {\n\t\tp->row_buffer->free_chunk(p->row_buffer TSRMLS_CC);\n\t\tp->row_buffer = NULL;\n\t}\n\tDBG_INF_FMT(\"stack_allocation=%u persistent=%u\", (int)stack_allocation, (int)p->header.persistent);\n\t/*\n\t  Don't free packet->fields :\n\t  - normal queries -> store_result() | fetch_row_unbuffered() will transfer\n\t    the ownership and NULL it.\n\t  - PS will pass in it the bound variables, we have to use them! and of course\n\t    not free the array. As it is passed to us, we should not clean it ourselves.\n\t*/\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n\tDBG_VOID_RETURN;\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_stats_read */\nstatic enum_func_status\nphp_mysqlnd_stats_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tMYSQLND_PACKET_STATS *packet= (MYSQLND_PACKET_STATS *) _packet;\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\n\tDBG_ENTER(\"php_mysqlnd_stats_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"statistics\", PROT_STATS_PACKET);\n\n\tpacket->message = mnd_emalloc(packet->header.size + 1);\n\tmemcpy(packet->message, buf, packet->header.size);\n\tpacket->message[packet->header.size] = '\\0';\n\tpacket->message_len = packet->header.size;\n\n\tDBG_RETURN(PASS);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_stats_free_mem */\nstatic\nvoid php_mysqlnd_stats_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_STATS *p= (MYSQLND_PACKET_STATS *) _packet;\n\tif (p->message) {\n\t\tmnd_efree(p->message);\n\t\tp->message = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* 1 + 4 (id) + 2 (field_c) + 2 (param_c) + 1 (filler) + 2 (warnings ) */\n#define PREPARE_RESPONSE_SIZE_41 9\n#define PREPARE_RESPONSE_SIZE_50 12\n\n/* {{{ php_mysqlnd_prepare_read */\nstatic enum_func_status\nphp_mysqlnd_prepare_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* In case of an error, we should have place to put it */\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tunsigned int data_size;\n\tMYSQLND_PACKET_PREPARE_RESPONSE *packet= (MYSQLND_PACKET_PREPARE_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_prepare_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"prepare\", PROT_PREPARE_RESP_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tdata_size = packet->header.size;\n\tpacket->error_code = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->error_code) {\n\t\tphp_mysqlnd_read_error_from_line(p, data_size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error,\n\t\t\t\t\t\t\t\t\t\t sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tif (data_size != PREPARE_RESPONSE_SIZE_41 &&\n\t\tdata_size != PREPARE_RESPONSE_SIZE_50 &&\n\t\t!(data_size > PREPARE_RESPONSE_SIZE_50)) {\n\t\tDBG_ERR_FMT(\"Wrong COM_STMT_PREPARE response size. Received %u\", data_size);\n\t\tphp_error(E_WARNING, \"Wrong COM_STMT_PREPARE response size. Received %u\", data_size);\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tpacket->stmt_id = uint4korr(p);\n\tp += 4;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Number of columns in result set */\n\tpacket->field_count = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->param_count = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (data_size > 9) {\n\t\t/* 0x0 filler sent by the server for 5.0+ clients */\n\t\tp++;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->warning_count = uint2korr(p);\n\t}\n\n\tDBG_INF_FMT(\"Prepare packet read: stmt_id=%u fields=%u params=%u\",\n\t\t\t\tpacket->stmt_id, packet->field_count, packet->param_count);\n\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"PREPARE packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"PREPARE packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_prepare_free_mem */\nstatic void\nphp_mysqlnd_prepare_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_PREPARE_RESPONSE *p= (MYSQLND_PACKET_PREPARE_RESPONSE *) _packet;\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_chg_user_read */\nstatic enum_func_status\nphp_mysqlnd_chg_user_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* There could be an error message */\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tMYSQLND_PACKET_CHG_USER_RESPONSE *packet= (MYSQLND_PACKET_CHG_USER_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_chg_user_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"change user response\", PROT_CHG_USER_RESP_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/*\n\t  Don't increment. First byte is ERROR_MARKER on error, but otherwise is starting byte\n\t  of encoded sequence for length.\n\t*/\n\n\t/* Should be always 0x0 or ERROR_MARKER for error */\n\tpacket->response_code = uint1korr(p);\n\tp++;\n\n\tif (packet->header.size == 1 && buf[0] == EODATA_MARKER && packet->server_capabilities & CLIENT_SECURE_CONNECTION) {\n\t\t/* We don't handle 3.23 authentication */\n\t\tpacket->server_asked_323_auth = TRUE;\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tif (ERROR_MARKER == packet->response_code) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error,\n\t\t\t\t\t\t\t\t\t\t sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t}\n\tBAIL_IF_NO_MORE_DATA;\n\tif (packet->response_code == 0xFE && packet->header.size > (size_t) (p - buf)) {\n\t\tpacket->new_auth_protocol = mnd_pestrdup((char *)p, FALSE);\n\t\tpacket->new_auth_protocol_len = strlen(packet->new_auth_protocol);\n\t\tp+= packet->new_auth_protocol_len + 1; /* +1 for the \\0 */\n\t\tpacket->new_auth_protocol_data_len = packet->header.size - (size_t) (p - buf);\n\t\tif (packet->new_auth_protocol_data_len) {\n\t\t\tpacket->new_auth_protocol_data = mnd_emalloc(packet->new_auth_protocol_data_len);\n\t\t\tmemcpy(packet->new_auth_protocol_data, p, packet->new_auth_protocol_data_len);\n\t\t}\n\t\tDBG_INF_FMT(\"The server requested switching auth plugin to : %s\", packet->new_auth_protocol);\n\t\tDBG_INF_FMT(\"Server salt : [%*s]\", packet->new_auth_protocol_data_len, packet->new_auth_protocol_data);\n\t}\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"CHANGE_USER packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"CHANGE_USER packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_chg_user_free_mem */\nstatic void\nphp_mysqlnd_chg_user_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_CHG_USER_RESPONSE * p = (MYSQLND_PACKET_CHG_USER_RESPONSE *) _packet;\n\n\tif (p->new_auth_protocol) {\n\t\tmnd_efree(p->new_auth_protocol);\n\t\tp->new_auth_protocol = NULL;\n\t}\n\tp->new_auth_protocol_len = 0;\n\n\tif (p->new_auth_protocol_data) {\n\t\tmnd_efree(p->new_auth_protocol_data);\n\t\tp->new_auth_protocol_data = NULL;\n\t}\n\tp->new_auth_protocol_data_len = 0;\n\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_sha256_pk_request_write */\nstatic\nsize_t php_mysqlnd_sha256_pk_request_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buffer[MYSQLND_HEADER_SIZE + 1];\n\tsize_t sent;\n\n\tDBG_ENTER(\"php_mysqlnd_sha256_pk_request_write\");\n\n\tint1store(buffer + MYSQLND_HEADER_SIZE, '\\1');\n\tsent = conn->net->data->m.send_ex(conn->net, buffer, 1, conn->stats, conn->error_info TSRMLS_CC);\n\n\tDBG_RETURN(sent);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_sha256_pk_request_free_mem */\nstatic\nvoid php_mysqlnd_sha256_pk_request_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_SHA256_PK_REQUEST * p = (MYSQLND_PACKET_SHA256_PK_REQUEST *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define SHA256_PK_REQUEST_RESP_BUFFER_SIZE 2048\n\n/* {{{ php_mysqlnd_sha256_pk_request_response_read */\nstatic enum_func_status\nphp_mysqlnd_sha256_pk_request_response_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buf[SHA256_PK_REQUEST_RESP_BUFFER_SIZE];\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tMYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE * packet= (MYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_sha256_pk_request_response_read\");\n\n\t/* leave space for terminating safety \\0 */\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, sizeof(buf), \"SHA256_PK_REQUEST_RESPONSE\", PROT_SHA256_PK_REQUEST_RESPONSE_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->public_key_len = packet->header.size - (p - buf);\n\tpacket->public_key = mnd_emalloc(packet->public_key_len + 1);\n\tmemcpy(packet->public_key, p, packet->public_key_len);\n\tpacket->public_key[packet->public_key_len] = '\\0';\n\n\tDBG_RETURN(PASS);\n\npremature_end:\n\tDBG_ERR_FMT(\"OK packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"SHA256_PK_REQUEST_RESPONSE packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_sha256_pk_request_response_free_mem */\nstatic void\nphp_mysqlnd_sha256_pk_request_response_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE * p = (MYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE *) _packet;\n\tif (p->public_key) {\n\t\tmnd_efree(p->public_key);\n\t\tp->public_key = NULL;\n\t}\n\tp->public_key_len = 0;\n\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ packet_methods */\nstatic\nmysqlnd_packet_methods packet_methods[PROT_LAST] =\n{\n\t{\n\t\tsizeof(MYSQLND_PACKET_GREET),\n\t\tphp_mysqlnd_greet_read,\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_greet_free_mem,\n\t}, /* PROT_GREET_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_AUTH),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_auth_write,\n\t\tphp_mysqlnd_auth_free_mem,\n\t}, /* PROT_AUTH_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_AUTH_RESPONSE),\n\t\tphp_mysqlnd_auth_response_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_auth_response_free_mem,\n\t}, /* PROT_AUTH_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_CHANGE_AUTH_RESPONSE),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_change_auth_response_write, /* write */\n\t\tphp_mysqlnd_change_auth_response_free_mem,\n\t}, /* PROT_CHANGE_AUTH_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_OK),\n\t\tphp_mysqlnd_ok_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_ok_free_mem,\n\t}, /* PROT_OK_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_EOF),\n\t\tphp_mysqlnd_eof_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_eof_free_mem,\n\t}, /* PROT_EOF_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_COMMAND),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_cmd_write, /* write */\n\t\tphp_mysqlnd_cmd_free_mem,\n\t}, /* PROT_CMD_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_RSET_HEADER),\n\t\tphp_mysqlnd_rset_header_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_rset_header_free_mem,\n\t}, /* PROT_RSET_HEADER_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_RES_FIELD),\n\t\tphp_mysqlnd_rset_field_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_rset_field_free_mem,\n\t}, /* PROT_RSET_FLD_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_ROW),\n\t\tphp_mysqlnd_rowp_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_rowp_free_mem,\n\t}, /* PROT_ROW_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_STATS),\n\t\tphp_mysqlnd_stats_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_stats_free_mem,\n\t}, /* PROT_STATS_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_PREPARE_RESPONSE),\n\t\tphp_mysqlnd_prepare_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_prepare_free_mem,\n\t}, /* PROT_PREPARE_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_CHG_USER_RESPONSE),\n\t\tphp_mysqlnd_chg_user_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_chg_user_free_mem,\n\t}, /* PROT_CHG_USER_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_SHA256_PK_REQUEST),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_sha256_pk_request_write,\n\t\tphp_mysqlnd_sha256_pk_request_free_mem,\n\t}, /* PROT_SHA256_PK_REQUEST_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE),\n\t\tphp_mysqlnd_sha256_pk_request_response_read,\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_sha256_pk_request_response_free_mem,\n\t} /* PROT_SHA256_PK_REQUEST_RESPONSE_PACKET */\n};\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_greet_packet */\nstatic struct st_mysqlnd_packet_greet *\nMYSQLND_METHOD(mysqlnd_protocol, get_greet_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_greet * packet = mnd_pecalloc(1, packet_methods[PROT_GREET_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_greet_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_GREET_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_auth_packet */\nstatic struct st_mysqlnd_packet_auth *\nMYSQLND_METHOD(mysqlnd_protocol, get_auth_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_auth * packet = mnd_pecalloc(1, packet_methods[PROT_AUTH_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_auth_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_AUTH_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_auth_response_packet */\nstatic struct st_mysqlnd_packet_auth_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_auth_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_auth_response * packet = mnd_pecalloc(1, packet_methods[PROT_AUTH_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_auth_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_AUTH_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_change_auth_response_packet */\nstatic struct st_mysqlnd_packet_change_auth_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_change_auth_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_change_auth_response * packet = mnd_pecalloc(1, packet_methods[PROT_CHANGE_AUTH_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_change_auth_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_CHANGE_AUTH_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_ok_packet */\nstatic struct st_mysqlnd_packet_ok *\nMYSQLND_METHOD(mysqlnd_protocol, get_ok_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_ok * packet = mnd_pecalloc(1, packet_methods[PROT_OK_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_ok_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_OK_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_eof_packet */\nstatic struct st_mysqlnd_packet_eof *\nMYSQLND_METHOD(mysqlnd_protocol, get_eof_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_eof * packet = mnd_pecalloc(1, packet_methods[PROT_EOF_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_eof_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_EOF_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_command_packet */\nstatic struct st_mysqlnd_packet_command *\nMYSQLND_METHOD(mysqlnd_protocol, get_command_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_command * packet = mnd_pecalloc(1, packet_methods[PROT_CMD_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_command_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_CMD_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_rset_packet */\nstatic struct st_mysqlnd_packet_rset_header *\nMYSQLND_METHOD(mysqlnd_protocol, get_rset_header_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_rset_header * packet = mnd_pecalloc(1, packet_methods[PROT_RSET_HEADER_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_rset_header_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_RSET_HEADER_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_result_field_packet */\nstatic struct st_mysqlnd_packet_res_field *\nMYSQLND_METHOD(mysqlnd_protocol, get_result_field_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_res_field * packet = mnd_pecalloc(1, packet_methods[PROT_RSET_FLD_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_result_field_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_RSET_FLD_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_row_packet */\nstatic struct st_mysqlnd_packet_row *\nMYSQLND_METHOD(mysqlnd_protocol, get_row_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_row * packet = mnd_pecalloc(1, packet_methods[PROT_ROW_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_row_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_ROW_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_stats_packet */\nstatic struct st_mysqlnd_packet_stats *\nMYSQLND_METHOD(mysqlnd_protocol, get_stats_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_stats * packet = mnd_pecalloc(1, packet_methods[PROT_STATS_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_stats_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_STATS_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_prepare_response_packet */\nstatic struct st_mysqlnd_packet_prepare_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_prepare_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_prepare_response * packet = mnd_pecalloc(1, packet_methods[PROT_PREPARE_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_prepare_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_PREPARE_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_change_user_response_packet */\nstatic struct st_mysqlnd_packet_chg_user_resp*\nMYSQLND_METHOD(mysqlnd_protocol, get_change_user_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_chg_user_resp * packet = mnd_pecalloc(1, packet_methods[PROT_CHG_USER_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_change_user_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_CHG_USER_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_sha256_pk_request_packet */\nstatic struct st_mysqlnd_packet_sha256_pk_request *\nMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_sha256_pk_request * packet = mnd_pecalloc(1, packet_methods[PROT_SHA256_PK_REQUEST_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_sha256_pk_request_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_SHA256_PK_REQUEST_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_sha256_pk_request_response_packet */\nstatic struct st_mysqlnd_packet_sha256_pk_request_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_sha256_pk_request_response * packet = mnd_pecalloc(1, packet_methods[PROT_SHA256_PK_REQUEST_RESPONSE_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_sha256_pk_request_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_SHA256_PK_REQUEST_RESPONSE_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n\nMYSQLND_CLASS_METHODS_START(mysqlnd_protocol)\n\tMYSQLND_METHOD(mysqlnd_protocol, get_greet_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_auth_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_auth_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_change_auth_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_ok_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_command_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_eof_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_rset_header_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_result_field_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_row_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_stats_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_prepare_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_change_user_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_response_packet)\nMYSQLND_CLASS_METHODS_END;\n\n\n/* {{{ mysqlnd_protocol_init */\nPHPAPI MYSQLND_PROTOCOL *\nmysqlnd_protocol_init(zend_bool persistent TSRMLS_DC)\n{\n\tMYSQLND_PROTOCOL * ret;\n\tDBG_ENTER(\"mysqlnd_protocol_init\");\n\tret = MYSQLND_CLASS_METHOD_TABLE_NAME(mysqlnd_object_factory).get_protocol_decoder(persistent TSRMLS_CC);\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol_free */\nPHPAPI void\nmysqlnd_protocol_free(MYSQLND_PROTOCOL * const protocol TSRMLS_DC)\n{\n\tDBG_ENTER(\"mysqlnd_protocol_free\");\n\n\tif (protocol) {\n\t\tzend_bool pers = protocol->persistent;\n\t\tmnd_pefree(protocol, pers);\n\t}\n\tDBG_VOID_RETURN;\n}\n/* }}} */\n\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n"], "fixing_code": ["/*\n  +----------------------------------------------------------------------+\n  | PHP Version 5                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 2006-2016 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Authors: Andrey Hristov <andrey@mysql.com>                           |\n  |          Ulf Wendel <uwendel@mysql.com>                              |\n  |          Georg Richter <georg@mysql.com>                             |\n  +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n#include \"php.h\"\n#include \"php_globals.h\"\n#include \"mysqlnd.h\"\n#include \"mysqlnd_priv.h\"\n#include \"mysqlnd_wireprotocol.h\"\n#include \"mysqlnd_statistics.h\"\n#include \"mysqlnd_debug.h\"\n#include \"zend_ini.h\"\n\n#define MYSQLND_SILENT 1\n\n#define MYSQLND_DUMP_HEADER_N_BODY\n\n#define\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_size, packet_type_as_text, packet_type) \\\n\t{ \\\n\t\tDBG_INF_FMT(\"buf=%p size=%u\", (buf), (buf_size)); \\\n\t\tif (FAIL == mysqlnd_read_header((conn)->net, &((packet)->header), (conn)->stats, ((conn)->error_info) TSRMLS_CC)) {\\\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT); \\\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\\\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", mysqlnd_server_gone); \\\n\t\t\tDBG_ERR_FMT(\"Can't read %s's header\", (packet_type_as_text)); \\\n\t\t\tDBG_RETURN(FAIL);\\\n\t\t}\\\n\t\tif ((buf_size) < (packet)->header.size) { \\\n\t\t\tDBG_ERR_FMT(\"Packet buffer %u wasn't big enough %u, %u bytes will be unread\", \\\n\t\t\t\t\t\t(buf_size), (packet)->header.size, (packet)->header.size - (buf_size)); \\\n\t\t\t\t\t\tDBG_RETURN(FAIL); \\\n\t\t}\\\n\t\tif (FAIL == conn->net->data->m.receive_ex((conn)->net, (buf), (packet)->header.size, (conn)->stats, ((conn)->error_info) TSRMLS_CC)) { \\\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT); \\\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\\\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", mysqlnd_server_gone); \\\n\t\t\tDBG_ERR_FMT(\"Empty '%s' packet body\", (packet_type_as_text)); \\\n\t\t\tDBG_RETURN(FAIL);\\\n\t\t} \\\n\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, packet_type_to_statistic_byte_count[packet_type], \\\n\t\t\t\t\t\t\t\t\t\t\tMYSQLND_HEADER_SIZE + (packet)->header.size, \\\n\t\t\t\t\t\t\t\t\t\t\tpacket_type_to_statistic_packet_count[packet_type], \\\n\t\t\t\t\t\t\t\t\t\t\t1); \\\n\t}\n\n\n#define BAIL_IF_NO_MORE_DATA \\\n\tif ((size_t)(p - begin) > packet->header.size) { \\\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Premature end of data (mysqlnd_wireprotocol.c:%u)\", __LINE__); \\\n\t\tgoto premature_end; \\\n\t} \\\n\n\nstatic const char *unknown_sqlstate= \"HY000\";\n\nconst char * const mysqlnd_empty_string = \"\";\n\n/* Used in mysqlnd_debug.c */\nconst char mysqlnd_read_header_name[]\t= \"mysqlnd_read_header\";\nconst char mysqlnd_read_body_name[]\t\t= \"mysqlnd_read_body\";\n\n\n#define ERROR_MARKER 0xFF\n#define EODATA_MARKER 0xFE\n\n/* {{{ mysqlnd_command_to_text\n */\nconst char * const mysqlnd_command_to_text[COM_END] =\n{\n  \"SLEEP\", \"QUIT\", \"INIT_DB\", \"QUERY\", \"FIELD_LIST\",\n  \"CREATE_DB\", \"DROP_DB\", \"REFRESH\", \"SHUTDOWN\", \"STATISTICS\",\n  \"PROCESS_INFO\", \"CONNECT\", \"PROCESS_KILL\", \"DEBUG\", \"PING\",\n  \"TIME\", \"DELAYED_INSERT\", \"CHANGE_USER\", \"BINLOG_DUMP\",\n  \"TABLE_DUMP\", \"CONNECT_OUT\", \"REGISTER_SLAVE\",\n  \"STMT_PREPARE\", \"STMT_EXECUTE\", \"STMT_SEND_LONG_DATA\", \"STMT_CLOSE\",\n  \"STMT_RESET\", \"SET_OPTION\", \"STMT_FETCH\", \"DAEMON\", \"BINLOG_DUMP_GTID\",\n  \"RESET_CONNECTION\"\n};\n/* }}} */\n\n\n\nstatic enum_mysqlnd_collected_stats packet_type_to_statistic_byte_count[PROT_LAST] =\n{\n\tSTAT_LAST,\n\tSTAT_LAST,\n\tSTAT_BYTES_RECEIVED_OK,\n\tSTAT_BYTES_RECEIVED_EOF,\n\tSTAT_LAST,\n\tSTAT_BYTES_RECEIVED_RSET_HEADER,\n\tSTAT_BYTES_RECEIVED_RSET_FIELD_META,\n\tSTAT_BYTES_RECEIVED_RSET_ROW,\n\tSTAT_BYTES_RECEIVED_PREPARE_RESPONSE,\n\tSTAT_BYTES_RECEIVED_CHANGE_USER,\n};\n\nstatic enum_mysqlnd_collected_stats packet_type_to_statistic_packet_count[PROT_LAST] =\n{\n\tSTAT_LAST,\n\tSTAT_LAST,\n\tSTAT_PACKETS_RECEIVED_OK,\n\tSTAT_PACKETS_RECEIVED_EOF,\n\tSTAT_LAST,\n\tSTAT_PACKETS_RECEIVED_RSET_HEADER,\n\tSTAT_PACKETS_RECEIVED_RSET_FIELD_META,\n\tSTAT_PACKETS_RECEIVED_RSET_ROW,\n\tSTAT_PACKETS_RECEIVED_PREPARE_RESPONSE,\n\tSTAT_PACKETS_RECEIVED_CHANGE_USER,\n};\n\n\n/* {{{ php_mysqlnd_net_field_length\n   Get next field's length */\nunsigned long\nphp_mysqlnd_net_field_length(zend_uchar **packet)\n{\n\tregister zend_uchar *p= (zend_uchar *)*packet;\n\n\tif (*p < 251) {\n\t\t(*packet)++;\n\t\treturn (unsigned long) *p;\n\t}\n\n\tswitch (*p) {\n\t\tcase 251:\n\t\t\t(*packet)++;\n\t\t\treturn MYSQLND_NULL_LENGTH;\n\t\tcase 252:\n\t\t\t(*packet) += 3;\n\t\t\treturn (unsigned long) uint2korr(p+1);\n\t\tcase 253:\n\t\t\t(*packet) += 4;\n\t\t\treturn (unsigned long) uint3korr(p+1);\n\t\tdefault:\n\t\t\t(*packet) += 9;\n\t\t\treturn (unsigned long) uint4korr(p+1);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_net_field_length_ll\n   Get next field's length */\nuint64_t\nphp_mysqlnd_net_field_length_ll(zend_uchar **packet)\n{\n\tregister zend_uchar *p= (zend_uchar *)*packet;\n\n\tif (*p < 251) {\n\t\t(*packet)++;\n\t\treturn (uint64_t) *p;\n\t}\n\n\tswitch (*p) {\n\t\tcase 251:\n\t\t\t(*packet)++;\n\t\t\treturn (uint64_t) MYSQLND_NULL_LENGTH;\n\t\tcase 252:\n\t\t\t(*packet) += 3;\n\t\t\treturn (uint64_t) uint2korr(p + 1);\n\t\tcase 253:\n\t\t\t(*packet) += 4;\n\t\t\treturn (uint64_t) uint3korr(p + 1);\n\t\tdefault:\n\t\t\t(*packet) += 9;\n\t\t\treturn (uint64_t) uint8korr(p + 1);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_net_store_length */\nzend_uchar *\nphp_mysqlnd_net_store_length(zend_uchar *packet, uint64_t length)\n{\n\tif (length < (uint64_t) L64(251)) {\n\t\t*packet = (zend_uchar) length;\n\t\treturn packet + 1;\n\t}\n\n\tif (length < (uint64_t) L64(65536)) {\n\t\t*packet++ = 252;\n\t\tint2store(packet,(unsigned int) length);\n\t\treturn packet + 2;\n\t}\n\n\tif (length < (uint64_t) L64(16777216)) {\n\t\t*packet++ = 253;\n\t\tint3store(packet,(ulong) length);\n\t\treturn packet + 3;\n\t}\n\t*packet++ = 254;\n\tint8store(packet, length);\n\treturn packet + 8;\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_net_store_length_size */\nsize_t \nphp_mysqlnd_net_store_length_size(uint64_t length)\n{\n\tif (length < (uint64_t) L64(251)) {\n\t\treturn 1;\n\t}\n\tif (length < (uint64_t) L64(65536)) {\n\t\treturn 3;\n\t}\n\tif (length < (uint64_t) L64(16777216)) {\n\t\treturn 4;\n\t}\n\treturn 9;\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_read_error_from_line */\nstatic enum_func_status\nphp_mysqlnd_read_error_from_line(zend_uchar *buf, size_t buf_len,\n\t\t\t\t\t\t\t\tchar *error, int error_buf_len,\n\t\t\t\t\t\t\t\tunsigned int *error_no, char *sqlstate TSRMLS_DC)\n{\n\tzend_uchar *p = buf;\n\tint error_msg_len= 0;\n\n\tDBG_ENTER(\"php_mysqlnd_read_error_from_line\");\n\n\t*error_no = CR_UNKNOWN_ERROR;\n\tmemcpy(sqlstate, unknown_sqlstate, MYSQLND_SQLSTATE_LENGTH);\n\n\tif (buf_len > 2) {\n\t\t*error_no = uint2korr(p);\n\t\tp+= 2;\n\t\t/*\n\t\t  sqlstate is following. No need to check for buf_left_len as we checked > 2 above,\n\t\t  if it was >=2 then we would need a check\n\t\t*/\n\t\tif (*p == '#') {\n\t\t\t++p;\n\t\t\tif ((buf_len - (p - buf)) >= MYSQLND_SQLSTATE_LENGTH) {\n\t\t\t\tmemcpy(sqlstate, p, MYSQLND_SQLSTATE_LENGTH);\n\t\t\t\tp+= MYSQLND_SQLSTATE_LENGTH;\n\t\t\t} else {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tif ((buf_len - (p - buf)) > 0) {\n\t\t\terror_msg_len = MIN((int)((buf_len - (p - buf))), (int) (error_buf_len - 1));\n\t\t\tmemcpy(error, p, error_msg_len);\n\t\t}\n\t}\nend:\n\tsqlstate[MYSQLND_SQLSTATE_LENGTH] = '\\0';\n\terror[error_msg_len]= '\\0';\n\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_read_header */\nstatic enum_func_status\nmysqlnd_read_header(MYSQLND_NET * net, MYSQLND_PACKET_HEADER * header,\n\t\t\t\t\tMYSQLND_STATS * conn_stats, MYSQLND_ERROR_INFO * error_info TSRMLS_DC)\n{\n\tzend_uchar buffer[MYSQLND_HEADER_SIZE];\n\n\tDBG_ENTER(mysqlnd_read_header_name);\n\tDBG_INF_FMT(\"compressed=%u\", net->data->compressed);\n\tif (FAIL == net->data->m.receive_ex(net, buffer, MYSQLND_HEADER_SIZE, conn_stats, error_info TSRMLS_CC)) {\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\theader->size = uint3korr(buffer);\n\theader->packet_no = uint1korr(buffer + 3);\n\n#ifdef MYSQLND_DUMP_HEADER_N_BODY\n\tDBG_INF_FMT(\"HEADER: prot_packet_no=%u size=%3u\", header->packet_no, header->size);\n#endif\n\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn_stats,\n\t\t\t\t\t\t\tSTAT_PROTOCOL_OVERHEAD_IN, MYSQLND_HEADER_SIZE,\n\t\t\t\t\t\t\tSTAT_PACKETS_RECEIVED, 1);\n\n\tif (net->data->compressed || net->packet_no == header->packet_no) {\n\t\t/*\n\t\t  Have to increase the number, so we can send correct number back. It will\n\t\t  round at 255 as this is unsigned char. The server needs this for simple\n\t\t  flow control checking.\n\t\t*/\n\t\tnet->packet_no++;\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tDBG_ERR_FMT(\"Logical link: packets out of order. Expected %u received %u. Packet size=\"MYSQLND_SZ_T_SPEC,\n\t\t\t\tnet->packet_no, header->packet_no, header->size);\n\n\tphp_error(E_WARNING, \"Packets out of order. Expected %u received %u. Packet size=\"MYSQLND_SZ_T_SPEC,\n\t\t\t  net->packet_no, header->packet_no, header->size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_greet_read */\nstatic enum_func_status\nphp_mysqlnd_greet_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buf[2048];\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tzend_uchar *pad_start = NULL;\n\tMYSQLND_PACKET_GREET *packet= (MYSQLND_PACKET_GREET *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_greet_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, sizeof(buf), \"greeting\", PROT_GREET_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->auth_plugin_data = packet->intern_auth_plugin_data;\n\tpacket->auth_plugin_data_len = sizeof(packet->intern_auth_plugin_data);\n\n\tif (packet->header.size < sizeof(buf)) {\n\t\t/*\n\t\t  Null-terminate the string, so strdup can work even if the packets have a string at the end,\n\t\t  which is not ASCIIZ\n\t\t*/\n\t\tbuf[packet->header.size] = '\\0'; \n\t}\n\n\tpacket->protocol_version = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->protocol_version) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\t/*\n\t\t  The server doesn't send sqlstate in the greet packet.\n\t\t  It's a bug#26426 , so we have to set it correctly ourselves.\n\t\t  It's probably \"Too many connections, which has SQL state 08004\".\n\t\t*/\n\t\tif (packet->error_no == 1040) {\n\t\t\tmemcpy(packet->sqlstate, \"08004\", MYSQLND_SQLSTATE_LENGTH);\n\t\t}\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tpacket->server_version = estrdup((char *)p);\n\tp+= strlen(packet->server_version) + 1; /* eat the '\\0' */\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->thread_id = uint4korr(p);\n\tp+=4;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmemcpy(packet->auth_plugin_data, p, SCRAMBLE_LENGTH_323);\n\tp+= SCRAMBLE_LENGTH_323;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* pad1 */\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->server_capabilities = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->charset_no = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->server_status = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* pad2 */\n\tpad_start = p;\n\tp+= 13;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif ((size_t) (p - buf) < packet->header.size) {\n\t\t/* auth_plugin_data is split into two parts */\n\t\tmemcpy(packet->auth_plugin_data + SCRAMBLE_LENGTH_323, p, SCRAMBLE_LENGTH - SCRAMBLE_LENGTH_323);\n\t\tp+= SCRAMBLE_LENGTH - SCRAMBLE_LENGTH_323;\n\t\tp++; /* 0x0 at the end of the scramble and thus last byte in the packet in 5.1 and previous */\n\t} else {\n\t\tpacket->pre41 = TRUE;\n\t}\n\n\t/* Is this a 5.5+ server ? */\n\tif ((size_t) (p - buf) < packet->header.size) {\n\t\t /* backtrack one byte, the 0x0 at the end of the scramble in 5.1 and previous */\n\t\tp--;\n\n    \t/* Additional 16 bits for server capabilities */\n\t\tpacket->server_capabilities |= uint2korr(pad_start) << 16;\n\t\t/* And a length of the server scramble in one byte */\n\t\tpacket->auth_plugin_data_len = uint1korr(pad_start + 2);\n\t\tif (packet->auth_plugin_data_len > SCRAMBLE_LENGTH) {\n\t\t\t/* more data*/\n\t\t\tzend_uchar * new_auth_plugin_data = emalloc(packet->auth_plugin_data_len);\n\t\t\tif (!new_auth_plugin_data) {\n\t\t\t\tgoto premature_end;\n\t\t\t}\n\t\t\t/* copy what we already have */\n\t\t\tmemcpy(new_auth_plugin_data, packet->auth_plugin_data, SCRAMBLE_LENGTH);\n\t\t\t/* add additional scramble data 5.5+ sent us */\n\t\t\tmemcpy(new_auth_plugin_data + SCRAMBLE_LENGTH, p, packet->auth_plugin_data_len - SCRAMBLE_LENGTH);\n\t\t\tp+= (packet->auth_plugin_data_len - SCRAMBLE_LENGTH);\n\t\t\tpacket->auth_plugin_data = new_auth_plugin_data;\n\t\t}\n\t}\n\n\tif (packet->server_capabilities & CLIENT_PLUGIN_AUTH) {\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\t/* The server is 5.5.x and supports authentication plugins */\n\t\tpacket->auth_protocol = estrdup((char *)p);\n\t\tp+= strlen(packet->auth_protocol) + 1; /* eat the '\\0' */\n\t}\n\n\tDBG_INF_FMT(\"proto=%u server=%s thread_id=%u\",\n\t\t\t\tpacket->protocol_version, packet->server_version, packet->thread_id);\n\n\tDBG_INF_FMT(\"server_capabilities=%u charset_no=%u server_status=%i auth_protocol=%s scramble_length=%u\",\n\t\t\t\tpacket->server_capabilities, packet->charset_no, packet->server_status,\n\t\t\t\tpacket->auth_protocol? packet->auth_protocol:\"n/a\", packet->auth_plugin_data_len);\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"GREET packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"GREET packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_greet_free_mem */\nstatic\nvoid php_mysqlnd_greet_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_GREET *p= (MYSQLND_PACKET_GREET *) _packet;\n\tif (p->server_version) {\n\t\tefree(p->server_version);\n\t\tp->server_version = NULL;\n\t}\n\tif (p->auth_plugin_data && p->auth_plugin_data != p->intern_auth_plugin_data) {\n\t\tefree(p->auth_plugin_data);\n\t\tp->auth_plugin_data = NULL;\n\t}\n\tif (p->auth_protocol) {\n\t\tefree(p->auth_protocol);\n\t\tp->auth_protocol = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define AUTH_WRITE_BUFFER_LEN (MYSQLND_HEADER_SIZE + MYSQLND_MAX_ALLOWED_USER_LEN + SCRAMBLE_LENGTH + MYSQLND_MAX_ALLOWED_DB_LEN + 1 + 4096)\n\n/* {{{ php_mysqlnd_auth_write */\nstatic\nsize_t php_mysqlnd_auth_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buffer[AUTH_WRITE_BUFFER_LEN];\n\tzend_uchar *p = buffer + MYSQLND_HEADER_SIZE; /* start after the header */\n\tint len;\n\tMYSQLND_PACKET_AUTH * packet= (MYSQLND_PACKET_AUTH *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_auth_write\");\n\n\tif (!packet->is_change_user_packet) {\n\t\tint4store(p, packet->client_flags);\n\t\tp+= 4;\n\n\t\tint4store(p, packet->max_packet_size);\n\t\tp+= 4;\n\n\t\tint1store(p, packet->charset_no);\n\t\tp++;\n\n\t\tmemset(p, 0, 23); /* filler */\n\t\tp+= 23;\n\t}\n\n\tif (packet->send_auth_data || packet->is_change_user_packet) {\n\t\tlen = MIN(strlen(packet->user), MYSQLND_MAX_ALLOWED_USER_LEN);\n\t\tmemcpy(p, packet->user, len);\n\t\tp+= len;\n\t\t*p++ = '\\0';\n\n\t\t/* defensive coding */\n\t\tif (packet->auth_data == NULL) {\n\t\t\tpacket->auth_data_len = 0;\n\t\t}\n\t\tif (packet->auth_data_len > 0xFF) {\n\t\t\tconst char * const msg = \"Authentication data too long. \"\n\t\t\t\t\"Won't fit into the buffer and will be truncated. Authentication will thus fail\";\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_UNKNOWN_ERROR, UNKNOWN_SQLSTATE, msg);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", msg);\n\t\t\tDBG_RETURN(0);\n\t\t}\t\t\n\t\t\n\t\tint1store(p, packet->auth_data_len);\n\t\t++p;\n/*!!!!! is the buffer big enough ??? */\n\t\tif ((sizeof(buffer) - (p - buffer)) < packet->auth_data_len) {\n\t\t\tDBG_ERR(\"the stack buffer was not enough!!\");\n\t\t\tDBG_RETURN(0);\n\t\t}\n\t\tif (packet->auth_data_len) {\n\t\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\t\tp+= packet->auth_data_len;\n\t\t}\n\n\t\tif (packet->db) {\n\t\t\t/* CLIENT_CONNECT_WITH_DB should have been set */\n\t\t\tsize_t real_db_len = MIN(MYSQLND_MAX_ALLOWED_DB_LEN, packet->db_len);\n\t\t\tmemcpy(p, packet->db, real_db_len);\n\t\t\tp+= real_db_len;\n\t\t\t*p++= '\\0';\n\t\t} else if (packet->is_change_user_packet) {\n\t\t\t*p++= '\\0';\t\t\n\t\t}\n\t\t/* no \\0 for no DB */\n\n\t\tif (packet->is_change_user_packet) {\n\t\t\tif (packet->charset_no) {\n\t\t\t\tint2store(p, packet->charset_no);\n\t\t\t\tp+= 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (packet->auth_plugin_name) {\n\t\t\tsize_t len = MIN(strlen(packet->auth_plugin_name), sizeof(buffer) - (p - buffer) - 1);\n\t\t\tmemcpy(p, packet->auth_plugin_name, len);\n\t\t\tp+= len;\n\t\t\t*p++= '\\0';\n\t\t}\n\n\t\tif (packet->connect_attr && zend_hash_num_elements(packet->connect_attr)) {\n\t\t\tHashPosition pos_value;\n\t\t\tconst char ** entry_value;\n\t\t\tsize_t ca_payload_len = 0;\n\t\t\tzend_hash_internal_pointer_reset_ex(packet->connect_attr, &pos_value);\n\t\t\twhile (SUCCESS == zend_hash_get_current_data_ex(packet->connect_attr, (void **)&entry_value, &pos_value)) {\n\t\t\t\tchar *s_key;\n\t\t\t\tunsigned int s_len;\n\t\t\t\tunsigned long num_key;\n\t\t\t\tsize_t value_len = strlen(*entry_value);\n\t\t\t\t\n\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(packet->connect_attr, &s_key, &s_len, &num_key, 0, &pos_value)) {\n\t\t\t\t\tca_payload_len += php_mysqlnd_net_store_length_size(s_len);\n\t\t\t\t\tca_payload_len += s_len;\n\t\t\t\t\tca_payload_len += php_mysqlnd_net_store_length_size(value_len);\n\t\t\t\t\tca_payload_len += value_len;\n\t\t\t\t}\n\t\t\t\tzend_hash_move_forward_ex(conn->options->connect_attr, &pos_value);\n\t\t\t}\n\n\t\t\tif ((sizeof(buffer) - (p - buffer)) >= (ca_payload_len + php_mysqlnd_net_store_length_size(ca_payload_len))) {\n\t\t\t\tp = php_mysqlnd_net_store_length(p, ca_payload_len);\n\n\t\t\t\tzend_hash_internal_pointer_reset_ex(packet->connect_attr, &pos_value);\n\t\t\t\twhile (SUCCESS == zend_hash_get_current_data_ex(packet->connect_attr, (void **)&entry_value, &pos_value)) {\n\t\t\t\t\tchar *s_key;\n\t\t\t\t\tunsigned int s_len;\n\t\t\t\t\tunsigned long num_key;\n\t\t\t\t\tsize_t value_len = strlen(*entry_value);\n\t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(packet->connect_attr, &s_key, &s_len, &num_key, 0, &pos_value)) {\n\t\t\t\t\t\t/* copy key */\n\t\t\t\t\t\tp = php_mysqlnd_net_store_length(p, s_len);\n\t\t\t\t\t\tmemcpy(p, s_key, s_len);\n\t\t\t\t\t\tp+= s_len;\n\t\t\t\t\t\t/* copy value */\n\t\t\t\t\t\tp = php_mysqlnd_net_store_length(p, value_len);\n\t\t\t\t\t\tmemcpy(p, *entry_value, value_len);\n\t\t\t\t\t\tp+= value_len;\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward_ex(conn->options->connect_attr, &pos_value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* cannot put the data - skip */\n\t\t\t}\n\t\t}\n\t}\n\tif (packet->is_change_user_packet) {\n\t\tif (PASS != conn->m->simple_command(conn, COM_CHANGE_USER, buffer + MYSQLND_HEADER_SIZE, p - buffer - MYSQLND_HEADER_SIZE,\n\t\t\t\t\t\t\t\t\t\t   PROT_LAST /* the caller will handle the OK packet */,\n\t\t\t\t\t\t\t\t\t\t   packet->silent, TRUE TSRMLS_CC)) {\n\t\t\tDBG_RETURN(0);\n\t\t}\n\t\tDBG_RETURN(p - buffer - MYSQLND_HEADER_SIZE);\n\t} else {\n\t\tsize_t sent = conn->net->data->m.send_ex(conn->net, buffer, p - buffer - MYSQLND_HEADER_SIZE, conn->stats, conn->error_info TSRMLS_CC);\n\t\tif (!sent) {\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_auth_free_mem */\nstatic\nvoid php_mysqlnd_auth_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_AUTH * p = (MYSQLND_PACKET_AUTH *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define AUTH_RESP_BUFFER_SIZE 2048\n\n/* {{{ php_mysqlnd_auth_response_read */\nstatic enum_func_status\nphp_mysqlnd_auth_response_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar local_buf[AUTH_RESP_BUFFER_SIZE];\n\tsize_t buf_len = conn->net->cmd_buffer.buffer? conn->net->cmd_buffer.length: AUTH_RESP_BUFFER_SIZE;\n\tzend_uchar *buf = conn->net->cmd_buffer.buffer? (zend_uchar *) conn->net->cmd_buffer.buffer : local_buf;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tunsigned long i;\n\tregister MYSQLND_PACKET_AUTH_RESPONSE * packet= (MYSQLND_PACKET_AUTH_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_auth_response_read\");\n\n\t/* leave space for terminating safety \\0 */\n\tbuf_len--;\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"OK\", PROT_OK_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/*\n\t  zero-terminate the buffer for safety. We are sure there is place for the \\0\n\t  because buf_len is -1 the size of the buffer pointed\n\t*/\n\tbuf[packet->header.size] = '\\0';\n\t\n\t/* Should be always 0x0 or ERROR_MARKER for error */\n\tpacket->response_code = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->response_code) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_RETURN(PASS);\n\t}\n\tif (0xFE == packet->response_code) {\n\t\t/* Authentication Switch Response */\n\t\tif (packet->header.size > (size_t) (p - buf)) {\n\t\t\tpacket->new_auth_protocol = mnd_pestrdup((char *)p, FALSE);\n\t\t\tpacket->new_auth_protocol_len = strlen(packet->new_auth_protocol);\n\t\t\tp+= packet->new_auth_protocol_len + 1; /* +1 for the \\0 */\n\n\t\t\tpacket->new_auth_protocol_data_len = packet->header.size - (size_t) (p - buf);\n\t\t\tif (packet->new_auth_protocol_data_len) {\n\t\t\t\tpacket->new_auth_protocol_data = mnd_emalloc(packet->new_auth_protocol_data_len);\n\t\t\t\tmemcpy(packet->new_auth_protocol_data, p, packet->new_auth_protocol_data_len);\n\t\t\t}\n\t\t\tDBG_INF_FMT(\"The server requested switching auth plugin to : %s\", packet->new_auth_protocol);\n\t\t\tDBG_INF_FMT(\"Server salt : [%d][%.*s]\", packet->new_auth_protocol_data_len, packet->new_auth_protocol_data_len, packet->new_auth_protocol_data);\n\t\t}\n\t} else {\n\t\t/* Everything was fine! */\n\t\tpacket->affected_rows  = php_mysqlnd_net_field_length_ll(&p);\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->last_insert_id = php_mysqlnd_net_field_length_ll(&p);\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->server_status = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->warning_count = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t/* There is a message */\n\t\tif (packet->header.size > (size_t) (p - buf) && (i = php_mysqlnd_net_field_length(&p))) {\n\t\t\tpacket->message_len = MIN(i, buf_len - (p - begin));\n\t\t\tpacket->message = mnd_pestrndup((char *)p, packet->message_len, FALSE);\n\t\t} else {\n\t\t\tpacket->message = NULL;\n\t\t\tpacket->message_len = 0;\n\t\t}\n\n\t\tDBG_INF_FMT(\"OK packet: aff_rows=%lld last_ins_id=%ld server_status=%u warnings=%u\",\n\t\t\t\t\tpacket->affected_rows, packet->last_insert_id, packet->server_status,\n\t\t\t\t\tpacket->warning_count);\n\t}\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"OK packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"AUTH_RESPONSE packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_auth_response_free_mem */\nstatic void\nphp_mysqlnd_auth_response_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_AUTH_RESPONSE * p = (MYSQLND_PACKET_AUTH_RESPONSE *) _packet;\n\tif (p->message) {\n\t\tmnd_efree(p->message);\n\t\tp->message = NULL;\n\t}\n\tif (p->new_auth_protocol) {\n\t\tmnd_efree(p->new_auth_protocol);\n\t\tp->new_auth_protocol = NULL;\n\t}\n\tp->new_auth_protocol_len = 0;\n\n\tif (p->new_auth_protocol_data) {\n\t\tmnd_efree(p->new_auth_protocol_data);\n\t\tp->new_auth_protocol_data = NULL;\n\t}\n\tp->new_auth_protocol_data_len = 0;\n\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_change_auth_response_write */\nstatic size_t\nphp_mysqlnd_change_auth_response_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tzend_uchar * buffer = conn->net->cmd_buffer.length >= packet->auth_data_len? conn->net->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar *p = buffer + MYSQLND_HEADER_SIZE; /* start after the header */\n\n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\n\t{\n\t\tsize_t sent = conn->net->data->m.send_ex(conn->net, buffer, p - buffer - MYSQLND_HEADER_SIZE, conn->stats, conn->error_info TSRMLS_CC);\n\t\tif (buffer != conn->net->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_change_auth_response_free_mem */\nstatic void\nphp_mysqlnd_change_auth_response_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE * p = (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define OK_BUFFER_SIZE 2048\n\n/* {{{ php_mysqlnd_ok_read */\nstatic enum_func_status\nphp_mysqlnd_ok_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar local_buf[OK_BUFFER_SIZE];\n\tsize_t buf_len = conn->net->cmd_buffer.buffer? conn->net->cmd_buffer.length : OK_BUFFER_SIZE;\n\tzend_uchar *buf = conn->net->cmd_buffer.buffer? (zend_uchar *) conn->net->cmd_buffer.buffer : local_buf;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tunsigned long i;\n\tregister MYSQLND_PACKET_OK *packet= (MYSQLND_PACKET_OK *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_ok_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"OK\", PROT_OK_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Should be always 0x0 or ERROR_MARKER for error */\n\tpacket->field_count = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->field_count) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_INF_FMT(\"conn->server_status=%u\", conn->upsert_status->server_status);\n\t\tDBG_RETURN(PASS);\n\t}\n\t/* Everything was fine! */\n\tpacket->affected_rows  = php_mysqlnd_net_field_length_ll(&p);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->last_insert_id = php_mysqlnd_net_field_length_ll(&p);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->server_status = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->warning_count = uint2korr(p);\n\tp+= 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* There is a message */\n\tif (packet->header.size > (size_t) (p - buf) && (i = php_mysqlnd_net_field_length(&p))) {\n\t\tpacket->message_len = MIN(i, buf_len - (p - begin));\n\t\tpacket->message = mnd_pestrndup((char *)p, packet->message_len, FALSE);\n\t} else {\n\t\tpacket->message = NULL;\n\t\tpacket->message_len = 0;\n\t}\n\n\tDBG_INF_FMT(\"OK packet: aff_rows=%lld last_ins_id=%ld server_status=%u warnings=%u\",\n\t\t\t\tpacket->affected_rows, packet->last_insert_id, packet->server_status,\n\t\t\t\tpacket->warning_count);\n\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"OK packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"OK packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_ok_free_mem */\nstatic void\nphp_mysqlnd_ok_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_OK *p= (MYSQLND_PACKET_OK *) _packet;\n\tif (p->message) {\n\t\tmnd_efree(p->message);\n\t\tp->message = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_eof_read */\nstatic enum_func_status\nphp_mysqlnd_eof_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/*\n\t  EOF packet is since 4.1 five bytes long,\n\t  but we can get also an error, make it bigger.\n\n\t  Error : error_code + '#' + sqlstate + MYSQLND_ERRMSG_SIZE\n\t*/\n\tMYSQLND_PACKET_EOF *packet= (MYSQLND_PACKET_EOF *) _packet;\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\n\tDBG_ENTER(\"php_mysqlnd_eof_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"EOF\", PROT_EOF_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Should be always EODATA_MARKER */\n\tpacket->field_count = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->field_count) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error, sizeof(packet->error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_no, packet->sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_RETURN(PASS);\n\t}\n\n\t/*\n\t\t4.1 sends 1 byte EOF packet after metadata of\n\t\tPREPARE/EXECUTE but 5 bytes after the result. This is not\n\t\taccording to the Docs@Forge!!!\n\t*/\n\tif (packet->header.size > 1) {\n\t\tpacket->warning_count = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->server_status = uint2korr(p);\n\t\tp+= 2;\n\t\tBAIL_IF_NO_MORE_DATA;\n\t} else {\n\t\tpacket->warning_count = 0;\n\t\tpacket->server_status = 0;\n\t}\n\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_INF_FMT(\"EOF packet: fields=%u status=%u warnings=%u\",\n\t\t\t\tpacket->field_count, packet->server_status, packet->warning_count);\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"EOF packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"EOF packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_eof_free_mem */\nstatic\nvoid php_mysqlnd_eof_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tmnd_pefree(_packet, ((MYSQLND_PACKET_EOF *)_packet)->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_cmd_write */\nsize_t php_mysqlnd_cmd_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* Let's have some space, which we can use, if not enough, we will allocate new buffer */\n\tMYSQLND_PACKET_COMMAND * packet= (MYSQLND_PACKET_COMMAND *) _packet;\n\tMYSQLND_NET * net = conn->net;\n\tunsigned int error_reporting = EG(error_reporting);\n\tsize_t sent = 0;\n\n\tDBG_ENTER(\"php_mysqlnd_cmd_write\");\n\t/*\n\t  Reset packet_no, or we will get bad handshake!\n\t  Every command starts a new TX and packet numbers are reset to 0.\n\t*/\n\tnet->packet_no = 0;\n\tnet->compressed_envelope_packet_no = 0; /* this is for the response */\n\n\tif (error_reporting) {\n\t\tEG(error_reporting) = 0;\n\t}\n\n\tMYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_PACKETS_SENT_CMD);\n\n#ifdef MYSQLND_DO_WIRE_CHECK_BEFORE_COMMAND\n\tnet->data->m.consume_uneaten_data(net, packet->command TSRMLS_CC);\n#endif\n\n\tif (!packet->argument || !packet->arg_len) {\n\t\tzend_uchar buffer[MYSQLND_HEADER_SIZE + 1];\n\n\t\tint1store(buffer + MYSQLND_HEADER_SIZE, packet->command);\n\t\tsent = net->data->m.send_ex(net, buffer, 1, conn->stats, conn->error_info TSRMLS_CC);\n\t} else {\n\t\tsize_t tmp_len = packet->arg_len + 1 + MYSQLND_HEADER_SIZE;\n\t\tzend_uchar *tmp, *p;\n\t\ttmp = (tmp_len > net->cmd_buffer.length)? mnd_emalloc(tmp_len):net->cmd_buffer.buffer;\n\t\tif (!tmp) {\n\t\t\tgoto end;\n\t\t}\n\t\tp = tmp + MYSQLND_HEADER_SIZE; /* skip the header */\n\n\t\tint1store(p, packet->command);\n\t\tp++;\n\n\t\tmemcpy(p, packet->argument, packet->arg_len);\n\n\t\tsent = net->data->m.send_ex(net, tmp, tmp_len - MYSQLND_HEADER_SIZE, conn->stats, conn->error_info TSRMLS_CC);\n\t\tif (tmp != net->cmd_buffer.buffer) {\n\t\t\tMYSQLND_INC_CONN_STATISTIC(conn->stats, STAT_CMD_BUFFER_TOO_SMALL);\n\t\t\tmnd_efree(tmp);\n\t\t}\n\t}\nend:\n\tif (error_reporting) {\n\t\t/* restore error reporting */\n\t\tEG(error_reporting) = error_reporting;\n\t}\n\tif (!sent) {\n\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\t}\n\tDBG_RETURN(sent);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_cmd_free_mem */\nstatic\nvoid php_mysqlnd_cmd_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_COMMAND * p = (MYSQLND_PACKET_COMMAND *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rset_header_read */\nstatic enum_func_status\nphp_mysqlnd_rset_header_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tenum_func_status ret = PASS;\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tsize_t len;\n\tMYSQLND_PACKET_RSET_HEADER *packet= (MYSQLND_PACKET_RSET_HEADER *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_rset_header_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"resultset header\", PROT_RSET_HEADER_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/*\n\t  Don't increment. First byte is ERROR_MARKER on error, but otherwise is starting byte\n\t  of encoded sequence for length.\n\t*/\n\tif (ERROR_MARKER == *p) {\n\t\t/* Error */\n\t\tp++;\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error, sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no, packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_INF_FMT(\"conn->server_status=%u\", conn->upsert_status->server_status);\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tpacket->field_count = php_mysqlnd_net_field_length(&p);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tswitch (packet->field_count) {\n\t\tcase MYSQLND_NULL_LENGTH:\n\t\t\tDBG_INF(\"LOAD LOCAL\");\n\t\t\t/*\n\t\t\t  First byte in the packet is the field count.\n\t\t\t  Thus, the name is size - 1. And we add 1 for a trailing \\0.\n\t\t\t  Because we have BAIL_IF_NO_MORE_DATA before the switch, we are guaranteed\n\t\t\t  that packet->header.size is > 0. Which means that len can't underflow, that\n\t\t\t  would lead to 0 byte allocation but 2^32 or 2^64 bytes copied.\n\t\t\t*/\n\t\t\tlen = packet->header.size - 1;\n\t\t\tpacket->info_or_local_file = mnd_emalloc(len + 1);\n\t\t\tif (packet->info_or_local_file) {\n\t\t\t\tmemcpy(packet->info_or_local_file, p, len);\n\t\t\t\tpacket->info_or_local_file[len] = '\\0';\n\t\t\t\tpacket->info_or_local_file_len = len;\n\t\t\t} else {\n\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\tret = FAIL;\t\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\tDBG_INF(\"UPSERT\");\n\t\t\tpacket->affected_rows = php_mysqlnd_net_field_length_ll(&p);\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t\tpacket->last_insert_id = php_mysqlnd_net_field_length_ll(&p);\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t\tpacket->server_status = uint2korr(p);\n\t\t\tp+=2;\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\t\tpacket->warning_count = uint2korr(p);\n\t\t\tp+=2;\n\t\t\tBAIL_IF_NO_MORE_DATA;\n\t\t\t/* Check for additional textual data */\n\t\t\tif (packet->header.size  > (size_t) (p - buf) && (len = php_mysqlnd_net_field_length(&p))) {\n\t\t\t\tpacket->info_or_local_file = mnd_emalloc(len + 1);\n\t\t\t\tif (packet->info_or_local_file) {\n\t\t\t\t\tmemcpy(packet->info_or_local_file, p, len);\n\t\t\t\t\tpacket->info_or_local_file[len] = '\\0';\n\t\t\t\t\tpacket->info_or_local_file_len = len;\n\t\t\t\t} else {\n\t\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\t\tret = FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_INF_FMT(\"affected_rows=%llu last_insert_id=%llu server_status=%u warning_count=%u\",\n\t\t\t\t\t\tpacket->affected_rows, packet->last_insert_id,\n\t\t\t\t\t\tpacket->server_status, packet->warning_count);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG_INF(\"SELECT\");\n\t\t\t/* Result set */\n\t\t\tbreak;\n\t}\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_RETURN(ret);\npremature_end:\n\tDBG_ERR_FMT(\"RSET_HEADER packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"RSET_HEADER packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rset_header_free_mem */\nstatic\nvoid php_mysqlnd_rset_header_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_RSET_HEADER *p= (MYSQLND_PACKET_RSET_HEADER *) _packet;\n\tDBG_ENTER(\"php_mysqlnd_rset_header_free_mem\");\n\tif (p->info_or_local_file) {\n\t\tmnd_efree(p->info_or_local_file);\n\t\tp->info_or_local_file = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n\tDBG_VOID_RETURN;\n}\n/* }}} */\n\nstatic size_t rset_field_offsets[] =\n{\n\tSTRUCT_OFFSET(MYSQLND_FIELD, catalog),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, catalog_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, db),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, db_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, table),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, table_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_table),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_table_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, name),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, name_length),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_name),\n\tSTRUCT_OFFSET(MYSQLND_FIELD, org_name_length)\n};\n\n\n/* {{{ php_mysqlnd_rset_field_read */\nstatic enum_func_status\nphp_mysqlnd_rset_field_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* Should be enough for the metadata of a single row */\n\tMYSQLND_PACKET_RES_FIELD *packet= (MYSQLND_PACKET_RES_FIELD *) _packet;\n\tsize_t buf_len = conn->net->cmd_buffer.length, total_len = 0;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tchar *root_ptr;\n\tunsigned long len;\n\tMYSQLND_FIELD *meta;\n\tunsigned int i, field_count = sizeof(rset_field_offsets)/sizeof(size_t);\n\n\tDBG_ENTER(\"php_mysqlnd_rset_field_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"field\", PROT_RSET_FLD_PACKET);\n\n\tif (packet->skip_parsing) {\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tBAIL_IF_NO_MORE_DATA;\n\tif (ERROR_MARKER == *p) {\n\t\t/* Error */\n\t\tp++;\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error, sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no, packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_ERR_FMT(\"Server error : (%u) %s\", packet->error_info.error_no, packet->error_info.error);\n\t\tDBG_RETURN(PASS);\n\t} else if (EODATA_MARKER == *p && packet->header.size < 8) {\n\t\t/* Premature EOF. That should be COM_FIELD_LIST */\n\t\tDBG_INF(\"Premature EOF. That should be COM_FIELD_LIST\");\n\t\tpacket->stupid_list_fields_eof = TRUE;\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tmeta = packet->metadata;\n\n\tfor (i = 0; i < field_count; i += 2) {\n\t\tlen = php_mysqlnd_net_field_length(&p);\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tswitch ((len)) {\n\t\t\tcase 0:\n\t\t\t\t*(const char **)(((char*)meta) + rset_field_offsets[i]) = mysqlnd_empty_string;\n\t\t\t\t*(unsigned int *)(((char*)meta) + rset_field_offsets[i+1]) = 0;\n\t\t\t\tbreak;\n\t\t\tcase MYSQLND_NULL_LENGTH:\n\t\t\t\tgoto faulty_or_fake;\n\t\t\tdefault:\n\t\t\t\t*(const char **)(((char *)meta) + rset_field_offsets[i]) = (const char *)p;\n\t\t\t\t*(unsigned int *)(((char*)meta) + rset_field_offsets[i+1]) = len;\n\t\t\t\tp += len;\n\t\t\t\ttotal_len += len + 1;\n\t\t\t\tbreak;\n\t\t}\n\t\tBAIL_IF_NO_MORE_DATA;\n\t}\n\n\t/* 1 byte length */\n\tif (12 != *p) {\n\t\tDBG_ERR_FMT(\"Protocol error. Server sent false length. Expected 12 got %d\", (int) *p);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Protocol error. Server sent false length. Expected 12\");\n\t}\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->charsetnr = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->length = uint4korr(p);\n\tp += 4;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->type = uint1korr(p);\n\tp += 1;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->flags = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tmeta->decimals = uint1korr(p);\n\tp += 1;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* 2 byte filler */\n\tp +=2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Should we set NUM_FLAG (libmysql does it) ? */\n\tif (\n\t\t(meta->type <= MYSQL_TYPE_INT24 &&\n\t\t\t(meta->type != MYSQL_TYPE_TIMESTAMP || meta->length == 14 || meta->length == 8)\n\t\t) || meta->type == MYSQL_TYPE_YEAR)\n\t{\n\t\tmeta->flags |= NUM_FLAG;\n\t}\n\n\n\t/*\n\t  def could be empty, thus don't allocate on the root.\n\t  NULL_LENGTH (0xFB) comes from COM_FIELD_LIST when the default value is NULL.\n\t  Otherwise the string is length encoded.\n\t*/\n\tif (packet->header.size > (size_t) (p - buf) &&\n\t\t(len = php_mysqlnd_net_field_length(&p)) &&\n\t\tlen != MYSQLND_NULL_LENGTH)\n\t{\n\t\tBAIL_IF_NO_MORE_DATA;\n\t\tDBG_INF_FMT(\"Def found, length %lu, persistent=%u\", len, packet->persistent_alloc);\n\t\tmeta->def = mnd_pemalloc(len + 1, packet->persistent_alloc);\n\t\tif (!meta->def) {\n\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\tDBG_RETURN(FAIL);\t\t\n\t\t}\n\t\tmemcpy(meta->def, p, len);\n\t\tmeta->def[len] = '\\0';\n\t\tmeta->def_length = len;\n\t\tp += len;\n\t}\n\n\tDBG_INF_FMT(\"allocing root. persistent=%u\", packet->persistent_alloc);\n\troot_ptr = meta->root = mnd_pemalloc(total_len, packet->persistent_alloc);\n\tif (!root_ptr) {\n\t\tSET_OOM_ERROR(*conn->error_info);\n\t\tDBG_RETURN(FAIL);\t\n\t}\n\t\n\tmeta->root_len = total_len;\n\t/* Now do allocs */\n\tif (meta->catalog && meta->catalog != mysqlnd_empty_string) {\n\t\tlen = meta->catalog_length;\n\t\tmeta->catalog = memcpy(root_ptr, meta->catalog, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->db && meta->db != mysqlnd_empty_string) {\n\t\tlen = meta->db_length;\n\t\tmeta->db = memcpy(root_ptr, meta->db, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->table && meta->table != mysqlnd_empty_string) {\n\t\tlen = meta->table_length;\n\t\tmeta->table = memcpy(root_ptr, meta->table, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->org_table && meta->org_table != mysqlnd_empty_string) {\n\t\tlen = meta->org_table_length;\n\t\tmeta->org_table = memcpy(root_ptr, meta->org_table, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->name && meta->name != mysqlnd_empty_string) {\n\t\tlen = meta->name_length;\n\t\tmeta->name = memcpy(root_ptr, meta->name, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tif (meta->org_name && meta->org_name != mysqlnd_empty_string) {\n\t\tlen = meta->org_name_length;\n\t\tmeta->org_name = memcpy(root_ptr, meta->org_name, len);\n\t\t*(root_ptr +=len) = '\\0';\n\t\troot_ptr++;\n\t}\n\n\tDBG_INF_FMT(\"FIELD=[%s.%s.%s]\", meta->db? meta->db:\"*NA*\", meta->table? meta->table:\"*NA*\",\n\t\t\t\tmeta->name? meta->name:\"*NA*\");\n\n\tDBG_RETURN(PASS);\n\nfaulty_or_fake:\n\tDBG_ERR_FMT(\"Protocol error. Server sent NULL_LENGTH. The server is faulty\");\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Protocol error. Server sent NULL_LENGTH.\"\n\t\t\t\t\t \" The server is faulty\");\n\tDBG_RETURN(FAIL);\npremature_end:\n\tDBG_ERR_FMT(\"RSET field packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Result set field packet \"MYSQLND_SZ_T_SPEC\" bytes \"\n\t\t\t \t\t\"shorter than expected\", p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rset_field_free_mem */\nstatic\nvoid php_mysqlnd_rset_field_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_RES_FIELD *p= (MYSQLND_PACKET_RES_FIELD *) _packet;\n\t/* p->metadata was passed to us as temporal buffer */\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_read_row_ex */\nstatic enum_func_status\nphp_mysqlnd_read_row_ex(MYSQLND_CONN_DATA * conn, MYSQLND_MEMORY_POOL * result_set_memory_pool,\n\t\t\t\t\t\tMYSQLND_MEMORY_POOL_CHUNK ** buffer,\n\t\t\t\t\t\tsize_t * data_size, zend_bool persistent_alloc,\n\t\t\t\t\t\tunsigned int prealloc_more_bytes TSRMLS_DC)\n{\n\tenum_func_status ret = PASS;\n\tMYSQLND_PACKET_HEADER header;\n\tzend_uchar * p = NULL;\n\tzend_bool first_iteration = TRUE;\n\n\tDBG_ENTER(\"php_mysqlnd_read_row_ex\");\n\n\t/*\n\t  To ease the process the server splits everything in packets up to 2^24 - 1.\n\t  Even in the case the payload is evenly divisible by this value, the last\n\t  packet will be empty, namely 0 bytes. Thus, we can read every packet and ask\n\t  for next one if they have 2^24 - 1 sizes. But just read the header of a\n\t  zero-length byte, don't read the body, there is no such.\n\t*/\n\n\t*data_size = prealloc_more_bytes;\n\twhile (1) {\n\t\tif (FAIL == mysqlnd_read_header(conn->net, &header, conn->stats, conn->error_info TSRMLS_CC)) {\n\t\t\tret = FAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\t*data_size += header.size;\n\n\t\tif (first_iteration) {\n\t\t\tfirst_iteration = FALSE;\n\t\t\t/*\n\t\t\t  We need a trailing \\0 for the last string, in case of text-mode,\n\t\t\t  to be able to implement read-only variables. Thus, we add + 1.\n\t\t\t*/\n\t\t\t*buffer = result_set_memory_pool->get_chunk(result_set_memory_pool, *data_size + 1 TSRMLS_CC);\n\t\t\tif (!*buffer) {\n\t\t\t\tret = FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = (*buffer)->ptr;\n\t\t} else if (!first_iteration) {\n\t\t\t/* Empty packet after MYSQLND_MAX_PACKET_SIZE packet. That's ok, break */\n\t\t\tif (!header.size) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t  We have to realloc the buffer.\n\n\t\t\t  We need a trailing \\0 for the last string, in case of text-mode,\n\t\t\t  to be able to implement read-only variables.\n\t\t\t*/\n\t\t\tif (FAIL == (*buffer)->resize_chunk((*buffer), *data_size + 1 TSRMLS_CC)) {\n\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\tret = FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* The position could have changed, recalculate */\n\t\t\tp = (*buffer)->ptr + (*data_size - header.size);\n\t\t}\n\n\t\tif (PASS != (ret = conn->net->data->m.receive_ex(conn->net, p, header.size, conn->stats, conn->error_info TSRMLS_CC))) {\n\t\t\tDBG_ERR(\"Empty row packet body\");\n\t\t\tphp_error(E_WARNING, \"Empty row packet body\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header.size < MYSQLND_MAX_PACKET_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret == FAIL && *buffer) {\n\t\t(*buffer)->free_chunk((*buffer) TSRMLS_CC);\n\t\t*buffer = NULL;\n\t}\n\t*data_size -= prealloc_more_bytes;\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_read_binary_protocol */\nenum_func_status\nphp_mysqlnd_rowp_read_binary_protocol(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\t  unsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\t  zend_bool as_int_or_float, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\tunsigned int i;\n\tzend_uchar * p = row_buffer->ptr;\n\tzend_uchar * null_ptr, bit;\n\tzval **current_field, **end_field, **start_field;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_binary_protocol\");\n\n\tif (!fields) {\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tend_field = (start_field = fields) + field_count;\n\n\t/* skip the first byte, not EODATA_MARKER -> 0x0, status */\n\tp++;\n\tnull_ptr= p;\n\tp += (field_count + 9)/8;\t/* skip null bits */\n\tbit\t= 4;\t\t\t\t\t/* first 2 bits are reserved */\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\tDBG_INF(\"Directly creating zval\");\n\t\tMAKE_STD_ZVAL(*current_field);\n\t\tif (!*current_field) {\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n\t}\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\tenum_mysqlnd_collected_stats statistic;\n\t\tzend_uchar * orig_p = p;\n\n\t\tDBG_INF_FMT(\"Into zval=%p decoding column %u [%s.%s.%s] type=%u field->flags&unsigned=%u flags=%u is_bit=%u\",\n\t\t\t*current_field, i,\n\t\t\tfields_metadata[i].db, fields_metadata[i].table, fields_metadata[i].name, fields_metadata[i].type,\n\t\t\tfields_metadata[i].flags & UNSIGNED_FLAG, fields_metadata[i].flags, fields_metadata[i].type == MYSQL_TYPE_BIT);\n\t\tif (*null_ptr & bit) {\n\t\t\tDBG_INF(\"It's null\");\n\t\t\tZVAL_NULL(*current_field);\n\t\t\tstatistic = STAT_BINARY_TYPE_FETCHED_NULL;\n\t\t} else {\n\t\t\tenum_mysqlnd_field_types type = fields_metadata[i].type;\n\t\t\tmysqlnd_ps_fetch_functions[type].func(*current_field, &fields_metadata[i], 0, &p TSRMLS_CC);\n\n\t\t\tif (MYSQLND_G(collect_statistics)) {\n\t\t\t\tswitch (fields_metadata[i].type) {\n\t\t\t\t\tcase MYSQL_TYPE_DECIMAL:\tstatistic = STAT_BINARY_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT8; break;\n\t\t\t\t\tcase MYSQL_TYPE_SHORT:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT16; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT32; break;\n\t\t\t\t\tcase MYSQL_TYPE_FLOAT:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_FLOAT; break;\n\t\t\t\t\tcase MYSQL_TYPE_DOUBLE:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_DOUBLE; break;\n\t\t\t\t\tcase MYSQL_TYPE_NULL:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_NULL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIMESTAMP:\tstatistic = STAT_BINARY_TYPE_FETCHED_TIMESTAMP; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONGLONG:\tstatistic = STAT_BINARY_TYPE_FETCHED_INT64; break;\n\t\t\t\t\tcase MYSQL_TYPE_INT24:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_INT24; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATE:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIME:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_TIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATETIME:\tstatistic = STAT_BINARY_TYPE_FETCHED_DATETIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_YEAR:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_YEAR; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDATE:\tstatistic = STAT_BINARY_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_VARCHAR:\tstatistic = STAT_BINARY_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_BIT:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_BIT; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDECIMAL:\tstatistic = STAT_BINARY_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_ENUM:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_ENUM; break;\n\t\t\t\t\tcase MYSQL_TYPE_SET:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_SET; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY_BLOB:\tstatistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG_BLOB:\tstatistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_BLOB:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_VAR_STRING:\tstatistic = STAT_BINARY_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_STRING:\t\tstatistic = STAT_BINARY_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_GEOMETRY:\tstatistic = STAT_BINARY_TYPE_FETCHED_GEOMETRY; break;\n\t\t\t\t\tdefault: statistic = STAT_BINARY_TYPE_FETCHED_OTHER; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1,\n\t\t\t\t\t\t\t\t\t\tSTAT_BYTES_RECEIVED_PURE_DATA_PS,\n\t\t\t\t\t\t\t\t\t\t(Z_TYPE_PP(current_field) == IS_STRING)?\n\t\t\t\t\t\t\t\t\t\t\tZ_STRLEN_PP(current_field) : (p - orig_p));\n\n\t\tif (!((bit<<=1) & 255)) {\n\t\t\tbit = 1;\t/* to the following byte */\n\t\t\tnull_ptr++;\n\t\t}\n\t}\n\n\tDBG_RETURN(PASS);\n}\n/* }}} */\n\n/* {{{ php_mysqlnd_rowp_read_text_protocol */\nenum_func_status\nphp_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, zend_bool copy_data, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\t\n\tunsigned int i;\n\tzend_bool last_field_was_string = FALSE;\n\tzval **current_field, **end_field, **start_field;\n\tzend_uchar * p = row_buffer->ptr;\n\tsize_t data_size = row_buffer->app;\n\tzend_uchar * bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1; /* we allocate from here */\n\tconst zend_uchar * const packet_end = (zend_uchar*) row_buffer->ptr + data_size;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_aux\");\n\n\tif (!fields) {\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tend_field = (start_field = fields) + field_count;\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\tDBG_INF(\"Directly creating zval\");\n\t\tMAKE_STD_ZVAL(*current_field);\n\t\tif (!*current_field) {\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n\t}\n\n\tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n\t\t/* Don't reverse the order. It is significant!*/\n\t\tzend_uchar *this_field_len_pos = p;\n\t\t/* php_mysqlnd_net_field_length() call should be after *this_field_len_pos = p; */\n\t\tconst unsigned long len = php_mysqlnd_net_field_length(&p);\n\n\t\tif (len != MYSQLND_NULL_LENGTH && ((p + len) > packet_end)) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Malformed server packet. Field length pointing \"MYSQLND_SZ_T_SPEC\n\t\t\t\t\t\t\t\t\t\t\t  \" bytes after end of packet\", (p + len) - packet_end - 1);\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n\t\tif (copy_data == FALSE && current_field > start_field && last_field_was_string) {\n\t\t\t/*\n\t\t\t  Normal queries:\n\t\t\t  We have to put \\0 now to the end of the previous field, if it was\n\t\t\t  a string. IS_NULL doesn't matter. Because we have already read our\n\t\t\t  length, then we can overwrite it in the row buffer.\n\t\t\t  This statement terminates the previous field, not the current one.\n\n\t\t\t  NULL_LENGTH is encoded in one byte, so we can stick a \\0 there.\n\t\t\t  Any string's length is encoded in at least one byte, so we can stick\n\t\t\t  a \\0 there.\n\t\t\t*/\n\n\t\t\t*this_field_len_pos = '\\0';\n\t\t}\n\n\t\t/* NULL or NOT NULL, this is the question! */\n\t\tif (len == MYSQLND_NULL_LENGTH) {\n\t\t\tZVAL_NULL(*current_field);\n\t\t\tlast_field_was_string = FALSE;\n\t\t} else {\n#if defined(MYSQLND_STRING_TO_INT_CONVERSION)\n\t\t\tstruct st_mysqlnd_perm_bind perm_bind =\n\t\t\t\t\tmysqlnd_ps_fetch_functions[fields_metadata[i].type];\n#endif\n\t\t\tif (MYSQLND_G(collect_statistics)) {\n\t\t\t\tenum_mysqlnd_collected_stats statistic;\n\t\t\t\tswitch (fields_metadata[i].type) {\n\t\t\t\t\tcase MYSQL_TYPE_DECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT8; break;\n\t\t\t\t\tcase MYSQL_TYPE_SHORT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT16; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT32; break;\n\t\t\t\t\tcase MYSQL_TYPE_FLOAT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_FLOAT; break;\n\t\t\t\t\tcase MYSQL_TYPE_DOUBLE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DOUBLE; break;\n\t\t\t\t\tcase MYSQL_TYPE_NULL:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_NULL; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIMESTAMP:\tstatistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONGLONG:\tstatistic = STAT_TEXT_TYPE_FETCHED_INT64; break;\n\t\t\t\t\tcase MYSQL_TYPE_INT24:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT24; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_TIME:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_TIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_DATETIME:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATETIME; break;\n\t\t\t\t\tcase MYSQL_TYPE_YEAR:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_YEAR; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDATE:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n\t\t\t\t\tcase MYSQL_TYPE_VARCHAR:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_BIT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BIT; break;\n\t\t\t\t\tcase MYSQL_TYPE_NEWDECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n\t\t\t\t\tcase MYSQL_TYPE_ENUM:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_ENUM; break;\n\t\t\t\t\tcase MYSQL_TYPE_SET:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_SET; break;\n\t\t\t\t\tcase MYSQL_TYPE_JSON:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_JSON; break;\n\t\t\t\t\tcase MYSQL_TYPE_TINY_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_LONG_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_BLOB:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n\t\t\t\t\tcase MYSQL_TYPE_VAR_STRING:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_STRING:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n\t\t\t\t\tcase MYSQL_TYPE_GEOMETRY:\tstatistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY; break;\n\t\t\t\t\tdefault: statistic = STAT_TEXT_TYPE_FETCHED_OTHER; break;\n\t\t\t\t}\n\t\t\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1, STAT_BYTES_RECEIVED_PURE_DATA_TEXT, len);\n\t\t\t}\n#ifdef MYSQLND_STRING_TO_INT_CONVERSION\n\t\t\tif (as_int_or_float && perm_bind.php_type == IS_LONG) {\n\t\t\t\tzend_uchar save = *(p + len);\n\t\t\t\t/* We have to make it ASCIIZ temporarily */\n\t\t\t\t*(p + len) = '\\0';\n\t\t\t\tif (perm_bind.pack_len < SIZEOF_LONG) {\n\t\t\t\t\t/* direct conversion */\n\t\t\t\t\tint64_t v =\n#ifndef PHP_WIN32\n\t\t\t\t\t\tatoll((char *) p);\n#else\n\t\t\t\t\t\t_atoi64((char *) p);\n#endif\n\t\t\t\t\tZVAL_LONG(*current_field, (long) v); /* the cast is safe */\n\t\t\t\t} else {\n\t\t\t\t\tuint64_t v =\n#ifndef PHP_WIN32\n\t\t\t\t\t\t(uint64_t) atoll((char *) p);\n#else\n\t\t\t\t\t\t(uint64_t) _atoi64((char *) p);\n#endif\n\t\t\t\t\tzend_bool uns = fields_metadata[i].flags & UNSIGNED_FLAG? TRUE:FALSE;\n\t\t\t\t\t/* We have to make it ASCIIZ temporarily */\n#if SIZEOF_LONG==8\n\t\t\t\t\tif (uns == TRUE && v > 9223372036854775807L)\n#elif SIZEOF_LONG==4\n\t\t\t\t\tif ((uns == TRUE && v > L64(2147483647)) ||\n\t\t\t\t\t\t(uns == FALSE && (( L64(2147483647) < (int64_t) v) ||\n\t\t\t\t\t\t(L64(-2147483648) > (int64_t) v))))\n#else\n#error Need fix for this architecture\n#endif /* SIZEOF */\n\t\t\t\t\t{\n\t\t\t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tZVAL_LONG(*current_field, (long) v); /* the cast is safe */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*(p + len) = save;\n\t\t\t} else if (as_int_or_float && perm_bind.php_type == IS_DOUBLE) {\n\t\t\t\tzend_uchar save = *(p + len);\n\t\t\t\t/* We have to make it ASCIIZ temporarily */\n\t\t\t\t*(p + len) = '\\0';\n\t\t\t\tZVAL_DOUBLE(*current_field, atof((char *) p));\n\t\t\t\t*(p + len) = save;\n\t\t\t} else\n#endif /* MYSQLND_STRING_TO_INT_CONVERSION */\n\t\t\tif (fields_metadata[i].type == MYSQL_TYPE_BIT) {\n\t\t\t\t/*\n\t\t\t\t  BIT fields are specially handled. As they come as bit mask, we have\n\t\t\t\t  to convert it to human-readable representation. As the bits take\n\t\t\t\t  less space in the protocol than the numbers they represent, we don't\n\t\t\t\t  have enough space in the packet buffer to overwrite inside.\n\t\t\t\t  Thus, a bit more space is pre-allocated at the end of the buffer,\n\t\t\t\t  see php_mysqlnd_rowp_read(). And we add the strings at the end.\n\t\t\t\t  Definitely not nice, _hackish_ :(, but works.\n\t\t\t\t*/\n\t\t\t\tzend_uchar *start = bit_area;\n\t\t\t\tps_fetch_from_1_to_8_bytes(*current_field, &(fields_metadata[i]), 0, &p, len TSRMLS_CC);\n\t\t\t\t/*\n\t\t\t\t  We have advanced in ps_fetch_from_1_to_8_bytes. We should go back because\n\t\t\t\t  later in this function there will be an advancement.\n\t\t\t\t*/\n\t\t\t\tp -= len;\n\t\t\t\tif (Z_TYPE_PP(current_field) == IS_LONG) {\n\t\t\t\t\tbit_area += 1 + sprintf((char *)start, \"%ld\", Z_LVAL_PP(current_field));\n\t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n\t\t\t\t} else if (Z_TYPE_PP(current_field) == IS_STRING){\n\t\t\t\t\tmemcpy(bit_area, Z_STRVAL_PP(current_field), Z_STRLEN_PP(current_field));\n\t\t\t\t\tbit_area += Z_STRLEN_PP(current_field);\n\t\t\t\t\t*bit_area++ = '\\0';\n\t\t\t\t\tzval_dtor(*current_field);\n\t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, copy_data);\n\t\t\t}\n\t\t\tp += len;\n\t\t\tlast_field_was_string = TRUE;\n\t\t}\n\t}\n\tif (copy_data == FALSE && last_field_was_string) {\n\t\t/* Normal queries: The buffer has one more byte at the end, because we need it */\n\t\trow_buffer->ptr[data_size] = '\\0';\n\t}\n\n\tDBG_RETURN(PASS);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_read_text_protocol_zval */\nenum_func_status\nphp_mysqlnd_rowp_read_text_protocol_zval(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\tenum_func_status ret;\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_zval\");\n\tret = php_mysqlnd_rowp_read_text_protocol_aux(row_buffer, fields, field_count, fields_metadata, as_int_or_float, FALSE, stats TSRMLS_CC);\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_read_text_protocol_c */\nenum_func_status\nphp_mysqlnd_rowp_read_text_protocol_c(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n\t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n\t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, MYSQLND_STATS * stats TSRMLS_DC)\n{\n\tenum_func_status ret;\n\tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_c\");\n\tret = php_mysqlnd_rowp_read_text_protocol_aux(row_buffer, fields, field_count, fields_metadata, as_int_or_float, TRUE, stats TSRMLS_CC);\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n\n\n/* {{{ php_mysqlnd_rowp_read */\n/*\n  if normal statements => packet->fields is created by this function,\n  if PS => packet->fields is passed from outside\n*/\nstatic enum_func_status\nphp_mysqlnd_rowp_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar *p;\n\tenum_func_status ret = PASS;\n\tMYSQLND_PACKET_ROW *packet= (MYSQLND_PACKET_ROW *) _packet;\n\tsize_t post_alloc_for_bit_fields = 0;\n\tsize_t data_size = 0;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_read\");\n\n\tif (!packet->binary_protocol && packet->bit_fields_count) {\n\t\t/* For every field we need terminating \\0 */\n\t\tpost_alloc_for_bit_fields = packet->bit_fields_total_len + packet->bit_fields_count;\n\t}\n\n\tret = php_mysqlnd_read_row_ex(conn, packet->result_set_memory_pool, &packet->row_buffer, &data_size,\n\t\t\t\t\t\t\t\t  packet->persistent_alloc, post_alloc_for_bit_fields\n\t\t\t\t\t\t\t\t  TSRMLS_CC);\n\tif (FAIL == ret) {\n\t\tgoto end;\n\t}\n\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(conn->stats, packet_type_to_statistic_byte_count[PROT_ROW_PACKET],\n\t\t\t\t\t\t\t\t\t\tMYSQLND_HEADER_SIZE + packet->header.size,\n\t\t\t\t\t\t\t\t\t\tpacket_type_to_statistic_packet_count[PROT_ROW_PACKET],\n\t\t\t\t\t\t\t\t\t\t1);\n\n\t/* packet->row_buffer->ptr is of size 'data_size + 1' */\n\tpacket->header.size = data_size;\n\tpacket->row_buffer->app = data_size;\n\n\tif (ERROR_MARKER == (*(p = packet->row_buffer->ptr))) {\n\t\t/*\n\t\t   Error message as part of the result set,\n\t\t   not good but we should not hang. See:\n\t\t   Bug #27876 : SF with cyrillic variable name fails during execution\n\t\t*/\n\t\tret = FAIL;\n\t\tphp_mysqlnd_read_error_from_line(p + 1, data_size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error,\n\t\t\t\t\t\t\t\t\t\t sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t} else if (EODATA_MARKER == *p && data_size < 8) { /* EOF */\n\t\tpacket->eof = TRUE;\n\t\tp++;\n\t\tif (data_size > 1) {\n\t\t\tpacket->warning_count = uint2korr(p);\n\t\t\tp += 2;\n\t\t\tpacket->server_status = uint2korr(p);\n\t\t\t/* Seems we have 3 bytes reserved for future use */\n\t\t\tDBG_INF_FMT(\"server_status=%u warning_count=%u\", packet->server_status, packet->warning_count);\n\t\t}\n\t} else {\n\t\tMYSQLND_INC_CONN_STATISTIC(conn->stats,\n\t\t\t\t\t\t\t\t\tpacket->binary_protocol? STAT_ROWS_FETCHED_FROM_SERVER_PS:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t STAT_ROWS_FETCHED_FROM_SERVER_NORMAL);\n\n\t\tpacket->eof = FALSE;\n\t\t/* packet->field_count is set by the user of the packet */\n\n\t\tif (!packet->skip_extraction) {\n\t\t\tif (!packet->fields) {\n\t\t\t\tDBG_INF(\"Allocating packet->fields\");\n\t\t\t\t/*\n\t\t\t\t  old-API will probably set packet->fields to NULL every time, though for\n\t\t\t\t  unbuffered sets it makes not much sense as the zvals in this buffer matter,\n\t\t\t\t  not the buffer. Constantly allocating and deallocating brings nothing.\n\n\t\t\t\t  For PS - if stmt_store() is performed, thus we don't have a cursor, it will\n\t\t\t\t  behave just like old-API buffered. Cursors will behave like a bit different,\n\t\t\t\t  but mostly like old-API unbuffered and thus will populate this array with\n\t\t\t\t  value.\n\t\t\t\t*/\n\t\t\t\tpacket->fields = (zval **) mnd_pecalloc(packet->field_count, sizeof(zval *),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpacket->persistent_alloc);\n\t\t\t}\n\t\t} else {\n\t\t\tMYSQLND_INC_CONN_STATISTIC(conn->stats,\n\t\t\t\t\t\t\t\t\t\tpacket->binary_protocol? STAT_ROWS_SKIPPED_PS:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t STAT_ROWS_SKIPPED_NORMAL);\n\t\t}\n\t}\n\nend:\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_rowp_free_mem */\nstatic void\nphp_mysqlnd_rowp_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_ROW *p;\n\n\tDBG_ENTER(\"php_mysqlnd_rowp_free_mem\");\n\tp = (MYSQLND_PACKET_ROW *) _packet;\n\tif (p->row_buffer) {\n\t\tp->row_buffer->free_chunk(p->row_buffer TSRMLS_CC);\n\t\tp->row_buffer = NULL;\n\t}\n\tDBG_INF_FMT(\"stack_allocation=%u persistent=%u\", (int)stack_allocation, (int)p->header.persistent);\n\t/*\n\t  Don't free packet->fields :\n\t  - normal queries -> store_result() | fetch_row_unbuffered() will transfer\n\t    the ownership and NULL it.\n\t  - PS will pass in it the bound variables, we have to use them! and of course\n\t    not free the array. As it is passed to us, we should not clean it ourselves.\n\t*/\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n\tDBG_VOID_RETURN;\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_stats_read */\nstatic enum_func_status\nphp_mysqlnd_stats_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tMYSQLND_PACKET_STATS *packet= (MYSQLND_PACKET_STATS *) _packet;\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\n\tDBG_ENTER(\"php_mysqlnd_stats_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"statistics\", PROT_STATS_PACKET);\n\n\tpacket->message = mnd_emalloc(packet->header.size + 1);\n\tmemcpy(packet->message, buf, packet->header.size);\n\tpacket->message[packet->header.size] = '\\0';\n\tpacket->message_len = packet->header.size;\n\n\tDBG_RETURN(PASS);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_stats_free_mem */\nstatic\nvoid php_mysqlnd_stats_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_STATS *p= (MYSQLND_PACKET_STATS *) _packet;\n\tif (p->message) {\n\t\tmnd_efree(p->message);\n\t\tp->message = NULL;\n\t}\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* 1 + 4 (id) + 2 (field_c) + 2 (param_c) + 1 (filler) + 2 (warnings ) */\n#define PREPARE_RESPONSE_SIZE_41 9\n#define PREPARE_RESPONSE_SIZE_50 12\n\n/* {{{ php_mysqlnd_prepare_read */\nstatic enum_func_status\nphp_mysqlnd_prepare_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* In case of an error, we should have place to put it */\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tunsigned int data_size;\n\tMYSQLND_PACKET_PREPARE_RESPONSE *packet= (MYSQLND_PACKET_PREPARE_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_prepare_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"prepare\", PROT_PREPARE_RESP_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tdata_size = packet->header.size;\n\tpacket->error_code = uint1korr(p);\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (ERROR_MARKER == packet->error_code) {\n\t\tphp_mysqlnd_read_error_from_line(p, data_size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error,\n\t\t\t\t\t\t\t\t\t\t sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t\tDBG_RETURN(PASS);\n\t}\n\n\tif (data_size != PREPARE_RESPONSE_SIZE_41 &&\n\t\tdata_size != PREPARE_RESPONSE_SIZE_50 &&\n\t\t!(data_size > PREPARE_RESPONSE_SIZE_50)) {\n\t\tDBG_ERR_FMT(\"Wrong COM_STMT_PREPARE response size. Received %u\", data_size);\n\t\tphp_error(E_WARNING, \"Wrong COM_STMT_PREPARE response size. Received %u\", data_size);\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tpacket->stmt_id = uint4korr(p);\n\tp += 4;\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/* Number of columns in result set */\n\tpacket->field_count = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->param_count = uint2korr(p);\n\tp += 2;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tif (data_size > 9) {\n\t\t/* 0x0 filler sent by the server for 5.0+ clients */\n\t\tp++;\n\t\tBAIL_IF_NO_MORE_DATA;\n\n\t\tpacket->warning_count = uint2korr(p);\n\t}\n\n\tDBG_INF_FMT(\"Prepare packet read: stmt_id=%u fields=%u params=%u\",\n\t\t\t\tpacket->stmt_id, packet->field_count, packet->param_count);\n\n\tBAIL_IF_NO_MORE_DATA;\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"PREPARE packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"PREPARE packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_prepare_free_mem */\nstatic void\nphp_mysqlnd_prepare_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_PREPARE_RESPONSE *p= (MYSQLND_PACKET_PREPARE_RESPONSE *) _packet;\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_chg_user_read */\nstatic enum_func_status\nphp_mysqlnd_chg_user_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\t/* There could be an error message */\n\tsize_t buf_len = conn->net->cmd_buffer.length;\n\tzend_uchar *buf = (zend_uchar *) conn->net->cmd_buffer.buffer;\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tMYSQLND_PACKET_CHG_USER_RESPONSE *packet= (MYSQLND_PACKET_CHG_USER_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_chg_user_read\");\n\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, buf_len, \"change user response\", PROT_CHG_USER_RESP_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\t/*\n\t  Don't increment. First byte is ERROR_MARKER on error, but otherwise is starting byte\n\t  of encoded sequence for length.\n\t*/\n\n\t/* Should be always 0x0 or ERROR_MARKER for error */\n\tpacket->response_code = uint1korr(p);\n\tp++;\n\n\tif (packet->header.size == 1 && buf[0] == EODATA_MARKER && packet->server_capabilities & CLIENT_SECURE_CONNECTION) {\n\t\t/* We don't handle 3.23 authentication */\n\t\tpacket->server_asked_323_auth = TRUE;\n\t\tDBG_RETURN(FAIL);\n\t}\n\n\tif (ERROR_MARKER == packet->response_code) {\n\t\tphp_mysqlnd_read_error_from_line(p, packet->header.size - 1,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.error,\n\t\t\t\t\t\t\t\t\t\t sizeof(packet->error_info.error),\n\t\t\t\t\t\t\t\t\t\t &packet->error_info.error_no,\n\t\t\t\t\t\t\t\t\t\t packet->error_info.sqlstate\n\t\t\t\t\t\t\t\t\t\t TSRMLS_CC);\n\t}\n\tBAIL_IF_NO_MORE_DATA;\n\tif (packet->response_code == 0xFE && packet->header.size > (size_t) (p - buf)) {\n\t\tpacket->new_auth_protocol = mnd_pestrdup((char *)p, FALSE);\n\t\tpacket->new_auth_protocol_len = strlen(packet->new_auth_protocol);\n\t\tp+= packet->new_auth_protocol_len + 1; /* +1 for the \\0 */\n\t\tpacket->new_auth_protocol_data_len = packet->header.size - (size_t) (p - buf);\n\t\tif (packet->new_auth_protocol_data_len) {\n\t\t\tpacket->new_auth_protocol_data = mnd_emalloc(packet->new_auth_protocol_data_len);\n\t\t\tmemcpy(packet->new_auth_protocol_data, p, packet->new_auth_protocol_data_len);\n\t\t}\n\t\tDBG_INF_FMT(\"The server requested switching auth plugin to : %s\", packet->new_auth_protocol);\n\t\tDBG_INF_FMT(\"Server salt : [%*s]\", packet->new_auth_protocol_data_len, packet->new_auth_protocol_data);\n\t}\n\n\tDBG_RETURN(PASS);\npremature_end:\n\tDBG_ERR_FMT(\"CHANGE_USER packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"CHANGE_USER packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_chg_user_free_mem */\nstatic void\nphp_mysqlnd_chg_user_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_CHG_USER_RESPONSE * p = (MYSQLND_PACKET_CHG_USER_RESPONSE *) _packet;\n\n\tif (p->new_auth_protocol) {\n\t\tmnd_efree(p->new_auth_protocol);\n\t\tp->new_auth_protocol = NULL;\n\t}\n\tp->new_auth_protocol_len = 0;\n\n\tif (p->new_auth_protocol_data) {\n\t\tmnd_efree(p->new_auth_protocol_data);\n\t\tp->new_auth_protocol_data = NULL;\n\t}\n\tp->new_auth_protocol_data_len = 0;\n\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_sha256_pk_request_write */\nstatic\nsize_t php_mysqlnd_sha256_pk_request_write(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buffer[MYSQLND_HEADER_SIZE + 1];\n\tsize_t sent;\n\n\tDBG_ENTER(\"php_mysqlnd_sha256_pk_request_write\");\n\n\tint1store(buffer + MYSQLND_HEADER_SIZE, '\\1');\n\tsent = conn->net->data->m.send_ex(conn->net, buffer, 1, conn->stats, conn->error_info TSRMLS_CC);\n\n\tDBG_RETURN(sent);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_sha256_pk_request_free_mem */\nstatic\nvoid php_mysqlnd_sha256_pk_request_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tMYSQLND_PACKET_SHA256_PK_REQUEST * p = (MYSQLND_PACKET_SHA256_PK_REQUEST *) _packet;\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n#define SHA256_PK_REQUEST_RESP_BUFFER_SIZE 2048\n\n/* {{{ php_mysqlnd_sha256_pk_request_response_read */\nstatic enum_func_status\nphp_mysqlnd_sha256_pk_request_response_read(void * _packet, MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tzend_uchar buf[SHA256_PK_REQUEST_RESP_BUFFER_SIZE];\n\tzend_uchar *p = buf;\n\tzend_uchar *begin = buf;\n\tMYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE * packet= (MYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE *) _packet;\n\n\tDBG_ENTER(\"php_mysqlnd_sha256_pk_request_response_read\");\n\n\t/* leave space for terminating safety \\0 */\n\tPACKET_READ_HEADER_AND_BODY(packet, conn, buf, sizeof(buf), \"SHA256_PK_REQUEST_RESPONSE\", PROT_SHA256_PK_REQUEST_RESPONSE_PACKET);\n\tBAIL_IF_NO_MORE_DATA;\n\n\tp++;\n\tBAIL_IF_NO_MORE_DATA;\n\n\tpacket->public_key_len = packet->header.size - (p - buf);\n\tpacket->public_key = mnd_emalloc(packet->public_key_len + 1);\n\tmemcpy(packet->public_key, p, packet->public_key_len);\n\tpacket->public_key[packet->public_key_len] = '\\0';\n\n\tDBG_RETURN(PASS);\n\npremature_end:\n\tDBG_ERR_FMT(\"OK packet %d bytes shorter than expected\", p - begin - packet->header.size);\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"SHA256_PK_REQUEST_RESPONSE packet \"MYSQLND_SZ_T_SPEC\" bytes shorter than expected\",\n\t\t\t\t\t p - begin - packet->header.size);\n\tDBG_RETURN(FAIL);\n}\n/* }}} */\n\n\n/* {{{ php_mysqlnd_sha256_pk_request_response_free_mem */\nstatic void\nphp_mysqlnd_sha256_pk_request_response_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE * p = (MYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE *) _packet;\n\tif (p->public_key) {\n\t\tmnd_efree(p->public_key);\n\t\tp->public_key = NULL;\n\t}\n\tp->public_key_len = 0;\n\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n/* }}} */\n\n\n/* {{{ packet_methods */\nstatic\nmysqlnd_packet_methods packet_methods[PROT_LAST] =\n{\n\t{\n\t\tsizeof(MYSQLND_PACKET_GREET),\n\t\tphp_mysqlnd_greet_read,\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_greet_free_mem,\n\t}, /* PROT_GREET_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_AUTH),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_auth_write,\n\t\tphp_mysqlnd_auth_free_mem,\n\t}, /* PROT_AUTH_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_AUTH_RESPONSE),\n\t\tphp_mysqlnd_auth_response_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_auth_response_free_mem,\n\t}, /* PROT_AUTH_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_CHANGE_AUTH_RESPONSE),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_change_auth_response_write, /* write */\n\t\tphp_mysqlnd_change_auth_response_free_mem,\n\t}, /* PROT_CHANGE_AUTH_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_OK),\n\t\tphp_mysqlnd_ok_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_ok_free_mem,\n\t}, /* PROT_OK_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_EOF),\n\t\tphp_mysqlnd_eof_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_eof_free_mem,\n\t}, /* PROT_EOF_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_COMMAND),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_cmd_write, /* write */\n\t\tphp_mysqlnd_cmd_free_mem,\n\t}, /* PROT_CMD_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_RSET_HEADER),\n\t\tphp_mysqlnd_rset_header_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_rset_header_free_mem,\n\t}, /* PROT_RSET_HEADER_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_RES_FIELD),\n\t\tphp_mysqlnd_rset_field_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_rset_field_free_mem,\n\t}, /* PROT_RSET_FLD_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_ROW),\n\t\tphp_mysqlnd_rowp_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_rowp_free_mem,\n\t}, /* PROT_ROW_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_STATS),\n\t\tphp_mysqlnd_stats_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_stats_free_mem,\n\t}, /* PROT_STATS_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_PREPARE_RESPONSE),\n\t\tphp_mysqlnd_prepare_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_prepare_free_mem,\n\t}, /* PROT_PREPARE_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_CHG_USER_RESPONSE),\n\t\tphp_mysqlnd_chg_user_read, /* read */\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_chg_user_free_mem,\n\t}, /* PROT_CHG_USER_RESP_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_SHA256_PK_REQUEST),\n\t\tNULL, /* read */\n\t\tphp_mysqlnd_sha256_pk_request_write,\n\t\tphp_mysqlnd_sha256_pk_request_free_mem,\n\t}, /* PROT_SHA256_PK_REQUEST_PACKET */\n\t{\n\t\tsizeof(MYSQLND_PACKET_SHA256_PK_REQUEST_RESPONSE),\n\t\tphp_mysqlnd_sha256_pk_request_response_read,\n\t\tNULL, /* write */\n\t\tphp_mysqlnd_sha256_pk_request_response_free_mem,\n\t} /* PROT_SHA256_PK_REQUEST_RESPONSE_PACKET */\n};\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_greet_packet */\nstatic struct st_mysqlnd_packet_greet *\nMYSQLND_METHOD(mysqlnd_protocol, get_greet_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_greet * packet = mnd_pecalloc(1, packet_methods[PROT_GREET_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_greet_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_GREET_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_auth_packet */\nstatic struct st_mysqlnd_packet_auth *\nMYSQLND_METHOD(mysqlnd_protocol, get_auth_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_auth * packet = mnd_pecalloc(1, packet_methods[PROT_AUTH_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_auth_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_AUTH_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_auth_response_packet */\nstatic struct st_mysqlnd_packet_auth_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_auth_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_auth_response * packet = mnd_pecalloc(1, packet_methods[PROT_AUTH_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_auth_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_AUTH_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_change_auth_response_packet */\nstatic struct st_mysqlnd_packet_change_auth_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_change_auth_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_change_auth_response * packet = mnd_pecalloc(1, packet_methods[PROT_CHANGE_AUTH_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_change_auth_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_CHANGE_AUTH_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_ok_packet */\nstatic struct st_mysqlnd_packet_ok *\nMYSQLND_METHOD(mysqlnd_protocol, get_ok_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_ok * packet = mnd_pecalloc(1, packet_methods[PROT_OK_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_ok_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_OK_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_eof_packet */\nstatic struct st_mysqlnd_packet_eof *\nMYSQLND_METHOD(mysqlnd_protocol, get_eof_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_eof * packet = mnd_pecalloc(1, packet_methods[PROT_EOF_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_eof_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_EOF_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_command_packet */\nstatic struct st_mysqlnd_packet_command *\nMYSQLND_METHOD(mysqlnd_protocol, get_command_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_command * packet = mnd_pecalloc(1, packet_methods[PROT_CMD_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_command_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_CMD_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_rset_packet */\nstatic struct st_mysqlnd_packet_rset_header *\nMYSQLND_METHOD(mysqlnd_protocol, get_rset_header_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_rset_header * packet = mnd_pecalloc(1, packet_methods[PROT_RSET_HEADER_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_rset_header_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_RSET_HEADER_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_result_field_packet */\nstatic struct st_mysqlnd_packet_res_field *\nMYSQLND_METHOD(mysqlnd_protocol, get_result_field_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_res_field * packet = mnd_pecalloc(1, packet_methods[PROT_RSET_FLD_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_result_field_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_RSET_FLD_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_row_packet */\nstatic struct st_mysqlnd_packet_row *\nMYSQLND_METHOD(mysqlnd_protocol, get_row_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_row * packet = mnd_pecalloc(1, packet_methods[PROT_ROW_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_row_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_ROW_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_stats_packet */\nstatic struct st_mysqlnd_packet_stats *\nMYSQLND_METHOD(mysqlnd_protocol, get_stats_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_stats * packet = mnd_pecalloc(1, packet_methods[PROT_STATS_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_stats_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_STATS_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_prepare_response_packet */\nstatic struct st_mysqlnd_packet_prepare_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_prepare_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_prepare_response * packet = mnd_pecalloc(1, packet_methods[PROT_PREPARE_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_prepare_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_PREPARE_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_change_user_response_packet */\nstatic struct st_mysqlnd_packet_chg_user_resp*\nMYSQLND_METHOD(mysqlnd_protocol, get_change_user_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_chg_user_resp * packet = mnd_pecalloc(1, packet_methods[PROT_CHG_USER_RESP_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_change_user_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_CHG_USER_RESP_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_sha256_pk_request_packet */\nstatic struct st_mysqlnd_packet_sha256_pk_request *\nMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_sha256_pk_request * packet = mnd_pecalloc(1, packet_methods[PROT_SHA256_PK_REQUEST_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_sha256_pk_request_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_SHA256_PK_REQUEST_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol::get_sha256_pk_request_response_packet */\nstatic struct st_mysqlnd_packet_sha256_pk_request_response *\nMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_response_packet)(MYSQLND_PROTOCOL * const protocol, zend_bool persistent TSRMLS_DC)\n{\n\tstruct st_mysqlnd_packet_sha256_pk_request_response * packet = mnd_pecalloc(1, packet_methods[PROT_SHA256_PK_REQUEST_RESPONSE_PACKET].struct_size, persistent);\n\tDBG_ENTER(\"mysqlnd_protocol::get_sha256_pk_request_response_packet\");\n\tif (packet) {\n\t\tpacket->header.m = &packet_methods[PROT_SHA256_PK_REQUEST_RESPONSE_PACKET];\n\t\tpacket->header.persistent = persistent;\n\t}\n\tDBG_RETURN(packet);\n}\n/* }}} */\n\n\n\nMYSQLND_CLASS_METHODS_START(mysqlnd_protocol)\n\tMYSQLND_METHOD(mysqlnd_protocol, get_greet_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_auth_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_auth_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_change_auth_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_ok_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_command_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_eof_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_rset_header_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_result_field_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_row_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_stats_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_prepare_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_change_user_response_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_packet),\n\tMYSQLND_METHOD(mysqlnd_protocol, get_sha256_pk_request_response_packet)\nMYSQLND_CLASS_METHODS_END;\n\n\n/* {{{ mysqlnd_protocol_init */\nPHPAPI MYSQLND_PROTOCOL *\nmysqlnd_protocol_init(zend_bool persistent TSRMLS_DC)\n{\n\tMYSQLND_PROTOCOL * ret;\n\tDBG_ENTER(\"mysqlnd_protocol_init\");\n\tret = MYSQLND_CLASS_METHOD_TABLE_NAME(mysqlnd_object_factory).get_protocol_decoder(persistent TSRMLS_CC);\n\tDBG_RETURN(ret);\n}\n/* }}} */\n\n\n/* {{{ mysqlnd_protocol_free */\nPHPAPI void\nmysqlnd_protocol_free(MYSQLND_PROTOCOL * const protocol TSRMLS_DC)\n{\n\tDBG_ENTER(\"mysqlnd_protocol_free\");\n\n\tif (protocol) {\n\t\tzend_bool pers = protocol->persistent;\n\t\tmnd_pefree(protocol, pers);\n\t}\n\tDBG_VOID_RETURN;\n}\n/* }}} */\n\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n"], "filenames": ["ext/mysqlnd/mysqlnd_wireprotocol.c"], "buggy_code_start_loc": [1587], "buggy_code_end_loc": [1611], "fixing_code_start_loc": [1588], "fixing_code_end_loc": [1617], "type": "CWE-119", "message": "ext/mysqlnd/mysqlnd_wireprotocol.c in PHP before 5.6.26 and 7.x before 7.0.11 does not verify that a BIT field has the UNSIGNED_FLAG flag, which allows remote MySQL servers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted field metadata.", "other": {"cve": {"id": "CVE-2016-7412", "sourceIdentifier": "cve@mitre.org", "published": "2016-09-17T21:59:03.900", "lastModified": "2018-05-04T01:29:01.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ext/mysqlnd/mysqlnd_wireprotocol.c in PHP before 5.6.26 and 7.x before 7.0.11 does not verify that a BIT field has the UNSIGNED_FLAG flag, which allows remote MySQL servers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted field metadata."}, {"lang": "es", "value": "ext/mysqlnd/mysqlnd_wireprotocol.c en PHP en versiones anteriores a 5.6.26 y 7.x en versiones anteriores a 7.0.11 no verifica que un campo BIT tenga el indicador UNSIGNED_FLAG, lo que podr\u00eda permitir a servidores MySQL remotos provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica) o tener otro posible impacto no especificado a trav\u00e9s de metadatos de campo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.6.25", "matchCriteriaId": "D860D77C-575A-48A1-9475-485D26EF5E41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "DB6890AF-8A0A-46EE-AAD5-CF9AAE14A321"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "6B90B947-7B54-47F3-9637-2F4AC44079EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "35848414-BD5D-4164-84DC-61ABBB1C4152"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "2B1F8402-8551-4F66-A9A7-81D472AB058E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "7A773E8E-48CD-4D35-A0FD-629BD9334486"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "FC492340-79AF-4676-A161-079A97EC6F0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "F1C2D8FE-C380-4B43-B634-A3DBA4700A71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "3EB58393-0C10-413C-8D95-6BAA8BC19A1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "751F51CA-9D88-4971-A6EC-8C0B72E8E22B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "37B74118-8FC2-44CB-9673-A83DF777B2E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "4D56A200-1477-40DA-9444-CFC946157C69"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/15/10", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://www.php.net/ChangeLog-5.php", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.php.net/ChangeLog-7.php", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/93005", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1036836", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1296", "source": "cve@mitre.org"}, {"url": "https://bugs.php.net/bug.php?id=72293", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/php/php-src/commit/28f80baf3c53e267c9ce46a2a0fadbb981585132?w=1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201611-22", "source": "cve@mitre.org"}, {"url": "https://www.tenable.com/security/tns-2016-19", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/php/php-src/commit/28f80baf3c53e267c9ce46a2a0fadbb981585132?w=1"}}