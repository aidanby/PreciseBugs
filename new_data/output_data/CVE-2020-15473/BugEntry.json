{"buggy_code": ["/*\n * openvpn.c\n *\n * Copyright (C) 2011-20 - ntop.org\n *\n * OpenVPN TCP / UDP Detection - 128/160 hmac\n *\n * Detection based upon these openvpn protocol properties:\n *   - opcode\n *   - packet ID\n *   - session ID\n *\n * Two (good) packets are needed to perform detection.\n *  - First packet from client: save session ID\n *  - Second packet from server: report saved session ID\n *\n * TODO\n *  - Support PSK only mode (instead of TLS)\n *  - Support PSK + TLS mode (PSK used for early authentication)\n *  - TLS certificate extraction\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_OPENVPN\n\n#include \"ndpi_api.h\"\n\n\n#define P_CONTROL_HARD_RESET_CLIENT_V1  (0x01 << 3)\n#define P_CONTROL_HARD_RESET_CLIENT_V2  (0x07 << 3)\n#define P_CONTROL_HARD_RESET_SERVER_V1  (0x02 << 3)\n#define P_CONTROL_HARD_RESET_SERVER_V2  (0x08 << 3)\n#define P_OPCODE_MASK 0xF8\n#define P_SHA1_HMAC_SIZE 20\n#define P_HMAC_128 16                            // (RSA-)MD5, (RSA-)MD4, ..others\n#define P_HMAC_160 20                            // (RSA-|DSA-)SHA(1), ..others, SHA1 is openvpn default\n#define P_HARD_RESET_PACKET_ID_OFFSET(hmac_size) (9 + hmac_size)\n#define P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)  (P_HARD_RESET_PACKET_ID_OFFSET(hmac_size) + 8)\n#define P_HARD_RESET_CLIENT_MAX_COUNT  5\n\nstatic \n#ifndef WIN32\ninline \n#endif\nu_int32_t get_packet_id(const u_int8_t * payload, u_int8_t hms) {\n  return(ntohl(*(u_int32_t*)(payload + P_HARD_RESET_PACKET_ID_OFFSET(hms))));\n}\n\nstatic \n#ifndef WIN32\ninline\n#endif\nint8_t check_pkid_and_detect_hmac_size(const u_int8_t * payload) {\n  // try to guess\n  if(get_packet_id(payload, P_HMAC_160) == 1)\n    return P_HMAC_160;\n  \n  if(get_packet_id(payload, P_HMAC_128) == 1)    \n    return P_HMAC_128;\n  \n  return(-1);\n}\n\nvoid ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,\n                         struct ndpi_flow_struct* flow) {\n  struct ndpi_packet_struct* packet = &flow->packet;\n  const u_int8_t * ovpn_payload = packet->payload;\n  const u_int8_t * session_remote;\n  u_int8_t opcode;\n  u_int8_t alen;\n  int8_t hmac_size;\n  int8_t failed = 0;\n\n  if(packet->payload_packet_len >= 40) {\n    // skip openvpn TCP transport packet size\n    if(packet->tcp != NULL)\n      ovpn_payload += 2;\n\n    opcode = ovpn_payload[0] & P_OPCODE_MASK;\n\n    if(packet->udp) {\n#ifdef DEBUG\n      printf(\"[packet_id: %u][opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\",\n\t     flow->num_processed_pkts,\n\t     opcode, check_pkid_and_detect_hmac_size(ovpn_payload),\n\t     htons(packet->udp->source), htons(packet->udp->dest), packet->payload_packet_len);\t   \n#endif\n      \n      if(\n\t (flow->num_processed_pkts == 1)\n\t && (\n\t     ((packet->payload_packet_len == 112)\n\t      && ((opcode == 168) || (opcode == 192))\n\t      )\n\t     || ((packet->payload_packet_len == 80)\n\t\t && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168) || (opcode == 200)))\n\t     )) {\n\tNDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n    }\n    \n    if(flow->ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && (opcode == P_CONTROL_HARD_RESET_CLIENT_V1 ||\n\t\t\t\t    opcode == P_CONTROL_HARD_RESET_CLIENT_V2)) {\n      if(check_pkid_and_detect_hmac_size(ovpn_payload) > 0) {\n        memcpy(flow->ovpn_session_id, ovpn_payload+1, 8);\n\n        NDPI_LOG_DBG2(ndpi_struct,\n\t\t \"session key: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t flow->ovpn_session_id[0], flow->ovpn_session_id[1], flow->ovpn_session_id[2], flow->ovpn_session_id[3],\n\t\t flow->ovpn_session_id[4], flow->ovpn_session_id[5], flow->ovpn_session_id[6], flow->ovpn_session_id[7]);\n      }\n    } else if(flow->ovpn_counter >= 1 && flow->ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT &&\n            (opcode == P_CONTROL_HARD_RESET_SERVER_V1 || opcode == P_CONTROL_HARD_RESET_SERVER_V2)) {\n\n      hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);\n\n      if(hmac_size > 0) {\n        alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];\n        if (alen > 0) {\n\t  session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;\n\n          if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {\n\t    NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  } else {\n            NDPI_LOG_DBG2(ndpi_struct,\n\t\t   \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t   session_remote[0], session_remote[1], session_remote[2], session_remote[3],\n\t\t   session_remote[4], session_remote[5], session_remote[6], session_remote[7]);\n            failed = 1;\n          }\n        } else\n          failed = 1;\n      } else\n        failed = 1;\n    } else\n      failed = 1;\n\n    flow->ovpn_counter++;\n    \n    if(failed) {\n      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    }\n  }\n}\n\nvoid init_openvpn_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t    u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"OpenVPN\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_OPENVPN,\n\t\t\t\t      ndpi_search_openvpn,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "fixing_code": ["/*\n * openvpn.c\n *\n * Copyright (C) 2011-20 - ntop.org\n *\n * OpenVPN TCP / UDP Detection - 128/160 hmac\n *\n * Detection based upon these openvpn protocol properties:\n *   - opcode\n *   - packet ID\n *   - session ID\n *\n * Two (good) packets are needed to perform detection.\n *  - First packet from client: save session ID\n *  - Second packet from server: report saved session ID\n *\n * TODO\n *  - Support PSK only mode (instead of TLS)\n *  - Support PSK + TLS mode (PSK used for early authentication)\n *  - TLS certificate extraction\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_OPENVPN\n\n#include \"ndpi_api.h\"\n\n\n#define P_CONTROL_HARD_RESET_CLIENT_V1  (0x01 << 3)\n#define P_CONTROL_HARD_RESET_CLIENT_V2  (0x07 << 3)\n#define P_CONTROL_HARD_RESET_SERVER_V1  (0x02 << 3)\n#define P_CONTROL_HARD_RESET_SERVER_V2  (0x08 << 3)\n#define P_OPCODE_MASK 0xF8\n#define P_SHA1_HMAC_SIZE 20\n#define P_HMAC_128 16                            // (RSA-)MD5, (RSA-)MD4, ..others\n#define P_HMAC_160 20                            // (RSA-|DSA-)SHA(1), ..others, SHA1 is openvpn default\n#define P_HARD_RESET_PACKET_ID_OFFSET(hmac_size) (9 + hmac_size)\n#define P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)  (P_HARD_RESET_PACKET_ID_OFFSET(hmac_size) + 8)\n#define P_HARD_RESET_CLIENT_MAX_COUNT  5\n\nstatic \n#ifndef WIN32\ninline \n#endif\nu_int32_t get_packet_id(const u_int8_t * payload, u_int8_t hms) {\n  return(ntohl(*(u_int32_t*)(payload + P_HARD_RESET_PACKET_ID_OFFSET(hms))));\n}\n\nstatic \n#ifndef WIN32\ninline\n#endif\nint8_t check_pkid_and_detect_hmac_size(const u_int8_t * payload) {\n  // try to guess\n  if(get_packet_id(payload, P_HMAC_160) == 1)\n    return P_HMAC_160;\n  \n  if(get_packet_id(payload, P_HMAC_128) == 1)    \n    return P_HMAC_128;\n  \n  return(-1);\n}\n\nvoid ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,\n                         struct ndpi_flow_struct* flow) {\n  struct ndpi_packet_struct* packet = &flow->packet;\n  const u_int8_t * ovpn_payload = packet->payload;\n  const u_int8_t * session_remote;\n  u_int8_t opcode;\n  u_int8_t alen;\n  int8_t hmac_size;\n  int8_t failed = 0;\n  /* No u_ */int16_t ovpn_payload_len = packet->payload_packet_len;\n  \n  if(ovpn_payload_len >= 40) {\n    // skip openvpn TCP transport packet size\n    if(packet->tcp != NULL)\n      ovpn_payload += 2, ovpn_payload_len -= 2;;\n\n    opcode = ovpn_payload[0] & P_OPCODE_MASK;\n\n    if(packet->udp) {\n#ifdef DEBUG\n      printf(\"[packet_id: %u][opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\",\n\t     flow->num_processed_pkts,\n\t     opcode, check_pkid_and_detect_hmac_size(ovpn_payload),\n\t     htons(packet->udp->source), htons(packet->udp->dest), ovpn_payload_len);\t   \n#endif\n      \n      if(\n\t (flow->num_processed_pkts == 1)\n\t && (\n\t     ((ovpn_payload_len == 112)\n\t      && ((opcode == 168) || (opcode == 192))\n\t      )\n\t     || ((ovpn_payload_len == 80)\n\t\t && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168) || (opcode == 200)))\n\t     )) {\n\tNDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n    }\n    \n    if(flow->ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && (opcode == P_CONTROL_HARD_RESET_CLIENT_V1 ||\n\t\t\t\t    opcode == P_CONTROL_HARD_RESET_CLIENT_V2)) {\n      if(check_pkid_and_detect_hmac_size(ovpn_payload) > 0) {\n        memcpy(flow->ovpn_session_id, ovpn_payload+1, 8);\n\n        NDPI_LOG_DBG2(ndpi_struct,\n\t\t \"session key: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t flow->ovpn_session_id[0], flow->ovpn_session_id[1], flow->ovpn_session_id[2], flow->ovpn_session_id[3],\n\t\t flow->ovpn_session_id[4], flow->ovpn_session_id[5], flow->ovpn_session_id[6], flow->ovpn_session_id[7]);\n      }\n    } else if(flow->ovpn_counter >= 1 && flow->ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT &&\n            (opcode == P_CONTROL_HARD_RESET_SERVER_V1 || opcode == P_CONTROL_HARD_RESET_SERVER_V2)) {\n\n      hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);\n\n      if(hmac_size > 0) {\n\tu_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size);\n\t  \n        alen = ovpn_payload[offset];\n\t\n        if (alen > 0) {\n\t  offset += 1 + alen * 4;\n\n\t  if((offset+8) <= ovpn_payload_len) {\n\t    session_remote = &ovpn_payload[offset];\n\t    \n\t    if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {\n\t      NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\t      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    } else {\n\t      NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t    \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t    session_remote[0], session_remote[1], session_remote[2], session_remote[3],\n\t\t\t    session_remote[4], session_remote[5], session_remote[6], session_remote[7]);\n\t      failed = 1;\n\t    }\n\t  } else\n\t    failed = 1;\n\t} else\n          failed = 1;\n      } else\n        failed = 1;\n    } else\n      failed = 1;\n\n    flow->ovpn_counter++;\n    \n    if(failed) {\n      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    }\n  }\n}\n\nvoid init_openvpn_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t    u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"OpenVPN\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_OPENVPN,\n\t\t\t\t      ndpi_search_openvpn,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "filenames": ["src/lib/protocols/openvpn.c"], "buggy_code_start_loc": [75], "buggy_code_end_loc": [138], "fixing_code_start_loc": [75], "fixing_code_end_loc": [147], "type": "CWE-125", "message": "In nDPI through 3.2, the OpenVPN dissector is vulnerable to a heap-based buffer over-read in ndpi_search_openvpn in lib/protocols/openvpn.c.", "other": {"cve": {"id": "CVE-2020-15473", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-01T11:15:11.210", "lastModified": "2020-07-06T19:23:27.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In nDPI through 3.2, the OpenVPN dissector is vulnerable to a heap-based buffer over-read in ndpi_search_openvpn in lib/protocols/openvpn.c."}, {"lang": "es", "value": "En nDPI versiones hasta 3.2, el disector OpenVPN es vulnerable a una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n ndpi_search_openvpn en la biblioteca lib/protocols/openvpn.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntop:ndpi:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2", "matchCriteriaId": "97EDB1C6-9886-4C0B-8F09-5A4C52DC5A45"}]}]}], "references": [{"url": "https://github.com/ntop/nDPI/commit/8e7b1ea7a136cc4e4aa9880072ec2d69900a825e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntop/nDPI/commit/8e7b1ea7a136cc4e4aa9880072ec2d69900a825e"}}