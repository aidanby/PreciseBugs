{"buggy_code": ["<?php\n\n//session_start();\n\ninclude($_SERVER['DOCUMENT_ROOT'].\"/inc/main.php\");\n\n// Check login_as feature\n$user = $_SESSION['user'];\nif (($_SESSION['user'] == 'admin') && (!empty($_SESSION['look']))) {\n    $user=$_SESSION['look'];\n}\n\n\ndefine('USERNAME', $user);\n\n\n/*\n// Check user session\nif ((!isset($_SESSION['user'])) && (!defined('NO_AUTH_REQUIRED'))) {\n    $_SESSION['request_uri'] = $_SERVER['REQUEST_URI'];\n    header(\"Location: /login/\");\n    exit;\n}\n*/\n\n\n/*\n * jQuery File Upload Plugin PHP Class 8.1.0\n * https://github.com/blueimp/jQuery-File-Upload\n *\n * Copyright 2010, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * http://www.opensource.org/licenses/MIT\n */\n\nclass UploadHandler\n{\n\n    protected $options;\n\n    // PHP File Upload error message codes:\n    // http://php.net/manual/en/features.file-upload.errors.php\n    protected $error_messages = array(\n        1 => 'The uploaded file exceeds the upload_max_filesize directive in php.ini',\n        2 => 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form',\n        3 => 'The uploaded file was only partially uploaded',\n        4 => 'No file was uploaded',\n        6 => 'Missing a temporary folder',\n        7 => 'Failed to write file to disk',\n        8 => 'A PHP extension stopped the file upload',\n        'post_max_size' => 'The uploaded file exceeds the post_max_size directive in php.ini',\n        'max_file_size' => 'File is too big',\n        'min_file_size' => 'File is too small',\n        'accept_file_types' => 'Filetype not allowed',\n        'max_number_of_files' => 'Maximum number of files exceeded',\n        'max_width' => 'Image exceeds maximum width',\n        'min_width' => 'Image requires a minimum width',\n        'max_height' => 'Image exceeds maximum height',\n        'min_height' => 'Image requires a minimum height',\n        'abort' => 'File upload aborted',\n        'image_resize' => 'Failed to resize image'\n    );\n\n    protected $image_objects = array();\n\n    function __construct($options = null, $initialize = true, $error_messages = null) {\n        $this->options = array(\n            'script_url' => $this->get_full_url().'/',\n            'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/files/',\n            'upload_url' => $this->get_full_url().'/files/',\n            'user_dirs' => false,\n            'mkdir_mode' => 0755,\n            'param_name' => 'files',\n            // Set the following option to 'POST', if your server does not support\n            // DELETE requests. This is a parameter sent to the client:\n            'delete_type' => 'DELETE',\n            'access_control_allow_origin' => '*',\n            'access_control_allow_credentials' => false,\n            'access_control_allow_methods' => array(\n                'OPTIONS',\n                'HEAD',\n                'GET',\n                'POST',\n                'PUT',\n                'PATCH',\n                'DELETE'\n            ),\n            'access_control_allow_headers' => array(\n                'Content-Type',\n                'Content-Range',\n                'Content-Disposition'\n            ),\n            // Enable to provide file downloads via GET requests to the PHP script:\n            //     1. Set to 1 to download files via readfile method through PHP\n            //     2. Set to 2 to send a X-Sendfile header for lighttpd/Apache\n            //     3. Set to 3 to send a X-Accel-Redirect header for nginx\n            // If set to 2 or 3, adjust the upload_url option to the base path of\n            // the redirect parameter, e.g. '/files/'.\n            'download_via_php' => false,\n            // Read files in chunks to avoid memory limits when download_via_php\n            // is enabled, set to 0 to disable chunked reading of files:\n            'readfile_chunk_size' => 10 * 1024 * 1024, // 10 MiB\n            // Defines which files can be displayed inline when downloaded:\n            'inline_file_types' => '/\\.(gif|jpe?g|png)$/i',\n            // Defines which files (based on their names) are accepted for upload:\n            'accept_file_types' => '/.+$/i',\n            // The php.ini settings upload_max_filesize and post_max_size\n            // take precedence over the following max_file_size setting:\n            'max_file_size' => null,\n            'min_file_size' => null,\n            // The maximum number of files for the upload directory:\n            'max_number_of_files' => null,\n            // Defines which files are handled as image files:\n            'image_file_types' => '/\\.(gif|jpe?g|png)$/i',\n            // Use exif_imagetype on all files to correct file extensions:\n            'correct_image_extensions' => false,\n            // Image resolution restrictions:\n            'max_width' => null,\n            'max_height' => null,\n            'min_width' => 1,\n            'min_height' => 1,\n            // Set the following option to false to enable resumable uploads:\n            'discard_aborted_uploads' => true,\n            // Set to 0 to use the GD library to scale and orient images,\n            // set to 1 to use imagick (if installed, falls back to GD),\n            // set to 2 to use the ImageMagick convert binary directly:\n            'image_library' => 1,\n            // Uncomment the following to define an array of resource limits\n            // for imagick:\n            /*\n            'imagick_resource_limits' => array(\n                imagick::RESOURCETYPE_MAP => 32,\n                imagick::RESOURCETYPE_MEMORY => 32\n            ),\n            */\n            // Command or path for to the ImageMagick convert binary:\n            'convert_bin' => 'convert',\n            // Uncomment the following to add parameters in front of each\n            // ImageMagick convert call (the limit constraints seem only\n            // to have an effect if put in front):\n            /*\n            'convert_params' => '-limit memory 32MiB -limit map 32MiB',\n            */\n            // Command or path for to the ImageMagick identify binary:\n            'identify_bin' => 'identify',\n            'image_versions' => array(\n                // The empty image version key defines options for the original image:\n                '' => array(\n                    // Automatically rotate images based on EXIF meta data:\n                    'auto_orient' => true\n                ),\n                // Uncomment the following to create medium sized images:\n                /*\n                'medium' => array(\n                    'max_width' => 800,\n                    'max_height' => 600\n                ),\n                */\n                'thumbnail' => array(\n                    // Uncomment the following to use a defined directory for the thumbnails\n                    // instead of a subdirectory based on the version identifier.\n                    // Make sure that this directory doesn't allow execution of files if you\n                    // don't pose any restrictions on the type of uploaded files, e.g. by\n                    // copying the .htaccess file from the files directory for Apache:\n                    //'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/thumb/',\n                    //'upload_url' => $this->get_full_url().'/thumb/',\n                    // Uncomment the following to force the max\n                    // dimensions and e.g. create square thumbnails:\n                    //'crop' => true,\n                    'max_width' => 80,\n                    'max_height' => 80\n                )\n            )\n        );\n        if ($options) {\n            $this->options = $options + $this->options;\n        }\n        if ($error_messages) {\n            $this->error_messages = $error_messages + $this->error_messages;\n        }\n        if ($initialize) {\n            $this->initialize();\n        }\n    }\n\n    protected function initialize() {\n        switch ($this->get_server_var('REQUEST_METHOD')) {\n            case 'OPTIONS':\n            case 'HEAD':\n                $this->head();\n                break;\n            case 'GET':\n                $this->get();\n                break;\n            case 'PATCH':\n            case 'PUT':\n            case 'POST':\n                $this->post();\n                break;\n            case 'DELETE':\n                $this->delete();\n                break;\n            default:\n                $this->header('HTTP/1.1 405 Method Not Allowed');\n        }\n    }\n\n    protected function get_full_url() {\n        $https = !empty($_SERVER['HTTPS']) && strcasecmp($_SERVER['HTTPS'], 'on') === 0 ||\n            !empty($_SERVER['HTTP_X_FORWARDED_PROTO']) &&\n                strcasecmp($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') === 0;\n        return\n            ($https ? 'https://' : 'http://').\n            (!empty($_SERVER['REMOTE_USER']) ? $_SERVER['REMOTE_USER'].'@' : '').\n            (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : ($_SERVER['SERVER_NAME'].\n            ($https && $_SERVER['SERVER_PORT'] === 443 ||\n            $_SERVER['SERVER_PORT'] === 80 ? '' : ':'.$_SERVER['SERVER_PORT']))).\n            substr($_SERVER['SCRIPT_NAME'],0, strrpos($_SERVER['SCRIPT_NAME'], '/'));\n    }\n\n    protected function get_user_id() {\n        @session_start();\n        return session_id();\n    }\n\n    protected function get_user_path() {\n        if ($this->options['user_dirs']) {\n            return $this->get_user_id().'/';\n        }\n        return '';\n    }\n\n    protected function get_upload_path($file_name = null, $version = null) {\n        $relocate_directory = $_GET['dir'];\n        if (empty($relocate_directory)) {\n            $relocate_directory = '/home/admin/'; // fallback dir\n        }\n        if ($relocate_directory[strlen($relocate_directory) -1] != '/') {\n            $relocate_directory .= '/';\n        }\n        $file_name = $file_name ? $file_name : '';\n        if (empty($version)) {\n            $version_path = '';\n        } else {\n            $version_dir = @$this->options['image_versions'][$version]['upload_dir'];\n            if ($version_dir) {\n                return $version_dir.$this->get_user_path().$file_name;\n            }\n            $version_path = $version.'/';\n        }\n        //return $this->options['upload_dir'].$this->get_user_path()\n        //    .$version_path.$file_name;\n        return $relocate_directory\n            .$version_path.$file_name;\n    }\n\n    protected function get_query_separator($url) {\n        return strpos($url, '?') === false ? '?' : '&';\n    }\n\n    protected function get_download_url($file_name, $version = null, $direct = false) {\n        if (!$direct && $this->options['download_via_php']) {\n            $url = $this->options['script_url']\n                .$this->get_query_separator($this->options['script_url'])\n                .$this->get_singular_param_name()\n                .'='.rawurlencode($file_name);\n            if ($version) {\n                $url .= '&version='.rawurlencode($version);\n            }\n            return $url.'&download=1';\n        }\n        if (empty($version)) {\n            $version_path = '';\n        } else {\n            $version_url = @$this->options['image_versions'][$version]['upload_url'];\n            if ($version_url) {\n                return $version_url.$this->get_user_path().rawurlencode($file_name);\n            }\n            $version_path = rawurlencode($version).'/';\n        }\n        return $this->options['upload_url'].$this->get_user_path()\n            .$version_path.rawurlencode($file_name);\n    }\n\n    protected function set_additional_file_properties($file) {\n        $file->deleteUrl = $this->options['script_url']\n            .$this->get_query_separator($this->options['script_url'])\n            .$this->get_singular_param_name()\n            .'='.rawurlencode($file->name);\n        $file->deleteType = $this->options['delete_type'];\n        if ($file->deleteType !== 'DELETE') {\n            $file->deleteUrl .= '&_method=DELETE';\n        }\n        if ($this->options['access_control_allow_credentials']) {\n            $file->deleteWithCredentials = true;\n        }\n    }\n\n    // Fix for overflowing signed 32 bit integers,\n    // works for sizes up to 2^32-1 bytes (4 GiB - 1):\n    protected function fix_integer_overflow($size) {\n        if ($size < 0) {\n            $size += 2.0 * (PHP_INT_MAX + 1);\n        }\n        return $size;\n    }\n\n    protected function get_file_size($file_path, $clear_stat_cache = false) {\n        if ($clear_stat_cache) {\n            if (version_compare(PHP_VERSION, '5.3.0') >= 0) {\n                clearstatcache(true, $file_path);\n            } else {\n                clearstatcache();\n            }\n        }\n\n        return $this->fix_integer_overflow(filesize($file_path));\n    }\n\n    protected function is_valid_file_object($file_name) {\n        $file_path = $this->get_upload_path($file_name);\n        if (is_file($file_path) && $file_name[0] !== '.') {\n            return true;\n        }\n        return false;\n    }\n\n    protected function get_file_object($file_name) {\n        if ($this->is_valid_file_object($file_name)) {\n            $file = new \\stdClass();\n            $file->name = $file_name;\n            $file->size = $this->get_file_size(\n                $this->get_upload_path($file_name)\n            );\n            $file->url = $this->get_download_url($file->name);\n            foreach($this->options['image_versions'] as $version => $options) {\n                if (!empty($version)) {\n                    if (is_file($this->get_upload_path($file_name, $version))) {\n                        $file->{$version.'Url'} = $this->get_download_url(\n                            $file->name,\n                            $version\n                        );\n                    }\n                }\n            }\n            $this->set_additional_file_properties($file);\n            return $file;\n        }\n        return null;\n    }\n\n    protected function get_file_objects($iteration_method = 'get_file_object') {\n        $upload_dir = $this->get_upload_path();\n        if (!is_dir($upload_dir)) {\n            return array();\n        }\n        return array_values(array_filter(array_map(\n            array($this, $iteration_method),\n            scandir($upload_dir)\n        )));\n    }\n\n    protected function count_file_objects() {\n        return count($this->get_file_objects('is_valid_file_object'));\n    }\n\n    protected function get_error_message($error) {\n        return array_key_exists($error, $this->error_messages) ?\n            $this->error_messages[$error] : $error;\n    }\n\n    function get_config_bytes($val) {\n        $val = trim($val);\n        $last = strtolower($val[strlen($val)-1]);\n        switch($last) {\n            case 'g':\n                $val *= 1024;\n            case 'm':\n                $val *= 1024;\n            case 'k':\n                $val *= 1024;\n        }\n        return $this->fix_integer_overflow($val);\n    }\n\n    protected function validate($uploaded_file, $file, $error, $index) {\n        if ($error) {\n            $file->error = $this->get_error_message($error);\n            return false;\n        }\n        $content_length = $this->fix_integer_overflow(intval(\n            $this->get_server_var('CONTENT_LENGTH')\n        ));\n        $post_max_size = $this->get_config_bytes(ini_get('post_max_size'));\n        if ($post_max_size && ($content_length > $post_max_size)) {\n            $file->error = $this->get_error_message('post_max_size');\n            return false;\n        }\n        if (!preg_match($this->options['accept_file_types'], $file->name)) {\n            $file->error = $this->get_error_message('accept_file_types');\n            return false;\n        }\n        if ($uploaded_file && is_uploaded_file($uploaded_file)) {\n            $file_size = $this->get_file_size($uploaded_file);\n        } else {\n            $file_size = $content_length;\n        }\n        if ($this->options['max_file_size'] && (\n                $file_size > $this->options['max_file_size'] ||\n                $file->size > $this->options['max_file_size'])\n            ) {\n            $file->error = $this->get_error_message('max_file_size');\n            return false;\n        }\n        if ($this->options['min_file_size'] &&\n            $file_size < $this->options['min_file_size']) {\n            $file->error = $this->get_error_message('min_file_size');\n            return false;\n        }\n        if (is_int($this->options['max_number_of_files']) &&\n                ($this->count_file_objects() >= $this->options['max_number_of_files']) &&\n                // Ignore additional chunks of existing files:\n                !is_file($this->get_upload_path($file->name))) {\n            $file->error = $this->get_error_message('max_number_of_files');\n            return false;\n        }\n        $max_width = @$this->options['max_width'];\n        $max_height = @$this->options['max_height'];\n        $min_width = @$this->options['min_width'];\n        $min_height = @$this->options['min_height'];\n        if (($max_width || $max_height || $min_width || $min_height)\n           && preg_match($this->options['image_file_types'], $file->name)) {\n            list($img_width, $img_height) = $this->get_image_size($uploaded_file);\n        }\n        if (!empty($img_width)) {\n            if ($max_width && $img_width > $max_width) {\n                $file->error = $this->get_error_message('max_width');\n                return false;\n            }\n            if ($max_height && $img_height > $max_height) {\n                $file->error = $this->get_error_message('max_height');\n                return false;\n            }\n            if ($min_width && $img_width < $min_width) {\n                $file->error = $this->get_error_message('min_width');\n                return false;\n            }\n            if ($min_height && $img_height < $min_height) {\n                $file->error = $this->get_error_message('min_height');\n                return false;\n            }\n        }\n        return true;\n    }\n\n    protected function upcount_name_callback($matches) {\n        $index = isset($matches[1]) ? intval($matches[1]) + 1 : 1;\n        $ext = isset($matches[2]) ? $matches[2] : '';\n        return ' ('.$index.')'.$ext;\n    }\n\n    protected function upcount_name($name) {\n        return preg_replace_callback(\n            '/(?:(?: \\(([\\d]+)\\))?(\\.[^.]+))?$/',\n            array($this, 'upcount_name_callback'),\n            $name,\n            1\n        );\n    }\n\n    protected function sanitizeFileName($file) {\n        // (|\\\\?*<\\\":>+[]/')\n        // \\|\\\\\\?\\*\\<\\\"\\'\\:\\>\\+\\[\\]\n        $file = preg_replace(\"/'/\", '', $file);\n\n        return $file;\n    }\n\n    protected function get_unique_filename($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        $name = $this->sanitizeFileName($name);\n\n        while(is_dir($this->get_upload_path($name))) {\n            $name = $this->upcount_name($name);\n        }\n        // Keep an existing filename if this is part of a chunked upload:\n        $uploaded_bytes = $this->fix_integer_overflow(intval($content_range[1]));\n        while(is_file($this->get_upload_path($name))) {\n            if ($uploaded_bytes === $this->get_file_size(\n                    $this->get_upload_path($name))) {\n                break;\n            }\n            $name = $this->upcount_name($name);\n        }\n        return $name;\n    }\n\n    protected function fix_file_extension($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        // Add missing file extension for known image types:\n        if (strpos($name, '.') === false &&\n                preg_match('/^image\\/(gif|jpe?g|png)/', $type, $matches)) {\n            $name .= '.'.$matches[1];\n        }\n        if ($this->options['correct_image_extensions'] &&\n                function_exists('exif_imagetype')) {\n            switch(@exif_imagetype($file_path)){\n                case IMAGETYPE_JPEG:\n                    $extensions = array('jpg', 'jpeg');\n                    break;\n                case IMAGETYPE_PNG:\n                    $extensions = array('png');\n                    break;\n                case IMAGETYPE_GIF:\n                    $extensions = array('gif');\n                    break;\n            }\n            // Adjust incorrect image file extensions:\n            if (!empty($extensions)) {\n                $parts = explode('.', $name);\n                $extIndex = count($parts) - 1;\n                $ext = strtolower(@$parts[$extIndex]);\n                if (!in_array($ext, $extensions)) {\n                    $parts[$extIndex] = $extensions[0];\n                    $name = implode('.', $parts);\n                }\n            }\n        }\n        return $name;\n    }\n\n    protected function trim_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        // Remove path information and dots around the filename, to prevent uploading\n        // into different directories or replacing hidden system files.\n        // Also remove control characters and spaces (\\x00..\\x20) around the filename:\n        $name = trim(basename(stripslashes($name)), \".\\x00..\\x20\");\n        // Use a timestamp for empty filenames:\n        if (!$name) {\n            $name = str_replace('.', '-', microtime(true));\n        }\n        return $name;\n    }\n\n    protected function get_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        $name = $this->trim_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range);\n        return $this->get_unique_filename(\n            $file_path,\n            $this->fix_file_extension($file_path, $name, $size, $type, $error,\n                $index, $content_range),\n            $size,\n            $type,\n            $error,\n            $index,\n            $content_range\n        );\n    }\n\n    protected function get_current_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n\n        $name = $this->trim_file_name($file_path, $name, $size, $type, $error, $index, $content_range);\n\n\n        return $this->get_unique_filename(\n            $file_path,\n            $this->fix_file_extension($file_path, $name, $size, $type, $error,\n                $index, $content_range),\n            $size,\n            $type,\n            $error,\n            $index,\n            $content_range\n        );\n    }\n\n\n    protected function handle_form_data($file, $index) {\n        // Handle form data, e.g. $_REQUEST['description'][$index]\n    }\n\n    protected function get_scaled_image_file_paths($file_name, $version) {\n        $file_path = $this->get_upload_path($file_name);\n        if (!empty($version)) {\n            $version_dir = $this->get_upload_path(null, $version);\n            if (!is_dir($version_dir)) {\n                mkdir($version_dir, $this->options['mkdir_mode'], true);\n            }\n            $new_file_path = $version_dir.'/'.$file_name;\n        } else {\n            $new_file_path = $file_path;\n        }\n        return array($file_path, $new_file_path);\n    }\n\n    protected function gd_get_image_object($file_path, $func, $no_cache = false) {\n        if (empty($this->image_objects[$file_path]) || $no_cache) {\n            $this->gd_destroy_image_object($file_path);\n            $this->image_objects[$file_path] = $func($file_path);\n        }\n        return $this->image_objects[$file_path];\n    }\n\n    protected function gd_set_image_object($file_path, $image) {\n        $this->gd_destroy_image_object($file_path);\n        $this->image_objects[$file_path] = $image;\n    }\n\n    protected function gd_destroy_image_object($file_path) {\n        $image = (isset($this->image_objects[$file_path])) ? $this->image_objects[$file_path] : null ;\n        return $image && imagedestroy($image);\n    }\n\n    protected function gd_imageflip($image, $mode) {\n        if (function_exists('imageflip')) {\n            return imageflip($image, $mode);\n        }\n        $new_width = $src_width = imagesx($image);\n        $new_height = $src_height = imagesy($image);\n        $new_img = imagecreatetruecolor($new_width, $new_height);\n        $src_x = 0;\n        $src_y = 0;\n        switch ($mode) {\n            case '1': // flip on the horizontal axis\n                $src_y = $new_height - 1;\n                $src_height = -$new_height;\n                break;\n            case '2': // flip on the vertical axis\n                $src_x  = $new_width - 1;\n                $src_width = -$new_width;\n                break;\n            case '3': // flip on both axes\n                $src_y = $new_height - 1;\n                $src_height = -$new_height;\n                $src_x  = $new_width - 1;\n                $src_width = -$new_width;\n                break;\n            default:\n                return $image;\n        }\n        imagecopyresampled(\n            $new_img,\n            $image,\n            0,\n            0,\n            $src_x,\n            $src_y,\n            $new_width,\n            $new_height,\n            $src_width,\n            $src_height\n        );\n        return $new_img;\n    }\n\n    protected function gd_orient_image($file_path, $src_img) {\n        if (!function_exists('exif_read_data')) {\n            return false;\n        }\n        $exif = @exif_read_data($file_path);\n        if ($exif === false) {\n            return false;\n        }\n        $orientation = intval(@$exif['Orientation']);\n        if ($orientation < 2 || $orientation > 8) {\n            return false;\n        }\n        switch ($orientation) {\n            case 2:\n                $new_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2\n                );\n                break;\n            case 3:\n                $new_img = imagerotate($src_img, 180, 0);\n                break;\n            case 4:\n                $new_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1\n                );\n                break;\n            case 5:\n                $tmp_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1\n                );\n                $new_img = imagerotate($tmp_img, 270, 0);\n                imagedestroy($tmp_img);\n                break;\n            case 6:\n                $new_img = imagerotate($src_img, 270, 0);\n                break;\n            case 7:\n                $tmp_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2\n                );\n                $new_img = imagerotate($tmp_img, 270, 0);\n                imagedestroy($tmp_img);\n                break;\n            case 8:\n                $new_img = imagerotate($src_img, 90, 0);\n                break;\n            default:\n                return false;\n        }\n        $this->gd_set_image_object($file_path, $new_img);\n        return true;\n    }\n\n    protected function gd_create_scaled_image($file_name, $version, $options) {\n        if (!function_exists('imagecreatetruecolor')) {\n            error_log('Function not found: imagecreatetruecolor');\n            return false;\n        }\n        list($file_path, $new_file_path) =\n            $this->get_scaled_image_file_paths($file_name, $version);\n        $type = strtolower(substr(strrchr($file_name, '.'), 1));\n        switch ($type) {\n            case 'jpg':\n            case 'jpeg':\n                $src_func = 'imagecreatefromjpeg';\n                $write_func = 'imagejpeg';\n                $image_quality = isset($options['jpeg_quality']) ?\n                    $options['jpeg_quality'] : 75;\n                break;\n            case 'gif':\n                $src_func = 'imagecreatefromgif';\n                $write_func = 'imagegif';\n                $image_quality = null;\n                break;\n            case 'png':\n                $src_func = 'imagecreatefrompng';\n                $write_func = 'imagepng';\n                $image_quality = isset($options['png_quality']) ?\n                    $options['png_quality'] : 9;\n                break;\n            default:\n                return false;\n        }\n        $src_img = $this->gd_get_image_object(\n            $file_path,\n            $src_func,\n            !empty($options['no_cache'])\n        );\n        $image_oriented = false;\n        if (!empty($options['auto_orient']) && $this->gd_orient_image(\n                $file_path,\n                $src_img\n            )) {\n            $image_oriented = true;\n            $src_img = $this->gd_get_image_object(\n                $file_path,\n                $src_func\n            );\n        }\n        $max_width = $img_width = imagesx($src_img);\n        $max_height = $img_height = imagesy($src_img);\n        if (!empty($options['max_width'])) {\n            $max_width = $options['max_width'];\n        }\n        if (!empty($options['max_height'])) {\n            $max_height = $options['max_height'];\n        }\n        $scale = min(\n            $max_width / $img_width,\n            $max_height / $img_height\n        );\n        if ($scale >= 1) {\n            if ($image_oriented) {\n                return $write_func($src_img, $new_file_path, $image_quality);\n            }\n            if ($file_path !== $new_file_path) {\n                return copy($file_path, $new_file_path);\n            }\n            return true;\n        }\n        if (empty($options['crop'])) {\n            $new_width = $img_width * $scale;\n            $new_height = $img_height * $scale;\n            $dst_x = 0;\n            $dst_y = 0;\n            $new_img = imagecreatetruecolor($new_width, $new_height);\n        } else {\n            if (($img_width / $img_height) >= ($max_width / $max_height)) {\n                $new_width = $img_width / ($img_height / $max_height);\n                $new_height = $max_height;\n            } else {\n                $new_width = $max_width;\n                $new_height = $img_height / ($img_width / $max_width);\n            }\n            $dst_x = 0 - ($new_width - $max_width) / 2;\n            $dst_y = 0 - ($new_height - $max_height) / 2;\n            $new_img = imagecreatetruecolor($max_width, $max_height);\n        }\n        // Handle transparency in GIF and PNG images:\n        switch ($type) {\n            case 'gif':\n            case 'png':\n                imagecolortransparent($new_img, imagecolorallocate($new_img, 0, 0, 0));\n            case 'png':\n                imagealphablending($new_img, false);\n                imagesavealpha($new_img, true);\n                break;\n        }\n        $success = imagecopyresampled(\n            $new_img,\n            $src_img,\n            $dst_x,\n            $dst_y,\n            0,\n            0,\n            $new_width,\n            $new_height,\n            $img_width,\n            $img_height\n        ) && $write_func($new_img, $new_file_path, $image_quality);\n        $this->gd_set_image_object($file_path, $new_img);\n        return $success;\n    }\n\n    protected function imagick_get_image_object($file_path, $no_cache = false) {\n        if (empty($this->image_objects[$file_path]) || $no_cache) {\n            $this->imagick_destroy_image_object($file_path);\n            $image = new \\Imagick();\n            if (!empty($this->options['imagick_resource_limits'])) {\n                foreach ($this->options['imagick_resource_limits'] as $type => $limit) {\n                    $image->setResourceLimit($type, $limit);\n                }\n            }\n            $image->readImage($file_path);\n            $this->image_objects[$file_path] = $image;\n        }\n        return $this->image_objects[$file_path];\n    }\n\n    protected function imagick_set_image_object($file_path, $image) {\n        $this->imagick_destroy_image_object($file_path);\n        $this->image_objects[$file_path] = $image;\n    }\n\n    protected function imagick_destroy_image_object($file_path) {\n        $image = (isset($this->image_objects[$file_path])) ? $this->image_objects[$file_path] : null ;\n        return $image && $image->destroy();\n    }\n\n    protected function imagick_orient_image($image) {\n        $orientation = $image->getImageOrientation();\n        $background = new \\ImagickPixel('none');\n        switch ($orientation) {\n            case \\imagick::ORIENTATION_TOPRIGHT: // 2\n                $image->flopImage(); // horizontal flop around y-axis\n                break;\n            case \\imagick::ORIENTATION_BOTTOMRIGHT: // 3\n                $image->rotateImage($background, 180);\n                break;\n            case \\imagick::ORIENTATION_BOTTOMLEFT: // 4\n                $image->flipImage(); // vertical flip around x-axis\n                break;\n            case \\imagick::ORIENTATION_LEFTTOP: // 5\n                $image->flopImage(); // horizontal flop around y-axis\n                $image->rotateImage($background, 270);\n                break;\n            case \\imagick::ORIENTATION_RIGHTTOP: // 6\n                $image->rotateImage($background, 90);\n                break;\n            case \\imagick::ORIENTATION_RIGHTBOTTOM: // 7\n                $image->flipImage(); // vertical flip around x-axis\n                $image->rotateImage($background, 270);\n                break;\n            case \\imagick::ORIENTATION_LEFTBOTTOM: // 8\n                $image->rotateImage($background, 270);\n                break;\n            default:\n                return false;\n        }\n        $image->setImageOrientation(\\imagick::ORIENTATION_TOPLEFT); // 1\n        return true;\n    }\n\n    protected function imagick_create_scaled_image($file_name, $version, $options) {\n        list($file_path, $new_file_path) =\n            $this->get_scaled_image_file_paths($file_name, $version);\n        $image = $this->imagick_get_image_object(\n            $file_path,\n            !empty($options['no_cache'])\n        );\n        if ($image->getImageFormat() === 'GIF') {\n            // Handle animated GIFs:\n            $images = $image->coalesceImages();\n            foreach ($images as $frame) {\n                $image = $frame;\n                $this->imagick_set_image_object($file_name, $image);\n                break;\n            }\n        }\n        $image_oriented = false;\n        if (!empty($options['auto_orient'])) {\n            $image_oriented = $this->imagick_orient_image($image);\n        }\n        $new_width = $max_width = $img_width = $image->getImageWidth();\n        $new_height = $max_height = $img_height = $image->getImageHeight();\n        if (!empty($options['max_width'])) {\n            $new_width = $max_width = $options['max_width'];\n        }\n        if (!empty($options['max_height'])) {\n            $new_height = $max_height = $options['max_height'];\n        }\n        if (!($image_oriented || $max_width < $img_width || $max_height < $img_height)) {\n            if ($file_path !== $new_file_path) {\n                return copy($file_path, $new_file_path);\n            }\n            return true;\n        }\n        $crop = !empty($options['crop']);\n        if ($crop) {\n            $x = 0;\n            $y = 0;\n            if (($img_width / $img_height) >= ($max_width / $max_height)) {\n                $new_width = 0; // Enables proportional scaling based on max_height\n                $x = ($img_width / ($img_height / $max_height) - $max_width) / 2;\n            } else {\n                $new_height = 0; // Enables proportional scaling based on max_width\n                $y = ($img_height / ($img_width / $max_width) - $max_height) / 2;\n            }\n        }\n        $success = $image->resizeImage(\n            $new_width,\n            $new_height,\n            isset($options['filter']) ? $options['filter'] : \\imagick::FILTER_LANCZOS,\n            isset($options['blur']) ? $options['blur'] : 1,\n            $new_width && $new_height // fit image into constraints if not to be cropped\n        );\n        if ($success && $crop) {\n            $success = $image->cropImage(\n                $max_width,\n                $max_height,\n                $x,\n                $y\n            );\n            if ($success) {\n                $success = $image->setImagePage($max_width, $max_height, 0, 0);\n            }\n        }\n        $type = strtolower(substr(strrchr($file_name, '.'), 1));\n        switch ($type) {\n            case 'jpg':\n            case 'jpeg':\n                if (!empty($options['jpeg_quality'])) {\n                    $image->setImageCompression(\\imagick::COMPRESSION_JPEG);\n                    $image->setImageCompressionQuality($options['jpeg_quality']);\n                }\n                break;\n        }\n        if (!empty($options['strip'])) {\n            $image->stripImage();\n        }\n        return $success && $image->writeImage($new_file_path);\n    }\n\n    protected function imagemagick_create_scaled_image($file_name, $version, $options) {\n        list($file_path, $new_file_path) =\n            $this->get_scaled_image_file_paths($file_name, $version);\n        $resize = @$options['max_width']\n            .(empty($options['max_height']) ? '' : 'X'.$options['max_height']);\n        if (!$resize && empty($options['auto_orient'])) {\n            if ($file_path !== $new_file_path) {\n                return copy($file_path, $new_file_path);\n            }\n            return true;\n        }\n        $cmd = $this->options['convert_bin'];\n        if (!empty($this->options['convert_params'])) {\n            $cmd .= ' '.$this->options['convert_params'];\n        }\n        $cmd .= ' '.escapeshellarg($file_path);\n        if (!empty($options['auto_orient'])) {\n            $cmd .= ' -auto-orient';\n        }\n        if ($resize) {\n            // Handle animated GIFs:\n            $cmd .= ' -coalesce';\n            if (empty($options['crop'])) {\n                $cmd .= ' -resize '.escapeshellarg($resize.'>');\n            } else {\n                $cmd .= ' -resize '.escapeshellarg($resize.'^');\n                $cmd .= ' -gravity center';\n                $cmd .= ' -crop '.escapeshellarg($resize.'+0+0');\n            }\n            // Make sure the page dimensions are correct (fixes offsets of animated GIFs):\n            $cmd .= ' +repage';\n        }\n        if (!empty($options['convert_params'])) {\n            $cmd .= ' '.$options['convert_params'];\n        }\n        $cmd .= ' '.escapeshellarg($new_file_path);\n        exec($cmd, $output, $error);\n        if ($error) {\n            error_log(implode('\\n', $output));\n            return false;\n        }\n        return true;\n    }\n\n    protected function get_image_size($file_path) {\n        if ($this->options['image_library']) {\n            if (extension_loaded('imagick')) {\n                $image = new \\Imagick();\n                try {\n                    if (@$image->pingImage($file_path)) {\n                        $dimensions = array($image->getImageWidth(), $image->getImageHeight());\n                        $image->destroy();\n                        return $dimensions;\n                    }\n                    return false;\n                } catch (Exception $e) {\n                    error_log($e->getMessage());\n                }\n            }\n            if ($this->options['image_library'] === 2) {\n                $cmd = $this->options['identify_bin'];\n                $cmd .= ' -ping '.escapeshellarg($file_path);\n                exec($cmd, $output, $error);\n                if (!$error && !empty($output)) {\n                    // image.jpg JPEG 1920x1080 1920x1080+0+0 8-bit sRGB 465KB 0.000u 0:00.000\n                    $infos = preg_split('/\\s+/', $output[0]);\n                    $dimensions = preg_split('/x/', $infos[2]);\n                    return $dimensions;\n                }\n                return false;\n            }\n        }\n        if (!function_exists('getimagesize')) {\n            error_log('Function not found: getimagesize');\n            return false;\n        }\n        return @getimagesize($file_path);\n    }\n\n    protected function create_scaled_image($file_name, $version, $options) {\n        if ($this->options['image_library'] === 2) {\n            return $this->imagemagick_create_scaled_image($file_name, $version, $options);\n        }\n        if ($this->options['image_library'] && extension_loaded('imagick')) {\n            return $this->imagick_create_scaled_image($file_name, $version, $options);\n        }\n        return $this->gd_create_scaled_image($file_name, $version, $options);\n    }\n\n    protected function destroy_image_object($file_path) {\n        if ($this->options['image_library'] && extension_loaded('imagick')) {\n            return $this->imagick_destroy_image_object($file_path);\n        }\n    }\n\n    protected function is_valid_image_file($file_path) {\n        if (!preg_match($this->options['image_file_types'], $file_path)) {\n            return false;\n        }\n        if (function_exists('exif_imagetype')) {\n            return @exif_imagetype($file_path);\n        }\n        $image_info = $this->get_image_size($file_path);\n        return $image_info && $image_info[0] && $image_info[1];\n    }\n\n    protected function handle_image_file($file_path, $file) {\n        $failed_versions = array();\n        foreach($this->options['image_versions'] as $version => $options) {\n            if ($this->create_scaled_image($file->name, $version, $options)) {\n                if (!empty($version)) {\n                    $file->{$version.'Url'} = $this->get_download_url(\n                        $file->name,\n                        $version\n                    );\n                } else {\n                    $file->size = $this->get_file_size($file_path, true);\n                }\n            } else {\n                $failed_versions[] = $version ? $version : 'original';\n            }\n        }\n        if (count($failed_versions)) {\n            $file->error = $this->get_error_message('image_resize')\n                    .' ('.implode($failed_versions,', ').')';\n        }\n        // Free memory:\n        $this->destroy_image_object($file_path);\n    }\n\n    protected function handle_file_upload($uploaded_file, $name, $size, $type, $error,\n        $index = null, $content_range = null) {\n\n        $file = new \\stdClass();\n//        $file->name = $this->get_file_name($uploaded_file, $name, $size, $type, $error,\n//            $index, $content_range);\n\n        $file->name = $this->trim_file_name($uploaded_path, $name, $size, $type, $error, $index, $content_range);\n        $file->name = $this->fix_file_extension($uploaded_path, $name, $size, $type, $error, $index, $content_range);\n\n\n        $file->size = $this->fix_integer_overflow(intval($size));\n        $file->type = $type;\n        if ($this->validate($uploaded_file, $file, $error, $index)) {\n            $this->handle_form_data($file, $index);\n            $upload_dir = $this->get_upload_path();\n            if (!is_dir($upload_dir)) {\n                mkdir($upload_dir, $this->options['mkdir_mode'], true);\n            }\n            $file_path = $this->get_upload_path($file->name);\n            $append_file = $content_range && is_file($file_path) &&\n                $file->size > $this->get_file_size($file_path);\n            if ($uploaded_file && is_uploaded_file($uploaded_file) && strpos($file_path, \"'\")===false && strpos($file_path, '\"')===false) {\n                chmod($uploaded_file, 0644);\n                exec (VESTA_CMD . \"v-copy-fs-file \". USERNAME .\" \".$uploaded_file.\" \".escapeshellarg($file_path), $output, $return_var);\n                $error = check_return_code($return_var, $output);\n                if ($return_var != 0) {\n                    $file->error = 'Error while saving file ';\n                }\n            }\n            $file_size = $this->get_file_size($file_path, $append_file);\n\n            if ($file_size === $file->size) {\n                $file->url = $this->get_download_url($file->name);\n                // uncomment if images also need to be resized\n                //if ($this->is_valid_image_file($file_path)) {\n                //    $this->handle_image_file($file_path, $file);\n                //}\n            } else {\n                //$file->size = $file_size;\n                //if (!$content_range && $this->options['discard_aborted_uploads']) {\n                //    unlink($file_path);\n                //    $file->error = $this->get_error_message('abort');\n                //}\n            }\n            $this->set_additional_file_properties($file);\n        }\n        return $file;\n    }\n\n    protected function readfile($file_path) {\n        $file_size = $this->get_file_size($file_path);\n        $chunk_size = $this->options['readfile_chunk_size'];\n        if ($chunk_size && $file_size > $chunk_size) {\n            $handle = fopen($file_path, 'rb');\n            while (!feof($handle)) {\n                echo fread($handle, $chunk_size);\n                @ob_flush();\n                @flush();\n            }\n            fclose($handle);\n            return $file_size;\n        }\n        return readfile($file_path);\n    }\n\n    protected function body($str) {\n        echo $str;\n    }\n\n    protected function header($str) {\n        header($str);\n    }\n\n    protected function get_server_var($id) {\n        return isset($_SERVER[$id]) ? $_SERVER[$id] : '';\n    }\n\n    protected function generate_response($content, $print_response = true) {\n        if ($print_response) {\n            $json = json_encode($content);\n            $redirect = isset($_REQUEST['redirect']) ?\n                stripslashes($_REQUEST['redirect']) : null;\n            if ($redirect) {\n                $this->header('Location: '.sprintf($redirect, rawurlencode($json)));\n                return;\n            }\n            $this->head();\n            if ($this->get_server_var('HTTP_CONTENT_RANGE')) {\n                $files = isset($content[$this->options['param_name']]) ?\n                    $content[$this->options['param_name']] : null;\n                if ($files && is_array($files) && is_object($files[0]) && $files[0]->size) {\n                    $this->header('Range: 0-'.(\n                        $this->fix_integer_overflow(intval($files[0]->size)) - 1\n                    ));\n                }\n            }\n            $this->body($json);\n        }\n        return $content;\n    }\n\n    protected function get_version_param() {\n        return isset($_GET['version']) ? basename(stripslashes($_GET['version'])) : null;\n    }\n\n    protected function get_singular_param_name() {\n        return substr($this->options['param_name'], 0, -1);\n    }\n\n    protected function get_file_name_param() {\n        $name = $this->get_singular_param_name();\n        return isset($_REQUEST[$name]) ? basename(stripslashes($_REQUEST[$name])) : null;\n    }\n\n    protected function get_file_names_params() {\n        $params = isset($_REQUEST[$this->options['param_name']]) ?\n            $_REQUEST[$this->options['param_name']] : array();\n        foreach ($params as $key => $value) {\n            $params[$key] = basename(stripslashes($value));\n        }\n        return $params;\n    }\n\n    protected function get_file_type($file_path) {\n        switch (strtolower(pathinfo($file_path, PATHINFO_EXTENSION))) {\n            case 'jpeg':\n            case 'jpg':\n                return 'image/jpeg';\n            case 'png':\n                return 'image/png';\n            case 'gif':\n                return 'image/gif';\n            default:\n                return '';\n        }\n    }\n\n    protected function download() {\n        switch ($this->options['download_via_php']) {\n            case 1:\n                $redirect_header = null;\n                break;\n            case 2:\n                $redirect_header = 'X-Sendfile';\n                break;\n            case 3:\n                $redirect_header = 'X-Accel-Redirect';\n                break;\n            default:\n                return $this->header('HTTP/1.1 403 Forbidden');\n        }\n        $file_name = $this->get_file_name_param();\n        if (!$this->is_valid_file_object($file_name)) {\n            return $this->header('HTTP/1.1 404 Not Found');\n        }\n        if ($redirect_header) {\n            return $this->header(\n                $redirect_header.': '.$this->get_download_url(\n                    $file_name,\n                    $this->get_version_param(),\n                    true\n                )\n            );\n        }\n        $file_path = $this->get_upload_path($file_name, $this->get_version_param());\n        // Prevent browsers from MIME-sniffing the content-type:\n        $this->header('X-Content-Type-Options: nosniff');\n        if (!preg_match($this->options['inline_file_types'], $file_name)) {\n            $this->header('Content-Type: application/octet-stream');\n            $this->header('Content-Disposition: attachment; filename=\"'.$file_name.'\"');\n        } else {\n            $this->header('Content-Type: '.$this->get_file_type($file_path));\n            $this->header('Content-Disposition: inline; filename=\"'.$file_name.'\"');\n        }\n        $this->header('Content-Length: '.$this->get_file_size($file_path));\n        $this->header('Last-Modified: '.gmdate('D, d M Y H:i:s T', filemtime($file_path)));\n        $this->readfile($file_path);\n    }\n\n    protected function send_content_type_header() {\n        $this->header('Vary: Accept');\n        if (strpos($this->get_server_var('HTTP_ACCEPT'), 'application/json') !== false) {\n            $this->header('Content-type: application/json');\n        } else {\n            $this->header('Content-type: text/plain');\n        }\n    }\n\n    protected function send_access_control_headers() {\n        $this->header('Access-Control-Allow-Origin: '.$this->options['access_control_allow_origin']);\n        $this->header('Access-Control-Allow-Credentials: '\n            .($this->options['access_control_allow_credentials'] ? 'true' : 'false'));\n        $this->header('Access-Control-Allow-Methods: '\n            .implode(', ', $this->options['access_control_allow_methods']));\n        $this->header('Access-Control-Allow-Headers: '\n            .implode(', ', $this->options['access_control_allow_headers']));\n    }\n\n    public function head() {\n        $this->header('Pragma: no-cache');\n        $this->header('Cache-Control: no-store, no-cache, must-revalidate');\n        $this->header('Content-Disposition: inline; filename=\"files.json\"');\n        // Prevent Internet Explorer from MIME-sniffing the content-type:\n        $this->header('X-Content-Type-Options: nosniff');\n        if ($this->options['access_control_allow_origin']) {\n            $this->send_access_control_headers();\n        }\n        $this->send_content_type_header();\n    }\n\n    public function get($print_response = true) {\n        if ($print_response && isset($_GET['download'])) {\n            return $this->download();\n        }\n        $file_name = $this->get_file_name_param();\n        if ($file_name) {\n            $response = array(\n                $this->get_singular_param_name() => $this->get_file_object($file_name)\n            );\n        } else {\n            $response = array(\n                $this->options['param_name'] => $this->get_file_objects()\n            );\n        }\n        return $this->generate_response($response, $print_response);\n    }\n\n    public function post($print_response = true) {\n        if (isset($_REQUEST['_method']) && $_REQUEST['_method'] === 'DELETE') {\n            return $this->delete($print_response);\n        }\n        $upload = isset($_FILES[$this->options['param_name']]) ?\n            $_FILES[$this->options['param_name']] : null;\n        // Parse the Content-Disposition header, if available:\n        $file_name = $this->get_server_var('HTTP_CONTENT_DISPOSITION') ?\n            rawurldecode(preg_replace(\n                '/(^[^\"]+\")|(\"$)/',\n                '',\n                $this->get_server_var('HTTP_CONTENT_DISPOSITION')\n            )) : null;\n        // Parse the Content-Range header, which has the following form:\n        // Content-Range: bytes 0-524287/2000000\n        $content_range = $this->get_server_var('HTTP_CONTENT_RANGE') ?\n            preg_split('/[^0-9]+/', $this->get_server_var('HTTP_CONTENT_RANGE')) : null;\n        $size =  $content_range ? $content_range[3] : null;\n        $files = array();\n        if ($upload && is_array($upload['tmp_name'])) {\n            // param_name is an array identifier like \"files[]\",\n            // $_FILES is a multi-dimensional array:\n            foreach ($upload['tmp_name'] as $index => $value) {\n                $files[] = $this->handle_file_upload(\n                    $upload['tmp_name'][$index],\n                    $file_name ? $file_name : $upload['name'][$index],\n                    $size ? $size : $upload['size'][$index],\n                    $upload['type'][$index],\n                    $upload['error'][$index],\n                    $index,\n                    $content_range\n                );\n            }\n        } else {\n            // param_name is a single object identifier like \"file\",\n            // $_FILES is a one-dimensional array:\n            $files[] = $this->handle_file_upload(\n                isset($upload['tmp_name']) ? $upload['tmp_name'] : null,\n                $file_name ? $file_name : (isset($upload['name']) ?\n                        $upload['name'] : null),\n                $size ? $size : (isset($upload['size']) ?\n                        $upload['size'] : $this->get_server_var('CONTENT_LENGTH')),\n                isset($upload['type']) ?\n                        $upload['type'] : $this->get_server_var('CONTENT_TYPE'),\n                isset($upload['error']) ? $upload['error'] : null,\n                null,\n                $content_range\n            );\n        }\n        return $this->generate_response(\n            array($this->options['param_name'] => $files),\n            $print_response\n        );\n    }\n\n    public function delete($print_response = true) {\n        $file_names = $this->get_file_names_params();\n        if (empty($file_names)) {\n            $file_names = array($this->get_file_name_param());\n        }\n        $response = array();\n        foreach($file_names as $file_name) {\n            $file_path = $this->get_upload_path($file_name);\n            $success = is_file($file_path) && $file_name[0] !== '.' && unlink($file_path);\n            if ($success) {\n                foreach($this->options['image_versions'] as $version => $options) {\n                    if (!empty($version)) {\n                        $file = $this->get_upload_path($file_name, $version);\n                        if (is_file($file)) {\n                            unlink($file);\n                        }\n                    }\n                }\n            }\n            $response[$file_name] = $success;\n        }\n        return $this->generate_response($response, $print_response);\n    }\n\n}\n"], "fixing_code": ["<?php\n\n//session_start();\n\n$hostname = exec('hostname');\n$port = $_SERVER['SERVER_PORT'];\n$expected_http_origin=\"https://\".$hostname.\":\".$port;\nif ($_SERVER['HTTP_ORIGIN'] != $expected_http_origin) {\n    die (\"Nope.\");\n}\n\ninclude($_SERVER['DOCUMENT_ROOT'].\"/inc/main.php\");\n\n// Check login_as feature\n$user = $_SESSION['user'];\nif (($_SESSION['user'] == 'admin') && (!empty($_SESSION['look']))) {\n    $user=$_SESSION['look'];\n}\n\n\ndefine('USERNAME', $user);\n\n\n/*\n// Check user session\nif ((!isset($_SESSION['user'])) && (!defined('NO_AUTH_REQUIRED'))) {\n    $_SESSION['request_uri'] = $_SERVER['REQUEST_URI'];\n    header(\"Location: /login/\");\n    exit;\n}\n*/\n\n\n/*\n * jQuery File Upload Plugin PHP Class 8.1.0\n * https://github.com/blueimp/jQuery-File-Upload\n *\n * Copyright 2010, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * http://www.opensource.org/licenses/MIT\n */\n\nclass UploadHandler\n{\n\n    protected $options;\n\n    // PHP File Upload error message codes:\n    // http://php.net/manual/en/features.file-upload.errors.php\n    protected $error_messages = array(\n        1 => 'The uploaded file exceeds the upload_max_filesize directive in php.ini',\n        2 => 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form',\n        3 => 'The uploaded file was only partially uploaded',\n        4 => 'No file was uploaded',\n        6 => 'Missing a temporary folder',\n        7 => 'Failed to write file to disk',\n        8 => 'A PHP extension stopped the file upload',\n        'post_max_size' => 'The uploaded file exceeds the post_max_size directive in php.ini',\n        'max_file_size' => 'File is too big',\n        'min_file_size' => 'File is too small',\n        'accept_file_types' => 'Filetype not allowed',\n        'max_number_of_files' => 'Maximum number of files exceeded',\n        'max_width' => 'Image exceeds maximum width',\n        'min_width' => 'Image requires a minimum width',\n        'max_height' => 'Image exceeds maximum height',\n        'min_height' => 'Image requires a minimum height',\n        'abort' => 'File upload aborted',\n        'image_resize' => 'Failed to resize image'\n    );\n\n    protected $image_objects = array();\n\n    function __construct($options = null, $initialize = true, $error_messages = null) {\n        $this->options = array(\n            'script_url' => $this->get_full_url().'/',\n            'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/files/',\n            'upload_url' => $this->get_full_url().'/files/',\n            'user_dirs' => false,\n            'mkdir_mode' => 0755,\n            'param_name' => 'files',\n            // Set the following option to 'POST', if your server does not support\n            // DELETE requests. This is a parameter sent to the client:\n            'delete_type' => 'DELETE',\n            'access_control_allow_origin' => '*',\n            'access_control_allow_credentials' => false,\n            'access_control_allow_methods' => array(\n                'OPTIONS',\n                'HEAD',\n                'GET',\n                'POST',\n                'PUT',\n                'PATCH',\n                'DELETE'\n            ),\n            'access_control_allow_headers' => array(\n                'Content-Type',\n                'Content-Range',\n                'Content-Disposition'\n            ),\n            // Enable to provide file downloads via GET requests to the PHP script:\n            //     1. Set to 1 to download files via readfile method through PHP\n            //     2. Set to 2 to send a X-Sendfile header for lighttpd/Apache\n            //     3. Set to 3 to send a X-Accel-Redirect header for nginx\n            // If set to 2 or 3, adjust the upload_url option to the base path of\n            // the redirect parameter, e.g. '/files/'.\n            'download_via_php' => false,\n            // Read files in chunks to avoid memory limits when download_via_php\n            // is enabled, set to 0 to disable chunked reading of files:\n            'readfile_chunk_size' => 10 * 1024 * 1024, // 10 MiB\n            // Defines which files can be displayed inline when downloaded:\n            'inline_file_types' => '/\\.(gif|jpe?g|png)$/i',\n            // Defines which files (based on their names) are accepted for upload:\n            'accept_file_types' => '/.+$/i',\n            // The php.ini settings upload_max_filesize and post_max_size\n            // take precedence over the following max_file_size setting:\n            'max_file_size' => null,\n            'min_file_size' => null,\n            // The maximum number of files for the upload directory:\n            'max_number_of_files' => null,\n            // Defines which files are handled as image files:\n            'image_file_types' => '/\\.(gif|jpe?g|png)$/i',\n            // Use exif_imagetype on all files to correct file extensions:\n            'correct_image_extensions' => false,\n            // Image resolution restrictions:\n            'max_width' => null,\n            'max_height' => null,\n            'min_width' => 1,\n            'min_height' => 1,\n            // Set the following option to false to enable resumable uploads:\n            'discard_aborted_uploads' => true,\n            // Set to 0 to use the GD library to scale and orient images,\n            // set to 1 to use imagick (if installed, falls back to GD),\n            // set to 2 to use the ImageMagick convert binary directly:\n            'image_library' => 1,\n            // Uncomment the following to define an array of resource limits\n            // for imagick:\n            /*\n            'imagick_resource_limits' => array(\n                imagick::RESOURCETYPE_MAP => 32,\n                imagick::RESOURCETYPE_MEMORY => 32\n            ),\n            */\n            // Command or path for to the ImageMagick convert binary:\n            'convert_bin' => 'convert',\n            // Uncomment the following to add parameters in front of each\n            // ImageMagick convert call (the limit constraints seem only\n            // to have an effect if put in front):\n            /*\n            'convert_params' => '-limit memory 32MiB -limit map 32MiB',\n            */\n            // Command or path for to the ImageMagick identify binary:\n            'identify_bin' => 'identify',\n            'image_versions' => array(\n                // The empty image version key defines options for the original image:\n                '' => array(\n                    // Automatically rotate images based on EXIF meta data:\n                    'auto_orient' => true\n                ),\n                // Uncomment the following to create medium sized images:\n                /*\n                'medium' => array(\n                    'max_width' => 800,\n                    'max_height' => 600\n                ),\n                */\n                'thumbnail' => array(\n                    // Uncomment the following to use a defined directory for the thumbnails\n                    // instead of a subdirectory based on the version identifier.\n                    // Make sure that this directory doesn't allow execution of files if you\n                    // don't pose any restrictions on the type of uploaded files, e.g. by\n                    // copying the .htaccess file from the files directory for Apache:\n                    //'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/thumb/',\n                    //'upload_url' => $this->get_full_url().'/thumb/',\n                    // Uncomment the following to force the max\n                    // dimensions and e.g. create square thumbnails:\n                    //'crop' => true,\n                    'max_width' => 80,\n                    'max_height' => 80\n                )\n            )\n        );\n        if ($options) {\n            $this->options = $options + $this->options;\n        }\n        if ($error_messages) {\n            $this->error_messages = $error_messages + $this->error_messages;\n        }\n        if ($initialize) {\n            $this->initialize();\n        }\n    }\n\n    protected function initialize() {\n        switch ($this->get_server_var('REQUEST_METHOD')) {\n            case 'OPTIONS':\n            case 'HEAD':\n                $this->head();\n                break;\n            case 'GET':\n                $this->get();\n                break;\n            case 'PATCH':\n            case 'PUT':\n            case 'POST':\n                $this->post();\n                break;\n            case 'DELETE':\n                $this->delete();\n                break;\n            default:\n                $this->header('HTTP/1.1 405 Method Not Allowed');\n        }\n    }\n\n    protected function get_full_url() {\n        $https = !empty($_SERVER['HTTPS']) && strcasecmp($_SERVER['HTTPS'], 'on') === 0 ||\n            !empty($_SERVER['HTTP_X_FORWARDED_PROTO']) &&\n                strcasecmp($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') === 0;\n        return\n            ($https ? 'https://' : 'http://').\n            (!empty($_SERVER['REMOTE_USER']) ? $_SERVER['REMOTE_USER'].'@' : '').\n            (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : ($_SERVER['SERVER_NAME'].\n            ($https && $_SERVER['SERVER_PORT'] === 443 ||\n            $_SERVER['SERVER_PORT'] === 80 ? '' : ':'.$_SERVER['SERVER_PORT']))).\n            substr($_SERVER['SCRIPT_NAME'],0, strrpos($_SERVER['SCRIPT_NAME'], '/'));\n    }\n\n    protected function get_user_id() {\n        @session_start();\n        return session_id();\n    }\n\n    protected function get_user_path() {\n        if ($this->options['user_dirs']) {\n            return $this->get_user_id().'/';\n        }\n        return '';\n    }\n\n    protected function get_upload_path($file_name = null, $version = null) {\n        $relocate_directory = $_GET['dir'];\n        if (empty($relocate_directory)) {\n            $relocate_directory = '/home/admin/'; // fallback dir\n        }\n        if ($relocate_directory[strlen($relocate_directory) -1] != '/') {\n            $relocate_directory .= '/';\n        }\n        $file_name = $file_name ? $file_name : '';\n        if (empty($version)) {\n            $version_path = '';\n        } else {\n            $version_dir = @$this->options['image_versions'][$version]['upload_dir'];\n            if ($version_dir) {\n                return $version_dir.$this->get_user_path().$file_name;\n            }\n            $version_path = $version.'/';\n        }\n        //return $this->options['upload_dir'].$this->get_user_path()\n        //    .$version_path.$file_name;\n        return $relocate_directory\n            .$version_path.$file_name;\n    }\n\n    protected function get_query_separator($url) {\n        return strpos($url, '?') === false ? '?' : '&';\n    }\n\n    protected function get_download_url($file_name, $version = null, $direct = false) {\n        if (!$direct && $this->options['download_via_php']) {\n            $url = $this->options['script_url']\n                .$this->get_query_separator($this->options['script_url'])\n                .$this->get_singular_param_name()\n                .'='.rawurlencode($file_name);\n            if ($version) {\n                $url .= '&version='.rawurlencode($version);\n            }\n            return $url.'&download=1';\n        }\n        if (empty($version)) {\n            $version_path = '';\n        } else {\n            $version_url = @$this->options['image_versions'][$version]['upload_url'];\n            if ($version_url) {\n                return $version_url.$this->get_user_path().rawurlencode($file_name);\n            }\n            $version_path = rawurlencode($version).'/';\n        }\n        return $this->options['upload_url'].$this->get_user_path()\n            .$version_path.rawurlencode($file_name);\n    }\n\n    protected function set_additional_file_properties($file) {\n        $file->deleteUrl = $this->options['script_url']\n            .$this->get_query_separator($this->options['script_url'])\n            .$this->get_singular_param_name()\n            .'='.rawurlencode($file->name);\n        $file->deleteType = $this->options['delete_type'];\n        if ($file->deleteType !== 'DELETE') {\n            $file->deleteUrl .= '&_method=DELETE';\n        }\n        if ($this->options['access_control_allow_credentials']) {\n            $file->deleteWithCredentials = true;\n        }\n    }\n\n    // Fix for overflowing signed 32 bit integers,\n    // works for sizes up to 2^32-1 bytes (4 GiB - 1):\n    protected function fix_integer_overflow($size) {\n        if ($size < 0) {\n            $size += 2.0 * (PHP_INT_MAX + 1);\n        }\n        return $size;\n    }\n\n    protected function get_file_size($file_path, $clear_stat_cache = false) {\n        if ($clear_stat_cache) {\n            if (version_compare(PHP_VERSION, '5.3.0') >= 0) {\n                clearstatcache(true, $file_path);\n            } else {\n                clearstatcache();\n            }\n        }\n\n        return $this->fix_integer_overflow(filesize($file_path));\n    }\n\n    protected function is_valid_file_object($file_name) {\n        $file_path = $this->get_upload_path($file_name);\n        if (is_file($file_path) && $file_name[0] !== '.') {\n            return true;\n        }\n        return false;\n    }\n\n    protected function get_file_object($file_name) {\n        if ($this->is_valid_file_object($file_name)) {\n            $file = new \\stdClass();\n            $file->name = $file_name;\n            $file->size = $this->get_file_size(\n                $this->get_upload_path($file_name)\n            );\n            $file->url = $this->get_download_url($file->name);\n            foreach($this->options['image_versions'] as $version => $options) {\n                if (!empty($version)) {\n                    if (is_file($this->get_upload_path($file_name, $version))) {\n                        $file->{$version.'Url'} = $this->get_download_url(\n                            $file->name,\n                            $version\n                        );\n                    }\n                }\n            }\n            $this->set_additional_file_properties($file);\n            return $file;\n        }\n        return null;\n    }\n\n    protected function get_file_objects($iteration_method = 'get_file_object') {\n        $upload_dir = $this->get_upload_path();\n        if (!is_dir($upload_dir)) {\n            return array();\n        }\n        return array_values(array_filter(array_map(\n            array($this, $iteration_method),\n            scandir($upload_dir)\n        )));\n    }\n\n    protected function count_file_objects() {\n        return count($this->get_file_objects('is_valid_file_object'));\n    }\n\n    protected function get_error_message($error) {\n        return array_key_exists($error, $this->error_messages) ?\n            $this->error_messages[$error] : $error;\n    }\n\n    function get_config_bytes($val) {\n        $val = trim($val);\n        $last = strtolower($val[strlen($val)-1]);\n        switch($last) {\n            case 'g':\n                $val *= 1024;\n            case 'm':\n                $val *= 1024;\n            case 'k':\n                $val *= 1024;\n        }\n        return $this->fix_integer_overflow($val);\n    }\n\n    protected function validate($uploaded_file, $file, $error, $index) {\n        if ($error) {\n            $file->error = $this->get_error_message($error);\n            return false;\n        }\n        $content_length = $this->fix_integer_overflow(intval(\n            $this->get_server_var('CONTENT_LENGTH')\n        ));\n        $post_max_size = $this->get_config_bytes(ini_get('post_max_size'));\n        if ($post_max_size && ($content_length > $post_max_size)) {\n            $file->error = $this->get_error_message('post_max_size');\n            return false;\n        }\n        if (!preg_match($this->options['accept_file_types'], $file->name)) {\n            $file->error = $this->get_error_message('accept_file_types');\n            return false;\n        }\n        if ($uploaded_file && is_uploaded_file($uploaded_file)) {\n            $file_size = $this->get_file_size($uploaded_file);\n        } else {\n            $file_size = $content_length;\n        }\n        if ($this->options['max_file_size'] && (\n                $file_size > $this->options['max_file_size'] ||\n                $file->size > $this->options['max_file_size'])\n            ) {\n            $file->error = $this->get_error_message('max_file_size');\n            return false;\n        }\n        if ($this->options['min_file_size'] &&\n            $file_size < $this->options['min_file_size']) {\n            $file->error = $this->get_error_message('min_file_size');\n            return false;\n        }\n        if (is_int($this->options['max_number_of_files']) &&\n                ($this->count_file_objects() >= $this->options['max_number_of_files']) &&\n                // Ignore additional chunks of existing files:\n                !is_file($this->get_upload_path($file->name))) {\n            $file->error = $this->get_error_message('max_number_of_files');\n            return false;\n        }\n        $max_width = @$this->options['max_width'];\n        $max_height = @$this->options['max_height'];\n        $min_width = @$this->options['min_width'];\n        $min_height = @$this->options['min_height'];\n        if (($max_width || $max_height || $min_width || $min_height)\n           && preg_match($this->options['image_file_types'], $file->name)) {\n            list($img_width, $img_height) = $this->get_image_size($uploaded_file);\n        }\n        if (!empty($img_width)) {\n            if ($max_width && $img_width > $max_width) {\n                $file->error = $this->get_error_message('max_width');\n                return false;\n            }\n            if ($max_height && $img_height > $max_height) {\n                $file->error = $this->get_error_message('max_height');\n                return false;\n            }\n            if ($min_width && $img_width < $min_width) {\n                $file->error = $this->get_error_message('min_width');\n                return false;\n            }\n            if ($min_height && $img_height < $min_height) {\n                $file->error = $this->get_error_message('min_height');\n                return false;\n            }\n        }\n        return true;\n    }\n\n    protected function upcount_name_callback($matches) {\n        $index = isset($matches[1]) ? intval($matches[1]) + 1 : 1;\n        $ext = isset($matches[2]) ? $matches[2] : '';\n        return ' ('.$index.')'.$ext;\n    }\n\n    protected function upcount_name($name) {\n        return preg_replace_callback(\n            '/(?:(?: \\(([\\d]+)\\))?(\\.[^.]+))?$/',\n            array($this, 'upcount_name_callback'),\n            $name,\n            1\n        );\n    }\n\n    protected function sanitizeFileName($file) {\n        // (|\\\\?*<\\\":>+[]/')\n        // \\|\\\\\\?\\*\\<\\\"\\'\\:\\>\\+\\[\\]\n        $file = preg_replace(\"/'/\", '', $file);\n\n        return $file;\n    }\n\n    protected function get_unique_filename($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        $name = $this->sanitizeFileName($name);\n\n        while(is_dir($this->get_upload_path($name))) {\n            $name = $this->upcount_name($name);\n        }\n        // Keep an existing filename if this is part of a chunked upload:\n        $uploaded_bytes = $this->fix_integer_overflow(intval($content_range[1]));\n        while(is_file($this->get_upload_path($name))) {\n            if ($uploaded_bytes === $this->get_file_size(\n                    $this->get_upload_path($name))) {\n                break;\n            }\n            $name = $this->upcount_name($name);\n        }\n        return $name;\n    }\n\n    protected function fix_file_extension($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        // Add missing file extension for known image types:\n        if (strpos($name, '.') === false &&\n                preg_match('/^image\\/(gif|jpe?g|png)/', $type, $matches)) {\n            $name .= '.'.$matches[1];\n        }\n        if ($this->options['correct_image_extensions'] &&\n                function_exists('exif_imagetype')) {\n            switch(@exif_imagetype($file_path)){\n                case IMAGETYPE_JPEG:\n                    $extensions = array('jpg', 'jpeg');\n                    break;\n                case IMAGETYPE_PNG:\n                    $extensions = array('png');\n                    break;\n                case IMAGETYPE_GIF:\n                    $extensions = array('gif');\n                    break;\n            }\n            // Adjust incorrect image file extensions:\n            if (!empty($extensions)) {\n                $parts = explode('.', $name);\n                $extIndex = count($parts) - 1;\n                $ext = strtolower(@$parts[$extIndex]);\n                if (!in_array($ext, $extensions)) {\n                    $parts[$extIndex] = $extensions[0];\n                    $name = implode('.', $parts);\n                }\n            }\n        }\n        return $name;\n    }\n\n    protected function trim_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        // Remove path information and dots around the filename, to prevent uploading\n        // into different directories or replacing hidden system files.\n        // Also remove control characters and spaces (\\x00..\\x20) around the filename:\n        $name = trim(basename(stripslashes($name)), \".\\x00..\\x20\");\n        // Use a timestamp for empty filenames:\n        if (!$name) {\n            $name = str_replace('.', '-', microtime(true));\n        }\n        return $name;\n    }\n\n    protected function get_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n        $name = $this->trim_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range);\n        return $this->get_unique_filename(\n            $file_path,\n            $this->fix_file_extension($file_path, $name, $size, $type, $error,\n                $index, $content_range),\n            $size,\n            $type,\n            $error,\n            $index,\n            $content_range\n        );\n    }\n\n    protected function get_current_file_name($file_path, $name, $size, $type, $error,\n            $index, $content_range) {\n\n        $name = $this->trim_file_name($file_path, $name, $size, $type, $error, $index, $content_range);\n\n\n        return $this->get_unique_filename(\n            $file_path,\n            $this->fix_file_extension($file_path, $name, $size, $type, $error,\n                $index, $content_range),\n            $size,\n            $type,\n            $error,\n            $index,\n            $content_range\n        );\n    }\n\n\n    protected function handle_form_data($file, $index) {\n        // Handle form data, e.g. $_REQUEST['description'][$index]\n    }\n\n    protected function get_scaled_image_file_paths($file_name, $version) {\n        $file_path = $this->get_upload_path($file_name);\n        if (!empty($version)) {\n            $version_dir = $this->get_upload_path(null, $version);\n            if (!is_dir($version_dir)) {\n                mkdir($version_dir, $this->options['mkdir_mode'], true);\n            }\n            $new_file_path = $version_dir.'/'.$file_name;\n        } else {\n            $new_file_path = $file_path;\n        }\n        return array($file_path, $new_file_path);\n    }\n\n    protected function gd_get_image_object($file_path, $func, $no_cache = false) {\n        if (empty($this->image_objects[$file_path]) || $no_cache) {\n            $this->gd_destroy_image_object($file_path);\n            $this->image_objects[$file_path] = $func($file_path);\n        }\n        return $this->image_objects[$file_path];\n    }\n\n    protected function gd_set_image_object($file_path, $image) {\n        $this->gd_destroy_image_object($file_path);\n        $this->image_objects[$file_path] = $image;\n    }\n\n    protected function gd_destroy_image_object($file_path) {\n        $image = (isset($this->image_objects[$file_path])) ? $this->image_objects[$file_path] : null ;\n        return $image && imagedestroy($image);\n    }\n\n    protected function gd_imageflip($image, $mode) {\n        if (function_exists('imageflip')) {\n            return imageflip($image, $mode);\n        }\n        $new_width = $src_width = imagesx($image);\n        $new_height = $src_height = imagesy($image);\n        $new_img = imagecreatetruecolor($new_width, $new_height);\n        $src_x = 0;\n        $src_y = 0;\n        switch ($mode) {\n            case '1': // flip on the horizontal axis\n                $src_y = $new_height - 1;\n                $src_height = -$new_height;\n                break;\n            case '2': // flip on the vertical axis\n                $src_x  = $new_width - 1;\n                $src_width = -$new_width;\n                break;\n            case '3': // flip on both axes\n                $src_y = $new_height - 1;\n                $src_height = -$new_height;\n                $src_x  = $new_width - 1;\n                $src_width = -$new_width;\n                break;\n            default:\n                return $image;\n        }\n        imagecopyresampled(\n            $new_img,\n            $image,\n            0,\n            0,\n            $src_x,\n            $src_y,\n            $new_width,\n            $new_height,\n            $src_width,\n            $src_height\n        );\n        return $new_img;\n    }\n\n    protected function gd_orient_image($file_path, $src_img) {\n        if (!function_exists('exif_read_data')) {\n            return false;\n        }\n        $exif = @exif_read_data($file_path);\n        if ($exif === false) {\n            return false;\n        }\n        $orientation = intval(@$exif['Orientation']);\n        if ($orientation < 2 || $orientation > 8) {\n            return false;\n        }\n        switch ($orientation) {\n            case 2:\n                $new_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2\n                );\n                break;\n            case 3:\n                $new_img = imagerotate($src_img, 180, 0);\n                break;\n            case 4:\n                $new_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1\n                );\n                break;\n            case 5:\n                $tmp_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1\n                );\n                $new_img = imagerotate($tmp_img, 270, 0);\n                imagedestroy($tmp_img);\n                break;\n            case 6:\n                $new_img = imagerotate($src_img, 270, 0);\n                break;\n            case 7:\n                $tmp_img = $this->gd_imageflip(\n                    $src_img,\n                    defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2\n                );\n                $new_img = imagerotate($tmp_img, 270, 0);\n                imagedestroy($tmp_img);\n                break;\n            case 8:\n                $new_img = imagerotate($src_img, 90, 0);\n                break;\n            default:\n                return false;\n        }\n        $this->gd_set_image_object($file_path, $new_img);\n        return true;\n    }\n\n    protected function gd_create_scaled_image($file_name, $version, $options) {\n        if (!function_exists('imagecreatetruecolor')) {\n            error_log('Function not found: imagecreatetruecolor');\n            return false;\n        }\n        list($file_path, $new_file_path) =\n            $this->get_scaled_image_file_paths($file_name, $version);\n        $type = strtolower(substr(strrchr($file_name, '.'), 1));\n        switch ($type) {\n            case 'jpg':\n            case 'jpeg':\n                $src_func = 'imagecreatefromjpeg';\n                $write_func = 'imagejpeg';\n                $image_quality = isset($options['jpeg_quality']) ?\n                    $options['jpeg_quality'] : 75;\n                break;\n            case 'gif':\n                $src_func = 'imagecreatefromgif';\n                $write_func = 'imagegif';\n                $image_quality = null;\n                break;\n            case 'png':\n                $src_func = 'imagecreatefrompng';\n                $write_func = 'imagepng';\n                $image_quality = isset($options['png_quality']) ?\n                    $options['png_quality'] : 9;\n                break;\n            default:\n                return false;\n        }\n        $src_img = $this->gd_get_image_object(\n            $file_path,\n            $src_func,\n            !empty($options['no_cache'])\n        );\n        $image_oriented = false;\n        if (!empty($options['auto_orient']) && $this->gd_orient_image(\n                $file_path,\n                $src_img\n            )) {\n            $image_oriented = true;\n            $src_img = $this->gd_get_image_object(\n                $file_path,\n                $src_func\n            );\n        }\n        $max_width = $img_width = imagesx($src_img);\n        $max_height = $img_height = imagesy($src_img);\n        if (!empty($options['max_width'])) {\n            $max_width = $options['max_width'];\n        }\n        if (!empty($options['max_height'])) {\n            $max_height = $options['max_height'];\n        }\n        $scale = min(\n            $max_width / $img_width,\n            $max_height / $img_height\n        );\n        if ($scale >= 1) {\n            if ($image_oriented) {\n                return $write_func($src_img, $new_file_path, $image_quality);\n            }\n            if ($file_path !== $new_file_path) {\n                return copy($file_path, $new_file_path);\n            }\n            return true;\n        }\n        if (empty($options['crop'])) {\n            $new_width = $img_width * $scale;\n            $new_height = $img_height * $scale;\n            $dst_x = 0;\n            $dst_y = 0;\n            $new_img = imagecreatetruecolor($new_width, $new_height);\n        } else {\n            if (($img_width / $img_height) >= ($max_width / $max_height)) {\n                $new_width = $img_width / ($img_height / $max_height);\n                $new_height = $max_height;\n            } else {\n                $new_width = $max_width;\n                $new_height = $img_height / ($img_width / $max_width);\n            }\n            $dst_x = 0 - ($new_width - $max_width) / 2;\n            $dst_y = 0 - ($new_height - $max_height) / 2;\n            $new_img = imagecreatetruecolor($max_width, $max_height);\n        }\n        // Handle transparency in GIF and PNG images:\n        switch ($type) {\n            case 'gif':\n            case 'png':\n                imagecolortransparent($new_img, imagecolorallocate($new_img, 0, 0, 0));\n            case 'png':\n                imagealphablending($new_img, false);\n                imagesavealpha($new_img, true);\n                break;\n        }\n        $success = imagecopyresampled(\n            $new_img,\n            $src_img,\n            $dst_x,\n            $dst_y,\n            0,\n            0,\n            $new_width,\n            $new_height,\n            $img_width,\n            $img_height\n        ) && $write_func($new_img, $new_file_path, $image_quality);\n        $this->gd_set_image_object($file_path, $new_img);\n        return $success;\n    }\n\n    protected function imagick_get_image_object($file_path, $no_cache = false) {\n        if (empty($this->image_objects[$file_path]) || $no_cache) {\n            $this->imagick_destroy_image_object($file_path);\n            $image = new \\Imagick();\n            if (!empty($this->options['imagick_resource_limits'])) {\n                foreach ($this->options['imagick_resource_limits'] as $type => $limit) {\n                    $image->setResourceLimit($type, $limit);\n                }\n            }\n            $image->readImage($file_path);\n            $this->image_objects[$file_path] = $image;\n        }\n        return $this->image_objects[$file_path];\n    }\n\n    protected function imagick_set_image_object($file_path, $image) {\n        $this->imagick_destroy_image_object($file_path);\n        $this->image_objects[$file_path] = $image;\n    }\n\n    protected function imagick_destroy_image_object($file_path) {\n        $image = (isset($this->image_objects[$file_path])) ? $this->image_objects[$file_path] : null ;\n        return $image && $image->destroy();\n    }\n\n    protected function imagick_orient_image($image) {\n        $orientation = $image->getImageOrientation();\n        $background = new \\ImagickPixel('none');\n        switch ($orientation) {\n            case \\imagick::ORIENTATION_TOPRIGHT: // 2\n                $image->flopImage(); // horizontal flop around y-axis\n                break;\n            case \\imagick::ORIENTATION_BOTTOMRIGHT: // 3\n                $image->rotateImage($background, 180);\n                break;\n            case \\imagick::ORIENTATION_BOTTOMLEFT: // 4\n                $image->flipImage(); // vertical flip around x-axis\n                break;\n            case \\imagick::ORIENTATION_LEFTTOP: // 5\n                $image->flopImage(); // horizontal flop around y-axis\n                $image->rotateImage($background, 270);\n                break;\n            case \\imagick::ORIENTATION_RIGHTTOP: // 6\n                $image->rotateImage($background, 90);\n                break;\n            case \\imagick::ORIENTATION_RIGHTBOTTOM: // 7\n                $image->flipImage(); // vertical flip around x-axis\n                $image->rotateImage($background, 270);\n                break;\n            case \\imagick::ORIENTATION_LEFTBOTTOM: // 8\n                $image->rotateImage($background, 270);\n                break;\n            default:\n                return false;\n        }\n        $image->setImageOrientation(\\imagick::ORIENTATION_TOPLEFT); // 1\n        return true;\n    }\n\n    protected function imagick_create_scaled_image($file_name, $version, $options) {\n        list($file_path, $new_file_path) =\n            $this->get_scaled_image_file_paths($file_name, $version);\n        $image = $this->imagick_get_image_object(\n            $file_path,\n            !empty($options['no_cache'])\n        );\n        if ($image->getImageFormat() === 'GIF') {\n            // Handle animated GIFs:\n            $images = $image->coalesceImages();\n            foreach ($images as $frame) {\n                $image = $frame;\n                $this->imagick_set_image_object($file_name, $image);\n                break;\n            }\n        }\n        $image_oriented = false;\n        if (!empty($options['auto_orient'])) {\n            $image_oriented = $this->imagick_orient_image($image);\n        }\n        $new_width = $max_width = $img_width = $image->getImageWidth();\n        $new_height = $max_height = $img_height = $image->getImageHeight();\n        if (!empty($options['max_width'])) {\n            $new_width = $max_width = $options['max_width'];\n        }\n        if (!empty($options['max_height'])) {\n            $new_height = $max_height = $options['max_height'];\n        }\n        if (!($image_oriented || $max_width < $img_width || $max_height < $img_height)) {\n            if ($file_path !== $new_file_path) {\n                return copy($file_path, $new_file_path);\n            }\n            return true;\n        }\n        $crop = !empty($options['crop']);\n        if ($crop) {\n            $x = 0;\n            $y = 0;\n            if (($img_width / $img_height) >= ($max_width / $max_height)) {\n                $new_width = 0; // Enables proportional scaling based on max_height\n                $x = ($img_width / ($img_height / $max_height) - $max_width) / 2;\n            } else {\n                $new_height = 0; // Enables proportional scaling based on max_width\n                $y = ($img_height / ($img_width / $max_width) - $max_height) / 2;\n            }\n        }\n        $success = $image->resizeImage(\n            $new_width,\n            $new_height,\n            isset($options['filter']) ? $options['filter'] : \\imagick::FILTER_LANCZOS,\n            isset($options['blur']) ? $options['blur'] : 1,\n            $new_width && $new_height // fit image into constraints if not to be cropped\n        );\n        if ($success && $crop) {\n            $success = $image->cropImage(\n                $max_width,\n                $max_height,\n                $x,\n                $y\n            );\n            if ($success) {\n                $success = $image->setImagePage($max_width, $max_height, 0, 0);\n            }\n        }\n        $type = strtolower(substr(strrchr($file_name, '.'), 1));\n        switch ($type) {\n            case 'jpg':\n            case 'jpeg':\n                if (!empty($options['jpeg_quality'])) {\n                    $image->setImageCompression(\\imagick::COMPRESSION_JPEG);\n                    $image->setImageCompressionQuality($options['jpeg_quality']);\n                }\n                break;\n        }\n        if (!empty($options['strip'])) {\n            $image->stripImage();\n        }\n        return $success && $image->writeImage($new_file_path);\n    }\n\n    protected function imagemagick_create_scaled_image($file_name, $version, $options) {\n        list($file_path, $new_file_path) =\n            $this->get_scaled_image_file_paths($file_name, $version);\n        $resize = @$options['max_width']\n            .(empty($options['max_height']) ? '' : 'X'.$options['max_height']);\n        if (!$resize && empty($options['auto_orient'])) {\n            if ($file_path !== $new_file_path) {\n                return copy($file_path, $new_file_path);\n            }\n            return true;\n        }\n        $cmd = $this->options['convert_bin'];\n        if (!empty($this->options['convert_params'])) {\n            $cmd .= ' '.$this->options['convert_params'];\n        }\n        $cmd .= ' '.escapeshellarg($file_path);\n        if (!empty($options['auto_orient'])) {\n            $cmd .= ' -auto-orient';\n        }\n        if ($resize) {\n            // Handle animated GIFs:\n            $cmd .= ' -coalesce';\n            if (empty($options['crop'])) {\n                $cmd .= ' -resize '.escapeshellarg($resize.'>');\n            } else {\n                $cmd .= ' -resize '.escapeshellarg($resize.'^');\n                $cmd .= ' -gravity center';\n                $cmd .= ' -crop '.escapeshellarg($resize.'+0+0');\n            }\n            // Make sure the page dimensions are correct (fixes offsets of animated GIFs):\n            $cmd .= ' +repage';\n        }\n        if (!empty($options['convert_params'])) {\n            $cmd .= ' '.$options['convert_params'];\n        }\n        $cmd .= ' '.escapeshellarg($new_file_path);\n        exec($cmd, $output, $error);\n        if ($error) {\n            error_log(implode('\\n', $output));\n            return false;\n        }\n        return true;\n    }\n\n    protected function get_image_size($file_path) {\n        if ($this->options['image_library']) {\n            if (extension_loaded('imagick')) {\n                $image = new \\Imagick();\n                try {\n                    if (@$image->pingImage($file_path)) {\n                        $dimensions = array($image->getImageWidth(), $image->getImageHeight());\n                        $image->destroy();\n                        return $dimensions;\n                    }\n                    return false;\n                } catch (Exception $e) {\n                    error_log($e->getMessage());\n                }\n            }\n            if ($this->options['image_library'] === 2) {\n                $cmd = $this->options['identify_bin'];\n                $cmd .= ' -ping '.escapeshellarg($file_path);\n                exec($cmd, $output, $error);\n                if (!$error && !empty($output)) {\n                    // image.jpg JPEG 1920x1080 1920x1080+0+0 8-bit sRGB 465KB 0.000u 0:00.000\n                    $infos = preg_split('/\\s+/', $output[0]);\n                    $dimensions = preg_split('/x/', $infos[2]);\n                    return $dimensions;\n                }\n                return false;\n            }\n        }\n        if (!function_exists('getimagesize')) {\n            error_log('Function not found: getimagesize');\n            return false;\n        }\n        return @getimagesize($file_path);\n    }\n\n    protected function create_scaled_image($file_name, $version, $options) {\n        if ($this->options['image_library'] === 2) {\n            return $this->imagemagick_create_scaled_image($file_name, $version, $options);\n        }\n        if ($this->options['image_library'] && extension_loaded('imagick')) {\n            return $this->imagick_create_scaled_image($file_name, $version, $options);\n        }\n        return $this->gd_create_scaled_image($file_name, $version, $options);\n    }\n\n    protected function destroy_image_object($file_path) {\n        if ($this->options['image_library'] && extension_loaded('imagick')) {\n            return $this->imagick_destroy_image_object($file_path);\n        }\n    }\n\n    protected function is_valid_image_file($file_path) {\n        if (!preg_match($this->options['image_file_types'], $file_path)) {\n            return false;\n        }\n        if (function_exists('exif_imagetype')) {\n            return @exif_imagetype($file_path);\n        }\n        $image_info = $this->get_image_size($file_path);\n        return $image_info && $image_info[0] && $image_info[1];\n    }\n\n    protected function handle_image_file($file_path, $file) {\n        $failed_versions = array();\n        foreach($this->options['image_versions'] as $version => $options) {\n            if ($this->create_scaled_image($file->name, $version, $options)) {\n                if (!empty($version)) {\n                    $file->{$version.'Url'} = $this->get_download_url(\n                        $file->name,\n                        $version\n                    );\n                } else {\n                    $file->size = $this->get_file_size($file_path, true);\n                }\n            } else {\n                $failed_versions[] = $version ? $version : 'original';\n            }\n        }\n        if (count($failed_versions)) {\n            $file->error = $this->get_error_message('image_resize')\n                    .' ('.implode($failed_versions,', ').')';\n        }\n        // Free memory:\n        $this->destroy_image_object($file_path);\n    }\n\n    protected function handle_file_upload($uploaded_file, $name, $size, $type, $error,\n        $index = null, $content_range = null) {\n\n        $file = new \\stdClass();\n//        $file->name = $this->get_file_name($uploaded_file, $name, $size, $type, $error,\n//            $index, $content_range);\n\n        $file->name = $this->trim_file_name($uploaded_path, $name, $size, $type, $error, $index, $content_range);\n        $file->name = $this->fix_file_extension($uploaded_path, $name, $size, $type, $error, $index, $content_range);\n\n\n        $file->size = $this->fix_integer_overflow(intval($size));\n        $file->type = $type;\n        if ($this->validate($uploaded_file, $file, $error, $index)) {\n            $this->handle_form_data($file, $index);\n            $upload_dir = $this->get_upload_path();\n            if (!is_dir($upload_dir)) {\n                mkdir($upload_dir, $this->options['mkdir_mode'], true);\n            }\n            $file_path = $this->get_upload_path($file->name);\n            $append_file = $content_range && is_file($file_path) &&\n                $file->size > $this->get_file_size($file_path);\n            if ($uploaded_file && is_uploaded_file($uploaded_file) && strpos($file_path, \"'\")===false && strpos($file_path, '\"')===false) {\n                chmod($uploaded_file, 0644);\n                exec (VESTA_CMD . \"v-copy-fs-file \". USERNAME .\" \".$uploaded_file.\" \".escapeshellarg($file_path), $output, $return_var);\n                $error = check_return_code($return_var, $output);\n                if ($return_var != 0) {\n                    $file->error = 'Error while saving file ';\n                }\n            }\n            $file_size = $this->get_file_size($file_path, $append_file);\n\n            if ($file_size === $file->size) {\n                $file->url = $this->get_download_url($file->name);\n                // uncomment if images also need to be resized\n                //if ($this->is_valid_image_file($file_path)) {\n                //    $this->handle_image_file($file_path, $file);\n                //}\n            } else {\n                //$file->size = $file_size;\n                //if (!$content_range && $this->options['discard_aborted_uploads']) {\n                //    unlink($file_path);\n                //    $file->error = $this->get_error_message('abort');\n                //}\n            }\n            $this->set_additional_file_properties($file);\n        }\n        return $file;\n    }\n\n    protected function readfile($file_path) {\n        $file_size = $this->get_file_size($file_path);\n        $chunk_size = $this->options['readfile_chunk_size'];\n        if ($chunk_size && $file_size > $chunk_size) {\n            $handle = fopen($file_path, 'rb');\n            while (!feof($handle)) {\n                echo fread($handle, $chunk_size);\n                @ob_flush();\n                @flush();\n            }\n            fclose($handle);\n            return $file_size;\n        }\n        return readfile($file_path);\n    }\n\n    protected function body($str) {\n        echo $str;\n    }\n\n    protected function header($str) {\n        header($str);\n    }\n\n    protected function get_server_var($id) {\n        return isset($_SERVER[$id]) ? $_SERVER[$id] : '';\n    }\n\n    protected function generate_response($content, $print_response = true) {\n        if ($print_response) {\n            $json = json_encode($content);\n            $redirect = isset($_REQUEST['redirect']) ?\n                stripslashes($_REQUEST['redirect']) : null;\n            if ($redirect) {\n                $this->header('Location: '.sprintf($redirect, rawurlencode($json)));\n                return;\n            }\n            $this->head();\n            if ($this->get_server_var('HTTP_CONTENT_RANGE')) {\n                $files = isset($content[$this->options['param_name']]) ?\n                    $content[$this->options['param_name']] : null;\n                if ($files && is_array($files) && is_object($files[0]) && $files[0]->size) {\n                    $this->header('Range: 0-'.(\n                        $this->fix_integer_overflow(intval($files[0]->size)) - 1\n                    ));\n                }\n            }\n            $this->body($json);\n        }\n        return $content;\n    }\n\n    protected function get_version_param() {\n        return isset($_GET['version']) ? basename(stripslashes($_GET['version'])) : null;\n    }\n\n    protected function get_singular_param_name() {\n        return substr($this->options['param_name'], 0, -1);\n    }\n\n    protected function get_file_name_param() {\n        $name = $this->get_singular_param_name();\n        return isset($_REQUEST[$name]) ? basename(stripslashes($_REQUEST[$name])) : null;\n    }\n\n    protected function get_file_names_params() {\n        $params = isset($_REQUEST[$this->options['param_name']]) ?\n            $_REQUEST[$this->options['param_name']] : array();\n        foreach ($params as $key => $value) {\n            $params[$key] = basename(stripslashes($value));\n        }\n        return $params;\n    }\n\n    protected function get_file_type($file_path) {\n        switch (strtolower(pathinfo($file_path, PATHINFO_EXTENSION))) {\n            case 'jpeg':\n            case 'jpg':\n                return 'image/jpeg';\n            case 'png':\n                return 'image/png';\n            case 'gif':\n                return 'image/gif';\n            default:\n                return '';\n        }\n    }\n\n    protected function download() {\n        switch ($this->options['download_via_php']) {\n            case 1:\n                $redirect_header = null;\n                break;\n            case 2:\n                $redirect_header = 'X-Sendfile';\n                break;\n            case 3:\n                $redirect_header = 'X-Accel-Redirect';\n                break;\n            default:\n                return $this->header('HTTP/1.1 403 Forbidden');\n        }\n        $file_name = $this->get_file_name_param();\n        if (!$this->is_valid_file_object($file_name)) {\n            return $this->header('HTTP/1.1 404 Not Found');\n        }\n        if ($redirect_header) {\n            return $this->header(\n                $redirect_header.': '.$this->get_download_url(\n                    $file_name,\n                    $this->get_version_param(),\n                    true\n                )\n            );\n        }\n        $file_path = $this->get_upload_path($file_name, $this->get_version_param());\n        // Prevent browsers from MIME-sniffing the content-type:\n        $this->header('X-Content-Type-Options: nosniff');\n        if (!preg_match($this->options['inline_file_types'], $file_name)) {\n            $this->header('Content-Type: application/octet-stream');\n            $this->header('Content-Disposition: attachment; filename=\"'.$file_name.'\"');\n        } else {\n            $this->header('Content-Type: '.$this->get_file_type($file_path));\n            $this->header('Content-Disposition: inline; filename=\"'.$file_name.'\"');\n        }\n        $this->header('Content-Length: '.$this->get_file_size($file_path));\n        $this->header('Last-Modified: '.gmdate('D, d M Y H:i:s T', filemtime($file_path)));\n        $this->readfile($file_path);\n    }\n\n    protected function send_content_type_header() {\n        $this->header('Vary: Accept');\n        if (strpos($this->get_server_var('HTTP_ACCEPT'), 'application/json') !== false) {\n            $this->header('Content-type: application/json');\n        } else {\n            $this->header('Content-type: text/plain');\n        }\n    }\n\n    protected function send_access_control_headers() {\n        $this->header('Access-Control-Allow-Origin: '.$this->options['access_control_allow_origin']);\n        $this->header('Access-Control-Allow-Credentials: '\n            .($this->options['access_control_allow_credentials'] ? 'true' : 'false'));\n        $this->header('Access-Control-Allow-Methods: '\n            .implode(', ', $this->options['access_control_allow_methods']));\n        $this->header('Access-Control-Allow-Headers: '\n            .implode(', ', $this->options['access_control_allow_headers']));\n    }\n\n    public function head() {\n        $this->header('Pragma: no-cache');\n        $this->header('Cache-Control: no-store, no-cache, must-revalidate');\n        $this->header('Content-Disposition: inline; filename=\"files.json\"');\n        // Prevent Internet Explorer from MIME-sniffing the content-type:\n        $this->header('X-Content-Type-Options: nosniff');\n        if ($this->options['access_control_allow_origin']) {\n            $this->send_access_control_headers();\n        }\n        $this->send_content_type_header();\n    }\n\n    public function get($print_response = true) {\n        if ($print_response && isset($_GET['download'])) {\n            return $this->download();\n        }\n        $file_name = $this->get_file_name_param();\n        if ($file_name) {\n            $response = array(\n                $this->get_singular_param_name() => $this->get_file_object($file_name)\n            );\n        } else {\n            $response = array(\n                $this->options['param_name'] => $this->get_file_objects()\n            );\n        }\n        return $this->generate_response($response, $print_response);\n    }\n\n    public function post($print_response = true) {\n        if (isset($_REQUEST['_method']) && $_REQUEST['_method'] === 'DELETE') {\n            return $this->delete($print_response);\n        }\n        $upload = isset($_FILES[$this->options['param_name']]) ?\n            $_FILES[$this->options['param_name']] : null;\n        // Parse the Content-Disposition header, if available:\n        $file_name = $this->get_server_var('HTTP_CONTENT_DISPOSITION') ?\n            rawurldecode(preg_replace(\n                '/(^[^\"]+\")|(\"$)/',\n                '',\n                $this->get_server_var('HTTP_CONTENT_DISPOSITION')\n            )) : null;\n        // Parse the Content-Range header, which has the following form:\n        // Content-Range: bytes 0-524287/2000000\n        $content_range = $this->get_server_var('HTTP_CONTENT_RANGE') ?\n            preg_split('/[^0-9]+/', $this->get_server_var('HTTP_CONTENT_RANGE')) : null;\n        $size =  $content_range ? $content_range[3] : null;\n        $files = array();\n        if ($upload && is_array($upload['tmp_name'])) {\n            // param_name is an array identifier like \"files[]\",\n            // $_FILES is a multi-dimensional array:\n            foreach ($upload['tmp_name'] as $index => $value) {\n                $files[] = $this->handle_file_upload(\n                    $upload['tmp_name'][$index],\n                    $file_name ? $file_name : $upload['name'][$index],\n                    $size ? $size : $upload['size'][$index],\n                    $upload['type'][$index],\n                    $upload['error'][$index],\n                    $index,\n                    $content_range\n                );\n            }\n        } else {\n            // param_name is a single object identifier like \"file\",\n            // $_FILES is a one-dimensional array:\n            $files[] = $this->handle_file_upload(\n                isset($upload['tmp_name']) ? $upload['tmp_name'] : null,\n                $file_name ? $file_name : (isset($upload['name']) ?\n                        $upload['name'] : null),\n                $size ? $size : (isset($upload['size']) ?\n                        $upload['size'] : $this->get_server_var('CONTENT_LENGTH')),\n                isset($upload['type']) ?\n                        $upload['type'] : $this->get_server_var('CONTENT_TYPE'),\n                isset($upload['error']) ? $upload['error'] : null,\n                null,\n                $content_range\n            );\n        }\n        return $this->generate_response(\n            array($this->options['param_name'] => $files),\n            $print_response\n        );\n    }\n\n    public function delete($print_response = true) {\n        $file_names = $this->get_file_names_params();\n        if (empty($file_names)) {\n            $file_names = array($this->get_file_name_param());\n        }\n        $response = array();\n        foreach($file_names as $file_name) {\n            $file_path = $this->get_upload_path($file_name);\n            $success = is_file($file_path) && $file_name[0] !== '.' && unlink($file_path);\n            if ($success) {\n                foreach($this->options['image_versions'] as $version => $options) {\n                    if (!empty($version)) {\n                        $file = $this->get_upload_path($file_name, $version);\n                        if (is_file($file)) {\n                            unlink($file);\n                        }\n                    }\n                }\n            }\n            $response[$file_name] = $success;\n        }\n        return $this->generate_response($response, $print_response);\n    }\n\n}\n"], "filenames": ["web/upload/UploadHandler.php"], "buggy_code_start_loc": [3], "buggy_code_end_loc": [3], "fixing_code_start_loc": [4], "fixing_code_end_loc": [11], "type": "CWE-434", "message": "web/upload/UploadHandler.php in Vesta Control Panel (aka VestaCP) through 0.9.8-27 and myVesta through 0.9.8-26-39 allows uploads from a different origin.", "other": {"cve": {"id": "CVE-2021-28379", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-15T06:15:12.783", "lastModified": "2021-03-19T20:36:35.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "web/upload/UploadHandler.php in Vesta Control Panel (aka VestaCP) through 0.9.8-27 and myVesta through 0.9.8-26-39 allows uploads from a different origin."}, {"lang": "es", "value": "El archivo web/upload/UploadHandler.php en Vesta Control Panel (tambi\u00e9n se conoce como VestaCP) versiones hasta 0.9.8-27 y myVesta versiones hasta 0.9.8-26-39, permite cargas desde un origen diferente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:myvestacp:myvesta:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.8-26-39", "matchCriteriaId": "A210CEF2-4A8A-4963-921D-47D4890EFB2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vestacp:vesta_control_panel:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.8-27", "matchCriteriaId": "7A573DF2-7611-421B-A340-4E4F0CFF4701"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/161836/VestaCP-0.9.8-Cross-Site-Request-Forgery.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/myvesta/vesta/commit/3402071e950e76b79fa8672a1e09b70d3860f355", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/myvesta/vesta/commit/3402071e950e76b79fa8672a1e09b70d3860f355"}}