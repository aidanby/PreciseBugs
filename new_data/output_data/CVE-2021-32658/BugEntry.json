{"buggy_code": ["/*\n * Nextcloud Android client application\n *\n * @author Tobias Kaminsky\n * Copyright (C) 2017 Tobias Kaminsky\n * Copyright (C) 2017 Nextcloud GmbH.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.owncloud.android.util;\n\nimport android.text.TextUtils;\n\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonParser;\nimport com.google.gson.reflect.TypeToken;\nimport com.owncloud.android.datamodel.DecryptedFolderMetadata;\nimport com.owncloud.android.datamodel.EncryptedFolderMetadata;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.utils.CsrHelper;\nimport com.owncloud.android.utils.EncryptionUtils;\n\nimport net.bytebuddy.utility.RandomString;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\nimport androidx.test.runner.AndroidJUnit4;\n\nimport static androidx.test.InstrumentationRegistry.getInstrumentation;\nimport static com.owncloud.android.utils.EncryptionUtils.EncryptedFile;\nimport static com.owncloud.android.utils.EncryptionUtils.decodeStringToBase64Bytes;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptFile;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptFolderMetaData;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptPrivateKey;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptStringAsymmetric;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptStringSymmetric;\nimport static com.owncloud.android.utils.EncryptionUtils.deserializeJSON;\nimport static com.owncloud.android.utils.EncryptionUtils.encodeBytesToBase64String;\nimport static com.owncloud.android.utils.EncryptionUtils.encryptFile;\nimport static com.owncloud.android.utils.EncryptionUtils.encryptFolderMetadata;\nimport static com.owncloud.android.utils.EncryptionUtils.generateKey;\nimport static com.owncloud.android.utils.EncryptionUtils.generateSHA512;\nimport static com.owncloud.android.utils.EncryptionUtils.getMD5Sum;\nimport static com.owncloud.android.utils.EncryptionUtils.ivDelimiter;\nimport static com.owncloud.android.utils.EncryptionUtils.ivDelimiterOld;\nimport static com.owncloud.android.utils.EncryptionUtils.ivLength;\nimport static com.owncloud.android.utils.EncryptionUtils.randomBytes;\nimport static com.owncloud.android.utils.EncryptionUtils.saltLength;\nimport static com.owncloud.android.utils.EncryptionUtils.serializeJSON;\nimport static com.owncloud.android.utils.EncryptionUtils.verifySHA512;\nimport static junit.framework.Assert.assertFalse;\nimport static junit.framework.Assert.assertTrue;\nimport static org.junit.Assert.assertEquals;\n\n@RunWith(AndroidJUnit4.class)\npublic class EncryptionTestIT {\n    private String privateKey = \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAo\" +\n            \"IBAQDsn0JKS/THu328z1IgN0VzYU53HjSX03WJIgWkmyTaxbiKpoJaKbksXmfSpgzV\" +\n            \"GzKFvGfZ03fwFrN7Q8P8R2e8SNiell7mh1TDw9/0P7Bt/ER8PJrXORo+GviKHxaLr7\" +\n            \"Y0BJX9i/nW/L0L/VaE8CZTAqYBdcSJGgHJjY4UMf892ZPTa9T2Dl3ggdMZ7BQ2kiCi\" +\n            \"CC3qV99b0igRJGmmLQaGiAflhFzuDQPMifUMq75wI8RSRPdxUAtjTfkl68QHu7Umye\" +\n            \"yy33OQgdUKaTl5zcS3VSQbNjveVCNM4RDH1RlEc+7Wf1BY8APqT6jbiBcROJD2CeoL\" +\n            \"H2eiIJCi+61ZkSGfAgMBAAECggEBALFStCHrhBf+GL9a+qer4/8QZ/X6i91PmaBX/7\" +\n            \"SYk2jjjWVSXRNmex+V6+Y/jBRT2mvAgm8J+7LPwFdatE+lz0aZrMRD2gCWYF6Itpda\" +\n            \"90OlLkmQPVWWtGTgX2ta2tF5r2iSGzk0IdoL8zw98Q2UzpOcw30KnWtFMxuxWk0mHq\" +\n            \"pgp00g80cDWg3+RPbWOhdLp5bflQ36fKDfmjq05cGlIk6unnVyC5HXpvh4d4k2EWlX\" +\n            \"rjGsndVBPCjGkZePlLRgDHxT06r+5XdJ+1CBDZgCsmjGz3M8uOHyCfVW0WhB7ynzDT\" +\n            \"agVgz0iqpuhAi9sPt6iWWwpAnRw8cQgqEKw9bvKKECgYEA/WPi2PJtL6u/xlysh/H7\" +\n            \"A717CId6fPHCMDace39ZNtzUzc0nT5BemlcF0wZ74NeJSur3Q395YzB+eBMLs5p8mA\" +\n            \"95wgGvJhM65/J+HX+k9kt6Z556zLMvtG+j1yo4D0VEwm3xahB4SUUP+1kD7dNvo4+8\" +\n            \"xeSCyjzNllvYZZC0DrECgYEA7w8pEqhHHn0a+twkPCZJS+gQTB9Rm+FBNGJqB3XpWs\" +\n            \"TeLUxYRbVGk0iDve+eeeZ41drxcdyWP+WcL34hnrjgI1Fo4mK88saajpwUIYMy6+qM\" +\n            \"LY+jC2NRSBox56eH7nsVYvQQK9eKqv9wbB+PF9SwOIvuETN7fd8mAY02UnoaaU8CgY\" +\n            \"BoHRKocXPLkpZJuuppMVQiRUi4SHJbxDo19Tp2w+y0TihiJ1lvp7I3WGpcOt3LlMQk\" +\n            \"tEbExSvrRZGxZKH6Og/XqwQsYuTEkEIz679F/5yYVosE6GkskrOXQAfh8Mb3/04xVV\" +\n            \"tMaVgDQw0+CWVD4wyL+BNofGwBDNqsXTCdCsfxAQKBgQCDv2EtbRw0y1HRKv21QIxo\" +\n            \"ju5cZW4+cDfVPN+eWPdQFOs1H7wOPsc0aGRiiupV2BSEF3O1ApKziEE5U1QH+29bR4\" +\n            \"R8L1pemeGX8qCNj5bCubKjcWOz5PpouDcEqimZ3q98p3E6GEHN15UHoaTkx0yO/V8o\" +\n            \"j6zhQ9fYRxDHB5ACtQKBgQCOO7TJUO1IaLTjcrwS4oCfJyRnAdz49L1AbVJkIBK0fh\" +\n            \"JLecOFu3ZlQl/RStQb69QKb5MNOIMmQhg8WOxZxHcpmIDbkDAm/J/ovJXFSoBdOr5o\" +\n            \"uQsYsDZhsWW97zvLMzg5pH9/3/1BNz5q3Vu4HgfBSwWGt4E2NENj+XA+QAVmGA==\";\n\n    private String cert = \"-----BEGIN CERTIFICATE-----\\n\" +\n            \"MIIDpzCCAo+gAwIBAgIBADANBgkqhkiG9w0BAQUFADBuMRowGAYDVQQDDBF3d3cu\\n\" +\n            \"bmV4dGNsb3VkLmNvbTESMBAGA1UECgwJTmV4dGNsb3VkMRIwEAYDVQQHDAlTdHV0\\n\" +\n            \"dGdhcnQxGzAZBgNVBAgMEkJhZGVuLVd1ZXJ0dGVtYmVyZzELMAkGA1UEBhMCREUw\\n\" +\n            \"HhcNMTcwOTI2MTAwNDMwWhcNMzcwOTIxMTAwNDMwWjBuMRowGAYDVQQDDBF3d3cu\\n\" +\n            \"bmV4dGNsb3VkLmNvbTESMBAGA1UECgwJTmV4dGNsb3VkMRIwEAYDVQQHDAlTdHV0\\n\" +\n            \"dGdhcnQxGzAZBgNVBAgMEkJhZGVuLVd1ZXJ0dGVtYmVyZzELMAkGA1UEBhMCREUw\\n\" +\n            \"ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDsn0JKS/THu328z1IgN0Vz\\n\" +\n            \"YU53HjSX03WJIgWkmyTaxbiKpoJaKbksXmfSpgzVGzKFvGfZ03fwFrN7Q8P8R2e8\\n\" +\n            \"SNiell7mh1TDw9/0P7Bt/ER8PJrXORo+GviKHxaLr7Y0BJX9i/nW/L0L/VaE8CZT\\n\" +\n            \"AqYBdcSJGgHJjY4UMf892ZPTa9T2Dl3ggdMZ7BQ2kiCiCC3qV99b0igRJGmmLQaG\\n\" +\n            \"iAflhFzuDQPMifUMq75wI8RSRPdxUAtjTfkl68QHu7Umyeyy33OQgdUKaTl5zcS3\\n\" +\n            \"VSQbNjveVCNM4RDH1RlEc+7Wf1BY8APqT6jbiBcROJD2CeoLH2eiIJCi+61ZkSGf\\n\" +\n            \"AgMBAAGjUDBOMB0GA1UdDgQWBBTFrXz2tk1HivD9rQ75qeoyHrAgIjAfBgNVHSME\\n\" +\n            \"GDAWgBTFrXz2tk1HivD9rQ75qeoyHrAgIjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3\\n\" +\n            \"DQEBBQUAA4IBAQARQTX21QKO77gAzBszFJ6xVnjfa23YZF26Z4X1KaM8uV8TGzuN\\n\" +\n            \"JA95XmReeP2iO3r8EWXS9djVCD64m2xx6FOsrUI8HZaw1JErU8mmOaLAe8q9RsOm\\n\" +\n            \"9Eq37e4vFp2YUEInYUqs87ByUcA4/8g3lEYeIUnRsRsWsA45S3wD7wy07t+KAn7j\\n\" +\n            \"yMmfxdma6hFfG9iN/egN6QXUAyIPXvUvlUuZ7/BhWBj/3sHMrF9quy9Q2DOI8F3t\\n\" +\n            \"1wdQrkq4BtStKhciY5AIXz9SqsctFHTv4Lwgtkapoel4izJnO0ZqYTXVe7THwri9\\n\" +\n            \"H/gua6uJDWH9jk2/CiZDWfsyFuNUuXvDSp05\\n\" +\n            \"-----END CERTIFICATE-----\";\n\n    @Test\n    public void encryptStringAsymmetric() throws Exception {\n        byte[] key1 = generateKey();\n        String base64encodedKey = encodeBytesToBase64String(key1);\n\n        String encryptedString = EncryptionUtils.encryptStringAsymmetric(base64encodedKey, cert);\n        String decryptedString = decryptStringAsymmetric(encryptedString, privateKey);\n\n        byte[] key2 = decodeStringToBase64Bytes(decryptedString);\n\n        assertTrue(Arrays.equals(key1, key2));\n    }\n\n    @Test\n    public void encryptStringSymmetricRandom() throws Exception {\n        int max = 500;\n        for (int i = 0; i < max; i++) {\n            Log_OC.d(\"EncryptionTestIT\", i + \" of \" + max);\n            byte[] key = generateKey();\n\n            String encryptedString;\n            if (new Random().nextBoolean()) {\n                encryptedString = EncryptionUtils.encryptStringSymmetric(privateKey, key);\n            } else {\n                encryptedString = EncryptionUtils.encryptStringSymmetricOld(privateKey, key);\n\n                if (encryptedString.indexOf(ivDelimiterOld) != encryptedString.lastIndexOf(ivDelimiterOld)) {\n                    Log_OC.d(\"EncryptionTestIT\", \"skip due to duplicated iv (old system) -> ignoring\");\n                    continue;\n                }\n            }\n            String decryptedString = decryptStringSymmetric(encryptedString, key);\n\n            assertEquals(privateKey, decryptedString);\n        }\n    }\n\n    @Test\n    public void encryptStringSymmetric() throws Exception {\n        int max = 5000;\n        byte[] key = generateKey();\n\n        for (int i = 0; i < max; i++) {\n            Log_OC.d(\"EncryptionTestIT\", i + \" of \" + max);\n\n            String encryptedString = EncryptionUtils.encryptStringSymmetric(privateKey, key);\n\n            int delimiterPosition = encryptedString.indexOf(ivDelimiter);\n            if (delimiterPosition == -1) {\n                throw new RuntimeException(\"IV not found!\");\n            }\n\n            String ivString = encryptedString.substring(delimiterPosition + ivDelimiter.length());\n            if (TextUtils.isEmpty(ivString)) {\n                delimiterPosition = encryptedString.lastIndexOf(ivDelimiter);\n                ivString = encryptedString.substring(delimiterPosition + ivDelimiter.length());\n\n                if (TextUtils.isEmpty(ivString)) {\n                    throw new RuntimeException(\"IV string is empty\");\n                }\n            }\n\n            String decryptedString = decryptStringSymmetric(encryptedString, key);\n\n            assertEquals(privateKey, decryptedString);\n        }\n    }\n\n    @Test\n    public void encryptPrivateKey() throws Exception {\n        int max = 10;\n        for (int i = 0; i < max; i++) {\n            Log_OC.d(\"EncryptionTestIT\", i + \" of \" + max);\n\n            String keyPhrase = \"moreovertelevisionfactorytendencyindependenceinternationalintellectualimpress\" +\n                \"interestvolunteer\";\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n            keyGen.initialize(4096, new SecureRandom());\n            KeyPair keyPair = keyGen.generateKeyPair();\n            PrivateKey privateKey = keyPair.getPrivate();\n            byte[] privateKeyBytes = privateKey.getEncoded();\n            String privateKeyString = encodeBytesToBase64String(privateKeyBytes);\n\n            String encryptedString;\n            if (new Random().nextBoolean()) {\n                encryptedString = EncryptionUtils.encryptPrivateKey(privateKeyString, keyPhrase);\n            } else {\n                encryptedString = EncryptionUtils.encryptPrivateKeyOld(privateKeyString, keyPhrase);\n            }\n            String decryptedString = decryptPrivateKey(encryptedString, keyPhrase);\n\n            assertEquals(privateKeyString, decryptedString);\n        }\n    }\n\n    @Test\n    public void generateCSR() throws Exception {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048, new SecureRandom());\n        KeyPair keyPair = keyGen.generateKeyPair();\n\n        assertFalse(CsrHelper.generateCsrPemEncodedString(keyPair, \"\").isEmpty());\n        assertFalse(encodeBytesToBase64String(keyPair.getPublic().getEncoded()).isEmpty());\n    }\n\n    /**\n     * DecryptedFolderMetadata -> EncryptedFolderMetadata -> JSON -> encrypt\n     * -> decrypt -> JSON -> EncryptedFolderMetadata -> DecryptedFolderMetadata\n     */\n    @Test\n    public void encryptionMetadata() throws Exception {\n        DecryptedFolderMetadata decryptedFolderMetadata1 = generateFolderMetadata();\n\n        // encrypt\n        EncryptedFolderMetadata encryptedFolderMetadata1 = encryptFolderMetadata(\n                decryptedFolderMetadata1, privateKey);\n\n        // serialize\n        String encryptedJson = serializeJSON(encryptedFolderMetadata1);\n\n        // de-serialize\n        EncryptedFolderMetadata encryptedFolderMetadata2 = deserializeJSON(encryptedJson,\n                                                                           new TypeToken<EncryptedFolderMetadata>() {\n                });\n\n        // decrypt\n        DecryptedFolderMetadata decryptedFolderMetadata2 = decryptFolderMetaData(\n                encryptedFolderMetadata2, privateKey);\n\n        // compare\n        assertTrue(compareJsonStrings(serializeJSON(decryptedFolderMetadata1),\n                                      serializeJSON(decryptedFolderMetadata2)));\n    }\n\n    @Test\n    public void testCryptFileWithoutMetadata() throws Exception {\n        byte[] key = decodeStringToBase64Bytes(\"WANM0gRv+DhaexIsI0T3Lg==\");\n        byte[] iv = decodeStringToBase64Bytes(\"gKm3n+mJzeY26q4OfuZEqg==\");\n        byte[] authTag = decodeStringToBase64Bytes(\"PboI9tqHHX3QeAA22PIu4w==\");\n\n        assertTrue(cryptFile(\"ia7OEEEyXMoRa1QWQk8r\", \"78f42172166f9dc8fd1a7156b1753353\", key, iv, authTag));\n    }\n\n    @Test\n    public void cryptFileWithMetadata() throws Exception {\n        DecryptedFolderMetadata metadata = generateFolderMetadata();\n\n        // n9WXAIXO2wRY4R8nXwmo\n        assertTrue(cryptFile(\"ia7OEEEyXMoRa1QWQk8r\",\n                             \"78f42172166f9dc8fd1a7156b1753353\",\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"ia7OEEEyXMoRa1QWQk8r\")\n                        .getEncrypted().getKey()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"ia7OEEEyXMoRa1QWQk8r\")\n                        .getInitializationVector()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"ia7OEEEyXMoRa1QWQk8r\")\n                        .getAuthenticationTag())));\n\n        // n9WXAIXO2wRY4R8nXwmo\n        assertTrue(cryptFile(\"n9WXAIXO2wRY4R8nXwmo\",\n                             \"825143ed1f21ebb0c3b3c3f005b2f5db\",\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"n9WXAIXO2wRY4R8nXwmo\")\n                        .getEncrypted().getKey()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"n9WXAIXO2wRY4R8nXwmo\")\n                        .getInitializationVector()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"n9WXAIXO2wRY4R8nXwmo\")\n                        .getAuthenticationTag())));\n    }\n\n    @Test\n    public void bigMetadata() throws Exception {\n        DecryptedFolderMetadata decryptedFolderMetadata1 = generateFolderMetadata();\n\n        // encrypt\n        EncryptedFolderMetadata encryptedFolderMetadata1 = encryptFolderMetadata(\n            decryptedFolderMetadata1, privateKey);\n\n        // serialize\n        String encryptedJson = serializeJSON(encryptedFolderMetadata1);\n\n        // de-serialize\n        EncryptedFolderMetadata encryptedFolderMetadata2 = deserializeJSON(encryptedJson,\n                                                                           new TypeToken<EncryptedFolderMetadata>() {\n                                                                           });\n\n        // decrypt\n        DecryptedFolderMetadata decryptedFolderMetadata2 = decryptFolderMetaData(\n            encryptedFolderMetadata2, privateKey);\n\n        // compare\n        assertTrue(compareJsonStrings(serializeJSON(decryptedFolderMetadata1),\n                                      serializeJSON(decryptedFolderMetadata2)));\n\n        // prefill with 500\n        for (int i = 0; i < 500; i++) {\n            addFile(decryptedFolderMetadata1, i);\n        }\n\n        int max = 505;\n        for (int i = 500; i < max; i++) {\n            Log_OC.d(this, \"Big metadata: \" + i + \" of \" + max);\n\n            addFile(decryptedFolderMetadata1, i);\n\n            // encrypt\n            encryptedFolderMetadata1 = encryptFolderMetadata(decryptedFolderMetadata1, privateKey);\n\n            // serialize\n            encryptedJson = serializeJSON(encryptedFolderMetadata1);\n\n            // de-serialize\n            encryptedFolderMetadata2 = deserializeJSON(encryptedJson,\n                                                       new TypeToken<EncryptedFolderMetadata>() {\n                                                       });\n\n            // decrypt\n            decryptedFolderMetadata2 = decryptFolderMetaData(encryptedFolderMetadata2, privateKey);\n\n            // compare\n            assertTrue(compareJsonStrings(serializeJSON(decryptedFolderMetadata1),\n                                          serializeJSON(decryptedFolderMetadata2)));\n\n            assertEquals(i + 3, decryptedFolderMetadata1.getFiles().size());\n            assertEquals(i + 3, decryptedFolderMetadata2.getFiles().size());\n        }\n    }\n\n    private void addFile(DecryptedFolderMetadata decryptedFolderMetadata, int counter) {\n        // Add new file\n        // Always generate new\n        byte[] key = generateKey();\n        byte[] iv = randomBytes(ivLength);\n        byte[] authTag = randomBytes((128 / 8));\n\n        DecryptedFolderMetadata.Data data = new DecryptedFolderMetadata.Data();\n        data.setKey(EncryptionUtils.encodeBytesToBase64String(key));\n        data.setFilename(counter + \".txt\");\n        data.setVersion(1);\n\n        DecryptedFolderMetadata.DecryptedFile file = new DecryptedFolderMetadata.DecryptedFile();\n        file.setInitializationVector(EncryptionUtils.encodeBytesToBase64String(iv));\n        file.setEncrypted(data);\n        file.setMetadataKey(0);\n        file.setAuthenticationTag(EncryptionUtils.encodeBytesToBase64String(authTag));\n\n        decryptedFolderMetadata.getFiles().put(RandomString.make(20), file);\n    }\n\n    /**\n     * generates new keys and tests if they are unique\n     */\n    @Test\n    public void testKey() {\n        Set<String> keys = new HashSet<>();\n\n        for (int i = 0; i < 50; i++) {\n            assertTrue(keys.add(encodeBytesToBase64String(generateKey())));\n        }\n    }\n\n    /**\n     * generates new ivs and tests if they are unique\n     */\n    @Test\n    public void testIV() {\n        Set<String> ivs = new HashSet<>();\n\n        for (int i = 0; i < 50; i++) {\n            assertTrue(ivs.add(encodeBytesToBase64String(\n                randomBytes(ivLength))));\n        }\n    }\n\n    /**\n     * generates new salt and tests if they are unique\n     */\n    @Test\n    public void testSalt() {\n        Set<String> ivs = new HashSet<>();\n\n        for (int i = 0; i < 50; i++) {\n            assertTrue(ivs.add(encodeBytesToBase64String(\n                randomBytes(saltLength))));\n        }\n    }\n\n    @Test\n    public void testSHA512() {\n        // sent to 3rd party app in cleartext\n        String token = \"4ae5978bf5354cd284b539015d442141\";\n        String salt = encodeBytesToBase64String(randomBytes(saltLength));\n\n        // stored in database\n        String hashedToken = generateSHA512(token, salt);\n\n        // check: use passed cleartext and salt to verify hashed token\n        assertTrue(verifySHA512(hashedToken, token));\n    }\n\n\n    // Helper\n    private boolean compareJsonStrings(String expected, String actual) {\n        JsonParser parser = new JsonParser();\n        JsonElement o1 = parser.parse(expected);\n        JsonElement o2 = parser.parse(actual);\n\n        if (o1.equals(o2)) {\n            return true;\n        } else {\n            System.out.println(\"expected: \" + o1);\n            System.out.println(\"actual: \" + o2);\n            return false;\n        }\n    }\n\n    private DecryptedFolderMetadata generateFolderMetadata() throws Exception {\n        String metadataKey0 = encodeBytesToBase64String(generateKey());\n        String metadataKey1 = encodeBytesToBase64String(generateKey());\n        String metadataKey2 = encodeBytesToBase64String(generateKey());\n        HashMap<Integer, String> metadataKeys = new HashMap<>();\n        metadataKeys.put(0, EncryptionUtils.encryptStringAsymmetric(metadataKey0, cert));\n        metadataKeys.put(1, EncryptionUtils.encryptStringAsymmetric(metadataKey1, cert));\n        metadataKeys.put(2, EncryptionUtils.encryptStringAsymmetric(metadataKey2, cert));\n        DecryptedFolderMetadata.Encrypted encrypted = new DecryptedFolderMetadata.Encrypted();\n        encrypted.setMetadataKeys(metadataKeys);\n\n        DecryptedFolderMetadata.Metadata metadata1 = new DecryptedFolderMetadata.Metadata();\n        metadata1.setMetadataKeys(metadataKeys);\n        metadata1.setVersion(1);\n\n        DecryptedFolderMetadata.Sharing sharing = new DecryptedFolderMetadata.Sharing();\n        sharing.setSignature(\"HMACOFRECIPIENTANDNEWESTMETADATAKEY\");\n        HashMap<String, String> recipient = new HashMap<>();\n        recipient.put(\"blah@schiessle.org\", \"PUBLIC KEY\");\n        recipient.put(\"bjoern@schiessle.org\", \"PUBLIC KEY\");\n        sharing.setRecipient(recipient);\n        metadata1.setSharing(sharing);\n\n        HashMap<String, DecryptedFolderMetadata.DecryptedFile> files = new HashMap<>();\n\n        DecryptedFolderMetadata.Data data1 = new DecryptedFolderMetadata.Data();\n        data1.setKey(\"WANM0gRv+DhaexIsI0T3Lg==\");\n        data1.setFilename(\"test.txt\");\n        data1.setVersion(1);\n\n        DecryptedFolderMetadata.DecryptedFile file1 = new DecryptedFolderMetadata.DecryptedFile();\n        file1.setInitializationVector(\"gKm3n+mJzeY26q4OfuZEqg==\");\n        file1.setEncrypted(data1);\n        file1.setMetadataKey(0);\n        file1.setAuthenticationTag(\"PboI9tqHHX3QeAA22PIu4w==\");\n\n        files.put(\"ia7OEEEyXMoRa1QWQk8r\", file1);\n\n        DecryptedFolderMetadata.Data data2 = new DecryptedFolderMetadata.Data();\n        data2.setKey(\"9dfzbIYDt28zTyZfbcll+g==\");\n        data2.setFilename(\"test2.txt\");\n        data2.setVersion(1);\n\n        DecryptedFolderMetadata.DecryptedFile file2 = new DecryptedFolderMetadata.DecryptedFile();\n        file2.setInitializationVector(\"hnJLF8uhDvDoFK4ajuvwrg==\");\n        file2.setEncrypted(data2);\n        file2.setMetadataKey(0);\n        file2.setAuthenticationTag(\"qOQZdu5soFO77Y7y4rAOVA==\");\n\n        files.put(\"n9WXAIXO2wRY4R8nXwmo\", file2);\n\n        return new DecryptedFolderMetadata(metadata1, files);\n    }\n\n    private boolean cryptFile(String fileName, String md5, byte[] key, byte[] iv, byte[] expectedAuthTag)\n            throws Exception {\n        File file = getFile(fileName);\n        assertEquals(md5, getMD5Sum(file));\n\n        EncryptedFile encryptedFile = encryptFile(file, key, iv);\n\n        File encryptedTempFile = File.createTempFile(\"file\", \"tmp\");\n        FileOutputStream fileOutputStream = new FileOutputStream(encryptedTempFile);\n        fileOutputStream.write(encryptedFile.encryptedBytes);\n        fileOutputStream.close();\n\n        byte[] authenticationTag = decodeStringToBase64Bytes(encryptedFile.authenticationTag);\n\n        // verify authentication tag\n        assertTrue(Arrays.equals(expectedAuthTag, authenticationTag));\n\n        byte[] decryptedBytes = decryptFile(encryptedTempFile, key, iv, authenticationTag);\n\n        File decryptedFile = File.createTempFile(\"file\", \"dec\");\n        FileOutputStream fileOutputStream1 = new FileOutputStream(decryptedFile);\n        fileOutputStream1.write(decryptedBytes);\n        fileOutputStream1.close();\n\n        return md5.compareTo(getMD5Sum(decryptedFile)) == 0;\n    }\n\n    private File getFile(String filename) throws IOException {\n        InputStream inputStream = getInstrumentation().getContext().getAssets().open(filename);\n        File temp = File.createTempFile(\"file\", \"file\");\n        FileUtils.copyInputStreamToFile(inputStream, temp);\n\n        return temp;\n    }\n}\n", "/*\n * Nextcloud Android client application\n *\n * @author Tobias Kaminsky\n * Copyright (C) 2017 Tobias Kaminsky\n * Copyright (C) 2017 Nextcloud GmbH.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage com.owncloud.android.ui.dialog;\n\nimport android.accounts.AccountManager;\nimport android.app.Dialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.graphics.PorterDuff;\nimport android.graphics.drawable.Drawable;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\n\nimport com.nextcloud.client.account.User;\nimport com.owncloud.android.R;\nimport com.owncloud.android.datamodel.ArbitraryDataProvider;\nimport com.owncloud.android.lib.common.accounts.AccountUtils;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.lib.resources.users.DeletePublicKeyOperation;\nimport com.owncloud.android.lib.resources.users.GetPrivateKeyOperation;\nimport com.owncloud.android.lib.resources.users.GetPublicKeyOperation;\nimport com.owncloud.android.lib.resources.users.SendCSROperation;\nimport com.owncloud.android.lib.resources.users.StorePrivateKeyOperation;\nimport com.owncloud.android.utils.CsrHelper;\nimport com.owncloud.android.utils.EncryptionUtils;\nimport com.owncloud.android.utils.theme.ThemeButtonUtils;\nimport com.owncloud.android.utils.theme.ThemeColorUtils;\n\nimport java.io.IOException;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.util.List;\nimport java.util.Locale;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.VisibleForTesting;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.core.graphics.drawable.DrawableCompat;\nimport androidx.fragment.app.DialogFragment;\n\n/*\n *  Dialog to setup encryption\n */\npublic class SetupEncryptionDialogFragment extends DialogFragment {\n\n    public static final String SUCCESS = \"SUCCESS\";\n    public static final int SETUP_ENCRYPTION_RESULT_CODE = 101;\n    public static final int SETUP_ENCRYPTION_REQUEST_CODE = 100;\n    public static final String SETUP_ENCRYPTION_DIALOG_TAG = \"SETUP_ENCRYPTION_DIALOG_TAG\";\n    public static final String ARG_POSITION = \"ARG_POSITION\";\n\n    private static final String ARG_USER = \"ARG_USER\";\n    private static final String TAG = SetupEncryptionDialogFragment.class.getSimpleName();\n\n    private static final String KEY_CREATED = \"KEY_CREATED\";\n    private static final String KEY_EXISTING_USED = \"KEY_EXISTING_USED\";\n    private static final String KEY_FAILED = \"KEY_FAILED\";\n    private static final String KEY_GENERATE = \"KEY_GENERATE\";\n\n    private User user;\n    private TextView textView;\n    private TextView passphraseTextView;\n    private ArbitraryDataProvider arbitraryDataProvider;\n    private Button positiveButton;\n    private Button neutralButton;\n    private DownloadKeysAsyncTask task;\n    private TextView passwordField;\n    private String keyResult;\n    private List<String> keyWords;\n\n    /**\n     * Public factory method to create new SetupEncryptionDialogFragment instance\n     *\n     * @return Dialog ready to show.\n     */\n    public static SetupEncryptionDialogFragment newInstance(User user, int position) {\n        SetupEncryptionDialogFragment fragment = new SetupEncryptionDialogFragment();\n        Bundle args = new Bundle();\n        args.putParcelable(ARG_USER, user);\n        args.putInt(ARG_POSITION, position);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n\n        AlertDialog alertDialog = (AlertDialog) getDialog();\n\n        positiveButton = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);\n        neutralButton = alertDialog.getButton(AlertDialog.BUTTON_NEUTRAL);\n        ThemeButtonUtils.themeBorderlessButton(positiveButton,\n                                               neutralButton);\n\n        task = new DownloadKeysAsyncTask();\n        task.execute();\n    }\n\n    @NonNull\n    @Override\n    public Dialog onCreateDialog(Bundle savedInstanceState) {\n        int primaryColor = ThemeColorUtils.primaryColor(getContext());\n        user = getArguments().getParcelable(ARG_USER);\n\n        arbitraryDataProvider = new ArbitraryDataProvider(getContext().getContentResolver());\n\n        // Inflate the layout for the dialog\n        LayoutInflater inflater = getActivity().getLayoutInflater();\n\n        // Setup layout\n        View v = inflater.inflate(R.layout.setup_encryption_dialog, null);\n        textView = v.findViewById(R.id.encryption_status);\n        passphraseTextView = v.findViewById(R.id.encryption_passphrase);\n        passwordField = v.findViewById(R.id.encryption_passwordInput);\n        passwordField.getBackground().setColorFilter(primaryColor, PorterDuff.Mode.SRC_ATOP);\n\n        Drawable wrappedDrawable = DrawableCompat.wrap(passwordField.getBackground());\n        DrawableCompat.setTint(wrappedDrawable, primaryColor);\n        passwordField.setBackgroundDrawable(wrappedDrawable);\n\n        return createDialog(v);\n    }\n\n    @NonNull\n    private Dialog createDialog(View v) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setView(v).setPositiveButton(R.string.common_ok, null)\n                .setNeutralButton(R.string.common_cancel, null)\n                .setTitle(R.string.end_to_end_encryption_title);\n\n        Dialog dialog = builder.create();\n        dialog.setCanceledOnTouchOutside(false);\n\n        dialog.setOnShowListener(new DialogInterface.OnShowListener() {\n\n            @Override\n            public void onShow(final DialogInterface dialog) {\n\n                Button button = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_POSITIVE);\n                button.setOnClickListener(new View.OnClickListener() {\n\n                    @Override\n                    public void onClick(View view) {\n                        switch (keyResult) {\n                            case KEY_CREATED:\n                                Log_OC.d(TAG, \"New keys generated and stored.\");\n\n                                dialog.dismiss();\n\n                                Intent intentCreated = new Intent();\n                                intentCreated.putExtra(SUCCESS, true);\n                                intentCreated.putExtra(ARG_POSITION, getArguments().getInt(ARG_POSITION));\n                                getTargetFragment().onActivityResult(getTargetRequestCode(),\n                                        SETUP_ENCRYPTION_RESULT_CODE, intentCreated);\n                                break;\n\n                            case KEY_EXISTING_USED:\n                                Log_OC.d(TAG, \"Decrypt private key\");\n\n                                textView.setText(R.string.end_to_end_encryption_decrypting);\n\n                                try {\n                                    String privateKey = task.get();\n                                    String mnemonicUnchanged = passwordField.getText().toString();\n                                    String mnemonic = passwordField.getText().toString().replaceAll(\"\\\\s\", \"\")\n                                            .toLowerCase(Locale.ROOT);\n                                    String decryptedPrivateKey = EncryptionUtils.decryptPrivateKey(privateKey,\n                                            mnemonic);\n\n                                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(),\n                                            EncryptionUtils.PRIVATE_KEY, decryptedPrivateKey);\n\n                                    dialog.dismiss();\n                                    Log_OC.d(TAG, \"Private key successfully decrypted and stored\");\n\n                                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.MNEMONIC,\n                                            mnemonicUnchanged);\n\n                                    Intent intentExisting = new Intent();\n                                    intentExisting.putExtra(SUCCESS, true);\n                                    intentExisting.putExtra(ARG_POSITION, getArguments().getInt(ARG_POSITION));\n                                    getTargetFragment().onActivityResult(getTargetRequestCode(),\n                                            SETUP_ENCRYPTION_RESULT_CODE, intentExisting);\n\n                                } catch (Exception e) {\n                                    textView.setText(R.string.end_to_end_encryption_wrong_password);\n                                    Log_OC.d(TAG, \"Error while decrypting private key: \" + e.getMessage());\n                                }\n                                break;\n\n                            case KEY_GENERATE:\n                                passphraseTextView.setVisibility(View.GONE);\n                                positiveButton.setVisibility(View.GONE);\n                                neutralButton.setVisibility(View.GONE);\n                                getDialog().setTitle(R.string.end_to_end_encryption_storing_keys);\n\n                                GenerateNewKeysAsyncTask newKeysTask = new GenerateNewKeysAsyncTask();\n                                newKeysTask.execute();\n                                break;\n\n                            default:\n                                dialog.dismiss();\n                                break;\n                        }\n                    }\n                });\n            }\n        });\n        return dialog;\n    }\n\n    public class DownloadKeysAsyncTask extends AsyncTask<Void, Void, String> {\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n\n            textView.setText(R.string.end_to_end_encryption_retrieving_keys);\n            positiveButton.setVisibility(View.INVISIBLE);\n            neutralButton.setVisibility(View.INVISIBLE);\n        }\n\n        @Override\n        protected String doInBackground(Void... voids) {\n            // fetch private/public key\n            // if available\n            //  - store public key\n            //  - decrypt private key, store unencrypted private key in database\n\n            GetPublicKeyOperation publicKeyOperation = new GetPublicKeyOperation();\n            RemoteOperationResult publicKeyResult = publicKeyOperation.execute(user.toPlatformAccount(), getContext());\n\n            if (publicKeyResult.isSuccess()) {\n                Log_OC.d(TAG, \"public key successful downloaded for \" + user.getAccountName());\n\n                String publicKeyFromServer = (String) publicKeyResult.getData().get(0);\n                arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.PUBLIC_KEY,\n                                                            publicKeyFromServer);\n            } else {\n                return null;\n            }\n\n            RemoteOperationResult<com.owncloud.android.lib.ocs.responses.PrivateKey> privateKeyResult =\n                new GetPrivateKeyOperation().execute(user.toPlatformAccount(), getContext());\n\n            if (privateKeyResult.isSuccess()) {\n                Log_OC.d(TAG, \"private key successful downloaded for \" + user.getAccountName());\n\n                keyResult = KEY_EXISTING_USED;\n                return privateKeyResult.getResultData().getKey();\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String privateKey) {\n            super.onPostExecute(privateKey);\n\n            if (privateKey == null) {\n                // first show info\n                try {\n                    keyWords = EncryptionUtils.getRandomWords(12, requireContext());\n                    showMnemonicInfo();\n                } catch (IOException e) {\n                    textView.setText(R.string.common_error);\n                }\n            } else if (!privateKey.isEmpty()) {\n                textView.setText(R.string.end_to_end_encryption_enter_password);\n                passwordField.setVisibility(View.VISIBLE);\n                positiveButton.setVisibility(View.VISIBLE);\n            } else {\n                Log_OC.e(TAG, \"Got empty private key string\");\n            }\n        }\n    }\n\n    public class GenerateNewKeysAsyncTask extends AsyncTask<Void, Void, String> {\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n\n            textView.setText(R.string.end_to_end_encryption_generating_keys);\n        }\n\n        @Override\n        protected String doInBackground(Void... voids) {\n            //  - create CSR, push to server, store returned public key in database\n            //  - encrypt private key, push key to server, store unencrypted private key in database\n\n            try {\n                String publicKey;\n\n                // Create public/private key pair\n                KeyPair keyPair = EncryptionUtils.generateKeyPair();\n\n                // create CSR\n                AccountManager accountManager = AccountManager.get(getContext());\n                String userId = accountManager.getUserData(user.toPlatformAccount(), AccountUtils.Constants.KEY_USER_ID);\n                String urlEncoded = CsrHelper.generateCsrPemEncodedString(keyPair, userId);\n\n                SendCSROperation operation = new SendCSROperation(urlEncoded);\n                RemoteOperationResult result = operation.execute(user.toPlatformAccount(), getContext());\n\n                if (result.isSuccess()) {\n                    Log_OC.d(TAG, \"public key success\");\n                    publicKey = (String) result.getData().get(0);\n                } else {\n                    keyResult = KEY_FAILED;\n                    return \"\";\n                }\n\n                PrivateKey privateKey = keyPair.getPrivate();\n                String privateKeyString = EncryptionUtils.encodeBytesToBase64String(privateKey.getEncoded());\n                String privatePemKeyString = EncryptionUtils.privateKeyToPEM(privateKey);\n                String encryptedPrivateKey = EncryptionUtils.encryptPrivateKey(privatePemKeyString,\n                        generateMnemonicString(false));\n\n                // upload encryptedPrivateKey\n                StorePrivateKeyOperation storePrivateKeyOperation = new StorePrivateKeyOperation(encryptedPrivateKey);\n                RemoteOperationResult storePrivateKeyResult = storePrivateKeyOperation.execute(user.toPlatformAccount(),\n                                                                                               getContext());\n\n                if (storePrivateKeyResult.isSuccess()) {\n                    Log_OC.d(TAG, \"private key success\");\n\n                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.PRIVATE_KEY,\n                            privateKeyString);\n                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.PUBLIC_KEY, publicKey);\n                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.MNEMONIC,\n                            generateMnemonicString(true));\n\n                    keyResult = KEY_CREATED;\n                    return (String) storePrivateKeyResult.getData().get(0);\n                } else {\n                    DeletePublicKeyOperation deletePublicKeyOperation = new DeletePublicKeyOperation();\n                    deletePublicKeyOperation.execute(user.toPlatformAccount(), getContext());\n                }\n            } catch (Exception e) {\n                Log_OC.e(TAG, e.getMessage());\n            }\n\n            keyResult = KEY_FAILED;\n            return \"\";\n        }\n\n        @Override\n        protected void onPostExecute(String s) {\n            super.onPostExecute(s);\n\n            if (s.isEmpty()) {\n                errorSavingKeys();\n            } else {\n                requireDialog().dismiss();\n\n                Intent intentExisting = new Intent();\n                intentExisting.putExtra(SUCCESS, true);\n                intentExisting.putExtra(ARG_POSITION, requireArguments().getInt(ARG_POSITION));\n                getTargetFragment().onActivityResult(getTargetRequestCode(),\n                                                     SETUP_ENCRYPTION_RESULT_CODE, intentExisting);\n            }\n        }\n    }\n\n    private String generateMnemonicString(boolean withWhitespace) {\n        StringBuilder stringBuilder = new StringBuilder();\n\n        for (String string : keyWords) {\n            stringBuilder.append(string);\n            if (withWhitespace) {\n                stringBuilder.append(' ');\n            }\n        }\n\n        return stringBuilder.toString();\n    }\n\n    @VisibleForTesting\n    public void showMnemonicInfo() {\n        requireDialog().setTitle(R.string.end_to_end_encryption_passphrase_title);\n\n        textView.setText(R.string.end_to_end_encryption_keywords_description);\n\n        passphraseTextView.setText(generateMnemonicString(true));\n\n        passphraseTextView.setVisibility(View.VISIBLE);\n        positiveButton.setText(R.string.end_to_end_encryption_confirm_button);\n        positiveButton.setVisibility(View.VISIBLE);\n\n        neutralButton.setVisibility(View.VISIBLE);\n        ThemeButtonUtils.themeBorderlessButton(positiveButton, neutralButton);\n\n        keyResult = KEY_GENERATE;\n    }\n\n    @VisibleForTesting\n    public void errorSavingKeys() {\n        keyResult = KEY_FAILED;\n\n        requireDialog().setTitle(R.string.common_error);\n        textView.setText(R.string.end_to_end_encryption_unsuccessful);\n        positiveButton.setText(R.string.end_to_end_encryption_dialog_close);\n        positiveButton.setVisibility(View.VISIBLE);\n        positiveButton.setTextColor(ThemeColorUtils.primaryAccentColor(getContext()));\n    }\n\n    @VisibleForTesting\n    public void setMnemonic(List<String> keyWords) {\n        this.keyWords = keyWords;\n    }\n}\n", "/*\n * Nextcloud Android client application\n *\n * @author Tobias Kaminsky\n * Copyright (C) 2017 Tobias Kaminsky\n * Copyright (C) 2017 Nextcloud GmbH.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.owncloud.android.utils;\n\nimport android.accounts.Account;\nimport android.content.Context;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Pair;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport com.owncloud.android.datamodel.ArbitraryDataProvider;\nimport com.owncloud.android.datamodel.DecryptedFolderMetadata;\nimport com.owncloud.android.datamodel.EncryptedFolderMetadata;\nimport com.owncloud.android.datamodel.OCFile;\nimport com.owncloud.android.lib.common.OwnCloudClient;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.lib.resources.e2ee.GetMetadataRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.LockFileRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.StoreMetadataRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.UnlockFileRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.UpdateMetadataRemoteOperation;\nimport com.owncloud.android.operations.UploadException;\n\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.commons.httpclient.HttpStatus;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.StandardCharsets;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.GCMParameterSpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport androidx.annotation.Nullable;\nimport androidx.annotation.VisibleForTesting;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\n/**\n * Utils for encryption\n */\npublic final class EncryptionUtils {\n    private static String TAG = EncryptionUtils.class.getSimpleName();\n\n    public static final String PUBLIC_KEY = \"PUBLIC_KEY\";\n    public static final String PRIVATE_KEY = \"PRIVATE_KEY\";\n    public static final String MNEMONIC = \"MNEMONIC\";\n    public static final int ivLength = 16;\n    public static final int saltLength = 40;\n    public static final String ivDelimiter = \"|\"; // not base64 encoded\n    public static final String ivDelimiterOld = \"fA==\"; // \"|\" base64 encoded\n\n    private static final String HASH_DELIMITER = \"$\";\n    private static final int iterationCount = 1024;\n    private static final int keyStrength = 256;\n    private static final String AES_CIPHER = \"AES/GCM/NoPadding\";\n    private static final String AES = \"AES\";\n    private static final String RSA_CIPHER = \"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\";\n    private static final String RSA = \"RSA\";\n\n    private EncryptionUtils() {\n        // utility class -> private constructor\n    }\n\n    /*\n    JSON\n     */\n\n    public static <T> T deserializeJSON(String json, TypeToken<T> type) {\n        return new Gson().fromJson(json, type.getType());\n    }\n\n    public static String serializeJSON(Object data) {\n        return new Gson().toJson(data);\n    }\n\n    /*\n    METADATA\n     */\n\n    /**\n     * Encrypt folder metaData\n     *\n     * @param decryptedFolderMetadata folder metaData to encrypt\n     * @return EncryptedFolderMetadata encrypted folder metadata\n     */\n    public static EncryptedFolderMetadata encryptFolderMetadata(DecryptedFolderMetadata decryptedFolderMetadata,\n                                                                String privateKey)\n            throws NoSuchAlgorithmException, InvalidKeyException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, BadPaddingException,\n            IllegalBlockSizeException, InvalidKeySpecException {\n\n        HashMap<String, EncryptedFolderMetadata.EncryptedFile> files = new HashMap<>();\n        EncryptedFolderMetadata encryptedFolderMetadata = new EncryptedFolderMetadata(decryptedFolderMetadata\n                .getMetadata(), files);\n\n        // Encrypt each file in \"files\"\n        for (Map.Entry<String, DecryptedFolderMetadata.DecryptedFile> entry : decryptedFolderMetadata\n                .getFiles().entrySet()) {\n            String key = entry.getKey();\n            DecryptedFolderMetadata.DecryptedFile decryptedFile = entry.getValue();\n\n            EncryptedFolderMetadata.EncryptedFile encryptedFile = new EncryptedFolderMetadata.EncryptedFile();\n            encryptedFile.setInitializationVector(decryptedFile.getInitializationVector());\n            encryptedFile.setMetadataKey(decryptedFile.getMetadataKey());\n            encryptedFile.setAuthenticationTag(decryptedFile.getAuthenticationTag());\n\n            byte[] decryptedMetadataKey = EncryptionUtils.decodeStringToBase64Bytes(EncryptionUtils.decryptStringAsymmetric(\n                    decryptedFolderMetadata.getMetadata().getMetadataKeys().get(encryptedFile.getMetadataKey()),\n                    privateKey));\n\n            // encrypt\n            String dataJson = EncryptionUtils.serializeJSON(decryptedFile.getEncrypted());\n            encryptedFile.setEncrypted(EncryptionUtils.encryptStringSymmetric(dataJson, decryptedMetadataKey));\n\n            files.put(key, encryptedFile);\n        }\n\n        return encryptedFolderMetadata;\n    }\n\n    /*\n     * decrypt folder metaData with private key\n     */\n    public static DecryptedFolderMetadata decryptFolderMetaData(EncryptedFolderMetadata encryptedFolderMetadata,\n                                                                String privateKey)\n            throws NoSuchAlgorithmException, InvalidKeyException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, BadPaddingException,\n            IllegalBlockSizeException, InvalidKeySpecException {\n\n        HashMap<String, DecryptedFolderMetadata.DecryptedFile> files = new HashMap<>();\n        DecryptedFolderMetadata decryptedFolderMetadata = new DecryptedFolderMetadata(\n                encryptedFolderMetadata.getMetadata(), files);\n\n        for (Map.Entry<String, EncryptedFolderMetadata.EncryptedFile> entry : encryptedFolderMetadata\n                .getFiles().entrySet()) {\n            String key = entry.getKey();\n            EncryptedFolderMetadata.EncryptedFile encryptedFile = entry.getValue();\n\n            DecryptedFolderMetadata.DecryptedFile decryptedFile = new DecryptedFolderMetadata.DecryptedFile();\n            decryptedFile.setInitializationVector(encryptedFile.getInitializationVector());\n            decryptedFile.setMetadataKey(encryptedFile.getMetadataKey());\n            decryptedFile.setAuthenticationTag(encryptedFile.getAuthenticationTag());\n\n            byte[] decryptedMetadataKey = EncryptionUtils.decodeStringToBase64Bytes(\n                    EncryptionUtils.decryptStringAsymmetric(decryptedFolderMetadata.getMetadata()\n                            .getMetadataKeys().get(encryptedFile.getMetadataKey()), privateKey));\n\n            // decrypt\n            String dataJson = EncryptionUtils.decryptStringSymmetric(encryptedFile.getEncrypted(), decryptedMetadataKey);\n            decryptedFile.setEncrypted(EncryptionUtils.deserializeJSON(dataJson,\n                    new TypeToken<DecryptedFolderMetadata.Data>() {\n                    }));\n\n            files.put(key, decryptedFile);\n        }\n\n        return decryptedFolderMetadata;\n    }\n\n    /**\n     * Download metadata for folder and decrypt it\n     *\n     * @return decrypted metadata or null\n     */\n    public static @Nullable\n    DecryptedFolderMetadata downloadFolderMetadata(OCFile folder, OwnCloudClient client,\n                                                   Context context, Account account) {\n        RemoteOperationResult getMetadataOperationResult = new GetMetadataRemoteOperation(folder.getLocalId())\n            .execute(client);\n\n        if (!getMetadataOperationResult.isSuccess()) {\n            return null;\n        }\n\n        // decrypt metadata\n        ArbitraryDataProvider arbitraryDataProvider = new ArbitraryDataProvider(context.getContentResolver());\n        String serializedEncryptedMetadata = (String) getMetadataOperationResult.getData().get(0);\n        String privateKey = arbitraryDataProvider.getValue(account.name, EncryptionUtils.PRIVATE_KEY);\n\n        EncryptedFolderMetadata encryptedFolderMetadata = EncryptionUtils.deserializeJSON(\n                serializedEncryptedMetadata, new TypeToken<EncryptedFolderMetadata>() {\n                });\n\n        try {\n            return EncryptionUtils.decryptFolderMetaData(encryptedFolderMetadata, privateKey);\n        } catch (Exception e) {\n            Log_OC.e(TAG, e.getMessage());\n            return null;\n        }\n    }\n\n    /*\n    BASE 64\n     */\n\n    public static byte[] encodeStringToBase64Bytes(String string) {\n        try {\n            return Base64.encode(string.getBytes(), Base64.NO_WRAP);\n        } catch (Exception e) {\n            return new byte[0];\n        }\n    }\n\n    public static String decodeBase64BytesToString(byte[] bytes) {\n        try {\n            return new String(Base64.decode(bytes, Base64.NO_WRAP));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public static String encodeBytesToBase64String(byte[] bytes) {\n        return Base64.encodeToString(bytes, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeStringToBase64Bytes(String string) {\n        return Base64.decode(string, Base64.NO_WRAP);\n    }\n\n    /*\n    ENCRYPTION\n     */\n\n    /**\n     * @param ocFile             file do crypt\n     * @param encryptionKeyBytes key, either from metadata or {@link EncryptionUtils#generateKey()}\n     * @param iv                 initialization vector, either from metadata or {@link EncryptionUtils#randomBytes(int)}\n     * @return encryptedFile with encryptedBytes and authenticationTag\n     */\n    public static EncryptedFile encryptFile(OCFile ocFile, byte[] encryptionKeyBytes, byte[] iv)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException, IOException {\n        File file = new File(ocFile.getStoragePath());\n\n        return encryptFile(file, encryptionKeyBytes, iv);\n    }\n\n    /**\n     * @param file               file do crypt\n     * @param encryptionKeyBytes key, either from metadata or {@link EncryptionUtils#generateKey()}\n     * @param iv                 initialization vector, either from metadata or {@link EncryptionUtils#randomBytes(int)}\n     * @return encryptedFile with encryptedBytes and authenticationTag\n     */\n    public static EncryptedFile encryptFile(File file, byte[] encryptionKeyBytes, byte[] iv)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException, IOException {\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n        byte[] fileBytes = new byte[(int) randomAccessFile.length()];\n        randomAccessFile.readFully(fileBytes);\n\n        byte[] cryptedBytes = cipher.doFinal(fileBytes);\n        String authenticationTag = encodeBytesToBase64String(Arrays.copyOfRange(cryptedBytes,\n                cryptedBytes.length - (128 / 8), cryptedBytes.length));\n\n        return new EncryptedFile(cryptedBytes, authenticationTag);\n    }\n\n    /**\n     * @param file               encrypted file\n     * @param encryptionKeyBytes key from metadata\n     * @param iv                 initialization vector from metadata\n     * @param authenticationTag  authenticationTag from metadata\n     * @return decrypted byte[]\n     */\n    public static byte[] decryptFile(File file, byte[] encryptionKeyBytes, byte[] iv, byte[] authenticationTag)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException, IOException {\n\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.DECRYPT_MODE, key, spec);\n\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n        byte[] fileBytes = new byte[(int) randomAccessFile.length()];\n        randomAccessFile.readFully(fileBytes);\n\n        // check authentication tag\n        byte[] extractedAuthenticationTag = Arrays.copyOfRange(fileBytes,\n                fileBytes.length - (128 / 8), fileBytes.length);\n\n        if (!Arrays.equals(extractedAuthenticationTag, authenticationTag)) {\n            throw new SecurityException(\"Tag not correct\");\n        }\n\n        return cipher.doFinal(fileBytes);\n    }\n\n    public static class EncryptedFile {\n        public byte[] encryptedBytes;\n        public String authenticationTag;\n\n        public EncryptedFile(byte[] encryptedBytes, String authenticationTag) {\n            this.encryptedBytes = encryptedBytes;\n            this.authenticationTag = authenticationTag;\n        }\n    }\n\n    /**\n     * Encrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding\n     * Asymmetric encryption, with private and public key\n     *\n     * @param string String to encrypt\n     * @param cert   contains public key in it\n     * @return encrypted string\n     */\n    public static String encryptStringAsymmetric(String string, String cert)\n            throws NoSuchAlgorithmException,\n            NoSuchPaddingException, InvalidKeyException,\n        BadPaddingException, IllegalBlockSizeException,\n        CertificateException {\n\n        Cipher cipher = Cipher.getInstance(RSA_CIPHER);\n\n        String trimmedCert = cert.replace(\"-----BEGIN CERTIFICATE-----\\n\", \"\")\n                .replace(\"-----END CERTIFICATE-----\\n\", \"\");\n        byte[] encodedCert = trimmedCert.getBytes(StandardCharsets.UTF_8);\n        byte[] decodedCert = org.apache.commons.codec.binary.Base64.decodeBase64(encodedCert);\n\n        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n        InputStream in = new ByteArrayInputStream(decodedCert);\n        X509Certificate certificate = (X509Certificate) certFactory.generateCertificate(in);\n        PublicKey realPublicKey = certificate.getPublicKey();\n\n        cipher.init(Cipher.ENCRYPT_MODE, realPublicKey);\n\n        byte[] bytes = encodeStringToBase64Bytes(string);\n        byte[] cryptedBytes = cipher.doFinal(bytes);\n\n        return encodeBytesToBase64String(cryptedBytes);\n    }\n\n\n    /**\n     * Decrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding\n     * Asymmetric encryption, with private and public key\n     *\n     * @param string           string to decrypt\n     * @param privateKeyString private key\n     * @return decrypted string\n     */\n    public static String decryptStringAsymmetric(String string, String privateKeyString)\n            throws NoSuchAlgorithmException,\n            NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException,\n            InvalidKeySpecException {\n\n        Cipher cipher = Cipher.getInstance(RSA_CIPHER);\n\n        byte[] privateKeyBytes = decodeStringToBase64Bytes(privateKeyString);\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);\n        KeyFactory kf = KeyFactory.getInstance(RSA);\n        PrivateKey privateKey = kf.generatePrivate(keySpec);\n\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n        byte[] bytes = decodeStringToBase64Bytes(string);\n        byte[] encodedBytes = cipher.doFinal(bytes);\n\n        return decodeBase64BytesToString(encodedBytes);\n    }\n\n    /**\n     * Encrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding Asymmetric encryption, with private\n     * and public key\n     *\n     * @param string             String to encrypt\n     * @param encryptionKeyBytes key, either from metadata or {@link EncryptionUtils#generateKey()}\n     * @return encrypted string\n     */\n    public static String encryptStringSymmetric(String string, byte[] encryptionKeyBytes)\n        throws NoSuchPaddingException,\n        InvalidKeyException,\n        NoSuchAlgorithmException,\n        IllegalBlockSizeException,\n        BadPaddingException,\n        InvalidAlgorithmParameterException {\n        return encryptStringSymmetric(string, encryptionKeyBytes, ivDelimiter);\n    }\n\n    @VisibleForTesting\n    public static String encryptStringSymmetricOld(String string, byte[] encryptionKeyBytes)\n        throws NoSuchPaddingException,\n        InvalidKeyException,\n        NoSuchAlgorithmException,\n        IllegalBlockSizeException,\n        BadPaddingException,\n        InvalidAlgorithmParameterException {\n        return encryptStringSymmetric(string, encryptionKeyBytes, ivDelimiterOld);\n    }\n\n    private static String encryptStringSymmetric(String string,\n                                                 byte[] encryptionKeyBytes,\n                                                 String delimiter)\n        throws NoSuchAlgorithmException,\n        InvalidAlgorithmParameterException,\n        NoSuchPaddingException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException {\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n        byte[] iv = randomBytes(ivLength);\n\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n\n        byte[] bytes = encodeStringToBase64Bytes(string);\n        byte[] cryptedBytes = cipher.doFinal(bytes);\n\n        String encodedCryptedBytes = encodeBytesToBase64String(cryptedBytes);\n        String encodedIV = encodeBytesToBase64String(iv);\n\n        return encodedCryptedBytes + delimiter + encodedIV;\n    }\n\n\n    /**\n     * Decrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding\n     * Asymmetric encryption, with private and public key\n     *\n     * @param string             string to decrypt\n     * @param encryptionKeyBytes key from metadata\n     * @return decrypted string\n     */\n    public static String decryptStringSymmetric(String string, byte[] encryptionKeyBytes)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException {\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n\n        String ivString;\n        int delimiterPosition = string.lastIndexOf(ivDelimiter);\n\n        if (delimiterPosition == -1) {\n            // backward compatibility\n            delimiterPosition = string.lastIndexOf(ivDelimiterOld);\n            ivString = string.substring(delimiterPosition + ivDelimiterOld.length());\n        } else {\n            ivString = string.substring(delimiterPosition + ivDelimiter.length());\n        }\n\n        String cipherString = string.substring(0, delimiterPosition);\n\n        byte[] iv = new IvParameterSpec(decodeStringToBase64Bytes(ivString)).getIV();\n\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.DECRYPT_MODE, key, spec);\n\n        byte[] bytes = decodeStringToBase64Bytes(cipherString);\n        byte[] encodedBytes = cipher.doFinal(bytes);\n\n        return decodeBase64BytesToString(encodedBytes);\n    }\n\n    /**\n     * Encrypt private key with symmetric AES encryption, GCM mode mode and no padding\n     *\n     * @param privateKey byte64 encoded string representation of private key\n     * @param keyPhrase  key used for encryption, e.g. 12 random words {@link EncryptionUtils#getRandomWords(int,\n     *                   Context)}\n     * @return encrypted string, bytes first encoded base64, IV separated with \"|\", then to string\n     */\n    public static String encryptPrivateKey(String privateKey, String keyPhrase)\n        throws NoSuchPaddingException,\n        NoSuchAlgorithmException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException,\n        InvalidKeySpecException {\n        return encryptPrivateKey(privateKey, keyPhrase, ivDelimiter);\n    }\n\n    @VisibleForTesting\n    public static String encryptPrivateKeyOld(String privateKey, String keyPhrase)\n        throws NoSuchPaddingException,\n        NoSuchAlgorithmException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException,\n        InvalidKeySpecException {\n        return encryptPrivateKey(privateKey, keyPhrase, ivDelimiterOld);\n    }\n\n    private static String encryptPrivateKey(String privateKey, String keyPhrase, String delimiter)\n        throws NoSuchPaddingException,\n        NoSuchAlgorithmException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException,\n        InvalidKeySpecException {\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        byte[] salt = randomBytes(saltLength);\n        KeySpec spec = new PBEKeySpec(keyPhrase.toCharArray(), salt, iterationCount, keyStrength);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKeySpec key = new SecretKeySpec(tmp.getEncoded(), AES);\n\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] bytes = encodeStringToBase64Bytes(privateKey);\n        byte[] encrypted = cipher.doFinal(bytes);\n\n        byte[] iv = cipher.getIV();\n        String encodedIV = encodeBytesToBase64String(iv);\n        String encodedSalt = encodeBytesToBase64String(salt);\n        String encodedEncryptedBytes = encodeBytesToBase64String(encrypted);\n\n        return encodedEncryptedBytes + delimiter + encodedIV + delimiter + encodedSalt;\n    }\n\n    /**\n     * Decrypt private key with symmetric AES encryption, GCM mode mode and no padding\n     *\n     * @param privateKey byte64 encoded string representation of private key, IV separated with \"|\"\n     * @param keyPhrase  key used for encryption, e.g. 12 random words\n     *                   {@link EncryptionUtils#getRandomWords(int, Context)}\n     * @return decrypted string\n     */\n    @SuppressFBWarnings(\"UCPM_USE_CHARACTER_PARAMETERIZED_METHOD\")\n    public static String decryptPrivateKey(String privateKey, String keyPhrase) throws NoSuchPaddingException,\n            NoSuchAlgorithmException, InvalidKeyException, BadPaddingException,\n            IllegalBlockSizeException, InvalidKeySpecException, InvalidAlgorithmParameterException {\n\n        String[] strings;\n\n        // split up iv, salt\n        if (privateKey.lastIndexOf(ivDelimiter) == -1) {\n            // backward compatibility\n            strings = privateKey.split(ivDelimiterOld);\n        } else {\n            strings = privateKey.split(\"\\\\\" + ivDelimiter);\n        }\n\n        String realPrivateKey = strings[0];\n        byte[] iv = decodeStringToBase64Bytes(strings[1]);\n        byte[] salt = decodeStringToBase64Bytes(strings[2]);\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(keyPhrase.toCharArray(), salt, iterationCount, keyStrength);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKeySpec key = new SecretKeySpec(tmp.getEncoded(), AES);\n\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n\n        byte[] bytes = decodeStringToBase64Bytes(realPrivateKey);\n        byte[] decrypted = cipher.doFinal(bytes);\n\n        String pemKey = decodeBase64BytesToString(decrypted);\n\n        return pemKey.replaceAll(\"\\n\", \"\").replace(\"-----BEGIN PRIVATE KEY-----\", \"\")\n                .replace(\"-----END PRIVATE KEY-----\", \"\");\n    }\n\n    public static String privateKeyToPEM(PrivateKey privateKey) {\n        String privateKeyString = encodeBytesToBase64String(privateKey.getEncoded());\n\n        return \"-----BEGIN PRIVATE KEY-----\\n\" + privateKeyString.replaceAll(\"(.{65})\", \"$1\\n\")\n                + \"\\n-----END PRIVATE KEY-----\";\n    }\n\n    /*\n    Helper\n     */\n\n    public static String getMD5Sum(File file) {\n        FileInputStream fileInputStream = null;\n        try {\n            fileInputStream = new FileInputStream(file);\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            byte[] bytes = new byte[2048];\n            int readBytes;\n\n            while ((readBytes = fileInputStream.read(bytes)) != -1) {\n                md5.update(bytes, 0, readBytes);\n            }\n\n            return new String(Hex.encodeHex(md5.digest()));\n\n        } catch (Exception e) {\n            Log_OC.e(TAG, e.getMessage());\n        } finally {\n            if (fileInputStream != null) {\n                try {\n                    fileInputStream.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, \"Error getting MD5 checksum for file\", e);\n                }\n            }\n        }\n\n        return \"\";\n    }\n\n    public static List<String> getRandomWords(int count, Context context) throws IOException {\n        InputStream ins = context.getResources().openRawResource(context.getResources()\n                .getIdentifier(\"encryption_key_words\", \"raw\", context.getPackageName()));\n\n        InputStreamReader inputStreamReader = new InputStreamReader(ins);\n\n        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);\n\n        List<String> lines = new ArrayList<>();\n        String line;\n        while ((line = bufferedReader.readLine()) != null) {\n            lines.add(line);\n        }\n\n        SecureRandom random = new SecureRandom();\n\n        List<String> outputLines = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            int randomLine = random.nextInt(lines.size());\n            outputLines.add(lines.get(randomLine));\n        }\n\n        return outputLines;\n    }\n\n    public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(RSA);\n        keyGen.initialize(2048, new SecureRandom());\n        return keyGen.generateKeyPair();\n    }\n\n    public static byte[] generateKey() {\n        KeyGenerator keyGenerator;\n        try {\n            keyGenerator = KeyGenerator.getInstance(AES);\n            keyGenerator.init(128);\n\n            return keyGenerator.generateKey().getEncoded();\n        } catch (NoSuchAlgorithmException e) {\n            Log_OC.e(TAG, e.getMessage());\n        }\n\n        return null;\n    }\n\n    public static byte[] randomBytes(int size) {\n        SecureRandom random = new SecureRandom();\n        final byte[] iv = new byte[size];\n        random.nextBytes(iv);\n\n        return iv;\n    }\n\n    /**\n     * Generate a SHA512 with appended salt\n     *\n     * @param token token to be hashed\n     * @return SHA512 with appended salt, delimiter HASH_DELIMITER\n     */\n    public static String generateSHA512(String token) {\n        String salt = EncryptionUtils.encodeBytesToBase64String(EncryptionUtils.randomBytes(EncryptionUtils.saltLength));\n\n        return generateSHA512(token, salt);\n    }\n\n    /**\n     * Generate a SHA512 with appended salt\n     *\n     * @param token token to be hashed\n     * @return SHA512 with appended salt, delimiter HASH_DELIMITER\n     */\n    public static String generateSHA512(String token, String salt) {\n        MessageDigest digest;\n        String hashedToken = \"\";\n        byte[] hash;\n        try {\n            digest = MessageDigest.getInstance(\"SHA-512\");\n            digest.update(salt.getBytes());\n            hash = digest.digest(token.getBytes());\n\n            StringBuilder stringBuilder = new StringBuilder();\n            for (byte hashByte : hash) {\n                stringBuilder.append(Integer.toString((hashByte & 0xff) + 0x100, 16).substring(1));\n            }\n\n            stringBuilder.append(HASH_DELIMITER).append(salt);\n\n            hashedToken = stringBuilder.toString();\n\n        } catch (NoSuchAlgorithmException e) {\n            Log_OC.e(TAG, \"Generating SHA512 failed\", e);\n        }\n\n        return hashedToken;\n    }\n\n    public static boolean verifySHA512(String hashWithSalt, String compareToken) {\n        String salt = hashWithSalt.split(\"\\\\\" + HASH_DELIMITER)[1];\n\n        String newHash = generateSHA512(compareToken, salt);\n\n        return hashWithSalt.equals(newHash);\n    }\n\n    public static String lockFolder(OCFile parentFile, OwnCloudClient client) throws UploadException {\n        // Lock folder\n        LockFileRemoteOperation lockFileOperation = new LockFileRemoteOperation(parentFile.getLocalId());\n        RemoteOperationResult lockFileOperationResult = lockFileOperation.execute(client);\n\n        if (lockFileOperationResult.isSuccess() &&\n            !TextUtils.isEmpty((String) lockFileOperationResult.getData().get(0))) {\n            return (String) lockFileOperationResult.getData().get(0);\n        } else if (lockFileOperationResult.getHttpCode() == HttpStatus.SC_FORBIDDEN) {\n            throw new UploadException(\"Forbidden! Please try again later.)\");\n        } else {\n            throw new UploadException(\"Could not lock folder\");\n        }\n    }\n\n    /**\n     * @param parentFile file metadata should be retrieved for\n     * @return Pair: boolean: true: metadata already exists, false: metadata new created\n     */\n    public static Pair<Boolean, DecryptedFolderMetadata> retrieveMetadata(OCFile parentFile,\n                                                                          OwnCloudClient client,\n                                                                          String privateKey,\n                                                                          String publicKey) throws UploadException,\n        InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, BadPaddingException,\n        IllegalBlockSizeException, InvalidKeyException, InvalidKeySpecException, CertificateException {\n        GetMetadataRemoteOperation getMetadataOperation = new GetMetadataRemoteOperation(parentFile.getLocalId());\n        RemoteOperationResult getMetadataOperationResult = getMetadataOperation.execute(client);\n\n        DecryptedFolderMetadata metadata;\n\n        if (getMetadataOperationResult.isSuccess()) {\n            // decrypt metadata\n            String serializedEncryptedMetadata = (String) getMetadataOperationResult.getData().get(0);\n\n\n            EncryptedFolderMetadata encryptedFolderMetadata = EncryptionUtils.deserializeJSON(\n                serializedEncryptedMetadata, new TypeToken<EncryptedFolderMetadata>() {\n                });\n\n            return new Pair<>(Boolean.TRUE, EncryptionUtils.decryptFolderMetaData(encryptedFolderMetadata, privateKey));\n\n        } else if (getMetadataOperationResult.getHttpCode() == HttpStatus.SC_NOT_FOUND) {\n            // new metadata\n            metadata = new DecryptedFolderMetadata();\n            metadata.setMetadata(new DecryptedFolderMetadata.Metadata());\n            metadata.getMetadata().setMetadataKeys(new HashMap<>());\n            String metadataKey = EncryptionUtils.encodeBytesToBase64String(EncryptionUtils.generateKey());\n            String encryptedMetadataKey = EncryptionUtils.encryptStringAsymmetric(metadataKey, publicKey);\n            metadata.getMetadata().getMetadataKeys().put(0, encryptedMetadataKey);\n\n            return new Pair<>(Boolean.FALSE, metadata);\n        } else {\n            // TODO error\n            throw new UploadException(\"something wrong\");\n        }\n    }\n\n    public static void uploadMetadata(OCFile parentFile,\n                                      String serializedFolderMetadata,\n                                      String token,\n                                      OwnCloudClient client,\n                                      boolean metadataExists) throws UploadException {\n        RemoteOperationResult uploadMetadataOperationResult;\n        if (metadataExists) {\n            // update metadata\n            UpdateMetadataRemoteOperation storeMetadataOperation = new UpdateMetadataRemoteOperation(\n                parentFile.getLocalId(), serializedFolderMetadata, token);\n            uploadMetadataOperationResult = storeMetadataOperation.execute(client);\n        } else {\n            // store metadata\n            StoreMetadataRemoteOperation storeMetadataOperation = new StoreMetadataRemoteOperation(\n                parentFile.getLocalId(), serializedFolderMetadata);\n            uploadMetadataOperationResult = storeMetadataOperation.execute(client);\n        }\n\n        if (!uploadMetadataOperationResult.isSuccess()) {\n            throw new UploadException(\"Storing/updating metadata was not successful\");\n        }\n    }\n\n    public static RemoteOperationResult unlockFolder(OCFile parentFolder, OwnCloudClient client, String token) {\n        if (token != null) {\n            return new UnlockFileRemoteOperation(parentFolder.getLocalId(), token).execute(client);\n        } else {\n            return new RemoteOperationResult(new Exception(\"No token available\"));\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Nextcloud Android client application\n *\n * @author Tobias Kaminsky\n * Copyright (C) 2017 Tobias Kaminsky\n * Copyright (C) 2017 Nextcloud GmbH.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.owncloud.android.util;\n\nimport android.text.TextUtils;\n\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonParser;\nimport com.google.gson.reflect.TypeToken;\nimport com.owncloud.android.datamodel.DecryptedFolderMetadata;\nimport com.owncloud.android.datamodel.EncryptedFolderMetadata;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.utils.CsrHelper;\nimport com.owncloud.android.utils.EncryptionUtils;\n\nimport net.bytebuddy.utility.RandomString;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\nimport javax.crypto.BadPaddingException;\n\nimport androidx.test.runner.AndroidJUnit4;\n\nimport static androidx.test.InstrumentationRegistry.getInstrumentation;\nimport static com.owncloud.android.utils.EncryptionUtils.EncryptedFile;\nimport static com.owncloud.android.utils.EncryptionUtils.decodeStringToBase64Bytes;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptFile;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptFolderMetaData;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptPrivateKey;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptStringAsymmetric;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptStringSymmetric;\nimport static com.owncloud.android.utils.EncryptionUtils.deserializeJSON;\nimport static com.owncloud.android.utils.EncryptionUtils.encodeBytesToBase64String;\nimport static com.owncloud.android.utils.EncryptionUtils.encryptFile;\nimport static com.owncloud.android.utils.EncryptionUtils.encryptFolderMetadata;\nimport static com.owncloud.android.utils.EncryptionUtils.generateKey;\nimport static com.owncloud.android.utils.EncryptionUtils.generateSHA512;\nimport static com.owncloud.android.utils.EncryptionUtils.getMD5Sum;\nimport static com.owncloud.android.utils.EncryptionUtils.ivDelimiter;\nimport static com.owncloud.android.utils.EncryptionUtils.ivDelimiterOld;\nimport static com.owncloud.android.utils.EncryptionUtils.ivLength;\nimport static com.owncloud.android.utils.EncryptionUtils.randomBytes;\nimport static com.owncloud.android.utils.EncryptionUtils.saltLength;\nimport static com.owncloud.android.utils.EncryptionUtils.serializeJSON;\nimport static com.owncloud.android.utils.EncryptionUtils.verifySHA512;\nimport static junit.framework.Assert.assertFalse;\nimport static junit.framework.Assert.assertTrue;\nimport static org.junit.Assert.assertEquals;\n\n@RunWith(AndroidJUnit4.class)\npublic class EncryptionTestIT {\n    private String privateKey = \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAo\" +\n            \"IBAQDsn0JKS/THu328z1IgN0VzYU53HjSX03WJIgWkmyTaxbiKpoJaKbksXmfSpgzV\" +\n            \"GzKFvGfZ03fwFrN7Q8P8R2e8SNiell7mh1TDw9/0P7Bt/ER8PJrXORo+GviKHxaLr7\" +\n            \"Y0BJX9i/nW/L0L/VaE8CZTAqYBdcSJGgHJjY4UMf892ZPTa9T2Dl3ggdMZ7BQ2kiCi\" +\n            \"CC3qV99b0igRJGmmLQaGiAflhFzuDQPMifUMq75wI8RSRPdxUAtjTfkl68QHu7Umye\" +\n            \"yy33OQgdUKaTl5zcS3VSQbNjveVCNM4RDH1RlEc+7Wf1BY8APqT6jbiBcROJD2CeoL\" +\n            \"H2eiIJCi+61ZkSGfAgMBAAECggEBALFStCHrhBf+GL9a+qer4/8QZ/X6i91PmaBX/7\" +\n            \"SYk2jjjWVSXRNmex+V6+Y/jBRT2mvAgm8J+7LPwFdatE+lz0aZrMRD2gCWYF6Itpda\" +\n            \"90OlLkmQPVWWtGTgX2ta2tF5r2iSGzk0IdoL8zw98Q2UzpOcw30KnWtFMxuxWk0mHq\" +\n            \"pgp00g80cDWg3+RPbWOhdLp5bflQ36fKDfmjq05cGlIk6unnVyC5HXpvh4d4k2EWlX\" +\n            \"rjGsndVBPCjGkZePlLRgDHxT06r+5XdJ+1CBDZgCsmjGz3M8uOHyCfVW0WhB7ynzDT\" +\n            \"agVgz0iqpuhAi9sPt6iWWwpAnRw8cQgqEKw9bvKKECgYEA/WPi2PJtL6u/xlysh/H7\" +\n            \"A717CId6fPHCMDace39ZNtzUzc0nT5BemlcF0wZ74NeJSur3Q395YzB+eBMLs5p8mA\" +\n            \"95wgGvJhM65/J+HX+k9kt6Z556zLMvtG+j1yo4D0VEwm3xahB4SUUP+1kD7dNvo4+8\" +\n            \"xeSCyjzNllvYZZC0DrECgYEA7w8pEqhHHn0a+twkPCZJS+gQTB9Rm+FBNGJqB3XpWs\" +\n            \"TeLUxYRbVGk0iDve+eeeZ41drxcdyWP+WcL34hnrjgI1Fo4mK88saajpwUIYMy6+qM\" +\n            \"LY+jC2NRSBox56eH7nsVYvQQK9eKqv9wbB+PF9SwOIvuETN7fd8mAY02UnoaaU8CgY\" +\n            \"BoHRKocXPLkpZJuuppMVQiRUi4SHJbxDo19Tp2w+y0TihiJ1lvp7I3WGpcOt3LlMQk\" +\n            \"tEbExSvrRZGxZKH6Og/XqwQsYuTEkEIz679F/5yYVosE6GkskrOXQAfh8Mb3/04xVV\" +\n            \"tMaVgDQw0+CWVD4wyL+BNofGwBDNqsXTCdCsfxAQKBgQCDv2EtbRw0y1HRKv21QIxo\" +\n            \"ju5cZW4+cDfVPN+eWPdQFOs1H7wOPsc0aGRiiupV2BSEF3O1ApKziEE5U1QH+29bR4\" +\n            \"R8L1pemeGX8qCNj5bCubKjcWOz5PpouDcEqimZ3q98p3E6GEHN15UHoaTkx0yO/V8o\" +\n            \"j6zhQ9fYRxDHB5ACtQKBgQCOO7TJUO1IaLTjcrwS4oCfJyRnAdz49L1AbVJkIBK0fh\" +\n            \"JLecOFu3ZlQl/RStQb69QKb5MNOIMmQhg8WOxZxHcpmIDbkDAm/J/ovJXFSoBdOr5o\" +\n            \"uQsYsDZhsWW97zvLMzg5pH9/3/1BNz5q3Vu4HgfBSwWGt4E2NENj+XA+QAVmGA==\";\n\n    private String cert = \"-----BEGIN CERTIFICATE-----\\n\" +\n            \"MIIDpzCCAo+gAwIBAgIBADANBgkqhkiG9w0BAQUFADBuMRowGAYDVQQDDBF3d3cu\\n\" +\n            \"bmV4dGNsb3VkLmNvbTESMBAGA1UECgwJTmV4dGNsb3VkMRIwEAYDVQQHDAlTdHV0\\n\" +\n            \"dGdhcnQxGzAZBgNVBAgMEkJhZGVuLVd1ZXJ0dGVtYmVyZzELMAkGA1UEBhMCREUw\\n\" +\n            \"HhcNMTcwOTI2MTAwNDMwWhcNMzcwOTIxMTAwNDMwWjBuMRowGAYDVQQDDBF3d3cu\\n\" +\n            \"bmV4dGNsb3VkLmNvbTESMBAGA1UECgwJTmV4dGNsb3VkMRIwEAYDVQQHDAlTdHV0\\n\" +\n            \"dGdhcnQxGzAZBgNVBAgMEkJhZGVuLVd1ZXJ0dGVtYmVyZzELMAkGA1UEBhMCREUw\\n\" +\n            \"ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDsn0JKS/THu328z1IgN0Vz\\n\" +\n            \"YU53HjSX03WJIgWkmyTaxbiKpoJaKbksXmfSpgzVGzKFvGfZ03fwFrN7Q8P8R2e8\\n\" +\n            \"SNiell7mh1TDw9/0P7Bt/ER8PJrXORo+GviKHxaLr7Y0BJX9i/nW/L0L/VaE8CZT\\n\" +\n            \"AqYBdcSJGgHJjY4UMf892ZPTa9T2Dl3ggdMZ7BQ2kiCiCC3qV99b0igRJGmmLQaG\\n\" +\n            \"iAflhFzuDQPMifUMq75wI8RSRPdxUAtjTfkl68QHu7Umyeyy33OQgdUKaTl5zcS3\\n\" +\n            \"VSQbNjveVCNM4RDH1RlEc+7Wf1BY8APqT6jbiBcROJD2CeoLH2eiIJCi+61ZkSGf\\n\" +\n            \"AgMBAAGjUDBOMB0GA1UdDgQWBBTFrXz2tk1HivD9rQ75qeoyHrAgIjAfBgNVHSME\\n\" +\n            \"GDAWgBTFrXz2tk1HivD9rQ75qeoyHrAgIjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3\\n\" +\n            \"DQEBBQUAA4IBAQARQTX21QKO77gAzBszFJ6xVnjfa23YZF26Z4X1KaM8uV8TGzuN\\n\" +\n            \"JA95XmReeP2iO3r8EWXS9djVCD64m2xx6FOsrUI8HZaw1JErU8mmOaLAe8q9RsOm\\n\" +\n            \"9Eq37e4vFp2YUEInYUqs87ByUcA4/8g3lEYeIUnRsRsWsA45S3wD7wy07t+KAn7j\\n\" +\n            \"yMmfxdma6hFfG9iN/egN6QXUAyIPXvUvlUuZ7/BhWBj/3sHMrF9quy9Q2DOI8F3t\\n\" +\n            \"1wdQrkq4BtStKhciY5AIXz9SqsctFHTv4Lwgtkapoel4izJnO0ZqYTXVe7THwri9\\n\" +\n            \"H/gua6uJDWH9jk2/CiZDWfsyFuNUuXvDSp05\\n\" +\n            \"-----END CERTIFICATE-----\";\n\n    @Test\n    public void encryptStringAsymmetric() throws Exception {\n        byte[] key1 = generateKey();\n        String base64encodedKey = encodeBytesToBase64String(key1);\n\n        String encryptedString = EncryptionUtils.encryptStringAsymmetric(base64encodedKey, cert);\n        String decryptedString = decryptStringAsymmetric(encryptedString, privateKey);\n\n        byte[] key2 = decodeStringToBase64Bytes(decryptedString);\n\n        assertTrue(Arrays.equals(key1, key2));\n    }\n\n    @Test\n    public void encryptStringAsymmetricCorrectPublicKey() throws Exception {\n        KeyPair keyPair = EncryptionUtils.generateKeyPair();\n\n        byte[] key1 = generateKey();\n        String base64encodedKey = encodeBytesToBase64String(key1);\n\n        String encryptedString = EncryptionUtils.encryptStringAsymmetric(base64encodedKey, keyPair.getPublic());\n        String decryptedString = decryptStringAsymmetric(encryptedString, keyPair.getPrivate());\n\n        byte[] key2 = decodeStringToBase64Bytes(decryptedString);\n\n        assertTrue(Arrays.equals(key1, key2));\n    }\n\n    @Test(expected = BadPaddingException.class)\n    public void encryptStringAsymmetricWrongPublicKey() throws Exception {\n        KeyPair keyPair1 = EncryptionUtils.generateKeyPair();\n        KeyPair keyPair2 = EncryptionUtils.generateKeyPair();\n\n        byte[] key1 = generateKey();\n        String base64encodedKey = encodeBytesToBase64String(key1);\n\n        String encryptedString = EncryptionUtils.encryptStringAsymmetric(base64encodedKey, keyPair1.getPublic());\n        decryptStringAsymmetric(encryptedString, keyPair2.getPrivate());\n    }\n\n    @Test\n    public void encryptStringSymmetricRandom() throws Exception {\n        int max = 500;\n        for (int i = 0; i < max; i++) {\n            Log_OC.d(\"EncryptionTestIT\", i + \" of \" + max);\n            byte[] key = generateKey();\n\n            String encryptedString;\n            if (new Random().nextBoolean()) {\n                encryptedString = EncryptionUtils.encryptStringSymmetric(privateKey, key);\n            } else {\n                encryptedString = EncryptionUtils.encryptStringSymmetricOld(privateKey, key);\n\n                if (encryptedString.indexOf(ivDelimiterOld) != encryptedString.lastIndexOf(ivDelimiterOld)) {\n                    Log_OC.d(\"EncryptionTestIT\", \"skip due to duplicated iv (old system) -> ignoring\");\n                    continue;\n                }\n            }\n            String decryptedString = decryptStringSymmetric(encryptedString, key);\n\n            assertEquals(privateKey, decryptedString);\n        }\n    }\n\n    @Test\n    public void encryptStringSymmetric() throws Exception {\n        int max = 5000;\n        byte[] key = generateKey();\n\n        for (int i = 0; i < max; i++) {\n            Log_OC.d(\"EncryptionTestIT\", i + \" of \" + max);\n\n            String encryptedString = EncryptionUtils.encryptStringSymmetric(privateKey, key);\n\n            int delimiterPosition = encryptedString.indexOf(ivDelimiter);\n            if (delimiterPosition == -1) {\n                throw new RuntimeException(\"IV not found!\");\n            }\n\n            String ivString = encryptedString.substring(delimiterPosition + ivDelimiter.length());\n            if (TextUtils.isEmpty(ivString)) {\n                delimiterPosition = encryptedString.lastIndexOf(ivDelimiter);\n                ivString = encryptedString.substring(delimiterPosition + ivDelimiter.length());\n\n                if (TextUtils.isEmpty(ivString)) {\n                    throw new RuntimeException(\"IV string is empty\");\n                }\n            }\n\n            String decryptedString = decryptStringSymmetric(encryptedString, key);\n\n            assertEquals(privateKey, decryptedString);\n        }\n    }\n\n    @Test\n    public void encryptPrivateKey() throws Exception {\n        int max = 10;\n        for (int i = 0; i < max; i++) {\n            Log_OC.d(\"EncryptionTestIT\", i + \" of \" + max);\n\n            String keyPhrase = \"moreovertelevisionfactorytendencyindependenceinternationalintellectualimpress\" +\n                \"interestvolunteer\";\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n            keyGen.initialize(4096, new SecureRandom());\n            KeyPair keyPair = keyGen.generateKeyPair();\n            PrivateKey privateKey = keyPair.getPrivate();\n            byte[] privateKeyBytes = privateKey.getEncoded();\n            String privateKeyString = encodeBytesToBase64String(privateKeyBytes);\n\n            String encryptedString;\n            if (new Random().nextBoolean()) {\n                encryptedString = EncryptionUtils.encryptPrivateKey(privateKeyString, keyPhrase);\n            } else {\n                encryptedString = EncryptionUtils.encryptPrivateKeyOld(privateKeyString, keyPhrase);\n            }\n            String decryptedString = decryptPrivateKey(encryptedString, keyPhrase);\n\n            assertEquals(privateKeyString, decryptedString);\n        }\n    }\n\n    @Test\n    public void generateCSR() throws Exception {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048, new SecureRandom());\n        KeyPair keyPair = keyGen.generateKeyPair();\n\n        assertFalse(CsrHelper.generateCsrPemEncodedString(keyPair, \"\").isEmpty());\n        assertFalse(encodeBytesToBase64String(keyPair.getPublic().getEncoded()).isEmpty());\n    }\n\n    /**\n     * DecryptedFolderMetadata -> EncryptedFolderMetadata -> JSON -> encrypt\n     * -> decrypt -> JSON -> EncryptedFolderMetadata -> DecryptedFolderMetadata\n     */\n    @Test\n    public void encryptionMetadata() throws Exception {\n        DecryptedFolderMetadata decryptedFolderMetadata1 = generateFolderMetadata();\n\n        // encrypt\n        EncryptedFolderMetadata encryptedFolderMetadata1 = encryptFolderMetadata(\n                decryptedFolderMetadata1, privateKey);\n\n        // serialize\n        String encryptedJson = serializeJSON(encryptedFolderMetadata1);\n\n        // de-serialize\n        EncryptedFolderMetadata encryptedFolderMetadata2 = deserializeJSON(encryptedJson,\n                                                                           new TypeToken<EncryptedFolderMetadata>() {\n                });\n\n        // decrypt\n        DecryptedFolderMetadata decryptedFolderMetadata2 = decryptFolderMetaData(\n                encryptedFolderMetadata2, privateKey);\n\n        // compare\n        assertTrue(compareJsonStrings(serializeJSON(decryptedFolderMetadata1),\n                                      serializeJSON(decryptedFolderMetadata2)));\n    }\n\n    @Test\n    public void testCryptFileWithoutMetadata() throws Exception {\n        byte[] key = decodeStringToBase64Bytes(\"WANM0gRv+DhaexIsI0T3Lg==\");\n        byte[] iv = decodeStringToBase64Bytes(\"gKm3n+mJzeY26q4OfuZEqg==\");\n        byte[] authTag = decodeStringToBase64Bytes(\"PboI9tqHHX3QeAA22PIu4w==\");\n\n        assertTrue(cryptFile(\"ia7OEEEyXMoRa1QWQk8r\", \"78f42172166f9dc8fd1a7156b1753353\", key, iv, authTag));\n    }\n\n    @Test\n    public void cryptFileWithMetadata() throws Exception {\n        DecryptedFolderMetadata metadata = generateFolderMetadata();\n\n        // n9WXAIXO2wRY4R8nXwmo\n        assertTrue(cryptFile(\"ia7OEEEyXMoRa1QWQk8r\",\n                             \"78f42172166f9dc8fd1a7156b1753353\",\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"ia7OEEEyXMoRa1QWQk8r\")\n                        .getEncrypted().getKey()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"ia7OEEEyXMoRa1QWQk8r\")\n                        .getInitializationVector()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"ia7OEEEyXMoRa1QWQk8r\")\n                        .getAuthenticationTag())));\n\n        // n9WXAIXO2wRY4R8nXwmo\n        assertTrue(cryptFile(\"n9WXAIXO2wRY4R8nXwmo\",\n                             \"825143ed1f21ebb0c3b3c3f005b2f5db\",\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"n9WXAIXO2wRY4R8nXwmo\")\n                        .getEncrypted().getKey()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"n9WXAIXO2wRY4R8nXwmo\")\n                        .getInitializationVector()),\n                             decodeStringToBase64Bytes(metadata.getFiles().get(\"n9WXAIXO2wRY4R8nXwmo\")\n                        .getAuthenticationTag())));\n    }\n\n    @Test\n    public void bigMetadata() throws Exception {\n        DecryptedFolderMetadata decryptedFolderMetadata1 = generateFolderMetadata();\n\n        // encrypt\n        EncryptedFolderMetadata encryptedFolderMetadata1 = encryptFolderMetadata(\n            decryptedFolderMetadata1, privateKey);\n\n        // serialize\n        String encryptedJson = serializeJSON(encryptedFolderMetadata1);\n\n        // de-serialize\n        EncryptedFolderMetadata encryptedFolderMetadata2 = deserializeJSON(encryptedJson,\n                                                                           new TypeToken<EncryptedFolderMetadata>() {\n                                                                           });\n\n        // decrypt\n        DecryptedFolderMetadata decryptedFolderMetadata2 = decryptFolderMetaData(\n            encryptedFolderMetadata2, privateKey);\n\n        // compare\n        assertTrue(compareJsonStrings(serializeJSON(decryptedFolderMetadata1),\n                                      serializeJSON(decryptedFolderMetadata2)));\n\n        // prefill with 500\n        for (int i = 0; i < 500; i++) {\n            addFile(decryptedFolderMetadata1, i);\n        }\n\n        int max = 505;\n        for (int i = 500; i < max; i++) {\n            Log_OC.d(this, \"Big metadata: \" + i + \" of \" + max);\n\n            addFile(decryptedFolderMetadata1, i);\n\n            // encrypt\n            encryptedFolderMetadata1 = encryptFolderMetadata(decryptedFolderMetadata1, privateKey);\n\n            // serialize\n            encryptedJson = serializeJSON(encryptedFolderMetadata1);\n\n            // de-serialize\n            encryptedFolderMetadata2 = deserializeJSON(encryptedJson,\n                                                       new TypeToken<EncryptedFolderMetadata>() {\n                                                       });\n\n            // decrypt\n            decryptedFolderMetadata2 = decryptFolderMetaData(encryptedFolderMetadata2, privateKey);\n\n            // compare\n            assertTrue(compareJsonStrings(serializeJSON(decryptedFolderMetadata1),\n                                          serializeJSON(decryptedFolderMetadata2)));\n\n            assertEquals(i + 3, decryptedFolderMetadata1.getFiles().size());\n            assertEquals(i + 3, decryptedFolderMetadata2.getFiles().size());\n        }\n    }\n\n    private void addFile(DecryptedFolderMetadata decryptedFolderMetadata, int counter) {\n        // Add new file\n        // Always generate new\n        byte[] key = generateKey();\n        byte[] iv = randomBytes(ivLength);\n        byte[] authTag = randomBytes((128 / 8));\n\n        DecryptedFolderMetadata.Data data = new DecryptedFolderMetadata.Data();\n        data.setKey(EncryptionUtils.encodeBytesToBase64String(key));\n        data.setFilename(counter + \".txt\");\n        data.setVersion(1);\n\n        DecryptedFolderMetadata.DecryptedFile file = new DecryptedFolderMetadata.DecryptedFile();\n        file.setInitializationVector(EncryptionUtils.encodeBytesToBase64String(iv));\n        file.setEncrypted(data);\n        file.setMetadataKey(0);\n        file.setAuthenticationTag(EncryptionUtils.encodeBytesToBase64String(authTag));\n\n        decryptedFolderMetadata.getFiles().put(RandomString.make(20), file);\n    }\n\n    /**\n     * generates new keys and tests if they are unique\n     */\n    @Test\n    public void testKey() {\n        Set<String> keys = new HashSet<>();\n\n        for (int i = 0; i < 50; i++) {\n            assertTrue(keys.add(encodeBytesToBase64String(generateKey())));\n        }\n    }\n\n    /**\n     * generates new ivs and tests if they are unique\n     */\n    @Test\n    public void testIV() {\n        Set<String> ivs = new HashSet<>();\n\n        for (int i = 0; i < 50; i++) {\n            assertTrue(ivs.add(encodeBytesToBase64String(\n                randomBytes(ivLength))));\n        }\n    }\n\n    /**\n     * generates new salt and tests if they are unique\n     */\n    @Test\n    public void testSalt() {\n        Set<String> ivs = new HashSet<>();\n\n        for (int i = 0; i < 50; i++) {\n            assertTrue(ivs.add(encodeBytesToBase64String(\n                randomBytes(saltLength))));\n        }\n    }\n\n    @Test\n    public void testSHA512() {\n        // sent to 3rd party app in cleartext\n        String token = \"4ae5978bf5354cd284b539015d442141\";\n        String salt = encodeBytesToBase64String(randomBytes(saltLength));\n\n        // stored in database\n        String hashedToken = generateSHA512(token, salt);\n\n        // check: use passed cleartext and salt to verify hashed token\n        assertTrue(verifySHA512(hashedToken, token));\n    }\n\n\n    // Helper\n    private boolean compareJsonStrings(String expected, String actual) {\n        JsonParser parser = new JsonParser();\n        JsonElement o1 = parser.parse(expected);\n        JsonElement o2 = parser.parse(actual);\n\n        if (o1.equals(o2)) {\n            return true;\n        } else {\n            System.out.println(\"expected: \" + o1);\n            System.out.println(\"actual: \" + o2);\n            return false;\n        }\n    }\n\n    private DecryptedFolderMetadata generateFolderMetadata() throws Exception {\n        String metadataKey0 = encodeBytesToBase64String(generateKey());\n        String metadataKey1 = encodeBytesToBase64String(generateKey());\n        String metadataKey2 = encodeBytesToBase64String(generateKey());\n        HashMap<Integer, String> metadataKeys = new HashMap<>();\n        metadataKeys.put(0, EncryptionUtils.encryptStringAsymmetric(metadataKey0, cert));\n        metadataKeys.put(1, EncryptionUtils.encryptStringAsymmetric(metadataKey1, cert));\n        metadataKeys.put(2, EncryptionUtils.encryptStringAsymmetric(metadataKey2, cert));\n        DecryptedFolderMetadata.Encrypted encrypted = new DecryptedFolderMetadata.Encrypted();\n        encrypted.setMetadataKeys(metadataKeys);\n\n        DecryptedFolderMetadata.Metadata metadata1 = new DecryptedFolderMetadata.Metadata();\n        metadata1.setMetadataKeys(metadataKeys);\n        metadata1.setVersion(1);\n\n        DecryptedFolderMetadata.Sharing sharing = new DecryptedFolderMetadata.Sharing();\n        sharing.setSignature(\"HMACOFRECIPIENTANDNEWESTMETADATAKEY\");\n        HashMap<String, String> recipient = new HashMap<>();\n        recipient.put(\"blah@schiessle.org\", \"PUBLIC KEY\");\n        recipient.put(\"bjoern@schiessle.org\", \"PUBLIC KEY\");\n        sharing.setRecipient(recipient);\n        metadata1.setSharing(sharing);\n\n        HashMap<String, DecryptedFolderMetadata.DecryptedFile> files = new HashMap<>();\n\n        DecryptedFolderMetadata.Data data1 = new DecryptedFolderMetadata.Data();\n        data1.setKey(\"WANM0gRv+DhaexIsI0T3Lg==\");\n        data1.setFilename(\"test.txt\");\n        data1.setVersion(1);\n\n        DecryptedFolderMetadata.DecryptedFile file1 = new DecryptedFolderMetadata.DecryptedFile();\n        file1.setInitializationVector(\"gKm3n+mJzeY26q4OfuZEqg==\");\n        file1.setEncrypted(data1);\n        file1.setMetadataKey(0);\n        file1.setAuthenticationTag(\"PboI9tqHHX3QeAA22PIu4w==\");\n\n        files.put(\"ia7OEEEyXMoRa1QWQk8r\", file1);\n\n        DecryptedFolderMetadata.Data data2 = new DecryptedFolderMetadata.Data();\n        data2.setKey(\"9dfzbIYDt28zTyZfbcll+g==\");\n        data2.setFilename(\"test2.txt\");\n        data2.setVersion(1);\n\n        DecryptedFolderMetadata.DecryptedFile file2 = new DecryptedFolderMetadata.DecryptedFile();\n        file2.setInitializationVector(\"hnJLF8uhDvDoFK4ajuvwrg==\");\n        file2.setEncrypted(data2);\n        file2.setMetadataKey(0);\n        file2.setAuthenticationTag(\"qOQZdu5soFO77Y7y4rAOVA==\");\n\n        files.put(\"n9WXAIXO2wRY4R8nXwmo\", file2);\n\n        return new DecryptedFolderMetadata(metadata1, files);\n    }\n\n    private boolean cryptFile(String fileName, String md5, byte[] key, byte[] iv, byte[] expectedAuthTag)\n            throws Exception {\n        File file = getFile(fileName);\n        assertEquals(md5, getMD5Sum(file));\n\n        EncryptedFile encryptedFile = encryptFile(file, key, iv);\n\n        File encryptedTempFile = File.createTempFile(\"file\", \"tmp\");\n        FileOutputStream fileOutputStream = new FileOutputStream(encryptedTempFile);\n        fileOutputStream.write(encryptedFile.encryptedBytes);\n        fileOutputStream.close();\n\n        byte[] authenticationTag = decodeStringToBase64Bytes(encryptedFile.authenticationTag);\n\n        // verify authentication tag\n        assertTrue(Arrays.equals(expectedAuthTag, authenticationTag));\n\n        byte[] decryptedBytes = decryptFile(encryptedTempFile, key, iv, authenticationTag);\n\n        File decryptedFile = File.createTempFile(\"file\", \"dec\");\n        FileOutputStream fileOutputStream1 = new FileOutputStream(decryptedFile);\n        fileOutputStream1.write(decryptedBytes);\n        fileOutputStream1.close();\n\n        return md5.compareTo(getMD5Sum(decryptedFile)) == 0;\n    }\n\n    private File getFile(String filename) throws IOException {\n        InputStream inputStream = getInstrumentation().getContext().getAssets().open(filename);\n        File temp = File.createTempFile(\"file\", \"file\");\n        FileUtils.copyInputStreamToFile(inputStream, temp);\n\n        return temp;\n    }\n}\n", "/*\n * Nextcloud Android client application\n *\n * @author Tobias Kaminsky\n * Copyright (C) 2017 Tobias Kaminsky\n * Copyright (C) 2017 Nextcloud GmbH.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage com.owncloud.android.ui.dialog;\n\nimport android.accounts.AccountManager;\nimport android.app.Dialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.graphics.PorterDuff;\nimport android.graphics.drawable.Drawable;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\n\nimport com.nextcloud.client.account.User;\nimport com.owncloud.android.R;\nimport com.owncloud.android.datamodel.ArbitraryDataProvider;\nimport com.owncloud.android.lib.common.accounts.AccountUtils;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.lib.resources.users.DeletePublicKeyOperation;\nimport com.owncloud.android.lib.resources.users.GetPrivateKeyOperation;\nimport com.owncloud.android.lib.resources.users.GetPublicKeyOperation;\nimport com.owncloud.android.lib.resources.users.SendCSROperation;\nimport com.owncloud.android.lib.resources.users.StorePrivateKeyOperation;\nimport com.owncloud.android.utils.CsrHelper;\nimport com.owncloud.android.utils.EncryptionUtils;\nimport com.owncloud.android.utils.theme.ThemeButtonUtils;\nimport com.owncloud.android.utils.theme.ThemeColorUtils;\n\nimport java.io.IOException;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.VisibleForTesting;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.core.graphics.drawable.DrawableCompat;\nimport androidx.fragment.app.DialogFragment;\n\nimport static com.owncloud.android.utils.EncryptionUtils.decodeStringToBase64Bytes;\nimport static com.owncloud.android.utils.EncryptionUtils.decryptStringAsymmetric;\nimport static com.owncloud.android.utils.EncryptionUtils.encodeBytesToBase64String;\nimport static com.owncloud.android.utils.EncryptionUtils.generateKey;\n\n/*\n *  Dialog to setup encryption\n */\npublic class SetupEncryptionDialogFragment extends DialogFragment {\n\n    public static final String SUCCESS = \"SUCCESS\";\n    public static final int SETUP_ENCRYPTION_RESULT_CODE = 101;\n    public static final int SETUP_ENCRYPTION_REQUEST_CODE = 100;\n    public static final String SETUP_ENCRYPTION_DIALOG_TAG = \"SETUP_ENCRYPTION_DIALOG_TAG\";\n    public static final String ARG_POSITION = \"ARG_POSITION\";\n\n    private static final String ARG_USER = \"ARG_USER\";\n    private static final String TAG = SetupEncryptionDialogFragment.class.getSimpleName();\n\n    private static final String KEY_CREATED = \"KEY_CREATED\";\n    private static final String KEY_EXISTING_USED = \"KEY_EXISTING_USED\";\n    private static final String KEY_FAILED = \"KEY_FAILED\";\n    private static final String KEY_GENERATE = \"KEY_GENERATE\";\n\n    private User user;\n    private TextView textView;\n    private TextView passphraseTextView;\n    private ArbitraryDataProvider arbitraryDataProvider;\n    private Button positiveButton;\n    private Button neutralButton;\n    private DownloadKeysAsyncTask task;\n    private TextView passwordField;\n    private String keyResult;\n    private List<String> keyWords;\n\n    /**\n     * Public factory method to create new SetupEncryptionDialogFragment instance\n     *\n     * @return Dialog ready to show.\n     */\n    public static SetupEncryptionDialogFragment newInstance(User user, int position) {\n        SetupEncryptionDialogFragment fragment = new SetupEncryptionDialogFragment();\n        Bundle args = new Bundle();\n        args.putParcelable(ARG_USER, user);\n        args.putInt(ARG_POSITION, position);\n        fragment.setArguments(args);\n        return fragment;\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n\n        AlertDialog alertDialog = (AlertDialog) getDialog();\n\n        positiveButton = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);\n        neutralButton = alertDialog.getButton(AlertDialog.BUTTON_NEUTRAL);\n        ThemeButtonUtils.themeBorderlessButton(positiveButton,\n                                               neutralButton);\n\n        task = new DownloadKeysAsyncTask();\n        task.execute();\n    }\n\n    @NonNull\n    @Override\n    public Dialog onCreateDialog(Bundle savedInstanceState) {\n        int primaryColor = ThemeColorUtils.primaryColor(getContext());\n        user = getArguments().getParcelable(ARG_USER);\n\n        arbitraryDataProvider = new ArbitraryDataProvider(getContext().getContentResolver());\n\n        // Inflate the layout for the dialog\n        LayoutInflater inflater = getActivity().getLayoutInflater();\n\n        // Setup layout\n        View v = inflater.inflate(R.layout.setup_encryption_dialog, null);\n        textView = v.findViewById(R.id.encryption_status);\n        passphraseTextView = v.findViewById(R.id.encryption_passphrase);\n        passwordField = v.findViewById(R.id.encryption_passwordInput);\n        passwordField.getBackground().setColorFilter(primaryColor, PorterDuff.Mode.SRC_ATOP);\n\n        Drawable wrappedDrawable = DrawableCompat.wrap(passwordField.getBackground());\n        DrawableCompat.setTint(wrappedDrawable, primaryColor);\n        passwordField.setBackgroundDrawable(wrappedDrawable);\n\n        return createDialog(v);\n    }\n\n    @NonNull\n    private Dialog createDialog(View v) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setView(v).setPositiveButton(R.string.common_ok, null)\n                .setNeutralButton(R.string.common_cancel, null)\n                .setTitle(R.string.end_to_end_encryption_title);\n\n        Dialog dialog = builder.create();\n        dialog.setCanceledOnTouchOutside(false);\n\n        dialog.setOnShowListener(new DialogInterface.OnShowListener() {\n\n            @Override\n            public void onShow(final DialogInterface dialog) {\n\n                Button button = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_POSITIVE);\n                button.setOnClickListener(new View.OnClickListener() {\n\n                    @Override\n                    public void onClick(View view) {\n                        switch (keyResult) {\n                            case KEY_CREATED:\n                                Log_OC.d(TAG, \"New keys generated and stored.\");\n\n                                dialog.dismiss();\n\n                                Intent intentCreated = new Intent();\n                                intentCreated.putExtra(SUCCESS, true);\n                                intentCreated.putExtra(ARG_POSITION, getArguments().getInt(ARG_POSITION));\n                                getTargetFragment().onActivityResult(getTargetRequestCode(),\n                                        SETUP_ENCRYPTION_RESULT_CODE, intentCreated);\n                                break;\n\n                            case KEY_EXISTING_USED:\n                                Log_OC.d(TAG, \"Decrypt private key\");\n\n                                textView.setText(R.string.end_to_end_encryption_decrypting);\n\n                                try {\n                                    String privateKey = task.get();\n                                    String mnemonicUnchanged = passwordField.getText().toString();\n                                    String mnemonic = passwordField.getText().toString().replaceAll(\"\\\\s\", \"\")\n                                        .toLowerCase(Locale.ROOT);\n                                    String decryptedPrivateKey = EncryptionUtils.decryptPrivateKey(privateKey,\n                                                                                                   mnemonic);\n\n                                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(),\n                                                                                EncryptionUtils.PRIVATE_KEY, decryptedPrivateKey);\n\n                                    dialog.dismiss();\n                                    Log_OC.d(TAG, \"Private key successfully decrypted and stored\");\n\n                                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(),\n                                                                                EncryptionUtils.MNEMONIC,\n                                                                                mnemonicUnchanged);\n\n                                    // check if private key and public key match\n                                    String publicKey = arbitraryDataProvider.getValue(user.getAccountName(),\n                                                                                      EncryptionUtils.PUBLIC_KEY);\n\n                                    byte[] key1 = generateKey();\n                                    String base64encodedKey = encodeBytesToBase64String(key1);\n\n                                    String encryptedString = EncryptionUtils.encryptStringAsymmetric(base64encodedKey,\n                                                                                                     publicKey);\n                                    String decryptedString = decryptStringAsymmetric(encryptedString,\n                                                                                     decryptedPrivateKey);\n\n                                    byte[] key2 = decodeStringToBase64Bytes(decryptedString);\n\n                                    if (!Arrays.equals(key1, key2)) {\n                                        throw new Exception(\"Keys do not match\");\n                                    }\n\n                                    Intent intentExisting = new Intent();\n                                    intentExisting.putExtra(SUCCESS, true);\n                                    intentExisting.putExtra(ARG_POSITION, getArguments().getInt(ARG_POSITION));\n                                    getTargetFragment().onActivityResult(getTargetRequestCode(),\n                                                                         SETUP_ENCRYPTION_RESULT_CODE, intentExisting);\n\n                                } catch (Exception e) {\n                                    textView.setText(R.string.end_to_end_encryption_wrong_password);\n                                    Log_OC.d(TAG, \"Error while decrypting private key: \" + e.getMessage());\n                                }\n                                break;\n\n                            case KEY_GENERATE:\n                                passphraseTextView.setVisibility(View.GONE);\n                                positiveButton.setVisibility(View.GONE);\n                                neutralButton.setVisibility(View.GONE);\n                                getDialog().setTitle(R.string.end_to_end_encryption_storing_keys);\n\n                                GenerateNewKeysAsyncTask newKeysTask = new GenerateNewKeysAsyncTask();\n                                newKeysTask.execute();\n                                break;\n\n                            default:\n                                dialog.dismiss();\n                                break;\n                        }\n                    }\n                });\n            }\n        });\n        return dialog;\n    }\n\n    public class DownloadKeysAsyncTask extends AsyncTask<Void, Void, String> {\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n\n            textView.setText(R.string.end_to_end_encryption_retrieving_keys);\n            positiveButton.setVisibility(View.INVISIBLE);\n            neutralButton.setVisibility(View.INVISIBLE);\n        }\n\n        @Override\n        protected String doInBackground(Void... voids) {\n            // fetch private/public key\n            // if available\n            //  - store public key\n            //  - decrypt private key, store unencrypted private key in database\n\n            GetPublicKeyOperation publicKeyOperation = new GetPublicKeyOperation();\n            RemoteOperationResult publicKeyResult = publicKeyOperation.execute(user.toPlatformAccount(), getContext());\n\n            if (publicKeyResult.isSuccess()) {\n                Log_OC.d(TAG, \"public key successful downloaded for \" + user.getAccountName());\n\n                String publicKeyFromServer = (String) publicKeyResult.getData().get(0);\n                arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(),\n                                                            EncryptionUtils.PUBLIC_KEY,\n                                                            publicKeyFromServer);\n            } else {\n                return null;\n            }\n\n            RemoteOperationResult<com.owncloud.android.lib.ocs.responses.PrivateKey> privateKeyResult =\n                new GetPrivateKeyOperation().execute(user.toPlatformAccount(), getContext());\n\n            if (privateKeyResult.isSuccess()) {\n                Log_OC.d(TAG, \"private key successful downloaded for \" + user.getAccountName());\n\n                keyResult = KEY_EXISTING_USED;\n                return privateKeyResult.getResultData().getKey();\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String privateKey) {\n            super.onPostExecute(privateKey);\n\n            if (privateKey == null) {\n                // first show info\n                try {\n                    keyWords = EncryptionUtils.getRandomWords(12, requireContext());\n                    showMnemonicInfo();\n                } catch (IOException e) {\n                    textView.setText(R.string.common_error);\n                }\n            } else if (!privateKey.isEmpty()) {\n                textView.setText(R.string.end_to_end_encryption_enter_password);\n                passwordField.setVisibility(View.VISIBLE);\n                positiveButton.setVisibility(View.VISIBLE);\n            } else {\n                Log_OC.e(TAG, \"Got empty private key string\");\n            }\n        }\n    }\n\n    public class GenerateNewKeysAsyncTask extends AsyncTask<Void, Void, String> {\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n\n            textView.setText(R.string.end_to_end_encryption_generating_keys);\n        }\n\n        @Override\n        protected String doInBackground(Void... voids) {\n            //  - create CSR, push to server, store returned public key in database\n            //  - encrypt private key, push key to server, store unencrypted private key in database\n\n            try {\n                String publicKey;\n\n                // Create public/private key pair\n                KeyPair keyPair = EncryptionUtils.generateKeyPair();\n\n                // create CSR\n                AccountManager accountManager = AccountManager.get(getContext());\n                String userId = accountManager.getUserData(user.toPlatformAccount(), AccountUtils.Constants.KEY_USER_ID);\n                String urlEncoded = CsrHelper.generateCsrPemEncodedString(keyPair, userId);\n\n                SendCSROperation operation = new SendCSROperation(urlEncoded);\n                RemoteOperationResult result = operation.execute(user.toPlatformAccount(), getContext());\n\n                if (result.isSuccess()) {\n                    Log_OC.d(TAG, \"public key success\");\n                    publicKey = (String) result.getData().get(0);\n                } else {\n                    keyResult = KEY_FAILED;\n                    return \"\";\n                }\n\n                PrivateKey privateKey = keyPair.getPrivate();\n                String privateKeyString = EncryptionUtils.encodeBytesToBase64String(privateKey.getEncoded());\n                String privatePemKeyString = EncryptionUtils.privateKeyToPEM(privateKey);\n                String encryptedPrivateKey = EncryptionUtils.encryptPrivateKey(privatePemKeyString,\n                        generateMnemonicString(false));\n\n                // upload encryptedPrivateKey\n                StorePrivateKeyOperation storePrivateKeyOperation = new StorePrivateKeyOperation(encryptedPrivateKey);\n                RemoteOperationResult storePrivateKeyResult = storePrivateKeyOperation.execute(user.toPlatformAccount(),\n                                                                                               getContext());\n\n                if (storePrivateKeyResult.isSuccess()) {\n                    Log_OC.d(TAG, \"private key success\");\n\n                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.PRIVATE_KEY,\n                            privateKeyString);\n                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.PUBLIC_KEY, publicKey);\n                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(), EncryptionUtils.MNEMONIC,\n                            generateMnemonicString(true));\n\n                    keyResult = KEY_CREATED;\n                    return (String) storePrivateKeyResult.getData().get(0);\n                } else {\n                    DeletePublicKeyOperation deletePublicKeyOperation = new DeletePublicKeyOperation();\n                    deletePublicKeyOperation.execute(user.toPlatformAccount(), getContext());\n                }\n            } catch (Exception e) {\n                Log_OC.e(TAG, e.getMessage());\n            }\n\n            keyResult = KEY_FAILED;\n            return \"\";\n        }\n\n        @Override\n        protected void onPostExecute(String s) {\n            super.onPostExecute(s);\n\n            if (s.isEmpty()) {\n                errorSavingKeys();\n            } else {\n                requireDialog().dismiss();\n\n                Intent intentExisting = new Intent();\n                intentExisting.putExtra(SUCCESS, true);\n                intentExisting.putExtra(ARG_POSITION, requireArguments().getInt(ARG_POSITION));\n                getTargetFragment().onActivityResult(getTargetRequestCode(),\n                                                     SETUP_ENCRYPTION_RESULT_CODE, intentExisting);\n            }\n        }\n    }\n\n    private String generateMnemonicString(boolean withWhitespace) {\n        StringBuilder stringBuilder = new StringBuilder();\n\n        for (String string : keyWords) {\n            stringBuilder.append(string);\n            if (withWhitespace) {\n                stringBuilder.append(' ');\n            }\n        }\n\n        return stringBuilder.toString();\n    }\n\n    @VisibleForTesting\n    public void showMnemonicInfo() {\n        requireDialog().setTitle(R.string.end_to_end_encryption_passphrase_title);\n\n        textView.setText(R.string.end_to_end_encryption_keywords_description);\n\n        passphraseTextView.setText(generateMnemonicString(true));\n\n        passphraseTextView.setVisibility(View.VISIBLE);\n        positiveButton.setText(R.string.end_to_end_encryption_confirm_button);\n        positiveButton.setVisibility(View.VISIBLE);\n\n        neutralButton.setVisibility(View.VISIBLE);\n        ThemeButtonUtils.themeBorderlessButton(positiveButton, neutralButton);\n\n        keyResult = KEY_GENERATE;\n    }\n\n    @VisibleForTesting\n    public void errorSavingKeys() {\n        keyResult = KEY_FAILED;\n\n        requireDialog().setTitle(R.string.common_error);\n        textView.setText(R.string.end_to_end_encryption_unsuccessful);\n        positiveButton.setText(R.string.end_to_end_encryption_dialog_close);\n        positiveButton.setVisibility(View.VISIBLE);\n        positiveButton.setTextColor(ThemeColorUtils.primaryAccentColor(getContext()));\n    }\n\n    @VisibleForTesting\n    public void setMnemonic(List<String> keyWords) {\n        this.keyWords = keyWords;\n    }\n}\n", "/*\n * Nextcloud Android client application\n *\n * @author Tobias Kaminsky\n * Copyright (C) 2017 Tobias Kaminsky\n * Copyright (C) 2017 Nextcloud GmbH.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.owncloud.android.utils;\n\nimport android.accounts.Account;\nimport android.content.Context;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Pair;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport com.owncloud.android.datamodel.ArbitraryDataProvider;\nimport com.owncloud.android.datamodel.DecryptedFolderMetadata;\nimport com.owncloud.android.datamodel.EncryptedFolderMetadata;\nimport com.owncloud.android.datamodel.OCFile;\nimport com.owncloud.android.lib.common.OwnCloudClient;\nimport com.owncloud.android.lib.common.operations.RemoteOperationResult;\nimport com.owncloud.android.lib.common.utils.Log_OC;\nimport com.owncloud.android.lib.resources.e2ee.GetMetadataRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.LockFileRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.StoreMetadataRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.UnlockFileRemoteOperation;\nimport com.owncloud.android.lib.resources.e2ee.UpdateMetadataRemoteOperation;\nimport com.owncloud.android.operations.UploadException;\n\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.commons.httpclient.HttpStatus;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.StandardCharsets;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.GCMParameterSpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport androidx.annotation.Nullable;\nimport androidx.annotation.VisibleForTesting;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\n/**\n * Utils for encryption\n */\npublic final class EncryptionUtils {\n    private static String TAG = EncryptionUtils.class.getSimpleName();\n\n    public static final String PUBLIC_KEY = \"PUBLIC_KEY\";\n    public static final String PRIVATE_KEY = \"PRIVATE_KEY\";\n    public static final String MNEMONIC = \"MNEMONIC\";\n    public static final int ivLength = 16;\n    public static final int saltLength = 40;\n    public static final String ivDelimiter = \"|\"; // not base64 encoded\n    public static final String ivDelimiterOld = \"fA==\"; // \"|\" base64 encoded\n\n    private static final String HASH_DELIMITER = \"$\";\n    private static final int iterationCount = 1024;\n    private static final int keyStrength = 256;\n    private static final String AES_CIPHER = \"AES/GCM/NoPadding\";\n    private static final String AES = \"AES\";\n    private static final String RSA_CIPHER = \"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\";\n    private static final String RSA = \"RSA\";\n\n    private EncryptionUtils() {\n        // utility class -> private constructor\n    }\n\n    /*\n    JSON\n     */\n\n    public static <T> T deserializeJSON(String json, TypeToken<T> type) {\n        return new Gson().fromJson(json, type.getType());\n    }\n\n    public static String serializeJSON(Object data) {\n        return new Gson().toJson(data);\n    }\n\n    /*\n    METADATA\n     */\n\n    /**\n     * Encrypt folder metaData\n     *\n     * @param decryptedFolderMetadata folder metaData to encrypt\n     * @return EncryptedFolderMetadata encrypted folder metadata\n     */\n    public static EncryptedFolderMetadata encryptFolderMetadata(DecryptedFolderMetadata decryptedFolderMetadata,\n                                                                String privateKey)\n            throws NoSuchAlgorithmException, InvalidKeyException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, BadPaddingException,\n            IllegalBlockSizeException, InvalidKeySpecException {\n\n        HashMap<String, EncryptedFolderMetadata.EncryptedFile> files = new HashMap<>();\n        EncryptedFolderMetadata encryptedFolderMetadata = new EncryptedFolderMetadata(decryptedFolderMetadata\n                .getMetadata(), files);\n\n        // Encrypt each file in \"files\"\n        for (Map.Entry<String, DecryptedFolderMetadata.DecryptedFile> entry : decryptedFolderMetadata\n                .getFiles().entrySet()) {\n            String key = entry.getKey();\n            DecryptedFolderMetadata.DecryptedFile decryptedFile = entry.getValue();\n\n            EncryptedFolderMetadata.EncryptedFile encryptedFile = new EncryptedFolderMetadata.EncryptedFile();\n            encryptedFile.setInitializationVector(decryptedFile.getInitializationVector());\n            encryptedFile.setMetadataKey(decryptedFile.getMetadataKey());\n            encryptedFile.setAuthenticationTag(decryptedFile.getAuthenticationTag());\n\n            byte[] decryptedMetadataKey = EncryptionUtils.decodeStringToBase64Bytes(EncryptionUtils.decryptStringAsymmetric(\n                    decryptedFolderMetadata.getMetadata().getMetadataKeys().get(encryptedFile.getMetadataKey()),\n                    privateKey));\n\n            // encrypt\n            String dataJson = EncryptionUtils.serializeJSON(decryptedFile.getEncrypted());\n            encryptedFile.setEncrypted(EncryptionUtils.encryptStringSymmetric(dataJson, decryptedMetadataKey));\n\n            files.put(key, encryptedFile);\n        }\n\n        return encryptedFolderMetadata;\n    }\n\n    /*\n     * decrypt folder metaData with private key\n     */\n    public static DecryptedFolderMetadata decryptFolderMetaData(EncryptedFolderMetadata encryptedFolderMetadata,\n                                                                String privateKey)\n            throws NoSuchAlgorithmException, InvalidKeyException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, BadPaddingException,\n            IllegalBlockSizeException, InvalidKeySpecException {\n\n        HashMap<String, DecryptedFolderMetadata.DecryptedFile> files = new HashMap<>();\n        DecryptedFolderMetadata decryptedFolderMetadata = new DecryptedFolderMetadata(\n                encryptedFolderMetadata.getMetadata(), files);\n\n        for (Map.Entry<String, EncryptedFolderMetadata.EncryptedFile> entry : encryptedFolderMetadata\n                .getFiles().entrySet()) {\n            String key = entry.getKey();\n            EncryptedFolderMetadata.EncryptedFile encryptedFile = entry.getValue();\n\n            DecryptedFolderMetadata.DecryptedFile decryptedFile = new DecryptedFolderMetadata.DecryptedFile();\n            decryptedFile.setInitializationVector(encryptedFile.getInitializationVector());\n            decryptedFile.setMetadataKey(encryptedFile.getMetadataKey());\n            decryptedFile.setAuthenticationTag(encryptedFile.getAuthenticationTag());\n\n            byte[] decryptedMetadataKey = EncryptionUtils.decodeStringToBase64Bytes(\n                    EncryptionUtils.decryptStringAsymmetric(decryptedFolderMetadata.getMetadata()\n                            .getMetadataKeys().get(encryptedFile.getMetadataKey()), privateKey));\n\n            // decrypt\n            String dataJson = EncryptionUtils.decryptStringSymmetric(encryptedFile.getEncrypted(), decryptedMetadataKey);\n            decryptedFile.setEncrypted(EncryptionUtils.deserializeJSON(dataJson,\n                    new TypeToken<DecryptedFolderMetadata.Data>() {\n                    }));\n\n            files.put(key, decryptedFile);\n        }\n\n        return decryptedFolderMetadata;\n    }\n\n    /**\n     * Download metadata for folder and decrypt it\n     *\n     * @return decrypted metadata or null\n     */\n    public static @Nullable\n    DecryptedFolderMetadata downloadFolderMetadata(OCFile folder, OwnCloudClient client,\n                                                   Context context, Account account) {\n        RemoteOperationResult getMetadataOperationResult = new GetMetadataRemoteOperation(folder.getLocalId())\n            .execute(client);\n\n        if (!getMetadataOperationResult.isSuccess()) {\n            return null;\n        }\n\n        // decrypt metadata\n        ArbitraryDataProvider arbitraryDataProvider = new ArbitraryDataProvider(context.getContentResolver());\n        String serializedEncryptedMetadata = (String) getMetadataOperationResult.getData().get(0);\n        String privateKey = arbitraryDataProvider.getValue(account.name, EncryptionUtils.PRIVATE_KEY);\n\n        EncryptedFolderMetadata encryptedFolderMetadata = EncryptionUtils.deserializeJSON(\n                serializedEncryptedMetadata, new TypeToken<EncryptedFolderMetadata>() {\n                });\n\n        try {\n            return EncryptionUtils.decryptFolderMetaData(encryptedFolderMetadata, privateKey);\n        } catch (Exception e) {\n            Log_OC.e(TAG, e.getMessage());\n            return null;\n        }\n    }\n\n    /*\n    BASE 64\n     */\n\n    public static byte[] encodeStringToBase64Bytes(String string) {\n        try {\n            return Base64.encode(string.getBytes(), Base64.NO_WRAP);\n        } catch (Exception e) {\n            return new byte[0];\n        }\n    }\n\n    public static String decodeBase64BytesToString(byte[] bytes) {\n        try {\n            return new String(Base64.decode(bytes, Base64.NO_WRAP));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public static String encodeBytesToBase64String(byte[] bytes) {\n        return Base64.encodeToString(bytes, Base64.NO_WRAP);\n    }\n\n    public static byte[] decodeStringToBase64Bytes(String string) {\n        return Base64.decode(string, Base64.NO_WRAP);\n    }\n\n    /*\n    ENCRYPTION\n     */\n\n    /**\n     * @param ocFile             file do crypt\n     * @param encryptionKeyBytes key, either from metadata or {@link EncryptionUtils#generateKey()}\n     * @param iv                 initialization vector, either from metadata or {@link EncryptionUtils#randomBytes(int)}\n     * @return encryptedFile with encryptedBytes and authenticationTag\n     */\n    public static EncryptedFile encryptFile(OCFile ocFile, byte[] encryptionKeyBytes, byte[] iv)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException, IOException {\n        File file = new File(ocFile.getStoragePath());\n\n        return encryptFile(file, encryptionKeyBytes, iv);\n    }\n\n    /**\n     * @param file               file do crypt\n     * @param encryptionKeyBytes key, either from metadata or {@link EncryptionUtils#generateKey()}\n     * @param iv                 initialization vector, either from metadata or {@link EncryptionUtils#randomBytes(int)}\n     * @return encryptedFile with encryptedBytes and authenticationTag\n     */\n    public static EncryptedFile encryptFile(File file, byte[] encryptionKeyBytes, byte[] iv)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException, IOException {\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n        byte[] fileBytes = new byte[(int) randomAccessFile.length()];\n        randomAccessFile.readFully(fileBytes);\n\n        byte[] cryptedBytes = cipher.doFinal(fileBytes);\n        String authenticationTag = encodeBytesToBase64String(Arrays.copyOfRange(cryptedBytes,\n                cryptedBytes.length - (128 / 8), cryptedBytes.length));\n\n        return new EncryptedFile(cryptedBytes, authenticationTag);\n    }\n\n    /**\n     * @param file               encrypted file\n     * @param encryptionKeyBytes key from metadata\n     * @param iv                 initialization vector from metadata\n     * @param authenticationTag  authenticationTag from metadata\n     * @return decrypted byte[]\n     */\n    public static byte[] decryptFile(File file, byte[] encryptionKeyBytes, byte[] iv, byte[] authenticationTag)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException, IOException {\n\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.DECRYPT_MODE, key, spec);\n\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n        byte[] fileBytes = new byte[(int) randomAccessFile.length()];\n        randomAccessFile.readFully(fileBytes);\n\n        // check authentication tag\n        byte[] extractedAuthenticationTag = Arrays.copyOfRange(fileBytes,\n                fileBytes.length - (128 / 8), fileBytes.length);\n\n        if (!Arrays.equals(extractedAuthenticationTag, authenticationTag)) {\n            throw new SecurityException(\"Tag not correct\");\n        }\n\n        return cipher.doFinal(fileBytes);\n    }\n\n    public static class EncryptedFile {\n        public byte[] encryptedBytes;\n        public String authenticationTag;\n\n        public EncryptedFile(byte[] encryptedBytes, String authenticationTag) {\n            this.encryptedBytes = encryptedBytes;\n            this.authenticationTag = authenticationTag;\n        }\n    }\n\n    /**\n     * Encrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding\n     * Asymmetric encryption, with private and public key\n     *\n     * @param string String to encrypt\n     * @param cert   contains public key in it\n     * @return encrypted string\n     */\n    public static String encryptStringAsymmetric(String string, String cert)\n            throws NoSuchAlgorithmException,\n            NoSuchPaddingException, InvalidKeyException,\n        BadPaddingException, IllegalBlockSizeException,\n        CertificateException {\n\n        Cipher cipher = Cipher.getInstance(RSA_CIPHER);\n\n        String trimmedCert = cert.replace(\"-----BEGIN CERTIFICATE-----\\n\", \"\")\n            .replace(\"-----END CERTIFICATE-----\\n\", \"\");\n        byte[] encodedCert = trimmedCert.getBytes(StandardCharsets.UTF_8);\n        byte[] decodedCert = org.apache.commons.codec.binary.Base64.decodeBase64(encodedCert);\n\n        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n        InputStream in = new ByteArrayInputStream(decodedCert);\n        X509Certificate certificate = (X509Certificate) certFactory.generateCertificate(in);\n        PublicKey realPublicKey = certificate.getPublicKey();\n\n        cipher.init(Cipher.ENCRYPT_MODE, realPublicKey);\n\n        byte[] bytes = encodeStringToBase64Bytes(string);\n        byte[] cryptedBytes = cipher.doFinal(bytes);\n\n        return encodeBytesToBase64String(cryptedBytes);\n    }\n\n    public static String encryptStringAsymmetric(String string, PublicKey publicKey) throws NoSuchPaddingException,\n        NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n        Cipher cipher = Cipher.getInstance(RSA_CIPHER);\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\n        byte[] bytes = encodeStringToBase64Bytes(string);\n        byte[] cryptedBytes = cipher.doFinal(bytes);\n\n        return encodeBytesToBase64String(cryptedBytes);\n    }\n\n\n    /**\n     * Decrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding\n     * Asymmetric encryption, with private and public key\n     *\n     * @param string           string to decrypt\n     * @param privateKeyString private key\n     * @return decrypted string\n     */\n    public static String decryptStringAsymmetric(String string, String privateKeyString)\n            throws NoSuchAlgorithmException,\n            NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException,\n        InvalidKeySpecException {\n\n        Cipher cipher = Cipher.getInstance(RSA_CIPHER);\n\n        byte[] privateKeyBytes = decodeStringToBase64Bytes(privateKeyString);\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);\n        KeyFactory kf = KeyFactory.getInstance(RSA);\n        PrivateKey privateKey = kf.generatePrivate(keySpec);\n\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n        byte[] bytes = decodeStringToBase64Bytes(string);\n        byte[] encodedBytes = cipher.doFinal(bytes);\n\n        return decodeBase64BytesToString(encodedBytes);\n    }\n\n    public static String decryptStringAsymmetric(String string, PrivateKey privateKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n        Cipher cipher = Cipher.getInstance(RSA_CIPHER);\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n        byte[] bytes = decodeStringToBase64Bytes(string);\n        byte[] encodedBytes = cipher.doFinal(bytes);\n\n        return decodeBase64BytesToString(encodedBytes);\n    }\n\n    /**\n     * Encrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding Asymmetric encryption, with private\n     * and public key\n     *\n     * @param string             String to encrypt\n     * @param encryptionKeyBytes key, either from metadata or {@link EncryptionUtils#generateKey()}\n     * @return encrypted string\n     */\n    public static String encryptStringSymmetric(String string, byte[] encryptionKeyBytes)\n        throws NoSuchPaddingException,\n        InvalidKeyException,\n        NoSuchAlgorithmException,\n        IllegalBlockSizeException,\n        BadPaddingException,\n        InvalidAlgorithmParameterException {\n        return encryptStringSymmetric(string, encryptionKeyBytes, ivDelimiter);\n    }\n\n    @VisibleForTesting\n    public static String encryptStringSymmetricOld(String string, byte[] encryptionKeyBytes)\n        throws NoSuchPaddingException,\n        InvalidKeyException,\n        NoSuchAlgorithmException,\n        IllegalBlockSizeException,\n        BadPaddingException,\n        InvalidAlgorithmParameterException {\n        return encryptStringSymmetric(string, encryptionKeyBytes, ivDelimiterOld);\n    }\n\n    private static String encryptStringSymmetric(String string,\n                                                 byte[] encryptionKeyBytes,\n                                                 String delimiter)\n        throws NoSuchAlgorithmException,\n        InvalidAlgorithmParameterException,\n        NoSuchPaddingException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException {\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n        byte[] iv = randomBytes(ivLength);\n\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n\n        byte[] bytes = encodeStringToBase64Bytes(string);\n        byte[] cryptedBytes = cipher.doFinal(bytes);\n\n        String encodedCryptedBytes = encodeBytesToBase64String(cryptedBytes);\n        String encodedIV = encodeBytesToBase64String(iv);\n\n        return encodedCryptedBytes + delimiter + encodedIV;\n    }\n\n\n    /**\n     * Decrypt string with RSA algorithm, ECB mode, OAEPWithSHA-256AndMGF1 padding\n     * Asymmetric encryption, with private and public key\n     *\n     * @param string             string to decrypt\n     * @param encryptionKeyBytes key from metadata\n     * @return decrypted string\n     */\n    public static String decryptStringSymmetric(String string, byte[] encryptionKeyBytes)\n            throws NoSuchAlgorithmException,\n            InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeyException,\n            BadPaddingException, IllegalBlockSizeException {\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n\n        String ivString;\n        int delimiterPosition = string.lastIndexOf(ivDelimiter);\n\n        if (delimiterPosition == -1) {\n            // backward compatibility\n            delimiterPosition = string.lastIndexOf(ivDelimiterOld);\n            ivString = string.substring(delimiterPosition + ivDelimiterOld.length());\n        } else {\n            ivString = string.substring(delimiterPosition + ivDelimiter.length());\n        }\n\n        String cipherString = string.substring(0, delimiterPosition);\n\n        byte[] iv = new IvParameterSpec(decodeStringToBase64Bytes(ivString)).getIV();\n\n        Key key = new SecretKeySpec(encryptionKeyBytes, AES);\n\n        GCMParameterSpec spec = new GCMParameterSpec(128, iv);\n        cipher.init(Cipher.DECRYPT_MODE, key, spec);\n\n        byte[] bytes = decodeStringToBase64Bytes(cipherString);\n        byte[] encodedBytes = cipher.doFinal(bytes);\n\n        return decodeBase64BytesToString(encodedBytes);\n    }\n\n    /**\n     * Encrypt private key with symmetric AES encryption, GCM mode mode and no padding\n     *\n     * @param privateKey byte64 encoded string representation of private key\n     * @param keyPhrase  key used for encryption, e.g. 12 random words {@link EncryptionUtils#getRandomWords(int,\n     *                   Context)}\n     * @return encrypted string, bytes first encoded base64, IV separated with \"|\", then to string\n     */\n    public static String encryptPrivateKey(String privateKey, String keyPhrase)\n        throws NoSuchPaddingException,\n        NoSuchAlgorithmException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException,\n        InvalidKeySpecException {\n        return encryptPrivateKey(privateKey, keyPhrase, ivDelimiter);\n    }\n\n    @VisibleForTesting\n    public static String encryptPrivateKeyOld(String privateKey, String keyPhrase)\n        throws NoSuchPaddingException,\n        NoSuchAlgorithmException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException,\n        InvalidKeySpecException {\n        return encryptPrivateKey(privateKey, keyPhrase, ivDelimiterOld);\n    }\n\n    private static String encryptPrivateKey(String privateKey, String keyPhrase, String delimiter)\n        throws NoSuchPaddingException,\n        NoSuchAlgorithmException,\n        InvalidKeyException,\n        BadPaddingException,\n        IllegalBlockSizeException,\n        InvalidKeySpecException {\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        byte[] salt = randomBytes(saltLength);\n        KeySpec spec = new PBEKeySpec(keyPhrase.toCharArray(), salt, iterationCount, keyStrength);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKeySpec key = new SecretKeySpec(tmp.getEncoded(), AES);\n\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] bytes = encodeStringToBase64Bytes(privateKey);\n        byte[] encrypted = cipher.doFinal(bytes);\n\n        byte[] iv = cipher.getIV();\n        String encodedIV = encodeBytesToBase64String(iv);\n        String encodedSalt = encodeBytesToBase64String(salt);\n        String encodedEncryptedBytes = encodeBytesToBase64String(encrypted);\n\n        return encodedEncryptedBytes + delimiter + encodedIV + delimiter + encodedSalt;\n    }\n\n    /**\n     * Decrypt private key with symmetric AES encryption, GCM mode mode and no padding\n     *\n     * @param privateKey byte64 encoded string representation of private key, IV separated with \"|\"\n     * @param keyPhrase  key used for encryption, e.g. 12 random words\n     *                   {@link EncryptionUtils#getRandomWords(int, Context)}\n     * @return decrypted string\n     */\n    @SuppressFBWarnings(\"UCPM_USE_CHARACTER_PARAMETERIZED_METHOD\")\n    public static String decryptPrivateKey(String privateKey, String keyPhrase) throws NoSuchPaddingException,\n            NoSuchAlgorithmException, InvalidKeyException, BadPaddingException,\n            IllegalBlockSizeException, InvalidKeySpecException, InvalidAlgorithmParameterException {\n\n        String[] strings;\n\n        // split up iv, salt\n        if (privateKey.lastIndexOf(ivDelimiter) == -1) {\n            // backward compatibility\n            strings = privateKey.split(ivDelimiterOld);\n        } else {\n            strings = privateKey.split(\"\\\\\" + ivDelimiter);\n        }\n\n        String realPrivateKey = strings[0];\n        byte[] iv = decodeStringToBase64Bytes(strings[1]);\n        byte[] salt = decodeStringToBase64Bytes(strings[2]);\n\n        Cipher cipher = Cipher.getInstance(AES_CIPHER);\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(keyPhrase.toCharArray(), salt, iterationCount, keyStrength);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKeySpec key = new SecretKeySpec(tmp.getEncoded(), AES);\n\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n\n        byte[] bytes = decodeStringToBase64Bytes(realPrivateKey);\n        byte[] decrypted = cipher.doFinal(bytes);\n\n        String pemKey = decodeBase64BytesToString(decrypted);\n\n        return pemKey.replaceAll(\"\\n\", \"\").replace(\"-----BEGIN PRIVATE KEY-----\", \"\")\n                .replace(\"-----END PRIVATE KEY-----\", \"\");\n    }\n\n    public static String privateKeyToPEM(PrivateKey privateKey) {\n        String privateKeyString = encodeBytesToBase64String(privateKey.getEncoded());\n\n        return \"-----BEGIN PRIVATE KEY-----\\n\" + privateKeyString.replaceAll(\"(.{65})\", \"$1\\n\")\n                + \"\\n-----END PRIVATE KEY-----\";\n    }\n\n    /*\n    Helper\n     */\n\n    public static String getMD5Sum(File file) {\n        FileInputStream fileInputStream = null;\n        try {\n            fileInputStream = new FileInputStream(file);\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            byte[] bytes = new byte[2048];\n            int readBytes;\n\n            while ((readBytes = fileInputStream.read(bytes)) != -1) {\n                md5.update(bytes, 0, readBytes);\n            }\n\n            return new String(Hex.encodeHex(md5.digest()));\n\n        } catch (Exception e) {\n            Log_OC.e(TAG, e.getMessage());\n        } finally {\n            if (fileInputStream != null) {\n                try {\n                    fileInputStream.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, \"Error getting MD5 checksum for file\", e);\n                }\n            }\n        }\n\n        return \"\";\n    }\n\n    public static List<String> getRandomWords(int count, Context context) throws IOException {\n        InputStream ins = context.getResources().openRawResource(context.getResources()\n                .getIdentifier(\"encryption_key_words\", \"raw\", context.getPackageName()));\n\n        InputStreamReader inputStreamReader = new InputStreamReader(ins);\n\n        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);\n\n        List<String> lines = new ArrayList<>();\n        String line;\n        while ((line = bufferedReader.readLine()) != null) {\n            lines.add(line);\n        }\n\n        SecureRandom random = new SecureRandom();\n\n        List<String> outputLines = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            int randomLine = random.nextInt(lines.size());\n            outputLines.add(lines.get(randomLine));\n        }\n\n        return outputLines;\n    }\n\n    public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(RSA);\n        keyGen.initialize(2048, new SecureRandom());\n        return keyGen.generateKeyPair();\n    }\n\n    public static byte[] generateKey() {\n        KeyGenerator keyGenerator;\n        try {\n            keyGenerator = KeyGenerator.getInstance(AES);\n            keyGenerator.init(128);\n\n            return keyGenerator.generateKey().getEncoded();\n        } catch (NoSuchAlgorithmException e) {\n            Log_OC.e(TAG, e.getMessage());\n        }\n\n        return null;\n    }\n\n    public static byte[] randomBytes(int size) {\n        SecureRandom random = new SecureRandom();\n        final byte[] iv = new byte[size];\n        random.nextBytes(iv);\n\n        return iv;\n    }\n\n    /**\n     * Generate a SHA512 with appended salt\n     *\n     * @param token token to be hashed\n     * @return SHA512 with appended salt, delimiter HASH_DELIMITER\n     */\n    public static String generateSHA512(String token) {\n        String salt = EncryptionUtils.encodeBytesToBase64String(EncryptionUtils.randomBytes(EncryptionUtils.saltLength));\n\n        return generateSHA512(token, salt);\n    }\n\n    /**\n     * Generate a SHA512 with appended salt\n     *\n     * @param token token to be hashed\n     * @return SHA512 with appended salt, delimiter HASH_DELIMITER\n     */\n    public static String generateSHA512(String token, String salt) {\n        MessageDigest digest;\n        String hashedToken = \"\";\n        byte[] hash;\n        try {\n            digest = MessageDigest.getInstance(\"SHA-512\");\n            digest.update(salt.getBytes());\n            hash = digest.digest(token.getBytes());\n\n            StringBuilder stringBuilder = new StringBuilder();\n            for (byte hashByte : hash) {\n                stringBuilder.append(Integer.toString((hashByte & 0xff) + 0x100, 16).substring(1));\n            }\n\n            stringBuilder.append(HASH_DELIMITER).append(salt);\n\n            hashedToken = stringBuilder.toString();\n\n        } catch (NoSuchAlgorithmException e) {\n            Log_OC.e(TAG, \"Generating SHA512 failed\", e);\n        }\n\n        return hashedToken;\n    }\n\n    public static boolean verifySHA512(String hashWithSalt, String compareToken) {\n        String salt = hashWithSalt.split(\"\\\\\" + HASH_DELIMITER)[1];\n\n        String newHash = generateSHA512(compareToken, salt);\n\n        return hashWithSalt.equals(newHash);\n    }\n\n    public static String lockFolder(OCFile parentFile, OwnCloudClient client) throws UploadException {\n        // Lock folder\n        LockFileRemoteOperation lockFileOperation = new LockFileRemoteOperation(parentFile.getLocalId());\n        RemoteOperationResult lockFileOperationResult = lockFileOperation.execute(client);\n\n        if (lockFileOperationResult.isSuccess() &&\n            !TextUtils.isEmpty((String) lockFileOperationResult.getData().get(0))) {\n            return (String) lockFileOperationResult.getData().get(0);\n        } else if (lockFileOperationResult.getHttpCode() == HttpStatus.SC_FORBIDDEN) {\n            throw new UploadException(\"Forbidden! Please try again later.)\");\n        } else {\n            throw new UploadException(\"Could not lock folder\");\n        }\n    }\n\n    /**\n     * @param parentFile file metadata should be retrieved for\n     * @return Pair: boolean: true: metadata already exists, false: metadata new created\n     */\n    public static Pair<Boolean, DecryptedFolderMetadata> retrieveMetadata(OCFile parentFile,\n                                                                          OwnCloudClient client,\n                                                                          String privateKey,\n                                                                          String publicKey) throws UploadException,\n        InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, BadPaddingException,\n        IllegalBlockSizeException, InvalidKeyException, InvalidKeySpecException, CertificateException {\n        GetMetadataRemoteOperation getMetadataOperation = new GetMetadataRemoteOperation(parentFile.getLocalId());\n        RemoteOperationResult getMetadataOperationResult = getMetadataOperation.execute(client);\n\n        DecryptedFolderMetadata metadata;\n\n        if (getMetadataOperationResult.isSuccess()) {\n            // decrypt metadata\n            String serializedEncryptedMetadata = (String) getMetadataOperationResult.getData().get(0);\n\n\n            EncryptedFolderMetadata encryptedFolderMetadata = EncryptionUtils.deserializeJSON(\n                serializedEncryptedMetadata, new TypeToken<EncryptedFolderMetadata>() {\n                });\n\n            return new Pair<>(Boolean.TRUE, EncryptionUtils.decryptFolderMetaData(encryptedFolderMetadata, privateKey));\n\n        } else if (getMetadataOperationResult.getHttpCode() == HttpStatus.SC_NOT_FOUND) {\n            // new metadata\n            metadata = new DecryptedFolderMetadata();\n            metadata.setMetadata(new DecryptedFolderMetadata.Metadata());\n            metadata.getMetadata().setMetadataKeys(new HashMap<>());\n            String metadataKey = EncryptionUtils.encodeBytesToBase64String(EncryptionUtils.generateKey());\n            String encryptedMetadataKey = EncryptionUtils.encryptStringAsymmetric(metadataKey, publicKey);\n            metadata.getMetadata().getMetadataKeys().put(0, encryptedMetadataKey);\n\n            return new Pair<>(Boolean.FALSE, metadata);\n        } else {\n            // TODO error\n            throw new UploadException(\"something wrong\");\n        }\n    }\n\n    public static void uploadMetadata(OCFile parentFile,\n                                      String serializedFolderMetadata,\n                                      String token,\n                                      OwnCloudClient client,\n                                      boolean metadataExists) throws UploadException {\n        RemoteOperationResult uploadMetadataOperationResult;\n        if (metadataExists) {\n            // update metadata\n            UpdateMetadataRemoteOperation storeMetadataOperation = new UpdateMetadataRemoteOperation(\n                parentFile.getLocalId(), serializedFolderMetadata, token);\n            uploadMetadataOperationResult = storeMetadataOperation.execute(client);\n        } else {\n            // store metadata\n            StoreMetadataRemoteOperation storeMetadataOperation = new StoreMetadataRemoteOperation(\n                parentFile.getLocalId(), serializedFolderMetadata);\n            uploadMetadataOperationResult = storeMetadataOperation.execute(client);\n        }\n\n        if (!uploadMetadataOperationResult.isSuccess()) {\n            throw new UploadException(\"Storing/updating metadata was not successful\");\n        }\n    }\n\n    public static RemoteOperationResult unlockFolder(OCFile parentFolder, OwnCloudClient client, String token) {\n        if (token != null) {\n            return new UnlockFileRemoteOperation(parentFolder.getLocalId(), token).execute(client);\n        } else {\n            return new RemoteOperationResult(new Exception(\"No token available\"));\n        }\n    }\n}\n"], "filenames": ["src/androidTest/java/com/owncloud/android/util/EncryptionTestIT.java", "src/main/java/com/owncloud/android/ui/dialog/SetupEncryptionDialogFragment.java", "src/main/java/com/owncloud/android/utils/EncryptionUtils.java"], "buggy_code_start_loc": [53, 54, 387], "buggy_code_end_loc": [147, 261, 425], "fixing_code_start_loc": [54, 55, 387], "fixing_code_end_loc": [177, 287, 447], "type": "CWE-212", "message": "Nextcloud Android is the Android client for the Nextcloud open source home cloud system. Due to a timeout issue the Android client may not properly clean all sensitive data on account removal. This could include sensitive key material such as the End-to-End encryption keys. It is recommended that the Nextcloud Android App is upgraded to 3.16.1", "other": {"cve": {"id": "CVE-2021-32658", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-08T19:15:08.377", "lastModified": "2022-10-25T15:47:27.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nextcloud Android is the Android client for the Nextcloud open source home cloud system. Due to a timeout issue the Android client may not properly clean all sensitive data on account removal. This could include sensitive key material such as the End-to-End encryption keys. It is recommended that the Nextcloud Android App is upgraded to 3.16.1"}, {"lang": "es", "value": "Nextcloud Android es el cliente Android para el sistema de nube dom\u00e9stica de c\u00f3digo abierto Nextcloud. Debido a un problema de tiempo de espera, el cliente de Android podr\u00eda no limpiar apropiadamente todos los datos confidenciales al eliminar la cuenta. Esto podr\u00eda incluir material clave confidencial como las claves de cifrado de Extremo a Extremo. Es recomendable actualizar la aplicaci\u00f3n Android de Nextcloud a la versi\u00f3n 3.16.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-212"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:nextcloud:*:*:*:*:*:android:*:*", "versionEndExcluding": "3.16.1", "matchCriteriaId": "8387BECC-5B20-4A16-9641-E91178BFA60D"}]}]}], "references": [{"url": "https://github.com/nextcloud/android/commit/355f3c745b464b741b20a3b96597303490c26333", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nextcloud/security-advisories/security/advisories/GHSA-g5gf-rmhm-wpxw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1189168", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nextcloud/android/commit/355f3c745b464b741b20a3b96597303490c26333"}}