{"buggy_code": ["#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/ratelimit.h>\n\n#undef LDISC_DEBUG_HANGUP\n\n#ifdef LDISC_DEBUG_HANGUP\n#define tty_ldisc_debug(tty, f, args...)\ttty_debug(tty, f, ##args)\n#else\n#define tty_ldisc_debug(tty, f, args...)\n#endif\n\n/* lockdep nested classes for tty->ldisc_sem */\nenum {\n\tLDISC_SEM_NORMAL,\n\tLDISC_SEM_OTHER,\n};\n\n\n/*\n *\tThis guards the refcounted line discipline lists. The lock\n *\tmust be taken with irqs off because there are hangup path\n *\tcallers who will do ldisc lookups and cannot sleep.\n */\n\nstatic DEFINE_RAW_SPINLOCK(tty_ldiscs_lock);\n/* Line disc dispatch table */\nstatic struct tty_ldisc_ops *tty_ldiscs[NR_LDISCS];\n\n/**\n *\ttty_register_ldisc\t-\tinstall a line discipline\n *\t@disc: ldisc number\n *\t@new_ldisc: pointer to the ldisc object\n *\n *\tInstalls a new line discipline into the kernel. The discipline\n *\tis set up as unreferenced and then made available to the kernel\n *\tfrom this point onwards.\n *\n *\tLocking:\n *\t\ttakes tty_ldiscs_lock to guard against ldisc races\n */\n\nint tty_register_ldisc(int disc, struct tty_ldisc_ops *new_ldisc)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\ttty_ldiscs[disc] = new_ldisc;\n\tnew_ldisc->num = disc;\n\tnew_ldisc->refcount = 0;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(tty_register_ldisc);\n\n/**\n *\ttty_unregister_ldisc\t-\tunload a line discipline\n *\t@disc: ldisc number\n *\t@new_ldisc: pointer to the ldisc object\n *\n *\tRemove a line discipline from the kernel providing it is not\n *\tcurrently in use.\n *\n *\tLocking:\n *\t\ttakes tty_ldiscs_lock to guard against ldisc races\n */\n\nint tty_unregister_ldisc(int disc)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tif (tty_ldiscs[disc]->refcount)\n\t\tret = -EBUSY;\n\telse\n\t\ttty_ldiscs[disc] = NULL;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(tty_unregister_ldisc);\n\nstatic struct tty_ldisc_ops *get_ldops(int disc)\n{\n\tunsigned long flags;\n\tstruct tty_ldisc_ops *ldops, *ret;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tret = ERR_PTR(-EINVAL);\n\tldops = tty_ldiscs[disc];\n\tif (ldops) {\n\t\tret = ERR_PTR(-EAGAIN);\n\t\tif (try_module_get(ldops->owner)) {\n\t\t\tldops->refcount++;\n\t\t\tret = ldops;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\treturn ret;\n}\n\nstatic void put_ldops(struct tty_ldisc_ops *ldops)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tldops->refcount--;\n\tmodule_put(ldops->owner);\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n}\n\n/**\n *\ttty_ldisc_get\t\t-\ttake a reference to an ldisc\n *\t@disc: ldisc number\n *\n *\tTakes a reference to a line discipline. Deals with refcounts and\n *\tmodule locking counts. Returns NULL if the discipline is not available.\n *\tReturns a pointer to the discipline and bumps the ref count if it is\n *\tavailable\n *\n *\tLocking:\n *\t\ttakes tty_ldiscs_lock to guard against ldisc races\n */\n\nstatic struct tty_ldisc *tty_ldisc_get(struct tty_struct *tty, int disc)\n{\n\tstruct tty_ldisc *ld;\n\tstruct tty_ldisc_ops *ldops;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Get the ldisc ops - we may need to request them to be loaded\n\t * dynamically and try again.\n\t */\n\tldops = get_ldops(disc);\n\tif (IS_ERR(ldops)) {\n\t\trequest_module(\"tty-ldisc-%d\", disc);\n\t\tldops = get_ldops(disc);\n\t\tif (IS_ERR(ldops))\n\t\t\treturn ERR_CAST(ldops);\n\t}\n\n\tld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL);\n\tif (ld == NULL) {\n\t\tput_ldops(ldops);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tld->ops = ldops;\n\tld->tty = tty;\n\n\treturn ld;\n}\n\n/**\n *\ttty_ldisc_put\t\t-\trelease the ldisc\n *\n *\tComplement of tty_ldisc_get().\n */\nstatic void tty_ldisc_put(struct tty_ldisc *ld)\n{\n\tif (WARN_ON_ONCE(!ld))\n\t\treturn;\n\n\tput_ldops(ld->ops);\n\tkfree(ld);\n}\n\nstatic void *tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)\n{\n\treturn (*pos < NR_LDISCS) ? pos : NULL;\n}\n\nstatic void *tty_ldiscs_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn (*pos < NR_LDISCS) ? pos : NULL;\n}\n\nstatic void tty_ldiscs_seq_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int tty_ldiscs_seq_show(struct seq_file *m, void *v)\n{\n\tint i = *(loff_t *)v;\n\tstruct tty_ldisc_ops *ldops;\n\n\tldops = get_ldops(i);\n\tif (IS_ERR(ldops))\n\t\treturn 0;\n\tseq_printf(m, \"%-10s %2d\\n\", ldops->name ? ldops->name : \"???\", i);\n\tput_ldops(ldops);\n\treturn 0;\n}\n\nstatic const struct seq_operations tty_ldiscs_seq_ops = {\n\t.start\t= tty_ldiscs_seq_start,\n\t.next\t= tty_ldiscs_seq_next,\n\t.stop\t= tty_ldiscs_seq_stop,\n\t.show\t= tty_ldiscs_seq_show,\n};\n\nstatic int proc_tty_ldiscs_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &tty_ldiscs_seq_ops);\n}\n\nconst struct file_operations tty_ldiscs_proc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= proc_tty_ldiscs_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\n/**\n *\ttty_ldisc_ref_wait\t-\twait for the tty ldisc\n *\t@tty: tty device\n *\n *\tDereference the line discipline for the terminal and take a\n *\treference to it. If the line discipline is in flux then\n *\twait patiently until it changes.\n *\n *\tNote: Must not be called from an IRQ/timer context. The caller\n *\tmust also be careful not to hold other locks that will deadlock\n *\tagainst a discipline change, such as an existing ldisc reference\n *\t(which we check for)\n *\n *\tNote: only callable from a file_operations routine (which\n *\tguarantees tty->ldisc != NULL when the lock is acquired).\n */\n\nstruct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *tty)\n{\n\tldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\n\tWARN_ON(!tty->ldisc);\n\treturn tty->ldisc;\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_ref_wait);\n\n/**\n *\ttty_ldisc_ref\t\t-\tget the tty ldisc\n *\t@tty: tty device\n *\n *\tDereference the line discipline for the terminal and take a\n *\treference to it. If the line discipline is in flux then\n *\treturn NULL. Can be called from IRQ and timer functions.\n */\n\nstruct tty_ldisc *tty_ldisc_ref(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = NULL;\n\n\tif (ldsem_down_read_trylock(&tty->ldisc_sem)) {\n\t\tld = tty->ldisc;\n\t\tif (!ld)\n\t\t\tldsem_up_read(&tty->ldisc_sem);\n\t}\n\treturn ld;\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_ref);\n\n/**\n *\ttty_ldisc_deref\t\t-\tfree a tty ldisc reference\n *\t@ld: reference to free up\n *\n *\tUndoes the effect of tty_ldisc_ref or tty_ldisc_ref_wait. May\n *\tbe called in IRQ context.\n */\n\nvoid tty_ldisc_deref(struct tty_ldisc *ld)\n{\n\tldsem_up_read(&ld->tty->ldisc_sem);\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_deref);\n\n\nstatic inline int __lockfunc\n__tty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\n{\n\treturn ldsem_down_write(&tty->ldisc_sem, timeout);\n}\n\nstatic inline int __lockfunc\n__tty_ldisc_lock_nested(struct tty_struct *tty, unsigned long timeout)\n{\n\treturn ldsem_down_write_nested(&tty->ldisc_sem,\n\t\t\t\t       LDISC_SEM_OTHER, timeout);\n}\n\nstatic inline void __tty_ldisc_unlock(struct tty_struct *tty)\n{\n\tldsem_up_write(&tty->ldisc_sem);\n}\n\nstatic int __lockfunc\ntty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\n{\n\tint ret;\n\n\tret = __tty_ldisc_lock(tty, timeout);\n\tif (!ret)\n\t\treturn -EBUSY;\n\tset_bit(TTY_LDISC_HALTED, &tty->flags);\n\treturn 0;\n}\n\nstatic void tty_ldisc_unlock(struct tty_struct *tty)\n{\n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\t__tty_ldisc_unlock(tty);\n}\n\nstatic int __lockfunc\ntty_ldisc_lock_pair_timeout(struct tty_struct *tty, struct tty_struct *tty2,\n\t\t\t    unsigned long timeout)\n{\n\tint ret;\n\n\tif (tty < tty2) {\n\t\tret = __tty_ldisc_lock(tty, timeout);\n\t\tif (ret) {\n\t\t\tret = __tty_ldisc_lock_nested(tty2, timeout);\n\t\t\tif (!ret)\n\t\t\t\t__tty_ldisc_unlock(tty);\n\t\t}\n\t} else {\n\t\t/* if this is possible, it has lots of implications */\n\t\tWARN_ON_ONCE(tty == tty2);\n\t\tif (tty2 && tty != tty2) {\n\t\t\tret = __tty_ldisc_lock(tty2, timeout);\n\t\t\tif (ret) {\n\t\t\t\tret = __tty_ldisc_lock_nested(tty, timeout);\n\t\t\t\tif (!ret)\n\t\t\t\t\t__tty_ldisc_unlock(tty2);\n\t\t\t}\n\t\t} else\n\t\t\tret = __tty_ldisc_lock(tty, timeout);\n\t}\n\n\tif (!ret)\n\t\treturn -EBUSY;\n\n\tset_bit(TTY_LDISC_HALTED, &tty->flags);\n\tif (tty2)\n\t\tset_bit(TTY_LDISC_HALTED, &tty2->flags);\n\treturn 0;\n}\n\nstatic void __lockfunc\ntty_ldisc_lock_pair(struct tty_struct *tty, struct tty_struct *tty2)\n{\n\ttty_ldisc_lock_pair_timeout(tty, tty2, MAX_SCHEDULE_TIMEOUT);\n}\n\nstatic void __lockfunc tty_ldisc_unlock_pair(struct tty_struct *tty,\n\t\t\t\t\t     struct tty_struct *tty2)\n{\n\t__tty_ldisc_unlock(tty);\n\tif (tty2)\n\t\t__tty_ldisc_unlock(tty2);\n}\n\n/**\n *\ttty_ldisc_flush\t-\tflush line discipline queue\n *\t@tty: tty\n *\n *\tFlush the line discipline queue (if any) and the tty flip buffers\n *\tfor this tty.\n */\n\nvoid tty_ldisc_flush(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_ref(tty);\n\n\ttty_buffer_flush(tty, ld);\n\tif (ld)\n\t\ttty_ldisc_deref(ld);\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_flush);\n\n/**\n *\ttty_set_termios_ldisc\t\t-\tset ldisc field\n *\t@tty: tty structure\n *\t@num: line discipline number\n *\n *\tThis is probably overkill for real world processors but\n *\tthey are not on hot paths so a little discipline won't do\n *\tany harm.\n *\n *\tLocking: takes termios_rwsem\n */\n\nstatic void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n}\n\n/**\n *\ttty_ldisc_open\t\t-\topen a line discipline\n *\t@tty: tty we are opening the ldisc on\n *\t@ld: discipline to open\n *\n *\tA helper opening method. Also a convenient debugging and check\n *\tpoint.\n *\n *\tLocking: always called with BTM already held.\n */\n\nstatic int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tWARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));\n\tif (ld->ops->open) {\n\t\tint ret;\n                /* BTM here locks versus a hangup event */\n\t\tret = ld->ops->open(tty);\n\t\tif (ret)\n\t\t\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\n\t\ttty_ldisc_debug(tty, \"%p: opened\\n\", tty->ldisc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n/**\n *\ttty_ldisc_close\t\t-\tclose a line discipline\n *\t@tty: tty we are opening the ldisc on\n *\t@ld: discipline to close\n *\n *\tA helper close method. Also a convenient debugging and check\n *\tpoint.\n */\n\nstatic void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tWARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));\n\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\tif (ld->ops->close)\n\t\tld->ops->close(tty);\n\ttty_ldisc_debug(tty, \"%p: closed\\n\", tty->ldisc);\n}\n\n/**\n *\ttty_ldisc_restore\t-\thelper for tty ldisc change\n *\t@tty: tty to recover\n *\t@old: previous ldisc\n *\n *\tRestore the previous line discipline or N_TTY when a line discipline\n *\tchange fails due to an open error\n */\n\nstatic void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)\n{\n\tstruct tty_ldisc *new_ldisc;\n\tint r;\n\n\t/* There is an outstanding reference here so this is safe */\n\told = tty_ldisc_get(tty, old->ops->num);\n\tWARN_ON(IS_ERR(old));\n\ttty->ldisc = old;\n\ttty_set_termios_ldisc(tty, old->ops->num);\n\tif (tty_ldisc_open(tty, old) < 0) {\n\t\ttty_ldisc_put(old);\n\t\t/* This driver is always present */\n\t\tnew_ldisc = tty_ldisc_get(tty, N_TTY);\n\t\tif (IS_ERR(new_ldisc))\n\t\t\tpanic(\"n_tty: get\");\n\t\ttty->ldisc = new_ldisc;\n\t\ttty_set_termios_ldisc(tty, N_TTY);\n\t\tr = tty_ldisc_open(tty, new_ldisc);\n\t\tif (r < 0)\n\t\t\tpanic(\"Couldn't open N_TTY ldisc for \"\n\t\t\t      \"%s --- error %d.\",\n\t\t\t      tty_name(tty), r);\n\t}\n}\n\n/**\n *\ttty_set_ldisc\t\t-\tset line discipline\n *\t@tty: the terminal to set\n *\t@ldisc: the line discipline\n *\n *\tSet the discipline of a tty line. Must be called from a process\n *\tcontext. The ldisc change logic has to protect itself against any\n *\toverlapping ldisc change (including on the other end of pty pairs),\n *\tthe close of one side of a tty/pty pair, and eventually hangup.\n */\n\nint tty_set_ldisc(struct tty_struct *tty, int ldisc)\n{\n\tint retval;\n\tstruct tty_ldisc *old_ldisc, *new_ldisc;\n\n\tnew_ldisc = tty_ldisc_get(tty, ldisc);\n\tif (IS_ERR(new_ldisc))\n\t\treturn PTR_ERR(new_ldisc);\n\n\ttty_lock(tty);\n\tretval = tty_ldisc_lock(tty, 5 * HZ);\n\tif (retval)\n\t\tgoto err;\n\n\t/* Check the no-op case */\n\tif (tty->ldisc->ops->num == ldisc)\n\t\tgoto out;\n\n\tif (test_bit(TTY_HUPPED, &tty->flags)) {\n\t\t/* We were raced by hangup */\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\told_ldisc = tty->ldisc;\n\n\t/* Shutdown the old discipline. */\n\ttty_ldisc_close(tty, old_ldisc);\n\n\t/* Now set up the new line discipline. */\n\ttty->ldisc = new_ldisc;\n\ttty_set_termios_ldisc(tty, ldisc);\n\n\tretval = tty_ldisc_open(tty, new_ldisc);\n\tif (retval < 0) {\n\t\t/* Back to the old one or N_TTY if we can't */\n\t\ttty_ldisc_put(new_ldisc);\n\t\ttty_ldisc_restore(tty, old_ldisc);\n\t}\n\n\tif (tty->ldisc->ops->num != old_ldisc->ops->num && tty->ops->set_ldisc) {\n\t\tdown_read(&tty->termios_rwsem);\n\t\ttty->ops->set_ldisc(tty);\n\t\tup_read(&tty->termios_rwsem);\n\t}\n\n\t/* At this point we hold a reference to the new ldisc and a\n\t   reference to the old ldisc, or we hold two references to\n\t   the old ldisc (if it was restored as part of error cleanup\n\t   above). In either case, releasing a single reference from\n\t   the old ldisc is correct. */\n\tnew_ldisc = old_ldisc;\nout:\n\ttty_ldisc_unlock(tty);\n\n\t/* Restart the work queue in case no characters kick it off. Safe if\n\t   already running */\n\ttty_buffer_restart_work(tty->port);\nerr:\n\ttty_ldisc_put(new_ldisc);\t/* drop the extra reference */\n\ttty_unlock(tty);\n\treturn retval;\n}\n\n/**\n *\ttty_reset_termios\t-\treset terminal state\n *\t@tty: tty to reset\n *\n *\tRestore a terminal to the driver default state.\n */\n\nstatic void tty_reset_termios(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios = tty->driver->init_termios;\n\ttty->termios.c_ispeed = tty_termios_input_baud_rate(&tty->termios);\n\ttty->termios.c_ospeed = tty_termios_baud_rate(&tty->termios);\n\tup_write(&tty->termios_rwsem);\n}\n\n\n/**\n *\ttty_ldisc_reinit\t-\treinitialise the tty ldisc\n *\t@tty: tty to reinit\n *\t@ldisc: line discipline to reinitialize\n *\n *\tSwitch the tty to a line discipline and leave the ldisc\n *\tstate closed\n */\n\nstatic int tty_ldisc_reinit(struct tty_struct *tty, int ldisc)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_get(tty, ldisc);\n\n\tif (IS_ERR(ld))\n\t\treturn -1;\n\n\ttty_ldisc_close(tty, tty->ldisc);\n\ttty_ldisc_put(tty->ldisc);\n\t/*\n\t *\tSwitch the line discipline back\n\t */\n\ttty->ldisc = ld;\n\ttty_set_termios_ldisc(tty, ldisc);\n\n\treturn 0;\n}\n\n/**\n *\ttty_ldisc_hangup\t\t-\thangup ldisc reset\n *\t@tty: tty being hung up\n *\n *\tSome tty devices reset their termios when they receive a hangup\n *\tevent. In that situation we must also switch back to N_TTY properly\n *\tbefore we reset the termios data.\n *\n *\tLocking: We can take the ldisc mutex as the rest of the code is\n *\tcareful to allow for this.\n *\n *\tIn the pty pair case this occurs in the close() path of the\n *\ttty itself so we must be careful about locking rules.\n */\n\nvoid tty_ldisc_hangup(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld;\n\tint reset = tty->driver->flags & TTY_DRIVER_RESET_TERMIOS;\n\tint err = 0;\n\n\ttty_ldisc_debug(tty, \"%p: closing\\n\", tty->ldisc);\n\n\tld = tty_ldisc_ref(tty);\n\tif (ld != NULL) {\n\t\tif (ld->ops->flush_buffer)\n\t\t\tld->ops->flush_buffer(tty);\n\t\ttty_driver_flush_buffer(tty);\n\t\tif ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&\n\t\t    ld->ops->write_wakeup)\n\t\t\tld->ops->write_wakeup(tty);\n\t\tif (ld->ops->hangup)\n\t\t\tld->ops->hangup(tty);\n\t\ttty_ldisc_deref(ld);\n\t}\n\n\twake_up_interruptible_poll(&tty->write_wait, POLLOUT);\n\twake_up_interruptible_poll(&tty->read_wait, POLLIN);\n\n\t/*\n\t * Shutdown the current line discipline, and reset it to\n\t * N_TTY if need be.\n\t *\n\t * Avoid racing set_ldisc or tty_ldisc_release\n\t */\n\ttty_ldisc_lock(tty, MAX_SCHEDULE_TIMEOUT);\n\n\tif (tty->ldisc) {\n\n\t\t/* At this point we have a halted ldisc; we want to close it and\n\t\t   reopen a new ldisc. We could defer the reopen to the next\n\t\t   open but it means auditing a lot of other paths so this is\n\t\t   a FIXME */\n\t\tif (reset == 0) {\n\n\t\t\tif (!tty_ldisc_reinit(tty, tty->termios.c_line))\n\t\t\t\terr = tty_ldisc_open(tty, tty->ldisc);\n\t\t\telse\n\t\t\t\terr = 1;\n\t\t}\n\t\t/* If the re-open fails or we reset then go to N_TTY. The\n\t\t   N_TTY open cannot fail */\n\t\tif (reset || err) {\n\t\t\tBUG_ON(tty_ldisc_reinit(tty, N_TTY));\n\t\t\tWARN_ON(tty_ldisc_open(tty, tty->ldisc));\n\t\t}\n\t}\n\ttty_ldisc_unlock(tty);\n\tif (reset)\n\t\ttty_reset_termios(tty);\n\n\ttty_ldisc_debug(tty, \"%p: re-opened\\n\", tty->ldisc);\n}\n\n/**\n *\ttty_ldisc_setup\t\t\t-\topen line discipline\n *\t@tty: tty being shut down\n *\t@o_tty: pair tty for pty/tty pairs\n *\n *\tCalled during the initial open of a tty/pty pair in order to set up the\n *\tline disciplines and bind them to the tty. This has no locking issues\n *\tas the device isn't yet active.\n */\n\nint tty_ldisc_setup(struct tty_struct *tty, struct tty_struct *o_tty)\n{\n\tstruct tty_ldisc *ld = tty->ldisc;\n\tint retval;\n\n\tretval = tty_ldisc_open(tty, ld);\n\tif (retval)\n\t\treturn retval;\n\n\tif (o_tty) {\n\t\tretval = tty_ldisc_open(o_tty, o_tty->ldisc);\n\t\tif (retval) {\n\t\t\ttty_ldisc_close(tty, ld);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void tty_ldisc_kill(struct tty_struct *tty)\n{\n\t/*\n\t * Now kill off the ldisc\n\t */\n\ttty_ldisc_close(tty, tty->ldisc);\n\ttty_ldisc_put(tty->ldisc);\n\t/* Force an oops if we mess this up */\n\ttty->ldisc = NULL;\n\n\t/* Ensure the next open requests the N_TTY ldisc */\n\ttty_set_termios_ldisc(tty, N_TTY);\n}\n\n/**\n *\ttty_ldisc_release\t\t-\trelease line discipline\n *\t@tty: tty being shut down (or one end of pty pair)\n *\n *\tCalled during the final close of a tty or a pty pair in order to shut\n *\tdown the line discpline layer. On exit, each ldisc assigned is N_TTY and\n *\teach ldisc has not been opened.\n */\n\nvoid tty_ldisc_release(struct tty_struct *tty)\n{\n\tstruct tty_struct *o_tty = tty->link;\n\n\t/*\n\t * Shutdown this line discipline. As this is the final close,\n\t * it does not race with the set_ldisc code path.\n\t */\n\n\ttty_ldisc_lock_pair(tty, o_tty);\n\ttty_ldisc_kill(tty);\n\tif (o_tty)\n\t\ttty_ldisc_kill(o_tty);\n\ttty_ldisc_unlock_pair(tty, o_tty);\n\n\t/* And the memory resources remaining (buffers, termios) will be\n\t   disposed of when the kref hits zero */\n\n\ttty_ldisc_debug(tty, \"released\\n\");\n}\n\n/**\n *\ttty_ldisc_init\t\t-\tldisc setup for new tty\n *\t@tty: tty being allocated\n *\n *\tSet up the line discipline objects for a newly allocated tty. Note that\n *\tthe tty structure is not completely set up when this call is made.\n */\n\nvoid tty_ldisc_init(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_get(tty, N_TTY);\n\tif (IS_ERR(ld))\n\t\tpanic(\"n_tty: init_tty\");\n\ttty->ldisc = ld;\n}\n\n/**\n *\ttty_ldisc_init\t\t-\tldisc cleanup for new tty\n *\t@tty: tty that was allocated recently\n *\n *\tThe tty structure must not becompletely set up (tty_ldisc_setup) when\n *      this call is made.\n */\nvoid tty_ldisc_deinit(struct tty_struct *tty)\n{\n\ttty_ldisc_put(tty->ldisc);\n\ttty->ldisc = NULL;\n}\n\nvoid tty_ldisc_begin(void)\n{\n\t/* Setup the default TTY line discipline. */\n\t(void) tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);\n}\n"], "fixing_code": ["#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/ratelimit.h>\n\n#undef LDISC_DEBUG_HANGUP\n\n#ifdef LDISC_DEBUG_HANGUP\n#define tty_ldisc_debug(tty, f, args...)\ttty_debug(tty, f, ##args)\n#else\n#define tty_ldisc_debug(tty, f, args...)\n#endif\n\n/* lockdep nested classes for tty->ldisc_sem */\nenum {\n\tLDISC_SEM_NORMAL,\n\tLDISC_SEM_OTHER,\n};\n\n\n/*\n *\tThis guards the refcounted line discipline lists. The lock\n *\tmust be taken with irqs off because there are hangup path\n *\tcallers who will do ldisc lookups and cannot sleep.\n */\n\nstatic DEFINE_RAW_SPINLOCK(tty_ldiscs_lock);\n/* Line disc dispatch table */\nstatic struct tty_ldisc_ops *tty_ldiscs[NR_LDISCS];\n\n/**\n *\ttty_register_ldisc\t-\tinstall a line discipline\n *\t@disc: ldisc number\n *\t@new_ldisc: pointer to the ldisc object\n *\n *\tInstalls a new line discipline into the kernel. The discipline\n *\tis set up as unreferenced and then made available to the kernel\n *\tfrom this point onwards.\n *\n *\tLocking:\n *\t\ttakes tty_ldiscs_lock to guard against ldisc races\n */\n\nint tty_register_ldisc(int disc, struct tty_ldisc_ops *new_ldisc)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\ttty_ldiscs[disc] = new_ldisc;\n\tnew_ldisc->num = disc;\n\tnew_ldisc->refcount = 0;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(tty_register_ldisc);\n\n/**\n *\ttty_unregister_ldisc\t-\tunload a line discipline\n *\t@disc: ldisc number\n *\t@new_ldisc: pointer to the ldisc object\n *\n *\tRemove a line discipline from the kernel providing it is not\n *\tcurrently in use.\n *\n *\tLocking:\n *\t\ttakes tty_ldiscs_lock to guard against ldisc races\n */\n\nint tty_unregister_ldisc(int disc)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tif (tty_ldiscs[disc]->refcount)\n\t\tret = -EBUSY;\n\telse\n\t\ttty_ldiscs[disc] = NULL;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(tty_unregister_ldisc);\n\nstatic struct tty_ldisc_ops *get_ldops(int disc)\n{\n\tunsigned long flags;\n\tstruct tty_ldisc_ops *ldops, *ret;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tret = ERR_PTR(-EINVAL);\n\tldops = tty_ldiscs[disc];\n\tif (ldops) {\n\t\tret = ERR_PTR(-EAGAIN);\n\t\tif (try_module_get(ldops->owner)) {\n\t\t\tldops->refcount++;\n\t\t\tret = ldops;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\treturn ret;\n}\n\nstatic void put_ldops(struct tty_ldisc_ops *ldops)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tldops->refcount--;\n\tmodule_put(ldops->owner);\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n}\n\n/**\n *\ttty_ldisc_get\t\t-\ttake a reference to an ldisc\n *\t@disc: ldisc number\n *\n *\tTakes a reference to a line discipline. Deals with refcounts and\n *\tmodule locking counts. Returns NULL if the discipline is not available.\n *\tReturns a pointer to the discipline and bumps the ref count if it is\n *\tavailable\n *\n *\tLocking:\n *\t\ttakes tty_ldiscs_lock to guard against ldisc races\n */\n\nstatic struct tty_ldisc *tty_ldisc_get(struct tty_struct *tty, int disc)\n{\n\tstruct tty_ldisc *ld;\n\tstruct tty_ldisc_ops *ldops;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Get the ldisc ops - we may need to request them to be loaded\n\t * dynamically and try again.\n\t */\n\tldops = get_ldops(disc);\n\tif (IS_ERR(ldops)) {\n\t\trequest_module(\"tty-ldisc-%d\", disc);\n\t\tldops = get_ldops(disc);\n\t\tif (IS_ERR(ldops))\n\t\t\treturn ERR_CAST(ldops);\n\t}\n\n\tld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL);\n\tif (ld == NULL) {\n\t\tput_ldops(ldops);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tld->ops = ldops;\n\tld->tty = tty;\n\n\treturn ld;\n}\n\n/**\n *\ttty_ldisc_put\t\t-\trelease the ldisc\n *\n *\tComplement of tty_ldisc_get().\n */\nstatic void tty_ldisc_put(struct tty_ldisc *ld)\n{\n\tif (WARN_ON_ONCE(!ld))\n\t\treturn;\n\n\tput_ldops(ld->ops);\n\tkfree(ld);\n}\n\nstatic void *tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)\n{\n\treturn (*pos < NR_LDISCS) ? pos : NULL;\n}\n\nstatic void *tty_ldiscs_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn (*pos < NR_LDISCS) ? pos : NULL;\n}\n\nstatic void tty_ldiscs_seq_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int tty_ldiscs_seq_show(struct seq_file *m, void *v)\n{\n\tint i = *(loff_t *)v;\n\tstruct tty_ldisc_ops *ldops;\n\n\tldops = get_ldops(i);\n\tif (IS_ERR(ldops))\n\t\treturn 0;\n\tseq_printf(m, \"%-10s %2d\\n\", ldops->name ? ldops->name : \"???\", i);\n\tput_ldops(ldops);\n\treturn 0;\n}\n\nstatic const struct seq_operations tty_ldiscs_seq_ops = {\n\t.start\t= tty_ldiscs_seq_start,\n\t.next\t= tty_ldiscs_seq_next,\n\t.stop\t= tty_ldiscs_seq_stop,\n\t.show\t= tty_ldiscs_seq_show,\n};\n\nstatic int proc_tty_ldiscs_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &tty_ldiscs_seq_ops);\n}\n\nconst struct file_operations tty_ldiscs_proc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= proc_tty_ldiscs_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\n/**\n *\ttty_ldisc_ref_wait\t-\twait for the tty ldisc\n *\t@tty: tty device\n *\n *\tDereference the line discipline for the terminal and take a\n *\treference to it. If the line discipline is in flux then\n *\twait patiently until it changes.\n *\n *\tNote: Must not be called from an IRQ/timer context. The caller\n *\tmust also be careful not to hold other locks that will deadlock\n *\tagainst a discipline change, such as an existing ldisc reference\n *\t(which we check for)\n *\n *\tNote: only callable from a file_operations routine (which\n *\tguarantees tty->ldisc != NULL when the lock is acquired).\n */\n\nstruct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *tty)\n{\n\tldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\n\tWARN_ON(!tty->ldisc);\n\treturn tty->ldisc;\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_ref_wait);\n\n/**\n *\ttty_ldisc_ref\t\t-\tget the tty ldisc\n *\t@tty: tty device\n *\n *\tDereference the line discipline for the terminal and take a\n *\treference to it. If the line discipline is in flux then\n *\treturn NULL. Can be called from IRQ and timer functions.\n */\n\nstruct tty_ldisc *tty_ldisc_ref(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = NULL;\n\n\tif (ldsem_down_read_trylock(&tty->ldisc_sem)) {\n\t\tld = tty->ldisc;\n\t\tif (!ld)\n\t\t\tldsem_up_read(&tty->ldisc_sem);\n\t}\n\treturn ld;\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_ref);\n\n/**\n *\ttty_ldisc_deref\t\t-\tfree a tty ldisc reference\n *\t@ld: reference to free up\n *\n *\tUndoes the effect of tty_ldisc_ref or tty_ldisc_ref_wait. May\n *\tbe called in IRQ context.\n */\n\nvoid tty_ldisc_deref(struct tty_ldisc *ld)\n{\n\tldsem_up_read(&ld->tty->ldisc_sem);\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_deref);\n\n\nstatic inline int __lockfunc\n__tty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\n{\n\treturn ldsem_down_write(&tty->ldisc_sem, timeout);\n}\n\nstatic inline int __lockfunc\n__tty_ldisc_lock_nested(struct tty_struct *tty, unsigned long timeout)\n{\n\treturn ldsem_down_write_nested(&tty->ldisc_sem,\n\t\t\t\t       LDISC_SEM_OTHER, timeout);\n}\n\nstatic inline void __tty_ldisc_unlock(struct tty_struct *tty)\n{\n\tldsem_up_write(&tty->ldisc_sem);\n}\n\nstatic int __lockfunc\ntty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\n{\n\tint ret;\n\n\tret = __tty_ldisc_lock(tty, timeout);\n\tif (!ret)\n\t\treturn -EBUSY;\n\tset_bit(TTY_LDISC_HALTED, &tty->flags);\n\treturn 0;\n}\n\nstatic void tty_ldisc_unlock(struct tty_struct *tty)\n{\n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\t__tty_ldisc_unlock(tty);\n}\n\nstatic int __lockfunc\ntty_ldisc_lock_pair_timeout(struct tty_struct *tty, struct tty_struct *tty2,\n\t\t\t    unsigned long timeout)\n{\n\tint ret;\n\n\tif (tty < tty2) {\n\t\tret = __tty_ldisc_lock(tty, timeout);\n\t\tif (ret) {\n\t\t\tret = __tty_ldisc_lock_nested(tty2, timeout);\n\t\t\tif (!ret)\n\t\t\t\t__tty_ldisc_unlock(tty);\n\t\t}\n\t} else {\n\t\t/* if this is possible, it has lots of implications */\n\t\tWARN_ON_ONCE(tty == tty2);\n\t\tif (tty2 && tty != tty2) {\n\t\t\tret = __tty_ldisc_lock(tty2, timeout);\n\t\t\tif (ret) {\n\t\t\t\tret = __tty_ldisc_lock_nested(tty, timeout);\n\t\t\t\tif (!ret)\n\t\t\t\t\t__tty_ldisc_unlock(tty2);\n\t\t\t}\n\t\t} else\n\t\t\tret = __tty_ldisc_lock(tty, timeout);\n\t}\n\n\tif (!ret)\n\t\treturn -EBUSY;\n\n\tset_bit(TTY_LDISC_HALTED, &tty->flags);\n\tif (tty2)\n\t\tset_bit(TTY_LDISC_HALTED, &tty2->flags);\n\treturn 0;\n}\n\nstatic void __lockfunc\ntty_ldisc_lock_pair(struct tty_struct *tty, struct tty_struct *tty2)\n{\n\ttty_ldisc_lock_pair_timeout(tty, tty2, MAX_SCHEDULE_TIMEOUT);\n}\n\nstatic void __lockfunc tty_ldisc_unlock_pair(struct tty_struct *tty,\n\t\t\t\t\t     struct tty_struct *tty2)\n{\n\t__tty_ldisc_unlock(tty);\n\tif (tty2)\n\t\t__tty_ldisc_unlock(tty2);\n}\n\n/**\n *\ttty_ldisc_flush\t-\tflush line discipline queue\n *\t@tty: tty\n *\n *\tFlush the line discipline queue (if any) and the tty flip buffers\n *\tfor this tty.\n */\n\nvoid tty_ldisc_flush(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_ref(tty);\n\n\ttty_buffer_flush(tty, ld);\n\tif (ld)\n\t\ttty_ldisc_deref(ld);\n}\nEXPORT_SYMBOL_GPL(tty_ldisc_flush);\n\n/**\n *\ttty_set_termios_ldisc\t\t-\tset ldisc field\n *\t@tty: tty structure\n *\t@num: line discipline number\n *\n *\tThis is probably overkill for real world processors but\n *\tthey are not on hot paths so a little discipline won't do\n *\tany harm.\n *\n *\tThe line discipline-related tty_struct fields are reset to\n *\tprevent the ldisc driver from re-using stale information for\n *\tthe new ldisc instance.\n *\n *\tLocking: takes termios_rwsem\n */\n\nstatic void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}\n\n/**\n *\ttty_ldisc_open\t\t-\topen a line discipline\n *\t@tty: tty we are opening the ldisc on\n *\t@ld: discipline to open\n *\n *\tA helper opening method. Also a convenient debugging and check\n *\tpoint.\n *\n *\tLocking: always called with BTM already held.\n */\n\nstatic int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tWARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));\n\tif (ld->ops->open) {\n\t\tint ret;\n                /* BTM here locks versus a hangup event */\n\t\tret = ld->ops->open(tty);\n\t\tif (ret)\n\t\t\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\n\t\ttty_ldisc_debug(tty, \"%p: opened\\n\", tty->ldisc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n/**\n *\ttty_ldisc_close\t\t-\tclose a line discipline\n *\t@tty: tty we are opening the ldisc on\n *\t@ld: discipline to close\n *\n *\tA helper close method. Also a convenient debugging and check\n *\tpoint.\n */\n\nstatic void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)\n{\n\tWARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));\n\tclear_bit(TTY_LDISC_OPEN, &tty->flags);\n\tif (ld->ops->close)\n\t\tld->ops->close(tty);\n\ttty_ldisc_debug(tty, \"%p: closed\\n\", tty->ldisc);\n}\n\n/**\n *\ttty_ldisc_restore\t-\thelper for tty ldisc change\n *\t@tty: tty to recover\n *\t@old: previous ldisc\n *\n *\tRestore the previous line discipline or N_TTY when a line discipline\n *\tchange fails due to an open error\n */\n\nstatic void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)\n{\n\tstruct tty_ldisc *new_ldisc;\n\tint r;\n\n\t/* There is an outstanding reference here so this is safe */\n\told = tty_ldisc_get(tty, old->ops->num);\n\tWARN_ON(IS_ERR(old));\n\ttty->ldisc = old;\n\ttty_set_termios_ldisc(tty, old->ops->num);\n\tif (tty_ldisc_open(tty, old) < 0) {\n\t\ttty_ldisc_put(old);\n\t\t/* This driver is always present */\n\t\tnew_ldisc = tty_ldisc_get(tty, N_TTY);\n\t\tif (IS_ERR(new_ldisc))\n\t\t\tpanic(\"n_tty: get\");\n\t\ttty->ldisc = new_ldisc;\n\t\ttty_set_termios_ldisc(tty, N_TTY);\n\t\tr = tty_ldisc_open(tty, new_ldisc);\n\t\tif (r < 0)\n\t\t\tpanic(\"Couldn't open N_TTY ldisc for \"\n\t\t\t      \"%s --- error %d.\",\n\t\t\t      tty_name(tty), r);\n\t}\n}\n\n/**\n *\ttty_set_ldisc\t\t-\tset line discipline\n *\t@tty: the terminal to set\n *\t@ldisc: the line discipline\n *\n *\tSet the discipline of a tty line. Must be called from a process\n *\tcontext. The ldisc change logic has to protect itself against any\n *\toverlapping ldisc change (including on the other end of pty pairs),\n *\tthe close of one side of a tty/pty pair, and eventually hangup.\n */\n\nint tty_set_ldisc(struct tty_struct *tty, int ldisc)\n{\n\tint retval;\n\tstruct tty_ldisc *old_ldisc, *new_ldisc;\n\n\tnew_ldisc = tty_ldisc_get(tty, ldisc);\n\tif (IS_ERR(new_ldisc))\n\t\treturn PTR_ERR(new_ldisc);\n\n\ttty_lock(tty);\n\tretval = tty_ldisc_lock(tty, 5 * HZ);\n\tif (retval)\n\t\tgoto err;\n\n\t/* Check the no-op case */\n\tif (tty->ldisc->ops->num == ldisc)\n\t\tgoto out;\n\n\tif (test_bit(TTY_HUPPED, &tty->flags)) {\n\t\t/* We were raced by hangup */\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\told_ldisc = tty->ldisc;\n\n\t/* Shutdown the old discipline. */\n\ttty_ldisc_close(tty, old_ldisc);\n\n\t/* Now set up the new line discipline. */\n\ttty->ldisc = new_ldisc;\n\ttty_set_termios_ldisc(tty, ldisc);\n\n\tretval = tty_ldisc_open(tty, new_ldisc);\n\tif (retval < 0) {\n\t\t/* Back to the old one or N_TTY if we can't */\n\t\ttty_ldisc_put(new_ldisc);\n\t\ttty_ldisc_restore(tty, old_ldisc);\n\t}\n\n\tif (tty->ldisc->ops->num != old_ldisc->ops->num && tty->ops->set_ldisc) {\n\t\tdown_read(&tty->termios_rwsem);\n\t\ttty->ops->set_ldisc(tty);\n\t\tup_read(&tty->termios_rwsem);\n\t}\n\n\t/* At this point we hold a reference to the new ldisc and a\n\t   reference to the old ldisc, or we hold two references to\n\t   the old ldisc (if it was restored as part of error cleanup\n\t   above). In either case, releasing a single reference from\n\t   the old ldisc is correct. */\n\tnew_ldisc = old_ldisc;\nout:\n\ttty_ldisc_unlock(tty);\n\n\t/* Restart the work queue in case no characters kick it off. Safe if\n\t   already running */\n\ttty_buffer_restart_work(tty->port);\nerr:\n\ttty_ldisc_put(new_ldisc);\t/* drop the extra reference */\n\ttty_unlock(tty);\n\treturn retval;\n}\n\n/**\n *\ttty_reset_termios\t-\treset terminal state\n *\t@tty: tty to reset\n *\n *\tRestore a terminal to the driver default state.\n */\n\nstatic void tty_reset_termios(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios = tty->driver->init_termios;\n\ttty->termios.c_ispeed = tty_termios_input_baud_rate(&tty->termios);\n\ttty->termios.c_ospeed = tty_termios_baud_rate(&tty->termios);\n\tup_write(&tty->termios_rwsem);\n}\n\n\n/**\n *\ttty_ldisc_reinit\t-\treinitialise the tty ldisc\n *\t@tty: tty to reinit\n *\t@ldisc: line discipline to reinitialize\n *\n *\tSwitch the tty to a line discipline and leave the ldisc\n *\tstate closed\n */\n\nstatic int tty_ldisc_reinit(struct tty_struct *tty, int ldisc)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_get(tty, ldisc);\n\n\tif (IS_ERR(ld))\n\t\treturn -1;\n\n\ttty_ldisc_close(tty, tty->ldisc);\n\ttty_ldisc_put(tty->ldisc);\n\t/*\n\t *\tSwitch the line discipline back\n\t */\n\ttty->ldisc = ld;\n\ttty_set_termios_ldisc(tty, ldisc);\n\n\treturn 0;\n}\n\n/**\n *\ttty_ldisc_hangup\t\t-\thangup ldisc reset\n *\t@tty: tty being hung up\n *\n *\tSome tty devices reset their termios when they receive a hangup\n *\tevent. In that situation we must also switch back to N_TTY properly\n *\tbefore we reset the termios data.\n *\n *\tLocking: We can take the ldisc mutex as the rest of the code is\n *\tcareful to allow for this.\n *\n *\tIn the pty pair case this occurs in the close() path of the\n *\ttty itself so we must be careful about locking rules.\n */\n\nvoid tty_ldisc_hangup(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld;\n\tint reset = tty->driver->flags & TTY_DRIVER_RESET_TERMIOS;\n\tint err = 0;\n\n\ttty_ldisc_debug(tty, \"%p: closing\\n\", tty->ldisc);\n\n\tld = tty_ldisc_ref(tty);\n\tif (ld != NULL) {\n\t\tif (ld->ops->flush_buffer)\n\t\t\tld->ops->flush_buffer(tty);\n\t\ttty_driver_flush_buffer(tty);\n\t\tif ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&\n\t\t    ld->ops->write_wakeup)\n\t\t\tld->ops->write_wakeup(tty);\n\t\tif (ld->ops->hangup)\n\t\t\tld->ops->hangup(tty);\n\t\ttty_ldisc_deref(ld);\n\t}\n\n\twake_up_interruptible_poll(&tty->write_wait, POLLOUT);\n\twake_up_interruptible_poll(&tty->read_wait, POLLIN);\n\n\t/*\n\t * Shutdown the current line discipline, and reset it to\n\t * N_TTY if need be.\n\t *\n\t * Avoid racing set_ldisc or tty_ldisc_release\n\t */\n\ttty_ldisc_lock(tty, MAX_SCHEDULE_TIMEOUT);\n\n\tif (tty->ldisc) {\n\n\t\t/* At this point we have a halted ldisc; we want to close it and\n\t\t   reopen a new ldisc. We could defer the reopen to the next\n\t\t   open but it means auditing a lot of other paths so this is\n\t\t   a FIXME */\n\t\tif (reset == 0) {\n\n\t\t\tif (!tty_ldisc_reinit(tty, tty->termios.c_line))\n\t\t\t\terr = tty_ldisc_open(tty, tty->ldisc);\n\t\t\telse\n\t\t\t\terr = 1;\n\t\t}\n\t\t/* If the re-open fails or we reset then go to N_TTY. The\n\t\t   N_TTY open cannot fail */\n\t\tif (reset || err) {\n\t\t\tBUG_ON(tty_ldisc_reinit(tty, N_TTY));\n\t\t\tWARN_ON(tty_ldisc_open(tty, tty->ldisc));\n\t\t}\n\t}\n\ttty_ldisc_unlock(tty);\n\tif (reset)\n\t\ttty_reset_termios(tty);\n\n\ttty_ldisc_debug(tty, \"%p: re-opened\\n\", tty->ldisc);\n}\n\n/**\n *\ttty_ldisc_setup\t\t\t-\topen line discipline\n *\t@tty: tty being shut down\n *\t@o_tty: pair tty for pty/tty pairs\n *\n *\tCalled during the initial open of a tty/pty pair in order to set up the\n *\tline disciplines and bind them to the tty. This has no locking issues\n *\tas the device isn't yet active.\n */\n\nint tty_ldisc_setup(struct tty_struct *tty, struct tty_struct *o_tty)\n{\n\tstruct tty_ldisc *ld = tty->ldisc;\n\tint retval;\n\n\tretval = tty_ldisc_open(tty, ld);\n\tif (retval)\n\t\treturn retval;\n\n\tif (o_tty) {\n\t\tretval = tty_ldisc_open(o_tty, o_tty->ldisc);\n\t\tif (retval) {\n\t\t\ttty_ldisc_close(tty, ld);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void tty_ldisc_kill(struct tty_struct *tty)\n{\n\t/*\n\t * Now kill off the ldisc\n\t */\n\ttty_ldisc_close(tty, tty->ldisc);\n\ttty_ldisc_put(tty->ldisc);\n\t/* Force an oops if we mess this up */\n\ttty->ldisc = NULL;\n\n\t/* Ensure the next open requests the N_TTY ldisc */\n\ttty_set_termios_ldisc(tty, N_TTY);\n}\n\n/**\n *\ttty_ldisc_release\t\t-\trelease line discipline\n *\t@tty: tty being shut down (or one end of pty pair)\n *\n *\tCalled during the final close of a tty or a pty pair in order to shut\n *\tdown the line discpline layer. On exit, each ldisc assigned is N_TTY and\n *\teach ldisc has not been opened.\n */\n\nvoid tty_ldisc_release(struct tty_struct *tty)\n{\n\tstruct tty_struct *o_tty = tty->link;\n\n\t/*\n\t * Shutdown this line discipline. As this is the final close,\n\t * it does not race with the set_ldisc code path.\n\t */\n\n\ttty_ldisc_lock_pair(tty, o_tty);\n\ttty_ldisc_kill(tty);\n\tif (o_tty)\n\t\ttty_ldisc_kill(o_tty);\n\ttty_ldisc_unlock_pair(tty, o_tty);\n\n\t/* And the memory resources remaining (buffers, termios) will be\n\t   disposed of when the kref hits zero */\n\n\ttty_ldisc_debug(tty, \"released\\n\");\n}\n\n/**\n *\ttty_ldisc_init\t\t-\tldisc setup for new tty\n *\t@tty: tty being allocated\n *\n *\tSet up the line discipline objects for a newly allocated tty. Note that\n *\tthe tty structure is not completely set up when this call is made.\n */\n\nvoid tty_ldisc_init(struct tty_struct *tty)\n{\n\tstruct tty_ldisc *ld = tty_ldisc_get(tty, N_TTY);\n\tif (IS_ERR(ld))\n\t\tpanic(\"n_tty: init_tty\");\n\ttty->ldisc = ld;\n}\n\n/**\n *\ttty_ldisc_init\t\t-\tldisc cleanup for new tty\n *\t@tty: tty that was allocated recently\n *\n *\tThe tty structure must not becompletely set up (tty_ldisc_setup) when\n *      this call is made.\n */\nvoid tty_ldisc_deinit(struct tty_struct *tty)\n{\n\ttty_ldisc_put(tty->ldisc);\n\ttty->ldisc = NULL;\n}\n\nvoid tty_ldisc_begin(void)\n{\n\t/* Setup the default TTY line discipline. */\n\t(void) tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);\n}\n"], "filenames": ["drivers/tty/tty_ldisc.c"], "buggy_code_start_loc": [419], "buggy_code_end_loc": [427], "fixing_code_start_loc": [420], "fixing_code_end_loc": [435], "type": "CWE-200", "message": "The tty_set_termios_ldisc function in drivers/tty/tty_ldisc.c in the Linux kernel before 4.5 allows local users to obtain sensitive information from kernel memory by reading a tty data structure.", "other": {"cve": {"id": "CVE-2015-8964", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:03.843", "lastModified": "2016-11-28T19:50:55.427", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The tty_set_termios_ldisc function in drivers/tty/tty_ldisc.c in the Linux kernel before 4.5 allows local users to obtain sensitive information from kernel memory by reading a tty data structure."}, {"lang": "es", "value": "La funci\u00f3n tty_set_termios_ldisc en drivers/tty/tty_ldisc.c enel kernel de Linux en versiones anteriores a 4.5 permite a los usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel mediante la lectura de una estructura de datos tty."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4.32", "matchCriteriaId": "268BB38E-3466-45EB-868F-B2262EB71CA7"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=dd42bf1197144ede075a9d4793123f7689e164bc", "source": "security@android.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94138", "source": "security@android.com"}, {"url": "https://github.com/torvalds/linux/commit/dd42bf1197144ede075a9d4793123f7689e164bc", "source": "security@android.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/dd42bf1197144ede075a9d4793123f7689e164bc"}}