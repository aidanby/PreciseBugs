{"buggy_code": ["language: node_js\nsudo: false\nnode_js:\n    - 10\n    - 12\n    - 14\nnotifications:\n    email:\n        - andris@kreata.ee\n    webhooks:\n        urls:\n            - https://webhooks.gitter.im/e/0ed18fd9b3e529b3c2cc\n        on_success: change # options: [always|never|change] default: always\n        on_failure: always # options: [always|never|change] default: always\n        on_start: false # default: false\n", "'use strict';\n\nmodule.exports = function(grunt) {\n    // Project configuration.\n    grunt.initConfig({\n        eslint: {\n            all: ['index.js', 'lib/**/*.js', 'test/**/*.js', 'examples/**/*.js', 'Gruntfile.js']\n        },\n\n        mochaTest: {\n            all: {\n                options: {\n                    reporter: 'spec'\n                },\n                src: ['test/**/*-test.js']\n            }\n        }\n    });\n\n    // Load the plugin(s)\n    grunt.loadNpmTasks('grunt-eslint');\n    grunt.loadNpmTasks('grunt-mocha-test');\n\n    // Tasks\n    grunt.registerTask('default', ['eslint', 'mochaTest']);\n};\n", "'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line\n                    .substr(0, line.indexOf(':'))\n                    .trim()\n                    .toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n", "'use strict';\n\n// module to handle cookies\n\nconst urllib = require('url');\n\nconst SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nclass Cookies {\n    constructor(options) {\n        this.options = options || {};\n        this.cookies = [];\n    }\n\n    /**\n     * Stores a cookie string to the cookie storage\n     *\n     * @param {String} cookieStr Value from the 'Set-Cookie:' header\n     * @param {String} url Current URL\n     */\n    set(cookieStr, url) {\n        let urlparts = urllib.parse(url || '');\n        let cookie = this.parse(cookieStr);\n        let domain;\n\n        if (cookie.domain) {\n            domain = cookie.domain.replace(/^\\./, '');\n\n            // do not allow cross origin cookies\n            if (\n                // can't be valid if the requested domain is shorter than current hostname\n                urlparts.hostname.length < domain.length ||\n                // prefix domains with dot to be sure that partial matches are not used\n                ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain\n            ) {\n                cookie.domain = urlparts.hostname;\n            }\n        } else {\n            cookie.domain = urlparts.hostname;\n        }\n\n        if (!cookie.path) {\n            cookie.path = this.getPath(urlparts.pathname);\n        }\n\n        // if no expire date, then use sessionTimeout value\n        if (!cookie.expires) {\n            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n        }\n\n        return this.add(cookie);\n    }\n\n    /**\n     * Returns cookie string for the 'Cookie:' header.\n     *\n     * @param {String} url URL to check for\n     * @returns {String} Cookie header or empty string if no matches were found\n     */\n    get(url) {\n        return this.list(url)\n            .map(cookie => cookie.name + '=' + cookie.value)\n            .join('; ');\n    }\n\n    /**\n     * Lists all valied cookie objects for the specified URL\n     *\n     * @param {String} url URL to check for\n     * @returns {Array} An array of cookie objects\n     */\n    list(url) {\n        let result = [];\n        let i;\n        let cookie;\n\n        for (i = this.cookies.length - 1; i >= 0; i--) {\n            cookie = this.cookies[i];\n\n            if (this.isExpired(cookie)) {\n                this.cookies.splice(i, i);\n                continue;\n            }\n\n            if (this.match(cookie, url)) {\n                result.unshift(cookie);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Parses cookie string from the 'Set-Cookie:' header\n     *\n     * @param {String} cookieStr String from the 'Set-Cookie:' header\n     * @returns {Object} Cookie object\n     */\n    parse(cookieStr) {\n        let cookie = {};\n\n        (cookieStr || '')\n            .toString()\n            .split(';')\n            .forEach(cookiePart => {\n                let valueParts = cookiePart.split('=');\n                let key = valueParts\n                    .shift()\n                    .trim()\n                    .toLowerCase();\n                let value = valueParts.join('=').trim();\n                let domain;\n\n                if (!key) {\n                    // skip empty parts\n                    return;\n                }\n\n                switch (key) {\n                    case 'expires':\n                        value = new Date(value);\n                        // ignore date if can not parse it\n                        if (value.toString() !== 'Invalid Date') {\n                            cookie.expires = value;\n                        }\n                        break;\n\n                    case 'path':\n                        cookie.path = value;\n                        break;\n\n                    case 'domain':\n                        domain = value.toLowerCase();\n                        if (domain.length && domain.charAt(0) !== '.') {\n                            domain = '.' + domain; // ensure preceeding dot for user set domains\n                        }\n                        cookie.domain = domain;\n                        break;\n\n                    case 'max-age':\n                        cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n                        break;\n\n                    case 'secure':\n                        cookie.secure = true;\n                        break;\n\n                    case 'httponly':\n                        cookie.httponly = true;\n                        break;\n\n                    default:\n                        if (!cookie.name) {\n                            cookie.name = key;\n                            cookie.value = value;\n                        }\n                }\n            });\n\n        return cookie;\n    }\n\n    /**\n     * Checks if a cookie object is valid for a specified URL\n     *\n     * @param {Object} cookie Cookie object\n     * @param {String} url URL to check for\n     * @returns {Boolean} true if cookie is valid for specifiec URL\n     */\n    match(cookie, url) {\n        let urlparts = urllib.parse(url || '');\n\n        // check if hostname matches\n        // .foo.com also matches subdomains, foo.com does not\n        if (\n            urlparts.hostname !== cookie.domain &&\n            (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)\n        ) {\n            return false;\n        }\n\n        // check if path matches\n        let path = this.getPath(urlparts.pathname);\n        if (path.substr(0, cookie.path.length) !== cookie.path) {\n            return false;\n        }\n\n        // check secure argument\n        if (cookie.secure && urlparts.protocol !== 'https:') {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Adds (or updates/removes if needed) a cookie object to the cookie storage\n     *\n     * @param {Object} cookie Cookie value to be stored\n     */\n    add(cookie) {\n        let i;\n        let len;\n\n        // nothing to do here\n        if (!cookie || !cookie.name) {\n            return false;\n        }\n\n        // overwrite if has same params\n        for (i = 0, len = this.cookies.length; i < len; i++) {\n            if (this.compare(this.cookies[i], cookie)) {\n                // check if the cookie needs to be removed instead\n                if (this.isExpired(cookie)) {\n                    this.cookies.splice(i, 1); // remove expired/unset cookie\n                    return false;\n                }\n\n                this.cookies[i] = cookie;\n                return true;\n            }\n        }\n\n        // add as new if not already expired\n        if (!this.isExpired(cookie)) {\n            this.cookies.push(cookie);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if two cookie objects are the same\n     *\n     * @param {Object} a Cookie to check against\n     * @param {Object} b Cookie to check against\n     * @returns {Boolean} True, if the cookies are the same\n     */\n    compare(a, b) {\n        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n    }\n\n    /**\n     * Checks if a cookie is expired\n     *\n     * @param {Object} cookie Cookie object to check against\n     * @returns {Boolean} True, if the cookie is expired\n     */\n    isExpired(cookie) {\n        return (cookie.expires && cookie.expires < new Date()) || !cookie.value;\n    }\n\n    /**\n     * Returns normalized cookie path for an URL path argument\n     *\n     * @param {String} pathname\n     * @returns {String} Normalized path\n     */\n    getPath(pathname) {\n        let path = (pathname || '/').split('/');\n        path.pop(); // remove filename part\n        path = path.join('/').trim();\n\n        // ensure path prefix /\n        if (path.charAt(0) !== '/') {\n            path = '/' + path;\n        }\n\n        // ensure path suffix /\n        if (path.substr(-1) !== '/') {\n            path += '/';\n        }\n\n        return path;\n    }\n}\n\nmodule.exports = Cookies;\n", "'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function(url, options) {\n    return fetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction fetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(cookie => {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    let fetchRes = options.fetchRes;\n    let parsed = urllib.parse(url);\n    let method =\n        (options.method || '')\n            .toString()\n            .trim()\n            .toUpperCase() || 'GET';\n    let finished = false;\n    let cookies;\n    let body;\n\n    let handler = parsed.protocol === 'https:' ? https : http;\n\n    let headers = {\n        'accept-encoding': 'gzip,deflate',\n        'user-agent': 'nodemailer/' + packageData.version\n    };\n\n    Object.keys(options.headers || {}).forEach(key => {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['user-agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                try {\n                    // encodeURIComponent can fail on invalid input (partial emoji etc.)\n                    body = Buffer.from(\n                        Object.keys(options.body)\n                            .map(key => {\n                                let value = options.body[key].toString().trim();\n                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                            })\n                            .join('&')\n                    );\n                } catch (E) {\n                    if (finished) {\n                        return;\n                    }\n                    finished = true;\n                    E.type = 'FETCH';\n                    E.sourceUrl = url;\n                    fetchRes.emit('error', E);\n                    return;\n                }\n            } else {\n                body = Buffer.from(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method =\n            (options.method || '')\n                .toString()\n                .trim()\n                .toUpperCase() || 'POST';\n    }\n\n    let req;\n    let reqOptions = {\n        method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n        headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(key => {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(() => {\n            E.type = 'FETCH';\n            E.sourceUrl = url;\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            let err = new Error('Request Timeout');\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n        });\n    }\n\n    req.on('error', err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', res => {\n        let inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                let err = new Error('Maximum redirect count exceeded');\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n                return;\n            }\n            // redirect does not include POST body\n            options.method = 'GET';\n            options.body = false;\n            return fetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        fetchRes.statusCode = res.statusCode;\n        fetchRes.headers = res.headers;\n\n        if (res.statusCode >= 300 && !options.allowErrorResponse) {\n            finished = true;\n            let err = new Error('Invalid status code ' + res.statusCode);\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n            return;\n        }\n\n        res.on('error', err => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(() => {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n", "'use strict';\n\nconst shared = require('../shared');\nconst MimeNode = require('../mime-node');\nconst mimeFuncs = require('../mime-funcs');\n\nclass MailMessage {\n    constructor(mailer, data) {\n        this.mailer = mailer;\n        this.data = {};\n        this.message = null;\n\n        data = data || {};\n        let options = mailer.options || {};\n        let defaults = mailer._defaults || {};\n\n        Object.keys(data).forEach(key => {\n            this.data[key] = data[key];\n        });\n\n        this.data.headers = this.data.headers || {};\n\n        // apply defaults\n        Object.keys(defaults).forEach(key => {\n            if (!(key in this.data)) {\n                this.data[key] = defaults[key];\n            } else if (key === 'headers') {\n                // headers is a special case. Allow setting individual default headers\n                Object.keys(defaults.headers).forEach(key => {\n                    if (!(key in this.data.headers)) {\n                        this.data.headers[key] = defaults.headers[key];\n                    }\n                });\n            }\n        });\n\n        // force specific keys from transporter options\n        ['disableFileAccess', 'disableUrlAccess', 'normalizeHeaderKey'].forEach(key => {\n            if (key in options) {\n                this.data[key] = options[key];\n            }\n        });\n    }\n\n    resolveContent(...args) {\n        return shared.resolveContent(...args);\n    }\n\n    resolveAll(callback) {\n        let keys = [\n            [this.data, 'html'],\n            [this.data, 'text'],\n            [this.data, 'watchHtml'],\n            [this.data, 'amp'],\n            [this.data, 'icalEvent']\n        ];\n\n        if (this.data.alternatives && this.data.alternatives.length) {\n            this.data.alternatives.forEach((alternative, i) => {\n                keys.push([this.data.alternatives, i]);\n            });\n        }\n\n        if (this.data.attachments && this.data.attachments.length) {\n            this.data.attachments.forEach((attachment, i) => {\n                if (!attachment.filename) {\n                    attachment.filename =\n                        (attachment.path || attachment.href || '')\n                            .split('/')\n                            .pop()\n                            .split('?')\n                            .shift() || 'attachment-' + (i + 1);\n                    if (attachment.filename.indexOf('.') < 0) {\n                        attachment.filename += '.' + mimeFuncs.detectExtension(attachment.contentType);\n                    }\n                }\n\n                if (!attachment.contentType) {\n                    attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');\n                }\n\n                keys.push([this.data.attachments, i]);\n            });\n        }\n\n        let mimeNode = new MimeNode();\n\n        let addressKeys = ['from', 'to', 'cc', 'bcc', 'sender', 'replyTo'];\n\n        addressKeys.forEach(address => {\n            let value;\n            if (this.message) {\n                value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === 'replyTo' ? 'reply-to' : address)) || []);\n            } else if (this.data[address]) {\n                value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);\n            }\n            if (value && value.length) {\n                this.data[address] = value;\n            } else if (address in this.data) {\n                this.data[address] = null;\n            }\n        });\n\n        let singleKeys = ['from', 'sender', 'replyTo'];\n        singleKeys.forEach(address => {\n            if (this.data[address]) {\n                this.data[address] = this.data[address].shift();\n            }\n        });\n\n        let pos = 0;\n        let resolveNext = () => {\n            if (pos >= keys.length) {\n                return callback(null, this.data);\n            }\n            let args = keys[pos++];\n            if (!args[0] || !args[0][args[1]]) {\n                return resolveNext();\n            }\n            shared.resolveContent(...args, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                let node = {\n                    content: value\n                };\n                if (args[0][args[1]] && typeof args[0][args[1]] === 'object' && !Buffer.isBuffer(args[0][args[1]])) {\n                    Object.keys(args[0][args[1]]).forEach(key => {\n                        if (!(key in node) && !['content', 'path', 'href', 'raw'].includes(key)) {\n                            node[key] = args[0][args[1]][key];\n                        }\n                    });\n                }\n\n                args[0][args[1]] = node;\n                resolveNext();\n            });\n        };\n\n        setImmediate(() => resolveNext());\n    }\n\n    normalize(callback) {\n        let envelope = this.data.envelope || this.message.getEnvelope();\n        let messageId = this.message.messageId();\n\n        this.resolveAll((err, data) => {\n            if (err) {\n                return callback(err);\n            }\n\n            data.envelope = envelope;\n            data.messageId = messageId;\n\n            ['html', 'text', 'watchHtml', 'amp'].forEach(key => {\n                if (data[key] && data[key].content) {\n                    if (typeof data[key].content === 'string') {\n                        data[key] = data[key].content;\n                    } else if (Buffer.isBuffer(data[key].content)) {\n                        data[key] = data[key].content.toString();\n                    }\n                }\n            });\n\n            if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {\n                data.icalEvent.content = data.icalEvent.content.toString('base64');\n                data.icalEvent.encoding = 'base64';\n            }\n\n            if (data.alternatives && data.alternatives.length) {\n                data.alternatives.forEach(alternative => {\n                    if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {\n                        alternative.content = alternative.content.toString('base64');\n                        alternative.encoding = 'base64';\n                    }\n                });\n            }\n\n            if (data.attachments && data.attachments.length) {\n                data.attachments.forEach(attachment => {\n                    if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {\n                        attachment.content = attachment.content.toString('base64');\n                        attachment.encoding = 'base64';\n                    }\n                });\n            }\n\n            data.normalizedHeaders = {};\n            Object.keys(data.headers || {}).forEach(key => {\n                let value = [].concat(data.headers[key] || []).shift();\n                value = (value && value.value) || value;\n                if (value) {\n                    if (['references', 'in-reply-to', 'message-id', 'content-id'].includes(key)) {\n                        value = this.message._encodeHeaderValue(key, value);\n                    }\n                    data.normalizedHeaders[key] = value;\n                }\n            });\n\n            if (data.list && typeof data.list === 'object') {\n                let listHeaders = this._getListHeaders(data.list);\n                listHeaders.forEach(entry => {\n                    data.normalizedHeaders[entry.key] = entry.value.map(val => (val && val.value) || val).join(', ');\n                });\n            }\n\n            if (data.references) {\n                data.normalizedHeaders.references = this.message._encodeHeaderValue('references', data.references);\n            }\n\n            if (data.inReplyTo) {\n                data.normalizedHeaders['in-reply-to'] = this.message._encodeHeaderValue('in-reply-to', data.inReplyTo);\n            }\n\n            return callback(null, data);\n        });\n    }\n\n    setMailerHeader() {\n        if (!this.message || !this.data.xMailer) {\n            return;\n        }\n        this.message.setHeader('X-Mailer', this.data.xMailer);\n    }\n\n    setPriorityHeaders() {\n        if (!this.message || !this.data.priority) {\n            return;\n        }\n        switch ((this.data.priority || '').toString().toLowerCase()) {\n            case 'high':\n                this.message.setHeader('X-Priority', '1 (Highest)');\n                this.message.setHeader('X-MSMail-Priority', 'High');\n                this.message.setHeader('Importance', 'High');\n                break;\n            case 'low':\n                this.message.setHeader('X-Priority', '5 (Lowest)');\n                this.message.setHeader('X-MSMail-Priority', 'Low');\n                this.message.setHeader('Importance', 'Low');\n                break;\n            default:\n            // do not add anything, since all messages are 'Normal' by default\n        }\n    }\n\n    setListHeaders() {\n        if (!this.message || !this.data.list || typeof this.data.list !== 'object') {\n            return;\n        }\n        // add optional List-* headers\n        if (this.data.list && typeof this.data.list === 'object') {\n            this._getListHeaders(this.data.list).forEach(listHeader => {\n                listHeader.value.forEach(value => {\n                    this.message.addHeader(listHeader.key, value);\n                });\n            });\n        }\n    }\n\n    _getListHeaders(listData) {\n        // make sure an url looks like <protocol:url>\n        return Object.keys(listData).map(key => ({\n            key: 'list-' + key.toLowerCase().trim(),\n            value: [].concat(listData[key] || []).map(value => ({\n                prepared: true,\n                foldLines: true,\n                value: []\n                    .concat(value || [])\n                    .map(value => {\n                        if (typeof value === 'string') {\n                            value = {\n                                url: value\n                            };\n                        }\n\n                        if (value && value.url) {\n                            if (key.toLowerCase().trim() === 'id') {\n                                // List-ID: \"comment\" <domain>\n                                let comment = value.comment || '';\n                                if (mimeFuncs.isPlainText(comment)) {\n                                    comment = '\"' + comment + '\"';\n                                } else {\n                                    comment = mimeFuncs.encodeWord(comment);\n                                }\n\n                                return (value.comment ? comment + ' ' : '') + this._formatListUrl(value.url).replace(/^<[^:]+\\/{,2}/, '');\n                            }\n\n                            // List-*: <http://domain> (comment)\n                            let comment = value.comment || '';\n                            if (!mimeFuncs.isPlainText(comment)) {\n                                comment = mimeFuncs.encodeWord(comment);\n                            }\n\n                            return this._formatListUrl(value.url) + (value.comment ? ' (' + comment + ')' : '');\n                        }\n\n                        return '';\n                    })\n                    .filter(value => value)\n                    .join(', ')\n            }))\n        }));\n    }\n\n    _formatListUrl(url) {\n        url = url.replace(/[\\s<]+|[\\s>]+/g, '');\n        if (/^(https?|mailto|ftp):/.test(url)) {\n            return '<' + url + '>';\n        }\n        if (/^[^@]+@[^@]+$/.test(url)) {\n            return '<mailto:' + url + '>';\n        }\n\n        return '<http://' + url + '>';\n    }\n}\n\nmodule.exports = MailMessage;\n", "/* eslint quote-props: 0 */\n\n'use strict';\n\nconst path = require('path');\n\nconst defaultMimeType = 'application/octet-stream';\nconst defaultExtension = 'bin';\n\nconst mimeTypes = new Map([\n    ['application/acad', 'dwg'],\n    ['application/applixware', 'aw'],\n    ['application/arj', 'arj'],\n    ['application/atom+xml', 'xml'],\n    ['application/atomcat+xml', 'atomcat'],\n    ['application/atomsvc+xml', 'atomsvc'],\n    ['application/base64', ['mm', 'mme']],\n    ['application/binhex', 'hqx'],\n    ['application/binhex4', 'hqx'],\n    ['application/book', ['book', 'boo']],\n    ['application/ccxml+xml,', 'ccxml'],\n    ['application/cdf', 'cdf'],\n    ['application/cdmi-capability', 'cdmia'],\n    ['application/cdmi-container', 'cdmic'],\n    ['application/cdmi-domain', 'cdmid'],\n    ['application/cdmi-object', 'cdmio'],\n    ['application/cdmi-queue', 'cdmiq'],\n    ['application/clariscad', 'ccad'],\n    ['application/commonground', 'dp'],\n    ['application/cu-seeme', 'cu'],\n    ['application/davmount+xml', 'davmount'],\n    ['application/drafting', 'drw'],\n    ['application/dsptype', 'tsp'],\n    ['application/dssc+der', 'dssc'],\n    ['application/dssc+xml', 'xdssc'],\n    ['application/dxf', 'dxf'],\n    ['application/ecmascript', ['js', 'es']],\n    ['application/emma+xml', 'emma'],\n    ['application/envoy', 'evy'],\n    ['application/epub+zip', 'epub'],\n    ['application/excel', ['xls', 'xl', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],\n    ['application/exi', 'exi'],\n    ['application/font-tdpfr', 'pfr'],\n    ['application/fractals', 'fif'],\n    ['application/freeloader', 'frl'],\n    ['application/futuresplash', 'spl'],\n    ['application/gnutar', 'tgz'],\n    ['application/groupwise', 'vew'],\n    ['application/hlp', 'hlp'],\n    ['application/hta', 'hta'],\n    ['application/hyperstudio', 'stk'],\n    ['application/i-deas', 'unv'],\n    ['application/iges', ['iges', 'igs']],\n    ['application/inf', 'inf'],\n    ['application/internet-property-stream', 'acx'],\n    ['application/ipfix', 'ipfix'],\n    ['application/java', 'class'],\n    ['application/java-archive', 'jar'],\n    ['application/java-byte-code', 'class'],\n    ['application/java-serialized-object', 'ser'],\n    ['application/java-vm', 'class'],\n    ['application/javascript', 'js'],\n    ['application/json', 'json'],\n    ['application/lha', 'lha'],\n    ['application/lzx', 'lzx'],\n    ['application/mac-binary', 'bin'],\n    ['application/mac-binhex', 'hqx'],\n    ['application/mac-binhex40', 'hqx'],\n    ['application/mac-compactpro', 'cpt'],\n    ['application/macbinary', 'bin'],\n    ['application/mads+xml', 'mads'],\n    ['application/marc', 'mrc'],\n    ['application/marcxml+xml', 'mrcx'],\n    ['application/mathematica', 'ma'],\n    ['application/mathml+xml', 'mathml'],\n    ['application/mbedlet', 'mbd'],\n    ['application/mbox', 'mbox'],\n    ['application/mcad', 'mcd'],\n    ['application/mediaservercontrol+xml', 'mscml'],\n    ['application/metalink4+xml', 'meta4'],\n    ['application/mets+xml', 'mets'],\n    ['application/mime', 'aps'],\n    ['application/mods+xml', 'mods'],\n    ['application/mp21', 'm21'],\n    ['application/mp4', 'mp4'],\n    ['application/mspowerpoint', ['ppt', 'pot', 'pps', 'ppz']],\n    ['application/msword', ['doc', 'dot', 'w6w', 'wiz', 'word']],\n    ['application/mswrite', 'wri'],\n    ['application/mxf', 'mxf'],\n    ['application/netmc', 'mcp'],\n    ['application/octet-stream', ['*']],\n    ['application/oda', 'oda'],\n    ['application/oebps-package+xml', 'opf'],\n    ['application/ogg', 'ogx'],\n    ['application/olescript', 'axs'],\n    ['application/onenote', 'onetoc'],\n    ['application/patch-ops-error+xml', 'xer'],\n    ['application/pdf', 'pdf'],\n    ['application/pgp-encrypted', 'asc'],\n    ['application/pgp-signature', 'pgp'],\n    ['application/pics-rules', 'prf'],\n    ['application/pkcs-12', 'p12'],\n    ['application/pkcs-crl', 'crl'],\n    ['application/pkcs10', 'p10'],\n    ['application/pkcs7-mime', ['p7c', 'p7m']],\n    ['application/pkcs7-signature', 'p7s'],\n    ['application/pkcs8', 'p8'],\n    ['application/pkix-attr-cert', 'ac'],\n    ['application/pkix-cert', ['cer', 'crt']],\n    ['application/pkix-crl', 'crl'],\n    ['application/pkix-pkipath', 'pkipath'],\n    ['application/pkixcmp', 'pki'],\n    ['application/plain', 'text'],\n    ['application/pls+xml', 'pls'],\n    ['application/postscript', ['ps', 'ai', 'eps']],\n    ['application/powerpoint', 'ppt'],\n    ['application/pro_eng', ['part', 'prt']],\n    ['application/prs.cww', 'cww'],\n    ['application/pskc+xml', 'pskcxml'],\n    ['application/rdf+xml', 'rdf'],\n    ['application/reginfo+xml', 'rif'],\n    ['application/relax-ng-compact-syntax', 'rnc'],\n    ['application/resource-lists+xml', 'rl'],\n    ['application/resource-lists-diff+xml', 'rld'],\n    ['application/ringing-tones', 'rng'],\n    ['application/rls-services+xml', 'rs'],\n    ['application/rsd+xml', 'rsd'],\n    ['application/rss+xml', 'xml'],\n    ['application/rtf', ['rtf', 'rtx']],\n    ['application/sbml+xml', 'sbml'],\n    ['application/scvp-cv-request', 'scq'],\n    ['application/scvp-cv-response', 'scs'],\n    ['application/scvp-vp-request', 'spq'],\n    ['application/scvp-vp-response', 'spp'],\n    ['application/sdp', 'sdp'],\n    ['application/sea', 'sea'],\n    ['application/set', 'set'],\n    ['application/set-payment-initiation', 'setpay'],\n    ['application/set-registration-initiation', 'setreg'],\n    ['application/shf+xml', 'shf'],\n    ['application/sla', 'stl'],\n    ['application/smil', ['smi', 'smil']],\n    ['application/smil+xml', 'smi'],\n    ['application/solids', 'sol'],\n    ['application/sounder', 'sdr'],\n    ['application/sparql-query', 'rq'],\n    ['application/sparql-results+xml', 'srx'],\n    ['application/srgs', 'gram'],\n    ['application/srgs+xml', 'grxml'],\n    ['application/sru+xml', 'sru'],\n    ['application/ssml+xml', 'ssml'],\n    ['application/step', ['step', 'stp']],\n    ['application/streamingmedia', 'ssm'],\n    ['application/tei+xml', 'tei'],\n    ['application/thraud+xml', 'tfi'],\n    ['application/timestamped-data', 'tsd'],\n    ['application/toolbook', 'tbk'],\n    ['application/vda', 'vda'],\n    ['application/vnd.3gpp.pic-bw-large', 'plb'],\n    ['application/vnd.3gpp.pic-bw-small', 'psb'],\n    ['application/vnd.3gpp.pic-bw-var', 'pvb'],\n    ['application/vnd.3gpp2.tcap', 'tcap'],\n    ['application/vnd.3m.post-it-notes', 'pwn'],\n    ['application/vnd.accpac.simply.aso', 'aso'],\n    ['application/vnd.accpac.simply.imp', 'imp'],\n    ['application/vnd.acucobol', 'acu'],\n    ['application/vnd.acucorp', 'atc'],\n    ['application/vnd.adobe.air-application-installer-package+zip', 'air'],\n    ['application/vnd.adobe.fxp', 'fxp'],\n    ['application/vnd.adobe.xdp+xml', 'xdp'],\n    ['application/vnd.adobe.xfdf', 'xfdf'],\n    ['application/vnd.ahead.space', 'ahead'],\n    ['application/vnd.airzip.filesecure.azf', 'azf'],\n    ['application/vnd.airzip.filesecure.azs', 'azs'],\n    ['application/vnd.amazon.ebook', 'azw'],\n    ['application/vnd.americandynamics.acc', 'acc'],\n    ['application/vnd.amiga.ami', 'ami'],\n    ['application/vnd.android.package-archive', 'apk'],\n    ['application/vnd.anser-web-certificate-issue-initiation', 'cii'],\n    ['application/vnd.anser-web-funds-transfer-initiation', 'fti'],\n    ['application/vnd.antix.game-component', 'atx'],\n    ['application/vnd.apple.installer+xml', 'mpkg'],\n    ['application/vnd.apple.mpegurl', 'm3u8'],\n    ['application/vnd.aristanetworks.swi', 'swi'],\n    ['application/vnd.audiograph', 'aep'],\n    ['application/vnd.blueice.multipass', 'mpm'],\n    ['application/vnd.bmi', 'bmi'],\n    ['application/vnd.businessobjects', 'rep'],\n    ['application/vnd.chemdraw+xml', 'cdxml'],\n    ['application/vnd.chipnuts.karaoke-mmd', 'mmd'],\n    ['application/vnd.cinderella', 'cdy'],\n    ['application/vnd.claymore', 'cla'],\n    ['application/vnd.cloanto.rp9', 'rp9'],\n    ['application/vnd.clonk.c4group', 'c4g'],\n    ['application/vnd.cluetrust.cartomobile-config', 'c11amc'],\n    ['application/vnd.cluetrust.cartomobile-config-pkg', 'c11amz'],\n    ['application/vnd.commonspace', 'csp'],\n    ['application/vnd.contact.cmsg', 'cdbcmsg'],\n    ['application/vnd.cosmocaller', 'cmc'],\n    ['application/vnd.crick.clicker', 'clkx'],\n    ['application/vnd.crick.clicker.keyboard', 'clkk'],\n    ['application/vnd.crick.clicker.palette', 'clkp'],\n    ['application/vnd.crick.clicker.template', 'clkt'],\n    ['application/vnd.crick.clicker.wordbank', 'clkw'],\n    ['application/vnd.criticaltools.wbs+xml', 'wbs'],\n    ['application/vnd.ctc-posml', 'pml'],\n    ['application/vnd.cups-ppd', 'ppd'],\n    ['application/vnd.curl.car', 'car'],\n    ['application/vnd.curl.pcurl', 'pcurl'],\n    ['application/vnd.data-vision.rdz', 'rdz'],\n    ['application/vnd.denovo.fcselayout-link', 'fe_launch'],\n    ['application/vnd.dna', 'dna'],\n    ['application/vnd.dolby.mlp', 'mlp'],\n    ['application/vnd.dpgraph', 'dpg'],\n    ['application/vnd.dreamfactory', 'dfac'],\n    ['application/vnd.dvb.ait', 'ait'],\n    ['application/vnd.dvb.service', 'svc'],\n    ['application/vnd.dynageo', 'geo'],\n    ['application/vnd.ecowin.chart', 'mag'],\n    ['application/vnd.enliven', 'nml'],\n    ['application/vnd.epson.esf', 'esf'],\n    ['application/vnd.epson.msf', 'msf'],\n    ['application/vnd.epson.quickanime', 'qam'],\n    ['application/vnd.epson.salt', 'slt'],\n    ['application/vnd.epson.ssf', 'ssf'],\n    ['application/vnd.eszigno3+xml', 'es3'],\n    ['application/vnd.ezpix-album', 'ez2'],\n    ['application/vnd.ezpix-package', 'ez3'],\n    ['application/vnd.fdf', 'fdf'],\n    ['application/vnd.fdsn.seed', 'seed'],\n    ['application/vnd.flographit', 'gph'],\n    ['application/vnd.fluxtime.clip', 'ftc'],\n    ['application/vnd.framemaker', 'fm'],\n    ['application/vnd.frogans.fnc', 'fnc'],\n    ['application/vnd.frogans.ltf', 'ltf'],\n    ['application/vnd.fsc.weblaunch', 'fsc'],\n    ['application/vnd.fujitsu.oasys', 'oas'],\n    ['application/vnd.fujitsu.oasys2', 'oa2'],\n    ['application/vnd.fujitsu.oasys3', 'oa3'],\n    ['application/vnd.fujitsu.oasysgp', 'fg5'],\n    ['application/vnd.fujitsu.oasysprs', 'bh2'],\n    ['application/vnd.fujixerox.ddd', 'ddd'],\n    ['application/vnd.fujixerox.docuworks', 'xdw'],\n    ['application/vnd.fujixerox.docuworks.binder', 'xbd'],\n    ['application/vnd.fuzzysheet', 'fzs'],\n    ['application/vnd.genomatix.tuxedo', 'txd'],\n    ['application/vnd.geogebra.file', 'ggb'],\n    ['application/vnd.geogebra.tool', 'ggt'],\n    ['application/vnd.geometry-explorer', 'gex'],\n    ['application/vnd.geonext', 'gxt'],\n    ['application/vnd.geoplan', 'g2w'],\n    ['application/vnd.geospace', 'g3w'],\n    ['application/vnd.gmx', 'gmx'],\n    ['application/vnd.google-earth.kml+xml', 'kml'],\n    ['application/vnd.google-earth.kmz', 'kmz'],\n    ['application/vnd.grafeq', 'gqf'],\n    ['application/vnd.groove-account', 'gac'],\n    ['application/vnd.groove-help', 'ghf'],\n    ['application/vnd.groove-identity-message', 'gim'],\n    ['application/vnd.groove-injector', 'grv'],\n    ['application/vnd.groove-tool-message', 'gtm'],\n    ['application/vnd.groove-tool-template', 'tpl'],\n    ['application/vnd.groove-vcard', 'vcg'],\n    ['application/vnd.hal+xml', 'hal'],\n    ['application/vnd.handheld-entertainment+xml', 'zmm'],\n    ['application/vnd.hbci', 'hbci'],\n    ['application/vnd.hhe.lesson-player', 'les'],\n    ['application/vnd.hp-hpgl', ['hgl', 'hpg', 'hpgl']],\n    ['application/vnd.hp-hpid', 'hpid'],\n    ['application/vnd.hp-hps', 'hps'],\n    ['application/vnd.hp-jlyt', 'jlt'],\n    ['application/vnd.hp-pcl', 'pcl'],\n    ['application/vnd.hp-pclxl', 'pclxl'],\n    ['application/vnd.hydrostatix.sof-data', 'sfd-hdstx'],\n    ['application/vnd.hzn-3d-crossword', 'x3d'],\n    ['application/vnd.ibm.minipay', 'mpy'],\n    ['application/vnd.ibm.modcap', 'afp'],\n    ['application/vnd.ibm.rights-management', 'irm'],\n    ['application/vnd.ibm.secure-container', 'sc'],\n    ['application/vnd.iccprofile', 'icc'],\n    ['application/vnd.igloader', 'igl'],\n    ['application/vnd.immervision-ivp', 'ivp'],\n    ['application/vnd.immervision-ivu', 'ivu'],\n    ['application/vnd.insors.igm', 'igm'],\n    ['application/vnd.intercon.formnet', 'xpw'],\n    ['application/vnd.intergeo', 'i2g'],\n    ['application/vnd.intu.qbo', 'qbo'],\n    ['application/vnd.intu.qfx', 'qfx'],\n    ['application/vnd.ipunplugged.rcprofile', 'rcprofile'],\n    ['application/vnd.irepository.package+xml', 'irp'],\n    ['application/vnd.is-xpr', 'xpr'],\n    ['application/vnd.isac.fcs', 'fcs'],\n    ['application/vnd.jam', 'jam'],\n    ['application/vnd.jcp.javame.midlet-rms', 'rms'],\n    ['application/vnd.jisp', 'jisp'],\n    ['application/vnd.joost.joda-archive', 'joda'],\n    ['application/vnd.kahootz', 'ktz'],\n    ['application/vnd.kde.karbon', 'karbon'],\n    ['application/vnd.kde.kchart', 'chrt'],\n    ['application/vnd.kde.kformula', 'kfo'],\n    ['application/vnd.kde.kivio', 'flw'],\n    ['application/vnd.kde.kontour', 'kon'],\n    ['application/vnd.kde.kpresenter', 'kpr'],\n    ['application/vnd.kde.kspread', 'ksp'],\n    ['application/vnd.kde.kword', 'kwd'],\n    ['application/vnd.kenameaapp', 'htke'],\n    ['application/vnd.kidspiration', 'kia'],\n    ['application/vnd.kinar', 'kne'],\n    ['application/vnd.koan', 'skp'],\n    ['application/vnd.kodak-descriptor', 'sse'],\n    ['application/vnd.las.las+xml', 'lasxml'],\n    ['application/vnd.llamagraphics.life-balance.desktop', 'lbd'],\n    ['application/vnd.llamagraphics.life-balance.exchange+xml', 'lbe'],\n    ['application/vnd.lotus-1-2-3', '123'],\n    ['application/vnd.lotus-approach', 'apr'],\n    ['application/vnd.lotus-freelance', 'pre'],\n    ['application/vnd.lotus-notes', 'nsf'],\n    ['application/vnd.lotus-organizer', 'org'],\n    ['application/vnd.lotus-screencam', 'scm'],\n    ['application/vnd.lotus-wordpro', 'lwp'],\n    ['application/vnd.macports.portpkg', 'portpkg'],\n    ['application/vnd.mcd', 'mcd'],\n    ['application/vnd.medcalcdata', 'mc1'],\n    ['application/vnd.mediastation.cdkey', 'cdkey'],\n    ['application/vnd.mfer', 'mwf'],\n    ['application/vnd.mfmp', 'mfm'],\n    ['application/vnd.micrografx.flo', 'flo'],\n    ['application/vnd.micrografx.igx', 'igx'],\n    ['application/vnd.mif', 'mif'],\n    ['application/vnd.mobius.daf', 'daf'],\n    ['application/vnd.mobius.dis', 'dis'],\n    ['application/vnd.mobius.mbk', 'mbk'],\n    ['application/vnd.mobius.mqy', 'mqy'],\n    ['application/vnd.mobius.msl', 'msl'],\n    ['application/vnd.mobius.plc', 'plc'],\n    ['application/vnd.mobius.txf', 'txf'],\n    ['application/vnd.mophun.application', 'mpn'],\n    ['application/vnd.mophun.certificate', 'mpc'],\n    ['application/vnd.mozilla.xul+xml', 'xul'],\n    ['application/vnd.ms-artgalry', 'cil'],\n    ['application/vnd.ms-cab-compressed', 'cab'],\n    ['application/vnd.ms-excel', ['xls', 'xla', 'xlc', 'xlm', 'xlt', 'xlw', 'xlb', 'xll']],\n    ['application/vnd.ms-excel.addin.macroenabled.12', 'xlam'],\n    ['application/vnd.ms-excel.sheet.binary.macroenabled.12', 'xlsb'],\n    ['application/vnd.ms-excel.sheet.macroenabled.12', 'xlsm'],\n    ['application/vnd.ms-excel.template.macroenabled.12', 'xltm'],\n    ['application/vnd.ms-fontobject', 'eot'],\n    ['application/vnd.ms-htmlhelp', 'chm'],\n    ['application/vnd.ms-ims', 'ims'],\n    ['application/vnd.ms-lrm', 'lrm'],\n    ['application/vnd.ms-officetheme', 'thmx'],\n    ['application/vnd.ms-outlook', 'msg'],\n    ['application/vnd.ms-pki.certstore', 'sst'],\n    ['application/vnd.ms-pki.pko', 'pko'],\n    ['application/vnd.ms-pki.seccat', 'cat'],\n    ['application/vnd.ms-pki.stl', 'stl'],\n    ['application/vnd.ms-pkicertstore', 'sst'],\n    ['application/vnd.ms-pkiseccat', 'cat'],\n    ['application/vnd.ms-pkistl', 'stl'],\n    ['application/vnd.ms-powerpoint', ['ppt', 'pot', 'pps', 'ppa', 'pwz']],\n    ['application/vnd.ms-powerpoint.addin.macroenabled.12', 'ppam'],\n    ['application/vnd.ms-powerpoint.presentation.macroenabled.12', 'pptm'],\n    ['application/vnd.ms-powerpoint.slide.macroenabled.12', 'sldm'],\n    ['application/vnd.ms-powerpoint.slideshow.macroenabled.12', 'ppsm'],\n    ['application/vnd.ms-powerpoint.template.macroenabled.12', 'potm'],\n    ['application/vnd.ms-project', 'mpp'],\n    ['application/vnd.ms-word.document.macroenabled.12', 'docm'],\n    ['application/vnd.ms-word.template.macroenabled.12', 'dotm'],\n    ['application/vnd.ms-works', ['wks', 'wcm', 'wdb', 'wps']],\n    ['application/vnd.ms-wpl', 'wpl'],\n    ['application/vnd.ms-xpsdocument', 'xps'],\n    ['application/vnd.mseq', 'mseq'],\n    ['application/vnd.musician', 'mus'],\n    ['application/vnd.muvee.style', 'msty'],\n    ['application/vnd.neurolanguage.nlu', 'nlu'],\n    ['application/vnd.noblenet-directory', 'nnd'],\n    ['application/vnd.noblenet-sealer', 'nns'],\n    ['application/vnd.noblenet-web', 'nnw'],\n    ['application/vnd.nokia.configuration-message', 'ncm'],\n    ['application/vnd.nokia.n-gage.data', 'ngdat'],\n    ['application/vnd.nokia.n-gage.symbian.install', 'n-gage'],\n    ['application/vnd.nokia.radio-preset', 'rpst'],\n    ['application/vnd.nokia.radio-presets', 'rpss'],\n    ['application/vnd.nokia.ringing-tone', 'rng'],\n    ['application/vnd.novadigm.edm', 'edm'],\n    ['application/vnd.novadigm.edx', 'edx'],\n    ['application/vnd.novadigm.ext', 'ext'],\n    ['application/vnd.oasis.opendocument.chart', 'odc'],\n    ['application/vnd.oasis.opendocument.chart-template', 'otc'],\n    ['application/vnd.oasis.opendocument.database', 'odb'],\n    ['application/vnd.oasis.opendocument.formula', 'odf'],\n    ['application/vnd.oasis.opendocument.formula-template', 'odft'],\n    ['application/vnd.oasis.opendocument.graphics', 'odg'],\n    ['application/vnd.oasis.opendocument.graphics-template', 'otg'],\n    ['application/vnd.oasis.opendocument.image', 'odi'],\n    ['application/vnd.oasis.opendocument.image-template', 'oti'],\n    ['application/vnd.oasis.opendocument.presentation', 'odp'],\n    ['application/vnd.oasis.opendocument.presentation-template', 'otp'],\n    ['application/vnd.oasis.opendocument.spreadsheet', 'ods'],\n    ['application/vnd.oasis.opendocument.spreadsheet-template', 'ots'],\n    ['application/vnd.oasis.opendocument.text', 'odt'],\n    ['application/vnd.oasis.opendocument.text-master', 'odm'],\n    ['application/vnd.oasis.opendocument.text-template', 'ott'],\n    ['application/vnd.oasis.opendocument.text-web', 'oth'],\n    ['application/vnd.olpc-sugar', 'xo'],\n    ['application/vnd.oma.dd2+xml', 'dd2'],\n    ['application/vnd.openofficeorg.extension', 'oxt'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.presentation', 'pptx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.slide', 'sldx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.slideshow', 'ppsx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.template', 'potx'],\n    ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'xlsx'],\n    ['application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'xltx'],\n    ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'docx'],\n    ['application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'dotx'],\n    ['application/vnd.osgeo.mapguide.package', 'mgp'],\n    ['application/vnd.osgi.dp', 'dp'],\n    ['application/vnd.palm', 'pdb'],\n    ['application/vnd.pawaafile', 'paw'],\n    ['application/vnd.pg.format', 'str'],\n    ['application/vnd.pg.osasli', 'ei6'],\n    ['application/vnd.picsel', 'efif'],\n    ['application/vnd.pmi.widget', 'wg'],\n    ['application/vnd.pocketlearn', 'plf'],\n    ['application/vnd.powerbuilder6', 'pbd'],\n    ['application/vnd.previewsystems.box', 'box'],\n    ['application/vnd.proteus.magazine', 'mgz'],\n    ['application/vnd.publishare-delta-tree', 'qps'],\n    ['application/vnd.pvi.ptid1', 'ptid'],\n    ['application/vnd.quark.quarkxpress', 'qxd'],\n    ['application/vnd.realvnc.bed', 'bed'],\n    ['application/vnd.recordare.musicxml', 'mxl'],\n    ['application/vnd.recordare.musicxml+xml', 'musicxml'],\n    ['application/vnd.rig.cryptonote', 'cryptonote'],\n    ['application/vnd.rim.cod', 'cod'],\n    ['application/vnd.rn-realmedia', 'rm'],\n    ['application/vnd.rn-realplayer', 'rnx'],\n    ['application/vnd.route66.link66+xml', 'link66'],\n    ['application/vnd.sailingtracker.track', 'st'],\n    ['application/vnd.seemail', 'see'],\n    ['application/vnd.sema', 'sema'],\n    ['application/vnd.semd', 'semd'],\n    ['application/vnd.semf', 'semf'],\n    ['application/vnd.shana.informed.formdata', 'ifm'],\n    ['application/vnd.shana.informed.formtemplate', 'itp'],\n    ['application/vnd.shana.informed.interchange', 'iif'],\n    ['application/vnd.shana.informed.package', 'ipk'],\n    ['application/vnd.simtech-mindmapper', 'twd'],\n    ['application/vnd.smaf', 'mmf'],\n    ['application/vnd.smart.teacher', 'teacher'],\n    ['application/vnd.solent.sdkm+xml', 'sdkm'],\n    ['application/vnd.spotfire.dxp', 'dxp'],\n    ['application/vnd.spotfire.sfs', 'sfs'],\n    ['application/vnd.stardivision.calc', 'sdc'],\n    ['application/vnd.stardivision.draw', 'sda'],\n    ['application/vnd.stardivision.impress', 'sdd'],\n    ['application/vnd.stardivision.math', 'smf'],\n    ['application/vnd.stardivision.writer', 'sdw'],\n    ['application/vnd.stardivision.writer-global', 'sgl'],\n    ['application/vnd.stepmania.stepchart', 'sm'],\n    ['application/vnd.sun.xml.calc', 'sxc'],\n    ['application/vnd.sun.xml.calc.template', 'stc'],\n    ['application/vnd.sun.xml.draw', 'sxd'],\n    ['application/vnd.sun.xml.draw.template', 'std'],\n    ['application/vnd.sun.xml.impress', 'sxi'],\n    ['application/vnd.sun.xml.impress.template', 'sti'],\n    ['application/vnd.sun.xml.math', 'sxm'],\n    ['application/vnd.sun.xml.writer', 'sxw'],\n    ['application/vnd.sun.xml.writer.global', 'sxg'],\n    ['application/vnd.sun.xml.writer.template', 'stw'],\n    ['application/vnd.sus-calendar', 'sus'],\n    ['application/vnd.svd', 'svd'],\n    ['application/vnd.symbian.install', 'sis'],\n    ['application/vnd.syncml+xml', 'xsm'],\n    ['application/vnd.syncml.dm+wbxml', 'bdm'],\n    ['application/vnd.syncml.dm+xml', 'xdm'],\n    ['application/vnd.tao.intent-module-archive', 'tao'],\n    ['application/vnd.tmobile-livetv', 'tmo'],\n    ['application/vnd.trid.tpt', 'tpt'],\n    ['application/vnd.triscape.mxs', 'mxs'],\n    ['application/vnd.trueapp', 'tra'],\n    ['application/vnd.ufdl', 'ufd'],\n    ['application/vnd.uiq.theme', 'utz'],\n    ['application/vnd.umajin', 'umj'],\n    ['application/vnd.unity', 'unityweb'],\n    ['application/vnd.uoml+xml', 'uoml'],\n    ['application/vnd.vcx', 'vcx'],\n    ['application/vnd.visio', 'vsd'],\n    ['application/vnd.visionary', 'vis'],\n    ['application/vnd.vsf', 'vsf'],\n    ['application/vnd.wap.wbxml', 'wbxml'],\n    ['application/vnd.wap.wmlc', 'wmlc'],\n    ['application/vnd.wap.wmlscriptc', 'wmlsc'],\n    ['application/vnd.webturbo', 'wtb'],\n    ['application/vnd.wolfram.player', 'nbp'],\n    ['application/vnd.wordperfect', 'wpd'],\n    ['application/vnd.wqd', 'wqd'],\n    ['application/vnd.wt.stf', 'stf'],\n    ['application/vnd.xara', ['web', 'xar']],\n    ['application/vnd.xfdl', 'xfdl'],\n    ['application/vnd.yamaha.hv-dic', 'hvd'],\n    ['application/vnd.yamaha.hv-script', 'hvs'],\n    ['application/vnd.yamaha.hv-voice', 'hvp'],\n    ['application/vnd.yamaha.openscoreformat', 'osf'],\n    ['application/vnd.yamaha.openscoreformat.osfpvg+xml', 'osfpvg'],\n    ['application/vnd.yamaha.smaf-audio', 'saf'],\n    ['application/vnd.yamaha.smaf-phrase', 'spf'],\n    ['application/vnd.yellowriver-custom-menu', 'cmp'],\n    ['application/vnd.zul', 'zir'],\n    ['application/vnd.zzazz.deck+xml', 'zaz'],\n    ['application/vocaltec-media-desc', 'vmd'],\n    ['application/vocaltec-media-file', 'vmf'],\n    ['application/voicexml+xml', 'vxml'],\n    ['application/widget', 'wgt'],\n    ['application/winhlp', 'hlp'],\n    ['application/wordperfect', ['wp', 'wp5', 'wp6', 'wpd']],\n    ['application/wordperfect6.0', ['w60', 'wp5']],\n    ['application/wordperfect6.1', 'w61'],\n    ['application/wsdl+xml', 'wsdl'],\n    ['application/wspolicy+xml', 'wspolicy'],\n    ['application/x-123', 'wk1'],\n    ['application/x-7z-compressed', '7z'],\n    ['application/x-abiword', 'abw'],\n    ['application/x-ace-compressed', 'ace'],\n    ['application/x-aim', 'aim'],\n    ['application/x-authorware-bin', 'aab'],\n    ['application/x-authorware-map', 'aam'],\n    ['application/x-authorware-seg', 'aas'],\n    ['application/x-bcpio', 'bcpio'],\n    ['application/x-binary', 'bin'],\n    ['application/x-binhex40', 'hqx'],\n    ['application/x-bittorrent', 'torrent'],\n    ['application/x-bsh', ['bsh', 'sh', 'shar']],\n    ['application/x-bytecode.elisp', 'elc'],\n    ['applicaiton/x-bytecode.python', 'pyc'],\n    ['application/x-bzip', 'bz'],\n    ['application/x-bzip2', ['boz', 'bz2']],\n    ['application/x-cdf', 'cdf'],\n    ['application/x-cdlink', 'vcd'],\n    ['application/x-chat', ['cha', 'chat']],\n    ['application/x-chess-pgn', 'pgn'],\n    ['application/x-cmu-raster', 'ras'],\n    ['application/x-cocoa', 'cco'],\n    ['application/x-compactpro', 'cpt'],\n    ['application/x-compress', 'z'],\n    ['application/x-compressed', ['tgz', 'gz', 'z', 'zip']],\n    ['application/x-conference', 'nsc'],\n    ['application/x-cpio', 'cpio'],\n    ['application/x-cpt', 'cpt'],\n    ['application/x-csh', 'csh'],\n    ['application/x-debian-package', 'deb'],\n    ['application/x-deepv', 'deepv'],\n    ['application/x-director', ['dir', 'dcr', 'dxr']],\n    ['application/x-doom', 'wad'],\n    ['application/x-dtbncx+xml', 'ncx'],\n    ['application/x-dtbook+xml', 'dtb'],\n    ['application/x-dtbresource+xml', 'res'],\n    ['application/x-dvi', 'dvi'],\n    ['application/x-elc', 'elc'],\n    ['application/x-envoy', ['env', 'evy']],\n    ['application/x-esrehber', 'es'],\n    ['application/x-excel', ['xls', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],\n    ['application/x-font-bdf', 'bdf'],\n    ['application/x-font-ghostscript', 'gsf'],\n    ['application/x-font-linux-psf', 'psf'],\n    ['application/x-font-otf', 'otf'],\n    ['application/x-font-pcf', 'pcf'],\n    ['application/x-font-snf', 'snf'],\n    ['application/x-font-ttf', 'ttf'],\n    ['application/x-font-type1', 'pfa'],\n    ['application/x-font-woff', 'woff'],\n    ['application/x-frame', 'mif'],\n    ['application/x-freelance', 'pre'],\n    ['application/x-futuresplash', 'spl'],\n    ['application/x-gnumeric', 'gnumeric'],\n    ['application/x-gsp', 'gsp'],\n    ['application/x-gss', 'gss'],\n    ['application/x-gtar', 'gtar'],\n    ['application/x-gzip', ['gz', 'gzip']],\n    ['application/x-hdf', 'hdf'],\n    ['application/x-helpfile', ['help', 'hlp']],\n    ['application/x-httpd-imap', 'imap'],\n    ['application/x-ima', 'ima'],\n    ['application/x-internet-signup', ['ins', 'isp']],\n    ['application/x-internett-signup', 'ins'],\n    ['application/x-inventor', 'iv'],\n    ['application/x-ip2', 'ip'],\n    ['application/x-iphone', 'iii'],\n    ['application/x-java-class', 'class'],\n    ['application/x-java-commerce', 'jcm'],\n    ['application/x-java-jnlp-file', 'jnlp'],\n    ['application/x-javascript', 'js'],\n    ['application/x-koan', ['skd', 'skm', 'skp', 'skt']],\n    ['application/x-ksh', 'ksh'],\n    ['application/x-latex', ['latex', 'ltx']],\n    ['application/x-lha', 'lha'],\n    ['application/x-lisp', 'lsp'],\n    ['application/x-livescreen', 'ivy'],\n    ['application/x-lotus', 'wq1'],\n    ['application/x-lotusscreencam', 'scm'],\n    ['application/x-lzh', 'lzh'],\n    ['application/x-lzx', 'lzx'],\n    ['application/x-mac-binhex40', 'hqx'],\n    ['application/x-macbinary', 'bin'],\n    ['application/x-magic-cap-package-1.0', 'mc$'],\n    ['application/x-mathcad', 'mcd'],\n    ['application/x-meme', 'mm'],\n    ['application/x-midi', ['mid', 'midi']],\n    ['application/x-mif', 'mif'],\n    ['application/x-mix-transfer', 'nix'],\n    ['application/x-mobipocket-ebook', 'prc'],\n    ['application/x-mplayer2', 'asx'],\n    ['application/x-ms-application', 'application'],\n    ['application/x-ms-wmd', 'wmd'],\n    ['application/x-ms-wmz', 'wmz'],\n    ['application/x-ms-xbap', 'xbap'],\n    ['application/x-msaccess', 'mdb'],\n    ['application/x-msbinder', 'obd'],\n    ['application/x-mscardfile', 'crd'],\n    ['application/x-msclip', 'clp'],\n    ['application/x-msdownload', ['exe', 'dll']],\n    ['application/x-msexcel', ['xls', 'xla', 'xlw']],\n    ['application/x-msmediaview', ['mvb', 'm13', 'm14']],\n    ['application/x-msmetafile', 'wmf'],\n    ['application/x-msmoney', 'mny'],\n    ['application/x-mspowerpoint', 'ppt'],\n    ['application/x-mspublisher', 'pub'],\n    ['application/x-msschedule', 'scd'],\n    ['application/x-msterminal', 'trm'],\n    ['application/x-mswrite', 'wri'],\n    ['application/x-navi-animation', 'ani'],\n    ['application/x-navidoc', 'nvd'],\n    ['application/x-navimap', 'map'],\n    ['application/x-navistyle', 'stl'],\n    ['application/x-netcdf', ['cdf', 'nc']],\n    ['application/x-newton-compatible-pkg', 'pkg'],\n    ['application/x-nokia-9000-communicator-add-on-software', 'aos'],\n    ['application/x-omc', 'omc'],\n    ['application/x-omcdatamaker', 'omcd'],\n    ['application/x-omcregerator', 'omcr'],\n    ['application/x-pagemaker', ['pm4', 'pm5']],\n    ['application/x-pcl', 'pcl'],\n    ['application/x-perfmon', ['pma', 'pmc', 'pml', 'pmr', 'pmw']],\n    ['application/x-pixclscript', 'plx'],\n    ['application/x-pkcs10', 'p10'],\n    ['application/x-pkcs12', ['p12', 'pfx']],\n    ['application/x-pkcs7-certificates', ['p7b', 'spc']],\n    ['application/x-pkcs7-certreqresp', 'p7r'],\n    ['application/x-pkcs7-mime', ['p7m', 'p7c']],\n    ['application/x-pkcs7-signature', ['p7s', 'p7a']],\n    ['application/x-pointplus', 'css'],\n    ['application/x-portable-anymap', 'pnm'],\n    ['application/x-project', ['mpc', 'mpt', 'mpv', 'mpx']],\n    ['application/x-qpro', 'wb1'],\n    ['application/x-rar-compressed', 'rar'],\n    ['application/x-rtf', 'rtf'],\n    ['application/x-sdp', 'sdp'],\n    ['application/x-sea', 'sea'],\n    ['application/x-seelogo', 'sl'],\n    ['application/x-sh', 'sh'],\n    ['application/x-shar', ['shar', 'sh']],\n    ['application/x-shockwave-flash', 'swf'],\n    ['application/x-silverlight-app', 'xap'],\n    ['application/x-sit', 'sit'],\n    ['application/x-sprite', ['spr', 'sprite']],\n    ['application/x-stuffit', 'sit'],\n    ['application/x-stuffitx', 'sitx'],\n    ['application/x-sv4cpio', 'sv4cpio'],\n    ['application/x-sv4crc', 'sv4crc'],\n    ['application/x-tar', 'tar'],\n    ['application/x-tbook', ['sbk', 'tbk']],\n    ['application/x-tcl', 'tcl'],\n    ['application/x-tex', 'tex'],\n    ['application/x-tex-tfm', 'tfm'],\n    ['application/x-texinfo', ['texi', 'texinfo']],\n    ['application/x-troff', ['roff', 't', 'tr']],\n    ['application/x-troff-man', 'man'],\n    ['application/x-troff-me', 'me'],\n    ['application/x-troff-ms', 'ms'],\n    ['application/x-troff-msvideo', 'avi'],\n    ['application/x-ustar', 'ustar'],\n    ['application/x-visio', ['vsd', 'vst', 'vsw']],\n    ['application/x-vnd.audioexplosion.mzz', 'mzz'],\n    ['application/x-vnd.ls-xpix', 'xpix'],\n    ['application/x-vrml', 'vrml'],\n    ['application/x-wais-source', ['src', 'wsrc']],\n    ['application/x-winhelp', 'hlp'],\n    ['application/x-wintalk', 'wtk'],\n    ['application/x-world', ['wrl', 'svr']],\n    ['application/x-wpwin', 'wpd'],\n    ['application/x-wri', 'wri'],\n    ['application/x-x509-ca-cert', ['cer', 'crt', 'der']],\n    ['application/x-x509-user-cert', 'crt'],\n    ['application/x-xfig', 'fig'],\n    ['application/x-xpinstall', 'xpi'],\n    ['application/x-zip-compressed', 'zip'],\n    ['application/xcap-diff+xml', 'xdf'],\n    ['application/xenc+xml', 'xenc'],\n    ['application/xhtml+xml', 'xhtml'],\n    ['application/xml', 'xml'],\n    ['application/xml-dtd', 'dtd'],\n    ['application/xop+xml', 'xop'],\n    ['application/xslt+xml', 'xslt'],\n    ['application/xspf+xml', 'xspf'],\n    ['application/xv+xml', 'mxml'],\n    ['application/yang', 'yang'],\n    ['application/yin+xml', 'yin'],\n    ['application/ynd.ms-pkipko', 'pko'],\n    ['application/zip', 'zip'],\n    ['audio/adpcm', 'adp'],\n    ['audio/aiff', ['aiff', 'aif', 'aifc']],\n    ['audio/basic', ['snd', 'au']],\n    ['audio/it', 'it'],\n    ['audio/make', ['funk', 'my', 'pfunk']],\n    ['audio/make.my.funk', 'pfunk'],\n    ['audio/mid', ['mid', 'rmi']],\n    ['audio/midi', ['midi', 'kar', 'mid']],\n    ['audio/mod', 'mod'],\n    ['audio/mp4', 'mp4a'],\n    ['audio/mpeg', ['mpga', 'mp3', 'm2a', 'mp2', 'mpa', 'mpg']],\n    ['audio/mpeg3', 'mp3'],\n    ['audio/nspaudio', ['la', 'lma']],\n    ['audio/ogg', 'oga'],\n    ['audio/s3m', 's3m'],\n    ['audio/tsp-audio', 'tsi'],\n    ['audio/tsplayer', 'tsp'],\n    ['audio/vnd.dece.audio', 'uva'],\n    ['audio/vnd.digital-winds', 'eol'],\n    ['audio/vnd.dra', 'dra'],\n    ['audio/vnd.dts', 'dts'],\n    ['audio/vnd.dts.hd', 'dtshd'],\n    ['audio/vnd.lucent.voice', 'lvp'],\n    ['audio/vnd.ms-playready.media.pya', 'pya'],\n    ['audio/vnd.nuera.ecelp4800', 'ecelp4800'],\n    ['audio/vnd.nuera.ecelp7470', 'ecelp7470'],\n    ['audio/vnd.nuera.ecelp9600', 'ecelp9600'],\n    ['audio/vnd.qcelp', 'qcp'],\n    ['audio/vnd.rip', 'rip'],\n    ['audio/voc', 'voc'],\n    ['audio/voxware', 'vox'],\n    ['audio/wav', 'wav'],\n    ['audio/webm', 'weba'],\n    ['audio/x-aac', 'aac'],\n    ['audio/x-adpcm', 'snd'],\n    ['audio/x-aiff', ['aiff', 'aif', 'aifc']],\n    ['audio/x-au', 'au'],\n    ['audio/x-gsm', ['gsd', 'gsm']],\n    ['audio/x-jam', 'jam'],\n    ['audio/x-liveaudio', 'lam'],\n    ['audio/x-mid', ['mid', 'midi']],\n    ['audio/x-midi', ['midi', 'mid']],\n    ['audio/x-mod', 'mod'],\n    ['audio/x-mpeg', 'mp2'],\n    ['audio/x-mpeg-3', 'mp3'],\n    ['audio/x-mpegurl', 'm3u'],\n    ['audio/x-mpequrl', 'm3u'],\n    ['audio/x-ms-wax', 'wax'],\n    ['audio/x-ms-wma', 'wma'],\n    ['audio/x-nspaudio', ['la', 'lma']],\n    ['audio/x-pn-realaudio', ['ra', 'ram', 'rm', 'rmm', 'rmp']],\n    ['audio/x-pn-realaudio-plugin', ['ra', 'rmp', 'rpm']],\n    ['audio/x-psid', 'sid'],\n    ['audio/x-realaudio', 'ra'],\n    ['audio/x-twinvq', 'vqf'],\n    ['audio/x-twinvq-plugin', ['vqe', 'vql']],\n    ['audio/x-vnd.audioexplosion.mjuicemediafile', 'mjf'],\n    ['audio/x-voc', 'voc'],\n    ['audio/x-wav', 'wav'],\n    ['audio/xm', 'xm'],\n    ['chemical/x-cdx', 'cdx'],\n    ['chemical/x-cif', 'cif'],\n    ['chemical/x-cmdf', 'cmdf'],\n    ['chemical/x-cml', 'cml'],\n    ['chemical/x-csml', 'csml'],\n    ['chemical/x-pdb', ['pdb', 'xyz']],\n    ['chemical/x-xyz', 'xyz'],\n    ['drawing/x-dwf', 'dwf'],\n    ['i-world/i-vrml', 'ivr'],\n    ['image/bmp', ['bmp', 'bm']],\n    ['image/cgm', 'cgm'],\n    ['image/cis-cod', 'cod'],\n    ['image/cmu-raster', ['ras', 'rast']],\n    ['image/fif', 'fif'],\n    ['image/florian', ['flo', 'turbot']],\n    ['image/g3fax', 'g3'],\n    ['image/gif', 'gif'],\n    ['image/ief', ['ief', 'iefs']],\n    ['image/jpeg', ['jpeg', 'jpe', 'jpg', 'jfif', 'jfif-tbnl']],\n    ['image/jutvision', 'jut'],\n    ['image/ktx', 'ktx'],\n    ['image/naplps', ['nap', 'naplps']],\n    ['image/pict', ['pic', 'pict']],\n    ['image/pipeg', 'jfif'],\n    ['image/pjpeg', ['jfif', 'jpe', 'jpeg', 'jpg']],\n    ['image/png', ['png', 'x-png']],\n    ['image/prs.btif', 'btif'],\n    ['image/svg+xml', 'svg'],\n    ['image/tiff', ['tif', 'tiff']],\n    ['image/vasa', 'mcf'],\n    ['image/vnd.adobe.photoshop', 'psd'],\n    ['image/vnd.dece.graphic', 'uvi'],\n    ['image/vnd.djvu', 'djvu'],\n    ['image/vnd.dvb.subtitle', 'sub'],\n    ['image/vnd.dwg', ['dwg', 'dxf', 'svf']],\n    ['image/vnd.dxf', 'dxf'],\n    ['image/vnd.fastbidsheet', 'fbs'],\n    ['image/vnd.fpx', 'fpx'],\n    ['image/vnd.fst', 'fst'],\n    ['image/vnd.fujixerox.edmics-mmr', 'mmr'],\n    ['image/vnd.fujixerox.edmics-rlc', 'rlc'],\n    ['image/vnd.ms-modi', 'mdi'],\n    ['image/vnd.net-fpx', ['fpx', 'npx']],\n    ['image/vnd.rn-realflash', 'rf'],\n    ['image/vnd.rn-realpix', 'rp'],\n    ['image/vnd.wap.wbmp', 'wbmp'],\n    ['image/vnd.xiff', 'xif'],\n    ['image/webp', 'webp'],\n    ['image/x-cmu-raster', 'ras'],\n    ['image/x-cmx', 'cmx'],\n    ['image/x-dwg', ['dwg', 'dxf', 'svf']],\n    ['image/x-freehand', 'fh'],\n    ['image/x-icon', 'ico'],\n    ['image/x-jg', 'art'],\n    ['image/x-jps', 'jps'],\n    ['image/x-niff', ['niff', 'nif']],\n    ['image/x-pcx', 'pcx'],\n    ['image/x-pict', ['pct', 'pic']],\n    ['image/x-portable-anymap', 'pnm'],\n    ['image/x-portable-bitmap', 'pbm'],\n    ['image/x-portable-graymap', 'pgm'],\n    ['image/x-portable-greymap', 'pgm'],\n    ['image/x-portable-pixmap', 'ppm'],\n    ['image/x-quicktime', ['qif', 'qti', 'qtif']],\n    ['image/x-rgb', 'rgb'],\n    ['image/x-tiff', ['tif', 'tiff']],\n    ['image/x-windows-bmp', 'bmp'],\n    ['image/x-xbitmap', 'xbm'],\n    ['image/x-xbm', 'xbm'],\n    ['image/x-xpixmap', ['xpm', 'pm']],\n    ['image/x-xwd', 'xwd'],\n    ['image/x-xwindowdump', 'xwd'],\n    ['image/xbm', 'xbm'],\n    ['image/xpm', 'xpm'],\n    ['message/rfc822', ['eml', 'mht', 'mhtml', 'nws', 'mime']],\n    ['model/iges', ['iges', 'igs']],\n    ['model/mesh', 'msh'],\n    ['model/vnd.collada+xml', 'dae'],\n    ['model/vnd.dwf', 'dwf'],\n    ['model/vnd.gdl', 'gdl'],\n    ['model/vnd.gtw', 'gtw'],\n    ['model/vnd.mts', 'mts'],\n    ['model/vnd.vtu', 'vtu'],\n    ['model/vrml', ['vrml', 'wrl', 'wrz']],\n    ['model/x-pov', 'pov'],\n    ['multipart/x-gzip', 'gzip'],\n    ['multipart/x-ustar', 'ustar'],\n    ['multipart/x-zip', 'zip'],\n    ['music/crescendo', ['mid', 'midi']],\n    ['music/x-karaoke', 'kar'],\n    ['paleovu/x-pv', 'pvu'],\n    ['text/asp', 'asp'],\n    ['text/calendar', 'ics'],\n    ['text/css', 'css'],\n    ['text/csv', 'csv'],\n    ['text/ecmascript', 'js'],\n    ['text/h323', '323'],\n    ['text/html', ['html', 'htm', 'stm', 'acgi', 'htmls', 'htx', 'shtml']],\n    ['text/iuls', 'uls'],\n    ['text/javascript', 'js'],\n    ['text/mcf', 'mcf'],\n    ['text/n3', 'n3'],\n    ['text/pascal', 'pas'],\n    [\n        'text/plain',\n        [\n            'txt',\n            'bas',\n            'c',\n            'h',\n            'c++',\n            'cc',\n            'com',\n            'conf',\n            'cxx',\n            'def',\n            'f',\n            'f90',\n            'for',\n            'g',\n            'hh',\n            'idc',\n            'jav',\n            'java',\n            'list',\n            'log',\n            'lst',\n            'm',\n            'mar',\n            'pl',\n            'sdml',\n            'text'\n        ]\n    ],\n    ['text/plain-bas', 'par'],\n    ['text/prs.lines.tag', 'dsc'],\n    ['text/richtext', ['rtx', 'rt', 'rtf']],\n    ['text/scriplet', 'wsc'],\n    ['text/scriptlet', 'sct'],\n    ['text/sgml', ['sgm', 'sgml']],\n    ['text/tab-separated-values', 'tsv'],\n    ['text/troff', 't'],\n    ['text/turtle', 'ttl'],\n    ['text/uri-list', ['uni', 'unis', 'uri', 'uris']],\n    ['text/vnd.abc', 'abc'],\n    ['text/vnd.curl', 'curl'],\n    ['text/vnd.curl.dcurl', 'dcurl'],\n    ['text/vnd.curl.mcurl', 'mcurl'],\n    ['text/vnd.curl.scurl', 'scurl'],\n    ['text/vnd.fly', 'fly'],\n    ['text/vnd.fmi.flexstor', 'flx'],\n    ['text/vnd.graphviz', 'gv'],\n    ['text/vnd.in3d.3dml', '3dml'],\n    ['text/vnd.in3d.spot', 'spot'],\n    ['text/vnd.rn-realtext', 'rt'],\n    ['text/vnd.sun.j2me.app-descriptor', 'jad'],\n    ['text/vnd.wap.wml', 'wml'],\n    ['text/vnd.wap.wmlscript', 'wmls'],\n    ['text/webviewhtml', 'htt'],\n    ['text/x-asm', ['asm', 's']],\n    ['text/x-audiosoft-intra', 'aip'],\n    ['text/x-c', ['c', 'cc', 'cpp']],\n    ['text/x-component', 'htc'],\n    ['text/x-fortran', ['for', 'f', 'f77', 'f90']],\n    ['text/x-h', ['h', 'hh']],\n    ['text/x-java-source', ['java', 'jav']],\n    ['text/x-java-source,java', 'java'],\n    ['text/x-la-asf', 'lsx'],\n    ['text/x-m', 'm'],\n    ['text/x-pascal', 'p'],\n    ['text/x-script', 'hlb'],\n    ['text/x-script.csh', 'csh'],\n    ['text/x-script.elisp', 'el'],\n    ['text/x-script.guile', 'scm'],\n    ['text/x-script.ksh', 'ksh'],\n    ['text/x-script.lisp', 'lsp'],\n    ['text/x-script.perl', 'pl'],\n    ['text/x-script.perl-module', 'pm'],\n    ['text/x-script.phyton', 'py'],\n    ['text/x-script.rexx', 'rexx'],\n    ['text/x-script.scheme', 'scm'],\n    ['text/x-script.sh', 'sh'],\n    ['text/x-script.tcl', 'tcl'],\n    ['text/x-script.tcsh', 'tcsh'],\n    ['text/x-script.zsh', 'zsh'],\n    ['text/x-server-parsed-html', ['shtml', 'ssi']],\n    ['text/x-setext', 'etx'],\n    ['text/x-sgml', ['sgm', 'sgml']],\n    ['text/x-speech', ['spc', 'talk']],\n    ['text/x-uil', 'uil'],\n    ['text/x-uuencode', ['uu', 'uue']],\n    ['text/x-vcalendar', 'vcs'],\n    ['text/x-vcard', 'vcf'],\n    ['text/xml', 'xml'],\n    ['video/3gpp', '3gp'],\n    ['video/3gpp2', '3g2'],\n    ['video/animaflex', 'afl'],\n    ['video/avi', 'avi'],\n    ['video/avs-video', 'avs'],\n    ['video/dl', 'dl'],\n    ['video/fli', 'fli'],\n    ['video/gl', 'gl'],\n    ['video/h261', 'h261'],\n    ['video/h263', 'h263'],\n    ['video/h264', 'h264'],\n    ['video/jpeg', 'jpgv'],\n    ['video/jpm', 'jpm'],\n    ['video/mj2', 'mj2'],\n    ['video/mp4', 'mp4'],\n    ['video/mpeg', ['mpeg', 'mp2', 'mpa', 'mpe', 'mpg', 'mpv2', 'm1v', 'm2v', 'mp3']],\n    ['video/msvideo', 'avi'],\n    ['video/ogg', 'ogv'],\n    ['video/quicktime', ['mov', 'qt', 'moov']],\n    ['video/vdo', 'vdo'],\n    ['video/vivo', ['viv', 'vivo']],\n    ['video/vnd.dece.hd', 'uvh'],\n    ['video/vnd.dece.mobile', 'uvm'],\n    ['video/vnd.dece.pd', 'uvp'],\n    ['video/vnd.dece.sd', 'uvs'],\n    ['video/vnd.dece.video', 'uvv'],\n    ['video/vnd.fvt', 'fvt'],\n    ['video/vnd.mpegurl', 'mxu'],\n    ['video/vnd.ms-playready.media.pyv', 'pyv'],\n    ['video/vnd.rn-realvideo', 'rv'],\n    ['video/vnd.uvvu.mp4', 'uvu'],\n    ['video/vnd.vivo', ['viv', 'vivo']],\n    ['video/vosaic', 'vos'],\n    ['video/webm', 'webm'],\n    ['video/x-amt-demorun', 'xdr'],\n    ['video/x-amt-showrun', 'xsr'],\n    ['video/x-atomic3d-feature', 'fmf'],\n    ['video/x-dl', 'dl'],\n    ['video/x-dv', ['dif', 'dv']],\n    ['video/x-f4v', 'f4v'],\n    ['video/x-fli', 'fli'],\n    ['video/x-flv', 'flv'],\n    ['video/x-gl', 'gl'],\n    ['video/x-isvideo', 'isu'],\n    ['video/x-la-asf', ['lsf', 'lsx']],\n    ['video/x-m4v', 'm4v'],\n    ['video/x-motion-jpeg', 'mjpg'],\n    ['video/x-mpeg', ['mp3', 'mp2']],\n    ['video/x-mpeq2a', 'mp2'],\n    ['video/x-ms-asf', ['asf', 'asr', 'asx']],\n    ['video/x-ms-asf-plugin', 'asx'],\n    ['video/x-ms-wm', 'wm'],\n    ['video/x-ms-wmv', 'wmv'],\n    ['video/x-ms-wmx', 'wmx'],\n    ['video/x-ms-wvx', 'wvx'],\n    ['video/x-msvideo', 'avi'],\n    ['video/x-qtc', 'qtc'],\n    ['video/x-scm', 'scm'],\n    ['video/x-sgi-movie', ['movie', 'mv']],\n    ['windows/metafile', 'wmf'],\n    ['www/mime', 'mime'],\n    ['x-conference/x-cooltalk', 'ice'],\n    ['x-music/x-midi', ['mid', 'midi']],\n    ['x-world/x-3dmf', ['3dm', '3dmf', 'qd3', 'qd3d']],\n    ['x-world/x-svr', 'svr'],\n    ['x-world/x-vrml', ['flr', 'vrml', 'wrl', 'wrz', 'xaf', 'xof']],\n    ['x-world/x-vrt', 'vrt'],\n    ['xgl/drawing', 'xgz'],\n    ['xgl/movie', 'xmz']\n]);\nconst extensions = new Map([\n    ['123', 'application/vnd.lotus-1-2-3'],\n    ['323', 'text/h323'],\n    ['*', 'application/octet-stream'],\n    ['3dm', 'x-world/x-3dmf'],\n    ['3dmf', 'x-world/x-3dmf'],\n    ['3dml', 'text/vnd.in3d.3dml'],\n    ['3g2', 'video/3gpp2'],\n    ['3gp', 'video/3gpp'],\n    ['7z', 'application/x-7z-compressed'],\n    ['a', 'application/octet-stream'],\n    ['aab', 'application/x-authorware-bin'],\n    ['aac', 'audio/x-aac'],\n    ['aam', 'application/x-authorware-map'],\n    ['aas', 'application/x-authorware-seg'],\n    ['abc', 'text/vnd.abc'],\n    ['abw', 'application/x-abiword'],\n    ['ac', 'application/pkix-attr-cert'],\n    ['acc', 'application/vnd.americandynamics.acc'],\n    ['ace', 'application/x-ace-compressed'],\n    ['acgi', 'text/html'],\n    ['acu', 'application/vnd.acucobol'],\n    ['acx', 'application/internet-property-stream'],\n    ['adp', 'audio/adpcm'],\n    ['aep', 'application/vnd.audiograph'],\n    ['afl', 'video/animaflex'],\n    ['afp', 'application/vnd.ibm.modcap'],\n    ['ahead', 'application/vnd.ahead.space'],\n    ['ai', 'application/postscript'],\n    ['aif', ['audio/aiff', 'audio/x-aiff']],\n    ['aifc', ['audio/aiff', 'audio/x-aiff']],\n    ['aiff', ['audio/aiff', 'audio/x-aiff']],\n    ['aim', 'application/x-aim'],\n    ['aip', 'text/x-audiosoft-intra'],\n    ['air', 'application/vnd.adobe.air-application-installer-package+zip'],\n    ['ait', 'application/vnd.dvb.ait'],\n    ['ami', 'application/vnd.amiga.ami'],\n    ['ani', 'application/x-navi-animation'],\n    ['aos', 'application/x-nokia-9000-communicator-add-on-software'],\n    ['apk', 'application/vnd.android.package-archive'],\n    ['application', 'application/x-ms-application'],\n    ['apr', 'application/vnd.lotus-approach'],\n    ['aps', 'application/mime'],\n    ['arc', 'application/octet-stream'],\n    ['arj', ['application/arj', 'application/octet-stream']],\n    ['art', 'image/x-jg'],\n    ['asf', 'video/x-ms-asf'],\n    ['asm', 'text/x-asm'],\n    ['aso', 'application/vnd.accpac.simply.aso'],\n    ['asp', 'text/asp'],\n    ['asr', 'video/x-ms-asf'],\n    ['asx', ['video/x-ms-asf', 'application/x-mplayer2', 'video/x-ms-asf-plugin']],\n    ['atc', 'application/vnd.acucorp'],\n    ['atomcat', 'application/atomcat+xml'],\n    ['atomsvc', 'application/atomsvc+xml'],\n    ['atx', 'application/vnd.antix.game-component'],\n    ['au', ['audio/basic', 'audio/x-au']],\n    ['avi', ['video/avi', 'video/msvideo', 'application/x-troff-msvideo', 'video/x-msvideo']],\n    ['avs', 'video/avs-video'],\n    ['aw', 'application/applixware'],\n    ['axs', 'application/olescript'],\n    ['azf', 'application/vnd.airzip.filesecure.azf'],\n    ['azs', 'application/vnd.airzip.filesecure.azs'],\n    ['azw', 'application/vnd.amazon.ebook'],\n    ['bas', 'text/plain'],\n    ['bcpio', 'application/x-bcpio'],\n    ['bdf', 'application/x-font-bdf'],\n    ['bdm', 'application/vnd.syncml.dm+wbxml'],\n    ['bed', 'application/vnd.realvnc.bed'],\n    ['bh2', 'application/vnd.fujitsu.oasysprs'],\n    ['bin', ['application/octet-stream', 'application/mac-binary', 'application/macbinary', 'application/x-macbinary', 'application/x-binary']],\n    ['bm', 'image/bmp'],\n    ['bmi', 'application/vnd.bmi'],\n    ['bmp', ['image/bmp', 'image/x-windows-bmp']],\n    ['boo', 'application/book'],\n    ['book', 'application/book'],\n    ['box', 'application/vnd.previewsystems.box'],\n    ['boz', 'application/x-bzip2'],\n    ['bsh', 'application/x-bsh'],\n    ['btif', 'image/prs.btif'],\n    ['bz', 'application/x-bzip'],\n    ['bz2', 'application/x-bzip2'],\n    ['c', ['text/plain', 'text/x-c']],\n    ['c++', 'text/plain'],\n    ['c11amc', 'application/vnd.cluetrust.cartomobile-config'],\n    ['c11amz', 'application/vnd.cluetrust.cartomobile-config-pkg'],\n    ['c4g', 'application/vnd.clonk.c4group'],\n    ['cab', 'application/vnd.ms-cab-compressed'],\n    ['car', 'application/vnd.curl.car'],\n    ['cat', ['application/vnd.ms-pkiseccat', 'application/vnd.ms-pki.seccat']],\n    ['cc', ['text/plain', 'text/x-c']],\n    ['ccad', 'application/clariscad'],\n    ['cco', 'application/x-cocoa'],\n    ['ccxml', 'application/ccxml+xml,'],\n    ['cdbcmsg', 'application/vnd.contact.cmsg'],\n    ['cdf', ['application/cdf', 'application/x-cdf', 'application/x-netcdf']],\n    ['cdkey', 'application/vnd.mediastation.cdkey'],\n    ['cdmia', 'application/cdmi-capability'],\n    ['cdmic', 'application/cdmi-container'],\n    ['cdmid', 'application/cdmi-domain'],\n    ['cdmio', 'application/cdmi-object'],\n    ['cdmiq', 'application/cdmi-queue'],\n    ['cdx', 'chemical/x-cdx'],\n    ['cdxml', 'application/vnd.chemdraw+xml'],\n    ['cdy', 'application/vnd.cinderella'],\n    ['cer', ['application/pkix-cert', 'application/x-x509-ca-cert']],\n    ['cgm', 'image/cgm'],\n    ['cha', 'application/x-chat'],\n    ['chat', 'application/x-chat'],\n    ['chm', 'application/vnd.ms-htmlhelp'],\n    ['chrt', 'application/vnd.kde.kchart'],\n    ['cif', 'chemical/x-cif'],\n    ['cii', 'application/vnd.anser-web-certificate-issue-initiation'],\n    ['cil', 'application/vnd.ms-artgalry'],\n    ['cla', 'application/vnd.claymore'],\n    ['class', ['application/octet-stream', 'application/java', 'application/java-byte-code', 'application/java-vm', 'application/x-java-class']],\n    ['clkk', 'application/vnd.crick.clicker.keyboard'],\n    ['clkp', 'application/vnd.crick.clicker.palette'],\n    ['clkt', 'application/vnd.crick.clicker.template'],\n    ['clkw', 'application/vnd.crick.clicker.wordbank'],\n    ['clkx', 'application/vnd.crick.clicker'],\n    ['clp', 'application/x-msclip'],\n    ['cmc', 'application/vnd.cosmocaller'],\n    ['cmdf', 'chemical/x-cmdf'],\n    ['cml', 'chemical/x-cml'],\n    ['cmp', 'application/vnd.yellowriver-custom-menu'],\n    ['cmx', 'image/x-cmx'],\n    ['cod', ['image/cis-cod', 'application/vnd.rim.cod']],\n    ['com', ['application/octet-stream', 'text/plain']],\n    ['conf', 'text/plain'],\n    ['cpio', 'application/x-cpio'],\n    ['cpp', 'text/x-c'],\n    ['cpt', ['application/mac-compactpro', 'application/x-compactpro', 'application/x-cpt']],\n    ['crd', 'application/x-mscardfile'],\n    ['crl', ['application/pkix-crl', 'application/pkcs-crl']],\n    ['crt', ['application/pkix-cert', 'application/x-x509-user-cert', 'application/x-x509-ca-cert']],\n    ['cryptonote', 'application/vnd.rig.cryptonote'],\n    ['csh', ['text/x-script.csh', 'application/x-csh']],\n    ['csml', 'chemical/x-csml'],\n    ['csp', 'application/vnd.commonspace'],\n    ['css', ['text/css', 'application/x-pointplus']],\n    ['csv', 'text/csv'],\n    ['cu', 'application/cu-seeme'],\n    ['curl', 'text/vnd.curl'],\n    ['cww', 'application/prs.cww'],\n    ['cxx', 'text/plain'],\n    ['dae', 'model/vnd.collada+xml'],\n    ['daf', 'application/vnd.mobius.daf'],\n    ['davmount', 'application/davmount+xml'],\n    ['dcr', 'application/x-director'],\n    ['dcurl', 'text/vnd.curl.dcurl'],\n    ['dd2', 'application/vnd.oma.dd2+xml'],\n    ['ddd', 'application/vnd.fujixerox.ddd'],\n    ['deb', 'application/x-debian-package'],\n    ['deepv', 'application/x-deepv'],\n    ['def', 'text/plain'],\n    ['der', 'application/x-x509-ca-cert'],\n    ['dfac', 'application/vnd.dreamfactory'],\n    ['dif', 'video/x-dv'],\n    ['dir', 'application/x-director'],\n    ['dis', 'application/vnd.mobius.dis'],\n    ['djvu', 'image/vnd.djvu'],\n    ['dl', ['video/dl', 'video/x-dl']],\n    ['dll', 'application/x-msdownload'],\n    ['dms', 'application/octet-stream'],\n    ['dna', 'application/vnd.dna'],\n    ['doc', 'application/msword'],\n    ['docm', 'application/vnd.ms-word.document.macroenabled.12'],\n    ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],\n    ['dot', 'application/msword'],\n    ['dotm', 'application/vnd.ms-word.template.macroenabled.12'],\n    ['dotx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template'],\n    ['dp', ['application/commonground', 'application/vnd.osgi.dp']],\n    ['dpg', 'application/vnd.dpgraph'],\n    ['dra', 'audio/vnd.dra'],\n    ['drw', 'application/drafting'],\n    ['dsc', 'text/prs.lines.tag'],\n    ['dssc', 'application/dssc+der'],\n    ['dtb', 'application/x-dtbook+xml'],\n    ['dtd', 'application/xml-dtd'],\n    ['dts', 'audio/vnd.dts'],\n    ['dtshd', 'audio/vnd.dts.hd'],\n    ['dump', 'application/octet-stream'],\n    ['dv', 'video/x-dv'],\n    ['dvi', 'application/x-dvi'],\n    ['dwf', ['model/vnd.dwf', 'drawing/x-dwf']],\n    ['dwg', ['application/acad', 'image/vnd.dwg', 'image/x-dwg']],\n    ['dxf', ['application/dxf', 'image/vnd.dwg', 'image/vnd.dxf', 'image/x-dwg']],\n    ['dxp', 'application/vnd.spotfire.dxp'],\n    ['dxr', 'application/x-director'],\n    ['ecelp4800', 'audio/vnd.nuera.ecelp4800'],\n    ['ecelp7470', 'audio/vnd.nuera.ecelp7470'],\n    ['ecelp9600', 'audio/vnd.nuera.ecelp9600'],\n    ['edm', 'application/vnd.novadigm.edm'],\n    ['edx', 'application/vnd.novadigm.edx'],\n    ['efif', 'application/vnd.picsel'],\n    ['ei6', 'application/vnd.pg.osasli'],\n    ['el', 'text/x-script.elisp'],\n    ['elc', ['application/x-elc', 'application/x-bytecode.elisp']],\n    ['eml', 'message/rfc822'],\n    ['emma', 'application/emma+xml'],\n    ['env', 'application/x-envoy'],\n    ['eol', 'audio/vnd.digital-winds'],\n    ['eot', 'application/vnd.ms-fontobject'],\n    ['eps', 'application/postscript'],\n    ['epub', 'application/epub+zip'],\n    ['es', ['application/ecmascript', 'application/x-esrehber']],\n    ['es3', 'application/vnd.eszigno3+xml'],\n    ['esf', 'application/vnd.epson.esf'],\n    ['etx', 'text/x-setext'],\n    ['evy', ['application/envoy', 'application/x-envoy']],\n    ['exe', ['application/octet-stream', 'application/x-msdownload']],\n    ['exi', 'application/exi'],\n    ['ext', 'application/vnd.novadigm.ext'],\n    ['ez2', 'application/vnd.ezpix-album'],\n    ['ez3', 'application/vnd.ezpix-package'],\n    ['f', ['text/plain', 'text/x-fortran']],\n    ['f4v', 'video/x-f4v'],\n    ['f77', 'text/x-fortran'],\n    ['f90', ['text/plain', 'text/x-fortran']],\n    ['fbs', 'image/vnd.fastbidsheet'],\n    ['fcs', 'application/vnd.isac.fcs'],\n    ['fdf', 'application/vnd.fdf'],\n    ['fe_launch', 'application/vnd.denovo.fcselayout-link'],\n    ['fg5', 'application/vnd.fujitsu.oasysgp'],\n    ['fh', 'image/x-freehand'],\n    ['fif', ['application/fractals', 'image/fif']],\n    ['fig', 'application/x-xfig'],\n    ['fli', ['video/fli', 'video/x-fli']],\n    ['flo', ['image/florian', 'application/vnd.micrografx.flo']],\n    ['flr', 'x-world/x-vrml'],\n    ['flv', 'video/x-flv'],\n    ['flw', 'application/vnd.kde.kivio'],\n    ['flx', 'text/vnd.fmi.flexstor'],\n    ['fly', 'text/vnd.fly'],\n    ['fm', 'application/vnd.framemaker'],\n    ['fmf', 'video/x-atomic3d-feature'],\n    ['fnc', 'application/vnd.frogans.fnc'],\n    ['for', ['text/plain', 'text/x-fortran']],\n    ['fpx', ['image/vnd.fpx', 'image/vnd.net-fpx']],\n    ['frl', 'application/freeloader'],\n    ['fsc', 'application/vnd.fsc.weblaunch'],\n    ['fst', 'image/vnd.fst'],\n    ['ftc', 'application/vnd.fluxtime.clip'],\n    ['fti', 'application/vnd.anser-web-funds-transfer-initiation'],\n    ['funk', 'audio/make'],\n    ['fvt', 'video/vnd.fvt'],\n    ['fxp', 'application/vnd.adobe.fxp'],\n    ['fzs', 'application/vnd.fuzzysheet'],\n    ['g', 'text/plain'],\n    ['g2w', 'application/vnd.geoplan'],\n    ['g3', 'image/g3fax'],\n    ['g3w', 'application/vnd.geospace'],\n    ['gac', 'application/vnd.groove-account'],\n    ['gdl', 'model/vnd.gdl'],\n    ['geo', 'application/vnd.dynageo'],\n    ['gex', 'application/vnd.geometry-explorer'],\n    ['ggb', 'application/vnd.geogebra.file'],\n    ['ggt', 'application/vnd.geogebra.tool'],\n    ['ghf', 'application/vnd.groove-help'],\n    ['gif', 'image/gif'],\n    ['gim', 'application/vnd.groove-identity-message'],\n    ['gl', ['video/gl', 'video/x-gl']],\n    ['gmx', 'application/vnd.gmx'],\n    ['gnumeric', 'application/x-gnumeric'],\n    ['gph', 'application/vnd.flographit'],\n    ['gqf', 'application/vnd.grafeq'],\n    ['gram', 'application/srgs'],\n    ['grv', 'application/vnd.groove-injector'],\n    ['grxml', 'application/srgs+xml'],\n    ['gsd', 'audio/x-gsm'],\n    ['gsf', 'application/x-font-ghostscript'],\n    ['gsm', 'audio/x-gsm'],\n    ['gsp', 'application/x-gsp'],\n    ['gss', 'application/x-gss'],\n    ['gtar', 'application/x-gtar'],\n    ['gtm', 'application/vnd.groove-tool-message'],\n    ['gtw', 'model/vnd.gtw'],\n    ['gv', 'text/vnd.graphviz'],\n    ['gxt', 'application/vnd.geonext'],\n    ['gz', ['application/x-gzip', 'application/x-compressed']],\n    ['gzip', ['multipart/x-gzip', 'application/x-gzip']],\n    ['h', ['text/plain', 'text/x-h']],\n    ['h261', 'video/h261'],\n    ['h263', 'video/h263'],\n    ['h264', 'video/h264'],\n    ['hal', 'application/vnd.hal+xml'],\n    ['hbci', 'application/vnd.hbci'],\n    ['hdf', 'application/x-hdf'],\n    ['help', 'application/x-helpfile'],\n    ['hgl', 'application/vnd.hp-hpgl'],\n    ['hh', ['text/plain', 'text/x-h']],\n    ['hlb', 'text/x-script'],\n    ['hlp', ['application/winhlp', 'application/hlp', 'application/x-helpfile', 'application/x-winhelp']],\n    ['hpg', 'application/vnd.hp-hpgl'],\n    ['hpgl', 'application/vnd.hp-hpgl'],\n    ['hpid', 'application/vnd.hp-hpid'],\n    ['hps', 'application/vnd.hp-hps'],\n    [\n        'hqx',\n        [\n            'application/mac-binhex40',\n            'application/binhex',\n            'application/binhex4',\n            'application/mac-binhex',\n            'application/x-binhex40',\n            'application/x-mac-binhex40'\n        ]\n    ],\n    ['hta', 'application/hta'],\n    ['htc', 'text/x-component'],\n    ['htke', 'application/vnd.kenameaapp'],\n    ['htm', 'text/html'],\n    ['html', 'text/html'],\n    ['htmls', 'text/html'],\n    ['htt', 'text/webviewhtml'],\n    ['htx', 'text/html'],\n    ['hvd', 'application/vnd.yamaha.hv-dic'],\n    ['hvp', 'application/vnd.yamaha.hv-voice'],\n    ['hvs', 'application/vnd.yamaha.hv-script'],\n    ['i2g', 'application/vnd.intergeo'],\n    ['icc', 'application/vnd.iccprofile'],\n    ['ice', 'x-conference/x-cooltalk'],\n    ['ico', 'image/x-icon'],\n    ['ics', 'text/calendar'],\n    ['idc', 'text/plain'],\n    ['ief', 'image/ief'],\n    ['iefs', 'image/ief'],\n    ['ifm', 'application/vnd.shana.informed.formdata'],\n    ['iges', ['application/iges', 'model/iges']],\n    ['igl', 'application/vnd.igloader'],\n    ['igm', 'application/vnd.insors.igm'],\n    ['igs', ['application/iges', 'model/iges']],\n    ['igx', 'application/vnd.micrografx.igx'],\n    ['iif', 'application/vnd.shana.informed.interchange'],\n    ['iii', 'application/x-iphone'],\n    ['ima', 'application/x-ima'],\n    ['imap', 'application/x-httpd-imap'],\n    ['imp', 'application/vnd.accpac.simply.imp'],\n    ['ims', 'application/vnd.ms-ims'],\n    ['inf', 'application/inf'],\n    ['ins', ['application/x-internet-signup', 'application/x-internett-signup']],\n    ['ip', 'application/x-ip2'],\n    ['ipfix', 'application/ipfix'],\n    ['ipk', 'application/vnd.shana.informed.package'],\n    ['irm', 'application/vnd.ibm.rights-management'],\n    ['irp', 'application/vnd.irepository.package+xml'],\n    ['isp', 'application/x-internet-signup'],\n    ['isu', 'video/x-isvideo'],\n    ['it', 'audio/it'],\n    ['itp', 'application/vnd.shana.informed.formtemplate'],\n    ['iv', 'application/x-inventor'],\n    ['ivp', 'application/vnd.immervision-ivp'],\n    ['ivr', 'i-world/i-vrml'],\n    ['ivu', 'application/vnd.immervision-ivu'],\n    ['ivy', 'application/x-livescreen'],\n    ['jad', 'text/vnd.sun.j2me.app-descriptor'],\n    ['jam', ['application/vnd.jam', 'audio/x-jam']],\n    ['jar', 'application/java-archive'],\n    ['jav', ['text/plain', 'text/x-java-source']],\n    ['java', ['text/plain', 'text/x-java-source,java', 'text/x-java-source']],\n    ['jcm', 'application/x-java-commerce'],\n    ['jfif', ['image/pipeg', 'image/jpeg', 'image/pjpeg']],\n    ['jfif-tbnl', 'image/jpeg'],\n    ['jisp', 'application/vnd.jisp'],\n    ['jlt', 'application/vnd.hp-jlyt'],\n    ['jnlp', 'application/x-java-jnlp-file'],\n    ['joda', 'application/vnd.joost.joda-archive'],\n    ['jpe', ['image/jpeg', 'image/pjpeg']],\n    ['jpeg', ['image/jpeg', 'image/pjpeg']],\n    ['jpg', ['image/jpeg', 'image/pjpeg']],\n    ['jpgv', 'video/jpeg'],\n    ['jpm', 'video/jpm'],\n    ['jps', 'image/x-jps'],\n    ['js', ['application/javascript', 'application/ecmascript', 'text/javascript', 'text/ecmascript', 'application/x-javascript']],\n    ['json', 'application/json'],\n    ['jut', 'image/jutvision'],\n    ['kar', ['audio/midi', 'music/x-karaoke']],\n    ['karbon', 'application/vnd.kde.karbon'],\n    ['kfo', 'application/vnd.kde.kformula'],\n    ['kia', 'application/vnd.kidspiration'],\n    ['kml', 'application/vnd.google-earth.kml+xml'],\n    ['kmz', 'application/vnd.google-earth.kmz'],\n    ['kne', 'application/vnd.kinar'],\n    ['kon', 'application/vnd.kde.kontour'],\n    ['kpr', 'application/vnd.kde.kpresenter'],\n    ['ksh', ['application/x-ksh', 'text/x-script.ksh']],\n    ['ksp', 'application/vnd.kde.kspread'],\n    ['ktx', 'image/ktx'],\n    ['ktz', 'application/vnd.kahootz'],\n    ['kwd', 'application/vnd.kde.kword'],\n    ['la', ['audio/nspaudio', 'audio/x-nspaudio']],\n    ['lam', 'audio/x-liveaudio'],\n    ['lasxml', 'application/vnd.las.las+xml'],\n    ['latex', 'application/x-latex'],\n    ['lbd', 'application/vnd.llamagraphics.life-balance.desktop'],\n    ['lbe', 'application/vnd.llamagraphics.life-balance.exchange+xml'],\n    ['les', 'application/vnd.hhe.lesson-player'],\n    ['lha', ['application/octet-stream', 'application/lha', 'application/x-lha']],\n    ['lhx', 'application/octet-stream'],\n    ['link66', 'application/vnd.route66.link66+xml'],\n    ['list', 'text/plain'],\n    ['lma', ['audio/nspaudio', 'audio/x-nspaudio']],\n    ['log', 'text/plain'],\n    ['lrm', 'application/vnd.ms-lrm'],\n    ['lsf', 'video/x-la-asf'],\n    ['lsp', ['application/x-lisp', 'text/x-script.lisp']],\n    ['lst', 'text/plain'],\n    ['lsx', ['video/x-la-asf', 'text/x-la-asf']],\n    ['ltf', 'application/vnd.frogans.ltf'],\n    ['ltx', 'application/x-latex'],\n    ['lvp', 'audio/vnd.lucent.voice'],\n    ['lwp', 'application/vnd.lotus-wordpro'],\n    ['lzh', ['application/octet-stream', 'application/x-lzh']],\n    ['lzx', ['application/lzx', 'application/octet-stream', 'application/x-lzx']],\n    ['m', ['text/plain', 'text/x-m']],\n    ['m13', 'application/x-msmediaview'],\n    ['m14', 'application/x-msmediaview'],\n    ['m1v', 'video/mpeg'],\n    ['m21', 'application/mp21'],\n    ['m2a', 'audio/mpeg'],\n    ['m2v', 'video/mpeg'],\n    ['m3u', ['audio/x-mpegurl', 'audio/x-mpequrl']],\n    ['m3u8', 'application/vnd.apple.mpegurl'],\n    ['m4v', 'video/x-m4v'],\n    ['ma', 'application/mathematica'],\n    ['mads', 'application/mads+xml'],\n    ['mag', 'application/vnd.ecowin.chart'],\n    ['man', 'application/x-troff-man'],\n    ['map', 'application/x-navimap'],\n    ['mar', 'text/plain'],\n    ['mathml', 'application/mathml+xml'],\n    ['mbd', 'application/mbedlet'],\n    ['mbk', 'application/vnd.mobius.mbk'],\n    ['mbox', 'application/mbox'],\n    ['mc$', 'application/x-magic-cap-package-1.0'],\n    ['mc1', 'application/vnd.medcalcdata'],\n    ['mcd', ['application/mcad', 'application/vnd.mcd', 'application/x-mathcad']],\n    ['mcf', ['image/vasa', 'text/mcf']],\n    ['mcp', 'application/netmc'],\n    ['mcurl', 'text/vnd.curl.mcurl'],\n    ['mdb', 'application/x-msaccess'],\n    ['mdi', 'image/vnd.ms-modi'],\n    ['me', 'application/x-troff-me'],\n    ['meta4', 'application/metalink4+xml'],\n    ['mets', 'application/mets+xml'],\n    ['mfm', 'application/vnd.mfmp'],\n    ['mgp', 'application/vnd.osgeo.mapguide.package'],\n    ['mgz', 'application/vnd.proteus.magazine'],\n    ['mht', 'message/rfc822'],\n    ['mhtml', 'message/rfc822'],\n    ['mid', ['audio/mid', 'audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],\n    ['midi', ['audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],\n    ['mif', ['application/vnd.mif', 'application/x-mif', 'application/x-frame']],\n    ['mime', ['message/rfc822', 'www/mime']],\n    ['mj2', 'video/mj2'],\n    ['mjf', 'audio/x-vnd.audioexplosion.mjuicemediafile'],\n    ['mjpg', 'video/x-motion-jpeg'],\n    ['mlp', 'application/vnd.dolby.mlp'],\n    ['mm', ['application/base64', 'application/x-meme']],\n    ['mmd', 'application/vnd.chipnuts.karaoke-mmd'],\n    ['mme', 'application/base64'],\n    ['mmf', 'application/vnd.smaf'],\n    ['mmr', 'image/vnd.fujixerox.edmics-mmr'],\n    ['mny', 'application/x-msmoney'],\n    ['mod', ['audio/mod', 'audio/x-mod']],\n    ['mods', 'application/mods+xml'],\n    ['moov', 'video/quicktime'],\n    ['mov', 'video/quicktime'],\n    ['movie', 'video/x-sgi-movie'],\n    ['mp2', ['video/mpeg', 'audio/mpeg', 'video/x-mpeg', 'audio/x-mpeg', 'video/x-mpeq2a']],\n    ['mp3', ['audio/mpeg', 'audio/mpeg3', 'video/mpeg', 'audio/x-mpeg-3', 'video/x-mpeg']],\n    ['mp4', ['video/mp4', 'application/mp4']],\n    ['mp4a', 'audio/mp4'],\n    ['mpa', ['video/mpeg', 'audio/mpeg']],\n    ['mpc', ['application/vnd.mophun.certificate', 'application/x-project']],\n    ['mpe', 'video/mpeg'],\n    ['mpeg', 'video/mpeg'],\n    ['mpg', ['video/mpeg', 'audio/mpeg']],\n    ['mpga', 'audio/mpeg'],\n    ['mpkg', 'application/vnd.apple.installer+xml'],\n    ['mpm', 'application/vnd.blueice.multipass'],\n    ['mpn', 'application/vnd.mophun.application'],\n    ['mpp', 'application/vnd.ms-project'],\n    ['mpt', 'application/x-project'],\n    ['mpv', 'application/x-project'],\n    ['mpv2', 'video/mpeg'],\n    ['mpx', 'application/x-project'],\n    ['mpy', 'application/vnd.ibm.minipay'],\n    ['mqy', 'application/vnd.mobius.mqy'],\n    ['mrc', 'application/marc'],\n    ['mrcx', 'application/marcxml+xml'],\n    ['ms', 'application/x-troff-ms'],\n    ['mscml', 'application/mediaservercontrol+xml'],\n    ['mseq', 'application/vnd.mseq'],\n    ['msf', 'application/vnd.epson.msf'],\n    ['msg', 'application/vnd.ms-outlook'],\n    ['msh', 'model/mesh'],\n    ['msl', 'application/vnd.mobius.msl'],\n    ['msty', 'application/vnd.muvee.style'],\n    ['mts', 'model/vnd.mts'],\n    ['mus', 'application/vnd.musician'],\n    ['musicxml', 'application/vnd.recordare.musicxml+xml'],\n    ['mv', 'video/x-sgi-movie'],\n    ['mvb', 'application/x-msmediaview'],\n    ['mwf', 'application/vnd.mfer'],\n    ['mxf', 'application/mxf'],\n    ['mxl', 'application/vnd.recordare.musicxml'],\n    ['mxml', 'application/xv+xml'],\n    ['mxs', 'application/vnd.triscape.mxs'],\n    ['mxu', 'video/vnd.mpegurl'],\n    ['my', 'audio/make'],\n    ['mzz', 'application/x-vnd.audioexplosion.mzz'],\n    ['n-gage', 'application/vnd.nokia.n-gage.symbian.install'],\n    ['n3', 'text/n3'],\n    ['nap', 'image/naplps'],\n    ['naplps', 'image/naplps'],\n    ['nbp', 'application/vnd.wolfram.player'],\n    ['nc', 'application/x-netcdf'],\n    ['ncm', 'application/vnd.nokia.configuration-message'],\n    ['ncx', 'application/x-dtbncx+xml'],\n    ['ngdat', 'application/vnd.nokia.n-gage.data'],\n    ['nif', 'image/x-niff'],\n    ['niff', 'image/x-niff'],\n    ['nix', 'application/x-mix-transfer'],\n    ['nlu', 'application/vnd.neurolanguage.nlu'],\n    ['nml', 'application/vnd.enliven'],\n    ['nnd', 'application/vnd.noblenet-directory'],\n    ['nns', 'application/vnd.noblenet-sealer'],\n    ['nnw', 'application/vnd.noblenet-web'],\n    ['npx', 'image/vnd.net-fpx'],\n    ['nsc', 'application/x-conference'],\n    ['nsf', 'application/vnd.lotus-notes'],\n    ['nvd', 'application/x-navidoc'],\n    ['nws', 'message/rfc822'],\n    ['o', 'application/octet-stream'],\n    ['oa2', 'application/vnd.fujitsu.oasys2'],\n    ['oa3', 'application/vnd.fujitsu.oasys3'],\n    ['oas', 'application/vnd.fujitsu.oasys'],\n    ['obd', 'application/x-msbinder'],\n    ['oda', 'application/oda'],\n    ['odb', 'application/vnd.oasis.opendocument.database'],\n    ['odc', 'application/vnd.oasis.opendocument.chart'],\n    ['odf', 'application/vnd.oasis.opendocument.formula'],\n    ['odft', 'application/vnd.oasis.opendocument.formula-template'],\n    ['odg', 'application/vnd.oasis.opendocument.graphics'],\n    ['odi', 'application/vnd.oasis.opendocument.image'],\n    ['odm', 'application/vnd.oasis.opendocument.text-master'],\n    ['odp', 'application/vnd.oasis.opendocument.presentation'],\n    ['ods', 'application/vnd.oasis.opendocument.spreadsheet'],\n    ['odt', 'application/vnd.oasis.opendocument.text'],\n    ['oga', 'audio/ogg'],\n    ['ogv', 'video/ogg'],\n    ['ogx', 'application/ogg'],\n    ['omc', 'application/x-omc'],\n    ['omcd', 'application/x-omcdatamaker'],\n    ['omcr', 'application/x-omcregerator'],\n    ['onetoc', 'application/onenote'],\n    ['opf', 'application/oebps-package+xml'],\n    ['org', 'application/vnd.lotus-organizer'],\n    ['osf', 'application/vnd.yamaha.openscoreformat'],\n    ['osfpvg', 'application/vnd.yamaha.openscoreformat.osfpvg+xml'],\n    ['otc', 'application/vnd.oasis.opendocument.chart-template'],\n    ['otf', 'application/x-font-otf'],\n    ['otg', 'application/vnd.oasis.opendocument.graphics-template'],\n    ['oth', 'application/vnd.oasis.opendocument.text-web'],\n    ['oti', 'application/vnd.oasis.opendocument.image-template'],\n    ['otp', 'application/vnd.oasis.opendocument.presentation-template'],\n    ['ots', 'application/vnd.oasis.opendocument.spreadsheet-template'],\n    ['ott', 'application/vnd.oasis.opendocument.text-template'],\n    ['oxt', 'application/vnd.openofficeorg.extension'],\n    ['p', 'text/x-pascal'],\n    ['p10', ['application/pkcs10', 'application/x-pkcs10']],\n    ['p12', ['application/pkcs-12', 'application/x-pkcs12']],\n    ['p7a', 'application/x-pkcs7-signature'],\n    ['p7b', 'application/x-pkcs7-certificates'],\n    ['p7c', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],\n    ['p7m', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],\n    ['p7r', 'application/x-pkcs7-certreqresp'],\n    ['p7s', ['application/pkcs7-signature', 'application/x-pkcs7-signature']],\n    ['p8', 'application/pkcs8'],\n    ['par', 'text/plain-bas'],\n    ['part', 'application/pro_eng'],\n    ['pas', 'text/pascal'],\n    ['paw', 'application/vnd.pawaafile'],\n    ['pbd', 'application/vnd.powerbuilder6'],\n    ['pbm', 'image/x-portable-bitmap'],\n    ['pcf', 'application/x-font-pcf'],\n    ['pcl', ['application/vnd.hp-pcl', 'application/x-pcl']],\n    ['pclxl', 'application/vnd.hp-pclxl'],\n    ['pct', 'image/x-pict'],\n    ['pcurl', 'application/vnd.curl.pcurl'],\n    ['pcx', 'image/x-pcx'],\n    ['pdb', ['application/vnd.palm', 'chemical/x-pdb']],\n    ['pdf', 'application/pdf'],\n    ['pfa', 'application/x-font-type1'],\n    ['pfr', 'application/font-tdpfr'],\n    ['pfunk', ['audio/make', 'audio/make.my.funk']],\n    ['pfx', 'application/x-pkcs12'],\n    ['pgm', ['image/x-portable-graymap', 'image/x-portable-greymap']],\n    ['pgn', 'application/x-chess-pgn'],\n    ['pgp', 'application/pgp-signature'],\n    ['pic', ['image/pict', 'image/x-pict']],\n    ['pict', 'image/pict'],\n    ['pkg', 'application/x-newton-compatible-pkg'],\n    ['pki', 'application/pkixcmp'],\n    ['pkipath', 'application/pkix-pkipath'],\n    ['pko', ['application/ynd.ms-pkipko', 'application/vnd.ms-pki.pko']],\n    ['pl', ['text/plain', 'text/x-script.perl']],\n    ['plb', 'application/vnd.3gpp.pic-bw-large'],\n    ['plc', 'application/vnd.mobius.plc'],\n    ['plf', 'application/vnd.pocketlearn'],\n    ['pls', 'application/pls+xml'],\n    ['plx', 'application/x-pixclscript'],\n    ['pm', ['text/x-script.perl-module', 'image/x-xpixmap']],\n    ['pm4', 'application/x-pagemaker'],\n    ['pm5', 'application/x-pagemaker'],\n    ['pma', 'application/x-perfmon'],\n    ['pmc', 'application/x-perfmon'],\n    ['pml', ['application/vnd.ctc-posml', 'application/x-perfmon']],\n    ['pmr', 'application/x-perfmon'],\n    ['pmw', 'application/x-perfmon'],\n    ['png', 'image/png'],\n    ['pnm', ['application/x-portable-anymap', 'image/x-portable-anymap']],\n    ['portpkg', 'application/vnd.macports.portpkg'],\n    ['pot', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],\n    ['potm', 'application/vnd.ms-powerpoint.template.macroenabled.12'],\n    ['potx', 'application/vnd.openxmlformats-officedocument.presentationml.template'],\n    ['pov', 'model/x-pov'],\n    ['ppa', 'application/vnd.ms-powerpoint'],\n    ['ppam', 'application/vnd.ms-powerpoint.addin.macroenabled.12'],\n    ['ppd', 'application/vnd.cups-ppd'],\n    ['ppm', 'image/x-portable-pixmap'],\n    ['pps', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],\n    ['ppsm', 'application/vnd.ms-powerpoint.slideshow.macroenabled.12'],\n    ['ppsx', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow'],\n    ['ppt', ['application/vnd.ms-powerpoint', 'application/mspowerpoint', 'application/powerpoint', 'application/x-mspowerpoint']],\n    ['pptm', 'application/vnd.ms-powerpoint.presentation.macroenabled.12'],\n    ['pptx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'],\n    ['ppz', 'application/mspowerpoint'],\n    ['prc', 'application/x-mobipocket-ebook'],\n    ['pre', ['application/vnd.lotus-freelance', 'application/x-freelance']],\n    ['prf', 'application/pics-rules'],\n    ['prt', 'application/pro_eng'],\n    ['ps', 'application/postscript'],\n    ['psb', 'application/vnd.3gpp.pic-bw-small'],\n    ['psd', ['application/octet-stream', 'image/vnd.adobe.photoshop']],\n    ['psf', 'application/x-font-linux-psf'],\n    ['pskcxml', 'application/pskc+xml'],\n    ['ptid', 'application/vnd.pvi.ptid1'],\n    ['pub', 'application/x-mspublisher'],\n    ['pvb', 'application/vnd.3gpp.pic-bw-var'],\n    ['pvu', 'paleovu/x-pv'],\n    ['pwn', 'application/vnd.3m.post-it-notes'],\n    ['pwz', 'application/vnd.ms-powerpoint'],\n    ['py', 'text/x-script.phyton'],\n    ['pya', 'audio/vnd.ms-playready.media.pya'],\n    ['pyc', 'applicaiton/x-bytecode.python'],\n    ['pyv', 'video/vnd.ms-playready.media.pyv'],\n    ['qam', 'application/vnd.epson.quickanime'],\n    ['qbo', 'application/vnd.intu.qbo'],\n    ['qcp', 'audio/vnd.qcelp'],\n    ['qd3', 'x-world/x-3dmf'],\n    ['qd3d', 'x-world/x-3dmf'],\n    ['qfx', 'application/vnd.intu.qfx'],\n    ['qif', 'image/x-quicktime'],\n    ['qps', 'application/vnd.publishare-delta-tree'],\n    ['qt', 'video/quicktime'],\n    ['qtc', 'video/x-qtc'],\n    ['qti', 'image/x-quicktime'],\n    ['qtif', 'image/x-quicktime'],\n    ['qxd', 'application/vnd.quark.quarkxpress'],\n    ['ra', ['audio/x-realaudio', 'audio/x-pn-realaudio', 'audio/x-pn-realaudio-plugin']],\n    ['ram', 'audio/x-pn-realaudio'],\n    ['rar', 'application/x-rar-compressed'],\n    ['ras', ['image/cmu-raster', 'application/x-cmu-raster', 'image/x-cmu-raster']],\n    ['rast', 'image/cmu-raster'],\n    ['rcprofile', 'application/vnd.ipunplugged.rcprofile'],\n    ['rdf', 'application/rdf+xml'],\n    ['rdz', 'application/vnd.data-vision.rdz'],\n    ['rep', 'application/vnd.businessobjects'],\n    ['res', 'application/x-dtbresource+xml'],\n    ['rexx', 'text/x-script.rexx'],\n    ['rf', 'image/vnd.rn-realflash'],\n    ['rgb', 'image/x-rgb'],\n    ['rif', 'application/reginfo+xml'],\n    ['rip', 'audio/vnd.rip'],\n    ['rl', 'application/resource-lists+xml'],\n    ['rlc', 'image/vnd.fujixerox.edmics-rlc'],\n    ['rld', 'application/resource-lists-diff+xml'],\n    ['rm', ['application/vnd.rn-realmedia', 'audio/x-pn-realaudio']],\n    ['rmi', 'audio/mid'],\n    ['rmm', 'audio/x-pn-realaudio'],\n    ['rmp', ['audio/x-pn-realaudio-plugin', 'audio/x-pn-realaudio']],\n    ['rms', 'application/vnd.jcp.javame.midlet-rms'],\n    ['rnc', 'application/relax-ng-compact-syntax'],\n    ['rng', ['application/ringing-tones', 'application/vnd.nokia.ringing-tone']],\n    ['rnx', 'application/vnd.rn-realplayer'],\n    ['roff', 'application/x-troff'],\n    ['rp', 'image/vnd.rn-realpix'],\n    ['rp9', 'application/vnd.cloanto.rp9'],\n    ['rpm', 'audio/x-pn-realaudio-plugin'],\n    ['rpss', 'application/vnd.nokia.radio-presets'],\n    ['rpst', 'application/vnd.nokia.radio-preset'],\n    ['rq', 'application/sparql-query'],\n    ['rs', 'application/rls-services+xml'],\n    ['rsd', 'application/rsd+xml'],\n    ['rt', ['text/richtext', 'text/vnd.rn-realtext']],\n    ['rtf', ['application/rtf', 'text/richtext', 'application/x-rtf']],\n    ['rtx', ['text/richtext', 'application/rtf']],\n    ['rv', 'video/vnd.rn-realvideo'],\n    ['s', 'text/x-asm'],\n    ['s3m', 'audio/s3m'],\n    ['saf', 'application/vnd.yamaha.smaf-audio'],\n    ['saveme', 'application/octet-stream'],\n    ['sbk', 'application/x-tbook'],\n    ['sbml', 'application/sbml+xml'],\n    ['sc', 'application/vnd.ibm.secure-container'],\n    ['scd', 'application/x-msschedule'],\n    ['scm', ['application/vnd.lotus-screencam', 'video/x-scm', 'text/x-script.guile', 'application/x-lotusscreencam', 'text/x-script.scheme']],\n    ['scq', 'application/scvp-cv-request'],\n    ['scs', 'application/scvp-cv-response'],\n    ['sct', 'text/scriptlet'],\n    ['scurl', 'text/vnd.curl.scurl'],\n    ['sda', 'application/vnd.stardivision.draw'],\n    ['sdc', 'application/vnd.stardivision.calc'],\n    ['sdd', 'application/vnd.stardivision.impress'],\n    ['sdkm', 'application/vnd.solent.sdkm+xml'],\n    ['sdml', 'text/plain'],\n    ['sdp', ['application/sdp', 'application/x-sdp']],\n    ['sdr', 'application/sounder'],\n    ['sdw', 'application/vnd.stardivision.writer'],\n    ['sea', ['application/sea', 'application/x-sea']],\n    ['see', 'application/vnd.seemail'],\n    ['seed', 'application/vnd.fdsn.seed'],\n    ['sema', 'application/vnd.sema'],\n    ['semd', 'application/vnd.semd'],\n    ['semf', 'application/vnd.semf'],\n    ['ser', 'application/java-serialized-object'],\n    ['set', 'application/set'],\n    ['setpay', 'application/set-payment-initiation'],\n    ['setreg', 'application/set-registration-initiation'],\n    ['sfd-hdstx', 'application/vnd.hydrostatix.sof-data'],\n    ['sfs', 'application/vnd.spotfire.sfs'],\n    ['sgl', 'application/vnd.stardivision.writer-global'],\n    ['sgm', ['text/sgml', 'text/x-sgml']],\n    ['sgml', ['text/sgml', 'text/x-sgml']],\n    ['sh', ['application/x-shar', 'application/x-bsh', 'application/x-sh', 'text/x-script.sh']],\n    ['shar', ['application/x-bsh', 'application/x-shar']],\n    ['shf', 'application/shf+xml'],\n    ['shtml', ['text/html', 'text/x-server-parsed-html']],\n    ['sid', 'audio/x-psid'],\n    ['sis', 'application/vnd.symbian.install'],\n    ['sit', ['application/x-stuffit', 'application/x-sit']],\n    ['sitx', 'application/x-stuffitx'],\n    ['skd', 'application/x-koan'],\n    ['skm', 'application/x-koan'],\n    ['skp', ['application/vnd.koan', 'application/x-koan']],\n    ['skt', 'application/x-koan'],\n    ['sl', 'application/x-seelogo'],\n    ['sldm', 'application/vnd.ms-powerpoint.slide.macroenabled.12'],\n    ['sldx', 'application/vnd.openxmlformats-officedocument.presentationml.slide'],\n    ['slt', 'application/vnd.epson.salt'],\n    ['sm', 'application/vnd.stepmania.stepchart'],\n    ['smf', 'application/vnd.stardivision.math'],\n    ['smi', ['application/smil', 'application/smil+xml']],\n    ['smil', 'application/smil'],\n    ['snd', ['audio/basic', 'audio/x-adpcm']],\n    ['snf', 'application/x-font-snf'],\n    ['sol', 'application/solids'],\n    ['spc', ['text/x-speech', 'application/x-pkcs7-certificates']],\n    ['spf', 'application/vnd.yamaha.smaf-phrase'],\n    ['spl', ['application/futuresplash', 'application/x-futuresplash']],\n    ['spot', 'text/vnd.in3d.spot'],\n    ['spp', 'application/scvp-vp-response'],\n    ['spq', 'application/scvp-vp-request'],\n    ['spr', 'application/x-sprite'],\n    ['sprite', 'application/x-sprite'],\n    ['src', 'application/x-wais-source'],\n    ['sru', 'application/sru+xml'],\n    ['srx', 'application/sparql-results+xml'],\n    ['sse', 'application/vnd.kodak-descriptor'],\n    ['ssf', 'application/vnd.epson.ssf'],\n    ['ssi', 'text/x-server-parsed-html'],\n    ['ssm', 'application/streamingmedia'],\n    ['ssml', 'application/ssml+xml'],\n    ['sst', ['application/vnd.ms-pkicertstore', 'application/vnd.ms-pki.certstore']],\n    ['st', 'application/vnd.sailingtracker.track'],\n    ['stc', 'application/vnd.sun.xml.calc.template'],\n    ['std', 'application/vnd.sun.xml.draw.template'],\n    ['step', 'application/step'],\n    ['stf', 'application/vnd.wt.stf'],\n    ['sti', 'application/vnd.sun.xml.impress.template'],\n    ['stk', 'application/hyperstudio'],\n    ['stl', ['application/vnd.ms-pkistl', 'application/sla', 'application/vnd.ms-pki.stl', 'application/x-navistyle']],\n    ['stm', 'text/html'],\n    ['stp', 'application/step'],\n    ['str', 'application/vnd.pg.format'],\n    ['stw', 'application/vnd.sun.xml.writer.template'],\n    ['sub', 'image/vnd.dvb.subtitle'],\n    ['sus', 'application/vnd.sus-calendar'],\n    ['sv4cpio', 'application/x-sv4cpio'],\n    ['sv4crc', 'application/x-sv4crc'],\n    ['svc', 'application/vnd.dvb.service'],\n    ['svd', 'application/vnd.svd'],\n    ['svf', ['image/vnd.dwg', 'image/x-dwg']],\n    ['svg', 'image/svg+xml'],\n    ['svr', ['x-world/x-svr', 'application/x-world']],\n    ['swf', 'application/x-shockwave-flash'],\n    ['swi', 'application/vnd.aristanetworks.swi'],\n    ['sxc', 'application/vnd.sun.xml.calc'],\n    ['sxd', 'application/vnd.sun.xml.draw'],\n    ['sxg', 'application/vnd.sun.xml.writer.global'],\n    ['sxi', 'application/vnd.sun.xml.impress'],\n    ['sxm', 'application/vnd.sun.xml.math'],\n    ['sxw', 'application/vnd.sun.xml.writer'],\n    ['t', ['text/troff', 'application/x-troff']],\n    ['talk', 'text/x-speech'],\n    ['tao', 'application/vnd.tao.intent-module-archive'],\n    ['tar', 'application/x-tar'],\n    ['tbk', ['application/toolbook', 'application/x-tbook']],\n    ['tcap', 'application/vnd.3gpp2.tcap'],\n    ['tcl', ['text/x-script.tcl', 'application/x-tcl']],\n    ['tcsh', 'text/x-script.tcsh'],\n    ['teacher', 'application/vnd.smart.teacher'],\n    ['tei', 'application/tei+xml'],\n    ['tex', 'application/x-tex'],\n    ['texi', 'application/x-texinfo'],\n    ['texinfo', 'application/x-texinfo'],\n    ['text', ['application/plain', 'text/plain']],\n    ['tfi', 'application/thraud+xml'],\n    ['tfm', 'application/x-tex-tfm'],\n    ['tgz', ['application/gnutar', 'application/x-compressed']],\n    ['thmx', 'application/vnd.ms-officetheme'],\n    ['tif', ['image/tiff', 'image/x-tiff']],\n    ['tiff', ['image/tiff', 'image/x-tiff']],\n    ['tmo', 'application/vnd.tmobile-livetv'],\n    ['torrent', 'application/x-bittorrent'],\n    ['tpl', 'application/vnd.groove-tool-template'],\n    ['tpt', 'application/vnd.trid.tpt'],\n    ['tr', 'application/x-troff'],\n    ['tra', 'application/vnd.trueapp'],\n    ['trm', 'application/x-msterminal'],\n    ['tsd', 'application/timestamped-data'],\n    ['tsi', 'audio/tsp-audio'],\n    ['tsp', ['application/dsptype', 'audio/tsplayer']],\n    ['tsv', 'text/tab-separated-values'],\n    ['ttf', 'application/x-font-ttf'],\n    ['ttl', 'text/turtle'],\n    ['turbot', 'image/florian'],\n    ['twd', 'application/vnd.simtech-mindmapper'],\n    ['txd', 'application/vnd.genomatix.tuxedo'],\n    ['txf', 'application/vnd.mobius.txf'],\n    ['txt', 'text/plain'],\n    ['ufd', 'application/vnd.ufdl'],\n    ['uil', 'text/x-uil'],\n    ['uls', 'text/iuls'],\n    ['umj', 'application/vnd.umajin'],\n    ['uni', 'text/uri-list'],\n    ['unis', 'text/uri-list'],\n    ['unityweb', 'application/vnd.unity'],\n    ['unv', 'application/i-deas'],\n    ['uoml', 'application/vnd.uoml+xml'],\n    ['uri', 'text/uri-list'],\n    ['uris', 'text/uri-list'],\n    ['ustar', ['application/x-ustar', 'multipart/x-ustar']],\n    ['utz', 'application/vnd.uiq.theme'],\n    ['uu', ['application/octet-stream', 'text/x-uuencode']],\n    ['uue', 'text/x-uuencode'],\n    ['uva', 'audio/vnd.dece.audio'],\n    ['uvh', 'video/vnd.dece.hd'],\n    ['uvi', 'image/vnd.dece.graphic'],\n    ['uvm', 'video/vnd.dece.mobile'],\n    ['uvp', 'video/vnd.dece.pd'],\n    ['uvs', 'video/vnd.dece.sd'],\n    ['uvu', 'video/vnd.uvvu.mp4'],\n    ['uvv', 'video/vnd.dece.video'],\n    ['vcd', 'application/x-cdlink'],\n    ['vcf', 'text/x-vcard'],\n    ['vcg', 'application/vnd.groove-vcard'],\n    ['vcs', 'text/x-vcalendar'],\n    ['vcx', 'application/vnd.vcx'],\n    ['vda', 'application/vda'],\n    ['vdo', 'video/vdo'],\n    ['vew', 'application/groupwise'],\n    ['vis', 'application/vnd.visionary'],\n    ['viv', ['video/vivo', 'video/vnd.vivo']],\n    ['vivo', ['video/vivo', 'video/vnd.vivo']],\n    ['vmd', 'application/vocaltec-media-desc'],\n    ['vmf', 'application/vocaltec-media-file'],\n    ['voc', ['audio/voc', 'audio/x-voc']],\n    ['vos', 'video/vosaic'],\n    ['vox', 'audio/voxware'],\n    ['vqe', 'audio/x-twinvq-plugin'],\n    ['vqf', 'audio/x-twinvq'],\n    ['vql', 'audio/x-twinvq-plugin'],\n    ['vrml', ['model/vrml', 'x-world/x-vrml', 'application/x-vrml']],\n    ['vrt', 'x-world/x-vrt'],\n    ['vsd', ['application/vnd.visio', 'application/x-visio']],\n    ['vsf', 'application/vnd.vsf'],\n    ['vst', 'application/x-visio'],\n    ['vsw', 'application/x-visio'],\n    ['vtu', 'model/vnd.vtu'],\n    ['vxml', 'application/voicexml+xml'],\n    ['w60', 'application/wordperfect6.0'],\n    ['w61', 'application/wordperfect6.1'],\n    ['w6w', 'application/msword'],\n    ['wad', 'application/x-doom'],\n    ['wav', ['audio/wav', 'audio/x-wav']],\n    ['wax', 'audio/x-ms-wax'],\n    ['wb1', 'application/x-qpro'],\n    ['wbmp', 'image/vnd.wap.wbmp'],\n    ['wbs', 'application/vnd.criticaltools.wbs+xml'],\n    ['wbxml', 'application/vnd.wap.wbxml'],\n    ['wcm', 'application/vnd.ms-works'],\n    ['wdb', 'application/vnd.ms-works'],\n    ['web', 'application/vnd.xara'],\n    ['weba', 'audio/webm'],\n    ['webm', 'video/webm'],\n    ['webp', 'image/webp'],\n    ['wg', 'application/vnd.pmi.widget'],\n    ['wgt', 'application/widget'],\n    ['wiz', 'application/msword'],\n    ['wk1', 'application/x-123'],\n    ['wks', 'application/vnd.ms-works'],\n    ['wm', 'video/x-ms-wm'],\n    ['wma', 'audio/x-ms-wma'],\n    ['wmd', 'application/x-ms-wmd'],\n    ['wmf', ['windows/metafile', 'application/x-msmetafile']],\n    ['wml', 'text/vnd.wap.wml'],\n    ['wmlc', 'application/vnd.wap.wmlc'],\n    ['wmls', 'text/vnd.wap.wmlscript'],\n    ['wmlsc', 'application/vnd.wap.wmlscriptc'],\n    ['wmv', 'video/x-ms-wmv'],\n    ['wmx', 'video/x-ms-wmx'],\n    ['wmz', 'application/x-ms-wmz'],\n    ['woff', 'application/x-font-woff'],\n    ['word', 'application/msword'],\n    ['wp', 'application/wordperfect'],\n    ['wp5', ['application/wordperfect', 'application/wordperfect6.0']],\n    ['wp6', 'application/wordperfect'],\n    ['wpd', ['application/wordperfect', 'application/vnd.wordperfect', 'application/x-wpwin']],\n    ['wpl', 'application/vnd.ms-wpl'],\n    ['wps', 'application/vnd.ms-works'],\n    ['wq1', 'application/x-lotus'],\n    ['wqd', 'application/vnd.wqd'],\n    ['wri', ['application/mswrite', 'application/x-wri', 'application/x-mswrite']],\n    ['wrl', ['model/vrml', 'x-world/x-vrml', 'application/x-world']],\n    ['wrz', ['model/vrml', 'x-world/x-vrml']],\n    ['wsc', 'text/scriplet'],\n    ['wsdl', 'application/wsdl+xml'],\n    ['wspolicy', 'application/wspolicy+xml'],\n    ['wsrc', 'application/x-wais-source'],\n    ['wtb', 'application/vnd.webturbo'],\n    ['wtk', 'application/x-wintalk'],\n    ['wvx', 'video/x-ms-wvx'],\n    ['x-png', 'image/png'],\n    ['x3d', 'application/vnd.hzn-3d-crossword'],\n    ['xaf', 'x-world/x-vrml'],\n    ['xap', 'application/x-silverlight-app'],\n    ['xar', 'application/vnd.xara'],\n    ['xbap', 'application/x-ms-xbap'],\n    ['xbd', 'application/vnd.fujixerox.docuworks.binder'],\n    ['xbm', ['image/xbm', 'image/x-xbm', 'image/x-xbitmap']],\n    ['xdf', 'application/xcap-diff+xml'],\n    ['xdm', 'application/vnd.syncml.dm+xml'],\n    ['xdp', 'application/vnd.adobe.xdp+xml'],\n    ['xdr', 'video/x-amt-demorun'],\n    ['xdssc', 'application/dssc+xml'],\n    ['xdw', 'application/vnd.fujixerox.docuworks'],\n    ['xenc', 'application/xenc+xml'],\n    ['xer', 'application/patch-ops-error+xml'],\n    ['xfdf', 'application/vnd.adobe.xfdf'],\n    ['xfdl', 'application/vnd.xfdl'],\n    ['xgz', 'xgl/drawing'],\n    ['xhtml', 'application/xhtml+xml'],\n    ['xif', 'image/vnd.xiff'],\n    ['xl', 'application/excel'],\n    ['xla', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xlam', 'application/vnd.ms-excel.addin.macroenabled.12'],\n    ['xlb', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],\n    ['xlc', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xld', ['application/excel', 'application/x-excel']],\n    ['xlk', ['application/excel', 'application/x-excel']],\n    ['xll', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],\n    ['xlm', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xls', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xlsb', 'application/vnd.ms-excel.sheet.binary.macroenabled.12'],\n    ['xlsm', 'application/vnd.ms-excel.sheet.macroenabled.12'],\n    ['xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],\n    ['xlt', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xltm', 'application/vnd.ms-excel.template.macroenabled.12'],\n    ['xltx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template'],\n    ['xlv', ['application/excel', 'application/x-excel']],\n    ['xlw', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xm', 'audio/xm'],\n    ['xml', ['application/xml', 'text/xml', 'application/atom+xml', 'application/rss+xml']],\n    ['xmz', 'xgl/movie'],\n    ['xo', 'application/vnd.olpc-sugar'],\n    ['xof', 'x-world/x-vrml'],\n    ['xop', 'application/xop+xml'],\n    ['xpi', 'application/x-xpinstall'],\n    ['xpix', 'application/x-vnd.ls-xpix'],\n    ['xpm', ['image/xpm', 'image/x-xpixmap']],\n    ['xpr', 'application/vnd.is-xpr'],\n    ['xps', 'application/vnd.ms-xpsdocument'],\n    ['xpw', 'application/vnd.intercon.formnet'],\n    ['xslt', 'application/xslt+xml'],\n    ['xsm', 'application/vnd.syncml+xml'],\n    ['xspf', 'application/xspf+xml'],\n    ['xsr', 'video/x-amt-showrun'],\n    ['xul', 'application/vnd.mozilla.xul+xml'],\n    ['xwd', ['image/x-xwd', 'image/x-xwindowdump']],\n    ['xyz', ['chemical/x-xyz', 'chemical/x-pdb']],\n    ['yang', 'application/yang'],\n    ['yin', 'application/yin+xml'],\n    ['z', ['application/x-compressed', 'application/x-compress']],\n    ['zaz', 'application/vnd.zzazz.deck+xml'],\n    ['zip', ['application/zip', 'multipart/x-zip', 'application/x-zip-compressed', 'application/x-compressed']],\n    ['zir', 'application/vnd.zul'],\n    ['zmm', 'application/vnd.handheld-entertainment+xml'],\n    ['zoo', 'application/octet-stream'],\n    ['zsh', 'text/x-script.zsh']\n]);\n\nmodule.exports = {\n    detectMimeType(filename) {\n        if (!filename) {\n            return defaultMimeType;\n        }\n\n        let parsed = path.parse(filename);\n        let extension = (parsed.ext.substr(1) || parsed.name || '')\n            .split('?')\n            .shift()\n            .trim()\n            .toLowerCase();\n        let value = defaultMimeType;\n\n        if (extensions.has(extension)) {\n            value = extensions.get(extension);\n        }\n\n        if (Array.isArray(value)) {\n            return value[0];\n        }\n        return value;\n    },\n\n    detectExtension(mimeType) {\n        if (!mimeType) {\n            return defaultExtension;\n        }\n        let parts = (mimeType || '')\n            .toLowerCase()\n            .trim()\n            .split('/');\n        let rootType = parts.shift().trim();\n        let subType = parts.join('/').trim();\n\n        if (mimeTypes.has(rootType + '/' + subType)) {\n            let value = mimeTypes.get(rootType + '/' + subType);\n            if (Array.isArray(value)) {\n                return value[0];\n            }\n            return value;\n        }\n\n        switch (rootType) {\n            case 'text':\n                return 'txt';\n            default:\n                return 'bin';\n        }\n    }\n};\n", "'use strict';\n\nconst Mailer = require('./mailer');\nconst shared = require('./shared');\nconst SMTPPool = require('./smtp-pool');\nconst SMTPTransport = require('./smtp-transport');\nconst SendmailTransport = require('./sendmail-transport');\nconst StreamTransport = require('./stream-transport');\nconst JSONTransport = require('./json-transport');\nconst SESTransport = require('./ses-transport');\nconst fetch = require('./fetch');\nconst packageData = require('../package.json');\n\nconst ETHEREAL_API = (process.env.ETHEREAL_API || 'https://api.nodemailer.com').replace(/\\/+$/, '');\nconst ETHEREAL_WEB = (process.env.ETHEREAL_WEB || 'https://ethereal.email').replace(/\\/+$/, '');\nconst ETHEREAL_CACHE = ['true', 'yes', 'y', '1'].includes(\n    (process.env.ETHEREAL_CACHE || 'yes')\n        .toString()\n        .trim()\n        .toLowerCase()\n);\n\nlet testAccount = false;\n\nmodule.exports.createTransport = function(transporter, defaults) {\n    let urlConfig;\n    let options;\n    let mailer;\n\n    if (\n        // provided transporter is a configuration object, not transporter plugin\n        (typeof transporter === 'object' && typeof transporter.send !== 'function') ||\n        // provided transporter looks like a connection url\n        (typeof transporter === 'string' && /^(smtps?|direct):/i.test(transporter))\n    ) {\n        if ((urlConfig = typeof transporter === 'string' ? transporter : transporter.url)) {\n            // parse a configuration URL into configuration options\n            options = shared.parseConnectionUrl(urlConfig);\n        } else {\n            options = transporter;\n        }\n\n        if (options.pool) {\n            transporter = new SMTPPool(options);\n        } else if (options.sendmail) {\n            transporter = new SendmailTransport(options);\n        } else if (options.streamTransport) {\n            transporter = new StreamTransport(options);\n        } else if (options.jsonTransport) {\n            transporter = new JSONTransport(options);\n        } else if (options.SES) {\n            transporter = new SESTransport(options);\n        } else {\n            transporter = new SMTPTransport(options);\n        }\n    }\n\n    mailer = new Mailer(transporter, options, defaults);\n\n    return mailer;\n};\n\nmodule.exports.createTestAccount = function(apiUrl, callback) {\n    let promise;\n\n    if (!callback && typeof apiUrl === 'function') {\n        callback = apiUrl;\n        apiUrl = false;\n    }\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = shared.callbackPromise(resolve, reject);\n        });\n    }\n\n    if (ETHEREAL_CACHE && testAccount) {\n        setImmediate(() => callback(null, testAccount));\n        return promise;\n    }\n\n    apiUrl = apiUrl || ETHEREAL_API;\n\n    let chunks = [];\n    let chunklen = 0;\n\n    let req = fetch(apiUrl + '/user', {\n        contentType: 'application/json',\n        method: 'POST',\n        body: Buffer.from(\n            JSON.stringify({\n                requestor: packageData.name,\n                version: packageData.version\n            })\n        )\n    });\n\n    req.on('readable', () => {\n        let chunk;\n        while ((chunk = req.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    req.once('error', err => callback(err));\n\n    req.once('end', () => {\n        let res = Buffer.concat(chunks, chunklen);\n        let data;\n        let err;\n        try {\n            data = JSON.parse(res.toString());\n        } catch (E) {\n            err = E;\n        }\n        if (err) {\n            return callback(err);\n        }\n        if (data.status !== 'success' || data.error) {\n            return callback(new Error(data.error || 'Request failed'));\n        }\n        delete data.status;\n        testAccount = data;\n        callback(null, testAccount);\n    });\n\n    return promise;\n};\n\nmodule.exports.getTestMessageUrl = function(info) {\n    if (!info || !info.response) {\n        return false;\n    }\n\n    let infoProps = new Map();\n    info.response.replace(/\\[([^\\]]+)\\]$/, (m, props) => {\n        props.replace(/\\b([A-Z0-9]+)=([^\\s]+)/g, (m, key, value) => {\n            infoProps.set(key, value);\n        });\n    });\n\n    if (infoProps.has('STATUS') && infoProps.has('MSGID')) {\n        return (testAccount.web || ETHEREAL_WEB) + '/message/' + infoProps.get('MSGID');\n    }\n\n    return false;\n};\n", "'use strict';\n\nconst spawn = require('child_process').spawn;\nconst packageData = require('../../package.json');\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\nconst shared = require('../shared');\n\n/**\n * Generates a Transport object for Sendmail\n *\n * Possible options can be the following:\n *\n *  * **path** optional path to sendmail binary\n *  * **newline** either 'windows' or 'unix'\n *  * **args** an array of arguments for the sendmail binary\n *\n * @constructor\n * @param {Object} optional config parameter for Sendmail\n */\nclass SendmailTransport {\n    constructor(options) {\n        options = options || {};\n\n        // use a reference to spawn for mocking purposes\n        this._spawn = spawn;\n\n        this.options = options || {};\n\n        this.name = 'Sendmail';\n        this.version = packageData.version;\n\n        this.path = 'sendmail';\n        this.args = false;\n        this.winbreak = false;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'sendmail'\n        });\n\n        if (options) {\n            if (typeof options === 'string') {\n                this.path = options;\n            } else if (typeof options === 'object') {\n                if (options.path) {\n                    this.path = options.path;\n                }\n                if (Array.isArray(options.args)) {\n                    this.args = options.args;\n                }\n                this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n            }\n        }\n    }\n\n    /**\n     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    send(mail, done) {\n        // Sendmail strips this header line by itself\n        mail.message.keepBcc = true;\n\n        let envelope = mail.data.envelope || mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n        let args;\n        let sendmail;\n        let returned;\n        let transform;\n\n        if (this.args) {\n            // force -i to keep single dots\n            args = ['-i'].concat(this.args).concat(envelope.to);\n        } else {\n            args = ['-i'].concat(envelope.from ? ['-f', envelope.from] : []).concat(envelope.to);\n        }\n\n        let callback = err => {\n            if (returned) {\n                // ignore any additional responses, already done\n                return;\n            }\n            returned = true;\n            if (typeof done === 'function') {\n                if (err) {\n                    return done(err);\n                } else {\n                    return done(null, {\n                        envelope: mail.data.envelope || mail.message.getEnvelope(),\n                        messageId,\n                        response: 'Messages queued for delivery'\n                    });\n                }\n            }\n        };\n\n        try {\n            sendmail = this._spawn(this.path, args);\n        } catch (E) {\n            this.logger.error(\n                {\n                    err: E,\n                    tnx: 'spawn',\n                    messageId\n                },\n                'Error occurred while spawning sendmail. %s',\n                E.message\n            );\n            return callback(E);\n        }\n\n        if (sendmail) {\n            sendmail.on('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'spawn',\n                        messageId\n                    },\n                    'Error occurred when sending message %s. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n\n            sendmail.once('exit', code => {\n                if (!code) {\n                    return callback();\n                }\n                let err;\n                if (code === 127) {\n                    err = new Error('Sendmail command not found, process exited with code ' + code);\n                } else {\n                    err = new Error('Sendmail exited with code ' + code);\n                }\n\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error sending message %s to sendmail. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n            sendmail.once('close', callback);\n\n            sendmail.stdin.on('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error occurred when piping message %s to sendmail. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n\n            let recipients = [].concat(envelope.to || []);\n            if (recipients.length > 3) {\n                recipients.push('...and ' + recipients.splice(2).length + ' more');\n            }\n            this.logger.info(\n                {\n                    tnx: 'send',\n                    messageId\n                },\n                'Sending message %s to <%s>',\n                messageId,\n                recipients.join(', ')\n            );\n\n            transform = this.winbreak ? new LeWindows() : new LeUnix();\n            let sourceStream = mail.message.createReadStream();\n\n            transform.once('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error occurred when generating message %s. %s',\n                    messageId,\n                    err.message\n                );\n                sendmail.kill('SIGINT'); // do not deliver the message\n                callback(err);\n            });\n\n            sourceStream.once('error', err => transform.emit('error', err));\n            sourceStream.pipe(transform).pipe(sendmail.stdin);\n        } else {\n            return callback(new Error('sendmail was not found'));\n        }\n    }\n}\n\nmodule.exports = SendmailTransport;\n", "/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst fetch = require('../fetch');\nconst dns = require('dns');\nconst net = require('net');\n\nconst DNS_TTL = 5 * 60 * 1000;\n\nconst resolver = (family, hostname, callback) => {\n    dns['resolve' + family](hostname, (err, addresses) => {\n        if (err) {\n            switch (err.code) {\n                case dns.NODATA:\n                case dns.NOTFOUND:\n                case dns.NOTIMP:\n                case dns.SERVFAIL:\n                case dns.CONNREFUSED:\n                case 'EAI_AGAIN':\n                    return callback(null, []);\n            }\n            return callback(err);\n        }\n        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n    });\n};\n\nconst dnsCache = (module.exports.dnsCache = new Map());\nmodule.exports.resolveHostname = (options, callback) => {\n    options = options || {};\n\n    if (!options.host || net.isIP(options.host)) {\n        // nothing to do here\n        let value = {\n            host: options.host,\n            servername: options.servername || false\n        };\n        return callback(null, value);\n    }\n\n    let cached;\n\n    if (dnsCache.has(options.host)) {\n        cached = dnsCache.get(options.host);\n        if (!cached.expires || cached.expires >= Date.now()) {\n            return callback(null, {\n                host: cached.value.host,\n                servername: cached.value.servername,\n                _cached: true\n            });\n        }\n    }\n\n    resolver(4, options.host, (err, addresses) => {\n        if (err) {\n            if (cached) {\n                // ignore error, use expired value\n                return callback(null, cached.value);\n            }\n            return callback(err);\n        }\n        if (addresses && addresses.length) {\n            let value = {\n                host: addresses[0] || options.host,\n                servername: options.servername || options.host\n            };\n            dnsCache.set(options.host, {\n                value,\n                expires: Date.now() + DNS_TTL\n            });\n            return callback(null, value);\n        }\n\n        resolver(6, options.host, (err, addresses) => {\n            if (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(null, cached.value);\n                }\n                return callback(err);\n            }\n            if (addresses && addresses.length) {\n                let value = {\n                    host: addresses[0] || options.host,\n                    servername: options.servername || options.host\n                };\n                dnsCache.set(options.host, {\n                    value,\n                    expires: Date.now() + DNS_TTL\n                });\n                return callback(null, value);\n            }\n\n            try {\n                dns.lookup(options.host, {}, (err, address) => {\n                    if (err) {\n                        if (cached) {\n                            // ignore error, use expired value\n                            return callback(null, cached.value);\n                        }\n                        return callback(err);\n                    }\n\n                    if (!address && cached) {\n                        // nothing was found, fallback to cached value\n                        return callback(null, cached.value);\n                    }\n\n                    let value = {\n                        host: address || options.host,\n                        servername: options.servername || options.host\n                    };\n                    dnsCache.set(options.host, {\n                        value,\n                        expires: Date.now() + DNS_TTL\n                    });\n                    return callback(null, value);\n                });\n            } catch (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(null, cached.value);\n                }\n                return callback(err);\n            }\n        });\n    });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n    str = str || '';\n    let options = {};\n\n    [urllib.parse(str, true)].forEach(url => {\n        let auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = auth.shift();\n            options.auth.pass = auth.join(':');\n        }\n\n        Object.keys(url.query || {}).forEach(key => {\n            let obj = options;\n            let lKey = key;\n            let value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n    let entry = {};\n\n    Object.keys(defaults || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = defaults[key];\n        }\n    });\n\n    Object.keys(data || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = data[key];\n        }\n    });\n\n    logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n    options = options || {};\n\n    let response = {};\n    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n    if (!options.logger) {\n        // use vanity logger\n        levels.forEach(level => {\n            response[level] = () => false;\n        });\n        return response;\n    }\n\n    let logger = options.logger;\n\n    if (options.logger === true) {\n        // create console logger\n        logger = createDefaultLogger(levels);\n    }\n\n    levels.forEach(level => {\n        response[level] = (data, message, ...args) => {\n            module.exports._logFunc(logger, level, defaults, data, message, ...args);\n        };\n    });\n\n    return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) =>\n    function() {\n        let args = Array.from(arguments);\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n    let promise;\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    let content = (data && data[key] && data[key].content) || data[key];\n    let contentStream;\n    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                data[key] = value;\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = fetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n            if (!parts) {\n                return callback(null, Buffer.from(0));\n            }\n            return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        content = Buffer.from(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(() => callback(null, content));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function(/* target, ... sources */) {\n    let args = Array.from(arguments);\n    let target = args.shift() || {};\n\n    args.forEach(source => {\n        Object.keys(source || {}).forEach(key => {\n            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // ensure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(subKey => {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n};\n\nmodule.exports.encodeXText = str => {\n    // ! 0x21\n    // + 0x2B\n    // = 0x3D\n    // ~ 0x7E\n    if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n        return str;\n    }\n    let buf = Buffer.from(str);\n    let result = '';\n    for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n        } else {\n            result += String.fromCharCode(c);\n        }\n    }\n    return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    let responded = false;\n    let chunks = [];\n    let chunklen = 0;\n\n    stream.on('error', err => {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', () => {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        let value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n    let levelMaxLen = 0;\n    let levelNames = new Map();\n    levels.forEach(level => {\n        if (level.length > levelMaxLen) {\n            levelMaxLen = level.length;\n        }\n    });\n\n    levels.forEach(level => {\n        let levelName = level.toUpperCase();\n        if (levelName.length < levelMaxLen) {\n            levelName += ' '.repeat(levelMaxLen - levelName.length);\n        }\n        levelNames.set(level, levelName);\n    });\n\n    let print = (level, entry, message, ...args) => {\n        let prefix = '';\n        if (entry) {\n            if (entry.tnx === 'server') {\n                prefix = 'S: ';\n            } else if (entry.tnx === 'client') {\n                prefix = 'C: ';\n            }\n\n            if (entry.sid) {\n                prefix = '[' + entry.sid + '] ' + prefix;\n            }\n\n            if (entry.cid) {\n                prefix = '[#' + entry.cid + '] ' + prefix;\n            }\n        }\n\n        message = util.format(message, ...args);\n        message.split(/\\r?\\n/).forEach(line => {\n            console.log(\n                '[%s] %s %s',\n                new Date()\n                    .toISOString()\n                    .substr(0, 19)\n                    .replace(/T/, ' '),\n                levelNames.get(level),\n                prefix + line\n            );\n        });\n    };\n\n    let logger = {};\n    levels.forEach(level => {\n        logger[level] = print.bind(null, level);\n    });\n\n    return logger;\n}\n", "'use strict';\n\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = require('net');\nconst tls = require('tls');\nconst urllib = require('url');\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n    let proxy = urllib.parse(proxyUrl);\n\n    // create a socket connection to the proxy server\n    let options;\n    let connect;\n    let socket;\n\n    options = {\n        host: proxy.hostname,\n        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n    };\n\n    if (proxy.protocol === 'https:') {\n        // we can use untrusted proxies as long as we verify actual SMTP certificates\n        options.rejectUnauthorized = false;\n        connect = tls.connect.bind(tls);\n    } else {\n        connect = net.connect.bind(net);\n    }\n\n    // Error harness for initial connection. Once connection is established, the responsibility\n    // to handle errors is passed to whoever uses this socket\n    let finished = false;\n    let tempSocketErr = function(err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        try {\n            socket.destroy();\n        } catch (E) {\n            // ignore\n        }\n        callback(err);\n    };\n\n    socket = connect(options, () => {\n        if (finished) {\n            return;\n        }\n\n        let reqHeaders = {\n            Host: destinationHost + ':' + destinationPort,\n            Connection: 'close'\n        };\n        if (proxy.auth) {\n            reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n        }\n\n        socket.write(\n            // HTTP method\n            'CONNECT ' +\n                destinationHost +\n                ':' +\n                destinationPort +\n                ' HTTP/1.1\\r\\n' +\n                // HTTP request headers\n                Object.keys(reqHeaders)\n                    .map(key => key + ': ' + reqHeaders[key])\n                    .join('\\r\\n') +\n                // End request\n                '\\r\\n\\r\\n'\n        );\n\n        let headers = '';\n        let onSocketData = chunk => {\n            let match;\n            let remainder;\n\n            if (finished) {\n                return;\n            }\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n\n                // proxy connection is now established\n                finished = true;\n\n                // check response code\n                match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n                if (!match || (match[1] || '').charAt(0) !== '2') {\n                    try {\n                        socket.destroy();\n                    } catch (E) {\n                        // ignore\n                    }\n                    return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));\n                }\n\n                socket.removeListener('error', tempSocketErr);\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;\n", "'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto\n            .randomBytes(8)\n            .toString('base64')\n            .replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        this.customAuth = new Map();\n        Object.keys(this.options.customAuth || {}).forEach(key => {\n            let mapKey = (key || '')\n                .toString()\n                .trim()\n                .toUpperCase();\n            if (!mapKey) {\n                return;\n            }\n            this.customAuth.set(mapKey, this.options.customAuth[key]);\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @publick\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Set to true, if EHLO response includes \"AUTH\".\n         * If false then authentication is not tried\n         */\n        this.allowsAuth = false;\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n\n        /**\n         * Callbacks for socket's listeners\n         */\n        this._onSocketData = chunk => this._onData(chunk);\n        this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n        this._onSocketClose = () => this._onClose();\n        this._onSocketEnd = () => this._onEnd();\n        this._onSocketTimeout = () => this._onTimeout();\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'SMTP handshake finished'\n                );\n                connectCallback();\n            });\n\n            const isDestroyedMessage = this._isDestroyedMessage('connect');\n            if (isDestroyedMessage) {\n                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        let setupConnectionHandlers = () => {\n            this._connectionTimeout = setTimeout(() => {\n                this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n            this._socket.on('error', this._onSocketError);\n        };\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() =>\n                    this._upgradeConnection(err => {\n                        if (err) {\n                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                            return;\n                        }\n                        this._onConnect();\n                    })\n                );\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n            return;\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved._cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved._cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket.connect(this.port, this.host, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved._cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved._cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = tls.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else {\n            // connect using plaintext\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved._cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved._cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = net.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        }\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug(\n            {\n                tnx: 'smtp'\n            },\n            'Closing connection to the server using \"%s\"',\n            closeMethod\n        );\n\n        let socket = (this._socket && this._socket.socket) || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                this._socket[closeMethod]();\n            } catch (E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        const isDestroyedMessage = this._isDestroyedMessage('login');\n        if (isDestroyedMessage) {\n            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        this._auth = authData || {};\n        // Select SASL authentication method\n        this._authMethod =\n            (this._auth.method || '')\n                .toString()\n                .trim()\n                .toUpperCase() || false;\n\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n            if (this._auth.user && this._auth.pass) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass,\n                    options: this._auth.options\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        if (this.customAuth.has(this._authMethod)) {\n            let handler = this.customAuth.get(this._authMethod);\n            let lastResponse;\n            let returned = false;\n\n            let resolve = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authenticated',\n                        method: this._authMethod\n                    },\n                    'User %s authenticated',\n                    JSON.stringify(this._auth.user)\n                );\n                this.authenticated = true;\n                callback(null, true);\n            };\n\n            let reject = err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n            };\n\n            let handlerResponse = handler({\n                auth: this._auth,\n                method: this._authMethod,\n\n                extensions: [].concat(this._supportedExtensions),\n                authMethods: [].concat(this._supportedAuth),\n                maxAllowedSize: this._maxAllowedSize || false,\n\n                sendCommand: (cmd, done) => {\n                    let promise;\n\n                    if (!done) {\n                        promise = new Promise((resolve, reject) => {\n                            done = shared.callbackPromise(resolve, reject);\n                        });\n                    }\n\n                    this._responseActions.push(str => {\n                        lastResponse = str;\n\n                        let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n                        let data = {\n                            command: cmd,\n                            response: str\n                        };\n                        if (codes) {\n                            data.status = Number(codes[1]) || 0;\n                            if (codes[2]) {\n                                data.code = codes[2];\n                            }\n                            data.text = str.substr(codes[0].length);\n                        } else {\n                            data.text = str;\n                            data.status = 0; // just in case we need to perform numeric comparisons\n                        }\n                        done(null, data);\n                    });\n                    setImmediate(() => this._sendCommand(cmd));\n\n                    return promise;\n                },\n\n                resolve,\n                reject\n            });\n\n            if (handlerResponse && typeof handlerResponse.catch === 'function') {\n                // a promise was returned\n                handlerResponse.then(resolve).catch(reject);\n            }\n\n            return;\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand(\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                this._auth.credentials.pass,\n                            'utf-8'\n                        ).toString('base64')\n                );\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        const isDestroyedMessage = this._isDestroyedMessage('send message');\n        if (isDestroyedMessage) {\n            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function() {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        let startTime = Date.now();\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                return callback(err);\n            }\n            let envelopeTime = Date.now();\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                info.envelopeTime = envelopeTime - startTime;\n                info.messageTime = Date.now() - envelopeTime;\n                info.messageSize = stream.outByteCount;\n                info.response = str;\n\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info(\n            {\n                tnx: 'network',\n                localAddress: this._socket.localAddress,\n                localPort: this._socket.localPort,\n                remoteAddress: this._socket.remoteAddress,\n                remotePort: this._socket.remotePort\n            },\n            '%s established to %s:%s',\n            this.secure ? 'Secure connection' : 'Connection',\n            this._socket.remoteAddress,\n            this._socket.remotePort\n        );\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeListener('data', this._onSocketData);\n        this._socket.removeListener('timeout', this._onSocketTimeout);\n        this._socket.removeListener('close', this._onSocketClose);\n        this._socket.removeListener('end', this._onSocketEnd);\n\n        this._socket.on('data', this._onSocketData);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        if (this._responseQueue.length) {\n            lastline = this._responseQueue[this._responseQueue.length - 1];\n            if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                return;\n            }\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = (typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0])) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        this.logger.info(\n            {\n                tnx: 'network'\n            },\n            'Connection closed'\n        );\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        if (this._socket && !this._socket.destroyed) {\n            this._socket.destroy();\n        }\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        this.upgrading = true;\n        this._socket = tls.connect(opts, () => {\n            this.secure = true;\n            this.upgrading = false;\n            this._socket.on('data', this._onSocketData);\n\n            socketPlain.removeListener('close', this._onSocketClose);\n            socketPlain.removeListener('end', this._onSocketEnd);\n\n            return callback(null, true);\n        });\n\n        this._socket.on('error', this._onSocketError);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());\n\n        if (/^\\d+-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'server'\n                },\n                str.replace(/\\r?\\n$/, '')\n            );\n        }\n\n        if (!str.trim()) {\n            // skip unexpected empty lines\n            setImmediate(() => this._processResponse(true));\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse(true));\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     */\n    _sendCommand(str) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'client'\n                },\n                (str || '').toString().replace(/\\r?\\n$/, '')\n            );\n        }\n\n        this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'FULL';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.orcpt || params.recipient || '').toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return args.length ? ' ' + args.join(' ') : '';\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(this._socket, {\n            end: false\n        });\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug(\n                        {\n                            tnx: 'message'\n                        },\n                        chunk.toString('binary').replace(/\\r?\\n$/, '')\n                    );\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info(\n                {\n                    tnx: 'message',\n                    inByteCount: dataStream.inByteCount,\n                    outByteCount: dataStream.outByteCount\n                },\n                '<%s bytes encoded mime message (source size %s bytes)>',\n                dataStream.outByteCount,\n                dataStream.inByteCount\n            );\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ -]SMTPUTF8\\b/im.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ -]DSN\\b/im.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ -]8BITMIME\\b/im.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ -]PIPELINING\\b/im.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports AUTH\n        if (/[ -]AUTH\\b/i.test(str)) {\n            this.allowsAuth = true;\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        // assume that authentication is enabled (most probably is not though)\n        this.allowsAuth = true;\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'Failed STARTTLS upgrade, continuing unencrypted'\n                );\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info(\n                {\n                    tnx: 'smtp'\n                },\n                'Connection upgraded with STARTTLS'\n            );\n\n            if (secured) {\n                // restart session\n                if (this.options.lmtp) {\n                    this._responseActions.push(this._actionLHLO);\n                    this._sendCommand('LHLO ' + this.name);\n                } else {\n                    this._responseActions.push(this._actionEHLO);\n                    this._sendCommand('EHLO ' + this.name);\n                }\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n            hmac_md5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmac_md5.update(base64decoded);\n\n        let hex_hmac = hmac_md5.digest('hex');\n        let prepended = this._auth.credentials.user + ' ' + hex_hmac;\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(prepended).toString('base64'));\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.pass + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info(\n                {\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                },\n                'User %s failed to authenticate',\n                JSON.stringify(this._auth.user)\n            );\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message,\n            err,\n            curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authfail',\n                        method: this._authMethod\n                    },\n                    'User %s failed to authenticate',\n                    JSON.stringify(this._auth.user)\n                );\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken));\n        });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n    _isDestroyedMessage(command) {\n        if (this._destroyed) {\n            return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n        }\n\n        if (this._socket) {\n            if (this._socket.destroyed) {\n                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n            }\n\n            if (!this._socket.writable) {\n                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n            }\n        }\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname = os.hostname() || '';\n\n        // ignore if not FQDN\n        if (defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n", "'use strict';\n\nconst services = require('./services.json');\nconst normalized = {};\n\nObject.keys(services).forEach(key => {\n    let service = services[key];\n\n    normalized[normalizeKey(key)] = normalizeService(service);\n\n    [].concat(service.aliases || []).forEach(alias => {\n        normalized[normalizeKey(alias)] = normalizeService(service);\n    });\n\n    [].concat(service.domains || []).forEach(domain => {\n        normalized[normalizeKey(domain)] = normalizeService(service);\n    });\n});\n\nfunction normalizeKey(key) {\n    return key.replace(/[^a-zA-Z0-9.-]/g, '').toLowerCase();\n}\n\nfunction normalizeService(service) {\n    let filter = ['domains', 'aliases'];\n    let response = {};\n\n    Object.keys(service).forEach(key => {\n        if (filter.indexOf(key) < 0) {\n            response[key] = service[key];\n        }\n    });\n\n    return response;\n}\n\n/**\n * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or\n * an email address (like 'test@googlemail.com').\n *\n * @param {String} key [description]\n * @returns {Object} SMTP config or false if not found\n */\nmodule.exports = function(key) {\n    key = normalizeKey(key.split('@').pop());\n    return normalized[key] || false;\n};\n", "{\n    \"1und1\": {\n        \"host\": \"smtp.1und1.de\",\n        \"port\": 465,\n        \"secure\": true,\n        \"authMethod\": \"LOGIN\"\n    },\n\n    \"AOL\": {\n        \"domains\": [\"aol.com\"],\n        \"host\": \"smtp.aol.com\",\n        \"port\": 587\n    },\n\n    \"DebugMail\": {\n        \"host\": \"debugmail.io\",\n        \"port\": 25\n    },\n\n    \"DynectEmail\": {\n        \"aliases\": [\"Dynect\"],\n        \"host\": \"smtp.dynect.net\",\n        \"port\": 25\n    },\n    \n    \"Ethereal\": {\n        \"aliases\": [\"ethereal.email\"],\n        \"host\": \"smtp.ethereal.email\",   \n        \"port\": 587\n    },\n\n    \"FastMail\": {\n        \"domains\": [\"fastmail.fm\"],\n        \"host\": \"smtp.fastmail.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"GandiMail\": {\n        \"aliases\": [\"Gandi\", \"Gandi Mail\"],\n        \"host\": \"mail.gandi.net\",\n        \"port\": 587\n    },\n\n    \"Gmail\": {\n        \"aliases\": [\"Google Mail\"],\n        \"domains\": [\"gmail.com\", \"googlemail.com\"],\n        \"host\": \"smtp.gmail.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Godaddy\": {\n        \"host\": \"smtpout.secureserver.net\",\n        \"port\": 25\n    },\n\n    \"GodaddyAsia\": {\n        \"host\": \"smtp.asia.secureserver.net\",\n        \"port\": 25\n    },\n\n    \"GodaddyEurope\": {\n        \"host\": \"smtp.europe.secureserver.net\",\n        \"port\": 25\n    },\n\n    \"hot.ee\": {\n        \"host\": \"mail.hot.ee\"\n    },\n\n    \"Hotmail\": {\n        \"aliases\": [\"Outlook\", \"Outlook.com\", \"Hotmail.com\"],\n        \"domains\": [\"hotmail.com\", \"outlook.com\"],\n        \"host\": \"smtp.live.com\",\n        \"port\": 587\n    },\n\n    \"iCloud\": {\n        \"aliases\": [\"Me\", \"Mac\"],\n        \"domains\": [\"me.com\", \"mac.com\"],\n        \"host\": \"smtp.mail.me.com\",\n        \"port\": 587\n    },\n\n    \"mail.ee\": {\n        \"host\": \"smtp.mail.ee\"\n    },\n\n    \"Mail.ru\": {\n        \"host\": \"smtp.mail.ru\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Maildev\": {\n        \"port\": 1025,\n        \"ignoreTLS\": true\n    },\n\n    \"Mailgun\": {\n        \"host\": \"smtp.mailgun.org\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Mailjet\": {\n        \"host\": \"in.mailjet.com\",\n        \"port\": 587\n    },\n\n    \"Mailosaur\": {\n        \"host\": \"mailosaur.io\",\n        \"port\": 25\n    },\n\n    \"Mailtrap\": {\n        \"host\": \"smtp.mailtrap.io\",\n        \"port\": 2525\n    },\n\n    \"Mandrill\": {\n        \"host\": \"smtp.mandrillapp.com\",\n        \"port\": 587\n    },\n\n    \"Naver\": {\n        \"host\": \"smtp.naver.com\",\n        \"port\": 587\n    },\n\n    \"One\": {\n        \"host\": \"send.one.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"OpenMailBox\": {\n        \"aliases\": [\"OMB\", \"openmailbox.org\"],\n        \"host\": \"smtp.openmailbox.org\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Outlook365\": {\n        \"host\": \"smtp.office365.com\",\n        \"port\": 587,\n        \"secure\": false\n    },\n\n    \"Postmark\": {\n        \"aliases\": [\"PostmarkApp\"],\n        \"host\": \"smtp.postmarkapp.com\",\n        \"port\": 2525\n    },\n\n    \"qiye.aliyun\": {\n        \"host\": \"smtp.mxhichina.com\",\n        \"port\": \"465\",\n        \"secure\": true\n    },\n\n    \"QQ\": {\n        \"domains\": [\"qq.com\"],\n        \"host\": \"smtp.qq.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"QQex\": {\n        \"aliases\": [\"QQ Enterprise\"],\n        \"domains\": [\"exmail.qq.com\"],\n        \"host\": \"smtp.exmail.qq.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SendCloud\": {\n        \"host\": \"smtpcloud.sohu.com\",\n        \"port\": 25\n    },\n\n    \"SendGrid\": {\n        \"host\": \"smtp.sendgrid.net\",\n        \"port\": 587\n    },\n\n    \"SendinBlue\": {\n        \"host\": \"smtp-relay.sendinblue.com\",\n        \"port\": 587\n    },\n\n    \"SendPulse\": {\n        \"host\": \"smtp-pulse.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES\": {\n        \"host\": \"email-smtp.us-east-1.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES-US-EAST-1\": {\n        \"host\": \"email-smtp.us-east-1.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES-US-WEST-2\": {\n        \"host\": \"email-smtp.us-west-2.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES-EU-WEST-1\": {\n        \"host\": \"email-smtp.eu-west-1.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Sparkpost\": {\n        \"aliases\": [\"SparkPost\", \"SparkPost Mail\"],\n        \"domains\": [\"sparkpost.com\"],\n        \"host\": \"smtp.sparkpostmail.com\",\n        \"port\": 587,\n        \"secure\": false\n    },\n\n    \"Tipimail\": {\n        \"host\": \"smtp.tipimail.com\",\n        \"port\": 587\n    },\n\n    \"Yahoo\": {\n        \"domains\": [\"yahoo.com\"],\n        \"host\": \"smtp.mail.yahoo.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Yandex\": {\n        \"domains\": [\"yandex.ru\"],\n        \"host\": \"smtp.yandex.ru\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Zoho\": {\n        \"host\": \"smtp.zoho.com\",\n        \"port\": 465,\n        \"secure\": true,\n        \"authMethod\": \"LOGIN\"\n    },\n\n    \"126\": {\n        \"host\": \"smtp.126.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"163\": {\n        \"host\": \"smtp.163.com\",\n        \"port\": 465,\n        \"secure\": true\n    }\n}\n", "'use strict';\n\nconst Stream = require('stream').Stream;\nconst fetch = require('../fetch');\nconst crypto = require('crypto');\nconst shared = require('../shared');\n\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\nclass XOAuth2 extends Stream {\n    constructor(options, logger) {\n        super();\n\n        this.options = options || {};\n\n        if (options && options.serviceClient) {\n            if (!options.privateKey || !options.user) {\n                setImmediate(() => this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!')));\n                return;\n            }\n\n            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);\n            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n        }\n\n        this.logger = shared.getLogger(\n            {\n                logger\n            },\n            {\n                component: this.options.component || 'OAuth2'\n            }\n        );\n\n        this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;\n\n        this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n        this.options.customHeaders = this.options.customHeaders || {};\n        this.options.customParams = this.options.customParams || {};\n\n        this.accessToken = this.options.accessToken || false;\n\n        if (this.options.expires && Number(this.options.expires)) {\n            this.expires = this.options.expires;\n        } else {\n            let timeout = Math.max(Number(this.options.timeout) || 0, 0);\n            this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n        }\n    }\n\n    /**\n     * Returns or generates (if previous has expired) a XOAuth2 token\n     *\n     * @param {Boolean} renew If false then use cached access token (if available)\n     * @param {Function} callback Callback function with error object and token string\n     */\n    getToken(renew, callback) {\n        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n            return callback(null, this.accessToken);\n        }\n\n        let generateCallback = (...args) => {\n            if (args[0]) {\n                this.logger.error(\n                    {\n                        err: args[0],\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Failed generating new Access Token for %s',\n                    this.options.user\n                );\n            } else {\n                this.logger.info(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Generated new Access Token for %s',\n                    this.options.user\n                );\n            }\n            callback(...args);\n        };\n\n        if (this.provisionCallback) {\n            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {\n                if (!err && accessToken) {\n                    this.accessToken = accessToken;\n                    this.expires = expires || 0;\n                }\n                generateCallback(err, accessToken);\n            });\n        } else {\n            this.generateToken(generateCallback);\n        }\n    }\n\n    /**\n     * Updates token values\n     *\n     * @param {String} accessToken New access token\n     * @param {Number} timeout Access token lifetime in seconds\n     *\n     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n     */\n    updateToken(accessToken, timeout) {\n        this.accessToken = accessToken;\n        timeout = Math.max(Number(timeout) || 0, 0);\n        this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n\n        this.emit('token', {\n            user: this.options.user,\n            accessToken: accessToken || '',\n            expires: this.expires\n        });\n    }\n\n    /**\n     * Generates a new XOAuth2 token with the credentials provided at initialization\n     *\n     * @param {Function} callback Callback function with error object and token string\n     */\n    generateToken(callback) {\n        let urlOptions;\n        let loggedUrlOptions;\n        if (this.options.serviceClient) {\n            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n            let iat = Math.floor(Date.now() / 1000); // unix time\n            let tokenData = {\n                iss: this.options.serviceClient,\n                scope: this.options.scope || 'https://mail.google.com/',\n                sub: this.options.user,\n                aud: this.options.accessUrl,\n                iat,\n                exp: iat + this.options.serviceRequestTimeout\n            };\n            let token;\n            try {\n                token = this.jwtSignRS256(tokenData);\n            } catch (err) {\n                return callback(new Error('Can\\x27t generate token. Check your auth options'));\n            }\n\n            urlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: token\n            };\n\n            loggedUrlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: tokenData\n            };\n        } else {\n            if (!this.options.refreshToken) {\n                return callback(new Error('Can\\x27t create new access token for user'));\n            }\n\n            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n            urlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: this.options.clientSecret || '',\n                refresh_token: this.options.refreshToken,\n                grant_type: 'refresh_token'\n            };\n\n            loggedUrlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n                refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n                grant_type: 'refresh_token'\n            };\n        }\n\n        Object.keys(this.options.customParams).forEach(key => {\n            urlOptions[key] = this.options.customParams[key];\n            loggedUrlOptions[key] = this.options.customParams[key];\n        });\n\n        this.logger.debug(\n            {\n                tnx: 'OAUTH2',\n                user: this.options.user,\n                action: 'generate'\n            },\n            'Requesting token using: %s',\n            JSON.stringify(loggedUrlOptions)\n        );\n\n        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {\n            let data;\n\n            if (error) {\n                return callback(error);\n            }\n\n            try {\n                data = JSON.parse(body.toString());\n            } catch (E) {\n                return callback(E);\n            }\n\n            if (!data || typeof data !== 'object') {\n                this.logger.debug(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'post'\n                    },\n                    'Response: %s',\n                    (body || '').toString()\n                );\n                return callback(new Error('Invalid authentication response'));\n            }\n\n            let logData = {};\n            Object.keys(data).forEach(key => {\n                if (key !== 'access_token') {\n                    logData[key] = data[key];\n                } else {\n                    logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n                }\n            });\n\n            this.logger.debug(\n                {\n                    tnx: 'OAUTH2',\n                    user: this.options.user,\n                    action: 'post'\n                },\n                'Response: %s',\n                JSON.stringify(logData)\n            );\n\n            if (data.error) {\n                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2\n                let errorMessage = data.error;\n                if(data.error_description) {\n                  errorMessage += ': ' + data.error_description;\n                }\n                if(data.error_uri) {\n                  errorMessage += ' (' + data.error_uri + ')';\n                }\n                return callback(new Error(errorMessage));\n            }\n\n            if (data.access_token) {\n                this.updateToken(data.access_token, data.expires_in);\n                return callback(null, this.accessToken);\n            }\n\n            return callback(new Error('No access token'));\n        });\n    }\n\n    /**\n     * Converts an access_token and user id into a base64 encoded XOAuth2 token\n     *\n     * @param {String} [accessToken] Access token string\n     * @return {String} Base64 encoded token for IMAP or SMTP login\n     */\n    buildXOAuth2Token(accessToken) {\n        let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n        return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n    }\n\n    /**\n     * Custom POST request handler.\n     * This is only needed to keep paths short in Windows \u2013 usually this module\n     * is a dependency of a dependency and if it tries to require something\n     * like the request module the paths get way too long to handle for Windows.\n     * As we do only a simple POST request we do not actually require complicated\n     * logic support (no redirects, no nothing) anyway.\n     *\n     * @param {String} url Url to POST to\n     * @param {String|Buffer} payload Payload to POST\n     * @param {Function} callback Callback function with (err, buff)\n     */\n    postRequest(url, payload, params, callback) {\n        let returned = false;\n\n        let chunks = [];\n        let chunklen = 0;\n\n        let req = fetch(url, {\n            method: 'post',\n            headers: params.customHeaders,\n            body: payload,\n            allowErrorResponse: true\n        });\n\n        req.on('readable', () => {\n            let chunk;\n            while ((chunk = req.read()) !== null) {\n                chunks.push(chunk);\n                chunklen += chunk.length;\n            }\n        });\n\n        req.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(err);\n        });\n\n        req.once('end', () => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(null, Buffer.concat(chunks, chunklen));\n        });\n    }\n\n    /**\n     * Encodes a buffer or a string into Base64url format\n     *\n     * @param {Buffer|String} data The data to convert\n     * @return {String} The encoded string\n     */\n    toBase64URL(data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(data);\n        }\n\n        return data\n            .toString('base64')\n            .replace(/[=]+/g, '') // remove '='s\n            .replace(/\\+/g, '-') // '+' \u2192 '-'\n            .replace(/\\//g, '_'); // '/' \u2192 '_'\n    }\n\n    /**\n     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n     *\n     * @param {Object} payload The payload to include in the generated token\n     * @return {String} The generated and signed token\n     */\n    jwtSignRS256(payload) {\n        payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');\n        let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n        return payload + '.' + this.toBase64URL(signature);\n    }\n}\n\nmodule.exports = XOAuth2;\n", "{\n    \"name\": \"nodemailer\",\n    \"version\": \"6.4.15\",\n    \"description\": \"Easy as cake e-mail sending from your Node.js applications\",\n    \"main\": \"lib/nodemailer.js\",\n    \"scripts\": {\n        \"test\": \"grunt\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/nodemailer/nodemailer.git\"\n    },\n    \"keywords\": [\n        \"Nodemailer\"\n    ],\n    \"author\": \"Andris Reinman\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/nodemailer/nodemailer/issues\"\n    },\n    \"homepage\": \"https://nodemailer.com/\",\n    \"devDependencies\": {\n        \"bunyan\": \"1.8.14\",\n        \"chai\": \"4.2.0\",\n        \"eslint-config-nodemailer\": \"1.2.0\",\n        \"eslint-config-prettier\": \"6.15.0\",\n        \"grunt\": \"1.3.0\",\n        \"grunt-cli\": \"1.3.2\",\n        \"grunt-eslint\": \"23.0.0\",\n        \"grunt-mocha-test\": \"0.13.3\",\n        \"libbase64\": \"1.2.1\",\n        \"libmime\": \"5.0.0\",\n        \"libqp\": \"1.1.0\",\n        \"mocha\": \"8.2.1\",\n        \"nodemailer-ntlm-auth\": \"1.0.1\",\n        \"proxy\": \"1.0.2\",\n        \"proxy-test-server\": \"1.0.0\",\n        \"sinon\": \"9.2.1\",\n        \"smtp-server\": \"3.7.0\"\n    },\n    \"engines\": {\n        \"node\": \">=6.0.0\"\n    },\n    \"dependencies\": {}\n}\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst libbase64 = require('libbase64');\nconst base64 = require('../../lib/base64');\nconst chai = require('chai');\nconst expect = chai.expect;\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nchai.config.includeStack = true;\n\ndescribe('Base64 Tests', function() {\n    let encodeFixtures = [\n        ['abcd= \u00d5\u00c4\u00d6\u00dc', 'YWJjZD0gw5XDhMOWw5w='],\n        ['foo bar  ', 'Zm9vIGJhciAg'],\n        ['foo bar\\t\\t', 'Zm9vIGJhcgkJ'],\n        ['foo \\r\\nbar', 'Zm9vIA0KYmFy']\n    ];\n\n    let wrapFixtures = [['dGVyZSwgdGVyZSwgdmFuYSBrZXJlLCBrdWlkYXMgc3VsIGzDpGhlYj8=', 'dGVyZSwgdGVyZSwgdmFu\\r\\nYSBrZXJlLCBrdWlkYXMg\\r\\nc3VsIGzDpGhlYj8=']];\n\n    let streamFixture = [\n        '123456789012345678  90\\r\\n\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc another line === ',\n        'MTIzNDU2N\\r\\nzg5MDEyMz\\r\\nQ1Njc4ICA\\r\\n5MA0Kw7XD\\r\\npMO2w7zDt\\r\\ncOkw7bDvM\\r\\nO1w6TDtsO\\r\\n8w7XDpMO2\\r\\nw7zDtcOkw\\r\\n7bDvMO1w6\\r\\nTDtsO8w7X\\r\\nDpMO2w7zD\\r\\ntcOkw7bDv\\r\\nCBhbm90aG\\r\\nVyIGxpbmU\\r\\ngPT09IA=='\n    ];\n\n    describe('#encode', function() {\n        it('shoud encode UTF-8 string to base64', function() {\n            encodeFixtures.forEach(function(test) {\n                expect(base64.encode(test[0])).to.equal(test[1]);\n            });\n        });\n\n        it('shoud encode Buffer to base64', function() {\n            expect(base64.encode(Buffer.from([0x00, 0x01, 0x02, 0x20, 0x03]))).to.equal('AAECIAM=');\n        });\n    });\n\n    describe('#wrap', function() {\n        it('should wrap long base64 encoded lines', function() {\n            wrapFixtures.forEach(function(test) {\n                expect(base64.wrap(test[0], 20)).to.equal(test[1]);\n            });\n        });\n    });\n\n    describe('base64 Streams', function() {\n        it('should transform incoming bytes to base64', function(done) {\n            let encoder = new base64.Encoder({\n                lineLength: 9\n            });\n\n            let bytes = Buffer.from(streamFixture[0]),\n                i = 0,\n                buf = [],\n                buflen = 0;\n\n            encoder.on('data', function(chunk) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            });\n\n            encoder.on('end', function(chunk) {\n                if (chunk) {\n                    buf.push(chunk);\n                    buflen += chunk.length;\n                }\n                buf = Buffer.concat(buf, buflen);\n\n                expect(buf.toString()).to.equal(streamFixture[1]);\n                done();\n            });\n\n            let sendNextByte = function() {\n                if (i >= bytes.length) {\n                    return encoder.end();\n                }\n\n                let ord = bytes[i++];\n                encoder.write(Buffer.from([ord]));\n                setImmediate(sendNextByte);\n            };\n\n            sendNextByte();\n        });\n\n        it('should transform incoming bytes to base64 and back', function(done) {\n            let decoder = new libbase64.Decoder();\n            let encoder = new base64.Encoder();\n            let file = fs.createReadStream(__dirname + '/fixtures/alice.txt');\n\n            let fhash = crypto.createHash('md5');\n            let dhash = crypto.createHash('md5');\n\n            file.pipe(encoder).pipe(decoder);\n\n            file.on('data', function(chunk) {\n                fhash.update(chunk);\n            });\n\n            file.on('end', function() {\n                fhash = fhash.digest('hex');\n            });\n\n            decoder.on('data', function(chunk) {\n                dhash.update(chunk);\n            });\n\n            decoder.on('end', function() {\n                dhash = dhash.digest('hex');\n                expect(fhash).to.equal(dhash);\n                done();\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst path = require('path');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst PassThrough = require('stream').PassThrough;\nconst DKIM = require('../../lib/dkim');\n\nchai.config.includeStack = true;\n\nconst privateKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIBywIBAAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8knBf3+uA7q/CSxpX6sQ8N\ndFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44ARpgHY4V0qSCdUt4rD32n\nwfjlGbh8p5ua5wIDAQABAmAm+uUQpQPTu7kg95wqVqw2sxLsa9giT6M8MtxQH7Uo\n1TF0eAO0TQ4KOxgY1S9OT5sGPVKnag258m3qX7o5imawcuyStb68DQgAUg6xv7Af\nAqAEDfYN5HW6xK+X81jfOUECMQDr7XAS4PERATvgb1B3vRu5UEbuXcenHDYgdoyT\n3qJFViTbep4qeaflF0uF9eFveMcCMQDic10rJ8fopGD7/a45O4VJb0+lRXVdqZxJ\nQzAp+zVKWqDqPfX7L93SQLzOGhdd7OECMQDeQyD7WBkjSQNMy/GF7I1qxrscIxNN\nVqGTcbu8Lti285Hjhx/sqhHHHGwU9vB7oM8CMQDKTS3Kw/s/xrot5O+kiZwFgr+w\ncmDrj/7jJHb+ykFNb7GaEkiSYqzUjKkfpweBDYECMFJUyzuuFJAjq3BXmGJlyykQ\nTweUw+zMVdSXjO+FCPcYNi6CP1t1KoESzGKBVoqA/g==\n-----END RSA PRIVATE KEY-----`;\n\n/*\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMHwwDQYJKoZIhvcNAQEBBQADawAwaAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8k\nnBf3+uA7q/CSxpX6sQ8NdFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44A\nRpgHY4V0qSCdUt4rD32nwfjlGbh8p5ua5wIDAQAB\n-----END PUBLIC KEY-----`;\n*/\n\ndescribe('DKIM Tests', function() {\n    this.timeout(100 * 1000); // eslint-disable-line\n\n    it('should sign message', function(done) {\n        let message = `From: saatja aadress\nTo: Saaja aadress\nSubject: pealkiri\n  mitmel\n  real\nMessage-Id: test\n\ntere tere\nteine rida\n`;\n        let s = new PassThrough();\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey\n        });\n\n        let output = dkim.sign(s);\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read(10 * 1024);\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message).to.equal(\n                'DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=node.ee; q=dns/txt;\\r\\n' +\n                    ' s=dkim; bh=h2JdEKA6yVYSGuI3DQCDlg2KL+96GxA7Yw7owvsYDUM=;\\r\\n' +\n                    ' h=from:subject:message-id:to;\\r\\n' +\n                    ' b=tey8mL2VQVuy/phh7yEKi86Y0Yyzyy04qTy73G4yg3qdEDB7uymjNr32ruRPVFmC9PimIK75p\\r\\n' +\n                    ' KVPF5T1oB8/oY6TFqyyuECRrI4D2CfG3VXWBShK32r1Wtv7eWN04b4s\\r\\n' +\n                    'From: saatja aadress\\n' +\n                    'To: Saaja aadress\\n' +\n                    'Subject: pealkiri\\n' +\n                    '  mitmel\\n' +\n                    '  real\\n' +\n                    'Message-Id: test\\n' +\n                    '\\n' +\n                    'tere tere\\n' +\n                    'teine rida\\n'\n            );\n            done();\n        });\n\n        let inputPos = 0;\n        let messageBuf = Buffer.from(message);\n        let writeNext = () => {\n            if (inputPos >= messageBuf.length) {\n                return s.end();\n            }\n            s.write(Buffer.from([messageBuf[inputPos++]]));\n            setImmediate(writeNext);\n        };\n        writeNext();\n    });\n\n    it('should sign large message using cache dir', function(done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: path.join(__dirname, 'cache')\n        });\n\n        let output = dkim.sign(fs.createReadStream(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.true;\n            done();\n        });\n    });\n\n    it('should sign large message without cache dir', function(done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey\n        });\n\n        let output = dkim.sign(fs.createReadStream(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.false;\n            done();\n        });\n    });\n\n    it('should emit cache error', function(done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: '/rootertewywrtyreetwert' // expecting that this location does not exist or is unwritable\n        });\n\n        let output = dkim.sign(fs.createReadStream(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.exist;\n            done();\n        });\n    });\n\n    it('should sign large message as Buffer', function(done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: path.join(__dirname, 'cache')\n        });\n\n        let output = dkim.sign(fs.readFileSync(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.true;\n            done();\n        });\n    });\n\n    it('should sign large message as String', function(done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: path.join(__dirname, 'cache')\n        });\n\n        let output = dkim.sign(fs.readFileSync(__dirname + '/fixtures/large.eml', 'utf-8'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.true;\n            done();\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\n//let http = require('http');\nconst MessageParser = require('../../lib/dkim/message-parser');\n\nchai.config.includeStack = true;\n\ndescribe('DKIM MessageParser Tests', function() {\n    it('should extract header and body', function(done) {\n        let parser = new MessageParser();\n        let message = `From: saatja aadress\nTo: Saaja aadress\nSubject: pealkiri\n  mitmel\n  real\nMessage-Id: test\n\ntere tere\nteine rida\n`;\n\n        let chunks = [];\n        let headers = false;\n        let end = false;\n\n        parser.on('data', chunk => {\n            chunks.push(chunk);\n        });\n\n        parser.on('end', () => {\n            end = true;\n            let body = Buffer.concat(chunks).toString();\n            expect(body).to.equal('tere tere\\nteine rida\\n');\n            if (headers) {\n                return done();\n            }\n        });\n\n        parser.on('headers', data => {\n            expect(data).to.deep.equal([\n                // fix auto format\n                {\n                    key: 'from',\n                    line: 'From: saatja aadress'\n                },\n                {\n                    key: 'to',\n                    line: 'To: Saaja aadress'\n                },\n                {\n                    key: 'subject',\n                    line: 'Subject: pealkiri\\n  mitmel\\n  real'\n                },\n                {\n                    key: 'message-id',\n                    line: 'Message-Id: test'\n                }\n            ]);\n            headers = true;\n            if (end) {\n                return done();\n            }\n        });\n\n        parser.end(Buffer.from(message));\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\nlet fs = require('fs');\nlet RelaxedBody = require('../../lib/dkim/relaxed-body');\n\nchai.config.includeStack = true;\n\ndescribe('DKIM RelaxedBody Tests', function() {\n    it('Should calculate body hash byte by byte', function(done) {\n        fs.readFile(__dirname + '/fixtures/message1.eml', 'utf-8', (err, message) => {\n            expect(err).to.not.exist;\n\n            message = message.replace(/\\r?\\n/g, '\\r\\n');\n            message = message.split('\\r\\n\\r\\n');\n            message.shift();\n            message = message.join('\\r\\n\\r\\n');\n\n            message = Buffer.from(message);\n\n            let s = new RelaxedBody({\n                hashAlgo: 'sha256',\n                debug: true\n            });\n\n            s.on('hash', hash => {\n                expect(hash).to.equal('D2H5TEwtUgM2u8Ew0gG6vnt/Na6L+Zep7apmSmfy8IQ=');\n                done();\n            });\n\n            let pos = 0;\n            let stream = () => {\n                if (pos >= message.length) {\n                    return s.end();\n                }\n                let ord = Buffer.from([message[pos++]]);\n                s.write(ord);\n                setImmediate(stream);\n            };\n            setImmediate(stream);\n        });\n    });\n\n    it('Should calculate body hash all at once', function(done) {\n        fs.readFile(__dirname + '/fixtures/message1.eml', 'utf-8', (err, message) => {\n            expect(err).to.not.exist;\n\n            message = message.replace(/\\r?\\n/g, '\\r\\n');\n            message = message.split('\\r\\n\\r\\n');\n            message.shift();\n            message = message.join('\\r\\n\\r\\n');\n\n            message = Buffer.from(message);\n\n            let s = new RelaxedBody({\n                hashAlgo: 'sha256',\n                debug: true\n            });\n\n            s.on('hash', hash => {\n                expect(hash).to.equal('D2H5TEwtUgM2u8Ew0gG6vnt/Na6L+Zep7apmSmfy8IQ=');\n                done();\n            });\n\n            setImmediate(() => s.end(message));\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\nlet sign = require('../../lib/dkim/sign');\n\nchai.config.includeStack = true;\n\nconst privateKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIBywIBAAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8knBf3+uA7q/CSxpX6sQ8N\ndFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44ARpgHY4V0qSCdUt4rD32n\nwfjlGbh8p5ua5wIDAQABAmAm+uUQpQPTu7kg95wqVqw2sxLsa9giT6M8MtxQH7Uo\n1TF0eAO0TQ4KOxgY1S9OT5sGPVKnag258m3qX7o5imawcuyStb68DQgAUg6xv7Af\nAqAEDfYN5HW6xK+X81jfOUECMQDr7XAS4PERATvgb1B3vRu5UEbuXcenHDYgdoyT\n3qJFViTbep4qeaflF0uF9eFveMcCMQDic10rJ8fopGD7/a45O4VJb0+lRXVdqZxJ\nQzAp+zVKWqDqPfX7L93SQLzOGhdd7OECMQDeQyD7WBkjSQNMy/GF7I1qxrscIxNN\nVqGTcbu8Lti285Hjhx/sqhHHHGwU9vB7oM8CMQDKTS3Kw/s/xrot5O+kiZwFgr+w\ncmDrj/7jJHb+ykFNb7GaEkiSYqzUjKkfpweBDYECMFJUyzuuFJAjq3BXmGJlyykQ\nTweUw+zMVdSXjO+FCPcYNi6CP1t1KoESzGKBVoqA/g==\n-----END RSA PRIVATE KEY-----`;\n\n/*\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMHwwDQYJKoZIhvcNAQEBBQADawAwaAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8k\nnBf3+uA7q/CSxpX6sQ8NdFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44A\nRpgHY4V0qSCdUt4rD32nwfjlGbh8p5ua5wIDAQAB\n-----END PUBLIC KEY-----`;\n*/\n\ndescribe('DKIM Sign Tests', function() {\n    it('should create relaxed headers', function() {\n        let headerLines = [\n            {\n                key: 'a',\n                line: 'A: X'\n            },\n            {\n                key: 'b',\n                line: 'B: Y\\t\\r\\n\\tZ  '\n            }\n        ];\n        expect(sign.relaxedHeaders(headerLines, 'a:b:c:d')).to.deep.equal({\n            headers: 'a:X\\r\\nb:Y Z\\r\\n',\n            fieldNames: 'a:b'\n        });\n    });\n\n    it('should skip specific headers', function() {\n        let headerLines = [\n            {\n                key: 'a',\n                line: 'A: X'\n            },\n            {\n                key: 'b',\n                line: 'B: Y\\t\\r\\n\\tZ  '\n            },\n            {\n                key: 'c',\n                line: 'C: X'\n            },\n            {\n                key: 'd',\n                line: 'D: X'\n            }\n        ];\n        expect(sign.relaxedHeaders(headerLines, 'a:b:c:d', 'a:c')).to.deep.equal({\n            headers: 'b:Y Z\\r\\nd:X\\r\\n',\n            fieldNames: 'b:d'\n        });\n    });\n\n    it('should sign headers', function() {\n        let headerLines = [\n            {\n                key: 'from',\n                line: 'From: andris@node.ee'\n            },\n            {\n                key: 'to',\n                line: 'To:andris@kreata.ee'\n            },\n            {\n                key: 'message-id',\n                line: 'Message-ID: <testkiri@kreata.ee>'\n            }\n        ];\n\n        let dkimField = sign(headerLines, 'sha256', 'z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=', {\n            skipFields: 'message-id:references',\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey\n        });\n        expect(dkimField.replace(/\\r?\\n\\s*/g, '').replace(/\\s+/g, '')).to.equal(\n            'DKIM-Signature:v=1;a=rsa-sha256;c=relaxed/relaxed;d=node.ee;q=dns/txt;s=dkim;bh=z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=;h=from:to;b=pVd+Dp+EjmYBcc1AWlBAP4ESpuAJ2WMS4gbxWLoeUZ1vZRodVN7K9UXvcCsLuqjJktCZMN2+8dyEUaYW2VIcxg4sVBCS1wqB/tqYZ/gxXLnG2/nZf4fyD2vxltJP4pDL'\n        );\n    });\n\n    it('should sign headers for unicode domain', function() {\n        let headerLines = [\n            {\n                key: 'from',\n                line: 'From: andris@node.ee'\n            },\n            {\n                key: 'to',\n                line: 'To:andris@kreata.ee'\n            }\n        ];\n\n        let dkimField = sign(headerLines, 'sha256', 'z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=', {\n            domainName: 'm\u00fcriaad-pol\u00fcteism.info',\n            keySelector: 'dkim',\n            privateKey\n        });\n        expect(dkimField.replace(/\\r?\\n\\s*/g, '').replace(/\\s+/g, '')).to.equal(\n            'DKIM-Signature:v=1;a=rsa-sha256;c=relaxed/relaxed;d=xn--mriaad-polteism-zvbj.info;q=dns/txt;s=dkim;bh=z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=;h=from:to;b=oBJ1MkwEkftfXa2AK4Expjp2xgIcAR43SVrftSEHVQ6F1SlGjP3EKP+cn/hLkhUel3rY0icthk/myDu6uhTBmM6DMtzIBW/7uQd6q9hfgaiYnw5Iew2tZc4TzBEYSdKi'\n        );\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst nodemailer = require('../lib/nodemailer');\nconst chai = require('chai');\nconst expect = chai.expect;\nchai.config.includeStack = true;\n\ndescribe('Ethereal Tests', function() {\n    this.timeout(50 * 1000); // eslint-disable-line no-invalid-this\n    it('should create an account and send a message', function(done) {\n        // Generate SMTP service account from ethereal.email\n        nodemailer.createTestAccount((err, account) => {\n            expect(err).to.not.exist;\n            expect(account.user).to.exist;\n\n            let transporter = nodemailer.createTransport({\n                host: account.smtp.host,\n                port: account.smtp.port,\n                secure: account.smtp.secure,\n                auth: {\n                    user: account.user,\n                    pass: account.pass\n                }\n            });\n\n            // Message object\n            let message = {\n                from: 'Pangalink <no-reply@pangalink.net>',\n                to: 'Andris Reinman <andris.reinman@gmail.com>',\n                subject: 'Ethereal unit test message',\n                text: 'Hello world',\n                html: '<p>Hello world</p>'\n            };\n\n            transporter.sendMail(message, (err, info) => {\n                expect(err).to.not.exist;\n                expect(nodemailer.getTestMessageUrl(info)).to.include('ethereal');\n                done();\n            });\n        });\n    });\n\n    it('should cache a created test account', function(done) {\n        nodemailer.createTestAccount((err, account) => {\n            expect(err).to.not.exist;\n            nodemailer.createTestAccount((err, account2) => {\n                expect(err).to.not.exist;\n                expect(account2).to.equal(account);\n                done();\n            });\n        });\n    });\n\n    it('should cache a created test account when using promises', function(done) {\n        nodemailer.createTestAccount().then(account => {\n            nodemailer.createTestAccount().then(account2 => {\n                expect(account2).to.equal(account);\n                done();\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\n//let http = require('http');\nconst Cookies = require('../../lib/fetch/cookies');\n\nchai.config.includeStack = true;\n\ndescribe('Cookie Tests', function() {\n    let biskviit;\n\n    beforeEach(function() {\n        biskviit = new Cookies();\n    });\n\n    describe('#getPath', function() {\n        it('should return root path', function() {\n            expect(biskviit.getPath('/')).to.equal('/');\n            expect(biskviit.getPath('')).to.equal('/');\n            expect(biskviit.getPath('/index.php')).to.equal('/');\n        });\n\n        it('should return without file', function() {\n            expect(biskviit.getPath('/path/to/file')).to.equal('/path/to/');\n        });\n    });\n\n    describe('#isExpired', function() {\n        it('should match expired cookie', function() {\n            expect(\n                biskviit.isExpired({\n                    name: 'a',\n                    value: 'b',\n                    expires: new Date(Date.now() + 10000)\n                })\n            ).to.be.false;\n\n            expect(\n                biskviit.isExpired({\n                    name: 'a',\n                    value: '',\n                    expires: new Date(Date.now() + 10000)\n                })\n            ).to.be.true;\n\n            expect(\n                biskviit.isExpired({\n                    name: 'a',\n                    value: 'b',\n                    expires: new Date(Date.now() - 10000)\n                })\n            ).to.be.true;\n        });\n    });\n\n    describe('#compare', function() {\n        it('should match similar cookies', function() {\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.true;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'yyy',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/amp',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'examples.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: true,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n        });\n    });\n\n    describe('#add', function() {\n        it('should append new cookie', function() {\n            expect(biskviit.cookies.length).to.equal(0);\n            biskviit.add({\n                name: 'zzz',\n                value: 'abc',\n                path: '/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            });\n            expect(biskviit.cookies.length).to.equal(1);\n            expect(biskviit.cookies[0].name).to.equal('zzz');\n            expect(biskviit.cookies[0].value).to.equal('abc');\n        });\n\n        it('should update existing cookie', function() {\n            expect(biskviit.cookies.length).to.equal(0);\n            biskviit.add({\n                name: 'zzz',\n                value: 'abc',\n                path: '/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            });\n            biskviit.add({\n                name: 'zzz',\n                value: 'def',\n                path: '/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            });\n            expect(biskviit.cookies.length).to.equal(1);\n            expect(biskviit.cookies[0].name).to.equal('zzz');\n            expect(biskviit.cookies[0].value).to.equal('def');\n        });\n    });\n\n    describe('#match', function() {\n        it('should check if a cookie matches particular domain and path', function() {\n            let cookie = {\n                name: 'zzz',\n                value: 'abc',\n                path: '/def/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            };\n            expect(biskviit.match(cookie, 'http://example.com/def/')).to.be.true;\n            expect(biskviit.match(cookie, 'http://example.com/bef/')).to.be.false;\n        });\n\n        it('should check if a cookie matches particular domain and path', function() {\n            let cookie = {\n                name: 'zzz',\n                value: 'abc',\n                path: '/def',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            };\n            expect(biskviit.match(cookie, 'http://example.com/def/')).to.be.true;\n            expect(biskviit.match(cookie, 'http://example.com/bef/')).to.be.false;\n        });\n\n        it('should check if a cookie is secure', function() {\n            let cookie = {\n                name: 'zzz',\n                value: 'abc',\n                path: '/def/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: true,\n                httponly: false\n            };\n            expect(biskviit.match(cookie, 'https://example.com/def/')).to.be.true;\n            expect(biskviit.match(cookie, 'http://example.com/def/')).to.be.false;\n        });\n    });\n\n    describe('#parse', function() {\n        it('should parse Set-Cookie value', function() {\n            expect(biskviit.parse('theme=plain')).to.deep.equal({\n                name: 'theme',\n                value: 'plain'\n            });\n\n            expect(biskviit.parse('SSID=Ap4P\u2026.GTEq; Domain=foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly')).to.deep.equal({\n                name: 'ssid',\n                value: 'Ap4P\u2026.GTEq',\n                domain: '.foo.com',\n                path: '/',\n                httponly: true,\n                secure: true,\n                expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n            });\n        });\n\n        it('should ignore invalid expire header', function() {\n            expect(biskviit.parse('theme=plain; Expires=Wed, 13 Jan 2021 22:23:01 GMT')).to.deep.equal({\n                name: 'theme',\n                value: 'plain',\n                expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n            });\n\n            expect(biskviit.parse('theme=plain; Expires=ZZZZZZZZ GMT')).to.deep.equal({\n                name: 'theme',\n                value: 'plain'\n            });\n        });\n    });\n\n    describe('Listing', function() {\n        beforeEach(function() {\n            biskviit.cookies = [\n                {\n                    name: 'ssid1',\n                    value: 'Ap4P\u2026.GTEq1',\n                    domain: '.foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid2',\n                    value: 'Ap4P\u2026.GTEq2',\n                    domain: '.foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 1900 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid3',\n                    value: 'Ap4P\u2026.GTEq3',\n                    domain: 'foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid4',\n                    value: 'Ap4P\u2026.GTEq4',\n                    domain: 'www.foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid5',\n                    value: 'Ap4P\u2026.GTEq5',\n                    domain: 'broo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                }\n            ];\n        });\n\n        describe('#list', function() {\n            it('should return matching cookies for an URL', function() {\n                expect(biskviit.list('https://www.foo.com')).to.deep.equal([\n                    {\n                        name: 'ssid1',\n                        value: 'Ap4P\u2026.GTEq1',\n                        domain: '.foo.com',\n                        path: '/',\n                        httponly: true,\n                        secure: true,\n                        expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                    },\n                    {\n                        name: 'ssid4',\n                        value: 'Ap4P\u2026.GTEq4',\n                        domain: 'www.foo.com',\n                        path: '/',\n                        httponly: true,\n                        secure: true,\n                        expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                    }\n                ]);\n            });\n        });\n\n        describe('#get', function() {\n            it('should return matching cookies for an URL', function() {\n                expect(biskviit.get('https://www.foo.com')).to.equal('ssid1=Ap4P\u2026.GTEq1; ssid4=Ap4P\u2026.GTEq4');\n            });\n        });\n    });\n\n    describe('#set', function() {\n        it('should set cookie', function() {\n            // short\n            biskviit.set('theme=plain', 'https://foo.com/');\n            // long\n            biskviit.set('SSID=Ap4P\u2026.GTEq; Domain=foo.com; Path=/test; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly', 'https://foo.com/');\n            // subdomains\n            biskviit.set('SSID=Ap4P\u2026.GTEq; Domain=.foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly', 'https://www.foo.com/');\n            // invalid cors\n            biskviit.set('invalid_1=cors; domain=example.com', 'https://foo.com/');\n            biskviit.set('invalid_2=cors; domain=www.foo.com', 'https://foo.com/');\n            // invalid date\n            biskviit.set('invalid_3=date; Expires=zzzz', 'https://foo.com/');\n            // invalid tld\n            biskviit.set('invalid_4=cors; domain=.co.uk', 'https://foo.co.uk/');\n            // should not be added\n            biskviit.set('expired_1=date; Expires=1999-01-01 01:01:01 GMT', 'https://foo.com/');\n\n            expect(\n                biskviit.cookies.map(function(cookie) {\n                    delete cookie.expires;\n                    return cookie;\n                })\n            ).to.deep.equal([\n                {\n                    name: 'theme',\n                    value: 'plain',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'ssid',\n                    value: 'Ap4P\u2026.GTEq',\n                    domain: 'foo.com',\n                    path: '/test',\n                    secure: true,\n                    httponly: true\n                },\n                {\n                    name: 'ssid',\n                    value: 'Ap4P\u2026.GTEq',\n                    domain: 'www.foo.com',\n                    path: '/',\n                    secure: true,\n                    httponly: true\n                },\n                {\n                    name: 'invalid_1',\n                    value: 'cors',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'invalid_2',\n                    value: 'cors',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'invalid_3',\n                    value: 'date',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'invalid_4',\n                    value: 'cors',\n                    domain: 'foo.co.uk',\n                    path: '/'\n                }\n            ]);\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback:0 */\n/* globals afterEach, beforeEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\n//let http = require('http');\nconst fetch = require('../../lib/fetch');\nconst http = require('http');\nconst https = require('https');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\n\nchai.config.includeStack = true;\n\nconst HTTP_PORT = 19998;\nconst HTTPS_PORT = 19993;\n\nconst httpsOptions = {\n    key:\n        '-----BEGIN RSA PRIVATE KEY-----\\n' +\n        'MIIEpAIBAAKCAQEA6Z5Qqhw+oWfhtEiMHE32Ht94mwTBpAfjt3vPpX8M7DMCTwHs\\n' +\n        '1xcXvQ4lQ3rwreDTOWdoJeEEy7gMxXqH0jw0WfBx+8IIJU69xstOyT7FRFDvA1yT\\n' +\n        'RXY2yt9K5s6SKken/ebMfmZR+03ND4UFsDzkz0FfgcjrkXmrMF5Eh5UXX/+9YHeU\\n' +\n        'xlp0gMAt+/SumSmgCaysxZLjLpd4uXz+X+JVxsk1ACg1NoEO7lWJC/3WBP7MIcu2\\n' +\n        'wVsMd2XegLT0gWYfT1/jsIH64U/mS/SVXC9QhxMl9Yfko2kx1OiYhDxhHs75RJZh\\n' +\n        'rNRxgfiwgSb50Gw4NAQaDIxr/DJPdLhgnpY6UQIDAQABAoIBAE+tfzWFjJbgJ0ql\\n' +\n        's6Ozs020Sh4U8TZQuonJ4HhBbNbiTtdDgNObPK1uNadeNtgW5fOeIRdKN6iDjVeN\\n' +\n        'AuXhQrmqGDYVZ1HSGUfD74sTrZQvRlWPLWtzdhybK6Css41YAyPFo9k4bJ2ZW2b/\\n' +\n        'p4EEQ8WsNja9oBpttMU6YYUchGxo1gujN8hmfDdXUQx3k5Xwx4KA68dveJ8GasIt\\n' +\n        'd+0Jd/FVwCyyx8HTiF1FF8QZYQeAXxbXJgLBuCsMQJghlcpBEzWkscBR3Ap1U0Zi\\n' +\n        '4oat8wrPZGCblaA6rNkRUVbc/+Vw0stnuJ/BLHbPxyBs6w495yBSjBqUWZMvljNz\\n' +\n        'm9/aK0ECgYEA9oVIVAd0enjSVIyAZNbw11ElidzdtBkeIJdsxqhmXzeIFZbB39Gd\\n' +\n        'bjtAVclVbq5mLsI1j22ER2rHA4Ygkn6vlLghK3ZMPxZa57oJtmL3oP0RvOjE4zRV\\n' +\n        'dzKexNGo9gU/x9SQbuyOmuauvAYhXZxeLpv+lEfsZTqqrvPUGeBiEQcCgYEA8poG\\n' +\n        'WVnykWuTmCe0bMmvYDsWpAEiZnFLDaKcSbz3O7RMGbPy1cypmqSinIYUpURBT/WY\\n' +\n        'wVPAGtjkuTXtd1Cy58m7PqziB7NNWMcsMGj+lWrTPZ6hCHIBcAImKEPpd+Y9vGJX\\n' +\n        'oatFJguqAGOz7rigBq6iPfeQOCWpmprNAuah++cCgYB1gcybOT59TnA7mwlsh8Qf\\n' +\n        'bm+tSllnin2A3Y0dGJJLmsXEPKtHS7x2Gcot2h1d98V/TlWHe5WNEUmx1VJbYgXB\\n' +\n        'pw8wj2ACxl4ojNYqWPxegaLd4DpRbtW6Tqe9e47FTnU7hIggR6QmFAWAXI+09l8y\\n' +\n        'amssNShqjE9lu5YDi6BTKwKBgQCuIlKGViLfsKjrYSyHnajNWPxiUhIgGBf4PI0T\\n' +\n        '/Jg1ea/aDykxv0rKHnw9/5vYGIsM2st/kR7l5mMecg/2Qa145HsLfMptHo1ZOPWF\\n' +\n        '9gcuttPTegY6aqKPhGthIYX2MwSDMM+X0ri6m0q2JtqjclAjG7yG4CjbtGTt/UlE\\n' +\n        'WMlSZwKBgQDslGeLUnkW0bsV5EG3AKRUyPKz/6DVNuxaIRRhOeWVKV101claqXAT\\n' +\n        'wXOpdKrvkjZbT4AzcNrlGtRl3l7dEVXTu+dN7/ZieJRu7zaStlAQZkIyP9O3DdQ3\\n' +\n        'rIcetQpfrJ1cAqz6Ng0pD0mh77vQ13WG1BBmDFa2A9BuzLoBituf4g==\\n' +\n        '-----END RSA PRIVATE KEY-----',\n    cert:\n        '-----BEGIN CERTIFICATE-----\\n' +\n        'MIICpDCCAYwCCQCuVLVKVTXnAjANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwls\\n' +\n        'b2NhbGhvc3QwHhcNMTUwMjEyMTEzMjU4WhcNMjUwMjA5MTEzMjU4WjAUMRIwEAYD\\n' +\n        'VQQDEwlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDp\\n' +\n        'nlCqHD6hZ+G0SIwcTfYe33ibBMGkB+O3e8+lfwzsMwJPAezXFxe9DiVDevCt4NM5\\n' +\n        'Z2gl4QTLuAzFeofSPDRZ8HH7wgglTr3Gy07JPsVEUO8DXJNFdjbK30rmzpIqR6f9\\n' +\n        '5sx+ZlH7Tc0PhQWwPOTPQV+ByOuReaswXkSHlRdf/71gd5TGWnSAwC379K6ZKaAJ\\n' +\n        'rKzFkuMul3i5fP5f4lXGyTUAKDU2gQ7uVYkL/dYE/swhy7bBWwx3Zd6AtPSBZh9P\\n' +\n        'X+OwgfrhT+ZL9JVcL1CHEyX1h+SjaTHU6JiEPGEezvlElmGs1HGB+LCBJvnQbDg0\\n' +\n        'BBoMjGv8Mk90uGCeljpRAgMBAAEwDQYJKoZIhvcNAQELBQADggEBABXm8GPdY0sc\\n' +\n        'mMUFlgDqFzcevjdGDce0QfboR+M7WDdm512Jz2SbRTgZD/4na42ThODOZz9z1AcM\\n' +\n        'zLgx2ZNZzVhBz0odCU4JVhOCEks/OzSyKeGwjIb4JAY7dh+Kju1+6MNfQJ4r1Hza\\n' +\n        'SVXH0+JlpJDaJ73NQ2JyfqELmJ1mTcptkA/N6rQWhlzycTBSlfogwf9xawgVPATP\\n' +\n        '4AuwgjHl12JI2HVVs1gu65Y3slvaHRCr0B4+Kg1GYNLLcbFcK+NEHrHmPxy9TnTh\\n' +\n        'Zwp1dsNQU+Xkylz8IUANWSLHYZOMtN2e5SKIdwTtl5C8YxveuY8YKb1gDExnMraT\\n' +\n        'VGXQDqPleug=\\n' +\n        '-----END CERTIFICATE-----'\n};\n\ndescribe('Fetch Tests', function() {\n    let httpServer, httpsServer;\n\n    beforeEach(function(done) {\n        httpServer = http.createServer(function(req, res) {\n            switch (req.url) {\n                case '/redirect6':\n                    res.writeHead(302, {\n                        Location: '/redirect5'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect5':\n                    res.writeHead(302, {\n                        Location: '/redirect4'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect4':\n                    res.writeHead(302, {\n                        Location: '/redirect3'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect3':\n                    res.writeHead(302, {\n                        Location: '/redirect2'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect2':\n                    res.writeHead(302, {\n                        Location: '/redirect1'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect1':\n                    res.writeHead(302, {\n                        Location: '/'\n                    });\n                    res.end();\n                    break;\n\n                case '/forever':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.write('This connection is never closed');\n                    // never end the request\n                    break;\n\n                case '/gzip': {\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain',\n                        'Content-Encoding': 'gzip'\n                    });\n\n                    let stream = zlib.createGzip();\n                    stream.pipe(res);\n                    stream.end('Hello World HTTP\\n');\n                    break;\n                }\n                case '/invalid':\n                    res.writeHead(500, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end('Hello World HTTP\\n');\n                    break;\n\n                case '/auth':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end(Buffer.from(req.headers.authorization.split(' ').pop(), 'base64'));\n                    break;\n\n                case '/cookie':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end(req.headers.cookie);\n                    break;\n\n                case '/ua':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end(req.headers['user-agent']);\n                    break;\n\n                case '/post': {\n                    let body = [];\n                    req.on('readable', function() {\n                        let chunk;\n                        while ((chunk = req.read()) !== null) {\n                            body.push(chunk);\n                        }\n                    });\n                    req.on('end', function() {\n                        res.writeHead(200, {\n                            'Content-Type': 'text/plain'\n                        });\n                        res.end(Buffer.concat(body));\n                    });\n\n                    break;\n                }\n                default:\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end('Hello World HTTP\\n');\n            }\n        });\n\n        httpsServer = https.createServer(httpsOptions, function(req, res) {\n            res.writeHead(200, {\n                'Content-Type': 'text/plain'\n            });\n            res.end('Hello World HTTPS\\n');\n        });\n\n        httpServer.listen(HTTP_PORT, function() {\n            httpsServer.listen(HTTPS_PORT, done);\n        });\n    });\n\n    afterEach(function(done) {\n        httpServer.close(function() {\n            httpsServer.close(done);\n        });\n    });\n\n    it('should fetch HTTP data', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT);\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should fetch HTTPS data', function(done) {\n        let req = fetch('https://localhost:' + HTTPS_PORT);\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTPS\\n');\n            done();\n        });\n    });\n\n    it('should fetch HTTP data with redirects', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect3');\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for too many redirects', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect6');\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n\n    it('should fetch HTTP data with custom redirect limit', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect3', {\n            maxRedirects: 3\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for custom redirect limit', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect3', {\n            maxRedirects: 2\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n\n    it('should return disable redirects', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect1', {\n            maxRedirects: 0\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n\n    it('should unzip compressed HTTP data', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/gzip');\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for unresolved host', function(done) {\n        let req = fetch('http://asfhaskhhgbjdsfhgbsdjgk');\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n\n    it('should return error for invalid status', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/invalid');\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n\n    it('should allow invalid status', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/invalid', {\n            allowErrorResponse: true\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.not.exist;\n        });\n        req.on('end', function() {\n            expect(req.statusCode).to.equal(500);\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for invalid url', function(done) {\n        let req = fetch('http://localhost:99999999/');\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n\n    it('should return timeout error', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/forever', {\n            timeout: 1000\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n\n    it('should handle basic HTTP auth', function(done) {\n        let req = fetch('http://user:pass@localhost:' + HTTP_PORT + '/auth');\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('user:pass');\n            done();\n        });\n    });\n\n    if (!/^0\\.10\\./.test(process.versions.node)) {\n        // disabled for node 0.10\n        it('should return error for invalid protocol', function(done) {\n            let req = fetch('http://localhost:' + HTTPS_PORT);\n            let buf = [];\n            req.on('data', function(chunk) {\n                buf.push(chunk);\n            });\n            req.on('error', function(err) {\n                expect(err).to.exist;\n                done();\n            });\n            req.on('end', function() {});\n        });\n    }\n\n    it('should set cookie value', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/cookie', {\n            cookie: 'test=pest'\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('test=pest');\n            done();\n        });\n    });\n\n    it('should set user agent', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/ua', {\n            userAgent: 'nodemailer-fetch'\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('nodemailer-fetch');\n            done();\n        });\n    });\n\n    it('should post data', function(done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/post', {\n            method: 'post',\n            body: {\n                hello: 'world \ud83d\ude2d',\n                another: 'value'\n            }\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal('hello=world%20%F0%9F%98%AD&another=value');\n            done();\n        });\n    });\n\n    it('should post stream data', function(done) {\n        let body = new PassThrough();\n        let data = Buffer.from('hello=world%20%F0%9F%98%AD&another=value');\n\n        let req = fetch('http://localhost:' + HTTP_PORT + '/post', {\n            method: 'post',\n            body\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function() {\n            expect(Buffer.concat(buf).toString()).to.equal(data.toString());\n            done();\n        });\n\n        let pos = 0;\n        let writeNext = function() {\n            if (pos >= data.length) {\n                return body.end();\n            }\n            let char = data.slice(pos++, pos);\n            body.write(char);\n            setImmediate(writeNext);\n        };\n\n        setImmediate(writeNext);\n    });\n\n    it('should return error for invalid cert', function(done) {\n        let req = fetch('https://localhost:' + HTTPS_PORT, {\n            tls: {\n                rejectUnauthorized: true\n            }\n        });\n        let buf = [];\n        req.on('data', function(chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function(err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function() {});\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst nodemailer = require('../../lib/nodemailer');\nconst chai = require('chai');\nconst expect = chai.expect;\nchai.config.includeStack = true;\n\ndescribe('JSON Transport Tests', function() {\n    it('should return an JSON string', function(done) {\n        let transport = nodemailer.createTransport({\n            jsonTransport: true\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: {\n                path: __dirname + '/fixtures/body.html'\n            },\n            text: 'hello world',\n            attachments: [\n                {\n                    filename: 'img.png',\n                    path: __dirname + '/fixtures/image.png'\n                },\n                {\n                    path: __dirname + '/fixtures/image.png'\n                }\n            ]\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(JSON.parse(info.message)).to.deep.equal({\n                from: {\n                    address: 'andris.reinman@gmail.com',\n                    name: 'Andris Reinman'\n                },\n                to: [\n                    //\n                    {\n                        address: 'andris@kreata.ee',\n                        name: 'Andris Kreata'\n                    },\n                    {\n                        address: 'andris@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                cc: [\n                    {\n                        address: 'info@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                subject: 'Awesome!',\n                html: '<h1>Message</h1>\\n\\n<p>\\n    Body\\n</p>\\n',\n                text: 'hello world',\n                attachments: [\n                    {\n                        content:\n                            'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC',\n                        filename: 'img.png',\n                        contentType: 'image/png',\n                        encoding: 'base64'\n                    },\n                    {\n                        content:\n                            'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC',\n                        filename: 'image.png',\n                        contentType: 'image/png',\n                        encoding: 'base64'\n                    }\n                ],\n                headers: {},\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>'\n            });\n            done();\n        });\n    });\n\n    it('should return an JSON string for calendar event', function(done) {\n        let transport = nodemailer.createTransport({\n            jsonTransport: true\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: '<p>hello world!</p>',\n            text: 'hello world',\n            icalEvent: {\n                method: 'request',\n                path: __dirname + '/fixtures/event.ics'\n            }\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(JSON.parse(info.message)).to.deep.equal({\n                from: {\n                    address: 'andris.reinman@gmail.com',\n                    name: 'Andris Reinman'\n                },\n                to: [\n                    //\n                    {\n                        address: 'andris@kreata.ee',\n                        name: 'Andris Kreata'\n                    },\n                    {\n                        address: 'andris@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                cc: [\n                    {\n                        address: 'info@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                subject: 'Awesome!',\n                text: 'hello world',\n\n                html: '<p>hello world!</p>',\n                icalEvent: {\n                    content:\n                        'QkVHSU46VkNBTEVOREFSClZFUlNJT046Mi4wClBST0RJRDotLy9oYWNrc3cvaGFuZGNhbC8vTk9OU0dNTCB2MS4wLy9FTgpCRUdJTjpWRVZFTlQKVUlEOnVpZDFAZXhhbXBsZS5jb20KRFRTVEFNUDoxOTk3MDcxNFQxNzAwMDBaCk9SR0FOSVpFUjtDTj1Kb2huIERvZTpNQUlMVE86am9obi5kb2VAZXhhbXBsZS5jb20KRFRTVEFSVDoxOTk3MDcxNFQxNzAwMDBaCkRURU5EOjE5OTcwNzE1VDAzNTk1OVoKU1VNTUFSWTpCYXN0aWxsZSBEYXkgUGFydHkKRU5EOlZFVkVOVApFTkQ6VkNBTEVOREFSCg==',\n                    encoding: 'base64',\n                    method: 'request'\n                },\n\n                headers: {},\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>'\n            });\n            done();\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst libqp = require('libqp');\nconst qp = require('../../lib/qp');\nconst chai = require('chai');\nconst expect = chai.expect;\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nchai.config.includeStack = true;\n\ndescribe('Quoted-Printable Tests', function() {\n    let encodeFixtures = [\n        ['abcd= \u00d5\u00c4\u00d6\u00dc', 'abcd=3D =C3=95=C3=84=C3=96=C3=9C'],\n        ['foo bar  ', 'foo bar =20'],\n        ['foo bar\\t\\t', 'foo bar\\t=09'],\n        ['foo \\r\\nbar', 'foo=20\\r\\nbar']\n    ];\n\n    let wrapFixtures = [\n        ['tere, tere, vana kere, kuidas sul l=C3=A4heb?', 'tere, tere, vana =\\r\\nkere, kuidas sul =\\r\\nl=C3=A4heb?'],\n        ['=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4', '=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4'],\n        ['1234567890123456789=C3=A40', '1234567890123456789=\\r\\n=C3=A40'],\n        ['123456789012345678  90', '123456789012345678 =\\r\\n 90']\n    ];\n\n    let streamFixture = [\n        '123456789012345678  90\\r\\n\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc another line === ',\n        '12345678=\\r\\n90123456=\\r\\n78=20=20=\\r\\n90\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=20anoth=\\r\\ner=20lin=\\r\\ne=20=3D=\\r\\n=3D=3D=20'\n    ];\n\n    describe('#encode', function() {\n        it('shoud encode UTF-8 string to QP', function() {\n            encodeFixtures.forEach(function(test) {\n                expect(qp.encode(test[0])).to.equal(test[1]);\n            });\n        });\n\n        it('shoud encode Buffer to QP', function() {\n            expect(qp.encode(Buffer.from([0x00, 0x01, 0x02, 0x20, 0x03]))).to.equal('=00=01=02 =03');\n        });\n    });\n\n    describe('#wrap', function() {\n        it('should wrap long QP encoded lines', function() {\n            wrapFixtures.forEach(function(test) {\n                expect(qp.wrap(test[0], 20)).to.equal(test[1]);\n            });\n        });\n\n        it('should wrap line ending with <CR>', function() {\n            expect(qp.wrap('alfa palfa kalfa ralfa\\r', 10)).to.equal('alfa palf=\\r\\na kalfa =\\r\\nralfa\\r');\n        });\n    });\n\n    describe('QP Streams', function() {\n        it('should transform incoming bytes to QP', function(done) {\n            let encoder = new qp.Encoder({\n                lineLength: 9\n            });\n\n            let bytes = Buffer.from(streamFixture[0]),\n                i = 0,\n                buf = [],\n                buflen = 0;\n\n            encoder.on('data', function(chunk) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            });\n\n            encoder.on('end', function(chunk) {\n                if (chunk) {\n                    buf.push(chunk);\n                    buflen += chunk.length;\n                }\n                buf = Buffer.concat(buf, buflen);\n\n                expect(buf.toString()).to.equal(streamFixture[1]);\n                done();\n            });\n\n            let sendNextByte = function() {\n                if (i >= bytes.length) {\n                    return encoder.end();\n                }\n\n                let ord = bytes[i++];\n                encoder.write(Buffer.from([ord]));\n                setImmediate(sendNextByte);\n            };\n\n            sendNextByte();\n        });\n\n        it('should transform incoming bytes to QP and back', function(done) {\n            let decoder = new libqp.Decoder();\n            let encoder = new qp.Encoder();\n            let file = fs.createReadStream(__dirname + '/fixtures/alice.txt');\n\n            let fhash = crypto.createHash('md5');\n            let dhash = crypto.createHash('md5');\n\n            file.pipe(encoder).pipe(decoder);\n\n            file.on('data', function(chunk) {\n                fhash.update(chunk);\n            });\n\n            file.on('end', function() {\n                fhash = fhash.digest('hex');\n            });\n\n            decoder.on('data', function(chunk) {\n                dhash.update(chunk);\n            });\n\n            decoder.on('end', function() {\n                dhash = dhash.digest('hex');\n                expect(fhash).to.equal(dhash);\n                done();\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst LeUnix = require('../../lib/sendmail-transport/le-unix');\nconst chai = require('chai');\nconst expect = chai.expect;\n\nchai.config.includeStack = true;\n\ndescribe('Sendmail Unix Newlines', function() {\n    it('should rewrite all linebreaks (byte by byte)', function(done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeUnix();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        let pos = 0;\n        let writeNextByte = () => {\n            if (pos >= data.length) {\n                return out.end();\n            }\n            out.write(Buffer.from([data[pos++]]));\n            setImmediate(writeNextByte);\n        };\n\n        setImmediate(writeNextByte);\n    });\n\n    it('should rewrite all linebreaks (all at once)', function(done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeUnix();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        out.end(data);\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst LeWindows = require('../../lib/sendmail-transport/le-windows');\nconst chai = require('chai');\nconst expect = chai.expect;\n\nchai.config.includeStack = true;\n\ndescribe('Sendmail Windows Newlines', function() {\n    it('should rewrite all linebreaks (byte by byte)', function(done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeWindows();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\r\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        let pos = 0;\n        let writeNextByte = () => {\n            if (pos >= data.length) {\n                return out.end();\n            }\n            out.write(Buffer.from([data[pos++]]));\n            setImmediate(writeNextByte);\n        };\n\n        setImmediate(writeNextByte);\n    });\n\n    it('should rewrite all linebreaks (all at once)', function(done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeWindows();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\r\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        out.end(data);\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst PassThrough = require('stream').PassThrough;\nconst EventEmitter = require('events').EventEmitter;\nconst sinon = require('sinon');\nconst SendmailTransport = require('../../lib/sendmail-transport');\nchai.config.includeStack = true;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('Sendmail Transport Tests', function() {\n    it('Should expose version number', function() {\n        let client = new SendmailTransport();\n        expect(client.name).to.exist;\n        expect(client.version).to.exist;\n    });\n\n    it('Should send message', function(done) {\n        let client = new SendmailTransport();\n\n        let stubbedSpawn = new EventEmitter();\n        stubbedSpawn.stdin = new PassThrough();\n        stubbedSpawn.stdout = new PassThrough();\n\n        let output = '';\n        stubbedSpawn.stdin.on('data', function(chunk) {\n            output += chunk.toString();\n        });\n\n        stubbedSpawn.stdin.on('end', function() {\n            stubbedSpawn.emit('close', 0);\n            stubbedSpawn.emit('exit', 0);\n        });\n\n        sinon.stub(client, '_spawn').returns(stubbedSpawn);\n\n        client.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'message\\r\\nline 2'\n                )\n            },\n            function(err, data) {\n                expect(err).to.not.exist;\n                expect(data.messageId).to.equal('<test>');\n                expect(output).to.equal('message\\nline 2');\n                client._spawn.restore();\n                done();\n            }\n        );\n    });\n\n    it('Should return an error', function(done) {\n        let client = new SendmailTransport();\n\n        let stubbedSpawn = new EventEmitter();\n        stubbedSpawn.stdin = new PassThrough();\n        stubbedSpawn.stdout = new PassThrough();\n\n        stubbedSpawn.stdin.on('data', () => false);\n\n        stubbedSpawn.stdin.on('end', function() {\n            stubbedSpawn.emit('close', 127);\n            stubbedSpawn.emit('exit', 127);\n        });\n\n        sinon.stub(client, '_spawn').returns(stubbedSpawn);\n\n        client.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'message\\r\\nline 2'\n                )\n            },\n            function(err, data) {\n                expect(err).to.exist;\n                expect(data).to.not.exist;\n                client._spawn.restore();\n                done();\n            }\n        );\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst nodemailer = require('../../lib/nodemailer');\nconst chai = require('chai');\nconst expect = chai.expect;\nchai.config.includeStack = true;\n\nconst privateKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIBywIBAAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8knBf3+uA7q/CSxpX6sQ8N\ndFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44ARpgHY4V0qSCdUt4rD32n\nwfjlGbh8p5ua5wIDAQABAmAm+uUQpQPTu7kg95wqVqw2sxLsa9giT6M8MtxQH7Uo\n1TF0eAO0TQ4KOxgY1S9OT5sGPVKnag258m3qX7o5imawcuyStb68DQgAUg6xv7Af\nAqAEDfYN5HW6xK+X81jfOUECMQDr7XAS4PERATvgb1B3vRu5UEbuXcenHDYgdoyT\n3qJFViTbep4qeaflF0uF9eFveMcCMQDic10rJ8fopGD7/a45O4VJb0+lRXVdqZxJ\nQzAp+zVKWqDqPfX7L93SQLzOGhdd7OECMQDeQyD7WBkjSQNMy/GF7I1qxrscIxNN\nVqGTcbu8Lti285Hjhx/sqhHHHGwU9vB7oM8CMQDKTS3Kw/s/xrot5O+kiZwFgr+w\ncmDrj/7jJHb+ykFNb7GaEkiSYqzUjKkfpweBDYECMFJUyzuuFJAjq3BXmGJlyykQ\nTweUw+zMVdSXjO+FCPcYNi6CP1t1KoESzGKBVoqA/g==\n-----END RSA PRIVATE KEY-----`;\n\ndescribe('SES Transport Tests', function() {\n    this.timeout(50 * 1000); // eslint-disable-line no-invalid-this\n\n    it('should return MessageId', function(done) {\n        let transport = nodemailer.createTransport({\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                // Prevent tests from actually sending mail by mocking sendRawEmail\n                sendRawEmail: (message, cb) => {\n                    setImmediate(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    });\n                }\n            }\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: {\n                path: __dirname + '/../json-transport/fixtures/body.html'\n            },\n            text: 'hello world',\n            attachments: [\n                {\n                    filename: 'image.png',\n                    path: __dirname + '/../json-transport/fixtures/image.png'\n                }\n            ]\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n            expect(info.envelope).to.deep.equal({\n                from: 'andris.reinman@gmail.com',\n                to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n            });\n            expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n            expect(info.response).to.equal('testtest');\n            done();\n        });\n    });\n\n    it('should sign message with DKIM', function(done) {\n        let transport = nodemailer.createTransport({\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    expect(message.RawMessage.Data.toString()).to.include('h=from:subject:to:cc:mime-version:content-type;');\n                    setImmediate(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    });\n                }\n            },\n            dkim: {\n                domainName: 'node.ee',\n                keySelector: 'dkim',\n                privateKey\n            }\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: {\n                path: __dirname + '/../json-transport/fixtures/body.html'\n            },\n            text: 'hello world',\n            attachments: [\n                {\n                    filename: 'image.png',\n                    path: __dirname + '/../json-transport/fixtures/image.png'\n                }\n            ]\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n            expect(info.envelope).to.deep.equal({\n                from: 'andris.reinman@gmail.com',\n                to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n            });\n            expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n            expect(info.response).to.equal('testtest');\n            done();\n        });\n    });\n\n    it('should limit parallel connections', function(done) {\n        let transport = nodemailer.createTransport({\n            maxConnections: 2,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(5000);\n                    expect(Date.now() - start).to.be.lte(10000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('should rate limit messages', function(done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 10,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(10000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('should rate limit long messages', function(done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 30,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 3000);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(12000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('should rate limit messages and connections', function(done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 100,\n            maxConnections: 1,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(10000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('detect sending slots on idle events', function(done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 100,\n            maxConnections: 1,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n        let sent = 0;\n\n        let sendNext = () => {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(10000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        };\n\n        transport.on('idle', () => {\n            while (transport.isIdle() && sent < total) {\n                sent++;\n                sendNext();\n            }\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, afterEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst shared = require('../../lib/shared');\n\nconst http = require('http');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nchai.config.includeStack = true;\n\ndescribe('Shared Funcs Tests', function() {\n    describe('Logger tests', function() {\n        it('Should create a logger', function() {\n            expect(\n                typeof shared.getLogger({\n                    logger: false\n                })\n            ).to.equal('object');\n            expect(\n                typeof shared.getLogger({\n                    logger: true\n                })\n            ).to.equal('object');\n            expect(typeof shared.getLogger()).to.equal('object');\n        });\n    });\n\n    describe('Connection url parser tests', function() {\n        it('Should parse connection url', function() {\n            let url = 'smtps://user:pass@localhost:123?tls.rejectUnauthorized=false&name=horizon';\n            expect(shared.parseConnectionUrl(url)).to.deep.equal({\n                secure: true,\n                port: 123,\n                host: 'localhost',\n                auth: {\n                    user: 'user',\n                    pass: 'pass'\n                },\n                tls: {\n                    rejectUnauthorized: false\n                },\n                name: 'horizon'\n            });\n        });\n\n        it('should not choke on special symbols in auth', function() {\n            let url = 'smtps://user%40gmail.com:%3Apasswith%25Char@smtp.gmail.com';\n            expect(shared.parseConnectionUrl(url)).to.deep.equal({\n                secure: true,\n                host: 'smtp.gmail.com',\n                auth: {\n                    user: 'user@gmail.com',\n                    pass: ':passwith%Char'\n                }\n            });\n        });\n    });\n\n    describe('Resolver tests', function() {\n        let port = 10337;\n        let server;\n\n        beforeEach(function(done) {\n            server = http.createServer(function(req, res) {\n                if (/redirect/.test(req.url)) {\n                    res.writeHead(302, {\n                        Location: 'http://localhost:' + port + '/message.html'\n                    });\n                    res.end('Go to http://localhost:' + port + '/message.html');\n                } else if (/compressed/.test(req.url)) {\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain',\n                        'Content-Encoding': 'gzip'\n                    });\n                    let stream = zlib.createGzip();\n                    stream.pipe(res);\n                    stream.write('<p>Tere, tere</p><p>vana kere!</p>\\n');\n                    stream.end();\n                } else {\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end('<p>Tere, tere</p><p>vana kere!</p>\\n');\n                }\n            });\n\n            server.listen(port, done);\n        });\n\n        afterEach(function(done) {\n            server.close(done);\n        });\n\n        it('should set text from html string', function(done) {\n            let mail = {\n                data: {\n                    html: '<p>Tere, tere</p><p>vana kere!</p>\\n'\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.equal('<p>Tere, tere</p><p>vana kere!</p>\\n');\n                done();\n            });\n        });\n\n        it('should set text from html buffer', function(done) {\n            let mail = {\n                data: {\n                    html: Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n')\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(mail.data.html);\n                done();\n            });\n        });\n\n        it('should set text from a html file', function(done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: __dirname + '/fixtures/message.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from an html url', function(done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + port + '/message.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from redirecting url', function(done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + port + '/redirect.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from gzipped url', function(done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + port + '/compressed.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from a html stream', function(done) {\n            let mail = {\n                data: {\n                    html: fs.createReadStream(__dirname + '/fixtures/message.html')\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(mail).to.deep.equal({\n                    data: {\n                        html: Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n')\n                    }\n                });\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should return an error', function(done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + (port + 1000) + '/message.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err) {\n                expect(err).to.exist;\n                done();\n            });\n        });\n\n        it('should return encoded string as buffer', function(done) {\n            let str = '<p>Tere, tere</p><p>vana kere!</p>\\n';\n            let mail = {\n                data: {\n                    html: {\n                        encoding: 'base64',\n                        content: Buffer.from(str).toString('base64')\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function(err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from(str));\n                done();\n            });\n        });\n\n        describe('data uri tests', function() {\n            it('should resolve with mime type and base64', function(done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path:\n                                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function(err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(\n                        Buffer.from(\n                            'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==',\n                            'base64'\n                        )\n                    );\n                    done();\n                });\n            });\n\n            it('should resolve with mime type and plaintext', function(done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path: 'data:image/png,tere%20tere'\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function(err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(Buffer.from('tere tere'));\n                    done();\n                });\n            });\n\n            it('should resolve with plaintext', function(done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path: 'data:,tere%20tere'\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function(err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(Buffer.from('tere tere'));\n                    done();\n                });\n            });\n\n            it('should resolve with mime type, charset and base64', function(done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path:\n                                'data:image/png;charset=iso-8859-1;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function(err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(\n                        Buffer.from(\n                            'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==',\n                            'base64'\n                        )\n                    );\n                    done();\n                });\n            });\n        });\n    });\n\n    describe('#assign tests', function() {\n        it('should assign multiple objects to target', function() {\n            let target = {\n                a: 1,\n                b: 2,\n                c: 3\n            };\n            let arg1 = {\n                b: 5,\n                y: 66,\n                e: 33\n            };\n\n            let arg2 = {\n                y: 17,\n                qq: 98\n            };\n\n            shared.assign(target, arg1, arg2);\n            expect(target).to.deep.equal({\n                a: 1,\n                b: 5,\n                c: 3,\n                y: 17,\n                e: 33,\n                qq: 98\n            });\n        });\n    });\n\n    describe('#encodeXText tests', function() {\n        it('should not encode atom', function() {\n            expect(shared.encodeXText('teretere')).to.equal('teretere');\n        });\n\n        it('should not encode email', function() {\n            expect(shared.encodeXText('andris.reinman@gmail.com')).to.equal('andris.reinman@gmail.com');\n        });\n\n        it('should encode space', function() {\n            expect(shared.encodeXText('tere tere')).to.equal('tere+20tere');\n        });\n\n        it('should encode unicode', function() {\n            expect(shared.encodeXText('tere t\u00f5re')).to.equal('tere+20t+C3+B5re');\n        });\n\n        it('should encode low codes', function() {\n            expect(shared.encodeXText('tere t\\tre')).to.equal('tere+20t+09re');\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst http = require('http');\nconst proxy = require('proxy');\nconst httpProxyClient = require('../../lib/smtp-connection/http-proxy-client');\nconst SMTPServer = require('smtp-server').SMTPServer;\nconst chai = require('chai');\nconst expect = chai.expect;\n\nchai.config.includeStack = true;\n\nconst PROXY_PORT = 3128;\nconst TARGET_PORT = 3129;\n\ndescribe('HTTP Proxy Client Tests', function() {\n    it('should connect to a socket through proxy', function(done) {\n        let smtpServer = new SMTPServer({\n            logger: false\n        });\n\n        smtpServer.listen(TARGET_PORT, () => {\n            let proxyServer = proxy(http.createServer());\n            proxyServer.listen(PROXY_PORT, () => {\n                httpProxyClient('http://localhost:' + PROXY_PORT, TARGET_PORT, '127.0.0.1', (err, socket) => {\n                    expect(err).to.not.exist;\n                    socket.once('data', chunk => {\n                        expect(/^220[ -]/.test(chunk.toString())).to.be.true;\n                        socket.end();\n                        socket.on('close', () => {\n                            socket.destroy();\n                            smtpServer.close(() => setImmediate(done) && proxyServer.close());\n                        });\n                    });\n                });\n            });\n        });\n    });\n    it('should connect to a socket through proxy with auth', function(done) {\n        let smtpServer = new SMTPServer({\n            logger: false\n        });\n\n        smtpServer.listen(TARGET_PORT, () => {\n            let proxyServer = proxy(http.createServer());\n            proxyServer.authenticate = (req, cb) => {\n                cb(null, req.headers['proxy-authorization'] === 'Basic dGVzdDpwZXN0');\n            };\n            proxyServer.listen(PROXY_PORT, () => {\n                httpProxyClient('http://test:pest@localhost:' + PROXY_PORT, TARGET_PORT, '127.0.0.1', (err, socket) => {\n                    expect(err).to.not.exist;\n                    socket.once('data', chunk => {\n                        expect(/^220[ -]/.test(chunk.toString())).to.be.true;\n                        socket.end();\n                        socket.on('close', () => {\n                            socket.destroy();\n                            smtpServer.close(() => setImmediate(done) && proxyServer.close());\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    it('should should fail auth', function(done) {\n        let smtpServer = new SMTPServer({\n            logger: false\n        });\n\n        smtpServer.listen(TARGET_PORT, () => {\n            let proxyServer = proxy(http.createServer());\n            proxyServer.authenticate = (req, cb) => {\n                cb(null, req.headers['proxy-authorization'] === 'Basic dGVzdDpwZXN0');\n            };\n            proxyServer.listen(PROXY_PORT, () => {\n                httpProxyClient('http://test:kest@localhost:' + PROXY_PORT, TARGET_PORT, '127.0.0.1', (err, socket) => {\n                    expect(err).to.exist;\n                    expect(socket).to.not.exist;\n\n                    smtpServer.close(() => setImmediate(done) && proxyServer.close());\n                });\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, no-var: 0, prefer-arrow-callback: 0, object-shorthand: 0 */\n/* globals afterEach, beforeEach, describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nlet fs = require('fs');\nlet chai = require('chai');\nlet expect = chai.expect;\nlet SMTPConnection = require('../../lib/smtp-connection');\nlet packageData = require('../../package.json');\nlet SMTPServer = require('smtp-server').SMTPServer;\nlet HttpConnectProxy = require('proxy-test-server');\nlet net = require('net');\nlet xoauth2Server = require('./xoauth2-mock-server');\nlet XOAuth2 = require('../../lib/xoauth2');\nlet sinon = require('sinon');\n\nchai.config.includeStack = true;\n\nlet PORT_NUMBER = 8397;\nlet PROXY_PORT_NUMBER = 9999;\nlet LMTP_PORT_NUMBER = 8396;\nlet XOAUTH_PORT = 8497;\n\ndescribe('SMTP-Connection Tests', function() {\n    describe('Version test', function() {\n        it('Should expose version number', function() {\n            let client = new SMTPConnection();\n            expect(client.version).to.equal(packageData.version);\n        });\n    });\n\n    describe('Connection tests', function() {\n        let server, insecureServer, invalidServer, secureServer, httpProxy;\n\n        beforeEach(function(done) {\n            server = new SMTPServer({\n                onAuth: function(auth, session, callback) {\n                    if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                        return callback(new Error('Invalid username or password'));\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onData: function(stream, session, callback) {\n                    stream.on('data', function() {});\n                    stream.on('end', callback);\n                }\n            });\n\n            insecureServer = new SMTPServer({\n                disabledCommands: ['STARTTLS', 'AUTH'],\n                onData: function(stream, session, callback) {\n                    let err = false;\n                    stream.on('data', function(chunk) {\n                        if (err || session.use8BitMime) {\n                            return;\n                        }\n                        for (let i = 0, len = chunk.length; i < len; i++) {\n                            if (chunk[i] >= 0x80) {\n                                err = new Error('8 bit content not allowed');\n                            }\n                        }\n                    });\n                    stream.on('end', function() {\n                        callback(err, false);\n                    });\n                },\n                logger: false\n            });\n\n            invalidServer = net.createServer(function() {});\n\n            secureServer = new SMTPServer({\n                secure: true,\n                onAuth: function(auth, session, callback) {\n                    if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                        return callback(new Error('Invalid username or password'));\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onData: function(stream, session, callback) {\n                    stream.on('data', function() {});\n                    stream.on('end', callback);\n                },\n                logger: false\n            });\n\n            httpProxy = new HttpConnectProxy();\n\n            server.listen(PORT_NUMBER, function() {\n                invalidServer.listen(PORT_NUMBER + 1, function() {\n                    secureServer.listen(PORT_NUMBER + 2, function() {\n                        insecureServer.listen(PORT_NUMBER + 3, function() {\n                            httpProxy.listen(PROXY_PORT_NUMBER, done);\n                        });\n                    });\n                });\n            });\n        });\n\n        afterEach(function(done) {\n            server.close(function() {\n                invalidServer.close(function() {\n                    secureServer.close(function() {\n                        insecureServer.close(function() {\n                            httpProxy.close(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('should connect to unsecure server', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                ignoreTLS: true,\n                logger: false\n            });\n\n            client.connect(function() {\n                expect(client.secure).to.be.false;\n                client.close();\n            });\n\n            client.on('error', function(err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a server and upgrade with STARTTLS', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                logger: false\n            });\n\n            client.connect(function() {\n                expect(client.secure).to.be.true;\n                client.close();\n            });\n\n            client.on('error', function(err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a server and upgrade with forced STARTTLS', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                requireTLS: true,\n                transactionLog: true,\n                logger: false\n            });\n\n            client.connect(function() {\n                expect(client.secure).to.be.true;\n                client.close();\n            });\n\n            client.on('error', function(err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a server and try to upgrade STARTTLS', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                logger: false,\n                requireTLS: true,\n                opportunisticTLS: true\n            });\n\n            client.connect(function() {\n                expect(client.secure).to.be.false;\n                client.close();\n            });\n\n            client.on('error', function(err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should try upgrade with STARTTLS where not advertised', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                requireTLS: true,\n                logger: false\n            });\n\n            client.connect(function() {\n                // should not run\n                expect(false).to.be.true;\n                client.close();\n            });\n\n            client.once('error', function(err) {\n                expect(err).to.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should close connection after STARTTLS', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                logger: false\n            });\n\n            client.connect(function() {\n                expect(client.secure).to.be.true;\n                server.connections.forEach(function(conn) {\n                    conn.close();\n                });\n            });\n\n            client.on('error', function(err) {\n                expect(err.message).to.equal('Connection closed unexpectedly');\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a secure server', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 2,\n                secure: true,\n                logger: false\n            });\n\n            client.connect(function() {\n                expect(client.secure).to.be.true;\n                client.close();\n            });\n\n            client.on('error', function(err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should emit error for invalid port', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 10,\n                logger: false\n            });\n\n            client.connect(function() {\n                // should not run\n                expect(false).to.be.true;\n                client.close();\n            });\n\n            client.once('error', function(err) {\n                expect(err).to.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should emit error for too large port', function(done) {\n            let client = new SMTPConnection({\n                port: 999999999,\n                logger: false\n            });\n\n            client.connect(function() {\n                // should not run\n                expect(false).to.be.true;\n                client.close();\n            });\n\n            client.once('error', function(err) {\n                expect(err).to.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should emit inactivity timeout error', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                socketTimeout: 100,\n                logger: false\n            });\n\n            client.connect(function() {\n                // do nothing\n            });\n\n            client.once('error', function(err) {\n                expect(err).to.exist;\n                expect(err.code).to.equal('ETIMEDOUT');\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect through proxy', function(done) {\n            let runTest = function(socket) {\n                let client = new SMTPConnection({\n                    logger: false,\n                    port: PORT_NUMBER,\n                    connection: socket\n                });\n\n                client.connect(function() {\n                    expect(client.secure).to.be.true;\n                    client.login(\n                        {\n                            user: 'testuser',\n                            credentials: {\n                                user: 'testuser',\n                                pass: 'testpass'\n                            }\n                        },\n                        function(err) {\n                            expect(err).to.not.exist;\n                            expect(client.authenticated).to.be.true;\n                            client.close();\n                        }\n                    );\n                });\n\n                client.on('error', function(err) {\n                    expect(err).to.not.exist;\n                });\n\n                client.on('end', done);\n            };\n\n            proxyConnect(PROXY_PORT_NUMBER, '127.0.0.1', PORT_NUMBER, '127.0.0.1', function(err, socket) {\n                expect(err).to.not.exist;\n                runTest(socket);\n            });\n        });\n\n        it('should connect through proxy to secure server', function(done) {\n            let runTest = function(socket) {\n                let client = new SMTPConnection({\n                    logger: false,\n                    port: PORT_NUMBER + 2,\n                    secure: true,\n                    connection: socket\n                });\n\n                client.connect(function() {\n                    expect(client.secure).to.be.true;\n                    client.login(\n                        {\n                            user: 'testuser',\n                            credentials: {\n                                user: 'testuser',\n                                pass: 'testpass'\n                            }\n                        },\n                        function(err) {\n                            expect(err).to.not.exist;\n                            expect(client.authenticated).to.be.true;\n                            client.close();\n                        }\n                    );\n                });\n\n                client.on('error', function(err) {\n                    expect(err).to.not.exist;\n                });\n\n                client.on('end', done);\n            };\n\n            proxyConnect(PROXY_PORT_NUMBER, '127.0.0.1', PORT_NUMBER + 2, '127.0.0.1', function(err, socket) {\n                expect(err).to.not.exist;\n                runTest(socket);\n            });\n        });\n\n        it('should send to unsecure server', function(done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                ignoreTLS: true,\n                logger: false\n            });\n\n            client.on('error', function(err) {\n                expect(err).to.not.exist;\n            });\n\n            client.connect(function() {\n                expect(client.secure).to.be.false;\n\n                let chunks = [],\n                    fname = __dirname + '/../../LICENSE',\n                    message = fs.readFileSync(fname, 'utf-8');\n\n                server.on('data', function(connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function(connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(\n                        message\n                            .toString()\n                            .trim()\n                            .replace(/\\n/g, '\\r\\n')\n                    );\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    fs.createReadStream(fname),\n                    function(err) {\n                        expect(err).to.not.exist;\n                        client.close();\n                    }\n                );\n            });\n\n            client.on('end', done);\n        });\n    });\n\n    describe('Login tests', function() {\n        this.timeout(10 * 1000);\n\n        let server,\n            lmtpServer,\n            client,\n            lmtpClient,\n            testtoken = 'testtoken';\n\n        beforeEach(function(done) {\n            server = new SMTPServer({\n                authMethods: ['PLAIN', 'XOAUTH2'],\n                disabledCommands: ['STARTTLS'],\n\n                size: 100 * 1024,\n\n                onData: function(stream, session, callback) {\n                    let err = false;\n                    stream.on('data', function(chunk) {\n                        if (err || session.use8BitMime) {\n                            return;\n                        }\n                        for (let i = 0, len = chunk.length; i < len; i++) {\n                            if (chunk[i] >= 0x80) {\n                                err = new Error('8 bit content not allowed');\n                            }\n                        }\n                    });\n                    stream.on('end', function() {\n                        callback(err, false);\n                    });\n                },\n\n                onAuth: function(auth, session, callback) {\n                    if (auth.method !== 'XOAUTH2') {\n                        if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                            return callback(new Error('Invalid username or password'));\n                        }\n                    } else if (auth.username !== 'testuser' || auth.accessToken !== testtoken) {\n                        return callback(null, {\n                            data: {\n                                status: '401',\n                                schemes: 'bearer mac',\n                                scope: 'my_smtp_access_scope_name'\n                            }\n                        });\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onMailFrom: function(address, session, callback) {\n                    if (address.args && parseInt(address.args.SIZE, 10) > 50 * 1024) {\n                        return callback(new Error('452 Insufficient channel storage: ' + address.address));\n                    }\n\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n\n                    if (address.args.SMTPUTF8) {\n                        session.smtpUtf8 = true;\n                    }\n\n                    if (address.args.BODY === '8BITMIME') {\n                        session.use8BitMime = true;\n                    }\n\n                    if (/[\\x80-\\uFFFF]/.test(address.address) && !session.smtpUtf8) {\n                        return callback(new Error('Trying to use Unicode address without declaring SMTPUTF8 first'));\n                    }\n\n                    return callback(); // Accept the address\n                },\n                onRcptTo: function(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    if (/[\\x80-\\uFFFF]/.test(address.address) && !session.smtpUtf8) {\n                        return callback(new Error('Trying to use Unicode address without declaring SMTPUTF8 first'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            lmtpServer = new SMTPServer({\n                lmtp: true,\n                disabledCommands: ['STARTTLS', 'AUTH'],\n\n                onData: function(stream, session, callback) {\n                    stream.on('data', function() {});\n                    stream.on('end', function() {\n                        let response = session.envelope.rcptTo.map(function(rcpt, i) {\n                            if (i % 2) {\n                                return '<' + rcpt.address + '> Accepted';\n                            } else {\n                                return new Error('<' + rcpt.address + '> Not accepted');\n                            }\n                        });\n                        callback(null, response);\n                    });\n                },\n                onMailFrom: function(address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                onRcptTo: function(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            client = new SMTPConnection({\n                port: PORT_NUMBER,\n                logger: false,\n                debug: false\n            });\n\n            lmtpClient = new SMTPConnection({\n                port: LMTP_PORT_NUMBER,\n                lmtp: true,\n                logger: false,\n                debug: false\n            });\n\n            server.listen(PORT_NUMBER, function() {\n                lmtpServer.listen(LMTP_PORT_NUMBER, function() {\n                    client.connect(function() {\n                        lmtpClient.connect(done);\n                    });\n                });\n            });\n        });\n\n        afterEach(function(done) {\n            client.close();\n            lmtpClient.close();\n            server.close(function() {\n                lmtpServer.close(done);\n            });\n        });\n\n        it('should login', function(done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser',\n                    credentials: {\n                        user: 'testuser',\n                        pass: 'testpass'\n                    }\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    expect(client.authenticated).to.be.true;\n                    done();\n                }\n            );\n        });\n\n        it('should return error for invalid login', function(done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser',\n                    credentials: {\n                        user: 'testuser',\n                        pass: 'invalid'\n                    }\n                },\n                function(err) {\n                    expect(err).to.exist;\n                    expect(client.authenticated).to.be.false;\n                    expect(err.code).to.equal('EAUTH');\n                    expect(err.responseCode).to.equal(535);\n                    done();\n                }\n            );\n        });\n\n        it('should return error for missing credentials', function(done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser'\n                },\n                function(err) {\n                    expect(err).to.exist;\n                    expect(client.authenticated).to.be.false;\n                    expect(err.message).to.match(/^Missing credentials/);\n                    expect(err.code).to.equal('EAUTH');\n                    expect(err.response).to.be.undefined;\n                    done();\n                }\n            );\n        });\n\n        it('should return error for incomplete credentials', function(done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser',\n                    credentials: {\n                        user: 'testuser'\n                    }\n                },\n                function(err) {\n                    expect(err).to.exist;\n                    expect(client.authenticated).to.be.false;\n                    expect(err.message).to.match(/^Missing credentials/);\n                    expect(err.code).to.equal('EAUTH');\n                    expect(err.response).to.be.undefined;\n                    done();\n                }\n            );\n        });\n\n        describe('xoauth2 login', function() {\n            this.timeout(10 * 1000);\n            let x2server;\n\n            beforeEach(function(done) {\n                x2server = xoauth2Server({\n                    port: XOAUTH_PORT,\n                    onUpdate: function(username, accessToken) {\n                        testtoken = accessToken;\n                    }.bind(this)\n                });\n\n                x2server.addUser('testuser', 'refresh-token');\n\n                x2server.start(done);\n            });\n\n            afterEach(function(done) {\n                x2server.stop(done);\n            });\n\n            it('should login with xoauth2 string', function(done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            accessToken: testtoken\n                        })\n                    },\n                    function(err) {\n                        expect(err).to.not.exist;\n                        expect(client.authenticated).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for invalid xoauth2 string token', function(done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            accessToken: 'invalid'\n                        })\n                    },\n                    function(err) {\n                        expect(err).to.exist;\n                        expect(client.authenticated).to.be.false;\n                        expect(err.code).to.equal('EAUTH');\n                        done();\n                    }\n                );\n            });\n\n            it('should login with xoauth2 object', function(done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            clientId: '{Client ID}',\n                            clientSecret: '{Client Secret}',\n                            refreshToken: 'refresh-token',\n                            accessToken: 'uuuuu',\n                            accessUrl: 'http://localhost:' + XOAUTH_PORT\n                        })\n                    },\n                    function(err) {\n                        expect(err).to.not.exist;\n                        expect(client.authenticated).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should fail with xoauth2 object', function(done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            clientId: '{Client ID}',\n                            clientSecret: '{Client Secret}',\n                            refreshToken: 'refrsesh-token',\n                            accessToken: 'uuuuu',\n                            accessUrl: 'http://localhost:' + XOAUTH_PORT\n                        })\n                    },\n                    function(err) {\n                        expect(err).to.exist;\n                        expect(client.authenticated).to.be.false;\n                        done();\n                    }\n                );\n            });\n\n            it('should fail with invalid xoauth2 response', function(done) {\n                expect(client.authenticated).to.be.false;\n\n                let oauth2 = new XOAuth2({\n                    user: 'testuser',\n                    clientId: '{Client ID}',\n                    clientSecret: '{Client Secret}',\n                    refreshToken: 'refrsesh-token',\n                    accessToken: 'uuuuu',\n                    accessUrl: 'http://localhost:' + XOAUTH_PORT\n                });\n\n                sinon.stub(oauth2, 'generateToken').yields(null, 'dXNlcj10ZXN0dXNlcgFhdXRoPUJlYXJlciB1dXV1dQEB');\n\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2\n                    },\n                    function(err) {\n                        expect(err).to.exist;\n                        expect(client.authenticated).to.be.false;\n\n                        oauth2.generateToken.restore();\n                        done();\n                    }\n                );\n            });\n        });\n\n        describe('custom login', function() {\n            let customClient;\n            beforeEach(function(done) {\n                customClient = new SMTPConnection({\n                    port: PORT_NUMBER,\n                    logger: false,\n                    debug: false,\n                    customAuth: {\n                        mytest: client => {\n                            client.sendCommand('HALLO1 HALLO', (err, response) => {\n                                expect(err).to.not.exist;\n                                expect(response.status).to.equal(500);\n                                client.sendCommand('HALLO2 HALLO', (err, response) => {\n                                    expect(err).to.not.exist;\n                                    expect(response.status).to.equal(500);\n                                    client.resolve();\n                                });\n                            });\n                        }\n                    }\n                });\n\n                customClient.connect(done);\n            });\n\n            afterEach(function(done) {\n                customClient.close();\n                done();\n            });\n\n            it('should login', function(done) {\n                expect(customClient.authenticated).to.be.false;\n                customClient.login(\n                    {\n                        method: 'mytest',\n                        user: 'testuser',\n                        credentials: {\n                            user: 'testuser',\n                            pass: 'testpass'\n                        }\n                    },\n                    function(err) {\n                        expect(err).to.not.exist;\n                        expect(customClient.authenticated).to.be.true;\n                        done();\n                    }\n                );\n            });\n        });\n\n        describe('Send without PIPELINING', function() {\n            beforeEach(function(done) {\n                client.on('end', function() {\n                    client = new SMTPConnection({\n                        port: PORT_NUMBER,\n                        logger: false,\n                        debug: false\n                    });\n                    // disable PIPELINING\n                    server.options.hidePIPELINING = true;\n                    client.connect(function() {\n                        client.login(\n                            {\n                                user: 'testuser',\n                                credentials: {\n                                    user: 'testuser',\n                                    pass: 'testpass'\n                                }\n                            },\n                            function(err) {\n                                expect(err).to.not.exist;\n                                // enable PIPELINING\n                                server.options.hidePIPELINING = false;\n                                done();\n                            }\n                        );\n                    });\n                });\n                client.close();\n            });\n\n            it('should send only to valid recipients without PIPELINING', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3@valid.recipient']\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        expect(info.rejectedErrors.length).to.equal(1);\n                        done();\n                    }\n                );\n            });\n        });\n\n        describe('Send messages', function() {\n            beforeEach(function(done) {\n                client.login(\n                    {\n                        user: 'testuser',\n                        credentials: {\n                            user: 'testuser',\n                            pass: 'testpass'\n                        }\n                    },\n                    function(err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test@valid.recipient'],\n                            rejected: [],\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('should send multiple messages', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test@valid.recipient'],\n                            rejected: [],\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        client.reset(function(err) {\n                            expect(err).to.not.exist;\n\n                            client.send(\n                                {\n                                    from: 'test2@valid.sender',\n                                    to: 'test2@valid.recipient'\n                                },\n                                'test2',\n                                function(err, info) {\n                                    expect(err).to.not.exist;\n                                    expect(info).to.deep.equal({\n                                        accepted: ['test2@valid.recipient'],\n                                        rejected: [],\n                                        envelopeTime: info.envelopeTime,\n                                        messageTime: info.messageTime,\n                                        messageSize: info.messageSize,\n                                        response: '250 OK: message queued'\n                                    });\n                                    done();\n                                }\n                            );\n                        });\n                    }\n                );\n            });\n\n            it('should send only to valid recipients', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3@valid.recipient']\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        expect(info.rejectedErrors.length).to.equal(1);\n                        done();\n                    }\n                );\n            });\n\n            it('should reject all recipients', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@invalid.recipient', 'test2@invalid.recipient', 'test3@invalid.recipient']\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.exist;\n                        expect(info).to.not.exist;\n                        expect(err.rejected).to.deep.equal(['test1@invalid.recipient', 'test2@invalid.recipient', 'test3@invalid.recipient']);\n                        expect(err.rejectedErrors.length).to.equal(3);\n                        done();\n                    }\n                );\n            });\n\n            it('should reject too large SIZE arguments', function(done) {\n                client.send(\n                    {\n                        from: 'test2@valid.sender',\n                        to: 'test2@valid.recipient',\n                        size: 1024 * 1024\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.exist;\n                        expect(info).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should reject too large message', function(done) {\n                client.send(\n                    {\n                        from: 'test2@valid.sender',\n                        to: 'test2@valid.recipient',\n                        size: 70 * 1024\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.exist;\n                        expect(info).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should declare SIZE', function(done) {\n                client.send(\n                    {\n                        from: 'test2@valid.sender',\n                        to: 'test2@valid.recipient',\n                        size: 10 * 1024\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test2@valid.recipient'],\n                            rejected: [],\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('lmtp should send only to valid recipients', function(done) {\n                lmtpClient.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: [\n                            'test1@valid.recipient',\n                            'test2@invalid.recipient',\n                            'test3@valid.recipient',\n                            'test4@valid.recipient',\n                            'test5@valid.recipient',\n                            'test6@valid.recipient'\n                        ]\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info.accepted).to.deep.equal(['test3@valid.recipient', 'test5@valid.recipient']);\n                        expect(info.rejected).to.deep.equal([\n                            'test2@invalid.recipient',\n                            'test1@valid.recipient',\n                            'test4@valid.recipient',\n                            'test6@valid.recipient'\n                        ]);\n                        expect(info.rejectedErrors.length).to.equal(info.rejected.length);\n                        done();\n                    }\n                );\n            });\n\n            it('should send using SMTPUTF8', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3\u00f5@valid.recipient']\n                    },\n                    'test',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3\u00f5@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('should send using 8BITMIME', function(done) {\n                client.send(\n                    {\n                        use8BitMime: true,\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3\u00f5@valid.recipient']\n                    },\n                    '\u00f5\u00f5\u00f5\u00f5',\n                    function(err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3\u00f5@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('should receive error for 8-bit content without 8BITMIME declaration', function(done) {\n                client.send(\n                    {\n                        use8BitMime: false,\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3\u00f5@valid.recipient']\n                    },\n                    '\u00f5\u00f5\u00f5\u00f5',\n                    function(err) {\n                        expect(/8 bit content not allowed/.test(err.message)).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for invalidly formatted recipients', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test@valid.recipient', '\"address\\r\\n with folding\"@valid.recipient']\n                    },\n                    'test',\n                    function(err) {\n                        expect(/^Invalid recipient/.test(err.message)).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for no valid recipients', function(done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@invalid.recipient', 'test2@invalid.recipient', 'test3@invalid.recipient']\n                    },\n                    'test',\n                    function(err) {\n                        expect(err).to.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for invalid sender', function(done) {\n                client.send(\n                    {\n                        from: 'test@invalid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'test',\n                    function(err) {\n                        expect(err).to.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message string', function(done) {\n                let chunks = [],\n                    message = new Array(1024).join('teretere, vana kere\\n');\n\n                server.on('data', function(connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function(connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message,\n                    function(err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message buffer', function(done) {\n                let chunks = [],\n                    message = Buffer.from(new Array(1024).join('teretere, vana kere\\n'));\n\n                server.on('data', function(connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function(connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(\n                        message\n                            .toString()\n                            .trim()\n                            .replace(/\\n/g, '\\r\\n')\n                    );\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message,\n                    function(err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message stream', function(done) {\n                let chunks = [],\n                    fname = __dirname + '/../../LICENSE',\n                    message = fs.readFileSync(fname, 'utf-8');\n\n                server.on('data', function(connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function(connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(\n                        message\n                            .toString()\n                            .trim()\n                            .replace(/\\n/g, '\\r\\n')\n                    );\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    fs.createReadStream(fname),\n                    function(err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n        });\n    });\n});\n\nfunction proxyConnect(port, host, destinationPort, destinationHost, callback) {\n    let socket = net.connect(port, host, function() {\n        socket.write('CONNECT ' + destinationHost + ':' + destinationPort + ' HTTP/1.1\\r\\n\\r\\n');\n\n        let headers = '';\n        let onSocketData = function(chunk) {\n            let match;\n            let remainder;\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n                // proxy connection is now established\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.on('error', function(err) {\n        expect(err).to.not.exist;\n    });\n}\n", "'use strict';\n\nconst http = require('http');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\n\nmodule.exports = function(options) {\n    return new OAuthServer(options);\n};\n\nfunction OAuthServer(options) {\n    this.options = options || {};\n    this.users = {};\n    this.tokens = {};\n\n    this.options.port = Number(this.options.port) || 3080;\n    this.options.expiresIn = Number(this.options.expiresIn) || 3600;\n}\n\nOAuthServer.prototype.addUser = function(username, refreshToken) {\n    let user = {\n        username,\n        refreshToken: refreshToken || crypto.randomBytes(10).toString('base64')\n    };\n\n    this.users[username] = user;\n    this.tokens[user.refreshToken] = username;\n\n    return this.generateAccessToken(user.refreshToken);\n};\n\nOAuthServer.prototype.generateAccessToken = function(refreshToken) {\n    let username = this.tokens[refreshToken],\n        accessToken = crypto.randomBytes(10).toString('base64');\n\n    if (!username) {\n        return {\n            error: 'Invalid refresh token'\n        };\n    }\n\n    this.users[username].accessToken = accessToken;\n    this.users[username].expiresIn = Date.now + this.options.expiresIn * 1000;\n\n    if (this.options.onUpdate) {\n        this.options.onUpdate(username, accessToken);\n    }\n\n    return {\n        access_token: accessToken,\n        expires_in: this.options.expiresIn,\n        token_type: 'Bearer'\n    };\n};\n\nOAuthServer.prototype.validateAccessToken = function(username, accessToken) {\n    if (!this.users[username] || this.users[username].accessToken !== accessToken || this.users[username].expiresIn < Date.now()) {\n        return false;\n    } else {\n        return true;\n    }\n};\n\nOAuthServer.prototype.start = function(callback) {\n    this.server = http.createServer((req, res) => {\n        let data = [],\n            datalen = 0;\n        req.on('data', chunk => {\n            if (!chunk || !chunk.length) {\n                return;\n            }\n\n            data.push(chunk);\n            datalen += chunk.length;\n        });\n        req.on('end', () => {\n            let query = querystring.parse(Buffer.concat(data, datalen).toString()),\n                response = this.generateAccessToken(query.refresh_token);\n\n            res.writeHead(!response.error ? 200 : 401, {\n                'Content-Type': 'application/json'\n            });\n\n            res.end(JSON.stringify(response));\n        });\n    });\n\n    this.server.listen(this.options.port, callback);\n};\n\nOAuthServer.prototype.stop = function(callback) {\n    this.server.close(callback);\n};\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, afterEach, describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst net = require('net');\nconst chai = require('chai');\nconst expect = chai.expect;\nconst SMTPPool = require('../../lib/smtp-pool');\nconst SMTPServer = require('smtp-server').SMTPServer;\nconst PassThrough = require('stream').PassThrough;\nchai.config.includeStack = true;\n\nconst PORT_NUMBER = 8397;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('SMTP Pool Tests', function() {\n    this.timeout(100 * 1000); //eslint-disable-line no-invalid-this\n\n    let server;\n\n    beforeEach(function(done) {\n        server = new SMTPServer({\n            authMethods: ['PLAIN', 'XOAUTH2'],\n            disabledCommands: ['STARTTLS'],\n\n            onData(stream, session, callback) {\n                stream.on('data', function() {});\n                stream.on('end', callback);\n            },\n\n            onAuth(auth, session, callback) {\n                if (auth.method !== 'XOAUTH2') {\n                    if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                        return callback(new Error('Invalid username or password'));\n                    }\n                } else if (auth.username !== 'testuser' || auth.accessToken !== 'testtoken') {\n                    return callback(null, {\n                        data: {\n                            status: '401',\n                            schemes: 'bearer mac',\n                            scope: 'my_smtp_access_scope_name'\n                        }\n                    });\n                }\n                callback(null, {\n                    user: 123\n                });\n            },\n            onMailFrom(address, session, callback) {\n                if (!/@valid.sender/.test(address.address)) {\n                    return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                }\n                return callback(); // Accept the address\n            },\n            onRcptTo(address, session, callback) {\n                if (!/@valid.recipient/.test(address.address)) {\n                    return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                }\n\n                if (!/timeout/.test(address.address)) {\n                    return callback(); // Accept the address\n                }\n            },\n            logger: false\n        });\n\n        server.listen(PORT_NUMBER, done);\n    });\n\n    afterEach(function(done) {\n        server.close(done);\n    });\n\n    it('Should expose version number', function() {\n        let pool = new SMTPPool();\n        expect(pool.name).to.exist;\n        expect(pool.version).to.exist;\n    });\n\n    it('Should detect wellknown data', function() {\n        let pool = new SMTPPool({\n            service: 'google mail'\n        });\n        expect(pool.options.host).to.equal('smtp.gmail.com');\n        expect(pool.options.port).to.equal(465);\n        expect(pool.options.secure).to.be.true;\n    });\n\n    it('should send mail', function(done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false,\n            debug: true\n        });\n\n        let message = new Array(1024).join('teretere, vana kere\\n');\n\n        server.onData = function(stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function(chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function() {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function(err) {\n                expect(err).to.not.exist;\n                pool.close();\n                done();\n            }\n        );\n    });\n\n    it('should send multiple mails', function(done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function(stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function(chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function() {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function() {\n            let sent = 0;\n\n            if (++returned === total) {\n                expect(pool._connections.length).to.be.above(1);\n                pool._connections.forEach(function(conn) {\n                    expect(conn.messages).to.be.above(1);\n                    sent += conn.messages;\n                });\n\n                expect(sent).to.be.equal(total);\n\n                pool.close();\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n    });\n\n    it('should tolerate connection errors', function(done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false\n        });\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function(stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function(chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function() {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        let c = 0;\n\n        function sendMessage(callback) {\n            let isErr = c++ % 2; // fail 50% of messages\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: isErr ? 'test@invalid.sender' : 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    if (isErr) {\n                        expect(err).to.exist;\n                    } else {\n                        expect(err).to.not.exist;\n                    }\n\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function() {\n            if (++returned === total) {\n                pool.close();\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n    });\n\n    it('should tolerate idle connections and re-assign messages to other connections', function(done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false\n        });\n\n        let total = 20;\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n        let sentMessages = 0;\n        let killedConnections = false;\n\n        server.onData = function(stream, session, callback) {\n            let callCallback = true;\n\n            stream.on('data', function() {\n                // If we hit half the messages, simulate the server closing connections\n                // that are open for long time\n                if (!killedConnections && sentMessages === total / 2) {\n                    killedConnections = true;\n                    callCallback = false;\n                    server.connections.forEach(function(connection) {\n                        connection._socket.end();\n                    });\n                }\n            });\n\n            stream.on('end', function() {\n                if (callCallback) {\n                    sentMessages += 1;\n                    return callback();\n                }\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    if (err) {\n                        expect(err.message).to.equal('Connection closed unexpectedly');\n                    }\n                    callback();\n                }\n            );\n        }\n\n        // Send 10 messages in a row.. then wait a bit and send 10 more\n        // When we wait a bit.. the server will kill the \"idle\" connections\n        // so that we can ensure the pool will handle it properly\n        let returned = 0;\n        let cb = function() {\n            returned++;\n\n            if (returned === total) {\n                pool.close();\n                return done();\n            } else if (returned === total / 2) {\n                setTimeout(sendHalfBulk, 1500);\n            }\n        };\n\n        function sendHalfBulk() {\n            for (let i = 0; i < total / 2; i++) {\n                sendMessage(cb);\n            }\n        }\n\n        sendHalfBulk();\n    });\n\n    it('should call back with connection errors to senders having messages in flight', function(done) {\n        let pool = new SMTPPool({\n            maxConnections: 1,\n            socketTimeout: 200,\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false\n        });\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function(err) {\n                expect(err).not.to.exist;\n            }\n        );\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test+timeout@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function(err) {\n                expect(err).to.exist;\n                pool.close();\n                done();\n            }\n        );\n    });\n\n    it('should not send more then allowed for one connection', function(done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?maxConnections=1&maxMessages=5&logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function(stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function(chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function() {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function() {\n            if (++returned === total) {\n                expect(pool._connections.length).to.be.equal(1);\n                expect(pool._connections[0].messages).to.be.below(6);\n                pool.close();\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n    });\n\n    it('should send multiple mails with rate limit', function(done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            maxConnections: 10,\n            rateLimit: 200, // 200 messages in sec, so sending 5000 messages should take at least 24 seconds and probably under 25 sec\n            logger: false\n        });\n        let message = 'teretere, vana kere\\n';\n        let startTime = Date.now();\n\n        server.onData = function(stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function(chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function() {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 5000;\n        let returned = 0;\n        let cb = function() {\n            if (++returned === total) {\n                let endTime = Date.now();\n                expect(endTime - startTime).to.be.at.least(24000);\n\n                pool.close();\n                return done();\n            }\n        };\n\n        let i = 0;\n        let send = function() {\n            if (i++ >= total) {\n                return;\n            }\n            sendMessage(cb);\n            setImmediate(send);\n        };\n\n        send();\n    });\n\n    it('should return pending messages once closed', function(done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?maxConnections=1&logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function(stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function(chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function() {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function() {\n            if (++returned === total) {\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n        pool.close();\n    });\n\n    it('should emit idle for free slots in the pool', function(done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function(stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function(chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function() {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                callback\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function() {\n            if (++returned === total) {\n                pool.close();\n                return done();\n            }\n        };\n\n        let i = 0;\n        pool.on('idle', function() {\n            setTimeout(function() {\n                while (i < total && pool.isIdle()) {\n                    i++;\n                    sendMessage(cb);\n                }\n                if (i > 50) {\n                    // kill all connections. We should still end up with the same amount of callbacks\n                    setImmediate(function() {\n                        for (let j = 5 - 1; j >= 0; j--) {\n                            if (pool._connections[j] && pool._connections[j].connection) {\n                                pool._connections[j].connection._socket.emit('error', new Error('TESTERROR'));\n                            }\n                        }\n                    });\n                }\n            }, 1000);\n        });\n    });\n\n    it('Should login and send mail using proxied socket', function(done) {\n        let pool = new SMTPPool({\n            url: 'smtp:testuser:testpass@www.example.com:1234',\n            logger: false,\n            getSocket(options, callback) {\n                let socket = net.connect(PORT_NUMBER, 'localhost');\n                let errHandler = function(err) {\n                    callback(err);\n                };\n                socket.on('error', errHandler);\n                socket.on('connect', function() {\n                    socket.removeListener('error', errHandler);\n                    callback(null, {\n                        connection: socket\n                    });\n                });\n            }\n        });\n        let chunks = [],\n            message = new Array(1024).join('teretere, vana kere\\n');\n\n        server.on('data', function(connection, chunk) {\n            chunks.push(chunk);\n        });\n\n        server.on('dataReady', function(connection, callback) {\n            let body = Buffer.concat(chunks);\n            expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n            callback(null, true);\n        });\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function(err) {\n                expect(err).to.not.exist;\n                pool.close();\n                return done();\n            }\n        );\n    });\n\n    it('Should verify connection with success', function(done) {\n        let client = new SMTPPool({\n            url: 'smtp:testuser:testpass@localhost:' + PORT_NUMBER,\n            logger: false\n        });\n\n        client.verify(function(err, success) {\n            expect(err).to.not.exist;\n            expect(success).to.be.true;\n            client.close();\n            done();\n        });\n    });\n\n    it('Should not verify connection', function(done) {\n        let client = new SMTPPool({\n            url: 'smtp:testuser:testpass@localhost:999' + PORT_NUMBER,\n            logger: false\n        });\n\n        client.verify(function(err) {\n            expect(err).to.exist;\n            client.close();\n            done();\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, afterEach, describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst chai = require('chai');\nconst net = require('net');\nconst expect = chai.expect;\nconst PassThrough = require('stream').PassThrough;\nconst SMTPTransport = require('../../lib/smtp-transport');\nconst SMTPServer = require('smtp-server').SMTPServer;\nchai.config.includeStack = true;\n\nconst PORT_NUMBER = 8397;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('SMTP Transport Tests', function() {\n    this.timeout(10000); // eslint-disable-line no-invalid-this\n\n    describe('Anonymous sender tests', function() {\n        let server, failingServer;\n\n        beforeEach(function(done) {\n            server = new SMTPServer({\n                disabledCommands: ['STARTTLS', 'AUTH'],\n\n                onData(stream, session, callback) {\n                    stream.on('data', function() {});\n                    stream.on('end', callback);\n                },\n\n                onMailFrom(address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n\n                onRcptTo(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            failingServer = new SMTPServer({\n                disabledCommands: ['STARTTLS', 'AUTH'],\n\n                onData(stream) {\n                    stream.on('data', () => false);\n                    stream.on('end', () => {\n                        setTimeout(() => {\n                            this.connections.forEach(socket => socket._socket.destroy());\n                        }, 150);\n                    });\n                },\n\n                onMailFrom(address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n\n                onRcptTo(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            server.listen(PORT_NUMBER, err => {\n                if (err) {\n                    return done(err);\n                }\n                failingServer.listen(PORT_NUMBER + 1, done);\n            });\n        });\n\n        afterEach(function(done) {\n            server.close(() => failingServer.close(done));\n        });\n\n        it('Should expose version number', function() {\n            let client = new SMTPTransport();\n            expect(client.name).to.exist;\n            expect(client.version).to.exist;\n        });\n\n        it('Should detect wellknown data', function() {\n            let client = new SMTPTransport({\n                service: 'google mail',\n                logger: false\n            });\n            expect(client.options.host).to.equal('smtp.gmail.com');\n            expect(client.options.port).to.equal(465);\n            expect(client.options.secure).to.be.true;\n        });\n\n        it('Should fail envelope', function(done) {\n            let client = new SMTPTransport({\n                port: PORT_NUMBER,\n                logger: false\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@invalid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        'test'\n                    )\n                },\n                function(err) {\n                    expect(err.code).to.equal('EENVELOPE');\n                    done();\n                }\n            );\n        });\n\n        it('Should not fail auth', function(done) {\n            let client = new SMTPTransport({\n                port: PORT_NUMBER,\n                auth: {\n                    user: 'zzz'\n                },\n                logger: false\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        'message'\n                    )\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n\n        it('Should fail auth if forceAuth=true', function(done) {\n            let client = new SMTPTransport({\n                port: PORT_NUMBER,\n                auth: {\n                    user: 'zzz'\n                },\n                forceAuth: true,\n                logger: false\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        'message'\n                    )\n                },\n                function(err) {\n                    expect(err.code).to.equal('EAUTH');\n                    done();\n                }\n            );\n        });\n\n        it('Should send mail', function(done) {\n            let client = new SMTPTransport('smtp:localhost:' + PORT_NUMBER + '?logger=false');\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function(connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function(connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n\n        it('Should recover unexpeced close during transmission', function(done) {\n            let client = new SMTPTransport('smtp:localhost:' + (PORT_NUMBER + 1) + '?logger=false');\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function(connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function(connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.exist;\n                    done();\n                }\n            );\n        });\n    });\n\n    describe('Authenticated sender tests', function() {\n        let server;\n\n        beforeEach(function(done) {\n            server = new SMTPServer({\n                authMethods: ['PLAIN', 'XOAUTH2'],\n                disabledCommands: ['STARTTLS'],\n\n                onData(stream, session, callback) {\n                    stream.on('data', function() {});\n                    stream.on('end', callback);\n                },\n\n                onAuth(auth, session, callback) {\n                    if (auth.method !== 'XOAUTH2') {\n                        if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                            return callback(new Error('Invalid username or password'));\n                        }\n                    } else if (auth.username !== 'testuser' || auth.accessToken !== 'testtoken') {\n                        return callback(null, {\n                            data: {\n                                status: '401',\n                                schemes: 'bearer mac',\n                                scope: 'my_smtp_access_scope_name'\n                            }\n                        });\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onMailFrom(address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                onRcptTo(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            server.listen(PORT_NUMBER, done);\n        });\n\n        afterEach(function(done) {\n            server.close(done);\n        });\n\n        it('Should login and send mail', function(done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@localhost:' + PORT_NUMBER,\n                logger: false\n            });\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function(connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function(connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n\n        it('Should verify connection with success', function(done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@localhost:' + PORT_NUMBER,\n                logger: false\n            });\n\n            client.verify(function(err, success) {\n                expect(err).to.not.exist;\n                expect(success).to.be.true;\n                done();\n            });\n        });\n\n        it('Should not verify connection', function(done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@localhost:999' + PORT_NUMBER,\n                logger: false\n            });\n\n            client.verify(function(err) {\n                expect(err).to.exist;\n                done();\n            });\n        });\n\n        it('Should login and send mail using proxied socket', function(done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@www.example.com:1234',\n                logger: false,\n                getSocket(options, callback) {\n                    let socket = net.connect(PORT_NUMBER, 'localhost');\n                    let errHandler = function(err) {\n                        callback(err);\n                    };\n                    socket.on('error', errHandler);\n                    socket.on('connect', function() {\n                        socket.removeListener('error', errHandler);\n                        callback(null, {\n                            connection: socket\n                        });\n                    });\n                }\n            });\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function(connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function(connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst PassThrough = require('stream').PassThrough;\nconst StreamTransport = require('../../lib/stream-transport');\nchai.config.includeStack = true;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('Stream Transport Tests', function() {\n    this.timeout(10000); // eslint-disable-line no-invalid-this\n\n    it('Should expose version number', function() {\n        let client = new StreamTransport();\n        expect(client.name).to.exist;\n        expect(client.version).to.exist;\n    });\n\n    describe('Send as stream', function() {\n        it('Should send mail using unix newlines', function(done) {\n            let client = new StreamTransport();\n            let chunks = [],\n                message = new Array(100).join('teretere\\r\\nvana kere\\r\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err, info) {\n                    expect(err).to.not.exist;\n\n                    expect(info.envelope).to.deep.equal({\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    });\n\n                    expect(info.messageId).to.equal('<test>');\n\n                    info.message.on('data', function(chunk) {\n                        chunks.push(chunk);\n                    });\n\n                    info.message.on('end', function() {\n                        let body = Buffer.concat(chunks);\n                        expect(body.toString()).to.equal(message.replace(/\\r\\n/g, '\\n'));\n                        done();\n                    });\n                }\n            );\n        });\n\n        it('Should send mail using windows newlines', function(done) {\n            let client = new StreamTransport({\n                newline: 'windows'\n            });\n            let chunks = [],\n                message = new Array(100).join('teretere\\nvana kere\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err, info) {\n                    expect(err).to.not.exist;\n\n                    info.message.on('data', function(chunk) {\n                        chunks.push(chunk);\n                    });\n\n                    info.message.on('end', function() {\n                        let body = Buffer.concat(chunks);\n                        expect(body.toString()).to.equal(message.replace(/\\n/g, '\\r\\n'));\n                        done();\n                    });\n                }\n            );\n        });\n    });\n\n    describe('Send as buffer', function() {\n        it('Should send mail using unix newlines', function(done) {\n            let client = new StreamTransport({\n                buffer: true\n            });\n            let message = new Array(100).join('teretere\\r\\nvana kere\\r\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err, info) {\n                    expect(err).to.not.exist;\n\n                    expect(info.message.toString()).to.equal(message.replace(/\\r\\n/g, '\\n'));\n                    done();\n                }\n            );\n        });\n\n        it('Should send mail using windows newlines', function(done) {\n            let client = new StreamTransport({\n                newline: 'windows',\n                buffer: true\n            });\n            let message = new Array(100).join('teretere\\nvana kere\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function(err, info) {\n                    expect(err).to.not.exist;\n\n                    expect(info.message.toString()).to.equal(message.replace(/\\n/g, '\\r\\n'));\n                    done();\n                }\n            );\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst wellKnown = require('../../lib/well-known');\n\nchai.config.includeStack = true;\n\ndescribe('Well-Known Services Tests', function() {\n    describe('#wellKnown', function() {\n        it('Should find by key', function() {\n            expect(wellKnown('Gmail')).to.deep.equal({\n                host: 'smtp.gmail.com',\n                port: 465,\n                secure: true\n            });\n        });\n\n        it('Should find by alias', function() {\n            expect(wellKnown('Google Mail')).to.deep.equal({\n                host: 'smtp.gmail.com',\n                port: 465,\n                secure: true\n            });\n        });\n\n        it('Should find by domain', function() {\n            expect(wellKnown('GoogleMail.com')).to.deep.equal({\n                host: 'smtp.gmail.com',\n                port: 465,\n                secure: true\n            });\n        });\n\n        it('Should find no match', function() {\n            expect(wellKnown('zzzzzz')).to.be.false;\n        });\n    });\n});\n", "'use strict';\n\n// Mock server for serving Oauth2 tokens\n\nconst http = require('http');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\n\nmodule.exports = function(options) {\n    return new OAuthServer(options);\n};\n\nfunction OAuthServer(options) {\n    this.options = options || {};\n    this.users = {};\n    this.tokens = {};\n\n    this.options.port = Number(this.options.port) || 3080;\n    this.options.expiresIn = Number(this.options.expiresIn) || 3600;\n}\n\nOAuthServer.prototype.addUser = function(username, refreshToken) {\n    let user = {\n        username,\n        refreshToken: refreshToken || crypto.randomBytes(10).toString('base64')\n    };\n\n    this.users[username] = user;\n    this.tokens[user.refreshToken] = username;\n\n    return this.generateAccessToken(user.refreshToken);\n};\n\nOAuthServer.prototype.generateAccessToken = function(refreshToken) {\n    let username = this.tokens[refreshToken];\n    let accessToken = crypto.randomBytes(10).toString('base64');\n\n    if (!username) {\n        return {\n            error: 'Invalid refresh token'\n        };\n    }\n\n    this.users[username].accessToken = accessToken;\n    this.users[username].expiresIn = Date.now + this.options.expiresIn * 1000;\n\n    if (this.options.onUpdate) {\n        this.options.onUpdate(username, accessToken);\n    }\n\n    return {\n        access_token: accessToken,\n        expires_in: this.options.expiresIn,\n        token_type: 'Bearer'\n    };\n};\n\nOAuthServer.prototype.validateAccessToken = function(username, accessToken) {\n    if (!this.users[username] || this.users[username].accessToken !== accessToken || this.users[username].expiresIn < Date.now()) {\n        return false;\n    } else {\n        return true;\n    }\n};\n\nOAuthServer.prototype.start = function(callback) {\n    this.server = http.createServer((req, res) => {\n        let data = [];\n        let datalen = 0;\n\n        req.on('data', chunk => {\n            if (!chunk || !chunk.length) {\n                return;\n            }\n\n            data.push(chunk);\n            datalen += chunk.length;\n        });\n\n        req.once('end', () => {\n            let query = querystring.parse(Buffer.concat(data, datalen).toString()),\n                response = this.generateAccessToken(query.refresh_token);\n\n            res.writeHead(!response.error ? 200 : 401, {\n                'Content-Type': 'application/json'\n            });\n\n            res.end(JSON.stringify(response));\n        });\n    });\n\n    this.server.listen(this.options.port, callback);\n};\n\nOAuthServer.prototype.stop = function(callback) {\n    this.server.close(callback);\n};\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, prefer-arrow-callback: 0, object-shorthand: 0 */\n/* globals afterEach, beforeEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst XOAuth2 = require('../../lib/xoauth2');\nconst mockServer = require('./server');\n\nchai.config.includeStack = true;\n\ndescribe('XOAuth2 tests', function() {\n    this.timeout(10000);\n\n    let server;\n    let users = {};\n    let XOAUTH_PORT = 8993;\n\n    beforeEach(function(done) {\n        server = mockServer({\n            port: XOAUTH_PORT,\n            onUpdate: function(username, accessToken) {\n                users[username] = accessToken;\n            }\n        });\n        server.addUser('test@example.com', 'saladus');\n        server.start(done);\n    });\n\n    afterEach(function(done) {\n        server.stop(done);\n    });\n\n    it('should get an existing access token', function(done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            accessToken: 'abc',\n            timeout: 3600\n        });\n\n        xoauth2.getToken(false, function(err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal('abc');\n            done();\n        });\n    });\n\n    it('should convert access token to XOAuth2 token', function() {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            accessToken: 'abc'\n        });\n\n        expect(xoauth2.buildXOAuth2Token()).to.equal('dXNlcj10ZXN0QGV4YW1wbGUuY29tAWF1dGg9QmVhcmVyIGFiYwEB');\n        expect(xoauth2.buildXOAuth2Token('bbb')).to.equal('dXNlcj10ZXN0QGV4YW1wbGUuY29tAWF1dGg9QmVhcmVyIGJiYgEB');\n    });\n\n    it('should get an existing access token, no timeout', function(done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            accessToken: 'abc'\n        });\n\n        xoauth2.getToken(false, function(err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal('abc');\n            done();\n        });\n    });\n\n    it('should generate a fresh access token', function(done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600\n        });\n\n        xoauth2.getToken(false, function(err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal(users['test@example.com']);\n            done();\n        });\n    });\n\n    it('should generate a fresh access token with custom method', function(done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600,\n            provisionCallback: (user, renew, cb) => {\n                cb(null, 'zzz');\n            }\n        });\n\n        xoauth2.getToken(false, function(err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal('zzz');\n            done();\n        });\n    });\n\n    it('should fail generating a fresh access token with custom method', function(done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600,\n            provisionCallback: (user, renew, cb) => {\n                cb(new Error('fail'));\n            }\n        });\n\n        xoauth2.getToken(false, function(err, accessToken) {\n            expect(err).to.exist;\n            expect(accessToken).to.not.exist;\n            done();\n        });\n    });\n\n    it('should generate a fresh access token after timeout', function(done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            accessToken: 'abc',\n            timeout: 1\n        });\n\n        setTimeout(function() {\n            xoauth2.getToken(false, function(err, accessToken) {\n                expect(err).to.not.exist;\n                expect(accessToken).to.equal(users['test@example.com']);\n                done();\n            });\n        }, 3000);\n    });\n\n    it('should emit access token update', function(done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600\n        });\n\n        xoauth2.once('token', function(tokenData) {\n            expect(tokenData.expires).to.be.gte(Date.now() + 3000 * 1000);\n            expect(tokenData).to.deep.equal({\n                user: 'test@example.com',\n                accessToken: users['test@example.com'],\n                expires: tokenData.expires\n            });\n            done();\n        });\n\n        xoauth2.getToken(false, function() {});\n    });\n\n    it('should sign payload', function() {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            serviceClient: '{Client ID}',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600,\n            privateKey:\n                '-----BEGIN RSA PRIVATE KEY-----\\n' +\n                'MIIEpAIBAAKCAQEA6Z5Qqhw+oWfhtEiMHE32Ht94mwTBpAfjt3vPpX8M7DMCTwHs\\n' +\n                '1xcXvQ4lQ3rwreDTOWdoJeEEy7gMxXqH0jw0WfBx+8IIJU69xstOyT7FRFDvA1yT\\n' +\n                'RXY2yt9K5s6SKken/ebMfmZR+03ND4UFsDzkz0FfgcjrkXmrMF5Eh5UXX/+9YHeU\\n' +\n                'xlp0gMAt+/SumSmgCaysxZLjLpd4uXz+X+JVxsk1ACg1NoEO7lWJC/3WBP7MIcu2\\n' +\n                'wVsMd2XegLT0gWYfT1/jsIH64U/mS/SVXC9QhxMl9Yfko2kx1OiYhDxhHs75RJZh\\n' +\n                'rNRxgfiwgSb50Gw4NAQaDIxr/DJPdLhgnpY6UQIDAQABAoIBAE+tfzWFjJbgJ0ql\\n' +\n                's6Ozs020Sh4U8TZQuonJ4HhBbNbiTtdDgNObPK1uNadeNtgW5fOeIRdKN6iDjVeN\\n' +\n                'AuXhQrmqGDYVZ1HSGUfD74sTrZQvRlWPLWtzdhybK6Css41YAyPFo9k4bJ2ZW2b/\\n' +\n                'p4EEQ8WsNja9oBpttMU6YYUchGxo1gujN8hmfDdXUQx3k5Xwx4KA68dveJ8GasIt\\n' +\n                'd+0Jd/FVwCyyx8HTiF1FF8QZYQeAXxbXJgLBuCsMQJghlcpBEzWkscBR3Ap1U0Zi\\n' +\n                '4oat8wrPZGCblaA6rNkRUVbc/+Vw0stnuJ/BLHbPxyBs6w495yBSjBqUWZMvljNz\\n' +\n                'm9/aK0ECgYEA9oVIVAd0enjSVIyAZNbw11ElidzdtBkeIJdsxqhmXzeIFZbB39Gd\\n' +\n                'bjtAVclVbq5mLsI1j22ER2rHA4Ygkn6vlLghK3ZMPxZa57oJtmL3oP0RvOjE4zRV\\n' +\n                'dzKexNGo9gU/x9SQbuyOmuauvAYhXZxeLpv+lEfsZTqqrvPUGeBiEQcCgYEA8poG\\n' +\n                'WVnykWuTmCe0bMmvYDsWpAEiZnFLDaKcSbz3O7RMGbPy1cypmqSinIYUpURBT/WY\\n' +\n                'wVPAGtjkuTXtd1Cy58m7PqziB7NNWMcsMGj+lWrTPZ6hCHIBcAImKEPpd+Y9vGJX\\n' +\n                'oatFJguqAGOz7rigBq6iPfeQOCWpmprNAuah++cCgYB1gcybOT59TnA7mwlsh8Qf\\n' +\n                'bm+tSllnin2A3Y0dGJJLmsXEPKtHS7x2Gcot2h1d98V/TlWHe5WNEUmx1VJbYgXB\\n' +\n                'pw8wj2ACxl4ojNYqWPxegaLd4DpRbtW6Tqe9e47FTnU7hIggR6QmFAWAXI+09l8y\\n' +\n                'amssNShqjE9lu5YDi6BTKwKBgQCuIlKGViLfsKjrYSyHnajNWPxiUhIgGBf4PI0T\\n' +\n                '/Jg1ea/aDykxv0rKHnw9/5vYGIsM2st/kR7l5mMecg/2Qa145HsLfMptHo1ZOPWF\\n' +\n                '9gcuttPTegY6aqKPhGthIYX2MwSDMM+X0ri6m0q2JtqjclAjG7yG4CjbtGTt/UlE\\n' +\n                'WMlSZwKBgQDslGeLUnkW0bsV5EG3AKRUyPKz/6DVNuxaIRRhOeWVKV101claqXAT\\n' +\n                'wXOpdKrvkjZbT4AzcNrlGtRl3l7dEVXTu+dN7/ZieJRu7zaStlAQZkIyP9O3DdQ3\\n' +\n                'rIcetQpfrJ1cAqz6Ng0pD0mh77vQ13WG1BBmDFa2A9BuzLoBituf4g==\\n' +\n                '-----END RSA PRIVATE KEY-----'\n        });\n        expect(\n            xoauth2.jwtSignRS256({\n                some: 'payload'\n            })\n        ).to.equal(\n            'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzb21lIjoicGF5bG9hZCJ9.yBo28P5qE8t8yMkN0hC6uWstUAGh8RGW-zLe1NHdtit8ZVlAEdnhXbZvjGEfDWjOeWe1aZ2eZ65i83awWsx02G9HDsI1xMOFTHpviSHLIWnOf1D2hqJxm0On9zYRjd6oFxuRlmJtI9PIDlMJltG7K3leqReLLC6ZOAYL1Au0WY5swdG2eA6Oi83BTEckLj9c-0TYYRYtyRSG9o298Iuc8JL2KhrAbM8d62JgAPuI3hN_NgEtxs36bidt3SHbuWSszAdt1lHR-bFCZ-kXy_DAGlGiYRHRNyvsLR_q_v4GhV2oVi3WSPR816UhHrTryA0NlbanACb8T22bJGRQ708m_g'\n        );\n    });\n});\n"], "fixing_code": ["language: node_js\nsudo: false\nnode_js:\n    - 10\n    - 12\n    - 14\n    - 15\nnotifications:\n    email:\n        - andris@kreata.ee\n    webhooks:\n        urls:\n            - https://webhooks.gitter.im/e/0ed18fd9b3e529b3c2cc\n        on_success: change # options: [always|never|change] default: always\n        on_failure: always # options: [always|never|change] default: always\n        on_start: false # default: false\n", "'use strict';\n\nmodule.exports = function (grunt) {\n    // Project configuration.\n    grunt.initConfig({\n        eslint: {\n            all: ['index.js', 'lib/**/*.js', 'test/**/*.js', 'examples/**/*.js', 'Gruntfile.js']\n        },\n\n        mochaTest: {\n            all: {\n                options: {\n                    reporter: 'spec'\n                },\n                src: ['test/**/*-test.js']\n            }\n        }\n    });\n\n    // Load the plugin(s)\n    grunt.loadNpmTasks('grunt-eslint');\n    grunt.loadNpmTasks('grunt-mocha-test');\n\n    // Tasks\n    grunt.registerTask('default', ['eslint', 'mochaTest']);\n};\n", "'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n", "'use strict';\n\n// module to handle cookies\n\nconst urllib = require('url');\n\nconst SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nclass Cookies {\n    constructor(options) {\n        this.options = options || {};\n        this.cookies = [];\n    }\n\n    /**\n     * Stores a cookie string to the cookie storage\n     *\n     * @param {String} cookieStr Value from the 'Set-Cookie:' header\n     * @param {String} url Current URL\n     */\n    set(cookieStr, url) {\n        let urlparts = urllib.parse(url || '');\n        let cookie = this.parse(cookieStr);\n        let domain;\n\n        if (cookie.domain) {\n            domain = cookie.domain.replace(/^\\./, '');\n\n            // do not allow cross origin cookies\n            if (\n                // can't be valid if the requested domain is shorter than current hostname\n                urlparts.hostname.length < domain.length ||\n                // prefix domains with dot to be sure that partial matches are not used\n                ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain\n            ) {\n                cookie.domain = urlparts.hostname;\n            }\n        } else {\n            cookie.domain = urlparts.hostname;\n        }\n\n        if (!cookie.path) {\n            cookie.path = this.getPath(urlparts.pathname);\n        }\n\n        // if no expire date, then use sessionTimeout value\n        if (!cookie.expires) {\n            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n        }\n\n        return this.add(cookie);\n    }\n\n    /**\n     * Returns cookie string for the 'Cookie:' header.\n     *\n     * @param {String} url URL to check for\n     * @returns {String} Cookie header or empty string if no matches were found\n     */\n    get(url) {\n        return this.list(url)\n            .map(cookie => cookie.name + '=' + cookie.value)\n            .join('; ');\n    }\n\n    /**\n     * Lists all valied cookie objects for the specified URL\n     *\n     * @param {String} url URL to check for\n     * @returns {Array} An array of cookie objects\n     */\n    list(url) {\n        let result = [];\n        let i;\n        let cookie;\n\n        for (i = this.cookies.length - 1; i >= 0; i--) {\n            cookie = this.cookies[i];\n\n            if (this.isExpired(cookie)) {\n                this.cookies.splice(i, i);\n                continue;\n            }\n\n            if (this.match(cookie, url)) {\n                result.unshift(cookie);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Parses cookie string from the 'Set-Cookie:' header\n     *\n     * @param {String} cookieStr String from the 'Set-Cookie:' header\n     * @returns {Object} Cookie object\n     */\n    parse(cookieStr) {\n        let cookie = {};\n\n        (cookieStr || '')\n            .toString()\n            .split(';')\n            .forEach(cookiePart => {\n                let valueParts = cookiePart.split('=');\n                let key = valueParts.shift().trim().toLowerCase();\n                let value = valueParts.join('=').trim();\n                let domain;\n\n                if (!key) {\n                    // skip empty parts\n                    return;\n                }\n\n                switch (key) {\n                    case 'expires':\n                        value = new Date(value);\n                        // ignore date if can not parse it\n                        if (value.toString() !== 'Invalid Date') {\n                            cookie.expires = value;\n                        }\n                        break;\n\n                    case 'path':\n                        cookie.path = value;\n                        break;\n\n                    case 'domain':\n                        domain = value.toLowerCase();\n                        if (domain.length && domain.charAt(0) !== '.') {\n                            domain = '.' + domain; // ensure preceeding dot for user set domains\n                        }\n                        cookie.domain = domain;\n                        break;\n\n                    case 'max-age':\n                        cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n                        break;\n\n                    case 'secure':\n                        cookie.secure = true;\n                        break;\n\n                    case 'httponly':\n                        cookie.httponly = true;\n                        break;\n\n                    default:\n                        if (!cookie.name) {\n                            cookie.name = key;\n                            cookie.value = value;\n                        }\n                }\n            });\n\n        return cookie;\n    }\n\n    /**\n     * Checks if a cookie object is valid for a specified URL\n     *\n     * @param {Object} cookie Cookie object\n     * @param {String} url URL to check for\n     * @returns {Boolean} true if cookie is valid for specifiec URL\n     */\n    match(cookie, url) {\n        let urlparts = urllib.parse(url || '');\n\n        // check if hostname matches\n        // .foo.com also matches subdomains, foo.com does not\n        if (\n            urlparts.hostname !== cookie.domain &&\n            (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)\n        ) {\n            return false;\n        }\n\n        // check if path matches\n        let path = this.getPath(urlparts.pathname);\n        if (path.substr(0, cookie.path.length) !== cookie.path) {\n            return false;\n        }\n\n        // check secure argument\n        if (cookie.secure && urlparts.protocol !== 'https:') {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Adds (or updates/removes if needed) a cookie object to the cookie storage\n     *\n     * @param {Object} cookie Cookie value to be stored\n     */\n    add(cookie) {\n        let i;\n        let len;\n\n        // nothing to do here\n        if (!cookie || !cookie.name) {\n            return false;\n        }\n\n        // overwrite if has same params\n        for (i = 0, len = this.cookies.length; i < len; i++) {\n            if (this.compare(this.cookies[i], cookie)) {\n                // check if the cookie needs to be removed instead\n                if (this.isExpired(cookie)) {\n                    this.cookies.splice(i, 1); // remove expired/unset cookie\n                    return false;\n                }\n\n                this.cookies[i] = cookie;\n                return true;\n            }\n        }\n\n        // add as new if not already expired\n        if (!this.isExpired(cookie)) {\n            this.cookies.push(cookie);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if two cookie objects are the same\n     *\n     * @param {Object} a Cookie to check against\n     * @param {Object} b Cookie to check against\n     * @returns {Boolean} True, if the cookies are the same\n     */\n    compare(a, b) {\n        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n    }\n\n    /**\n     * Checks if a cookie is expired\n     *\n     * @param {Object} cookie Cookie object to check against\n     * @returns {Boolean} True, if the cookie is expired\n     */\n    isExpired(cookie) {\n        return (cookie.expires && cookie.expires < new Date()) || !cookie.value;\n    }\n\n    /**\n     * Returns normalized cookie path for an URL path argument\n     *\n     * @param {String} pathname\n     * @returns {String} Normalized path\n     */\n    getPath(pathname) {\n        let path = (pathname || '/').split('/');\n        path.pop(); // remove filename part\n        path = path.join('/').trim();\n\n        // ensure path prefix /\n        if (path.charAt(0) !== '/') {\n            path = '/' + path;\n        }\n\n        // ensure path suffix /\n        if (path.substr(-1) !== '/') {\n            path += '/';\n        }\n\n        return path;\n    }\n}\n\nmodule.exports = Cookies;\n", "'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n    return fetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction fetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(cookie => {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    let fetchRes = options.fetchRes;\n    let parsed = urllib.parse(url);\n    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n    let finished = false;\n    let cookies;\n    let body;\n\n    let handler = parsed.protocol === 'https:' ? https : http;\n\n    let headers = {\n        'accept-encoding': 'gzip,deflate',\n        'user-agent': 'nodemailer/' + packageData.version\n    };\n\n    Object.keys(options.headers || {}).forEach(key => {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['user-agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                try {\n                    // encodeURIComponent can fail on invalid input (partial emoji etc.)\n                    body = Buffer.from(\n                        Object.keys(options.body)\n                            .map(key => {\n                                let value = options.body[key].toString().trim();\n                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                            })\n                            .join('&')\n                    );\n                } catch (E) {\n                    if (finished) {\n                        return;\n                    }\n                    finished = true;\n                    E.type = 'FETCH';\n                    E.sourceUrl = url;\n                    fetchRes.emit('error', E);\n                    return;\n                }\n            } else {\n                body = Buffer.from(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n    }\n\n    let req;\n    let reqOptions = {\n        method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n        headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(key => {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(() => {\n            E.type = 'FETCH';\n            E.sourceUrl = url;\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            let err = new Error('Request Timeout');\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n        });\n    }\n\n    req.on('error', err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', res => {\n        let inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                let err = new Error('Maximum redirect count exceeded');\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n                return;\n            }\n            // redirect does not include POST body\n            options.method = 'GET';\n            options.body = false;\n            return fetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        fetchRes.statusCode = res.statusCode;\n        fetchRes.headers = res.headers;\n\n        if (res.statusCode >= 300 && !options.allowErrorResponse) {\n            finished = true;\n            let err = new Error('Invalid status code ' + res.statusCode);\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n            return;\n        }\n\n        res.on('error', err => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(() => {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n", "'use strict';\n\nconst shared = require('../shared');\nconst MimeNode = require('../mime-node');\nconst mimeFuncs = require('../mime-funcs');\n\nclass MailMessage {\n    constructor(mailer, data) {\n        this.mailer = mailer;\n        this.data = {};\n        this.message = null;\n\n        data = data || {};\n        let options = mailer.options || {};\n        let defaults = mailer._defaults || {};\n\n        Object.keys(data).forEach(key => {\n            this.data[key] = data[key];\n        });\n\n        this.data.headers = this.data.headers || {};\n\n        // apply defaults\n        Object.keys(defaults).forEach(key => {\n            if (!(key in this.data)) {\n                this.data[key] = defaults[key];\n            } else if (key === 'headers') {\n                // headers is a special case. Allow setting individual default headers\n                Object.keys(defaults.headers).forEach(key => {\n                    if (!(key in this.data.headers)) {\n                        this.data.headers[key] = defaults.headers[key];\n                    }\n                });\n            }\n        });\n\n        // force specific keys from transporter options\n        ['disableFileAccess', 'disableUrlAccess', 'normalizeHeaderKey'].forEach(key => {\n            if (key in options) {\n                this.data[key] = options[key];\n            }\n        });\n    }\n\n    resolveContent(...args) {\n        return shared.resolveContent(...args);\n    }\n\n    resolveAll(callback) {\n        let keys = [\n            [this.data, 'html'],\n            [this.data, 'text'],\n            [this.data, 'watchHtml'],\n            [this.data, 'amp'],\n            [this.data, 'icalEvent']\n        ];\n\n        if (this.data.alternatives && this.data.alternatives.length) {\n            this.data.alternatives.forEach((alternative, i) => {\n                keys.push([this.data.alternatives, i]);\n            });\n        }\n\n        if (this.data.attachments && this.data.attachments.length) {\n            this.data.attachments.forEach((attachment, i) => {\n                if (!attachment.filename) {\n                    attachment.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n                    if (attachment.filename.indexOf('.') < 0) {\n                        attachment.filename += '.' + mimeFuncs.detectExtension(attachment.contentType);\n                    }\n                }\n\n                if (!attachment.contentType) {\n                    attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');\n                }\n\n                keys.push([this.data.attachments, i]);\n            });\n        }\n\n        let mimeNode = new MimeNode();\n\n        let addressKeys = ['from', 'to', 'cc', 'bcc', 'sender', 'replyTo'];\n\n        addressKeys.forEach(address => {\n            let value;\n            if (this.message) {\n                value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === 'replyTo' ? 'reply-to' : address)) || []);\n            } else if (this.data[address]) {\n                value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);\n            }\n            if (value && value.length) {\n                this.data[address] = value;\n            } else if (address in this.data) {\n                this.data[address] = null;\n            }\n        });\n\n        let singleKeys = ['from', 'sender', 'replyTo'];\n        singleKeys.forEach(address => {\n            if (this.data[address]) {\n                this.data[address] = this.data[address].shift();\n            }\n        });\n\n        let pos = 0;\n        let resolveNext = () => {\n            if (pos >= keys.length) {\n                return callback(null, this.data);\n            }\n            let args = keys[pos++];\n            if (!args[0] || !args[0][args[1]]) {\n                return resolveNext();\n            }\n            shared.resolveContent(...args, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                let node = {\n                    content: value\n                };\n                if (args[0][args[1]] && typeof args[0][args[1]] === 'object' && !Buffer.isBuffer(args[0][args[1]])) {\n                    Object.keys(args[0][args[1]]).forEach(key => {\n                        if (!(key in node) && !['content', 'path', 'href', 'raw'].includes(key)) {\n                            node[key] = args[0][args[1]][key];\n                        }\n                    });\n                }\n\n                args[0][args[1]] = node;\n                resolveNext();\n            });\n        };\n\n        setImmediate(() => resolveNext());\n    }\n\n    normalize(callback) {\n        let envelope = this.data.envelope || this.message.getEnvelope();\n        let messageId = this.message.messageId();\n\n        this.resolveAll((err, data) => {\n            if (err) {\n                return callback(err);\n            }\n\n            data.envelope = envelope;\n            data.messageId = messageId;\n\n            ['html', 'text', 'watchHtml', 'amp'].forEach(key => {\n                if (data[key] && data[key].content) {\n                    if (typeof data[key].content === 'string') {\n                        data[key] = data[key].content;\n                    } else if (Buffer.isBuffer(data[key].content)) {\n                        data[key] = data[key].content.toString();\n                    }\n                }\n            });\n\n            if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {\n                data.icalEvent.content = data.icalEvent.content.toString('base64');\n                data.icalEvent.encoding = 'base64';\n            }\n\n            if (data.alternatives && data.alternatives.length) {\n                data.alternatives.forEach(alternative => {\n                    if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {\n                        alternative.content = alternative.content.toString('base64');\n                        alternative.encoding = 'base64';\n                    }\n                });\n            }\n\n            if (data.attachments && data.attachments.length) {\n                data.attachments.forEach(attachment => {\n                    if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {\n                        attachment.content = attachment.content.toString('base64');\n                        attachment.encoding = 'base64';\n                    }\n                });\n            }\n\n            data.normalizedHeaders = {};\n            Object.keys(data.headers || {}).forEach(key => {\n                let value = [].concat(data.headers[key] || []).shift();\n                value = (value && value.value) || value;\n                if (value) {\n                    if (['references', 'in-reply-to', 'message-id', 'content-id'].includes(key)) {\n                        value = this.message._encodeHeaderValue(key, value);\n                    }\n                    data.normalizedHeaders[key] = value;\n                }\n            });\n\n            if (data.list && typeof data.list === 'object') {\n                let listHeaders = this._getListHeaders(data.list);\n                listHeaders.forEach(entry => {\n                    data.normalizedHeaders[entry.key] = entry.value.map(val => (val && val.value) || val).join(', ');\n                });\n            }\n\n            if (data.references) {\n                data.normalizedHeaders.references = this.message._encodeHeaderValue('references', data.references);\n            }\n\n            if (data.inReplyTo) {\n                data.normalizedHeaders['in-reply-to'] = this.message._encodeHeaderValue('in-reply-to', data.inReplyTo);\n            }\n\n            return callback(null, data);\n        });\n    }\n\n    setMailerHeader() {\n        if (!this.message || !this.data.xMailer) {\n            return;\n        }\n        this.message.setHeader('X-Mailer', this.data.xMailer);\n    }\n\n    setPriorityHeaders() {\n        if (!this.message || !this.data.priority) {\n            return;\n        }\n        switch ((this.data.priority || '').toString().toLowerCase()) {\n            case 'high':\n                this.message.setHeader('X-Priority', '1 (Highest)');\n                this.message.setHeader('X-MSMail-Priority', 'High');\n                this.message.setHeader('Importance', 'High');\n                break;\n            case 'low':\n                this.message.setHeader('X-Priority', '5 (Lowest)');\n                this.message.setHeader('X-MSMail-Priority', 'Low');\n                this.message.setHeader('Importance', 'Low');\n                break;\n            default:\n            // do not add anything, since all messages are 'Normal' by default\n        }\n    }\n\n    setListHeaders() {\n        if (!this.message || !this.data.list || typeof this.data.list !== 'object') {\n            return;\n        }\n        // add optional List-* headers\n        if (this.data.list && typeof this.data.list === 'object') {\n            this._getListHeaders(this.data.list).forEach(listHeader => {\n                listHeader.value.forEach(value => {\n                    this.message.addHeader(listHeader.key, value);\n                });\n            });\n        }\n    }\n\n    _getListHeaders(listData) {\n        // make sure an url looks like <protocol:url>\n        return Object.keys(listData).map(key => ({\n            key: 'list-' + key.toLowerCase().trim(),\n            value: [].concat(listData[key] || []).map(value => ({\n                prepared: true,\n                foldLines: true,\n                value: []\n                    .concat(value || [])\n                    .map(value => {\n                        if (typeof value === 'string') {\n                            value = {\n                                url: value\n                            };\n                        }\n\n                        if (value && value.url) {\n                            if (key.toLowerCase().trim() === 'id') {\n                                // List-ID: \"comment\" <domain>\n                                let comment = value.comment || '';\n                                if (mimeFuncs.isPlainText(comment)) {\n                                    comment = '\"' + comment + '\"';\n                                } else {\n                                    comment = mimeFuncs.encodeWord(comment);\n                                }\n\n                                return (value.comment ? comment + ' ' : '') + this._formatListUrl(value.url).replace(/^<[^:]+\\/{,2}/, '');\n                            }\n\n                            // List-*: <http://domain> (comment)\n                            let comment = value.comment || '';\n                            if (!mimeFuncs.isPlainText(comment)) {\n                                comment = mimeFuncs.encodeWord(comment);\n                            }\n\n                            return this._formatListUrl(value.url) + (value.comment ? ' (' + comment + ')' : '');\n                        }\n\n                        return '';\n                    })\n                    .filter(value => value)\n                    .join(', ')\n            }))\n        }));\n    }\n\n    _formatListUrl(url) {\n        url = url.replace(/[\\s<]+|[\\s>]+/g, '');\n        if (/^(https?|mailto|ftp):/.test(url)) {\n            return '<' + url + '>';\n        }\n        if (/^[^@]+@[^@]+$/.test(url)) {\n            return '<mailto:' + url + '>';\n        }\n\n        return '<http://' + url + '>';\n    }\n}\n\nmodule.exports = MailMessage;\n", "/* eslint quote-props: 0 */\n\n'use strict';\n\nconst path = require('path');\n\nconst defaultMimeType = 'application/octet-stream';\nconst defaultExtension = 'bin';\n\nconst mimeTypes = new Map([\n    ['application/acad', 'dwg'],\n    ['application/applixware', 'aw'],\n    ['application/arj', 'arj'],\n    ['application/atom+xml', 'xml'],\n    ['application/atomcat+xml', 'atomcat'],\n    ['application/atomsvc+xml', 'atomsvc'],\n    ['application/base64', ['mm', 'mme']],\n    ['application/binhex', 'hqx'],\n    ['application/binhex4', 'hqx'],\n    ['application/book', ['book', 'boo']],\n    ['application/ccxml+xml,', 'ccxml'],\n    ['application/cdf', 'cdf'],\n    ['application/cdmi-capability', 'cdmia'],\n    ['application/cdmi-container', 'cdmic'],\n    ['application/cdmi-domain', 'cdmid'],\n    ['application/cdmi-object', 'cdmio'],\n    ['application/cdmi-queue', 'cdmiq'],\n    ['application/clariscad', 'ccad'],\n    ['application/commonground', 'dp'],\n    ['application/cu-seeme', 'cu'],\n    ['application/davmount+xml', 'davmount'],\n    ['application/drafting', 'drw'],\n    ['application/dsptype', 'tsp'],\n    ['application/dssc+der', 'dssc'],\n    ['application/dssc+xml', 'xdssc'],\n    ['application/dxf', 'dxf'],\n    ['application/ecmascript', ['js', 'es']],\n    ['application/emma+xml', 'emma'],\n    ['application/envoy', 'evy'],\n    ['application/epub+zip', 'epub'],\n    ['application/excel', ['xls', 'xl', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],\n    ['application/exi', 'exi'],\n    ['application/font-tdpfr', 'pfr'],\n    ['application/fractals', 'fif'],\n    ['application/freeloader', 'frl'],\n    ['application/futuresplash', 'spl'],\n    ['application/gnutar', 'tgz'],\n    ['application/groupwise', 'vew'],\n    ['application/hlp', 'hlp'],\n    ['application/hta', 'hta'],\n    ['application/hyperstudio', 'stk'],\n    ['application/i-deas', 'unv'],\n    ['application/iges', ['iges', 'igs']],\n    ['application/inf', 'inf'],\n    ['application/internet-property-stream', 'acx'],\n    ['application/ipfix', 'ipfix'],\n    ['application/java', 'class'],\n    ['application/java-archive', 'jar'],\n    ['application/java-byte-code', 'class'],\n    ['application/java-serialized-object', 'ser'],\n    ['application/java-vm', 'class'],\n    ['application/javascript', 'js'],\n    ['application/json', 'json'],\n    ['application/lha', 'lha'],\n    ['application/lzx', 'lzx'],\n    ['application/mac-binary', 'bin'],\n    ['application/mac-binhex', 'hqx'],\n    ['application/mac-binhex40', 'hqx'],\n    ['application/mac-compactpro', 'cpt'],\n    ['application/macbinary', 'bin'],\n    ['application/mads+xml', 'mads'],\n    ['application/marc', 'mrc'],\n    ['application/marcxml+xml', 'mrcx'],\n    ['application/mathematica', 'ma'],\n    ['application/mathml+xml', 'mathml'],\n    ['application/mbedlet', 'mbd'],\n    ['application/mbox', 'mbox'],\n    ['application/mcad', 'mcd'],\n    ['application/mediaservercontrol+xml', 'mscml'],\n    ['application/metalink4+xml', 'meta4'],\n    ['application/mets+xml', 'mets'],\n    ['application/mime', 'aps'],\n    ['application/mods+xml', 'mods'],\n    ['application/mp21', 'm21'],\n    ['application/mp4', 'mp4'],\n    ['application/mspowerpoint', ['ppt', 'pot', 'pps', 'ppz']],\n    ['application/msword', ['doc', 'dot', 'w6w', 'wiz', 'word']],\n    ['application/mswrite', 'wri'],\n    ['application/mxf', 'mxf'],\n    ['application/netmc', 'mcp'],\n    ['application/octet-stream', ['*']],\n    ['application/oda', 'oda'],\n    ['application/oebps-package+xml', 'opf'],\n    ['application/ogg', 'ogx'],\n    ['application/olescript', 'axs'],\n    ['application/onenote', 'onetoc'],\n    ['application/patch-ops-error+xml', 'xer'],\n    ['application/pdf', 'pdf'],\n    ['application/pgp-encrypted', 'asc'],\n    ['application/pgp-signature', 'pgp'],\n    ['application/pics-rules', 'prf'],\n    ['application/pkcs-12', 'p12'],\n    ['application/pkcs-crl', 'crl'],\n    ['application/pkcs10', 'p10'],\n    ['application/pkcs7-mime', ['p7c', 'p7m']],\n    ['application/pkcs7-signature', 'p7s'],\n    ['application/pkcs8', 'p8'],\n    ['application/pkix-attr-cert', 'ac'],\n    ['application/pkix-cert', ['cer', 'crt']],\n    ['application/pkix-crl', 'crl'],\n    ['application/pkix-pkipath', 'pkipath'],\n    ['application/pkixcmp', 'pki'],\n    ['application/plain', 'text'],\n    ['application/pls+xml', 'pls'],\n    ['application/postscript', ['ps', 'ai', 'eps']],\n    ['application/powerpoint', 'ppt'],\n    ['application/pro_eng', ['part', 'prt']],\n    ['application/prs.cww', 'cww'],\n    ['application/pskc+xml', 'pskcxml'],\n    ['application/rdf+xml', 'rdf'],\n    ['application/reginfo+xml', 'rif'],\n    ['application/relax-ng-compact-syntax', 'rnc'],\n    ['application/resource-lists+xml', 'rl'],\n    ['application/resource-lists-diff+xml', 'rld'],\n    ['application/ringing-tones', 'rng'],\n    ['application/rls-services+xml', 'rs'],\n    ['application/rsd+xml', 'rsd'],\n    ['application/rss+xml', 'xml'],\n    ['application/rtf', ['rtf', 'rtx']],\n    ['application/sbml+xml', 'sbml'],\n    ['application/scvp-cv-request', 'scq'],\n    ['application/scvp-cv-response', 'scs'],\n    ['application/scvp-vp-request', 'spq'],\n    ['application/scvp-vp-response', 'spp'],\n    ['application/sdp', 'sdp'],\n    ['application/sea', 'sea'],\n    ['application/set', 'set'],\n    ['application/set-payment-initiation', 'setpay'],\n    ['application/set-registration-initiation', 'setreg'],\n    ['application/shf+xml', 'shf'],\n    ['application/sla', 'stl'],\n    ['application/smil', ['smi', 'smil']],\n    ['application/smil+xml', 'smi'],\n    ['application/solids', 'sol'],\n    ['application/sounder', 'sdr'],\n    ['application/sparql-query', 'rq'],\n    ['application/sparql-results+xml', 'srx'],\n    ['application/srgs', 'gram'],\n    ['application/srgs+xml', 'grxml'],\n    ['application/sru+xml', 'sru'],\n    ['application/ssml+xml', 'ssml'],\n    ['application/step', ['step', 'stp']],\n    ['application/streamingmedia', 'ssm'],\n    ['application/tei+xml', 'tei'],\n    ['application/thraud+xml', 'tfi'],\n    ['application/timestamped-data', 'tsd'],\n    ['application/toolbook', 'tbk'],\n    ['application/vda', 'vda'],\n    ['application/vnd.3gpp.pic-bw-large', 'plb'],\n    ['application/vnd.3gpp.pic-bw-small', 'psb'],\n    ['application/vnd.3gpp.pic-bw-var', 'pvb'],\n    ['application/vnd.3gpp2.tcap', 'tcap'],\n    ['application/vnd.3m.post-it-notes', 'pwn'],\n    ['application/vnd.accpac.simply.aso', 'aso'],\n    ['application/vnd.accpac.simply.imp', 'imp'],\n    ['application/vnd.acucobol', 'acu'],\n    ['application/vnd.acucorp', 'atc'],\n    ['application/vnd.adobe.air-application-installer-package+zip', 'air'],\n    ['application/vnd.adobe.fxp', 'fxp'],\n    ['application/vnd.adobe.xdp+xml', 'xdp'],\n    ['application/vnd.adobe.xfdf', 'xfdf'],\n    ['application/vnd.ahead.space', 'ahead'],\n    ['application/vnd.airzip.filesecure.azf', 'azf'],\n    ['application/vnd.airzip.filesecure.azs', 'azs'],\n    ['application/vnd.amazon.ebook', 'azw'],\n    ['application/vnd.americandynamics.acc', 'acc'],\n    ['application/vnd.amiga.ami', 'ami'],\n    ['application/vnd.android.package-archive', 'apk'],\n    ['application/vnd.anser-web-certificate-issue-initiation', 'cii'],\n    ['application/vnd.anser-web-funds-transfer-initiation', 'fti'],\n    ['application/vnd.antix.game-component', 'atx'],\n    ['application/vnd.apple.installer+xml', 'mpkg'],\n    ['application/vnd.apple.mpegurl', 'm3u8'],\n    ['application/vnd.aristanetworks.swi', 'swi'],\n    ['application/vnd.audiograph', 'aep'],\n    ['application/vnd.blueice.multipass', 'mpm'],\n    ['application/vnd.bmi', 'bmi'],\n    ['application/vnd.businessobjects', 'rep'],\n    ['application/vnd.chemdraw+xml', 'cdxml'],\n    ['application/vnd.chipnuts.karaoke-mmd', 'mmd'],\n    ['application/vnd.cinderella', 'cdy'],\n    ['application/vnd.claymore', 'cla'],\n    ['application/vnd.cloanto.rp9', 'rp9'],\n    ['application/vnd.clonk.c4group', 'c4g'],\n    ['application/vnd.cluetrust.cartomobile-config', 'c11amc'],\n    ['application/vnd.cluetrust.cartomobile-config-pkg', 'c11amz'],\n    ['application/vnd.commonspace', 'csp'],\n    ['application/vnd.contact.cmsg', 'cdbcmsg'],\n    ['application/vnd.cosmocaller', 'cmc'],\n    ['application/vnd.crick.clicker', 'clkx'],\n    ['application/vnd.crick.clicker.keyboard', 'clkk'],\n    ['application/vnd.crick.clicker.palette', 'clkp'],\n    ['application/vnd.crick.clicker.template', 'clkt'],\n    ['application/vnd.crick.clicker.wordbank', 'clkw'],\n    ['application/vnd.criticaltools.wbs+xml', 'wbs'],\n    ['application/vnd.ctc-posml', 'pml'],\n    ['application/vnd.cups-ppd', 'ppd'],\n    ['application/vnd.curl.car', 'car'],\n    ['application/vnd.curl.pcurl', 'pcurl'],\n    ['application/vnd.data-vision.rdz', 'rdz'],\n    ['application/vnd.denovo.fcselayout-link', 'fe_launch'],\n    ['application/vnd.dna', 'dna'],\n    ['application/vnd.dolby.mlp', 'mlp'],\n    ['application/vnd.dpgraph', 'dpg'],\n    ['application/vnd.dreamfactory', 'dfac'],\n    ['application/vnd.dvb.ait', 'ait'],\n    ['application/vnd.dvb.service', 'svc'],\n    ['application/vnd.dynageo', 'geo'],\n    ['application/vnd.ecowin.chart', 'mag'],\n    ['application/vnd.enliven', 'nml'],\n    ['application/vnd.epson.esf', 'esf'],\n    ['application/vnd.epson.msf', 'msf'],\n    ['application/vnd.epson.quickanime', 'qam'],\n    ['application/vnd.epson.salt', 'slt'],\n    ['application/vnd.epson.ssf', 'ssf'],\n    ['application/vnd.eszigno3+xml', 'es3'],\n    ['application/vnd.ezpix-album', 'ez2'],\n    ['application/vnd.ezpix-package', 'ez3'],\n    ['application/vnd.fdf', 'fdf'],\n    ['application/vnd.fdsn.seed', 'seed'],\n    ['application/vnd.flographit', 'gph'],\n    ['application/vnd.fluxtime.clip', 'ftc'],\n    ['application/vnd.framemaker', 'fm'],\n    ['application/vnd.frogans.fnc', 'fnc'],\n    ['application/vnd.frogans.ltf', 'ltf'],\n    ['application/vnd.fsc.weblaunch', 'fsc'],\n    ['application/vnd.fujitsu.oasys', 'oas'],\n    ['application/vnd.fujitsu.oasys2', 'oa2'],\n    ['application/vnd.fujitsu.oasys3', 'oa3'],\n    ['application/vnd.fujitsu.oasysgp', 'fg5'],\n    ['application/vnd.fujitsu.oasysprs', 'bh2'],\n    ['application/vnd.fujixerox.ddd', 'ddd'],\n    ['application/vnd.fujixerox.docuworks', 'xdw'],\n    ['application/vnd.fujixerox.docuworks.binder', 'xbd'],\n    ['application/vnd.fuzzysheet', 'fzs'],\n    ['application/vnd.genomatix.tuxedo', 'txd'],\n    ['application/vnd.geogebra.file', 'ggb'],\n    ['application/vnd.geogebra.tool', 'ggt'],\n    ['application/vnd.geometry-explorer', 'gex'],\n    ['application/vnd.geonext', 'gxt'],\n    ['application/vnd.geoplan', 'g2w'],\n    ['application/vnd.geospace', 'g3w'],\n    ['application/vnd.gmx', 'gmx'],\n    ['application/vnd.google-earth.kml+xml', 'kml'],\n    ['application/vnd.google-earth.kmz', 'kmz'],\n    ['application/vnd.grafeq', 'gqf'],\n    ['application/vnd.groove-account', 'gac'],\n    ['application/vnd.groove-help', 'ghf'],\n    ['application/vnd.groove-identity-message', 'gim'],\n    ['application/vnd.groove-injector', 'grv'],\n    ['application/vnd.groove-tool-message', 'gtm'],\n    ['application/vnd.groove-tool-template', 'tpl'],\n    ['application/vnd.groove-vcard', 'vcg'],\n    ['application/vnd.hal+xml', 'hal'],\n    ['application/vnd.handheld-entertainment+xml', 'zmm'],\n    ['application/vnd.hbci', 'hbci'],\n    ['application/vnd.hhe.lesson-player', 'les'],\n    ['application/vnd.hp-hpgl', ['hgl', 'hpg', 'hpgl']],\n    ['application/vnd.hp-hpid', 'hpid'],\n    ['application/vnd.hp-hps', 'hps'],\n    ['application/vnd.hp-jlyt', 'jlt'],\n    ['application/vnd.hp-pcl', 'pcl'],\n    ['application/vnd.hp-pclxl', 'pclxl'],\n    ['application/vnd.hydrostatix.sof-data', 'sfd-hdstx'],\n    ['application/vnd.hzn-3d-crossword', 'x3d'],\n    ['application/vnd.ibm.minipay', 'mpy'],\n    ['application/vnd.ibm.modcap', 'afp'],\n    ['application/vnd.ibm.rights-management', 'irm'],\n    ['application/vnd.ibm.secure-container', 'sc'],\n    ['application/vnd.iccprofile', 'icc'],\n    ['application/vnd.igloader', 'igl'],\n    ['application/vnd.immervision-ivp', 'ivp'],\n    ['application/vnd.immervision-ivu', 'ivu'],\n    ['application/vnd.insors.igm', 'igm'],\n    ['application/vnd.intercon.formnet', 'xpw'],\n    ['application/vnd.intergeo', 'i2g'],\n    ['application/vnd.intu.qbo', 'qbo'],\n    ['application/vnd.intu.qfx', 'qfx'],\n    ['application/vnd.ipunplugged.rcprofile', 'rcprofile'],\n    ['application/vnd.irepository.package+xml', 'irp'],\n    ['application/vnd.is-xpr', 'xpr'],\n    ['application/vnd.isac.fcs', 'fcs'],\n    ['application/vnd.jam', 'jam'],\n    ['application/vnd.jcp.javame.midlet-rms', 'rms'],\n    ['application/vnd.jisp', 'jisp'],\n    ['application/vnd.joost.joda-archive', 'joda'],\n    ['application/vnd.kahootz', 'ktz'],\n    ['application/vnd.kde.karbon', 'karbon'],\n    ['application/vnd.kde.kchart', 'chrt'],\n    ['application/vnd.kde.kformula', 'kfo'],\n    ['application/vnd.kde.kivio', 'flw'],\n    ['application/vnd.kde.kontour', 'kon'],\n    ['application/vnd.kde.kpresenter', 'kpr'],\n    ['application/vnd.kde.kspread', 'ksp'],\n    ['application/vnd.kde.kword', 'kwd'],\n    ['application/vnd.kenameaapp', 'htke'],\n    ['application/vnd.kidspiration', 'kia'],\n    ['application/vnd.kinar', 'kne'],\n    ['application/vnd.koan', 'skp'],\n    ['application/vnd.kodak-descriptor', 'sse'],\n    ['application/vnd.las.las+xml', 'lasxml'],\n    ['application/vnd.llamagraphics.life-balance.desktop', 'lbd'],\n    ['application/vnd.llamagraphics.life-balance.exchange+xml', 'lbe'],\n    ['application/vnd.lotus-1-2-3', '123'],\n    ['application/vnd.lotus-approach', 'apr'],\n    ['application/vnd.lotus-freelance', 'pre'],\n    ['application/vnd.lotus-notes', 'nsf'],\n    ['application/vnd.lotus-organizer', 'org'],\n    ['application/vnd.lotus-screencam', 'scm'],\n    ['application/vnd.lotus-wordpro', 'lwp'],\n    ['application/vnd.macports.portpkg', 'portpkg'],\n    ['application/vnd.mcd', 'mcd'],\n    ['application/vnd.medcalcdata', 'mc1'],\n    ['application/vnd.mediastation.cdkey', 'cdkey'],\n    ['application/vnd.mfer', 'mwf'],\n    ['application/vnd.mfmp', 'mfm'],\n    ['application/vnd.micrografx.flo', 'flo'],\n    ['application/vnd.micrografx.igx', 'igx'],\n    ['application/vnd.mif', 'mif'],\n    ['application/vnd.mobius.daf', 'daf'],\n    ['application/vnd.mobius.dis', 'dis'],\n    ['application/vnd.mobius.mbk', 'mbk'],\n    ['application/vnd.mobius.mqy', 'mqy'],\n    ['application/vnd.mobius.msl', 'msl'],\n    ['application/vnd.mobius.plc', 'plc'],\n    ['application/vnd.mobius.txf', 'txf'],\n    ['application/vnd.mophun.application', 'mpn'],\n    ['application/vnd.mophun.certificate', 'mpc'],\n    ['application/vnd.mozilla.xul+xml', 'xul'],\n    ['application/vnd.ms-artgalry', 'cil'],\n    ['application/vnd.ms-cab-compressed', 'cab'],\n    ['application/vnd.ms-excel', ['xls', 'xla', 'xlc', 'xlm', 'xlt', 'xlw', 'xlb', 'xll']],\n    ['application/vnd.ms-excel.addin.macroenabled.12', 'xlam'],\n    ['application/vnd.ms-excel.sheet.binary.macroenabled.12', 'xlsb'],\n    ['application/vnd.ms-excel.sheet.macroenabled.12', 'xlsm'],\n    ['application/vnd.ms-excel.template.macroenabled.12', 'xltm'],\n    ['application/vnd.ms-fontobject', 'eot'],\n    ['application/vnd.ms-htmlhelp', 'chm'],\n    ['application/vnd.ms-ims', 'ims'],\n    ['application/vnd.ms-lrm', 'lrm'],\n    ['application/vnd.ms-officetheme', 'thmx'],\n    ['application/vnd.ms-outlook', 'msg'],\n    ['application/vnd.ms-pki.certstore', 'sst'],\n    ['application/vnd.ms-pki.pko', 'pko'],\n    ['application/vnd.ms-pki.seccat', 'cat'],\n    ['application/vnd.ms-pki.stl', 'stl'],\n    ['application/vnd.ms-pkicertstore', 'sst'],\n    ['application/vnd.ms-pkiseccat', 'cat'],\n    ['application/vnd.ms-pkistl', 'stl'],\n    ['application/vnd.ms-powerpoint', ['ppt', 'pot', 'pps', 'ppa', 'pwz']],\n    ['application/vnd.ms-powerpoint.addin.macroenabled.12', 'ppam'],\n    ['application/vnd.ms-powerpoint.presentation.macroenabled.12', 'pptm'],\n    ['application/vnd.ms-powerpoint.slide.macroenabled.12', 'sldm'],\n    ['application/vnd.ms-powerpoint.slideshow.macroenabled.12', 'ppsm'],\n    ['application/vnd.ms-powerpoint.template.macroenabled.12', 'potm'],\n    ['application/vnd.ms-project', 'mpp'],\n    ['application/vnd.ms-word.document.macroenabled.12', 'docm'],\n    ['application/vnd.ms-word.template.macroenabled.12', 'dotm'],\n    ['application/vnd.ms-works', ['wks', 'wcm', 'wdb', 'wps']],\n    ['application/vnd.ms-wpl', 'wpl'],\n    ['application/vnd.ms-xpsdocument', 'xps'],\n    ['application/vnd.mseq', 'mseq'],\n    ['application/vnd.musician', 'mus'],\n    ['application/vnd.muvee.style', 'msty'],\n    ['application/vnd.neurolanguage.nlu', 'nlu'],\n    ['application/vnd.noblenet-directory', 'nnd'],\n    ['application/vnd.noblenet-sealer', 'nns'],\n    ['application/vnd.noblenet-web', 'nnw'],\n    ['application/vnd.nokia.configuration-message', 'ncm'],\n    ['application/vnd.nokia.n-gage.data', 'ngdat'],\n    ['application/vnd.nokia.n-gage.symbian.install', 'n-gage'],\n    ['application/vnd.nokia.radio-preset', 'rpst'],\n    ['application/vnd.nokia.radio-presets', 'rpss'],\n    ['application/vnd.nokia.ringing-tone', 'rng'],\n    ['application/vnd.novadigm.edm', 'edm'],\n    ['application/vnd.novadigm.edx', 'edx'],\n    ['application/vnd.novadigm.ext', 'ext'],\n    ['application/vnd.oasis.opendocument.chart', 'odc'],\n    ['application/vnd.oasis.opendocument.chart-template', 'otc'],\n    ['application/vnd.oasis.opendocument.database', 'odb'],\n    ['application/vnd.oasis.opendocument.formula', 'odf'],\n    ['application/vnd.oasis.opendocument.formula-template', 'odft'],\n    ['application/vnd.oasis.opendocument.graphics', 'odg'],\n    ['application/vnd.oasis.opendocument.graphics-template', 'otg'],\n    ['application/vnd.oasis.opendocument.image', 'odi'],\n    ['application/vnd.oasis.opendocument.image-template', 'oti'],\n    ['application/vnd.oasis.opendocument.presentation', 'odp'],\n    ['application/vnd.oasis.opendocument.presentation-template', 'otp'],\n    ['application/vnd.oasis.opendocument.spreadsheet', 'ods'],\n    ['application/vnd.oasis.opendocument.spreadsheet-template', 'ots'],\n    ['application/vnd.oasis.opendocument.text', 'odt'],\n    ['application/vnd.oasis.opendocument.text-master', 'odm'],\n    ['application/vnd.oasis.opendocument.text-template', 'ott'],\n    ['application/vnd.oasis.opendocument.text-web', 'oth'],\n    ['application/vnd.olpc-sugar', 'xo'],\n    ['application/vnd.oma.dd2+xml', 'dd2'],\n    ['application/vnd.openofficeorg.extension', 'oxt'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.presentation', 'pptx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.slide', 'sldx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.slideshow', 'ppsx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.template', 'potx'],\n    ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'xlsx'],\n    ['application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'xltx'],\n    ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'docx'],\n    ['application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'dotx'],\n    ['application/vnd.osgeo.mapguide.package', 'mgp'],\n    ['application/vnd.osgi.dp', 'dp'],\n    ['application/vnd.palm', 'pdb'],\n    ['application/vnd.pawaafile', 'paw'],\n    ['application/vnd.pg.format', 'str'],\n    ['application/vnd.pg.osasli', 'ei6'],\n    ['application/vnd.picsel', 'efif'],\n    ['application/vnd.pmi.widget', 'wg'],\n    ['application/vnd.pocketlearn', 'plf'],\n    ['application/vnd.powerbuilder6', 'pbd'],\n    ['application/vnd.previewsystems.box', 'box'],\n    ['application/vnd.proteus.magazine', 'mgz'],\n    ['application/vnd.publishare-delta-tree', 'qps'],\n    ['application/vnd.pvi.ptid1', 'ptid'],\n    ['application/vnd.quark.quarkxpress', 'qxd'],\n    ['application/vnd.realvnc.bed', 'bed'],\n    ['application/vnd.recordare.musicxml', 'mxl'],\n    ['application/vnd.recordare.musicxml+xml', 'musicxml'],\n    ['application/vnd.rig.cryptonote', 'cryptonote'],\n    ['application/vnd.rim.cod', 'cod'],\n    ['application/vnd.rn-realmedia', 'rm'],\n    ['application/vnd.rn-realplayer', 'rnx'],\n    ['application/vnd.route66.link66+xml', 'link66'],\n    ['application/vnd.sailingtracker.track', 'st'],\n    ['application/vnd.seemail', 'see'],\n    ['application/vnd.sema', 'sema'],\n    ['application/vnd.semd', 'semd'],\n    ['application/vnd.semf', 'semf'],\n    ['application/vnd.shana.informed.formdata', 'ifm'],\n    ['application/vnd.shana.informed.formtemplate', 'itp'],\n    ['application/vnd.shana.informed.interchange', 'iif'],\n    ['application/vnd.shana.informed.package', 'ipk'],\n    ['application/vnd.simtech-mindmapper', 'twd'],\n    ['application/vnd.smaf', 'mmf'],\n    ['application/vnd.smart.teacher', 'teacher'],\n    ['application/vnd.solent.sdkm+xml', 'sdkm'],\n    ['application/vnd.spotfire.dxp', 'dxp'],\n    ['application/vnd.spotfire.sfs', 'sfs'],\n    ['application/vnd.stardivision.calc', 'sdc'],\n    ['application/vnd.stardivision.draw', 'sda'],\n    ['application/vnd.stardivision.impress', 'sdd'],\n    ['application/vnd.stardivision.math', 'smf'],\n    ['application/vnd.stardivision.writer', 'sdw'],\n    ['application/vnd.stardivision.writer-global', 'sgl'],\n    ['application/vnd.stepmania.stepchart', 'sm'],\n    ['application/vnd.sun.xml.calc', 'sxc'],\n    ['application/vnd.sun.xml.calc.template', 'stc'],\n    ['application/vnd.sun.xml.draw', 'sxd'],\n    ['application/vnd.sun.xml.draw.template', 'std'],\n    ['application/vnd.sun.xml.impress', 'sxi'],\n    ['application/vnd.sun.xml.impress.template', 'sti'],\n    ['application/vnd.sun.xml.math', 'sxm'],\n    ['application/vnd.sun.xml.writer', 'sxw'],\n    ['application/vnd.sun.xml.writer.global', 'sxg'],\n    ['application/vnd.sun.xml.writer.template', 'stw'],\n    ['application/vnd.sus-calendar', 'sus'],\n    ['application/vnd.svd', 'svd'],\n    ['application/vnd.symbian.install', 'sis'],\n    ['application/vnd.syncml+xml', 'xsm'],\n    ['application/vnd.syncml.dm+wbxml', 'bdm'],\n    ['application/vnd.syncml.dm+xml', 'xdm'],\n    ['application/vnd.tao.intent-module-archive', 'tao'],\n    ['application/vnd.tmobile-livetv', 'tmo'],\n    ['application/vnd.trid.tpt', 'tpt'],\n    ['application/vnd.triscape.mxs', 'mxs'],\n    ['application/vnd.trueapp', 'tra'],\n    ['application/vnd.ufdl', 'ufd'],\n    ['application/vnd.uiq.theme', 'utz'],\n    ['application/vnd.umajin', 'umj'],\n    ['application/vnd.unity', 'unityweb'],\n    ['application/vnd.uoml+xml', 'uoml'],\n    ['application/vnd.vcx', 'vcx'],\n    ['application/vnd.visio', 'vsd'],\n    ['application/vnd.visionary', 'vis'],\n    ['application/vnd.vsf', 'vsf'],\n    ['application/vnd.wap.wbxml', 'wbxml'],\n    ['application/vnd.wap.wmlc', 'wmlc'],\n    ['application/vnd.wap.wmlscriptc', 'wmlsc'],\n    ['application/vnd.webturbo', 'wtb'],\n    ['application/vnd.wolfram.player', 'nbp'],\n    ['application/vnd.wordperfect', 'wpd'],\n    ['application/vnd.wqd', 'wqd'],\n    ['application/vnd.wt.stf', 'stf'],\n    ['application/vnd.xara', ['web', 'xar']],\n    ['application/vnd.xfdl', 'xfdl'],\n    ['application/vnd.yamaha.hv-dic', 'hvd'],\n    ['application/vnd.yamaha.hv-script', 'hvs'],\n    ['application/vnd.yamaha.hv-voice', 'hvp'],\n    ['application/vnd.yamaha.openscoreformat', 'osf'],\n    ['application/vnd.yamaha.openscoreformat.osfpvg+xml', 'osfpvg'],\n    ['application/vnd.yamaha.smaf-audio', 'saf'],\n    ['application/vnd.yamaha.smaf-phrase', 'spf'],\n    ['application/vnd.yellowriver-custom-menu', 'cmp'],\n    ['application/vnd.zul', 'zir'],\n    ['application/vnd.zzazz.deck+xml', 'zaz'],\n    ['application/vocaltec-media-desc', 'vmd'],\n    ['application/vocaltec-media-file', 'vmf'],\n    ['application/voicexml+xml', 'vxml'],\n    ['application/widget', 'wgt'],\n    ['application/winhlp', 'hlp'],\n    ['application/wordperfect', ['wp', 'wp5', 'wp6', 'wpd']],\n    ['application/wordperfect6.0', ['w60', 'wp5']],\n    ['application/wordperfect6.1', 'w61'],\n    ['application/wsdl+xml', 'wsdl'],\n    ['application/wspolicy+xml', 'wspolicy'],\n    ['application/x-123', 'wk1'],\n    ['application/x-7z-compressed', '7z'],\n    ['application/x-abiword', 'abw'],\n    ['application/x-ace-compressed', 'ace'],\n    ['application/x-aim', 'aim'],\n    ['application/x-authorware-bin', 'aab'],\n    ['application/x-authorware-map', 'aam'],\n    ['application/x-authorware-seg', 'aas'],\n    ['application/x-bcpio', 'bcpio'],\n    ['application/x-binary', 'bin'],\n    ['application/x-binhex40', 'hqx'],\n    ['application/x-bittorrent', 'torrent'],\n    ['application/x-bsh', ['bsh', 'sh', 'shar']],\n    ['application/x-bytecode.elisp', 'elc'],\n    ['applicaiton/x-bytecode.python', 'pyc'],\n    ['application/x-bzip', 'bz'],\n    ['application/x-bzip2', ['boz', 'bz2']],\n    ['application/x-cdf', 'cdf'],\n    ['application/x-cdlink', 'vcd'],\n    ['application/x-chat', ['cha', 'chat']],\n    ['application/x-chess-pgn', 'pgn'],\n    ['application/x-cmu-raster', 'ras'],\n    ['application/x-cocoa', 'cco'],\n    ['application/x-compactpro', 'cpt'],\n    ['application/x-compress', 'z'],\n    ['application/x-compressed', ['tgz', 'gz', 'z', 'zip']],\n    ['application/x-conference', 'nsc'],\n    ['application/x-cpio', 'cpio'],\n    ['application/x-cpt', 'cpt'],\n    ['application/x-csh', 'csh'],\n    ['application/x-debian-package', 'deb'],\n    ['application/x-deepv', 'deepv'],\n    ['application/x-director', ['dir', 'dcr', 'dxr']],\n    ['application/x-doom', 'wad'],\n    ['application/x-dtbncx+xml', 'ncx'],\n    ['application/x-dtbook+xml', 'dtb'],\n    ['application/x-dtbresource+xml', 'res'],\n    ['application/x-dvi', 'dvi'],\n    ['application/x-elc', 'elc'],\n    ['application/x-envoy', ['env', 'evy']],\n    ['application/x-esrehber', 'es'],\n    ['application/x-excel', ['xls', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],\n    ['application/x-font-bdf', 'bdf'],\n    ['application/x-font-ghostscript', 'gsf'],\n    ['application/x-font-linux-psf', 'psf'],\n    ['application/x-font-otf', 'otf'],\n    ['application/x-font-pcf', 'pcf'],\n    ['application/x-font-snf', 'snf'],\n    ['application/x-font-ttf', 'ttf'],\n    ['application/x-font-type1', 'pfa'],\n    ['application/x-font-woff', 'woff'],\n    ['application/x-frame', 'mif'],\n    ['application/x-freelance', 'pre'],\n    ['application/x-futuresplash', 'spl'],\n    ['application/x-gnumeric', 'gnumeric'],\n    ['application/x-gsp', 'gsp'],\n    ['application/x-gss', 'gss'],\n    ['application/x-gtar', 'gtar'],\n    ['application/x-gzip', ['gz', 'gzip']],\n    ['application/x-hdf', 'hdf'],\n    ['application/x-helpfile', ['help', 'hlp']],\n    ['application/x-httpd-imap', 'imap'],\n    ['application/x-ima', 'ima'],\n    ['application/x-internet-signup', ['ins', 'isp']],\n    ['application/x-internett-signup', 'ins'],\n    ['application/x-inventor', 'iv'],\n    ['application/x-ip2', 'ip'],\n    ['application/x-iphone', 'iii'],\n    ['application/x-java-class', 'class'],\n    ['application/x-java-commerce', 'jcm'],\n    ['application/x-java-jnlp-file', 'jnlp'],\n    ['application/x-javascript', 'js'],\n    ['application/x-koan', ['skd', 'skm', 'skp', 'skt']],\n    ['application/x-ksh', 'ksh'],\n    ['application/x-latex', ['latex', 'ltx']],\n    ['application/x-lha', 'lha'],\n    ['application/x-lisp', 'lsp'],\n    ['application/x-livescreen', 'ivy'],\n    ['application/x-lotus', 'wq1'],\n    ['application/x-lotusscreencam', 'scm'],\n    ['application/x-lzh', 'lzh'],\n    ['application/x-lzx', 'lzx'],\n    ['application/x-mac-binhex40', 'hqx'],\n    ['application/x-macbinary', 'bin'],\n    ['application/x-magic-cap-package-1.0', 'mc$'],\n    ['application/x-mathcad', 'mcd'],\n    ['application/x-meme', 'mm'],\n    ['application/x-midi', ['mid', 'midi']],\n    ['application/x-mif', 'mif'],\n    ['application/x-mix-transfer', 'nix'],\n    ['application/x-mobipocket-ebook', 'prc'],\n    ['application/x-mplayer2', 'asx'],\n    ['application/x-ms-application', 'application'],\n    ['application/x-ms-wmd', 'wmd'],\n    ['application/x-ms-wmz', 'wmz'],\n    ['application/x-ms-xbap', 'xbap'],\n    ['application/x-msaccess', 'mdb'],\n    ['application/x-msbinder', 'obd'],\n    ['application/x-mscardfile', 'crd'],\n    ['application/x-msclip', 'clp'],\n    ['application/x-msdownload', ['exe', 'dll']],\n    ['application/x-msexcel', ['xls', 'xla', 'xlw']],\n    ['application/x-msmediaview', ['mvb', 'm13', 'm14']],\n    ['application/x-msmetafile', 'wmf'],\n    ['application/x-msmoney', 'mny'],\n    ['application/x-mspowerpoint', 'ppt'],\n    ['application/x-mspublisher', 'pub'],\n    ['application/x-msschedule', 'scd'],\n    ['application/x-msterminal', 'trm'],\n    ['application/x-mswrite', 'wri'],\n    ['application/x-navi-animation', 'ani'],\n    ['application/x-navidoc', 'nvd'],\n    ['application/x-navimap', 'map'],\n    ['application/x-navistyle', 'stl'],\n    ['application/x-netcdf', ['cdf', 'nc']],\n    ['application/x-newton-compatible-pkg', 'pkg'],\n    ['application/x-nokia-9000-communicator-add-on-software', 'aos'],\n    ['application/x-omc', 'omc'],\n    ['application/x-omcdatamaker', 'omcd'],\n    ['application/x-omcregerator', 'omcr'],\n    ['application/x-pagemaker', ['pm4', 'pm5']],\n    ['application/x-pcl', 'pcl'],\n    ['application/x-perfmon', ['pma', 'pmc', 'pml', 'pmr', 'pmw']],\n    ['application/x-pixclscript', 'plx'],\n    ['application/x-pkcs10', 'p10'],\n    ['application/x-pkcs12', ['p12', 'pfx']],\n    ['application/x-pkcs7-certificates', ['p7b', 'spc']],\n    ['application/x-pkcs7-certreqresp', 'p7r'],\n    ['application/x-pkcs7-mime', ['p7m', 'p7c']],\n    ['application/x-pkcs7-signature', ['p7s', 'p7a']],\n    ['application/x-pointplus', 'css'],\n    ['application/x-portable-anymap', 'pnm'],\n    ['application/x-project', ['mpc', 'mpt', 'mpv', 'mpx']],\n    ['application/x-qpro', 'wb1'],\n    ['application/x-rar-compressed', 'rar'],\n    ['application/x-rtf', 'rtf'],\n    ['application/x-sdp', 'sdp'],\n    ['application/x-sea', 'sea'],\n    ['application/x-seelogo', 'sl'],\n    ['application/x-sh', 'sh'],\n    ['application/x-shar', ['shar', 'sh']],\n    ['application/x-shockwave-flash', 'swf'],\n    ['application/x-silverlight-app', 'xap'],\n    ['application/x-sit', 'sit'],\n    ['application/x-sprite', ['spr', 'sprite']],\n    ['application/x-stuffit', 'sit'],\n    ['application/x-stuffitx', 'sitx'],\n    ['application/x-sv4cpio', 'sv4cpio'],\n    ['application/x-sv4crc', 'sv4crc'],\n    ['application/x-tar', 'tar'],\n    ['application/x-tbook', ['sbk', 'tbk']],\n    ['application/x-tcl', 'tcl'],\n    ['application/x-tex', 'tex'],\n    ['application/x-tex-tfm', 'tfm'],\n    ['application/x-texinfo', ['texi', 'texinfo']],\n    ['application/x-troff', ['roff', 't', 'tr']],\n    ['application/x-troff-man', 'man'],\n    ['application/x-troff-me', 'me'],\n    ['application/x-troff-ms', 'ms'],\n    ['application/x-troff-msvideo', 'avi'],\n    ['application/x-ustar', 'ustar'],\n    ['application/x-visio', ['vsd', 'vst', 'vsw']],\n    ['application/x-vnd.audioexplosion.mzz', 'mzz'],\n    ['application/x-vnd.ls-xpix', 'xpix'],\n    ['application/x-vrml', 'vrml'],\n    ['application/x-wais-source', ['src', 'wsrc']],\n    ['application/x-winhelp', 'hlp'],\n    ['application/x-wintalk', 'wtk'],\n    ['application/x-world', ['wrl', 'svr']],\n    ['application/x-wpwin', 'wpd'],\n    ['application/x-wri', 'wri'],\n    ['application/x-x509-ca-cert', ['cer', 'crt', 'der']],\n    ['application/x-x509-user-cert', 'crt'],\n    ['application/x-xfig', 'fig'],\n    ['application/x-xpinstall', 'xpi'],\n    ['application/x-zip-compressed', 'zip'],\n    ['application/xcap-diff+xml', 'xdf'],\n    ['application/xenc+xml', 'xenc'],\n    ['application/xhtml+xml', 'xhtml'],\n    ['application/xml', 'xml'],\n    ['application/xml-dtd', 'dtd'],\n    ['application/xop+xml', 'xop'],\n    ['application/xslt+xml', 'xslt'],\n    ['application/xspf+xml', 'xspf'],\n    ['application/xv+xml', 'mxml'],\n    ['application/yang', 'yang'],\n    ['application/yin+xml', 'yin'],\n    ['application/ynd.ms-pkipko', 'pko'],\n    ['application/zip', 'zip'],\n    ['audio/adpcm', 'adp'],\n    ['audio/aiff', ['aiff', 'aif', 'aifc']],\n    ['audio/basic', ['snd', 'au']],\n    ['audio/it', 'it'],\n    ['audio/make', ['funk', 'my', 'pfunk']],\n    ['audio/make.my.funk', 'pfunk'],\n    ['audio/mid', ['mid', 'rmi']],\n    ['audio/midi', ['midi', 'kar', 'mid']],\n    ['audio/mod', 'mod'],\n    ['audio/mp4', 'mp4a'],\n    ['audio/mpeg', ['mpga', 'mp3', 'm2a', 'mp2', 'mpa', 'mpg']],\n    ['audio/mpeg3', 'mp3'],\n    ['audio/nspaudio', ['la', 'lma']],\n    ['audio/ogg', 'oga'],\n    ['audio/s3m', 's3m'],\n    ['audio/tsp-audio', 'tsi'],\n    ['audio/tsplayer', 'tsp'],\n    ['audio/vnd.dece.audio', 'uva'],\n    ['audio/vnd.digital-winds', 'eol'],\n    ['audio/vnd.dra', 'dra'],\n    ['audio/vnd.dts', 'dts'],\n    ['audio/vnd.dts.hd', 'dtshd'],\n    ['audio/vnd.lucent.voice', 'lvp'],\n    ['audio/vnd.ms-playready.media.pya', 'pya'],\n    ['audio/vnd.nuera.ecelp4800', 'ecelp4800'],\n    ['audio/vnd.nuera.ecelp7470', 'ecelp7470'],\n    ['audio/vnd.nuera.ecelp9600', 'ecelp9600'],\n    ['audio/vnd.qcelp', 'qcp'],\n    ['audio/vnd.rip', 'rip'],\n    ['audio/voc', 'voc'],\n    ['audio/voxware', 'vox'],\n    ['audio/wav', 'wav'],\n    ['audio/webm', 'weba'],\n    ['audio/x-aac', 'aac'],\n    ['audio/x-adpcm', 'snd'],\n    ['audio/x-aiff', ['aiff', 'aif', 'aifc']],\n    ['audio/x-au', 'au'],\n    ['audio/x-gsm', ['gsd', 'gsm']],\n    ['audio/x-jam', 'jam'],\n    ['audio/x-liveaudio', 'lam'],\n    ['audio/x-mid', ['mid', 'midi']],\n    ['audio/x-midi', ['midi', 'mid']],\n    ['audio/x-mod', 'mod'],\n    ['audio/x-mpeg', 'mp2'],\n    ['audio/x-mpeg-3', 'mp3'],\n    ['audio/x-mpegurl', 'm3u'],\n    ['audio/x-mpequrl', 'm3u'],\n    ['audio/x-ms-wax', 'wax'],\n    ['audio/x-ms-wma', 'wma'],\n    ['audio/x-nspaudio', ['la', 'lma']],\n    ['audio/x-pn-realaudio', ['ra', 'ram', 'rm', 'rmm', 'rmp']],\n    ['audio/x-pn-realaudio-plugin', ['ra', 'rmp', 'rpm']],\n    ['audio/x-psid', 'sid'],\n    ['audio/x-realaudio', 'ra'],\n    ['audio/x-twinvq', 'vqf'],\n    ['audio/x-twinvq-plugin', ['vqe', 'vql']],\n    ['audio/x-vnd.audioexplosion.mjuicemediafile', 'mjf'],\n    ['audio/x-voc', 'voc'],\n    ['audio/x-wav', 'wav'],\n    ['audio/xm', 'xm'],\n    ['chemical/x-cdx', 'cdx'],\n    ['chemical/x-cif', 'cif'],\n    ['chemical/x-cmdf', 'cmdf'],\n    ['chemical/x-cml', 'cml'],\n    ['chemical/x-csml', 'csml'],\n    ['chemical/x-pdb', ['pdb', 'xyz']],\n    ['chemical/x-xyz', 'xyz'],\n    ['drawing/x-dwf', 'dwf'],\n    ['i-world/i-vrml', 'ivr'],\n    ['image/bmp', ['bmp', 'bm']],\n    ['image/cgm', 'cgm'],\n    ['image/cis-cod', 'cod'],\n    ['image/cmu-raster', ['ras', 'rast']],\n    ['image/fif', 'fif'],\n    ['image/florian', ['flo', 'turbot']],\n    ['image/g3fax', 'g3'],\n    ['image/gif', 'gif'],\n    ['image/ief', ['ief', 'iefs']],\n    ['image/jpeg', ['jpeg', 'jpe', 'jpg', 'jfif', 'jfif-tbnl']],\n    ['image/jutvision', 'jut'],\n    ['image/ktx', 'ktx'],\n    ['image/naplps', ['nap', 'naplps']],\n    ['image/pict', ['pic', 'pict']],\n    ['image/pipeg', 'jfif'],\n    ['image/pjpeg', ['jfif', 'jpe', 'jpeg', 'jpg']],\n    ['image/png', ['png', 'x-png']],\n    ['image/prs.btif', 'btif'],\n    ['image/svg+xml', 'svg'],\n    ['image/tiff', ['tif', 'tiff']],\n    ['image/vasa', 'mcf'],\n    ['image/vnd.adobe.photoshop', 'psd'],\n    ['image/vnd.dece.graphic', 'uvi'],\n    ['image/vnd.djvu', 'djvu'],\n    ['image/vnd.dvb.subtitle', 'sub'],\n    ['image/vnd.dwg', ['dwg', 'dxf', 'svf']],\n    ['image/vnd.dxf', 'dxf'],\n    ['image/vnd.fastbidsheet', 'fbs'],\n    ['image/vnd.fpx', 'fpx'],\n    ['image/vnd.fst', 'fst'],\n    ['image/vnd.fujixerox.edmics-mmr', 'mmr'],\n    ['image/vnd.fujixerox.edmics-rlc', 'rlc'],\n    ['image/vnd.ms-modi', 'mdi'],\n    ['image/vnd.net-fpx', ['fpx', 'npx']],\n    ['image/vnd.rn-realflash', 'rf'],\n    ['image/vnd.rn-realpix', 'rp'],\n    ['image/vnd.wap.wbmp', 'wbmp'],\n    ['image/vnd.xiff', 'xif'],\n    ['image/webp', 'webp'],\n    ['image/x-cmu-raster', 'ras'],\n    ['image/x-cmx', 'cmx'],\n    ['image/x-dwg', ['dwg', 'dxf', 'svf']],\n    ['image/x-freehand', 'fh'],\n    ['image/x-icon', 'ico'],\n    ['image/x-jg', 'art'],\n    ['image/x-jps', 'jps'],\n    ['image/x-niff', ['niff', 'nif']],\n    ['image/x-pcx', 'pcx'],\n    ['image/x-pict', ['pct', 'pic']],\n    ['image/x-portable-anymap', 'pnm'],\n    ['image/x-portable-bitmap', 'pbm'],\n    ['image/x-portable-graymap', 'pgm'],\n    ['image/x-portable-greymap', 'pgm'],\n    ['image/x-portable-pixmap', 'ppm'],\n    ['image/x-quicktime', ['qif', 'qti', 'qtif']],\n    ['image/x-rgb', 'rgb'],\n    ['image/x-tiff', ['tif', 'tiff']],\n    ['image/x-windows-bmp', 'bmp'],\n    ['image/x-xbitmap', 'xbm'],\n    ['image/x-xbm', 'xbm'],\n    ['image/x-xpixmap', ['xpm', 'pm']],\n    ['image/x-xwd', 'xwd'],\n    ['image/x-xwindowdump', 'xwd'],\n    ['image/xbm', 'xbm'],\n    ['image/xpm', 'xpm'],\n    ['message/rfc822', ['eml', 'mht', 'mhtml', 'nws', 'mime']],\n    ['model/iges', ['iges', 'igs']],\n    ['model/mesh', 'msh'],\n    ['model/vnd.collada+xml', 'dae'],\n    ['model/vnd.dwf', 'dwf'],\n    ['model/vnd.gdl', 'gdl'],\n    ['model/vnd.gtw', 'gtw'],\n    ['model/vnd.mts', 'mts'],\n    ['model/vnd.vtu', 'vtu'],\n    ['model/vrml', ['vrml', 'wrl', 'wrz']],\n    ['model/x-pov', 'pov'],\n    ['multipart/x-gzip', 'gzip'],\n    ['multipart/x-ustar', 'ustar'],\n    ['multipart/x-zip', 'zip'],\n    ['music/crescendo', ['mid', 'midi']],\n    ['music/x-karaoke', 'kar'],\n    ['paleovu/x-pv', 'pvu'],\n    ['text/asp', 'asp'],\n    ['text/calendar', 'ics'],\n    ['text/css', 'css'],\n    ['text/csv', 'csv'],\n    ['text/ecmascript', 'js'],\n    ['text/h323', '323'],\n    ['text/html', ['html', 'htm', 'stm', 'acgi', 'htmls', 'htx', 'shtml']],\n    ['text/iuls', 'uls'],\n    ['text/javascript', 'js'],\n    ['text/mcf', 'mcf'],\n    ['text/n3', 'n3'],\n    ['text/pascal', 'pas'],\n    [\n        'text/plain',\n        [\n            'txt',\n            'bas',\n            'c',\n            'h',\n            'c++',\n            'cc',\n            'com',\n            'conf',\n            'cxx',\n            'def',\n            'f',\n            'f90',\n            'for',\n            'g',\n            'hh',\n            'idc',\n            'jav',\n            'java',\n            'list',\n            'log',\n            'lst',\n            'm',\n            'mar',\n            'pl',\n            'sdml',\n            'text'\n        ]\n    ],\n    ['text/plain-bas', 'par'],\n    ['text/prs.lines.tag', 'dsc'],\n    ['text/richtext', ['rtx', 'rt', 'rtf']],\n    ['text/scriplet', 'wsc'],\n    ['text/scriptlet', 'sct'],\n    ['text/sgml', ['sgm', 'sgml']],\n    ['text/tab-separated-values', 'tsv'],\n    ['text/troff', 't'],\n    ['text/turtle', 'ttl'],\n    ['text/uri-list', ['uni', 'unis', 'uri', 'uris']],\n    ['text/vnd.abc', 'abc'],\n    ['text/vnd.curl', 'curl'],\n    ['text/vnd.curl.dcurl', 'dcurl'],\n    ['text/vnd.curl.mcurl', 'mcurl'],\n    ['text/vnd.curl.scurl', 'scurl'],\n    ['text/vnd.fly', 'fly'],\n    ['text/vnd.fmi.flexstor', 'flx'],\n    ['text/vnd.graphviz', 'gv'],\n    ['text/vnd.in3d.3dml', '3dml'],\n    ['text/vnd.in3d.spot', 'spot'],\n    ['text/vnd.rn-realtext', 'rt'],\n    ['text/vnd.sun.j2me.app-descriptor', 'jad'],\n    ['text/vnd.wap.wml', 'wml'],\n    ['text/vnd.wap.wmlscript', 'wmls'],\n    ['text/webviewhtml', 'htt'],\n    ['text/x-asm', ['asm', 's']],\n    ['text/x-audiosoft-intra', 'aip'],\n    ['text/x-c', ['c', 'cc', 'cpp']],\n    ['text/x-component', 'htc'],\n    ['text/x-fortran', ['for', 'f', 'f77', 'f90']],\n    ['text/x-h', ['h', 'hh']],\n    ['text/x-java-source', ['java', 'jav']],\n    ['text/x-java-source,java', 'java'],\n    ['text/x-la-asf', 'lsx'],\n    ['text/x-m', 'm'],\n    ['text/x-pascal', 'p'],\n    ['text/x-script', 'hlb'],\n    ['text/x-script.csh', 'csh'],\n    ['text/x-script.elisp', 'el'],\n    ['text/x-script.guile', 'scm'],\n    ['text/x-script.ksh', 'ksh'],\n    ['text/x-script.lisp', 'lsp'],\n    ['text/x-script.perl', 'pl'],\n    ['text/x-script.perl-module', 'pm'],\n    ['text/x-script.phyton', 'py'],\n    ['text/x-script.rexx', 'rexx'],\n    ['text/x-script.scheme', 'scm'],\n    ['text/x-script.sh', 'sh'],\n    ['text/x-script.tcl', 'tcl'],\n    ['text/x-script.tcsh', 'tcsh'],\n    ['text/x-script.zsh', 'zsh'],\n    ['text/x-server-parsed-html', ['shtml', 'ssi']],\n    ['text/x-setext', 'etx'],\n    ['text/x-sgml', ['sgm', 'sgml']],\n    ['text/x-speech', ['spc', 'talk']],\n    ['text/x-uil', 'uil'],\n    ['text/x-uuencode', ['uu', 'uue']],\n    ['text/x-vcalendar', 'vcs'],\n    ['text/x-vcard', 'vcf'],\n    ['text/xml', 'xml'],\n    ['video/3gpp', '3gp'],\n    ['video/3gpp2', '3g2'],\n    ['video/animaflex', 'afl'],\n    ['video/avi', 'avi'],\n    ['video/avs-video', 'avs'],\n    ['video/dl', 'dl'],\n    ['video/fli', 'fli'],\n    ['video/gl', 'gl'],\n    ['video/h261', 'h261'],\n    ['video/h263', 'h263'],\n    ['video/h264', 'h264'],\n    ['video/jpeg', 'jpgv'],\n    ['video/jpm', 'jpm'],\n    ['video/mj2', 'mj2'],\n    ['video/mp4', 'mp4'],\n    ['video/mpeg', ['mpeg', 'mp2', 'mpa', 'mpe', 'mpg', 'mpv2', 'm1v', 'm2v', 'mp3']],\n    ['video/msvideo', 'avi'],\n    ['video/ogg', 'ogv'],\n    ['video/quicktime', ['mov', 'qt', 'moov']],\n    ['video/vdo', 'vdo'],\n    ['video/vivo', ['viv', 'vivo']],\n    ['video/vnd.dece.hd', 'uvh'],\n    ['video/vnd.dece.mobile', 'uvm'],\n    ['video/vnd.dece.pd', 'uvp'],\n    ['video/vnd.dece.sd', 'uvs'],\n    ['video/vnd.dece.video', 'uvv'],\n    ['video/vnd.fvt', 'fvt'],\n    ['video/vnd.mpegurl', 'mxu'],\n    ['video/vnd.ms-playready.media.pyv', 'pyv'],\n    ['video/vnd.rn-realvideo', 'rv'],\n    ['video/vnd.uvvu.mp4', 'uvu'],\n    ['video/vnd.vivo', ['viv', 'vivo']],\n    ['video/vosaic', 'vos'],\n    ['video/webm', 'webm'],\n    ['video/x-amt-demorun', 'xdr'],\n    ['video/x-amt-showrun', 'xsr'],\n    ['video/x-atomic3d-feature', 'fmf'],\n    ['video/x-dl', 'dl'],\n    ['video/x-dv', ['dif', 'dv']],\n    ['video/x-f4v', 'f4v'],\n    ['video/x-fli', 'fli'],\n    ['video/x-flv', 'flv'],\n    ['video/x-gl', 'gl'],\n    ['video/x-isvideo', 'isu'],\n    ['video/x-la-asf', ['lsf', 'lsx']],\n    ['video/x-m4v', 'm4v'],\n    ['video/x-motion-jpeg', 'mjpg'],\n    ['video/x-mpeg', ['mp3', 'mp2']],\n    ['video/x-mpeq2a', 'mp2'],\n    ['video/x-ms-asf', ['asf', 'asr', 'asx']],\n    ['video/x-ms-asf-plugin', 'asx'],\n    ['video/x-ms-wm', 'wm'],\n    ['video/x-ms-wmv', 'wmv'],\n    ['video/x-ms-wmx', 'wmx'],\n    ['video/x-ms-wvx', 'wvx'],\n    ['video/x-msvideo', 'avi'],\n    ['video/x-qtc', 'qtc'],\n    ['video/x-scm', 'scm'],\n    ['video/x-sgi-movie', ['movie', 'mv']],\n    ['windows/metafile', 'wmf'],\n    ['www/mime', 'mime'],\n    ['x-conference/x-cooltalk', 'ice'],\n    ['x-music/x-midi', ['mid', 'midi']],\n    ['x-world/x-3dmf', ['3dm', '3dmf', 'qd3', 'qd3d']],\n    ['x-world/x-svr', 'svr'],\n    ['x-world/x-vrml', ['flr', 'vrml', 'wrl', 'wrz', 'xaf', 'xof']],\n    ['x-world/x-vrt', 'vrt'],\n    ['xgl/drawing', 'xgz'],\n    ['xgl/movie', 'xmz']\n]);\nconst extensions = new Map([\n    ['123', 'application/vnd.lotus-1-2-3'],\n    ['323', 'text/h323'],\n    ['*', 'application/octet-stream'],\n    ['3dm', 'x-world/x-3dmf'],\n    ['3dmf', 'x-world/x-3dmf'],\n    ['3dml', 'text/vnd.in3d.3dml'],\n    ['3g2', 'video/3gpp2'],\n    ['3gp', 'video/3gpp'],\n    ['7z', 'application/x-7z-compressed'],\n    ['a', 'application/octet-stream'],\n    ['aab', 'application/x-authorware-bin'],\n    ['aac', 'audio/x-aac'],\n    ['aam', 'application/x-authorware-map'],\n    ['aas', 'application/x-authorware-seg'],\n    ['abc', 'text/vnd.abc'],\n    ['abw', 'application/x-abiword'],\n    ['ac', 'application/pkix-attr-cert'],\n    ['acc', 'application/vnd.americandynamics.acc'],\n    ['ace', 'application/x-ace-compressed'],\n    ['acgi', 'text/html'],\n    ['acu', 'application/vnd.acucobol'],\n    ['acx', 'application/internet-property-stream'],\n    ['adp', 'audio/adpcm'],\n    ['aep', 'application/vnd.audiograph'],\n    ['afl', 'video/animaflex'],\n    ['afp', 'application/vnd.ibm.modcap'],\n    ['ahead', 'application/vnd.ahead.space'],\n    ['ai', 'application/postscript'],\n    ['aif', ['audio/aiff', 'audio/x-aiff']],\n    ['aifc', ['audio/aiff', 'audio/x-aiff']],\n    ['aiff', ['audio/aiff', 'audio/x-aiff']],\n    ['aim', 'application/x-aim'],\n    ['aip', 'text/x-audiosoft-intra'],\n    ['air', 'application/vnd.adobe.air-application-installer-package+zip'],\n    ['ait', 'application/vnd.dvb.ait'],\n    ['ami', 'application/vnd.amiga.ami'],\n    ['ani', 'application/x-navi-animation'],\n    ['aos', 'application/x-nokia-9000-communicator-add-on-software'],\n    ['apk', 'application/vnd.android.package-archive'],\n    ['application', 'application/x-ms-application'],\n    ['apr', 'application/vnd.lotus-approach'],\n    ['aps', 'application/mime'],\n    ['arc', 'application/octet-stream'],\n    ['arj', ['application/arj', 'application/octet-stream']],\n    ['art', 'image/x-jg'],\n    ['asf', 'video/x-ms-asf'],\n    ['asm', 'text/x-asm'],\n    ['aso', 'application/vnd.accpac.simply.aso'],\n    ['asp', 'text/asp'],\n    ['asr', 'video/x-ms-asf'],\n    ['asx', ['video/x-ms-asf', 'application/x-mplayer2', 'video/x-ms-asf-plugin']],\n    ['atc', 'application/vnd.acucorp'],\n    ['atomcat', 'application/atomcat+xml'],\n    ['atomsvc', 'application/atomsvc+xml'],\n    ['atx', 'application/vnd.antix.game-component'],\n    ['au', ['audio/basic', 'audio/x-au']],\n    ['avi', ['video/avi', 'video/msvideo', 'application/x-troff-msvideo', 'video/x-msvideo']],\n    ['avs', 'video/avs-video'],\n    ['aw', 'application/applixware'],\n    ['axs', 'application/olescript'],\n    ['azf', 'application/vnd.airzip.filesecure.azf'],\n    ['azs', 'application/vnd.airzip.filesecure.azs'],\n    ['azw', 'application/vnd.amazon.ebook'],\n    ['bas', 'text/plain'],\n    ['bcpio', 'application/x-bcpio'],\n    ['bdf', 'application/x-font-bdf'],\n    ['bdm', 'application/vnd.syncml.dm+wbxml'],\n    ['bed', 'application/vnd.realvnc.bed'],\n    ['bh2', 'application/vnd.fujitsu.oasysprs'],\n    ['bin', ['application/octet-stream', 'application/mac-binary', 'application/macbinary', 'application/x-macbinary', 'application/x-binary']],\n    ['bm', 'image/bmp'],\n    ['bmi', 'application/vnd.bmi'],\n    ['bmp', ['image/bmp', 'image/x-windows-bmp']],\n    ['boo', 'application/book'],\n    ['book', 'application/book'],\n    ['box', 'application/vnd.previewsystems.box'],\n    ['boz', 'application/x-bzip2'],\n    ['bsh', 'application/x-bsh'],\n    ['btif', 'image/prs.btif'],\n    ['bz', 'application/x-bzip'],\n    ['bz2', 'application/x-bzip2'],\n    ['c', ['text/plain', 'text/x-c']],\n    ['c++', 'text/plain'],\n    ['c11amc', 'application/vnd.cluetrust.cartomobile-config'],\n    ['c11amz', 'application/vnd.cluetrust.cartomobile-config-pkg'],\n    ['c4g', 'application/vnd.clonk.c4group'],\n    ['cab', 'application/vnd.ms-cab-compressed'],\n    ['car', 'application/vnd.curl.car'],\n    ['cat', ['application/vnd.ms-pkiseccat', 'application/vnd.ms-pki.seccat']],\n    ['cc', ['text/plain', 'text/x-c']],\n    ['ccad', 'application/clariscad'],\n    ['cco', 'application/x-cocoa'],\n    ['ccxml', 'application/ccxml+xml,'],\n    ['cdbcmsg', 'application/vnd.contact.cmsg'],\n    ['cdf', ['application/cdf', 'application/x-cdf', 'application/x-netcdf']],\n    ['cdkey', 'application/vnd.mediastation.cdkey'],\n    ['cdmia', 'application/cdmi-capability'],\n    ['cdmic', 'application/cdmi-container'],\n    ['cdmid', 'application/cdmi-domain'],\n    ['cdmio', 'application/cdmi-object'],\n    ['cdmiq', 'application/cdmi-queue'],\n    ['cdx', 'chemical/x-cdx'],\n    ['cdxml', 'application/vnd.chemdraw+xml'],\n    ['cdy', 'application/vnd.cinderella'],\n    ['cer', ['application/pkix-cert', 'application/x-x509-ca-cert']],\n    ['cgm', 'image/cgm'],\n    ['cha', 'application/x-chat'],\n    ['chat', 'application/x-chat'],\n    ['chm', 'application/vnd.ms-htmlhelp'],\n    ['chrt', 'application/vnd.kde.kchart'],\n    ['cif', 'chemical/x-cif'],\n    ['cii', 'application/vnd.anser-web-certificate-issue-initiation'],\n    ['cil', 'application/vnd.ms-artgalry'],\n    ['cla', 'application/vnd.claymore'],\n    ['class', ['application/octet-stream', 'application/java', 'application/java-byte-code', 'application/java-vm', 'application/x-java-class']],\n    ['clkk', 'application/vnd.crick.clicker.keyboard'],\n    ['clkp', 'application/vnd.crick.clicker.palette'],\n    ['clkt', 'application/vnd.crick.clicker.template'],\n    ['clkw', 'application/vnd.crick.clicker.wordbank'],\n    ['clkx', 'application/vnd.crick.clicker'],\n    ['clp', 'application/x-msclip'],\n    ['cmc', 'application/vnd.cosmocaller'],\n    ['cmdf', 'chemical/x-cmdf'],\n    ['cml', 'chemical/x-cml'],\n    ['cmp', 'application/vnd.yellowriver-custom-menu'],\n    ['cmx', 'image/x-cmx'],\n    ['cod', ['image/cis-cod', 'application/vnd.rim.cod']],\n    ['com', ['application/octet-stream', 'text/plain']],\n    ['conf', 'text/plain'],\n    ['cpio', 'application/x-cpio'],\n    ['cpp', 'text/x-c'],\n    ['cpt', ['application/mac-compactpro', 'application/x-compactpro', 'application/x-cpt']],\n    ['crd', 'application/x-mscardfile'],\n    ['crl', ['application/pkix-crl', 'application/pkcs-crl']],\n    ['crt', ['application/pkix-cert', 'application/x-x509-user-cert', 'application/x-x509-ca-cert']],\n    ['cryptonote', 'application/vnd.rig.cryptonote'],\n    ['csh', ['text/x-script.csh', 'application/x-csh']],\n    ['csml', 'chemical/x-csml'],\n    ['csp', 'application/vnd.commonspace'],\n    ['css', ['text/css', 'application/x-pointplus']],\n    ['csv', 'text/csv'],\n    ['cu', 'application/cu-seeme'],\n    ['curl', 'text/vnd.curl'],\n    ['cww', 'application/prs.cww'],\n    ['cxx', 'text/plain'],\n    ['dae', 'model/vnd.collada+xml'],\n    ['daf', 'application/vnd.mobius.daf'],\n    ['davmount', 'application/davmount+xml'],\n    ['dcr', 'application/x-director'],\n    ['dcurl', 'text/vnd.curl.dcurl'],\n    ['dd2', 'application/vnd.oma.dd2+xml'],\n    ['ddd', 'application/vnd.fujixerox.ddd'],\n    ['deb', 'application/x-debian-package'],\n    ['deepv', 'application/x-deepv'],\n    ['def', 'text/plain'],\n    ['der', 'application/x-x509-ca-cert'],\n    ['dfac', 'application/vnd.dreamfactory'],\n    ['dif', 'video/x-dv'],\n    ['dir', 'application/x-director'],\n    ['dis', 'application/vnd.mobius.dis'],\n    ['djvu', 'image/vnd.djvu'],\n    ['dl', ['video/dl', 'video/x-dl']],\n    ['dll', 'application/x-msdownload'],\n    ['dms', 'application/octet-stream'],\n    ['dna', 'application/vnd.dna'],\n    ['doc', 'application/msword'],\n    ['docm', 'application/vnd.ms-word.document.macroenabled.12'],\n    ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],\n    ['dot', 'application/msword'],\n    ['dotm', 'application/vnd.ms-word.template.macroenabled.12'],\n    ['dotx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template'],\n    ['dp', ['application/commonground', 'application/vnd.osgi.dp']],\n    ['dpg', 'application/vnd.dpgraph'],\n    ['dra', 'audio/vnd.dra'],\n    ['drw', 'application/drafting'],\n    ['dsc', 'text/prs.lines.tag'],\n    ['dssc', 'application/dssc+der'],\n    ['dtb', 'application/x-dtbook+xml'],\n    ['dtd', 'application/xml-dtd'],\n    ['dts', 'audio/vnd.dts'],\n    ['dtshd', 'audio/vnd.dts.hd'],\n    ['dump', 'application/octet-stream'],\n    ['dv', 'video/x-dv'],\n    ['dvi', 'application/x-dvi'],\n    ['dwf', ['model/vnd.dwf', 'drawing/x-dwf']],\n    ['dwg', ['application/acad', 'image/vnd.dwg', 'image/x-dwg']],\n    ['dxf', ['application/dxf', 'image/vnd.dwg', 'image/vnd.dxf', 'image/x-dwg']],\n    ['dxp', 'application/vnd.spotfire.dxp'],\n    ['dxr', 'application/x-director'],\n    ['ecelp4800', 'audio/vnd.nuera.ecelp4800'],\n    ['ecelp7470', 'audio/vnd.nuera.ecelp7470'],\n    ['ecelp9600', 'audio/vnd.nuera.ecelp9600'],\n    ['edm', 'application/vnd.novadigm.edm'],\n    ['edx', 'application/vnd.novadigm.edx'],\n    ['efif', 'application/vnd.picsel'],\n    ['ei6', 'application/vnd.pg.osasli'],\n    ['el', 'text/x-script.elisp'],\n    ['elc', ['application/x-elc', 'application/x-bytecode.elisp']],\n    ['eml', 'message/rfc822'],\n    ['emma', 'application/emma+xml'],\n    ['env', 'application/x-envoy'],\n    ['eol', 'audio/vnd.digital-winds'],\n    ['eot', 'application/vnd.ms-fontobject'],\n    ['eps', 'application/postscript'],\n    ['epub', 'application/epub+zip'],\n    ['es', ['application/ecmascript', 'application/x-esrehber']],\n    ['es3', 'application/vnd.eszigno3+xml'],\n    ['esf', 'application/vnd.epson.esf'],\n    ['etx', 'text/x-setext'],\n    ['evy', ['application/envoy', 'application/x-envoy']],\n    ['exe', ['application/octet-stream', 'application/x-msdownload']],\n    ['exi', 'application/exi'],\n    ['ext', 'application/vnd.novadigm.ext'],\n    ['ez2', 'application/vnd.ezpix-album'],\n    ['ez3', 'application/vnd.ezpix-package'],\n    ['f', ['text/plain', 'text/x-fortran']],\n    ['f4v', 'video/x-f4v'],\n    ['f77', 'text/x-fortran'],\n    ['f90', ['text/plain', 'text/x-fortran']],\n    ['fbs', 'image/vnd.fastbidsheet'],\n    ['fcs', 'application/vnd.isac.fcs'],\n    ['fdf', 'application/vnd.fdf'],\n    ['fe_launch', 'application/vnd.denovo.fcselayout-link'],\n    ['fg5', 'application/vnd.fujitsu.oasysgp'],\n    ['fh', 'image/x-freehand'],\n    ['fif', ['application/fractals', 'image/fif']],\n    ['fig', 'application/x-xfig'],\n    ['fli', ['video/fli', 'video/x-fli']],\n    ['flo', ['image/florian', 'application/vnd.micrografx.flo']],\n    ['flr', 'x-world/x-vrml'],\n    ['flv', 'video/x-flv'],\n    ['flw', 'application/vnd.kde.kivio'],\n    ['flx', 'text/vnd.fmi.flexstor'],\n    ['fly', 'text/vnd.fly'],\n    ['fm', 'application/vnd.framemaker'],\n    ['fmf', 'video/x-atomic3d-feature'],\n    ['fnc', 'application/vnd.frogans.fnc'],\n    ['for', ['text/plain', 'text/x-fortran']],\n    ['fpx', ['image/vnd.fpx', 'image/vnd.net-fpx']],\n    ['frl', 'application/freeloader'],\n    ['fsc', 'application/vnd.fsc.weblaunch'],\n    ['fst', 'image/vnd.fst'],\n    ['ftc', 'application/vnd.fluxtime.clip'],\n    ['fti', 'application/vnd.anser-web-funds-transfer-initiation'],\n    ['funk', 'audio/make'],\n    ['fvt', 'video/vnd.fvt'],\n    ['fxp', 'application/vnd.adobe.fxp'],\n    ['fzs', 'application/vnd.fuzzysheet'],\n    ['g', 'text/plain'],\n    ['g2w', 'application/vnd.geoplan'],\n    ['g3', 'image/g3fax'],\n    ['g3w', 'application/vnd.geospace'],\n    ['gac', 'application/vnd.groove-account'],\n    ['gdl', 'model/vnd.gdl'],\n    ['geo', 'application/vnd.dynageo'],\n    ['gex', 'application/vnd.geometry-explorer'],\n    ['ggb', 'application/vnd.geogebra.file'],\n    ['ggt', 'application/vnd.geogebra.tool'],\n    ['ghf', 'application/vnd.groove-help'],\n    ['gif', 'image/gif'],\n    ['gim', 'application/vnd.groove-identity-message'],\n    ['gl', ['video/gl', 'video/x-gl']],\n    ['gmx', 'application/vnd.gmx'],\n    ['gnumeric', 'application/x-gnumeric'],\n    ['gph', 'application/vnd.flographit'],\n    ['gqf', 'application/vnd.grafeq'],\n    ['gram', 'application/srgs'],\n    ['grv', 'application/vnd.groove-injector'],\n    ['grxml', 'application/srgs+xml'],\n    ['gsd', 'audio/x-gsm'],\n    ['gsf', 'application/x-font-ghostscript'],\n    ['gsm', 'audio/x-gsm'],\n    ['gsp', 'application/x-gsp'],\n    ['gss', 'application/x-gss'],\n    ['gtar', 'application/x-gtar'],\n    ['gtm', 'application/vnd.groove-tool-message'],\n    ['gtw', 'model/vnd.gtw'],\n    ['gv', 'text/vnd.graphviz'],\n    ['gxt', 'application/vnd.geonext'],\n    ['gz', ['application/x-gzip', 'application/x-compressed']],\n    ['gzip', ['multipart/x-gzip', 'application/x-gzip']],\n    ['h', ['text/plain', 'text/x-h']],\n    ['h261', 'video/h261'],\n    ['h263', 'video/h263'],\n    ['h264', 'video/h264'],\n    ['hal', 'application/vnd.hal+xml'],\n    ['hbci', 'application/vnd.hbci'],\n    ['hdf', 'application/x-hdf'],\n    ['help', 'application/x-helpfile'],\n    ['hgl', 'application/vnd.hp-hpgl'],\n    ['hh', ['text/plain', 'text/x-h']],\n    ['hlb', 'text/x-script'],\n    ['hlp', ['application/winhlp', 'application/hlp', 'application/x-helpfile', 'application/x-winhelp']],\n    ['hpg', 'application/vnd.hp-hpgl'],\n    ['hpgl', 'application/vnd.hp-hpgl'],\n    ['hpid', 'application/vnd.hp-hpid'],\n    ['hps', 'application/vnd.hp-hps'],\n    [\n        'hqx',\n        [\n            'application/mac-binhex40',\n            'application/binhex',\n            'application/binhex4',\n            'application/mac-binhex',\n            'application/x-binhex40',\n            'application/x-mac-binhex40'\n        ]\n    ],\n    ['hta', 'application/hta'],\n    ['htc', 'text/x-component'],\n    ['htke', 'application/vnd.kenameaapp'],\n    ['htm', 'text/html'],\n    ['html', 'text/html'],\n    ['htmls', 'text/html'],\n    ['htt', 'text/webviewhtml'],\n    ['htx', 'text/html'],\n    ['hvd', 'application/vnd.yamaha.hv-dic'],\n    ['hvp', 'application/vnd.yamaha.hv-voice'],\n    ['hvs', 'application/vnd.yamaha.hv-script'],\n    ['i2g', 'application/vnd.intergeo'],\n    ['icc', 'application/vnd.iccprofile'],\n    ['ice', 'x-conference/x-cooltalk'],\n    ['ico', 'image/x-icon'],\n    ['ics', 'text/calendar'],\n    ['idc', 'text/plain'],\n    ['ief', 'image/ief'],\n    ['iefs', 'image/ief'],\n    ['ifm', 'application/vnd.shana.informed.formdata'],\n    ['iges', ['application/iges', 'model/iges']],\n    ['igl', 'application/vnd.igloader'],\n    ['igm', 'application/vnd.insors.igm'],\n    ['igs', ['application/iges', 'model/iges']],\n    ['igx', 'application/vnd.micrografx.igx'],\n    ['iif', 'application/vnd.shana.informed.interchange'],\n    ['iii', 'application/x-iphone'],\n    ['ima', 'application/x-ima'],\n    ['imap', 'application/x-httpd-imap'],\n    ['imp', 'application/vnd.accpac.simply.imp'],\n    ['ims', 'application/vnd.ms-ims'],\n    ['inf', 'application/inf'],\n    ['ins', ['application/x-internet-signup', 'application/x-internett-signup']],\n    ['ip', 'application/x-ip2'],\n    ['ipfix', 'application/ipfix'],\n    ['ipk', 'application/vnd.shana.informed.package'],\n    ['irm', 'application/vnd.ibm.rights-management'],\n    ['irp', 'application/vnd.irepository.package+xml'],\n    ['isp', 'application/x-internet-signup'],\n    ['isu', 'video/x-isvideo'],\n    ['it', 'audio/it'],\n    ['itp', 'application/vnd.shana.informed.formtemplate'],\n    ['iv', 'application/x-inventor'],\n    ['ivp', 'application/vnd.immervision-ivp'],\n    ['ivr', 'i-world/i-vrml'],\n    ['ivu', 'application/vnd.immervision-ivu'],\n    ['ivy', 'application/x-livescreen'],\n    ['jad', 'text/vnd.sun.j2me.app-descriptor'],\n    ['jam', ['application/vnd.jam', 'audio/x-jam']],\n    ['jar', 'application/java-archive'],\n    ['jav', ['text/plain', 'text/x-java-source']],\n    ['java', ['text/plain', 'text/x-java-source,java', 'text/x-java-source']],\n    ['jcm', 'application/x-java-commerce'],\n    ['jfif', ['image/pipeg', 'image/jpeg', 'image/pjpeg']],\n    ['jfif-tbnl', 'image/jpeg'],\n    ['jisp', 'application/vnd.jisp'],\n    ['jlt', 'application/vnd.hp-jlyt'],\n    ['jnlp', 'application/x-java-jnlp-file'],\n    ['joda', 'application/vnd.joost.joda-archive'],\n    ['jpe', ['image/jpeg', 'image/pjpeg']],\n    ['jpeg', ['image/jpeg', 'image/pjpeg']],\n    ['jpg', ['image/jpeg', 'image/pjpeg']],\n    ['jpgv', 'video/jpeg'],\n    ['jpm', 'video/jpm'],\n    ['jps', 'image/x-jps'],\n    ['js', ['application/javascript', 'application/ecmascript', 'text/javascript', 'text/ecmascript', 'application/x-javascript']],\n    ['json', 'application/json'],\n    ['jut', 'image/jutvision'],\n    ['kar', ['audio/midi', 'music/x-karaoke']],\n    ['karbon', 'application/vnd.kde.karbon'],\n    ['kfo', 'application/vnd.kde.kformula'],\n    ['kia', 'application/vnd.kidspiration'],\n    ['kml', 'application/vnd.google-earth.kml+xml'],\n    ['kmz', 'application/vnd.google-earth.kmz'],\n    ['kne', 'application/vnd.kinar'],\n    ['kon', 'application/vnd.kde.kontour'],\n    ['kpr', 'application/vnd.kde.kpresenter'],\n    ['ksh', ['application/x-ksh', 'text/x-script.ksh']],\n    ['ksp', 'application/vnd.kde.kspread'],\n    ['ktx', 'image/ktx'],\n    ['ktz', 'application/vnd.kahootz'],\n    ['kwd', 'application/vnd.kde.kword'],\n    ['la', ['audio/nspaudio', 'audio/x-nspaudio']],\n    ['lam', 'audio/x-liveaudio'],\n    ['lasxml', 'application/vnd.las.las+xml'],\n    ['latex', 'application/x-latex'],\n    ['lbd', 'application/vnd.llamagraphics.life-balance.desktop'],\n    ['lbe', 'application/vnd.llamagraphics.life-balance.exchange+xml'],\n    ['les', 'application/vnd.hhe.lesson-player'],\n    ['lha', ['application/octet-stream', 'application/lha', 'application/x-lha']],\n    ['lhx', 'application/octet-stream'],\n    ['link66', 'application/vnd.route66.link66+xml'],\n    ['list', 'text/plain'],\n    ['lma', ['audio/nspaudio', 'audio/x-nspaudio']],\n    ['log', 'text/plain'],\n    ['lrm', 'application/vnd.ms-lrm'],\n    ['lsf', 'video/x-la-asf'],\n    ['lsp', ['application/x-lisp', 'text/x-script.lisp']],\n    ['lst', 'text/plain'],\n    ['lsx', ['video/x-la-asf', 'text/x-la-asf']],\n    ['ltf', 'application/vnd.frogans.ltf'],\n    ['ltx', 'application/x-latex'],\n    ['lvp', 'audio/vnd.lucent.voice'],\n    ['lwp', 'application/vnd.lotus-wordpro'],\n    ['lzh', ['application/octet-stream', 'application/x-lzh']],\n    ['lzx', ['application/lzx', 'application/octet-stream', 'application/x-lzx']],\n    ['m', ['text/plain', 'text/x-m']],\n    ['m13', 'application/x-msmediaview'],\n    ['m14', 'application/x-msmediaview'],\n    ['m1v', 'video/mpeg'],\n    ['m21', 'application/mp21'],\n    ['m2a', 'audio/mpeg'],\n    ['m2v', 'video/mpeg'],\n    ['m3u', ['audio/x-mpegurl', 'audio/x-mpequrl']],\n    ['m3u8', 'application/vnd.apple.mpegurl'],\n    ['m4v', 'video/x-m4v'],\n    ['ma', 'application/mathematica'],\n    ['mads', 'application/mads+xml'],\n    ['mag', 'application/vnd.ecowin.chart'],\n    ['man', 'application/x-troff-man'],\n    ['map', 'application/x-navimap'],\n    ['mar', 'text/plain'],\n    ['mathml', 'application/mathml+xml'],\n    ['mbd', 'application/mbedlet'],\n    ['mbk', 'application/vnd.mobius.mbk'],\n    ['mbox', 'application/mbox'],\n    ['mc$', 'application/x-magic-cap-package-1.0'],\n    ['mc1', 'application/vnd.medcalcdata'],\n    ['mcd', ['application/mcad', 'application/vnd.mcd', 'application/x-mathcad']],\n    ['mcf', ['image/vasa', 'text/mcf']],\n    ['mcp', 'application/netmc'],\n    ['mcurl', 'text/vnd.curl.mcurl'],\n    ['mdb', 'application/x-msaccess'],\n    ['mdi', 'image/vnd.ms-modi'],\n    ['me', 'application/x-troff-me'],\n    ['meta4', 'application/metalink4+xml'],\n    ['mets', 'application/mets+xml'],\n    ['mfm', 'application/vnd.mfmp'],\n    ['mgp', 'application/vnd.osgeo.mapguide.package'],\n    ['mgz', 'application/vnd.proteus.magazine'],\n    ['mht', 'message/rfc822'],\n    ['mhtml', 'message/rfc822'],\n    ['mid', ['audio/mid', 'audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],\n    ['midi', ['audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],\n    ['mif', ['application/vnd.mif', 'application/x-mif', 'application/x-frame']],\n    ['mime', ['message/rfc822', 'www/mime']],\n    ['mj2', 'video/mj2'],\n    ['mjf', 'audio/x-vnd.audioexplosion.mjuicemediafile'],\n    ['mjpg', 'video/x-motion-jpeg'],\n    ['mlp', 'application/vnd.dolby.mlp'],\n    ['mm', ['application/base64', 'application/x-meme']],\n    ['mmd', 'application/vnd.chipnuts.karaoke-mmd'],\n    ['mme', 'application/base64'],\n    ['mmf', 'application/vnd.smaf'],\n    ['mmr', 'image/vnd.fujixerox.edmics-mmr'],\n    ['mny', 'application/x-msmoney'],\n    ['mod', ['audio/mod', 'audio/x-mod']],\n    ['mods', 'application/mods+xml'],\n    ['moov', 'video/quicktime'],\n    ['mov', 'video/quicktime'],\n    ['movie', 'video/x-sgi-movie'],\n    ['mp2', ['video/mpeg', 'audio/mpeg', 'video/x-mpeg', 'audio/x-mpeg', 'video/x-mpeq2a']],\n    ['mp3', ['audio/mpeg', 'audio/mpeg3', 'video/mpeg', 'audio/x-mpeg-3', 'video/x-mpeg']],\n    ['mp4', ['video/mp4', 'application/mp4']],\n    ['mp4a', 'audio/mp4'],\n    ['mpa', ['video/mpeg', 'audio/mpeg']],\n    ['mpc', ['application/vnd.mophun.certificate', 'application/x-project']],\n    ['mpe', 'video/mpeg'],\n    ['mpeg', 'video/mpeg'],\n    ['mpg', ['video/mpeg', 'audio/mpeg']],\n    ['mpga', 'audio/mpeg'],\n    ['mpkg', 'application/vnd.apple.installer+xml'],\n    ['mpm', 'application/vnd.blueice.multipass'],\n    ['mpn', 'application/vnd.mophun.application'],\n    ['mpp', 'application/vnd.ms-project'],\n    ['mpt', 'application/x-project'],\n    ['mpv', 'application/x-project'],\n    ['mpv2', 'video/mpeg'],\n    ['mpx', 'application/x-project'],\n    ['mpy', 'application/vnd.ibm.minipay'],\n    ['mqy', 'application/vnd.mobius.mqy'],\n    ['mrc', 'application/marc'],\n    ['mrcx', 'application/marcxml+xml'],\n    ['ms', 'application/x-troff-ms'],\n    ['mscml', 'application/mediaservercontrol+xml'],\n    ['mseq', 'application/vnd.mseq'],\n    ['msf', 'application/vnd.epson.msf'],\n    ['msg', 'application/vnd.ms-outlook'],\n    ['msh', 'model/mesh'],\n    ['msl', 'application/vnd.mobius.msl'],\n    ['msty', 'application/vnd.muvee.style'],\n    ['mts', 'model/vnd.mts'],\n    ['mus', 'application/vnd.musician'],\n    ['musicxml', 'application/vnd.recordare.musicxml+xml'],\n    ['mv', 'video/x-sgi-movie'],\n    ['mvb', 'application/x-msmediaview'],\n    ['mwf', 'application/vnd.mfer'],\n    ['mxf', 'application/mxf'],\n    ['mxl', 'application/vnd.recordare.musicxml'],\n    ['mxml', 'application/xv+xml'],\n    ['mxs', 'application/vnd.triscape.mxs'],\n    ['mxu', 'video/vnd.mpegurl'],\n    ['my', 'audio/make'],\n    ['mzz', 'application/x-vnd.audioexplosion.mzz'],\n    ['n-gage', 'application/vnd.nokia.n-gage.symbian.install'],\n    ['n3', 'text/n3'],\n    ['nap', 'image/naplps'],\n    ['naplps', 'image/naplps'],\n    ['nbp', 'application/vnd.wolfram.player'],\n    ['nc', 'application/x-netcdf'],\n    ['ncm', 'application/vnd.nokia.configuration-message'],\n    ['ncx', 'application/x-dtbncx+xml'],\n    ['ngdat', 'application/vnd.nokia.n-gage.data'],\n    ['nif', 'image/x-niff'],\n    ['niff', 'image/x-niff'],\n    ['nix', 'application/x-mix-transfer'],\n    ['nlu', 'application/vnd.neurolanguage.nlu'],\n    ['nml', 'application/vnd.enliven'],\n    ['nnd', 'application/vnd.noblenet-directory'],\n    ['nns', 'application/vnd.noblenet-sealer'],\n    ['nnw', 'application/vnd.noblenet-web'],\n    ['npx', 'image/vnd.net-fpx'],\n    ['nsc', 'application/x-conference'],\n    ['nsf', 'application/vnd.lotus-notes'],\n    ['nvd', 'application/x-navidoc'],\n    ['nws', 'message/rfc822'],\n    ['o', 'application/octet-stream'],\n    ['oa2', 'application/vnd.fujitsu.oasys2'],\n    ['oa3', 'application/vnd.fujitsu.oasys3'],\n    ['oas', 'application/vnd.fujitsu.oasys'],\n    ['obd', 'application/x-msbinder'],\n    ['oda', 'application/oda'],\n    ['odb', 'application/vnd.oasis.opendocument.database'],\n    ['odc', 'application/vnd.oasis.opendocument.chart'],\n    ['odf', 'application/vnd.oasis.opendocument.formula'],\n    ['odft', 'application/vnd.oasis.opendocument.formula-template'],\n    ['odg', 'application/vnd.oasis.opendocument.graphics'],\n    ['odi', 'application/vnd.oasis.opendocument.image'],\n    ['odm', 'application/vnd.oasis.opendocument.text-master'],\n    ['odp', 'application/vnd.oasis.opendocument.presentation'],\n    ['ods', 'application/vnd.oasis.opendocument.spreadsheet'],\n    ['odt', 'application/vnd.oasis.opendocument.text'],\n    ['oga', 'audio/ogg'],\n    ['ogv', 'video/ogg'],\n    ['ogx', 'application/ogg'],\n    ['omc', 'application/x-omc'],\n    ['omcd', 'application/x-omcdatamaker'],\n    ['omcr', 'application/x-omcregerator'],\n    ['onetoc', 'application/onenote'],\n    ['opf', 'application/oebps-package+xml'],\n    ['org', 'application/vnd.lotus-organizer'],\n    ['osf', 'application/vnd.yamaha.openscoreformat'],\n    ['osfpvg', 'application/vnd.yamaha.openscoreformat.osfpvg+xml'],\n    ['otc', 'application/vnd.oasis.opendocument.chart-template'],\n    ['otf', 'application/x-font-otf'],\n    ['otg', 'application/vnd.oasis.opendocument.graphics-template'],\n    ['oth', 'application/vnd.oasis.opendocument.text-web'],\n    ['oti', 'application/vnd.oasis.opendocument.image-template'],\n    ['otp', 'application/vnd.oasis.opendocument.presentation-template'],\n    ['ots', 'application/vnd.oasis.opendocument.spreadsheet-template'],\n    ['ott', 'application/vnd.oasis.opendocument.text-template'],\n    ['oxt', 'application/vnd.openofficeorg.extension'],\n    ['p', 'text/x-pascal'],\n    ['p10', ['application/pkcs10', 'application/x-pkcs10']],\n    ['p12', ['application/pkcs-12', 'application/x-pkcs12']],\n    ['p7a', 'application/x-pkcs7-signature'],\n    ['p7b', 'application/x-pkcs7-certificates'],\n    ['p7c', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],\n    ['p7m', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],\n    ['p7r', 'application/x-pkcs7-certreqresp'],\n    ['p7s', ['application/pkcs7-signature', 'application/x-pkcs7-signature']],\n    ['p8', 'application/pkcs8'],\n    ['par', 'text/plain-bas'],\n    ['part', 'application/pro_eng'],\n    ['pas', 'text/pascal'],\n    ['paw', 'application/vnd.pawaafile'],\n    ['pbd', 'application/vnd.powerbuilder6'],\n    ['pbm', 'image/x-portable-bitmap'],\n    ['pcf', 'application/x-font-pcf'],\n    ['pcl', ['application/vnd.hp-pcl', 'application/x-pcl']],\n    ['pclxl', 'application/vnd.hp-pclxl'],\n    ['pct', 'image/x-pict'],\n    ['pcurl', 'application/vnd.curl.pcurl'],\n    ['pcx', 'image/x-pcx'],\n    ['pdb', ['application/vnd.palm', 'chemical/x-pdb']],\n    ['pdf', 'application/pdf'],\n    ['pfa', 'application/x-font-type1'],\n    ['pfr', 'application/font-tdpfr'],\n    ['pfunk', ['audio/make', 'audio/make.my.funk']],\n    ['pfx', 'application/x-pkcs12'],\n    ['pgm', ['image/x-portable-graymap', 'image/x-portable-greymap']],\n    ['pgn', 'application/x-chess-pgn'],\n    ['pgp', 'application/pgp-signature'],\n    ['pic', ['image/pict', 'image/x-pict']],\n    ['pict', 'image/pict'],\n    ['pkg', 'application/x-newton-compatible-pkg'],\n    ['pki', 'application/pkixcmp'],\n    ['pkipath', 'application/pkix-pkipath'],\n    ['pko', ['application/ynd.ms-pkipko', 'application/vnd.ms-pki.pko']],\n    ['pl', ['text/plain', 'text/x-script.perl']],\n    ['plb', 'application/vnd.3gpp.pic-bw-large'],\n    ['plc', 'application/vnd.mobius.plc'],\n    ['plf', 'application/vnd.pocketlearn'],\n    ['pls', 'application/pls+xml'],\n    ['plx', 'application/x-pixclscript'],\n    ['pm', ['text/x-script.perl-module', 'image/x-xpixmap']],\n    ['pm4', 'application/x-pagemaker'],\n    ['pm5', 'application/x-pagemaker'],\n    ['pma', 'application/x-perfmon'],\n    ['pmc', 'application/x-perfmon'],\n    ['pml', ['application/vnd.ctc-posml', 'application/x-perfmon']],\n    ['pmr', 'application/x-perfmon'],\n    ['pmw', 'application/x-perfmon'],\n    ['png', 'image/png'],\n    ['pnm', ['application/x-portable-anymap', 'image/x-portable-anymap']],\n    ['portpkg', 'application/vnd.macports.portpkg'],\n    ['pot', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],\n    ['potm', 'application/vnd.ms-powerpoint.template.macroenabled.12'],\n    ['potx', 'application/vnd.openxmlformats-officedocument.presentationml.template'],\n    ['pov', 'model/x-pov'],\n    ['ppa', 'application/vnd.ms-powerpoint'],\n    ['ppam', 'application/vnd.ms-powerpoint.addin.macroenabled.12'],\n    ['ppd', 'application/vnd.cups-ppd'],\n    ['ppm', 'image/x-portable-pixmap'],\n    ['pps', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],\n    ['ppsm', 'application/vnd.ms-powerpoint.slideshow.macroenabled.12'],\n    ['ppsx', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow'],\n    ['ppt', ['application/vnd.ms-powerpoint', 'application/mspowerpoint', 'application/powerpoint', 'application/x-mspowerpoint']],\n    ['pptm', 'application/vnd.ms-powerpoint.presentation.macroenabled.12'],\n    ['pptx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'],\n    ['ppz', 'application/mspowerpoint'],\n    ['prc', 'application/x-mobipocket-ebook'],\n    ['pre', ['application/vnd.lotus-freelance', 'application/x-freelance']],\n    ['prf', 'application/pics-rules'],\n    ['prt', 'application/pro_eng'],\n    ['ps', 'application/postscript'],\n    ['psb', 'application/vnd.3gpp.pic-bw-small'],\n    ['psd', ['application/octet-stream', 'image/vnd.adobe.photoshop']],\n    ['psf', 'application/x-font-linux-psf'],\n    ['pskcxml', 'application/pskc+xml'],\n    ['ptid', 'application/vnd.pvi.ptid1'],\n    ['pub', 'application/x-mspublisher'],\n    ['pvb', 'application/vnd.3gpp.pic-bw-var'],\n    ['pvu', 'paleovu/x-pv'],\n    ['pwn', 'application/vnd.3m.post-it-notes'],\n    ['pwz', 'application/vnd.ms-powerpoint'],\n    ['py', 'text/x-script.phyton'],\n    ['pya', 'audio/vnd.ms-playready.media.pya'],\n    ['pyc', 'applicaiton/x-bytecode.python'],\n    ['pyv', 'video/vnd.ms-playready.media.pyv'],\n    ['qam', 'application/vnd.epson.quickanime'],\n    ['qbo', 'application/vnd.intu.qbo'],\n    ['qcp', 'audio/vnd.qcelp'],\n    ['qd3', 'x-world/x-3dmf'],\n    ['qd3d', 'x-world/x-3dmf'],\n    ['qfx', 'application/vnd.intu.qfx'],\n    ['qif', 'image/x-quicktime'],\n    ['qps', 'application/vnd.publishare-delta-tree'],\n    ['qt', 'video/quicktime'],\n    ['qtc', 'video/x-qtc'],\n    ['qti', 'image/x-quicktime'],\n    ['qtif', 'image/x-quicktime'],\n    ['qxd', 'application/vnd.quark.quarkxpress'],\n    ['ra', ['audio/x-realaudio', 'audio/x-pn-realaudio', 'audio/x-pn-realaudio-plugin']],\n    ['ram', 'audio/x-pn-realaudio'],\n    ['rar', 'application/x-rar-compressed'],\n    ['ras', ['image/cmu-raster', 'application/x-cmu-raster', 'image/x-cmu-raster']],\n    ['rast', 'image/cmu-raster'],\n    ['rcprofile', 'application/vnd.ipunplugged.rcprofile'],\n    ['rdf', 'application/rdf+xml'],\n    ['rdz', 'application/vnd.data-vision.rdz'],\n    ['rep', 'application/vnd.businessobjects'],\n    ['res', 'application/x-dtbresource+xml'],\n    ['rexx', 'text/x-script.rexx'],\n    ['rf', 'image/vnd.rn-realflash'],\n    ['rgb', 'image/x-rgb'],\n    ['rif', 'application/reginfo+xml'],\n    ['rip', 'audio/vnd.rip'],\n    ['rl', 'application/resource-lists+xml'],\n    ['rlc', 'image/vnd.fujixerox.edmics-rlc'],\n    ['rld', 'application/resource-lists-diff+xml'],\n    ['rm', ['application/vnd.rn-realmedia', 'audio/x-pn-realaudio']],\n    ['rmi', 'audio/mid'],\n    ['rmm', 'audio/x-pn-realaudio'],\n    ['rmp', ['audio/x-pn-realaudio-plugin', 'audio/x-pn-realaudio']],\n    ['rms', 'application/vnd.jcp.javame.midlet-rms'],\n    ['rnc', 'application/relax-ng-compact-syntax'],\n    ['rng', ['application/ringing-tones', 'application/vnd.nokia.ringing-tone']],\n    ['rnx', 'application/vnd.rn-realplayer'],\n    ['roff', 'application/x-troff'],\n    ['rp', 'image/vnd.rn-realpix'],\n    ['rp9', 'application/vnd.cloanto.rp9'],\n    ['rpm', 'audio/x-pn-realaudio-plugin'],\n    ['rpss', 'application/vnd.nokia.radio-presets'],\n    ['rpst', 'application/vnd.nokia.radio-preset'],\n    ['rq', 'application/sparql-query'],\n    ['rs', 'application/rls-services+xml'],\n    ['rsd', 'application/rsd+xml'],\n    ['rt', ['text/richtext', 'text/vnd.rn-realtext']],\n    ['rtf', ['application/rtf', 'text/richtext', 'application/x-rtf']],\n    ['rtx', ['text/richtext', 'application/rtf']],\n    ['rv', 'video/vnd.rn-realvideo'],\n    ['s', 'text/x-asm'],\n    ['s3m', 'audio/s3m'],\n    ['saf', 'application/vnd.yamaha.smaf-audio'],\n    ['saveme', 'application/octet-stream'],\n    ['sbk', 'application/x-tbook'],\n    ['sbml', 'application/sbml+xml'],\n    ['sc', 'application/vnd.ibm.secure-container'],\n    ['scd', 'application/x-msschedule'],\n    ['scm', ['application/vnd.lotus-screencam', 'video/x-scm', 'text/x-script.guile', 'application/x-lotusscreencam', 'text/x-script.scheme']],\n    ['scq', 'application/scvp-cv-request'],\n    ['scs', 'application/scvp-cv-response'],\n    ['sct', 'text/scriptlet'],\n    ['scurl', 'text/vnd.curl.scurl'],\n    ['sda', 'application/vnd.stardivision.draw'],\n    ['sdc', 'application/vnd.stardivision.calc'],\n    ['sdd', 'application/vnd.stardivision.impress'],\n    ['sdkm', 'application/vnd.solent.sdkm+xml'],\n    ['sdml', 'text/plain'],\n    ['sdp', ['application/sdp', 'application/x-sdp']],\n    ['sdr', 'application/sounder'],\n    ['sdw', 'application/vnd.stardivision.writer'],\n    ['sea', ['application/sea', 'application/x-sea']],\n    ['see', 'application/vnd.seemail'],\n    ['seed', 'application/vnd.fdsn.seed'],\n    ['sema', 'application/vnd.sema'],\n    ['semd', 'application/vnd.semd'],\n    ['semf', 'application/vnd.semf'],\n    ['ser', 'application/java-serialized-object'],\n    ['set', 'application/set'],\n    ['setpay', 'application/set-payment-initiation'],\n    ['setreg', 'application/set-registration-initiation'],\n    ['sfd-hdstx', 'application/vnd.hydrostatix.sof-data'],\n    ['sfs', 'application/vnd.spotfire.sfs'],\n    ['sgl', 'application/vnd.stardivision.writer-global'],\n    ['sgm', ['text/sgml', 'text/x-sgml']],\n    ['sgml', ['text/sgml', 'text/x-sgml']],\n    ['sh', ['application/x-shar', 'application/x-bsh', 'application/x-sh', 'text/x-script.sh']],\n    ['shar', ['application/x-bsh', 'application/x-shar']],\n    ['shf', 'application/shf+xml'],\n    ['shtml', ['text/html', 'text/x-server-parsed-html']],\n    ['sid', 'audio/x-psid'],\n    ['sis', 'application/vnd.symbian.install'],\n    ['sit', ['application/x-stuffit', 'application/x-sit']],\n    ['sitx', 'application/x-stuffitx'],\n    ['skd', 'application/x-koan'],\n    ['skm', 'application/x-koan'],\n    ['skp', ['application/vnd.koan', 'application/x-koan']],\n    ['skt', 'application/x-koan'],\n    ['sl', 'application/x-seelogo'],\n    ['sldm', 'application/vnd.ms-powerpoint.slide.macroenabled.12'],\n    ['sldx', 'application/vnd.openxmlformats-officedocument.presentationml.slide'],\n    ['slt', 'application/vnd.epson.salt'],\n    ['sm', 'application/vnd.stepmania.stepchart'],\n    ['smf', 'application/vnd.stardivision.math'],\n    ['smi', ['application/smil', 'application/smil+xml']],\n    ['smil', 'application/smil'],\n    ['snd', ['audio/basic', 'audio/x-adpcm']],\n    ['snf', 'application/x-font-snf'],\n    ['sol', 'application/solids'],\n    ['spc', ['text/x-speech', 'application/x-pkcs7-certificates']],\n    ['spf', 'application/vnd.yamaha.smaf-phrase'],\n    ['spl', ['application/futuresplash', 'application/x-futuresplash']],\n    ['spot', 'text/vnd.in3d.spot'],\n    ['spp', 'application/scvp-vp-response'],\n    ['spq', 'application/scvp-vp-request'],\n    ['spr', 'application/x-sprite'],\n    ['sprite', 'application/x-sprite'],\n    ['src', 'application/x-wais-source'],\n    ['sru', 'application/sru+xml'],\n    ['srx', 'application/sparql-results+xml'],\n    ['sse', 'application/vnd.kodak-descriptor'],\n    ['ssf', 'application/vnd.epson.ssf'],\n    ['ssi', 'text/x-server-parsed-html'],\n    ['ssm', 'application/streamingmedia'],\n    ['ssml', 'application/ssml+xml'],\n    ['sst', ['application/vnd.ms-pkicertstore', 'application/vnd.ms-pki.certstore']],\n    ['st', 'application/vnd.sailingtracker.track'],\n    ['stc', 'application/vnd.sun.xml.calc.template'],\n    ['std', 'application/vnd.sun.xml.draw.template'],\n    ['step', 'application/step'],\n    ['stf', 'application/vnd.wt.stf'],\n    ['sti', 'application/vnd.sun.xml.impress.template'],\n    ['stk', 'application/hyperstudio'],\n    ['stl', ['application/vnd.ms-pkistl', 'application/sla', 'application/vnd.ms-pki.stl', 'application/x-navistyle']],\n    ['stm', 'text/html'],\n    ['stp', 'application/step'],\n    ['str', 'application/vnd.pg.format'],\n    ['stw', 'application/vnd.sun.xml.writer.template'],\n    ['sub', 'image/vnd.dvb.subtitle'],\n    ['sus', 'application/vnd.sus-calendar'],\n    ['sv4cpio', 'application/x-sv4cpio'],\n    ['sv4crc', 'application/x-sv4crc'],\n    ['svc', 'application/vnd.dvb.service'],\n    ['svd', 'application/vnd.svd'],\n    ['svf', ['image/vnd.dwg', 'image/x-dwg']],\n    ['svg', 'image/svg+xml'],\n    ['svr', ['x-world/x-svr', 'application/x-world']],\n    ['swf', 'application/x-shockwave-flash'],\n    ['swi', 'application/vnd.aristanetworks.swi'],\n    ['sxc', 'application/vnd.sun.xml.calc'],\n    ['sxd', 'application/vnd.sun.xml.draw'],\n    ['sxg', 'application/vnd.sun.xml.writer.global'],\n    ['sxi', 'application/vnd.sun.xml.impress'],\n    ['sxm', 'application/vnd.sun.xml.math'],\n    ['sxw', 'application/vnd.sun.xml.writer'],\n    ['t', ['text/troff', 'application/x-troff']],\n    ['talk', 'text/x-speech'],\n    ['tao', 'application/vnd.tao.intent-module-archive'],\n    ['tar', 'application/x-tar'],\n    ['tbk', ['application/toolbook', 'application/x-tbook']],\n    ['tcap', 'application/vnd.3gpp2.tcap'],\n    ['tcl', ['text/x-script.tcl', 'application/x-tcl']],\n    ['tcsh', 'text/x-script.tcsh'],\n    ['teacher', 'application/vnd.smart.teacher'],\n    ['tei', 'application/tei+xml'],\n    ['tex', 'application/x-tex'],\n    ['texi', 'application/x-texinfo'],\n    ['texinfo', 'application/x-texinfo'],\n    ['text', ['application/plain', 'text/plain']],\n    ['tfi', 'application/thraud+xml'],\n    ['tfm', 'application/x-tex-tfm'],\n    ['tgz', ['application/gnutar', 'application/x-compressed']],\n    ['thmx', 'application/vnd.ms-officetheme'],\n    ['tif', ['image/tiff', 'image/x-tiff']],\n    ['tiff', ['image/tiff', 'image/x-tiff']],\n    ['tmo', 'application/vnd.tmobile-livetv'],\n    ['torrent', 'application/x-bittorrent'],\n    ['tpl', 'application/vnd.groove-tool-template'],\n    ['tpt', 'application/vnd.trid.tpt'],\n    ['tr', 'application/x-troff'],\n    ['tra', 'application/vnd.trueapp'],\n    ['trm', 'application/x-msterminal'],\n    ['tsd', 'application/timestamped-data'],\n    ['tsi', 'audio/tsp-audio'],\n    ['tsp', ['application/dsptype', 'audio/tsplayer']],\n    ['tsv', 'text/tab-separated-values'],\n    ['ttf', 'application/x-font-ttf'],\n    ['ttl', 'text/turtle'],\n    ['turbot', 'image/florian'],\n    ['twd', 'application/vnd.simtech-mindmapper'],\n    ['txd', 'application/vnd.genomatix.tuxedo'],\n    ['txf', 'application/vnd.mobius.txf'],\n    ['txt', 'text/plain'],\n    ['ufd', 'application/vnd.ufdl'],\n    ['uil', 'text/x-uil'],\n    ['uls', 'text/iuls'],\n    ['umj', 'application/vnd.umajin'],\n    ['uni', 'text/uri-list'],\n    ['unis', 'text/uri-list'],\n    ['unityweb', 'application/vnd.unity'],\n    ['unv', 'application/i-deas'],\n    ['uoml', 'application/vnd.uoml+xml'],\n    ['uri', 'text/uri-list'],\n    ['uris', 'text/uri-list'],\n    ['ustar', ['application/x-ustar', 'multipart/x-ustar']],\n    ['utz', 'application/vnd.uiq.theme'],\n    ['uu', ['application/octet-stream', 'text/x-uuencode']],\n    ['uue', 'text/x-uuencode'],\n    ['uva', 'audio/vnd.dece.audio'],\n    ['uvh', 'video/vnd.dece.hd'],\n    ['uvi', 'image/vnd.dece.graphic'],\n    ['uvm', 'video/vnd.dece.mobile'],\n    ['uvp', 'video/vnd.dece.pd'],\n    ['uvs', 'video/vnd.dece.sd'],\n    ['uvu', 'video/vnd.uvvu.mp4'],\n    ['uvv', 'video/vnd.dece.video'],\n    ['vcd', 'application/x-cdlink'],\n    ['vcf', 'text/x-vcard'],\n    ['vcg', 'application/vnd.groove-vcard'],\n    ['vcs', 'text/x-vcalendar'],\n    ['vcx', 'application/vnd.vcx'],\n    ['vda', 'application/vda'],\n    ['vdo', 'video/vdo'],\n    ['vew', 'application/groupwise'],\n    ['vis', 'application/vnd.visionary'],\n    ['viv', ['video/vivo', 'video/vnd.vivo']],\n    ['vivo', ['video/vivo', 'video/vnd.vivo']],\n    ['vmd', 'application/vocaltec-media-desc'],\n    ['vmf', 'application/vocaltec-media-file'],\n    ['voc', ['audio/voc', 'audio/x-voc']],\n    ['vos', 'video/vosaic'],\n    ['vox', 'audio/voxware'],\n    ['vqe', 'audio/x-twinvq-plugin'],\n    ['vqf', 'audio/x-twinvq'],\n    ['vql', 'audio/x-twinvq-plugin'],\n    ['vrml', ['model/vrml', 'x-world/x-vrml', 'application/x-vrml']],\n    ['vrt', 'x-world/x-vrt'],\n    ['vsd', ['application/vnd.visio', 'application/x-visio']],\n    ['vsf', 'application/vnd.vsf'],\n    ['vst', 'application/x-visio'],\n    ['vsw', 'application/x-visio'],\n    ['vtu', 'model/vnd.vtu'],\n    ['vxml', 'application/voicexml+xml'],\n    ['w60', 'application/wordperfect6.0'],\n    ['w61', 'application/wordperfect6.1'],\n    ['w6w', 'application/msword'],\n    ['wad', 'application/x-doom'],\n    ['wav', ['audio/wav', 'audio/x-wav']],\n    ['wax', 'audio/x-ms-wax'],\n    ['wb1', 'application/x-qpro'],\n    ['wbmp', 'image/vnd.wap.wbmp'],\n    ['wbs', 'application/vnd.criticaltools.wbs+xml'],\n    ['wbxml', 'application/vnd.wap.wbxml'],\n    ['wcm', 'application/vnd.ms-works'],\n    ['wdb', 'application/vnd.ms-works'],\n    ['web', 'application/vnd.xara'],\n    ['weba', 'audio/webm'],\n    ['webm', 'video/webm'],\n    ['webp', 'image/webp'],\n    ['wg', 'application/vnd.pmi.widget'],\n    ['wgt', 'application/widget'],\n    ['wiz', 'application/msword'],\n    ['wk1', 'application/x-123'],\n    ['wks', 'application/vnd.ms-works'],\n    ['wm', 'video/x-ms-wm'],\n    ['wma', 'audio/x-ms-wma'],\n    ['wmd', 'application/x-ms-wmd'],\n    ['wmf', ['windows/metafile', 'application/x-msmetafile']],\n    ['wml', 'text/vnd.wap.wml'],\n    ['wmlc', 'application/vnd.wap.wmlc'],\n    ['wmls', 'text/vnd.wap.wmlscript'],\n    ['wmlsc', 'application/vnd.wap.wmlscriptc'],\n    ['wmv', 'video/x-ms-wmv'],\n    ['wmx', 'video/x-ms-wmx'],\n    ['wmz', 'application/x-ms-wmz'],\n    ['woff', 'application/x-font-woff'],\n    ['word', 'application/msword'],\n    ['wp', 'application/wordperfect'],\n    ['wp5', ['application/wordperfect', 'application/wordperfect6.0']],\n    ['wp6', 'application/wordperfect'],\n    ['wpd', ['application/wordperfect', 'application/vnd.wordperfect', 'application/x-wpwin']],\n    ['wpl', 'application/vnd.ms-wpl'],\n    ['wps', 'application/vnd.ms-works'],\n    ['wq1', 'application/x-lotus'],\n    ['wqd', 'application/vnd.wqd'],\n    ['wri', ['application/mswrite', 'application/x-wri', 'application/x-mswrite']],\n    ['wrl', ['model/vrml', 'x-world/x-vrml', 'application/x-world']],\n    ['wrz', ['model/vrml', 'x-world/x-vrml']],\n    ['wsc', 'text/scriplet'],\n    ['wsdl', 'application/wsdl+xml'],\n    ['wspolicy', 'application/wspolicy+xml'],\n    ['wsrc', 'application/x-wais-source'],\n    ['wtb', 'application/vnd.webturbo'],\n    ['wtk', 'application/x-wintalk'],\n    ['wvx', 'video/x-ms-wvx'],\n    ['x-png', 'image/png'],\n    ['x3d', 'application/vnd.hzn-3d-crossword'],\n    ['xaf', 'x-world/x-vrml'],\n    ['xap', 'application/x-silverlight-app'],\n    ['xar', 'application/vnd.xara'],\n    ['xbap', 'application/x-ms-xbap'],\n    ['xbd', 'application/vnd.fujixerox.docuworks.binder'],\n    ['xbm', ['image/xbm', 'image/x-xbm', 'image/x-xbitmap']],\n    ['xdf', 'application/xcap-diff+xml'],\n    ['xdm', 'application/vnd.syncml.dm+xml'],\n    ['xdp', 'application/vnd.adobe.xdp+xml'],\n    ['xdr', 'video/x-amt-demorun'],\n    ['xdssc', 'application/dssc+xml'],\n    ['xdw', 'application/vnd.fujixerox.docuworks'],\n    ['xenc', 'application/xenc+xml'],\n    ['xer', 'application/patch-ops-error+xml'],\n    ['xfdf', 'application/vnd.adobe.xfdf'],\n    ['xfdl', 'application/vnd.xfdl'],\n    ['xgz', 'xgl/drawing'],\n    ['xhtml', 'application/xhtml+xml'],\n    ['xif', 'image/vnd.xiff'],\n    ['xl', 'application/excel'],\n    ['xla', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xlam', 'application/vnd.ms-excel.addin.macroenabled.12'],\n    ['xlb', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],\n    ['xlc', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xld', ['application/excel', 'application/x-excel']],\n    ['xlk', ['application/excel', 'application/x-excel']],\n    ['xll', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],\n    ['xlm', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xls', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xlsb', 'application/vnd.ms-excel.sheet.binary.macroenabled.12'],\n    ['xlsm', 'application/vnd.ms-excel.sheet.macroenabled.12'],\n    ['xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],\n    ['xlt', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xltm', 'application/vnd.ms-excel.template.macroenabled.12'],\n    ['xltx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template'],\n    ['xlv', ['application/excel', 'application/x-excel']],\n    ['xlw', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xm', 'audio/xm'],\n    ['xml', ['application/xml', 'text/xml', 'application/atom+xml', 'application/rss+xml']],\n    ['xmz', 'xgl/movie'],\n    ['xo', 'application/vnd.olpc-sugar'],\n    ['xof', 'x-world/x-vrml'],\n    ['xop', 'application/xop+xml'],\n    ['xpi', 'application/x-xpinstall'],\n    ['xpix', 'application/x-vnd.ls-xpix'],\n    ['xpm', ['image/xpm', 'image/x-xpixmap']],\n    ['xpr', 'application/vnd.is-xpr'],\n    ['xps', 'application/vnd.ms-xpsdocument'],\n    ['xpw', 'application/vnd.intercon.formnet'],\n    ['xslt', 'application/xslt+xml'],\n    ['xsm', 'application/vnd.syncml+xml'],\n    ['xspf', 'application/xspf+xml'],\n    ['xsr', 'video/x-amt-showrun'],\n    ['xul', 'application/vnd.mozilla.xul+xml'],\n    ['xwd', ['image/x-xwd', 'image/x-xwindowdump']],\n    ['xyz', ['chemical/x-xyz', 'chemical/x-pdb']],\n    ['yang', 'application/yang'],\n    ['yin', 'application/yin+xml'],\n    ['z', ['application/x-compressed', 'application/x-compress']],\n    ['zaz', 'application/vnd.zzazz.deck+xml'],\n    ['zip', ['application/zip', 'multipart/x-zip', 'application/x-zip-compressed', 'application/x-compressed']],\n    ['zir', 'application/vnd.zul'],\n    ['zmm', 'application/vnd.handheld-entertainment+xml'],\n    ['zoo', 'application/octet-stream'],\n    ['zsh', 'text/x-script.zsh']\n]);\n\nmodule.exports = {\n    detectMimeType(filename) {\n        if (!filename) {\n            return defaultMimeType;\n        }\n\n        let parsed = path.parse(filename);\n        let extension = (parsed.ext.substr(1) || parsed.name || '').split('?').shift().trim().toLowerCase();\n        let value = defaultMimeType;\n\n        if (extensions.has(extension)) {\n            value = extensions.get(extension);\n        }\n\n        if (Array.isArray(value)) {\n            return value[0];\n        }\n        return value;\n    },\n\n    detectExtension(mimeType) {\n        if (!mimeType) {\n            return defaultExtension;\n        }\n        let parts = (mimeType || '').toLowerCase().trim().split('/');\n        let rootType = parts.shift().trim();\n        let subType = parts.join('/').trim();\n\n        if (mimeTypes.has(rootType + '/' + subType)) {\n            let value = mimeTypes.get(rootType + '/' + subType);\n            if (Array.isArray(value)) {\n                return value[0];\n            }\n            return value;\n        }\n\n        switch (rootType) {\n            case 'text':\n                return 'txt';\n            default:\n                return 'bin';\n        }\n    }\n};\n", "'use strict';\n\nconst Mailer = require('./mailer');\nconst shared = require('./shared');\nconst SMTPPool = require('./smtp-pool');\nconst SMTPTransport = require('./smtp-transport');\nconst SendmailTransport = require('./sendmail-transport');\nconst StreamTransport = require('./stream-transport');\nconst JSONTransport = require('./json-transport');\nconst SESTransport = require('./ses-transport');\nconst fetch = require('./fetch');\nconst packageData = require('../package.json');\n\nconst ETHEREAL_API = (process.env.ETHEREAL_API || 'https://api.nodemailer.com').replace(/\\/+$/, '');\nconst ETHEREAL_WEB = (process.env.ETHEREAL_WEB || 'https://ethereal.email').replace(/\\/+$/, '');\nconst ETHEREAL_CACHE = ['true', 'yes', 'y', '1'].includes((process.env.ETHEREAL_CACHE || 'yes').toString().trim().toLowerCase());\n\nlet testAccount = false;\n\nmodule.exports.createTransport = function (transporter, defaults) {\n    let urlConfig;\n    let options;\n    let mailer;\n\n    if (\n        // provided transporter is a configuration object, not transporter plugin\n        (typeof transporter === 'object' && typeof transporter.send !== 'function') ||\n        // provided transporter looks like a connection url\n        (typeof transporter === 'string' && /^(smtps?|direct):/i.test(transporter))\n    ) {\n        if ((urlConfig = typeof transporter === 'string' ? transporter : transporter.url)) {\n            // parse a configuration URL into configuration options\n            options = shared.parseConnectionUrl(urlConfig);\n        } else {\n            options = transporter;\n        }\n\n        if (options.pool) {\n            transporter = new SMTPPool(options);\n        } else if (options.sendmail) {\n            transporter = new SendmailTransport(options);\n        } else if (options.streamTransport) {\n            transporter = new StreamTransport(options);\n        } else if (options.jsonTransport) {\n            transporter = new JSONTransport(options);\n        } else if (options.SES) {\n            transporter = new SESTransport(options);\n        } else {\n            transporter = new SMTPTransport(options);\n        }\n    }\n\n    mailer = new Mailer(transporter, options, defaults);\n\n    return mailer;\n};\n\nmodule.exports.createTestAccount = function (apiUrl, callback) {\n    let promise;\n\n    if (!callback && typeof apiUrl === 'function') {\n        callback = apiUrl;\n        apiUrl = false;\n    }\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = shared.callbackPromise(resolve, reject);\n        });\n    }\n\n    if (ETHEREAL_CACHE && testAccount) {\n        setImmediate(() => callback(null, testAccount));\n        return promise;\n    }\n\n    apiUrl = apiUrl || ETHEREAL_API;\n\n    let chunks = [];\n    let chunklen = 0;\n\n    let req = fetch(apiUrl + '/user', {\n        contentType: 'application/json',\n        method: 'POST',\n        body: Buffer.from(\n            JSON.stringify({\n                requestor: packageData.name,\n                version: packageData.version\n            })\n        )\n    });\n\n    req.on('readable', () => {\n        let chunk;\n        while ((chunk = req.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    req.once('error', err => callback(err));\n\n    req.once('end', () => {\n        let res = Buffer.concat(chunks, chunklen);\n        let data;\n        let err;\n        try {\n            data = JSON.parse(res.toString());\n        } catch (E) {\n            err = E;\n        }\n        if (err) {\n            return callback(err);\n        }\n        if (data.status !== 'success' || data.error) {\n            return callback(new Error(data.error || 'Request failed'));\n        }\n        delete data.status;\n        testAccount = data;\n        callback(null, testAccount);\n    });\n\n    return promise;\n};\n\nmodule.exports.getTestMessageUrl = function (info) {\n    if (!info || !info.response) {\n        return false;\n    }\n\n    let infoProps = new Map();\n    info.response.replace(/\\[([^\\]]+)\\]$/, (m, props) => {\n        props.replace(/\\b([A-Z0-9]+)=([^\\s]+)/g, (m, key, value) => {\n            infoProps.set(key, value);\n        });\n    });\n\n    if (infoProps.has('STATUS') && infoProps.has('MSGID')) {\n        return (testAccount.web || ETHEREAL_WEB) + '/message/' + infoProps.get('MSGID');\n    }\n\n    return false;\n};\n", "'use strict';\n\nconst spawn = require('child_process').spawn;\nconst packageData = require('../../package.json');\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\nconst shared = require('../shared');\n\n/**\n * Generates a Transport object for Sendmail\n *\n * Possible options can be the following:\n *\n *  * **path** optional path to sendmail binary\n *  * **newline** either 'windows' or 'unix'\n *  * **args** an array of arguments for the sendmail binary\n *\n * @constructor\n * @param {Object} optional config parameter for Sendmail\n */\nclass SendmailTransport {\n    constructor(options) {\n        options = options || {};\n\n        // use a reference to spawn for mocking purposes\n        this._spawn = spawn;\n\n        this.options = options || {};\n\n        this.name = 'Sendmail';\n        this.version = packageData.version;\n\n        this.path = 'sendmail';\n        this.args = false;\n        this.winbreak = false;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'sendmail'\n        });\n\n        if (options) {\n            if (typeof options === 'string') {\n                this.path = options;\n            } else if (typeof options === 'object') {\n                if (options.path) {\n                    this.path = options.path;\n                }\n                if (Array.isArray(options.args)) {\n                    this.args = options.args;\n                }\n                this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n            }\n        }\n    }\n\n    /**\n     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    send(mail, done) {\n        // Sendmail strips this header line by itself\n        mail.message.keepBcc = true;\n\n        let envelope = mail.data.envelope || mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n        let args;\n        let sendmail;\n        let returned;\n        let transform;\n\n        const hasInvalidAddresses = []\n            .concat(envelope.from || [])\n            .concat(envelope.to || [])\n            .some(addr => /^-/.test(addr));\n        if (hasInvalidAddresses) {\n            return done(new Error('Can not send mail. Invalid envelope addresses.'));\n        }\n\n        if (this.args) {\n            // force -i to keep single dots\n            args = ['-i'].concat(this.args).concat(envelope.to);\n        } else {\n            args = ['-i'].concat(envelope.from ? ['-f', envelope.from] : []).concat(envelope.to);\n        }\n\n        let callback = err => {\n            if (returned) {\n                // ignore any additional responses, already done\n                return;\n            }\n            returned = true;\n            if (typeof done === 'function') {\n                if (err) {\n                    return done(err);\n                } else {\n                    return done(null, {\n                        envelope: mail.data.envelope || mail.message.getEnvelope(),\n                        messageId,\n                        response: 'Messages queued for delivery'\n                    });\n                }\n            }\n        };\n\n        try {\n            sendmail = this._spawn(this.path, args);\n        } catch (E) {\n            this.logger.error(\n                {\n                    err: E,\n                    tnx: 'spawn',\n                    messageId\n                },\n                'Error occurred while spawning sendmail. %s',\n                E.message\n            );\n            return callback(E);\n        }\n\n        if (sendmail) {\n            sendmail.on('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'spawn',\n                        messageId\n                    },\n                    'Error occurred when sending message %s. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n\n            sendmail.once('exit', code => {\n                if (!code) {\n                    return callback();\n                }\n                let err;\n                if (code === 127) {\n                    err = new Error('Sendmail command not found, process exited with code ' + code);\n                } else {\n                    err = new Error('Sendmail exited with code ' + code);\n                }\n\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error sending message %s to sendmail. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n            sendmail.once('close', callback);\n\n            sendmail.stdin.on('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error occurred when piping message %s to sendmail. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n\n            let recipients = [].concat(envelope.to || []);\n            if (recipients.length > 3) {\n                recipients.push('...and ' + recipients.splice(2).length + ' more');\n            }\n            this.logger.info(\n                {\n                    tnx: 'send',\n                    messageId\n                },\n                'Sending message %s to <%s>',\n                messageId,\n                recipients.join(', ')\n            );\n\n            transform = this.winbreak ? new LeWindows() : new LeUnix();\n            let sourceStream = mail.message.createReadStream();\n\n            transform.once('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error occurred when generating message %s. %s',\n                    messageId,\n                    err.message\n                );\n                sendmail.kill('SIGINT'); // do not deliver the message\n                callback(err);\n            });\n\n            sourceStream.once('error', err => transform.emit('error', err));\n            sourceStream.pipe(transform).pipe(sendmail.stdin);\n        } else {\n            return callback(new Error('sendmail was not found'));\n        }\n    }\n}\n\nmodule.exports = SendmailTransport;\n", "/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst fetch = require('../fetch');\nconst dns = require('dns');\nconst net = require('net');\n\nconst DNS_TTL = 5 * 60 * 1000;\n\nconst resolver = (family, hostname, callback) => {\n    dns['resolve' + family](hostname, (err, addresses) => {\n        if (err) {\n            switch (err.code) {\n                case dns.NODATA:\n                case dns.NOTFOUND:\n                case dns.NOTIMP:\n                case dns.SERVFAIL:\n                case dns.CONNREFUSED:\n                case 'EAI_AGAIN':\n                    return callback(null, []);\n            }\n            return callback(err);\n        }\n        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n    });\n};\n\nconst dnsCache = (module.exports.dnsCache = new Map());\nmodule.exports.resolveHostname = (options, callback) => {\n    options = options || {};\n\n    if (!options.host || net.isIP(options.host)) {\n        // nothing to do here\n        let value = {\n            host: options.host,\n            servername: options.servername || false\n        };\n        return callback(null, value);\n    }\n\n    let cached;\n\n    if (dnsCache.has(options.host)) {\n        cached = dnsCache.get(options.host);\n        if (!cached.expires || cached.expires >= Date.now()) {\n            return callback(null, {\n                host: cached.value.host,\n                servername: cached.value.servername,\n                _cached: true\n            });\n        }\n    }\n\n    resolver(4, options.host, (err, addresses) => {\n        if (err) {\n            if (cached) {\n                // ignore error, use expired value\n                return callback(null, cached.value);\n            }\n            return callback(err);\n        }\n        if (addresses && addresses.length) {\n            let value = {\n                host: addresses[0] || options.host,\n                servername: options.servername || options.host\n            };\n            dnsCache.set(options.host, {\n                value,\n                expires: Date.now() + DNS_TTL\n            });\n            return callback(null, value);\n        }\n\n        resolver(6, options.host, (err, addresses) => {\n            if (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(null, cached.value);\n                }\n                return callback(err);\n            }\n            if (addresses && addresses.length) {\n                let value = {\n                    host: addresses[0] || options.host,\n                    servername: options.servername || options.host\n                };\n                dnsCache.set(options.host, {\n                    value,\n                    expires: Date.now() + DNS_TTL\n                });\n                return callback(null, value);\n            }\n\n            try {\n                dns.lookup(options.host, {}, (err, address) => {\n                    if (err) {\n                        if (cached) {\n                            // ignore error, use expired value\n                            return callback(null, cached.value);\n                        }\n                        return callback(err);\n                    }\n\n                    if (!address && cached) {\n                        // nothing was found, fallback to cached value\n                        return callback(null, cached.value);\n                    }\n\n                    let value = {\n                        host: address || options.host,\n                        servername: options.servername || options.host\n                    };\n                    dnsCache.set(options.host, {\n                        value,\n                        expires: Date.now() + DNS_TTL\n                    });\n                    return callback(null, value);\n                });\n            } catch (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(null, cached.value);\n                }\n                return callback(err);\n            }\n        });\n    });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n    str = str || '';\n    let options = {};\n\n    [urllib.parse(str, true)].forEach(url => {\n        let auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = auth.shift();\n            options.auth.pass = auth.join(':');\n        }\n\n        Object.keys(url.query || {}).forEach(key => {\n            let obj = options;\n            let lKey = key;\n            let value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n    let entry = {};\n\n    Object.keys(defaults || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = defaults[key];\n        }\n    });\n\n    Object.keys(data || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = data[key];\n        }\n    });\n\n    logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n    options = options || {};\n\n    let response = {};\n    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n    if (!options.logger) {\n        // use vanity logger\n        levels.forEach(level => {\n            response[level] = () => false;\n        });\n        return response;\n    }\n\n    let logger = options.logger;\n\n    if (options.logger === true) {\n        // create console logger\n        logger = createDefaultLogger(levels);\n    }\n\n    levels.forEach(level => {\n        response[level] = (data, message, ...args) => {\n            module.exports._logFunc(logger, level, defaults, data, message, ...args);\n        };\n    });\n\n    return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) =>\n    function () {\n        let args = Array.from(arguments);\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n    let promise;\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    let content = (data && data[key] && data[key].content) || data[key];\n    let contentStream;\n    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                data[key] = value;\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = fetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n            if (!parts) {\n                return callback(null, Buffer.from(0));\n            }\n            return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        content = Buffer.from(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(() => callback(null, content));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function (/* target, ... sources */) {\n    let args = Array.from(arguments);\n    let target = args.shift() || {};\n\n    args.forEach(source => {\n        Object.keys(source || {}).forEach(key => {\n            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // ensure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(subKey => {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n};\n\nmodule.exports.encodeXText = str => {\n    // ! 0x21\n    // + 0x2B\n    // = 0x3D\n    // ~ 0x7E\n    if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n        return str;\n    }\n    let buf = Buffer.from(str);\n    let result = '';\n    for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n        } else {\n            result += String.fromCharCode(c);\n        }\n    }\n    return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    let responded = false;\n    let chunks = [];\n    let chunklen = 0;\n\n    stream.on('error', err => {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', () => {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        let value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n    let levelMaxLen = 0;\n    let levelNames = new Map();\n    levels.forEach(level => {\n        if (level.length > levelMaxLen) {\n            levelMaxLen = level.length;\n        }\n    });\n\n    levels.forEach(level => {\n        let levelName = level.toUpperCase();\n        if (levelName.length < levelMaxLen) {\n            levelName += ' '.repeat(levelMaxLen - levelName.length);\n        }\n        levelNames.set(level, levelName);\n    });\n\n    let print = (level, entry, message, ...args) => {\n        let prefix = '';\n        if (entry) {\n            if (entry.tnx === 'server') {\n                prefix = 'S: ';\n            } else if (entry.tnx === 'client') {\n                prefix = 'C: ';\n            }\n\n            if (entry.sid) {\n                prefix = '[' + entry.sid + '] ' + prefix;\n            }\n\n            if (entry.cid) {\n                prefix = '[#' + entry.cid + '] ' + prefix;\n            }\n        }\n\n        message = util.format(message, ...args);\n        message.split(/\\r?\\n/).forEach(line => {\n            console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n        });\n    };\n\n    let logger = {};\n    levels.forEach(level => {\n        logger[level] = print.bind(null, level);\n    });\n\n    return logger;\n}\n", "'use strict';\n\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = require('net');\nconst tls = require('tls');\nconst urllib = require('url');\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n    let proxy = urllib.parse(proxyUrl);\n\n    // create a socket connection to the proxy server\n    let options;\n    let connect;\n    let socket;\n\n    options = {\n        host: proxy.hostname,\n        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n    };\n\n    if (proxy.protocol === 'https:') {\n        // we can use untrusted proxies as long as we verify actual SMTP certificates\n        options.rejectUnauthorized = false;\n        connect = tls.connect.bind(tls);\n    } else {\n        connect = net.connect.bind(net);\n    }\n\n    // Error harness for initial connection. Once connection is established, the responsibility\n    // to handle errors is passed to whoever uses this socket\n    let finished = false;\n    let tempSocketErr = function (err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        try {\n            socket.destroy();\n        } catch (E) {\n            // ignore\n        }\n        callback(err);\n    };\n\n    socket = connect(options, () => {\n        if (finished) {\n            return;\n        }\n\n        let reqHeaders = {\n            Host: destinationHost + ':' + destinationPort,\n            Connection: 'close'\n        };\n        if (proxy.auth) {\n            reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n        }\n\n        socket.write(\n            // HTTP method\n            'CONNECT ' +\n                destinationHost +\n                ':' +\n                destinationPort +\n                ' HTTP/1.1\\r\\n' +\n                // HTTP request headers\n                Object.keys(reqHeaders)\n                    .map(key => key + ': ' + reqHeaders[key])\n                    .join('\\r\\n') +\n                // End request\n                '\\r\\n\\r\\n'\n        );\n\n        let headers = '';\n        let onSocketData = chunk => {\n            let match;\n            let remainder;\n\n            if (finished) {\n                return;\n            }\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n\n                // proxy connection is now established\n                finished = true;\n\n                // check response code\n                match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n                if (!match || (match[1] || '').charAt(0) !== '2') {\n                    try {\n                        socket.destroy();\n                    } catch (E) {\n                        // ignore\n                    }\n                    return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));\n                }\n\n                socket.removeListener('error', tempSocketErr);\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;\n", "'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        this.customAuth = new Map();\n        Object.keys(this.options.customAuth || {}).forEach(key => {\n            let mapKey = (key || '').toString().trim().toUpperCase();\n            if (!mapKey) {\n                return;\n            }\n            this.customAuth.set(mapKey, this.options.customAuth[key]);\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @publick\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Set to true, if EHLO response includes \"AUTH\".\n         * If false then authentication is not tried\n         */\n        this.allowsAuth = false;\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n\n        /**\n         * Callbacks for socket's listeners\n         */\n        this._onSocketData = chunk => this._onData(chunk);\n        this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n        this._onSocketClose = () => this._onClose();\n        this._onSocketEnd = () => this._onEnd();\n        this._onSocketTimeout = () => this._onTimeout();\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'SMTP handshake finished'\n                );\n                connectCallback();\n            });\n\n            const isDestroyedMessage = this._isDestroyedMessage('connect');\n            if (isDestroyedMessage) {\n                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        let setupConnectionHandlers = () => {\n            this._connectionTimeout = setTimeout(() => {\n                this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n            this._socket.on('error', this._onSocketError);\n        };\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() =>\n                    this._upgradeConnection(err => {\n                        if (err) {\n                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                            return;\n                        }\n                        this._onConnect();\n                    })\n                );\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n            return;\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved._cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved._cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket.connect(this.port, this.host, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved._cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved._cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = tls.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else {\n            // connect using plaintext\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved._cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved._cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = net.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        }\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug(\n            {\n                tnx: 'smtp'\n            },\n            'Closing connection to the server using \"%s\"',\n            closeMethod\n        );\n\n        let socket = (this._socket && this._socket.socket) || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                this._socket[closeMethod]();\n            } catch (E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        const isDestroyedMessage = this._isDestroyedMessage('login');\n        if (isDestroyedMessage) {\n            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        this._auth = authData || {};\n        // Select SASL authentication method\n        this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n            if (this._auth.user && this._auth.pass) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass,\n                    options: this._auth.options\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        if (this.customAuth.has(this._authMethod)) {\n            let handler = this.customAuth.get(this._authMethod);\n            let lastResponse;\n            let returned = false;\n\n            let resolve = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authenticated',\n                        method: this._authMethod\n                    },\n                    'User %s authenticated',\n                    JSON.stringify(this._auth.user)\n                );\n                this.authenticated = true;\n                callback(null, true);\n            };\n\n            let reject = err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n            };\n\n            let handlerResponse = handler({\n                auth: this._auth,\n                method: this._authMethod,\n\n                extensions: [].concat(this._supportedExtensions),\n                authMethods: [].concat(this._supportedAuth),\n                maxAllowedSize: this._maxAllowedSize || false,\n\n                sendCommand: (cmd, done) => {\n                    let promise;\n\n                    if (!done) {\n                        promise = new Promise((resolve, reject) => {\n                            done = shared.callbackPromise(resolve, reject);\n                        });\n                    }\n\n                    this._responseActions.push(str => {\n                        lastResponse = str;\n\n                        let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n                        let data = {\n                            command: cmd,\n                            response: str\n                        };\n                        if (codes) {\n                            data.status = Number(codes[1]) || 0;\n                            if (codes[2]) {\n                                data.code = codes[2];\n                            }\n                            data.text = str.substr(codes[0].length);\n                        } else {\n                            data.text = str;\n                            data.status = 0; // just in case we need to perform numeric comparisons\n                        }\n                        done(null, data);\n                    });\n                    setImmediate(() => this._sendCommand(cmd));\n\n                    return promise;\n                },\n\n                resolve,\n                reject\n            });\n\n            if (handlerResponse && typeof handlerResponse.catch === 'function') {\n                // a promise was returned\n                handlerResponse.then(resolve).catch(reject);\n            }\n\n            return;\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand(\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                this._auth.credentials.pass,\n                            'utf-8'\n                        ).toString('base64')\n                );\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        const isDestroyedMessage = this._isDestroyedMessage('send message');\n        if (isDestroyedMessage) {\n            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        let startTime = Date.now();\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                return callback(err);\n            }\n            let envelopeTime = Date.now();\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                info.envelopeTime = envelopeTime - startTime;\n                info.messageTime = Date.now() - envelopeTime;\n                info.messageSize = stream.outByteCount;\n                info.response = str;\n\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info(\n            {\n                tnx: 'network',\n                localAddress: this._socket.localAddress,\n                localPort: this._socket.localPort,\n                remoteAddress: this._socket.remoteAddress,\n                remotePort: this._socket.remotePort\n            },\n            '%s established to %s:%s',\n            this.secure ? 'Secure connection' : 'Connection',\n            this._socket.remoteAddress,\n            this._socket.remotePort\n        );\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeListener('data', this._onSocketData);\n        this._socket.removeListener('timeout', this._onSocketTimeout);\n        this._socket.removeListener('close', this._onSocketClose);\n        this._socket.removeListener('end', this._onSocketEnd);\n\n        this._socket.on('data', this._onSocketData);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        if (this._responseQueue.length) {\n            lastline = this._responseQueue[this._responseQueue.length - 1];\n            if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                return;\n            }\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = (typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0])) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        this.logger.info(\n            {\n                tnx: 'network'\n            },\n            'Connection closed'\n        );\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        if (this._socket && !this._socket.destroyed) {\n            this._socket.destroy();\n        }\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        this.upgrading = true;\n        this._socket = tls.connect(opts, () => {\n            this.secure = true;\n            this.upgrading = false;\n            this._socket.on('data', this._onSocketData);\n\n            socketPlain.removeListener('close', this._onSocketClose);\n            socketPlain.removeListener('end', this._onSocketEnd);\n\n            return callback(null, true);\n        });\n\n        this._socket.on('error', this._onSocketError);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());\n\n        if (/^\\d+-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'server'\n                },\n                str.replace(/\\r?\\n$/, '')\n            );\n        }\n\n        if (!str.trim()) {\n            // skip unexpected empty lines\n            setImmediate(() => this._processResponse(true));\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse(true));\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     */\n    _sendCommand(str) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'client'\n                },\n                (str || '').toString().replace(/\\r?\\n$/, '')\n            );\n        }\n\n        this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'FULL';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.orcpt || params.recipient || '').toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return args.length ? ' ' + args.join(' ') : '';\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(this._socket, {\n            end: false\n        });\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug(\n                        {\n                            tnx: 'message'\n                        },\n                        chunk.toString('binary').replace(/\\r?\\n$/, '')\n                    );\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info(\n                {\n                    tnx: 'message',\n                    inByteCount: dataStream.inByteCount,\n                    outByteCount: dataStream.outByteCount\n                },\n                '<%s bytes encoded mime message (source size %s bytes)>',\n                dataStream.outByteCount,\n                dataStream.inByteCount\n            );\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ -]SMTPUTF8\\b/im.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ -]DSN\\b/im.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ -]8BITMIME\\b/im.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ -]PIPELINING\\b/im.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports AUTH\n        if (/[ -]AUTH\\b/i.test(str)) {\n            this.allowsAuth = true;\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        // assume that authentication is enabled (most probably is not though)\n        this.allowsAuth = true;\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'Failed STARTTLS upgrade, continuing unencrypted'\n                );\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info(\n                {\n                    tnx: 'smtp'\n                },\n                'Connection upgraded with STARTTLS'\n            );\n\n            if (secured) {\n                // restart session\n                if (this.options.lmtp) {\n                    this._responseActions.push(this._actionLHLO);\n                    this._sendCommand('LHLO ' + this.name);\n                } else {\n                    this._responseActions.push(this._actionEHLO);\n                    this._sendCommand('EHLO ' + this.name);\n                }\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n            hmac_md5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmac_md5.update(base64decoded);\n\n        let hex_hmac = hmac_md5.digest('hex');\n        let prepended = this._auth.credentials.user + ' ' + hex_hmac;\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(prepended).toString('base64'));\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.pass + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info(\n                {\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                },\n                'User %s failed to authenticate',\n                JSON.stringify(this._auth.user)\n            );\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message,\n            err,\n            curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authfail',\n                        method: this._authMethod\n                    },\n                    'User %s failed to authenticate',\n                    JSON.stringify(this._auth.user)\n                );\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken));\n        });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n    _isDestroyedMessage(command) {\n        if (this._destroyed) {\n            return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n        }\n\n        if (this._socket) {\n            if (this._socket.destroyed) {\n                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n            }\n\n            if (!this._socket.writable) {\n                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n            }\n        }\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname = os.hostname() || '';\n\n        // ignore if not FQDN\n        if (defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n", "'use strict';\n\nconst services = require('./services.json');\nconst normalized = {};\n\nObject.keys(services).forEach(key => {\n    let service = services[key];\n\n    normalized[normalizeKey(key)] = normalizeService(service);\n\n    [].concat(service.aliases || []).forEach(alias => {\n        normalized[normalizeKey(alias)] = normalizeService(service);\n    });\n\n    [].concat(service.domains || []).forEach(domain => {\n        normalized[normalizeKey(domain)] = normalizeService(service);\n    });\n});\n\nfunction normalizeKey(key) {\n    return key.replace(/[^a-zA-Z0-9.-]/g, '').toLowerCase();\n}\n\nfunction normalizeService(service) {\n    let filter = ['domains', 'aliases'];\n    let response = {};\n\n    Object.keys(service).forEach(key => {\n        if (filter.indexOf(key) < 0) {\n            response[key] = service[key];\n        }\n    });\n\n    return response;\n}\n\n/**\n * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or\n * an email address (like 'test@googlemail.com').\n *\n * @param {String} key [description]\n * @returns {Object} SMTP config or false if not found\n */\nmodule.exports = function (key) {\n    key = normalizeKey(key.split('@').pop());\n    return normalized[key] || false;\n};\n", "{\n    \"1und1\": {\n        \"host\": \"smtp.1und1.de\",\n        \"port\": 465,\n        \"secure\": true,\n        \"authMethod\": \"LOGIN\"\n    },\n\n    \"AOL\": {\n        \"domains\": [\"aol.com\"],\n        \"host\": \"smtp.aol.com\",\n        \"port\": 587\n    },\n\n    \"DebugMail\": {\n        \"host\": \"debugmail.io\",\n        \"port\": 25\n    },\n\n    \"DynectEmail\": {\n        \"aliases\": [\"Dynect\"],\n        \"host\": \"smtp.dynect.net\",\n        \"port\": 25\n    },\n\n    \"Ethereal\": {\n        \"aliases\": [\"ethereal.email\"],\n        \"host\": \"smtp.ethereal.email\",\n        \"port\": 587\n    },\n\n    \"FastMail\": {\n        \"domains\": [\"fastmail.fm\"],\n        \"host\": \"smtp.fastmail.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"GandiMail\": {\n        \"aliases\": [\"Gandi\", \"Gandi Mail\"],\n        \"host\": \"mail.gandi.net\",\n        \"port\": 587\n    },\n\n    \"Gmail\": {\n        \"aliases\": [\"Google Mail\"],\n        \"domains\": [\"gmail.com\", \"googlemail.com\"],\n        \"host\": \"smtp.gmail.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Godaddy\": {\n        \"host\": \"smtpout.secureserver.net\",\n        \"port\": 25\n    },\n\n    \"GodaddyAsia\": {\n        \"host\": \"smtp.asia.secureserver.net\",\n        \"port\": 25\n    },\n\n    \"GodaddyEurope\": {\n        \"host\": \"smtp.europe.secureserver.net\",\n        \"port\": 25\n    },\n\n    \"hot.ee\": {\n        \"host\": \"mail.hot.ee\"\n    },\n\n    \"Hotmail\": {\n        \"aliases\": [\"Outlook\", \"Outlook.com\", \"Hotmail.com\"],\n        \"domains\": [\"hotmail.com\", \"outlook.com\"],\n        \"host\": \"smtp.live.com\",\n        \"port\": 587\n    },\n\n    \"iCloud\": {\n        \"aliases\": [\"Me\", \"Mac\"],\n        \"domains\": [\"me.com\", \"mac.com\"],\n        \"host\": \"smtp.mail.me.com\",\n        \"port\": 587\n    },\n\n    \"mail.ee\": {\n        \"host\": \"smtp.mail.ee\"\n    },\n\n    \"Mail.ru\": {\n        \"host\": \"smtp.mail.ru\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Maildev\": {\n        \"port\": 1025,\n        \"ignoreTLS\": true\n    },\n\n    \"Mailgun\": {\n        \"host\": \"smtp.mailgun.org\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Mailjet\": {\n        \"host\": \"in.mailjet.com\",\n        \"port\": 587\n    },\n\n    \"Mailosaur\": {\n        \"host\": \"mailosaur.io\",\n        \"port\": 25\n    },\n\n    \"Mailtrap\": {\n        \"host\": \"smtp.mailtrap.io\",\n        \"port\": 2525\n    },\n\n    \"Mandrill\": {\n        \"host\": \"smtp.mandrillapp.com\",\n        \"port\": 587\n    },\n\n    \"Naver\": {\n        \"host\": \"smtp.naver.com\",\n        \"port\": 587\n    },\n\n    \"One\": {\n        \"host\": \"send.one.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"OpenMailBox\": {\n        \"aliases\": [\"OMB\", \"openmailbox.org\"],\n        \"host\": \"smtp.openmailbox.org\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Outlook365\": {\n        \"host\": \"smtp.office365.com\",\n        \"port\": 587,\n        \"secure\": false\n    },\n\n    \"Postmark\": {\n        \"aliases\": [\"PostmarkApp\"],\n        \"host\": \"smtp.postmarkapp.com\",\n        \"port\": 2525\n    },\n\n    \"qiye.aliyun\": {\n        \"host\": \"smtp.mxhichina.com\",\n        \"port\": \"465\",\n        \"secure\": true\n    },\n\n    \"QQ\": {\n        \"domains\": [\"qq.com\"],\n        \"host\": \"smtp.qq.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"QQex\": {\n        \"aliases\": [\"QQ Enterprise\"],\n        \"domains\": [\"exmail.qq.com\"],\n        \"host\": \"smtp.exmail.qq.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SendCloud\": {\n        \"host\": \"smtpcloud.sohu.com\",\n        \"port\": 25\n    },\n\n    \"SendGrid\": {\n        \"host\": \"smtp.sendgrid.net\",\n        \"port\": 587\n    },\n\n    \"SendinBlue\": {\n        \"host\": \"smtp-relay.sendinblue.com\",\n        \"port\": 587\n    },\n\n    \"SendPulse\": {\n        \"host\": \"smtp-pulse.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES\": {\n        \"host\": \"email-smtp.us-east-1.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES-US-EAST-1\": {\n        \"host\": \"email-smtp.us-east-1.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES-US-WEST-2\": {\n        \"host\": \"email-smtp.us-west-2.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"SES-EU-WEST-1\": {\n        \"host\": \"email-smtp.eu-west-1.amazonaws.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Sparkpost\": {\n        \"aliases\": [\"SparkPost\", \"SparkPost Mail\"],\n        \"domains\": [\"sparkpost.com\"],\n        \"host\": \"smtp.sparkpostmail.com\",\n        \"port\": 587,\n        \"secure\": false\n    },\n\n    \"Tipimail\": {\n        \"host\": \"smtp.tipimail.com\",\n        \"port\": 587\n    },\n\n    \"Yahoo\": {\n        \"domains\": [\"yahoo.com\"],\n        \"host\": \"smtp.mail.yahoo.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Yandex\": {\n        \"domains\": [\"yandex.ru\"],\n        \"host\": \"smtp.yandex.ru\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"Zoho\": {\n        \"host\": \"smtp.zoho.com\",\n        \"port\": 465,\n        \"secure\": true,\n        \"authMethod\": \"LOGIN\"\n    },\n\n    \"126\": {\n        \"host\": \"smtp.126.com\",\n        \"port\": 465,\n        \"secure\": true\n    },\n\n    \"163\": {\n        \"host\": \"smtp.163.com\",\n        \"port\": 465,\n        \"secure\": true\n    }\n}\n", "'use strict';\n\nconst Stream = require('stream').Stream;\nconst fetch = require('../fetch');\nconst crypto = require('crypto');\nconst shared = require('../shared');\n\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\nclass XOAuth2 extends Stream {\n    constructor(options, logger) {\n        super();\n\n        this.options = options || {};\n\n        if (options && options.serviceClient) {\n            if (!options.privateKey || !options.user) {\n                setImmediate(() => this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!')));\n                return;\n            }\n\n            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);\n            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n        }\n\n        this.logger = shared.getLogger(\n            {\n                logger\n            },\n            {\n                component: this.options.component || 'OAuth2'\n            }\n        );\n\n        this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;\n\n        this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n        this.options.customHeaders = this.options.customHeaders || {};\n        this.options.customParams = this.options.customParams || {};\n\n        this.accessToken = this.options.accessToken || false;\n\n        if (this.options.expires && Number(this.options.expires)) {\n            this.expires = this.options.expires;\n        } else {\n            let timeout = Math.max(Number(this.options.timeout) || 0, 0);\n            this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n        }\n    }\n\n    /**\n     * Returns or generates (if previous has expired) a XOAuth2 token\n     *\n     * @param {Boolean} renew If false then use cached access token (if available)\n     * @param {Function} callback Callback function with error object and token string\n     */\n    getToken(renew, callback) {\n        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n            return callback(null, this.accessToken);\n        }\n\n        let generateCallback = (...args) => {\n            if (args[0]) {\n                this.logger.error(\n                    {\n                        err: args[0],\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Failed generating new Access Token for %s',\n                    this.options.user\n                );\n            } else {\n                this.logger.info(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Generated new Access Token for %s',\n                    this.options.user\n                );\n            }\n            callback(...args);\n        };\n\n        if (this.provisionCallback) {\n            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {\n                if (!err && accessToken) {\n                    this.accessToken = accessToken;\n                    this.expires = expires || 0;\n                }\n                generateCallback(err, accessToken);\n            });\n        } else {\n            this.generateToken(generateCallback);\n        }\n    }\n\n    /**\n     * Updates token values\n     *\n     * @param {String} accessToken New access token\n     * @param {Number} timeout Access token lifetime in seconds\n     *\n     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n     */\n    updateToken(accessToken, timeout) {\n        this.accessToken = accessToken;\n        timeout = Math.max(Number(timeout) || 0, 0);\n        this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n\n        this.emit('token', {\n            user: this.options.user,\n            accessToken: accessToken || '',\n            expires: this.expires\n        });\n    }\n\n    /**\n     * Generates a new XOAuth2 token with the credentials provided at initialization\n     *\n     * @param {Function} callback Callback function with error object and token string\n     */\n    generateToken(callback) {\n        let urlOptions;\n        let loggedUrlOptions;\n        if (this.options.serviceClient) {\n            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n            let iat = Math.floor(Date.now() / 1000); // unix time\n            let tokenData = {\n                iss: this.options.serviceClient,\n                scope: this.options.scope || 'https://mail.google.com/',\n                sub: this.options.user,\n                aud: this.options.accessUrl,\n                iat,\n                exp: iat + this.options.serviceRequestTimeout\n            };\n            let token;\n            try {\n                token = this.jwtSignRS256(tokenData);\n            } catch (err) {\n                return callback(new Error('Can\\x27t generate token. Check your auth options'));\n            }\n\n            urlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: token\n            };\n\n            loggedUrlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: tokenData\n            };\n        } else {\n            if (!this.options.refreshToken) {\n                return callback(new Error('Can\\x27t create new access token for user'));\n            }\n\n            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n            urlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: this.options.clientSecret || '',\n                refresh_token: this.options.refreshToken,\n                grant_type: 'refresh_token'\n            };\n\n            loggedUrlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n                refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n                grant_type: 'refresh_token'\n            };\n        }\n\n        Object.keys(this.options.customParams).forEach(key => {\n            urlOptions[key] = this.options.customParams[key];\n            loggedUrlOptions[key] = this.options.customParams[key];\n        });\n\n        this.logger.debug(\n            {\n                tnx: 'OAUTH2',\n                user: this.options.user,\n                action: 'generate'\n            },\n            'Requesting token using: %s',\n            JSON.stringify(loggedUrlOptions)\n        );\n\n        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {\n            let data;\n\n            if (error) {\n                return callback(error);\n            }\n\n            try {\n                data = JSON.parse(body.toString());\n            } catch (E) {\n                return callback(E);\n            }\n\n            if (!data || typeof data !== 'object') {\n                this.logger.debug(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'post'\n                    },\n                    'Response: %s',\n                    (body || '').toString()\n                );\n                return callback(new Error('Invalid authentication response'));\n            }\n\n            let logData = {};\n            Object.keys(data).forEach(key => {\n                if (key !== 'access_token') {\n                    logData[key] = data[key];\n                } else {\n                    logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n                }\n            });\n\n            this.logger.debug(\n                {\n                    tnx: 'OAUTH2',\n                    user: this.options.user,\n                    action: 'post'\n                },\n                'Response: %s',\n                JSON.stringify(logData)\n            );\n\n            if (data.error) {\n                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2\n                let errorMessage = data.error;\n                if (data.error_description) {\n                    errorMessage += ': ' + data.error_description;\n                }\n                if (data.error_uri) {\n                    errorMessage += ' (' + data.error_uri + ')';\n                }\n                return callback(new Error(errorMessage));\n            }\n\n            if (data.access_token) {\n                this.updateToken(data.access_token, data.expires_in);\n                return callback(null, this.accessToken);\n            }\n\n            return callback(new Error('No access token'));\n        });\n    }\n\n    /**\n     * Converts an access_token and user id into a base64 encoded XOAuth2 token\n     *\n     * @param {String} [accessToken] Access token string\n     * @return {String} Base64 encoded token for IMAP or SMTP login\n     */\n    buildXOAuth2Token(accessToken) {\n        let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n        return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n    }\n\n    /**\n     * Custom POST request handler.\n     * This is only needed to keep paths short in Windows \u2013 usually this module\n     * is a dependency of a dependency and if it tries to require something\n     * like the request module the paths get way too long to handle for Windows.\n     * As we do only a simple POST request we do not actually require complicated\n     * logic support (no redirects, no nothing) anyway.\n     *\n     * @param {String} url Url to POST to\n     * @param {String|Buffer} payload Payload to POST\n     * @param {Function} callback Callback function with (err, buff)\n     */\n    postRequest(url, payload, params, callback) {\n        let returned = false;\n\n        let chunks = [];\n        let chunklen = 0;\n\n        let req = fetch(url, {\n            method: 'post',\n            headers: params.customHeaders,\n            body: payload,\n            allowErrorResponse: true\n        });\n\n        req.on('readable', () => {\n            let chunk;\n            while ((chunk = req.read()) !== null) {\n                chunks.push(chunk);\n                chunklen += chunk.length;\n            }\n        });\n\n        req.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(err);\n        });\n\n        req.once('end', () => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(null, Buffer.concat(chunks, chunklen));\n        });\n    }\n\n    /**\n     * Encodes a buffer or a string into Base64url format\n     *\n     * @param {Buffer|String} data The data to convert\n     * @return {String} The encoded string\n     */\n    toBase64URL(data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(data);\n        }\n\n        return data\n            .toString('base64')\n            .replace(/[=]+/g, '') // remove '='s\n            .replace(/\\+/g, '-') // '+' \u2192 '-'\n            .replace(/\\//g, '_'); // '/' \u2192 '_'\n    }\n\n    /**\n     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n     *\n     * @param {Object} payload The payload to include in the generated token\n     * @return {String} The generated and signed token\n     */\n    jwtSignRS256(payload) {\n        payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');\n        let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n        return payload + '.' + this.toBase64URL(signature);\n    }\n}\n\nmodule.exports = XOAuth2;\n", "{\n    \"name\": \"nodemailer\",\n    \"version\": \"6.4.16\",\n    \"description\": \"Easy as cake e-mail sending from your Node.js applications\",\n    \"main\": \"lib/nodemailer.js\",\n    \"scripts\": {\n        \"test\": \"grunt\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/nodemailer/nodemailer.git\"\n    },\n    \"keywords\": [\n        \"Nodemailer\"\n    ],\n    \"author\": \"Andris Reinman\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/nodemailer/nodemailer/issues\"\n    },\n    \"homepage\": \"https://nodemailer.com/\",\n    \"devDependencies\": {\n        \"bunyan\": \"1.8.14\",\n        \"chai\": \"4.2.0\",\n        \"eslint-config-nodemailer\": \"1.2.0\",\n        \"eslint-config-prettier\": \"6.15.0\",\n        \"grunt\": \"1.3.0\",\n        \"grunt-cli\": \"1.3.2\",\n        \"grunt-eslint\": \"23.0.0\",\n        \"grunt-mocha-test\": \"0.13.3\",\n        \"libbase64\": \"1.2.1\",\n        \"libmime\": \"5.0.0\",\n        \"libqp\": \"1.1.0\",\n        \"mocha\": \"8.2.1\",\n        \"nodemailer-ntlm-auth\": \"1.0.1\",\n        \"proxy\": \"1.0.2\",\n        \"proxy-test-server\": \"1.0.0\",\n        \"sinon\": \"9.2.1\",\n        \"smtp-server\": \"3.7.0\"\n    },\n    \"engines\": {\n        \"node\": \">=6.0.0\"\n    },\n    \"dependencies\": {}\n}\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst libbase64 = require('libbase64');\nconst base64 = require('../../lib/base64');\nconst chai = require('chai');\nconst expect = chai.expect;\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nchai.config.includeStack = true;\n\ndescribe('Base64 Tests', function () {\n    let encodeFixtures = [\n        ['abcd= \u00d5\u00c4\u00d6\u00dc', 'YWJjZD0gw5XDhMOWw5w='],\n        ['foo bar  ', 'Zm9vIGJhciAg'],\n        ['foo bar\\t\\t', 'Zm9vIGJhcgkJ'],\n        ['foo \\r\\nbar', 'Zm9vIA0KYmFy']\n    ];\n\n    let wrapFixtures = [['dGVyZSwgdGVyZSwgdmFuYSBrZXJlLCBrdWlkYXMgc3VsIGzDpGhlYj8=', 'dGVyZSwgdGVyZSwgdmFu\\r\\nYSBrZXJlLCBrdWlkYXMg\\r\\nc3VsIGzDpGhlYj8=']];\n\n    let streamFixture = [\n        '123456789012345678  90\\r\\n\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc another line === ',\n        'MTIzNDU2N\\r\\nzg5MDEyMz\\r\\nQ1Njc4ICA\\r\\n5MA0Kw7XD\\r\\npMO2w7zDt\\r\\ncOkw7bDvM\\r\\nO1w6TDtsO\\r\\n8w7XDpMO2\\r\\nw7zDtcOkw\\r\\n7bDvMO1w6\\r\\nTDtsO8w7X\\r\\nDpMO2w7zD\\r\\ntcOkw7bDv\\r\\nCBhbm90aG\\r\\nVyIGxpbmU\\r\\ngPT09IA=='\n    ];\n\n    describe('#encode', function () {\n        it('shoud encode UTF-8 string to base64', function () {\n            encodeFixtures.forEach(function (test) {\n                expect(base64.encode(test[0])).to.equal(test[1]);\n            });\n        });\n\n        it('shoud encode Buffer to base64', function () {\n            expect(base64.encode(Buffer.from([0x00, 0x01, 0x02, 0x20, 0x03]))).to.equal('AAECIAM=');\n        });\n    });\n\n    describe('#wrap', function () {\n        it('should wrap long base64 encoded lines', function () {\n            wrapFixtures.forEach(function (test) {\n                expect(base64.wrap(test[0], 20)).to.equal(test[1]);\n            });\n        });\n    });\n\n    describe('base64 Streams', function () {\n        it('should transform incoming bytes to base64', function (done) {\n            let encoder = new base64.Encoder({\n                lineLength: 9\n            });\n\n            let bytes = Buffer.from(streamFixture[0]),\n                i = 0,\n                buf = [],\n                buflen = 0;\n\n            encoder.on('data', function (chunk) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            });\n\n            encoder.on('end', function (chunk) {\n                if (chunk) {\n                    buf.push(chunk);\n                    buflen += chunk.length;\n                }\n                buf = Buffer.concat(buf, buflen);\n\n                expect(buf.toString()).to.equal(streamFixture[1]);\n                done();\n            });\n\n            let sendNextByte = function () {\n                if (i >= bytes.length) {\n                    return encoder.end();\n                }\n\n                let ord = bytes[i++];\n                encoder.write(Buffer.from([ord]));\n                setImmediate(sendNextByte);\n            };\n\n            sendNextByte();\n        });\n\n        it('should transform incoming bytes to base64 and back', function (done) {\n            let decoder = new libbase64.Decoder();\n            let encoder = new base64.Encoder();\n            let file = fs.createReadStream(__dirname + '/fixtures/alice.txt');\n\n            let fhash = crypto.createHash('md5');\n            let dhash = crypto.createHash('md5');\n\n            file.pipe(encoder).pipe(decoder);\n\n            file.on('data', function (chunk) {\n                fhash.update(chunk);\n            });\n\n            file.on('end', function () {\n                fhash = fhash.digest('hex');\n            });\n\n            decoder.on('data', function (chunk) {\n                dhash.update(chunk);\n            });\n\n            decoder.on('end', function () {\n                dhash = dhash.digest('hex');\n                expect(fhash).to.equal(dhash);\n                done();\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst path = require('path');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst PassThrough = require('stream').PassThrough;\nconst DKIM = require('../../lib/dkim');\n\nchai.config.includeStack = true;\n\nconst privateKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIBywIBAAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8knBf3+uA7q/CSxpX6sQ8N\ndFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44ARpgHY4V0qSCdUt4rD32n\nwfjlGbh8p5ua5wIDAQABAmAm+uUQpQPTu7kg95wqVqw2sxLsa9giT6M8MtxQH7Uo\n1TF0eAO0TQ4KOxgY1S9OT5sGPVKnag258m3qX7o5imawcuyStb68DQgAUg6xv7Af\nAqAEDfYN5HW6xK+X81jfOUECMQDr7XAS4PERATvgb1B3vRu5UEbuXcenHDYgdoyT\n3qJFViTbep4qeaflF0uF9eFveMcCMQDic10rJ8fopGD7/a45O4VJb0+lRXVdqZxJ\nQzAp+zVKWqDqPfX7L93SQLzOGhdd7OECMQDeQyD7WBkjSQNMy/GF7I1qxrscIxNN\nVqGTcbu8Lti285Hjhx/sqhHHHGwU9vB7oM8CMQDKTS3Kw/s/xrot5O+kiZwFgr+w\ncmDrj/7jJHb+ykFNb7GaEkiSYqzUjKkfpweBDYECMFJUyzuuFJAjq3BXmGJlyykQ\nTweUw+zMVdSXjO+FCPcYNi6CP1t1KoESzGKBVoqA/g==\n-----END RSA PRIVATE KEY-----`;\n\n/*\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMHwwDQYJKoZIhvcNAQEBBQADawAwaAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8k\nnBf3+uA7q/CSxpX6sQ8NdFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44A\nRpgHY4V0qSCdUt4rD32nwfjlGbh8p5ua5wIDAQAB\n-----END PUBLIC KEY-----`;\n*/\n\ndescribe('DKIM Tests', function () {\n    this.timeout(100 * 1000); // eslint-disable-line\n\n    it('should sign message', function (done) {\n        let message = `From: saatja aadress\nTo: Saaja aadress\nSubject: pealkiri\n  mitmel\n  real\nMessage-Id: test\n\ntere tere\nteine rida\n`;\n        let s = new PassThrough();\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey\n        });\n\n        let output = dkim.sign(s);\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read(10 * 1024);\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message).to.equal(\n                'DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=node.ee; q=dns/txt;\\r\\n' +\n                    ' s=dkim; bh=h2JdEKA6yVYSGuI3DQCDlg2KL+96GxA7Yw7owvsYDUM=;\\r\\n' +\n                    ' h=from:subject:message-id:to;\\r\\n' +\n                    ' b=tey8mL2VQVuy/phh7yEKi86Y0Yyzyy04qTy73G4yg3qdEDB7uymjNr32ruRPVFmC9PimIK75p\\r\\n' +\n                    ' KVPF5T1oB8/oY6TFqyyuECRrI4D2CfG3VXWBShK32r1Wtv7eWN04b4s\\r\\n' +\n                    'From: saatja aadress\\n' +\n                    'To: Saaja aadress\\n' +\n                    'Subject: pealkiri\\n' +\n                    '  mitmel\\n' +\n                    '  real\\n' +\n                    'Message-Id: test\\n' +\n                    '\\n' +\n                    'tere tere\\n' +\n                    'teine rida\\n'\n            );\n            done();\n        });\n\n        let inputPos = 0;\n        let messageBuf = Buffer.from(message);\n        let writeNext = () => {\n            if (inputPos >= messageBuf.length) {\n                return s.end();\n            }\n            s.write(Buffer.from([messageBuf[inputPos++]]));\n            setImmediate(writeNext);\n        };\n        writeNext();\n    });\n\n    it('should sign large message using cache dir', function (done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: path.join(__dirname, 'cache')\n        });\n\n        let output = dkim.sign(fs.createReadStream(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.true;\n            done();\n        });\n    });\n\n    it('should sign large message without cache dir', function (done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey\n        });\n\n        let output = dkim.sign(fs.createReadStream(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.false;\n            done();\n        });\n    });\n\n    it('should emit cache error', function (done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: '/rootertewywrtyreetwert' // expecting that this location does not exist or is unwritable\n        });\n\n        let output = dkim.sign(fs.createReadStream(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.exist;\n            done();\n        });\n    });\n\n    it('should sign large message as Buffer', function (done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: path.join(__dirname, 'cache')\n        });\n\n        let output = dkim.sign(fs.readFileSync(__dirname + '/fixtures/large.eml'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.true;\n            done();\n        });\n    });\n\n    it('should sign large message as String', function (done) {\n        let dkim = new DKIM({\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey,\n            cacheDir: path.join(__dirname, 'cache')\n        });\n\n        let output = dkim.sign(fs.readFileSync(__dirname + '/fixtures/large.eml', 'utf-8'));\n        output.on('error', err => {\n            expect(err).to.not.exist;\n            done();\n        });\n\n        let chunks = [];\n\n        let reading = false;\n        let readNext = () => {\n            let chunk = output.read();\n            if (chunk === null) {\n                reading = false;\n                return;\n            }\n            reading = true;\n            chunks.push(chunk);\n            setImmediate(readNext);\n        };\n\n        output.on('readable', () => {\n            if (!reading) {\n                readNext();\n            }\n        });\n\n        output.on('end', () => {\n            let message = Buffer.concat(chunks).toString();\n            expect(message.indexOf('bh=ST+2Z7mCDd8CPa6pWbCWnFBLKyl8/I5d0JCaEQub550=')).is.gte(0);\n            expect(\n                crypto\n                    .createHash('md5')\n                    .update(Buffer.from(message.substr(message.indexOf('X-Zone-Loop'))))\n                    .digest('hex')\n            ).to.equal('16078d67ecb4c9954f2568b3bd20e8b5');\n            expect(output.usingCache).to.be.true;\n            done();\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\n//let http = require('http');\nconst MessageParser = require('../../lib/dkim/message-parser');\n\nchai.config.includeStack = true;\n\ndescribe('DKIM MessageParser Tests', function () {\n    it('should extract header and body', function (done) {\n        let parser = new MessageParser();\n        let message = `From: saatja aadress\nTo: Saaja aadress\nSubject: pealkiri\n  mitmel\n  real\nMessage-Id: test\n\ntere tere\nteine rida\n`;\n\n        let chunks = [];\n        let headers = false;\n        let end = false;\n\n        parser.on('data', chunk => {\n            chunks.push(chunk);\n        });\n\n        parser.on('end', () => {\n            end = true;\n            let body = Buffer.concat(chunks).toString();\n            expect(body).to.equal('tere tere\\nteine rida\\n');\n            if (headers) {\n                return done();\n            }\n        });\n\n        parser.on('headers', data => {\n            expect(data).to.deep.equal([\n                // fix auto format\n                {\n                    key: 'from',\n                    line: 'From: saatja aadress'\n                },\n                {\n                    key: 'to',\n                    line: 'To: Saaja aadress'\n                },\n                {\n                    key: 'subject',\n                    line: 'Subject: pealkiri\\n  mitmel\\n  real'\n                },\n                {\n                    key: 'message-id',\n                    line: 'Message-Id: test'\n                }\n            ]);\n            headers = true;\n            if (end) {\n                return done();\n            }\n        });\n\n        parser.end(Buffer.from(message));\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\nlet fs = require('fs');\nlet RelaxedBody = require('../../lib/dkim/relaxed-body');\n\nchai.config.includeStack = true;\n\ndescribe('DKIM RelaxedBody Tests', function () {\n    it('Should calculate body hash byte by byte', function (done) {\n        fs.readFile(__dirname + '/fixtures/message1.eml', 'utf-8', (err, message) => {\n            expect(err).to.not.exist;\n\n            message = message.replace(/\\r?\\n/g, '\\r\\n');\n            message = message.split('\\r\\n\\r\\n');\n            message.shift();\n            message = message.join('\\r\\n\\r\\n');\n\n            message = Buffer.from(message);\n\n            let s = new RelaxedBody({\n                hashAlgo: 'sha256',\n                debug: true\n            });\n\n            s.on('hash', hash => {\n                expect(hash).to.equal('D2H5TEwtUgM2u8Ew0gG6vnt/Na6L+Zep7apmSmfy8IQ=');\n                done();\n            });\n\n            let pos = 0;\n            let stream = () => {\n                if (pos >= message.length) {\n                    return s.end();\n                }\n                let ord = Buffer.from([message[pos++]]);\n                s.write(ord);\n                setImmediate(stream);\n            };\n            setImmediate(stream);\n        });\n    });\n\n    it('Should calculate body hash all at once', function (done) {\n        fs.readFile(__dirname + '/fixtures/message1.eml', 'utf-8', (err, message) => {\n            expect(err).to.not.exist;\n\n            message = message.replace(/\\r?\\n/g, '\\r\\n');\n            message = message.split('\\r\\n\\r\\n');\n            message.shift();\n            message = message.join('\\r\\n\\r\\n');\n\n            message = Buffer.from(message);\n\n            let s = new RelaxedBody({\n                hashAlgo: 'sha256',\n                debug: true\n            });\n\n            s.on('hash', hash => {\n                expect(hash).to.equal('D2H5TEwtUgM2u8Ew0gG6vnt/Na6L+Zep7apmSmfy8IQ=');\n                done();\n            });\n\n            setImmediate(() => s.end(message));\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\nlet sign = require('../../lib/dkim/sign');\n\nchai.config.includeStack = true;\n\nconst privateKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIBywIBAAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8knBf3+uA7q/CSxpX6sQ8N\ndFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44ARpgHY4V0qSCdUt4rD32n\nwfjlGbh8p5ua5wIDAQABAmAm+uUQpQPTu7kg95wqVqw2sxLsa9giT6M8MtxQH7Uo\n1TF0eAO0TQ4KOxgY1S9OT5sGPVKnag258m3qX7o5imawcuyStb68DQgAUg6xv7Af\nAqAEDfYN5HW6xK+X81jfOUECMQDr7XAS4PERATvgb1B3vRu5UEbuXcenHDYgdoyT\n3qJFViTbep4qeaflF0uF9eFveMcCMQDic10rJ8fopGD7/a45O4VJb0+lRXVdqZxJ\nQzAp+zVKWqDqPfX7L93SQLzOGhdd7OECMQDeQyD7WBkjSQNMy/GF7I1qxrscIxNN\nVqGTcbu8Lti285Hjhx/sqhHHHGwU9vB7oM8CMQDKTS3Kw/s/xrot5O+kiZwFgr+w\ncmDrj/7jJHb+ykFNb7GaEkiSYqzUjKkfpweBDYECMFJUyzuuFJAjq3BXmGJlyykQ\nTweUw+zMVdSXjO+FCPcYNi6CP1t1KoESzGKBVoqA/g==\n-----END RSA PRIVATE KEY-----`;\n\n/*\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMHwwDQYJKoZIhvcNAQEBBQADawAwaAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8k\nnBf3+uA7q/CSxpX6sQ8NdFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44A\nRpgHY4V0qSCdUt4rD32nwfjlGbh8p5ua5wIDAQAB\n-----END PUBLIC KEY-----`;\n*/\n\ndescribe('DKIM Sign Tests', function () {\n    it('should create relaxed headers', function () {\n        let headerLines = [\n            {\n                key: 'a',\n                line: 'A: X'\n            },\n            {\n                key: 'b',\n                line: 'B: Y\\t\\r\\n\\tZ  '\n            }\n        ];\n        expect(sign.relaxedHeaders(headerLines, 'a:b:c:d')).to.deep.equal({\n            headers: 'a:X\\r\\nb:Y Z\\r\\n',\n            fieldNames: 'a:b'\n        });\n    });\n\n    it('should skip specific headers', function () {\n        let headerLines = [\n            {\n                key: 'a',\n                line: 'A: X'\n            },\n            {\n                key: 'b',\n                line: 'B: Y\\t\\r\\n\\tZ  '\n            },\n            {\n                key: 'c',\n                line: 'C: X'\n            },\n            {\n                key: 'd',\n                line: 'D: X'\n            }\n        ];\n        expect(sign.relaxedHeaders(headerLines, 'a:b:c:d', 'a:c')).to.deep.equal({\n            headers: 'b:Y Z\\r\\nd:X\\r\\n',\n            fieldNames: 'b:d'\n        });\n    });\n\n    it('should sign headers', function () {\n        let headerLines = [\n            {\n                key: 'from',\n                line: 'From: andris@node.ee'\n            },\n            {\n                key: 'to',\n                line: 'To:andris@kreata.ee'\n            },\n            {\n                key: 'message-id',\n                line: 'Message-ID: <testkiri@kreata.ee>'\n            }\n        ];\n\n        let dkimField = sign(headerLines, 'sha256', 'z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=', {\n            skipFields: 'message-id:references',\n            domainName: 'node.ee',\n            keySelector: 'dkim',\n            privateKey\n        });\n        expect(dkimField.replace(/\\r?\\n\\s*/g, '').replace(/\\s+/g, '')).to.equal(\n            'DKIM-Signature:v=1;a=rsa-sha256;c=relaxed/relaxed;d=node.ee;q=dns/txt;s=dkim;bh=z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=;h=from:to;b=pVd+Dp+EjmYBcc1AWlBAP4ESpuAJ2WMS4gbxWLoeUZ1vZRodVN7K9UXvcCsLuqjJktCZMN2+8dyEUaYW2VIcxg4sVBCS1wqB/tqYZ/gxXLnG2/nZf4fyD2vxltJP4pDL'\n        );\n    });\n\n    it('should sign headers for unicode domain', function () {\n        let headerLines = [\n            {\n                key: 'from',\n                line: 'From: andris@node.ee'\n            },\n            {\n                key: 'to',\n                line: 'To:andris@kreata.ee'\n            }\n        ];\n\n        let dkimField = sign(headerLines, 'sha256', 'z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=', {\n            domainName: 'm\u00fcriaad-pol\u00fcteism.info',\n            keySelector: 'dkim',\n            privateKey\n        });\n        expect(dkimField.replace(/\\r?\\n\\s*/g, '').replace(/\\s+/g, '')).to.equal(\n            'DKIM-Signature:v=1;a=rsa-sha256;c=relaxed/relaxed;d=xn--mriaad-polteism-zvbj.info;q=dns/txt;s=dkim;bh=z6TUz85EdYrACGMHYgZhJGvVy5oQI0dooVMKa2ZT7c4=;h=from:to;b=oBJ1MkwEkftfXa2AK4Expjp2xgIcAR43SVrftSEHVQ6F1SlGjP3EKP+cn/hLkhUel3rY0icthk/myDu6uhTBmM6DMtzIBW/7uQd6q9hfgaiYnw5Iew2tZc4TzBEYSdKi'\n        );\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst nodemailer = require('../lib/nodemailer');\nconst chai = require('chai');\nconst expect = chai.expect;\nchai.config.includeStack = true;\n\ndescribe('Ethereal Tests', function () {\n    this.timeout(50 * 1000); // eslint-disable-line no-invalid-this\n    it('should create an account and send a message', function (done) {\n        // Generate SMTP service account from ethereal.email\n        nodemailer.createTestAccount((err, account) => {\n            expect(err).to.not.exist;\n            expect(account.user).to.exist;\n\n            let transporter = nodemailer.createTransport({\n                host: account.smtp.host,\n                port: account.smtp.port,\n                secure: account.smtp.secure,\n                auth: {\n                    user: account.user,\n                    pass: account.pass\n                }\n            });\n\n            // Message object\n            let message = {\n                from: 'Pangalink <no-reply@pangalink.net>',\n                to: 'Andris Reinman <andris.reinman@gmail.com>',\n                subject: 'Ethereal unit test message',\n                text: 'Hello world',\n                html: '<p>Hello world</p>'\n            };\n\n            transporter.sendMail(message, (err, info) => {\n                expect(err).to.not.exist;\n                expect(nodemailer.getTestMessageUrl(info)).to.include('ethereal');\n                done();\n            });\n        });\n    });\n\n    it('should cache a created test account', function (done) {\n        nodemailer.createTestAccount((err, account) => {\n            expect(err).to.not.exist;\n            nodemailer.createTestAccount((err, account2) => {\n                expect(err).to.not.exist;\n                expect(account2).to.equal(account);\n                done();\n            });\n        });\n    });\n\n    it('should cache a created test account when using promises', function (done) {\n        nodemailer.createTestAccount().then(account => {\n            nodemailer.createTestAccount().then(account2 => {\n                expect(account2).to.equal(account);\n                done();\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\n//let http = require('http');\nconst Cookies = require('../../lib/fetch/cookies');\n\nchai.config.includeStack = true;\n\ndescribe('Cookie Tests', function () {\n    let biskviit;\n\n    beforeEach(function () {\n        biskviit = new Cookies();\n    });\n\n    describe('#getPath', function () {\n        it('should return root path', function () {\n            expect(biskviit.getPath('/')).to.equal('/');\n            expect(biskviit.getPath('')).to.equal('/');\n            expect(biskviit.getPath('/index.php')).to.equal('/');\n        });\n\n        it('should return without file', function () {\n            expect(biskviit.getPath('/path/to/file')).to.equal('/path/to/');\n        });\n    });\n\n    describe('#isExpired', function () {\n        it('should match expired cookie', function () {\n            expect(\n                biskviit.isExpired({\n                    name: 'a',\n                    value: 'b',\n                    expires: new Date(Date.now() + 10000)\n                })\n            ).to.be.false;\n\n            expect(\n                biskviit.isExpired({\n                    name: 'a',\n                    value: '',\n                    expires: new Date(Date.now() + 10000)\n                })\n            ).to.be.true;\n\n            expect(\n                biskviit.isExpired({\n                    name: 'a',\n                    value: 'b',\n                    expires: new Date(Date.now() - 10000)\n                })\n            ).to.be.true;\n        });\n    });\n\n    describe('#compare', function () {\n        it('should match similar cookies', function () {\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.true;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'yyy',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/amp',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'examples.com',\n                        secure: false,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n\n            expect(\n                biskviit.compare(\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: false,\n                        httponly: false\n                    },\n                    {\n                        name: 'zzz',\n                        path: '/',\n                        domain: 'example.com',\n                        secure: true,\n                        httponly: false\n                    }\n                )\n            ).to.be.false;\n        });\n    });\n\n    describe('#add', function () {\n        it('should append new cookie', function () {\n            expect(biskviit.cookies.length).to.equal(0);\n            biskviit.add({\n                name: 'zzz',\n                value: 'abc',\n                path: '/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            });\n            expect(biskviit.cookies.length).to.equal(1);\n            expect(biskviit.cookies[0].name).to.equal('zzz');\n            expect(biskviit.cookies[0].value).to.equal('abc');\n        });\n\n        it('should update existing cookie', function () {\n            expect(biskviit.cookies.length).to.equal(0);\n            biskviit.add({\n                name: 'zzz',\n                value: 'abc',\n                path: '/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            });\n            biskviit.add({\n                name: 'zzz',\n                value: 'def',\n                path: '/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            });\n            expect(biskviit.cookies.length).to.equal(1);\n            expect(biskviit.cookies[0].name).to.equal('zzz');\n            expect(biskviit.cookies[0].value).to.equal('def');\n        });\n    });\n\n    describe('#match', function () {\n        it('should check if a cookie matches particular domain and path', function () {\n            let cookie = {\n                name: 'zzz',\n                value: 'abc',\n                path: '/def/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            };\n            expect(biskviit.match(cookie, 'http://example.com/def/')).to.be.true;\n            expect(biskviit.match(cookie, 'http://example.com/bef/')).to.be.false;\n        });\n\n        it('should check if a cookie matches particular domain and path', function () {\n            let cookie = {\n                name: 'zzz',\n                value: 'abc',\n                path: '/def',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: false,\n                httponly: false\n            };\n            expect(biskviit.match(cookie, 'http://example.com/def/')).to.be.true;\n            expect(biskviit.match(cookie, 'http://example.com/bef/')).to.be.false;\n        });\n\n        it('should check if a cookie is secure', function () {\n            let cookie = {\n                name: 'zzz',\n                value: 'abc',\n                path: '/def/',\n                expires: new Date(Date.now() + 10000),\n                domain: 'example.com',\n                secure: true,\n                httponly: false\n            };\n            expect(biskviit.match(cookie, 'https://example.com/def/')).to.be.true;\n            expect(biskviit.match(cookie, 'http://example.com/def/')).to.be.false;\n        });\n    });\n\n    describe('#parse', function () {\n        it('should parse Set-Cookie value', function () {\n            expect(biskviit.parse('theme=plain')).to.deep.equal({\n                name: 'theme',\n                value: 'plain'\n            });\n\n            expect(biskviit.parse('SSID=Ap4P\u2026.GTEq; Domain=foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly')).to.deep.equal({\n                name: 'ssid',\n                value: 'Ap4P\u2026.GTEq',\n                domain: '.foo.com',\n                path: '/',\n                httponly: true,\n                secure: true,\n                expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n            });\n        });\n\n        it('should ignore invalid expire header', function () {\n            expect(biskviit.parse('theme=plain; Expires=Wed, 13 Jan 2021 22:23:01 GMT')).to.deep.equal({\n                name: 'theme',\n                value: 'plain',\n                expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n            });\n\n            expect(biskviit.parse('theme=plain; Expires=ZZZZZZZZ GMT')).to.deep.equal({\n                name: 'theme',\n                value: 'plain'\n            });\n        });\n    });\n\n    describe('Listing', function () {\n        beforeEach(function () {\n            biskviit.cookies = [\n                {\n                    name: 'ssid1',\n                    value: 'Ap4P\u2026.GTEq1',\n                    domain: '.foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid2',\n                    value: 'Ap4P\u2026.GTEq2',\n                    domain: '.foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 1900 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid3',\n                    value: 'Ap4P\u2026.GTEq3',\n                    domain: 'foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid4',\n                    value: 'Ap4P\u2026.GTEq4',\n                    domain: 'www.foo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                },\n                {\n                    name: 'ssid5',\n                    value: 'Ap4P\u2026.GTEq5',\n                    domain: 'broo.com',\n                    path: '/',\n                    httponly: true,\n                    secure: true,\n                    expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                }\n            ];\n        });\n\n        describe('#list', function () {\n            it('should return matching cookies for an URL', function () {\n                expect(biskviit.list('https://www.foo.com')).to.deep.equal([\n                    {\n                        name: 'ssid1',\n                        value: 'Ap4P\u2026.GTEq1',\n                        domain: '.foo.com',\n                        path: '/',\n                        httponly: true,\n                        secure: true,\n                        expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                    },\n                    {\n                        name: 'ssid4',\n                        value: 'Ap4P\u2026.GTEq4',\n                        domain: 'www.foo.com',\n                        path: '/',\n                        httponly: true,\n                        secure: true,\n                        expires: new Date('Wed, 13 Jan 2021 22:23:01 GMT')\n                    }\n                ]);\n            });\n        });\n\n        describe('#get', function () {\n            it('should return matching cookies for an URL', function () {\n                expect(biskviit.get('https://www.foo.com')).to.equal('ssid1=Ap4P\u2026.GTEq1; ssid4=Ap4P\u2026.GTEq4');\n            });\n        });\n    });\n\n    describe('#set', function () {\n        it('should set cookie', function () {\n            // short\n            biskviit.set('theme=plain', 'https://foo.com/');\n            // long\n            biskviit.set('SSID=Ap4P\u2026.GTEq; Domain=foo.com; Path=/test; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly', 'https://foo.com/');\n            // subdomains\n            biskviit.set('SSID=Ap4P\u2026.GTEq; Domain=.foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly', 'https://www.foo.com/');\n            // invalid cors\n            biskviit.set('invalid_1=cors; domain=example.com', 'https://foo.com/');\n            biskviit.set('invalid_2=cors; domain=www.foo.com', 'https://foo.com/');\n            // invalid date\n            biskviit.set('invalid_3=date; Expires=zzzz', 'https://foo.com/');\n            // invalid tld\n            biskviit.set('invalid_4=cors; domain=.co.uk', 'https://foo.co.uk/');\n            // should not be added\n            biskviit.set('expired_1=date; Expires=1999-01-01 01:01:01 GMT', 'https://foo.com/');\n\n            expect(\n                biskviit.cookies.map(function (cookie) {\n                    delete cookie.expires;\n                    return cookie;\n                })\n            ).to.deep.equal([\n                {\n                    name: 'theme',\n                    value: 'plain',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'ssid',\n                    value: 'Ap4P\u2026.GTEq',\n                    domain: 'foo.com',\n                    path: '/test',\n                    secure: true,\n                    httponly: true\n                },\n                {\n                    name: 'ssid',\n                    value: 'Ap4P\u2026.GTEq',\n                    domain: 'www.foo.com',\n                    path: '/',\n                    secure: true,\n                    httponly: true\n                },\n                {\n                    name: 'invalid_1',\n                    value: 'cors',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'invalid_2',\n                    value: 'cors',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'invalid_3',\n                    value: 'date',\n                    domain: 'foo.com',\n                    path: '/'\n                },\n                {\n                    name: 'invalid_4',\n                    value: 'cors',\n                    domain: 'foo.co.uk',\n                    path: '/'\n                }\n            ]);\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback:0 */\n/* globals afterEach, beforeEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\n\n//let http = require('http');\nconst fetch = require('../../lib/fetch');\nconst http = require('http');\nconst https = require('https');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\n\nchai.config.includeStack = true;\n\nconst HTTP_PORT = 19998;\nconst HTTPS_PORT = 19993;\n\nconst httpsOptions = {\n    key:\n        '-----BEGIN RSA PRIVATE KEY-----\\n' +\n        'MIIEpAIBAAKCAQEA6Z5Qqhw+oWfhtEiMHE32Ht94mwTBpAfjt3vPpX8M7DMCTwHs\\n' +\n        '1xcXvQ4lQ3rwreDTOWdoJeEEy7gMxXqH0jw0WfBx+8IIJU69xstOyT7FRFDvA1yT\\n' +\n        'RXY2yt9K5s6SKken/ebMfmZR+03ND4UFsDzkz0FfgcjrkXmrMF5Eh5UXX/+9YHeU\\n' +\n        'xlp0gMAt+/SumSmgCaysxZLjLpd4uXz+X+JVxsk1ACg1NoEO7lWJC/3WBP7MIcu2\\n' +\n        'wVsMd2XegLT0gWYfT1/jsIH64U/mS/SVXC9QhxMl9Yfko2kx1OiYhDxhHs75RJZh\\n' +\n        'rNRxgfiwgSb50Gw4NAQaDIxr/DJPdLhgnpY6UQIDAQABAoIBAE+tfzWFjJbgJ0ql\\n' +\n        's6Ozs020Sh4U8TZQuonJ4HhBbNbiTtdDgNObPK1uNadeNtgW5fOeIRdKN6iDjVeN\\n' +\n        'AuXhQrmqGDYVZ1HSGUfD74sTrZQvRlWPLWtzdhybK6Css41YAyPFo9k4bJ2ZW2b/\\n' +\n        'p4EEQ8WsNja9oBpttMU6YYUchGxo1gujN8hmfDdXUQx3k5Xwx4KA68dveJ8GasIt\\n' +\n        'd+0Jd/FVwCyyx8HTiF1FF8QZYQeAXxbXJgLBuCsMQJghlcpBEzWkscBR3Ap1U0Zi\\n' +\n        '4oat8wrPZGCblaA6rNkRUVbc/+Vw0stnuJ/BLHbPxyBs6w495yBSjBqUWZMvljNz\\n' +\n        'm9/aK0ECgYEA9oVIVAd0enjSVIyAZNbw11ElidzdtBkeIJdsxqhmXzeIFZbB39Gd\\n' +\n        'bjtAVclVbq5mLsI1j22ER2rHA4Ygkn6vlLghK3ZMPxZa57oJtmL3oP0RvOjE4zRV\\n' +\n        'dzKexNGo9gU/x9SQbuyOmuauvAYhXZxeLpv+lEfsZTqqrvPUGeBiEQcCgYEA8poG\\n' +\n        'WVnykWuTmCe0bMmvYDsWpAEiZnFLDaKcSbz3O7RMGbPy1cypmqSinIYUpURBT/WY\\n' +\n        'wVPAGtjkuTXtd1Cy58m7PqziB7NNWMcsMGj+lWrTPZ6hCHIBcAImKEPpd+Y9vGJX\\n' +\n        'oatFJguqAGOz7rigBq6iPfeQOCWpmprNAuah++cCgYB1gcybOT59TnA7mwlsh8Qf\\n' +\n        'bm+tSllnin2A3Y0dGJJLmsXEPKtHS7x2Gcot2h1d98V/TlWHe5WNEUmx1VJbYgXB\\n' +\n        'pw8wj2ACxl4ojNYqWPxegaLd4DpRbtW6Tqe9e47FTnU7hIggR6QmFAWAXI+09l8y\\n' +\n        'amssNShqjE9lu5YDi6BTKwKBgQCuIlKGViLfsKjrYSyHnajNWPxiUhIgGBf4PI0T\\n' +\n        '/Jg1ea/aDykxv0rKHnw9/5vYGIsM2st/kR7l5mMecg/2Qa145HsLfMptHo1ZOPWF\\n' +\n        '9gcuttPTegY6aqKPhGthIYX2MwSDMM+X0ri6m0q2JtqjclAjG7yG4CjbtGTt/UlE\\n' +\n        'WMlSZwKBgQDslGeLUnkW0bsV5EG3AKRUyPKz/6DVNuxaIRRhOeWVKV101claqXAT\\n' +\n        'wXOpdKrvkjZbT4AzcNrlGtRl3l7dEVXTu+dN7/ZieJRu7zaStlAQZkIyP9O3DdQ3\\n' +\n        'rIcetQpfrJ1cAqz6Ng0pD0mh77vQ13WG1BBmDFa2A9BuzLoBituf4g==\\n' +\n        '-----END RSA PRIVATE KEY-----',\n    cert:\n        '-----BEGIN CERTIFICATE-----\\n' +\n        'MIICpDCCAYwCCQCuVLVKVTXnAjANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwls\\n' +\n        'b2NhbGhvc3QwHhcNMTUwMjEyMTEzMjU4WhcNMjUwMjA5MTEzMjU4WjAUMRIwEAYD\\n' +\n        'VQQDEwlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDp\\n' +\n        'nlCqHD6hZ+G0SIwcTfYe33ibBMGkB+O3e8+lfwzsMwJPAezXFxe9DiVDevCt4NM5\\n' +\n        'Z2gl4QTLuAzFeofSPDRZ8HH7wgglTr3Gy07JPsVEUO8DXJNFdjbK30rmzpIqR6f9\\n' +\n        '5sx+ZlH7Tc0PhQWwPOTPQV+ByOuReaswXkSHlRdf/71gd5TGWnSAwC379K6ZKaAJ\\n' +\n        'rKzFkuMul3i5fP5f4lXGyTUAKDU2gQ7uVYkL/dYE/swhy7bBWwx3Zd6AtPSBZh9P\\n' +\n        'X+OwgfrhT+ZL9JVcL1CHEyX1h+SjaTHU6JiEPGEezvlElmGs1HGB+LCBJvnQbDg0\\n' +\n        'BBoMjGv8Mk90uGCeljpRAgMBAAEwDQYJKoZIhvcNAQELBQADggEBABXm8GPdY0sc\\n' +\n        'mMUFlgDqFzcevjdGDce0QfboR+M7WDdm512Jz2SbRTgZD/4na42ThODOZz9z1AcM\\n' +\n        'zLgx2ZNZzVhBz0odCU4JVhOCEks/OzSyKeGwjIb4JAY7dh+Kju1+6MNfQJ4r1Hza\\n' +\n        'SVXH0+JlpJDaJ73NQ2JyfqELmJ1mTcptkA/N6rQWhlzycTBSlfogwf9xawgVPATP\\n' +\n        '4AuwgjHl12JI2HVVs1gu65Y3slvaHRCr0B4+Kg1GYNLLcbFcK+NEHrHmPxy9TnTh\\n' +\n        'Zwp1dsNQU+Xkylz8IUANWSLHYZOMtN2e5SKIdwTtl5C8YxveuY8YKb1gDExnMraT\\n' +\n        'VGXQDqPleug=\\n' +\n        '-----END CERTIFICATE-----'\n};\n\ndescribe('Fetch Tests', function () {\n    let httpServer, httpsServer;\n\n    beforeEach(function (done) {\n        httpServer = http.createServer(function (req, res) {\n            switch (req.url) {\n                case '/redirect6':\n                    res.writeHead(302, {\n                        Location: '/redirect5'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect5':\n                    res.writeHead(302, {\n                        Location: '/redirect4'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect4':\n                    res.writeHead(302, {\n                        Location: '/redirect3'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect3':\n                    res.writeHead(302, {\n                        Location: '/redirect2'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect2':\n                    res.writeHead(302, {\n                        Location: '/redirect1'\n                    });\n                    res.end();\n                    break;\n\n                case '/redirect1':\n                    res.writeHead(302, {\n                        Location: '/'\n                    });\n                    res.end();\n                    break;\n\n                case '/forever':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.write('This connection is never closed');\n                    // never end the request\n                    break;\n\n                case '/gzip': {\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain',\n                        'Content-Encoding': 'gzip'\n                    });\n\n                    let stream = zlib.createGzip();\n                    stream.pipe(res);\n                    stream.end('Hello World HTTP\\n');\n                    break;\n                }\n                case '/invalid':\n                    res.writeHead(500, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end('Hello World HTTP\\n');\n                    break;\n\n                case '/auth':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end(Buffer.from(req.headers.authorization.split(' ').pop(), 'base64'));\n                    break;\n\n                case '/cookie':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end(req.headers.cookie);\n                    break;\n\n                case '/ua':\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end(req.headers['user-agent']);\n                    break;\n\n                case '/post': {\n                    let body = [];\n                    req.on('readable', function () {\n                        let chunk;\n                        while ((chunk = req.read()) !== null) {\n                            body.push(chunk);\n                        }\n                    });\n                    req.on('end', function () {\n                        res.writeHead(200, {\n                            'Content-Type': 'text/plain'\n                        });\n                        res.end(Buffer.concat(body));\n                    });\n\n                    break;\n                }\n                default:\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end('Hello World HTTP\\n');\n            }\n        });\n\n        httpsServer = https.createServer(httpsOptions, function (req, res) {\n            res.writeHead(200, {\n                'Content-Type': 'text/plain'\n            });\n            res.end('Hello World HTTPS\\n');\n        });\n\n        httpServer.listen(HTTP_PORT, function () {\n            httpsServer.listen(HTTPS_PORT, done);\n        });\n    });\n\n    afterEach(function (done) {\n        httpServer.close(function () {\n            httpsServer.close(done);\n        });\n    });\n\n    it('should fetch HTTP data', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT);\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should fetch HTTPS data', function (done) {\n        let req = fetch('https://localhost:' + HTTPS_PORT);\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTPS\\n');\n            done();\n        });\n    });\n\n    it('should fetch HTTP data with redirects', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect3');\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for too many redirects', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect6');\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n\n    it('should fetch HTTP data with custom redirect limit', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect3', {\n            maxRedirects: 3\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for custom redirect limit', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect3', {\n            maxRedirects: 2\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n\n    it('should return disable redirects', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/redirect1', {\n            maxRedirects: 0\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n\n    it('should unzip compressed HTTP data', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/gzip');\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for unresolved host', function (done) {\n        let req = fetch('http://asfhaskhhgbjdsfhgbsdjgk');\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n\n    it('should return error for invalid status', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/invalid');\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n\n    it('should allow invalid status', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/invalid', {\n            allowErrorResponse: true\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.not.exist;\n        });\n        req.on('end', function () {\n            expect(req.statusCode).to.equal(500);\n            expect(Buffer.concat(buf).toString()).to.equal('Hello World HTTP\\n');\n            done();\n        });\n    });\n\n    it('should return error for invalid url', function (done) {\n        let req = fetch('http://localhost:99999999/');\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n\n    it('should return timeout error', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/forever', {\n            timeout: 1000\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n\n    it('should handle basic HTTP auth', function (done) {\n        let req = fetch('http://user:pass@localhost:' + HTTP_PORT + '/auth');\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('user:pass');\n            done();\n        });\n    });\n\n    if (!/^0\\.10\\./.test(process.versions.node)) {\n        // disabled for node 0.10\n        it('should return error for invalid protocol', function (done) {\n            let req = fetch('http://localhost:' + HTTPS_PORT);\n            let buf = [];\n            req.on('data', function (chunk) {\n                buf.push(chunk);\n            });\n            req.on('error', function (err) {\n                expect(err).to.exist;\n                done();\n            });\n            req.on('end', function () {});\n        });\n    }\n\n    it('should set cookie value', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/cookie', {\n            cookie: 'test=pest'\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('test=pest');\n            done();\n        });\n    });\n\n    it('should set user agent', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/ua', {\n            userAgent: 'nodemailer-fetch'\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('nodemailer-fetch');\n            done();\n        });\n    });\n\n    it('should post data', function (done) {\n        let req = fetch('http://localhost:' + HTTP_PORT + '/post', {\n            method: 'post',\n            body: {\n                hello: 'world \ud83d\ude2d',\n                another: 'value'\n            }\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal('hello=world%20%F0%9F%98%AD&another=value');\n            done();\n        });\n    });\n\n    it('should post stream data', function (done) {\n        let body = new PassThrough();\n        let data = Buffer.from('hello=world%20%F0%9F%98%AD&another=value');\n\n        let req = fetch('http://localhost:' + HTTP_PORT + '/post', {\n            method: 'post',\n            body\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('end', function () {\n            expect(Buffer.concat(buf).toString()).to.equal(data.toString());\n            done();\n        });\n\n        let pos = 0;\n        let writeNext = function () {\n            if (pos >= data.length) {\n                return body.end();\n            }\n            let char = data.slice(pos++, pos);\n            body.write(char);\n            setImmediate(writeNext);\n        };\n\n        setImmediate(writeNext);\n    });\n\n    it('should return error for invalid cert', function (done) {\n        let req = fetch('https://localhost:' + HTTPS_PORT, {\n            tls: {\n                rejectUnauthorized: true\n            }\n        });\n        let buf = [];\n        req.on('data', function (chunk) {\n            buf.push(chunk);\n        });\n        req.on('error', function (err) {\n            expect(err).to.exist;\n            done();\n        });\n        req.on('end', function () {});\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst nodemailer = require('../../lib/nodemailer');\nconst chai = require('chai');\nconst expect = chai.expect;\nchai.config.includeStack = true;\n\ndescribe('JSON Transport Tests', function () {\n    it('should return an JSON string', function (done) {\n        let transport = nodemailer.createTransport({\n            jsonTransport: true\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: {\n                path: __dirname + '/fixtures/body.html'\n            },\n            text: 'hello world',\n            attachments: [\n                {\n                    filename: 'img.png',\n                    path: __dirname + '/fixtures/image.png'\n                },\n                {\n                    path: __dirname + '/fixtures/image.png'\n                }\n            ]\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(JSON.parse(info.message)).to.deep.equal({\n                from: {\n                    address: 'andris.reinman@gmail.com',\n                    name: 'Andris Reinman'\n                },\n                to: [\n                    //\n                    {\n                        address: 'andris@kreata.ee',\n                        name: 'Andris Kreata'\n                    },\n                    {\n                        address: 'andris@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                cc: [\n                    {\n                        address: 'info@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                subject: 'Awesome!',\n                html: '<h1>Message</h1>\\n\\n<p>\\n    Body\\n</p>\\n',\n                text: 'hello world',\n                attachments: [\n                    {\n                        content:\n                            'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC',\n                        filename: 'img.png',\n                        contentType: 'image/png',\n                        encoding: 'base64'\n                    },\n                    {\n                        content:\n                            'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC',\n                        filename: 'image.png',\n                        contentType: 'image/png',\n                        encoding: 'base64'\n                    }\n                ],\n                headers: {},\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>'\n            });\n            done();\n        });\n    });\n\n    it('should return an JSON string for calendar event', function (done) {\n        let transport = nodemailer.createTransport({\n            jsonTransport: true\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: '<p>hello world!</p>',\n            text: 'hello world',\n            icalEvent: {\n                method: 'request',\n                path: __dirname + '/fixtures/event.ics'\n            }\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(JSON.parse(info.message)).to.deep.equal({\n                from: {\n                    address: 'andris.reinman@gmail.com',\n                    name: 'Andris Reinman'\n                },\n                to: [\n                    //\n                    {\n                        address: 'andris@kreata.ee',\n                        name: 'Andris Kreata'\n                    },\n                    {\n                        address: 'andris@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                cc: [\n                    {\n                        address: 'info@nodemailer.com',\n                        name: ''\n                    }\n                ],\n                subject: 'Awesome!',\n                text: 'hello world',\n\n                html: '<p>hello world!</p>',\n                icalEvent: {\n                    content:\n                        'QkVHSU46VkNBTEVOREFSClZFUlNJT046Mi4wClBST0RJRDotLy9oYWNrc3cvaGFuZGNhbC8vTk9OU0dNTCB2MS4wLy9FTgpCRUdJTjpWRVZFTlQKVUlEOnVpZDFAZXhhbXBsZS5jb20KRFRTVEFNUDoxOTk3MDcxNFQxNzAwMDBaCk9SR0FOSVpFUjtDTj1Kb2huIERvZTpNQUlMVE86am9obi5kb2VAZXhhbXBsZS5jb20KRFRTVEFSVDoxOTk3MDcxNFQxNzAwMDBaCkRURU5EOjE5OTcwNzE1VDAzNTk1OVoKU1VNTUFSWTpCYXN0aWxsZSBEYXkgUGFydHkKRU5EOlZFVkVOVApFTkQ6VkNBTEVOREFSCg==',\n                    encoding: 'base64',\n                    method: 'request'\n                },\n\n                headers: {},\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>'\n            });\n            done();\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst libqp = require('libqp');\nconst qp = require('../../lib/qp');\nconst chai = require('chai');\nconst expect = chai.expect;\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nchai.config.includeStack = true;\n\ndescribe('Quoted-Printable Tests', function () {\n    let encodeFixtures = [\n        ['abcd= \u00d5\u00c4\u00d6\u00dc', 'abcd=3D =C3=95=C3=84=C3=96=C3=9C'],\n        ['foo bar  ', 'foo bar =20'],\n        ['foo bar\\t\\t', 'foo bar\\t=09'],\n        ['foo \\r\\nbar', 'foo=20\\r\\nbar']\n    ];\n\n    let wrapFixtures = [\n        ['tere, tere, vana kere, kuidas sul l=C3=A4heb?', 'tere, tere, vana =\\r\\nkere, kuidas sul =\\r\\nl=C3=A4heb?'],\n        ['=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4=C3=A4', '=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4=\\r\\n=C3=A4=C3=A4'],\n        ['1234567890123456789=C3=A40', '1234567890123456789=\\r\\n=C3=A40'],\n        ['123456789012345678  90', '123456789012345678 =\\r\\n 90']\n    ];\n\n    let streamFixture = [\n        '123456789012345678  90\\r\\n\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc\u00f5\u00e4\u00f6\u00fc another line === ',\n        '12345678=\\r\\n90123456=\\r\\n78=20=20=\\r\\n90\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=C3=B5=\\r\\n=C3=A4=\\r\\n=C3=B6=\\r\\n=C3=BC=\\r\\n=20anoth=\\r\\ner=20lin=\\r\\ne=20=3D=\\r\\n=3D=3D=20'\n    ];\n\n    describe('#encode', function () {\n        it('shoud encode UTF-8 string to QP', function () {\n            encodeFixtures.forEach(function (test) {\n                expect(qp.encode(test[0])).to.equal(test[1]);\n            });\n        });\n\n        it('shoud encode Buffer to QP', function () {\n            expect(qp.encode(Buffer.from([0x00, 0x01, 0x02, 0x20, 0x03]))).to.equal('=00=01=02 =03');\n        });\n    });\n\n    describe('#wrap', function () {\n        it('should wrap long QP encoded lines', function () {\n            wrapFixtures.forEach(function (test) {\n                expect(qp.wrap(test[0], 20)).to.equal(test[1]);\n            });\n        });\n\n        it('should wrap line ending with <CR>', function () {\n            expect(qp.wrap('alfa palfa kalfa ralfa\\r', 10)).to.equal('alfa palf=\\r\\na kalfa =\\r\\nralfa\\r');\n        });\n    });\n\n    describe('QP Streams', function () {\n        it('should transform incoming bytes to QP', function (done) {\n            let encoder = new qp.Encoder({\n                lineLength: 9\n            });\n\n            let bytes = Buffer.from(streamFixture[0]),\n                i = 0,\n                buf = [],\n                buflen = 0;\n\n            encoder.on('data', function (chunk) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            });\n\n            encoder.on('end', function (chunk) {\n                if (chunk) {\n                    buf.push(chunk);\n                    buflen += chunk.length;\n                }\n                buf = Buffer.concat(buf, buflen);\n\n                expect(buf.toString()).to.equal(streamFixture[1]);\n                done();\n            });\n\n            let sendNextByte = function () {\n                if (i >= bytes.length) {\n                    return encoder.end();\n                }\n\n                let ord = bytes[i++];\n                encoder.write(Buffer.from([ord]));\n                setImmediate(sendNextByte);\n            };\n\n            sendNextByte();\n        });\n\n        it('should transform incoming bytes to QP and back', function (done) {\n            let decoder = new libqp.Decoder();\n            let encoder = new qp.Encoder();\n            let file = fs.createReadStream(__dirname + '/fixtures/alice.txt');\n\n            let fhash = crypto.createHash('md5');\n            let dhash = crypto.createHash('md5');\n\n            file.pipe(encoder).pipe(decoder);\n\n            file.on('data', function (chunk) {\n                fhash.update(chunk);\n            });\n\n            file.on('end', function () {\n                fhash = fhash.digest('hex');\n            });\n\n            decoder.on('data', function (chunk) {\n                dhash.update(chunk);\n            });\n\n            decoder.on('end', function () {\n                dhash = dhash.digest('hex');\n                expect(fhash).to.equal(dhash);\n                done();\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst LeUnix = require('../../lib/sendmail-transport/le-unix');\nconst chai = require('chai');\nconst expect = chai.expect;\n\nchai.config.includeStack = true;\n\ndescribe('Sendmail Unix Newlines', function () {\n    it('should rewrite all linebreaks (byte by byte)', function (done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeUnix();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        let pos = 0;\n        let writeNextByte = () => {\n            if (pos >= data.length) {\n                return out.end();\n            }\n            out.write(Buffer.from([data[pos++]]));\n            setImmediate(writeNextByte);\n        };\n\n        setImmediate(writeNextByte);\n    });\n\n    it('should rewrite all linebreaks (all at once)', function (done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeUnix();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        out.end(data);\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst LeWindows = require('../../lib/sendmail-transport/le-windows');\nconst chai = require('chai');\nconst expect = chai.expect;\n\nchai.config.includeStack = true;\n\ndescribe('Sendmail Windows Newlines', function () {\n    it('should rewrite all linebreaks (byte by byte)', function (done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeWindows();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\r\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        let pos = 0;\n        let writeNextByte = () => {\n            if (pos >= data.length) {\n                return out.end();\n            }\n            out.write(Buffer.from([data[pos++]]));\n            setImmediate(writeNextByte);\n        };\n\n        setImmediate(writeNextByte);\n    });\n\n    it('should rewrite all linebreaks (all at once)', function (done) {\n        let source = 'tere tere\\nteine rida\\nkolmas rida\\r\\nneljas rida\\r\\nviies rida\\n kuues rida';\n\n        let chunks = [];\n        let out = new LeWindows();\n        out.on('data', chunk => chunks.push(chunk));\n        out.on('end', () => {\n            expect(Buffer.concat(chunks).toString()).to.equal(source.replace(/\\r?\\n/g, '\\r\\n'));\n            done();\n        });\n\n        let data = Buffer.from(source);\n        out.end(data);\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst PassThrough = require('stream').PassThrough;\nconst EventEmitter = require('events').EventEmitter;\nconst sinon = require('sinon');\nconst SendmailTransport = require('../../lib/sendmail-transport');\nchai.config.includeStack = true;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('Sendmail Transport Tests', function () {\n    it('Should expose version number', function () {\n        let client = new SendmailTransport();\n        expect(client.name).to.exist;\n        expect(client.version).to.exist;\n    });\n\n    it('Should send message', function (done) {\n        let client = new SendmailTransport();\n\n        let stubbedSpawn = new EventEmitter();\n        stubbedSpawn.stdin = new PassThrough();\n        stubbedSpawn.stdout = new PassThrough();\n\n        let output = '';\n        stubbedSpawn.stdin.on('data', function (chunk) {\n            output += chunk.toString();\n        });\n\n        stubbedSpawn.stdin.on('end', function () {\n            stubbedSpawn.emit('close', 0);\n            stubbedSpawn.emit('exit', 0);\n        });\n\n        sinon.stub(client, '_spawn').returns(stubbedSpawn);\n\n        client.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'message\\r\\nline 2'\n                )\n            },\n            function (err, data) {\n                expect(err).to.not.exist;\n                expect(data.messageId).to.equal('<test>');\n                expect(output).to.equal('message\\nline 2');\n                client._spawn.restore();\n                done();\n            }\n        );\n    });\n\n    it('Should reject message', function (done) {\n        let client = new SendmailTransport();\n\n        let stubbedSpawn = new EventEmitter();\n        stubbedSpawn.stdin = new PassThrough();\n        stubbedSpawn.stdout = new PassThrough();\n\n        let output = '';\n        stubbedSpawn.stdin.on('data', function (chunk) {\n            output += chunk.toString();\n        });\n\n        stubbedSpawn.stdin.on('end', function () {\n            stubbedSpawn.emit('close', 0);\n            stubbedSpawn.emit('exit', 0);\n        });\n\n        sinon.stub(client, '_spawn').returns(stubbedSpawn);\n\n        client.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: '-d0.1a@example.com'\n                    },\n                    'message\\r\\nline 2'\n                )\n            },\n            function (err, data) {\n                expect(err).to.exist;\n                expect(data).to.not.exist;\n                expect(output).to.equal('');\n                client._spawn.restore();\n                done();\n            }\n        );\n    });\n\n    it('Should return an error', function (done) {\n        let client = new SendmailTransport();\n\n        let stubbedSpawn = new EventEmitter();\n        stubbedSpawn.stdin = new PassThrough();\n        stubbedSpawn.stdout = new PassThrough();\n\n        stubbedSpawn.stdin.on('data', () => false);\n\n        stubbedSpawn.stdin.on('end', function () {\n            stubbedSpawn.emit('close', 127);\n            stubbedSpawn.emit('exit', 127);\n        });\n\n        sinon.stub(client, '_spawn').returns(stubbedSpawn);\n\n        client.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'message\\r\\nline 2'\n                )\n            },\n            function (err, data) {\n                expect(err).to.exist;\n                expect(data).to.not.exist;\n                client._spawn.restore();\n                done();\n            }\n        );\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst nodemailer = require('../../lib/nodemailer');\nconst chai = require('chai');\nconst expect = chai.expect;\nchai.config.includeStack = true;\n\nconst privateKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIBywIBAAJhANCx7ncKUfQ8wBUYmMqq6ky8rBB0NL8knBf3+uA7q/CSxpX6sQ8N\ndFNtEeEd7gu7BWEM7+PkO1P0M78eZOvVmput8BP9R44ARpgHY4V0qSCdUt4rD32n\nwfjlGbh8p5ua5wIDAQABAmAm+uUQpQPTu7kg95wqVqw2sxLsa9giT6M8MtxQH7Uo\n1TF0eAO0TQ4KOxgY1S9OT5sGPVKnag258m3qX7o5imawcuyStb68DQgAUg6xv7Af\nAqAEDfYN5HW6xK+X81jfOUECMQDr7XAS4PERATvgb1B3vRu5UEbuXcenHDYgdoyT\n3qJFViTbep4qeaflF0uF9eFveMcCMQDic10rJ8fopGD7/a45O4VJb0+lRXVdqZxJ\nQzAp+zVKWqDqPfX7L93SQLzOGhdd7OECMQDeQyD7WBkjSQNMy/GF7I1qxrscIxNN\nVqGTcbu8Lti285Hjhx/sqhHHHGwU9vB7oM8CMQDKTS3Kw/s/xrot5O+kiZwFgr+w\ncmDrj/7jJHb+ykFNb7GaEkiSYqzUjKkfpweBDYECMFJUyzuuFJAjq3BXmGJlyykQ\nTweUw+zMVdSXjO+FCPcYNi6CP1t1KoESzGKBVoqA/g==\n-----END RSA PRIVATE KEY-----`;\n\ndescribe('SES Transport Tests', function () {\n    this.timeout(50 * 1000); // eslint-disable-line no-invalid-this\n\n    it('should return MessageId', function (done) {\n        let transport = nodemailer.createTransport({\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                // Prevent tests from actually sending mail by mocking sendRawEmail\n                sendRawEmail: (message, cb) => {\n                    setImmediate(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    });\n                }\n            }\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: {\n                path: __dirname + '/../json-transport/fixtures/body.html'\n            },\n            text: 'hello world',\n            attachments: [\n                {\n                    filename: 'image.png',\n                    path: __dirname + '/../json-transport/fixtures/image.png'\n                }\n            ]\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n            expect(info.envelope).to.deep.equal({\n                from: 'andris.reinman@gmail.com',\n                to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n            });\n            expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n            expect(info.response).to.equal('testtest');\n            done();\n        });\n    });\n\n    it('should sign message with DKIM', function (done) {\n        let transport = nodemailer.createTransport({\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    expect(message.RawMessage.Data.toString()).to.include('h=from:subject:to:cc:mime-version:content-type;');\n                    setImmediate(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    });\n                }\n            },\n            dkim: {\n                domainName: 'node.ee',\n                keySelector: 'dkim',\n                privateKey\n            }\n        });\n\n        let messageObject = {\n            from: 'Andris Reinman <andris.reinman@gmail.com>',\n            to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n            cc: 'info@nodemailer.com',\n            subject: 'Awesome!',\n            messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n            html: {\n                path: __dirname + '/../json-transport/fixtures/body.html'\n            },\n            text: 'hello world',\n            attachments: [\n                {\n                    filename: 'image.png',\n                    path: __dirname + '/../json-transport/fixtures/image.png'\n                }\n            ]\n        };\n\n        transport.sendMail(messageObject, (err, info) => {\n            expect(err).to.not.exist;\n            expect(info).to.exist;\n            expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n            expect(info.envelope).to.deep.equal({\n                from: 'andris.reinman@gmail.com',\n                to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n            });\n            expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n            expect(info.response).to.equal('testtest');\n            done();\n        });\n    });\n\n    it('should limit parallel connections', function (done) {\n        let transport = nodemailer.createTransport({\n            maxConnections: 2,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(5000);\n                    expect(Date.now() - start).to.be.lte(10000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('should rate limit messages', function (done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 10,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(10000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('should rate limit long messages', function (done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 30,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 3000);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(12000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('should rate limit messages and connections', function (done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 100,\n            maxConnections: 1,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n\n        for (let i = 0; i < total; i++) {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(10000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        }\n    });\n\n    it('detect sending slots on idle events', function (done) {\n        let transport = nodemailer.createTransport({\n            sendingRate: 100,\n            maxConnections: 1,\n            SES: {\n                config: {\n                    region: 'eu-west-1'\n                },\n                sendRawEmail: (message, cb) => {\n                    setTimeout(() => {\n                        cb(null, {\n                            MessageId: 'testtest'\n                        });\n                    }, 100);\n                }\n            }\n        });\n\n        let total = 100;\n        let finished = 0;\n        let start = Date.now();\n        let sent = 0;\n\n        let sendNext = () => {\n            let messageObject = {\n                from: 'Andris Reinman <andris.reinman@gmail.com>',\n                to: 'Andris Kreata <andris@kreata.ee>, andris@nodemailer.com',\n                cc: 'info@nodemailer.com',\n                subject: 'Awesome!',\n                messageId: '<fede478a-aab9-af02-789c-ad93a76a3548@gmail.com>',\n                html: {\n                    path: __dirname + '/../json-transport/fixtures/body.html'\n                },\n                text: 'hello world',\n                attachments: [\n                    {\n                        filename: 'image.png',\n                        path: __dirname + '/../json-transport/fixtures/image.png'\n                    }\n                ]\n            };\n\n            transport.sendMail(messageObject, (err, info) => {\n                finished++;\n                expect(err).to.not.exist;\n                expect(info).to.exist;\n                expect(info).to.have.keys('envelope', 'messageId', 'response', 'raw');\n                expect(info.envelope).to.deep.equal({\n                    from: 'andris.reinman@gmail.com',\n                    to: ['andris@kreata.ee', 'andris@nodemailer.com', 'info@nodemailer.com']\n                });\n                expect(info.messageId).to.equal('<testtest@eu-west-1.amazonses.com>');\n                expect(info.response).to.equal('testtest');\n\n                if (total === finished) {\n                    expect(Date.now() - start).to.be.gte(10000);\n                    expect(Date.now() - start).to.be.lte(15000);\n                    return done();\n                }\n            });\n        };\n\n        transport.on('idle', () => {\n            while (transport.isIdle() && sent < total) {\n                sent++;\n                sendNext();\n            }\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, afterEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst shared = require('../../lib/shared');\n\nconst http = require('http');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nchai.config.includeStack = true;\n\ndescribe('Shared Funcs Tests', function () {\n    describe('Logger tests', function () {\n        it('Should create a logger', function () {\n            expect(\n                typeof shared.getLogger({\n                    logger: false\n                })\n            ).to.equal('object');\n            expect(\n                typeof shared.getLogger({\n                    logger: true\n                })\n            ).to.equal('object');\n            expect(typeof shared.getLogger()).to.equal('object');\n        });\n    });\n\n    describe('Connection url parser tests', function () {\n        it('Should parse connection url', function () {\n            let url = 'smtps://user:pass@localhost:123?tls.rejectUnauthorized=false&name=horizon';\n            expect(shared.parseConnectionUrl(url)).to.deep.equal({\n                secure: true,\n                port: 123,\n                host: 'localhost',\n                auth: {\n                    user: 'user',\n                    pass: 'pass'\n                },\n                tls: {\n                    rejectUnauthorized: false\n                },\n                name: 'horizon'\n            });\n        });\n\n        it('should not choke on special symbols in auth', function () {\n            let url = 'smtps://user%40gmail.com:%3Apasswith%25Char@smtp.gmail.com';\n            expect(shared.parseConnectionUrl(url)).to.deep.equal({\n                secure: true,\n                host: 'smtp.gmail.com',\n                auth: {\n                    user: 'user@gmail.com',\n                    pass: ':passwith%Char'\n                }\n            });\n        });\n    });\n\n    describe('Resolver tests', function () {\n        let port = 10337;\n        let server;\n\n        beforeEach(function (done) {\n            server = http.createServer(function (req, res) {\n                if (/redirect/.test(req.url)) {\n                    res.writeHead(302, {\n                        Location: 'http://localhost:' + port + '/message.html'\n                    });\n                    res.end('Go to http://localhost:' + port + '/message.html');\n                } else if (/compressed/.test(req.url)) {\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain',\n                        'Content-Encoding': 'gzip'\n                    });\n                    let stream = zlib.createGzip();\n                    stream.pipe(res);\n                    stream.write('<p>Tere, tere</p><p>vana kere!</p>\\n');\n                    stream.end();\n                } else {\n                    res.writeHead(200, {\n                        'Content-Type': 'text/plain'\n                    });\n                    res.end('<p>Tere, tere</p><p>vana kere!</p>\\n');\n                }\n            });\n\n            server.listen(port, done);\n        });\n\n        afterEach(function (done) {\n            server.close(done);\n        });\n\n        it('should set text from html string', function (done) {\n            let mail = {\n                data: {\n                    html: '<p>Tere, tere</p><p>vana kere!</p>\\n'\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.equal('<p>Tere, tere</p><p>vana kere!</p>\\n');\n                done();\n            });\n        });\n\n        it('should set text from html buffer', function (done) {\n            let mail = {\n                data: {\n                    html: Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n')\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(mail.data.html);\n                done();\n            });\n        });\n\n        it('should set text from a html file', function (done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: __dirname + '/fixtures/message.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from an html url', function (done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + port + '/message.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from redirecting url', function (done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + port + '/redirect.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from gzipped url', function (done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + port + '/compressed.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should set text from a html stream', function (done) {\n            let mail = {\n                data: {\n                    html: fs.createReadStream(__dirname + '/fixtures/message.html')\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(mail).to.deep.equal({\n                    data: {\n                        html: Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n')\n                    }\n                });\n                expect(value).to.deep.equal(Buffer.from('<p>Tere, tere</p><p>vana kere!</p>\\n'));\n                done();\n            });\n        });\n\n        it('should return an error', function (done) {\n            let mail = {\n                data: {\n                    html: {\n                        path: 'http://localhost:' + (port + 1000) + '/message.html'\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err) {\n                expect(err).to.exist;\n                done();\n            });\n        });\n\n        it('should return encoded string as buffer', function (done) {\n            let str = '<p>Tere, tere</p><p>vana kere!</p>\\n';\n            let mail = {\n                data: {\n                    html: {\n                        encoding: 'base64',\n                        content: Buffer.from(str).toString('base64')\n                    }\n                }\n            };\n            shared.resolveContent(mail.data, 'html', function (err, value) {\n                expect(err).to.not.exist;\n                expect(value).to.deep.equal(Buffer.from(str));\n                done();\n            });\n        });\n\n        describe('data uri tests', function () {\n            it('should resolve with mime type and base64', function (done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path:\n                                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function (err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(\n                        Buffer.from(\n                            'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==',\n                            'base64'\n                        )\n                    );\n                    done();\n                });\n            });\n\n            it('should resolve with mime type and plaintext', function (done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path: 'data:image/png,tere%20tere'\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function (err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(Buffer.from('tere tere'));\n                    done();\n                });\n            });\n\n            it('should resolve with plaintext', function (done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path: 'data:,tere%20tere'\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function (err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(Buffer.from('tere tere'));\n                    done();\n                });\n            });\n\n            it('should resolve with mime type, charset and base64', function (done) {\n                let mail = {\n                    data: {\n                        attachment: {\n                            path:\n                                'data:image/png;charset=iso-8859-1;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='\n                        }\n                    }\n                };\n                shared.resolveContent(mail.data, 'attachment', function (err, value) {\n                    expect(err).to.not.exist;\n                    expect(value).to.deep.equal(\n                        Buffer.from(\n                            'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==',\n                            'base64'\n                        )\n                    );\n                    done();\n                });\n            });\n        });\n    });\n\n    describe('#assign tests', function () {\n        it('should assign multiple objects to target', function () {\n            let target = {\n                a: 1,\n                b: 2,\n                c: 3\n            };\n            let arg1 = {\n                b: 5,\n                y: 66,\n                e: 33\n            };\n\n            let arg2 = {\n                y: 17,\n                qq: 98\n            };\n\n            shared.assign(target, arg1, arg2);\n            expect(target).to.deep.equal({\n                a: 1,\n                b: 5,\n                c: 3,\n                y: 17,\n                e: 33,\n                qq: 98\n            });\n        });\n    });\n\n    describe('#encodeXText tests', function () {\n        it('should not encode atom', function () {\n            expect(shared.encodeXText('teretere')).to.equal('teretere');\n        });\n\n        it('should not encode email', function () {\n            expect(shared.encodeXText('andris.reinman@gmail.com')).to.equal('andris.reinman@gmail.com');\n        });\n\n        it('should encode space', function () {\n            expect(shared.encodeXText('tere tere')).to.equal('tere+20tere');\n        });\n\n        it('should encode unicode', function () {\n            expect(shared.encodeXText('tere t\u00f5re')).to.equal('tere+20t+C3+B5re');\n        });\n\n        it('should encode low codes', function () {\n            expect(shared.encodeXText('tere t\\tre')).to.equal('tere+20t+09re');\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst http = require('http');\nconst proxy = require('proxy');\nconst httpProxyClient = require('../../lib/smtp-connection/http-proxy-client');\nconst SMTPServer = require('smtp-server').SMTPServer;\nconst chai = require('chai');\nconst expect = chai.expect;\n\nchai.config.includeStack = true;\n\nconst PROXY_PORT = 3128;\nconst TARGET_PORT = 3129;\n\ndescribe('HTTP Proxy Client Tests', function () {\n    it('should connect to a socket through proxy', function (done) {\n        let smtpServer = new SMTPServer({\n            logger: false\n        });\n\n        smtpServer.listen(TARGET_PORT, () => {\n            let proxyServer = proxy(http.createServer());\n            proxyServer.listen(PROXY_PORT, () => {\n                httpProxyClient('http://localhost:' + PROXY_PORT, TARGET_PORT, '127.0.0.1', (err, socket) => {\n                    expect(err).to.not.exist;\n                    socket.once('data', chunk => {\n                        expect(/^220[ -]/.test(chunk.toString())).to.be.true;\n                        socket.end();\n                        socket.on('close', () => {\n                            socket.destroy();\n                            smtpServer.close(() => setImmediate(done) && proxyServer.close());\n                        });\n                    });\n                });\n            });\n        });\n    });\n    it('should connect to a socket through proxy with auth', function (done) {\n        let smtpServer = new SMTPServer({\n            logger: false\n        });\n\n        smtpServer.listen(TARGET_PORT, () => {\n            let proxyServer = proxy(http.createServer());\n            proxyServer.authenticate = (req, cb) => {\n                cb(null, req.headers['proxy-authorization'] === 'Basic dGVzdDpwZXN0');\n            };\n            proxyServer.listen(PROXY_PORT, () => {\n                httpProxyClient('http://test:pest@localhost:' + PROXY_PORT, TARGET_PORT, '127.0.0.1', (err, socket) => {\n                    expect(err).to.not.exist;\n                    socket.once('data', chunk => {\n                        expect(/^220[ -]/.test(chunk.toString())).to.be.true;\n                        socket.end();\n                        socket.on('close', () => {\n                            socket.destroy();\n                            smtpServer.close(() => setImmediate(done) && proxyServer.close());\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    it('should should fail auth', function (done) {\n        let smtpServer = new SMTPServer({\n            logger: false\n        });\n\n        smtpServer.listen(TARGET_PORT, () => {\n            let proxyServer = proxy(http.createServer());\n            proxyServer.authenticate = (req, cb) => {\n                cb(null, req.headers['proxy-authorization'] === 'Basic dGVzdDpwZXN0');\n            };\n            proxyServer.listen(PROXY_PORT, () => {\n                httpProxyClient('http://test:kest@localhost:' + PROXY_PORT, TARGET_PORT, '127.0.0.1', (err, socket) => {\n                    expect(err).to.exist;\n                    expect(socket).to.not.exist;\n\n                    smtpServer.close(() => setImmediate(done) && proxyServer.close());\n                });\n            });\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, no-var: 0, prefer-arrow-callback: 0, object-shorthand: 0 */\n/* globals afterEach, beforeEach, describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nlet fs = require('fs');\nlet chai = require('chai');\nlet expect = chai.expect;\nlet SMTPConnection = require('../../lib/smtp-connection');\nlet packageData = require('../../package.json');\nlet SMTPServer = require('smtp-server').SMTPServer;\nlet HttpConnectProxy = require('proxy-test-server');\nlet net = require('net');\nlet xoauth2Server = require('./xoauth2-mock-server');\nlet XOAuth2 = require('../../lib/xoauth2');\nlet sinon = require('sinon');\n\nchai.config.includeStack = true;\n\nlet PORT_NUMBER = 8397;\nlet PROXY_PORT_NUMBER = 9999;\nlet LMTP_PORT_NUMBER = 8396;\nlet XOAUTH_PORT = 8497;\n\ndescribe('SMTP-Connection Tests', function () {\n    describe('Version test', function () {\n        it('Should expose version number', function () {\n            let client = new SMTPConnection();\n            expect(client.version).to.equal(packageData.version);\n        });\n    });\n\n    describe('Connection tests', function () {\n        let server, insecureServer, invalidServer, secureServer, httpProxy;\n\n        beforeEach(function (done) {\n            server = new SMTPServer({\n                onAuth: function (auth, session, callback) {\n                    if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                        return callback(new Error('Invalid username or password'));\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onData: function (stream, session, callback) {\n                    stream.on('data', function () {});\n                    stream.on('end', callback);\n                }\n            });\n\n            insecureServer = new SMTPServer({\n                disabledCommands: ['STARTTLS', 'AUTH'],\n                onData: function (stream, session, callback) {\n                    let err = false;\n                    stream.on('data', function (chunk) {\n                        if (err || session.use8BitMime) {\n                            return;\n                        }\n                        for (let i = 0, len = chunk.length; i < len; i++) {\n                            if (chunk[i] >= 0x80) {\n                                err = new Error('8 bit content not allowed');\n                            }\n                        }\n                    });\n                    stream.on('end', function () {\n                        callback(err, false);\n                    });\n                },\n                logger: false\n            });\n\n            invalidServer = net.createServer(function () {});\n\n            secureServer = new SMTPServer({\n                secure: true,\n                onAuth: function (auth, session, callback) {\n                    if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                        return callback(new Error('Invalid username or password'));\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onData: function (stream, session, callback) {\n                    stream.on('data', function () {});\n                    stream.on('end', callback);\n                },\n                logger: false\n            });\n\n            httpProxy = new HttpConnectProxy();\n\n            server.listen(PORT_NUMBER, function () {\n                invalidServer.listen(PORT_NUMBER + 1, function () {\n                    secureServer.listen(PORT_NUMBER + 2, function () {\n                        insecureServer.listen(PORT_NUMBER + 3, function () {\n                            httpProxy.listen(PROXY_PORT_NUMBER, done);\n                        });\n                    });\n                });\n            });\n        });\n\n        afterEach(function (done) {\n            server.close(function () {\n                invalidServer.close(function () {\n                    secureServer.close(function () {\n                        insecureServer.close(function () {\n                            httpProxy.close(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('should connect to unsecure server', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                ignoreTLS: true,\n                logger: false\n            });\n\n            client.connect(function () {\n                expect(client.secure).to.be.false;\n                client.close();\n            });\n\n            client.on('error', function (err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a server and upgrade with STARTTLS', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                logger: false\n            });\n\n            client.connect(function () {\n                expect(client.secure).to.be.true;\n                client.close();\n            });\n\n            client.on('error', function (err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a server and upgrade with forced STARTTLS', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                requireTLS: true,\n                transactionLog: true,\n                logger: false\n            });\n\n            client.connect(function () {\n                expect(client.secure).to.be.true;\n                client.close();\n            });\n\n            client.on('error', function (err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a server and try to upgrade STARTTLS', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                logger: false,\n                requireTLS: true,\n                opportunisticTLS: true\n            });\n\n            client.connect(function () {\n                expect(client.secure).to.be.false;\n                client.close();\n            });\n\n            client.on('error', function (err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should try upgrade with STARTTLS where not advertised', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                requireTLS: true,\n                logger: false\n            });\n\n            client.connect(function () {\n                // should not run\n                expect(false).to.be.true;\n                client.close();\n            });\n\n            client.once('error', function (err) {\n                expect(err).to.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should close connection after STARTTLS', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                logger: false\n            });\n\n            client.connect(function () {\n                expect(client.secure).to.be.true;\n                server.connections.forEach(function (conn) {\n                    conn.close();\n                });\n            });\n\n            client.on('error', function (err) {\n                expect(err.message).to.equal('Connection closed unexpectedly');\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect to a secure server', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 2,\n                secure: true,\n                logger: false\n            });\n\n            client.connect(function () {\n                expect(client.secure).to.be.true;\n                client.close();\n            });\n\n            client.on('error', function (err) {\n                expect(err).to.not.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should emit error for invalid port', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 10,\n                logger: false\n            });\n\n            client.connect(function () {\n                // should not run\n                expect(false).to.be.true;\n                client.close();\n            });\n\n            client.once('error', function (err) {\n                expect(err).to.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should emit error for too large port', function (done) {\n            let client = new SMTPConnection({\n                port: 999999999,\n                logger: false\n            });\n\n            client.connect(function () {\n                // should not run\n                expect(false).to.be.true;\n                client.close();\n            });\n\n            client.once('error', function (err) {\n                expect(err).to.exist;\n            });\n\n            client.on('end', done);\n        });\n\n        it('should emit inactivity timeout error', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER,\n                socketTimeout: 100,\n                logger: false\n            });\n\n            client.connect(function () {\n                // do nothing\n            });\n\n            client.once('error', function (err) {\n                expect(err).to.exist;\n                expect(err.code).to.equal('ETIMEDOUT');\n            });\n\n            client.on('end', done);\n        });\n\n        it('should connect through proxy', function (done) {\n            let runTest = function (socket) {\n                let client = new SMTPConnection({\n                    logger: false,\n                    port: PORT_NUMBER,\n                    connection: socket\n                });\n\n                client.connect(function () {\n                    expect(client.secure).to.be.true;\n                    client.login(\n                        {\n                            user: 'testuser',\n                            credentials: {\n                                user: 'testuser',\n                                pass: 'testpass'\n                            }\n                        },\n                        function (err) {\n                            expect(err).to.not.exist;\n                            expect(client.authenticated).to.be.true;\n                            client.close();\n                        }\n                    );\n                });\n\n                client.on('error', function (err) {\n                    expect(err).to.not.exist;\n                });\n\n                client.on('end', done);\n            };\n\n            proxyConnect(PROXY_PORT_NUMBER, '127.0.0.1', PORT_NUMBER, '127.0.0.1', function (err, socket) {\n                expect(err).to.not.exist;\n                runTest(socket);\n            });\n        });\n\n        it('should connect through proxy to secure server', function (done) {\n            let runTest = function (socket) {\n                let client = new SMTPConnection({\n                    logger: false,\n                    port: PORT_NUMBER + 2,\n                    secure: true,\n                    connection: socket\n                });\n\n                client.connect(function () {\n                    expect(client.secure).to.be.true;\n                    client.login(\n                        {\n                            user: 'testuser',\n                            credentials: {\n                                user: 'testuser',\n                                pass: 'testpass'\n                            }\n                        },\n                        function (err) {\n                            expect(err).to.not.exist;\n                            expect(client.authenticated).to.be.true;\n                            client.close();\n                        }\n                    );\n                });\n\n                client.on('error', function (err) {\n                    expect(err).to.not.exist;\n                });\n\n                client.on('end', done);\n            };\n\n            proxyConnect(PROXY_PORT_NUMBER, '127.0.0.1', PORT_NUMBER + 2, '127.0.0.1', function (err, socket) {\n                expect(err).to.not.exist;\n                runTest(socket);\n            });\n        });\n\n        it('should send to unsecure server', function (done) {\n            let client = new SMTPConnection({\n                port: PORT_NUMBER + 3,\n                ignoreTLS: true,\n                logger: false\n            });\n\n            client.on('error', function (err) {\n                expect(err).to.not.exist;\n            });\n\n            client.connect(function () {\n                expect(client.secure).to.be.false;\n\n                let chunks = [],\n                    fname = __dirname + '/../../LICENSE',\n                    message = fs.readFileSync(fname, 'utf-8');\n\n                server.on('data', function (connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function (connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(message.toString().trim().replace(/\\n/g, '\\r\\n'));\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    fs.createReadStream(fname),\n                    function (err) {\n                        expect(err).to.not.exist;\n                        client.close();\n                    }\n                );\n            });\n\n            client.on('end', done);\n        });\n    });\n\n    describe('Login tests', function () {\n        this.timeout(10 * 1000);\n\n        let server,\n            lmtpServer,\n            client,\n            lmtpClient,\n            testtoken = 'testtoken';\n\n        beforeEach(function (done) {\n            server = new SMTPServer({\n                authMethods: ['PLAIN', 'XOAUTH2'],\n                disabledCommands: ['STARTTLS'],\n\n                size: 100 * 1024,\n\n                onData: function (stream, session, callback) {\n                    let err = false;\n                    stream.on('data', function (chunk) {\n                        if (err || session.use8BitMime) {\n                            return;\n                        }\n                        for (let i = 0, len = chunk.length; i < len; i++) {\n                            if (chunk[i] >= 0x80) {\n                                err = new Error('8 bit content not allowed');\n                            }\n                        }\n                    });\n                    stream.on('end', function () {\n                        callback(err, false);\n                    });\n                },\n\n                onAuth: function (auth, session, callback) {\n                    if (auth.method !== 'XOAUTH2') {\n                        if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                            return callback(new Error('Invalid username or password'));\n                        }\n                    } else if (auth.username !== 'testuser' || auth.accessToken !== testtoken) {\n                        return callback(null, {\n                            data: {\n                                status: '401',\n                                schemes: 'bearer mac',\n                                scope: 'my_smtp_access_scope_name'\n                            }\n                        });\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onMailFrom: function (address, session, callback) {\n                    if (address.args && parseInt(address.args.SIZE, 10) > 50 * 1024) {\n                        return callback(new Error('452 Insufficient channel storage: ' + address.address));\n                    }\n\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n\n                    if (address.args.SMTPUTF8) {\n                        session.smtpUtf8 = true;\n                    }\n\n                    if (address.args.BODY === '8BITMIME') {\n                        session.use8BitMime = true;\n                    }\n\n                    if (/[\\x80-\\uFFFF]/.test(address.address) && !session.smtpUtf8) {\n                        return callback(new Error('Trying to use Unicode address without declaring SMTPUTF8 first'));\n                    }\n\n                    return callback(); // Accept the address\n                },\n                onRcptTo: function (address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    if (/[\\x80-\\uFFFF]/.test(address.address) && !session.smtpUtf8) {\n                        return callback(new Error('Trying to use Unicode address without declaring SMTPUTF8 first'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            lmtpServer = new SMTPServer({\n                lmtp: true,\n                disabledCommands: ['STARTTLS', 'AUTH'],\n\n                onData: function (stream, session, callback) {\n                    stream.on('data', function () {});\n                    stream.on('end', function () {\n                        let response = session.envelope.rcptTo.map(function (rcpt, i) {\n                            if (i % 2) {\n                                return '<' + rcpt.address + '> Accepted';\n                            } else {\n                                return new Error('<' + rcpt.address + '> Not accepted');\n                            }\n                        });\n                        callback(null, response);\n                    });\n                },\n                onMailFrom: function (address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                onRcptTo: function (address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            client = new SMTPConnection({\n                port: PORT_NUMBER,\n                logger: false,\n                debug: false\n            });\n\n            lmtpClient = new SMTPConnection({\n                port: LMTP_PORT_NUMBER,\n                lmtp: true,\n                logger: false,\n                debug: false\n            });\n\n            server.listen(PORT_NUMBER, function () {\n                lmtpServer.listen(LMTP_PORT_NUMBER, function () {\n                    client.connect(function () {\n                        lmtpClient.connect(done);\n                    });\n                });\n            });\n        });\n\n        afterEach(function (done) {\n            client.close();\n            lmtpClient.close();\n            server.close(function () {\n                lmtpServer.close(done);\n            });\n        });\n\n        it('should login', function (done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser',\n                    credentials: {\n                        user: 'testuser',\n                        pass: 'testpass'\n                    }\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    expect(client.authenticated).to.be.true;\n                    done();\n                }\n            );\n        });\n\n        it('should return error for invalid login', function (done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser',\n                    credentials: {\n                        user: 'testuser',\n                        pass: 'invalid'\n                    }\n                },\n                function (err) {\n                    expect(err).to.exist;\n                    expect(client.authenticated).to.be.false;\n                    expect(err.code).to.equal('EAUTH');\n                    expect(err.responseCode).to.equal(535);\n                    done();\n                }\n            );\n        });\n\n        it('should return error for missing credentials', function (done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser'\n                },\n                function (err) {\n                    expect(err).to.exist;\n                    expect(client.authenticated).to.be.false;\n                    expect(err.message).to.match(/^Missing credentials/);\n                    expect(err.code).to.equal('EAUTH');\n                    expect(err.response).to.be.undefined;\n                    done();\n                }\n            );\n        });\n\n        it('should return error for incomplete credentials', function (done) {\n            expect(client.authenticated).to.be.false;\n            client.login(\n                {\n                    user: 'testuser',\n                    credentials: {\n                        user: 'testuser'\n                    }\n                },\n                function (err) {\n                    expect(err).to.exist;\n                    expect(client.authenticated).to.be.false;\n                    expect(err.message).to.match(/^Missing credentials/);\n                    expect(err.code).to.equal('EAUTH');\n                    expect(err.response).to.be.undefined;\n                    done();\n                }\n            );\n        });\n\n        describe('xoauth2 login', function () {\n            this.timeout(10 * 1000);\n            let x2server;\n\n            beforeEach(function (done) {\n                x2server = xoauth2Server({\n                    port: XOAUTH_PORT,\n                    onUpdate: function (username, accessToken) {\n                        testtoken = accessToken;\n                    }.bind(this)\n                });\n\n                x2server.addUser('testuser', 'refresh-token');\n\n                x2server.start(done);\n            });\n\n            afterEach(function (done) {\n                x2server.stop(done);\n            });\n\n            it('should login with xoauth2 string', function (done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            accessToken: testtoken\n                        })\n                    },\n                    function (err) {\n                        expect(err).to.not.exist;\n                        expect(client.authenticated).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for invalid xoauth2 string token', function (done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            accessToken: 'invalid'\n                        })\n                    },\n                    function (err) {\n                        expect(err).to.exist;\n                        expect(client.authenticated).to.be.false;\n                        expect(err.code).to.equal('EAUTH');\n                        done();\n                    }\n                );\n            });\n\n            it('should login with xoauth2 object', function (done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            clientId: '{Client ID}',\n                            clientSecret: '{Client Secret}',\n                            refreshToken: 'refresh-token',\n                            accessToken: 'uuuuu',\n                            accessUrl: 'http://localhost:' + XOAUTH_PORT\n                        })\n                    },\n                    function (err) {\n                        expect(err).to.not.exist;\n                        expect(client.authenticated).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should fail with xoauth2 object', function (done) {\n                expect(client.authenticated).to.be.false;\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2: new XOAuth2({\n                            user: 'testuser',\n                            clientId: '{Client ID}',\n                            clientSecret: '{Client Secret}',\n                            refreshToken: 'refrsesh-token',\n                            accessToken: 'uuuuu',\n                            accessUrl: 'http://localhost:' + XOAUTH_PORT\n                        })\n                    },\n                    function (err) {\n                        expect(err).to.exist;\n                        expect(client.authenticated).to.be.false;\n                        done();\n                    }\n                );\n            });\n\n            it('should fail with invalid xoauth2 response', function (done) {\n                expect(client.authenticated).to.be.false;\n\n                let oauth2 = new XOAuth2({\n                    user: 'testuser',\n                    clientId: '{Client ID}',\n                    clientSecret: '{Client Secret}',\n                    refreshToken: 'refrsesh-token',\n                    accessToken: 'uuuuu',\n                    accessUrl: 'http://localhost:' + XOAUTH_PORT\n                });\n\n                sinon.stub(oauth2, 'generateToken').yields(null, 'dXNlcj10ZXN0dXNlcgFhdXRoPUJlYXJlciB1dXV1dQEB');\n\n                client.login(\n                    {\n                        type: 'oauth2',\n                        user: 'testuser',\n                        oauth2\n                    },\n                    function (err) {\n                        expect(err).to.exist;\n                        expect(client.authenticated).to.be.false;\n\n                        oauth2.generateToken.restore();\n                        done();\n                    }\n                );\n            });\n        });\n\n        describe('custom login', function () {\n            let customClient;\n            beforeEach(function (done) {\n                customClient = new SMTPConnection({\n                    port: PORT_NUMBER,\n                    logger: false,\n                    debug: false,\n                    customAuth: {\n                        mytest: client => {\n                            client.sendCommand('HALLO1 HALLO', (err, response) => {\n                                expect(err).to.not.exist;\n                                expect(response.status).to.equal(500);\n                                client.sendCommand('HALLO2 HALLO', (err, response) => {\n                                    expect(err).to.not.exist;\n                                    expect(response.status).to.equal(500);\n                                    client.resolve();\n                                });\n                            });\n                        }\n                    }\n                });\n\n                customClient.connect(done);\n            });\n\n            afterEach(function (done) {\n                customClient.close();\n                done();\n            });\n\n            it('should login', function (done) {\n                expect(customClient.authenticated).to.be.false;\n                customClient.login(\n                    {\n                        method: 'mytest',\n                        user: 'testuser',\n                        credentials: {\n                            user: 'testuser',\n                            pass: 'testpass'\n                        }\n                    },\n                    function (err) {\n                        expect(err).to.not.exist;\n                        expect(customClient.authenticated).to.be.true;\n                        done();\n                    }\n                );\n            });\n        });\n\n        describe('Send without PIPELINING', function () {\n            beforeEach(function (done) {\n                client.on('end', function () {\n                    client = new SMTPConnection({\n                        port: PORT_NUMBER,\n                        logger: false,\n                        debug: false\n                    });\n                    // disable PIPELINING\n                    server.options.hidePIPELINING = true;\n                    client.connect(function () {\n                        client.login(\n                            {\n                                user: 'testuser',\n                                credentials: {\n                                    user: 'testuser',\n                                    pass: 'testpass'\n                                }\n                            },\n                            function (err) {\n                                expect(err).to.not.exist;\n                                // enable PIPELINING\n                                server.options.hidePIPELINING = false;\n                                done();\n                            }\n                        );\n                    });\n                });\n                client.close();\n            });\n\n            it('should send only to valid recipients without PIPELINING', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3@valid.recipient']\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        expect(info.rejectedErrors.length).to.equal(1);\n                        done();\n                    }\n                );\n            });\n        });\n\n        describe('Send messages', function () {\n            beforeEach(function (done) {\n                client.login(\n                    {\n                        user: 'testuser',\n                        credentials: {\n                            user: 'testuser',\n                            pass: 'testpass'\n                        }\n                    },\n                    function (err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test@valid.recipient'],\n                            rejected: [],\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('should send multiple messages', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test@valid.recipient'],\n                            rejected: [],\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        client.reset(function (err) {\n                            expect(err).to.not.exist;\n\n                            client.send(\n                                {\n                                    from: 'test2@valid.sender',\n                                    to: 'test2@valid.recipient'\n                                },\n                                'test2',\n                                function (err, info) {\n                                    expect(err).to.not.exist;\n                                    expect(info).to.deep.equal({\n                                        accepted: ['test2@valid.recipient'],\n                                        rejected: [],\n                                        envelopeTime: info.envelopeTime,\n                                        messageTime: info.messageTime,\n                                        messageSize: info.messageSize,\n                                        response: '250 OK: message queued'\n                                    });\n                                    done();\n                                }\n                            );\n                        });\n                    }\n                );\n            });\n\n            it('should send only to valid recipients', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3@valid.recipient']\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        expect(info.rejectedErrors.length).to.equal(1);\n                        done();\n                    }\n                );\n            });\n\n            it('should reject all recipients', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@invalid.recipient', 'test2@invalid.recipient', 'test3@invalid.recipient']\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.exist;\n                        expect(info).to.not.exist;\n                        expect(err.rejected).to.deep.equal(['test1@invalid.recipient', 'test2@invalid.recipient', 'test3@invalid.recipient']);\n                        expect(err.rejectedErrors.length).to.equal(3);\n                        done();\n                    }\n                );\n            });\n\n            it('should reject too large SIZE arguments', function (done) {\n                client.send(\n                    {\n                        from: 'test2@valid.sender',\n                        to: 'test2@valid.recipient',\n                        size: 1024 * 1024\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.exist;\n                        expect(info).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should reject too large message', function (done) {\n                client.send(\n                    {\n                        from: 'test2@valid.sender',\n                        to: 'test2@valid.recipient',\n                        size: 70 * 1024\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.exist;\n                        expect(info).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should declare SIZE', function (done) {\n                client.send(\n                    {\n                        from: 'test2@valid.sender',\n                        to: 'test2@valid.recipient',\n                        size: 10 * 1024\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test2@valid.recipient'],\n                            rejected: [],\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('lmtp should send only to valid recipients', function (done) {\n                lmtpClient.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: [\n                            'test1@valid.recipient',\n                            'test2@invalid.recipient',\n                            'test3@valid.recipient',\n                            'test4@valid.recipient',\n                            'test5@valid.recipient',\n                            'test6@valid.recipient'\n                        ]\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info.accepted).to.deep.equal(['test3@valid.recipient', 'test5@valid.recipient']);\n                        expect(info.rejected).to.deep.equal([\n                            'test2@invalid.recipient',\n                            'test1@valid.recipient',\n                            'test4@valid.recipient',\n                            'test6@valid.recipient'\n                        ]);\n                        expect(info.rejectedErrors.length).to.equal(info.rejected.length);\n                        done();\n                    }\n                );\n            });\n\n            it('should send using SMTPUTF8', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3\u00f5@valid.recipient']\n                    },\n                    'test',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3\u00f5@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('should send using 8BITMIME', function (done) {\n                client.send(\n                    {\n                        use8BitMime: true,\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3\u00f5@valid.recipient']\n                    },\n                    '\u00f5\u00f5\u00f5\u00f5',\n                    function (err, info) {\n                        expect(err).to.not.exist;\n                        expect(info).to.deep.equal({\n                            accepted: ['test1@valid.recipient', 'test3\u00f5@valid.recipient'],\n                            rejected: ['test2@invalid.recipient'],\n                            rejectedErrors: info.rejectedErrors,\n                            envelopeTime: info.envelopeTime,\n                            messageTime: info.messageTime,\n                            messageSize: info.messageSize,\n                            response: '250 OK: message queued'\n                        });\n                        done();\n                    }\n                );\n            });\n\n            it('should receive error for 8-bit content without 8BITMIME declaration', function (done) {\n                client.send(\n                    {\n                        use8BitMime: false,\n                        from: 'test@valid.sender',\n                        to: ['test1@valid.recipient', 'test2@invalid.recipient', 'test3\u00f5@valid.recipient']\n                    },\n                    '\u00f5\u00f5\u00f5\u00f5',\n                    function (err) {\n                        expect(/8 bit content not allowed/.test(err.message)).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for invalidly formatted recipients', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test@valid.recipient', '\"address\\r\\n with folding\"@valid.recipient']\n                    },\n                    'test',\n                    function (err) {\n                        expect(/^Invalid recipient/.test(err.message)).to.be.true;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for no valid recipients', function (done) {\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: ['test1@invalid.recipient', 'test2@invalid.recipient', 'test3@invalid.recipient']\n                    },\n                    'test',\n                    function (err) {\n                        expect(err).to.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should return error for invalid sender', function (done) {\n                client.send(\n                    {\n                        from: 'test@invalid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    'test',\n                    function (err) {\n                        expect(err).to.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message string', function (done) {\n                let chunks = [],\n                    message = new Array(1024).join('teretere, vana kere\\n');\n\n                server.on('data', function (connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function (connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message,\n                    function (err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message buffer', function (done) {\n                let chunks = [],\n                    message = Buffer.from(new Array(1024).join('teretere, vana kere\\n'));\n\n                server.on('data', function (connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function (connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(message.toString().trim().replace(/\\n/g, '\\r\\n'));\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message,\n                    function (err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n\n            it('should send message stream', function (done) {\n                let chunks = [],\n                    fname = __dirname + '/../../LICENSE',\n                    message = fs.readFileSync(fname, 'utf-8');\n\n                server.on('data', function (connection, chunk) {\n                    chunks.push(chunk);\n                });\n\n                server.removeAllListeners('dataReady');\n                server.on('dataReady', function (connection, callback) {\n                    let body = Buffer.concat(chunks);\n                    expect(body.toString()).to.equal(message.toString().trim().replace(/\\n/g, '\\r\\n'));\n                    callback(null, 'ABC1');\n                });\n\n                client.send(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    fs.createReadStream(fname),\n                    function (err) {\n                        expect(err).to.not.exist;\n                        done();\n                    }\n                );\n            });\n        });\n    });\n});\n\nfunction proxyConnect(port, host, destinationPort, destinationHost, callback) {\n    let socket = net.connect(port, host, function () {\n        socket.write('CONNECT ' + destinationHost + ':' + destinationPort + ' HTTP/1.1\\r\\n\\r\\n');\n\n        let headers = '';\n        let onSocketData = function (chunk) {\n            let match;\n            let remainder;\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n                // proxy connection is now established\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.on('error', function (err) {\n        expect(err).to.not.exist;\n    });\n}\n", "'use strict';\n\nconst http = require('http');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\n\nmodule.exports = function (options) {\n    return new OAuthServer(options);\n};\n\nfunction OAuthServer(options) {\n    this.options = options || {};\n    this.users = {};\n    this.tokens = {};\n\n    this.options.port = Number(this.options.port) || 3080;\n    this.options.expiresIn = Number(this.options.expiresIn) || 3600;\n}\n\nOAuthServer.prototype.addUser = function (username, refreshToken) {\n    let user = {\n        username,\n        refreshToken: refreshToken || crypto.randomBytes(10).toString('base64')\n    };\n\n    this.users[username] = user;\n    this.tokens[user.refreshToken] = username;\n\n    return this.generateAccessToken(user.refreshToken);\n};\n\nOAuthServer.prototype.generateAccessToken = function (refreshToken) {\n    let username = this.tokens[refreshToken],\n        accessToken = crypto.randomBytes(10).toString('base64');\n\n    if (!username) {\n        return {\n            error: 'Invalid refresh token'\n        };\n    }\n\n    this.users[username].accessToken = accessToken;\n    this.users[username].expiresIn = Date.now + this.options.expiresIn * 1000;\n\n    if (this.options.onUpdate) {\n        this.options.onUpdate(username, accessToken);\n    }\n\n    return {\n        access_token: accessToken,\n        expires_in: this.options.expiresIn,\n        token_type: 'Bearer'\n    };\n};\n\nOAuthServer.prototype.validateAccessToken = function (username, accessToken) {\n    if (!this.users[username] || this.users[username].accessToken !== accessToken || this.users[username].expiresIn < Date.now()) {\n        return false;\n    } else {\n        return true;\n    }\n};\n\nOAuthServer.prototype.start = function (callback) {\n    this.server = http.createServer((req, res) => {\n        let data = [],\n            datalen = 0;\n        req.on('data', chunk => {\n            if (!chunk || !chunk.length) {\n                return;\n            }\n\n            data.push(chunk);\n            datalen += chunk.length;\n        });\n        req.on('end', () => {\n            let query = querystring.parse(Buffer.concat(data, datalen).toString()),\n                response = this.generateAccessToken(query.refresh_token);\n\n            res.writeHead(!response.error ? 200 : 401, {\n                'Content-Type': 'application/json'\n            });\n\n            res.end(JSON.stringify(response));\n        });\n    });\n\n    this.server.listen(this.options.port, callback);\n};\n\nOAuthServer.prototype.stop = function (callback) {\n    this.server.close(callback);\n};\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, afterEach, describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst net = require('net');\nconst chai = require('chai');\nconst expect = chai.expect;\nconst SMTPPool = require('../../lib/smtp-pool');\nconst SMTPServer = require('smtp-server').SMTPServer;\nconst PassThrough = require('stream').PassThrough;\nchai.config.includeStack = true;\n\nconst PORT_NUMBER = 8397;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('SMTP Pool Tests', function () {\n    this.timeout(100 * 1000); //eslint-disable-line no-invalid-this\n\n    let server;\n\n    beforeEach(function (done) {\n        server = new SMTPServer({\n            authMethods: ['PLAIN', 'XOAUTH2'],\n            disabledCommands: ['STARTTLS'],\n\n            onData(stream, session, callback) {\n                stream.on('data', function () {});\n                stream.on('end', callback);\n            },\n\n            onAuth(auth, session, callback) {\n                if (auth.method !== 'XOAUTH2') {\n                    if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                        return callback(new Error('Invalid username or password'));\n                    }\n                } else if (auth.username !== 'testuser' || auth.accessToken !== 'testtoken') {\n                    return callback(null, {\n                        data: {\n                            status: '401',\n                            schemes: 'bearer mac',\n                            scope: 'my_smtp_access_scope_name'\n                        }\n                    });\n                }\n                callback(null, {\n                    user: 123\n                });\n            },\n            onMailFrom(address, session, callback) {\n                if (!/@valid.sender/.test(address.address)) {\n                    return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                }\n                return callback(); // Accept the address\n            },\n            onRcptTo(address, session, callback) {\n                if (!/@valid.recipient/.test(address.address)) {\n                    return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                }\n\n                if (!/timeout/.test(address.address)) {\n                    return callback(); // Accept the address\n                }\n            },\n            logger: false\n        });\n\n        server.listen(PORT_NUMBER, done);\n    });\n\n    afterEach(function (done) {\n        server.close(done);\n    });\n\n    it('Should expose version number', function () {\n        let pool = new SMTPPool();\n        expect(pool.name).to.exist;\n        expect(pool.version).to.exist;\n    });\n\n    it('Should detect wellknown data', function () {\n        let pool = new SMTPPool({\n            service: 'google mail'\n        });\n        expect(pool.options.host).to.equal('smtp.gmail.com');\n        expect(pool.options.port).to.equal(465);\n        expect(pool.options.secure).to.be.true;\n    });\n\n    it('should send mail', function (done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false,\n            debug: true\n        });\n\n        let message = new Array(1024).join('teretere, vana kere\\n');\n\n        server.onData = function (stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function (chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function () {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function (err) {\n                expect(err).to.not.exist;\n                pool.close();\n                done();\n            }\n        );\n    });\n\n    it('should send multiple mails', function (done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function (stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function (chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function () {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function () {\n            let sent = 0;\n\n            if (++returned === total) {\n                expect(pool._connections.length).to.be.above(1);\n                pool._connections.forEach(function (conn) {\n                    expect(conn.messages).to.be.above(1);\n                    sent += conn.messages;\n                });\n\n                expect(sent).to.be.equal(total);\n\n                pool.close();\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n    });\n\n    it('should tolerate connection errors', function (done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false\n        });\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function (stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function (chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function () {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        let c = 0;\n\n        function sendMessage(callback) {\n            let isErr = c++ % 2; // fail 50% of messages\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: isErr ? 'test@invalid.sender' : 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    if (isErr) {\n                        expect(err).to.exist;\n                    } else {\n                        expect(err).to.not.exist;\n                    }\n\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function () {\n            if (++returned === total) {\n                pool.close();\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n    });\n\n    it('should tolerate idle connections and re-assign messages to other connections', function (done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false\n        });\n\n        let total = 20;\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n        let sentMessages = 0;\n        let killedConnections = false;\n\n        server.onData = function (stream, session, callback) {\n            let callCallback = true;\n\n            stream.on('data', function () {\n                // If we hit half the messages, simulate the server closing connections\n                // that are open for long time\n                if (!killedConnections && sentMessages === total / 2) {\n                    killedConnections = true;\n                    callCallback = false;\n                    server.connections.forEach(function (connection) {\n                        connection._socket.end();\n                    });\n                }\n            });\n\n            stream.on('end', function () {\n                if (callCallback) {\n                    sentMessages += 1;\n                    return callback();\n                }\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    if (err) {\n                        expect(err.message).to.equal('Connection closed unexpectedly');\n                    }\n                    callback();\n                }\n            );\n        }\n\n        // Send 10 messages in a row.. then wait a bit and send 10 more\n        // When we wait a bit.. the server will kill the \"idle\" connections\n        // so that we can ensure the pool will handle it properly\n        let returned = 0;\n        let cb = function () {\n            returned++;\n\n            if (returned === total) {\n                pool.close();\n                return done();\n            } else if (returned === total / 2) {\n                setTimeout(sendHalfBulk, 1500);\n            }\n        };\n\n        function sendHalfBulk() {\n            for (let i = 0; i < total / 2; i++) {\n                sendMessage(cb);\n            }\n        }\n\n        sendHalfBulk();\n    });\n\n    it('should call back with connection errors to senders having messages in flight', function (done) {\n        let pool = new SMTPPool({\n            maxConnections: 1,\n            socketTimeout: 200,\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            logger: false\n        });\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function (err) {\n                expect(err).not.to.exist;\n            }\n        );\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test+timeout@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function (err) {\n                expect(err).to.exist;\n                pool.close();\n                done();\n            }\n        );\n    });\n\n    it('should not send more then allowed for one connection', function (done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?maxConnections=1&maxMessages=5&logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function (stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function (chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function () {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function () {\n            if (++returned === total) {\n                expect(pool._connections.length).to.be.equal(1);\n                expect(pool._connections[0].messages).to.be.below(6);\n                pool.close();\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n    });\n\n    it('should send multiple mails with rate limit', function (done) {\n        let pool = new SMTPPool({\n            port: PORT_NUMBER,\n            auth: {\n                user: 'testuser',\n                pass: 'testpass'\n            },\n            maxConnections: 10,\n            rateLimit: 200, // 200 messages in sec, so sending 5000 messages should take at least 24 seconds and probably under 25 sec\n            logger: false\n        });\n        let message = 'teretere, vana kere\\n';\n        let startTime = Date.now();\n\n        server.onData = function (stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function (chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function () {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 5000;\n        let returned = 0;\n        let cb = function () {\n            if (++returned === total) {\n                let endTime = Date.now();\n                expect(endTime - startTime).to.be.at.least(24000);\n\n                pool.close();\n                return done();\n            }\n        };\n\n        let i = 0;\n        let send = function () {\n            if (i++ >= total) {\n                return;\n            }\n            sendMessage(cb);\n            setImmediate(send);\n        };\n\n        send();\n    });\n\n    it('should return pending messages once closed', function (done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?maxConnections=1&logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function (stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function (chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function () {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.exist;\n                    callback();\n                }\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function () {\n            if (++returned === total) {\n                return done();\n            }\n        };\n        for (let i = 0; i < total; i++) {\n            sendMessage(cb);\n        }\n        pool.close();\n    });\n\n    it('should emit idle for free slots in the pool', function (done) {\n        let pool = new SMTPPool('smtp://testuser:testpass@localhost:' + PORT_NUMBER + '/?logger=false');\n        let message = new Array(10 * 1024).join('teretere, vana kere\\n');\n\n        server.onData = function (stream, session, callback) {\n            let chunks = [];\n            stream.on('data', function (chunk) {\n                chunks.push(chunk);\n            });\n            stream.on('end', function () {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n                callback();\n            });\n        };\n\n        function sendMessage(callback) {\n            pool.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                callback\n            );\n        }\n\n        let total = 100;\n        let returned = 0;\n        let cb = function () {\n            if (++returned === total) {\n                pool.close();\n                return done();\n            }\n        };\n\n        let i = 0;\n        pool.on('idle', function () {\n            setTimeout(function () {\n                while (i < total && pool.isIdle()) {\n                    i++;\n                    sendMessage(cb);\n                }\n                if (i > 50) {\n                    // kill all connections. We should still end up with the same amount of callbacks\n                    setImmediate(function () {\n                        for (let j = 5 - 1; j >= 0; j--) {\n                            if (pool._connections[j] && pool._connections[j].connection) {\n                                pool._connections[j].connection._socket.emit('error', new Error('TESTERROR'));\n                            }\n                        }\n                    });\n                }\n            }, 1000);\n        });\n    });\n\n    it('Should login and send mail using proxied socket', function (done) {\n        let pool = new SMTPPool({\n            url: 'smtp:testuser:testpass@www.example.com:1234',\n            logger: false,\n            getSocket(options, callback) {\n                let socket = net.connect(PORT_NUMBER, 'localhost');\n                let errHandler = function (err) {\n                    callback(err);\n                };\n                socket.on('error', errHandler);\n                socket.on('connect', function () {\n                    socket.removeListener('error', errHandler);\n                    callback(null, {\n                        connection: socket\n                    });\n                });\n            }\n        });\n        let chunks = [],\n            message = new Array(1024).join('teretere, vana kere\\n');\n\n        server.on('data', function (connection, chunk) {\n            chunks.push(chunk);\n        });\n\n        server.on('dataReady', function (connection, callback) {\n            let body = Buffer.concat(chunks);\n            expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n') + '\\r\\n');\n            callback(null, true);\n        });\n\n        pool.send(\n            {\n                data: {},\n                message: new MockBuilder(\n                    {\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    },\n                    message\n                )\n            },\n            function (err) {\n                expect(err).to.not.exist;\n                pool.close();\n                return done();\n            }\n        );\n    });\n\n    it('Should verify connection with success', function (done) {\n        let client = new SMTPPool({\n            url: 'smtp:testuser:testpass@localhost:' + PORT_NUMBER,\n            logger: false\n        });\n\n        client.verify(function (err, success) {\n            expect(err).to.not.exist;\n            expect(success).to.be.true;\n            client.close();\n            done();\n        });\n    });\n\n    it('Should not verify connection', function (done) {\n        let client = new SMTPPool({\n            url: 'smtp:testuser:testpass@localhost:999' + PORT_NUMBER,\n            logger: false\n        });\n\n        client.verify(function (err) {\n            expect(err).to.exist;\n            client.close();\n            done();\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals beforeEach, afterEach, describe, it */\n\n'use strict';\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst chai = require('chai');\nconst net = require('net');\nconst expect = chai.expect;\nconst PassThrough = require('stream').PassThrough;\nconst SMTPTransport = require('../../lib/smtp-transport');\nconst SMTPServer = require('smtp-server').SMTPServer;\nchai.config.includeStack = true;\n\nconst PORT_NUMBER = 8397;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('SMTP Transport Tests', function () {\n    this.timeout(10000); // eslint-disable-line no-invalid-this\n\n    describe('Anonymous sender tests', function () {\n        let server, failingServer;\n\n        beforeEach(function (done) {\n            server = new SMTPServer({\n                disabledCommands: ['STARTTLS', 'AUTH'],\n\n                onData(stream, session, callback) {\n                    stream.on('data', function () {});\n                    stream.on('end', callback);\n                },\n\n                onMailFrom(address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n\n                onRcptTo(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            failingServer = new SMTPServer({\n                disabledCommands: ['STARTTLS', 'AUTH'],\n\n                onData(stream) {\n                    stream.on('data', () => false);\n                    stream.on('end', () => {\n                        setTimeout(() => {\n                            this.connections.forEach(socket => socket._socket.destroy());\n                        }, 150);\n                    });\n                },\n\n                onMailFrom(address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n\n                onRcptTo(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            server.listen(PORT_NUMBER, err => {\n                if (err) {\n                    return done(err);\n                }\n                failingServer.listen(PORT_NUMBER + 1, done);\n            });\n        });\n\n        afterEach(function (done) {\n            server.close(() => failingServer.close(done));\n        });\n\n        it('Should expose version number', function () {\n            let client = new SMTPTransport();\n            expect(client.name).to.exist;\n            expect(client.version).to.exist;\n        });\n\n        it('Should detect wellknown data', function () {\n            let client = new SMTPTransport({\n                service: 'google mail',\n                logger: false\n            });\n            expect(client.options.host).to.equal('smtp.gmail.com');\n            expect(client.options.port).to.equal(465);\n            expect(client.options.secure).to.be.true;\n        });\n\n        it('Should fail envelope', function (done) {\n            let client = new SMTPTransport({\n                port: PORT_NUMBER,\n                logger: false\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@invalid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        'test'\n                    )\n                },\n                function (err) {\n                    expect(err.code).to.equal('EENVELOPE');\n                    done();\n                }\n            );\n        });\n\n        it('Should not fail auth', function (done) {\n            let client = new SMTPTransport({\n                port: PORT_NUMBER,\n                auth: {\n                    user: 'zzz'\n                },\n                logger: false\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        'message'\n                    )\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n\n        it('Should fail auth if forceAuth=true', function (done) {\n            let client = new SMTPTransport({\n                port: PORT_NUMBER,\n                auth: {\n                    user: 'zzz'\n                },\n                forceAuth: true,\n                logger: false\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        'message'\n                    )\n                },\n                function (err) {\n                    expect(err.code).to.equal('EAUTH');\n                    done();\n                }\n            );\n        });\n\n        it('Should send mail', function (done) {\n            let client = new SMTPTransport('smtp:localhost:' + PORT_NUMBER + '?logger=false');\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function (connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function (connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n\n        it('Should recover unexpeced close during transmission', function (done) {\n            let client = new SMTPTransport('smtp:localhost:' + (PORT_NUMBER + 1) + '?logger=false');\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function (connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function (connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.exist;\n                    done();\n                }\n            );\n        });\n    });\n\n    describe('Authenticated sender tests', function () {\n        let server;\n\n        beforeEach(function (done) {\n            server = new SMTPServer({\n                authMethods: ['PLAIN', 'XOAUTH2'],\n                disabledCommands: ['STARTTLS'],\n\n                onData(stream, session, callback) {\n                    stream.on('data', function () {});\n                    stream.on('end', callback);\n                },\n\n                onAuth(auth, session, callback) {\n                    if (auth.method !== 'XOAUTH2') {\n                        if (auth.username !== 'testuser' || auth.password !== 'testpass') {\n                            return callback(new Error('Invalid username or password'));\n                        }\n                    } else if (auth.username !== 'testuser' || auth.accessToken !== 'testtoken') {\n                        return callback(null, {\n                            data: {\n                                status: '401',\n                                schemes: 'bearer mac',\n                                scope: 'my_smtp_access_scope_name'\n                            }\n                        });\n                    }\n                    callback(null, {\n                        user: 123\n                    });\n                },\n                onMailFrom(address, session, callback) {\n                    if (!/@valid.sender/.test(address.address)) {\n                        return callback(new Error('Only user@valid.sender is allowed to send mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                onRcptTo(address, session, callback) {\n                    if (!/@valid.recipient/.test(address.address)) {\n                        return callback(new Error('Only user@valid.recipient is allowed to receive mail'));\n                    }\n                    return callback(); // Accept the address\n                },\n                logger: false\n            });\n\n            server.listen(PORT_NUMBER, done);\n        });\n\n        afterEach(function (done) {\n            server.close(done);\n        });\n\n        it('Should login and send mail', function (done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@localhost:' + PORT_NUMBER,\n                logger: false\n            });\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function (connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function (connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n\n        it('Should verify connection with success', function (done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@localhost:' + PORT_NUMBER,\n                logger: false\n            });\n\n            client.verify(function (err, success) {\n                expect(err).to.not.exist;\n                expect(success).to.be.true;\n                done();\n            });\n        });\n\n        it('Should not verify connection', function (done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@localhost:999' + PORT_NUMBER,\n                logger: false\n            });\n\n            client.verify(function (err) {\n                expect(err).to.exist;\n                done();\n            });\n        });\n\n        it('Should login and send mail using proxied socket', function (done) {\n            let client = new SMTPTransport({\n                url: 'smtp:testuser:testpass@www.example.com:1234',\n                logger: false,\n                getSocket(options, callback) {\n                    let socket = net.connect(PORT_NUMBER, 'localhost');\n                    let errHandler = function (err) {\n                        callback(err);\n                    };\n                    socket.on('error', errHandler);\n                    socket.on('connect', function () {\n                        socket.removeListener('error', errHandler);\n                        callback(null, {\n                            connection: socket\n                        });\n                    });\n                }\n            });\n            let chunks = [],\n                message = new Array(1024).join('teretere, vana kere\\n');\n\n            server.on('data', function (connection, chunk) {\n                chunks.push(chunk);\n            });\n\n            server.on('dataReady', function (connection, callback) {\n                let body = Buffer.concat(chunks);\n                expect(body.toString()).to.equal(message.trim().replace(/\\n/g, '\\r\\n'));\n                callback(null, true);\n            });\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err) {\n                    expect(err).to.not.exist;\n                    done();\n                }\n            );\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst PassThrough = require('stream').PassThrough;\nconst StreamTransport = require('../../lib/stream-transport');\nchai.config.includeStack = true;\n\nclass MockBuilder {\n    constructor(envelope, message, messageId) {\n        this.envelope = envelope;\n        this.rawMessage = message;\n        this.mid = messageId || '<test>';\n    }\n\n    getEnvelope() {\n        return this.envelope;\n    }\n\n    messageId() {\n        return this.mid;\n    }\n\n    createReadStream() {\n        let stream = new PassThrough();\n        setImmediate(() => stream.end(this.rawMessage));\n        return stream;\n    }\n\n    getHeader() {\n        return 'teretere';\n    }\n}\n\ndescribe('Stream Transport Tests', function () {\n    this.timeout(10000); // eslint-disable-line no-invalid-this\n\n    it('Should expose version number', function () {\n        let client = new StreamTransport();\n        expect(client.name).to.exist;\n        expect(client.version).to.exist;\n    });\n\n    describe('Send as stream', function () {\n        it('Should send mail using unix newlines', function (done) {\n            let client = new StreamTransport();\n            let chunks = [],\n                message = new Array(100).join('teretere\\r\\nvana kere\\r\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err, info) {\n                    expect(err).to.not.exist;\n\n                    expect(info.envelope).to.deep.equal({\n                        from: 'test@valid.sender',\n                        to: 'test@valid.recipient'\n                    });\n\n                    expect(info.messageId).to.equal('<test>');\n\n                    info.message.on('data', function (chunk) {\n                        chunks.push(chunk);\n                    });\n\n                    info.message.on('end', function () {\n                        let body = Buffer.concat(chunks);\n                        expect(body.toString()).to.equal(message.replace(/\\r\\n/g, '\\n'));\n                        done();\n                    });\n                }\n            );\n        });\n\n        it('Should send mail using windows newlines', function (done) {\n            let client = new StreamTransport({\n                newline: 'windows'\n            });\n            let chunks = [],\n                message = new Array(100).join('teretere\\nvana kere\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err, info) {\n                    expect(err).to.not.exist;\n\n                    info.message.on('data', function (chunk) {\n                        chunks.push(chunk);\n                    });\n\n                    info.message.on('end', function () {\n                        let body = Buffer.concat(chunks);\n                        expect(body.toString()).to.equal(message.replace(/\\n/g, '\\r\\n'));\n                        done();\n                    });\n                }\n            );\n        });\n    });\n\n    describe('Send as buffer', function () {\n        it('Should send mail using unix newlines', function (done) {\n            let client = new StreamTransport({\n                buffer: true\n            });\n            let message = new Array(100).join('teretere\\r\\nvana kere\\r\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err, info) {\n                    expect(err).to.not.exist;\n\n                    expect(info.message.toString()).to.equal(message.replace(/\\r\\n/g, '\\n'));\n                    done();\n                }\n            );\n        });\n\n        it('Should send mail using windows newlines', function (done) {\n            let client = new StreamTransport({\n                newline: 'windows',\n                buffer: true\n            });\n            let message = new Array(100).join('teretere\\nvana kere\\n');\n\n            client.send(\n                {\n                    data: {},\n                    message: new MockBuilder(\n                        {\n                            from: 'test@valid.sender',\n                            to: 'test@valid.recipient'\n                        },\n                        message\n                    )\n                },\n                function (err, info) {\n                    expect(err).to.not.exist;\n\n                    expect(info.message.toString()).to.equal(message.replace(/\\n/g, '\\r\\n'));\n                    done();\n                }\n            );\n        });\n    });\n});\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, prefer-arrow-callback: 0 */\n/* globals describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst wellKnown = require('../../lib/well-known');\n\nchai.config.includeStack = true;\n\ndescribe('Well-Known Services Tests', function () {\n    describe('#wellKnown', function () {\n        it('Should find by key', function () {\n            expect(wellKnown('Gmail')).to.deep.equal({\n                host: 'smtp.gmail.com',\n                port: 465,\n                secure: true\n            });\n        });\n\n        it('Should find by alias', function () {\n            expect(wellKnown('Google Mail')).to.deep.equal({\n                host: 'smtp.gmail.com',\n                port: 465,\n                secure: true\n            });\n        });\n\n        it('Should find by domain', function () {\n            expect(wellKnown('GoogleMail.com')).to.deep.equal({\n                host: 'smtp.gmail.com',\n                port: 465,\n                secure: true\n            });\n        });\n\n        it('Should find no match', function () {\n            expect(wellKnown('zzzzzz')).to.be.false;\n        });\n    });\n});\n", "'use strict';\n\n// Mock server for serving Oauth2 tokens\n\nconst http = require('http');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\n\nmodule.exports = function (options) {\n    return new OAuthServer(options);\n};\n\nfunction OAuthServer(options) {\n    this.options = options || {};\n    this.users = {};\n    this.tokens = {};\n\n    this.options.port = Number(this.options.port) || 3080;\n    this.options.expiresIn = Number(this.options.expiresIn) || 3600;\n}\n\nOAuthServer.prototype.addUser = function (username, refreshToken) {\n    let user = {\n        username,\n        refreshToken: refreshToken || crypto.randomBytes(10).toString('base64')\n    };\n\n    this.users[username] = user;\n    this.tokens[user.refreshToken] = username;\n\n    return this.generateAccessToken(user.refreshToken);\n};\n\nOAuthServer.prototype.generateAccessToken = function (refreshToken) {\n    let username = this.tokens[refreshToken];\n    let accessToken = crypto.randomBytes(10).toString('base64');\n\n    if (!username) {\n        return {\n            error: 'Invalid refresh token'\n        };\n    }\n\n    this.users[username].accessToken = accessToken;\n    this.users[username].expiresIn = Date.now + this.options.expiresIn * 1000;\n\n    if (this.options.onUpdate) {\n        this.options.onUpdate(username, accessToken);\n    }\n\n    return {\n        access_token: accessToken,\n        expires_in: this.options.expiresIn,\n        token_type: 'Bearer'\n    };\n};\n\nOAuthServer.prototype.validateAccessToken = function (username, accessToken) {\n    if (!this.users[username] || this.users[username].accessToken !== accessToken || this.users[username].expiresIn < Date.now()) {\n        return false;\n    } else {\n        return true;\n    }\n};\n\nOAuthServer.prototype.start = function (callback) {\n    this.server = http.createServer((req, res) => {\n        let data = [];\n        let datalen = 0;\n\n        req.on('data', chunk => {\n            if (!chunk || !chunk.length) {\n                return;\n            }\n\n            data.push(chunk);\n            datalen += chunk.length;\n        });\n\n        req.once('end', () => {\n            let query = querystring.parse(Buffer.concat(data, datalen).toString()),\n                response = this.generateAccessToken(query.refresh_token);\n\n            res.writeHead(!response.error ? 200 : 401, {\n                'Content-Type': 'application/json'\n            });\n\n            res.end(JSON.stringify(response));\n        });\n    });\n\n    this.server.listen(this.options.port, callback);\n};\n\nOAuthServer.prototype.stop = function (callback) {\n    this.server.close(callback);\n};\n", "/* eslint no-unused-expressions:0, no-invalid-this:0, prefer-arrow-callback: 0, object-shorthand: 0 */\n/* globals afterEach, beforeEach, describe, it */\n\n'use strict';\n\nconst chai = require('chai');\nconst expect = chai.expect;\nconst XOAuth2 = require('../../lib/xoauth2');\nconst mockServer = require('./server');\n\nchai.config.includeStack = true;\n\ndescribe('XOAuth2 tests', function () {\n    this.timeout(10000);\n\n    let server;\n    let users = {};\n    let XOAUTH_PORT = 8993;\n\n    beforeEach(function (done) {\n        server = mockServer({\n            port: XOAUTH_PORT,\n            onUpdate: function (username, accessToken) {\n                users[username] = accessToken;\n            }\n        });\n        server.addUser('test@example.com', 'saladus');\n        server.start(done);\n    });\n\n    afterEach(function (done) {\n        server.stop(done);\n    });\n\n    it('should get an existing access token', function (done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            accessToken: 'abc',\n            timeout: 3600\n        });\n\n        xoauth2.getToken(false, function (err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal('abc');\n            done();\n        });\n    });\n\n    it('should convert access token to XOAuth2 token', function () {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            accessToken: 'abc'\n        });\n\n        expect(xoauth2.buildXOAuth2Token()).to.equal('dXNlcj10ZXN0QGV4YW1wbGUuY29tAWF1dGg9QmVhcmVyIGFiYwEB');\n        expect(xoauth2.buildXOAuth2Token('bbb')).to.equal('dXNlcj10ZXN0QGV4YW1wbGUuY29tAWF1dGg9QmVhcmVyIGJiYgEB');\n    });\n\n    it('should get an existing access token, no timeout', function (done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            accessToken: 'abc'\n        });\n\n        xoauth2.getToken(false, function (err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal('abc');\n            done();\n        });\n    });\n\n    it('should generate a fresh access token', function (done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600\n        });\n\n        xoauth2.getToken(false, function (err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal(users['test@example.com']);\n            done();\n        });\n    });\n\n    it('should generate a fresh access token with custom method', function (done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600,\n            provisionCallback: (user, renew, cb) => {\n                cb(null, 'zzz');\n            }\n        });\n\n        xoauth2.getToken(false, function (err, accessToken) {\n            expect(err).to.not.exist;\n            expect(accessToken).to.equal('zzz');\n            done();\n        });\n    });\n\n    it('should fail generating a fresh access token with custom method', function (done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600,\n            provisionCallback: (user, renew, cb) => {\n                cb(new Error('fail'));\n            }\n        });\n\n        xoauth2.getToken(false, function (err, accessToken) {\n            expect(err).to.exist;\n            expect(accessToken).to.not.exist;\n            done();\n        });\n    });\n\n    it('should generate a fresh access token after timeout', function (done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            accessToken: 'abc',\n            timeout: 1\n        });\n\n        setTimeout(function () {\n            xoauth2.getToken(false, function (err, accessToken) {\n                expect(err).to.not.exist;\n                expect(accessToken).to.equal(users['test@example.com']);\n                done();\n            });\n        }, 3000);\n    });\n\n    it('should emit access token update', function (done) {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            clientId: '{Client ID}',\n            clientSecret: '{Client Secret}',\n            refreshToken: 'saladus',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600\n        });\n\n        xoauth2.once('token', function (tokenData) {\n            expect(tokenData.expires).to.be.gte(Date.now() + 3000 * 1000);\n            expect(tokenData).to.deep.equal({\n                user: 'test@example.com',\n                accessToken: users['test@example.com'],\n                expires: tokenData.expires\n            });\n            done();\n        });\n\n        xoauth2.getToken(false, function () {});\n    });\n\n    it('should sign payload', function () {\n        let xoauth2 = new XOAuth2({\n            user: 'test@example.com',\n            serviceClient: '{Client ID}',\n            accessUrl: 'http://localhost:' + XOAUTH_PORT + '/',\n            timeout: 3600,\n            privateKey:\n                '-----BEGIN RSA PRIVATE KEY-----\\n' +\n                'MIIEpAIBAAKCAQEA6Z5Qqhw+oWfhtEiMHE32Ht94mwTBpAfjt3vPpX8M7DMCTwHs\\n' +\n                '1xcXvQ4lQ3rwreDTOWdoJeEEy7gMxXqH0jw0WfBx+8IIJU69xstOyT7FRFDvA1yT\\n' +\n                'RXY2yt9K5s6SKken/ebMfmZR+03ND4UFsDzkz0FfgcjrkXmrMF5Eh5UXX/+9YHeU\\n' +\n                'xlp0gMAt+/SumSmgCaysxZLjLpd4uXz+X+JVxsk1ACg1NoEO7lWJC/3WBP7MIcu2\\n' +\n                'wVsMd2XegLT0gWYfT1/jsIH64U/mS/SVXC9QhxMl9Yfko2kx1OiYhDxhHs75RJZh\\n' +\n                'rNRxgfiwgSb50Gw4NAQaDIxr/DJPdLhgnpY6UQIDAQABAoIBAE+tfzWFjJbgJ0ql\\n' +\n                's6Ozs020Sh4U8TZQuonJ4HhBbNbiTtdDgNObPK1uNadeNtgW5fOeIRdKN6iDjVeN\\n' +\n                'AuXhQrmqGDYVZ1HSGUfD74sTrZQvRlWPLWtzdhybK6Css41YAyPFo9k4bJ2ZW2b/\\n' +\n                'p4EEQ8WsNja9oBpttMU6YYUchGxo1gujN8hmfDdXUQx3k5Xwx4KA68dveJ8GasIt\\n' +\n                'd+0Jd/FVwCyyx8HTiF1FF8QZYQeAXxbXJgLBuCsMQJghlcpBEzWkscBR3Ap1U0Zi\\n' +\n                '4oat8wrPZGCblaA6rNkRUVbc/+Vw0stnuJ/BLHbPxyBs6w495yBSjBqUWZMvljNz\\n' +\n                'm9/aK0ECgYEA9oVIVAd0enjSVIyAZNbw11ElidzdtBkeIJdsxqhmXzeIFZbB39Gd\\n' +\n                'bjtAVclVbq5mLsI1j22ER2rHA4Ygkn6vlLghK3ZMPxZa57oJtmL3oP0RvOjE4zRV\\n' +\n                'dzKexNGo9gU/x9SQbuyOmuauvAYhXZxeLpv+lEfsZTqqrvPUGeBiEQcCgYEA8poG\\n' +\n                'WVnykWuTmCe0bMmvYDsWpAEiZnFLDaKcSbz3O7RMGbPy1cypmqSinIYUpURBT/WY\\n' +\n                'wVPAGtjkuTXtd1Cy58m7PqziB7NNWMcsMGj+lWrTPZ6hCHIBcAImKEPpd+Y9vGJX\\n' +\n                'oatFJguqAGOz7rigBq6iPfeQOCWpmprNAuah++cCgYB1gcybOT59TnA7mwlsh8Qf\\n' +\n                'bm+tSllnin2A3Y0dGJJLmsXEPKtHS7x2Gcot2h1d98V/TlWHe5WNEUmx1VJbYgXB\\n' +\n                'pw8wj2ACxl4ojNYqWPxegaLd4DpRbtW6Tqe9e47FTnU7hIggR6QmFAWAXI+09l8y\\n' +\n                'amssNShqjE9lu5YDi6BTKwKBgQCuIlKGViLfsKjrYSyHnajNWPxiUhIgGBf4PI0T\\n' +\n                '/Jg1ea/aDykxv0rKHnw9/5vYGIsM2st/kR7l5mMecg/2Qa145HsLfMptHo1ZOPWF\\n' +\n                '9gcuttPTegY6aqKPhGthIYX2MwSDMM+X0ri6m0q2JtqjclAjG7yG4CjbtGTt/UlE\\n' +\n                'WMlSZwKBgQDslGeLUnkW0bsV5EG3AKRUyPKz/6DVNuxaIRRhOeWVKV101claqXAT\\n' +\n                'wXOpdKrvkjZbT4AzcNrlGtRl3l7dEVXTu+dN7/ZieJRu7zaStlAQZkIyP9O3DdQ3\\n' +\n                'rIcetQpfrJ1cAqz6Ng0pD0mh77vQ13WG1BBmDFa2A9BuzLoBituf4g==\\n' +\n                '-----END RSA PRIVATE KEY-----'\n        });\n        expect(\n            xoauth2.jwtSignRS256({\n                some: 'payload'\n            })\n        ).to.equal(\n            'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzb21lIjoicGF5bG9hZCJ9.yBo28P5qE8t8yMkN0hC6uWstUAGh8RGW-zLe1NHdtit8ZVlAEdnhXbZvjGEfDWjOeWe1aZ2eZ65i83awWsx02G9HDsI1xMOFTHpviSHLIWnOf1D2hqJxm0On9zYRjd6oFxuRlmJtI9PIDlMJltG7K3leqReLLC6ZOAYL1Au0WY5swdG2eA6Oi83BTEckLj9c-0TYYRYtyRSG9o298Iuc8JL2KhrAbM8d62JgAPuI3hN_NgEtxs36bidt3SHbuWSszAdt1lHR-bFCZ-kXy_DAGlGiYRHRNyvsLR_q_v4GhV2oVi3WSPR816UhHrTryA0NlbanACb8T22bJGRQ708m_g'\n        );\n    });\n});\n"], "filenames": [".travis.yml", "Gruntfile.js", "lib/dkim/message-parser.js", "lib/fetch/cookies.js", "lib/fetch/index.js", "lib/mailer/mail-message.js", "lib/mime-funcs/mime-types.js", "lib/nodemailer.js", "lib/sendmail-transport/index.js", "lib/shared/index.js", "lib/smtp-connection/http-proxy-client.js", "lib/smtp-connection/index.js", "lib/well-known/index.js", "lib/well-known/services.json", "lib/xoauth2/index.js", "package.json", "test/base64/base64-test.js", "test/dkim/dkim-test.js", "test/dkim/message-parser-test.js", "test/dkim/relaxed-body-test.js", "test/dkim/sign-test.js", "test/ethereal-test.js", "test/fetch/cookies-test.js", "test/fetch/fetch-test.js", "test/json-transport/json-transport-test.js", "test/qp/qp-test.js", "test/sendmail/le-unix.test.js", "test/sendmail/le-windows-test.js", "test/sendmail/sendmail-test.js", "test/ses-transport/ses-transport-test.js", "test/shared/shared-test.js", "test/smtp-connection/http-proxy-client-test.js", "test/smtp-connection/smtp-connection-test.js", "test/smtp-connection/xoauth2-mock-server.js", "test/smtp-pool/smtp-pool-test.js", "test/smtp-transport/smtp-tranport-test.js", "test/stream-transport/stream-transport-test.js", "test/well-known/well-known-test.js", "test/xoauth2/server.js", "test/xoauth2/xoauth2-test.js"], "buggy_code_start_loc": [6, 3, 149, 113, 13, 67, 2066, 16, 72, 279, 47, 48, 44, 25, 266, 3, 15, 37, 14, 14, 34, 11, 14, 70, 13, 15, 12, 12, 42, 24, 16, 18, 27, 7, 44, 44, 38, 12, 9, 13], "buggy_code_end_loc": [6, 4, 153, 117, 123, 73, 2091, 132, 72, 501, 48, 602, 45, 29, 271, 4, 113, 272, 16, 50, 105, 58, 382, 504, 92, 122, 38, 38, 117, 377, 357, 68, 1343, 92, 713, 434, 168, 39, 96, 181], "fixing_code_start_loc": [7, 3, 149, 113, 13, 67, 2066, 16, 73, 279, 47, 48, 44, 25, 266, 3, 15, 37, 14, 14, 34, 11, 14, 70, 13, 15, 12, 12, 42, 24, 16, 18, 27, 7, 44, 44, 38, 12, 9, 13], "fixing_code_end_loc": [8, 4, 150, 114, 115, 68, 2084, 127, 81, 493, 48, 592, 45, 29, 271, 4, 113, 272, 16, 50, 105, 58, 382, 504, 92, 122, 38, 38, 157, 377, 357, 68, 1328, 92, 713, 434, 168, 39, 96, 181], "type": "CWE-88", "message": "This affects the package nodemailer before 6.4.16. Use of crafted recipient email addresses may result in arbitrary command flag injection in sendmail transport for sending mails.", "other": {"cve": {"id": "CVE-2020-7769", "sourceIdentifier": "report@snyk.io", "published": "2020-11-12T09:15:11.203", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package nodemailer before 6.4.16. Use of crafted recipient email addresses may result in arbitrary command flag injection in sendmail transport for sending mails."}, {"lang": "es", "value": "Esto afecta al paquete nodemailer versiones anteriores a  6.4.16.&#xa0;El uso de direcciones de correo electr\u00f3nico de destinatarios dise\u00f1adas puede resultar en una inyecci\u00f3n de un flag de comando arbitrario en el transporte de sendmail para enviar correos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-88"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodemailer:nodemailer:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "6.4.16", "matchCriteriaId": "88FDFB98-4838-4A67-BFA2-AD49842C0BDE"}]}]}], "references": [{"url": "https://github.com/nodemailer/nodemailer/blob/33b62e2ea6bc9215c99a9bb4bfba94e2fb27ebd0/lib/sendmail-transport/index.js%23L75", "source": "report@snyk.io", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://github.com/nodemailer/nodemailer/commit/ba31c64c910d884579875c52d57ac45acc47aa54", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1039742", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-NODEMAILER-1038834", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nodemailer/nodemailer/commit/ba31c64c910d884579875c52d57ac45acc47aa54"}}