{"buggy_code": ["/*********************************************************************\n  Blosc - Blocked Shuffling and Compression Library\n\n  Author: Francesc Alted <francesc@blosc.org>\n  Creation date: 2009-05-20\n\n  See LICENSE.txt for details about copyright and rights to use.\n**********************************************************************/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <assert.h>\n\n#include \"blosc2.h\"\n#include \"blosc-private.h\"\n#include \"blosc2-common.h\"\n\n#if defined(USING_CMAKE)\n  #include \"config.h\"\n#endif /*  USING_CMAKE */\n#include \"context.h\"\n\n#include \"shuffle.h\"\n#include \"delta.h\"\n#include \"trunc-prec.h\"\n#include \"blosclz.h\"\n#include \"btune.h\"\n\n#if defined(HAVE_LZ4)\n  #include \"lz4.h\"\n  #include \"lz4hc.h\"\n  #ifdef HAVE_IPP\n    #include <ipps.h>\n    #include <ippdc.h>\n  #endif\n#endif /*  HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  #include \"lizard_compress.h\"\n  #include \"lizard_decompress.h\"\n#endif /*  HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  #include \"snappy-c.h\"\n#endif /*  HAVE_SNAPPY */\n#if defined(HAVE_MINIZ)\n  #include \"miniz.c\"\n#elif defined(HAVE_ZLIB)\n  #include \"zlib.h\"\n#endif /*  HAVE_MINIZ */\n#if defined(HAVE_ZSTD)\n  #include \"zstd.h\"\n  #include \"zstd_errors.h\"\n  // #include \"cover.h\"  // for experimenting with fast cover training for building dicts\n  #include \"zdict.h\"\n#endif /*  HAVE_ZSTD */\n\n\n#if defined(_WIN32) && !defined(__MINGW32__)\n  #include <windows.h>\n  #include <malloc.h>\n\n/* stdint.h only available in VS2010 (VC++ 16.0) and newer */\n  #if defined(_MSC_VER) && _MSC_VER < 1600\n    #include \"win32/stdint-windows.h\"\n  #else\n    #include <stdint.h>\n  #endif\n\n  #include <process.h>\n  #define getpid _getpid\n#else\n  #include <unistd.h>\n#endif  /* _WIN32 */\n\n#if defined(_WIN32) && !defined(__GNUC__)\n  #include \"win32/pthread.c\"\n#endif\n\n/* Synchronization variables */\n\n/* Global context for non-contextual API */\nstatic blosc2_context* g_global_context;\nstatic pthread_mutex_t global_comp_mutex;\nstatic int g_compressor = BLOSC_BLOSCLZ;\nstatic int g_delta = 0;\n/* the compressor to use by default */\nstatic int g_nthreads = 1;\nstatic int32_t g_force_blocksize = 0;\nstatic int g_initlib = 0;\nstatic blosc2_schunk* g_schunk = NULL;   /* the pointer to super-chunk */\n\n\n// Forward declarations\n\nint init_threadpool(blosc2_context *context);\nint release_threadpool(blosc2_context *context);\n\n/* Macros for synchronization */\n\n/* Wait until all threads are initialized */\n#ifdef BLOSC_POSIX_BARRIERS\n#define WAIT_INIT(RET_VAL, CONTEXT_PTR)  \\\n  rc = pthread_barrier_wait(&(CONTEXT_PTR)->barr_init); \\\n  if (rc != 0 && rc != PTHREAD_BARRIER_SERIAL_THREAD) { \\\n    printf(\"Could not wait on barrier (init): %d\\n\", rc); \\\n    return((RET_VAL));                            \\\n  }\n#else\n#define WAIT_INIT(RET_VAL, CONTEXT_PTR)   \\\n  pthread_mutex_lock(&(CONTEXT_PTR)->count_threads_mutex); \\\n  if ((CONTEXT_PTR)->count_threads < (CONTEXT_PTR)->nthreads) { \\\n    (CONTEXT_PTR)->count_threads++;  \\\n    pthread_cond_wait(&(CONTEXT_PTR)->count_threads_cv, \\\n                      &(CONTEXT_PTR)->count_threads_mutex); \\\n  } \\\n  else { \\\n    pthread_cond_broadcast(&(CONTEXT_PTR)->count_threads_cv); \\\n  } \\\n  pthread_mutex_unlock(&(CONTEXT_PTR)->count_threads_mutex);\n#endif\n\n/* Wait for all threads to finish */\n#ifdef BLOSC_POSIX_BARRIERS\n#define WAIT_FINISH(RET_VAL, CONTEXT_PTR)   \\\n  rc = pthread_barrier_wait(&(CONTEXT_PTR)->barr_finish); \\\n  if (rc != 0 && rc != PTHREAD_BARRIER_SERIAL_THREAD) { \\\n    printf(\"Could not wait on barrier (finish)\\n\"); \\\n    return((RET_VAL));                              \\\n  }\n#else\n#define WAIT_FINISH(RET_VAL, CONTEXT_PTR)                           \\\n  pthread_mutex_lock(&(CONTEXT_PTR)->count_threads_mutex); \\\n  if ((CONTEXT_PTR)->count_threads > 0) { \\\n    (CONTEXT_PTR)->count_threads--; \\\n    pthread_cond_wait(&(CONTEXT_PTR)->count_threads_cv, \\\n                      &(CONTEXT_PTR)->count_threads_mutex); \\\n  } \\\n  else { \\\n    pthread_cond_broadcast(&(CONTEXT_PTR)->count_threads_cv); \\\n  } \\\n  pthread_mutex_unlock(&(CONTEXT_PTR)->count_threads_mutex);\n#endif\n\n\n/* global variable to change threading backend from Blosc-managed to caller-managed */\nstatic blosc_threads_callback threads_callback = 0;\nstatic void *threads_callback_data = 0;\n\n/* non-threadsafe function should be called before any other Blosc function in\n   order to change how threads are managed */\nvoid blosc_set_threads_callback(blosc_threads_callback callback, void *callback_data)\n{\n  threads_callback = callback;\n  threads_callback_data = callback_data;\n}\n\n\n/* A function for aligned malloc that is portable */\nstatic uint8_t* my_malloc(size_t size) {\n  void* block = NULL;\n  int res = 0;\n\n/* Do an alignment to 32 bytes because AVX2 is supported */\n#if defined(_WIN32)\n  /* A (void *) cast needed for avoiding a warning with MINGW :-/ */\n  block = (void *)_aligned_malloc(size, 32);\n#elif _POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600\n  /* Platform does have an implementation of posix_memalign */\n  res = posix_memalign(&block, 32, size);\n#else\n  block = malloc(size);\n#endif  /* _WIN32 */\n\n  if (block == NULL || res != 0) {\n    printf(\"Error allocating memory!\");\n    return NULL;\n  }\n\n  return (uint8_t*)block;\n}\n\n\n/* Release memory booked by my_malloc */\nstatic void my_free(void* block) {\n#if defined(_WIN32)\n  _aligned_free(block);\n#else\n  free(block);\n#endif  /* _WIN32 */\n}\n\n\n/*\n * Conversion routines between compressor and compression libraries\n */\n\n/* Return the library code associated with the compressor name */\nstatic int compname_to_clibcode(const char* compname) {\n  if (strcmp(compname, BLOSC_BLOSCLZ_COMPNAME) == 0)\n    return BLOSC_BLOSCLZ_LIB;\n  if (strcmp(compname, BLOSC_LZ4_COMPNAME) == 0)\n    return BLOSC_LZ4_LIB;\n  if (strcmp(compname, BLOSC_LZ4HC_COMPNAME) == 0)\n    return BLOSC_LZ4_LIB;\n  if (strcmp(compname, BLOSC_LIZARD_COMPNAME) == 0)\n    return BLOSC_LIZARD_LIB;\n  if (strcmp(compname, BLOSC_SNAPPY_COMPNAME) == 0)\n    return BLOSC_SNAPPY_LIB;\n  if (strcmp(compname, BLOSC_ZLIB_COMPNAME) == 0)\n    return BLOSC_ZLIB_LIB;\n  if (strcmp(compname, BLOSC_ZSTD_COMPNAME) == 0)\n    return BLOSC_ZSTD_LIB;\n  return -1;\n}\n\n/* Return the library name associated with the compressor code */\nstatic const char* clibcode_to_clibname(int clibcode) {\n  if (clibcode == BLOSC_BLOSCLZ_LIB) return BLOSC_BLOSCLZ_LIBNAME;\n  if (clibcode == BLOSC_LZ4_LIB) return BLOSC_LZ4_LIBNAME;\n  if (clibcode == BLOSC_LIZARD_LIB) return BLOSC_LIZARD_LIBNAME;\n  if (clibcode == BLOSC_SNAPPY_LIB) return BLOSC_SNAPPY_LIBNAME;\n  if (clibcode == BLOSC_ZLIB_LIB) return BLOSC_ZLIB_LIBNAME;\n  if (clibcode == BLOSC_ZSTD_LIB) return BLOSC_ZSTD_LIBNAME;\n  return NULL;                  /* should never happen */\n}\n\n\n/*\n * Conversion routines between compressor names and compressor codes\n */\n\n/* Get the compressor name associated with the compressor code */\nint blosc_compcode_to_compname(int compcode, const char** compname) {\n  int code = -1;    /* -1 means non-existent compressor code */\n  const char* name = NULL;\n\n  /* Map the compressor code */\n  if (compcode == BLOSC_BLOSCLZ)\n    name = BLOSC_BLOSCLZ_COMPNAME;\n  else if (compcode == BLOSC_LZ4)\n    name = BLOSC_LZ4_COMPNAME;\n  else if (compcode == BLOSC_LZ4HC)\n    name = BLOSC_LZ4HC_COMPNAME;\n  else if (compcode == BLOSC_LIZARD)\n    name = BLOSC_LIZARD_COMPNAME;\n  else if (compcode == BLOSC_SNAPPY)\n    name = BLOSC_SNAPPY_COMPNAME;\n  else if (compcode == BLOSC_ZLIB)\n    name = BLOSC_ZLIB_COMPNAME;\n  else if (compcode == BLOSC_ZSTD)\n    name = BLOSC_ZSTD_COMPNAME;\n\n  *compname = name;\n\n  /* Guess if there is support for this code */\n  if (compcode == BLOSC_BLOSCLZ)\n    code = BLOSC_BLOSCLZ;\n#if defined(HAVE_LZ4)\n  else if (compcode == BLOSC_LZ4)\n    code = BLOSC_LZ4;\n  else if (compcode == BLOSC_LZ4HC)\n    code = BLOSC_LZ4HC;\n#endif /* HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  else if (compcode == BLOSC_LIZARD)\n    code = BLOSC_LIZARD;\n#endif /* HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  else if (compcode == BLOSC_SNAPPY)\n    code = BLOSC_SNAPPY;\n#endif /* HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  else if (compcode == BLOSC_ZLIB)\n    code = BLOSC_ZLIB;\n#endif /* HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  else if (compcode == BLOSC_ZSTD)\n    code = BLOSC_ZSTD;\n#endif /* HAVE_ZSTD */\n\n  return code;\n}\n\n\n/* Get the compressor code for the compressor name. -1 if it is not available */\nint blosc_compname_to_compcode(const char* compname) {\n  int code = -1;  /* -1 means non-existent compressor code */\n\n  if (strcmp(compname, BLOSC_BLOSCLZ_COMPNAME) == 0) {\n    code = BLOSC_BLOSCLZ;\n  }\n#if defined(HAVE_LZ4)\n  else if (strcmp(compname, BLOSC_LZ4_COMPNAME) == 0) {\n    code = BLOSC_LZ4;\n  }\n  else if (strcmp(compname, BLOSC_LZ4HC_COMPNAME) == 0) {\n    code = BLOSC_LZ4HC;\n  }\n#endif /*  HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  else if (strcmp(compname, BLOSC_LIZARD_COMPNAME) == 0) {\n    code = BLOSC_LIZARD;\n  }\n#endif /*  HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  else if (strcmp(compname, BLOSC_SNAPPY_COMPNAME) == 0) {\n    code = BLOSC_SNAPPY;\n  }\n#endif /*  HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  else if (strcmp(compname, BLOSC_ZLIB_COMPNAME) == 0) {\n    code = BLOSC_ZLIB;\n  }\n#endif /*  HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  else if (strcmp(compname, BLOSC_ZSTD_COMPNAME) == 0) {\n    code = BLOSC_ZSTD;\n  }\n#endif /*  HAVE_ZSTD */\n\n  return code;\n}\n\n\n#if defined(HAVE_LZ4)\nstatic int lz4_wrap_compress(const char* input, size_t input_length,\n                             char* output, size_t maxout, int accel, void* hash_table) {\n  BLOSC_UNUSED_PARAM(accel);\n  int cbytes;\n#ifdef HAVE_IPP\n  if (hash_table == NULL) {\n    return -1;  // the hash table should always be initialized\n  }\n  int outlen = (int)maxout;\n  int inlen = (int)input_length;\n  // I have not found any function that uses `accel` like in `LZ4_compress_fast`, but\n  // the IPP LZ4Safe call does a pretty good job on compressing well, so let's use it\n  IppStatus status = ippsEncodeLZ4Safe_8u((const Ipp8u*)input, &inlen,\n                                           (Ipp8u*)output, &outlen, (Ipp8u*)hash_table);\n  if (status == ippStsDstSizeLessExpected) {\n    return 0;  // we cannot compress in required outlen\n  }\n  else if (status != ippStsNoErr) {\n    return -1;  // an unexpected error happened\n  }\n  cbytes = outlen;\n#else\n  BLOSC_UNUSED_PARAM(hash_table);\n  accel = 1;  // deactivate acceleration to match IPP behaviour\n  cbytes = LZ4_compress_fast(input, output, (int)input_length, (int)maxout, accel);\n#endif\n  return cbytes;\n}\n\n\nstatic int lz4hc_wrap_compress(const char* input, size_t input_length,\n                               char* output, size_t maxout, int clevel) {\n  int cbytes;\n  if (input_length > (size_t)(UINT32_C(2) << 30))\n    return -1;   /* input larger than 2 GB is not supported */\n  /* clevel for lz4hc goes up to 12, at least in LZ4 1.7.5\n   * but levels larger than 9 do not buy much compression. */\n  cbytes = LZ4_compress_HC(input, output, (int)input_length, (int)maxout,\n                           clevel);\n  return cbytes;\n}\n\n\nstatic int lz4_wrap_decompress(const char* input, size_t compressed_length,\n                               char* output, size_t maxout) {\n  int nbytes;\n#ifdef HAVE_IPP\n  int outlen = (int)maxout;\n  int inlen = (int)compressed_length;\n  IppStatus status;\n  status = ippsDecodeLZ4_8u((const Ipp8u*)input, inlen, (Ipp8u*)output, &outlen);\n  //status = ippsDecodeLZ4Dict_8u((const Ipp8u*)input, &inlen, (Ipp8u*)output, 0, &outlen, NULL, 1 << 16);\n  nbytes = (status == ippStsNoErr) ? outlen : -outlen;\n#else\n  nbytes = LZ4_decompress_safe(input, output, (int)compressed_length, (int)maxout);\n#endif\n  if (nbytes != (int)maxout) {\n    return 0;\n  }\n  return (int)maxout;\n}\n#endif /* HAVE_LZ4 */\n\n\n#if defined(HAVE_LIZARD)\nstatic int lizard_wrap_compress(const char* input, size_t input_length,\n                                char* output, size_t maxout, int clevel) {\n  int cbytes;\n  cbytes = Lizard_compress(input, output, (int)input_length, (int)maxout,\n                           clevel);\n  return cbytes;\n}\n\nstatic int lizard_wrap_decompress(const char* input, size_t compressed_length,\n                                  char* output, size_t maxout) {\n  int dbytes;\n  dbytes = Lizard_decompress_safe(input, output, (int)compressed_length,\n                                  (int)maxout);\n  if (dbytes < 0) {\n    return 0;\n  }\n  return dbytes;\n}\n\n#endif /* HAVE_LIZARD */\n\n#if defined(HAVE_SNAPPY)\nstatic int snappy_wrap_compress(const char* input, size_t input_length,\n                                char* output, size_t maxout) {\n  snappy_status status;\n  size_t cl = maxout;\n  status = snappy_compress(input, input_length, output, &cl);\n  if (status != SNAPPY_OK) {\n    return 0;\n  }\n  return (int)cl;\n}\n\nstatic int snappy_wrap_decompress(const char* input, size_t compressed_length,\n                                  char* output, size_t maxout) {\n  snappy_status status;\n  size_t ul = maxout;\n  status = snappy_uncompress(input, compressed_length, output, &ul);\n  if (status != SNAPPY_OK) {\n    return 0;\n  }\n  return (int)ul;\n}\n#endif /* HAVE_SNAPPY */\n\n\n#if defined(HAVE_ZLIB)\n/* zlib is not very respectful with sharing name space with others.\n Fortunately, its names do not collide with those already in blosc. */\nstatic int zlib_wrap_compress(const char* input, size_t input_length,\n                              char* output, size_t maxout, int clevel) {\n  int status;\n  uLongf cl = (uLongf)maxout;\n  status = compress2(\n      (Bytef*)output, &cl, (Bytef*)input, (uLong)input_length, clevel);\n  if (status != Z_OK) {\n    return 0;\n  }\n  return (int)cl;\n}\n\nstatic int zlib_wrap_decompress(const char* input, size_t compressed_length,\n                                char* output, size_t maxout) {\n  int status;\n  uLongf ul = (uLongf)maxout;\n  status = uncompress(\n      (Bytef*)output, &ul, (Bytef*)input, (uLong)compressed_length);\n  if (status != Z_OK) {\n    return 0;\n  }\n  return (int)ul;\n}\n#endif /*  HAVE_ZLIB */\n\n\n#if defined(HAVE_ZSTD)\nstatic int zstd_wrap_compress(struct thread_context* thread_context,\n                              const char* input, size_t input_length,\n                              char* output, size_t maxout, int clevel) {\n  size_t code;\n  blosc2_context* context = thread_context->parent_context;\n\n  clevel = (clevel < 9) ? clevel * 2 - 1 : ZSTD_maxCLevel();\n  /* Make the level 8 close enough to maxCLevel */\n  if (clevel == 8) clevel = ZSTD_maxCLevel() - 2;\n\n  if (thread_context->zstd_cctx == NULL) {\n    thread_context->zstd_cctx = ZSTD_createCCtx();\n  }\n\n  if (context->use_dict) {\n    assert(context->dict_cdict != NULL);\n    code = ZSTD_compress_usingCDict(\n            thread_context->zstd_cctx, (void*)output, maxout, (void*)input,\n            input_length, context->dict_cdict);\n  } else {\n    code = ZSTD_compressCCtx(thread_context->zstd_cctx,\n        (void*)output, maxout, (void*)input, input_length, clevel);\n  }\n  if (ZSTD_isError(code) != ZSTD_error_no_error) {\n    // Do not print anything because blosc will just memcpy this buffer\n    // fprintf(stderr, \"Error in ZSTD compression: '%s'.  Giving up.\\n\",\n    //         ZDICT_getErrorName(code));\n    return 0;\n  }\n  return (int)code;\n}\n\nstatic int zstd_wrap_decompress(struct thread_context* thread_context,\n                                const char* input, size_t compressed_length,\n                                char* output, size_t maxout) {\n  size_t code;\n  blosc2_context* context = thread_context->parent_context;\n\n  if (thread_context->zstd_dctx == NULL) {\n    thread_context->zstd_dctx = ZSTD_createDCtx();\n  }\n\n  if (context->use_dict) {\n    assert(context->dict_ddict != NULL);\n    code = ZSTD_decompress_usingDDict(\n            thread_context->zstd_dctx, (void*)output, maxout, (void*)input,\n            compressed_length, context->dict_ddict);\n  } else {\n    code = ZSTD_decompressDCtx(thread_context->zstd_dctx,\n        (void*)output, maxout, (void*)input, compressed_length);\n  }\n  if (ZSTD_isError(code) != ZSTD_error_no_error) {\n    fprintf(stderr, \"Error in ZSTD decompression: '%s'.  Giving up.\\n\",\n            ZDICT_getErrorName(code));\n    return 0;\n  }\n  return (int)code;\n}\n#endif /*  HAVE_ZSTD */\n\n/* Compute acceleration for blosclz */\nstatic int get_accel(const blosc2_context* context) {\n  int clevel = context->clevel;\n\n  if (context->compcode == BLOSC_LZ4) {\n    /* This acceleration setting based on discussions held in:\n     * https://groups.google.com/forum/#!topic/lz4c/zosy90P8MQw\n     */\n    return (10 - clevel);\n  }\n  else if (context->compcode == BLOSC_LIZARD) {\n    /* Lizard currently accepts clevels from 10 to 49 */\n      switch (clevel) {\n        case 1 :\n            return 10;\n        case 2 :\n            return 10;\n        case 3 :\n            return 10;\n        case 4 :\n            return 10;\n        case 5 :\n            return 20;\n        case 6 :\n            return 20;\n        case 7 :\n            return 20;\n        case 8 :\n            return 41;\n        case 9 :\n            return 41;\n        default :\n          break;\n      }\n  }\n  return 1;\n}\n\n\nint do_nothing(int8_t filter, char cmode) {\n  if (cmode == 'c') {\n    return (filter == BLOSC_NOFILTER);\n  } else {\n    // TRUNC_PREC do not have to be applied during decompression\n    return ((filter == BLOSC_NOFILTER) || (filter == BLOSC_TRUNC_PREC));\n  }\n}\n\n\nint next_filter(const uint8_t* filters, int current_filter, char cmode) {\n  for (int i = current_filter - 1; i >= 0; i--) {\n    if (!do_nothing(filters[i], cmode)) {\n      return filters[i];\n    }\n  }\n  return BLOSC_NOFILTER;\n}\n\n\nint last_filter(const uint8_t* filters, char cmode) {\n  int last_index = -1;\n  for (int i = BLOSC2_MAX_FILTERS - 1; i >= 0; i--) {\n    if (!do_nothing(filters[i], cmode))  {\n      last_index = i;\n    }\n  }\n  return last_index;\n}\n\n\nuint8_t* pipeline_c(struct thread_context* thread_context, const int32_t bsize,\n                    const uint8_t* src, const int32_t offset,\n                    uint8_t* dest, uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  uint8_t* _src = (uint8_t*)src + offset;\n  uint8_t* _tmp = tmp;\n  uint8_t* _dest = dest;\n  int32_t typesize = context->typesize;\n  uint8_t* filters = context->filters;\n  uint8_t* filters_meta = context->filters_meta;\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  /* Prefilter function */\n  if (context->prefilter != NULL) {\n    // Create new prefilter parameters for this block (must be private for each thread)\n    blosc2_prefilter_params pparams;\n    memcpy(&pparams, context->pparams, sizeof(pparams));\n    pparams.out = _dest;\n    pparams.out_size = (size_t)bsize;\n    pparams.out_typesize = typesize;\n    pparams.out_offset = offset;\n    pparams.tid = thread_context->tid;\n    pparams.ttmp = thread_context->tmp;\n    pparams.ttmp_nbytes = thread_context->tmp_nbytes;\n    pparams.ctx = context;\n\n    if (context->prefilter(&pparams) != 0) {\n      fprintf(stderr, \"Execution of prefilter function failed\\n\");\n      return NULL;\n    }\n\n    if (memcpyed) {\n      // No more filters are required\n      return _dest;\n    }\n    // Cycle buffers\n    _src = _dest;\n    _dest = _tmp;\n    _tmp = _src;\n  }\n\n  /* Process the filter pipeline */\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    switch (filters[i]) {\n      case BLOSC_SHUFFLE:\n        for (int j = 0; j <= filters_meta[i]; j++) {\n          shuffle(typesize, bsize, _src, _dest);\n          // Cycle filters when required\n          if (j < filters_meta[i]) {\n            _src = _dest;\n            _dest = _tmp;\n            _tmp = _src;\n          }\n        }\n        break;\n      case BLOSC_BITSHUFFLE:\n        bitshuffle(typesize, bsize, _src, _dest, tmp2);\n        break;\n      case BLOSC_DELTA:\n        delta_encoder(src, offset, bsize, typesize, _src, _dest);\n        break;\n      case BLOSC_TRUNC_PREC:\n        truncate_precision(filters_meta[i], typesize, bsize, _src, _dest);\n        break;\n      default:\n        if (filters[i] != BLOSC_NOFILTER) {\n          fprintf(stderr, \"Filter %d not handled during compression\\n\", filters[i]);\n          return NULL;\n        }\n    }\n    // Cycle buffers when required\n    if (filters[i] != BLOSC_NOFILTER) {\n      _src = _dest;\n      _dest = _tmp;\n      _tmp = _src;\n    }\n  }\n  return _src;\n}\n\n\n// Optimized version for detecting runs.  It compares 8 bytes values wherever possible.\nstatic bool get_run(const uint8_t* ip, const uint8_t* ip_bound) {\n  uint8_t x = *ip;\n  int64_t value, value2;\n  /* Broadcast the value for every byte in a 64-bit register */\n  memset(&value, x, 8);\n  while (ip < (ip_bound - 8)) {\n#if defined(BLOSC_STRICT_ALIGN)\n    memcpy(&value2, ref, 8);\n#else\n    value2 = *(int64_t*)ip;\n#endif\n    if (value != value2) {\n      // Values differ.  We don't have a run.\n      return false;\n    }\n    else {\n      ip += 8;\n    }\n  }\n  /* Look into the remainder */\n  while ((ip < ip_bound) && (*ip == x)) ip++;\n  return ip == ip_bound ? true : false;\n}\n\n\n/* Shuffle & compress a single block */\nstatic int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > maxbytes) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)maxbytes - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > maxbytes) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n\n  //printf(\"c%d\", ctbytes);\n  return ctbytes;\n}\n\n\n/* Process the filter pipeline (decompression mode) */\nint pipeline_d(blosc2_context* context, const int32_t bsize, uint8_t* dest,\n               const int32_t offset, uint8_t* src, uint8_t* tmp,\n               uint8_t* tmp2, int last_filter_index) {\n  int32_t typesize = context->typesize;\n  uint8_t* filters = context->filters;\n  uint8_t* filters_meta = context->filters_meta;\n  uint8_t* _src = src;\n  uint8_t* _dest = tmp;\n  uint8_t* _tmp = tmp2;\n  int errcode = 0;\n\n  for (int i = BLOSC2_MAX_FILTERS - 1; i >= 0; i--) {\n    // Delta filter requires the whole chunk ready\n    int last_copy_filter = (last_filter_index == i) || (next_filter(filters, i, 'd') == BLOSC_DELTA);\n    if (last_copy_filter) {\n      _dest = dest + offset;\n    }\n    switch (filters[i]) {\n      case BLOSC_SHUFFLE:\n        for (int j = 0; j <= filters_meta[i]; j++) {\n          unshuffle(typesize, bsize, _src, _dest);\n          // Cycle filters when required\n          if (j < filters_meta[i]) {\n            _src = _dest;\n            _dest = _tmp;\n            _tmp = _src;\n          }\n          // Check whether we have to copy the intermediate _dest buffer to final destination\n          if (last_copy_filter && (filters_meta[i] % 2) == 1 && j == filters_meta[i]) {\n            memcpy(dest + offset, _dest, (unsigned int)bsize);\n          }\n        }\n        break;\n      case BLOSC_BITSHUFFLE:\n        bitunshuffle(typesize, bsize, _src, _dest, _tmp, context->src[0]);\n        break;\n      case BLOSC_DELTA:\n        if (context->nthreads == 1) {\n          /* Serial mode */\n          delta_decoder(dest, offset, bsize, typesize, _dest);\n        } else {\n          /* Force the thread in charge of the block 0 to go first */\n          pthread_mutex_lock(&context->delta_mutex);\n          if (context->dref_not_init) {\n            if (offset != 0) {\n              pthread_cond_wait(&context->delta_cv, &context->delta_mutex);\n            } else {\n              delta_decoder(dest, offset, bsize, typesize, _dest);\n              context->dref_not_init = 0;\n              pthread_cond_broadcast(&context->delta_cv);\n            }\n          }\n          pthread_mutex_unlock(&context->delta_mutex);\n          if (offset != 0) {\n            delta_decoder(dest, offset, bsize, typesize, _dest);\n          }\n        }\n        break;\n      case BLOSC_TRUNC_PREC:\n        // TRUNC_PREC filter does not need to be undone\n        break;\n      default:\n        if (filters[i] != BLOSC_NOFILTER) {\n          fprintf(stderr, \"Filter %d not handled during decompression\\n\",\n                  filters[i]);\n          errcode = -1;\n        }\n    }\n    if (last_filter_index == i) {\n      return errcode;\n    }\n    // Cycle buffers when required\n    if ((filters[i] != BLOSC_NOFILTER) && (filters[i] != BLOSC_TRUNC_PREC)) {\n      _src = _dest;\n      _dest = _tmp;\n      _tmp = _src;\n    }\n  }\n\n  return errcode;\n}\n\n\n/* Decompress & unshuffle a single block */\nstatic int blosc_d(\n    struct thread_context* thread_context, int32_t bsize,\n    int32_t leftoverblock, const uint8_t* src, int32_t srcsize, int32_t src_offset,\n    uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  uint8_t* filters = context->filters;\n  uint8_t *tmp3 = thread_context->tmp4;\n  int32_t compformat = (context->header_flags & 0xe0) >> 5;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  //uint8_t blosc_version_format = src[0];\n  int nstreams;\n  int32_t neblock;\n  int32_t nbytes;                /* number of decompressed bytes in split */\n  int32_t cbytes;                /* number of compressed bytes in split */\n  int32_t ctbytes = 0;           /* number of compressed bytes in block */\n  int32_t ntbytes = 0;           /* number of uncompressed bytes in block */\n  uint8_t* _dest;\n  int32_t typesize = context->typesize;\n  int32_t nblock = dest_offset / context->blocksize;\n  const char* compname;\n\n  if (context->block_maskout != NULL && context->block_maskout[nblock]) {\n    // Do not decompress, but act as if we successfully decompressed everything\n    return bsize;\n  }\n\n  if (src_offset <= 0 || src_offset >= srcsize) {\n    /* Invalid block src offset encountered */\n    return -1;\n  }\n\n  src += src_offset;\n  srcsize -= src_offset;\n\n  int last_filter_index = last_filter(filters, 'd');\n\n  if ((last_filter_index >= 0) &&\n          (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) {\n   // We are making use of some filter, so use a temp for destination\n   _dest = tmp;\n  } else {\n    // If no filters, or only DELTA in pipeline\n   _dest = dest + dest_offset;\n  }\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !context->use_dict) {\n    // We don't want to split when in a training dict state\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n\n  neblock = bsize / nstreams;\n  for (int j = 0; j < nstreams; j++) {\n    if (srcsize < sizeof(int32_t)) {\n      /* Not enough input to read compressed size */\n      return -1;\n    }\n    srcsize -= sizeof(int32_t);\n    cbytes = sw32_(src);      /* amount of compressed bytes */\n    if (cbytes > 0) {\n      if (srcsize < cbytes) {\n        /* Not enough input to read compressed bytes */\n        return -1;\n      }\n      srcsize -= cbytes;\n    }\n    src += sizeof(int32_t);\n    ctbytes += (int32_t)sizeof(int32_t);\n\n    /* Uncompress */\n    if (cbytes <= 0) {\n      // A run\n      if (cbytes < -255) {\n        // Runs can only encode a byte\n        return -2;\n      }\n      uint8_t value = -cbytes;\n      memset(_dest, value, (unsigned int)neblock);\n      nbytes = neblock;\n      cbytes = 0;  // everything is encoded in the cbytes token\n    }\n    else if (cbytes == neblock) {\n      memcpy(_dest, src, (unsigned int)neblock);\n      nbytes = (int32_t)neblock;\n    }\n    else {\n      if (compformat == BLOSC_BLOSCLZ_FORMAT) {\n        nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);\n      }\n  #if defined(HAVE_LZ4)\n      else if (compformat == BLOSC_LZ4_FORMAT) {\n        nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,\n                                     (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n      else if (compformat == BLOSC_LIZARD_FORMAT) {\n        nbytes = lizard_wrap_decompress((char*)src, (size_t)cbytes,\n                                        (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n      else if (compformat == BLOSC_SNAPPY_FORMAT) {\n        nbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,\n                                        (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n      else if (compformat == BLOSC_ZLIB_FORMAT) {\n        nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n      else if (compformat == BLOSC_ZSTD_FORMAT) {\n        nbytes = zstd_wrap_decompress(thread_context,\n                                      (char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZSTD */\n      else {\n        compname = clibcode_to_clibname(compformat);\n        fprintf(stderr,\n                \"Blosc has not been compiled with decompression \"\n                    \"support for '%s' format. \", compname);\n        fprintf(stderr, \"Please recompile for adding this support.\\n\");\n        return -5;    /* signals no decompression support */\n      }\n\n      /* Check that decompressed bytes number is correct */\n      if (nbytes != neblock) {\n        return -2;\n      }\n\n    }\n    src += cbytes;\n    ctbytes += cbytes;\n    _dest += nbytes;\n    ntbytes += nbytes;\n  } /* Closes j < nstreams */\n\n  if (last_filter_index >= 0) {\n    int errcode = pipeline_d(context, bsize, dest, dest_offset, tmp, tmp2, tmp3,\n                             last_filter_index);\n    if (errcode < 0)\n      return errcode;\n  }\n\n  /* Return the number of uncompressed bytes */\n  return (int)ntbytes;\n}\n\n\n/* Serial version for compression/decompression */\nstatic int serial_blosc(struct thread_context* thread_context) {\n  blosc2_context* context = thread_context->parent_context;\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n  int32_t ntbytes = (int32_t)context->output_bytes;\n  int32_t* bstarts = context->bstarts;\n  uint8_t* tmp = thread_context->tmp;\n  uint8_t* tmp2 = thread_context->tmp2;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->do_compress && !memcpyed && !dict_training) {\n      _sw32(bstarts + j, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->do_compress) {\n      if (memcpyed && !context->prefilter) {\n        /* We want to memcpy only */\n        memcpy(context->dest + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n                 context->src + j * context->blocksize,\n                 (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src, j * context->blocksize,\n                         context->dest + ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      if (memcpyed) {\n        // Check that sizes in header are compatible, otherwise there is a header corruption\n        int32_t csize = sw32_(context->src + 12);   /* compressed buffer size */\n        if (context->sourcesize + BLOSC_MAX_OVERHEAD != csize) {\n          return -1;\n        }\n        if (context->srcsize < BLOSC_MAX_OVERHEAD + (j * context->blocksize) + bsize) {\n          /* Not enough input to copy block */\n          return -1;\n        }\n        memcpy(context->dest + j * context->blocksize,\n               context->src + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n               (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular decompression */\n        cbytes = blosc_d(thread_context, bsize, leftoverblock,\n                         context->src, context->srcsize, sw32_(bstarts + j),\n                         context->dest, j * context->blocksize, tmp, tmp2);\n      }\n    }\n\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}\n\nstatic void t_blosc_do_job(void *ctxt);\n\n/* Threaded version for compression/decompression */\nstatic int parallel_blosc(blosc2_context* context) {\n#ifdef BLOSC_POSIX_BARRIERS\n  int rc;\n#endif\n  /* Set sentinels */\n  context->thread_giveup_code = 1;\n  context->thread_nblock = -1;\n\n  if (threads_callback) {\n    threads_callback(threads_callback_data, t_blosc_do_job,\n                     context->nthreads, sizeof(struct thread_context), (void*) context->thread_contexts);\n  }\n  else {\n    /* Synchronization point for all threads (wait for initialization) */\n    WAIT_INIT(-1, context);\n\n    /* Synchronization point for all threads (wait for finalization) */\n    WAIT_FINISH(-1, context);\n  }\n\n  if (context->thread_giveup_code <= 0) {\n    /* Compression/decompression gave up.  Return error code. */\n    return context->thread_giveup_code;\n  }\n\n  /* Return the total bytes (de-)compressed in threads */\n  return (int)context->output_bytes;\n}\n\n/* initialize a thread_context that has already been allocated */\nstatic void init_thread_context(struct thread_context* thread_context, blosc2_context* context, int32_t tid)\n{\n  int32_t ebsize;\n\n  thread_context->parent_context = context;\n  thread_context->tid = tid;\n\n  ebsize = context->blocksize + context->typesize * (int32_t)sizeof(int32_t);\n  thread_context->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;\n  thread_context->tmp = my_malloc(thread_context->tmp_nbytes);\n  thread_context->tmp2 = thread_context->tmp + context->blocksize;\n  thread_context->tmp3 = thread_context->tmp + context->blocksize + ebsize;\n  thread_context->tmp4 = thread_context->tmp + 2 * context->blocksize + ebsize;\n  thread_context->tmp_blocksize = context->blocksize;\n  #if defined(HAVE_ZSTD)\n  thread_context->zstd_cctx = NULL;\n  thread_context->zstd_dctx = NULL;\n  #endif\n\n  /* Create the hash table for LZ4 in case we are using IPP */\n#ifdef HAVE_IPP\n  IppStatus status;\n  int inlen = thread_context->tmp_blocksize > 0 ? thread_context->tmp_blocksize : 1 << 16;\n  int hash_size = 0;\n  status = ippsEncodeLZ4HashTableGetSize_8u(&hash_size);\n  if (status != ippStsNoErr) {\n    fprintf(stderr, \"Error in ippsEncodeLZ4HashTableGetSize_8u\");\n  }\n  Ipp8u *hash_table = ippsMalloc_8u(hash_size);\n  status = ippsEncodeLZ4HashTableInit_8u(hash_table, inlen);\n  if (status != ippStsNoErr) {\n    fprintf(stderr, \"Error in ippsEncodeLZ4HashTableInit_8u\");\n  }\n  thread_context->lz4_hash_table = hash_table;\n#endif\n}\n\nstatic struct thread_context*\ncreate_thread_context(blosc2_context* context, int32_t tid) {\n  struct thread_context* thread_context;\n  thread_context = (struct thread_context*)my_malloc(sizeof(struct thread_context));\n  init_thread_context(thread_context, context, tid);\n  return thread_context;\n}\n\n/* free members of thread_context, but not thread_context itself */\nstatic void destroy_thread_context(struct thread_context* thread_context) {\n  my_free(thread_context->tmp);\n#if defined(HAVE_ZSTD)\n  if (thread_context->zstd_cctx != NULL) {\n    ZSTD_freeCCtx(thread_context->zstd_cctx);\n  }\n  if (thread_context->zstd_dctx != NULL) {\n    ZSTD_freeDCtx(thread_context->zstd_dctx);\n  }\n#endif\n#ifdef HAVE_IPP\n  if (thread_context->lz4_hash_table != NULL) {\n    ippsFree(thread_context->lz4_hash_table);\n  }\n#endif\n}\n\nvoid free_thread_context(struct thread_context* thread_context) {\n  destroy_thread_context(thread_context);\n  my_free(thread_context);\n}\n\n\nint check_nthreads(blosc2_context* context) {\n  if (context->nthreads <= 0) {\n    fprintf(stderr, \"Error.  nthreads must be a positive integer\");\n    return -1;\n  }\n\n  if (context->new_nthreads != context->nthreads) {\n    if (context->nthreads > 1) {\n      release_threadpool(context);\n    }\n    context->nthreads = context->new_nthreads;\n  }\n  if (context->new_nthreads > 1 && context->threads_started == 0) {\n    init_threadpool(context);\n  }\n\n  return context->nthreads;\n}\n\n/* Do the compression or decompression of the buffer depending on the\n   global params. */\nstatic int do_job(blosc2_context* context) {\n  int32_t ntbytes;\n\n  /* Set sentinels */\n  context->dref_not_init = 1;\n\n  /* Check whether we need to restart threads */\n  check_nthreads(context);\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not larger than blocksize */\n  if (context->nthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    /* The context for this 'thread' has no been initialized yet */\n    if (context->serial_context == NULL) {\n      context->serial_context = create_thread_context(context, 0);\n    }\n    else if (context->blocksize != context->serial_context->tmp_blocksize) {\n      free_thread_context(context->serial_context);\n      context->serial_context = create_thread_context(context, 0);\n    }\n    ntbytes = serial_blosc(context->serial_context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}\n\n\n/* Convert filter pipeline to filter flags */\nstatic uint8_t filters_to_flags(const uint8_t* filters) {\n  uint8_t flags = 0;\n\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    switch (filters[i]) {\n      case BLOSC_SHUFFLE:\n        flags |= BLOSC_DOSHUFFLE;\n        break;\n      case BLOSC_BITSHUFFLE:\n        flags |= BLOSC_DOBITSHUFFLE;\n        break;\n      case BLOSC_DELTA:\n        flags |= BLOSC_DODELTA;\n        break;\n      default :\n        break;\n    }\n  }\n  return flags;\n}\n\n\n/* Convert filter flags to filter pipeline */\nstatic void flags_to_filters(const uint8_t flags, uint8_t* filters) {\n  /* Initialize the filter pipeline */\n  memset(filters, 0, BLOSC2_MAX_FILTERS);\n  /* Fill the filter pipeline */\n  if (flags & BLOSC_DOSHUFFLE)\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;\n  if (flags & BLOSC_DOBITSHUFFLE)\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;\n  if (flags & BLOSC_DODELTA)\n    filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;\n}\n\n\nstatic int initialize_context_compression(\n  blosc2_context* context, const void* src, int32_t srcsize, void* dest,\n  int32_t destsize, int clevel, uint8_t const *filters,\n  uint8_t const *filters_meta, int32_t typesize, int compressor,\n  int32_t blocksize, int new_nthreads, int nthreads, blosc2_schunk* schunk) {\n\n  /* Set parameters */\n  context->do_compress = 1;\n  context->src = (const uint8_t*)src;\n  context->srcsize = srcsize;\n  context->dest = (uint8_t*)dest;\n  context->output_bytes = 0;\n  context->destsize = destsize;\n  context->sourcesize = srcsize;\n  context->typesize = (int32_t)typesize;\n  context->filter_flags = filters_to_flags(filters);\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    context->filters[i] = filters[i];\n    context->filters_meta[i] = filters_meta[i];\n  }\n  context->compcode = compressor;\n  context->nthreads = nthreads;\n  context->new_nthreads = new_nthreads;\n  context->end_threads = 0;\n  context->clevel = clevel;\n  context->schunk = schunk;\n\n  /* Tune some compression parameters */\n  context->blocksize = (int32_t)blocksize;\n  if (context->btune != NULL) {\n    btune_next_cparams(context);\n  } else {\n    btune_next_blocksize(context);\n  }\n\n  char* envvar = getenv(\"BLOSC_WARN\");\n  int warnlvl = 0;\n  if (envvar != NULL) {\n    warnlvl = strtol(envvar, NULL, 10);\n  }\n\n  /* Check buffer size limits */\n  if (srcsize > BLOSC_MAX_BUFFERSIZE) {\n    if (warnlvl > 0) {\n      fprintf(stderr, \"Input buffer size cannot exceed %d bytes\\n\",\n              BLOSC_MAX_BUFFERSIZE);\n    }\n    return 0;\n  }\n\n  if (destsize < BLOSC_MAX_OVERHEAD) {\n    if (warnlvl > 0) {\n      fprintf(stderr, \"Output buffer size should be larger than %d bytes\\n\",\n              BLOSC_MAX_OVERHEAD);\n    }\n    return 0;\n  }\n\n  if (destsize < BLOSC_MAX_OVERHEAD) {\n    if (warnlvl > 0) {\n      fprintf(stderr, \"Output buffer size should be larger than %d bytes\\n\",\n              BLOSC_MAX_OVERHEAD);\n    }\n    return -2;\n  }\n  if (destsize < BLOSC_MAX_OVERHEAD) {\n    fprintf(stderr, \"Output buffer size should be larger than %d bytes\\n\",\n            BLOSC_MAX_OVERHEAD);\n    return -1;\n  }\n\n  /* Compression level */\n  if (clevel < 0 || clevel > 9) {\n    /* If clevel not in 0..9, print an error */\n    fprintf(stderr, \"`clevel` parameter must be between 0 and 9!\\n\");\n    return -10;\n  }\n\n  /* Check typesize limits */\n  if (context->typesize > BLOSC_MAX_TYPESIZE) {\n    /* If typesize is too large, treat buffer as an 1-byte stream. */\n    context->typesize = 1;\n  }\n\n  /* Compute number of blocks in buffer */\n  context->nblocks = context->sourcesize / context->blocksize;\n  context->leftover = context->sourcesize % context->blocksize;\n  context->nblocks = (context->leftover > 0) ?\n                     (context->nblocks + 1) : context->nblocks;\n\n  return 1;\n}\n\n\n/* Get filter flags from header flags */\nstatic uint8_t get_filter_flags(const uint8_t header_flags,\n                                const int32_t typesize) {\n  uint8_t flags = 0;\n\n  if ((header_flags & BLOSC_DOSHUFFLE) && (typesize > 1)) {\n    flags |= BLOSC_DOSHUFFLE;\n  }\n  if (header_flags & BLOSC_DOBITSHUFFLE) {\n    flags |= BLOSC_DOBITSHUFFLE;\n  }\n  if (header_flags & BLOSC_DODELTA) {\n    flags |= BLOSC_DODELTA;\n  }\n  if (header_flags & BLOSC_MEMCPYED) {\n    flags |= BLOSC_MEMCPYED;\n  }\n  return flags;\n}\n\n\nstatic int initialize_context_decompression(blosc2_context* context, const void* src, int32_t srcsize,\n                                            void* dest, int32_t destsize) {\n  uint8_t blosc2_flags = 0;\n  int32_t cbytes;\n  int32_t bstarts_offset;\n  int32_t bstarts_end;\n\n  context->do_compress = 0;\n  context->src = (const uint8_t*)src;\n  context->srcsize = srcsize;\n  context->dest = (uint8_t*)dest;\n  context->destsize = destsize;\n  context->output_bytes = 0;\n  context->end_threads = 0;\n\n  if (context->srcsize < BLOSC_MIN_HEADER_LENGTH) {\n    /* Not enough input to read minimum header */\n    return -1;\n  }\n\n  context->header_flags = context->src[2];\n  context->typesize = context->src[3];\n  context->sourcesize = sw32_(context->src + 4);\n  context->blocksize = sw32_(context->src + 8);\n  cbytes = sw32_(context->src + 12);\n\n  // Some checks for malformed headers\n  if (context->blocksize <= 0 || context->blocksize > destsize ||\n      context->typesize <= 0 || context->typesize > BLOSC_MAX_TYPESIZE ||\n      cbytes > srcsize) {\n    return -1;\n  }\n  /* Check that we have enough space to decompress */\n  if (context->sourcesize > (int32_t)destsize) {\n    return -1;\n  }\n\n  /* Total blocks */\n  context->nblocks = context->sourcesize / context->blocksize;\n  context->leftover = context->sourcesize % context->blocksize;\n  context->nblocks = (context->leftover > 0) ?\n                      context->nblocks + 1 : context->nblocks;\n\n  if (context->block_maskout != NULL && context->block_maskout_nitems != context->nblocks) {\n    fprintf(stderr, \"The number of items in block_maskout (%d) must match the number\"\n                    \" of blocks in chunk (%d)\", context->block_maskout_nitems, context->nblocks);\n    return -2;\n  }\n\n  if ((context->header_flags & BLOSC_DOSHUFFLE) &&\n      (context->header_flags & BLOSC_DOBITSHUFFLE)) {\n    /* Extended header */\n    if (context->srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {\n      /* Not enough input to read extended header */\n      return -1;\n    }\n    uint8_t* filters = (uint8_t*)(context->src + BLOSC_MIN_HEADER_LENGTH);\n    uint8_t* filters_meta = filters + 8;\n    uint8_t header_version = context->src[0];\n    // The number of filters depends on the version of the header\n    // (we need to read less because filters where not initialized to zero in blosc2 alpha series)\n    int max_filters = (header_version == BLOSC2_VERSION_FORMAT_ALPHA) ? 5 : BLOSC2_MAX_FILTERS;\n    for (int i = 0; i < max_filters; i++) {\n      context->filters[i] = filters[i];\n      context->filters_meta[i] = filters_meta[i];\n    }\n    context->filter_flags = filters_to_flags(filters);\n    bstarts_offset = BLOSC_EXTENDED_HEADER_LENGTH;\n    blosc2_flags = context->src[0x1F];\n  } else {\n    /* Regular (Blosc1) header */\n    context->filter_flags = get_filter_flags(context->header_flags,\n                                             context->typesize);\n    flags_to_filters(context->header_flags, context->filters);\n    bstarts_offset = BLOSC_MIN_HEADER_LENGTH;\n  }\n\n  context->bstarts = (int32_t*)(context->src + bstarts_offset);\n  bstarts_end = bstarts_offset + (context->nblocks * sizeof(int32_t));\n  if (srcsize < bstarts_end) {\n    /* Not enough input to read entire `bstarts` section */\n    return -1;\n  }\n  srcsize -= bstarts_end;\n\n  /* Read optional dictionary if flag set */\n  if (blosc2_flags & BLOSC2_USEDICT) {\n#if defined(HAVE_ZSTD)\n    context->use_dict = 1;\n    if (context->dict_ddict != NULL) {\n      // Free the existing dictionary (probably from another chunk)\n      ZSTD_freeDDict(context->dict_ddict);\n    }\n    // The trained dictionary is after the bstarts block\n    if (srcsize < sizeof(int32_t)) {\n      /* Not enough input to size of dictionary */\n      return -1;\n    }\n    srcsize -= sizeof(int32_t);\n    context->dict_size = (size_t)sw32_(context->src + bstarts_end);\n    if (context->dict_size <= 0 || context->dict_size > BLOSC2_MAXDICTSIZE) {\n      /* Dictionary size is smaller than minimum or larger than maximum allowed */\n      return -1;\n    }\n    if (srcsize < (int32_t)context->dict_size) {\n      /* Not enough input to read entire dictionary */\n      return -1;\n    }\n    srcsize -= context->dict_size;\n    context->dict_buffer = (void*)(context->src + bstarts_end + sizeof(int32_t));\n    context->dict_ddict = ZSTD_createDDict(context->dict_buffer, context->dict_size);\n#endif   // HAVE_ZSTD\n  }\n\n\n  return 0;\n}\n\n\nstatic int write_compression_header(blosc2_context* context,\n                                    bool extended_header) {\n  int32_t compformat;\n  int dont_split;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n\n  // Set the whole header to zeros so that the reserved values are zeroed\n  if (extended_header) {\n    memset(context->dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);\n  }\n  else {\n    memset(context->dest, 0, BLOSC_MIN_HEADER_LENGTH);\n  }\n\n  /* Write version header for this block */\n  context->dest[0] = BLOSC_VERSION_FORMAT;\n\n  /* Write compressor format */\n  compformat = -1;\n  switch (context->compcode) {\n    case BLOSC_BLOSCLZ:\n      compformat = BLOSC_BLOSCLZ_FORMAT;\n      context->dest[1] = BLOSC_BLOSCLZ_VERSION_FORMAT;\n      break;\n\n#if defined(HAVE_LZ4)\n    case BLOSC_LZ4:\n      compformat = BLOSC_LZ4_FORMAT;\n      context->dest[1] = BLOSC_LZ4_VERSION_FORMAT;\n      break;\n    case BLOSC_LZ4HC:\n      compformat = BLOSC_LZ4HC_FORMAT;\n      context->dest[1] = BLOSC_LZ4HC_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_LZ4 */\n\n#if defined(HAVE_LIZARD)\n    case BLOSC_LIZARD:\n      compformat = BLOSC_LIZARD_FORMAT;\n      context->dest[1] = BLOSC_LIZARD_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_LIZARD */\n\n#if defined(HAVE_SNAPPY)\n    case BLOSC_SNAPPY:\n      compformat = BLOSC_SNAPPY_FORMAT;\n      context->dest[1] = BLOSC_SNAPPY_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_SNAPPY */\n\n#if defined(HAVE_ZLIB)\n    case BLOSC_ZLIB:\n      compformat = BLOSC_ZLIB_FORMAT;\n      context->dest[1] = BLOSC_ZLIB_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_ZLIB */\n\n#if defined(HAVE_ZSTD)\n    case BLOSC_ZSTD:\n      compformat = BLOSC_ZSTD_FORMAT;\n      context->dest[1] = BLOSC_ZSTD_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_ZSTD */\n\n    default: {\n      const char* compname;\n      compname = clibcode_to_clibname(compformat);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n      break;\n    }\n  }\n\n  if (context->clevel == 0) {\n    /* Compression level 0 means buffer to be memcpy'ed */\n    context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n  }\n\n  if (context->sourcesize < BLOSC_MIN_BUFFERSIZE) {\n    /* Buffer is too small.  Try memcpy'ing. */\n    context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n  }\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  context->dest[2] = 0;                               /* zeroes flags */\n  context->dest[3] = (uint8_t)context->typesize;\n  _sw32(context->dest + 4, (int32_t)context->sourcesize);\n  _sw32(context->dest + 8, (int32_t)context->blocksize);\n  if (extended_header) {\n    /* Mark that we are handling an extended header */\n    context->header_flags |= (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);\n    /* Store filter pipeline info at the end of the header */\n    uint8_t *filters = context->dest + BLOSC_MIN_HEADER_LENGTH;\n    uint8_t *filters_meta = filters + 8;\n    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n      filters[i] = context->filters[i];\n      filters_meta[i] = context->filters_meta[i];\n    }\n    uint8_t* blosc2_flags = context->dest + 0x1F;\n    *blosc2_flags = 0;    // zeroes flags\n    *blosc2_flags |= is_little_endian() ? 0 : BLOSC2_BIGENDIAN;  // endianness\n    if (dict_training || memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH;\n    } else {\n      context->bstarts = (int32_t*)(context->dest + BLOSC_EXTENDED_HEADER_LENGTH);\n      context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH +\n                              sizeof(int32_t) * context->nblocks;\n    }\n    if (context->use_dict) {\n      *blosc2_flags |= BLOSC2_USEDICT;\n    }\n  } else {\n    // Regular header\n    if (memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = BLOSC_MIN_HEADER_LENGTH;\n    } else {\n      context->bstarts = (int32_t *) (context->dest + BLOSC_MIN_HEADER_LENGTH);\n      context->output_bytes = BLOSC_MIN_HEADER_LENGTH +\n                              sizeof(int32_t) * context->nblocks;\n    }\n  }\n\n  // when memcpyed bit is set, there is no point in dealing with others\n  if (!memcpyed) {\n    if (context->filter_flags & BLOSC_DOSHUFFLE) {\n      /* Byte-shuffle is active */\n      context->header_flags |= BLOSC_DOSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DOBITSHUFFLE) {\n      /* Bit-shuffle is active */\n      context->header_flags |= BLOSC_DOBITSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DODELTA) {\n      /* Delta is active */\n      context->header_flags |= BLOSC_DODELTA;\n    }\n\n    dont_split = !split_block(context, context->typesize,\n                              context->blocksize, extended_header);\n    context->header_flags |= dont_split << 4;  /* dont_split is in bit 4 */\n    context->header_flags |= compformat << 5;  /* codec starts at bit 5 */\n  }\n\n  // store header flags in dest\n  context->dest[2] = context->header_flags;\n\n  return 1;\n}\n\n\nint blosc_compress_context(blosc2_context* context) {\n  int ntbytes = 0;\n  blosc_timestamp_t last, current;\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  blosc_set_timestamp(&last);\n\n  if (!memcpyed) {\n    /* Do the actual compression */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return -1;\n    }\n    if (ntbytes == 0) {\n      // Try out with a memcpy later on (last chance for fitting src buffer in dest).\n      context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n      memcpyed = true;\n    }\n  }\n\n  if (memcpyed) {\n    if (context->sourcesize + BLOSC_MAX_OVERHEAD > context->destsize) {\n      /* We are exceeding maximum output size */\n      ntbytes = 0;\n    }\n    else {\n      context->output_bytes = BLOSC_MAX_OVERHEAD;\n      ntbytes = do_job(context);\n      if (ntbytes < 0) {\n        return -1;\n      }\n      // Success!  update the memcpy bit in header\n      context->dest[2] = context->header_flags;\n      // and clear the memcpy bit in context (for next reuse)\n      context->header_flags &= ~(uint8_t)BLOSC_MEMCPYED;\n    }\n  }\n\n  /* Set the number of compressed bytes in header */\n  _sw32(context->dest + 12, ntbytes);\n\n  /* Set the number of bytes in dest buffer (might be useful for btune) */\n  context->destsize = ntbytes;\n\n  assert(ntbytes <= context->destsize);\n\n  if (context->btune != NULL) {\n    blosc_set_timestamp(&current);\n    double ctime = blosc_elapsed_secs(last, current);\n    btune_update(context, ctime);\n  }\n\n  return ntbytes;\n}\n\n\n/* The public secure routine for compression with context. */\nint blosc2_compress_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n                        void* dest, int32_t destsize) {\n  int error, cbytes;\n\n  if (context->do_compress != 1) {\n    fprintf(stderr, \"Context is not meant for compression.  Giving up.\\n\");\n    return -10;\n  }\n\n  error = initialize_context_compression(\n    context, src, srcsize, dest, destsize,\n    context->clevel, context->filters, context->filters_meta,\n    context->typesize, context->compcode, context->blocksize,\n    context->new_nthreads, context->nthreads, context->schunk);\n  if (error <= 0) {\n    return error;\n  }\n\n  /* Write the extended header */\n  error = write_compression_header(context, true);\n  if (error < 0) {\n    return error;\n  }\n\n  cbytes = blosc_compress_context(context);\n  if (cbytes < 0) {\n    return cbytes;\n  }\n\n  if (context->use_dict && context->dict_cdict == NULL) {\n\n    if (context->compcode != BLOSC_ZSTD) {\n      const char* compname;\n      compname = clibcode_to_clibname(context->compcode);\n      fprintf(stderr, \"Codec %s does not support dicts.  Giving up.\\n\",\n              compname);\n      return -20;\n    }\n\n#ifdef HAVE_ZSTD\n    // Build the dictionary out of the filters outcome and compress with it\n    int32_t dict_maxsize = BLOSC2_MAXDICTSIZE;\n    // Do not make the dict more than 5% larger than uncompressed buffer\n    if (dict_maxsize > srcsize / 20) {\n      dict_maxsize = srcsize / 20;\n    }\n    void* samples_buffer = context->dest + BLOSC_EXTENDED_HEADER_LENGTH;\n    unsigned nblocks = 8;  // the minimum that accepts zstd as of 1.4.0\n    unsigned sample_fraction = 1;  // 1 allows to use most of the chunk for training\n    size_t sample_size = context->sourcesize / nblocks / sample_fraction;\n\n    // Populate the samples sizes for training the dictionary\n    size_t* samples_sizes = malloc(nblocks * sizeof(void*));\n    for (size_t i = 0; i < nblocks; i++) {\n      samples_sizes[i] = sample_size;\n    }\n\n    // Train from samples\n    void* dict_buffer = malloc(dict_maxsize);\n    size_t dict_actual_size = ZDICT_trainFromBuffer(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks);\n\n    // TODO: experiment with parameters of low-level fast cover algorithm\n    // Note that this API is still unstable.  See: https://github.com/facebook/zstd/issues/1599\n    // ZDICT_fastCover_params_t fast_cover_params;\n    // memset(&fast_cover_params, 0, sizeof(fast_cover_params));\n    // fast_cover_params.d = nblocks;\n    // fast_cover_params.steps = 4;\n    // fast_cover_params.zParams.compressionLevel = context->clevel;\n    //size_t dict_actual_size = ZDICT_optimizeTrainFromBuffer_fastCover(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks, &fast_cover_params);\n\n    if (ZDICT_isError(dict_actual_size) != ZSTD_error_no_error) {\n      fprintf(stderr, \"Error in ZDICT_trainFromBuffer(): '%s'.\"\n              \"  Giving up.\\n\", ZDICT_getErrorName(dict_actual_size));\n      return -20;\n    }\n    assert(dict_actual_size > 0);\n    free(samples_sizes);\n\n    // Update bytes counter and pointers to bstarts for the new compressed buffer\n    context->bstarts = (int32_t*)(context->dest + BLOSC_EXTENDED_HEADER_LENGTH);\n    context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH +\n                            sizeof(int32_t) * context->nblocks;\n    /* Write the size of trained dict at the end of bstarts */\n    _sw32(context->dest + context->output_bytes, (int32_t)dict_actual_size);\n    context->output_bytes += sizeof(int32_t);\n    /* Write the trained dict afterwards */\n    context->dict_buffer = context->dest + context->output_bytes;\n    memcpy(context->dict_buffer, dict_buffer, (unsigned int)dict_actual_size);\n    context->dict_cdict = ZSTD_createCDict(dict_buffer, dict_actual_size, 1);  // TODO: use get_accel()\n    free(dict_buffer);      // the dictionary is copied in the header now\n    context->output_bytes += (int32_t)dict_actual_size;\n    context->dict_size = dict_actual_size;\n\n    /* Compress with dict */\n    cbytes = blosc_compress_context(context);\n\n    // Invalidate the dictionary for compressing other chunks using the same context\n    context->dict_buffer = NULL;\n    ZSTD_freeCDict(context->dict_cdict);\n    context->dict_cdict = NULL;\n#endif  // HAVE_ZSTD\n  }\n\n  return cbytes;\n}\n\n\nvoid build_filters(const int doshuffle, const int delta,\n                   const size_t typesize, uint8_t* filters) {\n\n  /* Fill the end part of the filter pipeline */\n  if ((doshuffle == BLOSC_SHUFFLE) && (typesize > 1))\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;\n  if (doshuffle == BLOSC_BITSHUFFLE)\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;\n  if (delta)\n    filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;\n}\n\n/* The public secure routine for compression. */\nint blosc2_compress(int clevel, int doshuffle, int32_t typesize,\n                    const void* src, int32_t srcsize, void* dest, int32_t destsize) {\n  int error;\n  int result;\n  char* envvar;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  /* Check for a BLOSC_CLEVEL environment variable */\n  envvar = getenv(\"BLOSC_CLEVEL\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value >= 0)) {\n      clevel = (int)value;\n    }\n  }\n\n  /* Check for a BLOSC_SHUFFLE environment variable */\n  envvar = getenv(\"BLOSC_SHUFFLE\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"NOSHUFFLE\") == 0) {\n      doshuffle = BLOSC_NOSHUFFLE;\n    }\n    if (strcmp(envvar, \"SHUFFLE\") == 0) {\n      doshuffle = BLOSC_SHUFFLE;\n    }\n    if (strcmp(envvar, \"BITSHUFFLE\") == 0) {\n      doshuffle = BLOSC_BITSHUFFLE;\n    }\n  }\n\n  /* Check for a BLOSC_DELTA environment variable */\n  envvar = getenv(\"BLOSC_DELTA\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"1\") == 0) {\n      blosc_set_delta(1);\n    } else {\n      blosc_set_delta(0);\n    }\n  }\n\n  /* Check for a BLOSC_TYPESIZE environment variable */\n  envvar = getenv(\"BLOSC_TYPESIZE\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value > 0)) {\n      typesize = (size_t)value;\n    }\n  }\n\n  /* Check for a BLOSC_COMPRESSOR environment variable */\n  envvar = getenv(\"BLOSC_COMPRESSOR\");\n  if (envvar != NULL) {\n    result = blosc_set_compressor(envvar);\n    if (result < 0) { return result; }\n  }\n\n  /* Check for a BLOSC_COMPRESSOR environment variable */\n  envvar = getenv(\"BLOSC_BLOCKSIZE\");\n  if (envvar != NULL) {\n    long blocksize;\n    blocksize = strtol(envvar, NULL, 10);\n    if ((blocksize != EINVAL) && (blocksize > 0)) {\n      blosc_set_blocksize((size_t)blocksize);\n    }\n  }\n\n  /* Check for a BLOSC_NTHREADS environment variable */\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    long nthreads;\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    // TODO: here is the only place that returns an extended header from\n    //   a blosc_compress() call.  This should probably be fixed.\n    const char *compname;\n    blosc2_context *cctx;\n    blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;\n\n    blosc_compcode_to_compname(g_compressor, &compname);\n    /* Create a context for compression */\n    build_filters(doshuffle, g_delta, typesize, cparams.filters);\n    // TODO: cparams can be shared in a multithreaded environment.  do a copy!\n    cparams.typesize = (uint8_t)typesize;\n    cparams.compcode = (uint8_t)g_compressor;\n    cparams.clevel = (uint8_t)clevel;\n    cparams.nthreads = (uint8_t)g_nthreads;\n    cctx = blosc2_create_cctx(cparams);\n    /* Do the actual compression */\n    result = blosc2_compress_ctx(cctx, src, srcsize, dest, destsize);\n    /* Release context resources */\n    blosc2_free_ctx(cctx);\n    return result;\n  }\n\n  pthread_mutex_lock(&global_comp_mutex);\n\n  /* Initialize a context compression */\n  uint8_t* filters = calloc(1, BLOSC2_MAX_FILTERS);\n  uint8_t* filters_meta = calloc(1, BLOSC2_MAX_FILTERS);\n  build_filters(doshuffle, g_delta, typesize, filters);\n  error = initialize_context_compression(\n    g_global_context, src, srcsize, dest, destsize, clevel, filters,\n    filters_meta, (int32_t)typesize, g_compressor, g_force_blocksize, g_nthreads, g_nthreads,\n    g_schunk);\n  free(filters);\n  free(filters_meta);\n  if (error <= 0) {\n    pthread_mutex_unlock(&global_comp_mutex);\n    return error;\n  }\n\n  /* Write chunk header without extended header (Blosc1 compatibility mode) */\n  error = write_compression_header(g_global_context, false);\n  if (error < 0) {\n    pthread_mutex_unlock(&global_comp_mutex);\n    return error;\n  }\n\n  result = blosc_compress_context(g_global_context);\n\n  pthread_mutex_unlock(&global_comp_mutex);\n\n  return result;\n}\n\n\n/* The public routine for compression. */\nint blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,\n                   const void* src, void* dest, size_t destsize) {\n  return blosc2_compress(clevel, doshuffle, (int32_t)typesize, src, (int32_t)nbytes, dest, (int32_t)destsize);\n}\n\n\nint blosc_run_decompression_with_context(blosc2_context* context, const void* src, int32_t srcsize,\n                                         void* dest, int32_t destsize) {\n  int32_t ntbytes;\n  uint8_t* _src = (uint8_t*)src;\n  uint8_t version;\n  int error;\n\n  if (srcsize <= 0) {\n    /* Invalid argument */\n    return -1;\n  }\n  version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    return -1;\n  }\n\n  error = initialize_context_decompression(context, src, srcsize, dest, destsize);\n  if (error < 0) {\n    return error;\n  }\n\n  /* Check whether this buffer is memcpy'ed */\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  if (memcpyed) {\n    // Check that sizes in header are compatible, otherwise there is a header corruption\n    ntbytes = context->sourcesize;\n    int32_t cbytes = sw32_(_src + 12);   /* compressed buffer size */\n    if (ntbytes + BLOSC_MAX_OVERHEAD != cbytes) {\n      return -1;\n    }\n    // Check that we have enough space in destination for the copy operation\n    if (destsize < ntbytes) {\n      return -1;\n    }\n    memcpy(dest, _src + BLOSC_MAX_OVERHEAD, (unsigned int)ntbytes);\n  }\n  else {\n    /* Do the actual decompression */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return -1;\n    }\n  }\n\n  assert(ntbytes <= (int32_t)destsize);\n  return ntbytes;\n}\n\n\n/* The public secure routine for decompression with context. */\nint blosc2_decompress_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n                          void* dest, int32_t destsize) {\n  int result;\n\n  if (context->do_compress != 0) {\n    fprintf(stderr, \"Context is not meant for decompression.  Giving up.\\n\");\n    return -10;\n  }\n\n  result = blosc_run_decompression_with_context(context, src, srcsize, dest, destsize);\n\n  // Reset a possible block_maskout\n  if (context->block_maskout != NULL) {\n    free(context->block_maskout);\n    context->block_maskout = NULL;\n  }\n  context->block_maskout_nitems = 0;\n\n  return result;\n}\n\n\n/* The public secure routine for decompression. */\nint blosc2_decompress(const void* src, int32_t srcsize, void* dest, int32_t destsize) {\n  int result;\n  char* envvar;\n  long nthreads;\n  blosc2_context *dctx;\n  blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  /* Check for a BLOSC_NTHREADS environment variable */\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    dparams.nthreads = g_nthreads;\n    dctx = blosc2_create_dctx(dparams);\n    result = blosc2_decompress_ctx(dctx, src, srcsize, dest, destsize);\n    blosc2_free_ctx(dctx);\n    return result;\n  }\n\n  pthread_mutex_lock(&global_comp_mutex);\n\n  result = blosc_run_decompression_with_context(\n          g_global_context, src, srcsize, dest, destsize);\n\n  pthread_mutex_unlock(&global_comp_mutex);\n\n  return result;\n}\n\n\n/* The public routine for decompression. */\nint blosc_decompress(const void* src, void* dest, size_t destsize) {\n  return blosc2_decompress(src, INT32_MAX, dest, (int32_t)destsize);\n}\n\n\n/* Specific routine optimized for decompression a small number of\n   items out of a compressed chunk.  This does not use threads because\n   it would affect negatively to performance. */\nint _blosc_getitem(blosc2_context* context, const void* src, int32_t srcsize,\n                   int start, int nitems, void* dest) {\n  uint8_t* _src = NULL;             /* current pos for source buffer */\n  uint8_t flags;                    /* flags for header */\n  int32_t ntbytes = 0;              /* the number of uncompressed bytes */\n  int32_t nblocks;                   /* number of total blocks in buffer */\n  int32_t leftover;                  /* extra bytes at end of buffer */\n  int32_t* bstarts;                /* start pointers for each block */\n  int32_t typesize, blocksize, nbytes;\n  int32_t bsize, bsize2, ebsize, leftoverblock;\n  int32_t cbytes;\n  int32_t startb, stopb;\n  int32_t stop = start + nitems;\n  int j;\n\n  if (srcsize < BLOSC_MIN_HEADER_LENGTH) {\n    /* Not enough input to parse Blosc1 header */\n    return -1;\n  }\n  _src = (uint8_t*)(src);\n\n  /* Read the header block */\n  flags = _src[2];                  /* flags */\n  bool memcpyed = flags & (uint8_t)BLOSC_MEMCPYED;\n  typesize = (int32_t)_src[3];      /* typesize */\n  nbytes = sw32_(_src + 4);         /* buffer size */\n  blocksize = sw32_(_src + 8);      /* block size */\n  cbytes = sw32_(_src + 12);    /* compressed buffer size */\n\n  ebsize = blocksize + typesize * (int32_t)sizeof(int32_t);\n\n  if ((context->header_flags & BLOSC_DOSHUFFLE) &&\n      (context->header_flags & BLOSC_DOBITSHUFFLE)) {\n    /* Extended header */\n    if (srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {\n      /* Not enough input to parse Blosc2 header */\n      return -1;\n    }\n    uint8_t* filters = _src + BLOSC_MIN_HEADER_LENGTH;\n    uint8_t* filters_meta = filters + 8;\n    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n      context->filters[i] = filters[i];\n      context->filters_meta[i] = filters_meta[i];\n    }\n    bstarts = (int32_t*)(_src + BLOSC_EXTENDED_HEADER_LENGTH);\n  } else {\n    /* Minimal header */\n    flags_to_filters(flags, context->filters);\n    bstarts = (int32_t*)(_src + BLOSC_MIN_HEADER_LENGTH);\n  }\n\n  // Some checks for malformed buffers\n  if (blocksize <= 0 || blocksize > nbytes || typesize <= 0 || typesize > BLOSC_MAX_TYPESIZE) {\n    return -1;\n  }\n\n  /* Compute some params */\n  /* Total blocks */\n  nblocks = nbytes / blocksize;\n  leftover = nbytes % blocksize;\n  nblocks = (leftover > 0) ? nblocks + 1 : nblocks;\n\n  /* Check region boundaries */\n  if ((start < 0) || (start * typesize > nbytes)) {\n    fprintf(stderr, \"`start` out of bounds\");\n    return -1;\n  }\n\n  if ((stop < 0) || (stop * typesize > nbytes)) {\n    fprintf(stderr, \"`start`+`nitems` out of bounds\");\n    return -1;\n  }\n\n  if (_src + srcsize < (uint8_t *)(bstarts + nblocks)) {\n    /* Not enough input to read all `bstarts` */\n    return -1;\n  }\n\n  for (j = 0; j < nblocks; j++) {\n    bsize = blocksize;\n    leftoverblock = 0;\n    if ((j == nblocks - 1) && (leftover > 0)) {\n      bsize = leftover;\n      leftoverblock = 1;\n    }\n\n    /* Compute start & stop for each block */\n    startb = start * (int)typesize - j * (int)blocksize;\n    stopb = stop * (int)typesize - j * (int)blocksize;\n    if ((startb >= (int)blocksize) || (stopb <= 0)) {\n      continue;\n    }\n    if (startb < 0) {\n      startb = 0;\n    }\n    if (stopb > (int)blocksize) {\n      stopb = (int)blocksize;\n    }\n    bsize2 = stopb - startb;\n\n    /* Do the actual data copy */\n    if (memcpyed) {\n      // Check that sizes in header are compatible, otherwise there is a header corruption\n      if (nbytes + BLOSC_MAX_OVERHEAD != cbytes) {\n         return -1;\n      }\n      if (srcsize < BLOSC_MAX_OVERHEAD + j * blocksize + startb + bsize2) {\n        /* Not enough input to copy data */\n        return -1;\n      }\n      memcpy((uint8_t*)dest + ntbytes,\n             (uint8_t*)src + BLOSC_MAX_OVERHEAD + j * blocksize + startb,\n             (unsigned int)bsize2);\n      cbytes = (int)bsize2;\n    }\n    else {\n      struct thread_context* scontext = context->serial_context;\n\n      /* Resize the temporaries in serial context if needed */\n      if (blocksize != scontext->tmp_blocksize) {\n        my_free(scontext->tmp);\n        scontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;\n        scontext->tmp = my_malloc(scontext->tmp_nbytes);\n        scontext->tmp2 = scontext->tmp + blocksize;\n        scontext->tmp3 = scontext->tmp + blocksize + ebsize;\n        scontext->tmp4 = scontext->tmp + 2 * blocksize + ebsize;\n        scontext->tmp_blocksize = (int32_t)blocksize;\n      }\n\n      // Regular decompression.  Put results in tmp2.\n      // If the block is aligned and the worst case fits in destination, let's avoid a copy\n      bool get_single_block = ((startb == 0) && (bsize == nitems * typesize));\n      uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;\n      cbytes = blosc_d(context->serial_context, bsize, leftoverblock,\n                       src, srcsize, sw32_(bstarts + j),\n                       tmp2, 0, scontext->tmp, scontext->tmp3);\n      if (cbytes < 0) {\n        ntbytes = cbytes;\n        break;\n      }\n      if (!get_single_block) {\n        /* Copy to destination */\n        memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);\n      }\n      cbytes = (int)bsize2;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}\n\n\n/* Specific routine optimized for decompression a small number of\n   items out of a compressed chunk.  Public non-contextual API. */\nint blosc_getitem(const void* src, int start, int nitems, void* dest) {\n  uint8_t* _src = (uint8_t*)(src);\n  blosc2_context context;\n  int result;\n\n  uint8_t version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    return -1;\n  }\n\n  /* Minimally populate the context */\n  memset(&context, 0, sizeof(blosc2_context));\n  context.src = src;\n  context.dest = dest;\n  context.typesize = (uint8_t)_src[3];\n  context.blocksize = sw32_(_src + 8);\n  context.header_flags = *(_src + 2);\n  context.filter_flags = get_filter_flags(context.header_flags, context.typesize);\n  context.schunk = g_schunk;\n  context.nthreads = 1;  // force a serial decompression; fixes #95\n  context.serial_context = create_thread_context(&context, 0);\n\n  /* Call the actual getitem function */\n  result = _blosc_getitem(&context, src, INT32_MAX, start, nitems, dest);\n\n  /* Release resources */\n  free_thread_context(context.serial_context);\n  return result;\n}\n\nint blosc2_getitem_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n    int start, int nitems, void* dest) {\n  uint8_t* _src = (uint8_t*)(src);\n  int result;\n\n  /* Minimally populate the context */\n  context->typesize = (uint8_t)_src[3];\n  context->blocksize = sw32_(_src + 8);\n  context->header_flags = *(_src + 2);\n  context->filter_flags = get_filter_flags(*(_src + 2), context->typesize);\n  if (context->serial_context == NULL) {\n    context->serial_context = create_thread_context(context, 0);\n  }\n\n  /* Call the actual getitem function */\n  result = _blosc_getitem(context, src, srcsize, start, nitems, dest);\n\n  return result;\n}\n\n/* execute single compression/decompression job for a single thread_context */\nstatic void t_blosc_do_job(void *ctxt)\n{\n  struct thread_context* thcontext = (struct thread_context*)ctxt;\n  blosc2_context* context = thcontext->parent_context;\n  int32_t cbytes;\n  int32_t ntdest;\n  int32_t tblocks;               /* number of blocks per thread */\n  int32_t tblock;                /* limit block on a thread */\n  int32_t nblock_;              /* private copy of nblock */\n  int32_t bsize;\n  int32_t leftoverblock;\n  /* Parameters for threads */\n  int32_t blocksize;\n  int32_t ebsize;\n  int32_t srcsize;\n  bool compress = context->do_compress != 0;\n  int32_t maxbytes;\n  int32_t nblocks;\n  int32_t leftover;\n  int32_t leftover2;\n  int32_t* bstarts;\n  const uint8_t* src;\n  uint8_t* dest;\n  uint8_t* tmp;\n  uint8_t* tmp2;\n  uint8_t* tmp3;\n\n  /* Get parameters for this thread before entering the main loop */\n  blocksize = context->blocksize;\n  ebsize = blocksize + context->typesize * sizeof(int32_t);\n  maxbytes = context->destsize;\n  nblocks = context->nblocks;\n  leftover = context->leftover;\n  bstarts = context->bstarts;\n  src = context->src;\n  srcsize = context->srcsize;\n  dest = context->dest;\n\n  /* Resize the temporaries if needed */\n  if (blocksize != thcontext->tmp_blocksize) {\n    my_free(thcontext->tmp);\n    thcontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;\n    thcontext->tmp = my_malloc(thcontext->tmp_nbytes);\n    thcontext->tmp2 = thcontext->tmp + blocksize;\n    thcontext->tmp3 = thcontext->tmp + blocksize + ebsize;\n    thcontext->tmp4 = thcontext->tmp + 2 * blocksize + ebsize;\n    thcontext->tmp_blocksize = blocksize;\n  }\n\n  tmp = thcontext->tmp;\n  tmp2 = thcontext->tmp2;\n  tmp3 = thcontext->tmp3;\n\n  // Determine whether we can do a static distribution of workload among different threads\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  bool static_schedule = (!compress || memcpyed) && context->block_maskout == NULL;\n  if (static_schedule) {\n      /* Blocks per thread */\n      tblocks = nblocks / context->nthreads;\n      leftover2 = nblocks % context->nthreads;\n      tblocks = (leftover2 > 0) ? tblocks + 1 : tblocks;\n      nblock_ = thcontext->tid * tblocks;\n      tblock = nblock_ + tblocks;\n      if (tblock > nblocks) {\n          tblock = nblocks;\n      }\n  }\n  else {\n    // Use dynamic schedule via a queue.  Get the next block.\n    pthread_mutex_lock(&context->count_mutex);\n    context->thread_nblock++;\n    nblock_ = context->thread_nblock;\n    pthread_mutex_unlock(&context->count_mutex);\n    tblock = nblocks;\n  }\n\n  /* Loop over blocks */\n  leftoverblock = 0;\n  while ((nblock_ < tblock) && (context->thread_giveup_code > 0)) {\n    bsize = blocksize;\n    if (nblock_ == (nblocks - 1) && (leftover > 0)) {\n      bsize = leftover;\n      leftoverblock = 1;\n    }\n    if (compress) {\n      if (memcpyed) {\n        if (!context->prefilter) {\n          /* We want to memcpy only */\n          memcpy(dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,\n                 src + nblock_ * blocksize, (unsigned int) bsize);\n          cbytes = (int32_t) bsize;\n        }\n        else {\n          /* Only the prefilter has to be executed, and this is done in blosc_c().\n           * However, no further actions are needed, so we can put the result\n           * directly in dest. */\n          cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,\n                           ebsize, src, nblock_ * blocksize,\n                           dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,\n                           tmp, tmp3);\n        }\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,\n                          ebsize, src, nblock_ * blocksize, tmp2, tmp, tmp3);\n      }\n    }\n    else {\n      if (memcpyed) {\n        /* We want to memcpy only */\n        if (srcsize < BLOSC_MAX_OVERHEAD + (nblock_ * blocksize) + bsize) {\n          /* Not enough input to copy data */\n\n          cbytes = -1;\n        } else {\n          memcpy(dest + nblock_ * blocksize,\n                  src + BLOSC_MAX_OVERHEAD + nblock_ * blocksize, (unsigned int)bsize);\n          cbytes = (int32_t)bsize;\n        }\n      }\n      else {\n        if (srcsize < (int32_t)(BLOSC_MAX_OVERHEAD + (sizeof(int32_t) * nblocks))) {\n          /* Not enough input to read all `bstarts` */\n          cbytes = -1;\n        } else {\n          cbytes = blosc_d(thcontext, bsize, leftoverblock,\n                            src, srcsize, sw32_(bstarts + nblock_),\n                            dest, nblock_ * blocksize, tmp, tmp2);\n        }\n      }\n    }\n\n    /* Check whether current thread has to giveup */\n    if (context->thread_giveup_code <= 0) {\n      break;\n    }\n\n    /* Check results for the compressed/decompressed block */\n    if (cbytes < 0) {            /* compr/decompr failure */\n      /* Set giveup_code error */\n      pthread_mutex_lock(&context->count_mutex);\n      context->thread_giveup_code = cbytes;\n      pthread_mutex_unlock(&context->count_mutex);\n      break;\n    }\n\n    if (compress && !memcpyed) {\n      /* Start critical section */\n      pthread_mutex_lock(&context->count_mutex);\n      ntdest = context->output_bytes;\n      // Note: do not use a typical local dict_training variable here\n      // because it is probably cached from previous calls if the number of\n      // threads does not change (the usual thing).\n      if (!(context->use_dict && context->dict_cdict == NULL)) {\n        _sw32(bstarts + nblock_, (int32_t) ntdest);\n      }\n\n      if ((cbytes == 0) || (ntdest + cbytes > maxbytes)) {\n        context->thread_giveup_code = 0;  /* uncompressible buf */\n        pthread_mutex_unlock(&context->count_mutex);\n        break;\n      }\n      context->thread_nblock++;\n      nblock_ = context->thread_nblock;\n      context->output_bytes += cbytes;\n      pthread_mutex_unlock(&context->count_mutex);\n      /* End of critical section */\n\n      /* Copy the compressed buffer to destination */\n      memcpy(dest + ntdest, tmp2, (unsigned int) cbytes);\n    }\n    else if (static_schedule) {\n      nblock_++;\n    }\n    else {\n      pthread_mutex_lock(&context->count_mutex);\n      context->thread_nblock++;\n      nblock_ = context->thread_nblock;\n      context->output_bytes += cbytes;\n      pthread_mutex_unlock(&context->count_mutex);\n    }\n\n  } /* closes while (nblock_) */\n\n  if (static_schedule) {\n    context->output_bytes = context->sourcesize;\n    if (compress) {\n      context->output_bytes += BLOSC_MAX_OVERHEAD;\n    }\n  }\n\n}\n\n/* Decompress & unshuffle several blocks in a single thread */\nstatic void* t_blosc(void* ctxt) {\n  struct thread_context* thcontext = (struct thread_context*)ctxt;\n  blosc2_context* context = thcontext->parent_context;\n#ifdef BLOSC_POSIX_BARRIERS\n  int rc;\n#endif\n\n  while (1) {\n    /* Synchronization point for all threads (wait for initialization) */\n    WAIT_INIT(NULL, context);\n\n    if (context->end_threads) {\n      break;\n    }\n\n    t_blosc_do_job(ctxt);\n\n    /* Meeting point for all threads (wait for finalization) */\n    WAIT_FINISH(NULL, context);\n  }\n\n  /* Cleanup our working space and context */\n  free_thread_context(thcontext);\n\n  return (NULL);\n}\n\n\nint init_threadpool(blosc2_context *context) {\n  int32_t tid;\n  int rc2;\n\n  /* Initialize mutex and condition variable objects */\n  pthread_mutex_init(&context->count_mutex, NULL);\n  pthread_mutex_init(&context->delta_mutex, NULL);\n  pthread_cond_init(&context->delta_cv, NULL);\n\n  /* Set context thread sentinels */\n  context->thread_giveup_code = 1;\n  context->thread_nblock = -1;\n\n  /* Barrier initialization */\n#ifdef BLOSC_POSIX_BARRIERS\n  pthread_barrier_init(&context->barr_init, NULL, context->nthreads + 1);\n  pthread_barrier_init(&context->barr_finish, NULL, context->nthreads + 1);\n#else\n  pthread_mutex_init(&context->count_threads_mutex, NULL);\n  pthread_cond_init(&context->count_threads_cv, NULL);\n  context->count_threads = 0;      /* Reset threads counter */\n#endif\n\n  if (threads_callback) {\n      /* Create thread contexts to store data for callback threads */\n    context->thread_contexts = (struct thread_context *)my_malloc(\n            context->nthreads * sizeof(struct thread_context));\n    for (tid = 0; tid < context->nthreads; tid++)\n      init_thread_context(context->thread_contexts + tid, context, tid);\n  }\n  else {\n    #if !defined(_WIN32)\n      /* Initialize and set thread detached attribute */\n      pthread_attr_init(&context->ct_attr);\n      pthread_attr_setdetachstate(&context->ct_attr, PTHREAD_CREATE_JOINABLE);\n    #endif\n\n    /* Make space for thread handlers */\n    context->threads = (pthread_t*)my_malloc(\n            context->nthreads * sizeof(pthread_t));\n    /* Finally, create the threads */\n    for (tid = 0; tid < context->nthreads; tid++) {\n      /* Create a thread context (will destroy when finished) */\n      struct thread_context *thread_context = create_thread_context(context, tid);\n\n      #if !defined(_WIN32)\n        rc2 = pthread_create(&context->threads[tid], &context->ct_attr, t_blosc,\n                            (void*)thread_context);\n      #else\n        rc2 = pthread_create(&context->threads[tid], NULL, t_blosc,\n                            (void *)thread_context);\n      #endif\n      if (rc2) {\n        fprintf(stderr, \"ERROR; return code from pthread_create() is %d\\n\", rc2);\n        fprintf(stderr, \"\\tError detail: %s\\n\", strerror(rc2));\n        return (-1);\n      }\n    }\n  }\n\n  /* We have now started/initialized the threads */\n  context->threads_started = context->nthreads;\n  context->new_nthreads = context->nthreads;\n\n  return (0);\n}\n\nint blosc_get_nthreads(void)\n{\n  return g_nthreads;\n}\n\nint blosc_set_nthreads(int nthreads_new) {\n  int ret = g_nthreads;          /* the previous number of threads */\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n if (nthreads_new != ret) {\n   g_nthreads = nthreads_new;\n   g_global_context->new_nthreads = nthreads_new;\n   check_nthreads(g_global_context);\n }\n\n  return ret;\n}\n\n\nconst char* blosc_get_compressor(void)\n{\n  const char* compname;\n  blosc_compcode_to_compname(g_compressor, &compname);\n\n  return compname;\n}\n\nint blosc_set_compressor(const char* compname) {\n  int code = blosc_compname_to_compcode(compname);\n\n  g_compressor = code;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  return code;\n}\n\nvoid blosc_set_delta(int dodelta) {\n\n  g_delta = dodelta;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n}\n\nconst char* blosc_list_compressors(void) {\n  static int compressors_list_done = 0;\n  static char ret[256];\n\n  if (compressors_list_done) return ret;\n  ret[0] = '\\0';\n  strcat(ret, BLOSC_BLOSCLZ_COMPNAME);\n#if defined(HAVE_LZ4)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_LZ4_COMPNAME);\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_LZ4HC_COMPNAME);\n#endif /* HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_LIZARD_COMPNAME);\n#endif /* HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_SNAPPY_COMPNAME);\n#endif /* HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_ZLIB_COMPNAME);\n#endif /* HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_ZSTD_COMPNAME);\n#endif /* HAVE_ZSTD */\n  compressors_list_done = 1;\n  return ret;\n}\n\n\nconst char* blosc_get_version_string(void) {\n  return BLOSC_VERSION_STRING;\n}\n\n\nint blosc_get_complib_info(const char* compname, char** complib, char** version) {\n  int clibcode;\n  const char* clibname;\n  const char* clibversion = \"unknown\";\n\n#if (defined(HAVE_LZ4) && defined(LZ4_VERSION_MAJOR)) || \\\n  (defined(HAVE_LIZARD) && defined(LIZARD_VERSION_MAJOR)) || \\\n  (defined(HAVE_SNAPPY) && defined(SNAPPY_VERSION)) || \\\n  (defined(HAVE_ZSTD) && defined(ZSTD_VERSION_MAJOR))\n  char sbuffer[256];\n#endif\n\n  clibcode = compname_to_clibcode(compname);\n  clibname = clibcode_to_clibname(clibcode);\n\n  /* complib version */\n  if (clibcode == BLOSC_BLOSCLZ_LIB) {\n    clibversion = BLOSCLZ_VERSION_STRING;\n  }\n#if defined(HAVE_LZ4)\n  else if (clibcode == BLOSC_LZ4_LIB) {\n#if defined(LZ4_VERSION_MAJOR)\n    sprintf(sbuffer, \"%d.%d.%d\",\n            LZ4_VERSION_MAJOR, LZ4_VERSION_MINOR, LZ4_VERSION_RELEASE);\n    clibversion = sbuffer;\n#endif /* LZ4_VERSION_MAJOR */\n  }\n#endif /* HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  else if (clibcode == BLOSC_LIZARD_LIB) {\n    sprintf(sbuffer, \"%d.%d.%d\",\n            LIZARD_VERSION_MAJOR, LIZARD_VERSION_MINOR, LIZARD_VERSION_RELEASE);\n    clibversion = sbuffer;\n  }\n#endif /* HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  else if (clibcode == BLOSC_SNAPPY_LIB) {\n#if defined(SNAPPY_VERSION)\n    sprintf(sbuffer, \"%d.%d.%d\", SNAPPY_MAJOR, SNAPPY_MINOR, SNAPPY_PATCHLEVEL);\n    clibversion = sbuffer;\n#endif /* SNAPPY_VERSION */\n  }\n#endif /* HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  else if (clibcode == BLOSC_ZLIB_LIB) {\n    clibversion = ZLIB_VERSION;\n  }\n#endif /* HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  else if (clibcode == BLOSC_ZSTD_LIB) {\n    sprintf(sbuffer, \"%d.%d.%d\",\n            ZSTD_VERSION_MAJOR, ZSTD_VERSION_MINOR, ZSTD_VERSION_RELEASE);\n    clibversion = sbuffer;\n  }\n#endif /* HAVE_ZSTD */\n\n#ifdef _MSC_VER\n  *complib = _strdup(clibname);\n  *version = _strdup(clibversion);\n#else\n  *complib = strdup(clibname);\n  *version = strdup(clibversion);\n#endif\n  return clibcode;\n}\n\n/* Return `nbytes`, `cbytes` and `blocksize` from a compressed buffer. */\nvoid blosc_cbuffer_sizes(const void* cbuffer, size_t* nbytes,\n                         size_t* cbytes, size_t* blocksize) {\n  uint8_t* _src = (uint8_t*)(cbuffer);    /* current pos for source buffer */\n  uint8_t version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    *nbytes = *blocksize = *cbytes = 0;\n    return;\n  }\n\n  /* Read the interesting values */\n  *nbytes = (size_t)sw32_(_src + 4);       /* uncompressed buffer size */\n  *blocksize = (size_t)sw32_(_src + 8);    /* block size */\n  *cbytes = (size_t)sw32_(_src + 12);      /* compressed buffer size */\n}\n\nint blosc_cbuffer_validate(const void* cbuffer, size_t cbytes, size_t* nbytes) {\n  size_t header_cbytes, header_blocksize;\n  if (cbytes < BLOSC_MIN_HEADER_LENGTH) {\n    /* Compressed data should contain enough space for header */\n    *nbytes = 0;\n    return -1;\n  }\n  blosc_cbuffer_sizes(cbuffer, nbytes, &header_cbytes, &header_blocksize);\n  if (header_cbytes != cbytes) {\n    /* Compressed size from header does not match `cbytes` */\n    *nbytes = 0;\n    return -1;\n  }\n  if (*nbytes > BLOSC_MAX_BUFFERSIZE) {\n    /* Uncompressed size is larger than allowed */\n    return -1;\n  }\n  return 0;\n}\n\n/* Return `typesize` and `flags` from a compressed buffer. */\nvoid blosc_cbuffer_metainfo(const void* cbuffer, size_t* typesize, int* flags) {\n  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */\n  uint8_t version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    *flags = 0;\n    *typesize = 0;\n    return;\n  }\n\n  /* Read the interesting values */\n  *flags = (int)_src[2];                 /* flags */\n  *typesize = (size_t)_src[3];           /* typesize */\n}\n\n\n/* Return version information from a compressed buffer. */\nvoid blosc_cbuffer_versions(const void* cbuffer, int* version,\n                            int* versionlz) {\n  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */\n\n  /* Read the version info */\n  *version = (int)_src[0];         /* blosc format version */\n  *versionlz = (int)_src[1];       /* Lempel-Ziv compressor format version */\n}\n\n\n/* Return the compressor library/format used in a compressed buffer. */\nconst char* blosc_cbuffer_complib(const void* cbuffer) {\n  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */\n  int clibcode;\n  const char* complib;\n\n  /* Read the compressor format/library info */\n  clibcode = (_src[2] & 0xe0) >> 5;\n  complib = clibcode_to_clibname(clibcode);\n  return complib;\n}\n\n\n/* Get the internal blocksize to be used during compression.  0 means\n   that an automatic blocksize is computed internally. */\nint blosc_get_blocksize(void)\n{\n  return (int)g_force_blocksize;\n}\n\n\n/* Force the use of a specific blocksize.  If 0, an automatic\n   blocksize will be used (the default). */\nvoid blosc_set_blocksize(size_t size) {\n  g_force_blocksize = (int32_t)size;\n}\n\n\n/* Set pointer to super-chunk.  If NULL, no super-chunk will be\n   reachable (the default). */\nvoid blosc_set_schunk(blosc2_schunk* schunk) {\n  g_schunk = schunk;\n  g_global_context->schunk = schunk;\n}\n\n\nvoid blosc_init(void) {\n  /* Return if Blosc is already initialized */\n  if (g_initlib) return;\n\n  pthread_mutex_init(&global_comp_mutex, NULL);\n  /* Create a global context */\n  g_global_context = (blosc2_context*)my_malloc(sizeof(blosc2_context));\n  memset(g_global_context, 0, sizeof(blosc2_context));\n  g_global_context->nthreads = g_nthreads;\n  g_global_context->new_nthreads = g_nthreads;\n  g_initlib = 1;\n}\n\n\nvoid blosc_destroy(void) {\n  /* Return if Blosc is not initialized */\n  if (!g_initlib) return;\n\n  g_initlib = 0;\n  release_threadpool(g_global_context);\n  if (g_global_context->serial_context != NULL) {\n    free_thread_context(g_global_context->serial_context);\n  }\n  my_free(g_global_context);\n  pthread_mutex_destroy(&global_comp_mutex);\n}\n\n\nint release_threadpool(blosc2_context *context) {\n  int32_t t;\n  void* status;\n  int rc;\n\n  if (context->threads_started > 0) {\n    if (threads_callback) {\n      /* free context data for user-managed threads */\n      for (t=0; t<context->threads_started; t++)\n        destroy_thread_context(context->thread_contexts + t);\n      my_free(context->thread_contexts);\n    }\n    else {\n      /* Tell all existing threads to finish */\n      context->end_threads = 1;\n      WAIT_INIT(-1, context);\n\n      /* Join exiting threads */\n      for (t = 0; t < context->threads_started; t++) {\n        rc = pthread_join(context->threads[t], &status);\n        if (rc) {\n          fprintf(stderr, \"ERROR; return code from pthread_join() is %d\\n\", rc);\n          fprintf(stderr, \"\\tError detail: %s\\n\", strerror(rc));\n        }\n      }\n\n      /* Thread attributes */\n      #if !defined(_WIN32)\n        pthread_attr_destroy(&context->ct_attr);\n      #endif\n\n      /* Release thread handlers */\n      my_free(context->threads);\n    }\n\n    /* Release mutex and condition variable objects */\n    pthread_mutex_destroy(&context->count_mutex);\n    pthread_mutex_destroy(&context->delta_mutex);\n    pthread_cond_destroy(&context->delta_cv);\n\n    /* Barriers */\n  #ifdef BLOSC_POSIX_BARRIERS\n    pthread_barrier_destroy(&context->barr_init);\n    pthread_barrier_destroy(&context->barr_finish);\n  #else\n    pthread_mutex_destroy(&context->count_threads_mutex);\n    pthread_cond_destroy(&context->count_threads_cv);\n    context->count_threads = 0;      /* Reset threads counter */\n  #endif\n\n    /* Reset flags and counters */\n    context->end_threads = 0;\n    context->threads_started = 0;\n  }\n\n\n  return 0;\n}\n\nint blosc_free_resources(void) {\n  /* Return if Blosc is not initialized */\n  if (!g_initlib) return -1;\n\n  return release_threadpool(g_global_context);\n}\n\n\n/* Contexts */\n\n/* Create a context for compression */\nblosc2_context* blosc2_create_cctx(blosc2_cparams cparams) {\n  blosc2_context* context = (blosc2_context*)my_malloc(sizeof(blosc2_context));\n\n  /* Populate the context, using zeros as default values */\n  memset(context, 0, sizeof(blosc2_context));\n  context->do_compress = 1;   /* meant for compression */\n  context->compcode = cparams.compcode;\n  context->clevel = cparams.clevel;\n  context->use_dict = cparams.use_dict;\n  context->typesize = cparams.typesize;\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    context->filters[i] = cparams.filters[i];\n    context->filters_meta[i] = cparams.filters_meta[i];\n  }\n  context->nthreads = cparams.nthreads;\n  context->new_nthreads = context->nthreads;\n  context->blocksize = cparams.blocksize;\n  context->threads_started = 0;\n  context->schunk = cparams.schunk;\n\n  if (cparams.prefilter != NULL) {\n    context->prefilter = cparams.prefilter;\n    context->pparams = (blosc2_prefilter_params*)my_malloc(sizeof(blosc2_prefilter_params));\n    memcpy(context->pparams, cparams.pparams, sizeof(blosc2_prefilter_params));\n  }\n\n  return context;\n}\n\n\n/* Create a context for decompression */\nblosc2_context* blosc2_create_dctx(blosc2_dparams dparams) {\n  blosc2_context* context = (blosc2_context*)my_malloc(sizeof(blosc2_context));\n\n  /* Populate the context, using zeros as default values */\n  memset(context, 0, sizeof(blosc2_context));\n  context->do_compress = 0;   /* Meant for decompression */\n  context->nthreads = dparams.nthreads;\n  context->new_nthreads = context->nthreads;\n  context->threads_started = 0;\n  context->block_maskout = NULL;\n  context->block_maskout_nitems = 0;\n  context->schunk = dparams.schunk;\n\n  return context;\n}\n\n\nvoid blosc2_free_ctx(blosc2_context* context) {\n  release_threadpool(context);\n  if (context->serial_context != NULL) {\n    free_thread_context(context->serial_context);\n  }\n  if (context->dict_cdict != NULL) {\n#ifdef HAVE_ZSTD\n    ZSTD_freeCDict(context->dict_cdict);\n#endif\n  }\n  if (context->dict_ddict != NULL) {\n#ifdef HAVE_ZSTD\n    ZSTD_freeDDict(context->dict_ddict);\n#endif\n  }\n  if (context->btune != NULL) {\n    btune_free(context);\n  }\n  if (context->prefilter != NULL) {\n    my_free(context->pparams);\n  }\n\n  if (context->block_maskout != NULL) {\n    free(context->block_maskout);\n  }\n\n  my_free(context);\n}\n\n\n/* Set a maskout in decompression context */\nint blosc2_set_maskout(blosc2_context *ctx, bool *maskout, int nblocks) {\n\n  if (ctx->block_maskout != NULL) {\n    // Get rid of a possible mask here\n    free(ctx->block_maskout);\n  }\n\n  bool *maskout_ = malloc(nblocks);\n  memcpy(maskout_, maskout, nblocks);\n  ctx->block_maskout = maskout_;\n  ctx->block_maskout_nitems = nblocks;\n\n  return 0;\n}\n"], "fixing_code": ["/*********************************************************************\n  Blosc - Blocked Shuffling and Compression Library\n\n  Author: Francesc Alted <francesc@blosc.org>\n  Creation date: 2009-05-20\n\n  See LICENSE.txt for details about copyright and rights to use.\n**********************************************************************/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <assert.h>\n\n#include \"blosc2.h\"\n#include \"blosc-private.h\"\n#include \"blosc2-common.h\"\n\n#if defined(USING_CMAKE)\n  #include \"config.h\"\n#endif /*  USING_CMAKE */\n#include \"context.h\"\n\n#include \"shuffle.h\"\n#include \"delta.h\"\n#include \"trunc-prec.h\"\n#include \"blosclz.h\"\n#include \"btune.h\"\n\n#if defined(HAVE_LZ4)\n  #include \"lz4.h\"\n  #include \"lz4hc.h\"\n  #ifdef HAVE_IPP\n    #include <ipps.h>\n    #include <ippdc.h>\n  #endif\n#endif /*  HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  #include \"lizard_compress.h\"\n  #include \"lizard_decompress.h\"\n#endif /*  HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  #include \"snappy-c.h\"\n#endif /*  HAVE_SNAPPY */\n#if defined(HAVE_MINIZ)\n  #include \"miniz.c\"\n#elif defined(HAVE_ZLIB)\n  #include \"zlib.h\"\n#endif /*  HAVE_MINIZ */\n#if defined(HAVE_ZSTD)\n  #include \"zstd.h\"\n  #include \"zstd_errors.h\"\n  // #include \"cover.h\"  // for experimenting with fast cover training for building dicts\n  #include \"zdict.h\"\n#endif /*  HAVE_ZSTD */\n\n\n#if defined(_WIN32) && !defined(__MINGW32__)\n  #include <windows.h>\n  #include <malloc.h>\n\n/* stdint.h only available in VS2010 (VC++ 16.0) and newer */\n  #if defined(_MSC_VER) && _MSC_VER < 1600\n    #include \"win32/stdint-windows.h\"\n  #else\n    #include <stdint.h>\n  #endif\n\n  #include <process.h>\n  #define getpid _getpid\n#else\n  #include <unistd.h>\n#endif  /* _WIN32 */\n\n#if defined(_WIN32) && !defined(__GNUC__)\n  #include \"win32/pthread.c\"\n#endif\n\n/* Synchronization variables */\n\n/* Global context for non-contextual API */\nstatic blosc2_context* g_global_context;\nstatic pthread_mutex_t global_comp_mutex;\nstatic int g_compressor = BLOSC_BLOSCLZ;\nstatic int g_delta = 0;\n/* the compressor to use by default */\nstatic int g_nthreads = 1;\nstatic int32_t g_force_blocksize = 0;\nstatic int g_initlib = 0;\nstatic blosc2_schunk* g_schunk = NULL;   /* the pointer to super-chunk */\n\n\n// Forward declarations\n\nint init_threadpool(blosc2_context *context);\nint release_threadpool(blosc2_context *context);\n\n/* Macros for synchronization */\n\n/* Wait until all threads are initialized */\n#ifdef BLOSC_POSIX_BARRIERS\n#define WAIT_INIT(RET_VAL, CONTEXT_PTR)  \\\n  rc = pthread_barrier_wait(&(CONTEXT_PTR)->barr_init); \\\n  if (rc != 0 && rc != PTHREAD_BARRIER_SERIAL_THREAD) { \\\n    printf(\"Could not wait on barrier (init): %d\\n\", rc); \\\n    return((RET_VAL));                            \\\n  }\n#else\n#define WAIT_INIT(RET_VAL, CONTEXT_PTR)   \\\n  pthread_mutex_lock(&(CONTEXT_PTR)->count_threads_mutex); \\\n  if ((CONTEXT_PTR)->count_threads < (CONTEXT_PTR)->nthreads) { \\\n    (CONTEXT_PTR)->count_threads++;  \\\n    pthread_cond_wait(&(CONTEXT_PTR)->count_threads_cv, \\\n                      &(CONTEXT_PTR)->count_threads_mutex); \\\n  } \\\n  else { \\\n    pthread_cond_broadcast(&(CONTEXT_PTR)->count_threads_cv); \\\n  } \\\n  pthread_mutex_unlock(&(CONTEXT_PTR)->count_threads_mutex);\n#endif\n\n/* Wait for all threads to finish */\n#ifdef BLOSC_POSIX_BARRIERS\n#define WAIT_FINISH(RET_VAL, CONTEXT_PTR)   \\\n  rc = pthread_barrier_wait(&(CONTEXT_PTR)->barr_finish); \\\n  if (rc != 0 && rc != PTHREAD_BARRIER_SERIAL_THREAD) { \\\n    printf(\"Could not wait on barrier (finish)\\n\"); \\\n    return((RET_VAL));                              \\\n  }\n#else\n#define WAIT_FINISH(RET_VAL, CONTEXT_PTR)                           \\\n  pthread_mutex_lock(&(CONTEXT_PTR)->count_threads_mutex); \\\n  if ((CONTEXT_PTR)->count_threads > 0) { \\\n    (CONTEXT_PTR)->count_threads--; \\\n    pthread_cond_wait(&(CONTEXT_PTR)->count_threads_cv, \\\n                      &(CONTEXT_PTR)->count_threads_mutex); \\\n  } \\\n  else { \\\n    pthread_cond_broadcast(&(CONTEXT_PTR)->count_threads_cv); \\\n  } \\\n  pthread_mutex_unlock(&(CONTEXT_PTR)->count_threads_mutex);\n#endif\n\n\n/* global variable to change threading backend from Blosc-managed to caller-managed */\nstatic blosc_threads_callback threads_callback = 0;\nstatic void *threads_callback_data = 0;\n\n/* non-threadsafe function should be called before any other Blosc function in\n   order to change how threads are managed */\nvoid blosc_set_threads_callback(blosc_threads_callback callback, void *callback_data)\n{\n  threads_callback = callback;\n  threads_callback_data = callback_data;\n}\n\n\n/* A function for aligned malloc that is portable */\nstatic uint8_t* my_malloc(size_t size) {\n  void* block = NULL;\n  int res = 0;\n\n/* Do an alignment to 32 bytes because AVX2 is supported */\n#if defined(_WIN32)\n  /* A (void *) cast needed for avoiding a warning with MINGW :-/ */\n  block = (void *)_aligned_malloc(size, 32);\n#elif _POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600\n  /* Platform does have an implementation of posix_memalign */\n  res = posix_memalign(&block, 32, size);\n#else\n  block = malloc(size);\n#endif  /* _WIN32 */\n\n  if (block == NULL || res != 0) {\n    printf(\"Error allocating memory!\");\n    return NULL;\n  }\n\n  return (uint8_t*)block;\n}\n\n\n/* Release memory booked by my_malloc */\nstatic void my_free(void* block) {\n#if defined(_WIN32)\n  _aligned_free(block);\n#else\n  free(block);\n#endif  /* _WIN32 */\n}\n\n\n/*\n * Conversion routines between compressor and compression libraries\n */\n\n/* Return the library code associated with the compressor name */\nstatic int compname_to_clibcode(const char* compname) {\n  if (strcmp(compname, BLOSC_BLOSCLZ_COMPNAME) == 0)\n    return BLOSC_BLOSCLZ_LIB;\n  if (strcmp(compname, BLOSC_LZ4_COMPNAME) == 0)\n    return BLOSC_LZ4_LIB;\n  if (strcmp(compname, BLOSC_LZ4HC_COMPNAME) == 0)\n    return BLOSC_LZ4_LIB;\n  if (strcmp(compname, BLOSC_LIZARD_COMPNAME) == 0)\n    return BLOSC_LIZARD_LIB;\n  if (strcmp(compname, BLOSC_SNAPPY_COMPNAME) == 0)\n    return BLOSC_SNAPPY_LIB;\n  if (strcmp(compname, BLOSC_ZLIB_COMPNAME) == 0)\n    return BLOSC_ZLIB_LIB;\n  if (strcmp(compname, BLOSC_ZSTD_COMPNAME) == 0)\n    return BLOSC_ZSTD_LIB;\n  return -1;\n}\n\n/* Return the library name associated with the compressor code */\nstatic const char* clibcode_to_clibname(int clibcode) {\n  if (clibcode == BLOSC_BLOSCLZ_LIB) return BLOSC_BLOSCLZ_LIBNAME;\n  if (clibcode == BLOSC_LZ4_LIB) return BLOSC_LZ4_LIBNAME;\n  if (clibcode == BLOSC_LIZARD_LIB) return BLOSC_LIZARD_LIBNAME;\n  if (clibcode == BLOSC_SNAPPY_LIB) return BLOSC_SNAPPY_LIBNAME;\n  if (clibcode == BLOSC_ZLIB_LIB) return BLOSC_ZLIB_LIBNAME;\n  if (clibcode == BLOSC_ZSTD_LIB) return BLOSC_ZSTD_LIBNAME;\n  return NULL;                  /* should never happen */\n}\n\n\n/*\n * Conversion routines between compressor names and compressor codes\n */\n\n/* Get the compressor name associated with the compressor code */\nint blosc_compcode_to_compname(int compcode, const char** compname) {\n  int code = -1;    /* -1 means non-existent compressor code */\n  const char* name = NULL;\n\n  /* Map the compressor code */\n  if (compcode == BLOSC_BLOSCLZ)\n    name = BLOSC_BLOSCLZ_COMPNAME;\n  else if (compcode == BLOSC_LZ4)\n    name = BLOSC_LZ4_COMPNAME;\n  else if (compcode == BLOSC_LZ4HC)\n    name = BLOSC_LZ4HC_COMPNAME;\n  else if (compcode == BLOSC_LIZARD)\n    name = BLOSC_LIZARD_COMPNAME;\n  else if (compcode == BLOSC_SNAPPY)\n    name = BLOSC_SNAPPY_COMPNAME;\n  else if (compcode == BLOSC_ZLIB)\n    name = BLOSC_ZLIB_COMPNAME;\n  else if (compcode == BLOSC_ZSTD)\n    name = BLOSC_ZSTD_COMPNAME;\n\n  *compname = name;\n\n  /* Guess if there is support for this code */\n  if (compcode == BLOSC_BLOSCLZ)\n    code = BLOSC_BLOSCLZ;\n#if defined(HAVE_LZ4)\n  else if (compcode == BLOSC_LZ4)\n    code = BLOSC_LZ4;\n  else if (compcode == BLOSC_LZ4HC)\n    code = BLOSC_LZ4HC;\n#endif /* HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  else if (compcode == BLOSC_LIZARD)\n    code = BLOSC_LIZARD;\n#endif /* HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  else if (compcode == BLOSC_SNAPPY)\n    code = BLOSC_SNAPPY;\n#endif /* HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  else if (compcode == BLOSC_ZLIB)\n    code = BLOSC_ZLIB;\n#endif /* HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  else if (compcode == BLOSC_ZSTD)\n    code = BLOSC_ZSTD;\n#endif /* HAVE_ZSTD */\n\n  return code;\n}\n\n\n/* Get the compressor code for the compressor name. -1 if it is not available */\nint blosc_compname_to_compcode(const char* compname) {\n  int code = -1;  /* -1 means non-existent compressor code */\n\n  if (strcmp(compname, BLOSC_BLOSCLZ_COMPNAME) == 0) {\n    code = BLOSC_BLOSCLZ;\n  }\n#if defined(HAVE_LZ4)\n  else if (strcmp(compname, BLOSC_LZ4_COMPNAME) == 0) {\n    code = BLOSC_LZ4;\n  }\n  else if (strcmp(compname, BLOSC_LZ4HC_COMPNAME) == 0) {\n    code = BLOSC_LZ4HC;\n  }\n#endif /*  HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  else if (strcmp(compname, BLOSC_LIZARD_COMPNAME) == 0) {\n    code = BLOSC_LIZARD;\n  }\n#endif /*  HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  else if (strcmp(compname, BLOSC_SNAPPY_COMPNAME) == 0) {\n    code = BLOSC_SNAPPY;\n  }\n#endif /*  HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  else if (strcmp(compname, BLOSC_ZLIB_COMPNAME) == 0) {\n    code = BLOSC_ZLIB;\n  }\n#endif /*  HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  else if (strcmp(compname, BLOSC_ZSTD_COMPNAME) == 0) {\n    code = BLOSC_ZSTD;\n  }\n#endif /*  HAVE_ZSTD */\n\n  return code;\n}\n\n\n#if defined(HAVE_LZ4)\nstatic int lz4_wrap_compress(const char* input, size_t input_length,\n                             char* output, size_t maxout, int accel, void* hash_table) {\n  BLOSC_UNUSED_PARAM(accel);\n  int cbytes;\n#ifdef HAVE_IPP\n  if (hash_table == NULL) {\n    return -1;  // the hash table should always be initialized\n  }\n  int outlen = (int)maxout;\n  int inlen = (int)input_length;\n  // I have not found any function that uses `accel` like in `LZ4_compress_fast`, but\n  // the IPP LZ4Safe call does a pretty good job on compressing well, so let's use it\n  IppStatus status = ippsEncodeLZ4Safe_8u((const Ipp8u*)input, &inlen,\n                                           (Ipp8u*)output, &outlen, (Ipp8u*)hash_table);\n  if (status == ippStsDstSizeLessExpected) {\n    return 0;  // we cannot compress in required outlen\n  }\n  else if (status != ippStsNoErr) {\n    return -1;  // an unexpected error happened\n  }\n  cbytes = outlen;\n#else\n  BLOSC_UNUSED_PARAM(hash_table);\n  accel = 1;  // deactivate acceleration to match IPP behaviour\n  cbytes = LZ4_compress_fast(input, output, (int)input_length, (int)maxout, accel);\n#endif\n  return cbytes;\n}\n\n\nstatic int lz4hc_wrap_compress(const char* input, size_t input_length,\n                               char* output, size_t maxout, int clevel) {\n  int cbytes;\n  if (input_length > (size_t)(UINT32_C(2) << 30))\n    return -1;   /* input larger than 2 GB is not supported */\n  /* clevel for lz4hc goes up to 12, at least in LZ4 1.7.5\n   * but levels larger than 9 do not buy much compression. */\n  cbytes = LZ4_compress_HC(input, output, (int)input_length, (int)maxout,\n                           clevel);\n  return cbytes;\n}\n\n\nstatic int lz4_wrap_decompress(const char* input, size_t compressed_length,\n                               char* output, size_t maxout) {\n  int nbytes;\n#ifdef HAVE_IPP\n  int outlen = (int)maxout;\n  int inlen = (int)compressed_length;\n  IppStatus status;\n  status = ippsDecodeLZ4_8u((const Ipp8u*)input, inlen, (Ipp8u*)output, &outlen);\n  //status = ippsDecodeLZ4Dict_8u((const Ipp8u*)input, &inlen, (Ipp8u*)output, 0, &outlen, NULL, 1 << 16);\n  nbytes = (status == ippStsNoErr) ? outlen : -outlen;\n#else\n  nbytes = LZ4_decompress_safe(input, output, (int)compressed_length, (int)maxout);\n#endif\n  if (nbytes != (int)maxout) {\n    return 0;\n  }\n  return (int)maxout;\n}\n#endif /* HAVE_LZ4 */\n\n\n#if defined(HAVE_LIZARD)\nstatic int lizard_wrap_compress(const char* input, size_t input_length,\n                                char* output, size_t maxout, int clevel) {\n  int cbytes;\n  cbytes = Lizard_compress(input, output, (int)input_length, (int)maxout,\n                           clevel);\n  return cbytes;\n}\n\nstatic int lizard_wrap_decompress(const char* input, size_t compressed_length,\n                                  char* output, size_t maxout) {\n  int dbytes;\n  dbytes = Lizard_decompress_safe(input, output, (int)compressed_length,\n                                  (int)maxout);\n  if (dbytes < 0) {\n    return 0;\n  }\n  return dbytes;\n}\n\n#endif /* HAVE_LIZARD */\n\n#if defined(HAVE_SNAPPY)\nstatic int snappy_wrap_compress(const char* input, size_t input_length,\n                                char* output, size_t maxout) {\n  snappy_status status;\n  size_t cl = maxout;\n  status = snappy_compress(input, input_length, output, &cl);\n  if (status != SNAPPY_OK) {\n    return 0;\n  }\n  return (int)cl;\n}\n\nstatic int snappy_wrap_decompress(const char* input, size_t compressed_length,\n                                  char* output, size_t maxout) {\n  snappy_status status;\n  size_t ul = maxout;\n  status = snappy_uncompress(input, compressed_length, output, &ul);\n  if (status != SNAPPY_OK) {\n    return 0;\n  }\n  return (int)ul;\n}\n#endif /* HAVE_SNAPPY */\n\n\n#if defined(HAVE_ZLIB)\n/* zlib is not very respectful with sharing name space with others.\n Fortunately, its names do not collide with those already in blosc. */\nstatic int zlib_wrap_compress(const char* input, size_t input_length,\n                              char* output, size_t maxout, int clevel) {\n  int status;\n  uLongf cl = (uLongf)maxout;\n  status = compress2(\n      (Bytef*)output, &cl, (Bytef*)input, (uLong)input_length, clevel);\n  if (status != Z_OK) {\n    return 0;\n  }\n  return (int)cl;\n}\n\nstatic int zlib_wrap_decompress(const char* input, size_t compressed_length,\n                                char* output, size_t maxout) {\n  int status;\n  uLongf ul = (uLongf)maxout;\n  status = uncompress(\n      (Bytef*)output, &ul, (Bytef*)input, (uLong)compressed_length);\n  if (status != Z_OK) {\n    return 0;\n  }\n  return (int)ul;\n}\n#endif /*  HAVE_ZLIB */\n\n\n#if defined(HAVE_ZSTD)\nstatic int zstd_wrap_compress(struct thread_context* thread_context,\n                              const char* input, size_t input_length,\n                              char* output, size_t maxout, int clevel) {\n  size_t code;\n  blosc2_context* context = thread_context->parent_context;\n\n  clevel = (clevel < 9) ? clevel * 2 - 1 : ZSTD_maxCLevel();\n  /* Make the level 8 close enough to maxCLevel */\n  if (clevel == 8) clevel = ZSTD_maxCLevel() - 2;\n\n  if (thread_context->zstd_cctx == NULL) {\n    thread_context->zstd_cctx = ZSTD_createCCtx();\n  }\n\n  if (context->use_dict) {\n    assert(context->dict_cdict != NULL);\n    code = ZSTD_compress_usingCDict(\n            thread_context->zstd_cctx, (void*)output, maxout, (void*)input,\n            input_length, context->dict_cdict);\n  } else {\n    code = ZSTD_compressCCtx(thread_context->zstd_cctx,\n        (void*)output, maxout, (void*)input, input_length, clevel);\n  }\n  if (ZSTD_isError(code) != ZSTD_error_no_error) {\n    // Do not print anything because blosc will just memcpy this buffer\n    // fprintf(stderr, \"Error in ZSTD compression: '%s'.  Giving up.\\n\",\n    //         ZDICT_getErrorName(code));\n    return 0;\n  }\n  return (int)code;\n}\n\nstatic int zstd_wrap_decompress(struct thread_context* thread_context,\n                                const char* input, size_t compressed_length,\n                                char* output, size_t maxout) {\n  size_t code;\n  blosc2_context* context = thread_context->parent_context;\n\n  if (thread_context->zstd_dctx == NULL) {\n    thread_context->zstd_dctx = ZSTD_createDCtx();\n  }\n\n  if (context->use_dict) {\n    assert(context->dict_ddict != NULL);\n    code = ZSTD_decompress_usingDDict(\n            thread_context->zstd_dctx, (void*)output, maxout, (void*)input,\n            compressed_length, context->dict_ddict);\n  } else {\n    code = ZSTD_decompressDCtx(thread_context->zstd_dctx,\n        (void*)output, maxout, (void*)input, compressed_length);\n  }\n  if (ZSTD_isError(code) != ZSTD_error_no_error) {\n    fprintf(stderr, \"Error in ZSTD decompression: '%s'.  Giving up.\\n\",\n            ZDICT_getErrorName(code));\n    return 0;\n  }\n  return (int)code;\n}\n#endif /*  HAVE_ZSTD */\n\n/* Compute acceleration for blosclz */\nstatic int get_accel(const blosc2_context* context) {\n  int clevel = context->clevel;\n\n  if (context->compcode == BLOSC_LZ4) {\n    /* This acceleration setting based on discussions held in:\n     * https://groups.google.com/forum/#!topic/lz4c/zosy90P8MQw\n     */\n    return (10 - clevel);\n  }\n  else if (context->compcode == BLOSC_LIZARD) {\n    /* Lizard currently accepts clevels from 10 to 49 */\n      switch (clevel) {\n        case 1 :\n            return 10;\n        case 2 :\n            return 10;\n        case 3 :\n            return 10;\n        case 4 :\n            return 10;\n        case 5 :\n            return 20;\n        case 6 :\n            return 20;\n        case 7 :\n            return 20;\n        case 8 :\n            return 41;\n        case 9 :\n            return 41;\n        default :\n          break;\n      }\n  }\n  return 1;\n}\n\n\nint do_nothing(int8_t filter, char cmode) {\n  if (cmode == 'c') {\n    return (filter == BLOSC_NOFILTER);\n  } else {\n    // TRUNC_PREC do not have to be applied during decompression\n    return ((filter == BLOSC_NOFILTER) || (filter == BLOSC_TRUNC_PREC));\n  }\n}\n\n\nint next_filter(const uint8_t* filters, int current_filter, char cmode) {\n  for (int i = current_filter - 1; i >= 0; i--) {\n    if (!do_nothing(filters[i], cmode)) {\n      return filters[i];\n    }\n  }\n  return BLOSC_NOFILTER;\n}\n\n\nint last_filter(const uint8_t* filters, char cmode) {\n  int last_index = -1;\n  for (int i = BLOSC2_MAX_FILTERS - 1; i >= 0; i--) {\n    if (!do_nothing(filters[i], cmode))  {\n      last_index = i;\n    }\n  }\n  return last_index;\n}\n\n\nuint8_t* pipeline_c(struct thread_context* thread_context, const int32_t bsize,\n                    const uint8_t* src, const int32_t offset,\n                    uint8_t* dest, uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  uint8_t* _src = (uint8_t*)src + offset;\n  uint8_t* _tmp = tmp;\n  uint8_t* _dest = dest;\n  int32_t typesize = context->typesize;\n  uint8_t* filters = context->filters;\n  uint8_t* filters_meta = context->filters_meta;\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  /* Prefilter function */\n  if (context->prefilter != NULL) {\n    // Create new prefilter parameters for this block (must be private for each thread)\n    blosc2_prefilter_params pparams;\n    memcpy(&pparams, context->pparams, sizeof(pparams));\n    pparams.out = _dest;\n    pparams.out_size = (size_t)bsize;\n    pparams.out_typesize = typesize;\n    pparams.out_offset = offset;\n    pparams.tid = thread_context->tid;\n    pparams.ttmp = thread_context->tmp;\n    pparams.ttmp_nbytes = thread_context->tmp_nbytes;\n    pparams.ctx = context;\n\n    if (context->prefilter(&pparams) != 0) {\n      fprintf(stderr, \"Execution of prefilter function failed\\n\");\n      return NULL;\n    }\n\n    if (memcpyed) {\n      // No more filters are required\n      return _dest;\n    }\n    // Cycle buffers\n    _src = _dest;\n    _dest = _tmp;\n    _tmp = _src;\n  }\n\n  /* Process the filter pipeline */\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    switch (filters[i]) {\n      case BLOSC_SHUFFLE:\n        for (int j = 0; j <= filters_meta[i]; j++) {\n          shuffle(typesize, bsize, _src, _dest);\n          // Cycle filters when required\n          if (j < filters_meta[i]) {\n            _src = _dest;\n            _dest = _tmp;\n            _tmp = _src;\n          }\n        }\n        break;\n      case BLOSC_BITSHUFFLE:\n        bitshuffle(typesize, bsize, _src, _dest, tmp2);\n        break;\n      case BLOSC_DELTA:\n        delta_encoder(src, offset, bsize, typesize, _src, _dest);\n        break;\n      case BLOSC_TRUNC_PREC:\n        truncate_precision(filters_meta[i], typesize, bsize, _src, _dest);\n        break;\n      default:\n        if (filters[i] != BLOSC_NOFILTER) {\n          fprintf(stderr, \"Filter %d not handled during compression\\n\", filters[i]);\n          return NULL;\n        }\n    }\n    // Cycle buffers when required\n    if (filters[i] != BLOSC_NOFILTER) {\n      _src = _dest;\n      _dest = _tmp;\n      _tmp = _src;\n    }\n  }\n  return _src;\n}\n\n\n// Optimized version for detecting runs.  It compares 8 bytes values wherever possible.\nstatic bool get_run(const uint8_t* ip, const uint8_t* ip_bound) {\n  uint8_t x = *ip;\n  int64_t value, value2;\n  /* Broadcast the value for every byte in a 64-bit register */\n  memset(&value, x, 8);\n  while (ip < (ip_bound - 8)) {\n#if defined(BLOSC_STRICT_ALIGN)\n    memcpy(&value2, ref, 8);\n#else\n    value2 = *(int64_t*)ip;\n#endif\n    if (value != value2) {\n      // Values differ.  We don't have a run.\n      return false;\n    }\n    else {\n      ip += 8;\n    }\n  }\n  /* Look into the remainder */\n  while ((ip < ip_bound) && (*ip == x)) ip++;\n  return ip == ip_bound ? true : false;\n}\n\n\n/* Shuffle & compress a single block */\nstatic int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t destsize,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      if (ntbytes > destsize) {\n        /* Not enough space to write out compressed block size */\n        return -1;\n      }\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > destsize) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)destsize - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > destsize) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n\n  //printf(\"c%d\", ctbytes);\n  return ctbytes;\n}\n\n\n/* Process the filter pipeline (decompression mode) */\nint pipeline_d(blosc2_context* context, const int32_t bsize, uint8_t* dest,\n               const int32_t offset, uint8_t* src, uint8_t* tmp,\n               uint8_t* tmp2, int last_filter_index) {\n  int32_t typesize = context->typesize;\n  uint8_t* filters = context->filters;\n  uint8_t* filters_meta = context->filters_meta;\n  uint8_t* _src = src;\n  uint8_t* _dest = tmp;\n  uint8_t* _tmp = tmp2;\n  int errcode = 0;\n\n  for (int i = BLOSC2_MAX_FILTERS - 1; i >= 0; i--) {\n    // Delta filter requires the whole chunk ready\n    int last_copy_filter = (last_filter_index == i) || (next_filter(filters, i, 'd') == BLOSC_DELTA);\n    if (last_copy_filter) {\n      _dest = dest + offset;\n    }\n    switch (filters[i]) {\n      case BLOSC_SHUFFLE:\n        for (int j = 0; j <= filters_meta[i]; j++) {\n          unshuffle(typesize, bsize, _src, _dest);\n          // Cycle filters when required\n          if (j < filters_meta[i]) {\n            _src = _dest;\n            _dest = _tmp;\n            _tmp = _src;\n          }\n          // Check whether we have to copy the intermediate _dest buffer to final destination\n          if (last_copy_filter && (filters_meta[i] % 2) == 1 && j == filters_meta[i]) {\n            memcpy(dest + offset, _dest, (unsigned int)bsize);\n          }\n        }\n        break;\n      case BLOSC_BITSHUFFLE:\n        bitunshuffle(typesize, bsize, _src, _dest, _tmp, context->src[0]);\n        break;\n      case BLOSC_DELTA:\n        if (context->nthreads == 1) {\n          /* Serial mode */\n          delta_decoder(dest, offset, bsize, typesize, _dest);\n        } else {\n          /* Force the thread in charge of the block 0 to go first */\n          pthread_mutex_lock(&context->delta_mutex);\n          if (context->dref_not_init) {\n            if (offset != 0) {\n              pthread_cond_wait(&context->delta_cv, &context->delta_mutex);\n            } else {\n              delta_decoder(dest, offset, bsize, typesize, _dest);\n              context->dref_not_init = 0;\n              pthread_cond_broadcast(&context->delta_cv);\n            }\n          }\n          pthread_mutex_unlock(&context->delta_mutex);\n          if (offset != 0) {\n            delta_decoder(dest, offset, bsize, typesize, _dest);\n          }\n        }\n        break;\n      case BLOSC_TRUNC_PREC:\n        // TRUNC_PREC filter does not need to be undone\n        break;\n      default:\n        if (filters[i] != BLOSC_NOFILTER) {\n          fprintf(stderr, \"Filter %d not handled during decompression\\n\",\n                  filters[i]);\n          errcode = -1;\n        }\n    }\n    if (last_filter_index == i) {\n      return errcode;\n    }\n    // Cycle buffers when required\n    if ((filters[i] != BLOSC_NOFILTER) && (filters[i] != BLOSC_TRUNC_PREC)) {\n      _src = _dest;\n      _dest = _tmp;\n      _tmp = _src;\n    }\n  }\n\n  return errcode;\n}\n\n\n/* Decompress & unshuffle a single block */\nstatic int blosc_d(\n    struct thread_context* thread_context, int32_t bsize,\n    int32_t leftoverblock, const uint8_t* src, int32_t srcsize, int32_t src_offset,\n    uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  uint8_t* filters = context->filters;\n  uint8_t *tmp3 = thread_context->tmp4;\n  int32_t compformat = (context->header_flags & 0xe0) >> 5;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  //uint8_t blosc_version_format = src[0];\n  int nstreams;\n  int32_t neblock;\n  int32_t nbytes;                /* number of decompressed bytes in split */\n  int32_t cbytes;                /* number of compressed bytes in split */\n  int32_t ctbytes = 0;           /* number of compressed bytes in block */\n  int32_t ntbytes = 0;           /* number of uncompressed bytes in block */\n  uint8_t* _dest;\n  int32_t typesize = context->typesize;\n  int32_t nblock = dest_offset / context->blocksize;\n  const char* compname;\n\n  if (context->block_maskout != NULL && context->block_maskout[nblock]) {\n    // Do not decompress, but act as if we successfully decompressed everything\n    return bsize;\n  }\n\n  if (src_offset <= 0 || src_offset >= srcsize) {\n    /* Invalid block src offset encountered */\n    return -1;\n  }\n\n  src += src_offset;\n  srcsize -= src_offset;\n\n  int last_filter_index = last_filter(filters, 'd');\n\n  if ((last_filter_index >= 0) &&\n          (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) {\n   // We are making use of some filter, so use a temp for destination\n   _dest = tmp;\n  } else {\n    // If no filters, or only DELTA in pipeline\n   _dest = dest + dest_offset;\n  }\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !context->use_dict) {\n    // We don't want to split when in a training dict state\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n\n  neblock = bsize / nstreams;\n  for (int j = 0; j < nstreams; j++) {\n    if (srcsize < sizeof(int32_t)) {\n      /* Not enough input to read compressed size */\n      return -1;\n    }\n    srcsize -= sizeof(int32_t);\n    cbytes = sw32_(src);      /* amount of compressed bytes */\n    if (cbytes > 0) {\n      if (srcsize < cbytes) {\n        /* Not enough input to read compressed bytes */\n        return -1;\n      }\n      srcsize -= cbytes;\n    }\n    src += sizeof(int32_t);\n    ctbytes += (int32_t)sizeof(int32_t);\n\n    /* Uncompress */\n    if (cbytes <= 0) {\n      // A run\n      if (cbytes < -255) {\n        // Runs can only encode a byte\n        return -2;\n      }\n      uint8_t value = -cbytes;\n      memset(_dest, value, (unsigned int)neblock);\n      nbytes = neblock;\n      cbytes = 0;  // everything is encoded in the cbytes token\n    }\n    else if (cbytes == neblock) {\n      memcpy(_dest, src, (unsigned int)neblock);\n      nbytes = (int32_t)neblock;\n    }\n    else {\n      if (compformat == BLOSC_BLOSCLZ_FORMAT) {\n        nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);\n      }\n  #if defined(HAVE_LZ4)\n      else if (compformat == BLOSC_LZ4_FORMAT) {\n        nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,\n                                     (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n      else if (compformat == BLOSC_LIZARD_FORMAT) {\n        nbytes = lizard_wrap_decompress((char*)src, (size_t)cbytes,\n                                        (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n      else if (compformat == BLOSC_SNAPPY_FORMAT) {\n        nbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,\n                                        (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n      else if (compformat == BLOSC_ZLIB_FORMAT) {\n        nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n      else if (compformat == BLOSC_ZSTD_FORMAT) {\n        nbytes = zstd_wrap_decompress(thread_context,\n                                      (char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZSTD */\n      else {\n        compname = clibcode_to_clibname(compformat);\n        fprintf(stderr,\n                \"Blosc has not been compiled with decompression \"\n                    \"support for '%s' format. \", compname);\n        fprintf(stderr, \"Please recompile for adding this support.\\n\");\n        return -5;    /* signals no decompression support */\n      }\n\n      /* Check that decompressed bytes number is correct */\n      if (nbytes != neblock) {\n        return -2;\n      }\n\n    }\n    src += cbytes;\n    ctbytes += cbytes;\n    _dest += nbytes;\n    ntbytes += nbytes;\n  } /* Closes j < nstreams */\n\n  if (last_filter_index >= 0) {\n    int errcode = pipeline_d(context, bsize, dest, dest_offset, tmp, tmp2, tmp3,\n                             last_filter_index);\n    if (errcode < 0)\n      return errcode;\n  }\n\n  /* Return the number of uncompressed bytes */\n  return (int)ntbytes;\n}\n\n\n/* Serial version for compression/decompression */\nstatic int serial_blosc(struct thread_context* thread_context) {\n  blosc2_context* context = thread_context->parent_context;\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n  int32_t ntbytes = (int32_t)context->output_bytes;\n  int32_t* bstarts = context->bstarts;\n  uint8_t* tmp = thread_context->tmp;\n  uint8_t* tmp2 = thread_context->tmp2;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->do_compress && !memcpyed && !dict_training) {\n      _sw32(bstarts + j, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->do_compress) {\n      if (memcpyed && !context->prefilter) {\n        /* We want to memcpy only */\n        memcpy(context->dest + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n                 context->src + j * context->blocksize,\n                 (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src, j * context->blocksize,\n                         context->dest + ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      if (memcpyed) {\n        // Check that sizes in header are compatible, otherwise there is a header corruption\n        int32_t csize = sw32_(context->src + 12);   /* compressed buffer size */\n        if (context->sourcesize + BLOSC_MAX_OVERHEAD != csize) {\n          return -1;\n        }\n        if (context->srcsize < BLOSC_MAX_OVERHEAD + (j * context->blocksize) + bsize) {\n          /* Not enough input to copy block */\n          return -1;\n        }\n        memcpy(context->dest + j * context->blocksize,\n               context->src + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n               (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular decompression */\n        cbytes = blosc_d(thread_context, bsize, leftoverblock,\n                         context->src, context->srcsize, sw32_(bstarts + j),\n                         context->dest, j * context->blocksize, tmp, tmp2);\n      }\n    }\n\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}\n\nstatic void t_blosc_do_job(void *ctxt);\n\n/* Threaded version for compression/decompression */\nstatic int parallel_blosc(blosc2_context* context) {\n#ifdef BLOSC_POSIX_BARRIERS\n  int rc;\n#endif\n  /* Set sentinels */\n  context->thread_giveup_code = 1;\n  context->thread_nblock = -1;\n\n  if (threads_callback) {\n    threads_callback(threads_callback_data, t_blosc_do_job,\n                     context->nthreads, sizeof(struct thread_context), (void*) context->thread_contexts);\n  }\n  else {\n    /* Synchronization point for all threads (wait for initialization) */\n    WAIT_INIT(-1, context);\n\n    /* Synchronization point for all threads (wait for finalization) */\n    WAIT_FINISH(-1, context);\n  }\n\n  if (context->thread_giveup_code <= 0) {\n    /* Compression/decompression gave up.  Return error code. */\n    return context->thread_giveup_code;\n  }\n\n  /* Return the total bytes (de-)compressed in threads */\n  return (int)context->output_bytes;\n}\n\n/* initialize a thread_context that has already been allocated */\nstatic void init_thread_context(struct thread_context* thread_context, blosc2_context* context, int32_t tid)\n{\n  int32_t ebsize;\n\n  thread_context->parent_context = context;\n  thread_context->tid = tid;\n\n  ebsize = context->blocksize + context->typesize * (int32_t)sizeof(int32_t);\n  thread_context->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;\n  thread_context->tmp = my_malloc(thread_context->tmp_nbytes);\n  thread_context->tmp2 = thread_context->tmp + context->blocksize;\n  thread_context->tmp3 = thread_context->tmp + context->blocksize + ebsize;\n  thread_context->tmp4 = thread_context->tmp + 2 * context->blocksize + ebsize;\n  thread_context->tmp_blocksize = context->blocksize;\n  #if defined(HAVE_ZSTD)\n  thread_context->zstd_cctx = NULL;\n  thread_context->zstd_dctx = NULL;\n  #endif\n\n  /* Create the hash table for LZ4 in case we are using IPP */\n#ifdef HAVE_IPP\n  IppStatus status;\n  int inlen = thread_context->tmp_blocksize > 0 ? thread_context->tmp_blocksize : 1 << 16;\n  int hash_size = 0;\n  status = ippsEncodeLZ4HashTableGetSize_8u(&hash_size);\n  if (status != ippStsNoErr) {\n    fprintf(stderr, \"Error in ippsEncodeLZ4HashTableGetSize_8u\");\n  }\n  Ipp8u *hash_table = ippsMalloc_8u(hash_size);\n  status = ippsEncodeLZ4HashTableInit_8u(hash_table, inlen);\n  if (status != ippStsNoErr) {\n    fprintf(stderr, \"Error in ippsEncodeLZ4HashTableInit_8u\");\n  }\n  thread_context->lz4_hash_table = hash_table;\n#endif\n}\n\nstatic struct thread_context*\ncreate_thread_context(blosc2_context* context, int32_t tid) {\n  struct thread_context* thread_context;\n  thread_context = (struct thread_context*)my_malloc(sizeof(struct thread_context));\n  init_thread_context(thread_context, context, tid);\n  return thread_context;\n}\n\n/* free members of thread_context, but not thread_context itself */\nstatic void destroy_thread_context(struct thread_context* thread_context) {\n  my_free(thread_context->tmp);\n#if defined(HAVE_ZSTD)\n  if (thread_context->zstd_cctx != NULL) {\n    ZSTD_freeCCtx(thread_context->zstd_cctx);\n  }\n  if (thread_context->zstd_dctx != NULL) {\n    ZSTD_freeDCtx(thread_context->zstd_dctx);\n  }\n#endif\n#ifdef HAVE_IPP\n  if (thread_context->lz4_hash_table != NULL) {\n    ippsFree(thread_context->lz4_hash_table);\n  }\n#endif\n}\n\nvoid free_thread_context(struct thread_context* thread_context) {\n  destroy_thread_context(thread_context);\n  my_free(thread_context);\n}\n\n\nint check_nthreads(blosc2_context* context) {\n  if (context->nthreads <= 0) {\n    fprintf(stderr, \"Error.  nthreads must be a positive integer\");\n    return -1;\n  }\n\n  if (context->new_nthreads != context->nthreads) {\n    if (context->nthreads > 1) {\n      release_threadpool(context);\n    }\n    context->nthreads = context->new_nthreads;\n  }\n  if (context->new_nthreads > 1 && context->threads_started == 0) {\n    init_threadpool(context);\n  }\n\n  return context->nthreads;\n}\n\n/* Do the compression or decompression of the buffer depending on the\n   global params. */\nstatic int do_job(blosc2_context* context) {\n  int32_t ntbytes;\n\n  /* Set sentinels */\n  context->dref_not_init = 1;\n\n  /* Check whether we need to restart threads */\n  check_nthreads(context);\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not larger than blocksize */\n  if (context->nthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    /* The context for this 'thread' has no been initialized yet */\n    if (context->serial_context == NULL) {\n      context->serial_context = create_thread_context(context, 0);\n    }\n    else if (context->blocksize != context->serial_context->tmp_blocksize) {\n      free_thread_context(context->serial_context);\n      context->serial_context = create_thread_context(context, 0);\n    }\n    ntbytes = serial_blosc(context->serial_context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}\n\n\n/* Convert filter pipeline to filter flags */\nstatic uint8_t filters_to_flags(const uint8_t* filters) {\n  uint8_t flags = 0;\n\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    switch (filters[i]) {\n      case BLOSC_SHUFFLE:\n        flags |= BLOSC_DOSHUFFLE;\n        break;\n      case BLOSC_BITSHUFFLE:\n        flags |= BLOSC_DOBITSHUFFLE;\n        break;\n      case BLOSC_DELTA:\n        flags |= BLOSC_DODELTA;\n        break;\n      default :\n        break;\n    }\n  }\n  return flags;\n}\n\n\n/* Convert filter flags to filter pipeline */\nstatic void flags_to_filters(const uint8_t flags, uint8_t* filters) {\n  /* Initialize the filter pipeline */\n  memset(filters, 0, BLOSC2_MAX_FILTERS);\n  /* Fill the filter pipeline */\n  if (flags & BLOSC_DOSHUFFLE)\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;\n  if (flags & BLOSC_DOBITSHUFFLE)\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;\n  if (flags & BLOSC_DODELTA)\n    filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;\n}\n\n\nstatic int initialize_context_compression(\n  blosc2_context* context, const void* src, int32_t srcsize, void* dest,\n  int32_t destsize, int clevel, uint8_t const *filters,\n  uint8_t const *filters_meta, int32_t typesize, int compressor,\n  int32_t blocksize, int new_nthreads, int nthreads, blosc2_schunk* schunk) {\n\n  /* Set parameters */\n  context->do_compress = 1;\n  context->src = (const uint8_t*)src;\n  context->srcsize = srcsize;\n  context->dest = (uint8_t*)dest;\n  context->output_bytes = 0;\n  context->destsize = destsize;\n  context->sourcesize = srcsize;\n  context->typesize = (int32_t)typesize;\n  context->filter_flags = filters_to_flags(filters);\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    context->filters[i] = filters[i];\n    context->filters_meta[i] = filters_meta[i];\n  }\n  context->compcode = compressor;\n  context->nthreads = nthreads;\n  context->new_nthreads = new_nthreads;\n  context->end_threads = 0;\n  context->clevel = clevel;\n  context->schunk = schunk;\n\n  /* Tune some compression parameters */\n  context->blocksize = (int32_t)blocksize;\n  if (context->btune != NULL) {\n    btune_next_cparams(context);\n  } else {\n    btune_next_blocksize(context);\n  }\n\n  char* envvar = getenv(\"BLOSC_WARN\");\n  int warnlvl = 0;\n  if (envvar != NULL) {\n    warnlvl = strtol(envvar, NULL, 10);\n  }\n\n  /* Check buffer size limits */\n  if (srcsize > BLOSC_MAX_BUFFERSIZE) {\n    if (warnlvl > 0) {\n      fprintf(stderr, \"Input buffer size cannot exceed %d bytes\\n\",\n              BLOSC_MAX_BUFFERSIZE);\n    }\n    return 0;\n  }\n\n  if (destsize < BLOSC_MAX_OVERHEAD) {\n    if (warnlvl > 0) {\n      fprintf(stderr, \"Output buffer size should be larger than %d bytes\\n\",\n              BLOSC_MAX_OVERHEAD);\n    }\n    return 0;\n  }\n\n  if (destsize < BLOSC_MAX_OVERHEAD) {\n    if (warnlvl > 0) {\n      fprintf(stderr, \"Output buffer size should be larger than %d bytes\\n\",\n              BLOSC_MAX_OVERHEAD);\n    }\n    return -2;\n  }\n  if (destsize < BLOSC_MAX_OVERHEAD) {\n    fprintf(stderr, \"Output buffer size should be larger than %d bytes\\n\",\n            BLOSC_MAX_OVERHEAD);\n    return -1;\n  }\n\n  /* Compression level */\n  if (clevel < 0 || clevel > 9) {\n    /* If clevel not in 0..9, print an error */\n    fprintf(stderr, \"`clevel` parameter must be between 0 and 9!\\n\");\n    return -10;\n  }\n\n  /* Check typesize limits */\n  if (context->typesize > BLOSC_MAX_TYPESIZE) {\n    /* If typesize is too large, treat buffer as an 1-byte stream. */\n    context->typesize = 1;\n  }\n\n  /* Compute number of blocks in buffer */\n  context->nblocks = context->sourcesize / context->blocksize;\n  context->leftover = context->sourcesize % context->blocksize;\n  context->nblocks = (context->leftover > 0) ?\n                     (context->nblocks + 1) : context->nblocks;\n\n  return 1;\n}\n\n\n/* Get filter flags from header flags */\nstatic uint8_t get_filter_flags(const uint8_t header_flags,\n                                const int32_t typesize) {\n  uint8_t flags = 0;\n\n  if ((header_flags & BLOSC_DOSHUFFLE) && (typesize > 1)) {\n    flags |= BLOSC_DOSHUFFLE;\n  }\n  if (header_flags & BLOSC_DOBITSHUFFLE) {\n    flags |= BLOSC_DOBITSHUFFLE;\n  }\n  if (header_flags & BLOSC_DODELTA) {\n    flags |= BLOSC_DODELTA;\n  }\n  if (header_flags & BLOSC_MEMCPYED) {\n    flags |= BLOSC_MEMCPYED;\n  }\n  return flags;\n}\n\n\nstatic int initialize_context_decompression(blosc2_context* context, const void* src, int32_t srcsize,\n                                            void* dest, int32_t destsize) {\n  uint8_t blosc2_flags = 0;\n  int32_t cbytes;\n  int32_t bstarts_offset;\n  int32_t bstarts_end;\n\n  context->do_compress = 0;\n  context->src = (const uint8_t*)src;\n  context->srcsize = srcsize;\n  context->dest = (uint8_t*)dest;\n  context->destsize = destsize;\n  context->output_bytes = 0;\n  context->end_threads = 0;\n\n  if (context->srcsize < BLOSC_MIN_HEADER_LENGTH) {\n    /* Not enough input to read minimum header */\n    return -1;\n  }\n\n  context->header_flags = context->src[2];\n  context->typesize = context->src[3];\n  context->sourcesize = sw32_(context->src + 4);\n  context->blocksize = sw32_(context->src + 8);\n  cbytes = sw32_(context->src + 12);\n\n  // Some checks for malformed headers\n  if (context->blocksize <= 0 || context->blocksize > destsize ||\n      context->typesize <= 0 || context->typesize > BLOSC_MAX_TYPESIZE ||\n      cbytes > srcsize) {\n    return -1;\n  }\n  /* Check that we have enough space to decompress */\n  if (context->sourcesize > (int32_t)destsize) {\n    return -1;\n  }\n\n  /* Total blocks */\n  context->nblocks = context->sourcesize / context->blocksize;\n  context->leftover = context->sourcesize % context->blocksize;\n  context->nblocks = (context->leftover > 0) ?\n                      context->nblocks + 1 : context->nblocks;\n\n  if (context->block_maskout != NULL && context->block_maskout_nitems != context->nblocks) {\n    fprintf(stderr, \"The number of items in block_maskout (%d) must match the number\"\n                    \" of blocks in chunk (%d)\", context->block_maskout_nitems, context->nblocks);\n    return -2;\n  }\n\n  if ((context->header_flags & BLOSC_DOSHUFFLE) &&\n      (context->header_flags & BLOSC_DOBITSHUFFLE)) {\n    /* Extended header */\n    if (context->srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {\n      /* Not enough input to read extended header */\n      return -1;\n    }\n    uint8_t* filters = (uint8_t*)(context->src + BLOSC_MIN_HEADER_LENGTH);\n    uint8_t* filters_meta = filters + 8;\n    uint8_t header_version = context->src[0];\n    // The number of filters depends on the version of the header\n    // (we need to read less because filters where not initialized to zero in blosc2 alpha series)\n    int max_filters = (header_version == BLOSC2_VERSION_FORMAT_ALPHA) ? 5 : BLOSC2_MAX_FILTERS;\n    for (int i = 0; i < max_filters; i++) {\n      context->filters[i] = filters[i];\n      context->filters_meta[i] = filters_meta[i];\n    }\n    context->filter_flags = filters_to_flags(filters);\n    bstarts_offset = BLOSC_EXTENDED_HEADER_LENGTH;\n    blosc2_flags = context->src[0x1F];\n  } else {\n    /* Regular (Blosc1) header */\n    context->filter_flags = get_filter_flags(context->header_flags,\n                                             context->typesize);\n    flags_to_filters(context->header_flags, context->filters);\n    bstarts_offset = BLOSC_MIN_HEADER_LENGTH;\n  }\n\n  context->bstarts = (int32_t*)(context->src + bstarts_offset);\n  bstarts_end = bstarts_offset + (context->nblocks * sizeof(int32_t));\n  if (srcsize < bstarts_end) {\n    /* Not enough input to read entire `bstarts` section */\n    return -1;\n  }\n  srcsize -= bstarts_end;\n\n  /* Read optional dictionary if flag set */\n  if (blosc2_flags & BLOSC2_USEDICT) {\n#if defined(HAVE_ZSTD)\n    context->use_dict = 1;\n    if (context->dict_ddict != NULL) {\n      // Free the existing dictionary (probably from another chunk)\n      ZSTD_freeDDict(context->dict_ddict);\n    }\n    // The trained dictionary is after the bstarts block\n    if (srcsize < sizeof(int32_t)) {\n      /* Not enough input to size of dictionary */\n      return -1;\n    }\n    srcsize -= sizeof(int32_t);\n    context->dict_size = (size_t)sw32_(context->src + bstarts_end);\n    if (context->dict_size <= 0 || context->dict_size > BLOSC2_MAXDICTSIZE) {\n      /* Dictionary size is smaller than minimum or larger than maximum allowed */\n      return -1;\n    }\n    if (srcsize < (int32_t)context->dict_size) {\n      /* Not enough input to read entire dictionary */\n      return -1;\n    }\n    srcsize -= context->dict_size;\n    context->dict_buffer = (void*)(context->src + bstarts_end + sizeof(int32_t));\n    context->dict_ddict = ZSTD_createDDict(context->dict_buffer, context->dict_size);\n#endif   // HAVE_ZSTD\n  }\n\n\n  return 0;\n}\n\n\nstatic int write_compression_header(blosc2_context* context,\n                                    bool extended_header) {\n  int32_t compformat;\n  int dont_split;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n\n  // Set the whole header to zeros so that the reserved values are zeroed\n  if (extended_header) {\n    memset(context->dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);\n  }\n  else {\n    memset(context->dest, 0, BLOSC_MIN_HEADER_LENGTH);\n  }\n\n  /* Write version header for this block */\n  context->dest[0] = BLOSC_VERSION_FORMAT;\n\n  /* Write compressor format */\n  compformat = -1;\n  switch (context->compcode) {\n    case BLOSC_BLOSCLZ:\n      compformat = BLOSC_BLOSCLZ_FORMAT;\n      context->dest[1] = BLOSC_BLOSCLZ_VERSION_FORMAT;\n      break;\n\n#if defined(HAVE_LZ4)\n    case BLOSC_LZ4:\n      compformat = BLOSC_LZ4_FORMAT;\n      context->dest[1] = BLOSC_LZ4_VERSION_FORMAT;\n      break;\n    case BLOSC_LZ4HC:\n      compformat = BLOSC_LZ4HC_FORMAT;\n      context->dest[1] = BLOSC_LZ4HC_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_LZ4 */\n\n#if defined(HAVE_LIZARD)\n    case BLOSC_LIZARD:\n      compformat = BLOSC_LIZARD_FORMAT;\n      context->dest[1] = BLOSC_LIZARD_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_LIZARD */\n\n#if defined(HAVE_SNAPPY)\n    case BLOSC_SNAPPY:\n      compformat = BLOSC_SNAPPY_FORMAT;\n      context->dest[1] = BLOSC_SNAPPY_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_SNAPPY */\n\n#if defined(HAVE_ZLIB)\n    case BLOSC_ZLIB:\n      compformat = BLOSC_ZLIB_FORMAT;\n      context->dest[1] = BLOSC_ZLIB_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_ZLIB */\n\n#if defined(HAVE_ZSTD)\n    case BLOSC_ZSTD:\n      compformat = BLOSC_ZSTD_FORMAT;\n      context->dest[1] = BLOSC_ZSTD_VERSION_FORMAT;\n      break;\n#endif /*  HAVE_ZSTD */\n\n    default: {\n      const char* compname;\n      compname = clibcode_to_clibname(compformat);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n      break;\n    }\n  }\n\n  if (context->clevel == 0) {\n    /* Compression level 0 means buffer to be memcpy'ed */\n    context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n  }\n\n  if (context->sourcesize < BLOSC_MIN_BUFFERSIZE) {\n    /* Buffer is too small.  Try memcpy'ing. */\n    context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n  }\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  context->dest[2] = 0;                               /* zeroes flags */\n  context->dest[3] = (uint8_t)context->typesize;\n  _sw32(context->dest + 4, (int32_t)context->sourcesize);\n  _sw32(context->dest + 8, (int32_t)context->blocksize);\n  if (extended_header) {\n    /* Mark that we are handling an extended header */\n    context->header_flags |= (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);\n    /* Store filter pipeline info at the end of the header */\n    uint8_t *filters = context->dest + BLOSC_MIN_HEADER_LENGTH;\n    uint8_t *filters_meta = filters + 8;\n    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n      filters[i] = context->filters[i];\n      filters_meta[i] = context->filters_meta[i];\n    }\n    uint8_t* blosc2_flags = context->dest + 0x1F;\n    *blosc2_flags = 0;    // zeroes flags\n    *blosc2_flags |= is_little_endian() ? 0 : BLOSC2_BIGENDIAN;  // endianness\n    if (dict_training || memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH;\n    } else {\n      context->bstarts = (int32_t*)(context->dest + BLOSC_EXTENDED_HEADER_LENGTH);\n      context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH +\n                              sizeof(int32_t) * context->nblocks;\n    }\n    if (context->use_dict) {\n      *blosc2_flags |= BLOSC2_USEDICT;\n    }\n  } else {\n    // Regular header\n    if (memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = BLOSC_MIN_HEADER_LENGTH;\n    } else {\n      context->bstarts = (int32_t *) (context->dest + BLOSC_MIN_HEADER_LENGTH);\n      context->output_bytes = BLOSC_MIN_HEADER_LENGTH +\n                              sizeof(int32_t) * context->nblocks;\n    }\n  }\n\n  // when memcpyed bit is set, there is no point in dealing with others\n  if (!memcpyed) {\n    if (context->filter_flags & BLOSC_DOSHUFFLE) {\n      /* Byte-shuffle is active */\n      context->header_flags |= BLOSC_DOSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DOBITSHUFFLE) {\n      /* Bit-shuffle is active */\n      context->header_flags |= BLOSC_DOBITSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DODELTA) {\n      /* Delta is active */\n      context->header_flags |= BLOSC_DODELTA;\n    }\n\n    dont_split = !split_block(context, context->typesize,\n                              context->blocksize, extended_header);\n    context->header_flags |= dont_split << 4;  /* dont_split is in bit 4 */\n    context->header_flags |= compformat << 5;  /* codec starts at bit 5 */\n  }\n\n  // store header flags in dest\n  context->dest[2] = context->header_flags;\n\n  return 1;\n}\n\n\nint blosc_compress_context(blosc2_context* context) {\n  int ntbytes = 0;\n  blosc_timestamp_t last, current;\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  blosc_set_timestamp(&last);\n\n  if (!memcpyed) {\n    /* Do the actual compression */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return -1;\n    }\n    if (ntbytes == 0) {\n      // Try out with a memcpy later on (last chance for fitting src buffer in dest).\n      context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n      memcpyed = true;\n    }\n  }\n\n  if (memcpyed) {\n    if (context->sourcesize + BLOSC_MAX_OVERHEAD > context->destsize) {\n      /* We are exceeding maximum output size */\n      ntbytes = 0;\n    }\n    else {\n      context->output_bytes = BLOSC_MAX_OVERHEAD;\n      ntbytes = do_job(context);\n      if (ntbytes < 0) {\n        return -1;\n      }\n      // Success!  update the memcpy bit in header\n      context->dest[2] = context->header_flags;\n      // and clear the memcpy bit in context (for next reuse)\n      context->header_flags &= ~(uint8_t)BLOSC_MEMCPYED;\n    }\n  }\n\n  /* Set the number of compressed bytes in header */\n  _sw32(context->dest + 12, ntbytes);\n\n  /* Set the number of bytes in dest buffer (might be useful for btune) */\n  context->destsize = ntbytes;\n\n  assert(ntbytes <= context->destsize);\n\n  if (context->btune != NULL) {\n    blosc_set_timestamp(&current);\n    double ctime = blosc_elapsed_secs(last, current);\n    btune_update(context, ctime);\n  }\n\n  return ntbytes;\n}\n\n\n/* The public secure routine for compression with context. */\nint blosc2_compress_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n                        void* dest, int32_t destsize) {\n  int error, cbytes;\n\n  if (context->do_compress != 1) {\n    fprintf(stderr, \"Context is not meant for compression.  Giving up.\\n\");\n    return -10;\n  }\n\n  error = initialize_context_compression(\n    context, src, srcsize, dest, destsize,\n    context->clevel, context->filters, context->filters_meta,\n    context->typesize, context->compcode, context->blocksize,\n    context->new_nthreads, context->nthreads, context->schunk);\n  if (error <= 0) {\n    return error;\n  }\n\n  /* Write the extended header */\n  error = write_compression_header(context, true);\n  if (error < 0) {\n    return error;\n  }\n\n  cbytes = blosc_compress_context(context);\n  if (cbytes < 0) {\n    return cbytes;\n  }\n\n  if (context->use_dict && context->dict_cdict == NULL) {\n\n    if (context->compcode != BLOSC_ZSTD) {\n      const char* compname;\n      compname = clibcode_to_clibname(context->compcode);\n      fprintf(stderr, \"Codec %s does not support dicts.  Giving up.\\n\",\n              compname);\n      return -20;\n    }\n\n#ifdef HAVE_ZSTD\n    // Build the dictionary out of the filters outcome and compress with it\n    int32_t dict_maxsize = BLOSC2_MAXDICTSIZE;\n    // Do not make the dict more than 5% larger than uncompressed buffer\n    if (dict_maxsize > srcsize / 20) {\n      dict_maxsize = srcsize / 20;\n    }\n    void* samples_buffer = context->dest + BLOSC_EXTENDED_HEADER_LENGTH;\n    unsigned nblocks = 8;  // the minimum that accepts zstd as of 1.4.0\n    unsigned sample_fraction = 1;  // 1 allows to use most of the chunk for training\n    size_t sample_size = context->sourcesize / nblocks / sample_fraction;\n\n    // Populate the samples sizes for training the dictionary\n    size_t* samples_sizes = malloc(nblocks * sizeof(void*));\n    for (size_t i = 0; i < nblocks; i++) {\n      samples_sizes[i] = sample_size;\n    }\n\n    // Train from samples\n    void* dict_buffer = malloc(dict_maxsize);\n    size_t dict_actual_size = ZDICT_trainFromBuffer(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks);\n\n    // TODO: experiment with parameters of low-level fast cover algorithm\n    // Note that this API is still unstable.  See: https://github.com/facebook/zstd/issues/1599\n    // ZDICT_fastCover_params_t fast_cover_params;\n    // memset(&fast_cover_params, 0, sizeof(fast_cover_params));\n    // fast_cover_params.d = nblocks;\n    // fast_cover_params.steps = 4;\n    // fast_cover_params.zParams.compressionLevel = context->clevel;\n    //size_t dict_actual_size = ZDICT_optimizeTrainFromBuffer_fastCover(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks, &fast_cover_params);\n\n    if (ZDICT_isError(dict_actual_size) != ZSTD_error_no_error) {\n      fprintf(stderr, \"Error in ZDICT_trainFromBuffer(): '%s'.\"\n              \"  Giving up.\\n\", ZDICT_getErrorName(dict_actual_size));\n      return -20;\n    }\n    assert(dict_actual_size > 0);\n    free(samples_sizes);\n\n    // Update bytes counter and pointers to bstarts for the new compressed buffer\n    context->bstarts = (int32_t*)(context->dest + BLOSC_EXTENDED_HEADER_LENGTH);\n    context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH +\n                            sizeof(int32_t) * context->nblocks;\n    /* Write the size of trained dict at the end of bstarts */\n    _sw32(context->dest + context->output_bytes, (int32_t)dict_actual_size);\n    context->output_bytes += sizeof(int32_t);\n    /* Write the trained dict afterwards */\n    context->dict_buffer = context->dest + context->output_bytes;\n    memcpy(context->dict_buffer, dict_buffer, (unsigned int)dict_actual_size);\n    context->dict_cdict = ZSTD_createCDict(dict_buffer, dict_actual_size, 1);  // TODO: use get_accel()\n    free(dict_buffer);      // the dictionary is copied in the header now\n    context->output_bytes += (int32_t)dict_actual_size;\n    context->dict_size = dict_actual_size;\n\n    /* Compress with dict */\n    cbytes = blosc_compress_context(context);\n\n    // Invalidate the dictionary for compressing other chunks using the same context\n    context->dict_buffer = NULL;\n    ZSTD_freeCDict(context->dict_cdict);\n    context->dict_cdict = NULL;\n#endif  // HAVE_ZSTD\n  }\n\n  return cbytes;\n}\n\n\nvoid build_filters(const int doshuffle, const int delta,\n                   const size_t typesize, uint8_t* filters) {\n\n  /* Fill the end part of the filter pipeline */\n  if ((doshuffle == BLOSC_SHUFFLE) && (typesize > 1))\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;\n  if (doshuffle == BLOSC_BITSHUFFLE)\n    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;\n  if (delta)\n    filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;\n}\n\n/* The public secure routine for compression. */\nint blosc2_compress(int clevel, int doshuffle, int32_t typesize,\n                    const void* src, int32_t srcsize, void* dest, int32_t destsize) {\n  int error;\n  int result;\n  char* envvar;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  /* Check for a BLOSC_CLEVEL environment variable */\n  envvar = getenv(\"BLOSC_CLEVEL\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value >= 0)) {\n      clevel = (int)value;\n    }\n  }\n\n  /* Check for a BLOSC_SHUFFLE environment variable */\n  envvar = getenv(\"BLOSC_SHUFFLE\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"NOSHUFFLE\") == 0) {\n      doshuffle = BLOSC_NOSHUFFLE;\n    }\n    if (strcmp(envvar, \"SHUFFLE\") == 0) {\n      doshuffle = BLOSC_SHUFFLE;\n    }\n    if (strcmp(envvar, \"BITSHUFFLE\") == 0) {\n      doshuffle = BLOSC_BITSHUFFLE;\n    }\n  }\n\n  /* Check for a BLOSC_DELTA environment variable */\n  envvar = getenv(\"BLOSC_DELTA\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"1\") == 0) {\n      blosc_set_delta(1);\n    } else {\n      blosc_set_delta(0);\n    }\n  }\n\n  /* Check for a BLOSC_TYPESIZE environment variable */\n  envvar = getenv(\"BLOSC_TYPESIZE\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value > 0)) {\n      typesize = (size_t)value;\n    }\n  }\n\n  /* Check for a BLOSC_COMPRESSOR environment variable */\n  envvar = getenv(\"BLOSC_COMPRESSOR\");\n  if (envvar != NULL) {\n    result = blosc_set_compressor(envvar);\n    if (result < 0) { return result; }\n  }\n\n  /* Check for a BLOSC_COMPRESSOR environment variable */\n  envvar = getenv(\"BLOSC_BLOCKSIZE\");\n  if (envvar != NULL) {\n    long blocksize;\n    blocksize = strtol(envvar, NULL, 10);\n    if ((blocksize != EINVAL) && (blocksize > 0)) {\n      blosc_set_blocksize((size_t)blocksize);\n    }\n  }\n\n  /* Check for a BLOSC_NTHREADS environment variable */\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    long nthreads;\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    // TODO: here is the only place that returns an extended header from\n    //   a blosc_compress() call.  This should probably be fixed.\n    const char *compname;\n    blosc2_context *cctx;\n    blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;\n\n    blosc_compcode_to_compname(g_compressor, &compname);\n    /* Create a context for compression */\n    build_filters(doshuffle, g_delta, typesize, cparams.filters);\n    // TODO: cparams can be shared in a multithreaded environment.  do a copy!\n    cparams.typesize = (uint8_t)typesize;\n    cparams.compcode = (uint8_t)g_compressor;\n    cparams.clevel = (uint8_t)clevel;\n    cparams.nthreads = (uint8_t)g_nthreads;\n    cctx = blosc2_create_cctx(cparams);\n    /* Do the actual compression */\n    result = blosc2_compress_ctx(cctx, src, srcsize, dest, destsize);\n    /* Release context resources */\n    blosc2_free_ctx(cctx);\n    return result;\n  }\n\n  pthread_mutex_lock(&global_comp_mutex);\n\n  /* Initialize a context compression */\n  uint8_t* filters = calloc(1, BLOSC2_MAX_FILTERS);\n  uint8_t* filters_meta = calloc(1, BLOSC2_MAX_FILTERS);\n  build_filters(doshuffle, g_delta, typesize, filters);\n  error = initialize_context_compression(\n    g_global_context, src, srcsize, dest, destsize, clevel, filters,\n    filters_meta, (int32_t)typesize, g_compressor, g_force_blocksize, g_nthreads, g_nthreads,\n    g_schunk);\n  free(filters);\n  free(filters_meta);\n  if (error <= 0) {\n    pthread_mutex_unlock(&global_comp_mutex);\n    return error;\n  }\n\n  /* Write chunk header without extended header (Blosc1 compatibility mode) */\n  error = write_compression_header(g_global_context, false);\n  if (error < 0) {\n    pthread_mutex_unlock(&global_comp_mutex);\n    return error;\n  }\n\n  result = blosc_compress_context(g_global_context);\n\n  pthread_mutex_unlock(&global_comp_mutex);\n\n  return result;\n}\n\n\n/* The public routine for compression. */\nint blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,\n                   const void* src, void* dest, size_t destsize) {\n  return blosc2_compress(clevel, doshuffle, (int32_t)typesize, src, (int32_t)nbytes, dest, (int32_t)destsize);\n}\n\n\nint blosc_run_decompression_with_context(blosc2_context* context, const void* src, int32_t srcsize,\n                                         void* dest, int32_t destsize) {\n  int32_t ntbytes;\n  uint8_t* _src = (uint8_t*)src;\n  uint8_t version;\n  int error;\n\n  if (srcsize <= 0) {\n    /* Invalid argument */\n    return -1;\n  }\n  version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    return -1;\n  }\n\n  error = initialize_context_decompression(context, src, srcsize, dest, destsize);\n  if (error < 0) {\n    return error;\n  }\n\n  /* Check whether this buffer is memcpy'ed */\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  if (memcpyed) {\n    // Check that sizes in header are compatible, otherwise there is a header corruption\n    ntbytes = context->sourcesize;\n    int32_t cbytes = sw32_(_src + 12);   /* compressed buffer size */\n    if (ntbytes + BLOSC_MAX_OVERHEAD != cbytes) {\n      return -1;\n    }\n    // Check that we have enough space in destination for the copy operation\n    if (destsize < ntbytes) {\n      return -1;\n    }\n    memcpy(dest, _src + BLOSC_MAX_OVERHEAD, (unsigned int)ntbytes);\n  }\n  else {\n    /* Do the actual decompression */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return -1;\n    }\n  }\n\n  assert(ntbytes <= (int32_t)destsize);\n  return ntbytes;\n}\n\n\n/* The public secure routine for decompression with context. */\nint blosc2_decompress_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n                          void* dest, int32_t destsize) {\n  int result;\n\n  if (context->do_compress != 0) {\n    fprintf(stderr, \"Context is not meant for decompression.  Giving up.\\n\");\n    return -10;\n  }\n\n  result = blosc_run_decompression_with_context(context, src, srcsize, dest, destsize);\n\n  // Reset a possible block_maskout\n  if (context->block_maskout != NULL) {\n    free(context->block_maskout);\n    context->block_maskout = NULL;\n  }\n  context->block_maskout_nitems = 0;\n\n  return result;\n}\n\n\n/* The public secure routine for decompression. */\nint blosc2_decompress(const void* src, int32_t srcsize, void* dest, int32_t destsize) {\n  int result;\n  char* envvar;\n  long nthreads;\n  blosc2_context *dctx;\n  blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  /* Check for a BLOSC_NTHREADS environment variable */\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    dparams.nthreads = g_nthreads;\n    dctx = blosc2_create_dctx(dparams);\n    result = blosc2_decompress_ctx(dctx, src, srcsize, dest, destsize);\n    blosc2_free_ctx(dctx);\n    return result;\n  }\n\n  pthread_mutex_lock(&global_comp_mutex);\n\n  result = blosc_run_decompression_with_context(\n          g_global_context, src, srcsize, dest, destsize);\n\n  pthread_mutex_unlock(&global_comp_mutex);\n\n  return result;\n}\n\n\n/* The public routine for decompression. */\nint blosc_decompress(const void* src, void* dest, size_t destsize) {\n  return blosc2_decompress(src, INT32_MAX, dest, (int32_t)destsize);\n}\n\n\n/* Specific routine optimized for decompression a small number of\n   items out of a compressed chunk.  This does not use threads because\n   it would affect negatively to performance. */\nint _blosc_getitem(blosc2_context* context, const void* src, int32_t srcsize,\n                   int start, int nitems, void* dest) {\n  uint8_t* _src = NULL;             /* current pos for source buffer */\n  uint8_t flags;                    /* flags for header */\n  int32_t ntbytes = 0;              /* the number of uncompressed bytes */\n  int32_t nblocks;                   /* number of total blocks in buffer */\n  int32_t leftover;                  /* extra bytes at end of buffer */\n  int32_t* bstarts;                /* start pointers for each block */\n  int32_t typesize, blocksize, nbytes;\n  int32_t bsize, bsize2, ebsize, leftoverblock;\n  int32_t cbytes;\n  int32_t startb, stopb;\n  int32_t stop = start + nitems;\n  int j;\n\n  if (srcsize < BLOSC_MIN_HEADER_LENGTH) {\n    /* Not enough input to parse Blosc1 header */\n    return -1;\n  }\n  _src = (uint8_t*)(src);\n\n  /* Read the header block */\n  flags = _src[2];                  /* flags */\n  bool memcpyed = flags & (uint8_t)BLOSC_MEMCPYED;\n  typesize = (int32_t)_src[3];      /* typesize */\n  nbytes = sw32_(_src + 4);         /* buffer size */\n  blocksize = sw32_(_src + 8);      /* block size */\n  cbytes = sw32_(_src + 12);    /* compressed buffer size */\n\n  ebsize = blocksize + typesize * (int32_t)sizeof(int32_t);\n\n  if ((context->header_flags & BLOSC_DOSHUFFLE) &&\n      (context->header_flags & BLOSC_DOBITSHUFFLE)) {\n    /* Extended header */\n    if (srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {\n      /* Not enough input to parse Blosc2 header */\n      return -1;\n    }\n    uint8_t* filters = _src + BLOSC_MIN_HEADER_LENGTH;\n    uint8_t* filters_meta = filters + 8;\n    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n      context->filters[i] = filters[i];\n      context->filters_meta[i] = filters_meta[i];\n    }\n    bstarts = (int32_t*)(_src + BLOSC_EXTENDED_HEADER_LENGTH);\n  } else {\n    /* Minimal header */\n    flags_to_filters(flags, context->filters);\n    bstarts = (int32_t*)(_src + BLOSC_MIN_HEADER_LENGTH);\n  }\n\n  // Some checks for malformed buffers\n  if (blocksize <= 0 || blocksize > nbytes || typesize <= 0 || typesize > BLOSC_MAX_TYPESIZE) {\n    return -1;\n  }\n\n  /* Compute some params */\n  /* Total blocks */\n  nblocks = nbytes / blocksize;\n  leftover = nbytes % blocksize;\n  nblocks = (leftover > 0) ? nblocks + 1 : nblocks;\n\n  /* Check region boundaries */\n  if ((start < 0) || (start * typesize > nbytes)) {\n    fprintf(stderr, \"`start` out of bounds\");\n    return -1;\n  }\n\n  if ((stop < 0) || (stop * typesize > nbytes)) {\n    fprintf(stderr, \"`start`+`nitems` out of bounds\");\n    return -1;\n  }\n\n  if (_src + srcsize < (uint8_t *)(bstarts + nblocks)) {\n    /* Not enough input to read all `bstarts` */\n    return -1;\n  }\n\n  for (j = 0; j < nblocks; j++) {\n    bsize = blocksize;\n    leftoverblock = 0;\n    if ((j == nblocks - 1) && (leftover > 0)) {\n      bsize = leftover;\n      leftoverblock = 1;\n    }\n\n    /* Compute start & stop for each block */\n    startb = start * (int)typesize - j * (int)blocksize;\n    stopb = stop * (int)typesize - j * (int)blocksize;\n    if ((startb >= (int)blocksize) || (stopb <= 0)) {\n      continue;\n    }\n    if (startb < 0) {\n      startb = 0;\n    }\n    if (stopb > (int)blocksize) {\n      stopb = (int)blocksize;\n    }\n    bsize2 = stopb - startb;\n\n    /* Do the actual data copy */\n    if (memcpyed) {\n      // Check that sizes in header are compatible, otherwise there is a header corruption\n      if (nbytes + BLOSC_MAX_OVERHEAD != cbytes) {\n         return -1;\n      }\n      if (srcsize < BLOSC_MAX_OVERHEAD + j * blocksize + startb + bsize2) {\n        /* Not enough input to copy data */\n        return -1;\n      }\n      memcpy((uint8_t*)dest + ntbytes,\n             (uint8_t*)src + BLOSC_MAX_OVERHEAD + j * blocksize + startb,\n             (unsigned int)bsize2);\n      cbytes = (int)bsize2;\n    }\n    else {\n      struct thread_context* scontext = context->serial_context;\n\n      /* Resize the temporaries in serial context if needed */\n      if (blocksize != scontext->tmp_blocksize) {\n        my_free(scontext->tmp);\n        scontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;\n        scontext->tmp = my_malloc(scontext->tmp_nbytes);\n        scontext->tmp2 = scontext->tmp + blocksize;\n        scontext->tmp3 = scontext->tmp + blocksize + ebsize;\n        scontext->tmp4 = scontext->tmp + 2 * blocksize + ebsize;\n        scontext->tmp_blocksize = (int32_t)blocksize;\n      }\n\n      // Regular decompression.  Put results in tmp2.\n      // If the block is aligned and the worst case fits in destination, let's avoid a copy\n      bool get_single_block = ((startb == 0) && (bsize == nitems * typesize));\n      uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;\n      cbytes = blosc_d(context->serial_context, bsize, leftoverblock,\n                       src, srcsize, sw32_(bstarts + j),\n                       tmp2, 0, scontext->tmp, scontext->tmp3);\n      if (cbytes < 0) {\n        ntbytes = cbytes;\n        break;\n      }\n      if (!get_single_block) {\n        /* Copy to destination */\n        memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);\n      }\n      cbytes = (int)bsize2;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}\n\n\n/* Specific routine optimized for decompression a small number of\n   items out of a compressed chunk.  Public non-contextual API. */\nint blosc_getitem(const void* src, int start, int nitems, void* dest) {\n  uint8_t* _src = (uint8_t*)(src);\n  blosc2_context context;\n  int result;\n\n  uint8_t version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    return -1;\n  }\n\n  /* Minimally populate the context */\n  memset(&context, 0, sizeof(blosc2_context));\n  context.src = src;\n  context.dest = dest;\n  context.typesize = (uint8_t)_src[3];\n  context.blocksize = sw32_(_src + 8);\n  context.header_flags = *(_src + 2);\n  context.filter_flags = get_filter_flags(context.header_flags, context.typesize);\n  context.schunk = g_schunk;\n  context.nthreads = 1;  // force a serial decompression; fixes #95\n  context.serial_context = create_thread_context(&context, 0);\n\n  /* Call the actual getitem function */\n  result = _blosc_getitem(&context, src, INT32_MAX, start, nitems, dest);\n\n  /* Release resources */\n  free_thread_context(context.serial_context);\n  return result;\n}\n\nint blosc2_getitem_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n    int start, int nitems, void* dest) {\n  uint8_t* _src = (uint8_t*)(src);\n  int result;\n\n  /* Minimally populate the context */\n  context->typesize = (uint8_t)_src[3];\n  context->blocksize = sw32_(_src + 8);\n  context->header_flags = *(_src + 2);\n  context->filter_flags = get_filter_flags(*(_src + 2), context->typesize);\n  if (context->serial_context == NULL) {\n    context->serial_context = create_thread_context(context, 0);\n  }\n\n  /* Call the actual getitem function */\n  result = _blosc_getitem(context, src, srcsize, start, nitems, dest);\n\n  return result;\n}\n\n/* execute single compression/decompression job for a single thread_context */\nstatic void t_blosc_do_job(void *ctxt)\n{\n  struct thread_context* thcontext = (struct thread_context*)ctxt;\n  blosc2_context* context = thcontext->parent_context;\n  int32_t cbytes;\n  int32_t ntdest;\n  int32_t tblocks;               /* number of blocks per thread */\n  int32_t tblock;                /* limit block on a thread */\n  int32_t nblock_;              /* private copy of nblock */\n  int32_t bsize;\n  int32_t leftoverblock;\n  /* Parameters for threads */\n  int32_t blocksize;\n  int32_t ebsize;\n  int32_t srcsize;\n  bool compress = context->do_compress != 0;\n  int32_t maxbytes;\n  int32_t nblocks;\n  int32_t leftover;\n  int32_t leftover2;\n  int32_t* bstarts;\n  const uint8_t* src;\n  uint8_t* dest;\n  uint8_t* tmp;\n  uint8_t* tmp2;\n  uint8_t* tmp3;\n\n  /* Get parameters for this thread before entering the main loop */\n  blocksize = context->blocksize;\n  ebsize = blocksize + context->typesize * sizeof(int32_t);\n  maxbytes = context->destsize;\n  nblocks = context->nblocks;\n  leftover = context->leftover;\n  bstarts = context->bstarts;\n  src = context->src;\n  srcsize = context->srcsize;\n  dest = context->dest;\n\n  /* Resize the temporaries if needed */\n  if (blocksize != thcontext->tmp_blocksize) {\n    my_free(thcontext->tmp);\n    thcontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;\n    thcontext->tmp = my_malloc(thcontext->tmp_nbytes);\n    thcontext->tmp2 = thcontext->tmp + blocksize;\n    thcontext->tmp3 = thcontext->tmp + blocksize + ebsize;\n    thcontext->tmp4 = thcontext->tmp + 2 * blocksize + ebsize;\n    thcontext->tmp_blocksize = blocksize;\n  }\n\n  tmp = thcontext->tmp;\n  tmp2 = thcontext->tmp2;\n  tmp3 = thcontext->tmp3;\n\n  // Determine whether we can do a static distribution of workload among different threads\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  bool static_schedule = (!compress || memcpyed) && context->block_maskout == NULL;\n  if (static_schedule) {\n      /* Blocks per thread */\n      tblocks = nblocks / context->nthreads;\n      leftover2 = nblocks % context->nthreads;\n      tblocks = (leftover2 > 0) ? tblocks + 1 : tblocks;\n      nblock_ = thcontext->tid * tblocks;\n      tblock = nblock_ + tblocks;\n      if (tblock > nblocks) {\n          tblock = nblocks;\n      }\n  }\n  else {\n    // Use dynamic schedule via a queue.  Get the next block.\n    pthread_mutex_lock(&context->count_mutex);\n    context->thread_nblock++;\n    nblock_ = context->thread_nblock;\n    pthread_mutex_unlock(&context->count_mutex);\n    tblock = nblocks;\n  }\n\n  /* Loop over blocks */\n  leftoverblock = 0;\n  while ((nblock_ < tblock) && (context->thread_giveup_code > 0)) {\n    bsize = blocksize;\n    if (nblock_ == (nblocks - 1) && (leftover > 0)) {\n      bsize = leftover;\n      leftoverblock = 1;\n    }\n    if (compress) {\n      if (memcpyed) {\n        if (!context->prefilter) {\n          /* We want to memcpy only */\n          memcpy(dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,\n                 src + nblock_ * blocksize, (unsigned int) bsize);\n          cbytes = (int32_t) bsize;\n        }\n        else {\n          /* Only the prefilter has to be executed, and this is done in blosc_c().\n           * However, no further actions are needed, so we can put the result\n           * directly in dest. */\n          cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,\n                           ebsize, src, nblock_ * blocksize,\n                           dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,\n                           tmp, tmp3);\n        }\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,\n                          ebsize, src, nblock_ * blocksize, tmp2, tmp, tmp3);\n      }\n    }\n    else {\n      if (memcpyed) {\n        /* We want to memcpy only */\n        if (srcsize < BLOSC_MAX_OVERHEAD + (nblock_ * blocksize) + bsize) {\n          /* Not enough input to copy data */\n\n          cbytes = -1;\n        } else {\n          memcpy(dest + nblock_ * blocksize,\n                  src + BLOSC_MAX_OVERHEAD + nblock_ * blocksize, (unsigned int)bsize);\n          cbytes = (int32_t)bsize;\n        }\n      }\n      else {\n        if (srcsize < (int32_t)(BLOSC_MAX_OVERHEAD + (sizeof(int32_t) * nblocks))) {\n          /* Not enough input to read all `bstarts` */\n          cbytes = -1;\n        } else {\n          cbytes = blosc_d(thcontext, bsize, leftoverblock,\n                            src, srcsize, sw32_(bstarts + nblock_),\n                            dest, nblock_ * blocksize, tmp, tmp2);\n        }\n      }\n    }\n\n    /* Check whether current thread has to giveup */\n    if (context->thread_giveup_code <= 0) {\n      break;\n    }\n\n    /* Check results for the compressed/decompressed block */\n    if (cbytes < 0) {            /* compr/decompr failure */\n      /* Set giveup_code error */\n      pthread_mutex_lock(&context->count_mutex);\n      context->thread_giveup_code = cbytes;\n      pthread_mutex_unlock(&context->count_mutex);\n      break;\n    }\n\n    if (compress && !memcpyed) {\n      /* Start critical section */\n      pthread_mutex_lock(&context->count_mutex);\n      ntdest = context->output_bytes;\n      // Note: do not use a typical local dict_training variable here\n      // because it is probably cached from previous calls if the number of\n      // threads does not change (the usual thing).\n      if (!(context->use_dict && context->dict_cdict == NULL)) {\n        _sw32(bstarts + nblock_, (int32_t) ntdest);\n      }\n\n      if ((cbytes == 0) || (ntdest + cbytes > maxbytes)) {\n        context->thread_giveup_code = 0;  /* uncompressible buf */\n        pthread_mutex_unlock(&context->count_mutex);\n        break;\n      }\n      context->thread_nblock++;\n      nblock_ = context->thread_nblock;\n      context->output_bytes += cbytes;\n      pthread_mutex_unlock(&context->count_mutex);\n      /* End of critical section */\n\n      /* Copy the compressed buffer to destination */\n      memcpy(dest + ntdest, tmp2, (unsigned int) cbytes);\n    }\n    else if (static_schedule) {\n      nblock_++;\n    }\n    else {\n      pthread_mutex_lock(&context->count_mutex);\n      context->thread_nblock++;\n      nblock_ = context->thread_nblock;\n      context->output_bytes += cbytes;\n      pthread_mutex_unlock(&context->count_mutex);\n    }\n\n  } /* closes while (nblock_) */\n\n  if (static_schedule) {\n    context->output_bytes = context->sourcesize;\n    if (compress) {\n      context->output_bytes += BLOSC_MAX_OVERHEAD;\n    }\n  }\n\n}\n\n/* Decompress & unshuffle several blocks in a single thread */\nstatic void* t_blosc(void* ctxt) {\n  struct thread_context* thcontext = (struct thread_context*)ctxt;\n  blosc2_context* context = thcontext->parent_context;\n#ifdef BLOSC_POSIX_BARRIERS\n  int rc;\n#endif\n\n  while (1) {\n    /* Synchronization point for all threads (wait for initialization) */\n    WAIT_INIT(NULL, context);\n\n    if (context->end_threads) {\n      break;\n    }\n\n    t_blosc_do_job(ctxt);\n\n    /* Meeting point for all threads (wait for finalization) */\n    WAIT_FINISH(NULL, context);\n  }\n\n  /* Cleanup our working space and context */\n  free_thread_context(thcontext);\n\n  return (NULL);\n}\n\n\nint init_threadpool(blosc2_context *context) {\n  int32_t tid;\n  int rc2;\n\n  /* Initialize mutex and condition variable objects */\n  pthread_mutex_init(&context->count_mutex, NULL);\n  pthread_mutex_init(&context->delta_mutex, NULL);\n  pthread_cond_init(&context->delta_cv, NULL);\n\n  /* Set context thread sentinels */\n  context->thread_giveup_code = 1;\n  context->thread_nblock = -1;\n\n  /* Barrier initialization */\n#ifdef BLOSC_POSIX_BARRIERS\n  pthread_barrier_init(&context->barr_init, NULL, context->nthreads + 1);\n  pthread_barrier_init(&context->barr_finish, NULL, context->nthreads + 1);\n#else\n  pthread_mutex_init(&context->count_threads_mutex, NULL);\n  pthread_cond_init(&context->count_threads_cv, NULL);\n  context->count_threads = 0;      /* Reset threads counter */\n#endif\n\n  if (threads_callback) {\n      /* Create thread contexts to store data for callback threads */\n    context->thread_contexts = (struct thread_context *)my_malloc(\n            context->nthreads * sizeof(struct thread_context));\n    for (tid = 0; tid < context->nthreads; tid++)\n      init_thread_context(context->thread_contexts + tid, context, tid);\n  }\n  else {\n    #if !defined(_WIN32)\n      /* Initialize and set thread detached attribute */\n      pthread_attr_init(&context->ct_attr);\n      pthread_attr_setdetachstate(&context->ct_attr, PTHREAD_CREATE_JOINABLE);\n    #endif\n\n    /* Make space for thread handlers */\n    context->threads = (pthread_t*)my_malloc(\n            context->nthreads * sizeof(pthread_t));\n    /* Finally, create the threads */\n    for (tid = 0; tid < context->nthreads; tid++) {\n      /* Create a thread context (will destroy when finished) */\n      struct thread_context *thread_context = create_thread_context(context, tid);\n\n      #if !defined(_WIN32)\n        rc2 = pthread_create(&context->threads[tid], &context->ct_attr, t_blosc,\n                            (void*)thread_context);\n      #else\n        rc2 = pthread_create(&context->threads[tid], NULL, t_blosc,\n                            (void *)thread_context);\n      #endif\n      if (rc2) {\n        fprintf(stderr, \"ERROR; return code from pthread_create() is %d\\n\", rc2);\n        fprintf(stderr, \"\\tError detail: %s\\n\", strerror(rc2));\n        return (-1);\n      }\n    }\n  }\n\n  /* We have now started/initialized the threads */\n  context->threads_started = context->nthreads;\n  context->new_nthreads = context->nthreads;\n\n  return (0);\n}\n\nint blosc_get_nthreads(void)\n{\n  return g_nthreads;\n}\n\nint blosc_set_nthreads(int nthreads_new) {\n  int ret = g_nthreads;          /* the previous number of threads */\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n if (nthreads_new != ret) {\n   g_nthreads = nthreads_new;\n   g_global_context->new_nthreads = nthreads_new;\n   check_nthreads(g_global_context);\n }\n\n  return ret;\n}\n\n\nconst char* blosc_get_compressor(void)\n{\n  const char* compname;\n  blosc_compcode_to_compname(g_compressor, &compname);\n\n  return compname;\n}\n\nint blosc_set_compressor(const char* compname) {\n  int code = blosc_compname_to_compcode(compname);\n\n  g_compressor = code;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  return code;\n}\n\nvoid blosc_set_delta(int dodelta) {\n\n  g_delta = dodelta;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n}\n\nconst char* blosc_list_compressors(void) {\n  static int compressors_list_done = 0;\n  static char ret[256];\n\n  if (compressors_list_done) return ret;\n  ret[0] = '\\0';\n  strcat(ret, BLOSC_BLOSCLZ_COMPNAME);\n#if defined(HAVE_LZ4)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_LZ4_COMPNAME);\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_LZ4HC_COMPNAME);\n#endif /* HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_LIZARD_COMPNAME);\n#endif /* HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_SNAPPY_COMPNAME);\n#endif /* HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_ZLIB_COMPNAME);\n#endif /* HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  strcat(ret, \",\");\n  strcat(ret, BLOSC_ZSTD_COMPNAME);\n#endif /* HAVE_ZSTD */\n  compressors_list_done = 1;\n  return ret;\n}\n\n\nconst char* blosc_get_version_string(void) {\n  return BLOSC_VERSION_STRING;\n}\n\n\nint blosc_get_complib_info(const char* compname, char** complib, char** version) {\n  int clibcode;\n  const char* clibname;\n  const char* clibversion = \"unknown\";\n\n#if (defined(HAVE_LZ4) && defined(LZ4_VERSION_MAJOR)) || \\\n  (defined(HAVE_LIZARD) && defined(LIZARD_VERSION_MAJOR)) || \\\n  (defined(HAVE_SNAPPY) && defined(SNAPPY_VERSION)) || \\\n  (defined(HAVE_ZSTD) && defined(ZSTD_VERSION_MAJOR))\n  char sbuffer[256];\n#endif\n\n  clibcode = compname_to_clibcode(compname);\n  clibname = clibcode_to_clibname(clibcode);\n\n  /* complib version */\n  if (clibcode == BLOSC_BLOSCLZ_LIB) {\n    clibversion = BLOSCLZ_VERSION_STRING;\n  }\n#if defined(HAVE_LZ4)\n  else if (clibcode == BLOSC_LZ4_LIB) {\n#if defined(LZ4_VERSION_MAJOR)\n    sprintf(sbuffer, \"%d.%d.%d\",\n            LZ4_VERSION_MAJOR, LZ4_VERSION_MINOR, LZ4_VERSION_RELEASE);\n    clibversion = sbuffer;\n#endif /* LZ4_VERSION_MAJOR */\n  }\n#endif /* HAVE_LZ4 */\n#if defined(HAVE_LIZARD)\n  else if (clibcode == BLOSC_LIZARD_LIB) {\n    sprintf(sbuffer, \"%d.%d.%d\",\n            LIZARD_VERSION_MAJOR, LIZARD_VERSION_MINOR, LIZARD_VERSION_RELEASE);\n    clibversion = sbuffer;\n  }\n#endif /* HAVE_LIZARD */\n#if defined(HAVE_SNAPPY)\n  else if (clibcode == BLOSC_SNAPPY_LIB) {\n#if defined(SNAPPY_VERSION)\n    sprintf(sbuffer, \"%d.%d.%d\", SNAPPY_MAJOR, SNAPPY_MINOR, SNAPPY_PATCHLEVEL);\n    clibversion = sbuffer;\n#endif /* SNAPPY_VERSION */\n  }\n#endif /* HAVE_SNAPPY */\n#if defined(HAVE_ZLIB)\n  else if (clibcode == BLOSC_ZLIB_LIB) {\n    clibversion = ZLIB_VERSION;\n  }\n#endif /* HAVE_ZLIB */\n#if defined(HAVE_ZSTD)\n  else if (clibcode == BLOSC_ZSTD_LIB) {\n    sprintf(sbuffer, \"%d.%d.%d\",\n            ZSTD_VERSION_MAJOR, ZSTD_VERSION_MINOR, ZSTD_VERSION_RELEASE);\n    clibversion = sbuffer;\n  }\n#endif /* HAVE_ZSTD */\n\n#ifdef _MSC_VER\n  *complib = _strdup(clibname);\n  *version = _strdup(clibversion);\n#else\n  *complib = strdup(clibname);\n  *version = strdup(clibversion);\n#endif\n  return clibcode;\n}\n\n/* Return `nbytes`, `cbytes` and `blocksize` from a compressed buffer. */\nvoid blosc_cbuffer_sizes(const void* cbuffer, size_t* nbytes,\n                         size_t* cbytes, size_t* blocksize) {\n  uint8_t* _src = (uint8_t*)(cbuffer);    /* current pos for source buffer */\n  uint8_t version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    *nbytes = *blocksize = *cbytes = 0;\n    return;\n  }\n\n  /* Read the interesting values */\n  *nbytes = (size_t)sw32_(_src + 4);       /* uncompressed buffer size */\n  *blocksize = (size_t)sw32_(_src + 8);    /* block size */\n  *cbytes = (size_t)sw32_(_src + 12);      /* compressed buffer size */\n}\n\nint blosc_cbuffer_validate(const void* cbuffer, size_t cbytes, size_t* nbytes) {\n  size_t header_cbytes, header_blocksize;\n  if (cbytes < BLOSC_MIN_HEADER_LENGTH) {\n    /* Compressed data should contain enough space for header */\n    *nbytes = 0;\n    return -1;\n  }\n  blosc_cbuffer_sizes(cbuffer, nbytes, &header_cbytes, &header_blocksize);\n  if (header_cbytes != cbytes) {\n    /* Compressed size from header does not match `cbytes` */\n    *nbytes = 0;\n    return -1;\n  }\n  if (*nbytes > BLOSC_MAX_BUFFERSIZE) {\n    /* Uncompressed size is larger than allowed */\n    return -1;\n  }\n  return 0;\n}\n\n/* Return `typesize` and `flags` from a compressed buffer. */\nvoid blosc_cbuffer_metainfo(const void* cbuffer, size_t* typesize, int* flags) {\n  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */\n  uint8_t version = _src[0];                        /* blosc format version */\n  if (version > BLOSC_VERSION_FORMAT) {\n    /* Version from future */\n    *flags = 0;\n    *typesize = 0;\n    return;\n  }\n\n  /* Read the interesting values */\n  *flags = (int)_src[2];                 /* flags */\n  *typesize = (size_t)_src[3];           /* typesize */\n}\n\n\n/* Return version information from a compressed buffer. */\nvoid blosc_cbuffer_versions(const void* cbuffer, int* version,\n                            int* versionlz) {\n  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */\n\n  /* Read the version info */\n  *version = (int)_src[0];         /* blosc format version */\n  *versionlz = (int)_src[1];       /* Lempel-Ziv compressor format version */\n}\n\n\n/* Return the compressor library/format used in a compressed buffer. */\nconst char* blosc_cbuffer_complib(const void* cbuffer) {\n  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */\n  int clibcode;\n  const char* complib;\n\n  /* Read the compressor format/library info */\n  clibcode = (_src[2] & 0xe0) >> 5;\n  complib = clibcode_to_clibname(clibcode);\n  return complib;\n}\n\n\n/* Get the internal blocksize to be used during compression.  0 means\n   that an automatic blocksize is computed internally. */\nint blosc_get_blocksize(void)\n{\n  return (int)g_force_blocksize;\n}\n\n\n/* Force the use of a specific blocksize.  If 0, an automatic\n   blocksize will be used (the default). */\nvoid blosc_set_blocksize(size_t size) {\n  g_force_blocksize = (int32_t)size;\n}\n\n\n/* Set pointer to super-chunk.  If NULL, no super-chunk will be\n   reachable (the default). */\nvoid blosc_set_schunk(blosc2_schunk* schunk) {\n  g_schunk = schunk;\n  g_global_context->schunk = schunk;\n}\n\n\nvoid blosc_init(void) {\n  /* Return if Blosc is already initialized */\n  if (g_initlib) return;\n\n  pthread_mutex_init(&global_comp_mutex, NULL);\n  /* Create a global context */\n  g_global_context = (blosc2_context*)my_malloc(sizeof(blosc2_context));\n  memset(g_global_context, 0, sizeof(blosc2_context));\n  g_global_context->nthreads = g_nthreads;\n  g_global_context->new_nthreads = g_nthreads;\n  g_initlib = 1;\n}\n\n\nvoid blosc_destroy(void) {\n  /* Return if Blosc is not initialized */\n  if (!g_initlib) return;\n\n  g_initlib = 0;\n  release_threadpool(g_global_context);\n  if (g_global_context->serial_context != NULL) {\n    free_thread_context(g_global_context->serial_context);\n  }\n  my_free(g_global_context);\n  pthread_mutex_destroy(&global_comp_mutex);\n}\n\n\nint release_threadpool(blosc2_context *context) {\n  int32_t t;\n  void* status;\n  int rc;\n\n  if (context->threads_started > 0) {\n    if (threads_callback) {\n      /* free context data for user-managed threads */\n      for (t=0; t<context->threads_started; t++)\n        destroy_thread_context(context->thread_contexts + t);\n      my_free(context->thread_contexts);\n    }\n    else {\n      /* Tell all existing threads to finish */\n      context->end_threads = 1;\n      WAIT_INIT(-1, context);\n\n      /* Join exiting threads */\n      for (t = 0; t < context->threads_started; t++) {\n        rc = pthread_join(context->threads[t], &status);\n        if (rc) {\n          fprintf(stderr, \"ERROR; return code from pthread_join() is %d\\n\", rc);\n          fprintf(stderr, \"\\tError detail: %s\\n\", strerror(rc));\n        }\n      }\n\n      /* Thread attributes */\n      #if !defined(_WIN32)\n        pthread_attr_destroy(&context->ct_attr);\n      #endif\n\n      /* Release thread handlers */\n      my_free(context->threads);\n    }\n\n    /* Release mutex and condition variable objects */\n    pthread_mutex_destroy(&context->count_mutex);\n    pthread_mutex_destroy(&context->delta_mutex);\n    pthread_cond_destroy(&context->delta_cv);\n\n    /* Barriers */\n  #ifdef BLOSC_POSIX_BARRIERS\n    pthread_barrier_destroy(&context->barr_init);\n    pthread_barrier_destroy(&context->barr_finish);\n  #else\n    pthread_mutex_destroy(&context->count_threads_mutex);\n    pthread_cond_destroy(&context->count_threads_cv);\n    context->count_threads = 0;      /* Reset threads counter */\n  #endif\n\n    /* Reset flags and counters */\n    context->end_threads = 0;\n    context->threads_started = 0;\n  }\n\n\n  return 0;\n}\n\nint blosc_free_resources(void) {\n  /* Return if Blosc is not initialized */\n  if (!g_initlib) return -1;\n\n  return release_threadpool(g_global_context);\n}\n\n\n/* Contexts */\n\n/* Create a context for compression */\nblosc2_context* blosc2_create_cctx(blosc2_cparams cparams) {\n  blosc2_context* context = (blosc2_context*)my_malloc(sizeof(blosc2_context));\n\n  /* Populate the context, using zeros as default values */\n  memset(context, 0, sizeof(blosc2_context));\n  context->do_compress = 1;   /* meant for compression */\n  context->compcode = cparams.compcode;\n  context->clevel = cparams.clevel;\n  context->use_dict = cparams.use_dict;\n  context->typesize = cparams.typesize;\n  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {\n    context->filters[i] = cparams.filters[i];\n    context->filters_meta[i] = cparams.filters_meta[i];\n  }\n  context->nthreads = cparams.nthreads;\n  context->new_nthreads = context->nthreads;\n  context->blocksize = cparams.blocksize;\n  context->threads_started = 0;\n  context->schunk = cparams.schunk;\n\n  if (cparams.prefilter != NULL) {\n    context->prefilter = cparams.prefilter;\n    context->pparams = (blosc2_prefilter_params*)my_malloc(sizeof(blosc2_prefilter_params));\n    memcpy(context->pparams, cparams.pparams, sizeof(blosc2_prefilter_params));\n  }\n\n  return context;\n}\n\n\n/* Create a context for decompression */\nblosc2_context* blosc2_create_dctx(blosc2_dparams dparams) {\n  blosc2_context* context = (blosc2_context*)my_malloc(sizeof(blosc2_context));\n\n  /* Populate the context, using zeros as default values */\n  memset(context, 0, sizeof(blosc2_context));\n  context->do_compress = 0;   /* Meant for decompression */\n  context->nthreads = dparams.nthreads;\n  context->new_nthreads = context->nthreads;\n  context->threads_started = 0;\n  context->block_maskout = NULL;\n  context->block_maskout_nitems = 0;\n  context->schunk = dparams.schunk;\n\n  return context;\n}\n\n\nvoid blosc2_free_ctx(blosc2_context* context) {\n  release_threadpool(context);\n  if (context->serial_context != NULL) {\n    free_thread_context(context->serial_context);\n  }\n  if (context->dict_cdict != NULL) {\n#ifdef HAVE_ZSTD\n    ZSTD_freeCDict(context->dict_cdict);\n#endif\n  }\n  if (context->dict_ddict != NULL) {\n#ifdef HAVE_ZSTD\n    ZSTD_freeDDict(context->dict_ddict);\n#endif\n  }\n  if (context->btune != NULL) {\n    btune_free(context);\n  }\n  if (context->prefilter != NULL) {\n    my_free(context->pparams);\n  }\n\n  if (context->block_maskout != NULL) {\n    free(context->block_maskout);\n  }\n\n  my_free(context);\n}\n\n\n/* Set a maskout in decompression context */\nint blosc2_set_maskout(blosc2_context *ctx, bool *maskout, int nblocks) {\n\n  if (ctx->block_maskout != NULL) {\n    // Get rid of a possible mask here\n    free(ctx->block_maskout);\n  }\n\n  bool *maskout_ = malloc(nblocks);\n  memcpy(maskout_, maskout, nblocks);\n  ctx->block_maskout = maskout_;\n  ctx->block_maskout_nitems = nblocks;\n\n  return 0;\n}\n"], "filenames": ["blosc/blosc2.c"], "buggy_code_start_loc": [709], "buggy_code_end_loc": [863], "fixing_code_start_loc": [709], "fixing_code_end_loc": [867], "type": "CWE-787", "message": "blosc2.c in Blosc C-Blosc2 through 2.0.0.beta.5 has a heap-based buffer overflow when there is a lack of space to write compressed data.", "other": {"cve": {"id": "CVE-2020-29367", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-27T20:15:11.090", "lastModified": "2020-12-03T20:58:00.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "blosc2.c in Blosc C-Blosc2 through 2.0.0.beta.5 has a heap-based buffer overflow when there is a lack of space to write compressed data."}, {"lang": "es", "value": "El archivo blosc2.c en Blosc C-Blosc2 hasta versi\u00f3n 2.0.0.beta.5. presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria cuando carece de espacio para escribir datos comprimidos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:a2:*:*:*:*:*:*", "matchCriteriaId": "F38E7F84-C0DD-4A66-8D73-2644234A96FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:a3:*:*:*:*:*:*", "matchCriteriaId": "73549200-288F-41FD-8B92-DDDFC4C69C29"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:a4:*:*:*:*:*:*", "matchCriteriaId": "D28CA7AD-5034-4754-9F95-155967E07FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:a5:*:*:*:*:*:*", "matchCriteriaId": "6A429AC4-C03D-45DF-ADF9-1BC853C03AF1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "89600A69-9878-4ACB-84B4-4363F14FC348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "579AD92B-4D68-4986-B0CD-24ABB767EABE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "A9AA58E0-C130-43D6-A1A4-881840BEE51E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "B426166C-73BC-4234-8796-6D572177C9E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:2.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "6761509F-D81C-4E57-B9B1-F55460A9BA27"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26442", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/Blosc/c-blosc2/commit/c4c6470e88210afc95262c8b9fcc27e30ca043ee", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Blosc/c-blosc2/commit/c4c6470e88210afc95262c8b9fcc27e30ca043ee"}}