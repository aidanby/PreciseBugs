{"buggy_code": ["/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.settings.metadata.predefined\");\npimcore.settings.metadata.predefined = Class.create({\n\n    initialize: function () {\n        this.getTabPanel();\n    },\n\n    activate: function () {\n        var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n        tabPanel.setActiveItem(\"predefined_metadata\");\n    },\n\n    getTabPanel: function () {\n\n        if (!this.panel) {\n            this.panel = new Ext.Panel({\n                id: \"predefined_metadata\",\n                title: t(\"predefined_metadata_definitions\"),\n                iconCls: \"pimcore_icon_metadata\",\n                border: false,\n                layout: \"fit\",\n                closable:true,\n                items: [this.getRowEditor()]\n            });\n\n            var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n            tabPanel.add(this.panel);\n            tabPanel.setActiveItem(\"predefined_metadata\");\n\n\n            this.panel.on(\"destroy\", function () {\n                pimcore.globalmanager.remove(\"predefined_metadata\");\n            }.bind(this));\n\n            pimcore.layout.refresh();\n        }\n\n        return this.panel;\n    },\n\n    getRowEditor: function () {\n        var url = Routing.generate('pimcore_admin_settings_metadata');\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            url,\n            [\n                'id',\n                {\n                    name: 'name',\n                    allowBlank: false,\n                    convert: function (v, r) {\n                        return v.replace(/[~]/g, \"---\");\n                    }\n                },\n                'description','type',\n                {name: 'data',\n                    convert: function (v, r) {\n                        let dataType = r.data.type;\n                        if (typeof pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData === \"function\") {\n                            v = pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData(v, r);\n                        }\n                        return v;\n                    }\n                },'config', 'targetSubtype', 'language', 'creationDate' ,'modificationDate'\n            ], null, {\n                remoteSort: false,\n                remoteFilter: false\n            }\n        );\n\n        this.store.getProxy().getReader().setMessageProperty('message');\n        this.store.getProxy().on('exception', function (proxy, response, operation) {\n            pimcore.helpers.showNotification(t(\"error\"), t(operation.getError()), \"error\");\n            this.store.load();\n        }.bind(this));\n\n        this.store.addListener('exception', function(proxy, mode, action, options, response) {\n            Ext.Msg.show({\n                title: t(\"error\"),\n                msg: t(response.raw.message),\n                buttons: Ext.Msg.OK,\n                animEl: 'elId',\n                icon: Ext.MessageBox.ERROR\n            });\n        });\n\n        this.filterField = new Ext.form.TextField({\n            xtype: \"textfield\",\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            listeners: {\n                \"keydown\" : function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.filter = input.getValue();\n                        this.store.load();\n                    }\n                }.bind(this)\n            }\n        });\n\n\n        var languagestore = [[\"\",t(\"none\")]];\n        for (let i=0; i<pimcore.settings.websiteLanguages.length; i++) {\n            languagestore.push([pimcore.settings.websiteLanguages[i],pimcore.settings.websiteLanguages[i]]);\n        }\n\n        var supportedTypes = pimcore.helpers.getAssetMetadataDataTypes(\"predefined\");\n        var typeStore = [];\n\n        for (let i = 0; i < supportedTypes.length; i++) {\n            let type = supportedTypes[i];\n            typeStore.push([type, t(type)]);\n        }\n\n        var metadataColumns = [\n            {\n                text: t(\"type\"),\n                dataIndex: 'type',\n                editable: false,\n                width: 40,\n                renderer: this.getTypeRenderer.bind(this),\n                sortable: true\n            },\n            {text: t(\"name\"), width: 200, sortable: true, dataIndex: 'name',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {text: t(\"group\"), width: 200, sortable: true, dataIndex: 'group',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {text: t(\"description\"), sortable: true, dataIndex: 'description',\n                getEditor: function() { return new Ext.form.TextArea({}); },\n                renderer: function (value, metaData, record, rowIndex, colIndex, store) {\n                    if (empty(value)) {\n                        return \"\";\n                    }\n                    return nl2br(Ext.util.Format.htmlEncode(value));\n                }\n            },\n            {text: t(\"type\"), width: 90, sortable: true,\n                dataIndex: 'type',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: false,\n                        store: typeStore\n\n                    })\n                }\n            },\n            {text: t(\"value\"),\n                flex: 510,\n                sortable: true,\n                dataIndex: 'data',\n                editable: true,\n                getEditor: this.getCellEditor.bind(this),\n                renderer: this.getCellRenderer.bind(this)\n            },\n            {text: t(\"configuration\"),\n                width: 100,\n                sortable: false,\n                dataIndex: 'config',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {\n                text: t('language'),\n                sortable: true,\n                dataIndex: \"language\",\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        name: \"language\",\n                        store: languagestore,\n                        editable: false,\n                        triggerAction: 'all',\n                        mode: \"local\"\n                    });\n                },\n                width: 70\n            },\n            {\n                text: t(\"target_subtype\"), width: 80, sortable: true, dataIndex: 'targetSubtype',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: true,\n                        store: [\"image\", \"text\", \"audio\", \"video\", \"document\", \"archive\", \"unknown\"]\n                    });\n                }\n            },\n            {\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 40,\n                items: [{\n                    getClass: function(v, meta, rec) {\n                        var klass = \"pimcore_action_column \";\n                        if(rec.data.writeable) {\n                            klass += \"pimcore_icon_minus\";\n                        }\n                        return klass;\n                    },\n                    tooltip: t('delete'),\n                    handler: function (grid, rowIndex) {\n                        let data = grid.getStore().getAt(rowIndex);\n                        pimcore.helpers.deleteConfirm(t('predefined_metadata'), data.data.name, function () {\n                            grid.getStore().removeAt(rowIndex);\n                        }.bind(this));\n                    }.bind(this)\n                }]\n            },\n            {text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            },\n            {text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            }\n        ];\n\n        this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1,\n            listeners: {\n                beforeedit: function(editor, context, eOpts) {\n                    //need to clear cached editors of cell-editing editor in order to\n                    //enable different editors per row\n                    editor.editors.each(function (e) {\n                        try {\n                            // complete edit, so the value is stored when hopping around with TAB\n                            e.completeEdit();\n                            Ext.destroy(e);\n                        } catch (exception) {\n                            // garbage collector was faster\n                            // already destroyed\n                        }\n                    });\n\n                    editor.editors.clear();\n                },\n                validateedit: function (editor, context, eOpts) {\n                    if (!context.record.data.writeable) {\n                        editor.cancelEdit();\n                        pimcore.helpers.showNotification(t(\"info\"), t(\"config_not_writeable\"), \"info\");\n                        return false;\n                    }\n                }\n            }\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            stripeRows: true,\n            bodyCls: \"pimcore_editable_grid\",\n            trackMouseOver: true,\n            columns: {\n                items: metadataColumns,\n                defaults: {\n                    renderer: Ext.util.Format.htmlEncode\n                },\n            },\n            clicksToEdit: 1,\n            selModel: Ext.create('Ext.selection.CellModel', {}),\n            bbar: this.pagingtoolbar,\n            autoExpandColumn: \"value_col\",\n            plugins: [\n                this.cellEditing\n            ],\n\n            viewConfig: {\n                listeners: {\n                    rowupdated: this.updateRows.bind(this, \"rowupdated\"),\n                    refresh: this.updateRows.bind(this, \"refresh\")\n                },\n                forceFit: true,\n                getRowClass: function (record, rowIndex) {\n                    return record.data.writeable ? '' : 'pimcore_grid_row_disabled';\n                }\n            },\n            tbar: {\n                cls: 'pimcore_main_toolbar',\n                items: [\n                    {\n                        text: t('add'),\n                        handler: this.onAdd.bind(this),\n                        iconCls: \"pimcore_icon_add\",\n                        disabled: !pimcore.settings['predefined-asset-metadata-writeable']\n                    },\"->\",{\n                        text: t(\"filter\") + \"/\" + t(\"search\"),\n                        xtype: \"tbtext\",\n                        style: \"margin: 0 10px 0 0;\"\n                    },\n                    this.filterField\n                ]\n            }\n        });\n\n        this.grid.on(\"viewready\", this.updateRows.bind(this));\n        this.store.on(\"update\", this.updateRows.bind(this));\n\n        return this.grid;\n    },\n\n    getTypeRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        if (value == \"input\") {\n            value = \"text\";\n        }\n        return '<div class=\"pimcore_icon_' + value + '\" recordid=' + record.id + '>&nbsp;</div>';\n    },\n\n    getCellRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n        var data = store.getAt(rowIndex).data;\n        var type = data.type;\n        return pimcore.asset.metadata.tags[type].prototype.getGridCellRenderer(value, metaData, record, rowIndex, colIndex, store);\n    },\n\n    onAdd: function (btn, ev) {\n        var model = this.grid.store.getModel();\n        var newEntry = new model({\n            name: t('new_definition'),\n            key: \"new_key\",\n            subtype: \"image\",\n            type: \"input\"\n        });\n\n        this.grid.store.insert(0, newEntry);\n    },\n\n    updateRows: function (event) {\n        var rows = Ext.get(this.grid.getEl().dom).query(\".x-grid-row\");\n\n        for (let i = 0; i < rows.length; i++) {\n\n            try {\n                var list = Ext.get(rows[i]).query(\".x-grid-cell-first div div\");\n                var firstItem = list[0];\n                if (!firstItem) {\n                    continue;\n                }\n                var recordId = firstItem.getAttribute(\"recordid\");\n                var data = this.grid.getStore().getById(recordId);\n                if (!data) {\n                    continue;\n                }\n\n                data = data.data;\n\n                if(in_array(data.name, this.disallowedKeys)) {\n                    Ext.get(rows[i]).addCls(\"pimcore_properties_hidden_row\");\n                }\n\n                pimcore.asset.metadata.tags[data.type].prototype.updatePredefinedGridRow(this.grid, rows[i], data);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    },\n\n    getCellEditor: function (record) {\n        var data = record.data;\n        var type = data.type;\n        var editor = pimcore.asset.metadata.tags[type].prototype.getGridCellEditor(\"predefined\", record);\n        return editor;\n    }\n});\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.settings.properties.predefined\");\npimcore.settings.properties.predefined = Class.create({\n\n    initialize: function () {\n        this.getTabPanel();\n    },\n\n    activate: function () {\n        var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n        tabPanel.setActiveItem(\"predefined_properties\");\n    },\n\n    getTabPanel: function () {\n\n        if (!this.panel) {\n            this.panel = new Ext.Panel({\n                id: \"predefined_properties\",\n                title: t(\"predefined_properties\"),\n                iconCls: \"pimcore_icon_properties\",\n                border: false,\n                layout: \"fit\",\n                closable:true,\n                items: [this.getRowEditor()]\n            });\n\n            var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n            tabPanel.add(this.panel);\n            tabPanel.setActiveItem(\"predefined_properties\");\n\n\n            this.panel.on(\"destroy\", function () {\n                pimcore.globalmanager.remove(\"predefined_properties\");\n            }.bind(this));\n\n            pimcore.layout.refresh();\n        }\n\n        return this.panel;\n    },\n\n    getRowEditor: function () {\n\n        var url = Routing.generate('pimcore_admin_settings_properties');\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            url,\n            ['id',\n\n                {name: 'name', allowBlank: false},'description',\n                {name: 'key', allowBlank: false},\n                {name: 'type', allowBlank: false}, 'data', 'config',\n                {name: 'ctype', allowBlank: false}, 'inheritable', 'creationDate', 'modificationDate'\n\n            ], null, {\n                remoteSort: false,\n                remoteFilter: false\n            }\n        );\n        this.store.setAutoSync(true);\n\n        this.filterField = new Ext.form.TextField({\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            listeners: {\n                \"keydown\" : function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.filter = input.getValue();\n                        this.store.load();\n                    }\n                }.bind(this)\n            }\n        });\n\n        var inheritableCheck = new Ext.grid.column.Check({\n            text: t(\"inheritable\"),\n            dataIndex: \"inheritable\",\n            editor: {\n                xtype: 'checkbox',\n            },\n            width: 50\n        });\n\n        var contentTypesStore = Ext.create('Ext.data.ArrayStore', {\n            fields: ['value', 'text'],\n            data: [\n                ['document', 'document'],\n                ['asset', 'asset'],\n                ['object', 'object']\n            ],\n            autoLoad: true\n        });\n\n\n        var propertiesColumns = [\n            {text: t(\"name\"), flex: 100, sortable: true, dataIndex: 'name', editor: new Ext.form.TextField({})},\n            {text: t(\"description\"), sortable: true, dataIndex: 'description', editor: new Ext.form.TextArea({}),\n                renderer: function (value, metaData, record, rowIndex, colIndex, store) {\n                    if(empty(value)) {\n                        return \"\";\n                    }\n                    return nl2br(Ext.util.Format.htmlEncode(value));\n               }\n            },\n            {text: t(\"key\"), flex: 50, sortable: true, dataIndex: 'key', editor: new Ext.form.TextField({})},\n            {text: t(\"type\"), flex: 50, sortable: true, dataIndex: 'type',\n                editor: new Ext.form.ComboBox({\n                    triggerAction: 'all',\n                    editable: false,\n                    store: [\"text\",\"document\",\"asset\",\"object\",\"bool\",\"select\"]\n\n            })},\n            {text: t(\"value\"), flex: 50, sortable: true, dataIndex: 'data', editor: new Ext.form.TextField({})},\n            {text: t(\"configuration\"), flex: 50, sortable: false, dataIndex: 'config', editor: new Ext.form.TextField({})},\n            {text: t(\"content_type\"), flex: 50, sortable: true, dataIndex: 'ctype',\n                editor: new Ext.ux.form.MultiSelect({\n                    store: new Ext.data.ArrayStore({\n                        fields: ['key', {\n                            name: 'value',\n                            convert: function (v, r) {\n                                if (Array.isArray(v)) {\n                                    return v.join(\";\");\n                                }\n                                return v;\n                            }\n                        }],\n                        data: [\n                            ['document', 'document'],\n                            ['object', ['object']],\n                            ['asset', ['asset']]\n                        ],\n                    }),\n                    displayField: 'key',\n                    valueField: 'value',\n                }),\n            },\n            inheritableCheck,\n            {\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 30,\n                items: [{\n                    getClass: function(v, meta, rec) {\n                      var klass = \"pimcore_action_column \";\n                      if(rec.data.writeable) {\n                          klass += \"pimcore_icon_minus\";\n                      }\n                      return klass;\n                    },\n                    tooltip: t('delete'),\n                    handler: function (grid, rowIndex) {\n                        let data = grid.getStore().getAt(rowIndex);\n                        pimcore.helpers.deleteConfirm(t('predefined_properties'), data.data.name, function () {\n                            grid.getStore().removeAt(rowIndex);\n                        }.bind(this));\n                    }.bind(this)\n                }]\n            },{\n                xtype: 'actioncolumn',\n                menuText: t('translate'),\n                width: 30,\n                items: [{\n                    tooltip: t('translate'),\n                    icon: \"/bundles/pimcoreadmin/img/flat-color-icons/collaboration.svg\",\n                    handler: function(grid, rowIndex){\n                        var rec = grid.getStore().getAt(rowIndex);\n                        try {\n                            pimcore.globalmanager.get(\"translationdomainmanager\").activate(rec.data.name);\n                        } catch (e) {\n                            pimcore.globalmanager.add(\"translationdomainmanager\",\n                                new pimcore.settings.translation.domain(\"admin\", rec.data.name));\n                        }\n                    }.bind(this)\n                }]\n            },\n            {text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return Ext.Date.format(date, \"Y-m-d H:i:s\");\n                    } else {\n                        return \"\";\n                    }\n                }\n            },\n            {text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return Ext.Date.format(date, \"Y-m-d H:i:s\");\n                    } else {\n                        return \"\";\n                    }\n                }\n            }\n\n        ];\n\n        this.rowEditing = Ext.create('Ext.grid.plugin.RowEditing', {\n            clicksToEdit: 1,\n            clicksToMoveEditor: 1,\n            listeners: {\n                beforeedit: function (editor, context, eOpts) {\n                    if (!context.record.data.writeable) {\n                        return false;\n                    }\n                }\n            }\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            bodyCls: \"pimcore_editable_grid\",\n            stripeRows: true,\n            trackMouseOver: true,\n            columns: {\n                items: propertiesColumns,\n                defaults: {\n                    renderer: Ext.util.Format.htmlEncode\n                },\n            },\n            selModel: Ext.create('Ext.selection.RowModel', {}),\n            plugins: [\n                this.rowEditing\n            ],\n            tbar: {\n                cls: 'pimcore_main_toolbar',\n                items: [\n                    {\n                        text: t('add'),\n                        handler: this.onAdd.bind(this),\n                        iconCls: \"pimcore_icon_add\",\n                        disabled: !pimcore.settings['predefined-properties-writeable']\n                    },\"->\",{\n                        text: t(\"filter\") + \"/\" + t(\"search\"),\n                        xtype: \"tbtext\",\n                        style: \"margin: 0 10px 0 0;\"\n                    },\n                    this.filterField\n                ]\n            },\n            viewConfig: {\n                forceFit: true,\n                getRowClass: function (record, rowIndex) {\n                    return record.data.writeable ? '' : 'pimcore_grid_row_disabled';\n                }\n            }\n        });\n\n        return this.grid;\n    },\n\n    onAdd: function (btn, ev) {\n        this.grid.store.insert(0, {\n            name: t('new_property'),\n            key: \"new_key\",\n            ctype: \"document\",\n            type: \"text\"\n        });\n    }\n});\n"], "fixing_code": ["/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.settings.metadata.predefined\");\npimcore.settings.metadata.predefined = Class.create({\n\n    initialize: function () {\n        this.getTabPanel();\n    },\n\n    activate: function () {\n        var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n        tabPanel.setActiveItem(\"predefined_metadata\");\n    },\n\n    getTabPanel: function () {\n\n        if (!this.panel) {\n            this.panel = new Ext.Panel({\n                id: \"predefined_metadata\",\n                title: t(\"predefined_metadata_definitions\"),\n                iconCls: \"pimcore_icon_metadata\",\n                border: false,\n                layout: \"fit\",\n                closable:true,\n                items: [this.getRowEditor()]\n            });\n\n            var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n            tabPanel.add(this.panel);\n            tabPanel.setActiveItem(\"predefined_metadata\");\n\n\n            this.panel.on(\"destroy\", function () {\n                pimcore.globalmanager.remove(\"predefined_metadata\");\n            }.bind(this));\n\n            pimcore.layout.refresh();\n        }\n\n        return this.panel;\n    },\n\n    getRowEditor: function () {\n        var url = Routing.generate('pimcore_admin_settings_metadata');\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            url,\n            [\n                'id',\n                {\n                    name: 'name',\n                    allowBlank: false,\n                    convert: function (v, r) {\n                        return v.replace(/[~]/g, \"---\");\n                    }\n                },\n                'description','type',\n                {name: 'data',\n                    convert: function (v, r) {\n                        let dataType = r.data.type;\n                        if (typeof pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData === \"function\") {\n                            v = pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData(v, r);\n                        }\n                        return v;\n                    }\n                },'config', 'targetSubtype', 'language', 'creationDate' ,'modificationDate'\n            ], null, {\n                remoteSort: false,\n                remoteFilter: false\n            }\n        );\n\n        this.store.getProxy().getReader().setMessageProperty('message');\n        this.store.getProxy().on('exception', function (proxy, response, operation) {\n            pimcore.helpers.showNotification(t(\"error\"), t(operation.getError()), \"error\");\n            this.store.load();\n        }.bind(this));\n\n        this.store.addListener('exception', function(proxy, mode, action, options, response) {\n            Ext.Msg.show({\n                title: t(\"error\"),\n                msg: t(response.raw.message),\n                buttons: Ext.Msg.OK,\n                animEl: 'elId',\n                icon: Ext.MessageBox.ERROR\n            });\n        });\n\n        this.filterField = new Ext.form.TextField({\n            xtype: \"textfield\",\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            listeners: {\n                \"keydown\" : function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.filter = input.getValue();\n                        this.store.load();\n                    }\n                }.bind(this)\n            }\n        });\n\n\n        var languagestore = [[\"\",t(\"none\")]];\n        for (let i=0; i<pimcore.settings.websiteLanguages.length; i++) {\n            languagestore.push([pimcore.settings.websiteLanguages[i],pimcore.settings.websiteLanguages[i]]);\n        }\n\n        var supportedTypes = pimcore.helpers.getAssetMetadataDataTypes(\"predefined\");\n        var typeStore = [];\n\n        for (let i = 0; i < supportedTypes.length; i++) {\n            let type = supportedTypes[i];\n            typeStore.push([type, t(type)]);\n        }\n\n        var metadataColumns = [\n            {\n                text: t(\"type\"),\n                dataIndex: 'type',\n                editable: false,\n                width: 40,\n                renderer: this.getTypeRenderer.bind(this),\n                sortable: true\n            },\n            {text: t(\"name\"), width: 200, sortable: true, dataIndex: 'name',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {text: t(\"group\"), width: 200, sortable: true, dataIndex: 'group',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {text: t(\"description\"), sortable: true, dataIndex: 'description',\n                getEditor: function() { return new Ext.form.TextArea({}); },\n                renderer: function (value, metaData, record, rowIndex, colIndex, store) {\n                    if (empty(value)) {\n                        return \"\";\n                    }\n                    return nl2br(Ext.util.Format.htmlEncode(value));\n                }\n            },\n            {text: t(\"type\"), width: 90, sortable: true,\n                dataIndex: 'type',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: false,\n                        store: typeStore\n\n                    })\n                }\n            },\n            {text: t(\"value\"),\n                flex: 510,\n                sortable: true,\n                dataIndex: 'data',\n                editable: true,\n                getEditor: this.getCellEditor.bind(this),\n                renderer: this.getCellRenderer.bind(this)\n            },\n            {text: t(\"configuration\"),\n                width: 100,\n                sortable: false,\n                dataIndex: 'config',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {\n                text: t('language'),\n                sortable: true,\n                dataIndex: \"language\",\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        name: \"language\",\n                        store: languagestore,\n                        editable: false,\n                        triggerAction: 'all',\n                        mode: \"local\"\n                    });\n                },\n                width: 70\n            },\n            {\n                text: t(\"target_subtype\"), width: 80, sortable: true, dataIndex: 'targetSubtype',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: true,\n                        store: [\"image\", \"text\", \"audio\", \"video\", \"document\", \"archive\", \"unknown\"]\n                    });\n                }\n            },\n            {\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 40,\n                items: [{\n                    getClass: function(v, meta, rec) {\n                        var klass = \"pimcore_action_column \";\n                        if(rec.data.writeable) {\n                            klass += \"pimcore_icon_minus\";\n                        }\n                        return klass;\n                    },\n                    tooltip: t('delete'),\n                    handler: function (grid, rowIndex) {\n                        let data = grid.getStore().getAt(rowIndex);\n                        pimcore.helpers.deleteConfirm(t('predefined_metadata'),\n                            Ext.util.Format.htmlEncode(data.data.name),\n                            function () {\n                            grid.getStore().removeAt(rowIndex);\n                        }.bind(this));\n                    }.bind(this)\n                }]\n            },\n            {text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            },\n            {text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            }\n        ];\n\n        this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1,\n            listeners: {\n                beforeedit: function(editor, context, eOpts) {\n                    //need to clear cached editors of cell-editing editor in order to\n                    //enable different editors per row\n                    editor.editors.each(function (e) {\n                        try {\n                            // complete edit, so the value is stored when hopping around with TAB\n                            e.completeEdit();\n                            Ext.destroy(e);\n                        } catch (exception) {\n                            // garbage collector was faster\n                            // already destroyed\n                        }\n                    });\n\n                    editor.editors.clear();\n                },\n                validateedit: function (editor, context, eOpts) {\n                    if (!context.record.data.writeable) {\n                        editor.cancelEdit();\n                        pimcore.helpers.showNotification(t(\"info\"), t(\"config_not_writeable\"), \"info\");\n                        return false;\n                    }\n                }\n            }\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            stripeRows: true,\n            bodyCls: \"pimcore_editable_grid\",\n            trackMouseOver: true,\n            columns: {\n                items: metadataColumns,\n                defaults: {\n                    renderer: Ext.util.Format.htmlEncode\n                },\n            },\n            clicksToEdit: 1,\n            selModel: Ext.create('Ext.selection.CellModel', {}),\n            bbar: this.pagingtoolbar,\n            autoExpandColumn: \"value_col\",\n            plugins: [\n                this.cellEditing\n            ],\n\n            viewConfig: {\n                listeners: {\n                    rowupdated: this.updateRows.bind(this, \"rowupdated\"),\n                    refresh: this.updateRows.bind(this, \"refresh\")\n                },\n                forceFit: true,\n                getRowClass: function (record, rowIndex) {\n                    return record.data.writeable ? '' : 'pimcore_grid_row_disabled';\n                }\n            },\n            tbar: {\n                cls: 'pimcore_main_toolbar',\n                items: [\n                    {\n                        text: t('add'),\n                        handler: this.onAdd.bind(this),\n                        iconCls: \"pimcore_icon_add\",\n                        disabled: !pimcore.settings['predefined-asset-metadata-writeable']\n                    },\"->\",{\n                        text: t(\"filter\") + \"/\" + t(\"search\"),\n                        xtype: \"tbtext\",\n                        style: \"margin: 0 10px 0 0;\"\n                    },\n                    this.filterField\n                ]\n            }\n        });\n\n        this.grid.on(\"viewready\", this.updateRows.bind(this));\n        this.store.on(\"update\", this.updateRows.bind(this));\n\n        return this.grid;\n    },\n\n    getTypeRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        if (value == \"input\") {\n            value = \"text\";\n        }\n        return '<div class=\"pimcore_icon_' + value + '\" recordid=' + record.id + '>&nbsp;</div>';\n    },\n\n    getCellRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n        var data = store.getAt(rowIndex).data;\n        var type = data.type;\n        return pimcore.asset.metadata.tags[type].prototype.getGridCellRenderer(value, metaData, record, rowIndex, colIndex, store);\n    },\n\n    onAdd: function (btn, ev) {\n        var model = this.grid.store.getModel();\n        var newEntry = new model({\n            name: t('new_definition'),\n            key: \"new_key\",\n            subtype: \"image\",\n            type: \"input\"\n        });\n\n        this.grid.store.insert(0, newEntry);\n    },\n\n    updateRows: function (event) {\n        var rows = Ext.get(this.grid.getEl().dom).query(\".x-grid-row\");\n\n        for (let i = 0; i < rows.length; i++) {\n\n            try {\n                var list = Ext.get(rows[i]).query(\".x-grid-cell-first div div\");\n                var firstItem = list[0];\n                if (!firstItem) {\n                    continue;\n                }\n                var recordId = firstItem.getAttribute(\"recordid\");\n                var data = this.grid.getStore().getById(recordId);\n                if (!data) {\n                    continue;\n                }\n\n                data = data.data;\n\n                if(in_array(data.name, this.disallowedKeys)) {\n                    Ext.get(rows[i]).addCls(\"pimcore_properties_hidden_row\");\n                }\n\n                pimcore.asset.metadata.tags[data.type].prototype.updatePredefinedGridRow(this.grid, rows[i], data);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    },\n\n    getCellEditor: function (record) {\n        var data = record.data;\n        var type = data.type;\n        var editor = pimcore.asset.metadata.tags[type].prototype.getGridCellEditor(\"predefined\", record);\n        return editor;\n    }\n});\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.settings.properties.predefined\");\npimcore.settings.properties.predefined = Class.create({\n\n    initialize: function () {\n        this.getTabPanel();\n    },\n\n    activate: function () {\n        var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n        tabPanel.setActiveItem(\"predefined_properties\");\n    },\n\n    getTabPanel: function () {\n\n        if (!this.panel) {\n            this.panel = new Ext.Panel({\n                id: \"predefined_properties\",\n                title: t(\"predefined_properties\"),\n                iconCls: \"pimcore_icon_properties\",\n                border: false,\n                layout: \"fit\",\n                closable:true,\n                items: [this.getRowEditor()]\n            });\n\n            var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n            tabPanel.add(this.panel);\n            tabPanel.setActiveItem(\"predefined_properties\");\n\n\n            this.panel.on(\"destroy\", function () {\n                pimcore.globalmanager.remove(\"predefined_properties\");\n            }.bind(this));\n\n            pimcore.layout.refresh();\n        }\n\n        return this.panel;\n    },\n\n    getRowEditor: function () {\n\n        var url = Routing.generate('pimcore_admin_settings_properties');\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            url,\n            ['id',\n\n                {name: 'name', allowBlank: false},'description',\n                {name: 'key', allowBlank: false},\n                {name: 'type', allowBlank: false}, 'data', 'config',\n                {name: 'ctype', allowBlank: false}, 'inheritable', 'creationDate', 'modificationDate'\n\n            ], null, {\n                remoteSort: false,\n                remoteFilter: false\n            }\n        );\n        this.store.setAutoSync(true);\n\n        this.filterField = new Ext.form.TextField({\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            listeners: {\n                \"keydown\" : function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.filter = input.getValue();\n                        this.store.load();\n                    }\n                }.bind(this)\n            }\n        });\n\n        var inheritableCheck = new Ext.grid.column.Check({\n            text: t(\"inheritable\"),\n            dataIndex: \"inheritable\",\n            editor: {\n                xtype: 'checkbox',\n            },\n            width: 50\n        });\n\n        var contentTypesStore = Ext.create('Ext.data.ArrayStore', {\n            fields: ['value', 'text'],\n            data: [\n                ['document', 'document'],\n                ['asset', 'asset'],\n                ['object', 'object']\n            ],\n            autoLoad: true\n        });\n\n\n        var propertiesColumns = [\n            {text: t(\"name\"), flex: 100, sortable: true, dataIndex: 'name', editor: new Ext.form.TextField({})},\n            {text: t(\"description\"), sortable: true, dataIndex: 'description', editor: new Ext.form.TextArea({}),\n                renderer: function (value, metaData, record, rowIndex, colIndex, store) {\n                    if(empty(value)) {\n                        return \"\";\n                    }\n                    return nl2br(Ext.util.Format.htmlEncode(value));\n               }\n            },\n            {text: t(\"key\"), flex: 50, sortable: true, dataIndex: 'key', editor: new Ext.form.TextField({})},\n            {text: t(\"type\"), flex: 50, sortable: true, dataIndex: 'type',\n                editor: new Ext.form.ComboBox({\n                    triggerAction: 'all',\n                    editable: false,\n                    store: [\"text\",\"document\",\"asset\",\"object\",\"bool\",\"select\"]\n\n            })},\n            {text: t(\"value\"), flex: 50, sortable: true, dataIndex: 'data', editor: new Ext.form.TextField({})},\n            {text: t(\"configuration\"), flex: 50, sortable: false, dataIndex: 'config', editor: new Ext.form.TextField({})},\n            {text: t(\"content_type\"), flex: 50, sortable: true, dataIndex: 'ctype',\n                editor: new Ext.ux.form.MultiSelect({\n                    store: new Ext.data.ArrayStore({\n                        fields: ['key', {\n                            name: 'value',\n                            convert: function (v, r) {\n                                if (Array.isArray(v)) {\n                                    return v.join(\";\");\n                                }\n                                return v;\n                            }\n                        }],\n                        data: [\n                            ['document', 'document'],\n                            ['object', ['object']],\n                            ['asset', ['asset']]\n                        ],\n                    }),\n                    displayField: 'key',\n                    valueField: 'value',\n                }),\n            },\n            inheritableCheck,\n            {\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 30,\n                items: [{\n                    getClass: function(v, meta, rec) {\n                      var klass = \"pimcore_action_column \";\n                      if(rec.data.writeable) {\n                          klass += \"pimcore_icon_minus\";\n                      }\n                      return klass;\n                    },\n                    tooltip: t('delete'),\n                    handler: function (grid, rowIndex) {\n                        let data = grid.getStore().getAt(rowIndex);\n                        pimcore.helpers.deleteConfirm(t('predefined_properties'),\n                            Ext.util.Format.htmlEncode(data.data.name),\n                            function () {\n                            grid.getStore().removeAt(rowIndex);\n                        }.bind(this));\n                    }.bind(this)\n                }]\n            },{\n                xtype: 'actioncolumn',\n                menuText: t('translate'),\n                width: 30,\n                items: [{\n                    tooltip: t('translate'),\n                    icon: \"/bundles/pimcoreadmin/img/flat-color-icons/collaboration.svg\",\n                    handler: function(grid, rowIndex){\n                        var rec = grid.getStore().getAt(rowIndex);\n                        try {\n                            pimcore.globalmanager.get(\"translationdomainmanager\").activate(rec.data.name);\n                        } catch (e) {\n                            pimcore.globalmanager.add(\"translationdomainmanager\",\n                                new pimcore.settings.translation.domain(\"admin\", rec.data.name));\n                        }\n                    }.bind(this)\n                }]\n            },\n            {text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return Ext.Date.format(date, \"Y-m-d H:i:s\");\n                    } else {\n                        return \"\";\n                    }\n                }\n            },\n            {text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return Ext.Date.format(date, \"Y-m-d H:i:s\");\n                    } else {\n                        return \"\";\n                    }\n                }\n            }\n\n        ];\n\n        this.rowEditing = Ext.create('Ext.grid.plugin.RowEditing', {\n            clicksToEdit: 1,\n            clicksToMoveEditor: 1,\n            listeners: {\n                beforeedit: function (editor, context, eOpts) {\n                    if (!context.record.data.writeable) {\n                        return false;\n                    }\n                }\n            }\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            bodyCls: \"pimcore_editable_grid\",\n            stripeRows: true,\n            trackMouseOver: true,\n            columns: {\n                items: propertiesColumns,\n                defaults: {\n                    renderer: Ext.util.Format.htmlEncode\n                },\n            },\n            selModel: Ext.create('Ext.selection.RowModel', {}),\n            plugins: [\n                this.rowEditing\n            ],\n            tbar: {\n                cls: 'pimcore_main_toolbar',\n                items: [\n                    {\n                        text: t('add'),\n                        handler: this.onAdd.bind(this),\n                        iconCls: \"pimcore_icon_add\",\n                        disabled: !pimcore.settings['predefined-properties-writeable']\n                    },\"->\",{\n                        text: t(\"filter\") + \"/\" + t(\"search\"),\n                        xtype: \"tbtext\",\n                        style: \"margin: 0 10px 0 0;\"\n                    },\n                    this.filterField\n                ]\n            },\n            viewConfig: {\n                forceFit: true,\n                getRowClass: function (record, rowIndex) {\n                    return record.data.writeable ? '' : 'pimcore_grid_row_disabled';\n                }\n            }\n        });\n\n        return this.grid;\n    },\n\n    onAdd: function (btn, ev) {\n        this.grid.store.insert(0, {\n            name: t('new_property'),\n            key: \"new_key\",\n            ctype: \"document\",\n            type: \"text\"\n        });\n    }\n});\n"], "filenames": ["bundles/AdminBundle/Resources/public/js/pimcore/settings/metadata/predefined.js", "bundles/AdminBundle/Resources/public/js/pimcore/settings/properties/predefined.js"], "buggy_code_start_loc": [218, 168], "buggy_code_end_loc": [219, 169], "fixing_code_start_loc": [218, 168], "fixing_code_end_loc": [221, 171], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Generic in GitHub repository pimcore/pimcore prior to 10.5.20.", "other": {"cve": {"id": "CVE-2023-1702", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-29T16:15:07.283", "lastModified": "2023-04-03T18:21:42.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Generic in GitHub repository pimcore/pimcore prior to 10.5.20."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:H/UI:R/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.6, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.20", "matchCriteriaId": "98C7372B-CF43-42C5-9227-9ED728BF03F5"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/2b997737dd6a60be2239a51dd6d9ef5881568e6d", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/d8a47f29-3297-4fce-b534-e1d95a2b3e19", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/2b997737dd6a60be2239a51dd6d9ef5881568e6d"}}