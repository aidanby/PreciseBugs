{"buggy_code": ["/*\n * Copyright (C) 2015 Martine Lenders <mlenders@inf.fu-berlin.de>\n * Copyright (C) 2015 PHYTEC Messtechnik GmbH\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n *\n * @author      Martine Lenders <mlenders@inf.fu-berlin.de>\n * @author      Johann Fischer <j.fischer@phytec.de> (nhc udp encoding)\n */\n\n#include <stdbool.h>\n\n#include \"byteorder.h\"\n#include \"net/ipv6/hdr.h\"\n#include \"net/ipv6/ext.h\"\n#include \"net/gnrc.h\"\n#include \"net/gnrc/netif/internal.h\"\n#include \"net/gnrc/sixlowpan.h\"\n#include \"net/gnrc/sixlowpan/ctx.h\"\n#include \"net/gnrc/sixlowpan/frag/rb.h\"\n#include \"net/gnrc/sixlowpan/frag/minfwd.h\"\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n#include \"net/gnrc/sixlowpan/frag/sfr.h\"\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n#include \"net/gnrc/sixlowpan/frag/vrb.h\"\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n#include \"net/gnrc/sixlowpan/internal.h\"\n#include \"net/sixlowpan.h\"\n#include \"utlist.h\"\n#include \"net/gnrc/nettype.h\"\n#include \"net/gnrc/udp.h\"\n#include \"od.h\"\n\n#include \"net/gnrc/sixlowpan/iphc.h\"\n\n#define ENABLE_DEBUG 0\n#include \"debug.h\"\n\n/* dispatch byte definitions */\n#define IPHC1_IDX                   (0U)\n#define IPHC2_IDX                   (1U)\n#define CID_EXT_IDX                 (2U)\n\n/* compression values for traffic class and flow label */\n#define IPHC_TF_ECN_DSCP_FL         (0x00)\n#define IPHC_TF_ECN_FL              (0x08)\n#define IPHC_TF_ECN_DSCP            (0x10)\n#define IPHC_TF_ECN_ELIDE           (0x18)\n\n/* compression values for hop limit */\n#define IPHC_HL_INLINE              (0x00)\n#define IPHC_HL_1                   (0x01)\n#define IPHC_HL_64                  (0x02)\n#define IPHC_HL_255                 (0x03)\n\n/* compression values for source address */\n#define IPHC_SAC_SAM_FULL           (0x00)\n#define IPHC_SAC_SAM_64             (0x10)\n#define IPHC_SAC_SAM_16             (0x20)\n#define IPHC_SAC_SAM_L2             (0x30)\n#define IPHC_SAC_SAM_UNSPEC         (0x40)\n#define IPHC_SAC_SAM_CTX_64         (0x50)\n#define IPHC_SAC_SAM_CTX_16         (0x60)\n#define IPHC_SAC_SAM_CTX_L2         (0x70)\n\n/* compression values for destination address */\n#define IPHC_M_DAC_DAM_U_FULL       (0x00)\n#define IPHC_M_DAC_DAM_U_64         (0x01)\n#define IPHC_M_DAC_DAM_U_16         (0x02)\n#define IPHC_M_DAC_DAM_U_L2         (0x03)\n#define IPHC_M_DAC_DAM_U_UNSPEC     (0x04)\n#define IPHC_M_DAC_DAM_U_CTX_64     (0x05)\n#define IPHC_M_DAC_DAM_U_CTX_16     (0x06)\n#define IPHC_M_DAC_DAM_U_CTX_L2     (0x07)\n#define IPHC_M_DAC_DAM_M_FULL       (0x08)\n#define IPHC_M_DAC_DAM_M_48         (0x09)\n#define IPHC_M_DAC_DAM_M_32         (0x0a)\n#define IPHC_M_DAC_DAM_M_8          (0x0b)\n#define IPHC_M_DAC_DAM_M_UC_PREFIX  (0x0c)\n\n#define NHC_ID_MASK                 (0xF8)\n#define NHC_UDP_ID                  (0xF0)\n#define NHC_UDP_PP_MASK             (0x03)\n#define NHC_UDP_SD_INLINE           (0x00)\n#define NHC_UDP_S_INLINE            (0x01)\n#define NHC_UDP_D_INLINE            (0x02)\n#define NHC_UDP_SD_ELIDED           (0x03)\n#define NHC_UDP_C_ELIDED            (0x04)\n\n#define NHC_UDP_4BIT_PORT           (0xF0B0)\n#define NHC_UDP_4BIT_MASK           (0xFFF0)\n#define NHC_UDP_8BIT_PORT           (0xF000)\n#define NHC_UDP_8BIT_MASK           (0xFF00)\n\n#define NHC_IPV6_EXT_ID             (0xE0)\n#define NHC_IPV6_EXT_ID_ALT         (0xE8)  /* first bit of EID 1 */\n#define NHC_IPV6_EXT_EID_MASK       (0x0E)\n#define NHC_IPV6_EXT_NH             (0x01)\n\n#define NHC_IPV6_EXT_EID_HOPOPT     (0x00 << 1)\n#define NHC_IPV6_EXT_EID_RH         (0x01 << 1)\n#define NHC_IPV6_EXT_EID_FRAG       (0x02 << 1)\n#define NHC_IPV6_EXT_EID_DST        (0x03 << 1)\n#define NHC_IPV6_EXT_EID_MOB        (0x04 << 1)\n#define NHC_IPV6_EXT_EID_IPV6       (0x07 << 1)\n\n#define SIXLOWPAN_IPHC_PREFIX_LEN   (64)    /**< minimum prefix length for IPHC */\n\n/* currently only used with forwarding output, remove guard if more debug info\n * is added */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\nstatic char addr_str[IPV6_ADDR_MAX_STR_LEN];\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\nstatic inline bool _is_rfrag(gnrc_pktsnip_t *sixlo)\n{\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n    assert((sixlo->next != NULL) &&\n           (sixlo->next->type == GNRC_NETTYPE_SIXLOWPAN));\n    return sixlowpan_sfr_rfrag_is(sixlo->next->data);\n#else   /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n    (void)sixlo;\n    return false;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n}\n\nstatic inline bool _context_overlaps_iid(gnrc_sixlowpan_ctx_t *ctx,\n                                         ipv6_addr_t *addr,\n                                         eui64_t *iid)\n{\n    uint8_t byte_mask[] = {0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01};\n\n    if ((ctx == NULL) || (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n        return false;\n    }\n\n    return ((ctx->prefix_len == 128) || /* Full-length prefix overlaps IID in any case */\n            ((ctx->prefix_len > 64) &&  /* otherwise, if bigger than 64-bit */\n             /* compare bytes until prefix length with IID */\n             (memcmp(&(addr->u8[(ctx->prefix_len / 8) + 1]),\n                     &(iid->uint8[(ctx->prefix_len / 8) - 7]),\n                     sizeof(network_uint64_t) - ((ctx->prefix_len / 8) - 7)) == 0) &&\n             /* compare bits at prefix length with IID */\n             (addr->u8[(ctx->prefix_len / 8)] & byte_mask[ctx->prefix_len % 8]) ==\n             (iid->uint8[(ctx->prefix_len / 8) - 8] & byte_mask[ctx->prefix_len % 8])));\n}\n\nstatic gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *netif);\n\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\nstatic gnrc_pktsnip_t *_encode_frag_for_forwarding(gnrc_pktsnip_t *decoded_pkt,\n                                                   gnrc_sixlowpan_frag_vrb_t *vrbe);\nstatic int _forward_frag(gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *frag_hdr,\n                         gnrc_sixlowpan_frag_vrb_t *vrbe, unsigned page);\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\nstatic size_t _iphc_ipv6_decode(const uint8_t *iphc_hdr,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface, ipv6_hdr_t *ipv6_hdr)\n{\n    gnrc_sixlowpan_ctx_t *ctx = NULL;\n    size_t payload_offset = SIXLOWPAN_IPHC_HDR_LEN;\n\n    if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_CID_EXT) {\n        payload_offset++;\n    }\n\n    /* bits of the uncompressed address might not be written in decompression,\n     * so zero the whole header first */\n    memset(ipv6_hdr, 0, sizeof(*ipv6_hdr));\n    ipv6_hdr_set_version(ipv6_hdr);\n\n    switch (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_TF) {\n        case IPHC_TF_ECN_DSCP_FL:\n            ipv6_hdr_set_tc(ipv6_hdr, iphc_hdr[payload_offset++]);\n            ipv6_hdr->v_tc_fl.u8[1] |= iphc_hdr[payload_offset++] & 0x0f;\n            ipv6_hdr->v_tc_fl.u8[2] |= iphc_hdr[payload_offset++];\n            ipv6_hdr->v_tc_fl.u8[3] |= iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_TF_ECN_FL:\n            ipv6_hdr_set_tc_ecn(ipv6_hdr, iphc_hdr[payload_offset] >> 6);\n            ipv6_hdr_set_tc_dscp(ipv6_hdr, 0);\n            ipv6_hdr->v_tc_fl.u8[1] |= iphc_hdr[payload_offset++] & 0x0f;\n            ipv6_hdr->v_tc_fl.u8[2] |= iphc_hdr[payload_offset++];\n            ipv6_hdr->v_tc_fl.u8[3] |= iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_TF_ECN_DSCP:\n            ipv6_hdr_set_tc(ipv6_hdr, iphc_hdr[payload_offset++]);\n            ipv6_hdr_set_fl(ipv6_hdr, 0);\n            break;\n\n        case IPHC_TF_ECN_ELIDE:\n            ipv6_hdr_set_tc(ipv6_hdr, 0);\n            ipv6_hdr_set_fl(ipv6_hdr, 0);\n            break;\n    }\n\n    if (!(iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH)) {\n        ipv6_hdr->nh = iphc_hdr[payload_offset++];\n    }\n\n    switch (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_HL) {\n        case IPHC_HL_INLINE:\n            ipv6_hdr->hl = iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_HL_1:\n            ipv6_hdr->hl = 1;\n            break;\n\n        case IPHC_HL_64:\n            ipv6_hdr->hl = 64;\n            break;\n\n        case IPHC_HL_255:\n            ipv6_hdr->hl = 255;\n            break;\n    }\n\n    if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_SAC) {\n        uint8_t sci = 0;\n\n        if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_CID_EXT) {\n            sci = iphc_hdr[CID_EXT_IDX] >> 4;\n        }\n\n        if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_SAM) {\n            ctx = gnrc_sixlowpan_ctx_lookup_id(sci);\n\n            if (ctx == NULL) {\n                DEBUG(\"6lo iphc: could not find source context\\n\");\n                return 0;\n            }\n        }\n    }\n\n    iface = gnrc_netif_hdr_get_netif(netif_hdr);\n    switch (iphc_hdr[IPHC2_IDX] & (SIXLOWPAN_IPHC2_SAC | SIXLOWPAN_IPHC2_SAM)) {\n\n        case IPHC_SAC_SAM_FULL:\n            /* take full 128 from inline */\n            memcpy(&(ipv6_hdr->src), iphc_hdr + payload_offset, 16);\n            payload_offset += 16;\n            break;\n\n        case IPHC_SAC_SAM_64:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->src);\n            memcpy(ipv6_hdr->src.u8 + 8, iphc_hdr + payload_offset, 8);\n            payload_offset += 8;\n            break;\n\n        case IPHC_SAC_SAM_16:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->src);\n            ipv6_hdr->src.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->src.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->src.u8 + 14, iphc_hdr + payload_offset, 2);\n            payload_offset += 2;\n            break;\n\n        case IPHC_SAC_SAM_L2:\n            if (gnrc_netif_hdr_ipv6_iid_from_src(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->src.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get source's IID\\n\");\n                return 0;\n            }\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->src);\n            break;\n\n        case IPHC_SAC_SAM_UNSPEC:\n            ipv6_addr_set_unspecified(&ipv6_hdr->src);\n            break;\n\n        case IPHC_SAC_SAM_CTX_64:\n            assert(ctx != NULL);\n            memcpy(ipv6_hdr->src.u8 + 8, iphc_hdr + payload_offset, 8);\n            ipv6_addr_init_prefix(&ipv6_hdr->src, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 8;\n            break;\n\n        case IPHC_SAC_SAM_CTX_16:\n            assert(ctx != NULL);\n            ipv6_hdr->src.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->src.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->src.u8 + 14, iphc_hdr + payload_offset, 2);\n            ipv6_addr_init_prefix(&ipv6_hdr->src, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 2;\n            break;\n\n        case IPHC_SAC_SAM_CTX_L2:\n            assert(ctx != NULL);\n            if (gnrc_netif_hdr_ipv6_iid_from_src(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->src.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get source's IID\\n\");\n                return 0;\n            }\n            ipv6_addr_init_prefix(&ipv6_hdr->src, &ctx->prefix,\n                                  ctx->prefix_len);\n            break;\n    }\n\n    if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_DAC) {\n        uint8_t dci = 0;\n\n        if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_CID_EXT) {\n            dci = iphc_hdr[CID_EXT_IDX] & 0x0f;\n        }\n\n        if (iphc_hdr[IPHC2_IDX] & (SIXLOWPAN_IPHC2_M | SIXLOWPAN_IPHC2_DAM)) {\n            ctx = gnrc_sixlowpan_ctx_lookup_id(dci);\n\n            if (ctx == NULL) {\n                DEBUG(\"6lo iphc: could not find destination context\\n\");\n                return 0;\n            }\n        }\n    }\n\n    switch (iphc_hdr[IPHC2_IDX] & (SIXLOWPAN_IPHC2_M | SIXLOWPAN_IPHC2_DAC |\n                                   SIXLOWPAN_IPHC2_DAM)) {\n        case IPHC_M_DAC_DAM_U_FULL:\n        case IPHC_M_DAC_DAM_M_FULL:\n            memcpy(&(ipv6_hdr->dst.u8), iphc_hdr + payload_offset, 16);\n            payload_offset += 16;\n            break;\n\n        case IPHC_M_DAC_DAM_U_64:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->dst);\n            memcpy(ipv6_hdr->dst.u8 + 8, iphc_hdr + payload_offset, 8);\n            payload_offset += 8;\n            break;\n\n        case IPHC_M_DAC_DAM_U_16:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->dst.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->dst.u8 + 14, iphc_hdr + payload_offset, 2);\n            payload_offset += 2;\n            break;\n\n        case IPHC_M_DAC_DAM_U_L2:\n            if (gnrc_netif_hdr_ipv6_iid_from_dst(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->dst.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n                return 0;\n            }\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->dst);\n            break;\n\n        case IPHC_M_DAC_DAM_U_CTX_64:\n            assert(ctx != NULL);\n            memcpy(ipv6_hdr->dst.u8 + 8, iphc_hdr + payload_offset, 8);\n            ipv6_addr_init_prefix(&ipv6_hdr->dst, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 8;\n            break;\n\n        case IPHC_M_DAC_DAM_U_CTX_16:\n            ipv6_hdr->dst.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->dst.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->dst.u8 + 14, iphc_hdr + payload_offset, 2);\n            assert(ctx != NULL);\n            ipv6_addr_init_prefix(&ipv6_hdr->dst, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 2;\n            break;\n\n        case IPHC_M_DAC_DAM_U_CTX_L2:\n            if (gnrc_netif_hdr_ipv6_iid_from_dst(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->dst.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n                return 0;\n            }\n            assert(ctx != NULL);\n            ipv6_addr_init_prefix(&ipv6_hdr->dst, &ctx->prefix,\n                                  ctx->prefix_len);\n            break;\n\n        case IPHC_M_DAC_DAM_M_48:\n            /* ffXX::00XX:XXXX:XXXX */\n            ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u8[0] = 0xff;\n            ipv6_hdr->dst.u8[1] = iphc_hdr[payload_offset++];\n            memcpy(ipv6_hdr->dst.u8 + 11, iphc_hdr + payload_offset, 5);\n            payload_offset += 5;\n            break;\n\n        case IPHC_M_DAC_DAM_M_32:\n            /* ffXX::00XX:XXXX */\n            ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u8[0] = 0xff;\n            ipv6_hdr->dst.u8[1] = iphc_hdr[payload_offset++];\n            memcpy(ipv6_hdr->dst.u8 + 13, iphc_hdr + payload_offset, 3);\n            payload_offset += 3;\n            break;\n\n        case IPHC_M_DAC_DAM_M_8:\n            /* ff02::XX: */\n            ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u8[0] = 0xff;\n            ipv6_hdr->dst.u8[1] = 0x02;\n            ipv6_hdr->dst.u8[15] = iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_M_DAC_DAM_M_UC_PREFIX:\n            do {\n                assert(ctx != NULL);\n                uint8_t orig_ctx_len = ctx->prefix_len;\n\n                ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n\n                if (ctx->prefix_len > 64) {\n                    ctx->prefix_len = 64;\n                }\n\n                ipv6_hdr->dst.u8[0] = 0xff;\n                ipv6_hdr->dst.u8[1] = iphc_hdr[payload_offset++];\n                ipv6_hdr->dst.u8[2] = iphc_hdr[payload_offset++];\n                ipv6_hdr->dst.u8[3] = ctx->prefix_len;\n                ipv6_addr_init_prefix((ipv6_addr_t *)(ipv6_hdr->dst.u8 + 4),\n                                      &ctx->prefix, ctx->prefix_len);\n                memcpy(ipv6_hdr->dst.u8 + 12, iphc_hdr + payload_offset + 2, 4);\n\n                payload_offset += 4;\n                ctx->prefix_len = orig_ctx_len;\n            } while (0);    /* ANSI-C compatible block creation for orig_ctx_len allocation */\n            break;\n\n        default:\n            DEBUG(\"6lo iphc: unspecified or reserved M, DAC, DAM combination\\n\");\n            break;\n    }\n    return payload_offset;\n}\n\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\nstatic size_t _iphc_nhc_ipv6_ext_decode(gnrc_pktsnip_t *sixlo, size_t offset,\n                                        size_t *prev_nh_offset,\n                                        gnrc_pktsnip_t *ipv6,\n                                        size_t *uncomp_hdr_len)\n{\n    uint8_t *payload = sixlo->data;\n    ipv6_ext_t *ext_hdr;\n    uint8_t ipv6_ext_nhc = payload[offset++];\n    uint8_t protnum;\n    uint8_t ext_len = (ipv6_ext_nhc & NHC_IPV6_EXT_NH)\n                    ? payload[offset]\n                    : payload[offset + 1];\n\n    /* realloc size for uncompressed snip, if too small */\n    if (ipv6->size < (*uncomp_hdr_len + sizeof(ipv6_ext_t) + ext_len)) {\n        if (gnrc_pktbuf_realloc_data(ipv6,\n                                     *uncomp_hdr_len + sizeof(ipv6_ext_t) +\n                                     ext_len)) {\n            DEBUG(\"6lo iphc: unable to decode IPv6 Extension header NHC \"\n                  \"(not enough buffer space)\\n\");\n            return 0;\n        }\n    }\n    ext_hdr = (ipv6_ext_t *)((uint8_t *)ipv6->data + *uncomp_hdr_len);\n    switch (ipv6_ext_nhc & NHC_IPV6_EXT_EID_MASK) {\n        case NHC_IPV6_EXT_EID_HOPOPT:\n            protnum = PROTNUM_IPV6_EXT_HOPOPT;\n            break;\n        case NHC_IPV6_EXT_EID_RH:\n            protnum = PROTNUM_IPV6_EXT_RH;\n            break;\n        case NHC_IPV6_EXT_EID_FRAG:\n            protnum = PROTNUM_IPV6_EXT_FRAG;\n            break;\n        case NHC_IPV6_EXT_EID_DST:\n            protnum = PROTNUM_IPV6_EXT_DST;\n            break;\n        case NHC_IPV6_EXT_EID_MOB:\n            protnum = PROTNUM_IPV6_EXT_MOB;\n            break;\n        default:\n            DEBUG(\"6lo iphc: unexpected extension header EID %u\\n\",\n                  (ipv6_ext_nhc & NHC_IPV6_EXT_EID_MASK) >> 1U);\n            return 0;\n    }\n    ((uint8_t *)ipv6->data)[*prev_nh_offset] = protnum;\n    if (!(ipv6_ext_nhc & NHC_IPV6_EXT_NH)) {\n        ext_hdr->nh = payload[offset++];\n        /* signal end of next header compression to caller */\n        *prev_nh_offset = 0;\n    }\n    else {\n        *prev_nh_offset = (&ext_hdr->nh) - ((uint8_t *)ipv6->data);\n    }\n    /* skip already fetched length field */\n    offset++;\n    ext_hdr->len = ((sizeof(ipv6_ext_t) + ext_len) - IPV6_EXT_LEN_UNIT) /\n                   IPV6_EXT_LEN_UNIT;\n    memcpy(ext_hdr + 1, &payload[offset], ext_len);\n    offset += ext_len;\n    *uncomp_hdr_len += sizeof(ipv6_ext_t) + ext_len;\n    return offset;\n}\n\nstatic size_t _iphc_nhc_ipv6_decode(gnrc_pktsnip_t *sixlo, size_t offset,\n                                    const gnrc_sixlowpan_frag_rb_t *rbuf,\n                                    size_t *prev_nh_offset,\n                                    gnrc_pktsnip_t *ipv6,\n                                    size_t *uncomp_hdr_len)\n{\n    uint8_t *payload = sixlo->data;\n    uint8_t ipv6_nhc = payload[offset];\n\n    switch (ipv6_nhc & NHC_IPV6_EXT_EID_MASK) {\n        case NHC_IPV6_EXT_EID_HOPOPT:\n        case NHC_IPV6_EXT_EID_RH:\n        case NHC_IPV6_EXT_EID_FRAG:\n        case NHC_IPV6_EXT_EID_DST:\n        case NHC_IPV6_EXT_EID_MOB: {\n            size_t tmp;\n            tmp = _iphc_nhc_ipv6_ext_decode(sixlo, offset, prev_nh_offset,\n                                            ipv6, uncomp_hdr_len);\n            if (tmp == 0) {\n                /* unable to parse IPHC header */\n                return 0;\n            }\n            offset = tmp;\n            break;\n        }\n        case NHC_IPV6_EXT_EID_IPV6: {\n            gnrc_pktsnip_t *netif = gnrc_pktsnip_search_type(sixlo,\n                                                             GNRC_NETTYPE_NETIF);\n            ipv6_hdr_t *ipv6_hdr;\n            uint16_t payload_len;\n            size_t tmp;\n\n            offset++;   /* move over NHC header */\n            /* realloc size for uncompressed snip, if too small */\n            if (ipv6->size < (*uncomp_hdr_len + sizeof(ipv6_hdr_t))) {\n                if (gnrc_pktbuf_realloc_data(ipv6,\n                                             *uncomp_hdr_len +\n                                             sizeof(ipv6_hdr_t))) {\n                    DEBUG(\"6lo iphc: unable to decode IPv6 encapsulated header \"\n                          \"NHC (not enough buffer space)\\n\");\n                    return 0;\n                }\n            }\n            ipv6_hdr = (ipv6_hdr_t *)(((uint8_t *)ipv6->data) + *uncomp_hdr_len);\n            tmp = _iphc_ipv6_decode(&payload[offset], netif->data,\n                                    gnrc_netif_hdr_get_netif(netif->data),\n                                    ipv6_hdr);\n            if (tmp == 0) {\n                /* unable to parse IPHC header */\n                return 0;\n            }\n            ((uint8_t *)ipv6->data)[*prev_nh_offset] = PROTNUM_IPV6;\n            if (payload[offset + IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n                *prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n            }\n            else {\n                /* signal end of next header compression to caller */\n                *prev_nh_offset = 0;\n            }\n            offset += tmp;\n            /* might be needed to be overwritten by IPv6 reassembly after the IPv6\n             * packet was reassembled to get complete length */\n            if (rbuf != NULL) {\n                if (_is_rfrag(sixlo)) {\n                    payload_len = (rbuf->super.datagram_size + *uncomp_hdr_len) -\n                                  (sizeof(ipv6_hdr_t) - offset);\n                }\n                else {\n                    payload_len = rbuf->super.datagram_size - *uncomp_hdr_len -\n                                  sizeof(ipv6_hdr_t);\n                }\n            }\n            else {\n                payload_len = (sixlo->size + *uncomp_hdr_len) -\n                              sizeof(ipv6_hdr_t) - offset;\n            }\n            ipv6_hdr->len = byteorder_htons(payload_len);\n            *uncomp_hdr_len += sizeof(ipv6_hdr_t);\n            break;\n        }\n        default:\n            DEBUG(\"6lo iphc: unknown IPv6 extension header EID\\n\");\n            break;\n    }\n    return offset;\n}\n\n/**\n * @brief   Decodes UDP NHC\n *\n * @param[in] sixlo                 The IPHC encoded packet\n * @param[in] offset                The offset of the NHC encoded header\n * @param[in] rbuf                  Reassembly buffer entry if @p ipv6 is a\n *                                  fragmented datagram. May be NULL, if @p ipv6\n *                                  is not fragmented\n * @param[out] prev_nh_offset       Offset to previous nh field in\n *                                  gnrc_pktsnip_t::data of @p ipv6\n * @param[out] ipv6                 The packet to write the decoded data to\n * @param[in,out] uncomp_hdr_len    Number of bytes already decoded into @p ipv6\n *                                  by IPHC and other NHC. Adds size of @ref\n *                                  udp_hdr_t after successful UDP header\n *                                  decompression\n *\n * @return  The offset after UDP NHC header on success.\n * @return  0 on error.\n */\nstatic size_t _iphc_nhc_udp_decode(gnrc_pktsnip_t *sixlo, size_t offset,\n                                   const gnrc_sixlowpan_frag_rb_t *rbuf,\n                                   size_t prev_nh_offset, gnrc_pktsnip_t *ipv6,\n                                   size_t *uncomp_hdr_len)\n{\n    uint8_t *payload = sixlo->data;\n    udp_hdr_t *udp_hdr;\n    uint16_t payload_len;\n    uint8_t udp_nhc = payload[offset++];\n    uint8_t tmp;\n\n    /* realloc size for uncompressed snip, if too small */\n    if (ipv6->size < (*uncomp_hdr_len + sizeof(udp_hdr_t))) {\n        if (gnrc_pktbuf_realloc_data(ipv6,\n                                     *uncomp_hdr_len + sizeof(udp_hdr_t))) {\n            DEBUG(\"6lo: unable to decode UDP NHC (not enough buffer space)\\n\");\n            return 0;\n        }\n    }\n    udp_hdr = (udp_hdr_t *)((uint8_t *)ipv6->data + *uncomp_hdr_len);\n    network_uint16_t *src_port = &(udp_hdr->src_port);\n    network_uint16_t *dst_port = &(udp_hdr->dst_port);\n\n    switch (udp_nhc & NHC_UDP_PP_MASK) {\n\n        case NHC_UDP_SD_INLINE:\n            DEBUG(\"6lo iphc nhc: SD_INLINE\\n\");\n            src_port->u8[0] = payload[offset++];\n            src_port->u8[1] = payload[offset++];\n            dst_port->u8[0] = payload[offset++];\n            dst_port->u8[1] = payload[offset++];\n            break;\n\n        case NHC_UDP_S_INLINE:\n            DEBUG(\"6lo iphc nhc: S_INLINE\\n\");\n            src_port->u8[0] = payload[offset++];\n            src_port->u8[1] = payload[offset++];\n            *dst_port = byteorder_htons(payload[offset++] + NHC_UDP_8BIT_PORT);\n            break;\n\n        case NHC_UDP_D_INLINE:\n            DEBUG(\"6lo iphc nhc: D_INLINE\\n\");\n            *src_port = byteorder_htons(payload[offset++] + NHC_UDP_8BIT_PORT);\n            dst_port->u8[0] = payload[offset++];\n            dst_port->u8[1] = payload[offset++];\n            break;\n\n        case NHC_UDP_SD_ELIDED:\n            DEBUG(\"6lo iphc nhc: SD_ELIDED\\n\");\n            tmp = payload[offset++];\n            *src_port = byteorder_htons((tmp >> 4) + NHC_UDP_4BIT_PORT);\n            *dst_port = byteorder_htons((tmp & 0xf) + NHC_UDP_4BIT_PORT);\n            break;\n\n        default:\n            break;\n    }\n\n    if ((udp_nhc & NHC_UDP_C_ELIDED) != 0) {\n        DEBUG(\"6lo iphc nhc: unsupported elided checksum\\n\");\n        return 0;\n    }\n    else {\n        udp_hdr->checksum.u8[0] = payload[offset++];\n        udp_hdr->checksum.u8[1] = payload[offset++];\n    }\n\n    /* might be needed to be overwritten by IPv6 reassembly after the IPv6\n     * packet was reassembled to get complete length */\n    if (rbuf != NULL) {\n        if (_is_rfrag(sixlo)) {\n            payload_len = rbuf->super.datagram_size + sizeof(udp_hdr_t) -\n                          offset;\n        }\n        else {\n            payload_len = rbuf->super.datagram_size - *uncomp_hdr_len;\n        }\n    }\n    else {\n        payload_len = sixlo->size + sizeof(udp_hdr_t) - offset;\n    }\n    udp_hdr->length = byteorder_htons(payload_len);\n    *uncomp_hdr_len += sizeof(udp_hdr_t);\n    ((uint8_t *)ipv6->data)[prev_nh_offset] = PROTNUM_UDP;\n\n    return offset;\n}\n#endif\n\nstatic inline void _recv_error_release(gnrc_pktsnip_t *sixlo,\n                                       gnrc_pktsnip_t *ipv6,\n                                       gnrc_sixlowpan_frag_rb_t *rbuf) {\n    if (rbuf != NULL) {\n        gnrc_sixlowpan_frag_rb_remove(rbuf);\n    }\n    gnrc_pktbuf_release(ipv6);\n    gnrc_pktbuf_release(sixlo);\n}\n\nvoid gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,\n                              unsigned page)\n{\n    assert(sixlo != NULL);\n    gnrc_pktsnip_t *ipv6, *netif;\n    gnrc_netif_t *iface;\n    ipv6_hdr_t *ipv6_hdr;\n    uint8_t *iphc_hdr = sixlo->data;\n    size_t payload_offset;\n    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (sixlo->size < 2U) {\n        DEBUG(\"6lo iphc: IPHC header truncated\\n\");\n        if (rbuf != NULL) {\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n        }\n        gnrc_pktbuf_release(sixlo);\n        return;\n    }\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n        /* unable to parse IPHC header or malicious packet */\n        DEBUG(\"6lo iphc: malformed IPHC header\\n\");\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        if (_is_rfrag(sixlo)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  rbuf->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)payload_offset);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)uncomp_hdr_len);\n            /* set IPv6 header payload length field to the length of whatever is\n             * left after removing the 6LoWPAN header and adding uncompressed\n             * headers */\n            payload_len = (rbuf->super.datagram_size - payload_offset) +\n                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", payload_len);\n            /* adapt datagram size for uncompressed datagram */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n            /* guard required because SFR-specific field of vrbe is accessed */\n            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);\n            rbuf->super.datagram_size += rbuf->offset_diff;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n        }\n        else {\n            /* for a fragmented datagram we know the overall length already */\n            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            sixlo = gnrc_pkt_delete(sixlo, netif);\n            ipv6 = gnrc_pkt_append(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n                return;\n            }\n        }\n        /* reallocate to copy complete payload */\n        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        /* set IPv6 header payload length field to the length of whatever is left\n         * after removing the 6LoWPAN header and adding uncompressed headers */\n        payload_len = (sixlo->size + uncomp_hdr_len -\n                       payload_offset - sizeof(ipv6_hdr_t));\n    }\n    if (rbuf == NULL) {\n        /* (rbuf == NULL) => forwarding is not affected by this */\n        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n\n    /* re-assign IPv6 header in case realloc changed the address */\n    ipv6_hdr = ipv6->data;\n    ipv6_hdr->len = byteorder_htons(payload_len);\n    if (sixlo->size > payload_offset) {\n        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n               ((uint8_t *)sixlo->data) + payload_offset,\n               sixlo->size - payload_offset);\n    }\n    if (rbuf != NULL) {\n        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        if (vrbe != NULL) {\n            int res = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            ipv6_hdr->hl--;\n            vrbe->super.current_size = rbuf->super.current_size;\n            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n                /* guard required because SFR-specific field of vrbe is\n                 * accessed */\n                if (_is_rfrag(sixlo)) {\n                    vrbe->in_netif = iface;\n                    /* calculate offset difference due to compression */\n                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -\n                                        sixlo->size;\n                }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* empty list, as it should be in VRB now */\n                    rbuf->super.ints = NULL;\n                }\n            }\n            if ((ipv6 == NULL) || (res < 0)) {\n                /* TODO: There is a potential to fall-back to classic reassembly\n                 * when ipv6 != NULL. However, since `ipv6` was reversed in\n                 * `_encode_frag_for_forwarding`, that step needs to be reversed\n                 * or a version of the old ipv6 needs to be held in the buffer.\n                 * For now, just drop the packet all together in an error case\n                 */\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n            gnrc_pktbuf_release(sixlo);\n            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        sixlo = gnrc_pkt_delete(sixlo, netif);\n        ipv6 = gnrc_pkt_append(ipv6, netif);\n        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);\n    }\n    gnrc_pktbuf_release(sixlo);\n    return;\n}\n\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\nstatic gnrc_pktsnip_t *_encode_frag_for_forwarding(gnrc_pktsnip_t *decoded_pkt,\n                                                   gnrc_sixlowpan_frag_vrb_t *vrbe)\n{\n    gnrc_pktsnip_t *res;\n    gnrc_netif_hdr_t *netif_hdr;\n\n    /* mark IPv6 header to allow for next header compression */\n    res = gnrc_pktbuf_mark(decoded_pkt, sizeof(ipv6_hdr_t), GNRC_NETTYPE_IPV6);\n    if (res == NULL) {\n        DEBUG(\"6lo iphc: unable to mark IPv6 header for forwarding\\n\");\n        gnrc_pktbuf_release(decoded_pkt);\n        return NULL;\n    }\n    res = gnrc_pktbuf_reverse_snips(decoded_pkt);\n    if (res == NULL) {\n        DEBUG(\"6lo iphc: unable to reverse packet for forwarding\\n\");\n        /* decoded_pkt is released in gnrc_pktbuf_reverse_snips() */\n        return NULL;\n    }\n    /* set netif header from VRB for correct encoding */\n    netif_hdr = res->data;\n    /* _iphc_encode only checks the destination address, so leave src\n     * untouched */\n    netif_hdr->dst_l2addr_len = vrbe->super.dst_len;\n    gnrc_netif_hdr_set_dst_addr(netif_hdr, vrbe->super.dst,\n                                vrbe->super.dst_len);\n    gnrc_netif_hdr_set_netif(netif_hdr, vrbe->out_netif);\n    decoded_pkt = res;\n    if ((res = _iphc_encode(decoded_pkt, netif_hdr, vrbe->out_netif))) {\n        return res;\n    }\n    else {\n        DEBUG(\"6lo iphc: unable to compress packet for forwarding\\n\");\n        gnrc_pktbuf_release(decoded_pkt);\n        return NULL;\n    }\n}\n\nstatic int _forward_frag(gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *frag_hdr,\n                         gnrc_sixlowpan_frag_vrb_t *vrbe, unsigned page)\n{\n    /* remove rewritten netif header (forwarding implementation must do this\n     * anyway) */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt);\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n        sixlowpan_frag_is(frag_hdr->data)) {\n        return gnrc_sixlowpan_frag_minfwd_forward(pkt, frag_hdr->data, vrbe,\n                                                  page);\n    }\n    /* the following is just debug output for testing without any forwarding\n     * scheme */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n    if (sixlowpan_sfr_rfrag_is(frag_hdr->data)) {\n        return gnrc_sixlowpan_frag_sfr_forward(pkt, frag_hdr->data, vrbe, page);\n    }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n    DEBUG(\"6lo iphc: Do not know how to forward fragment from (%s, %u) \",\n          gnrc_netif_addr_to_str(vrbe->super.src, vrbe->super.src_len,\n                                 addr_str), vrbe->super.tag);\n    DEBUG(\"to (%s, %u)\\n\",\n          gnrc_netif_addr_to_str(vrbe->super.dst, vrbe->super.dst_len,\n                                 addr_str), vrbe->out_tag);\n    if (IS_ACTIVE(ENABLE_DEBUG) && IS_USED(MODULE_OD)) {\n        DEBUG(\"Original fragmentation header:\\n\");\n        od_hex_dump(frag_hdr->data, frag_hdr->size, OD_WIDTH_DEFAULT);\n        DEBUG(\"IPHC headers + payload:\\n\");\n        frag_hdr = pkt;\n        while (frag_hdr) {\n            od_hex_dump(frag_hdr->data, frag_hdr->size, OD_WIDTH_DEFAULT);\n            frag_hdr = frag_hdr->next;\n        }\n    }\n    gnrc_pktbuf_release(pkt);\n    (void)frag_hdr;\n    (void)page;\n    return -ENOTSUP;\n}\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\nstatic inline bool _compressible_nh(uint8_t nh)\n{\n    switch (nh) {\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n        case PROTNUM_IPV6_EXT_HOPOPT:\n        case PROTNUM_UDP:\n        case PROTNUM_IPV6:\n        case PROTNUM_IPV6_EXT_RH:\n        case PROTNUM_IPV6_EXT_FRAG:\n        case PROTNUM_IPV6_EXT_DST:\n        case PROTNUM_IPV6_EXT_MOB:\n            return true;\n#endif\n        default:\n            return false;\n    }\n}\n\nstatic size_t _iphc_ipv6_encode(gnrc_pktsnip_t *pkt,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface,\n                                uint8_t *iphc_hdr)\n{\n    gnrc_sixlowpan_ctx_t *src_ctx = NULL, *dst_ctx = NULL;\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    bool addr_comp = false;\n    uint16_t inline_pos = SIXLOWPAN_IPHC_HDR_LEN;\n\n    assert(iface != NULL);\n\n    /* set initial dispatch value*/\n    iphc_hdr[IPHC1_IDX] = SIXLOWPAN_IPHC1_DISP;\n    iphc_hdr[IPHC2_IDX] = 0;\n\n    /* check for available contexts */\n    if (!ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        src_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->src));\n        /* do not use source context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (src_ctx && !(src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            src_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (src_ctx &&\n            ipv6_addr_match_prefix(&src_ctx->prefix, &ipv6_hdr->src) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            src_ctx = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&ipv6_hdr->dst)) {\n        dst_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->dst));\n        /* do not use destination context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (dst_ctx && !(dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            dst_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (dst_ctx &&\n            ipv6_addr_match_prefix(&dst_ctx->prefix, &ipv6_hdr->dst) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            dst_ctx = NULL;\n        }\n    }\n\n    /* if contexts available and both != 0 */\n    /* since this moves inline_pos we have to do this ahead*/\n    if (((src_ctx != NULL) &&\n            ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) ||\n        ((dst_ctx != NULL) &&\n            ((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0))) {\n        /* add context identifier extension */\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_CID_EXT;\n        iphc_hdr[CID_EXT_IDX] = 0;\n\n        /* move position to behind CID extension */\n        inline_pos += SIXLOWPAN_IPHC_CID_EXT_LEN;\n    }\n\n    /* compress flow label and traffic class */\n    if (ipv6_hdr_get_fl(ipv6_hdr) == 0) {\n        if (ipv6_hdr_get_tc(ipv6_hdr) == 0) {\n            /* elide both traffic class and flow label */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_ELIDE;\n        }\n        else {\n            /* elide flow label, traffic class (ECN + DSCP) inline (1 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(ipv6_hdr) == 0) {\n            /* elide DSCP, ECN + 2-bit pad + flow label inline (3 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_FL;\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_tc_ecn(ipv6_hdr) << 6) |\n                                               ((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16));\n        }\n        else {\n            /* ECN + DSCP + 4-bit pad + flow label (4 bytes) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP_FL;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16);\n        }\n\n        /* copy remaining bytes of flow label */\n        iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x0000ff00) >> 8);\n        iphc_hdr[inline_pos++] = (uint8_t)(ipv6_hdr_get_fl(ipv6_hdr) & 0x000000ff);\n    }\n\n    /* check for compressible next header */\n    if (_compressible_nh(ipv6_hdr->nh)) {\n        iphc_hdr[IPHC1_IDX] |= SIXLOWPAN_IPHC1_NH;\n    }\n    else {\n        iphc_hdr[inline_pos++] = ipv6_hdr->nh;\n    }\n\n    /* compress hop limit */\n    switch (ipv6_hdr->hl) {\n        case 1:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_1;\n            break;\n\n        case 64:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_64;\n            break;\n\n        case 255:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_255;\n            break;\n\n        default:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_INLINE;\n            iphc_hdr[inline_pos++] = ipv6_hdr->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_UNSPEC;\n    }\n    else {\n        if (src_ctx != NULL) {\n            /* stateful source address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_SAC;\n\n            if (((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) << 4);\n            }\n        }\n\n        if ((src_ctx != NULL) || ipv6_addr_is_link_local(&(ipv6_hdr->src))) {\n            eui64_t iid;\n            iid.uint64.u64 = 0;\n\n            gnrc_netif_acquire(iface);\n            if (gnrc_netif_ipv6_get_iid(iface, &iid) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(iface);\n                return 0;\n            }\n            gnrc_netif_release(iface);\n\n            if ((ipv6_hdr->src.u64[1].u64 == iid.uint64.u64) ||\n                _context_overlaps_iid(src_ctx, &ipv6_hdr->src, &iid)) {\n                /* 0 bits. The address is derived from link-layer address */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_L2;\n                addr_comp = true;\n            }\n            else if ((byteorder_ntohl(ipv6_hdr->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(ipv6_hdr->src.u16[6]) == 0xfe00)) {\n                /* 16 bits. The address is derived using 16 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_16;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u16 + 7, 2);\n                inline_pos += 2;\n                addr_comp = true;\n            }\n            else {\n                /* 64 bits. The address is derived using 64 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_64;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u64 + 1, 8);\n                inline_pos += 8;\n                addr_comp = true;\n            }\n        }\n\n        if (!addr_comp) {\n            /* full address is carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n            memcpy(iphc_hdr + inline_pos, &ipv6_hdr->src, 16);\n            inline_pos += 16;\n        }\n    }\n\n    addr_comp = false;\n\n    /* M: Multicast compression */\n    if (ipv6_addr_is_multicast(&(ipv6_hdr->dst))) {\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_M;\n\n        /* if multicast address is of format ffXX::XXXX:XXXX:XXXX */\n        if ((ipv6_hdr->dst.u16[1].u16 == 0) &&\n            (ipv6_hdr->dst.u32[1].u32 == 0) &&\n            (ipv6_hdr->dst.u16[4].u16 == 0)) {\n            /* if multicast address is of format ff02::XX */\n            if ((ipv6_hdr->dst.u8[1] == 0x02) &&\n                (ipv6_hdr->dst.u32[2].u32 == 0) &&\n                (ipv6_hdr->dst.u16[6].u16 == 0) &&\n                (ipv6_hdr->dst.u8[14] == 0)) {\n                /* 8 bits. The address is derived using 8 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_8;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[15];\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX */\n            else if ((ipv6_hdr->dst.u16[5].u16 == 0) &&\n                     (ipv6_hdr->dst.u8[12] == 0)) {\n                /* 32 bits. The address is derived using 32 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_32;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 13, 3);\n                inline_pos += 3;\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX:XXXX */\n            else if (ipv6_hdr->dst.u8[10] == 0) {\n                /* 48 bits. The address is derived using 48 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_48;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 11, 5);\n                inline_pos += 5;\n                addr_comp = true;\n            }\n        }\n        /* try unicast prefix based compression */\n        else {\n            gnrc_sixlowpan_ctx_t *ctx;\n            ipv6_addr_t unicast_prefix;\n            unicast_prefix.u16[0] = ipv6_hdr->dst.u16[2];\n            unicast_prefix.u16[1] = ipv6_hdr->dst.u16[3];\n            unicast_prefix.u16[2] = ipv6_hdr->dst.u16[4];\n            unicast_prefix.u16[3] = ipv6_hdr->dst.u16[5];\n\n            ctx = gnrc_sixlowpan_ctx_lookup_addr(&unicast_prefix);\n\n            if ((ctx != NULL) && (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP) &&\n                (ctx->prefix_len == ipv6_hdr->dst.u8[3])) {\n                /* Unicast prefix based IPv6 multicast address\n                 * (https://tools.ietf.org/html/rfc3306) with given context\n                 * for unicast prefix -> context based compression */\n                iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n                if ((ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0) {\n                    iphc_hdr[CID_EXT_IDX] |= (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n                }\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[2];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u16 + 6, 4);\n                inline_pos += 4;\n                addr_comp = true;\n            }\n        }\n    }\n    else if (((dst_ctx != NULL) ||\n              ipv6_addr_is_link_local(&ipv6_hdr->dst)) && (netif_hdr->dst_l2addr_len > 0)) {\n        eui64_t iid;\n\n        if (dst_ctx != NULL) {\n            /* stateful destination address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n\n            if (((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= (dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(iface, netif_hdr, &iid) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((ipv6_hdr->dst.u64[1].u64 == iid.uint64.u64) ||\n            _context_overlaps_iid(dst_ctx, &(ipv6_hdr->dst), &iid)) {\n            /* 0 bits. The address is derived using the link-layer address */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_L2;\n            addr_comp = true;\n        }\n        else if ((byteorder_ntohl(ipv6_hdr->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(ipv6_hdr->dst.u16[6]) == 0xfe00)) {\n            /* 16 bits. The address is derived using 16 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_16;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u16[7]), 2);\n            inline_pos += 2;\n            addr_comp = true;\n        }\n        else {\n            /* 64 bits. The address is derived using 64 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_64;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u8[8]), 8);\n            inline_pos += 8;\n            addr_comp = true;\n        }\n    }\n\n    if (!addr_comp) {\n        /* full destination address is carried inline */\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n        memcpy(iphc_hdr + inline_pos, &ipv6_hdr->dst, 16);\n        inline_pos += 16;\n    }\n\n    return inline_pos;\n}\n\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\nstatic ssize_t _iphc_nhc_ipv6_ext_encode(uint8_t *nhc_data,\n                                        const gnrc_pktsnip_t *ext,\n                                        uint16_t ext_len,\n                                        uint8_t *protnum)\n{\n    const ipv6_ext_t *ext_hdr = ext->data;\n    size_t nhc_len = 1; /* skip over NHC header */\n    uint8_t nh = ext_hdr->nh;\n\n    /* From https://tools.ietf.org/html/rfc6282#section-4.1:\n     * > The Length field contained in a compressed IPv6 Extension Header\n     * > indicates the number of octets that pertain to the (compressed)\n     * > extension header following the Length field.\n     *\n     * ipv6_ext_t is nh + length field so subtract it\n     */\n    ext_len -= sizeof(ipv6_ext_t);\n    if (ext_len > UINT8_MAX) {\n        /* From https://tools.ietf.org/html/rfc6282#section-4.1:\n         * > Note that specifying units in octets means that LOWPAN_NHC MUST NOT\n         * > be used to encode IPv6 Extension Headers that have more than 255\n         * > octets following the Length field after compression. */\n        return 0;\n    }\n    /* Set IPv6 extension compression header type\n     * (see https://tools.ietf.org/html/rfc6282#section-4.2). */\n    nhc_data[0] = NHC_IPV6_EXT_ID;\n    switch (*protnum) {\n        case PROTNUM_IPV6_EXT_HOPOPT:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_HOPOPT;\n            /* TODO: decrement ext_len by length of trailing Pad1/PadN option:\n             * > IPv6 Hop-by-Hop and Destination Options Headers may use a trailing\n             * > Pad1 or PadN to achieve 8-octet alignment.  When there is a single\n             * > trailing Pad1 or PadN option of 7 octets or less and the containing\n             * > header is a multiple of 8 octets, the trailing Pad1 or PadN option\n             * > MAY be elided by the compressor. */\n            break;\n        case PROTNUM_IPV6_EXT_RH:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_RH;\n            break;\n        case PROTNUM_IPV6_EXT_FRAG:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_FRAG;\n            break;\n        case PROTNUM_IPV6_EXT_DST:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_DST;\n            /* TODO: decrement ext_len by length of trailing Pad1/PadN option:\n             * > IPv6 Hop-by-Hop and Destination Options Headers may use a trailing\n             * > Pad1 or PadN to achieve 8-octet alignment.  When there is a single\n             * > trailing Pad1 or PadN option of 7 octets or less and the containing\n             * > header is a multiple of 8 octets, the trailing Pad1 or PadN option\n             * > MAY be elided by the compressor. */\n            break;\n        case PROTNUM_IPV6_EXT_MOB:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_MOB;\n            break;\n        default:\n            return -1;\n    }\n    if (_compressible_nh(nh) &&\n        /* carry next header inline when fragment header and offset is equal to\n         * 0 (which means the next header indicates the next header after the\n         * fragment header in the *first fragment*) */\n        ((*protnum != PROTNUM_IPV6_EXT_FRAG) ||\n         (ipv6_ext_frag_get_offset((ipv6_ext_frag_t *)ext_hdr) == 0))) {\n        nhc_data[0] |= NHC_IPV6_EXT_NH;\n    }\n    else {\n        nhc_data[nhc_len++] = ext_hdr->nh;\n        /* prevent next header from being encoded regardless (e.g. if not\n         * first IPv6 fragment) */\n        nh = PROTNUM_RESERVED;\n    }\n    /* integer overflow prevented by `ext_len > UINT8_MAX` check above */\n    nhc_data[nhc_len++] = (uint8_t)ext_len;\n    memcpy(&nhc_data[nhc_len], ext_hdr + 1, ext_len);\n    *protnum = nh;\n    return nhc_len + ext_len;\n}\n\nstatic inline size_t iphc_nhc_udp_encode(uint8_t *nhc_data,\n                                         const gnrc_pktsnip_t *udp)\n{\n    const udp_hdr_t *udp_hdr = udp->data;\n    uint16_t src_port = byteorder_ntohs(udp_hdr->src_port);\n    uint16_t dst_port = byteorder_ntohs(udp_hdr->dst_port);\n    size_t nhc_len = 1; /* skip over NHC header */\n\n    /* Set UDP NHC header type\n     * (see https://tools.ietf.org/html/rfc6282#section-4.3). */\n    nhc_data[0] = NHC_UDP_ID;\n    /* Compressing UDP ports, follow the same sequence as the linux kernel (nhc_udp module). */\n    if (((src_port & NHC_UDP_4BIT_MASK) == NHC_UDP_4BIT_PORT) &&\n        ((dst_port & NHC_UDP_4BIT_MASK) == NHC_UDP_4BIT_PORT)) {\n        DEBUG(\"6lo iphc nhc: elide src and dst\\n\");\n        nhc_data[0] |= NHC_UDP_SD_ELIDED;\n        nhc_data[nhc_len++] = dst_port - NHC_UDP_4BIT_PORT +\n                              ((src_port - NHC_UDP_4BIT_PORT) << 4);\n    }\n    else if ((dst_port & NHC_UDP_8BIT_MASK) == NHC_UDP_8BIT_PORT) {\n        DEBUG(\"6lo iphc nhc: elide dst\\n\");\n        nhc_data[0] |= NHC_UDP_S_INLINE;\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[1];\n        nhc_data[nhc_len++] = dst_port - NHC_UDP_8BIT_PORT;\n    }\n    else if ((src_port & NHC_UDP_8BIT_MASK) == NHC_UDP_8BIT_PORT) {\n        DEBUG(\"6lo iphc nhc: elide src\\n\");\n        nhc_data[0] |= NHC_UDP_D_INLINE;\n        nhc_data[nhc_len++] = src_port - NHC_UDP_8BIT_PORT;\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[1];\n    }\n    else {\n        DEBUG(\"6lo iphc nhc: src and dst inline\\n\");\n        nhc_data[0] |= NHC_UDP_SD_INLINE;\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[1];\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[1];\n    }\n\n    /* TODO: Add support for elided checksum. */\n    nhc_data[nhc_len++] = udp_hdr->checksum.u8[0];\n    nhc_data[nhc_len++] = udp_hdr->checksum.u8[1];\n\n    return nhc_len;\n}\n\nstatic bool _remove_header(gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *hdr,\n                           size_t exp_hdr_size)\n{\n    if (hdr->size > exp_hdr_size) {\n        hdr = gnrc_pktbuf_mark(hdr, exp_hdr_size,\n                               GNRC_NETTYPE_UNDEF);\n\n        if (hdr == NULL) {\n            DEBUG(\"6lo iphc: unable to remove compressed header\\n\");\n            return false;\n        }\n    }\n    gnrc_pktbuf_remove_snip(pkt, hdr);\n    return true;\n}\n\nstatic ssize_t _nhc_ipv6_encode_snip(gnrc_pktsnip_t *pkt,\n                                     const gnrc_netif_hdr_t *netif_hdr,\n                                     gnrc_netif_t *iface,\n                                     uint8_t *nhc_data,\n                                     uint8_t *nh)\n{\n    gnrc_pktsnip_t *hdr = pkt->next->next;\n    ssize_t nhc_len = 1;    /* skip over NHC header */\n    size_t tmp;\n    uint8_t new_nh = ((ipv6_hdr_t *)hdr->data)->nh;\n\n    assert(hdr->size >= sizeof(ipv6_hdr_t));\n    /* Set IPv6 extension compression header type\n     * (see https://tools.ietf.org/html/rfc6282#section-4.2). */\n    nhc_data[0] = NHC_IPV6_EXT_ID;\n    if (_compressible_nh(new_nh)) {\n        nhc_data[0] |= NHC_IPV6_EXT_NH;\n    }\n    else {\n        nhc_data[nhc_len++] = new_nh;\n    }\n    /* save to cast as result is max 40 */\n    tmp = (ssize_t)_iphc_ipv6_encode(hdr, netif_hdr, iface, &nhc_data[nhc_len]);\n    if (tmp == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        return -1;\n    }\n    nhc_len += tmp;\n    /* remove encapsulated IPv6 header */\n    if (!_remove_header(pkt, hdr, sizeof(ipv6_hdr_t))) {\n        return -1;\n    }\n    *nh = new_nh;\n    return nhc_len;\n}\n\nstatic ssize_t _nhc_ipv6_ext_encode_snip(gnrc_pktsnip_t *pkt, uint8_t *nhc_data,\n                                         uint8_t *nh)\n{\n    gnrc_pktsnip_t *hdr = pkt->next->next;\n    ipv6_ext_t *ext = hdr->data;\n    ssize_t nhc_len;\n    uint16_t ext_len = ((ext->len * IPV6_EXT_LEN_UNIT) + IPV6_EXT_LEN_UNIT);\n    uint8_t new_nh = *nh;\n\n    assert((hdr->size >= sizeof(ipv6_ext_t)) && (hdr->size >= ext_len));\n    /* _iphc_nhc_ipv6_ext_encode() manipulates nh, so use `new_nh` as temporary\n     * carrier in case of later errors */\n    nhc_len = _iphc_nhc_ipv6_ext_encode(nhc_data, hdr, ext_len, &new_nh);\n    if (nhc_len == 0) {\n        /* extension header is not compressible, so don't compress it and\n         * just copy it after the preceding compression headers */\n        return nhc_len;\n    }\n    /* remove IPv6 extension header */\n    if (!_remove_header(pkt, hdr, ext_len)) {\n        return -1;\n    }\n    *nh = new_nh;\n    return nhc_len;\n}\n\nstatic ssize_t _nhc_udp_encode_snip(gnrc_pktsnip_t *pkt, uint8_t *nhc_data)\n{\n    gnrc_pktsnip_t *hdr = pkt->next->next;\n    ssize_t nhc_len;\n\n    assert(hdr->size >= sizeof(udp_hdr_t));\n    /* save to cast, as result is max 8 */\n    nhc_len = (ssize_t)iphc_nhc_udp_encode(nhc_data, hdr);\n    /* remove UDP header */\n    if (!_remove_header(pkt, hdr, sizeof(udp_hdr_t))) {\n        return -1;\n    }\n    return nhc_len;\n}\n#endif\n\nstatic inline bool _compressible(gnrc_pktsnip_t *hdr)\n{\n    switch (hdr->type) {\n        case GNRC_NETTYPE_UNDEF:    /* when forwarded */\n        case GNRC_NETTYPE_IPV6:\n#if defined(MODULE_GNRC_SIXLOWPAN_IPHC_NHC)\n# if defined(MODULE_GNRC_IPV6_EXT)\n        case GNRC_NETTYPE_IPV6_EXT:\n# endif /* defined(MODULE_GNRC_IPV6_EXT) */\n# if defined(MODULE_GNRC_UDP)\n        case GNRC_NETTYPE_UDP:\n# endif /* defined(MODULE_GNRC_UDP) */\n#endif\n            return true;\n        default:\n            return false;\n    }\n}\n\nstatic gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *iface)\n{\n    assert(pkt != NULL);\n    uint8_t *iphc_hdr;\n    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;\n    size_t dispatch_size = 0;\n    uint16_t inline_pos = 0;\n    uint8_t nh;\n\n    dispatch = NULL;    /* use dispatch as temporary pointer for prev */\n    /* determine maximum dispatch size and write protect all headers until\n     * then because they will be removed */\n    while ((ptr != NULL) && _compressible(ptr)) {\n        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);\n\n        if (tmp == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        ptr = tmp;\n        if (dispatch == NULL) {\n            /* pkt was already write protected in gnrc_sixlowpan.c:_send so\n             * we shouldn't do it again */\n            pkt->next = ptr;    /* reset original packet */\n        }\n        else {\n            dispatch->next = ptr;\n        }\n        dispatch_size += ptr->size;\n        dispatch = ptr; /* use dispatch as temporary point for prev */\n        ptr = ptr->next;\n    }\n    /* there should be at least one compressible header in `pkt`, otherwise this\n     * function should not be called */\n    assert(dispatch_size > 0);\n    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (dispatch == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    iphc_hdr = dispatch->data;\n    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);\n\n    if (inline_pos == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(dispatch);\n        return NULL;\n    }\n\n    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    while (_compressible_nh(nh)) {\n        ssize_t local_pos = 0;\n        if (pkt->next->next == NULL) {\n            DEBUG(\"6lo iphc: packet next header missing data\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        switch (nh) {\n            case PROTNUM_UDP:\n                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */\n                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,\n                                                  &iphc_hdr[inline_pos], &nh);\n                break;\n            }\n            case PROTNUM_IPV6_EXT_HOPOPT:\n            case PROTNUM_IPV6_EXT_RH:\n            case PROTNUM_IPV6_EXT_FRAG:\n            case PROTNUM_IPV6_EXT_DST:\n            case PROTNUM_IPV6_EXT_MOB:\n                local_pos = _nhc_ipv6_ext_encode_snip(pkt,\n                                                      &iphc_hdr[inline_pos],\n                                                      &nh);\n                if (local_pos == 0) {\n                    /* abort loop, extension header is not compressible as\n                     * length field is too large value */\n                    nh = PROTNUM_RESERVED;\n                }\n                break;\n            default:\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n        }\n        if (local_pos < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        inline_pos += local_pos;\n    }\n#endif\n\n    /* shrink dispatch allocation to final size */\n    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */\n    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);\n\n    /* remove IPv6 header */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);\n\n    /* insert dispatch into packet */\n    dispatch->next = pkt->next;\n    pkt->next = dispatch;\n    return pkt;\n}\n\nvoid gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    /* datagram size before compression */\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    /* copying original destination address */\n    }\n\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        gnrc_pktbuf_release(pkt);\n    }\n}\n\n/** @} */\n"], "fixing_code": ["/*\n * Copyright (C) 2015 Martine Lenders <mlenders@inf.fu-berlin.de>\n * Copyright (C) 2015 PHYTEC Messtechnik GmbH\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n *\n * @author      Martine Lenders <mlenders@inf.fu-berlin.de>\n * @author      Johann Fischer <j.fischer@phytec.de> (nhc udp encoding)\n */\n\n#include <stdbool.h>\n\n#include \"byteorder.h\"\n#include \"net/ipv6/hdr.h\"\n#include \"net/ipv6/ext.h\"\n#include \"net/gnrc.h\"\n#include \"net/gnrc/netif/internal.h\"\n#include \"net/gnrc/sixlowpan.h\"\n#include \"net/gnrc/sixlowpan/ctx.h\"\n#include \"net/gnrc/sixlowpan/frag/rb.h\"\n#include \"net/gnrc/sixlowpan/frag/minfwd.h\"\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n#include \"net/gnrc/sixlowpan/frag/sfr.h\"\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n#include \"net/gnrc/sixlowpan/frag/vrb.h\"\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n#include \"net/gnrc/sixlowpan/internal.h\"\n#include \"net/sixlowpan.h\"\n#include \"utlist.h\"\n#include \"net/gnrc/nettype.h\"\n#include \"net/gnrc/udp.h\"\n#include \"od.h\"\n\n#include \"net/gnrc/sixlowpan/iphc.h\"\n\n#define ENABLE_DEBUG 0\n#include \"debug.h\"\n\n/* dispatch byte definitions */\n#define IPHC1_IDX                   (0U)\n#define IPHC2_IDX                   (1U)\n#define CID_EXT_IDX                 (2U)\n\n/* compression values for traffic class and flow label */\n#define IPHC_TF_ECN_DSCP_FL         (0x00)\n#define IPHC_TF_ECN_FL              (0x08)\n#define IPHC_TF_ECN_DSCP            (0x10)\n#define IPHC_TF_ECN_ELIDE           (0x18)\n\n/* compression values for hop limit */\n#define IPHC_HL_INLINE              (0x00)\n#define IPHC_HL_1                   (0x01)\n#define IPHC_HL_64                  (0x02)\n#define IPHC_HL_255                 (0x03)\n\n/* compression values for source address */\n#define IPHC_SAC_SAM_FULL           (0x00)\n#define IPHC_SAC_SAM_64             (0x10)\n#define IPHC_SAC_SAM_16             (0x20)\n#define IPHC_SAC_SAM_L2             (0x30)\n#define IPHC_SAC_SAM_UNSPEC         (0x40)\n#define IPHC_SAC_SAM_CTX_64         (0x50)\n#define IPHC_SAC_SAM_CTX_16         (0x60)\n#define IPHC_SAC_SAM_CTX_L2         (0x70)\n\n/* compression values for destination address */\n#define IPHC_M_DAC_DAM_U_FULL       (0x00)\n#define IPHC_M_DAC_DAM_U_64         (0x01)\n#define IPHC_M_DAC_DAM_U_16         (0x02)\n#define IPHC_M_DAC_DAM_U_L2         (0x03)\n#define IPHC_M_DAC_DAM_U_UNSPEC     (0x04)\n#define IPHC_M_DAC_DAM_U_CTX_64     (0x05)\n#define IPHC_M_DAC_DAM_U_CTX_16     (0x06)\n#define IPHC_M_DAC_DAM_U_CTX_L2     (0x07)\n#define IPHC_M_DAC_DAM_M_FULL       (0x08)\n#define IPHC_M_DAC_DAM_M_48         (0x09)\n#define IPHC_M_DAC_DAM_M_32         (0x0a)\n#define IPHC_M_DAC_DAM_M_8          (0x0b)\n#define IPHC_M_DAC_DAM_M_UC_PREFIX  (0x0c)\n\n#define NHC_ID_MASK                 (0xF8)\n#define NHC_UDP_ID                  (0xF0)\n#define NHC_UDP_PP_MASK             (0x03)\n#define NHC_UDP_SD_INLINE           (0x00)\n#define NHC_UDP_S_INLINE            (0x01)\n#define NHC_UDP_D_INLINE            (0x02)\n#define NHC_UDP_SD_ELIDED           (0x03)\n#define NHC_UDP_C_ELIDED            (0x04)\n\n#define NHC_UDP_4BIT_PORT           (0xF0B0)\n#define NHC_UDP_4BIT_MASK           (0xFFF0)\n#define NHC_UDP_8BIT_PORT           (0xF000)\n#define NHC_UDP_8BIT_MASK           (0xFF00)\n\n#define NHC_IPV6_EXT_ID             (0xE0)\n#define NHC_IPV6_EXT_ID_ALT         (0xE8)  /* first bit of EID 1 */\n#define NHC_IPV6_EXT_EID_MASK       (0x0E)\n#define NHC_IPV6_EXT_NH             (0x01)\n\n#define NHC_IPV6_EXT_EID_HOPOPT     (0x00 << 1)\n#define NHC_IPV6_EXT_EID_RH         (0x01 << 1)\n#define NHC_IPV6_EXT_EID_FRAG       (0x02 << 1)\n#define NHC_IPV6_EXT_EID_DST        (0x03 << 1)\n#define NHC_IPV6_EXT_EID_MOB        (0x04 << 1)\n#define NHC_IPV6_EXT_EID_IPV6       (0x07 << 1)\n\n#define SIXLOWPAN_IPHC_PREFIX_LEN   (64)    /**< minimum prefix length for IPHC */\n\n/* currently only used with forwarding output, remove guard if more debug info\n * is added */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\nstatic char addr_str[IPV6_ADDR_MAX_STR_LEN];\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\nstatic inline bool _is_rfrag(gnrc_pktsnip_t *sixlo)\n{\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n    assert((sixlo->next != NULL) &&\n           (sixlo->next->type == GNRC_NETTYPE_SIXLOWPAN));\n    return sixlowpan_sfr_rfrag_is(sixlo->next->data);\n#else   /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n    (void)sixlo;\n    return false;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n}\n\nstatic inline bool _context_overlaps_iid(gnrc_sixlowpan_ctx_t *ctx,\n                                         ipv6_addr_t *addr,\n                                         eui64_t *iid)\n{\n    uint8_t byte_mask[] = {0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01};\n\n    if ((ctx == NULL) || (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n        return false;\n    }\n\n    return ((ctx->prefix_len == 128) || /* Full-length prefix overlaps IID in any case */\n            ((ctx->prefix_len > 64) &&  /* otherwise, if bigger than 64-bit */\n             /* compare bytes until prefix length with IID */\n             (memcmp(&(addr->u8[(ctx->prefix_len / 8) + 1]),\n                     &(iid->uint8[(ctx->prefix_len / 8) - 7]),\n                     sizeof(network_uint64_t) - ((ctx->prefix_len / 8) - 7)) == 0) &&\n             /* compare bits at prefix length with IID */\n             (addr->u8[(ctx->prefix_len / 8)] & byte_mask[ctx->prefix_len % 8]) ==\n             (iid->uint8[(ctx->prefix_len / 8) - 8] & byte_mask[ctx->prefix_len % 8])));\n}\n\nstatic gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *netif);\n\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\nstatic gnrc_pktsnip_t *_encode_frag_for_forwarding(gnrc_pktsnip_t *decoded_pkt,\n                                                   gnrc_sixlowpan_frag_vrb_t *vrbe);\nstatic int _forward_frag(gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *frag_hdr,\n                         gnrc_sixlowpan_frag_vrb_t *vrbe, unsigned page);\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\nstatic size_t _iphc_ipv6_decode(const uint8_t *iphc_hdr,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface, ipv6_hdr_t *ipv6_hdr)\n{\n    gnrc_sixlowpan_ctx_t *ctx = NULL;\n    size_t payload_offset = SIXLOWPAN_IPHC_HDR_LEN;\n\n    if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_CID_EXT) {\n        payload_offset++;\n    }\n\n    /* bits of the uncompressed address might not be written in decompression,\n     * so zero the whole header first */\n    memset(ipv6_hdr, 0, sizeof(*ipv6_hdr));\n    ipv6_hdr_set_version(ipv6_hdr);\n\n    switch (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_TF) {\n        case IPHC_TF_ECN_DSCP_FL:\n            ipv6_hdr_set_tc(ipv6_hdr, iphc_hdr[payload_offset++]);\n            ipv6_hdr->v_tc_fl.u8[1] |= iphc_hdr[payload_offset++] & 0x0f;\n            ipv6_hdr->v_tc_fl.u8[2] |= iphc_hdr[payload_offset++];\n            ipv6_hdr->v_tc_fl.u8[3] |= iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_TF_ECN_FL:\n            ipv6_hdr_set_tc_ecn(ipv6_hdr, iphc_hdr[payload_offset] >> 6);\n            ipv6_hdr_set_tc_dscp(ipv6_hdr, 0);\n            ipv6_hdr->v_tc_fl.u8[1] |= iphc_hdr[payload_offset++] & 0x0f;\n            ipv6_hdr->v_tc_fl.u8[2] |= iphc_hdr[payload_offset++];\n            ipv6_hdr->v_tc_fl.u8[3] |= iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_TF_ECN_DSCP:\n            ipv6_hdr_set_tc(ipv6_hdr, iphc_hdr[payload_offset++]);\n            ipv6_hdr_set_fl(ipv6_hdr, 0);\n            break;\n\n        case IPHC_TF_ECN_ELIDE:\n            ipv6_hdr_set_tc(ipv6_hdr, 0);\n            ipv6_hdr_set_fl(ipv6_hdr, 0);\n            break;\n    }\n\n    if (!(iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH)) {\n        ipv6_hdr->nh = iphc_hdr[payload_offset++];\n    }\n\n    switch (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_HL) {\n        case IPHC_HL_INLINE:\n            ipv6_hdr->hl = iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_HL_1:\n            ipv6_hdr->hl = 1;\n            break;\n\n        case IPHC_HL_64:\n            ipv6_hdr->hl = 64;\n            break;\n\n        case IPHC_HL_255:\n            ipv6_hdr->hl = 255;\n            break;\n    }\n\n    if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_SAC) {\n        uint8_t sci = 0;\n\n        if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_CID_EXT) {\n            sci = iphc_hdr[CID_EXT_IDX] >> 4;\n        }\n\n        if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_SAM) {\n            ctx = gnrc_sixlowpan_ctx_lookup_id(sci);\n\n            if (ctx == NULL) {\n                DEBUG(\"6lo iphc: could not find source context\\n\");\n                return 0;\n            }\n        }\n    }\n\n    iface = gnrc_netif_hdr_get_netif(netif_hdr);\n    switch (iphc_hdr[IPHC2_IDX] & (SIXLOWPAN_IPHC2_SAC | SIXLOWPAN_IPHC2_SAM)) {\n\n        case IPHC_SAC_SAM_FULL:\n            /* take full 128 from inline */\n            memcpy(&(ipv6_hdr->src), iphc_hdr + payload_offset, 16);\n            payload_offset += 16;\n            break;\n\n        case IPHC_SAC_SAM_64:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->src);\n            memcpy(ipv6_hdr->src.u8 + 8, iphc_hdr + payload_offset, 8);\n            payload_offset += 8;\n            break;\n\n        case IPHC_SAC_SAM_16:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->src);\n            ipv6_hdr->src.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->src.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->src.u8 + 14, iphc_hdr + payload_offset, 2);\n            payload_offset += 2;\n            break;\n\n        case IPHC_SAC_SAM_L2:\n            if (gnrc_netif_hdr_ipv6_iid_from_src(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->src.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get source's IID\\n\");\n                return 0;\n            }\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->src);\n            break;\n\n        case IPHC_SAC_SAM_UNSPEC:\n            ipv6_addr_set_unspecified(&ipv6_hdr->src);\n            break;\n\n        case IPHC_SAC_SAM_CTX_64:\n            assert(ctx != NULL);\n            memcpy(ipv6_hdr->src.u8 + 8, iphc_hdr + payload_offset, 8);\n            ipv6_addr_init_prefix(&ipv6_hdr->src, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 8;\n            break;\n\n        case IPHC_SAC_SAM_CTX_16:\n            assert(ctx != NULL);\n            ipv6_hdr->src.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->src.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->src.u8 + 14, iphc_hdr + payload_offset, 2);\n            ipv6_addr_init_prefix(&ipv6_hdr->src, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 2;\n            break;\n\n        case IPHC_SAC_SAM_CTX_L2:\n            assert(ctx != NULL);\n            if (gnrc_netif_hdr_ipv6_iid_from_src(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->src.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get source's IID\\n\");\n                return 0;\n            }\n            ipv6_addr_init_prefix(&ipv6_hdr->src, &ctx->prefix,\n                                  ctx->prefix_len);\n            break;\n    }\n\n    if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_DAC) {\n        uint8_t dci = 0;\n\n        if (iphc_hdr[IPHC2_IDX] & SIXLOWPAN_IPHC2_CID_EXT) {\n            dci = iphc_hdr[CID_EXT_IDX] & 0x0f;\n        }\n\n        if (iphc_hdr[IPHC2_IDX] & (SIXLOWPAN_IPHC2_M | SIXLOWPAN_IPHC2_DAM)) {\n            ctx = gnrc_sixlowpan_ctx_lookup_id(dci);\n\n            if (ctx == NULL) {\n                DEBUG(\"6lo iphc: could not find destination context\\n\");\n                return 0;\n            }\n        }\n    }\n\n    switch (iphc_hdr[IPHC2_IDX] & (SIXLOWPAN_IPHC2_M | SIXLOWPAN_IPHC2_DAC |\n                                   SIXLOWPAN_IPHC2_DAM)) {\n        case IPHC_M_DAC_DAM_U_FULL:\n        case IPHC_M_DAC_DAM_M_FULL:\n            memcpy(&(ipv6_hdr->dst.u8), iphc_hdr + payload_offset, 16);\n            payload_offset += 16;\n            break;\n\n        case IPHC_M_DAC_DAM_U_64:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->dst);\n            memcpy(ipv6_hdr->dst.u8 + 8, iphc_hdr + payload_offset, 8);\n            payload_offset += 8;\n            break;\n\n        case IPHC_M_DAC_DAM_U_16:\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->dst.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->dst.u8 + 14, iphc_hdr + payload_offset, 2);\n            payload_offset += 2;\n            break;\n\n        case IPHC_M_DAC_DAM_U_L2:\n            if (gnrc_netif_hdr_ipv6_iid_from_dst(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->dst.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n                return 0;\n            }\n            ipv6_addr_set_link_local_prefix(&ipv6_hdr->dst);\n            break;\n\n        case IPHC_M_DAC_DAM_U_CTX_64:\n            assert(ctx != NULL);\n            memcpy(ipv6_hdr->dst.u8 + 8, iphc_hdr + payload_offset, 8);\n            ipv6_addr_init_prefix(&ipv6_hdr->dst, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 8;\n            break;\n\n        case IPHC_M_DAC_DAM_U_CTX_16:\n            ipv6_hdr->dst.u32[2] = byteorder_htonl(0x000000ff);\n            ipv6_hdr->dst.u16[6] = byteorder_htons(0xfe00);\n            memcpy(ipv6_hdr->dst.u8 + 14, iphc_hdr + payload_offset, 2);\n            assert(ctx != NULL);\n            ipv6_addr_init_prefix(&ipv6_hdr->dst, &ctx->prefix,\n                                  ctx->prefix_len);\n            payload_offset += 2;\n            break;\n\n        case IPHC_M_DAC_DAM_U_CTX_L2:\n            if (gnrc_netif_hdr_ipv6_iid_from_dst(\n                        iface, netif_hdr, (eui64_t *)(&ipv6_hdr->dst.u64[1])\n                    ) < 0) {\n                DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n                return 0;\n            }\n            assert(ctx != NULL);\n            ipv6_addr_init_prefix(&ipv6_hdr->dst, &ctx->prefix,\n                                  ctx->prefix_len);\n            break;\n\n        case IPHC_M_DAC_DAM_M_48:\n            /* ffXX::00XX:XXXX:XXXX */\n            ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u8[0] = 0xff;\n            ipv6_hdr->dst.u8[1] = iphc_hdr[payload_offset++];\n            memcpy(ipv6_hdr->dst.u8 + 11, iphc_hdr + payload_offset, 5);\n            payload_offset += 5;\n            break;\n\n        case IPHC_M_DAC_DAM_M_32:\n            /* ffXX::00XX:XXXX */\n            ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u8[0] = 0xff;\n            ipv6_hdr->dst.u8[1] = iphc_hdr[payload_offset++];\n            memcpy(ipv6_hdr->dst.u8 + 13, iphc_hdr + payload_offset, 3);\n            payload_offset += 3;\n            break;\n\n        case IPHC_M_DAC_DAM_M_8:\n            /* ff02::XX: */\n            ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n            ipv6_hdr->dst.u8[0] = 0xff;\n            ipv6_hdr->dst.u8[1] = 0x02;\n            ipv6_hdr->dst.u8[15] = iphc_hdr[payload_offset++];\n            break;\n\n        case IPHC_M_DAC_DAM_M_UC_PREFIX:\n            do {\n                assert(ctx != NULL);\n                uint8_t orig_ctx_len = ctx->prefix_len;\n\n                ipv6_addr_set_unspecified(&ipv6_hdr->dst);\n\n                if (ctx->prefix_len > 64) {\n                    ctx->prefix_len = 64;\n                }\n\n                ipv6_hdr->dst.u8[0] = 0xff;\n                ipv6_hdr->dst.u8[1] = iphc_hdr[payload_offset++];\n                ipv6_hdr->dst.u8[2] = iphc_hdr[payload_offset++];\n                ipv6_hdr->dst.u8[3] = ctx->prefix_len;\n                ipv6_addr_init_prefix((ipv6_addr_t *)(ipv6_hdr->dst.u8 + 4),\n                                      &ctx->prefix, ctx->prefix_len);\n                memcpy(ipv6_hdr->dst.u8 + 12, iphc_hdr + payload_offset + 2, 4);\n\n                payload_offset += 4;\n                ctx->prefix_len = orig_ctx_len;\n            } while (0);    /* ANSI-C compatible block creation for orig_ctx_len allocation */\n            break;\n\n        default:\n            DEBUG(\"6lo iphc: unspecified or reserved M, DAC, DAM combination\\n\");\n            break;\n    }\n    return payload_offset;\n}\n\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\nstatic size_t _iphc_nhc_ipv6_ext_decode(gnrc_pktsnip_t *sixlo, size_t offset,\n                                        size_t *prev_nh_offset,\n                                        gnrc_pktsnip_t *ipv6,\n                                        size_t *uncomp_hdr_len)\n{\n    uint8_t *payload = sixlo->data;\n    ipv6_ext_t *ext_hdr;\n    uint8_t ipv6_ext_nhc = payload[offset++];\n    uint8_t protnum;\n    uint8_t ext_len = (ipv6_ext_nhc & NHC_IPV6_EXT_NH)\n                    ? payload[offset]\n                    : payload[offset + 1];\n\n    /* realloc size for uncompressed snip, if too small */\n    if (ipv6->size < (*uncomp_hdr_len + sizeof(ipv6_ext_t) + ext_len)) {\n        if (gnrc_pktbuf_realloc_data(ipv6,\n                                     *uncomp_hdr_len + sizeof(ipv6_ext_t) +\n                                     ext_len)) {\n            DEBUG(\"6lo iphc: unable to decode IPv6 Extension header NHC \"\n                  \"(not enough buffer space)\\n\");\n            return 0;\n        }\n    }\n    ext_hdr = (ipv6_ext_t *)((uint8_t *)ipv6->data + *uncomp_hdr_len);\n    switch (ipv6_ext_nhc & NHC_IPV6_EXT_EID_MASK) {\n        case NHC_IPV6_EXT_EID_HOPOPT:\n            protnum = PROTNUM_IPV6_EXT_HOPOPT;\n            break;\n        case NHC_IPV6_EXT_EID_RH:\n            protnum = PROTNUM_IPV6_EXT_RH;\n            break;\n        case NHC_IPV6_EXT_EID_FRAG:\n            protnum = PROTNUM_IPV6_EXT_FRAG;\n            break;\n        case NHC_IPV6_EXT_EID_DST:\n            protnum = PROTNUM_IPV6_EXT_DST;\n            break;\n        case NHC_IPV6_EXT_EID_MOB:\n            protnum = PROTNUM_IPV6_EXT_MOB;\n            break;\n        default:\n            DEBUG(\"6lo iphc: unexpected extension header EID %u\\n\",\n                  (ipv6_ext_nhc & NHC_IPV6_EXT_EID_MASK) >> 1U);\n            return 0;\n    }\n    ((uint8_t *)ipv6->data)[*prev_nh_offset] = protnum;\n    if (!(ipv6_ext_nhc & NHC_IPV6_EXT_NH)) {\n        ext_hdr->nh = payload[offset++];\n        /* signal end of next header compression to caller */\n        *prev_nh_offset = 0;\n    }\n    else {\n        *prev_nh_offset = (&ext_hdr->nh) - ((uint8_t *)ipv6->data);\n    }\n    /* skip already fetched length field */\n    offset++;\n    ext_hdr->len = ((sizeof(ipv6_ext_t) + ext_len) - IPV6_EXT_LEN_UNIT) /\n                   IPV6_EXT_LEN_UNIT;\n    memcpy(ext_hdr + 1, &payload[offset], ext_len);\n    offset += ext_len;\n    *uncomp_hdr_len += sizeof(ipv6_ext_t) + ext_len;\n    return offset;\n}\n\nstatic size_t _iphc_nhc_ipv6_decode(gnrc_pktsnip_t *sixlo, size_t offset,\n                                    const gnrc_sixlowpan_frag_rb_t *rbuf,\n                                    size_t *prev_nh_offset,\n                                    gnrc_pktsnip_t *ipv6,\n                                    size_t *uncomp_hdr_len)\n{\n    uint8_t *payload = sixlo->data;\n    uint8_t ipv6_nhc = payload[offset];\n\n    switch (ipv6_nhc & NHC_IPV6_EXT_EID_MASK) {\n        case NHC_IPV6_EXT_EID_HOPOPT:\n        case NHC_IPV6_EXT_EID_RH:\n        case NHC_IPV6_EXT_EID_FRAG:\n        case NHC_IPV6_EXT_EID_DST:\n        case NHC_IPV6_EXT_EID_MOB: {\n            size_t tmp;\n            tmp = _iphc_nhc_ipv6_ext_decode(sixlo, offset, prev_nh_offset,\n                                            ipv6, uncomp_hdr_len);\n            if (tmp == 0) {\n                /* unable to parse IPHC header */\n                return 0;\n            }\n            offset = tmp;\n            break;\n        }\n        case NHC_IPV6_EXT_EID_IPV6: {\n            gnrc_pktsnip_t *netif = gnrc_pktsnip_search_type(sixlo,\n                                                             GNRC_NETTYPE_NETIF);\n            ipv6_hdr_t *ipv6_hdr;\n            uint16_t payload_len;\n            size_t tmp;\n\n            offset++;   /* move over NHC header */\n            /* realloc size for uncompressed snip, if too small */\n            if (ipv6->size < (*uncomp_hdr_len + sizeof(ipv6_hdr_t))) {\n                if (gnrc_pktbuf_realloc_data(ipv6,\n                                             *uncomp_hdr_len +\n                                             sizeof(ipv6_hdr_t))) {\n                    DEBUG(\"6lo iphc: unable to decode IPv6 encapsulated header \"\n                          \"NHC (not enough buffer space)\\n\");\n                    return 0;\n                }\n            }\n            ipv6_hdr = (ipv6_hdr_t *)(((uint8_t *)ipv6->data) + *uncomp_hdr_len);\n            tmp = _iphc_ipv6_decode(&payload[offset], netif->data,\n                                    gnrc_netif_hdr_get_netif(netif->data),\n                                    ipv6_hdr);\n            if (tmp == 0) {\n                /* unable to parse IPHC header */\n                return 0;\n            }\n            ((uint8_t *)ipv6->data)[*prev_nh_offset] = PROTNUM_IPV6;\n            if (payload[offset + IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n                *prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n            }\n            else {\n                /* signal end of next header compression to caller */\n                *prev_nh_offset = 0;\n            }\n            offset += tmp;\n            /* might be needed to be overwritten by IPv6 reassembly after the IPv6\n             * packet was reassembled to get complete length */\n            if (rbuf != NULL) {\n                if (_is_rfrag(sixlo)) {\n                    payload_len = (rbuf->super.datagram_size + *uncomp_hdr_len) -\n                                  (sizeof(ipv6_hdr_t) - offset);\n                }\n                else {\n                    payload_len = rbuf->super.datagram_size - *uncomp_hdr_len -\n                                  sizeof(ipv6_hdr_t);\n                }\n            }\n            else {\n                payload_len = (sixlo->size + *uncomp_hdr_len) -\n                              sizeof(ipv6_hdr_t) - offset;\n            }\n            ipv6_hdr->len = byteorder_htons(payload_len);\n            *uncomp_hdr_len += sizeof(ipv6_hdr_t);\n            break;\n        }\n        default:\n            DEBUG(\"6lo iphc: unknown IPv6 extension header EID\\n\");\n            break;\n    }\n    return offset;\n}\n\n/**\n * @brief   Decodes UDP NHC\n *\n * @param[in] sixlo                 The IPHC encoded packet\n * @param[in] offset                The offset of the NHC encoded header\n * @param[in] rbuf                  Reassembly buffer entry if @p ipv6 is a\n *                                  fragmented datagram. May be NULL, if @p ipv6\n *                                  is not fragmented\n * @param[out] prev_nh_offset       Offset to previous nh field in\n *                                  gnrc_pktsnip_t::data of @p ipv6\n * @param[out] ipv6                 The packet to write the decoded data to\n * @param[in,out] uncomp_hdr_len    Number of bytes already decoded into @p ipv6\n *                                  by IPHC and other NHC. Adds size of @ref\n *                                  udp_hdr_t after successful UDP header\n *                                  decompression\n *\n * @return  The offset after UDP NHC header on success.\n * @return  0 on error.\n */\nstatic size_t _iphc_nhc_udp_decode(gnrc_pktsnip_t *sixlo, size_t offset,\n                                   const gnrc_sixlowpan_frag_rb_t *rbuf,\n                                   size_t prev_nh_offset, gnrc_pktsnip_t *ipv6,\n                                   size_t *uncomp_hdr_len)\n{\n    uint8_t *payload = sixlo->data;\n    udp_hdr_t *udp_hdr;\n    uint16_t payload_len;\n    uint8_t udp_nhc = payload[offset++];\n    uint8_t tmp;\n\n    /* realloc size for uncompressed snip, if too small */\n    if (ipv6->size < (*uncomp_hdr_len + sizeof(udp_hdr_t))) {\n        if (gnrc_pktbuf_realloc_data(ipv6,\n                                     *uncomp_hdr_len + sizeof(udp_hdr_t))) {\n            DEBUG(\"6lo: unable to decode UDP NHC (not enough buffer space)\\n\");\n            return 0;\n        }\n    }\n    udp_hdr = (udp_hdr_t *)((uint8_t *)ipv6->data + *uncomp_hdr_len);\n    network_uint16_t *src_port = &(udp_hdr->src_port);\n    network_uint16_t *dst_port = &(udp_hdr->dst_port);\n\n    switch (udp_nhc & NHC_UDP_PP_MASK) {\n\n        case NHC_UDP_SD_INLINE:\n            DEBUG(\"6lo iphc nhc: SD_INLINE\\n\");\n            src_port->u8[0] = payload[offset++];\n            src_port->u8[1] = payload[offset++];\n            dst_port->u8[0] = payload[offset++];\n            dst_port->u8[1] = payload[offset++];\n            break;\n\n        case NHC_UDP_S_INLINE:\n            DEBUG(\"6lo iphc nhc: S_INLINE\\n\");\n            src_port->u8[0] = payload[offset++];\n            src_port->u8[1] = payload[offset++];\n            *dst_port = byteorder_htons(payload[offset++] + NHC_UDP_8BIT_PORT);\n            break;\n\n        case NHC_UDP_D_INLINE:\n            DEBUG(\"6lo iphc nhc: D_INLINE\\n\");\n            *src_port = byteorder_htons(payload[offset++] + NHC_UDP_8BIT_PORT);\n            dst_port->u8[0] = payload[offset++];\n            dst_port->u8[1] = payload[offset++];\n            break;\n\n        case NHC_UDP_SD_ELIDED:\n            DEBUG(\"6lo iphc nhc: SD_ELIDED\\n\");\n            tmp = payload[offset++];\n            *src_port = byteorder_htons((tmp >> 4) + NHC_UDP_4BIT_PORT);\n            *dst_port = byteorder_htons((tmp & 0xf) + NHC_UDP_4BIT_PORT);\n            break;\n\n        default:\n            break;\n    }\n\n    if ((udp_nhc & NHC_UDP_C_ELIDED) != 0) {\n        DEBUG(\"6lo iphc nhc: unsupported elided checksum\\n\");\n        return 0;\n    }\n    else {\n        udp_hdr->checksum.u8[0] = payload[offset++];\n        udp_hdr->checksum.u8[1] = payload[offset++];\n    }\n\n    /* might be needed to be overwritten by IPv6 reassembly after the IPv6\n     * packet was reassembled to get complete length */\n    if (rbuf != NULL) {\n        if (_is_rfrag(sixlo)) {\n            payload_len = rbuf->super.datagram_size + sizeof(udp_hdr_t) -\n                          offset;\n        }\n        else {\n            payload_len = rbuf->super.datagram_size - *uncomp_hdr_len;\n        }\n    }\n    else {\n        payload_len = sixlo->size + sizeof(udp_hdr_t) - offset;\n    }\n    udp_hdr->length = byteorder_htons(payload_len);\n    *uncomp_hdr_len += sizeof(udp_hdr_t);\n    ((uint8_t *)ipv6->data)[prev_nh_offset] = PROTNUM_UDP;\n\n    return offset;\n}\n#endif\n\nstatic inline void _recv_error_release(gnrc_pktsnip_t *sixlo,\n                                       gnrc_pktsnip_t *ipv6,\n                                       gnrc_sixlowpan_frag_rb_t *rbuf) {\n    if (rbuf != NULL) {\n        gnrc_sixlowpan_frag_rb_remove(rbuf);\n    }\n    gnrc_pktbuf_release(ipv6);\n    gnrc_pktbuf_release(sixlo);\n}\n\nvoid gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,\n                              unsigned page)\n{\n    assert(sixlo != NULL);\n    gnrc_pktsnip_t *ipv6, *netif;\n    gnrc_netif_t *iface;\n    ipv6_hdr_t *ipv6_hdr;\n    uint8_t *iphc_hdr = sixlo->data;\n    size_t payload_offset;\n    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (sixlo->size < 2U) {\n        DEBUG(\"6lo iphc: IPHC header truncated\\n\");\n        if (rbuf != NULL) {\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n        }\n        gnrc_pktbuf_release(sixlo);\n        return;\n    }\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n        /* unable to parse IPHC header or malicious packet */\n        DEBUG(\"6lo iphc: malformed IPHC header\\n\");\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        if (_is_rfrag(sixlo)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  rbuf->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)payload_offset);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)uncomp_hdr_len);\n            /* set IPv6 header payload length field to the length of whatever is\n             * left after removing the 6LoWPAN header and adding uncompressed\n             * headers */\n            payload_len = (rbuf->super.datagram_size - payload_offset) +\n                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", payload_len);\n            /* adapt datagram size for uncompressed datagram */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n            /* guard required because SFR-specific field of vrbe is accessed */\n            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);\n            rbuf->super.datagram_size += rbuf->offset_diff;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n        }\n        else {\n            /* for a fragmented datagram we know the overall length already */\n            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            sixlo = gnrc_pkt_delete(sixlo, netif);\n            ipv6 = gnrc_pkt_append(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n                return;\n            }\n        }\n        /* reallocate to copy complete payload */\n        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        /* set IPv6 header payload length field to the length of whatever is left\n         * after removing the 6LoWPAN header and adding uncompressed headers */\n        payload_len = (sixlo->size + uncomp_hdr_len -\n                       payload_offset - sizeof(ipv6_hdr_t));\n    }\n    if (rbuf == NULL) {\n        /* (rbuf == NULL) => forwarding is not affected by this */\n        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n\n    /* re-assign IPv6 header in case realloc changed the address */\n    ipv6_hdr = ipv6->data;\n    ipv6_hdr->len = byteorder_htons(payload_len);\n    if (sixlo->size > payload_offset) {\n        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n               ((uint8_t *)sixlo->data) + payload_offset,\n               sixlo->size - payload_offset);\n    }\n    if (rbuf != NULL) {\n        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        if (vrbe != NULL) {\n            int res = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            ipv6_hdr->hl--;\n            vrbe->super.current_size = rbuf->super.current_size;\n            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n                /* guard required because SFR-specific field of vrbe is\n                 * accessed */\n                if (_is_rfrag(sixlo)) {\n                    vrbe->in_netif = iface;\n                    /* calculate offset difference due to compression */\n                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -\n                                        sixlo->size;\n                }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* empty list, as it should be in VRB now */\n                    rbuf->super.ints = NULL;\n                }\n            }\n            if ((ipv6 == NULL) || (res < 0)) {\n                /* TODO: There is a potential to fall-back to classic reassembly\n                 * when ipv6 != NULL. However, since `ipv6` was reversed in\n                 * `_encode_frag_for_forwarding`, that step needs to be reversed\n                 * or a version of the old ipv6 needs to be held in the buffer.\n                 * For now, just drop the packet all together in an error case\n                 */\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n            gnrc_pktbuf_release(sixlo);\n            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        sixlo = gnrc_pkt_delete(sixlo, netif);\n        ipv6 = gnrc_pkt_append(ipv6, netif);\n        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);\n    }\n    gnrc_pktbuf_release(sixlo);\n    return;\n}\n\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\nstatic gnrc_pktsnip_t *_encode_frag_for_forwarding(gnrc_pktsnip_t *decoded_pkt,\n                                                   gnrc_sixlowpan_frag_vrb_t *vrbe)\n{\n    gnrc_pktsnip_t *res;\n    gnrc_netif_hdr_t *netif_hdr;\n\n    /* mark IPv6 header to allow for next header compression */\n    res = gnrc_pktbuf_mark(decoded_pkt, sizeof(ipv6_hdr_t), GNRC_NETTYPE_IPV6);\n    if (res == NULL) {\n        DEBUG(\"6lo iphc: unable to mark IPv6 header for forwarding\\n\");\n        gnrc_pktbuf_release(decoded_pkt);\n        return NULL;\n    }\n    res = gnrc_pktbuf_reverse_snips(decoded_pkt);\n    if (res == NULL) {\n        DEBUG(\"6lo iphc: unable to reverse packet for forwarding\\n\");\n        /* decoded_pkt is released in gnrc_pktbuf_reverse_snips() */\n        return NULL;\n    }\n    /* set netif header from VRB for correct encoding */\n    netif_hdr = res->data;\n    /* _iphc_encode only checks the destination address, so leave src\n     * untouched */\n    netif_hdr->dst_l2addr_len = vrbe->super.dst_len;\n    gnrc_netif_hdr_set_dst_addr(netif_hdr, vrbe->super.dst,\n                                vrbe->super.dst_len);\n    gnrc_netif_hdr_set_netif(netif_hdr, vrbe->out_netif);\n    decoded_pkt = res;\n    if ((res = _iphc_encode(decoded_pkt, netif_hdr, vrbe->out_netif))) {\n        return res;\n    }\n    else {\n        DEBUG(\"6lo iphc: unable to compress packet for forwarding\\n\");\n        gnrc_pktbuf_release(decoded_pkt);\n        return NULL;\n    }\n}\n\nstatic int _forward_frag(gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *frag_hdr,\n                         gnrc_sixlowpan_frag_vrb_t *vrbe, unsigned page)\n{\n    /* remove rewritten netif header (forwarding implementation must do this\n     * anyway) */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt);\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n        sixlowpan_frag_is(frag_hdr->data)) {\n        return gnrc_sixlowpan_frag_minfwd_forward(pkt, frag_hdr->data, vrbe,\n                                                  page);\n    }\n    /* the following is just debug output for testing without any forwarding\n     * scheme */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n    if (sixlowpan_sfr_rfrag_is(frag_hdr->data)) {\n        return gnrc_sixlowpan_frag_sfr_forward(pkt, frag_hdr->data, vrbe, page);\n    }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n    DEBUG(\"6lo iphc: Do not know how to forward fragment from (%s, %u) \",\n          gnrc_netif_addr_to_str(vrbe->super.src, vrbe->super.src_len,\n                                 addr_str), vrbe->super.tag);\n    DEBUG(\"to (%s, %u)\\n\",\n          gnrc_netif_addr_to_str(vrbe->super.dst, vrbe->super.dst_len,\n                                 addr_str), vrbe->out_tag);\n    if (IS_ACTIVE(ENABLE_DEBUG) && IS_USED(MODULE_OD)) {\n        DEBUG(\"Original fragmentation header:\\n\");\n        od_hex_dump(frag_hdr->data, frag_hdr->size, OD_WIDTH_DEFAULT);\n        DEBUG(\"IPHC headers + payload:\\n\");\n        frag_hdr = pkt;\n        while (frag_hdr) {\n            od_hex_dump(frag_hdr->data, frag_hdr->size, OD_WIDTH_DEFAULT);\n            frag_hdr = frag_hdr->next;\n        }\n    }\n    gnrc_pktbuf_release(pkt);\n    (void)frag_hdr;\n    (void)page;\n    return -ENOTSUP;\n}\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\nstatic inline bool _compressible_nh(uint8_t nh)\n{\n    switch (nh) {\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n        case PROTNUM_IPV6_EXT_HOPOPT:\n        case PROTNUM_UDP:\n        case PROTNUM_IPV6:\n        case PROTNUM_IPV6_EXT_RH:\n        case PROTNUM_IPV6_EXT_FRAG:\n        case PROTNUM_IPV6_EXT_DST:\n        case PROTNUM_IPV6_EXT_MOB:\n            return true;\n#endif\n        default:\n            return false;\n    }\n}\n\nstatic size_t _iphc_ipv6_encode(gnrc_pktsnip_t *pkt,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface,\n                                uint8_t *iphc_hdr)\n{\n    gnrc_sixlowpan_ctx_t *src_ctx = NULL, *dst_ctx = NULL;\n    ipv6_hdr_t *ipv6_hdr;\n    bool addr_comp = false;\n    uint16_t inline_pos = SIXLOWPAN_IPHC_HDR_LEN;\n\n    assert(iface != NULL);\n\n    if (pkt->next == NULL) {\n        DEBUG(\"6lo iphc: packet missing header\\n\");\n        return 0;\n    }\n    ipv6_hdr = pkt->next->data;\n\n    /* set initial dispatch value*/\n    iphc_hdr[IPHC1_IDX] = SIXLOWPAN_IPHC1_DISP;\n    iphc_hdr[IPHC2_IDX] = 0;\n\n    /* check for available contexts */\n    if (!ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        src_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->src));\n        /* do not use source context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (src_ctx && !(src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            src_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (src_ctx &&\n            ipv6_addr_match_prefix(&src_ctx->prefix, &ipv6_hdr->src) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            src_ctx = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&ipv6_hdr->dst)) {\n        dst_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->dst));\n        /* do not use destination context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (dst_ctx && !(dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            dst_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (dst_ctx &&\n            ipv6_addr_match_prefix(&dst_ctx->prefix, &ipv6_hdr->dst) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            dst_ctx = NULL;\n        }\n    }\n\n    /* if contexts available and both != 0 */\n    /* since this moves inline_pos we have to do this ahead*/\n    if (((src_ctx != NULL) &&\n            ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) ||\n        ((dst_ctx != NULL) &&\n            ((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0))) {\n        /* add context identifier extension */\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_CID_EXT;\n        iphc_hdr[CID_EXT_IDX] = 0;\n\n        /* move position to behind CID extension */\n        inline_pos += SIXLOWPAN_IPHC_CID_EXT_LEN;\n    }\n\n    /* compress flow label and traffic class */\n    if (ipv6_hdr_get_fl(ipv6_hdr) == 0) {\n        if (ipv6_hdr_get_tc(ipv6_hdr) == 0) {\n            /* elide both traffic class and flow label */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_ELIDE;\n        }\n        else {\n            /* elide flow label, traffic class (ECN + DSCP) inline (1 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(ipv6_hdr) == 0) {\n            /* elide DSCP, ECN + 2-bit pad + flow label inline (3 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_FL;\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_tc_ecn(ipv6_hdr) << 6) |\n                                               ((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16));\n        }\n        else {\n            /* ECN + DSCP + 4-bit pad + flow label (4 bytes) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP_FL;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16);\n        }\n\n        /* copy remaining bytes of flow label */\n        iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x0000ff00) >> 8);\n        iphc_hdr[inline_pos++] = (uint8_t)(ipv6_hdr_get_fl(ipv6_hdr) & 0x000000ff);\n    }\n\n    /* check for compressible next header */\n    if (_compressible_nh(ipv6_hdr->nh)) {\n        iphc_hdr[IPHC1_IDX] |= SIXLOWPAN_IPHC1_NH;\n    }\n    else {\n        iphc_hdr[inline_pos++] = ipv6_hdr->nh;\n    }\n\n    /* compress hop limit */\n    switch (ipv6_hdr->hl) {\n        case 1:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_1;\n            break;\n\n        case 64:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_64;\n            break;\n\n        case 255:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_255;\n            break;\n\n        default:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_INLINE;\n            iphc_hdr[inline_pos++] = ipv6_hdr->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_UNSPEC;\n    }\n    else {\n        if (src_ctx != NULL) {\n            /* stateful source address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_SAC;\n\n            if (((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) << 4);\n            }\n        }\n\n        if ((src_ctx != NULL) || ipv6_addr_is_link_local(&(ipv6_hdr->src))) {\n            eui64_t iid;\n            iid.uint64.u64 = 0;\n\n            gnrc_netif_acquire(iface);\n            if (gnrc_netif_ipv6_get_iid(iface, &iid) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(iface);\n                return 0;\n            }\n            gnrc_netif_release(iface);\n\n            if ((ipv6_hdr->src.u64[1].u64 == iid.uint64.u64) ||\n                _context_overlaps_iid(src_ctx, &ipv6_hdr->src, &iid)) {\n                /* 0 bits. The address is derived from link-layer address */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_L2;\n                addr_comp = true;\n            }\n            else if ((byteorder_ntohl(ipv6_hdr->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(ipv6_hdr->src.u16[6]) == 0xfe00)) {\n                /* 16 bits. The address is derived using 16 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_16;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u16 + 7, 2);\n                inline_pos += 2;\n                addr_comp = true;\n            }\n            else {\n                /* 64 bits. The address is derived using 64 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_64;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u64 + 1, 8);\n                inline_pos += 8;\n                addr_comp = true;\n            }\n        }\n\n        if (!addr_comp) {\n            /* full address is carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n            memcpy(iphc_hdr + inline_pos, &ipv6_hdr->src, 16);\n            inline_pos += 16;\n        }\n    }\n\n    addr_comp = false;\n\n    /* M: Multicast compression */\n    if (ipv6_addr_is_multicast(&(ipv6_hdr->dst))) {\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_M;\n\n        /* if multicast address is of format ffXX::XXXX:XXXX:XXXX */\n        if ((ipv6_hdr->dst.u16[1].u16 == 0) &&\n            (ipv6_hdr->dst.u32[1].u32 == 0) &&\n            (ipv6_hdr->dst.u16[4].u16 == 0)) {\n            /* if multicast address is of format ff02::XX */\n            if ((ipv6_hdr->dst.u8[1] == 0x02) &&\n                (ipv6_hdr->dst.u32[2].u32 == 0) &&\n                (ipv6_hdr->dst.u16[6].u16 == 0) &&\n                (ipv6_hdr->dst.u8[14] == 0)) {\n                /* 8 bits. The address is derived using 8 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_8;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[15];\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX */\n            else if ((ipv6_hdr->dst.u16[5].u16 == 0) &&\n                     (ipv6_hdr->dst.u8[12] == 0)) {\n                /* 32 bits. The address is derived using 32 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_32;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 13, 3);\n                inline_pos += 3;\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX:XXXX */\n            else if (ipv6_hdr->dst.u8[10] == 0) {\n                /* 48 bits. The address is derived using 48 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_48;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 11, 5);\n                inline_pos += 5;\n                addr_comp = true;\n            }\n        }\n        /* try unicast prefix based compression */\n        else {\n            gnrc_sixlowpan_ctx_t *ctx;\n            ipv6_addr_t unicast_prefix;\n            unicast_prefix.u16[0] = ipv6_hdr->dst.u16[2];\n            unicast_prefix.u16[1] = ipv6_hdr->dst.u16[3];\n            unicast_prefix.u16[2] = ipv6_hdr->dst.u16[4];\n            unicast_prefix.u16[3] = ipv6_hdr->dst.u16[5];\n\n            ctx = gnrc_sixlowpan_ctx_lookup_addr(&unicast_prefix);\n\n            if ((ctx != NULL) && (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP) &&\n                (ctx->prefix_len == ipv6_hdr->dst.u8[3])) {\n                /* Unicast prefix based IPv6 multicast address\n                 * (https://tools.ietf.org/html/rfc3306) with given context\n                 * for unicast prefix -> context based compression */\n                iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n                if ((ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0) {\n                    iphc_hdr[CID_EXT_IDX] |= (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n                }\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[2];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u16 + 6, 4);\n                inline_pos += 4;\n                addr_comp = true;\n            }\n        }\n    }\n    else if (((dst_ctx != NULL) ||\n              ipv6_addr_is_link_local(&ipv6_hdr->dst)) && (netif_hdr->dst_l2addr_len > 0)) {\n        eui64_t iid;\n\n        if (dst_ctx != NULL) {\n            /* stateful destination address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n\n            if (((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= (dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(iface, netif_hdr, &iid) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((ipv6_hdr->dst.u64[1].u64 == iid.uint64.u64) ||\n            _context_overlaps_iid(dst_ctx, &(ipv6_hdr->dst), &iid)) {\n            /* 0 bits. The address is derived using the link-layer address */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_L2;\n            addr_comp = true;\n        }\n        else if ((byteorder_ntohl(ipv6_hdr->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(ipv6_hdr->dst.u16[6]) == 0xfe00)) {\n            /* 16 bits. The address is derived using 16 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_16;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u16[7]), 2);\n            inline_pos += 2;\n            addr_comp = true;\n        }\n        else {\n            /* 64 bits. The address is derived using 64 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_64;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u8[8]), 8);\n            inline_pos += 8;\n            addr_comp = true;\n        }\n    }\n\n    if (!addr_comp) {\n        /* full destination address is carried inline */\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n        memcpy(iphc_hdr + inline_pos, &ipv6_hdr->dst, 16);\n        inline_pos += 16;\n    }\n\n    return inline_pos;\n}\n\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\nstatic ssize_t _iphc_nhc_ipv6_ext_encode(uint8_t *nhc_data,\n                                        const gnrc_pktsnip_t *ext,\n                                        uint16_t ext_len,\n                                        uint8_t *protnum)\n{\n    const ipv6_ext_t *ext_hdr = ext->data;\n    size_t nhc_len = 1; /* skip over NHC header */\n    uint8_t nh = ext_hdr->nh;\n\n    /* From https://tools.ietf.org/html/rfc6282#section-4.1:\n     * > The Length field contained in a compressed IPv6 Extension Header\n     * > indicates the number of octets that pertain to the (compressed)\n     * > extension header following the Length field.\n     *\n     * ipv6_ext_t is nh + length field so subtract it\n     */\n    ext_len -= sizeof(ipv6_ext_t);\n    if (ext_len > UINT8_MAX) {\n        /* From https://tools.ietf.org/html/rfc6282#section-4.1:\n         * > Note that specifying units in octets means that LOWPAN_NHC MUST NOT\n         * > be used to encode IPv6 Extension Headers that have more than 255\n         * > octets following the Length field after compression. */\n        return 0;\n    }\n    /* Set IPv6 extension compression header type\n     * (see https://tools.ietf.org/html/rfc6282#section-4.2). */\n    nhc_data[0] = NHC_IPV6_EXT_ID;\n    switch (*protnum) {\n        case PROTNUM_IPV6_EXT_HOPOPT:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_HOPOPT;\n            /* TODO: decrement ext_len by length of trailing Pad1/PadN option:\n             * > IPv6 Hop-by-Hop and Destination Options Headers may use a trailing\n             * > Pad1 or PadN to achieve 8-octet alignment.  When there is a single\n             * > trailing Pad1 or PadN option of 7 octets or less and the containing\n             * > header is a multiple of 8 octets, the trailing Pad1 or PadN option\n             * > MAY be elided by the compressor. */\n            break;\n        case PROTNUM_IPV6_EXT_RH:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_RH;\n            break;\n        case PROTNUM_IPV6_EXT_FRAG:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_FRAG;\n            break;\n        case PROTNUM_IPV6_EXT_DST:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_DST;\n            /* TODO: decrement ext_len by length of trailing Pad1/PadN option:\n             * > IPv6 Hop-by-Hop and Destination Options Headers may use a trailing\n             * > Pad1 or PadN to achieve 8-octet alignment.  When there is a single\n             * > trailing Pad1 or PadN option of 7 octets or less and the containing\n             * > header is a multiple of 8 octets, the trailing Pad1 or PadN option\n             * > MAY be elided by the compressor. */\n            break;\n        case PROTNUM_IPV6_EXT_MOB:\n            nhc_data[0] |= NHC_IPV6_EXT_EID_MOB;\n            break;\n        default:\n            return -1;\n    }\n    if (_compressible_nh(nh) &&\n        /* carry next header inline when fragment header and offset is equal to\n         * 0 (which means the next header indicates the next header after the\n         * fragment header in the *first fragment*) */\n        ((*protnum != PROTNUM_IPV6_EXT_FRAG) ||\n         (ipv6_ext_frag_get_offset((ipv6_ext_frag_t *)ext_hdr) == 0))) {\n        nhc_data[0] |= NHC_IPV6_EXT_NH;\n    }\n    else {\n        nhc_data[nhc_len++] = ext_hdr->nh;\n        /* prevent next header from being encoded regardless (e.g. if not\n         * first IPv6 fragment) */\n        nh = PROTNUM_RESERVED;\n    }\n    /* integer overflow prevented by `ext_len > UINT8_MAX` check above */\n    nhc_data[nhc_len++] = (uint8_t)ext_len;\n    memcpy(&nhc_data[nhc_len], ext_hdr + 1, ext_len);\n    *protnum = nh;\n    return nhc_len + ext_len;\n}\n\nstatic inline size_t iphc_nhc_udp_encode(uint8_t *nhc_data,\n                                         const gnrc_pktsnip_t *udp)\n{\n    const udp_hdr_t *udp_hdr = udp->data;\n    uint16_t src_port = byteorder_ntohs(udp_hdr->src_port);\n    uint16_t dst_port = byteorder_ntohs(udp_hdr->dst_port);\n    size_t nhc_len = 1; /* skip over NHC header */\n\n    /* Set UDP NHC header type\n     * (see https://tools.ietf.org/html/rfc6282#section-4.3). */\n    nhc_data[0] = NHC_UDP_ID;\n    /* Compressing UDP ports, follow the same sequence as the linux kernel (nhc_udp module). */\n    if (((src_port & NHC_UDP_4BIT_MASK) == NHC_UDP_4BIT_PORT) &&\n        ((dst_port & NHC_UDP_4BIT_MASK) == NHC_UDP_4BIT_PORT)) {\n        DEBUG(\"6lo iphc nhc: elide src and dst\\n\");\n        nhc_data[0] |= NHC_UDP_SD_ELIDED;\n        nhc_data[nhc_len++] = dst_port - NHC_UDP_4BIT_PORT +\n                              ((src_port - NHC_UDP_4BIT_PORT) << 4);\n    }\n    else if ((dst_port & NHC_UDP_8BIT_MASK) == NHC_UDP_8BIT_PORT) {\n        DEBUG(\"6lo iphc nhc: elide dst\\n\");\n        nhc_data[0] |= NHC_UDP_S_INLINE;\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[1];\n        nhc_data[nhc_len++] = dst_port - NHC_UDP_8BIT_PORT;\n    }\n    else if ((src_port & NHC_UDP_8BIT_MASK) == NHC_UDP_8BIT_PORT) {\n        DEBUG(\"6lo iphc nhc: elide src\\n\");\n        nhc_data[0] |= NHC_UDP_D_INLINE;\n        nhc_data[nhc_len++] = src_port - NHC_UDP_8BIT_PORT;\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[1];\n    }\n    else {\n        DEBUG(\"6lo iphc nhc: src and dst inline\\n\");\n        nhc_data[0] |= NHC_UDP_SD_INLINE;\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->src_port.u8[1];\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[0];\n        nhc_data[nhc_len++] = udp_hdr->dst_port.u8[1];\n    }\n\n    /* TODO: Add support for elided checksum. */\n    nhc_data[nhc_len++] = udp_hdr->checksum.u8[0];\n    nhc_data[nhc_len++] = udp_hdr->checksum.u8[1];\n\n    return nhc_len;\n}\n\nstatic bool _remove_header(gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *hdr,\n                           size_t exp_hdr_size)\n{\n    if (hdr->size > exp_hdr_size) {\n        hdr = gnrc_pktbuf_mark(hdr, exp_hdr_size,\n                               GNRC_NETTYPE_UNDEF);\n\n        if (hdr == NULL) {\n            DEBUG(\"6lo iphc: unable to remove compressed header\\n\");\n            return false;\n        }\n    }\n    gnrc_pktbuf_remove_snip(pkt, hdr);\n    return true;\n}\n\nstatic ssize_t _nhc_ipv6_encode_snip(gnrc_pktsnip_t *pkt,\n                                     const gnrc_netif_hdr_t *netif_hdr,\n                                     gnrc_netif_t *iface,\n                                     uint8_t *nhc_data,\n                                     uint8_t *nh)\n{\n    gnrc_pktsnip_t *hdr = pkt->next->next;\n    ssize_t nhc_len = 1;    /* skip over NHC header */\n    size_t tmp;\n    uint8_t new_nh = ((ipv6_hdr_t *)hdr->data)->nh;\n\n    assert(hdr->size >= sizeof(ipv6_hdr_t));\n    /* Set IPv6 extension compression header type\n     * (see https://tools.ietf.org/html/rfc6282#section-4.2). */\n    nhc_data[0] = NHC_IPV6_EXT_ID;\n    if (_compressible_nh(new_nh)) {\n        nhc_data[0] |= NHC_IPV6_EXT_NH;\n    }\n    else {\n        nhc_data[nhc_len++] = new_nh;\n    }\n    /* save to cast as result is max 40 */\n    tmp = (ssize_t)_iphc_ipv6_encode(hdr, netif_hdr, iface, &nhc_data[nhc_len]);\n    if (tmp == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        return -1;\n    }\n    nhc_len += tmp;\n    /* remove encapsulated IPv6 header */\n    if (!_remove_header(pkt, hdr, sizeof(ipv6_hdr_t))) {\n        return -1;\n    }\n    *nh = new_nh;\n    return nhc_len;\n}\n\nstatic ssize_t _nhc_ipv6_ext_encode_snip(gnrc_pktsnip_t *pkt, uint8_t *nhc_data,\n                                         uint8_t *nh)\n{\n    gnrc_pktsnip_t *hdr = pkt->next->next;\n    ipv6_ext_t *ext = hdr->data;\n    ssize_t nhc_len;\n    uint16_t ext_len = ((ext->len * IPV6_EXT_LEN_UNIT) + IPV6_EXT_LEN_UNIT);\n    uint8_t new_nh = *nh;\n\n    assert((hdr->size >= sizeof(ipv6_ext_t)) && (hdr->size >= ext_len));\n    /* _iphc_nhc_ipv6_ext_encode() manipulates nh, so use `new_nh` as temporary\n     * carrier in case of later errors */\n    nhc_len = _iphc_nhc_ipv6_ext_encode(nhc_data, hdr, ext_len, &new_nh);\n    if (nhc_len == 0) {\n        /* extension header is not compressible, so don't compress it and\n         * just copy it after the preceding compression headers */\n        return nhc_len;\n    }\n    /* remove IPv6 extension header */\n    if (!_remove_header(pkt, hdr, ext_len)) {\n        return -1;\n    }\n    *nh = new_nh;\n    return nhc_len;\n}\n\nstatic ssize_t _nhc_udp_encode_snip(gnrc_pktsnip_t *pkt, uint8_t *nhc_data)\n{\n    gnrc_pktsnip_t *hdr = pkt->next->next;\n    ssize_t nhc_len;\n\n    assert(hdr->size >= sizeof(udp_hdr_t));\n    /* save to cast, as result is max 8 */\n    nhc_len = (ssize_t)iphc_nhc_udp_encode(nhc_data, hdr);\n    /* remove UDP header */\n    if (!_remove_header(pkt, hdr, sizeof(udp_hdr_t))) {\n        return -1;\n    }\n    return nhc_len;\n}\n#endif\n\nstatic inline bool _compressible(gnrc_pktsnip_t *hdr)\n{\n    switch (hdr->type) {\n        case GNRC_NETTYPE_UNDEF:    /* when forwarded */\n        case GNRC_NETTYPE_IPV6:\n#if defined(MODULE_GNRC_SIXLOWPAN_IPHC_NHC)\n# if defined(MODULE_GNRC_IPV6_EXT)\n        case GNRC_NETTYPE_IPV6_EXT:\n# endif /* defined(MODULE_GNRC_IPV6_EXT) */\n# if defined(MODULE_GNRC_UDP)\n        case GNRC_NETTYPE_UDP:\n# endif /* defined(MODULE_GNRC_UDP) */\n#endif\n            return true;\n        default:\n            return false;\n    }\n}\n\nstatic gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *iface)\n{\n    assert(pkt != NULL);\n    uint8_t *iphc_hdr;\n    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;\n    size_t dispatch_size = 0;\n    uint16_t inline_pos = 0;\n    uint8_t nh;\n\n    dispatch = NULL;    /* use dispatch as temporary pointer for prev */\n    /* determine maximum dispatch size and write protect all headers until\n     * then because they will be removed */\n    while ((ptr != NULL) && _compressible(ptr)) {\n        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);\n\n        if (tmp == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        ptr = tmp;\n        if (dispatch == NULL) {\n            /* pkt was already write protected in gnrc_sixlowpan.c:_send so\n             * we shouldn't do it again */\n            pkt->next = ptr;    /* reset original packet */\n        }\n        else {\n            dispatch->next = ptr;\n        }\n        dispatch_size += ptr->size;\n        dispatch = ptr; /* use dispatch as temporary point for prev */\n        ptr = ptr->next;\n    }\n    /* there should be at least one compressible header in `pkt`, otherwise this\n     * function should not be called */\n    assert(dispatch_size > 0);\n    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (dispatch == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    iphc_hdr = dispatch->data;\n    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);\n\n    if (inline_pos == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(dispatch);\n        return NULL;\n    }\n\n    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    while (_compressible_nh(nh)) {\n        ssize_t local_pos = 0;\n        if (pkt->next->next == NULL) {\n            DEBUG(\"6lo iphc: packet next header missing data\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        switch (nh) {\n            case PROTNUM_UDP:\n                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */\n                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,\n                                                  &iphc_hdr[inline_pos], &nh);\n                break;\n            }\n            case PROTNUM_IPV6_EXT_HOPOPT:\n            case PROTNUM_IPV6_EXT_RH:\n            case PROTNUM_IPV6_EXT_FRAG:\n            case PROTNUM_IPV6_EXT_DST:\n            case PROTNUM_IPV6_EXT_MOB:\n                local_pos = _nhc_ipv6_ext_encode_snip(pkt,\n                                                      &iphc_hdr[inline_pos],\n                                                      &nh);\n                if (local_pos == 0) {\n                    /* abort loop, extension header is not compressible as\n                     * length field is too large value */\n                    nh = PROTNUM_RESERVED;\n                }\n                break;\n            default:\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n        }\n        if (local_pos < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        inline_pos += local_pos;\n    }\n#endif\n\n    /* shrink dispatch allocation to final size */\n    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */\n    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);\n\n    /* remove IPv6 header */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);\n\n    /* insert dispatch into packet */\n    dispatch->next = pkt->next;\n    pkt->next = dispatch;\n    return pkt;\n}\n\nvoid gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    /* datagram size before compression */\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    /* copying original destination address */\n    }\n\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n\n            if (fb->pkt == pkt) {\n                /* free provided fragmentation buffer */\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}\n\n/** @} */\n"], "filenames": ["sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c"], "buggy_code_start_loc": [1077], "buggy_code_end_loc": [1744], "fixing_code_start_loc": [1077], "fixing_code_end_loc": [1759], "type": "CWE-476", "message": "RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send a crafted frame which is forwarded by the device. During encoding of the packet a NULL pointer dereference occurs. This crashes the device leading to denial of service. A patch is available at pull request 19678. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-33973", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-30T17:15:10.127", "lastModified": "2023-06-06T16:35:11.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send a crafted frame which is forwarded by the device. During encoding of the packet a NULL pointer dereference occurs. This crashes the device leading to denial of service. A patch is available at pull request 19678. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:riot-os:riot:*:*:*:*:*:*:*:*", "versionEndIncluding": "2023.01", "matchCriteriaId": "E3ECD3F7-1DD5-430A-B5E7-50FDFE044CF7"}]}]}], "references": [{"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c#L1067", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c#L1495", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c#L1511", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c#L1644", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c#L1655", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/commit/c9d7863e5664a169035038628029bb07e090c5ff", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/RIOT-OS/RIOT/pull/19678", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-r2pv-3jqc-vh7w", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/RIOT-OS/RIOT/commit/c9d7863e5664a169035038628029bb07e090c5ff"}}