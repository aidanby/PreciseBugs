{"buggy_code": ["import Immutable, { List, Map } from 'immutable';\nimport { signUp } from '../../../connection/database/actions';\nimport { swap, setEntity } from '../../../store';\n\nconst webApiMock = () => require('core/web_api');\nconst coreActionsMock = () => require('core/actions');\njest.mock('core/actions', () => ({\n  validateAndSubmit: jest.fn()\n}));\n\njest.mock('core/web_api', () => ({\n  signUp: jest.fn()\n}));\n\ndescribe('database/actions.js', () => {\n  beforeEach(() => {\n    jest.resetAllMocks();\n  });\n\n  it('signUp splits root attributes correctly', () => {\n    const id = 1;\n    const hookRunner = jest.fn((str, m, context, fn) => fn());\n\n    require('connection/database/index').databaseConnectionName = () => 'test-connection';\n    require('connection/database/index').shouldAutoLogin = () => true;\n\n    const m = Immutable.fromJS({\n      field: {\n        email: {\n          value: 'test@email.com'\n        },\n        password: {\n          value: 'testpass'\n        },\n        family_name: {\n          value: 'test-family-name'\n        },\n        given_name: {\n          value: 'test-given-name'\n        },\n        name: {\n          value: 'test-name'\n        },\n        nickname: {\n          value: 'test-nickname'\n        },\n        picture: {\n          value: 'test-pic'\n        },\n        other_prop: {\n          value: 'test-other'\n        }\n      },\n      database: {\n        additionalSignUpFields: [\n          { name: 'family_name', storage: 'root' },\n          { name: 'given_name', storage: 'root' },\n          { name: 'name', storage: 'root' },\n          { name: 'nickname', storage: 'root' },\n          { name: 'picture', storage: 'root' },\n          { name: 'other_prop' }\n        ]\n      },\n      core: {\n        hookRunner\n      }\n    });\n    swap(setEntity, 'lock', id, m);\n    signUp(id);\n    const {\n      validateAndSubmit: { mock: validateAndSubmitMock }\n    } = coreActionsMock();\n    expect(validateAndSubmitMock.calls.length).toBe(1);\n    expect(validateAndSubmitMock.calls[0][0]).toBe(id);\n    expect(validateAndSubmitMock.calls[0][1]).toContain('email');\n    expect(validateAndSubmitMock.calls[0][1]).toContain('password');\n    validateAndSubmitMock.calls[0][2](m);\n    const {\n      signUp: { mock: signUpMock }\n    } = webApiMock();\n    expect(signUpMock.calls.length).toBe(1);\n    expect(signUpMock.calls[0][0]).toBe(id);\n    expect(signUpMock.calls[0][1]).toMatchObject({\n      connection: 'test-connection',\n      email: 'test@email.com',\n      password: 'testpass',\n      autoLogin: true,\n      family_name: 'test-family-name',\n      given_name: 'test-given-name',\n      name: 'test-name',\n      nickname: 'test-nickname',\n      picture: 'test-pic',\n      user_metadata: {\n        other_prop: 'test-other'\n      }\n    });\n  });\n\n  it('runs the signingUp hook on signUp', () => {\n    const id = 1;\n\n    require('connection/database/index').databaseConnectionName = () => 'test-connection';\n    require('connection/database/index').shouldAutoLogin = () => true;\n\n    const hookRunner = jest.fn((str, m, context, fn) => fn());\n\n    const m = Immutable.fromJS({\n      field: {\n        email: {\n          value: 'test@email.com'\n        },\n        password: {\n          value: 'testpass'\n        }\n      },\n      core: {\n        hookRunner\n      }\n    });\n\n    swap(setEntity, 'lock', id, m);\n\n    signUp(id);\n\n    const {\n      validateAndSubmit: { mock: validateAndSubmitMock }\n    } = coreActionsMock();\n\n    validateAndSubmitMock.calls[0][2](m);\n\n    const {\n      signUp: { mock: signUpMock }\n    } = webApiMock();\n\n    expect(hookRunner).toHaveBeenCalledTimes(1);\n    expect(hookRunner).toHaveBeenCalledWith('signingUp', m, null, expect.any(Function));\n    expect(signUpMock.calls.length).toBe(1);\n    expect(signUpMock.calls[0][0]).toBe(id);\n  });\n});\n", "import Immutable, { Map } from 'immutable';\nimport { getEntity, read, swap, updateEntity } from '../../store/index';\nimport webApi from '../../core/web_api';\nimport { closeLock, logIn as coreLogIn, logInSuccess, validateAndSubmit } from '../../core/actions';\nimport * as l from '../../core/index';\nimport * as c from '../../field/index';\nimport {\n  databaseConnection,\n  databaseConnectionName,\n  databaseConnectionRequiresUsername,\n  databaseLogInWithEmail,\n  hasScreen,\n  setScreen,\n  shouldAutoLogin,\n  toggleTermsAcceptance as internalToggleTermsAcceptance,\n  additionalSignUpFields,\n  signUpHideUsernameField\n} from './index';\n\nimport * as i18n from '../../i18n';\nimport { setCaptchaParams, showMissingCaptcha, swapCaptcha } from '../captcha';\n\nexport function logIn(id, needsMFA = false) {\n  const m = read(getEntity, 'lock', id);\n  const usernameField = databaseLogInWithEmail(m) ? 'email' : 'username';\n  const username = c.getFieldValue(m, usernameField);\n\n  const params = {\n    connection: databaseConnectionName(m),\n    username: username,\n    password: c.getFieldValue(m, 'password')\n  };\n\n  const fields = [usernameField, 'password'];\n  const isCaptchaValid = setCaptchaParams(m, params, fields);\n\n  if (!isCaptchaValid) {\n    return showMissingCaptcha(m, id);\n  }\n\n  const mfaCode = c.getFieldValue(m, 'mfa_code');\n\n  if (needsMFA) {\n    params['mfa_code'] = mfaCode;\n    fields.push('mfa_code');\n  }\n\n  coreLogIn(id, fields, params, (id, error, fields, next) => {\n    if (error.error === 'a0.mfa_required') {\n      return showLoginMFAActivity(id);\n    }\n\n    if (error) {\n      const wasInvalid = error && error.code === 'invalid_captcha';\n      return swapCaptcha(id, wasInvalid, next);\n    }\n\n    next();\n  });\n}\n\nfunction generateRandomUsername(length) {\n  let result = '';\n  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport function signUp(id) {\n  const m = read(getEntity, 'lock', id);\n  const fields = ['email', 'password'];\n\n  // Skip the username validation if signUpHideUsernameField option is enabled.\n  // We will generate a random username to avoid name collusion before we make the signup API call.\n  if (databaseConnectionRequiresUsername(m) && !signUpHideUsernameField(m)) fields.push('username');\n\n  additionalSignUpFields(m).forEach(x => fields.push(x.get('name')));\n\n  validateAndSubmit(id, fields, m => {\n    const params = {\n      connection: databaseConnectionName(m),\n      email: c.getFieldValue(m, 'email'),\n      password: c.getFieldValue(m, 'password'),\n      autoLogin: shouldAutoLogin(m)\n    };\n\n    const isCaptchaValid = setCaptchaParams(m, params, fields);\n    if (!isCaptchaValid) {\n      return showMissingCaptcha(m, id);\n    }\n\n    if (databaseConnectionRequiresUsername(m)) {\n      if (signUpHideUsernameField(m)) {\n        const usernameValidation = databaseConnection(m).getIn(['validation', 'username']);\n        const range = usernameValidation ? usernameValidation.toJS() : { max: 15 };\n        params.username = generateRandomUsername(range.max);\n      } else {\n        params.username = c.getFieldValue(m, 'username');\n      }\n    }\n\n    if (!additionalSignUpFields(m).isEmpty()) {\n      params.user_metadata = {};\n      additionalSignUpFields(m).forEach(x => {\n        const storage = x.get('storage');\n        const fieldName = x.get('name');\n        const fieldValue = c.getFieldValue(m, x.get('name'));\n        switch (storage) {\n          case 'root':\n            params[fieldName] = fieldValue;\n            break;\n          default:\n            if (!params.user_metadata) {\n              params.user_metadata = {};\n            }\n            params.user_metadata[fieldName] = fieldValue;\n            break;\n        }\n      });\n    }\n\n    const errorHandler = (error, popupHandler) => {\n      if (!!popupHandler) {\n        popupHandler._current_popup.kill();\n      }\n\n      const wasInvalidCaptcha = error && error.code === 'invalid_captcha';\n\n      swapCaptcha(id, wasInvalidCaptcha, () => {\n        setTimeout(() => signUpError(id, error), 250);\n      });\n    };\n\n    try {\n      // For now, always pass 'null' for the context as we don't need it yet.\n      // If we need it later, it'll save a breaking change in hooks already in use.\n      const context = null;\n\n      l.runHook(m, 'signingUp', context, () => {\n        webApi.signUp(id, params, (error, result, popupHandler, ...args) => {\n          if (error) {\n            errorHandler(error, popupHandler);\n          } else {\n            signUpSuccess(id, result, popupHandler, ...args);\n          }\n        });\n      });\n    } catch (e) {\n      errorHandler(e);\n    }\n  });\n}\n\nfunction signUpSuccess(id, result, popupHandler) {\n  const lock = read(getEntity, 'lock', id);\n\n  l.emitEvent(lock, 'signup success', result);\n\n  if (shouldAutoLogin(lock)) {\n    swap(updateEntity, 'lock', id, m => m.set('signedUp', true));\n\n    // TODO: check options, redirect is missing\n    const options = {\n      connection: databaseConnectionName(lock),\n      username: c.email(lock),\n      password: c.password(lock)\n    };\n\n    if (!!popupHandler) {\n      options.popupHandler = popupHandler;\n    }\n\n    return webApi.logIn(id, options, l.auth.params(lock).toJS(), (error, ...args) => {\n      if (error) {\n        setTimeout(() => autoLogInError(id, error), 250);\n      } else {\n        logInSuccess(id, ...args);\n      }\n    });\n  }\n\n  const autoclose = l.ui.autoclose(lock);\n\n  if (!autoclose) {\n    swap(updateEntity, 'lock', id, lock => l.setSubmitting(lock, false).set('signedUp', true));\n  } else {\n    closeLock(id, false);\n  }\n}\n\nexport function signUpError(id, error) {\n  const m = read(getEntity, 'lock', id);\n\n  const invalidPasswordKeys = {\n    PasswordDictionaryError: 'password_dictionary_error',\n    PasswordNoUserInfoError: 'password_no_user_info_error',\n    PasswordStrengthError: 'password_strength_error'\n  };\n\n  l.emitEvent(m, 'signup error', error);\n\n  const errorKey =\n    (error.code === 'invalid_password' && invalidPasswordKeys[error.name]) || error.code;\n\n  let errorMessage =\n    i18n.html(m, ['error', 'signUp', errorKey]) ||\n    i18n.html(m, ['error', 'signUp', 'lock.fallback']);\n\n  if (error.code === 'hook_error') {\n    swap(updateEntity, 'lock', id, l.setSubmitting, false, error.description || errorMessage);\n    return;\n  }\n\n  if (errorKey === 'invalid_captcha') {\n    errorMessage = i18n.html(m, ['error', 'login', errorKey]);\n    return swapCaptcha(id, true, () => {\n      swap(updateEntity, 'lock', id, l.setSubmitting, false, errorMessage);\n    });\n  }\n\n  swap(updateEntity, 'lock', id, l.setSubmitting, false, errorMessage);\n}\n\nfunction autoLogInError(id, error) {\n  swap(updateEntity, 'lock', id, m => {\n    const errorMessage = l.loginErrorMessage(m, error);\n    if (hasScreen(m, 'login')) {\n      return l.setSubmitting(setScreen(m, 'login'), false, errorMessage);\n    } else {\n      return l.setSubmitting(m, false, errorMessage);\n    }\n  });\n}\n\nexport function resetPassword(id) {\n  validateAndSubmit(id, ['email'], m => {\n    const params = {\n      connection: databaseConnectionName(m),\n      email: c.getFieldValue(m, 'email')\n    };\n\n    webApi.resetPassword(id, params, (error, ...args) => {\n      if (error) {\n        setTimeout(() => resetPasswordError(id, error), 250);\n      } else {\n        resetPasswordSuccess(id);\n      }\n    });\n  });\n}\n\nfunction resetPasswordSuccess(id) {\n  const m = read(getEntity, 'lock', id);\n  if (hasScreen(m, 'login')) {\n    swap(\n      updateEntity,\n      'lock',\n      id,\n      m => setScreen(l.setSubmitting(m, false), 'login', ['']) // array with one empty string tells the function to not clear any field\n    );\n\n    // TODO: should be handled by box\n    setTimeout(() => {\n      const successMessage = i18n.html(m, ['success', 'forgotPassword']);\n      swap(updateEntity, 'lock', id, l.setGlobalSuccess, successMessage);\n    }, 500);\n  } else {\n    if (l.ui.autoclose(m)) {\n      closeLock(id);\n    } else {\n      swap(updateEntity, 'lock', id, m => l.setSubmitting(m, false).set('passwordResetted', true));\n    }\n  }\n}\n\nfunction resetPasswordError(id, error) {\n  const m = read(getEntity, 'lock', id);\n\n  const errorMessage =\n    i18n.html(m, ['error', 'forgotPassword', error.code]) ||\n    i18n.html(m, ['error', 'forgotPassword', 'lock.fallback']);\n\n  swap(updateEntity, 'lock', id, l.setSubmitting, false, errorMessage);\n}\n\nexport function showLoginActivity(id, fields = ['password']) {\n  swap(updateEntity, 'lock', id, setScreen, 'login', fields);\n}\n\nexport function showSignUpActivity(id, fields = ['password']) {\n  swap(updateEntity, 'lock', id, setScreen, 'signUp', fields);\n}\n\nexport function showResetPasswordActivity(id, fields = ['password']) {\n  swap(updateEntity, 'lock', id, setScreen, 'forgotPassword', fields);\n}\n\nexport function cancelResetPassword(id) {\n  return showLoginActivity(id);\n}\n\nexport function cancelMFALogin(id) {\n  return showLoginActivity(id);\n}\n\nexport function toggleTermsAcceptance(id) {\n  swap(updateEntity, 'lock', id, internalToggleTermsAcceptance);\n}\n\nexport function showLoginMFAActivity(id, fields = ['mfa_code']) {\n  swap(updateEntity, 'lock', id, setScreen, 'mfaLogin', fields);\n}\n"], "fixing_code": ["import Immutable, { List, Map } from 'immutable';\nimport { signUp } from '../../../connection/database/actions';\nimport { swap, setEntity } from '../../../store';\n\nconst webApiMock = () => require('core/web_api');\nconst coreActionsMock = () => require('core/actions');\njest.mock('core/actions', () => ({\n  validateAndSubmit: jest.fn()\n}));\n\njest.mock('core/web_api', () => ({\n  signUp: jest.fn()\n}));\n\ndescribe('database/actions.js', () => {\n  beforeEach(() => {\n    jest.resetAllMocks();\n  });\n\n  it('signUp splits root attributes correctly', () => {\n    const id = 1;\n    const hookRunner = jest.fn((str, m, context, fn) => fn());\n\n    require('connection/database/index').databaseConnectionName = () => 'test-connection';\n    require('connection/database/index').shouldAutoLogin = () => true;\n\n    const m = Immutable.fromJS({\n      field: {\n        email: {\n          value: 'test@email.com'\n        },\n        password: {\n          value: 'testpass'\n        },\n        family_name: {\n          value: 'test-family-name'\n        },\n        given_name: {\n          value: 'test-given-name'\n        },\n        name: {\n          value: 'test-name'\n        },\n        nickname: {\n          value: 'test-nickname'\n        },\n        picture: {\n          value: 'test-pic'\n        },\n        other_prop: {\n          value: 'test-other'\n        }\n      },\n      database: {\n        additionalSignUpFields: [\n          { name: 'family_name', storage: 'root' },\n          { name: 'given_name', storage: 'root' },\n          { name: 'name', storage: 'root' },\n          { name: 'nickname', storage: 'root' },\n          { name: 'picture', storage: 'root' },\n          { name: 'other_prop' }\n        ]\n      },\n      core: {\n        hookRunner\n      }\n    });\n    swap(setEntity, 'lock', id, m);\n    signUp(id);\n    const {\n      validateAndSubmit: { mock: validateAndSubmitMock }\n    } = coreActionsMock();\n    expect(validateAndSubmitMock.calls.length).toBe(1);\n    expect(validateAndSubmitMock.calls[0][0]).toBe(id);\n    expect(validateAndSubmitMock.calls[0][1]).toContain('email');\n    expect(validateAndSubmitMock.calls[0][1]).toContain('password');\n    validateAndSubmitMock.calls[0][2](m);\n    const {\n      signUp: { mock: signUpMock }\n    } = webApiMock();\n    expect(signUpMock.calls.length).toBe(1);\n    expect(signUpMock.calls[0][0]).toBe(id);\n    expect(signUpMock.calls[0][1]).toMatchObject({\n      connection: 'test-connection',\n      email: 'test@email.com',\n      password: 'testpass',\n      autoLogin: true,\n      family_name: 'test-family-name',\n      given_name: 'test-given-name',\n      name: 'test-name',\n      nickname: 'test-nickname',\n      picture: 'test-pic',\n      user_metadata: {\n        other_prop: 'test-other'\n      }\n    });\n  });\n\n  it('runs the signingUp hook on signUp', () => {\n    const id = 1;\n\n    require('connection/database/index').databaseConnectionName = () => 'test-connection';\n    require('connection/database/index').shouldAutoLogin = () => true;\n\n    const hookRunner = jest.fn((str, m, context, fn) => fn());\n\n    const m = Immutable.fromJS({\n      field: {\n        email: {\n          value: 'test@email.com'\n        },\n        password: {\n          value: 'testpass'\n        }\n      },\n      core: {\n        hookRunner\n      }\n    });\n\n    swap(setEntity, 'lock', id, m);\n\n    signUp(id);\n\n    const {\n      validateAndSubmit: { mock: validateAndSubmitMock }\n    } = coreActionsMock();\n\n    validateAndSubmitMock.calls[0][2](m);\n\n    const {\n      signUp: { mock: signUpMock }\n    } = webApiMock();\n\n    expect(hookRunner).toHaveBeenCalledTimes(1);\n    expect(hookRunner).toHaveBeenCalledWith('signingUp', m, null, expect.any(Function));\n    expect(signUpMock.calls.length).toBe(1);\n    expect(signUpMock.calls[0][0]).toBe(id);\n  });\n\n  it('sanitizes additionalSignUp fields using dompurify', () => {\n    const id = 1;\n    const hookRunner = jest.fn((str, m, context, fn) => fn());\n\n    require('connection/database/index').databaseConnectionName = () => 'test-connection';\n    require('connection/database/index').shouldAutoLogin = () => true;\n\n    // Test different fields using some examples from DOMPurify\n    // https://github.com/cure53/DOMPurify#some-purification-samples-please\n    const m = Immutable.fromJS({\n      field: {\n        email: {\n          value: 'test@email.com'\n        },\n        password: {\n          value: 'testpass'\n        },\n        family_name: {\n          value: 'Test <a href=\"https://www.google.co.uk\">Fake link</a>' // HTML but not malicious\n        },\n        given_name: {\n          value: '<img src=x onerror=alert(1)//>'\n        },\n        name: {\n          value: '<p>abc<iframe//src=jAva&Tab;script:alert(3)>def</p>'\n        },\n        other_name: {\n          value:\n            '<div onclick=alert(0)><form onsubmit=alert(1)><input onfocus=alert(2) name=parentNode>123</form></div>'\n        }\n      },\n      database: {\n        additionalSignUpFields: [\n          { name: 'family_name', storage: 'root' },\n          { name: 'given_name', storage: 'root' },\n          { name: 'name', storage: 'root' },\n          { name: 'other_name' }\n        ]\n      },\n      core: {\n        hookRunner\n      }\n    });\n\n    swap(setEntity, 'lock', id, m);\n    signUp(id);\n\n    const {\n      validateAndSubmit: { mock: validateAndSubmitMock }\n    } = coreActionsMock();\n\n    validateAndSubmitMock.calls[0][2](m);\n\n    const {\n      signUp: { mock: signUpMock }\n    } = webApiMock();\n\n    expect(signUpMock.calls[0][1]).toMatchObject({\n      connection: 'test-connection',\n      email: 'test@email.com',\n      password: 'testpass',\n      autoLogin: true,\n      family_name: 'Test Fake link',\n      given_name: '',\n      name: 'abc',\n      user_metadata: {\n        other_name: '123'\n      }\n    });\n  });\n});\n", "import { getEntity, read, swap, updateEntity } from '../../store/index';\nimport webApi from '../../core/web_api';\nimport { closeLock, logIn as coreLogIn, logInSuccess, validateAndSubmit } from '../../core/actions';\nimport * as l from '../../core/index';\nimport * as c from '../../field/index';\nimport { sanitize } from 'dompurify';\n\nimport {\n  databaseConnection,\n  databaseConnectionName,\n  databaseConnectionRequiresUsername,\n  databaseLogInWithEmail,\n  hasScreen,\n  setScreen,\n  shouldAutoLogin,\n  toggleTermsAcceptance as internalToggleTermsAcceptance,\n  additionalSignUpFields,\n  signUpHideUsernameField\n} from './index';\n\nimport * as i18n from '../../i18n';\nimport { setCaptchaParams, showMissingCaptcha, swapCaptcha } from '../captcha';\n\nexport function logIn(id, needsMFA = false) {\n  const m = read(getEntity, 'lock', id);\n  const usernameField = databaseLogInWithEmail(m) ? 'email' : 'username';\n  const username = c.getFieldValue(m, usernameField);\n\n  const params = {\n    connection: databaseConnectionName(m),\n    username: username,\n    password: c.getFieldValue(m, 'password')\n  };\n\n  const fields = [usernameField, 'password'];\n  const isCaptchaValid = setCaptchaParams(m, params, fields);\n\n  if (!isCaptchaValid) {\n    return showMissingCaptcha(m, id);\n  }\n\n  const mfaCode = c.getFieldValue(m, 'mfa_code');\n\n  if (needsMFA) {\n    params['mfa_code'] = mfaCode;\n    fields.push('mfa_code');\n  }\n\n  coreLogIn(id, fields, params, (id, error, fields, next) => {\n    if (error.error === 'a0.mfa_required') {\n      return showLoginMFAActivity(id);\n    }\n\n    if (error) {\n      const wasInvalid = error && error.code === 'invalid_captcha';\n      return swapCaptcha(id, wasInvalid, next);\n    }\n\n    next();\n  });\n}\n\nfunction generateRandomUsername(length) {\n  let result = '';\n  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport function signUp(id) {\n  const m = read(getEntity, 'lock', id);\n  const fields = ['email', 'password'];\n\n  // Skip the username validation if signUpHideUsernameField option is enabled.\n  // We will generate a random username to avoid name collusion before we make the signup API call.\n  if (databaseConnectionRequiresUsername(m) && !signUpHideUsernameField(m)) fields.push('username');\n\n  additionalSignUpFields(m).forEach(x => fields.push(x.get('name')));\n\n  validateAndSubmit(id, fields, m => {\n    const params = {\n      connection: databaseConnectionName(m),\n      email: c.getFieldValue(m, 'email'),\n      password: c.getFieldValue(m, 'password'),\n      autoLogin: shouldAutoLogin(m)\n    };\n\n    const isCaptchaValid = setCaptchaParams(m, params, fields);\n    if (!isCaptchaValid) {\n      return showMissingCaptcha(m, id);\n    }\n\n    if (databaseConnectionRequiresUsername(m)) {\n      if (signUpHideUsernameField(m)) {\n        const usernameValidation = databaseConnection(m).getIn(['validation', 'username']);\n        const range = usernameValidation ? usernameValidation.toJS() : { max: 15 };\n        params.username = generateRandomUsername(range.max);\n      } else {\n        params.username = c.getFieldValue(m, 'username');\n      }\n    }\n\n    if (!additionalSignUpFields(m).isEmpty()) {\n      params.user_metadata = {};\n      additionalSignUpFields(m).forEach(x => {\n        const storage = x.get('storage');\n        const fieldName = x.get('name');\n        const fieldValue = sanitize(c.getFieldValue(m, x.get('name')), { ALLOWED_TAGS: [] });\n\n        switch (storage) {\n          case 'root':\n            params[fieldName] = fieldValue;\n            break;\n          default:\n            if (!params.user_metadata) {\n              params.user_metadata = {};\n            }\n            params.user_metadata[fieldName] = fieldValue;\n            break;\n        }\n      });\n    }\n\n    const errorHandler = (error, popupHandler) => {\n      if (!!popupHandler) {\n        popupHandler._current_popup.kill();\n      }\n\n      const wasInvalidCaptcha = error && error.code === 'invalid_captcha';\n\n      swapCaptcha(id, wasInvalidCaptcha, () => {\n        setTimeout(() => signUpError(id, error), 250);\n      });\n    };\n\n    try {\n      // For now, always pass 'null' for the context as we don't need it yet.\n      // If we need it later, it'll save a breaking change in hooks already in use.\n      const context = null;\n\n      l.runHook(m, 'signingUp', context, () => {\n        webApi.signUp(id, params, (error, result, popupHandler, ...args) => {\n          if (error) {\n            errorHandler(error, popupHandler);\n          } else {\n            signUpSuccess(id, result, popupHandler, ...args);\n          }\n        });\n      });\n    } catch (e) {\n      errorHandler(e);\n    }\n  });\n}\n\nfunction signUpSuccess(id, result, popupHandler) {\n  const lock = read(getEntity, 'lock', id);\n\n  l.emitEvent(lock, 'signup success', result);\n\n  if (shouldAutoLogin(lock)) {\n    swap(updateEntity, 'lock', id, m => m.set('signedUp', true));\n\n    // TODO: check options, redirect is missing\n    const options = {\n      connection: databaseConnectionName(lock),\n      username: c.email(lock),\n      password: c.password(lock)\n    };\n\n    if (!!popupHandler) {\n      options.popupHandler = popupHandler;\n    }\n\n    return webApi.logIn(id, options, l.auth.params(lock).toJS(), (error, ...args) => {\n      if (error) {\n        setTimeout(() => autoLogInError(id, error), 250);\n      } else {\n        logInSuccess(id, ...args);\n      }\n    });\n  }\n\n  const autoclose = l.ui.autoclose(lock);\n\n  if (!autoclose) {\n    swap(updateEntity, 'lock', id, lock => l.setSubmitting(lock, false).set('signedUp', true));\n  } else {\n    closeLock(id, false);\n  }\n}\n\nexport function signUpError(id, error) {\n  const m = read(getEntity, 'lock', id);\n\n  const invalidPasswordKeys = {\n    PasswordDictionaryError: 'password_dictionary_error',\n    PasswordNoUserInfoError: 'password_no_user_info_error',\n    PasswordStrengthError: 'password_strength_error'\n  };\n\n  l.emitEvent(m, 'signup error', error);\n\n  const errorKey =\n    (error.code === 'invalid_password' && invalidPasswordKeys[error.name]) || error.code;\n\n  let errorMessage =\n    i18n.html(m, ['error', 'signUp', errorKey]) ||\n    i18n.html(m, ['error', 'signUp', 'lock.fallback']);\n\n  if (error.code === 'hook_error') {\n    swap(updateEntity, 'lock', id, l.setSubmitting, false, error.description || errorMessage);\n    return;\n  }\n\n  if (errorKey === 'invalid_captcha') {\n    errorMessage = i18n.html(m, ['error', 'login', errorKey]);\n    return swapCaptcha(id, true, () => {\n      swap(updateEntity, 'lock', id, l.setSubmitting, false, errorMessage);\n    });\n  }\n\n  swap(updateEntity, 'lock', id, l.setSubmitting, false, errorMessage);\n}\n\nfunction autoLogInError(id, error) {\n  swap(updateEntity, 'lock', id, m => {\n    const errorMessage = l.loginErrorMessage(m, error);\n    if (hasScreen(m, 'login')) {\n      return l.setSubmitting(setScreen(m, 'login'), false, errorMessage);\n    } else {\n      return l.setSubmitting(m, false, errorMessage);\n    }\n  });\n}\n\nexport function resetPassword(id) {\n  validateAndSubmit(id, ['email'], m => {\n    const params = {\n      connection: databaseConnectionName(m),\n      email: c.getFieldValue(m, 'email')\n    };\n\n    webApi.resetPassword(id, params, (error, ...args) => {\n      if (error) {\n        setTimeout(() => resetPasswordError(id, error), 250);\n      } else {\n        resetPasswordSuccess(id);\n      }\n    });\n  });\n}\n\nfunction resetPasswordSuccess(id) {\n  const m = read(getEntity, 'lock', id);\n  if (hasScreen(m, 'login')) {\n    swap(\n      updateEntity,\n      'lock',\n      id,\n      m => setScreen(l.setSubmitting(m, false), 'login', ['']) // array with one empty string tells the function to not clear any field\n    );\n\n    // TODO: should be handled by box\n    setTimeout(() => {\n      const successMessage = i18n.html(m, ['success', 'forgotPassword']);\n      swap(updateEntity, 'lock', id, l.setGlobalSuccess, successMessage);\n    }, 500);\n  } else {\n    if (l.ui.autoclose(m)) {\n      closeLock(id);\n    } else {\n      swap(updateEntity, 'lock', id, m => l.setSubmitting(m, false).set('passwordResetted', true));\n    }\n  }\n}\n\nfunction resetPasswordError(id, error) {\n  const m = read(getEntity, 'lock', id);\n\n  const errorMessage =\n    i18n.html(m, ['error', 'forgotPassword', error.code]) ||\n    i18n.html(m, ['error', 'forgotPassword', 'lock.fallback']);\n\n  swap(updateEntity, 'lock', id, l.setSubmitting, false, errorMessage);\n}\n\nexport function showLoginActivity(id, fields = ['password']) {\n  swap(updateEntity, 'lock', id, setScreen, 'login', fields);\n}\n\nexport function showSignUpActivity(id, fields = ['password']) {\n  swap(updateEntity, 'lock', id, setScreen, 'signUp', fields);\n}\n\nexport function showResetPasswordActivity(id, fields = ['password']) {\n  swap(updateEntity, 'lock', id, setScreen, 'forgotPassword', fields);\n}\n\nexport function cancelResetPassword(id) {\n  return showLoginActivity(id);\n}\n\nexport function cancelMFALogin(id) {\n  return showLoginActivity(id);\n}\n\nexport function toggleTermsAcceptance(id) {\n  swap(updateEntity, 'lock', id, internalToggleTermsAcceptance);\n}\n\nexport function showLoginMFAActivity(id, fields = ['mfa_code']) {\n  swap(updateEntity, 'lock', id, setScreen, 'mfaLogin', fields);\n}\n"], "filenames": ["src/__tests__/connection/database/actions.test.js", "src/connection/database/actions.js"], "buggy_code_start_loc": [139, 1], "buggy_code_end_loc": [139, 111], "fixing_code_start_loc": [140, 0], "fixing_code_end_loc": [211, 113], "type": "CWE-79", "message": "Auth0 is an authentication broker that supports both social and enterprise identity providers, including Active Directory, LDAP, Google Apps, and Salesforce. In versions before `11.33.0`, when the \u00e2\u20ac\u0153additional signup fields\u00e2\u20ac? feature [is configured](https://github.com/auth0/lock#additional-sign-up-fields), a malicious actor can inject invalidated HTML code into these additional fields, which is then stored in the service `user_metdata` payload (using the `name` property). Verification emails, when applicable, are generated using this metadata. It is therefor possible for an actor to craft a malicious link by injecting HTML, which is then rendered as the recipient's name within the delivered email template. You are impacted by this vulnerability if you are using `auth0-lock` version `11.32.2` or lower and are using the \u00e2\u20ac\u0153additional signup fields\u00e2\u20ac? feature in your application. Upgrade to version `11.33.0`.", "other": {"cve": {"id": "CVE-2022-29172", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-05T23:15:09.150", "lastModified": "2023-03-01T19:01:06.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Auth0 is an authentication broker that supports both social and enterprise identity providers, including Active Directory, LDAP, Google Apps, and Salesforce. In versions before `11.33.0`, when the \u00e2\u20ac\u0153additional signup fields\u00e2\u20ac? feature [is configured](https://github.com/auth0/lock#additional-sign-up-fields), a malicious actor can inject invalidated HTML code into these additional fields, which is then stored in the service `user_metdata` payload (using the `name` property). Verification emails, when applicable, are generated using this metadata. It is therefor possible for an actor to craft a malicious link by injecting HTML, which is then rendered as the recipient's name within the delivered email template. You are impacted by this vulnerability if you are using `auth0-lock` version `11.32.2` or lower and are using the \u00e2\u20ac\u0153additional signup fields\u00e2\u20ac? feature in your application. Upgrade to version `11.33.0`."}, {"lang": "es", "value": "Auth0 es un broker de autenticaci\u00f3n que soporta proveedores de identidad social y empresarial, incluyendo Active Directory, LDAP, Google Apps y Salesforce. En las versiones anteriores a \"11.33.0\", cuando la funcionalidad \"additional signup fields\" [est\u00e1 configurada] (https://github.com/auth0/lock#additional-sign-up-fields), un actor malicioso puede inyectar c\u00f3digo HTML inv\u00e1lido en estos campos adicionales, que luego es almacenado en la carga \u00fatil del servicio \"user_metdata\" (usando la propiedad \"name\"). Los correos electr\u00f3nicos de verificaci\u00f3n, cuando son aplicados, son generados usando estos metadatos. Por lo tanto, es posible que un actor dise\u00f1e un enlace malicioso inyectando HTML, que luego es presentado como el nombre del destinatario dentro de la plantilla de correo electr\u00f3nico entregada. Esta vulnerabilidad le afecta si usa la versi\u00f3n \"auth0-lock\" o inferior y usa la funcionalidad de \"additional signup fields\" en su aplicaci\u00f3n. Actualice a versi\u00f3n \"11.33.0\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:auth0:lock:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "11.33.0", "matchCriteriaId": "CFD2AD83-48BA-494A-80F6-79E53F168CFB"}]}]}], "references": [{"url": "https://github.com/auth0/lock/commit/79ae557d331274b114848150f19832ae341771b1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/auth0/lock/security/advisories/GHSA-7ww6-75fj-jcj7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/auth0/lock/commit/79ae557d331274b114848150f19832ae341771b1"}}