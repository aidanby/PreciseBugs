{"buggy_code": ["--TEST--\nBug #70172 - Use After Free Vulnerability in unserialize()\n--XFAIL--\nUnfinished merge, needs fix.\n--FILE--\n<?php\nclass obj implements Serializable {\n\tvar $data;\n\tfunction serialize() {\n\t\treturn serialize($this->data);\n\t}\n\tfunction unserialize($data) {\n\t\t$this->data = unserialize($data);\n\t}\n}\n\nclass obj2 {\n\tvar $ryat;\n\tfunction __wakeup() {\n\t\t$this->ryat = 1;\n\t}\n}\n\n$fakezval = ptr2str(1122334455);\n$fakezval .= ptr2str(0);\n$fakezval .= \"\\x00\\x00\\x00\\x00\";\n$fakezval .= \"\\x01\";\n$fakezval .= \"\\x00\";\n$fakezval .= \"\\x00\\x00\";\n\n$inner = 'r:2;';\n$exploit = 'a:2:{i:0;O:4:\"obj2\":1:{s:4:\"ryat\";C:3:\"obj\":'.strlen($inner).':{'.$inner.'}}i:1;a:1:{i:0;a:1:{i:0;R:4;}}}';\n\n$data = unserialize($exploit);\n\nfor ($i = 0; $i < 5; $i++) {\n\t$v[$i] = $fakezval.$i;\n}\n\nvar_dump($data);\n\nfunction ptr2str($ptr)\n{\n\t$out = '';\n\tfor ($i = 0; $i < 8; $i++) {\n\t\t$out .= chr($ptr & 0xff);\n\t\t$ptr >>= 8;\n\t}\n\treturn $out;\n}\n?>\n--EXPECTF--\narray(2) {\n  [0]=>\n  object(obj2)#%d (1) {\n    [\"ryat\"]=>\n    int(1)\n  }\n  [1]=>\n  array(1) {\n    [0]=>\n    array(1) {\n      [0]=>\n      &object(obj2)#%d (1) {\n        [\"ryat\"]=>\n        int(1)\n      }\n    }\n  }\n}", "/*\n   +----------------------------------------------------------------------+\n   | PHP Version 7                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Jani Lehtim\u00e4ki <jkl@njet.net>                               |\n   |          Thies C. Arntzen <thies@thieso.net>                         |\n   |          Sascha Schumann <sascha@schumann.cx>                        |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n/* {{{ includes\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"php.h\"\n#include \"php_string.h\"\n#include \"php_var.h\"\n#include \"zend_smart_str.h\"\n#include \"basic_functions.h\"\n#include \"php_incomplete_class.h\"\n\n#define COMMON (is_ref ? \"&\" : \"\")\n/* }}} */\n\nstatic void php_array_element_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tphp_printf(\"%*c[\\\"\", level + 1, ' ');\n\t\tPHPWRITE(ZSTR_VAL(key), ZSTR_LEN(key));\n\t\tphp_printf(\"\\\"]=>\\n\");\n\t}\n\tphp_var_dump(zv, level + 2);\n}\n/* }}} */\n\nstatic void php_object_property_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tconst char *prop_name, *class_name;\n\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tint unmangle = zend_unmangle_property_name(key, &class_name, &prop_name);\n\t\tphp_printf(\"%*c[\", level + 1, ' ');\n\n\t\tif (class_name && unmangle == SUCCESS) {\n\t\t\tif (class_name[0] == '*') {\n\t\t\t\tphp_printf(\"\\\"%s\\\":protected\", prop_name);\n\t\t\t} else {\n\t\t\t\tphp_printf(\"\\\"%s\\\":\\\"%s\\\":private\", prop_name, class_name);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_printf(\"\\\"\");\n\t\t\tPHPWRITE(ZSTR_VAL(key), ZSTR_LEN(key));\n\t\t\tphp_printf(\"\\\"\");\n\t\t}\n\t\tZEND_PUTS(\"]=>\\n\");\n\t}\n\tphp_var_dump(zv, level + 2);\n}\n/* }}} */\n\nPHPAPI void php_var_dump(zval *struc, int level) /* {{{ */\n{\n\tHashTable *myht;\n\tzend_string *class_name;\n\tint is_temp;\n\tint is_ref = 0;\n\tzend_ulong num;\n\tzend_string *key;\n\tzval *val;\n\tuint32_t count;\n\n\tif (level > 1) {\n\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t}\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\t\tcase IS_FALSE:\n\t\t\tphp_printf(\"%sbool(false)\\n\", COMMON);\n\t\t\tbreak;\n\t\tcase IS_TRUE:\n\t\t\tphp_printf(\"%sbool(true)\\n\", COMMON);\n\t\t\tbreak;\n\t\tcase IS_NULL:\n\t\t\tphp_printf(\"%sNULL\\n\", COMMON);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tphp_printf(\"%sint(\" ZEND_LONG_FMT \")\\n\", COMMON, Z_LVAL_P(struc));\n\t\t\tbreak;\n\t\tcase IS_DOUBLE:\n\t\t\tphp_printf(\"%sfloat(%.*G)\\n\", COMMON, (int) EG(precision), Z_DVAL_P(struc));\n\t\t\tbreak;\n\t\tcase IS_STRING:\n\t\t\tphp_printf(\"%sstring(%zd) \\\"\", COMMON, Z_STRLEN_P(struc));\n\t\t\tPHPWRITE(Z_STRVAL_P(struc), Z_STRLEN_P(struc));\n\t\t\tPUTS(\"\\\"\\n\");\n\t\t\tbreak;\n\t\tcase IS_ARRAY:\n\t\t\tmyht = Z_ARRVAL_P(struc);\n\t\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht) && ++myht->u.v.nApplyCount > 1) {\n\t\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\t\t--myht->u.v.nApplyCount;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcount = zend_array_count(myht);\n\t\t\tphp_printf(\"%sarray(%d) {\\n\", COMMON, count);\n\t\t\tis_temp = 0;\n\n\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, num, key, val) {\n\t\t\t\tphp_array_element_dump(val, num, key, level);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht)) {\n\t\t\t\t--myht->u.v.nApplyCount;\n\t\t\t}\n\t\t\tif (is_temp) {\n\t\t\t\tzend_hash_destroy(myht);\n\t\t\t\tefree(myht);\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tphp_printf(\"%*c\", level-1, ' ');\n\t\t\t}\n\t\t\tPUTS(\"}\\n\");\n\t\t\tbreak;\n\t\tcase IS_OBJECT:\n\t\t\tif (Z_OBJ_APPLY_COUNT_P(struc) > 0) {\n\t\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tZ_OBJ_INC_APPLY_COUNT_P(struc);\n\n\t\t\tmyht = Z_OBJDEBUG_P(struc, is_temp);\n\t\t\tclass_name = Z_OBJ_HANDLER_P(struc, get_class_name)(Z_OBJ_P(struc));\n\t\t\tphp_printf(\"%sobject(%s)#%d (%d) {\\n\", COMMON, ZSTR_VAL(class_name), Z_OBJ_HANDLE_P(struc), myht ? zend_array_count(myht) : 0);\n\t\t\tzend_string_release(class_name);\n\n\t\t\tif (myht) {\n\t\t\t\tzend_ulong num;\n\t\t\t\tzend_string *key;\n\t\t\t\tzval *val;\n\n\t\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, num, key, val) {\n\t\t\t\t\tphp_object_property_dump(val, num, key, level);\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t\tif (is_temp) {\n\t\t\t\t\tzend_hash_destroy(myht);\n\t\t\t\t\tefree(myht);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tphp_printf(\"%*c\", level-1, ' ');\n\t\t\t}\n\t\t\tPUTS(\"}\\n\");\n\t\t\tZ_OBJ_DEC_APPLY_COUNT_P(struc);\n\t\t\tbreak;\n\t\tcase IS_RESOURCE: {\n\t\t\tconst char *type_name = zend_rsrc_list_get_rsrc_type(Z_RES_P(struc));\n\t\t\tphp_printf(\"%sresource(%pd) of type (%s)\\n\", COMMON, Z_RES_P(struc)->handle, type_name ? type_name : \"Unknown\");\n\t\t\tbreak;\n\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\t//??? hide references with refcount==1 (for compatibility)\n\t\t\tif (Z_REFCOUNT_P(struc) > 1) {\n\t\t\t\tis_ref = 1;\n\t\t\t}\n\t\t\tstruc = Z_REFVAL_P(struc);\n\t\t\tgoto again;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_printf(\"%sUNKNOWN:0\\n\", COMMON);\n\t\t\tbreak;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void var_dump(mixed var)\n   Dumps a string representation of variable to output */\nPHP_FUNCTION(var_dump)\n{\n\tzval *args;\n\tint argc;\n\tint\ti;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"+\", &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\tphp_var_dump(&args[i], 1);\n\t}\n}\n/* }}} */\n\nstatic void zval_array_element_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tphp_printf(\"%*c[\\\"\", level + 1, ' ');\n\t\tPHPWRITE(ZSTR_VAL(key), ZSTR_LEN(key));\n\t\tphp_printf(\"\\\"]=>\\n\");\n\t}\n\tphp_debug_zval_dump(zv, level + 2);\n}\n/* }}} */\n\nstatic void zval_object_property_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tconst char *prop_name, *class_name;\n\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tzend_unmangle_property_name(key, &class_name, &prop_name);\n\t\tphp_printf(\"%*c[\", level + 1, ' ');\n\n\t\tif (class_name) {\n\t\t\tif (class_name[0] == '*') {\n\t\t\t\tphp_printf(\"\\\"%s\\\":protected\", prop_name);\n\t\t\t} else {\n\t\t\t\tphp_printf(\"\\\"%s\\\":\\\"%s\\\":private\", prop_name, class_name);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_printf(\"\\\"%s\\\"\", prop_name);\n\t\t}\n\t\tZEND_PUTS(\"]=>\\n\");\n\t}\n\tphp_debug_zval_dump(zv, level + 2);\n}\n/* }}} */\n\nPHPAPI void php_debug_zval_dump(zval *struc, int level) /* {{{ */\n{\n\tHashTable *myht = NULL;\n\tzend_string *class_name;\n\tint is_temp = 0;\n\tint is_ref = 0;\n\tzend_ulong index;\n\tzend_string *key;\n\tzval *val;\n\tuint32_t count;\n\n\tif (level > 1) {\n\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t}\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\tcase IS_FALSE:\n\t\tphp_printf(\"%sbool(false)\\n\", COMMON);\n\t\tbreak;\n\tcase IS_TRUE:\n\t\tphp_printf(\"%sbool(true)\\n\", COMMON);\n\t\tbreak;\n\tcase IS_NULL:\n\t\tphp_printf(\"%sNULL\\n\", COMMON);\n\t\tbreak;\n\tcase IS_LONG:\n\t\tphp_printf(\"%sint(\" ZEND_LONG_FMT \")\\n\", COMMON, Z_LVAL_P(struc));\n\t\tbreak;\n\tcase IS_DOUBLE:\n\t\tphp_printf(\"%sfloat(%.*G)\\n\", COMMON, (int) EG(precision), Z_DVAL_P(struc));\n\t\tbreak;\n\tcase IS_STRING:\n\t\tphp_printf(\"%sstring(%zd) \\\"\", COMMON, Z_STRLEN_P(struc));\n\t\tPHPWRITE(Z_STRVAL_P(struc), Z_STRLEN_P(struc));\n\t\tphp_printf(\"\\\" refcount(%u)\\n\", Z_REFCOUNTED_P(struc) ? Z_REFCOUNT_P(struc) : 1);\n\t\tbreak;\n\tcase IS_ARRAY:\n\t\tmyht = Z_ARRVAL_P(struc);\n\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht) && myht->u.v.nApplyCount++ > 1) {\n\t\t\tmyht->u.v.nApplyCount--;\n\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcount = zend_array_count(myht);\n\t\tphp_printf(\"%sarray(%d) refcount(%u){\\n\", COMMON, count, Z_REFCOUNTED_P(struc) ? Z_REFCOUNT_P(struc) : 1);\n\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\tzval_array_element_dump(val, index, key, level);\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht)) {\n\t\t\tmyht->u.v.nApplyCount--;\n\t\t}\n\t\tif (is_temp) {\n\t\t\tzend_hash_destroy(myht);\n\t\t\tefree(myht);\n\t\t}\n\t\tif (level > 1) {\n\t\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t\t}\n\t\tPUTS(\"}\\n\");\n\t\tbreak;\n\tcase IS_OBJECT:\n\t\tmyht = Z_OBJDEBUG_P(struc, is_temp);\n\t\tif (myht) {\n\t\t\tif (myht->u.v.nApplyCount > 1) {\n\t\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmyht->u.v.nApplyCount++;\n\t\t\t}\n\t\t}\n\t\tclass_name = Z_OBJ_HANDLER_P(struc, get_class_name)(Z_OBJ_P(struc));\n\t\tphp_printf(\"%sobject(%s)#%d (%d) refcount(%u){\\n\", COMMON, ZSTR_VAL(class_name), Z_OBJ_HANDLE_P(struc), myht ? zend_array_count(myht) : 0, Z_REFCOUNT_P(struc));\n\t\tzend_string_release(class_name);\n\t\tif (myht) {\n\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\t\tzval_object_property_dump(val, index, key, level);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tmyht->u.v.nApplyCount--;\n\t\t\tif (is_temp) {\n\t\t\t\tzend_hash_destroy(myht);\n\t\t\t\tefree(myht);\n\t\t\t}\n\t\t}\n\t\tif (level > 1) {\n\t\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t\t}\n\t\tPUTS(\"}\\n\");\n\t\tbreak;\n\tcase IS_RESOURCE: {\n\t\tconst char *type_name = zend_rsrc_list_get_rsrc_type(Z_RES_P(struc));\n\t\tphp_printf(\"%sresource(%d) of type (%s) refcount(%u)\\n\", COMMON, Z_RES_P(struc)->handle, type_name ? type_name : \"Unknown\", Z_REFCOUNT_P(struc));\n\t\tbreak;\n\t}\n\tcase IS_REFERENCE:\n\t\t//??? hide references with refcount==1 (for compatibility)\n\t\tif (Z_REFCOUNT_P(struc) > 1) {\n\t\t\tis_ref = 1;\n\t\t}\n\t\tstruc = Z_REFVAL_P(struc);\n\t\tgoto again;\n\tdefault:\n\t\tphp_printf(\"%sUNKNOWN:0\\n\", COMMON);\n\t\tbreak;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void debug_zval_dump(mixed var)\n   Dumps a string representation of an internal zend value to output. */\nPHP_FUNCTION(debug_zval_dump)\n{\n\tzval *args;\n\tint argc;\n\tint\ti;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"+\", &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\tphp_debug_zval_dump(&args[i], 1);\n\t}\n}\n/* }}} */\n\n#define buffer_append_spaces(buf, num_spaces) \\\n\tdo { \\\n\t\tchar *tmp_spaces; \\\n\t\tsize_t tmp_spaces_len; \\\n\t\ttmp_spaces_len = spprintf(&tmp_spaces, 0,\"%*c\", num_spaces, ' '); \\\n\t\tsmart_str_appendl(buf, tmp_spaces, tmp_spaces_len); \\\n\t\tefree(tmp_spaces); \\\n\t} while(0);\n\nstatic void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tbuffer_append_spaces(buf, level+1);\n\t\tsmart_str_append_long(buf, (zend_long) index);\n\t\tsmart_str_appendl(buf, \" => \", 4);\n\n\t} else { /* string key */\n\t\tzend_string *tmp_str;\n\t\tzend_string *ckey = php_addcslashes(key, 0, \"'\\\\\", 2);\n\t\ttmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), \"\\0\", 1, \"' . \\\"\\\\0\\\" . '\", 12);\n\n\t\tbuffer_append_spaces(buf, level + 1);\n\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tsmart_str_append(buf, tmp_str);\n\t\tsmart_str_appendl(buf, \"' => \", 5);\n\n\t\tzend_string_free(ckey);\n\t\tzend_string_free(tmp_str);\n\t}\n\tphp_var_export_ex(zv, level + 2, buf);\n\n\tsmart_str_appendc(buf, ',');\n\tsmart_str_appendc(buf, '\\n');\n}\n/* }}} */\n\nstatic void php_object_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */\n{\n\tbuffer_append_spaces(buf, level + 2);\n\tif (key != NULL) {\n\t\tconst char *class_name, *prop_name;\n\t\tsize_t prop_name_len;\n\t\tzend_string *pname_esc;\n\n\t\tzend_unmangle_property_name_ex(key, &class_name, &prop_name, &prop_name_len);\n\t\tpname_esc = php_addcslashes(zend_string_init(prop_name, prop_name_len, 0), 1, \"'\\\\\", 2);\n\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tsmart_str_append(buf, pname_esc);\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tzend_string_release(pname_esc);\n\t} else {\n\t\tsmart_str_append_long(buf, (zend_long) index);\n\t}\n\tsmart_str_appendl(buf, \" => \", 4);\n\tphp_var_export_ex(zv, level + 2, buf);\n\tsmart_str_appendc(buf, ',');\n\tsmart_str_appendc(buf, '\\n');\n}\n/* }}} */\n\nPHPAPI void php_var_export_ex(zval *struc, int level, smart_str *buf) /* {{{ */\n{\n\tHashTable *myht;\n\tchar *tmp_str;\n\tsize_t tmp_len;\n\tzend_string *ztmp, *ztmp2;\n\tzend_ulong index;\n\tzend_string *key;\n\tzval *val;\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\t\tcase IS_FALSE:\n\t\t\tsmart_str_appendl(buf, \"false\", 5);\n\t\t\tbreak;\n\t\tcase IS_TRUE:\n\t\t\tsmart_str_appendl(buf, \"true\", 4);\n\t\t\tbreak;\n\t\tcase IS_NULL:\n\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tsmart_str_append_long(buf, Z_LVAL_P(struc));\n\t\t\tbreak;\n\t\tcase IS_DOUBLE:\n\t\t\ttmp_len = spprintf(&tmp_str, 0,\"%.*H\", PG(serialize_precision), Z_DVAL_P(struc));\n\t\t\tsmart_str_appendl(buf, tmp_str, tmp_len);\n\t\t\t/* Without a decimal point, PHP treats a number literal as an int.\n\t\t\t * This check even works for scientific notation, because the\n\t\t\t * mantissa always contains a decimal point.\n\t\t\t * We need to check for finiteness, because INF, -INF and NAN\n\t\t\t * must not have a decimal point added.\n\t\t\t */\n\t\t\tif (zend_finite(Z_DVAL_P(struc)) && NULL == strchr(tmp_str, '.')) {\n\t\t\t\tsmart_str_appendl(buf, \".0\", 2);\n\t\t\t}\n\t\t\tefree(tmp_str);\n\t\t\tbreak;\n\t\tcase IS_STRING:\n\t\t\tztmp = php_addcslashes(Z_STR_P(struc), 0, \"'\\\\\", 2);\n\t\t\tztmp2 = php_str_to_str(ZSTR_VAL(ztmp), ZSTR_LEN(ztmp), \"\\0\", 1, \"' . \\\"\\\\0\\\" . '\", 12);\n\n\t\t\tsmart_str_appendc(buf, '\\'');\n\t\t\tsmart_str_append(buf, ztmp2);\n\t\t\tsmart_str_appendc(buf, '\\'');\n\n\t\t\tzend_string_free(ztmp);\n\t\t\tzend_string_free(ztmp2);\n\t\t\tbreak;\n\t\tcase IS_ARRAY:\n\t\t\tmyht = Z_ARRVAL_P(struc);\n\t\t\tif (ZEND_HASH_APPLY_PROTECTION(myht) && myht->u.v.nApplyCount++ > 0) {\n\t\t\t\tmyht->u.v.nApplyCount--;\n\t\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\t\tzend_error(E_WARNING, \"var_export does not handle circular references\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tsmart_str_appendc(buf, '\\n');\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\t\t\tsmart_str_appendl(buf, \"array (\\n\", 8);\n\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\t\tphp_array_element_export(val, index, key, level, buf);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tif (ZEND_HASH_APPLY_PROTECTION(myht)) {\n\t\t\t\tmyht->u.v.nApplyCount--;\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\t\t\tsmart_str_appendc(buf, ')');\n\n\t\t\tbreak;\n\n\t\tcase IS_OBJECT:\n\t\t\tmyht = Z_OBJPROP_P(struc);\n\t\t\tif (myht) {\n\t\t\t\tif (myht->u.v.nApplyCount > 0) {\n\t\t\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\t\t\tzend_error(E_WARNING, \"var_export does not handle circular references\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tmyht->u.v.nApplyCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tsmart_str_appendc(buf, '\\n');\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\n\t\t\tsmart_str_append(buf, Z_OBJCE_P(struc)->name);\n\t\t\tsmart_str_appendl(buf, \"::__set_state(array(\\n\", 21);\n\n\t\t\tif (myht) {\n\t\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\t\t\tphp_object_element_export(val, index, key, level, buf);\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t\tmyht->u.v.nApplyCount--;\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\t\t\tsmart_str_appendl(buf, \"))\", 2);\n\n\t\t\tbreak;\n\t\tcase IS_REFERENCE:\n\t\t\tstruc = Z_REFVAL_P(struc);\n\t\t\tgoto again;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\tbreak;\n\t}\n}\n/* }}} */\n\n/* FOR BC reasons, this will always perform and then print */\nPHPAPI void php_var_export(zval *struc, int level) /* {{{ */\n{\n\tsmart_str buf = {0};\n\tphp_var_export_ex(struc, level, &buf);\n\tsmart_str_0(&buf);\n\tPHPWRITE(ZSTR_VAL(buf.s), ZSTR_LEN(buf.s));\n\tsmart_str_free(&buf);\n}\n/* }}} */\n\n/* {{{ proto mixed var_export(mixed var [, bool return])\n   Outputs or returns a string representation of a variable */\nPHP_FUNCTION(var_export)\n{\n\tzval *var;\n\tzend_bool return_output = 0;\n\tsmart_str buf = {0};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"z|b\", &var, &return_output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_var_export_ex(var, 1, &buf);\n\tsmart_str_0 (&buf);\n\n\tif (return_output) {\n\t\tRETURN_NEW_STR(buf.s);\n\t} else {\n\t\tPHPWRITE(ZSTR_VAL(buf.s), ZSTR_LEN(buf.s));\n\t\tsmart_str_free(&buf);\n\t}\n}\n/* }}} */\n\nstatic void php_var_serialize_intern(smart_str *buf, zval *struc, php_serialize_data_t var_hash);\n\nstatic inline zend_long php_add_var_hash(php_serialize_data_t data, zval *var) /* {{{ */\n{\n\tzval *zv;\n\tzend_ulong key;\n\tzend_bool is_ref = Z_ISREF_P(var);\n\n\tdata->n += 1;\n\n\tif (!is_ref && Z_TYPE_P(var) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\t/* References to objects are treated as if the reference didn't exist */\n\tif (is_ref && Z_TYPE_P(Z_REFVAL_P(var)) == IS_OBJECT) {\n\t\tvar = Z_REFVAL_P(var);\n\t}\n\n\t/* Index for the variable is stored using the numeric value of the pointer to\n\t * the zend_refcounted struct */\n\tkey = (zend_ulong) (zend_uintptr_t) Z_COUNTED_P(var);\n\tzv = zend_hash_index_find(&data->ht, key);\n\n\tif (zv) {\n\t\t/* References are only counted once, undo the data->n increment above */\n\t\tif (is_ref) {\n\t\t\tdata->n -= 1;\n\t\t}\n\n\t\treturn Z_LVAL_P(zv);\n\t} else {\n\t\tzval zv_n;\n\t\tZVAL_LONG(&zv_n, data->n);\n\t\tzend_hash_index_add_new(&data->ht, key, &zv_n);\n\n\t\t/* Additionally to the index, we also store the variable, to ensure that it is\n\t\t * not destroyed during serialization and its pointer reused. The variable is\n\t\t * stored at the numeric value of the pointer + 1, which cannot be the location\n\t\t * of another zend_refcounted structure. */\n\t\tzend_hash_index_add_new(&data->ht, key + 1, var);\n\t\tZ_ADDREF_P(var);\n\n\t\treturn 0;\n\t}\n}\n/* }}} */\n\nstatic inline void php_var_serialize_long(smart_str *buf, zend_long val) /* {{{ */\n{\n\tsmart_str_appendl(buf, \"i:\", 2);\n\tsmart_str_append_long(buf, val);\n\tsmart_str_appendc(buf, ';');\n}\n/* }}} */\n\nstatic inline void php_var_serialize_string(smart_str *buf, char *str, size_t len) /* {{{ */\n{\n\tsmart_str_appendl(buf, \"s:\", 2);\n\tsmart_str_append_unsigned(buf, len);\n\tsmart_str_appendl(buf, \":\\\"\", 2);\n\tsmart_str_appendl(buf, str, len);\n\tsmart_str_appendl(buf, \"\\\";\", 2);\n}\n/* }}} */\n\nstatic inline zend_bool php_var_serialize_class_name(smart_str *buf, zval *struc) /* {{{ */\n{\n\tPHP_CLASS_ATTRIBUTES;\n\n\tPHP_SET_CLASS_ATTRIBUTES(struc);\n\tsmart_str_appendl(buf, \"O:\", 2);\n\tsmart_str_append_unsigned(buf, ZSTR_LEN(class_name));\n\tsmart_str_appendl(buf, \":\\\"\", 2);\n\tsmart_str_append(buf, class_name);\n\tsmart_str_appendl(buf, \"\\\":\", 2);\n\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\treturn incomplete_class;\n}\n/* }}} */\n\nstatic HashTable *php_var_serialize_collect_names(HashTable *src, uint32_t count, zend_bool incomplete) /* {{{ */ {\n\tzval *val;\n\tHashTable *ht;\n\tzend_string *key, *name;\n\n\tALLOC_HASHTABLE(ht);\n\tzend_hash_init(ht, count, NULL, NULL, 0);\n\tZEND_HASH_FOREACH_STR_KEY_VAL(src, key, val) {\n\t\tif (incomplete && strcmp(ZSTR_VAL(key), MAGIC_MEMBER) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Z_TYPE_P(val) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_NOTICE,\n\t\t\t\t\t\"__sleep should return an array only containing the names of instance-variables to serialize.\");\n\t\t}\n\t\tname = zval_get_string(val);\n\t\tif (zend_hash_exists(ht, name)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE,\n\t\t\t\t\t\"\\\"%s\\\" is returned from __sleep multiple times\", ZSTR_VAL(name));\n\t\t\tzend_string_release(name);\n\t\t\tcontinue;\n\t\t}\n\t\tzend_hash_add_empty_element(ht, name);\n\t\tzend_string_release(name);\n\t} ZEND_HASH_FOREACH_END();\n\n\treturn ht;\n}\n/* }}} */\n\nstatic void php_var_serialize_class(smart_str *buf, zval *struc, zval *retval_ptr, php_serialize_data_t var_hash) /* {{{ */\n{\n\tuint32_t count;\n\tzend_bool incomplete_class;\n\tHashTable *ht;\n\n\tincomplete_class = php_var_serialize_class_name(buf, struc);\n\t/* count after serializing name, since php_var_serialize_class_name\n\t * changes the count if the variable is incomplete class */\n\tif (Z_TYPE_P(retval_ptr) == IS_ARRAY) {\n\t\tht = Z_ARRVAL_P(retval_ptr);\n\t\tcount = zend_array_count(ht);\n\t} else if (Z_TYPE_P(retval_ptr) == IS_OBJECT) {\n\t\tht = Z_OBJPROP_P(retval_ptr);\n\t\tcount = zend_array_count(ht);\n\t\tif (incomplete_class) {\n\t\t\t--count;\n\t\t}\n\t} else {\n\t\tcount = 0;\n\t\tht = NULL;\n\t}\n\n\tif (count > 0) {\n\t\tzval *d;\n\t\tzval nval, *nvalp;\n\t\tzend_string *name;\n\t\tHashTable *names, *propers;\n\n\t\tnames = php_var_serialize_collect_names(ht, count, incomplete_class);\n\n\t\tsmart_str_append_unsigned(buf, zend_hash_num_elements(names));\n\t\tsmart_str_appendl(buf, \":{\", 2);\n\n\t\tZVAL_NULL(&nval);\n\t\tnvalp = &nval;\n\t\tpropers = Z_OBJPROP_P(struc);\n\n\t\tZEND_HASH_FOREACH_STR_KEY(names, name) {\n\t\t\tif ((d = zend_hash_find(propers, name)) != NULL) {\n\t\t\t\tif (Z_TYPE_P(d) == IS_INDIRECT) {\n\t\t\t\t\td = Z_INDIRECT_P(d);\n\t\t\t\t\tif (Z_TYPE_P(d) == IS_UNDEF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(name), ZSTR_LEN(name));\n\t\t\t\tphp_var_serialize_intern(buf, d, var_hash);\n\t\t\t} else {\n\t\t\t\tzend_class_entry *ce = Z_OBJ_P(struc)->ce;\n\t\t\t\tif (ce) {\n\t\t\t\t\tzend_string *prot_name, *priv_name;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tpriv_name = zend_mangle_property_name(\n\t\t\t\t\t\t\t\tZSTR_VAL(ce->name), ZSTR_LEN(ce->name), ZSTR_VAL(name), ZSTR_LEN(name), ce->type & ZEND_INTERNAL_CLASS);\n\t\t\t\t\t\tif ((d = zend_hash_find(propers, priv_name)) != NULL) {\n\t\t\t\t\t\t\tif (Z_TYPE_P(d) == IS_INDIRECT) {\n\t\t\t\t\t\t\t\td = Z_INDIRECT_P(d);\n\t\t\t\t\t\t\t\tif (Z_ISUNDEF_P(d)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(priv_name), ZSTR_LEN(priv_name));\n\t\t\t\t\t\t\tzend_string_free(priv_name);\n\t\t\t\t\t\t\tphp_var_serialize_intern(buf, d, var_hash);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tzend_string_free(priv_name);\n\t\t\t\t\t\tprot_name = zend_mangle_property_name(\n\t\t\t\t\t\t\t\t\"*\", 1, ZSTR_VAL(name), ZSTR_LEN(name), ce->type & ZEND_INTERNAL_CLASS);\n\t\t\t\t\t\tif ((d = zend_hash_find(propers, prot_name)) != NULL) {\n\t\t\t\t\t\t\tif (Z_TYPE_P(d) == IS_INDIRECT) {\n\t\t\t\t\t\t\t\td = Z_INDIRECT_P(d);\n\t\t\t\t\t\t\t\tif (Z_TYPE_P(d) == IS_UNDEF) {\n\t\t\t\t\t\t\t\t\tzend_string_free(prot_name);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(prot_name), ZSTR_LEN(prot_name));\n\t\t\t\t\t\t\tzend_string_free(prot_name);\n\t\t\t\t\t\t\tphp_var_serialize_intern(buf, d, var_hash);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tzend_string_free(prot_name);\n\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(name), ZSTR_LEN(name));\n\t\t\t\t\t\tphp_var_serialize_intern(buf, nvalp, var_hash);\n\t\t\t\t\t\tphp_error_docref(NULL, E_NOTICE,\n\t\t\t\t\t\t\t\t\"\\\"%s\\\" returned as member variable from __sleep() but does not exist\", ZSTR_VAL(name));\n\t\t\t\t\t} while (0);\n\t\t\t\t} else {\n\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(name), ZSTR_LEN(name));\n\t\t\t\t\tphp_var_serialize_intern(buf, nvalp, var_hash);\n\t\t\t\t}\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tsmart_str_appendc(buf, '}');\n\n\t\tzend_hash_destroy(names);\n\t\tFREE_HASHTABLE(names);\n\t} else {\n\t\tsmart_str_appendl(buf, \"0:{}\", 4);\n\t}\n}\n/* }}} */\n\nstatic void php_var_serialize_intern(smart_str *buf, zval *struc, php_serialize_data_t var_hash) /* {{{ */\n{\n\tzend_long var_already;\n\tHashTable *myht;\n\n\tif (EG(exception)) {\n\t\treturn;\n\t}\n\n\tif (var_hash && (var_already = php_add_var_hash(var_hash, struc))) {\n\t\tif (Z_ISREF_P(struc)) {\n\t\t\tsmart_str_appendl(buf, \"R:\", 2);\n\t\t\tsmart_str_append_long(buf, var_already);\n\t\t\tsmart_str_appendc(buf, ';');\n\t\t\treturn;\n\t\t} else if (Z_TYPE_P(struc) == IS_OBJECT) {\n\t\t\tsmart_str_appendl(buf, \"r:\", 2);\n\t\t\tsmart_str_append_long(buf, var_already);\n\t\t\tsmart_str_appendc(buf, ';');\n\t\t\treturn;\n\t\t}\n\t}\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\t\tcase IS_FALSE:\n\t\t\tsmart_str_appendl(buf, \"b:0;\", 4);\n\t\t\treturn;\n\n\t\tcase IS_TRUE:\n\t\t\tsmart_str_appendl(buf, \"b:1;\", 4);\n\t\t\treturn;\n\n\t\tcase IS_NULL:\n\t\t\tsmart_str_appendl(buf, \"N;\", 2);\n\t\t\treturn;\n\n\t\tcase IS_LONG:\n\t\t\tphp_var_serialize_long(buf, Z_LVAL_P(struc));\n\t\t\treturn;\n\n\t\tcase IS_DOUBLE: {\n\t\t\t\tchar *s;\n\n\t\t\t\tsmart_str_appendl(buf, \"d:\", 2);\n\t\t\t\ts = (char *) safe_emalloc(PG(serialize_precision), 1, MAX_LENGTH_OF_DOUBLE + 1);\n\t\t\t\tphp_gcvt(Z_DVAL_P(struc), (int)PG(serialize_precision), '.', 'E', s);\n\t\t\t\tsmart_str_appends(buf, s);\n\t\t\t\tsmart_str_appendc(buf, ';');\n\t\t\t\tefree(s);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase IS_STRING:\n\t\t\tphp_var_serialize_string(buf, Z_STRVAL_P(struc), Z_STRLEN_P(struc));\n\t\t\treturn;\n\n\t\tcase IS_OBJECT: {\n\t\t\t\tzval retval;\n\t\t\t\tzval fname;\n\t\t\t\tint res;\n\t\t\t\tzend_class_entry *ce = Z_OBJCE_P(struc);\n\n\t\t\t\tif (ce->serialize != NULL) {\n\t\t\t\t\t/* has custom handler */\n\t\t\t\t\tunsigned char *serialized_data = NULL;\n\t\t\t\t\tsize_t serialized_length;\n\n\t\t\t\t\tif (ce->serialize(struc, &serialized_data, &serialized_length, (zend_serialize_data *)var_hash) == SUCCESS) {\n\t\t\t\t\t\tsmart_str_appendl(buf, \"C:\", 2);\n\t\t\t\t\t\tsmart_str_append_unsigned(buf, ZSTR_LEN(Z_OBJCE_P(struc)->name));\n\t\t\t\t\t\tsmart_str_appendl(buf, \":\\\"\", 2);\n\t\t\t\t\t\tsmart_str_append(buf, Z_OBJCE_P(struc)->name);\n\t\t\t\t\t\tsmart_str_appendl(buf, \"\\\":\", 2);\n\n\t\t\t\t\t\tsmart_str_append_unsigned(buf, serialized_length);\n\t\t\t\t\t\tsmart_str_appendl(buf, \":{\", 2);\n\t\t\t\t\t\tsmart_str_appendl(buf, (char *) serialized_data, serialized_length);\n\t\t\t\t\t\tsmart_str_appendc(buf, '}');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(buf, \"N;\", 2);\n\t\t\t\t\t}\n\t\t\t\t\tif (serialized_data) {\n\t\t\t\t\t\tefree(serialized_data);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (ce != PHP_IC_ENTRY && zend_hash_str_exists(&ce->function_table, \"__sleep\", sizeof(\"__sleep\")-1)) {\n\t\t\t\t\tZVAL_STRINGL(&fname, \"__sleep\", sizeof(\"__sleep\") - 1);\n\t\t\t\t\tBG(serialize_lock)++;\n\t\t\t\t\tres = call_user_function_ex(CG(function_table), struc, &fname, &retval, 0, 0, 1, NULL);\n\t\t\t\t\tBG(serialize_lock)--;\n\t\t\t\t\tzval_dtor(&fname);\n\n\t\t\t\t\tif (EG(exception)) {\n\t\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (res == SUCCESS) {\n\t\t\t\t\t\tif (Z_TYPE(retval) != IS_UNDEF) {\n\t\t\t\t\t\t\tif (HASH_OF(&retval)) {\n\t\t\t\t\t\t\t\tphp_var_serialize_class(buf, struc, &retval, var_hash);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL, E_NOTICE, \"__sleep should return an array only containing the names of instance-variables to serialize\");\n\t\t\t\t\t\t\t\t/* we should still add element even if it's not OK,\n\t\t\t\t\t\t\t\t * since we already wrote the length of the array before */\n\t\t\t\t\t\t\t\tsmart_str_appendl(buf,\"N;\", 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t}\n\n\t\t\t\t/* fall-through */\n\t\t\t}\n\t\tcase IS_ARRAY: {\n\t\t\tuint32_t i;\n\t\t\tzend_bool incomplete_class = 0;\n\t\t\tif (Z_TYPE_P(struc) == IS_ARRAY) {\n\t\t\t\tsmart_str_appendl(buf, \"a:\", 2);\n\t\t\t\tmyht = Z_ARRVAL_P(struc);\n\t\t\t\ti = zend_array_count(myht);\n\t\t\t} else {\n\t\t\t\tincomplete_class = php_var_serialize_class_name(buf, struc);\n\t\t\t\tmyht = Z_OBJPROP_P(struc);\n\t\t\t\t/* count after serializing name, since php_var_serialize_class_name\n\t\t\t\t * changes the count if the variable is incomplete class */\n\t\t\t\ti = zend_array_count(myht);\n\t\t\t\tif (i > 0 && incomplete_class) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmart_str_append_unsigned(buf, i);\n\t\t\tsmart_str_appendl(buf, \":{\", 2);\n\t\t\tif (i > 0) {\n\t\t\t\tzend_string *key;\n\t\t\t\tzval *data;\n\t\t\t\tzend_ulong index;\n\n\t\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, data) {\n\n\t\t\t\t\tif (incomplete_class && strcmp(ZSTR_VAL(key), MAGIC_MEMBER) == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!key) {\n\t\t\t\t\t\tphp_var_serialize_long(buf, index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(key), ZSTR_LEN(key));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Z_ISREF_P(data) && Z_REFCOUNT_P(data) == 1) {\n\t\t\t\t\t\tdata = Z_REFVAL_P(data);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* we should still add element even if it's not OK,\n\t\t\t\t\t * since we already wrote the length of the array before */\n\t\t\t\t\tif ((Z_TYPE_P(data) == IS_ARRAY && Z_TYPE_P(struc) == IS_ARRAY && Z_ARR_P(data) == Z_ARR_P(struc))\n\t\t\t\t\t\t|| (Z_TYPE_P(data) == IS_ARRAY && Z_ARRVAL_P(data)->u.v.nApplyCount > 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\tsmart_str_appendl(buf, \"N;\", 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (Z_TYPE_P(data) == IS_ARRAY && ZEND_HASH_APPLY_PROTECTION(Z_ARRVAL_P(data))) {\n\t\t\t\t\t\t\tZ_ARRVAL_P(data)->u.v.nApplyCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_var_serialize_intern(buf, data, var_hash);\n\t\t\t\t\t\tif (Z_TYPE_P(data) == IS_ARRAY && ZEND_HASH_APPLY_PROTECTION(Z_ARRVAL_P(data))) {\n\t\t\t\t\t\t\tZ_ARRVAL_P(data)->u.v.nApplyCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t}\n\t\t\tsmart_str_appendc(buf, '}');\n\t\t\treturn;\n\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\tstruc = Z_REFVAL_P(struc);\n\t\t\tgoto again;\n\t\tdefault:\n\t\t\tsmart_str_appendl(buf, \"i:0;\", 4);\n\t\t\treturn;\n\t}\n}\n/* }}} */\n\nPHPAPI void php_var_serialize(smart_str *buf, zval *struc, php_serialize_data_t *data) /* {{{ */\n{\n\tphp_var_serialize_intern(buf, struc, *data);\n\tsmart_str_0(buf);\n}\n/* }}} */\n\n/* {{{ proto string serialize(mixed variable)\n   Returns a string representation of variable (which can later be unserialized) */\nPHP_FUNCTION(serialize)\n{\n\tzval *struc;\n\tphp_serialize_data_t var_hash;\n\tsmart_str buf = {0};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"z\", &struc) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_VAR_SERIALIZE_INIT(var_hash);\n\tphp_var_serialize(&buf, struc, &var_hash);\n\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\n\tif (EG(exception)) {\n\t\tsmart_str_free(&buf);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf.s) {\n\t\tRETURN_NEW_STR(buf.s);\n\t} else {\n\t\tRETURN_NULL();\n\t}\n}\n/* }}} */\n\n/* {{{ proto mixed unserialize(string variable_representation[, array allowed_classes])\n   Takes a string representation of variable and recreates it */\nPHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int memory_get_usage([bool real_usage])\n   Returns the allocated by PHP memory */\nPHP_FUNCTION(memory_get_usage) {\n\tzend_bool real_usage = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|b\", &real_usage) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(zend_memory_usage(real_usage));\n}\n/* }}} */\n\n/* {{{ proto int memory_get_peak_usage([bool real_usage])\n   Returns the peak allocated by PHP memory */\nPHP_FUNCTION(memory_get_peak_usage) {\n\tzend_bool real_usage = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|b\", &real_usage) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(zend_memory_peak_usage(real_usage));\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "fixing_code": ["--TEST--\nBug #70172 - Use After Free Vulnerability in unserialize()\n--FILE--\n<?php\nclass obj implements Serializable {\n\tvar $data;\n\tfunction serialize() {\n\t\treturn serialize($this->data);\n\t}\n\tfunction unserialize($data) {\n\t\t$this->data = unserialize($data);\n\t}\n}\n\nclass obj2 {\n\tvar $ryat;\n\tfunction __wakeup() {\n\t\t$this->ryat = 1;\n\t}\n}\n\n$fakezval = ptr2str(1122334455);\n$fakezval .= ptr2str(0);\n$fakezval .= \"\\x00\\x00\\x00\\x00\";\n$fakezval .= \"\\x01\";\n$fakezval .= \"\\x00\";\n$fakezval .= \"\\x00\\x00\";\n\n$inner = 'r:2;';\n$exploit = 'a:2:{i:0;O:4:\"obj2\":1:{s:4:\"ryat\";C:3:\"obj\":'.strlen($inner).':{'.$inner.'}}i:1;a:1:{i:0;a:1:{i:0;R:4;}}}';\n\n$data = unserialize($exploit);\n\nfor ($i = 0; $i < 5; $i++) {\n\t$v[$i] = $fakezval.$i;\n}\n\nvar_dump($data);\n\nfunction ptr2str($ptr)\n{\n\t$out = '';\n\tfor ($i = 0; $i < 8; $i++) {\n\t\t$out .= chr($ptr & 0xff);\n\t\t$ptr >>= 8;\n\t}\n\treturn $out;\n}\n?>\n--EXPECTF--\narray(2) {\n  [0]=>\n  object(obj2)#%d (1) {\n    [\"ryat\"]=>\n    int(1)\n  }\n  [1]=>\n  array(1) {\n    [0]=>\n    array(1) {\n      [0]=>\n      object(obj2)#%d (1) {\n        [\"ryat\"]=>\n        int(1)\n      }\n    }\n  }\n}\n", "/*\n   +----------------------------------------------------------------------+\n   | PHP Version 7                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Jani Lehtim\u00e4ki <jkl@njet.net>                               |\n   |          Thies C. Arntzen <thies@thieso.net>                         |\n   |          Sascha Schumann <sascha@schumann.cx>                        |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n/* {{{ includes\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"php.h\"\n#include \"php_string.h\"\n#include \"php_var.h\"\n#include \"zend_smart_str.h\"\n#include \"basic_functions.h\"\n#include \"php_incomplete_class.h\"\n\n#define COMMON (is_ref ? \"&\" : \"\")\n/* }}} */\n\nstatic void php_array_element_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tphp_printf(\"%*c[\\\"\", level + 1, ' ');\n\t\tPHPWRITE(ZSTR_VAL(key), ZSTR_LEN(key));\n\t\tphp_printf(\"\\\"]=>\\n\");\n\t}\n\tphp_var_dump(zv, level + 2);\n}\n/* }}} */\n\nstatic void php_object_property_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tconst char *prop_name, *class_name;\n\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tint unmangle = zend_unmangle_property_name(key, &class_name, &prop_name);\n\t\tphp_printf(\"%*c[\", level + 1, ' ');\n\n\t\tif (class_name && unmangle == SUCCESS) {\n\t\t\tif (class_name[0] == '*') {\n\t\t\t\tphp_printf(\"\\\"%s\\\":protected\", prop_name);\n\t\t\t} else {\n\t\t\t\tphp_printf(\"\\\"%s\\\":\\\"%s\\\":private\", prop_name, class_name);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_printf(\"\\\"\");\n\t\t\tPHPWRITE(ZSTR_VAL(key), ZSTR_LEN(key));\n\t\t\tphp_printf(\"\\\"\");\n\t\t}\n\t\tZEND_PUTS(\"]=>\\n\");\n\t}\n\tphp_var_dump(zv, level + 2);\n}\n/* }}} */\n\nPHPAPI void php_var_dump(zval *struc, int level) /* {{{ */\n{\n\tHashTable *myht;\n\tzend_string *class_name;\n\tint is_temp;\n\tint is_ref = 0;\n\tzend_ulong num;\n\tzend_string *key;\n\tzval *val;\n\tuint32_t count;\n\n\tif (level > 1) {\n\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t}\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\t\tcase IS_FALSE:\n\t\t\tphp_printf(\"%sbool(false)\\n\", COMMON);\n\t\t\tbreak;\n\t\tcase IS_TRUE:\n\t\t\tphp_printf(\"%sbool(true)\\n\", COMMON);\n\t\t\tbreak;\n\t\tcase IS_NULL:\n\t\t\tphp_printf(\"%sNULL\\n\", COMMON);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tphp_printf(\"%sint(\" ZEND_LONG_FMT \")\\n\", COMMON, Z_LVAL_P(struc));\n\t\t\tbreak;\n\t\tcase IS_DOUBLE:\n\t\t\tphp_printf(\"%sfloat(%.*G)\\n\", COMMON, (int) EG(precision), Z_DVAL_P(struc));\n\t\t\tbreak;\n\t\tcase IS_STRING:\n\t\t\tphp_printf(\"%sstring(%zd) \\\"\", COMMON, Z_STRLEN_P(struc));\n\t\t\tPHPWRITE(Z_STRVAL_P(struc), Z_STRLEN_P(struc));\n\t\t\tPUTS(\"\\\"\\n\");\n\t\t\tbreak;\n\t\tcase IS_ARRAY:\n\t\t\tmyht = Z_ARRVAL_P(struc);\n\t\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht) && ++myht->u.v.nApplyCount > 1) {\n\t\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\t\t--myht->u.v.nApplyCount;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcount = zend_array_count(myht);\n\t\t\tphp_printf(\"%sarray(%d) {\\n\", COMMON, count);\n\t\t\tis_temp = 0;\n\n\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, num, key, val) {\n\t\t\t\tphp_array_element_dump(val, num, key, level);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht)) {\n\t\t\t\t--myht->u.v.nApplyCount;\n\t\t\t}\n\t\t\tif (is_temp) {\n\t\t\t\tzend_hash_destroy(myht);\n\t\t\t\tefree(myht);\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tphp_printf(\"%*c\", level-1, ' ');\n\t\t\t}\n\t\t\tPUTS(\"}\\n\");\n\t\t\tbreak;\n\t\tcase IS_OBJECT:\n\t\t\tif (Z_OBJ_APPLY_COUNT_P(struc) > 0) {\n\t\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tZ_OBJ_INC_APPLY_COUNT_P(struc);\n\n\t\t\tmyht = Z_OBJDEBUG_P(struc, is_temp);\n\t\t\tclass_name = Z_OBJ_HANDLER_P(struc, get_class_name)(Z_OBJ_P(struc));\n\t\t\tphp_printf(\"%sobject(%s)#%d (%d) {\\n\", COMMON, ZSTR_VAL(class_name), Z_OBJ_HANDLE_P(struc), myht ? zend_array_count(myht) : 0);\n\t\t\tzend_string_release(class_name);\n\n\t\t\tif (myht) {\n\t\t\t\tzend_ulong num;\n\t\t\t\tzend_string *key;\n\t\t\t\tzval *val;\n\n\t\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, num, key, val) {\n\t\t\t\t\tphp_object_property_dump(val, num, key, level);\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t\tif (is_temp) {\n\t\t\t\t\tzend_hash_destroy(myht);\n\t\t\t\t\tefree(myht);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tphp_printf(\"%*c\", level-1, ' ');\n\t\t\t}\n\t\t\tPUTS(\"}\\n\");\n\t\t\tZ_OBJ_DEC_APPLY_COUNT_P(struc);\n\t\t\tbreak;\n\t\tcase IS_RESOURCE: {\n\t\t\tconst char *type_name = zend_rsrc_list_get_rsrc_type(Z_RES_P(struc));\n\t\t\tphp_printf(\"%sresource(%pd) of type (%s)\\n\", COMMON, Z_RES_P(struc)->handle, type_name ? type_name : \"Unknown\");\n\t\t\tbreak;\n\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\t//??? hide references with refcount==1 (for compatibility)\n\t\t\tif (Z_REFCOUNT_P(struc) > 1) {\n\t\t\t\tis_ref = 1;\n\t\t\t}\n\t\t\tstruc = Z_REFVAL_P(struc);\n\t\t\tgoto again;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_printf(\"%sUNKNOWN:0\\n\", COMMON);\n\t\t\tbreak;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void var_dump(mixed var)\n   Dumps a string representation of variable to output */\nPHP_FUNCTION(var_dump)\n{\n\tzval *args;\n\tint argc;\n\tint\ti;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"+\", &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\tphp_var_dump(&args[i], 1);\n\t}\n}\n/* }}} */\n\nstatic void zval_array_element_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tphp_printf(\"%*c[\\\"\", level + 1, ' ');\n\t\tPHPWRITE(ZSTR_VAL(key), ZSTR_LEN(key));\n\t\tphp_printf(\"\\\"]=>\\n\");\n\t}\n\tphp_debug_zval_dump(zv, level + 2);\n}\n/* }}} */\n\nstatic void zval_object_property_dump(zval *zv, zend_ulong index, zend_string *key, int level) /* {{{ */\n{\n\tconst char *prop_name, *class_name;\n\n\tif (key == NULL) { /* numeric key */\n\t\tphp_printf(\"%*c[\" ZEND_LONG_FMT \"]=>\\n\", level + 1, ' ', index);\n\t} else { /* string key */\n\t\tzend_unmangle_property_name(key, &class_name, &prop_name);\n\t\tphp_printf(\"%*c[\", level + 1, ' ');\n\n\t\tif (class_name) {\n\t\t\tif (class_name[0] == '*') {\n\t\t\t\tphp_printf(\"\\\"%s\\\":protected\", prop_name);\n\t\t\t} else {\n\t\t\t\tphp_printf(\"\\\"%s\\\":\\\"%s\\\":private\", prop_name, class_name);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_printf(\"\\\"%s\\\"\", prop_name);\n\t\t}\n\t\tZEND_PUTS(\"]=>\\n\");\n\t}\n\tphp_debug_zval_dump(zv, level + 2);\n}\n/* }}} */\n\nPHPAPI void php_debug_zval_dump(zval *struc, int level) /* {{{ */\n{\n\tHashTable *myht = NULL;\n\tzend_string *class_name;\n\tint is_temp = 0;\n\tint is_ref = 0;\n\tzend_ulong index;\n\tzend_string *key;\n\tzval *val;\n\tuint32_t count;\n\n\tif (level > 1) {\n\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t}\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\tcase IS_FALSE:\n\t\tphp_printf(\"%sbool(false)\\n\", COMMON);\n\t\tbreak;\n\tcase IS_TRUE:\n\t\tphp_printf(\"%sbool(true)\\n\", COMMON);\n\t\tbreak;\n\tcase IS_NULL:\n\t\tphp_printf(\"%sNULL\\n\", COMMON);\n\t\tbreak;\n\tcase IS_LONG:\n\t\tphp_printf(\"%sint(\" ZEND_LONG_FMT \")\\n\", COMMON, Z_LVAL_P(struc));\n\t\tbreak;\n\tcase IS_DOUBLE:\n\t\tphp_printf(\"%sfloat(%.*G)\\n\", COMMON, (int) EG(precision), Z_DVAL_P(struc));\n\t\tbreak;\n\tcase IS_STRING:\n\t\tphp_printf(\"%sstring(%zd) \\\"\", COMMON, Z_STRLEN_P(struc));\n\t\tPHPWRITE(Z_STRVAL_P(struc), Z_STRLEN_P(struc));\n\t\tphp_printf(\"\\\" refcount(%u)\\n\", Z_REFCOUNTED_P(struc) ? Z_REFCOUNT_P(struc) : 1);\n\t\tbreak;\n\tcase IS_ARRAY:\n\t\tmyht = Z_ARRVAL_P(struc);\n\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht) && myht->u.v.nApplyCount++ > 1) {\n\t\t\tmyht->u.v.nApplyCount--;\n\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcount = zend_array_count(myht);\n\t\tphp_printf(\"%sarray(%d) refcount(%u){\\n\", COMMON, count, Z_REFCOUNTED_P(struc) ? Z_REFCOUNT_P(struc) : 1);\n\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\tzval_array_element_dump(val, index, key, level);\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tif (level > 1 && ZEND_HASH_APPLY_PROTECTION(myht)) {\n\t\t\tmyht->u.v.nApplyCount--;\n\t\t}\n\t\tif (is_temp) {\n\t\t\tzend_hash_destroy(myht);\n\t\t\tefree(myht);\n\t\t}\n\t\tif (level > 1) {\n\t\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t\t}\n\t\tPUTS(\"}\\n\");\n\t\tbreak;\n\tcase IS_OBJECT:\n\t\tmyht = Z_OBJDEBUG_P(struc, is_temp);\n\t\tif (myht) {\n\t\t\tif (myht->u.v.nApplyCount > 1) {\n\t\t\t\tPUTS(\"*RECURSION*\\n\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmyht->u.v.nApplyCount++;\n\t\t\t}\n\t\t}\n\t\tclass_name = Z_OBJ_HANDLER_P(struc, get_class_name)(Z_OBJ_P(struc));\n\t\tphp_printf(\"%sobject(%s)#%d (%d) refcount(%u){\\n\", COMMON, ZSTR_VAL(class_name), Z_OBJ_HANDLE_P(struc), myht ? zend_array_count(myht) : 0, Z_REFCOUNT_P(struc));\n\t\tzend_string_release(class_name);\n\t\tif (myht) {\n\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\t\tzval_object_property_dump(val, index, key, level);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tmyht->u.v.nApplyCount--;\n\t\t\tif (is_temp) {\n\t\t\t\tzend_hash_destroy(myht);\n\t\t\t\tefree(myht);\n\t\t\t}\n\t\t}\n\t\tif (level > 1) {\n\t\t\tphp_printf(\"%*c\", level - 1, ' ');\n\t\t}\n\t\tPUTS(\"}\\n\");\n\t\tbreak;\n\tcase IS_RESOURCE: {\n\t\tconst char *type_name = zend_rsrc_list_get_rsrc_type(Z_RES_P(struc));\n\t\tphp_printf(\"%sresource(%d) of type (%s) refcount(%u)\\n\", COMMON, Z_RES_P(struc)->handle, type_name ? type_name : \"Unknown\", Z_REFCOUNT_P(struc));\n\t\tbreak;\n\t}\n\tcase IS_REFERENCE:\n\t\t//??? hide references with refcount==1 (for compatibility)\n\t\tif (Z_REFCOUNT_P(struc) > 1) {\n\t\t\tis_ref = 1;\n\t\t}\n\t\tstruc = Z_REFVAL_P(struc);\n\t\tgoto again;\n\tdefault:\n\t\tphp_printf(\"%sUNKNOWN:0\\n\", COMMON);\n\t\tbreak;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void debug_zval_dump(mixed var)\n   Dumps a string representation of an internal zend value to output. */\nPHP_FUNCTION(debug_zval_dump)\n{\n\tzval *args;\n\tint argc;\n\tint\ti;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"+\", &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\tphp_debug_zval_dump(&args[i], 1);\n\t}\n}\n/* }}} */\n\n#define buffer_append_spaces(buf, num_spaces) \\\n\tdo { \\\n\t\tchar *tmp_spaces; \\\n\t\tsize_t tmp_spaces_len; \\\n\t\ttmp_spaces_len = spprintf(&tmp_spaces, 0,\"%*c\", num_spaces, ' '); \\\n\t\tsmart_str_appendl(buf, tmp_spaces, tmp_spaces_len); \\\n\t\tefree(tmp_spaces); \\\n\t} while(0);\n\nstatic void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tbuffer_append_spaces(buf, level+1);\n\t\tsmart_str_append_long(buf, (zend_long) index);\n\t\tsmart_str_appendl(buf, \" => \", 4);\n\n\t} else { /* string key */\n\t\tzend_string *tmp_str;\n\t\tzend_string *ckey = php_addcslashes(key, 0, \"'\\\\\", 2);\n\t\ttmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), \"\\0\", 1, \"' . \\\"\\\\0\\\" . '\", 12);\n\n\t\tbuffer_append_spaces(buf, level + 1);\n\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tsmart_str_append(buf, tmp_str);\n\t\tsmart_str_appendl(buf, \"' => \", 5);\n\n\t\tzend_string_free(ckey);\n\t\tzend_string_free(tmp_str);\n\t}\n\tphp_var_export_ex(zv, level + 2, buf);\n\n\tsmart_str_appendc(buf, ',');\n\tsmart_str_appendc(buf, '\\n');\n}\n/* }}} */\n\nstatic void php_object_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */\n{\n\tbuffer_append_spaces(buf, level + 2);\n\tif (key != NULL) {\n\t\tconst char *class_name, *prop_name;\n\t\tsize_t prop_name_len;\n\t\tzend_string *pname_esc;\n\n\t\tzend_unmangle_property_name_ex(key, &class_name, &prop_name, &prop_name_len);\n\t\tpname_esc = php_addcslashes(zend_string_init(prop_name, prop_name_len, 0), 1, \"'\\\\\", 2);\n\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tsmart_str_append(buf, pname_esc);\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tzend_string_release(pname_esc);\n\t} else {\n\t\tsmart_str_append_long(buf, (zend_long) index);\n\t}\n\tsmart_str_appendl(buf, \" => \", 4);\n\tphp_var_export_ex(zv, level + 2, buf);\n\tsmart_str_appendc(buf, ',');\n\tsmart_str_appendc(buf, '\\n');\n}\n/* }}} */\n\nPHPAPI void php_var_export_ex(zval *struc, int level, smart_str *buf) /* {{{ */\n{\n\tHashTable *myht;\n\tchar *tmp_str;\n\tsize_t tmp_len;\n\tzend_string *ztmp, *ztmp2;\n\tzend_ulong index;\n\tzend_string *key;\n\tzval *val;\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\t\tcase IS_FALSE:\n\t\t\tsmart_str_appendl(buf, \"false\", 5);\n\t\t\tbreak;\n\t\tcase IS_TRUE:\n\t\t\tsmart_str_appendl(buf, \"true\", 4);\n\t\t\tbreak;\n\t\tcase IS_NULL:\n\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tsmart_str_append_long(buf, Z_LVAL_P(struc));\n\t\t\tbreak;\n\t\tcase IS_DOUBLE:\n\t\t\ttmp_len = spprintf(&tmp_str, 0,\"%.*H\", PG(serialize_precision), Z_DVAL_P(struc));\n\t\t\tsmart_str_appendl(buf, tmp_str, tmp_len);\n\t\t\t/* Without a decimal point, PHP treats a number literal as an int.\n\t\t\t * This check even works for scientific notation, because the\n\t\t\t * mantissa always contains a decimal point.\n\t\t\t * We need to check for finiteness, because INF, -INF and NAN\n\t\t\t * must not have a decimal point added.\n\t\t\t */\n\t\t\tif (zend_finite(Z_DVAL_P(struc)) && NULL == strchr(tmp_str, '.')) {\n\t\t\t\tsmart_str_appendl(buf, \".0\", 2);\n\t\t\t}\n\t\t\tefree(tmp_str);\n\t\t\tbreak;\n\t\tcase IS_STRING:\n\t\t\tztmp = php_addcslashes(Z_STR_P(struc), 0, \"'\\\\\", 2);\n\t\t\tztmp2 = php_str_to_str(ZSTR_VAL(ztmp), ZSTR_LEN(ztmp), \"\\0\", 1, \"' . \\\"\\\\0\\\" . '\", 12);\n\n\t\t\tsmart_str_appendc(buf, '\\'');\n\t\t\tsmart_str_append(buf, ztmp2);\n\t\t\tsmart_str_appendc(buf, '\\'');\n\n\t\t\tzend_string_free(ztmp);\n\t\t\tzend_string_free(ztmp2);\n\t\t\tbreak;\n\t\tcase IS_ARRAY:\n\t\t\tmyht = Z_ARRVAL_P(struc);\n\t\t\tif (ZEND_HASH_APPLY_PROTECTION(myht) && myht->u.v.nApplyCount++ > 0) {\n\t\t\t\tmyht->u.v.nApplyCount--;\n\t\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\t\tzend_error(E_WARNING, \"var_export does not handle circular references\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tsmart_str_appendc(buf, '\\n');\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\t\t\tsmart_str_appendl(buf, \"array (\\n\", 8);\n\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\t\tphp_array_element_export(val, index, key, level, buf);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tif (ZEND_HASH_APPLY_PROTECTION(myht)) {\n\t\t\t\tmyht->u.v.nApplyCount--;\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\t\t\tsmart_str_appendc(buf, ')');\n\n\t\t\tbreak;\n\n\t\tcase IS_OBJECT:\n\t\t\tmyht = Z_OBJPROP_P(struc);\n\t\t\tif (myht) {\n\t\t\t\tif (myht->u.v.nApplyCount > 0) {\n\t\t\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\t\t\tzend_error(E_WARNING, \"var_export does not handle circular references\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tmyht->u.v.nApplyCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tsmart_str_appendc(buf, '\\n');\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\n\t\t\tsmart_str_append(buf, Z_OBJCE_P(struc)->name);\n\t\t\tsmart_str_appendl(buf, \"::__set_state(array(\\n\", 21);\n\n\t\t\tif (myht) {\n\t\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, val) {\n\t\t\t\t\tphp_object_element_export(val, index, key, level, buf);\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t\tmyht->u.v.nApplyCount--;\n\t\t\t}\n\t\t\tif (level > 1) {\n\t\t\t\tbuffer_append_spaces(buf, level - 1);\n\t\t\t}\n\t\t\tsmart_str_appendl(buf, \"))\", 2);\n\n\t\t\tbreak;\n\t\tcase IS_REFERENCE:\n\t\t\tstruc = Z_REFVAL_P(struc);\n\t\t\tgoto again;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsmart_str_appendl(buf, \"NULL\", 4);\n\t\t\tbreak;\n\t}\n}\n/* }}} */\n\n/* FOR BC reasons, this will always perform and then print */\nPHPAPI void php_var_export(zval *struc, int level) /* {{{ */\n{\n\tsmart_str buf = {0};\n\tphp_var_export_ex(struc, level, &buf);\n\tsmart_str_0(&buf);\n\tPHPWRITE(ZSTR_VAL(buf.s), ZSTR_LEN(buf.s));\n\tsmart_str_free(&buf);\n}\n/* }}} */\n\n/* {{{ proto mixed var_export(mixed var [, bool return])\n   Outputs or returns a string representation of a variable */\nPHP_FUNCTION(var_export)\n{\n\tzval *var;\n\tzend_bool return_output = 0;\n\tsmart_str buf = {0};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"z|b\", &var, &return_output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_var_export_ex(var, 1, &buf);\n\tsmart_str_0 (&buf);\n\n\tif (return_output) {\n\t\tRETURN_NEW_STR(buf.s);\n\t} else {\n\t\tPHPWRITE(ZSTR_VAL(buf.s), ZSTR_LEN(buf.s));\n\t\tsmart_str_free(&buf);\n\t}\n}\n/* }}} */\n\nstatic void php_var_serialize_intern(smart_str *buf, zval *struc, php_serialize_data_t var_hash);\n\nstatic inline zend_long php_add_var_hash(php_serialize_data_t data, zval *var) /* {{{ */\n{\n\tzval *zv;\n\tzend_ulong key;\n\tzend_bool is_ref = Z_ISREF_P(var);\n\n\tdata->n += 1;\n\n\tif (!is_ref && Z_TYPE_P(var) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\t/* References to objects are treated as if the reference didn't exist */\n\tif (is_ref && Z_TYPE_P(Z_REFVAL_P(var)) == IS_OBJECT) {\n\t\tvar = Z_REFVAL_P(var);\n\t}\n\n\t/* Index for the variable is stored using the numeric value of the pointer to\n\t * the zend_refcounted struct */\n\tkey = (zend_ulong) (zend_uintptr_t) Z_COUNTED_P(var);\n\tzv = zend_hash_index_find(&data->ht, key);\n\n\tif (zv) {\n\t\t/* References are only counted once, undo the data->n increment above */\n\t\tif (is_ref) {\n\t\t\tdata->n -= 1;\n\t\t}\n\n\t\treturn Z_LVAL_P(zv);\n\t} else {\n\t\tzval zv_n;\n\t\tZVAL_LONG(&zv_n, data->n);\n\t\tzend_hash_index_add_new(&data->ht, key, &zv_n);\n\n\t\t/* Additionally to the index, we also store the variable, to ensure that it is\n\t\t * not destroyed during serialization and its pointer reused. The variable is\n\t\t * stored at the numeric value of the pointer + 1, which cannot be the location\n\t\t * of another zend_refcounted structure. */\n\t\tzend_hash_index_add_new(&data->ht, key + 1, var);\n\t\tZ_ADDREF_P(var);\n\n\t\treturn 0;\n\t}\n}\n/* }}} */\n\nstatic inline void php_var_serialize_long(smart_str *buf, zend_long val) /* {{{ */\n{\n\tsmart_str_appendl(buf, \"i:\", 2);\n\tsmart_str_append_long(buf, val);\n\tsmart_str_appendc(buf, ';');\n}\n/* }}} */\n\nstatic inline void php_var_serialize_string(smart_str *buf, char *str, size_t len) /* {{{ */\n{\n\tsmart_str_appendl(buf, \"s:\", 2);\n\tsmart_str_append_unsigned(buf, len);\n\tsmart_str_appendl(buf, \":\\\"\", 2);\n\tsmart_str_appendl(buf, str, len);\n\tsmart_str_appendl(buf, \"\\\";\", 2);\n}\n/* }}} */\n\nstatic inline zend_bool php_var_serialize_class_name(smart_str *buf, zval *struc) /* {{{ */\n{\n\tPHP_CLASS_ATTRIBUTES;\n\n\tPHP_SET_CLASS_ATTRIBUTES(struc);\n\tsmart_str_appendl(buf, \"O:\", 2);\n\tsmart_str_append_unsigned(buf, ZSTR_LEN(class_name));\n\tsmart_str_appendl(buf, \":\\\"\", 2);\n\tsmart_str_append(buf, class_name);\n\tsmart_str_appendl(buf, \"\\\":\", 2);\n\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n\treturn incomplete_class;\n}\n/* }}} */\n\nstatic HashTable *php_var_serialize_collect_names(HashTable *src, uint32_t count, zend_bool incomplete) /* {{{ */ {\n\tzval *val;\n\tHashTable *ht;\n\tzend_string *key, *name;\n\n\tALLOC_HASHTABLE(ht);\n\tzend_hash_init(ht, count, NULL, NULL, 0);\n\tZEND_HASH_FOREACH_STR_KEY_VAL(src, key, val) {\n\t\tif (incomplete && strcmp(ZSTR_VAL(key), MAGIC_MEMBER) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Z_TYPE_P(val) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_NOTICE,\n\t\t\t\t\t\"__sleep should return an array only containing the names of instance-variables to serialize.\");\n\t\t}\n\t\tname = zval_get_string(val);\n\t\tif (zend_hash_exists(ht, name)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE,\n\t\t\t\t\t\"\\\"%s\\\" is returned from __sleep multiple times\", ZSTR_VAL(name));\n\t\t\tzend_string_release(name);\n\t\t\tcontinue;\n\t\t}\n\t\tzend_hash_add_empty_element(ht, name);\n\t\tzend_string_release(name);\n\t} ZEND_HASH_FOREACH_END();\n\n\treturn ht;\n}\n/* }}} */\n\nstatic void php_var_serialize_class(smart_str *buf, zval *struc, zval *retval_ptr, php_serialize_data_t var_hash) /* {{{ */\n{\n\tuint32_t count;\n\tzend_bool incomplete_class;\n\tHashTable *ht;\n\n\tincomplete_class = php_var_serialize_class_name(buf, struc);\n\t/* count after serializing name, since php_var_serialize_class_name\n\t * changes the count if the variable is incomplete class */\n\tif (Z_TYPE_P(retval_ptr) == IS_ARRAY) {\n\t\tht = Z_ARRVAL_P(retval_ptr);\n\t\tcount = zend_array_count(ht);\n\t} else if (Z_TYPE_P(retval_ptr) == IS_OBJECT) {\n\t\tht = Z_OBJPROP_P(retval_ptr);\n\t\tcount = zend_array_count(ht);\n\t\tif (incomplete_class) {\n\t\t\t--count;\n\t\t}\n\t} else {\n\t\tcount = 0;\n\t\tht = NULL;\n\t}\n\n\tif (count > 0) {\n\t\tzval *d;\n\t\tzval nval, *nvalp;\n\t\tzend_string *name;\n\t\tHashTable *names, *propers;\n\n\t\tnames = php_var_serialize_collect_names(ht, count, incomplete_class);\n\n\t\tsmart_str_append_unsigned(buf, zend_hash_num_elements(names));\n\t\tsmart_str_appendl(buf, \":{\", 2);\n\n\t\tZVAL_NULL(&nval);\n\t\tnvalp = &nval;\n\t\tpropers = Z_OBJPROP_P(struc);\n\n\t\tZEND_HASH_FOREACH_STR_KEY(names, name) {\n\t\t\tif ((d = zend_hash_find(propers, name)) != NULL) {\n\t\t\t\tif (Z_TYPE_P(d) == IS_INDIRECT) {\n\t\t\t\t\td = Z_INDIRECT_P(d);\n\t\t\t\t\tif (Z_TYPE_P(d) == IS_UNDEF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(name), ZSTR_LEN(name));\n\t\t\t\tphp_var_serialize_intern(buf, d, var_hash);\n\t\t\t} else {\n\t\t\t\tzend_class_entry *ce = Z_OBJ_P(struc)->ce;\n\t\t\t\tif (ce) {\n\t\t\t\t\tzend_string *prot_name, *priv_name;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tpriv_name = zend_mangle_property_name(\n\t\t\t\t\t\t\t\tZSTR_VAL(ce->name), ZSTR_LEN(ce->name), ZSTR_VAL(name), ZSTR_LEN(name), ce->type & ZEND_INTERNAL_CLASS);\n\t\t\t\t\t\tif ((d = zend_hash_find(propers, priv_name)) != NULL) {\n\t\t\t\t\t\t\tif (Z_TYPE_P(d) == IS_INDIRECT) {\n\t\t\t\t\t\t\t\td = Z_INDIRECT_P(d);\n\t\t\t\t\t\t\t\tif (Z_ISUNDEF_P(d)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(priv_name), ZSTR_LEN(priv_name));\n\t\t\t\t\t\t\tzend_string_free(priv_name);\n\t\t\t\t\t\t\tphp_var_serialize_intern(buf, d, var_hash);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tzend_string_free(priv_name);\n\t\t\t\t\t\tprot_name = zend_mangle_property_name(\n\t\t\t\t\t\t\t\t\"*\", 1, ZSTR_VAL(name), ZSTR_LEN(name), ce->type & ZEND_INTERNAL_CLASS);\n\t\t\t\t\t\tif ((d = zend_hash_find(propers, prot_name)) != NULL) {\n\t\t\t\t\t\t\tif (Z_TYPE_P(d) == IS_INDIRECT) {\n\t\t\t\t\t\t\t\td = Z_INDIRECT_P(d);\n\t\t\t\t\t\t\t\tif (Z_TYPE_P(d) == IS_UNDEF) {\n\t\t\t\t\t\t\t\t\tzend_string_free(prot_name);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(prot_name), ZSTR_LEN(prot_name));\n\t\t\t\t\t\t\tzend_string_free(prot_name);\n\t\t\t\t\t\t\tphp_var_serialize_intern(buf, d, var_hash);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tzend_string_free(prot_name);\n\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(name), ZSTR_LEN(name));\n\t\t\t\t\t\tphp_var_serialize_intern(buf, nvalp, var_hash);\n\t\t\t\t\t\tphp_error_docref(NULL, E_NOTICE,\n\t\t\t\t\t\t\t\t\"\\\"%s\\\" returned as member variable from __sleep() but does not exist\", ZSTR_VAL(name));\n\t\t\t\t\t} while (0);\n\t\t\t\t} else {\n\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(name), ZSTR_LEN(name));\n\t\t\t\t\tphp_var_serialize_intern(buf, nvalp, var_hash);\n\t\t\t\t}\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tsmart_str_appendc(buf, '}');\n\n\t\tzend_hash_destroy(names);\n\t\tFREE_HASHTABLE(names);\n\t} else {\n\t\tsmart_str_appendl(buf, \"0:{}\", 4);\n\t}\n}\n/* }}} */\n\nstatic void php_var_serialize_intern(smart_str *buf, zval *struc, php_serialize_data_t var_hash) /* {{{ */\n{\n\tzend_long var_already;\n\tHashTable *myht;\n\n\tif (EG(exception)) {\n\t\treturn;\n\t}\n\n\tif (var_hash && (var_already = php_add_var_hash(var_hash, struc))) {\n\t\tif (Z_ISREF_P(struc)) {\n\t\t\tsmart_str_appendl(buf, \"R:\", 2);\n\t\t\tsmart_str_append_long(buf, var_already);\n\t\t\tsmart_str_appendc(buf, ';');\n\t\t\treturn;\n\t\t} else if (Z_TYPE_P(struc) == IS_OBJECT) {\n\t\t\tsmart_str_appendl(buf, \"r:\", 2);\n\t\t\tsmart_str_append_long(buf, var_already);\n\t\t\tsmart_str_appendc(buf, ';');\n\t\t\treturn;\n\t\t}\n\t}\n\nagain:\n\tswitch (Z_TYPE_P(struc)) {\n\t\tcase IS_FALSE:\n\t\t\tsmart_str_appendl(buf, \"b:0;\", 4);\n\t\t\treturn;\n\n\t\tcase IS_TRUE:\n\t\t\tsmart_str_appendl(buf, \"b:1;\", 4);\n\t\t\treturn;\n\n\t\tcase IS_NULL:\n\t\t\tsmart_str_appendl(buf, \"N;\", 2);\n\t\t\treturn;\n\n\t\tcase IS_LONG:\n\t\t\tphp_var_serialize_long(buf, Z_LVAL_P(struc));\n\t\t\treturn;\n\n\t\tcase IS_DOUBLE: {\n\t\t\t\tchar *s;\n\n\t\t\t\tsmart_str_appendl(buf, \"d:\", 2);\n\t\t\t\ts = (char *) safe_emalloc(PG(serialize_precision), 1, MAX_LENGTH_OF_DOUBLE + 1);\n\t\t\t\tphp_gcvt(Z_DVAL_P(struc), (int)PG(serialize_precision), '.', 'E', s);\n\t\t\t\tsmart_str_appends(buf, s);\n\t\t\t\tsmart_str_appendc(buf, ';');\n\t\t\t\tefree(s);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase IS_STRING:\n\t\t\tphp_var_serialize_string(buf, Z_STRVAL_P(struc), Z_STRLEN_P(struc));\n\t\t\treturn;\n\n\t\tcase IS_OBJECT: {\n\t\t\t\tzval retval;\n\t\t\t\tzval fname;\n\t\t\t\tint res;\n\t\t\t\tzend_class_entry *ce = Z_OBJCE_P(struc);\n\n\t\t\t\tif (ce->serialize != NULL) {\n\t\t\t\t\t/* has custom handler */\n\t\t\t\t\tunsigned char *serialized_data = NULL;\n\t\t\t\t\tsize_t serialized_length;\n\n\t\t\t\t\tif (ce->serialize(struc, &serialized_data, &serialized_length, (zend_serialize_data *)var_hash) == SUCCESS) {\n\t\t\t\t\t\tsmart_str_appendl(buf, \"C:\", 2);\n\t\t\t\t\t\tsmart_str_append_unsigned(buf, ZSTR_LEN(Z_OBJCE_P(struc)->name));\n\t\t\t\t\t\tsmart_str_appendl(buf, \":\\\"\", 2);\n\t\t\t\t\t\tsmart_str_append(buf, Z_OBJCE_P(struc)->name);\n\t\t\t\t\t\tsmart_str_appendl(buf, \"\\\":\", 2);\n\n\t\t\t\t\t\tsmart_str_append_unsigned(buf, serialized_length);\n\t\t\t\t\t\tsmart_str_appendl(buf, \":{\", 2);\n\t\t\t\t\t\tsmart_str_appendl(buf, (char *) serialized_data, serialized_length);\n\t\t\t\t\t\tsmart_str_appendc(buf, '}');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(buf, \"N;\", 2);\n\t\t\t\t\t}\n\t\t\t\t\tif (serialized_data) {\n\t\t\t\t\t\tefree(serialized_data);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (ce != PHP_IC_ENTRY && zend_hash_str_exists(&ce->function_table, \"__sleep\", sizeof(\"__sleep\")-1)) {\n\t\t\t\t\tZVAL_STRINGL(&fname, \"__sleep\", sizeof(\"__sleep\") - 1);\n\t\t\t\t\tBG(serialize_lock)++;\n\t\t\t\t\tres = call_user_function_ex(CG(function_table), struc, &fname, &retval, 0, 0, 1, NULL);\n\t\t\t\t\tBG(serialize_lock)--;\n\t\t\t\t\tzval_dtor(&fname);\n\n\t\t\t\t\tif (EG(exception)) {\n\t\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (res == SUCCESS) {\n\t\t\t\t\t\tif (Z_TYPE(retval) != IS_UNDEF) {\n\t\t\t\t\t\t\tif (HASH_OF(&retval)) {\n\t\t\t\t\t\t\t\tphp_var_serialize_class(buf, struc, &retval, var_hash);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL, E_NOTICE, \"__sleep should return an array only containing the names of instance-variables to serialize\");\n\t\t\t\t\t\t\t\t/* we should still add element even if it's not OK,\n\t\t\t\t\t\t\t\t * since we already wrote the length of the array before */\n\t\t\t\t\t\t\t\tsmart_str_appendl(buf,\"N;\", 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t}\n\n\t\t\t\t/* fall-through */\n\t\t\t}\n\t\tcase IS_ARRAY: {\n\t\t\tuint32_t i;\n\t\t\tzend_bool incomplete_class = 0;\n\t\t\tif (Z_TYPE_P(struc) == IS_ARRAY) {\n\t\t\t\tsmart_str_appendl(buf, \"a:\", 2);\n\t\t\t\tmyht = Z_ARRVAL_P(struc);\n\t\t\t\ti = zend_array_count(myht);\n\t\t\t} else {\n\t\t\t\tincomplete_class = php_var_serialize_class_name(buf, struc);\n\t\t\t\tmyht = Z_OBJPROP_P(struc);\n\t\t\t\t/* count after serializing name, since php_var_serialize_class_name\n\t\t\t\t * changes the count if the variable is incomplete class */\n\t\t\t\ti = zend_array_count(myht);\n\t\t\t\tif (i > 0 && incomplete_class) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmart_str_append_unsigned(buf, i);\n\t\t\tsmart_str_appendl(buf, \":{\", 2);\n\t\t\tif (i > 0) {\n\t\t\t\tzend_string *key;\n\t\t\t\tzval *data;\n\t\t\t\tzend_ulong index;\n\n\t\t\t\tZEND_HASH_FOREACH_KEY_VAL_IND(myht, index, key, data) {\n\n\t\t\t\t\tif (incomplete_class && strcmp(ZSTR_VAL(key), MAGIC_MEMBER) == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!key) {\n\t\t\t\t\t\tphp_var_serialize_long(buf, index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphp_var_serialize_string(buf, ZSTR_VAL(key), ZSTR_LEN(key));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Z_ISREF_P(data) && Z_REFCOUNT_P(data) == 1) {\n\t\t\t\t\t\tdata = Z_REFVAL_P(data);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* we should still add element even if it's not OK,\n\t\t\t\t\t * since we already wrote the length of the array before */\n\t\t\t\t\tif ((Z_TYPE_P(data) == IS_ARRAY && Z_TYPE_P(struc) == IS_ARRAY && Z_ARR_P(data) == Z_ARR_P(struc))\n\t\t\t\t\t\t|| (Z_TYPE_P(data) == IS_ARRAY && Z_ARRVAL_P(data)->u.v.nApplyCount > 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\tsmart_str_appendl(buf, \"N;\", 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (Z_TYPE_P(data) == IS_ARRAY && ZEND_HASH_APPLY_PROTECTION(Z_ARRVAL_P(data))) {\n\t\t\t\t\t\t\tZ_ARRVAL_P(data)->u.v.nApplyCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_var_serialize_intern(buf, data, var_hash);\n\t\t\t\t\t\tif (Z_TYPE_P(data) == IS_ARRAY && ZEND_HASH_APPLY_PROTECTION(Z_ARRVAL_P(data))) {\n\t\t\t\t\t\t\tZ_ARRVAL_P(data)->u.v.nApplyCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t}\n\t\t\tsmart_str_appendc(buf, '}');\n\t\t\treturn;\n\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\tstruc = Z_REFVAL_P(struc);\n\t\t\tgoto again;\n\t\tdefault:\n\t\t\tsmart_str_appendl(buf, \"i:0;\", 4);\n\t\t\treturn;\n\t}\n}\n/* }}} */\n\nPHPAPI void php_var_serialize(smart_str *buf, zval *struc, php_serialize_data_t *data) /* {{{ */\n{\n\tphp_var_serialize_intern(buf, struc, *data);\n\tsmart_str_0(buf);\n}\n/* }}} */\n\n/* {{{ proto string serialize(mixed variable)\n   Returns a string representation of variable (which can later be unserialized) */\nPHP_FUNCTION(serialize)\n{\n\tzval *struc;\n\tphp_serialize_data_t var_hash;\n\tsmart_str buf = {0};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"z\", &struc) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_VAR_SERIALIZE_INIT(var_hash);\n\tphp_var_serialize(&buf, struc, &var_hash);\n\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\n\tif (EG(exception)) {\n\t\tsmart_str_free(&buf);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf.s) {\n\t\tRETURN_NEW_STR(buf.s);\n\t} else {\n\t\tRETURN_NULL();\n\t}\n}\n/* }}} */\n\n/* {{{ proto mixed unserialize(string variable_representation[, array allowed_classes])\n   Takes a string representation of variable and recreates it */\nPHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tzval *retval;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tretval = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tZVAL_COPY(return_value, retval);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int memory_get_usage([bool real_usage])\n   Returns the allocated by PHP memory */\nPHP_FUNCTION(memory_get_usage) {\n\tzend_bool real_usage = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|b\", &real_usage) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(zend_memory_usage(real_usage));\n}\n/* }}} */\n\n/* {{{ proto int memory_get_peak_usage([bool real_usage])\n   Returns the peak allocated by PHP memory */\nPHP_FUNCTION(memory_get_peak_usage) {\n\tzend_bool real_usage = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|b\", &real_usage) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(zend_memory_peak_usage(real_usage));\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "filenames": ["ext/standard/tests/serialize/bug70172_2.phpt", "ext/standard/var.c"], "buggy_code_start_loc": [3, 1038], "buggy_code_end_loc": [71, 1086], "fixing_code_start_loc": [2, 1039], "fixing_code_end_loc": [69, 1086], "type": "CWE-416", "message": "The unserialize implementation in ext/standard/var.c in PHP 7.x before 7.0.14 allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted serialized data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6834.", "other": {"cve": {"id": "CVE-2016-9936", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-04T20:59:00.607", "lastModified": "2018-05-04T01:29:02.333", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The unserialize implementation in ext/standard/var.c in PHP 7.x before 7.0.14 allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted serialized data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6834."}, {"lang": "es", "value": "La implementaci\u00f3n no serializada en ext/standard/var.c en PHP 7.x en versiones anteriores a 7.0.14 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n) o posiblemente tener otro impacto no especificado a trav\u00e9s de datos serializados manipulados. NOTA: esta vulnerabilidad existe por una reparaci\u00f3n incompleta de la CVE-2015-6834."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "DB6890AF-8A0A-46EE-AAD5-CF9AAE14A321"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "6B90B947-7B54-47F3-9637-2F4AC44079EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "35848414-BD5D-4164-84DC-61ABBB1C4152"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "2B1F8402-8551-4F66-A9A7-81D472AB058E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "7A773E8E-48CD-4D35-A0FD-629BD9334486"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "FC492340-79AF-4676-A161-079A97EC6F0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "F1C2D8FE-C380-4B43-B634-A3DBA4700A71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "3EB58393-0C10-413C-8D95-6BAA8BC19A1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "751F51CA-9D88-4971-A6EC-8C0B72E8E22B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "37B74118-8FC2-44CB-9673-A83DF777B2E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "4D56A200-1477-40DA-9444-CFC946157C69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "FD0D1CCC-A857-4C15-899E-08F9255CEE34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "6745CC43-2836-4CD8-848F-EEA08AE9D5AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "7BEB6696-14F9-4D9B-9974-B682FFBB828E"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-01/msg00034.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/12/2", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://www.php.net/ChangeLog-7.php", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "http://www.securityfocus.com/bid/94849", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1296", "source": "cve@mitre.org"}, {"url": "https://bugs.php.net/bug.php?id=72978", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17"}}