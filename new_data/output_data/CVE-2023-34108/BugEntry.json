{"buggy_code": ["#!/bin/bash\nset -e\n\n# Wait for MySQL to warm-up\nwhile ! mysqladmin status --socket=/var/run/mysqld/mysqld.sock -u${DBUSER} -p${DBPASS} --silent; do\n  echo \"Waiting for database to come up...\"\n  sleep 2\ndone\n\nuntil dig +short mailcow.email > /dev/null; do\n  echo \"Waiting for DNS...\"\n  sleep 1\ndone\n\n# Do not attempt to write to slave\nif [[ ! -z ${REDIS_SLAVEOF_IP} ]]; then\n  REDIS_CMDLINE=\"redis-cli -h ${REDIS_SLAVEOF_IP} -p ${REDIS_SLAVEOF_PORT}\"\nelse\n  REDIS_CMDLINE=\"redis-cli -h redis -p 6379\"\nfi\n\nuntil [[ $(${REDIS_CMDLINE} PING) == \"PONG\" ]]; do\n  echo \"Waiting for Redis...\"\n  sleep 2\ndone\n\n${REDIS_CMDLINE} SET DOVECOT_REPL_HEALTH 1 > /dev/null\n\n# Create missing directories\n[[ ! -d /etc/dovecot/sql/ ]] && mkdir -p /etc/dovecot/sql/\n[[ ! -d /etc/dovecot/lua/ ]] && mkdir -p /etc/dovecot/lua/\n[[ ! -d /var/vmail/_garbage ]] && mkdir -p /var/vmail/_garbage\n[[ ! -d /var/vmail/sieve ]] && mkdir -p /var/vmail/sieve\n[[ ! -d /etc/sogo ]] && mkdir -p /etc/sogo\n[[ ! -d /var/volatile ]] && mkdir -p /var/volatile\n\n# Set Dovecot sql config parameters, escape \" in db password\nDBPASS=$(echo ${DBPASS} | sed 's/\"/\\\\\"/g')\n\n# Create quota dict for Dovecot\nif [[ \"${MASTER}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n  QUOTA_TABLE=quota2\nelse\n  QUOTA_TABLE=quota2replica\nfi\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-quota.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/quota/storage\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = bytes\n}\nmap {\n  pattern = priv/quota/messages\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = messages\n}\nEOF\n\n# Create dict used for sieve pre and postfilters\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_before.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_before\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_before\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_after.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_after\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_after\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\necho -n ${ACL_ANYONE} > /etc/dovecot/acl_anyone\n\nif [[ \"${SKIP_SOLR}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify listescape replication mail_log' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nelse\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify fts fts_solr listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify mail_log fts fts_solr listescape replication' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl fts fts_solr notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nfi\nchmod 644 /etc/dovecot/mail_plugins /etc/dovecot/mail_plugins_imap /etc/dovecot/mail_plugins_lmtp /templates/quarantine.tpl\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-userdb.conf\n# Autogenerated by mailcow\ndriver = mysql\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nuser_query = SELECT CONCAT(JSON_UNQUOTE(JSON_VALUE(attributes, '$.mailbox_format')), mailbox_path_prefix, '%d/%n/${MAILDIR_SUB}:VOLATILEDIR=/var/volatile/%u:INDEX=/var/vmail_index/%u') AS mail, '%s' AS protocol, 5000 AS uid, 5000 AS gid, concat('*:bytes=', quota) AS quota_rule FROM mailbox WHERE username = '%u' AND (active = '1' OR active = '2')\niterate_query = SELECT username FROM mailbox WHERE active = '1' OR active = '2';\nEOF\n\ncat <<EOF > /etc/dovecot/lua/passwd-verify.lua\nfunction auth_password_verify(req, pass)\n\n  if req.domain == nil then\n    return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"No such user\"\n  end\n\n  if cur == nil then\n    script_init()\n  end\n\n  if req.user == nil then\n    req.user = ''\n  end\n\n  respbody = {}\n\n  -- check against mailbox passwds\n  local cur,errorString = con:execute(string.format([[SELECT password FROM mailbox\n    WHERE username = '%s'\n      AND active = '1'\n      AND domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(mailbox.attributes, '$.force_pw_update')), 0) != '1'\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(attributes, '$.%s_access')), 1) = '1']], con:escape(req.user), con:escape(req.domain), con:escape(req.service)))\n  local row = cur:fetch ({}, \"a\")\n  while row do\n    if req.password_verify(req, row.password, pass) == 1 then\n      con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n        VALUES (\"%s\", 0, \"%s\", \"%s\")]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip)))\n      cur:close()\n      con:close()\n      return dovecot.auth.PASSDB_RESULT_OK, \"password=\" .. pass\n    end\n    row = cur:fetch (row, \"a\")\n  end\n\n  -- check against app passwds for imap and smtp\n  -- app passwords are only available for imap, smtp, sieve and pop3 when using sasl\n  if req.service == \"smtp\" or req.service == \"imap\" or req.service == \"sieve\" or req.service == \"pop3\" then\n    local cur,errorString = con:execute(string.format([[SELECT app_passwd.id, %s_access AS has_prot_access, app_passwd.password FROM app_passwd\n      INNER JOIN mailbox ON mailbox.username = app_passwd.mailbox\n      WHERE mailbox = '%s'\n        AND app_passwd.active = '1'\n        AND mailbox.active = '1'\n        AND app_passwd.domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')]], con:escape(req.service), con:escape(req.user), con:escape(req.domain)))\n    local row = cur:fetch ({}, \"a\")\n    while row do\n      if req.password_verify(req, row.password, pass) == 1 then\n        -- if password is valid and protocol access is 1 OR real_rip matches SOGo, proceed\n        if tostring(req.real_rip) == \"__IPV4_SOGO__\" then\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"password=\" .. pass\n        elseif row.has_prot_access == \"1\" then\n          con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n            VALUES (\"%s\", %d, \"%s\", \"%s\")]], con:escape(req.service), row.id, con:escape(req.user), con:escape(req.real_rip)))\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"password=\" .. pass\n        end\n      end\n      row = cur:fetch (row, \"a\")\n    end\n  end\n\n  cur:close()\n  con:close()\n\n  return dovecot.auth.PASSDB_RESULT_PASSWORD_MISMATCH, \"Failed to authenticate\"\n\n  -- PoC\n  -- local reqbody = string.format([[{\n  --   \"success\":0,\n  --   \"service\":\"%s\",\n  --   \"app_password\":false,\n  --   \"username\":\"%s\",\n  --   \"real_rip\":\"%s\"\n  -- }]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip))\n  -- http.request {\n  --   method = \"POST\",\n  --   url = \"http://nginx:8081/sasl_log.php\",\n  --   source = ltn12.source.string(reqbody),\n  --   headers = {\n  --     [\"content-type\"] = \"application/json\",\n  --     [\"content-length\"] = tostring(#reqbody)\n  --   },\n  --   sink = ltn12.sink.table(respbody)\n  -- }\n\nend\n\nfunction auth_passdb_lookup(req)\n   return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"\"\nend\n\nfunction script_init()\n  mysql = require \"luasql.mysql\"\n  http = require \"socket.http\"\n  http.TIMEOUT = 5\n  ltn12 = require \"ltn12\"\n  env  = mysql.mysql()\n  con = env:connect(\"__DBNAME__\",\"__DBUSER__\",\"__DBPASS__\",\"localhost\")\n  return 0\nend\n\nfunction script_deinit()\n  con:close()\n  env:close()\nend\nEOF\n\n# Replace patterns in app-passdb.lua\nsed -i \"s/__DBUSER__/${DBUSER}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBPASS__/${DBPASS}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBNAME__/${DBNAME}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__IPV4_SOGO__/${IPV4_NETWORK}.248/g\" /etc/dovecot/lua/passwd-verify.lua\n\n\n# Migrate old sieve_after file\n[[ -f /etc/dovecot/sieve_after ]] && mv /etc/dovecot/sieve_after /etc/dovecot/global_sieve_after\n# Create global sieve scripts\ncat /etc/dovecot/global_sieve_after > /var/vmail/sieve/global_sieve_after.sieve\ncat /etc/dovecot/global_sieve_before > /var/vmail/sieve/global_sieve_before.sieve\n\n# Check permissions of vmail/index/garbage directories.\n# Do not do this every start-up, it may take a very long time. So we use a stat check here.\nif [[ $(stat -c %U /var/vmail/) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail ; fi\nif [[ $(stat -c %U /var/vmail/_garbage) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail/_garbage ; fi\nif [[ $(stat -c %U /var/vmail_index) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail_index ; fi\n\n# Cleanup random user maildirs\nrm -rf /var/vmail/mailcow.local/*\n# Cleanup PIDs\n[[ -f /tmp/quarantine_notify.pid ]] && rm /tmp/quarantine_notify.pid\n\n# create sni configuration\necho \"\" > /etc/dovecot/sni.conf\nfor cert_dir in /etc/ssl/mail/*/ ; do\n  if [[ ! -f ${cert_dir}domains ]] || [[ ! -f ${cert_dir}cert.pem ]] || [[ ! -f ${cert_dir}key.pem ]]; then\n    continue\n  fi\n  domains=($(cat ${cert_dir}domains))\n  for domain in ${domains[@]}; do\n    echo 'local_name '${domain}' {' >> /etc/dovecot/sni.conf;\n    echo '  ssl_cert = <'${cert_dir}'cert.pem' >> /etc/dovecot/sni.conf;\n    echo '  ssl_key = <'${cert_dir}'key.pem' >> /etc/dovecot/sni.conf;\n    echo '}' >> /etc/dovecot/sni.conf;\n  done\ndone\n\n# Create random master for SOGo sieve features\nRAND_USER=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 16 | head -n 1)\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 24 | head -n 1)\n\nif [[ ! -z ${DOVECOT_MASTER_USER} ]] && [[ ! -z ${DOVECOT_MASTER_PASS} ]]; then\n  RAND_USER=${DOVECOT_MASTER_USER}\n  RAND_PASS=${DOVECOT_MASTER_PASS}\nfi\necho ${RAND_USER}@mailcow.local:{SHA1}$(echo -n ${RAND_PASS} | sha1sum | awk '{print $1}'):::::: > /etc/dovecot/dovecot-master.passwd\necho ${RAND_USER}@mailcow.local::5000:5000:::: > /etc/dovecot/dovecot-master.userdb\necho ${RAND_USER}@mailcow.local:${RAND_PASS} > /etc/sogo/sieve.creds\n\nif [[ -z ${MAILDIR_SUB} ]]; then\n  MAILDIR_SUB_SHARED=\nelse\n  MAILDIR_SUB_SHARED=/${MAILDIR_SUB}\nfi\ncat <<EOF > /etc/dovecot/shared_namespace.conf\n# Autogenerated by mailcow\nnamespace {\n    type = shared\n    separator = /\n    prefix = Shared/%%u/\n    location = maildir:%%h${MAILDIR_SUB_SHARED}:INDEX=~${MAILDIR_SUB_SHARED}/Shared/%%u\n    subscriptions = no\n    list = children\n}\nEOF\n\n\ncat <<EOF > /etc/dovecot/sogo_trusted_ip.conf\n# Autogenerated by mailcow\nremote ${IPV4_NETWORK}.248 {\n  disable_plaintext_auth = no\n}\nEOF\n\n# Create random master Password for SOGo SSO\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)\necho -n ${RAND_PASS} > /etc/phpfpm/sogo-sso.pass\ncat <<EOF > /etc/dovecot/sogo-sso.conf\n# Autogenerated by mailcow\npassdb {\n  driver = static\n  args = allow_real_nets=${IPV4_NETWORK}.248/32 password={plain}${RAND_PASS}\n}\nEOF\n\nif [[ \"${MASTER}\" =~ ^([nN][oO]|[nN])+$ ]]; then\n  # Toggling MASTER will result in a rebuild of containers, so the quota script will be recreated\n  cat <<'EOF' > /usr/local/bin/quota_notify.py\n#!/usr/bin/python3\nimport sys\nsys.exit()\nEOF\nfi\n\n# 401 is user dovecot\nif [[ ! -s /mail_crypt/ecprivkey.pem || ! -s /mail_crypt/ecpubkey.pem ]]; then\n\topenssl ecparam -name prime256v1 -genkey | openssl pkey -out /mail_crypt/ecprivkey.pem\n\topenssl pkey -in /mail_crypt/ecprivkey.pem -pubout -out /mail_crypt/ecpubkey.pem\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nelse\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nfi\n\n# Compile sieve scripts\nsievec /var/vmail/sieve/global_sieve_before.sieve\nsievec /var/vmail/sieve/global_sieve_after.sieve\nsievec /usr/lib/dovecot/sieve/report-spam.sieve\nsievec /usr/lib/dovecot/sieve/report-ham.sieve\n\nfor file in /var/vmail/*/*/sieve/*.sieve ; do\n  if [[ \"$file\" == \"/var/vmail/*/*/sieve/*.sieve\" ]]; then\n    continue\n  fi\n  sievec \"$file\" \"$(dirname \"$file\")/../.dovecot.svbin\"\n  chown vmail:vmail \"$(dirname \"$file\")/../.dovecot.svbin\"\ndone\n\n# Fix permissions\nchown root:root /etc/dovecot/sql/*.conf\nchown root:dovecot /etc/dovecot/sql/dovecot-dict-sql-sieve* /etc/dovecot/sql/dovecot-dict-sql-quota* /etc/dovecot/lua/passwd-verify.lua\nchmod 640 /etc/dovecot/sql/*.conf /etc/dovecot/lua/passwd-verify.lua\nchown -R vmail:vmail /var/vmail/sieve\nchown -R vmail:vmail /var/volatile\nchown -R vmail:vmail /var/vmail_index\nadduser vmail tty\nchmod g+rw /dev/console\nchown root:tty /dev/console\nchmod +x /usr/lib/dovecot/sieve/rspamd-pipe-ham \\\n  /usr/lib/dovecot/sieve/rspamd-pipe-spam \\\n  /usr/local/bin/imapsync_runner.pl \\\n  /usr/local/bin/imapsync \\\n  /usr/local/bin/trim_logs.sh \\\n  /usr/local/bin/sa-rules.sh \\\n  /usr/local/bin/clean_q_aged.sh \\\n  /usr/local/bin/maildir_gc.sh \\\n  /usr/local/sbin/stop-supervisor.sh \\\n  /usr/local/bin/quota_notify.py \\\n  /usr/local/bin/repl_health.sh\n\n# Prepare environment file for cronjobs\nprintenv | sed 's/^\\(.*\\)$/export \\1/g' > /source_env.sh\n\n# Clean old PID if any\n[[ -f /var/run/dovecot/master.pid ]] && rm /var/run/dovecot/master.pid\n\n# Clean stopped imapsync jobs\nrm -f /tmp/imapsync_busy.lock\nIMAPSYNC_TABLE=$(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"SHOW TABLES LIKE 'imapsync'\" -Bs)\n[[ ! -z ${IMAPSYNC_TABLE} ]] && mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"UPDATE imapsync SET is_running='0'\"\n\n# Envsubst maildir_gc\necho \"$(envsubst < /usr/local/bin/maildir_gc.sh)\" > /usr/local/bin/maildir_gc.sh\n\n# GUID generation\nwhile [[ ${VERSIONS_OK} != 'OK' ]]; do\n  if [[ ! -z $(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -B -e \"SELECT 'OK' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \\\"${DBNAME}\\\" AND TABLE_NAME = 'versions'\") ]]; then\n    VERSIONS_OK=OK\n  else\n    echo \"Waiting for versions table to be created...\"\n    sleep 3\n  fi\ndone\nPUBKEY_MCRYPT=$(doveconf -P 2> /dev/null | grep -i mail_crypt_global_public_key | cut -d '<' -f2)\nif [ -f ${PUBKEY_MCRYPT} ]; then\n  GUID=$(cat <(echo ${MAILCOW_HOSTNAME}) /mail_crypt/ecpubkey.pem | sha256sum | cut -d ' ' -f1 | tr -cd \"[a-fA-F0-9.:/] \")\n  if [ ${#GUID} -eq 64 ]; then\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"${GUID}\");\nEOF\n  else\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"INVALID\");\nEOF\n  fi\nfi\n\n# Collect SA rules once now\n/usr/local/bin/sa-rules.sh\n\n# Run hooks\nfor file in /hooks/*; do\n  if [ -x \"${file}\" ]; then\n    echo \"Running hook ${file}\"\n    \"${file}\"\n  fi\ndone\n\n# For some strange, unknown and stupid reason, Dovecot may run into a race condition, when this file is not touched before it is read by dovecot/auth\n# May be related to something inside Docker, I seriously don't know\ntouch /etc/dovecot/lua/passwd-verify.lua\n\nexec \"$@\"\n"], "fixing_code": ["#!/bin/bash\nset -e\n\n# Wait for MySQL to warm-up\nwhile ! mysqladmin status --socket=/var/run/mysqld/mysqld.sock -u${DBUSER} -p${DBPASS} --silent; do\n  echo \"Waiting for database to come up...\"\n  sleep 2\ndone\n\nuntil dig +short mailcow.email > /dev/null; do\n  echo \"Waiting for DNS...\"\n  sleep 1\ndone\n\n# Do not attempt to write to slave\nif [[ ! -z ${REDIS_SLAVEOF_IP} ]]; then\n  REDIS_CMDLINE=\"redis-cli -h ${REDIS_SLAVEOF_IP} -p ${REDIS_SLAVEOF_PORT}\"\nelse\n  REDIS_CMDLINE=\"redis-cli -h redis -p 6379\"\nfi\n\nuntil [[ $(${REDIS_CMDLINE} PING) == \"PONG\" ]]; do\n  echo \"Waiting for Redis...\"\n  sleep 2\ndone\n\n${REDIS_CMDLINE} SET DOVECOT_REPL_HEALTH 1 > /dev/null\n\n# Create missing directories\n[[ ! -d /etc/dovecot/sql/ ]] && mkdir -p /etc/dovecot/sql/\n[[ ! -d /etc/dovecot/lua/ ]] && mkdir -p /etc/dovecot/lua/\n[[ ! -d /var/vmail/_garbage ]] && mkdir -p /var/vmail/_garbage\n[[ ! -d /var/vmail/sieve ]] && mkdir -p /var/vmail/sieve\n[[ ! -d /etc/sogo ]] && mkdir -p /etc/sogo\n[[ ! -d /var/volatile ]] && mkdir -p /var/volatile\n\n# Set Dovecot sql config parameters, escape \" in db password\nDBPASS=$(echo ${DBPASS} | sed 's/\"/\\\\\"/g')\n\n# Create quota dict for Dovecot\nif [[ \"${MASTER}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\n  QUOTA_TABLE=quota2\nelse\n  QUOTA_TABLE=quota2replica\nfi\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-quota.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/quota/storage\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = bytes\n}\nmap {\n  pattern = priv/quota/messages\n  table = ${QUOTA_TABLE}\n  username_field = username\n  value_field = messages\n}\nEOF\n\n# Create dict used for sieve pre and postfilters\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_before.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_before\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_before\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-sieve_after.conf\n# Autogenerated by mailcow\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nmap {\n  pattern = priv/sieve/name/\\$script_name\n  table = sieve_after\n  username_field = username\n  value_field = id\n  fields {\n    script_name = \\$script_name\n  }\n}\nmap {\n  pattern = priv/sieve/data/\\$id\n  table = sieve_after\n  username_field = username\n  value_field = script_data\n  fields {\n    id = \\$id\n  }\n}\nEOF\n\necho -n ${ACL_ANYONE} > /etc/dovecot/acl_anyone\n\nif [[ \"${SKIP_SOLR}\" =~ ^([yY][eE][sS]|[yY])+$ ]]; then\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify listescape replication mail_log' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nelse\necho -n 'quota acl zlib mail_crypt mail_crypt_acl mail_log notify fts fts_solr listescape replication' > /etc/dovecot/mail_plugins\necho -n 'quota imap_quota imap_acl acl zlib imap_zlib imap_sieve mail_crypt mail_crypt_acl notify mail_log fts fts_solr listescape replication' > /etc/dovecot/mail_plugins_imap\necho -n 'quota sieve acl zlib mail_crypt mail_crypt_acl fts fts_solr notify listescape replication' > /etc/dovecot/mail_plugins_lmtp\nfi\nchmod 644 /etc/dovecot/mail_plugins /etc/dovecot/mail_plugins_imap /etc/dovecot/mail_plugins_lmtp /templates/quarantine.tpl\n\ncat <<EOF > /etc/dovecot/sql/dovecot-dict-sql-userdb.conf\n# Autogenerated by mailcow\ndriver = mysql\nconnect = \"host=/var/run/mysqld/mysqld.sock dbname=${DBNAME} user=${DBUSER} password=${DBPASS}\"\nuser_query = SELECT CONCAT(JSON_UNQUOTE(JSON_VALUE(attributes, '$.mailbox_format')), mailbox_path_prefix, '%d/%n/${MAILDIR_SUB}:VOLATILEDIR=/var/volatile/%u:INDEX=/var/vmail_index/%u') AS mail, '%s' AS protocol, 5000 AS uid, 5000 AS gid, concat('*:bytes=', quota) AS quota_rule FROM mailbox WHERE username = '%u' AND (active = '1' OR active = '2')\niterate_query = SELECT username FROM mailbox WHERE active = '1' OR active = '2';\nEOF\n\ncat <<EOF > /etc/dovecot/lua/passwd-verify.lua\nfunction auth_password_verify(req, pass)\n\n  if req.domain == nil then\n    return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"No such user\"\n  end\n\n  if cur == nil then\n    script_init()\n  end\n\n  if req.user == nil then\n    req.user = ''\n  end\n\n  respbody = {}\n\n  -- check against mailbox passwds\n  local cur,errorString = con:execute(string.format([[SELECT password FROM mailbox\n    WHERE username = '%s'\n      AND active = '1'\n      AND domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(mailbox.attributes, '$.force_pw_update')), 0) != '1'\n      AND IFNULL(JSON_UNQUOTE(JSON_VALUE(attributes, '$.%s_access')), 1) = '1']], con:escape(req.user), con:escape(req.domain), con:escape(req.service)))\n  local row = cur:fetch ({}, \"a\")\n  while row do\n    if req.password_verify(req, row.password, pass) == 1 then\n      con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n        VALUES (\"%s\", 0, \"%s\", \"%s\")]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip)))\n      cur:close()\n      con:close()\n      return dovecot.auth.PASSDB_RESULT_OK, \"password=pass\"\n    end\n    row = cur:fetch (row, \"a\")\n  end\n\n  -- check against app passwds for imap and smtp\n  -- app passwords are only available for imap, smtp, sieve and pop3 when using sasl\n  if req.service == \"smtp\" or req.service == \"imap\" or req.service == \"sieve\" or req.service == \"pop3\" then\n    local cur,errorString = con:execute(string.format([[SELECT app_passwd.id, %s_access AS has_prot_access, app_passwd.password FROM app_passwd\n      INNER JOIN mailbox ON mailbox.username = app_passwd.mailbox\n      WHERE mailbox = '%s'\n        AND app_passwd.active = '1'\n        AND mailbox.active = '1'\n        AND app_passwd.domain IN (SELECT domain FROM domain WHERE domain='%s' AND active='1')]], con:escape(req.service), con:escape(req.user), con:escape(req.domain)))\n    local row = cur:fetch ({}, \"a\")\n    while row do\n      if req.password_verify(req, row.password, pass) == 1 then\n        -- if password is valid and protocol access is 1 OR real_rip matches SOGo, proceed\n        if tostring(req.real_rip) == \"__IPV4_SOGO__\" then\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"password=pass\"\n        elseif row.has_prot_access == \"1\" then\n          con:execute(string.format([[REPLACE INTO sasl_log (service, app_password, username, real_rip)\n            VALUES (\"%s\", %d, \"%s\", \"%s\")]], con:escape(req.service), row.id, con:escape(req.user), con:escape(req.real_rip)))\n          cur:close()\n          con:close()\n          return dovecot.auth.PASSDB_RESULT_OK, \"password=pass\"\n        end\n      end\n      row = cur:fetch (row, \"a\")\n    end\n  end\n\n  cur:close()\n  con:close()\n\n  return dovecot.auth.PASSDB_RESULT_PASSWORD_MISMATCH, \"Failed to authenticate\"\n\n  -- PoC\n  -- local reqbody = string.format([[{\n  --   \"success\":0,\n  --   \"service\":\"%s\",\n  --   \"app_password\":false,\n  --   \"username\":\"%s\",\n  --   \"real_rip\":\"%s\"\n  -- }]], con:escape(req.service), con:escape(req.user), con:escape(req.real_rip))\n  -- http.request {\n  --   method = \"POST\",\n  --   url = \"http://nginx:8081/sasl_log.php\",\n  --   source = ltn12.source.string(reqbody),\n  --   headers = {\n  --     [\"content-type\"] = \"application/json\",\n  --     [\"content-length\"] = tostring(#reqbody)\n  --   },\n  --   sink = ltn12.sink.table(respbody)\n  -- }\n\nend\n\nfunction auth_passdb_lookup(req)\n   return dovecot.auth.PASSDB_RESULT_USER_UNKNOWN, \"\"\nend\n\nfunction script_init()\n  mysql = require \"luasql.mysql\"\n  http = require \"socket.http\"\n  http.TIMEOUT = 5\n  ltn12 = require \"ltn12\"\n  env  = mysql.mysql()\n  con = env:connect(\"__DBNAME__\",\"__DBUSER__\",\"__DBPASS__\",\"localhost\")\n  return 0\nend\n\nfunction script_deinit()\n  con:close()\n  env:close()\nend\nEOF\n\n# Replace patterns in app-passdb.lua\nsed -i \"s/__DBUSER__/${DBUSER}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBPASS__/${DBPASS}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__DBNAME__/${DBNAME}/g\" /etc/dovecot/lua/passwd-verify.lua\nsed -i \"s/__IPV4_SOGO__/${IPV4_NETWORK}.248/g\" /etc/dovecot/lua/passwd-verify.lua\n\n\n# Migrate old sieve_after file\n[[ -f /etc/dovecot/sieve_after ]] && mv /etc/dovecot/sieve_after /etc/dovecot/global_sieve_after\n# Create global sieve scripts\ncat /etc/dovecot/global_sieve_after > /var/vmail/sieve/global_sieve_after.sieve\ncat /etc/dovecot/global_sieve_before > /var/vmail/sieve/global_sieve_before.sieve\n\n# Check permissions of vmail/index/garbage directories.\n# Do not do this every start-up, it may take a very long time. So we use a stat check here.\nif [[ $(stat -c %U /var/vmail/) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail ; fi\nif [[ $(stat -c %U /var/vmail/_garbage) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail/_garbage ; fi\nif [[ $(stat -c %U /var/vmail_index) != \"vmail\" ]] ; then chown -R vmail:vmail /var/vmail_index ; fi\n\n# Cleanup random user maildirs\nrm -rf /var/vmail/mailcow.local/*\n# Cleanup PIDs\n[[ -f /tmp/quarantine_notify.pid ]] && rm /tmp/quarantine_notify.pid\n\n# create sni configuration\necho \"\" > /etc/dovecot/sni.conf\nfor cert_dir in /etc/ssl/mail/*/ ; do\n  if [[ ! -f ${cert_dir}domains ]] || [[ ! -f ${cert_dir}cert.pem ]] || [[ ! -f ${cert_dir}key.pem ]]; then\n    continue\n  fi\n  domains=($(cat ${cert_dir}domains))\n  for domain in ${domains[@]}; do\n    echo 'local_name '${domain}' {' >> /etc/dovecot/sni.conf;\n    echo '  ssl_cert = <'${cert_dir}'cert.pem' >> /etc/dovecot/sni.conf;\n    echo '  ssl_key = <'${cert_dir}'key.pem' >> /etc/dovecot/sni.conf;\n    echo '}' >> /etc/dovecot/sni.conf;\n  done\ndone\n\n# Create random master for SOGo sieve features\nRAND_USER=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 16 | head -n 1)\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 24 | head -n 1)\n\nif [[ ! -z ${DOVECOT_MASTER_USER} ]] && [[ ! -z ${DOVECOT_MASTER_PASS} ]]; then\n  RAND_USER=${DOVECOT_MASTER_USER}\n  RAND_PASS=${DOVECOT_MASTER_PASS}\nfi\necho ${RAND_USER}@mailcow.local:{SHA1}$(echo -n ${RAND_PASS} | sha1sum | awk '{print $1}'):::::: > /etc/dovecot/dovecot-master.passwd\necho ${RAND_USER}@mailcow.local::5000:5000:::: > /etc/dovecot/dovecot-master.userdb\necho ${RAND_USER}@mailcow.local:${RAND_PASS} > /etc/sogo/sieve.creds\n\nif [[ -z ${MAILDIR_SUB} ]]; then\n  MAILDIR_SUB_SHARED=\nelse\n  MAILDIR_SUB_SHARED=/${MAILDIR_SUB}\nfi\ncat <<EOF > /etc/dovecot/shared_namespace.conf\n# Autogenerated by mailcow\nnamespace {\n    type = shared\n    separator = /\n    prefix = Shared/%%u/\n    location = maildir:%%h${MAILDIR_SUB_SHARED}:INDEX=~${MAILDIR_SUB_SHARED}/Shared/%%u\n    subscriptions = no\n    list = children\n}\nEOF\n\n\ncat <<EOF > /etc/dovecot/sogo_trusted_ip.conf\n# Autogenerated by mailcow\nremote ${IPV4_NETWORK}.248 {\n  disable_plaintext_auth = no\n}\nEOF\n\n# Create random master Password for SOGo SSO\nRAND_PASS=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)\necho -n ${RAND_PASS} > /etc/phpfpm/sogo-sso.pass\ncat <<EOF > /etc/dovecot/sogo-sso.conf\n# Autogenerated by mailcow\npassdb {\n  driver = static\n  args = allow_real_nets=${IPV4_NETWORK}.248/32 password={plain}${RAND_PASS}\n}\nEOF\n\nif [[ \"${MASTER}\" =~ ^([nN][oO]|[nN])+$ ]]; then\n  # Toggling MASTER will result in a rebuild of containers, so the quota script will be recreated\n  cat <<'EOF' > /usr/local/bin/quota_notify.py\n#!/usr/bin/python3\nimport sys\nsys.exit()\nEOF\nfi\n\n# 401 is user dovecot\nif [[ ! -s /mail_crypt/ecprivkey.pem || ! -s /mail_crypt/ecpubkey.pem ]]; then\n\topenssl ecparam -name prime256v1 -genkey | openssl pkey -out /mail_crypt/ecprivkey.pem\n\topenssl pkey -in /mail_crypt/ecprivkey.pem -pubout -out /mail_crypt/ecpubkey.pem\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nelse\n\tchown 401 /mail_crypt/ecprivkey.pem /mail_crypt/ecpubkey.pem\nfi\n\n# Compile sieve scripts\nsievec /var/vmail/sieve/global_sieve_before.sieve\nsievec /var/vmail/sieve/global_sieve_after.sieve\nsievec /usr/lib/dovecot/sieve/report-spam.sieve\nsievec /usr/lib/dovecot/sieve/report-ham.sieve\n\nfor file in /var/vmail/*/*/sieve/*.sieve ; do\n  if [[ \"$file\" == \"/var/vmail/*/*/sieve/*.sieve\" ]]; then\n    continue\n  fi\n  sievec \"$file\" \"$(dirname \"$file\")/../.dovecot.svbin\"\n  chown vmail:vmail \"$(dirname \"$file\")/../.dovecot.svbin\"\ndone\n\n# Fix permissions\nchown root:root /etc/dovecot/sql/*.conf\nchown root:dovecot /etc/dovecot/sql/dovecot-dict-sql-sieve* /etc/dovecot/sql/dovecot-dict-sql-quota* /etc/dovecot/lua/passwd-verify.lua\nchmod 640 /etc/dovecot/sql/*.conf /etc/dovecot/lua/passwd-verify.lua\nchown -R vmail:vmail /var/vmail/sieve\nchown -R vmail:vmail /var/volatile\nchown -R vmail:vmail /var/vmail_index\nadduser vmail tty\nchmod g+rw /dev/console\nchown root:tty /dev/console\nchmod +x /usr/lib/dovecot/sieve/rspamd-pipe-ham \\\n  /usr/lib/dovecot/sieve/rspamd-pipe-spam \\\n  /usr/local/bin/imapsync_runner.pl \\\n  /usr/local/bin/imapsync \\\n  /usr/local/bin/trim_logs.sh \\\n  /usr/local/bin/sa-rules.sh \\\n  /usr/local/bin/clean_q_aged.sh \\\n  /usr/local/bin/maildir_gc.sh \\\n  /usr/local/sbin/stop-supervisor.sh \\\n  /usr/local/bin/quota_notify.py \\\n  /usr/local/bin/repl_health.sh\n\n# Prepare environment file for cronjobs\nprintenv | sed 's/^\\(.*\\)$/export \\1/g' > /source_env.sh\n\n# Clean old PID if any\n[[ -f /var/run/dovecot/master.pid ]] && rm /var/run/dovecot/master.pid\n\n# Clean stopped imapsync jobs\nrm -f /tmp/imapsync_busy.lock\nIMAPSYNC_TABLE=$(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"SHOW TABLES LIKE 'imapsync'\" -Bs)\n[[ ! -z ${IMAPSYNC_TABLE} ]] && mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -e \"UPDATE imapsync SET is_running='0'\"\n\n# Envsubst maildir_gc\necho \"$(envsubst < /usr/local/bin/maildir_gc.sh)\" > /usr/local/bin/maildir_gc.sh\n\n# GUID generation\nwhile [[ ${VERSIONS_OK} != 'OK' ]]; do\n  if [[ ! -z $(mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} -B -e \"SELECT 'OK' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \\\"${DBNAME}\\\" AND TABLE_NAME = 'versions'\") ]]; then\n    VERSIONS_OK=OK\n  else\n    echo \"Waiting for versions table to be created...\"\n    sleep 3\n  fi\ndone\nPUBKEY_MCRYPT=$(doveconf -P 2> /dev/null | grep -i mail_crypt_global_public_key | cut -d '<' -f2)\nif [ -f ${PUBKEY_MCRYPT} ]; then\n  GUID=$(cat <(echo ${MAILCOW_HOSTNAME}) /mail_crypt/ecpubkey.pem | sha256sum | cut -d ' ' -f1 | tr -cd \"[a-fA-F0-9.:/] \")\n  if [ ${#GUID} -eq 64 ]; then\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"${GUID}\");\nEOF\n  else\n    mysql --socket=/var/run/mysqld/mysqld.sock -u ${DBUSER} -p${DBPASS} ${DBNAME} << EOF\nREPLACE INTO versions (application, version) VALUES (\"GUID\", \"INVALID\");\nEOF\n  fi\nfi\n\n# Collect SA rules once now\n/usr/local/bin/sa-rules.sh\n\n# Run hooks\nfor file in /hooks/*; do\n  if [ -x \"${file}\" ]; then\n    echo \"Running hook ${file}\"\n    \"${file}\"\n  fi\ndone\n\n# For some strange, unknown and stupid reason, Dovecot may run into a race condition, when this file is not touched before it is read by dovecot/auth\n# May be related to something inside Docker, I seriously don't know\ntouch /etc/dovecot/lua/passwd-verify.lua\n\nexec \"$@\"\n"], "filenames": ["data/Dockerfiles/dovecot/docker-entrypoint.sh"], "buggy_code_start_loc": [162], "buggy_code_end_loc": [190], "fixing_code_start_loc": [162], "fixing_code_end_loc": [190], "type": "NVD-CWE-noinfo", "message": "mailcow is a mail server suite based on Dovecot, Postfix and other open source software, that provides a modern web UI for user/server administration. A vulnerability has been discovered in mailcow which allows an attacker to manipulate internal Dovecot variables by using specially crafted passwords during the authentication process. The issue arises from the behavior of the `passwd-verify.lua` script, which is responsible for verifying user passwords during login attempts. Upon a successful login, the script returns a response in the format of \"password=<valid-password>\", indicating the successful authentication. By crafting a password with additional key-value pairs appended to it, an attacker can manipulate the returned string and influence the internal behavior of Dovecot. For example, using the password \"123 mail_crypt_save_version=0\" would cause the `passwd-verify.lua` script to return the string \"password=123 mail_crypt_save_version=0\". Consequently, Dovecot will interpret this string and set the internal variables accordingly, leading to unintended consequences. This vulnerability can be exploited by an authenticated attacker who has the ability to set their own password. Successful exploitation of this vulnerability could result in unauthorized access to user accounts, bypassing security controls, or other malicious activities. This issue has been patched in version `2023-05a`. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-34108", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-07T18:15:09.817", "lastModified": "2023-06-15T15:31:29.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mailcow is a mail server suite based on Dovecot, Postfix and other open source software, that provides a modern web UI for user/server administration. A vulnerability has been discovered in mailcow which allows an attacker to manipulate internal Dovecot variables by using specially crafted passwords during the authentication process. The issue arises from the behavior of the `passwd-verify.lua` script, which is responsible for verifying user passwords during login attempts. Upon a successful login, the script returns a response in the format of \"password=<valid-password>\", indicating the successful authentication. By crafting a password with additional key-value pairs appended to it, an attacker can manipulate the returned string and influence the internal behavior of Dovecot. For example, using the password \"123 mail_crypt_save_version=0\" would cause the `passwd-verify.lua` script to return the string \"password=123 mail_crypt_save_version=0\". Consequently, Dovecot will interpret this string and set the internal variables accordingly, leading to unintended consequences. This vulnerability can be exploited by an authenticated attacker who has the ability to set their own password. Successful exploitation of this vulnerability could result in unauthorized access to user accounts, bypassing security controls, or other malicious activities. This issue has been patched in version `2023-05a`. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mailcow:mailcow\\:_dockerized:*:*:*:*:*:*:*:*", "versionEndIncluding": "2023-05", "matchCriteriaId": "8736D463-F179-4128-9AD2-A4CE6F4A0ACA"}]}]}], "references": [{"url": "https://github.com/VladimirBorisov/CVE_proposal/blob/main/MailcowUserPassword.md", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/mailcow/mailcow-dockerized/commit/f80940efdccd393bf5fccec2886795372a38c445", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mailcow/mailcow-dockerized/security/advisories/GHSA-mhh4-qchc-pv22", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mailcow/mailcow-dockerized/commit/f80940efdccd393bf5fccec2886795372a38c445"}}