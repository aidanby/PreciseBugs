{"buggy_code": ["/*\n *  Host code generation\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/units.h\"\n#include \"qemu-common.h\"\n\n#define NO_CPU_IO_DEFS\n#include \"cpu.h\"\n#include \"exec/exec-all.h\"\n#include \"tcg/tcg.h\"\n#include \"exec/ram_addr.h\"\n\n#include \"exec/cputlb.h\"\n#include \"exec/tb-hash.h\"\n#include \"translate-all.h\"\n#include \"qemu/bitmap.h\"\n#include \"qemu/timer.h\"\n#include \"sysemu/cpus.h\"\n#include \"sysemu/tcg.h\"\n#include \"uc_priv.h\"\n\nstatic bool tb_exec_is_locked(TCGContext*);\nstatic void tb_exec_change(TCGContext*, bool locked);\n\n/* #define DEBUG_TB_INVALIDATE */\n/* #define DEBUG_TB_FLUSH */\n/* make various TB consistency checks */\n/* #define DEBUG_TB_CHECK */\n\n#ifdef DEBUG_TB_INVALIDATE\n#define DEBUG_TB_INVALIDATE_GATE 1\n#else\n#define DEBUG_TB_INVALIDATE_GATE 0\n#endif\n\n#ifdef DEBUG_TB_FLUSH\n#define DEBUG_TB_FLUSH_GATE 1\n#else\n#define DEBUG_TB_FLUSH_GATE 0\n#endif\n\n/* TB consistency checks only implemented for usermode emulation.  */\n#undef DEBUG_TB_CHECK\n\n#ifdef DEBUG_TB_CHECK\n#define DEBUG_TB_CHECK_GATE 1\n#else\n#define DEBUG_TB_CHECK_GATE 0\n#endif\n\n/* Access to the various translations structures need to be serialised via locks\n * for consistency.\n * In user-mode emulation access to the memory related structures are protected\n * with mmap_lock.\n * In !user-mode we use per-page locks.\n */\n#define assert_memory_lock()\n\n#define SMC_BITMAP_USE_THRESHOLD 10\n\ntypedef struct PageDesc {\n    /* list of TBs intersecting this ram page */\n    uintptr_t first_tb;\n    /* in order to optimize self modifying code, we count the number\n       of lookups we do to a given page to use a bitmap */\n    unsigned long *code_bitmap;\n    unsigned int code_write_count;\n} PageDesc;\n\n/**\n * struct page_entry - page descriptor entry\n * @pd:     pointer to the &struct PageDesc of the page this entry represents\n * @index:  page index of the page\n * @locked: whether the page is locked\n *\n * This struct helps us keep track of the locked state of a page, without\n * bloating &struct PageDesc.\n *\n * A page lock protects accesses to all fields of &struct PageDesc.\n *\n * See also: &struct page_collection.\n */\nstruct page_entry {\n    PageDesc *pd;\n    tb_page_addr_t index;\n    bool locked;\n};\n\n/**\n * struct page_collection - tracks a set of pages (i.e. &struct page_entry's)\n * @tree:   Binary search tree (BST) of the pages, with key == page index\n * @max:    Pointer to the page in @tree with the highest page index\n *\n * To avoid deadlock we lock pages in ascending order of page index.\n * When operating on a set of pages, we need to keep track of them so that\n * we can lock them in order and also unlock them later. For this we collect\n * pages (i.e. &struct page_entry's) in a binary search @tree. Given that the\n * @tree implementation we use does not provide an O(1) operation to obtain the\n * highest-ranked element, we use @max to keep track of the inserted page\n * with the highest index. This is valuable because if a page is not in\n * the tree and its index is higher than @max's, then we can lock it\n * without breaking the locking order rule.\n *\n * Note on naming: 'struct page_set' would be shorter, but we already have a few\n * page_set_*() helpers, so page_collection is used instead to avoid confusion.\n *\n * See also: page_collection_lock().\n */\nstruct page_collection {\n    GTree *tree;\n    struct page_entry *max;\n};\n\n/* list iterators for lists of tagged pointers in TranslationBlock */\n#define TB_FOR_EACH_TAGGED(head, tb, n, field)                          \\\n    for (n = (head) & 1, tb = (TranslationBlock *)((head) & ~1);        \\\n         tb; tb = (TranslationBlock *)tb->field[n], n = (uintptr_t)tb & 1, \\\n             tb = (TranslationBlock *)((uintptr_t)tb & ~1))\n\n#define PAGE_FOR_EACH_TB(pagedesc, tb, n)                       \\\n    TB_FOR_EACH_TAGGED((pagedesc)->first_tb, tb, n, page_next)\n\n#define TB_FOR_EACH_JMP(head_tb, tb, n)                                 \\\n    TB_FOR_EACH_TAGGED((head_tb)->jmp_list_head, tb, n, jmp_list_next)\n\n/* In system mode we want L1_MAP to be based on ram offsets,\n   while in user mode we want it to be based on virtual addresses.  */\n#if HOST_LONG_BITS < TARGET_PHYS_ADDR_SPACE_BITS\n# define L1_MAP_ADDR_SPACE_BITS  HOST_LONG_BITS\n#else\n# define L1_MAP_ADDR_SPACE_BITS  TARGET_PHYS_ADDR_SPACE_BITS\n#endif\n\n/* Size of the L2 (and L3, etc) page tables.  */\n#define V_L2_BITS 10\n#define V_L2_SIZE (1 << V_L2_BITS)\n\n/* Make sure all possible CPU event bits fit in tb->trace_vcpu_dstate */\nQEMU_BUILD_BUG_ON(CPU_TRACE_DSTATE_MAX_EVENTS >\n                  sizeof_field(TranslationBlock, trace_vcpu_dstate)\n                  * BITS_PER_BYTE);\n\n/* The bottom level has pointers to PageDesc, and is indexed by\n * anything from 4 to (V_L2_BITS + 3) bits, depending on target page size.\n */\n#define V_L1_MIN_BITS 4\n#define V_L1_MAX_BITS (V_L2_BITS + 3)\n#define V_L1_MAX_SIZE (1 << V_L1_MAX_BITS)\n\nstatic void page_table_config_init(struct uc_struct *uc)\n{\n    uint32_t v_l1_bits;\n\n    assert(TARGET_PAGE_BITS);\n    /* The bits remaining after N lower levels of page tables.  */\n    v_l1_bits = (L1_MAP_ADDR_SPACE_BITS - TARGET_PAGE_BITS) % V_L2_BITS;\n    if (v_l1_bits < V_L1_MIN_BITS) {\n        v_l1_bits += V_L2_BITS;\n    }\n\n    uc->v_l1_size = 1 << v_l1_bits;\n    uc->v_l1_shift = L1_MAP_ADDR_SPACE_BITS - TARGET_PAGE_BITS - v_l1_bits;\n    uc->v_l2_levels = uc->v_l1_shift / V_L2_BITS - 1;\n\n    assert(v_l1_bits <= V_L1_MAX_BITS);\n    assert(uc->v_l1_shift % V_L2_BITS == 0);\n    assert(uc->v_l2_levels >= 0);\n}\n\n/* Encode VAL as a signed leb128 sequence at P.\n   Return P incremented past the encoded value.  */\nstatic uint8_t *encode_sleb128(uint8_t *p, target_long val)\n{\n    int more, byte;\n\n    do {\n        byte = val & 0x7f;\n        val >>= 7;\n        more = !((val == 0 && (byte & 0x40) == 0)\n                 || (val == -1 && (byte & 0x40) != 0));\n        if (more) {\n            byte |= 0x80;\n        }\n        *p++ = byte;\n    } while (more);\n\n    return p;\n}\n\n/* Decode a signed leb128 sequence at *PP; increment *PP past the\n   decoded value.  Return the decoded value.  */\nstatic target_long decode_sleb128(uint8_t **pp)\n{\n    uint8_t *p = *pp;\n    target_long val = 0;\n    int byte, shift = 0;\n\n    do {\n        byte = *p++;\n        val |= (target_ulong)(byte & 0x7f) << shift;\n        shift += 7;\n    } while (byte & 0x80);\n    if (shift < TARGET_LONG_BITS && (byte & 0x40)) {\n#ifdef _MSC_VER\n        val |= ((target_ulong)0 - 1) << shift;\n#else\n        val |= -(target_ulong)1 << shift;\n#endif\n    }\n\n    *pp = p;\n    return val;\n}\n\n/* Encode the data collected about the instructions while compiling TB.\n   Place the data at BLOCK, and return the number of bytes consumed.\n\n   The logical table consists of TARGET_INSN_START_WORDS target_ulong's,\n   which come from the target's insn_start data, followed by a uintptr_t\n   which comes from the host pc of the end of the code implementing the insn.\n\n   Each line of the table is encoded as sleb128 deltas from the previous\n   line.  The seed for the first line is { tb->pc, 0..., tb->tc.ptr }.\n   That is, the first column is seeded with the guest pc, the last column\n   with the host pc, and the middle columns with zeros.  */\n\nstatic int encode_search(struct uc_struct *uc, TranslationBlock *tb, uint8_t *block)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    uint8_t *highwater = tcg_ctx->code_gen_highwater;\n    uint8_t *p = block;\n    int i, j, n;\n\n    for (i = 0, n = tb->icount; i < n; ++i) {\n        target_ulong prev;\n\n        for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {\n            if (i == 0) {\n                prev = (j == 0 ? tb->pc : 0);\n            } else {\n                prev = tcg_ctx->gen_insn_data[i - 1][j];\n            }\n            p = encode_sleb128(p, tcg_ctx->gen_insn_data[i][j] - prev);\n        }\n        prev = (i == 0 ? 0 : tcg_ctx->gen_insn_end_off[i - 1]);\n        p = encode_sleb128(p, tcg_ctx->gen_insn_end_off[i] - prev);\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n           one row beginning below the high water mark cannot overrun\n           the buffer completely.  Thus we can test for overflow after\n           encoding a row without having to check during encoding.  */\n        if (unlikely(p > highwater)) {\n            return -1;\n        }\n    }\n\n    return p - block;\n}\n\n/* The cpu state corresponding to 'searched_pc' is restored.\n * When reset_icount is true, current TB will be interrupted and\n * icount should be recalculated.\n */\nstatic int cpu_restore_state_from_tb(CPUState *cpu, TranslationBlock *tb,\n                                     uintptr_t searched_pc, bool reset_icount)\n{\n    target_ulong data[TARGET_INSN_START_WORDS] = { tb->pc };\n    uintptr_t host_pc = (uintptr_t)tb->tc.ptr;\n    CPUArchState *env = cpu->env_ptr;\n    uint8_t *p = (uint8_t *)tb->tc.ptr + tb->tc.size;\n    int i, j, num_insns = tb->icount;\n\n    searched_pc -= GETPC_ADJ;\n\n    if (searched_pc < host_pc) {\n        return -1;\n    }\n\n    /* Reconstruct the stored insn data while looking for the point at\n       which the end of the insn exceeds the searched_pc.  */\n    for (i = 0; i < num_insns; ++i) {\n        for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {\n            data[j] += decode_sleb128(&p);\n        }\n        host_pc += decode_sleb128(&p);\n        if (host_pc > searched_pc) {\n            goto found;\n        }\n    }\n    return -1;\n\n found:\n    if (reset_icount && (tb_cflags(tb) & CF_USE_ICOUNT)) {\n        /* Reset the cycle counter to the start of the block\n           and shift if to the number of actually executed instructions */\n        cpu_neg(cpu)->icount_decr.u16.low += num_insns - i;\n    }\n    restore_state_to_opc(env, tb, data);\n\n    return 0;\n}\n\nbool cpu_restore_state(CPUState *cpu, uintptr_t host_pc, bool will_exit)\n{\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n    TranslationBlock *tb;\n    bool r = false;\n    uintptr_t check_offset;\n    struct uc_struct *uc = cpu->uc;\n\n    /* The host_pc has to be in the region of current code buffer. If\n     * it is not we will not be able to resolve it here. The two cases\n     * where host_pc will not be correct are:\n     *\n     *  - fault during translation (instruction fetch)\n     *  - fault from helper (not using GETPC() macro)\n     *\n     * Either way we need return early as we can't resolve it here.\n     *\n     * We are using unsigned arithmetic so if host_pc <\n     * tcg_init_ctx.code_gen_buffer check_offset will wrap to way\n     * above the code_gen_buffer_size\n     */\n    check_offset = host_pc - (uintptr_t) uc->tcg_ctx->code_gen_buffer;\n\n    if (check_offset < uc->tcg_ctx->code_gen_buffer_size) {\n        tb = tcg_tb_lookup(tcg_ctx, host_pc);\n        if (tb) {\n            cpu_restore_state_from_tb(cpu, tb, host_pc, will_exit);\n            if (tb_cflags(tb) & CF_NOCACHE) {\n                /* one-shot translation, invalidate it immediately */\n                tb_phys_invalidate(tcg_ctx, tb, -1);\n                tcg_tb_remove(tcg_ctx, tb);\n            }\n            r = true;\n        }\n    }\n\n    return r;\n}\n\nstatic void page_init(struct uc_struct *uc)\n{\n    page_size_init(uc);\n    page_table_config_init(uc);\n}\n\nstatic PageDesc *page_find_alloc(struct uc_struct *uc, tb_page_addr_t index, int alloc)\n{\n    PageDesc *pd;\n    void **lp;\n    int i;\n\n    /* Level 1.  Always allocated.  */\n    lp = uc->l1_map + ((index >> uc->v_l1_shift) & (uc->v_l1_size - 1));\n\n    /* Level 2..N-1.  */\n    for (i = uc->v_l2_levels; i > 0; i--) {\n        void **p = *lp;\n\n        if (p == NULL) {\n            void *existing;\n\n            if (!alloc) {\n                return NULL;\n            }\n            p = g_new0(void *, V_L2_SIZE);\n            existing = *lp;\n            if (*lp == NULL) {\n                *lp = p;\n            }\n            if (unlikely(existing)) {\n                g_free(p);\n                p = existing;\n            }\n        }\n\n        lp = p + ((index >> (i * V_L2_BITS)) & (V_L2_SIZE - 1));\n    }\n\n    pd = *lp;\n    if (pd == NULL) {\n        void *existing;\n\n        if (!alloc) {\n            return NULL;\n        }\n        pd = g_new0(PageDesc, V_L2_SIZE);\n        existing = *lp;\n        if (*lp == NULL) {\n            *lp = pd;\n        }\n        if (unlikely(existing)) {\n            g_free(pd);\n            pd = existing;\n        }\n    }\n\n    return pd + (index & (V_L2_SIZE - 1));\n}\n\nstatic inline PageDesc *page_find(struct uc_struct *uc, tb_page_addr_t index)\n{\n    return page_find_alloc(uc, index, 0);\n}\n\nstatic void page_lock_pair(struct uc_struct *uc, PageDesc **ret_p1, tb_page_addr_t phys1,\n                           PageDesc **ret_p2, tb_page_addr_t phys2, int alloc);\n\n#ifdef CONFIG_DEBUG_TCG\n\nstatic void ht_pages_locked_debug_init(void)\n{\n    if (ht_pages_locked_debug) {\n        return;\n    }\n    ht_pages_locked_debug = g_hash_table_new(NULL, NULL);\n}\n\nstatic bool page_is_locked(const PageDesc *pd)\n{\n    PageDesc *found;\n\n    ht_pages_locked_debug_init();\n    found = g_hash_table_lookup(ht_pages_locked_debug, pd);\n    return !!found;\n}\n\nstatic void page_lock__debug(PageDesc *pd)\n{\n    ht_pages_locked_debug_init();\n    g_assert(!page_is_locked(pd));\n    g_hash_table_insert(ht_pages_locked_debug, pd, pd);\n}\n\nstatic void page_unlock__debug(const PageDesc *pd)\n{\n    bool removed;\n\n    ht_pages_locked_debug_init();\n    g_assert(page_is_locked(pd));\n    removed = g_hash_table_remove(ht_pages_locked_debug, pd);\n    g_assert(removed);\n}\n\nstatic void\ndo_assert_page_locked(const PageDesc *pd, const char *file, int line)\n{\n    if (unlikely(!page_is_locked(pd))) {\n        // error_report(\"assert_page_lock: PageDesc %p not locked @ %s:%d\",\n        //              pd, file, line);\n        abort();    // unreachable in unicorn.\n    }\n}\n\n#define assert_page_locked(pd) do_assert_page_locked(pd, __FILE__, __LINE__)\n\nvoid assert_no_pages_locked(void)\n{\n    ht_pages_locked_debug_init();\n    g_assert(g_hash_table_size(ht_pages_locked_debug) == 0);\n}\n\n#else /* !CONFIG_DEBUG_TCG */\n\n#define assert_page_locked(pd)\n\nstatic inline void page_lock__debug(const PageDesc *pd)\n{\n}\n\nstatic inline void page_unlock__debug(const PageDesc *pd)\n{\n}\n\n#endif /* CONFIG_DEBUG_TCG */\n\nstatic inline void page_lock(PageDesc *pd)\n{\n    page_lock__debug(pd);\n}\n\nstatic inline void page_unlock(PageDesc *pd)\n{\n    page_unlock__debug(pd);\n}\n\n/* lock the page(s) of a TB in the correct acquisition order */\nstatic inline void page_lock_tb(struct uc_struct *uc, const TranslationBlock *tb)\n{\n    page_lock_pair(uc, NULL, tb->page_addr[0], NULL, tb->page_addr[1], 0);\n}\n\nstatic inline void page_unlock_tb(struct uc_struct *uc, const TranslationBlock *tb)\n{\n    PageDesc *p1 = page_find(uc, tb->page_addr[0] >> TARGET_PAGE_BITS);\n\n    page_unlock(p1);\n    if (unlikely(tb->page_addr[1] != -1)) {\n        PageDesc *p2 = page_find(uc, tb->page_addr[1] >> TARGET_PAGE_BITS);\n\n        if (p2 != p1) {\n            page_unlock(p2);\n        }\n    }\n}\n\nstatic inline struct page_entry *\npage_entry_new(PageDesc *pd, tb_page_addr_t index)\n{\n    struct page_entry *pe = g_malloc(sizeof(*pe));\n\n    pe->index = index;\n    pe->pd = pd;\n    // pe->locked = false;\n    return pe;\n}\n\nstatic void page_entry_destroy(gpointer p)\n{\n    struct page_entry *pe = p;\n\n    // g_assert(pe->locked);\n    page_unlock(pe->pd);\n    g_free(pe);\n}\n\n#if 0\n/* returns false on success */\nstatic bool page_entry_trylock(struct page_entry *pe)\n{\n    bool busy;\n\n    busy = qemu_spin_trylock(&pe->pd->lock);\n    if (!busy) {\n        g_assert(!pe->locked);\n        pe->locked = true;\n        page_lock__debug(pe->pd);\n    }\n    return busy;\n}\n\nstatic void do_page_entry_lock(struct page_entry *pe)\n{\n    page_lock(pe->pd);\n    g_assert(!pe->locked);\n    pe->locked = true;\n}\n\nstatic gboolean page_entry_lock(gpointer key, gpointer value, gpointer data)\n{\n    struct page_entry *pe = value;\n\n    do_page_entry_lock(pe);\n    return FALSE;\n}\n\nstatic gboolean page_entry_unlock(gpointer key, gpointer value, gpointer data)\n{\n    struct page_entry *pe = value;\n\n    if (pe->locked) {\n        pe->locked = false;\n        page_unlock(pe->pd);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Trylock a page, and if successful, add the page to a collection.\n * Returns true (\"busy\") if the page could not be locked; false otherwise.\n */\nstatic bool page_trylock_add(struct uc_struct *uc, struct page_collection *set, tb_page_addr_t addr)\n{\n    tb_page_addr_t index = addr >> TARGET_PAGE_BITS;\n    struct page_entry *pe;\n    PageDesc *pd;\n\n    pe = g_tree_lookup(set->tree, &index);\n    if (pe) {\n        return false;\n    }\n\n    pd = page_find(uc, index);\n    if (pd == NULL) {\n        return false;\n    }\n\n    pe = page_entry_new(pd, index);\n    g_tree_insert(set->tree, &pe->index, pe);\n\n    /*\n     * If this is either (1) the first insertion or (2) a page whose index\n     * is higher than any other so far, just lock the page and move on.\n     */\n    if (set->max == NULL || pe->index > set->max->index) {\n        set->max = pe;\n#if 0\n        do_page_entry_lock(pe);\n#endif\n        return false;\n    }\n    /*\n     * Try to acquire out-of-order lock; if busy, return busy so that we acquire\n     * locks in order.\n     */\n#if 0\n    return page_entry_trylock(pe);\n#else\n    return 0;\n#endif\n}\n\nstatic gint tb_page_addr_cmp(gconstpointer ap, gconstpointer bp, gpointer udata)\n{\n    tb_page_addr_t a = *(const tb_page_addr_t *)ap;\n    tb_page_addr_t b = *(const tb_page_addr_t *)bp;\n\n    if (a == b) {\n        return 0;\n    } else if (a < b) {\n        return -1;\n    }\n    return 1;\n}\n\n/*\n * Lock a range of pages ([@start,@end[) as well as the pages of all\n * intersecting TBs.\n * Locking order: acquire locks in ascending order of page index.\n */\nstruct page_collection *\npage_collection_lock(struct uc_struct *uc, tb_page_addr_t start, tb_page_addr_t end)\n{\n    struct page_collection *set = g_malloc(sizeof(*set));\n    tb_page_addr_t index;\n    PageDesc *pd;\n\n    start >>= TARGET_PAGE_BITS;\n    end   >>= TARGET_PAGE_BITS;\n    g_assert(start <= end);\n\n    set->tree = g_tree_new_full(tb_page_addr_cmp, NULL, NULL,\n                                page_entry_destroy);\n    set->max = NULL;\n    assert_no_pages_locked();\n\n retry:\n#if 0\n    g_tree_foreach(set->tree, page_entry_lock, NULL);\n#endif\n\n    for (index = start; index <= end; index++) {\n        TranslationBlock *tb;\n        int n;\n\n        pd = page_find(uc, index);\n        if (pd == NULL) {\n            continue;\n        }\n        if (page_trylock_add(uc, set, index << TARGET_PAGE_BITS)) {\n#if 0\n            g_tree_foreach(set->tree, page_entry_unlock, NULL);\n#endif\n            goto retry;\n        }\n        assert_page_locked(pd);\n        PAGE_FOR_EACH_TB(pd, tb, n) {\n            if (page_trylock_add(uc, set, tb->page_addr[0]) ||\n                (tb->page_addr[1] != -1 &&\n                 page_trylock_add(uc, set, tb->page_addr[1]))) {\n                /* drop all locks, and reacquire in order */\n#if 0\n                g_tree_foreach(set->tree, page_entry_unlock, NULL);\n#endif\n                goto retry;\n            }\n        }\n    }\n    return set;\n}\n\nvoid page_collection_unlock(struct page_collection *set)\n{\n    /* entries are unlocked and freed via page_entry_destroy */\n    g_tree_destroy(set->tree);\n    g_free(set);\n}\n\nstatic void page_lock_pair(struct uc_struct *uc, PageDesc **ret_p1, tb_page_addr_t phys1,\n                           PageDesc **ret_p2, tb_page_addr_t phys2, int alloc)\n{\n    PageDesc *p1, *p2;\n    tb_page_addr_t page1;\n    tb_page_addr_t page2;\n\n    assert_memory_lock();\n    g_assert(phys1 != -1);\n\n    page1 = phys1 >> TARGET_PAGE_BITS;\n    page2 = phys2 >> TARGET_PAGE_BITS;\n\n    p1 = page_find_alloc(uc, page1, alloc);\n    if (ret_p1) {\n        *ret_p1 = p1;\n    }\n    if (likely(phys2 == -1)) {\n        page_lock(p1);\n        return;\n    } else if (page1 == page2) {\n        page_lock(p1);\n        if (ret_p2) {\n            *ret_p2 = p1;\n        }\n        return;\n    }\n    p2 = page_find_alloc(uc, page2, alloc);\n    if (ret_p2) {\n        *ret_p2 = p2;\n    }\n    if (page1 < page2) {\n        page_lock(p1);\n        page_lock(p2);\n    } else {\n        page_lock(p2);\n        page_lock(p1);\n    }\n}\n\n/* Minimum size of the code gen buffer.  This number is randomly chosen,\n   but not so small that we can't have a fair number of TB's live.  */\n#define MIN_CODE_GEN_BUFFER_SIZE     (1 * MiB)\n\n/* Maximum size of the code gen buffer we'd like to use.  Unless otherwise\n   indicated, this is constrained by the range of direct branches on the\n   host cpu, as used by the TCG implementation of goto_tb.  */\n#if defined(__x86_64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__sparc__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__powerpc64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__powerpc__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (32 * MiB)\n#elif defined(__aarch64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__s390x__)\n  /* We have a +- 4GB range on the branches; leave some slop.  */\n# define MAX_CODE_GEN_BUFFER_SIZE  (3 * GiB)\n#elif defined(__mips__)\n  /* We have a 256MB branch region, but leave room to make sure the\n     main executable is also within that region.  */\n# define MAX_CODE_GEN_BUFFER_SIZE  (128 * MiB)\n#else\n# define MAX_CODE_GEN_BUFFER_SIZE  ((size_t)-1)\n#endif\n\n#if TCG_TARGET_REG_BITS == 32\n#define DEFAULT_CODE_GEN_BUFFER_SIZE_1 (32 * MiB)\n#else /* TCG_TARGET_REG_BITS == 64 */\n/*\n * We expect most system emulation to run one or two guests per host.\n * Users running large scale system emulation may want to tweak their\n * runtime setup via the tb-size control on the command line.\n */\n#define DEFAULT_CODE_GEN_BUFFER_SIZE_1 (1 * GiB)\n#endif\n\n#define DEFAULT_CODE_GEN_BUFFER_SIZE \\\n  (DEFAULT_CODE_GEN_BUFFER_SIZE_1 < MAX_CODE_GEN_BUFFER_SIZE \\\n   ? DEFAULT_CODE_GEN_BUFFER_SIZE_1 : MAX_CODE_GEN_BUFFER_SIZE)\n\nstatic inline size_t size_code_gen_buffer(size_t tb_size)\n{\n    /* Size the buffer.  */\n    if (tb_size == 0) {\n        tb_size = DEFAULT_CODE_GEN_BUFFER_SIZE;\n    }\n    if (tb_size < MIN_CODE_GEN_BUFFER_SIZE) {\n        tb_size = MIN_CODE_GEN_BUFFER_SIZE;\n    }\n    if (tb_size > MAX_CODE_GEN_BUFFER_SIZE) {\n        tb_size = MAX_CODE_GEN_BUFFER_SIZE;\n    }\n    return tb_size;\n}\n\n#ifdef __mips__\n/* In order to use J and JAL within the code_gen_buffer, we require\n   that the buffer not cross a 256MB boundary.  */\nstatic inline bool cross_256mb(void *addr, size_t size)\n{\n    return ((uintptr_t)addr ^ ((uintptr_t)addr + size)) & ~0x0ffffffful;\n}\n\n/* We weren't able to allocate a buffer without crossing that boundary,\n   so make do with the larger portion of the buffer that doesn't cross.\n   Returns the new base of the buffer, and adjusts code_gen_buffer_size.  */\nstatic inline void *split_cross_256mb(TCGContext *tcg_ctx, void *buf1, size_t size1)\n{\n    void *buf2 = (void *)(((uintptr_t)buf1 + size1) & ~0x0ffffffful);\n    size_t size2 = buf1 + size1 - buf2;\n\n    size1 = buf2 - buf1;\n    if (size1 < size2) {\n        size1 = size2;\n        buf1 = buf2;\n    }\n\n    tcg_ctx->code_gen_buffer_size = size1;\n    return buf1;\n}\n#endif\n\n#ifdef USE_STATIC_CODE_GEN_BUFFER\nstatic uint8_t static_code_gen_buffer[DEFAULT_CODE_GEN_BUFFER_SIZE]\n    __attribute__((aligned(CODE_GEN_ALIGN)));\n\nstatic inline void *alloc_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    void *buf = static_code_gen_buffer;\n    void *end = static_code_gen_buffer + sizeof(static_code_gen_buffer);\n    size_t size;\n\n    /* page-align the beginning and end of the buffer */\n    buf = QEMU_ALIGN_PTR_UP(buf, uc->qemu_real_host_page_size);\n    end = QEMU_ALIGN_PTR_DOWN(end, uc->qemu_real_host_page_size);\n\n    size = end - buf;\n\n    /* Honor a command-line option limiting the size of the buffer.  */\n    if (size > tcg_ctx->code_gen_buffer_size) {\n        size = QEMU_ALIGN_DOWN(tcg_ctx->code_gen_buffer_size,\n                               uc->qemu_real_host_page_size);\n    }\n    tcg_ctx->code_gen_buffer_size = size;\n\n#ifdef __mips__\n    if (cross_256mb(buf, size)) {\n        buf = split_cross_256mb(tcg_ctx, buf, size);\n        size = tcg_ctx->code_gen_buffer_size;\n    }\n#endif\n\n    if (qemu_mprotect_rwx(buf, size)) {\n        abort();\n    }\n    qemu_madvise(buf, size, QEMU_MADV_HUGEPAGE);\n\n    return buf;\n}\n#elif defined(_WIN32)\nstatic inline void *alloc_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    size_t size = tcg_ctx->code_gen_buffer_size;\n    return VirtualAlloc(NULL, size, MEM_RESERVE | MEM_COMMIT,\n                        PAGE_EXECUTE_READWRITE);\n}\nvoid free_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    if (tcg_ctx->code_gen_buffer) {\n        VirtualFree(tcg_ctx->code_gen_buffer, 0, MEM_RELEASE);\n    }\n}\n#else\nvoid free_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    if (tcg_ctx->code_gen_buffer) {\n        munmap(tcg_ctx->code_gen_buffer, tcg_ctx->code_gen_buffer_size);\n    }\n}\n\nstatic inline void *alloc_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    int prot = PROT_WRITE | PROT_READ | PROT_EXEC;\n    int flags = MAP_PRIVATE | MAP_ANONYMOUS;\n    size_t size = tcg_ctx->code_gen_buffer_size;\n    void *buf;\n#ifdef USE_MAP_JIT\n    flags |= MAP_JIT;\n#endif\n    buf = mmap(NULL, size, prot, flags, -1, 0);\n    if (buf == MAP_FAILED) {\n        return NULL;\n    }\n\n#ifdef __mips__\n    if (cross_256mb(buf, size)) {\n        /*\n         * Try again, with the original still mapped, to avoid re-acquiring\n         * the same 256mb crossing.\n         */\n        size_t size2;\n        void *buf2 = mmap(NULL, size, prot, flags, -1, 0);\n        switch ((int)(buf2 != MAP_FAILED)) {\n        case 1:\n            if (!cross_256mb(buf2, size)) {\n                /* Success!  Use the new buffer.  */\n                munmap(buf, size);\n                break;\n            }\n            /* Failure.  Work with what we had.  */\n            munmap(buf2, size);\n            /* fallthru */\n        default:\n            /* Split the original buffer.  Free the smaller half.  */\n            buf2 = split_cross_256mb(tcg_ctx, buf, size);\n            size2 = tcg_ctx->code_gen_buffer_size;\n            if (buf == buf2) {\n                munmap(buf + size2, size - size2);\n            } else {\n                munmap(buf, size - size2);\n            }\n            size = size2;\n            break;\n        }\n        buf = buf2;\n    }\n#endif\n\n    /* Request large pages for the buffer.  */\n    qemu_madvise(buf, size, QEMU_MADV_HUGEPAGE);\n\n    return buf;\n}\n#endif /* USE_STATIC_CODE_GEN_BUFFER, WIN32, POSIX */\n\nstatic inline void code_gen_alloc(struct uc_struct *uc, size_t tb_size)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    tcg_ctx->code_gen_buffer_size = size_code_gen_buffer(tb_size);\n    tcg_ctx->code_gen_buffer = alloc_code_gen_buffer(uc);\n    if (tcg_ctx->code_gen_buffer == NULL) {\n        fprintf(stderr, \"Could not allocate dynamic translator buffer\\n\");\n        exit(1);\n    }\n}\n\nstatic bool tb_cmp(struct uc_struct *uc, const void *ap, const void *bp)\n{\n    const TranslationBlock *a = ap;\n    const TranslationBlock *b = bp;\n\n    return a->pc == b->pc &&\n        a->cs_base == b->cs_base &&\n        a->flags == b->flags &&\n        (tb_cflags(a) & CF_HASH_MASK) == (tb_cflags(b) & CF_HASH_MASK) &&\n        a->trace_vcpu_dstate == b->trace_vcpu_dstate &&\n        a->page_addr[0] == b->page_addr[0] &&\n        a->page_addr[1] == b->page_addr[1];\n}\n\nstatic void tb_htable_init(struct uc_struct *uc)\n{\n    unsigned int mode = QHT_MODE_AUTO_RESIZE;\n\n    qht_init(&uc->tcg_ctx->tb_ctx.htable, tb_cmp, CODE_GEN_HTABLE_SIZE, mode);\n}\n\n\nstatic void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n\n    // GVA to GPA (GPA -> HVA via page_find, HVA->HPA via host mmu)\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    \n    // For 32bit target.\n    end = (start + len) & (target_ulong)(-1);\n\n    // We get a wrap?\n    if (start > end) {\n        return;\n    }\n\n    tb_invalidate_phys_range(uc, start, end);\n}\n\nstatic uc_err uc_gen_tb(struct uc_struct *uc, uint64_t addr, uc_tb *out_tb) \n{\n    TranslationBlock *tb;\n    target_ulong cs_base, pc;\n    CPUState *cpu = uc->cpu;\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n    uint32_t flags;\n    uint32_t hash;\n    uint32_t cflags = cpu->cflags_next_tb;\n\n    if (cflags == -1) {\n        cflags = curr_cflags();\n    }\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    // Unicorn: Our hack here.\n    pc = addr;\n\n    hash = tb_jmp_cache_hash_func(env->uc, pc);\n    tb = cpu->tb_jmp_cache[hash];\n\n    cflags &= ~CF_CLUSTER_MASK;\n    cflags |= cpu->cluster_index << CF_CLUSTER_SHIFT;\n\n    if (unlikely(!(tb &&\n                   tb->pc == pc &&\n                   tb->cs_base == cs_base &&\n                   tb->flags == flags &&\n                   tb->trace_vcpu_dstate == *cpu->trace_dstate &&\n                   (tb_cflags(tb) & (CF_HASH_MASK | CF_INVALID)) == cflags))) {\n\n        tb = tb_htable_lookup(cpu, pc, cs_base, flags, cflags);\n        cpu->tb_jmp_cache[hash] = tb;\n\n        if (tb == NULL) {\n            mmap_lock();\n            tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);\n            mmap_unlock();\n            /* We add the TB in the virtual pc hash table for the fast lookup */\n            cpu->tb_jmp_cache[hash] = tb;\n        }\n    }\n\n    // If we still couldn't generate a TB, it must be out of memory.\n    if (tb == NULL) {\n        return UC_ERR_NOMEM;\n    }\n\n    if (out_tb != NULL) {\n        UC_TB_COPY(out_tb, tb);\n    }\n\n    return UC_ERR_OK;\n}\n\n/* Must be called before using the QEMU cpus. 'tb_size' is the size\n   (in bytes) allocated to the translation buffer. Zero means default\n   size. */\nvoid tcg_exec_init(struct uc_struct *uc, unsigned long tb_size)\n{\n    /* remove tcg object. init here. */\n    /* tcg class init: tcg-all.c:tcg_accel_class_init(), skip all. */\n    /* tcg object init: tcg-all.c:tcg_accel_instance_init(), skip all. */\n    /* tcg init: tcg-all.c: tcg_init(), skip all. */\n    /* run tcg_exec_init() here. */\n    uc->tcg_ctx = g_malloc(sizeof(TCGContext));\n    tcg_context_init(uc->tcg_ctx);\n    uc->tcg_ctx->uc = uc;\n    page_init(uc);\n    tb_htable_init(uc);\n    code_gen_alloc(uc, tb_size);\n    tb_exec_unlock(uc->tcg_ctx);\n    tcg_prologue_init(uc->tcg_ctx);\n    /* cpu_interrupt_handler is not used in uc1 */\n    uc->l1_map = g_malloc0(sizeof(void *) * V_L1_MAX_SIZE);\n    /* Invalidate / Cache TBs */\n    uc->uc_invalidate_tb = uc_invalidate_tb;\n    uc->uc_gen_tb = uc_gen_tb;\n\n    /* Inline hooks optimization */\n    uc->add_inline_hook = uc_add_inline_hook;\n    uc->del_inline_hook = uc_del_inline_hook;\n}\n\n/* call with @p->lock held */\nstatic inline void invalidate_page_bitmap(PageDesc *p)\n{\n    assert_page_locked(p);\n\n    g_free(p->code_bitmap);\n    p->code_bitmap = NULL;\n    p->code_write_count = 0;\n}\n\nstatic void tb_clean_internal(void **p, int x)\n{\n    int i;\n    void **q;\n\n    if (x <= 1) {\n        for (i = 0; i < V_L2_SIZE; i++) {\n            q = p[i];\n            if (q) {\n                g_free(q);\n            }\n        }\n        g_free(p);\n    } else {\n        for (i = 0; i < V_L2_SIZE; i++) {\n            q = p[i];\n            if (q) {\n                tb_clean_internal(q, x - 1);\n            }\n        }\n        g_free(p);\n    }\n}\n\nvoid tb_cleanup(struct uc_struct *uc)\n{\n    int i, x;\n    void **p;\n\n    if (uc) {\n        if (uc->l1_map) {\n            x = uc->v_l2_levels;\n            if (x <= 0) {\n                for (i = 0; i < uc->v_l1_size; i++) {\n                    p = uc->l1_map[i];\n                    if (p) {\n                        g_free(p);\n                        uc->l1_map[i] = NULL;\n                    }\n                }\n            } else {\n                for (i = 0; i < uc->v_l1_size; i++) {\n                    p = uc->l1_map[i];\n                    if (p) {\n                        tb_clean_internal(p, x);\n                        uc->l1_map[i] = NULL;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* Set to NULL all the 'first_tb' fields in all PageDescs. */\nstatic void page_flush_tb_1(struct uc_struct *uc, int level, void **lp)\n{\n    int i;\n\n    if (*lp == NULL) {\n        return;\n    }\n    if (level == 0) {\n        PageDesc *pd = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            page_lock(&pd[i]);\n            pd[i].first_tb = (uintptr_t)NULL;\n            invalidate_page_bitmap(pd + i);\n            page_unlock(&pd[i]);\n        }\n    } else {\n        void **pp = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            page_flush_tb_1(uc, level - 1, pp + i);\n        }\n    }\n}\n\nstatic void page_flush_tb(struct uc_struct *uc)\n{\n    int i, l1_sz = uc->v_l1_size;\n\n    for (i = 0; i < l1_sz; i++) {\n        page_flush_tb_1(uc, uc->v_l2_levels, uc->l1_map + i);\n    }\n}\n\n#if 0\nstatic gboolean tb_host_size_iter(gpointer key, gpointer value, gpointer data)\n{\n    const TranslationBlock *tb = value;\n    size_t *size = data;\n\n    *size += tb->tc.size;\n    return false;\n}\n#endif\n\n/* flush all the translation blocks */\nstatic void do_tb_flush(CPUState *cpu, run_on_cpu_data tb_flush_count)\n{\n    mmap_lock();\n    /* If it is already been done on request of another CPU,\n     * just retry.\n     */\n    if (cpu->uc->tcg_ctx->tb_ctx.tb_flush_count != tb_flush_count.host_int) {\n        goto done;\n    }\n\n#if 0\n    if (DEBUG_TB_FLUSH_GATE) {\n        size_t nb_tbs = tcg_nb_tbs(cpu->uc->tcg_ctx);\n        size_t host_size = 0;\n\n        tcg_tb_foreach(cpu->uc->tcg_ctx, tb_host_size_iter, &host_size);\n        //printf(\"qemu: flush code_size=%zu nb_tbs=%zu avg_tb_size=%zu\\n\",\n        //       tcg_code_size(cpu->uc->tcg_ctx), nb_tbs, nb_tbs > 0 ? host_size / nb_tbs : 0);\n    }\n\n    CPU_FOREACH(cpu) {\n        cpu_tb_jmp_cache_clear(cpu);\n    }\n#else\n    cpu_tb_jmp_cache_clear(cpu);\n#endif\n\n    qht_reset_size(cpu->uc, &cpu->uc->tcg_ctx->tb_ctx.htable, CODE_GEN_HTABLE_SIZE);\n    page_flush_tb(cpu->uc);\n\n    tcg_region_reset_all(cpu->uc->tcg_ctx);\n    /* XXX: flush processor icache at this point if cache flush is\n       expensive */\n    cpu->uc->tcg_ctx->tb_ctx.tb_flush_count = cpu->uc->tcg_ctx->tb_ctx.tb_flush_count + 1;\n\ndone:\n    mmap_unlock();\n}\n\nvoid tb_flush(CPUState *cpu)\n{\n    unsigned tb_flush_count = cpu->uc->tcg_ctx->tb_ctx.tb_flush_count;\n    do_tb_flush(cpu, RUN_ON_CPU_HOST_INT(tb_flush_count));\n}\n\n/*\n * user-mode: call with mmap_lock held\n * !user-mode: call with @pd->lock held\n */\nstatic inline void tb_page_remove(PageDesc *pd, TranslationBlock *tb)\n{\n    TranslationBlock *tb1;\n    uintptr_t *pprev;\n    unsigned int n1;\n\n    assert_page_locked(pd);\n    pprev = &pd->first_tb;\n    PAGE_FOR_EACH_TB(pd, tb1, n1) {\n        if (tb1 == tb) {\n            *pprev = tb1->page_next[n1];\n            return;\n        }\n        pprev = &tb1->page_next[n1];\n    }\n    g_assert_not_reached();\n}\n\n/* remove @orig from its @n_orig-th jump list */\nstatic inline void tb_remove_from_jmp_list(TranslationBlock *orig, int n_orig)\n{\n    uintptr_t ptr, ptr_locked;\n    TranslationBlock *dest;\n    TranslationBlock *tb;\n    uintptr_t *pprev;\n    int n;\n\n    /* mark the LSB of jmp_dest[] so that no further jumps can be inserted */\n    ptr = atomic_or_fetch(&orig->jmp_dest[n_orig], 1);\n    dest = (TranslationBlock *)(ptr & ~1);\n    if (dest == NULL) {\n        return;\n    }\n\n    ptr_locked = orig->jmp_dest[n_orig];\n    if (ptr_locked != ptr) {\n        /*\n         * The only possibility is that the jump was unlinked via\n         * tb_jump_unlink(dest). Seeing here another destination would be a bug,\n         * because we set the LSB above.\n         */\n        g_assert(ptr_locked == 1 && dest->cflags & CF_INVALID);\n        return;\n    }\n    /*\n     * We first acquired the lock, and since the destination pointer matches,\n     * we know for sure that @orig is in the jmp list.\n     */\n    pprev = &dest->jmp_list_head;\n    TB_FOR_EACH_JMP(dest, tb, n) {\n        if (tb == orig && n == n_orig) {\n            *pprev = tb->jmp_list_next[n];\n            /* no need to set orig->jmp_dest[n]; setting the LSB was enough */\n            return;\n        }\n        pprev = &tb->jmp_list_next[n];\n    }\n    g_assert_not_reached();\n}\n\n/* reset the jump entry 'n' of a TB so that it is not chained to\n   another TB */\nstatic inline void tb_reset_jump(TranslationBlock *tb, int n)\n{\n    uintptr_t addr = (uintptr_t)((char *)tb->tc.ptr + tb->jmp_reset_offset[n]);\n    tb_set_jmp_target(tb, n, addr);\n}\n\n/* remove any jumps to the TB */\nstatic inline void tb_jmp_unlink(TranslationBlock *dest)\n{\n    TranslationBlock *tb;\n    int n;\n\n    TB_FOR_EACH_JMP(dest, tb, n) {\n        tb_reset_jump(tb, n);\n#ifdef _MSC_VER\n        atomic_and((long *)&tb->jmp_dest[n], (uintptr_t)NULL | 1);\n#else\n        atomic_and(&tb->jmp_dest[n], (uintptr_t)NULL | 1);\n#endif\n        /* No need to clear the list entry; setting the dest ptr is enough */\n    }\n    dest->jmp_list_head = (uintptr_t)NULL;\n}\n\n/*\n * In user-mode, call with mmap_lock held.\n * In !user-mode, if @rm_from_page_list is set, call with the TB's pages'\n * locks held.\n */\nstatic void do_tb_phys_invalidate(TCGContext *tcg_ctx, TranslationBlock *tb, bool rm_from_page_list)\n{\n    CPUState *cpu = tcg_ctx->uc->cpu;\n    struct uc_struct *uc = tcg_ctx->uc;\n    PageDesc *p;\n    uint32_t h;\n    tb_page_addr_t phys_pc;\n    bool code_gen_locked;\n\n    assert_memory_lock();\n    code_gen_locked = tb_exec_is_locked(tcg_ctx);\n    tb_exec_unlock(tcg_ctx);\n\n    /* make sure no further incoming jumps will be chained to this TB */\n    tb->cflags = tb->cflags | CF_INVALID;\n\n    /* remove the TB from the hash list */\n    phys_pc = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);\n    h = tb_hash_func(phys_pc, tb->pc, tb->flags, tb_cflags(tb) & CF_HASH_MASK,\n                     tb->trace_vcpu_dstate);\n    if (!(tb->cflags & CF_NOCACHE) &&\n        !qht_remove(&tcg_ctx->tb_ctx.htable, tb, h)) {\n        tb_exec_change(tcg_ctx, code_gen_locked);\n        return;\n    }\n\n    /* remove the TB from the page list */\n    if (rm_from_page_list) {\n        p = page_find(tcg_ctx->uc, tb->page_addr[0] >> TARGET_PAGE_BITS);\n        tb_page_remove(p, tb);\n        invalidate_page_bitmap(p);\n        if (tb->page_addr[1] != -1) {\n            p = page_find(tcg_ctx->uc, tb->page_addr[1] >> TARGET_PAGE_BITS);\n            tb_page_remove(p, tb);\n            invalidate_page_bitmap(p);\n        }\n    }\n\n    /* remove the TB from the hash list */\n    h = tb_jmp_cache_hash_func(uc, tb->pc);\n    if (cpu->tb_jmp_cache[h] == tb) {\n        cpu->tb_jmp_cache[h] = NULL;\n    }\n\n    /* suppress this TB from the two jump lists */\n    tb_remove_from_jmp_list(tb, 0);\n    tb_remove_from_jmp_list(tb, 1);\n\n    /* suppress any remaining jumps to this TB */\n    tb_jmp_unlink(tb);\n\n    tcg_ctx->tb_phys_invalidate_count = tcg_ctx->tb_phys_invalidate_count + 1;\n\n    tb_exec_change(tcg_ctx, code_gen_locked);\n}\n\nstatic void tb_phys_invalidate__locked(TCGContext *tcg_ctx, TranslationBlock *tb)\n{\n    do_tb_phys_invalidate(tcg_ctx, tb, true);\n}\n\n/* invalidate one TB\n *\n * Called with mmap_lock held in user-mode.\n */\nvoid tb_phys_invalidate(TCGContext *tcg_ctx, TranslationBlock *tb, tb_page_addr_t page_addr)\n{\n    if (page_addr == -1 && tb->page_addr[0] != -1) {\n        page_lock_tb(tcg_ctx->uc, tb);\n        do_tb_phys_invalidate(tcg_ctx, tb, true);\n        page_unlock_tb(tcg_ctx->uc, tb);\n    } else {\n        do_tb_phys_invalidate(tcg_ctx, tb, false);\n    }\n}\n\n/* call with @p->lock held */\nstatic void build_page_bitmap(struct uc_struct *uc, PageDesc *p)\n{\n    int n, tb_start, tb_end;\n    TranslationBlock *tb;\n\n    assert_page_locked(p);\n    p->code_bitmap = bitmap_new(TARGET_PAGE_SIZE);\n\n    PAGE_FOR_EACH_TB(p, tb, n) {\n        /* NOTE: this is subtle as a TB may span two physical pages */\n        if (n == 0) {\n            /* NOTE: tb_end may be after the end of the page, but\n               it is not a problem */\n            tb_start = tb->pc & ~TARGET_PAGE_MASK;\n            tb_end = tb_start + tb->size;\n            if (tb_end > TARGET_PAGE_SIZE) {\n                tb_end = TARGET_PAGE_SIZE;\n             }\n        } else {\n            tb_start = 0;\n            tb_end = ((tb->pc + tb->size) & ~TARGET_PAGE_MASK);\n        }\n        qemu_bitmap_set(p->code_bitmap, tb_start, tb_end - tb_start);\n    }\n}\n\n/* add the tb in the target page and protect it if necessary\n *\n * Called with mmap_lock held for user-mode emulation.\n * Called with @p->lock held in !user-mode.\n */\nstatic inline void tb_page_add(struct uc_struct *uc, PageDesc *p, TranslationBlock *tb,\n                               unsigned int n, tb_page_addr_t page_addr)\n{\n    bool page_already_protected;\n\n    assert_page_locked(p);\n\n    tb->page_addr[n] = page_addr;\n    tb->page_next[n] = p->first_tb;\n    page_already_protected = p->first_tb != (uintptr_t)NULL;\n    p->first_tb = (uintptr_t)tb | n;\n    invalidate_page_bitmap(p);\n\n    /* if some code is already present, then the pages are already\n       protected. So we handle the case where only the first TB is\n       allocated in a physical page */\n    if (!page_already_protected) {\n        tlb_protect_code(uc, page_addr);\n    }\n}\n\n/* add a new TB and link it to the physical page tables. phys_page2 is\n * (-1) to indicate that only one page contains the TB.\n *\n * Called with mmap_lock held for user-mode emulation.\n *\n * Returns a pointer @tb, or a pointer to an existing TB that matches @tb.\n * Note that in !user-mode, another thread might have already added a TB\n * for the same block of guest code that @tb corresponds to. In that case,\n * the caller should discard the original @tb, and use instead the returned TB.\n */\nstatic TranslationBlock *\ntb_link_page(struct uc_struct *uc, TranslationBlock *tb, tb_page_addr_t phys_pc,\n             tb_page_addr_t phys_page2)\n{\n    PageDesc *p;\n    PageDesc *p2 = NULL;\n\n    assert_memory_lock();\n\n    if (phys_pc == -1) {\n        /*\n         * If the TB is not associated with a physical RAM page then\n         * it must be a temporary one-insn TB, and we have nothing to do\n         * except fill in the page_addr[] fields.\n         */\n        assert(tb->cflags & CF_NOCACHE);\n        tb->page_addr[0] = tb->page_addr[1] = -1;\n        return tb;\n    }\n\n    /*\n     * Add the TB to the page list, acquiring first the pages's locks.\n     * We keep the locks held until after inserting the TB in the hash table,\n     * so that if the insertion fails we know for sure that the TBs are still\n     * in the page descriptors.\n     * Note that inserting into the hash table first isn't an option, since\n     * we can only insert TBs that are fully initialized.\n     */\n    page_lock_pair(uc, &p, phys_pc, &p2, phys_page2, 1);\n    tb_page_add(uc, p, tb, 0, phys_pc & TARGET_PAGE_MASK);\n    if (p2) {\n        tb_page_add(uc, p2, tb, 1, phys_page2);\n    } else {\n        tb->page_addr[1] = -1;\n    }\n\n    if (!(tb->cflags & CF_NOCACHE)) {\n        void *existing_tb = NULL;\n        uint32_t h;\n\n        /* add in the hash table */\n        h = tb_hash_func(phys_pc, tb->pc, tb->flags, tb->cflags & CF_HASH_MASK,\n                         tb->trace_vcpu_dstate);\n        tb->hash = h;   // unicorn needs this so it can remove this tb\n        qht_insert(uc, &uc->tcg_ctx->tb_ctx.htable, tb, h, &existing_tb);\n\n        /* remove TB from the page(s) if we couldn't insert it */\n        if (unlikely(existing_tb)) {\n            tb_page_remove(p, tb);\n            invalidate_page_bitmap(p);\n            if (p2) {\n                tb_page_remove(p2, tb);\n                invalidate_page_bitmap(p2);\n            }\n            tb = existing_tb;\n        }\n    }\n\n    if (p2 && p2 != p) {\n        page_unlock(p2);\n    }\n    page_unlock(p);\n\n    return tb;\n}\n\n/* Called with mmap_lock held for user mode emulation.  */\nTranslationBlock *tb_gen_code(CPUState *cpu,\n                              target_ulong pc, target_ulong cs_base,\n                              uint32_t flags, int cflags)\n{\n#ifdef TARGET_ARM\n    struct uc_struct *uc = cpu->uc;\n#endif\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n    CPUArchState *env = cpu->env_ptr;\n    TranslationBlock *tb, *existing_tb;\n    tb_page_addr_t phys_pc, phys_page2;\n    target_ulong virt_page2;\n    tcg_insn_unit *gen_code_buf;\n    int gen_code_size, search_size, max_insns;\n\n    assert_memory_lock();\n#ifdef HAVE_PTHREAD_JIT_PROTECT\n    tb_exec_unlock(tcg_ctx);\n#endif\n    phys_pc = get_page_addr_code(env, pc);\n\n    if (phys_pc == -1) {\n        /* Generate a temporary TB with 1 insn in it */\n        cflags &= ~CF_COUNT_MASK;\n        cflags |= CF_NOCACHE | 1;\n    }\n\n    cflags &= ~CF_CLUSTER_MASK;\n    cflags |= cpu->cluster_index << CF_CLUSTER_SHIFT;\n\n    max_insns = cflags & CF_COUNT_MASK;\n    if (max_insns == 0) {\n        max_insns = CF_COUNT_MASK;\n    }\n    if (max_insns > TCG_MAX_INSNS) {\n        max_insns = TCG_MAX_INSNS;\n    }\n    if (cpu->singlestep_enabled) {\n        max_insns = 1;\n    }\n\n buffer_overflow:\n    tb = tcg_tb_alloc(tcg_ctx);\n    if (unlikely(!tb)) {\n        /* flush must be done */\n        tb_flush(cpu);\n        mmap_unlock();\n        /* Make the execution loop process the flush as soon as possible.  */\n        cpu->exception_index = EXCP_INTERRUPT;\n        cpu_loop_exit(cpu);\n    }\n\n    gen_code_buf = tcg_ctx->code_gen_ptr;\n    tb->tc.ptr = gen_code_buf;\n    tb->pc = pc;\n    tb->cs_base = cs_base;\n    tb->flags = flags;\n    tb->cflags = cflags;\n    tb->orig_tb = NULL;\n    tb->trace_vcpu_dstate = *cpu->trace_dstate;\n    tcg_ctx->tb_cflags = cflags;\n tb_overflow:\n\n    tcg_func_start(tcg_ctx);\n\n    tcg_ctx->cpu = env_cpu(env);\n    gen_intermediate_code(cpu, tb, max_insns);\n    tcg_ctx->cpu = NULL;\n\n    /* generate machine code */\n    tb->jmp_reset_offset[0] = TB_JMP_RESET_OFFSET_INVALID;\n    tb->jmp_reset_offset[1] = TB_JMP_RESET_OFFSET_INVALID;\n    tcg_ctx->tb_jmp_reset_offset = tb->jmp_reset_offset;\n    if (TCG_TARGET_HAS_direct_jump) {\n        tcg_ctx->tb_jmp_insn_offset = tb->jmp_target_arg;\n        tcg_ctx->tb_jmp_target_addr = NULL;\n    } else {\n        tcg_ctx->tb_jmp_insn_offset = NULL;\n        tcg_ctx->tb_jmp_target_addr = tb->jmp_target_arg;\n    }\n\n    gen_code_size = tcg_gen_code(tcg_ctx, tb);\n    if (unlikely(gen_code_size < 0)) {\n        switch (gen_code_size) {\n        case -1:\n            /*\n             * Overflow of code_gen_buffer, or the current slice of it.\n             *\n             * TODO: We don't need to re-do gen_intermediate_code, nor\n             * should we re-do the tcg optimization currently hidden\n             * inside tcg_gen_code.  All that should be required is to\n             * flush the TBs, allocate a new TB, re-initialize it per\n             * above, and re-do the actual code generation.\n             */\n            goto buffer_overflow;\n\n        case -2:\n            /*\n             * The code generated for the TranslationBlock is too large.\n             * The maximum size allowed by the unwind info is 64k.\n             * There may be stricter constraints from relocations\n             * in the tcg backend.\n             *\n             * Try again with half as many insns as we attempted this time.\n             * If a single insn overflows, there's a bug somewhere...\n             */\n            max_insns = tb->icount;\n            assert(max_insns > 1);\n            max_insns /= 2;\n            goto tb_overflow;\n\n        default:\n            g_assert_not_reached();\n        }\n    }\n    search_size = encode_search(cpu->uc, tb, (uint8_t *)gen_code_buf + gen_code_size);\n    if (unlikely(search_size < 0)) {\n        goto buffer_overflow;\n    }\n    tb->tc.size = gen_code_size;\n\n    tcg_ctx->code_gen_ptr = (void *)\n        ROUND_UP((uintptr_t)gen_code_buf + gen_code_size + search_size,\n                 CODE_GEN_ALIGN);\n\n    /* init jump list */\n    tb->jmp_list_head = (uintptr_t)NULL;\n    tb->jmp_list_next[0] = (uintptr_t)NULL;\n    tb->jmp_list_next[1] = (uintptr_t)NULL;\n    tb->jmp_dest[0] = (uintptr_t)NULL;\n    tb->jmp_dest[1] = (uintptr_t)NULL;\n\n    /* init original jump addresses which have been set during tcg_gen_code() */\n    if (tb->jmp_reset_offset[0] != TB_JMP_RESET_OFFSET_INVALID) {\n        tb_reset_jump(tb, 0);\n    }\n    if (tb->jmp_reset_offset[1] != TB_JMP_RESET_OFFSET_INVALID) {\n        tb_reset_jump(tb, 1);\n    }\n\n    /* check next page if needed */\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n    phys_page2 = -1;\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n        phys_page2 = get_page_addr_code(env, virt_page2);\n    }\n    /*\n     * No explicit memory barrier is required -- tb_link_page() makes the\n     * TB visible in a consistent state.\n     */\n    existing_tb = tb_link_page(cpu->uc, tb, phys_pc, phys_page2);\n    /* if the TB already exists, discard what we just translated */\n    if (unlikely(existing_tb != tb)) {\n        uintptr_t orig_aligned = (uintptr_t)gen_code_buf;\n\n        orig_aligned -= ROUND_UP(sizeof(*tb), tcg_ctx->uc->qemu_icache_linesize);\n        tcg_ctx->code_gen_ptr = (void *)orig_aligned;\n        return existing_tb;\n    }\n    tcg_tb_insert(tcg_ctx, tb);\n    return tb;\n}\n\n/*\n * @p must be non-NULL.\n * user-mode: call with mmap_lock held.\n * !user-mode: call with all @pages locked.\n */\nstatic void\ntb_invalidate_phys_page_range__locked(struct uc_struct *uc, struct page_collection *pages,\n                                      PageDesc *p, tb_page_addr_t start,\n                                      tb_page_addr_t end,\n                                      uintptr_t retaddr)\n{\n    TranslationBlock *tb;\n    tb_page_addr_t tb_start, tb_end;\n    int n;\n#ifdef TARGET_HAS_PRECISE_SMC\n    CPUState *cpu = uc->cpu;\n    CPUArchState *env = NULL;\n    bool current_tb_not_found = retaddr != 0;\n    bool current_tb_modified = false;\n    TranslationBlock *current_tb = NULL;\n    target_ulong current_pc = 0;\n    target_ulong current_cs_base = 0;\n    uint32_t current_flags = 0;\n#endif /* TARGET_HAS_PRECISE_SMC */\n\n    assert_page_locked(p);\n\n#if defined(TARGET_HAS_PRECISE_SMC)\n    if (cpu != NULL) {\n        env = cpu->env_ptr;\n    }\n#endif\n\n    /* we remove all the TBs in the range [start, end[ */\n    /* XXX: see if in some cases it could be faster to invalidate all\n       the code */\n    PAGE_FOR_EACH_TB(p, tb, n) {\n        assert_page_locked(p);\n        /* NOTE: this is subtle as a TB may span two physical pages */\n        if (n == 0) {\n            /* NOTE: tb_end may be after the end of the page, but\n               it is not a problem */\n            tb_start = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);\n            tb_end = tb_start + tb->size;\n        } else {\n            tb_start = tb->page_addr[1];\n            tb_end = tb_start + ((tb->pc + tb->size) & ~TARGET_PAGE_MASK);\n        }\n        // Unicorn: We may indeed generate a TB without any instruction which breaks qemu assumption.\n        if ( (!(tb_end <= start || tb_start >= end)) || (tb_start == tb_end) ) {\n#ifdef TARGET_HAS_PRECISE_SMC\n            if (current_tb_not_found) {\n                current_tb_not_found = false;\n                /* now we have a real cpu fault */\n                current_tb = tcg_tb_lookup(uc->tcg_ctx, retaddr);\n            }\n            if (current_tb == tb &&\n                (tb_cflags(current_tb) & CF_COUNT_MASK) != 1) {\n                /*\n                 * If we are modifying the current TB, we must stop\n                 * its execution. We could be more precise by checking\n                 * that the modification is after the current PC, but it\n                 * would require a specialized function to partially\n                 * restore the CPU state.\n                 */\n                current_tb_modified = true;\n                cpu_restore_state_from_tb(cpu, current_tb, retaddr, true);\n                cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                                     &current_flags);\n            }\n#endif /* TARGET_HAS_PRECISE_SMC */\n            tb_phys_invalidate__locked(uc->tcg_ctx, tb);\n        }\n    }\n\n    /* if no code remaining, no need to continue to use slow writes */\n    if (!p->first_tb) {\n        invalidate_page_bitmap(p);\n        tlb_unprotect_code(uc, start);\n    }\n\n#ifdef TARGET_HAS_PRECISE_SMC\n    if (current_tb_modified) {\n        page_collection_unlock(pages);\n        /* Force execution of one insn next time.  */\n        cpu->cflags_next_tb = 1 | curr_cflags();\n        mmap_unlock();\n        cpu_loop_exit_noexc(cpu);\n    }\n#endif\n}\n\n/*\n * Invalidate all TBs which intersect with the target physical address range\n * [start;end[. NOTE: start and end must refer to the *same* physical page.\n * 'is_cpu_write_access' should be true if called from a real cpu write\n * access: the virtual CPU will exit the current TB if code is modified inside\n * this TB.\n *\n * Called with mmap_lock held for user-mode emulation\n */\nvoid tb_invalidate_phys_page_range(struct uc_struct *uc, tb_page_addr_t start, tb_page_addr_t end)\n{\n    struct page_collection *pages;\n    PageDesc *p;\n\n    assert_memory_lock();\n\n    p = page_find(uc, start >> TARGET_PAGE_BITS);\n    if (p == NULL) {\n        return;\n    }\n    pages = page_collection_lock(uc, start, end);\n    tb_invalidate_phys_page_range__locked(uc, pages, p, start, end, 0);\n    page_collection_unlock(pages);\n}\n\n/*\n * Invalidate all TBs which intersect with the target physical address range\n * [start;end[. NOTE: start and end may refer to *different* physical pages.\n * 'is_cpu_write_access' should be true if called from a real cpu write\n * access: the virtual CPU will exit the current TB if code is modified inside\n * this TB.\n *\n * Called with mmap_lock held for user-mode emulation.\n */\nvoid tb_invalidate_phys_range(struct uc_struct *uc, ram_addr_t start, ram_addr_t end)\n{\n    struct page_collection *pages;\n    tb_page_addr_t next;\n\n    assert_memory_lock();\n\n    pages = page_collection_lock(uc, start, end);\n    for (next = (start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n         //start < end; Unicorn: Fix possible wrap around\n         (intptr_t)(end - start) > 0;\n         start = next, next += TARGET_PAGE_SIZE) {\n        PageDesc *pd = page_find(uc, start >> TARGET_PAGE_BITS);\n        tb_page_addr_t bound = MIN(next, end);\n\n        if (pd == NULL) {\n            continue;\n        }\n        tb_invalidate_phys_page_range__locked(uc, pages, pd, start, bound, 0);\n    }\n    page_collection_unlock(pages);\n}\n\n/* len must be <= 8 and start must be a multiple of len.\n * Called via softmmu_template.h when code areas are written to with\n * iothread mutex not held.\n *\n * Call with all @pages in the range [@start, @start + len[ locked.\n */\nvoid tb_invalidate_phys_page_fast(struct uc_struct *uc, struct page_collection *pages,\n                                  tb_page_addr_t start, int len,\n                                  uintptr_t retaddr)\n{\n    PageDesc *p;\n\n    assert_memory_lock();\n\n    p = page_find(uc, start >> TARGET_PAGE_BITS);\n    if (!p) {\n        return;\n    }\n\n    assert_page_locked(p);\n    if (!p->code_bitmap &&\n        ++p->code_write_count >= SMC_BITMAP_USE_THRESHOLD) {\n        build_page_bitmap(uc, p);\n    }\n    if (p->code_bitmap) {\n        unsigned int nr;\n        unsigned long b;\n\n        nr = start & ~TARGET_PAGE_MASK;\n        b = p->code_bitmap[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG - 1));\n        if (b & ((1 << len) - 1)) {\n            goto do_invalidate;\n        }\n    } else {\n    do_invalidate:\n        tb_invalidate_phys_page_range__locked(uc, pages, p, start, start + len,\n                                              retaddr);\n    }\n}\n\n/* user-mode: call with mmap_lock held */\nvoid tb_check_watchpoint(CPUState *cpu, uintptr_t retaddr)\n{\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n    TranslationBlock *tb;\n\n    assert_memory_lock();\n\n    tb = tcg_tb_lookup(tcg_ctx, retaddr);\n    if (tb) {\n        /* We can use retranslation to find the PC.  */\n        cpu_restore_state_from_tb(cpu, tb, retaddr, true);\n        tb_phys_invalidate(tcg_ctx, tb, -1);\n    } else {\n        /* The exception probably happened in a helper.  The CPU state should\n           have been saved before calling it. Fetch the PC from there.  */\n        CPUArchState *env = cpu->env_ptr;\n        target_ulong pc, cs_base;\n        tb_page_addr_t addr;\n        uint32_t flags;\n\n        cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n        addr = get_page_addr_code(env, pc);\n        if (addr != -1) {\n            tb_invalidate_phys_range(cpu->uc, addr, addr + 1);\n        }\n    }\n}\n\n/* in deterministic execution mode, instructions doing device I/Os\n * must be at the end of the TB.\n *\n * Called by softmmu_template.h, with iothread mutex not held.\n */\nvoid cpu_io_recompile(CPUState *cpu, uintptr_t retaddr)\n{\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n#if defined(TARGET_MIPS) || defined(TARGET_SH4)\n    CPUArchState *env = cpu->env_ptr;\n#endif\n    TranslationBlock *tb;\n    uint32_t n;\n\n    tb = tcg_tb_lookup(tcg_ctx, retaddr);\n    if (!tb) {\n        cpu_abort(cpu, \"cpu_io_recompile: could not find TB for pc=%p\",\n                  (void *)retaddr);\n    }\n    cpu_restore_state_from_tb(cpu, tb, retaddr, true);\n\n    /* On MIPS and SH, delay slot instructions can only be restarted if\n       they were already the first instruction in the TB.  If this is not\n       the first instruction in a TB then re-execute the preceding\n       branch.  */\n    n = 1;\n#if defined(TARGET_MIPS)\n    if ((env->hflags & MIPS_HFLAG_BMASK) != 0\n        && env->active_tc.PC != tb->pc) {\n        env->active_tc.PC -= (env->hflags & MIPS_HFLAG_B16 ? 2 : 4);\n        cpu_neg(cpu)->icount_decr.u16.low++;\n        env->hflags &= ~MIPS_HFLAG_BMASK;\n        n = 2;\n    }\n#elif defined(TARGET_SH4)\n    if ((env->flags & ((DELAY_SLOT | DELAY_SLOT_CONDITIONAL))) != 0\n        && env->pc != tb->pc) {\n        env->pc -= 2;\n        cpu_neg(cpu)->icount_decr.u16.low++;\n        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);\n        n = 2;\n    }\n#endif\n\n    /* Generate a new TB executing the I/O insn.  */\n    cpu->cflags_next_tb = curr_cflags() | CF_LAST_IO | n;\n\n    if (tb_cflags(tb) & CF_NOCACHE) {\n        if (tb->orig_tb) {\n            /* Invalidate original TB if this TB was generated in\n             * cpu_exec_nocache() */\n            tb_phys_invalidate(tcg_ctx, tb->orig_tb, -1);\n        }\n        tcg_tb_remove(tcg_ctx, tb);\n    }\n\n    /* TODO: If env->pc != tb->pc (i.e. the faulting instruction was not\n     * the first in the TB) then we end up generating a whole new TB and\n     *  repeating the fault, which is horribly inefficient.\n     *  Better would be to execute just this insn uncached, or generate a\n     *  second new TB.\n     */\n    cpu_loop_exit_noexc(cpu);\n}\n\nstatic void tb_jmp_cache_clear_page(CPUState *cpu, target_ulong page_addr)\n{\n    unsigned int i, i0 = tb_jmp_cache_hash_page(cpu->uc, page_addr);\n\n    for (i = 0; i < TB_JMP_PAGE_SIZE; i++) {\n        cpu->tb_jmp_cache[i0 + i] = NULL;\n    }\n}\n\nvoid tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n{\n#ifdef TARGET_ARM\n    struct uc_struct *uc = cpu->uc;\n#endif\n\n    /* Discard jump cache entries for any tb which might potentially\n       overlap the flushed page.  */\n    tb_jmp_cache_clear_page(cpu, addr - TARGET_PAGE_SIZE);\n    tb_jmp_cache_clear_page(cpu, addr);\n}\n\n/* This is a wrapper for common code that can not use CONFIG_SOFTMMU */\nvoid tcg_flush_softmmu_tlb(struct uc_struct *uc)\n{\n    tlb_flush(uc->cpu);\n}\n\n\n#ifdef HAVE_PTHREAD_JIT_PROTECT\nstatic bool tb_exec_is_locked(TCGContext *tcg_ctx)\n{\n    return tcg_ctx->code_gen_locked;\n}\n\nstatic void tb_exec_change(TCGContext *tcg_ctx, bool locked)\n{\n    jit_write_protect(locked);\n    tcg_ctx->code_gen_locked = locked;\n}\n#else /* not needed on non-Darwin platforms */\nstatic bool tb_exec_is_locked(TCGContext *tcg_ctx)\n{\n    return false;\n}\n\nstatic void tb_exec_change(TCGContext *tcg_ctx, bool locked) {}\n#endif\n\nvoid tb_exec_lock(TCGContext *tcg_ctx)\n{\n    /* assumes sys_icache_invalidate already called */\n    tb_exec_change(tcg_ctx, true);\n}\n\nvoid tb_exec_unlock(TCGContext *tcg_ctx)\n{\n    tb_exec_change(tcg_ctx, false);\n}\n", "/* Unicorn Emulator Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015 */\n/* Modified for Unicorn Engine by Chen Huitao<chenhuitao@hfmrit.com>, 2020 */\n\n#if defined(UNICORN_HAS_OSXKERNEL)\n#include <libkern/libkern.h>\n#else\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#endif\n\n#include <time.h> // nanosleep\n#include <string.h>\n\n#include \"uc_priv.h\"\n\n// target specific headers\n#include \"qemu/target/m68k/unicorn.h\"\n#include \"qemu/target/i386/unicorn.h\"\n#include \"qemu/target/arm/unicorn.h\"\n#include \"qemu/target/mips/unicorn.h\"\n#include \"qemu/target/sparc/unicorn.h\"\n#include \"qemu/target/ppc/unicorn.h\"\n#include \"qemu/target/riscv/unicorn.h\"\n\n#include \"qemu/include/qemu/queue.h\"\n#include \"qemu-common.h\"\n\nUNICORN_EXPORT\nunsigned int uc_version(unsigned int *major, unsigned int *minor)\n{\n    if (major != NULL && minor != NULL) {\n        *major = UC_API_MAJOR;\n        *minor = UC_API_MINOR;\n    }\n\n    return (UC_API_EXTRA << 16) + (UC_API_MAJOR << 8) + UC_API_MINOR;\n}\n\nUNICORN_EXPORT\nuc_err uc_errno(uc_engine *uc)\n{\n    return uc->errnum;\n}\n\nUNICORN_EXPORT\nconst char *uc_strerror(uc_err code)\n{\n    switch (code) {\n    default:\n        return \"Unknown error code\";\n    case UC_ERR_OK:\n        return \"OK (UC_ERR_OK)\";\n    case UC_ERR_NOMEM:\n        return \"No memory available or memory not present (UC_ERR_NOMEM)\";\n    case UC_ERR_ARCH:\n        return \"Invalid/unsupported architecture (UC_ERR_ARCH)\";\n    case UC_ERR_HANDLE:\n        return \"Invalid handle (UC_ERR_HANDLE)\";\n    case UC_ERR_MODE:\n        return \"Invalid mode (UC_ERR_MODE)\";\n    case UC_ERR_VERSION:\n        return \"Different API version between core & binding (UC_ERR_VERSION)\";\n    case UC_ERR_READ_UNMAPPED:\n        return \"Invalid memory read (UC_ERR_READ_UNMAPPED)\";\n    case UC_ERR_WRITE_UNMAPPED:\n        return \"Invalid memory write (UC_ERR_WRITE_UNMAPPED)\";\n    case UC_ERR_FETCH_UNMAPPED:\n        return \"Invalid memory fetch (UC_ERR_FETCH_UNMAPPED)\";\n    case UC_ERR_HOOK:\n        return \"Invalid hook type (UC_ERR_HOOK)\";\n    case UC_ERR_INSN_INVALID:\n        return \"Invalid instruction (UC_ERR_INSN_INVALID)\";\n    case UC_ERR_MAP:\n        return \"Invalid memory mapping (UC_ERR_MAP)\";\n    case UC_ERR_WRITE_PROT:\n        return \"Write to write-protected memory (UC_ERR_WRITE_PROT)\";\n    case UC_ERR_READ_PROT:\n        return \"Read from non-readable memory (UC_ERR_READ_PROT)\";\n    case UC_ERR_FETCH_PROT:\n        return \"Fetch from non-executable memory (UC_ERR_FETCH_PROT)\";\n    case UC_ERR_ARG:\n        return \"Invalid argument (UC_ERR_ARG)\";\n    case UC_ERR_READ_UNALIGNED:\n        return \"Read from unaligned memory (UC_ERR_READ_UNALIGNED)\";\n    case UC_ERR_WRITE_UNALIGNED:\n        return \"Write to unaligned memory (UC_ERR_WRITE_UNALIGNED)\";\n    case UC_ERR_FETCH_UNALIGNED:\n        return \"Fetch from unaligned memory (UC_ERR_FETCH_UNALIGNED)\";\n    case UC_ERR_RESOURCE:\n        return \"Insufficient resource (UC_ERR_RESOURCE)\";\n    case UC_ERR_EXCEPTION:\n        return \"Unhandled CPU exception (UC_ERR_EXCEPTION)\";\n    }\n}\n\nUNICORN_EXPORT\nbool uc_arch_supported(uc_arch arch)\n{\n    switch (arch) {\n#ifdef UNICORN_HAS_ARM\n    case UC_ARCH_ARM:\n        return true;\n#endif\n#ifdef UNICORN_HAS_ARM64\n    case UC_ARCH_ARM64:\n        return true;\n#endif\n#ifdef UNICORN_HAS_M68K\n    case UC_ARCH_M68K:\n        return true;\n#endif\n#ifdef UNICORN_HAS_MIPS\n    case UC_ARCH_MIPS:\n        return true;\n#endif\n#ifdef UNICORN_HAS_PPC\n    case UC_ARCH_PPC:\n        return true;\n#endif\n#ifdef UNICORN_HAS_SPARC\n    case UC_ARCH_SPARC:\n        return true;\n#endif\n#ifdef UNICORN_HAS_X86\n    case UC_ARCH_X86:\n        return true;\n#endif\n#ifdef UNICORN_HAS_RISCV\n    case UC_ARCH_RISCV:\n        return true;\n#endif\n    /* Invalid or disabled arch */\n    default:\n        return false;\n    }\n}\n\n#define UC_INIT(uc)                                                            \\\n    if (unlikely(!(uc)->init_done)) {                                          \\\n        int __init_ret = uc_init(uc);                                          \\\n        if (unlikely(__init_ret != UC_ERR_OK)) {                               \\\n            return __init_ret;                                                 \\\n        }                                                                      \\\n    }\n\nstatic gint uc_exits_cmp(gconstpointer a, gconstpointer b, gpointer user_data)\n{\n    uint64_t lhs = *((uint64_t *)a);\n    uint64_t rhs = *((uint64_t *)b);\n\n    if (lhs < rhs) {\n        return -1;\n    } else if (lhs == rhs) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\nstatic uc_err uc_init(uc_engine *uc)\n{\n\n    if (uc->init_done) {\n        return UC_ERR_HANDLE;\n    }\n\n    uc->exits = g_tree_new_full(uc_exits_cmp, NULL, g_free, NULL);\n\n    if (machine_initialize(uc)) {\n        return UC_ERR_RESOURCE;\n    }\n\n    // init fpu softfloat\n    uc->softfloat_initialize();\n\n    if (uc->reg_reset) {\n        uc->reg_reset(uc);\n    }\n\n    uc->init_done = true;\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_open(uc_arch arch, uc_mode mode, uc_engine **result)\n{\n    struct uc_struct *uc;\n\n    if (arch < UC_ARCH_MAX) {\n        uc = calloc(1, sizeof(*uc));\n        if (!uc) {\n            // memory insufficient\n            return UC_ERR_NOMEM;\n        }\n\n        /* qemu/exec.c: phys_map_node_reserve() */\n        uc->alloc_hint = 16;\n        uc->errnum = UC_ERR_OK;\n        uc->arch = arch;\n        uc->mode = mode;\n\n        // uc->ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) };\n        QLIST_INIT(&uc->ram_list.blocks);\n\n        QTAILQ_INIT(&uc->memory_listeners);\n\n        QTAILQ_INIT(&uc->address_spaces);\n\n        switch (arch) {\n        default:\n            break;\n#ifdef UNICORN_HAS_M68K\n        case UC_ARCH_M68K:\n            if ((mode & ~UC_MODE_M68K_MASK) || !(mode & UC_MODE_BIG_ENDIAN)) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            uc->init_arch = m68k_uc_init;\n            break;\n#endif\n#ifdef UNICORN_HAS_X86\n        case UC_ARCH_X86:\n            if ((mode & ~UC_MODE_X86_MASK) || (mode & UC_MODE_BIG_ENDIAN) ||\n                !(mode & (UC_MODE_16 | UC_MODE_32 | UC_MODE_64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            uc->init_arch = x86_uc_init;\n            break;\n#endif\n#ifdef UNICORN_HAS_ARM\n        case UC_ARCH_ARM:\n            if ((mode & ~UC_MODE_ARM_MASK)) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_BIG_ENDIAN) {\n                uc->init_arch = armeb_uc_init;\n            } else {\n                uc->init_arch = arm_uc_init;\n            }\n\n            if (mode & UC_MODE_THUMB) {\n                uc->thumb = 1;\n            }\n            break;\n#endif\n#ifdef UNICORN_HAS_ARM64\n        case UC_ARCH_ARM64:\n            if (mode & ~UC_MODE_ARM_MASK) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_BIG_ENDIAN) {\n                uc->init_arch = arm64eb_uc_init;\n            } else {\n                uc->init_arch = arm64_uc_init;\n            }\n            break;\n#endif\n\n#if defined(UNICORN_HAS_MIPS) || defined(UNICORN_HAS_MIPSEL) ||                \\\n    defined(UNICORN_HAS_MIPS64) || defined(UNICORN_HAS_MIPS64EL)\n        case UC_ARCH_MIPS:\n            if ((mode & ~UC_MODE_MIPS_MASK) ||\n                !(mode & (UC_MODE_MIPS32 | UC_MODE_MIPS64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_BIG_ENDIAN) {\n#ifdef UNICORN_HAS_MIPS\n                if (mode & UC_MODE_MIPS32) {\n                    uc->init_arch = mips_uc_init;\n                }\n#endif\n#ifdef UNICORN_HAS_MIPS64\n                if (mode & UC_MODE_MIPS64) {\n                    uc->init_arch = mips64_uc_init;\n                }\n#endif\n            } else { // little endian\n#ifdef UNICORN_HAS_MIPSEL\n                if (mode & UC_MODE_MIPS32) {\n                    uc->init_arch = mipsel_uc_init;\n                }\n#endif\n#ifdef UNICORN_HAS_MIPS64EL\n                if (mode & UC_MODE_MIPS64) {\n                    uc->init_arch = mips64el_uc_init;\n                }\n#endif\n            }\n            break;\n#endif\n\n#ifdef UNICORN_HAS_SPARC\n        case UC_ARCH_SPARC:\n            if ((mode & ~UC_MODE_SPARC_MASK) || !(mode & UC_MODE_BIG_ENDIAN) ||\n                !(mode & (UC_MODE_SPARC32 | UC_MODE_SPARC64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_SPARC64) {\n                uc->init_arch = sparc64_uc_init;\n            } else {\n                uc->init_arch = sparc_uc_init;\n            }\n            break;\n#endif\n#ifdef UNICORN_HAS_PPC\n        case UC_ARCH_PPC:\n            if ((mode & ~UC_MODE_PPC_MASK) || !(mode & UC_MODE_BIG_ENDIAN) ||\n                !(mode & (UC_MODE_PPC32 | UC_MODE_PPC64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_PPC64) {\n                uc->init_arch = ppc64_uc_init;\n            } else {\n                uc->init_arch = ppc_uc_init;\n            }\n            break;\n#endif\n#ifdef UNICORN_HAS_RISCV\n        case UC_ARCH_RISCV:\n            if ((mode & ~UC_MODE_RISCV_MASK) ||\n                !(mode & (UC_MODE_RISCV32 | UC_MODE_RISCV64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_RISCV32) {\n                uc->init_arch = riscv32_uc_init;\n            } else if (mode & UC_MODE_RISCV64) {\n                uc->init_arch = riscv64_uc_init;\n            } else {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            break;\n#endif\n        }\n\n        if (uc->init_arch == NULL) {\n            return UC_ERR_ARCH;\n        }\n\n        uc->init_done = false;\n        uc->cpu_model = INT_MAX; // INT_MAX means the default cpu model.\n\n        *result = uc;\n\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_ARCH;\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_close(uc_engine *uc)\n{\n    int i;\n    struct list_item *cur;\n    struct hook *hook;\n    MemoryRegion *mr;\n\n    if (!uc->init_done) {\n        free(uc);\n        return UC_ERR_OK;\n    }\n\n    // Cleanup internally.\n    if (uc->release) {\n        uc->release(uc->tcg_ctx);\n    }\n    g_free(uc->tcg_ctx);\n\n    // Cleanup CPU.\n    g_free(uc->cpu->cpu_ases);\n    g_free(uc->cpu->thread);\n\n    /* cpu */\n    free(uc->cpu);\n\n    /* flatviews */\n    g_hash_table_destroy(uc->flat_views);\n\n    // During flatviews destruction, we may still access memory regions.\n    // So we free them afterwards.\n    /* memory */\n    mr = &uc->io_mem_unassigned;\n    mr->destructor(mr);\n    mr = uc->system_io;\n    mr->destructor(mr);\n    mr = uc->system_memory;\n    mr->destructor(mr);\n    g_free(uc->system_memory);\n    g_free(uc->system_io);\n\n    // Thread relateds.\n    if (uc->qemu_thread_data) {\n        g_free(uc->qemu_thread_data);\n    }\n\n    /* free */\n    g_free(uc->init_target_page);\n\n    // Other auxilaries.\n    g_free(uc->l1_map);\n\n    if (uc->bounce.buffer) {\n        free(uc->bounce.buffer);\n    }\n\n    // free hooks and hook lists\n    for (i = 0; i < UC_HOOK_MAX; i++) {\n        cur = uc->hook[i].head;\n        // hook can be in more than one list\n        // so we refcount to know when to free\n        while (cur) {\n            hook = (struct hook *)cur->data;\n            if (--hook->refs == 0) {\n                free(hook);\n            }\n            cur = cur->next;\n        }\n        list_clear(&uc->hook[i]);\n    }\n\n    free(uc->mapped_blocks);\n\n    g_tree_destroy(uc->exits);\n\n    // finally, free uc itself.\n    memset(uc, 0, sizeof(*uc));\n    free(uc);\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_read_batch(uc_engine *uc, int *ids, void **vals, int count)\n{\n    int ret = UC_ERR_OK;\n\n    UC_INIT(uc);\n\n    if (uc->reg_read) {\n        ret = uc->reg_read(uc, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_write_batch(uc_engine *uc, int *ids, void *const *vals, int count)\n{\n    int ret = UC_ERR_OK;\n\n    UC_INIT(uc);\n\n    if (uc->reg_write) {\n        ret = uc->reg_write(uc, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_read(uc_engine *uc, int regid, void *value)\n{\n    UC_INIT(uc);\n    return uc_reg_read_batch(uc, &regid, &value, 1);\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_write(uc_engine *uc, int regid, const void *value)\n{\n    UC_INIT(uc);\n    return uc_reg_write_batch(uc, &regid, (void *const *)&value, 1);\n}\n\n// check if a memory area is mapped\n// this is complicated because an area can overlap adjacent blocks\nstatic bool check_mem_area(uc_engine *uc, uint64_t address, size_t size)\n{\n    size_t count = 0, len;\n\n    while (count < size) {\n        MemoryRegion *mr = memory_mapping(uc, address);\n        if (mr) {\n            len = (size_t)MIN(size - count, mr->end - address);\n            count += len;\n            address += len;\n        } else { // this address is not mapped in yet\n            break;\n        }\n    }\n\n    return (count == size);\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_read(uc_engine *uc, uint64_t address, void *_bytes, size_t size)\n{\n    size_t count = 0, len;\n    uint8_t *bytes = _bytes;\n\n    UC_INIT(uc);\n\n    // qemu cpu_physical_memory_rw() size is an int\n    if (size > INT_MAX)\n        return UC_ERR_ARG;\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_READ_UNMAPPED;\n    }\n\n    // memory area can overlap adjacent memory blocks\n    while (count < size) {\n        MemoryRegion *mr = memory_mapping(uc, address);\n        if (mr) {\n            len = (size_t)MIN(size - count, mr->end - address);\n            if (uc->read_mem(&uc->address_space_memory, address, bytes, len) ==\n                false) {\n                break;\n            }\n            count += len;\n            address += len;\n            bytes += len;\n        } else { // this address is not mapped in yet\n            break;\n        }\n    }\n\n    if (count == size) {\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_READ_UNMAPPED;\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_write(uc_engine *uc, uint64_t address, const void *_bytes,\n                    size_t size)\n{\n    size_t count = 0, len;\n    const uint8_t *bytes = _bytes;\n\n    UC_INIT(uc);\n\n    // qemu cpu_physical_memory_rw() size is an int\n    if (size > INT_MAX)\n        return UC_ERR_ARG;\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_WRITE_UNMAPPED;\n    }\n\n    // memory area can overlap adjacent memory blocks\n    while (count < size) {\n        MemoryRegion *mr = memory_mapping(uc, address);\n        if (mr) {\n            uint32_t operms = mr->perms;\n            if (!(operms & UC_PROT_WRITE)) { // write protected\n                // but this is not the program accessing memory, so temporarily\n                // mark writable\n                uc->readonly_mem(mr, false);\n            }\n\n            len = (size_t)MIN(size - count, mr->end - address);\n            if (uc->write_mem(&uc->address_space_memory, address, bytes, len) ==\n                false) {\n                break;\n            }\n\n            if (!(operms & UC_PROT_WRITE)) { // write protected\n                // now write protect it again\n                uc->readonly_mem(mr, true);\n            }\n\n            count += len;\n            address += len;\n            bytes += len;\n        } else { // this address is not mapped in yet\n            break;\n        }\n    }\n\n    if (count == size) {\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_WRITE_UNMAPPED;\n    }\n}\n\n#define TIMEOUT_STEP 2 // microseconds\nstatic void *_timeout_fn(void *arg)\n{\n    struct uc_struct *uc = arg;\n    int64_t current_time = get_clock();\n\n    do {\n        usleep(TIMEOUT_STEP);\n        // perhaps emulation is even done before timeout?\n        if (uc->emulation_done) {\n            break;\n        }\n    } while ((uint64_t)(get_clock() - current_time) < uc->timeout);\n\n    // timeout before emulation is done?\n    if (!uc->emulation_done) {\n        uc->timed_out = true;\n        // force emulation to stop\n        uc_emu_stop(uc);\n    }\n\n    return NULL;\n}\n\nstatic void enable_emu_timer(uc_engine *uc, uint64_t timeout)\n{\n    uc->timeout = timeout;\n    qemu_thread_create(uc, &uc->timer, \"timeout\", _timeout_fn, uc,\n                       QEMU_THREAD_JOINABLE);\n}\n\nstatic void hook_count_cb(struct uc_struct *uc, uint64_t address, uint32_t size,\n                          void *user_data)\n{\n    // count this instruction. ah ah ah.\n    uc->emu_counter++;\n    // printf(\":: emu counter = %u, at %lx\\n\", uc->emu_counter, address);\n\n    if (uc->emu_counter > uc->emu_count) {\n        // printf(\":: emu counter = %u, stop emulation\\n\", uc->emu_counter);\n        uc_emu_stop(uc);\n    }\n}\n\nstatic void clear_deleted_hooks(uc_engine *uc)\n{\n    struct list_item *cur;\n    struct hook *hook;\n    int i;\n\n    for (cur = uc->hooks_to_del.head;\n         cur != NULL && (hook = (struct hook *)cur->data); cur = cur->next) {\n        assert(hook->to_delete);\n        for (i = 0; i < UC_HOOK_MAX; i++) {\n            if (list_remove(&uc->hook[i], (void *)hook)) {\n                if (--hook->refs == 0) {\n                    uc->del_inline_hook(uc, hook);\n                    free(hook);\n                }\n\n                // a hook cannot be twice in the same list\n                break;\n            }\n        }\n    }\n\n    list_clear(&uc->hooks_to_del);\n}\n\nUNICORN_EXPORT\nuc_err uc_emu_start(uc_engine *uc, uint64_t begin, uint64_t until,\n                    uint64_t timeout, size_t count)\n{\n    // reset the counter\n    uc->emu_counter = 0;\n    uc->invalid_error = UC_ERR_OK;\n    uc->emulation_done = false;\n    uc->size_recur_mem = 0;\n    uc->timed_out = false;\n    uc->first_tb = true;\n\n    UC_INIT(uc);\n\n    // Advance the nested levels. We must decrease the level count by one when\n    // we return from uc_emu_start.\n    if (uc->nested_level >= UC_MAX_NESTED_LEVEL) {\n        // We can't support so many nested levels.\n        return UC_ERR_RESOURCE;\n    }\n    uc->nested_level++;\n\n    switch (uc->arch) {\n    default:\n        break;\n#ifdef UNICORN_HAS_M68K\n    case UC_ARCH_M68K:\n        uc_reg_write(uc, UC_M68K_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_X86\n    case UC_ARCH_X86:\n        switch (uc->mode) {\n        default:\n            break;\n        case UC_MODE_16: {\n            uint64_t ip;\n            uint16_t cs;\n\n            uc_reg_read(uc, UC_X86_REG_CS, &cs);\n            // compensate for later adding up IP & CS\n            ip = begin - cs * 16;\n            uc_reg_write(uc, UC_X86_REG_IP, &ip);\n            break;\n        }\n        case UC_MODE_32:\n            uc_reg_write(uc, UC_X86_REG_EIP, &begin);\n            break;\n        case UC_MODE_64:\n            uc_reg_write(uc, UC_X86_REG_RIP, &begin);\n            break;\n        }\n        break;\n#endif\n#ifdef UNICORN_HAS_ARM\n    case UC_ARCH_ARM:\n        uc_reg_write(uc, UC_ARM_REG_R15, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_ARM64\n    case UC_ARCH_ARM64:\n        uc_reg_write(uc, UC_ARM64_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_MIPS\n    case UC_ARCH_MIPS:\n        // TODO: MIPS32/MIPS64/BIGENDIAN etc\n        uc_reg_write(uc, UC_MIPS_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_SPARC\n    case UC_ARCH_SPARC:\n        // TODO: Sparc/Sparc64\n        uc_reg_write(uc, UC_SPARC_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_PPC\n    case UC_ARCH_PPC:\n        uc_reg_write(uc, UC_PPC_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_RISCV\n    case UC_ARCH_RISCV:\n        uc_reg_write(uc, UC_RISCV_REG_PC, &begin);\n        break;\n#endif\n    }\n\n    uc->stop_request = false;\n\n    uc->emu_count = count;\n    // remove count hook if counting isn't necessary\n    if (count <= 0 && uc->count_hook != 0) {\n        uc_hook_del(uc, uc->count_hook);\n        uc->count_hook = 0;\n    }\n    // set up count hook to count instructions.\n    if (count > 0 && uc->count_hook == 0) {\n        uc_err err;\n        // callback to count instructions must be run before everything else,\n        // so instead of appending, we must insert the hook at the begin\n        // of the hook list\n        uc->hook_insert = 1;\n        err = uc_hook_add(uc, &uc->count_hook, UC_HOOK_CODE, hook_count_cb,\n                          NULL, 1, 0);\n        // restore to append mode for uc_hook_add()\n        uc->hook_insert = 0;\n        if (err != UC_ERR_OK) {\n            uc->nested_level--;\n            return err;\n        }\n    }\n\n    // If UC_CTL_UC_USE_EXITS is set, then the @until param won't have any\n    // effect. This is designed for the backward compatibility.\n    if (!uc->use_exits) {\n        g_tree_remove_all(uc->exits);\n        uc_add_exit(uc, until);\n    }\n\n    if (timeout) {\n        enable_emu_timer(uc, timeout * 1000); // microseconds -> nanoseconds\n    }\n\n    uc->vm_start(uc);\n\n    // emulation is done\n    uc->emulation_done = true;\n\n    // remove hooks to delete\n    clear_deleted_hooks(uc);\n\n    if (timeout) {\n        // wait for the timer to finish\n        qemu_thread_join(&uc->timer);\n    }\n\n    uc->nested_level--;\n    return uc->invalid_error;\n}\n\nUNICORN_EXPORT\nuc_err uc_emu_stop(uc_engine *uc)\n{\n    UC_INIT(uc);\n\n    if (uc->emulation_done) {\n        return UC_ERR_OK;\n    }\n\n    uc->stop_request = true;\n    // TODO: make this atomic somehow?\n    if (uc->cpu) {\n        // exit the current TB\n        cpu_exit(uc->cpu);\n    }\n\n    return UC_ERR_OK;\n}\n\n// return target index where a memory region at the address exists, or could be\n// inserted\n//\n// address either is inside the mapping at the returned index, or is in free\n// space before the next mapping.\n//\n// if there is overlap, between regions, ending address will be higher than the\n// starting address of the mapping at returned index\nstatic int bsearch_mapped_blocks(const uc_engine *uc, uint64_t address)\n{\n    int left, right, mid;\n    MemoryRegion *mapping;\n\n    left = 0;\n    right = uc->mapped_block_count;\n\n    while (left < right) {\n        mid = left + (right - left) / 2;\n\n        mapping = uc->mapped_blocks[mid];\n\n        if (mapping->end - 1 < address) {\n            left = mid + 1;\n        } else if (mapping->addr > address) {\n            right = mid;\n        } else {\n            return mid;\n        }\n    }\n\n    return left;\n}\n\n// find if a memory range overlaps with existing mapped regions\nstatic bool memory_overlap(struct uc_struct *uc, uint64_t begin, size_t size)\n{\n    unsigned int i;\n    uint64_t end = begin + size - 1;\n\n    i = bsearch_mapped_blocks(uc, begin);\n\n    // is this the highest region with no possible overlap?\n    if (i >= uc->mapped_block_count)\n        return false;\n\n    // end address overlaps this region?\n    if (end >= uc->mapped_blocks[i]->addr)\n        return true;\n\n    // not found\n    return false;\n}\n\n// common setup/error checking shared between uc_mem_map and uc_mem_map_ptr\nstatic uc_err mem_map(uc_engine *uc, uint64_t address, size_t size,\n                      uint32_t perms, MemoryRegion *block)\n{\n    MemoryRegion **regions;\n    int pos;\n\n    if (block == NULL) {\n        return UC_ERR_NOMEM;\n    }\n\n    if ((uc->mapped_block_count & (MEM_BLOCK_INCR - 1)) == 0) { // time to grow\n        regions = (MemoryRegion **)g_realloc(\n            uc->mapped_blocks,\n            sizeof(MemoryRegion *) * (uc->mapped_block_count + MEM_BLOCK_INCR));\n        if (regions == NULL) {\n            return UC_ERR_NOMEM;\n        }\n        uc->mapped_blocks = regions;\n    }\n\n    pos = bsearch_mapped_blocks(uc, block->addr);\n\n    // shift the array right to give space for the new pointer\n    memmove(&uc->mapped_blocks[pos + 1], &uc->mapped_blocks[pos],\n            sizeof(MemoryRegion *) * (uc->mapped_block_count - pos));\n\n    uc->mapped_blocks[pos] = block;\n    uc->mapped_block_count++;\n\n    return UC_ERR_OK;\n}\n\nstatic uc_err mem_map_check(uc_engine *uc, uint64_t address, size_t size,\n                            uint32_t perms)\n{\n    if (size == 0) {\n        // invalid memory mapping\n        return UC_ERR_ARG;\n    }\n\n    // address cannot wrapp around\n    if (address + size - 1 < address) {\n        return UC_ERR_ARG;\n    }\n\n    // address must be aligned to uc->target_page_size\n    if ((address & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // size must be multiple of uc->target_page_size\n    if ((size & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // check for only valid permissions\n    if ((perms & ~UC_PROT_ALL) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // this area overlaps existing mapped regions?\n    if (memory_overlap(uc, address, size)) {\n        return UC_ERR_MAP;\n    }\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_map(uc_engine *uc, uint64_t address, size_t size, uint32_t perms)\n{\n    uc_err res;\n\n    UC_INIT(uc);\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    res = mem_map_check(uc, address, size, perms);\n    if (res) {\n        return res;\n    }\n\n    return mem_map(uc, address, size, perms,\n                   uc->memory_map(uc, address, size, perms));\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_map_ptr(uc_engine *uc, uint64_t address, size_t size,\n                      uint32_t perms, void *ptr)\n{\n    uc_err res;\n\n    UC_INIT(uc);\n\n    if (ptr == NULL) {\n        return UC_ERR_ARG;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    res = mem_map_check(uc, address, size, perms);\n    if (res) {\n        return res;\n    }\n\n    return mem_map(uc, address, size, UC_PROT_ALL,\n                   uc->memory_map_ptr(uc, address, size, perms, ptr));\n}\n\nUNICORN_EXPORT\nuc_err uc_mmio_map(uc_engine *uc, uint64_t address, size_t size,\n                   uc_cb_mmio_read_t read_cb, void *user_data_read,\n                   uc_cb_mmio_write_t write_cb, void *user_data_write)\n{\n    uc_err res;\n\n    UC_INIT(uc);\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    res = mem_map_check(uc, address, size, UC_PROT_ALL);\n    if (res)\n        return res;\n\n    // The callbacks do not need to be checked for NULL here, as their presence\n    // (or lack thereof) will determine the permissions used.\n    return mem_map(uc, address, size, UC_PROT_NONE,\n                   uc->memory_map_io(uc, address, size, read_cb, write_cb,\n                                     user_data_read, user_data_write));\n}\n\n// Create a backup copy of the indicated MemoryRegion.\n// Generally used in prepartion for splitting a MemoryRegion.\nstatic uint8_t *copy_region(struct uc_struct *uc, MemoryRegion *mr)\n{\n    uint8_t *block = (uint8_t *)g_malloc0((size_t)int128_get64(mr->size));\n    if (block != NULL) {\n        uc_err err =\n            uc_mem_read(uc, mr->addr, block, (size_t)int128_get64(mr->size));\n        if (err != UC_ERR_OK) {\n            free(block);\n            block = NULL;\n        }\n    }\n\n    return block;\n}\n\n/*\n   Split the given MemoryRegion at the indicated address for the indicated size\n   this may result in the create of up to 3 spanning sections. If the delete\n   parameter is true, the no new section will be created to replace the indicate\n   range. This functions exists to support uc_mem_protect and uc_mem_unmap.\n\n   This is a static function and callers have already done some preliminary\n   parameter validation.\n\n   The do_delete argument indicates that we are being called to support\n   uc_mem_unmap. In this case we save some time by choosing NOT to remap\n   the areas that are intended to get unmapped\n */\n// TODO: investigate whether qemu region manipulation functions already offered\n// this capability\nstatic bool split_region(struct uc_struct *uc, MemoryRegion *mr,\n                         uint64_t address, size_t size, bool do_delete)\n{\n    uint8_t *backup;\n    uint32_t perms;\n    uint64_t begin, end, chunk_end;\n    size_t l_size, m_size, r_size;\n    RAMBlock *block = NULL;\n    bool prealloc = false;\n\n    chunk_end = address + size;\n\n    // if this region belongs to area [address, address+size],\n    // then there is no work to do.\n    if (address <= mr->addr && chunk_end >= mr->end) {\n        return true;\n    }\n\n    if (size == 0) {\n        // trivial case\n        return true;\n    }\n\n    if (address >= mr->end || chunk_end <= mr->addr) {\n        // impossible case\n        return false;\n    }\n\n    QLIST_FOREACH(block, &uc->ram_list.blocks, next)\n    {\n        if (block->offset <= mr->addr &&\n            block->used_length >= (mr->end - mr->addr)) {\n            break;\n        }\n    }\n\n    if (block == NULL) {\n        return false;\n    }\n\n    // RAM_PREALLOC is not defined outside exec.c and I didn't feel like\n    // moving it\n    prealloc = !!(block->flags & 1);\n\n    if (block->flags & 1) {\n        backup = block->host;\n    } else {\n        backup = copy_region(uc, mr);\n        if (backup == NULL) {\n            return false;\n        }\n    }\n\n    // save the essential information required for the split before mr gets\n    // deleted\n    perms = mr->perms;\n    begin = mr->addr;\n    end = mr->end;\n\n    // unmap this region first, then do split it later\n    if (uc_mem_unmap(uc, mr->addr, (size_t)int128_get64(mr->size)) !=\n        UC_ERR_OK) {\n        goto error;\n    }\n\n    /* overlapping cases\n     *               |------mr------|\n     * case 1    |---size--|\n     * case 2           |--size--|\n     * case 3                  |---size--|\n     */\n\n    // adjust some things\n    if (address < begin) {\n        address = begin;\n    }\n    if (chunk_end > end) {\n        chunk_end = end;\n    }\n\n    // compute sub region sizes\n    l_size = (size_t)(address - begin);\n    r_size = (size_t)(end - chunk_end);\n    m_size = (size_t)(chunk_end - address);\n\n    // If there are error in any of the below operations, things are too far\n    // gone at that point to recover. Could try to remap orignal region, but\n    // these smaller allocation just failed so no guarantee that we can recover\n    // the original allocation at this point\n    if (l_size > 0) {\n        if (!prealloc) {\n            if (uc_mem_map(uc, begin, l_size, perms) != UC_ERR_OK) {\n                goto error;\n            }\n            if (uc_mem_write(uc, begin, backup, l_size) != UC_ERR_OK) {\n                goto error;\n            }\n        } else {\n            if (uc_mem_map_ptr(uc, begin, l_size, perms, backup) != UC_ERR_OK) {\n                goto error;\n            }\n        }\n    }\n\n    if (m_size > 0 && !do_delete) {\n        if (!prealloc) {\n            if (uc_mem_map(uc, address, m_size, perms) != UC_ERR_OK) {\n                goto error;\n            }\n            if (uc_mem_write(uc, address, backup + l_size, m_size) !=\n                UC_ERR_OK) {\n                goto error;\n            }\n        } else {\n            if (uc_mem_map_ptr(uc, address, m_size, perms, backup + l_size) !=\n                UC_ERR_OK) {\n                goto error;\n            }\n        }\n    }\n\n    if (r_size > 0) {\n        if (!prealloc) {\n            if (uc_mem_map(uc, chunk_end, r_size, perms) != UC_ERR_OK) {\n                goto error;\n            }\n            if (uc_mem_write(uc, chunk_end, backup + l_size + m_size, r_size) !=\n                UC_ERR_OK) {\n                goto error;\n            }\n        } else {\n            if (uc_mem_map_ptr(uc, chunk_end, r_size, perms,\n                               backup + l_size + m_size) != UC_ERR_OK) {\n                goto error;\n            }\n        }\n    }\n\n    if (!prealloc) {\n        free(backup);\n    }\n    return true;\n\nerror:\n    if (!prealloc) {\n        free(backup);\n    }\n    return false;\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_protect(struct uc_struct *uc, uint64_t address, size_t size,\n                      uint32_t perms)\n{\n    MemoryRegion *mr;\n    uint64_t addr = address;\n    size_t count, len;\n    bool remove_exec = false;\n\n    UC_INIT(uc);\n\n    if (size == 0) {\n        // trivial case, no change\n        return UC_ERR_OK;\n    }\n\n    // address must be aligned to uc->target_page_size\n    if ((address & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // size must be multiple of uc->target_page_size\n    if ((size & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // check for only valid permissions\n    if ((perms & ~UC_PROT_ALL) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    // check that user's entire requested block is mapped\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_NOMEM;\n    }\n\n    // Now we know entire region is mapped, so change permissions\n    // We may need to split regions if this area spans adjacent regions\n    addr = address;\n    count = 0;\n    while (count < size) {\n        mr = memory_mapping(uc, addr);\n        len = (size_t)MIN(size - count, mr->end - addr);\n        if (!split_region(uc, mr, addr, len, false)) {\n            return UC_ERR_NOMEM;\n        }\n\n        mr = memory_mapping(uc, addr);\n        // will this remove EXEC permission?\n        if (((mr->perms & UC_PROT_EXEC) != 0) &&\n            ((perms & UC_PROT_EXEC) == 0)) {\n            remove_exec = true;\n        }\n        mr->perms = perms;\n        uc->readonly_mem(mr, (perms & UC_PROT_WRITE) == 0);\n\n        count += len;\n        addr += len;\n    }\n\n    // if EXEC permission is removed, then quit TB and continue at the same\n    // place\n    if (remove_exec) {\n        uc->quit_request = true;\n        uc_emu_stop(uc);\n    }\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_unmap(struct uc_struct *uc, uint64_t address, size_t size)\n{\n    MemoryRegion *mr;\n    uint64_t addr;\n    size_t count, len;\n\n    UC_INIT(uc);\n\n    if (size == 0) {\n        // nothing to unmap\n        return UC_ERR_OK;\n    }\n\n    // address must be aligned to uc->target_page_size\n    if ((address & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // size must be multiple of uc->target_page_size\n    if ((size & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    // check that user's entire requested block is mapped\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_NOMEM;\n    }\n\n    // Now we know entire region is mapped, so do the unmap\n    // We may need to split regions if this area spans adjacent regions\n    addr = address;\n    count = 0;\n    while (count < size) {\n        mr = memory_mapping(uc, addr);\n        len = (size_t)MIN(size - count, mr->end - addr);\n        if (!split_region(uc, mr, addr, len, true)) {\n            return UC_ERR_NOMEM;\n        }\n\n        // if we can retrieve the mapping, then no splitting took place\n        // so unmap here\n        mr = memory_mapping(uc, addr);\n        if (mr != NULL) {\n            uc->memory_unmap(uc, mr);\n        }\n        count += len;\n        addr += len;\n    }\n\n    return UC_ERR_OK;\n}\n\n// find the memory region of this address\nMemoryRegion *memory_mapping(struct uc_struct *uc, uint64_t address)\n{\n    unsigned int i;\n\n    if (uc->mapped_block_count == 0) {\n        return NULL;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    // try with the cache index first\n    i = uc->mapped_block_cache_index;\n\n    if (i < uc->mapped_block_count && address >= uc->mapped_blocks[i]->addr &&\n        address < uc->mapped_blocks[i]->end) {\n        return uc->mapped_blocks[i];\n    }\n\n    i = bsearch_mapped_blocks(uc, address);\n\n    if (i < uc->mapped_block_count && address >= uc->mapped_blocks[i]->addr &&\n        address <= uc->mapped_blocks[i]->end - 1)\n        return uc->mapped_blocks[i];\n\n    // not found\n    return NULL;\n}\n\nUNICORN_EXPORT\nuc_err uc_hook_add(uc_engine *uc, uc_hook *hh, int type, void *callback,\n                   void *user_data, uint64_t begin, uint64_t end, ...)\n{\n    int ret = UC_ERR_OK;\n    int i = 0;\n\n    UC_INIT(uc);\n\n    struct hook *hook = calloc(1, sizeof(struct hook));\n    if (hook == NULL) {\n        return UC_ERR_NOMEM;\n    }\n\n    hook->begin = begin;\n    hook->end = end;\n    hook->type = type;\n    hook->callback = callback;\n    hook->user_data = user_data;\n    hook->refs = 0;\n    hook->to_delete = false;\n    *hh = (uc_hook)hook;\n\n    // UC_HOOK_INSN has an extra argument for instruction ID\n    if (type & UC_HOOK_INSN) {\n        va_list valist;\n\n        va_start(valist, end);\n        hook->insn = va_arg(valist, int);\n        va_end(valist);\n\n        if (uc->insn_hook_validate) {\n            if (!uc->insn_hook_validate(hook->insn)) {\n                free(hook);\n                return UC_ERR_HOOK;\n            }\n        }\n\n        if (uc->hook_insert) {\n            if (list_insert(&uc->hook[UC_HOOK_INSN_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        } else {\n            if (list_append(&uc->hook[UC_HOOK_INSN_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        }\n\n        uc->hooks_count[UC_HOOK_INSN_IDX]++;\n        hook->refs++;\n        return UC_ERR_OK;\n    }\n\n    if (type & UC_HOOK_TCG_OPCODE) {\n        va_list valist;\n\n        va_start(valist, end);\n        hook->op = va_arg(valist, int);\n        hook->op_flags = va_arg(valist, int);\n        va_end(valist);\n\n        if (uc->opcode_hook_invalidate) {\n            if (!uc->opcode_hook_invalidate(hook->op, hook->op_flags)) {\n                free(hook);\n                return UC_ERR_HOOK;\n            }\n        }\n\n        if (uc->hook_insert) {\n            if (list_insert(&uc->hook[UC_HOOK_TCG_OPCODE_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        } else {\n            if (list_append(&uc->hook[UC_HOOK_TCG_OPCODE_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        }\n\n        uc->hooks_count[UC_HOOK_TCG_OPCODE_IDX]++;\n        hook->refs++;\n        return UC_ERR_OK;\n    }\n\n    while ((type >> i) > 0) {\n        if ((type >> i) & 1) {\n            // TODO: invalid hook error?\n            if (i < UC_HOOK_MAX) {\n                if (uc->hook_insert) {\n                    if (list_insert(&uc->hook[i], hook) == NULL) {\n                        if (hook->refs == 0) {\n                            free(hook);\n                        }\n                        return UC_ERR_NOMEM;\n                    }\n                } else {\n                    if (list_append(&uc->hook[i], hook) == NULL) {\n                        if (hook->refs == 0) {\n                            free(hook);\n                        }\n                        return UC_ERR_NOMEM;\n                    }\n                }\n                uc->hooks_count[i]++;\n                hook->refs++;\n            }\n        }\n        i++;\n    }\n\n    // we didn't use the hook\n    // TODO: return an error?\n    if (hook->refs == 0) {\n        free(hook);\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_hook_del(uc_engine *uc, uc_hook hh)\n{\n    int i;\n    struct hook *hook = (struct hook *)hh;\n\n    UC_INIT(uc);\n\n    // we can't dereference hook->type if hook is invalid\n    // so for now we need to iterate over all possible types to remove the hook\n    // which is less efficient\n    // an optimization would be to align the hook pointer\n    // and store the type mask in the hook pointer.\n    for (i = 0; i < UC_HOOK_MAX; i++) {\n        if (list_exists(&uc->hook[i], (void *)hook)) {\n            hook->to_delete = true;\n            uc->hooks_count[i]--;\n            list_append(&uc->hooks_to_del, hook);\n        }\n    }\n\n    return UC_ERR_OK;\n}\n\n// TCG helper\n// 2 arguments are enough for most opcodes. Load/Store needs 3 arguments but we\n// have memory hooks already. We may exceed the maximum arguments of a tcg\n// helper but that's easy to extend.\nvoid helper_uc_traceopcode(struct hook *hook, uint64_t arg1, uint64_t arg2,\n                           uint32_t size, void *handle, uint64_t address);\nvoid helper_uc_traceopcode(struct hook *hook, uint64_t arg1, uint64_t arg2,\n                           uint32_t size, void *handle, uint64_t address)\n{\n    struct uc_struct *uc = handle;\n\n    if (unlikely(uc->stop_request)) {\n        return;\n    }\n\n    if (unlikely(hook->to_delete)) {\n        return;\n    }\n\n    // We did all checks in translation time.\n    //\n    // This could optimize the case that we have multiple hooks with different\n    // opcodes and have one callback per opcode. Note that the assumption don't\n    // hold in most cases for uc_tracecode.\n    //\n    // TODO: Shall we have a flag to allow users to control whether updating PC?\n    ((uc_hook_tcg_op_2)hook->callback)(uc, address, arg1, arg2, size,\n                                       hook->user_data);\n\n    if (unlikely(uc->stop_request)) {\n        return;\n    }\n}\n\nvoid helper_uc_tracecode(int32_t size, uc_hook_idx index, void *handle,\n                         int64_t address);\nvoid helper_uc_tracecode(int32_t size, uc_hook_idx index, void *handle,\n                         int64_t address)\n{\n    struct uc_struct *uc = handle;\n    struct list_item *cur;\n    struct hook *hook;\n    int hook_flags =\n        index &\n        UC_HOOK_FLAG_MASK; // The index here may contain additional flags. See\n                           // the comments of uc_hook_idx for details.\n\n    index = index & UC_HOOK_IDX_MASK;\n\n    // This has been done in tcg code.\n    // sync PC in CPUArchState with address\n    // if (uc->set_pc) {\n    //     uc->set_pc(uc, address);\n    // }\n\n    // the last callback may already asked to stop emulation\n    if (uc->stop_request && !(hook_flags & UC_HOOK_FLAG_NO_STOP)) {\n        return;\n    }\n\n    for (cur = uc->hook[index].head;\n         cur != NULL && (hook = (struct hook *)cur->data); cur = cur->next) {\n        if (hook->to_delete) {\n            continue;\n        }\n\n        // on invalid block/instruction, call instruction counter (if enable),\n        // then quit\n        if (size == 0) {\n            if (index == UC_HOOK_CODE_IDX && uc->count_hook) {\n                // this is the instruction counter (first hook in the list)\n                ((uc_cb_hookcode_t)hook->callback)(uc, address, size,\n                                                   hook->user_data);\n            }\n\n            return;\n        }\n\n        if (HOOK_BOUND_CHECK(hook, (uint64_t)address)) {\n            ((uc_cb_hookcode_t)hook->callback)(uc, address, size,\n                                               hook->user_data);\n        }\n\n        // the last callback may already asked to stop emulation\n        // Unicorn:\n        //   In an ARM IT block, we behave like the emulation continues\n        //   normally. No check_exit_request is generated and the hooks are\n        //   triggered normally. In other words, the whole IT block is treated\n        //   as a single instruction.\n        if (uc->stop_request && !(hook_flags & UC_HOOK_FLAG_NO_STOP)) {\n            break;\n        }\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_regions(uc_engine *uc, uc_mem_region **regions, uint32_t *count)\n{\n    uint32_t i;\n    uc_mem_region *r = NULL;\n\n    UC_INIT(uc);\n\n    *count = uc->mapped_block_count;\n\n    if (*count) {\n        r = g_malloc0(*count * sizeof(uc_mem_region));\n        if (r == NULL) {\n            // out of memory\n            return UC_ERR_NOMEM;\n        }\n    }\n\n    for (i = 0; i < *count; i++) {\n        r[i].begin = uc->mapped_blocks[i]->addr;\n        r[i].end = uc->mapped_blocks[i]->end - 1;\n        r[i].perms = uc->mapped_blocks[i]->perms;\n    }\n\n    *regions = r;\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_query(uc_engine *uc, uc_query_type type, size_t *result)\n{\n    UC_INIT(uc);\n\n    switch (type) {\n    default:\n        return UC_ERR_ARG;\n\n    case UC_QUERY_PAGE_SIZE:\n        *result = uc->target_page_size;\n        break;\n\n    case UC_QUERY_ARCH:\n        *result = uc->arch;\n        break;\n\n    case UC_QUERY_MODE:\n#ifdef UNICORN_HAS_ARM\n        if (uc->arch == UC_ARCH_ARM) {\n            return uc->query(uc, type, result);\n        }\n#endif\n        *result = uc->mode;\n        break;\n\n    case UC_QUERY_TIMEOUT:\n        *result = uc->timed_out;\n        break;\n    }\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_alloc(uc_engine *uc, uc_context **context)\n{\n    struct uc_context **_context = context;\n    size_t size = uc_context_size(uc);\n\n    UC_INIT(uc);\n\n    *_context = g_malloc(size);\n    if (*_context) {\n        (*_context)->context_size = uc->cpu_context_size;\n        (*_context)->arch = uc->arch;\n        (*_context)->mode = uc->mode;\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_NOMEM;\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_free(void *mem)\n{\n    g_free(mem);\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nsize_t uc_context_size(uc_engine *uc)\n{\n    UC_INIT(uc);\n    // return the total size of struct uc_context\n    return sizeof(uc_context) + uc->cpu_context_size;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_save(uc_engine *uc, uc_context *context)\n{\n    UC_INIT(uc);\n\n    memcpy(context->data, uc->cpu->env_ptr, context->context_size);\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_write(uc_context *ctx, int regid, const void *value)\n{\n    return uc_context_reg_write_batch(ctx, &regid, (void *const *)&value, 1);\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_read(uc_context *ctx, int regid, void *value)\n{\n    return uc_context_reg_read_batch(ctx, &regid, &value, 1);\n}\n\n// Keep in mind that we don't a uc_engine when r/w the registers of a context.\nstatic void find_context_reg_rw_function(uc_arch arch, uc_mode mode,\n                                         context_reg_rw_t *rw)\n{\n    // We believe that the arch/mode pair is correct.\n    switch (arch) {\n    default:\n        rw->context_reg_read = NULL;\n        rw->context_reg_write = NULL;\n        break;\n#ifdef UNICORN_HAS_M68K\n    case UC_ARCH_M68K:\n        rw->context_reg_read = m68k_context_reg_read;\n        rw->context_reg_write = m68k_context_reg_write;\n        break;\n#endif\n#ifdef UNICORN_HAS_X86\n    case UC_ARCH_X86:\n        rw->context_reg_read = x86_context_reg_read;\n        rw->context_reg_write = x86_context_reg_write;\n        break;\n#endif\n#ifdef UNICORN_HAS_ARM\n    case UC_ARCH_ARM:\n        if (mode & UC_MODE_BIG_ENDIAN) {\n            rw->context_reg_read = armeb_context_reg_read;\n            rw->context_reg_write = armeb_context_reg_write;\n        } else {\n            rw->context_reg_read = arm_context_reg_read;\n            rw->context_reg_write = arm_context_reg_write;\n        }\n#endif\n#ifdef UNICORN_HAS_ARM64\n    case UC_ARCH_ARM64:\n        if (mode & UC_MODE_BIG_ENDIAN) {\n            rw->context_reg_read = arm64eb_context_reg_read;\n            rw->context_reg_write = arm64eb_context_reg_write;\n        } else {\n            rw->context_reg_read = arm64_context_reg_read;\n            rw->context_reg_write = arm64_context_reg_write;\n        }\n        break;\n#endif\n\n#if defined(UNICORN_HAS_MIPS) || defined(UNICORN_HAS_MIPSEL) ||                \\\n    defined(UNICORN_HAS_MIPS64) || defined(UNICORN_HAS_MIPS64EL)\n    case UC_ARCH_MIPS:\n        if (mode & UC_MODE_BIG_ENDIAN) {\n#ifdef UNICORN_HAS_MIPS\n            if (mode & UC_MODE_MIPS32) {\n                rw->context_reg_read = mips_context_reg_read;\n                rw->context_reg_write = mips_context_reg_write;\n            }\n#endif\n#ifdef UNICORN_HAS_MIPS64\n            if (mode & UC_MODE_MIPS64) {\n                rw->context_reg_read = mips64_context_reg_read;\n                rw->context_reg_write = mips64_context_reg_write;\n            }\n#endif\n        } else { // little endian\n#ifdef UNICORN_HAS_MIPSEL\n            if (mode & UC_MODE_MIPS32) {\n                rw->context_reg_read = mipsel_context_reg_read;\n                rw->context_reg_write = mipsel_context_reg_write;\n            }\n#endif\n#ifdef UNICORN_HAS_MIPS64EL\n            if (mode & UC_MODE_MIPS64) {\n                rw->context_reg_read = mips64el_context_reg_read;\n                rw->context_reg_write = mips64el_context_reg_write;\n            }\n#endif\n        }\n        break;\n#endif\n\n#ifdef UNICORN_HAS_SPARC\n    case UC_ARCH_SPARC:\n        if (mode & UC_MODE_SPARC64) {\n            rw->context_reg_read = sparc64_context_reg_read;\n            rw->context_reg_write = sparc64_context_reg_write;\n        } else {\n            rw->context_reg_read = sparc_context_reg_read;\n            rw->context_reg_write = sparc_context_reg_write;\n        }\n        break;\n#endif\n#ifdef UNICORN_HAS_PPC\n    case UC_ARCH_PPC:\n        if (mode & UC_MODE_PPC64) {\n            rw->context_reg_read = ppc64_context_reg_read;\n            rw->context_reg_write = ppc64_context_reg_write;\n        } else {\n            rw->context_reg_read = ppc_context_reg_read;\n            rw->context_reg_write = ppc_context_reg_write;\n        }\n        break;\n#endif\n#ifdef UNICORN_HAS_RISCV\n    case UC_ARCH_RISCV:\n        if (mode & UC_MODE_RISCV32) {\n            rw->context_reg_read = riscv32_context_reg_read;\n            rw->context_reg_write = riscv32_context_reg_write;\n        } else if (mode & UC_MODE_RISCV64) {\n            rw->context_reg_read = riscv64_context_reg_read;\n            rw->context_reg_write = riscv64_context_reg_write;\n        }\n        break;\n#endif\n    }\n\n    return;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_write_batch(uc_context *ctx, int *ids, void *const *vals,\n                                  int count)\n{\n    int ret = UC_ERR_OK;\n    context_reg_rw_t rw;\n\n    find_context_reg_rw_function(ctx->arch, ctx->mode, &rw);\n    if (rw.context_reg_write) {\n        ret = rw.context_reg_write(ctx, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_read_batch(uc_context *ctx, int *ids, void **vals,\n                                 int count)\n{\n    int ret = UC_ERR_OK;\n    context_reg_rw_t rw;\n\n    find_context_reg_rw_function(ctx->arch, ctx->mode, &rw);\n    if (rw.context_reg_read) {\n        ret = rw.context_reg_read(ctx, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_restore(uc_engine *uc, uc_context *context)\n{\n    UC_INIT(uc);\n\n    memcpy(uc->cpu->env_ptr, context->data, context->context_size);\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_free(uc_context *context)\n{\n\n    return uc_free(context);\n}\n\ntypedef struct _uc_ctl_exit_request {\n    uint64_t *array;\n    size_t len;\n} uc_ctl_exit_request;\n\nstatic inline gboolean uc_read_exit_iter(gpointer key, gpointer val,\n                                         gpointer data)\n{\n    uc_ctl_exit_request *req = (uc_ctl_exit_request *)data;\n\n    req->array[req->len++] = *(uint64_t *)key;\n\n    return false;\n}\n\nUNICORN_EXPORT\nuc_err uc_ctl(uc_engine *uc, uc_control_type control, ...)\n{\n    int rw, type;\n    uc_err err = UC_ERR_OK;\n    va_list args;\n\n    // MSVC Would do signed shift on signed integers.\n    rw = (uint32_t)control >> 30;\n    type = (control & ((1 << 16) - 1));\n    va_start(args, control);\n\n    switch (type) {\n    case UC_CTL_UC_MODE: {\n        if (rw == UC_CTL_IO_READ) {\n            int *pmode = va_arg(args, int *);\n            *pmode = uc->mode;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_ARCH: {\n        if (rw == UC_CTL_IO_READ) {\n            int *arch = va_arg(args, int *);\n            *arch = uc->arch;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_TIMEOUT: {\n        if (rw == UC_CTL_IO_READ) {\n            uint64_t *arch = va_arg(args, uint64_t *);\n            *arch = uc->timeout;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_PAGE_SIZE: {\n        if (rw == UC_CTL_IO_READ) {\n\n            UC_INIT(uc);\n\n            uint32_t *page_size = va_arg(args, uint32_t *);\n            *page_size = uc->target_page_size;\n        } else {\n            uint32_t page_size = va_arg(args, uint32_t);\n            int bits = 0;\n\n            if (uc->init_done) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            if (uc->arch != UC_ARCH_ARM) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            if ((page_size & (page_size - 1))) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            while (page_size) {\n                bits++;\n                page_size >>= 1;\n            }\n\n            uc->target_bits = bits;\n\n            err = UC_ERR_OK;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_USE_EXITS: {\n        if (rw == UC_CTL_IO_WRITE) {\n            int use_exits = va_arg(args, int);\n            uc->use_exits = use_exits;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_EXITS_CNT: {\n\n        UC_INIT(uc);\n\n        if (!uc->use_exits) {\n            err = UC_ERR_ARG;\n        } else if (rw == UC_CTL_IO_READ) {\n            size_t *exits_cnt = va_arg(args, size_t *);\n            *exits_cnt = g_tree_nnodes(uc->exits);\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_EXITS: {\n\n        UC_INIT(uc);\n\n        if (!uc->use_exits) {\n            err = UC_ERR_ARG;\n        } else if (rw == UC_CTL_IO_READ) {\n            uint64_t *exits = va_arg(args, uint64_t *);\n            size_t cnt = va_arg(args, size_t);\n            if (cnt < g_tree_nnodes(uc->exits)) {\n                err = UC_ERR_ARG;\n            } else {\n                uc_ctl_exit_request req;\n                req.array = exits;\n                req.len = 0;\n\n                g_tree_foreach(uc->exits, uc_read_exit_iter, (void *)&req);\n            }\n        } else if (rw == UC_CTL_IO_WRITE) {\n            uint64_t *exits = va_arg(args, uint64_t *);\n            size_t cnt = va_arg(args, size_t);\n\n            g_tree_remove_all(uc->exits);\n\n            for (size_t i = 0; i < cnt; i++) {\n                uc_add_exit(uc, exits[i]);\n            }\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_CPU_MODEL: {\n        if (rw == UC_CTL_IO_READ) {\n\n            UC_INIT(uc);\n\n            int *model = va_arg(args, int *);\n            *model = uc->cpu_model;\n        } else {\n            int model = va_arg(args, int);\n\n            if (uc->init_done) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            uc->cpu_model = model;\n\n            err = UC_ERR_OK;\n        }\n        break;\n    }\n\n    case UC_CTL_TB_REQUEST_CACHE: {\n\n        UC_INIT(uc);\n\n        if (rw == UC_CTL_IO_READ_WRITE) {\n            uint64_t addr = va_arg(args, uint64_t);\n            uc_tb *tb = va_arg(args, uc_tb *);\n            err = uc->uc_gen_tb(uc, addr, tb);\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_TB_REMOVE_CACHE: {\n\n        UC_INIT(uc);\n\n        if (rw == UC_CTL_IO_WRITE) {\n            uint64_t addr = va_arg(args, uint64_t);\n            uint64_t end = va_arg(args, uint64_t);\n            if (end <= addr) {\n                err = UC_ERR_ARG;\n            } else {\n                uc->uc_invalidate_tb(uc, addr, end - addr);\n            }\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    default:\n        err = UC_ERR_ARG;\n        break;\n    }\n\n    va_end(args);\n\n    return err;\n}\n"], "fixing_code": ["/*\n *  Host code generation\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/units.h\"\n#include \"qemu-common.h\"\n\n#define NO_CPU_IO_DEFS\n#include \"cpu.h\"\n#include \"exec/exec-all.h\"\n#include \"tcg/tcg.h\"\n#include \"exec/ram_addr.h\"\n\n#include \"exec/cputlb.h\"\n#include \"exec/tb-hash.h\"\n#include \"translate-all.h\"\n#include \"qemu/bitmap.h\"\n#include \"qemu/timer.h\"\n#include \"sysemu/cpus.h\"\n#include \"sysemu/tcg.h\"\n#include \"uc_priv.h\"\n\nstatic bool tb_exec_is_locked(TCGContext*);\nstatic void tb_exec_change(TCGContext*, bool locked);\n\n/* #define DEBUG_TB_INVALIDATE */\n/* #define DEBUG_TB_FLUSH */\n/* make various TB consistency checks */\n/* #define DEBUG_TB_CHECK */\n\n#ifdef DEBUG_TB_INVALIDATE\n#define DEBUG_TB_INVALIDATE_GATE 1\n#else\n#define DEBUG_TB_INVALIDATE_GATE 0\n#endif\n\n#ifdef DEBUG_TB_FLUSH\n#define DEBUG_TB_FLUSH_GATE 1\n#else\n#define DEBUG_TB_FLUSH_GATE 0\n#endif\n\n/* TB consistency checks only implemented for usermode emulation.  */\n#undef DEBUG_TB_CHECK\n\n#ifdef DEBUG_TB_CHECK\n#define DEBUG_TB_CHECK_GATE 1\n#else\n#define DEBUG_TB_CHECK_GATE 0\n#endif\n\n/* Access to the various translations structures need to be serialised via locks\n * for consistency.\n * In user-mode emulation access to the memory related structures are protected\n * with mmap_lock.\n * In !user-mode we use per-page locks.\n */\n#define assert_memory_lock()\n\n#define SMC_BITMAP_USE_THRESHOLD 10\n\ntypedef struct PageDesc {\n    /* list of TBs intersecting this ram page */\n    uintptr_t first_tb;\n    /* in order to optimize self modifying code, we count the number\n       of lookups we do to a given page to use a bitmap */\n    unsigned long *code_bitmap;\n    unsigned int code_write_count;\n} PageDesc;\n\n/**\n * struct page_entry - page descriptor entry\n * @pd:     pointer to the &struct PageDesc of the page this entry represents\n * @index:  page index of the page\n * @locked: whether the page is locked\n *\n * This struct helps us keep track of the locked state of a page, without\n * bloating &struct PageDesc.\n *\n * A page lock protects accesses to all fields of &struct PageDesc.\n *\n * See also: &struct page_collection.\n */\nstruct page_entry {\n    PageDesc *pd;\n    tb_page_addr_t index;\n    bool locked;\n};\n\n/**\n * struct page_collection - tracks a set of pages (i.e. &struct page_entry's)\n * @tree:   Binary search tree (BST) of the pages, with key == page index\n * @max:    Pointer to the page in @tree with the highest page index\n *\n * To avoid deadlock we lock pages in ascending order of page index.\n * When operating on a set of pages, we need to keep track of them so that\n * we can lock them in order and also unlock them later. For this we collect\n * pages (i.e. &struct page_entry's) in a binary search @tree. Given that the\n * @tree implementation we use does not provide an O(1) operation to obtain the\n * highest-ranked element, we use @max to keep track of the inserted page\n * with the highest index. This is valuable because if a page is not in\n * the tree and its index is higher than @max's, then we can lock it\n * without breaking the locking order rule.\n *\n * Note on naming: 'struct page_set' would be shorter, but we already have a few\n * page_set_*() helpers, so page_collection is used instead to avoid confusion.\n *\n * See also: page_collection_lock().\n */\nstruct page_collection {\n    GTree *tree;\n    struct page_entry *max;\n};\n\n/* list iterators for lists of tagged pointers in TranslationBlock */\n#define TB_FOR_EACH_TAGGED(head, tb, n, field)                          \\\n    for (n = (head) & 1, tb = (TranslationBlock *)((head) & ~1);        \\\n         tb; tb = (TranslationBlock *)tb->field[n], n = (uintptr_t)tb & 1, \\\n             tb = (TranslationBlock *)((uintptr_t)tb & ~1))\n\n#define PAGE_FOR_EACH_TB(pagedesc, tb, n)                       \\\n    TB_FOR_EACH_TAGGED((pagedesc)->first_tb, tb, n, page_next)\n\n#define TB_FOR_EACH_JMP(head_tb, tb, n)                                 \\\n    TB_FOR_EACH_TAGGED((head_tb)->jmp_list_head, tb, n, jmp_list_next)\n\n/* In system mode we want L1_MAP to be based on ram offsets,\n   while in user mode we want it to be based on virtual addresses.  */\n#if HOST_LONG_BITS < TARGET_PHYS_ADDR_SPACE_BITS\n# define L1_MAP_ADDR_SPACE_BITS  HOST_LONG_BITS\n#else\n# define L1_MAP_ADDR_SPACE_BITS  TARGET_PHYS_ADDR_SPACE_BITS\n#endif\n\n/* Size of the L2 (and L3, etc) page tables.  */\n#define V_L2_BITS 10\n#define V_L2_SIZE (1 << V_L2_BITS)\n\n/* Make sure all possible CPU event bits fit in tb->trace_vcpu_dstate */\nQEMU_BUILD_BUG_ON(CPU_TRACE_DSTATE_MAX_EVENTS >\n                  sizeof_field(TranslationBlock, trace_vcpu_dstate)\n                  * BITS_PER_BYTE);\n\n/* The bottom level has pointers to PageDesc, and is indexed by\n * anything from 4 to (V_L2_BITS + 3) bits, depending on target page size.\n */\n#define V_L1_MIN_BITS 4\n#define V_L1_MAX_BITS (V_L2_BITS + 3)\n#define V_L1_MAX_SIZE (1 << V_L1_MAX_BITS)\n\nstatic void page_table_config_init(struct uc_struct *uc)\n{\n    uint32_t v_l1_bits;\n\n    assert(TARGET_PAGE_BITS);\n    /* The bits remaining after N lower levels of page tables.  */\n    v_l1_bits = (L1_MAP_ADDR_SPACE_BITS - TARGET_PAGE_BITS) % V_L2_BITS;\n    if (v_l1_bits < V_L1_MIN_BITS) {\n        v_l1_bits += V_L2_BITS;\n    }\n\n    uc->v_l1_size = 1 << v_l1_bits;\n    uc->v_l1_shift = L1_MAP_ADDR_SPACE_BITS - TARGET_PAGE_BITS - v_l1_bits;\n    uc->v_l2_levels = uc->v_l1_shift / V_L2_BITS - 1;\n\n    assert(v_l1_bits <= V_L1_MAX_BITS);\n    assert(uc->v_l1_shift % V_L2_BITS == 0);\n    assert(uc->v_l2_levels >= 0);\n}\n\n/* Encode VAL as a signed leb128 sequence at P.\n   Return P incremented past the encoded value.  */\nstatic uint8_t *encode_sleb128(uint8_t *p, target_long val)\n{\n    int more, byte;\n\n    do {\n        byte = val & 0x7f;\n        val >>= 7;\n        more = !((val == 0 && (byte & 0x40) == 0)\n                 || (val == -1 && (byte & 0x40) != 0));\n        if (more) {\n            byte |= 0x80;\n        }\n        *p++ = byte;\n    } while (more);\n\n    return p;\n}\n\n/* Decode a signed leb128 sequence at *PP; increment *PP past the\n   decoded value.  Return the decoded value.  */\nstatic target_long decode_sleb128(uint8_t **pp)\n{\n    uint8_t *p = *pp;\n    target_long val = 0;\n    int byte, shift = 0;\n\n    do {\n        byte = *p++;\n        val |= (target_ulong)(byte & 0x7f) << shift;\n        shift += 7;\n    } while (byte & 0x80);\n    if (shift < TARGET_LONG_BITS && (byte & 0x40)) {\n#ifdef _MSC_VER\n        val |= ((target_ulong)0 - 1) << shift;\n#else\n        val |= -(target_ulong)1 << shift;\n#endif\n    }\n\n    *pp = p;\n    return val;\n}\n\n/* Encode the data collected about the instructions while compiling TB.\n   Place the data at BLOCK, and return the number of bytes consumed.\n\n   The logical table consists of TARGET_INSN_START_WORDS target_ulong's,\n   which come from the target's insn_start data, followed by a uintptr_t\n   which comes from the host pc of the end of the code implementing the insn.\n\n   Each line of the table is encoded as sleb128 deltas from the previous\n   line.  The seed for the first line is { tb->pc, 0..., tb->tc.ptr }.\n   That is, the first column is seeded with the guest pc, the last column\n   with the host pc, and the middle columns with zeros.  */\n\nstatic int encode_search(struct uc_struct *uc, TranslationBlock *tb, uint8_t *block)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    uint8_t *highwater = tcg_ctx->code_gen_highwater;\n    uint8_t *p = block;\n    int i, j, n;\n\n    for (i = 0, n = tb->icount; i < n; ++i) {\n        target_ulong prev;\n\n        for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {\n            if (i == 0) {\n                prev = (j == 0 ? tb->pc : 0);\n            } else {\n                prev = tcg_ctx->gen_insn_data[i - 1][j];\n            }\n            p = encode_sleb128(p, tcg_ctx->gen_insn_data[i][j] - prev);\n        }\n        prev = (i == 0 ? 0 : tcg_ctx->gen_insn_end_off[i - 1]);\n        p = encode_sleb128(p, tcg_ctx->gen_insn_end_off[i] - prev);\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n           one row beginning below the high water mark cannot overrun\n           the buffer completely.  Thus we can test for overflow after\n           encoding a row without having to check during encoding.  */\n        if (unlikely(p > highwater)) {\n            return -1;\n        }\n    }\n\n    return p - block;\n}\n\n/* The cpu state corresponding to 'searched_pc' is restored.\n * When reset_icount is true, current TB will be interrupted and\n * icount should be recalculated.\n */\nstatic int cpu_restore_state_from_tb(CPUState *cpu, TranslationBlock *tb,\n                                     uintptr_t searched_pc, bool reset_icount)\n{\n    target_ulong data[TARGET_INSN_START_WORDS] = { tb->pc };\n    uintptr_t host_pc = (uintptr_t)tb->tc.ptr;\n    CPUArchState *env = cpu->env_ptr;\n    uint8_t *p = (uint8_t *)tb->tc.ptr + tb->tc.size;\n    int i, j, num_insns = tb->icount;\n\n    searched_pc -= GETPC_ADJ;\n\n    if (searched_pc < host_pc) {\n        return -1;\n    }\n\n    /* Reconstruct the stored insn data while looking for the point at\n       which the end of the insn exceeds the searched_pc.  */\n    for (i = 0; i < num_insns; ++i) {\n        for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {\n            data[j] += decode_sleb128(&p);\n        }\n        host_pc += decode_sleb128(&p);\n        if (host_pc > searched_pc) {\n            goto found;\n        }\n    }\n    return -1;\n\n found:\n    if (reset_icount && (tb_cflags(tb) & CF_USE_ICOUNT)) {\n        /* Reset the cycle counter to the start of the block\n           and shift if to the number of actually executed instructions */\n        cpu_neg(cpu)->icount_decr.u16.low += num_insns - i;\n    }\n    restore_state_to_opc(env, tb, data);\n\n    return 0;\n}\n\nbool cpu_restore_state(CPUState *cpu, uintptr_t host_pc, bool will_exit)\n{\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n    TranslationBlock *tb;\n    bool r = false;\n    uintptr_t check_offset;\n    struct uc_struct *uc = cpu->uc;\n\n    /* The host_pc has to be in the region of current code buffer. If\n     * it is not we will not be able to resolve it here. The two cases\n     * where host_pc will not be correct are:\n     *\n     *  - fault during translation (instruction fetch)\n     *  - fault from helper (not using GETPC() macro)\n     *\n     * Either way we need return early as we can't resolve it here.\n     *\n     * We are using unsigned arithmetic so if host_pc <\n     * tcg_init_ctx.code_gen_buffer check_offset will wrap to way\n     * above the code_gen_buffer_size\n     */\n    check_offset = host_pc - (uintptr_t) uc->tcg_ctx->code_gen_buffer;\n\n    if (check_offset < uc->tcg_ctx->code_gen_buffer_size) {\n        tb = tcg_tb_lookup(tcg_ctx, host_pc);\n        if (tb) {\n            cpu_restore_state_from_tb(cpu, tb, host_pc, will_exit);\n            if (tb_cflags(tb) & CF_NOCACHE) {\n                /* one-shot translation, invalidate it immediately */\n                tb_phys_invalidate(tcg_ctx, tb, -1);\n                tcg_tb_remove(tcg_ctx, tb);\n            }\n            r = true;\n        }\n    }\n\n    return r;\n}\n\nstatic void page_init(struct uc_struct *uc)\n{\n    page_size_init(uc);\n    page_table_config_init(uc);\n}\n\nstatic PageDesc *page_find_alloc(struct uc_struct *uc, tb_page_addr_t index, int alloc)\n{\n    PageDesc *pd;\n    void **lp;\n    int i;\n\n    /* Level 1.  Always allocated.  */\n    lp = uc->l1_map + ((index >> uc->v_l1_shift) & (uc->v_l1_size - 1));\n\n    /* Level 2..N-1.  */\n    for (i = uc->v_l2_levels; i > 0; i--) {\n        void **p = *lp;\n\n        if (p == NULL) {\n            void *existing;\n\n            if (!alloc) {\n                return NULL;\n            }\n            p = g_new0(void *, V_L2_SIZE);\n            existing = *lp;\n            if (*lp == NULL) {\n                *lp = p;\n            }\n            if (unlikely(existing)) {\n                g_free(p);\n                p = existing;\n            }\n        }\n\n        lp = p + ((index >> (i * V_L2_BITS)) & (V_L2_SIZE - 1));\n    }\n\n    pd = *lp;\n    if (pd == NULL) {\n        void *existing;\n\n        if (!alloc) {\n            return NULL;\n        }\n        pd = g_new0(PageDesc, V_L2_SIZE);\n        existing = *lp;\n        if (*lp == NULL) {\n            *lp = pd;\n        }\n        if (unlikely(existing)) {\n            g_free(pd);\n            pd = existing;\n        }\n    }\n\n    return pd + (index & (V_L2_SIZE - 1));\n}\n\nstatic inline PageDesc *page_find(struct uc_struct *uc, tb_page_addr_t index)\n{\n    return page_find_alloc(uc, index, 0);\n}\n\nstatic void page_lock_pair(struct uc_struct *uc, PageDesc **ret_p1, tb_page_addr_t phys1,\n                           PageDesc **ret_p2, tb_page_addr_t phys2, int alloc);\n\n#ifdef CONFIG_DEBUG_TCG\n\nstatic void ht_pages_locked_debug_init(void)\n{\n    if (ht_pages_locked_debug) {\n        return;\n    }\n    ht_pages_locked_debug = g_hash_table_new(NULL, NULL);\n}\n\nstatic bool page_is_locked(const PageDesc *pd)\n{\n    PageDesc *found;\n\n    ht_pages_locked_debug_init();\n    found = g_hash_table_lookup(ht_pages_locked_debug, pd);\n    return !!found;\n}\n\nstatic void page_lock__debug(PageDesc *pd)\n{\n    ht_pages_locked_debug_init();\n    g_assert(!page_is_locked(pd));\n    g_hash_table_insert(ht_pages_locked_debug, pd, pd);\n}\n\nstatic void page_unlock__debug(const PageDesc *pd)\n{\n    bool removed;\n\n    ht_pages_locked_debug_init();\n    g_assert(page_is_locked(pd));\n    removed = g_hash_table_remove(ht_pages_locked_debug, pd);\n    g_assert(removed);\n}\n\nstatic void\ndo_assert_page_locked(const PageDesc *pd, const char *file, int line)\n{\n    if (unlikely(!page_is_locked(pd))) {\n        // error_report(\"assert_page_lock: PageDesc %p not locked @ %s:%d\",\n        //              pd, file, line);\n        abort();    // unreachable in unicorn.\n    }\n}\n\n#define assert_page_locked(pd) do_assert_page_locked(pd, __FILE__, __LINE__)\n\nvoid assert_no_pages_locked(void)\n{\n    ht_pages_locked_debug_init();\n    g_assert(g_hash_table_size(ht_pages_locked_debug) == 0);\n}\n\n#else /* !CONFIG_DEBUG_TCG */\n\n#define assert_page_locked(pd)\n\nstatic inline void page_lock__debug(const PageDesc *pd)\n{\n}\n\nstatic inline void page_unlock__debug(const PageDesc *pd)\n{\n}\n\n#endif /* CONFIG_DEBUG_TCG */\n\nstatic inline void page_lock(PageDesc *pd)\n{\n    page_lock__debug(pd);\n}\n\nstatic inline void page_unlock(PageDesc *pd)\n{\n    page_unlock__debug(pd);\n}\n\n/* lock the page(s) of a TB in the correct acquisition order */\nstatic inline void page_lock_tb(struct uc_struct *uc, const TranslationBlock *tb)\n{\n    page_lock_pair(uc, NULL, tb->page_addr[0], NULL, tb->page_addr[1], 0);\n}\n\nstatic inline void page_unlock_tb(struct uc_struct *uc, const TranslationBlock *tb)\n{\n    PageDesc *p1 = page_find(uc, tb->page_addr[0] >> TARGET_PAGE_BITS);\n\n    page_unlock(p1);\n    if (unlikely(tb->page_addr[1] != -1)) {\n        PageDesc *p2 = page_find(uc, tb->page_addr[1] >> TARGET_PAGE_BITS);\n\n        if (p2 != p1) {\n            page_unlock(p2);\n        }\n    }\n}\n\nstatic inline struct page_entry *\npage_entry_new(PageDesc *pd, tb_page_addr_t index)\n{\n    struct page_entry *pe = g_malloc(sizeof(*pe));\n\n    pe->index = index;\n    pe->pd = pd;\n    // pe->locked = false;\n    return pe;\n}\n\nstatic void page_entry_destroy(gpointer p)\n{\n    struct page_entry *pe = p;\n\n    // g_assert(pe->locked);\n    page_unlock(pe->pd);\n    g_free(pe);\n}\n\n#if 0\n/* returns false on success */\nstatic bool page_entry_trylock(struct page_entry *pe)\n{\n    bool busy;\n\n    busy = qemu_spin_trylock(&pe->pd->lock);\n    if (!busy) {\n        g_assert(!pe->locked);\n        pe->locked = true;\n        page_lock__debug(pe->pd);\n    }\n    return busy;\n}\n\nstatic void do_page_entry_lock(struct page_entry *pe)\n{\n    page_lock(pe->pd);\n    g_assert(!pe->locked);\n    pe->locked = true;\n}\n\nstatic gboolean page_entry_lock(gpointer key, gpointer value, gpointer data)\n{\n    struct page_entry *pe = value;\n\n    do_page_entry_lock(pe);\n    return FALSE;\n}\n\nstatic gboolean page_entry_unlock(gpointer key, gpointer value, gpointer data)\n{\n    struct page_entry *pe = value;\n\n    if (pe->locked) {\n        pe->locked = false;\n        page_unlock(pe->pd);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Trylock a page, and if successful, add the page to a collection.\n * Returns true (\"busy\") if the page could not be locked; false otherwise.\n */\nstatic bool page_trylock_add(struct uc_struct *uc, struct page_collection *set, tb_page_addr_t addr)\n{\n    tb_page_addr_t index = addr >> TARGET_PAGE_BITS;\n    struct page_entry *pe;\n    PageDesc *pd;\n\n    pe = g_tree_lookup(set->tree, &index);\n    if (pe) {\n        return false;\n    }\n\n    pd = page_find(uc, index);\n    if (pd == NULL) {\n        return false;\n    }\n\n    pe = page_entry_new(pd, index);\n    g_tree_insert(set->tree, &pe->index, pe);\n\n    /*\n     * If this is either (1) the first insertion or (2) a page whose index\n     * is higher than any other so far, just lock the page and move on.\n     */\n    if (set->max == NULL || pe->index > set->max->index) {\n        set->max = pe;\n#if 0\n        do_page_entry_lock(pe);\n#endif\n        return false;\n    }\n    /*\n     * Try to acquire out-of-order lock; if busy, return busy so that we acquire\n     * locks in order.\n     */\n#if 0\n    return page_entry_trylock(pe);\n#else\n    return 0;\n#endif\n}\n\nstatic gint tb_page_addr_cmp(gconstpointer ap, gconstpointer bp, gpointer udata)\n{\n    tb_page_addr_t a = *(const tb_page_addr_t *)ap;\n    tb_page_addr_t b = *(const tb_page_addr_t *)bp;\n\n    if (a == b) {\n        return 0;\n    } else if (a < b) {\n        return -1;\n    }\n    return 1;\n}\n\n/*\n * Lock a range of pages ([@start,@end[) as well as the pages of all\n * intersecting TBs.\n * Locking order: acquire locks in ascending order of page index.\n */\nstruct page_collection *\npage_collection_lock(struct uc_struct *uc, tb_page_addr_t start, tb_page_addr_t end)\n{\n    struct page_collection *set = g_malloc(sizeof(*set));\n    tb_page_addr_t index;\n    PageDesc *pd;\n\n    start >>= TARGET_PAGE_BITS;\n    end   >>= TARGET_PAGE_BITS;\n    g_assert(start <= end);\n\n    set->tree = g_tree_new_full(tb_page_addr_cmp, NULL, NULL,\n                                page_entry_destroy);\n    set->max = NULL;\n    assert_no_pages_locked();\n\n retry:\n#if 0\n    g_tree_foreach(set->tree, page_entry_lock, NULL);\n#endif\n\n    for (index = start; index <= end; index++) {\n        TranslationBlock *tb;\n        int n;\n\n        pd = page_find(uc, index);\n        if (pd == NULL) {\n            continue;\n        }\n        if (page_trylock_add(uc, set, index << TARGET_PAGE_BITS)) {\n#if 0\n            g_tree_foreach(set->tree, page_entry_unlock, NULL);\n#endif\n            goto retry;\n        }\n        assert_page_locked(pd);\n        PAGE_FOR_EACH_TB(pd, tb, n) {\n            if (page_trylock_add(uc, set, tb->page_addr[0]) ||\n                (tb->page_addr[1] != -1 &&\n                 page_trylock_add(uc, set, tb->page_addr[1]))) {\n                /* drop all locks, and reacquire in order */\n#if 0\n                g_tree_foreach(set->tree, page_entry_unlock, NULL);\n#endif\n                goto retry;\n            }\n        }\n    }\n    return set;\n}\n\nvoid page_collection_unlock(struct page_collection *set)\n{\n    /* entries are unlocked and freed via page_entry_destroy */\n    g_tree_destroy(set->tree);\n    g_free(set);\n}\n\nstatic void page_lock_pair(struct uc_struct *uc, PageDesc **ret_p1, tb_page_addr_t phys1,\n                           PageDesc **ret_p2, tb_page_addr_t phys2, int alloc)\n{\n    PageDesc *p1, *p2;\n    tb_page_addr_t page1;\n    tb_page_addr_t page2;\n\n    assert_memory_lock();\n    g_assert(phys1 != -1);\n\n    page1 = phys1 >> TARGET_PAGE_BITS;\n    page2 = phys2 >> TARGET_PAGE_BITS;\n\n    p1 = page_find_alloc(uc, page1, alloc);\n    if (ret_p1) {\n        *ret_p1 = p1;\n    }\n    if (likely(phys2 == -1)) {\n        page_lock(p1);\n        return;\n    } else if (page1 == page2) {\n        page_lock(p1);\n        if (ret_p2) {\n            *ret_p2 = p1;\n        }\n        return;\n    }\n    p2 = page_find_alloc(uc, page2, alloc);\n    if (ret_p2) {\n        *ret_p2 = p2;\n    }\n    if (page1 < page2) {\n        page_lock(p1);\n        page_lock(p2);\n    } else {\n        page_lock(p2);\n        page_lock(p1);\n    }\n}\n\n/* Minimum size of the code gen buffer.  This number is randomly chosen,\n   but not so small that we can't have a fair number of TB's live.  */\n#define MIN_CODE_GEN_BUFFER_SIZE     (1 * MiB)\n\n/* Maximum size of the code gen buffer we'd like to use.  Unless otherwise\n   indicated, this is constrained by the range of direct branches on the\n   host cpu, as used by the TCG implementation of goto_tb.  */\n#if defined(__x86_64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__sparc__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__powerpc64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__powerpc__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (32 * MiB)\n#elif defined(__aarch64__)\n# define MAX_CODE_GEN_BUFFER_SIZE  (2 * GiB)\n#elif defined(__s390x__)\n  /* We have a +- 4GB range on the branches; leave some slop.  */\n# define MAX_CODE_GEN_BUFFER_SIZE  (3 * GiB)\n#elif defined(__mips__)\n  /* We have a 256MB branch region, but leave room to make sure the\n     main executable is also within that region.  */\n# define MAX_CODE_GEN_BUFFER_SIZE  (128 * MiB)\n#else\n# define MAX_CODE_GEN_BUFFER_SIZE  ((size_t)-1)\n#endif\n\n#if TCG_TARGET_REG_BITS == 32\n#define DEFAULT_CODE_GEN_BUFFER_SIZE_1 (32 * MiB)\n#else /* TCG_TARGET_REG_BITS == 64 */\n/*\n * We expect most system emulation to run one or two guests per host.\n * Users running large scale system emulation may want to tweak their\n * runtime setup via the tb-size control on the command line.\n */\n#define DEFAULT_CODE_GEN_BUFFER_SIZE_1 (1 * GiB)\n#endif\n\n#define DEFAULT_CODE_GEN_BUFFER_SIZE \\\n  (DEFAULT_CODE_GEN_BUFFER_SIZE_1 < MAX_CODE_GEN_BUFFER_SIZE \\\n   ? DEFAULT_CODE_GEN_BUFFER_SIZE_1 : MAX_CODE_GEN_BUFFER_SIZE)\n\nstatic inline size_t size_code_gen_buffer(size_t tb_size)\n{\n    /* Size the buffer.  */\n    if (tb_size == 0) {\n        tb_size = DEFAULT_CODE_GEN_BUFFER_SIZE;\n    }\n    if (tb_size < MIN_CODE_GEN_BUFFER_SIZE) {\n        tb_size = MIN_CODE_GEN_BUFFER_SIZE;\n    }\n    if (tb_size > MAX_CODE_GEN_BUFFER_SIZE) {\n        tb_size = MAX_CODE_GEN_BUFFER_SIZE;\n    }\n    return tb_size;\n}\n\n#ifdef __mips__\n/* In order to use J and JAL within the code_gen_buffer, we require\n   that the buffer not cross a 256MB boundary.  */\nstatic inline bool cross_256mb(void *addr, size_t size)\n{\n    return ((uintptr_t)addr ^ ((uintptr_t)addr + size)) & ~0x0ffffffful;\n}\n\n/* We weren't able to allocate a buffer without crossing that boundary,\n   so make do with the larger portion of the buffer that doesn't cross.\n   Returns the new base of the buffer, and adjusts code_gen_buffer_size.  */\nstatic inline void *split_cross_256mb(TCGContext *tcg_ctx, void *buf1, size_t size1)\n{\n    void *buf2 = (void *)(((uintptr_t)buf1 + size1) & ~0x0ffffffful);\n    size_t size2 = buf1 + size1 - buf2;\n\n    size1 = buf2 - buf1;\n    if (size1 < size2) {\n        size1 = size2;\n        buf1 = buf2;\n    }\n\n    tcg_ctx->code_gen_buffer_size = size1;\n    return buf1;\n}\n#endif\n\n#ifdef USE_STATIC_CODE_GEN_BUFFER\nstatic uint8_t static_code_gen_buffer[DEFAULT_CODE_GEN_BUFFER_SIZE]\n    __attribute__((aligned(CODE_GEN_ALIGN)));\n\nstatic inline void *alloc_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    void *buf = static_code_gen_buffer;\n    void *end = static_code_gen_buffer + sizeof(static_code_gen_buffer);\n    size_t size;\n\n    /* page-align the beginning and end of the buffer */\n    buf = QEMU_ALIGN_PTR_UP(buf, uc->qemu_real_host_page_size);\n    end = QEMU_ALIGN_PTR_DOWN(end, uc->qemu_real_host_page_size);\n\n    size = end - buf;\n\n    /* Honor a command-line option limiting the size of the buffer.  */\n    if (size > tcg_ctx->code_gen_buffer_size) {\n        size = QEMU_ALIGN_DOWN(tcg_ctx->code_gen_buffer_size,\n                               uc->qemu_real_host_page_size);\n    }\n    tcg_ctx->code_gen_buffer_size = size;\n\n#ifdef __mips__\n    if (cross_256mb(buf, size)) {\n        buf = split_cross_256mb(tcg_ctx, buf, size);\n        size = tcg_ctx->code_gen_buffer_size;\n    }\n#endif\n\n    if (qemu_mprotect_rwx(buf, size)) {\n        abort();\n    }\n    qemu_madvise(buf, size, QEMU_MADV_HUGEPAGE);\n\n    return buf;\n}\n#elif defined(_WIN32)\nstatic inline void *alloc_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    size_t size = tcg_ctx->code_gen_buffer_size;\n    return VirtualAlloc(NULL, size, MEM_RESERVE | MEM_COMMIT,\n                        PAGE_EXECUTE_READWRITE);\n}\nvoid free_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    if (tcg_ctx->code_gen_buffer) {\n        VirtualFree(tcg_ctx->code_gen_buffer, 0, MEM_RELEASE);\n    }\n}\n#else\nvoid free_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    if (tcg_ctx->code_gen_buffer) {\n        munmap(tcg_ctx->code_gen_buffer, tcg_ctx->code_gen_buffer_size);\n    }\n}\n\nstatic inline void *alloc_code_gen_buffer(struct uc_struct *uc)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    int prot = PROT_WRITE | PROT_READ | PROT_EXEC;\n    int flags = MAP_PRIVATE | MAP_ANONYMOUS;\n    size_t size = tcg_ctx->code_gen_buffer_size;\n    void *buf;\n#ifdef USE_MAP_JIT\n    flags |= MAP_JIT;\n#endif\n    buf = mmap(NULL, size, prot, flags, -1, 0);\n    if (buf == MAP_FAILED) {\n        return NULL;\n    }\n\n#ifdef __mips__\n    if (cross_256mb(buf, size)) {\n        /*\n         * Try again, with the original still mapped, to avoid re-acquiring\n         * the same 256mb crossing.\n         */\n        size_t size2;\n        void *buf2 = mmap(NULL, size, prot, flags, -1, 0);\n        switch ((int)(buf2 != MAP_FAILED)) {\n        case 1:\n            if (!cross_256mb(buf2, size)) {\n                /* Success!  Use the new buffer.  */\n                munmap(buf, size);\n                break;\n            }\n            /* Failure.  Work with what we had.  */\n            munmap(buf2, size);\n            /* fallthru */\n        default:\n            /* Split the original buffer.  Free the smaller half.  */\n            buf2 = split_cross_256mb(tcg_ctx, buf, size);\n            size2 = tcg_ctx->code_gen_buffer_size;\n            if (buf == buf2) {\n                munmap(buf + size2, size - size2);\n            } else {\n                munmap(buf, size - size2);\n            }\n            size = size2;\n            break;\n        }\n        buf = buf2;\n    }\n#endif\n\n    /* Request large pages for the buffer.  */\n    qemu_madvise(buf, size, QEMU_MADV_HUGEPAGE);\n\n    return buf;\n}\n#endif /* USE_STATIC_CODE_GEN_BUFFER, WIN32, POSIX */\n\nstatic inline void code_gen_alloc(struct uc_struct *uc, size_t tb_size)\n{\n    TCGContext *tcg_ctx = uc->tcg_ctx;\n    tcg_ctx->code_gen_buffer_size = size_code_gen_buffer(tb_size);\n    tcg_ctx->code_gen_buffer = alloc_code_gen_buffer(uc);\n    if (tcg_ctx->code_gen_buffer == NULL) {\n        fprintf(stderr, \"Could not allocate dynamic translator buffer\\n\");\n        exit(1);\n    }\n}\n\nstatic bool tb_cmp(struct uc_struct *uc, const void *ap, const void *bp)\n{\n    const TranslationBlock *a = ap;\n    const TranslationBlock *b = bp;\n\n    return a->pc == b->pc &&\n        a->cs_base == b->cs_base &&\n        a->flags == b->flags &&\n        (tb_cflags(a) & CF_HASH_MASK) == (tb_cflags(b) & CF_HASH_MASK) &&\n        a->trace_vcpu_dstate == b->trace_vcpu_dstate &&\n        a->page_addr[0] == b->page_addr[0] &&\n        a->page_addr[1] == b->page_addr[1];\n}\n\nstatic void tb_htable_init(struct uc_struct *uc)\n{\n    unsigned int mode = QHT_MODE_AUTO_RESIZE;\n\n    qht_init(&uc->tcg_ctx->tb_ctx.htable, tb_cmp, CODE_GEN_HTABLE_SIZE, mode);\n}\n\n\nstatic void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n\n    // GVA to GPA \n    // (GPA -> HVA via memory_region_get_ram_addr(mr) + GPA + block->host,\n    // HVA->HPA via host mmu)\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    \n    // For 32bit target.\n    end = (start + len) & (target_ulong)(-1);\n\n    // We get a wrap?\n    if (start > end) {\n        return;\n    }\n\n    tb_invalidate_phys_range(uc, start, end);\n}\n\nstatic uc_err uc_gen_tb(struct uc_struct *uc, uint64_t addr, uc_tb *out_tb) \n{\n    TranslationBlock *tb;\n    target_ulong cs_base, pc;\n    CPUState *cpu = uc->cpu;\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n    uint32_t flags;\n    uint32_t hash;\n    uint32_t cflags = cpu->cflags_next_tb;\n\n    if (cflags == -1) {\n        cflags = curr_cflags();\n    }\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    // Unicorn: Our hack here.\n    pc = addr;\n\n    hash = tb_jmp_cache_hash_func(env->uc, pc);\n    tb = cpu->tb_jmp_cache[hash];\n\n    cflags &= ~CF_CLUSTER_MASK;\n    cflags |= cpu->cluster_index << CF_CLUSTER_SHIFT;\n\n    if (unlikely(!(tb &&\n                   tb->pc == pc &&\n                   tb->cs_base == cs_base &&\n                   tb->flags == flags &&\n                   tb->trace_vcpu_dstate == *cpu->trace_dstate &&\n                   (tb_cflags(tb) & (CF_HASH_MASK | CF_INVALID)) == cflags))) {\n\n        tb = tb_htable_lookup(cpu, pc, cs_base, flags, cflags);\n        cpu->tb_jmp_cache[hash] = tb;\n\n        if (tb == NULL) {\n            mmap_lock();\n            tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);\n            mmap_unlock();\n            /* We add the TB in the virtual pc hash table for the fast lookup */\n            cpu->tb_jmp_cache[hash] = tb;\n        }\n    }\n\n    // If we still couldn't generate a TB, it must be out of memory.\n    if (tb == NULL) {\n        return UC_ERR_NOMEM;\n    }\n\n    if (out_tb != NULL) {\n        UC_TB_COPY(out_tb, tb);\n    }\n\n    return UC_ERR_OK;\n}\n\n/* Must be called before using the QEMU cpus. 'tb_size' is the size\n   (in bytes) allocated to the translation buffer. Zero means default\n   size. */\nvoid tcg_exec_init(struct uc_struct *uc, unsigned long tb_size)\n{\n    /* remove tcg object. init here. */\n    /* tcg class init: tcg-all.c:tcg_accel_class_init(), skip all. */\n    /* tcg object init: tcg-all.c:tcg_accel_instance_init(), skip all. */\n    /* tcg init: tcg-all.c: tcg_init(), skip all. */\n    /* run tcg_exec_init() here. */\n    uc->tcg_ctx = g_malloc(sizeof(TCGContext));\n    tcg_context_init(uc->tcg_ctx);\n    uc->tcg_ctx->uc = uc;\n    page_init(uc);\n    tb_htable_init(uc);\n    code_gen_alloc(uc, tb_size);\n    tb_exec_unlock(uc->tcg_ctx);\n    tcg_prologue_init(uc->tcg_ctx);\n    /* cpu_interrupt_handler is not used in uc1 */\n    uc->l1_map = g_malloc0(sizeof(void *) * V_L1_MAX_SIZE);\n    /* Invalidate / Cache TBs */\n    uc->uc_invalidate_tb = uc_invalidate_tb;\n    uc->uc_gen_tb = uc_gen_tb;\n\n    /* Inline hooks optimization */\n    uc->add_inline_hook = uc_add_inline_hook;\n    uc->del_inline_hook = uc_del_inline_hook;\n}\n\n/* call with @p->lock held */\nstatic inline void invalidate_page_bitmap(PageDesc *p)\n{\n    assert_page_locked(p);\n\n    g_free(p->code_bitmap);\n    p->code_bitmap = NULL;\n    p->code_write_count = 0;\n}\n\nstatic void tb_clean_internal(void **p, int x)\n{\n    int i;\n    void **q;\n\n    if (x <= 1) {\n        for (i = 0; i < V_L2_SIZE; i++) {\n            q = p[i];\n            if (q) {\n                g_free(q);\n            }\n        }\n        g_free(p);\n    } else {\n        for (i = 0; i < V_L2_SIZE; i++) {\n            q = p[i];\n            if (q) {\n                tb_clean_internal(q, x - 1);\n            }\n        }\n        g_free(p);\n    }\n}\n\nvoid tb_cleanup(struct uc_struct *uc)\n{\n    int i, x;\n    void **p;\n\n    if (uc) {\n        if (uc->l1_map) {\n            x = uc->v_l2_levels;\n            if (x <= 0) {\n                for (i = 0; i < uc->v_l1_size; i++) {\n                    p = uc->l1_map[i];\n                    if (p) {\n                        g_free(p);\n                        uc->l1_map[i] = NULL;\n                    }\n                }\n            } else {\n                for (i = 0; i < uc->v_l1_size; i++) {\n                    p = uc->l1_map[i];\n                    if (p) {\n                        tb_clean_internal(p, x);\n                        uc->l1_map[i] = NULL;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* Set to NULL all the 'first_tb' fields in all PageDescs. */\nstatic void page_flush_tb_1(struct uc_struct *uc, int level, void **lp)\n{\n    int i;\n\n    if (*lp == NULL) {\n        return;\n    }\n    if (level == 0) {\n        PageDesc *pd = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            page_lock(&pd[i]);\n            pd[i].first_tb = (uintptr_t)NULL;\n            invalidate_page_bitmap(pd + i);\n            page_unlock(&pd[i]);\n        }\n    } else {\n        void **pp = *lp;\n\n        for (i = 0; i < V_L2_SIZE; ++i) {\n            page_flush_tb_1(uc, level - 1, pp + i);\n        }\n    }\n}\n\nstatic void page_flush_tb(struct uc_struct *uc)\n{\n    int i, l1_sz = uc->v_l1_size;\n\n    for (i = 0; i < l1_sz; i++) {\n        page_flush_tb_1(uc, uc->v_l2_levels, uc->l1_map + i);\n    }\n}\n\n#if 0\nstatic gboolean tb_host_size_iter(gpointer key, gpointer value, gpointer data)\n{\n    const TranslationBlock *tb = value;\n    size_t *size = data;\n\n    *size += tb->tc.size;\n    return false;\n}\n#endif\n\n/* flush all the translation blocks */\nstatic void do_tb_flush(CPUState *cpu, run_on_cpu_data tb_flush_count)\n{\n    mmap_lock();\n    /* If it is already been done on request of another CPU,\n     * just retry.\n     */\n    if (cpu->uc->tcg_ctx->tb_ctx.tb_flush_count != tb_flush_count.host_int) {\n        goto done;\n    }\n\n#if 0\n    if (DEBUG_TB_FLUSH_GATE) {\n        size_t nb_tbs = tcg_nb_tbs(cpu->uc->tcg_ctx);\n        size_t host_size = 0;\n\n        tcg_tb_foreach(cpu->uc->tcg_ctx, tb_host_size_iter, &host_size);\n        //printf(\"qemu: flush code_size=%zu nb_tbs=%zu avg_tb_size=%zu\\n\",\n        //       tcg_code_size(cpu->uc->tcg_ctx), nb_tbs, nb_tbs > 0 ? host_size / nb_tbs : 0);\n    }\n\n    CPU_FOREACH(cpu) {\n        cpu_tb_jmp_cache_clear(cpu);\n    }\n#else\n    cpu_tb_jmp_cache_clear(cpu);\n#endif\n\n    qht_reset_size(cpu->uc, &cpu->uc->tcg_ctx->tb_ctx.htable, CODE_GEN_HTABLE_SIZE);\n    page_flush_tb(cpu->uc);\n\n    tcg_region_reset_all(cpu->uc->tcg_ctx);\n    /* XXX: flush processor icache at this point if cache flush is\n       expensive */\n    cpu->uc->tcg_ctx->tb_ctx.tb_flush_count = cpu->uc->tcg_ctx->tb_ctx.tb_flush_count + 1;\n\ndone:\n    mmap_unlock();\n}\n\nvoid tb_flush(CPUState *cpu)\n{\n    unsigned tb_flush_count = cpu->uc->tcg_ctx->tb_ctx.tb_flush_count;\n    do_tb_flush(cpu, RUN_ON_CPU_HOST_INT(tb_flush_count));\n}\n\n/*\n * user-mode: call with mmap_lock held\n * !user-mode: call with @pd->lock held\n */\nstatic inline void tb_page_remove(PageDesc *pd, TranslationBlock *tb)\n{\n    TranslationBlock *tb1;\n    uintptr_t *pprev;\n    unsigned int n1;\n\n    assert_page_locked(pd);\n    pprev = &pd->first_tb;\n    PAGE_FOR_EACH_TB(pd, tb1, n1) {\n        if (tb1 == tb) {\n            *pprev = tb1->page_next[n1];\n            return;\n        }\n        pprev = &tb1->page_next[n1];\n    }\n    g_assert_not_reached();\n}\n\n/* remove @orig from its @n_orig-th jump list */\nstatic inline void tb_remove_from_jmp_list(TranslationBlock *orig, int n_orig)\n{\n    uintptr_t ptr, ptr_locked;\n    TranslationBlock *dest;\n    TranslationBlock *tb;\n    uintptr_t *pprev;\n    int n;\n\n    /* mark the LSB of jmp_dest[] so that no further jumps can be inserted */\n    ptr = atomic_or_fetch(&orig->jmp_dest[n_orig], 1);\n    dest = (TranslationBlock *)(ptr & ~1);\n    if (dest == NULL) {\n        return;\n    }\n\n    ptr_locked = orig->jmp_dest[n_orig];\n    if (ptr_locked != ptr) {\n        /*\n         * The only possibility is that the jump was unlinked via\n         * tb_jump_unlink(dest). Seeing here another destination would be a bug,\n         * because we set the LSB above.\n         */\n        g_assert(ptr_locked == 1 && dest->cflags & CF_INVALID);\n        return;\n    }\n    /*\n     * We first acquired the lock, and since the destination pointer matches,\n     * we know for sure that @orig is in the jmp list.\n     */\n    pprev = &dest->jmp_list_head;\n    TB_FOR_EACH_JMP(dest, tb, n) {\n        if (tb == orig && n == n_orig) {\n            *pprev = tb->jmp_list_next[n];\n            /* no need to set orig->jmp_dest[n]; setting the LSB was enough */\n            return;\n        }\n        pprev = &tb->jmp_list_next[n];\n    }\n    g_assert_not_reached();\n}\n\n/* reset the jump entry 'n' of a TB so that it is not chained to\n   another TB */\nstatic inline void tb_reset_jump(TranslationBlock *tb, int n)\n{\n    uintptr_t addr = (uintptr_t)((char *)tb->tc.ptr + tb->jmp_reset_offset[n]);\n    tb_set_jmp_target(tb, n, addr);\n}\n\n/* remove any jumps to the TB */\nstatic inline void tb_jmp_unlink(TranslationBlock *dest)\n{\n    TranslationBlock *tb;\n    int n;\n\n    TB_FOR_EACH_JMP(dest, tb, n) {\n        tb_reset_jump(tb, n);\n#ifdef _MSC_VER\n        atomic_and((long *)&tb->jmp_dest[n], (uintptr_t)NULL | 1);\n#else\n        atomic_and(&tb->jmp_dest[n], (uintptr_t)NULL | 1);\n#endif\n        /* No need to clear the list entry; setting the dest ptr is enough */\n    }\n    dest->jmp_list_head = (uintptr_t)NULL;\n}\n\n/*\n * In user-mode, call with mmap_lock held.\n * In !user-mode, if @rm_from_page_list is set, call with the TB's pages'\n * locks held.\n */\nstatic void do_tb_phys_invalidate(TCGContext *tcg_ctx, TranslationBlock *tb, bool rm_from_page_list)\n{\n    CPUState *cpu = tcg_ctx->uc->cpu;\n    struct uc_struct *uc = tcg_ctx->uc;\n    PageDesc *p;\n    uint32_t h;\n    tb_page_addr_t phys_pc;\n    bool code_gen_locked;\n\n    assert_memory_lock();\n    code_gen_locked = tb_exec_is_locked(tcg_ctx);\n    tb_exec_unlock(tcg_ctx);\n\n    /* make sure no further incoming jumps will be chained to this TB */\n    tb->cflags = tb->cflags | CF_INVALID;\n\n    /* remove the TB from the hash list */\n    phys_pc = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);\n    h = tb_hash_func(phys_pc, tb->pc, tb->flags, tb_cflags(tb) & CF_HASH_MASK,\n                     tb->trace_vcpu_dstate);\n    if (!(tb->cflags & CF_NOCACHE) &&\n        !qht_remove(&tcg_ctx->tb_ctx.htable, tb, h)) {\n        tb_exec_change(tcg_ctx, code_gen_locked);\n        return;\n    }\n\n    /* remove the TB from the page list */\n    if (rm_from_page_list) {\n        p = page_find(tcg_ctx->uc, tb->page_addr[0] >> TARGET_PAGE_BITS);\n        tb_page_remove(p, tb);\n        invalidate_page_bitmap(p);\n        if (tb->page_addr[1] != -1) {\n            p = page_find(tcg_ctx->uc, tb->page_addr[1] >> TARGET_PAGE_BITS);\n            tb_page_remove(p, tb);\n            invalidate_page_bitmap(p);\n        }\n    }\n\n    /* remove the TB from the hash list */\n    h = tb_jmp_cache_hash_func(uc, tb->pc);\n    if (cpu->tb_jmp_cache[h] == tb) {\n        cpu->tb_jmp_cache[h] = NULL;\n    }\n\n    /* suppress this TB from the two jump lists */\n    tb_remove_from_jmp_list(tb, 0);\n    tb_remove_from_jmp_list(tb, 1);\n\n    /* suppress any remaining jumps to this TB */\n    tb_jmp_unlink(tb);\n\n    tcg_ctx->tb_phys_invalidate_count = tcg_ctx->tb_phys_invalidate_count + 1;\n\n    tb_exec_change(tcg_ctx, code_gen_locked);\n}\n\nstatic void tb_phys_invalidate__locked(TCGContext *tcg_ctx, TranslationBlock *tb)\n{\n    do_tb_phys_invalidate(tcg_ctx, tb, true);\n}\n\n/* invalidate one TB\n *\n * Called with mmap_lock held in user-mode.\n */\nvoid tb_phys_invalidate(TCGContext *tcg_ctx, TranslationBlock *tb, tb_page_addr_t page_addr)\n{\n    if (page_addr == -1 && tb->page_addr[0] != -1) {\n        page_lock_tb(tcg_ctx->uc, tb);\n        do_tb_phys_invalidate(tcg_ctx, tb, true);\n        page_unlock_tb(tcg_ctx->uc, tb);\n    } else {\n        do_tb_phys_invalidate(tcg_ctx, tb, false);\n    }\n}\n\n/* call with @p->lock held */\nstatic void build_page_bitmap(struct uc_struct *uc, PageDesc *p)\n{\n    int n, tb_start, tb_end;\n    TranslationBlock *tb;\n\n    assert_page_locked(p);\n    p->code_bitmap = bitmap_new(TARGET_PAGE_SIZE);\n\n    PAGE_FOR_EACH_TB(p, tb, n) {\n        /* NOTE: this is subtle as a TB may span two physical pages */\n        if (n == 0) {\n            /* NOTE: tb_end may be after the end of the page, but\n               it is not a problem */\n            tb_start = tb->pc & ~TARGET_PAGE_MASK;\n            tb_end = tb_start + tb->size;\n            if (tb_end > TARGET_PAGE_SIZE) {\n                tb_end = TARGET_PAGE_SIZE;\n             }\n        } else {\n            tb_start = 0;\n            tb_end = ((tb->pc + tb->size) & ~TARGET_PAGE_MASK);\n        }\n        qemu_bitmap_set(p->code_bitmap, tb_start, tb_end - tb_start);\n    }\n}\n\n/* add the tb in the target page and protect it if necessary\n *\n * Called with mmap_lock held for user-mode emulation.\n * Called with @p->lock held in !user-mode.\n */\nstatic inline void tb_page_add(struct uc_struct *uc, PageDesc *p, TranslationBlock *tb,\n                               unsigned int n, tb_page_addr_t page_addr)\n{\n    bool page_already_protected;\n\n    assert_page_locked(p);\n\n    tb->page_addr[n] = page_addr;\n    tb->page_next[n] = p->first_tb;\n    page_already_protected = p->first_tb != (uintptr_t)NULL;\n    p->first_tb = (uintptr_t)tb | n;\n    invalidate_page_bitmap(p);\n\n    /* if some code is already present, then the pages are already\n       protected. So we handle the case where only the first TB is\n       allocated in a physical page */\n    if (!page_already_protected) {\n        tlb_protect_code(uc, page_addr);\n    }\n}\n\n/* add a new TB and link it to the physical page tables. phys_page2 is\n * (-1) to indicate that only one page contains the TB.\n *\n * Called with mmap_lock held for user-mode emulation.\n *\n * Returns a pointer @tb, or a pointer to an existing TB that matches @tb.\n * Note that in !user-mode, another thread might have already added a TB\n * for the same block of guest code that @tb corresponds to. In that case,\n * the caller should discard the original @tb, and use instead the returned TB.\n */\nstatic TranslationBlock *\ntb_link_page(struct uc_struct *uc, TranslationBlock *tb, tb_page_addr_t phys_pc,\n             tb_page_addr_t phys_page2)\n{\n    PageDesc *p;\n    PageDesc *p2 = NULL;\n\n    assert_memory_lock();\n\n    if (phys_pc == -1) {\n        /*\n         * If the TB is not associated with a physical RAM page then\n         * it must be a temporary one-insn TB, and we have nothing to do\n         * except fill in the page_addr[] fields.\n         */\n        assert(tb->cflags & CF_NOCACHE);\n        tb->page_addr[0] = tb->page_addr[1] = -1;\n        return tb;\n    }\n\n    /*\n     * Add the TB to the page list, acquiring first the pages's locks.\n     * We keep the locks held until after inserting the TB in the hash table,\n     * so that if the insertion fails we know for sure that the TBs are still\n     * in the page descriptors.\n     * Note that inserting into the hash table first isn't an option, since\n     * we can only insert TBs that are fully initialized.\n     */\n    page_lock_pair(uc, &p, phys_pc, &p2, phys_page2, 1);\n    tb_page_add(uc, p, tb, 0, phys_pc & TARGET_PAGE_MASK);\n    if (p2) {\n        tb_page_add(uc, p2, tb, 1, phys_page2);\n    } else {\n        tb->page_addr[1] = -1;\n    }\n\n    if (!(tb->cflags & CF_NOCACHE)) {\n        void *existing_tb = NULL;\n        uint32_t h;\n\n        /* add in the hash table */\n        h = tb_hash_func(phys_pc, tb->pc, tb->flags, tb->cflags & CF_HASH_MASK,\n                         tb->trace_vcpu_dstate);\n        tb->hash = h;   // unicorn needs this so it can remove this tb\n        qht_insert(uc, &uc->tcg_ctx->tb_ctx.htable, tb, h, &existing_tb);\n\n        /* remove TB from the page(s) if we couldn't insert it */\n        if (unlikely(existing_tb)) {\n            tb_page_remove(p, tb);\n            invalidate_page_bitmap(p);\n            if (p2) {\n                tb_page_remove(p2, tb);\n                invalidate_page_bitmap(p2);\n            }\n            tb = existing_tb;\n        }\n    }\n\n    if (p2 && p2 != p) {\n        page_unlock(p2);\n    }\n    page_unlock(p);\n\n    return tb;\n}\n\n/* Called with mmap_lock held for user mode emulation.  */\nTranslationBlock *tb_gen_code(CPUState *cpu,\n                              target_ulong pc, target_ulong cs_base,\n                              uint32_t flags, int cflags)\n{\n#ifdef TARGET_ARM\n    struct uc_struct *uc = cpu->uc;\n#endif\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n    CPUArchState *env = cpu->env_ptr;\n    TranslationBlock *tb, *existing_tb;\n    tb_page_addr_t phys_pc, phys_page2;\n    target_ulong virt_page2;\n    tcg_insn_unit *gen_code_buf;\n    int gen_code_size, search_size, max_insns;\n\n    assert_memory_lock();\n#ifdef HAVE_PTHREAD_JIT_PROTECT\n    tb_exec_unlock(tcg_ctx);\n#endif\n    phys_pc = get_page_addr_code(env, pc);\n\n    if (phys_pc == -1) {\n        /* Generate a temporary TB with 1 insn in it */\n        cflags &= ~CF_COUNT_MASK;\n        cflags |= CF_NOCACHE | 1;\n    }\n\n    cflags &= ~CF_CLUSTER_MASK;\n    cflags |= cpu->cluster_index << CF_CLUSTER_SHIFT;\n\n    max_insns = cflags & CF_COUNT_MASK;\n    if (max_insns == 0) {\n        max_insns = CF_COUNT_MASK;\n    }\n    if (max_insns > TCG_MAX_INSNS) {\n        max_insns = TCG_MAX_INSNS;\n    }\n    if (cpu->singlestep_enabled) {\n        max_insns = 1;\n    }\n\n buffer_overflow:\n    tb = tcg_tb_alloc(tcg_ctx);\n    if (unlikely(!tb)) {\n        /* flush must be done */\n        tb_flush(cpu);\n        mmap_unlock();\n        /* Make the execution loop process the flush as soon as possible.  */\n        cpu->exception_index = EXCP_INTERRUPT;\n        cpu_loop_exit(cpu);\n    }\n\n    gen_code_buf = tcg_ctx->code_gen_ptr;\n    tb->tc.ptr = gen_code_buf;\n    tb->pc = pc;\n    tb->cs_base = cs_base;\n    tb->flags = flags;\n    tb->cflags = cflags;\n    tb->orig_tb = NULL;\n    tb->trace_vcpu_dstate = *cpu->trace_dstate;\n    tcg_ctx->tb_cflags = cflags;\n tb_overflow:\n\n    tcg_func_start(tcg_ctx);\n\n    tcg_ctx->cpu = env_cpu(env);\n    gen_intermediate_code(cpu, tb, max_insns);\n    tcg_ctx->cpu = NULL;\n\n    /* generate machine code */\n    tb->jmp_reset_offset[0] = TB_JMP_RESET_OFFSET_INVALID;\n    tb->jmp_reset_offset[1] = TB_JMP_RESET_OFFSET_INVALID;\n    tcg_ctx->tb_jmp_reset_offset = tb->jmp_reset_offset;\n    if (TCG_TARGET_HAS_direct_jump) {\n        tcg_ctx->tb_jmp_insn_offset = tb->jmp_target_arg;\n        tcg_ctx->tb_jmp_target_addr = NULL;\n    } else {\n        tcg_ctx->tb_jmp_insn_offset = NULL;\n        tcg_ctx->tb_jmp_target_addr = tb->jmp_target_arg;\n    }\n\n    gen_code_size = tcg_gen_code(tcg_ctx, tb);\n    if (unlikely(gen_code_size < 0)) {\n        switch (gen_code_size) {\n        case -1:\n            /*\n             * Overflow of code_gen_buffer, or the current slice of it.\n             *\n             * TODO: We don't need to re-do gen_intermediate_code, nor\n             * should we re-do the tcg optimization currently hidden\n             * inside tcg_gen_code.  All that should be required is to\n             * flush the TBs, allocate a new TB, re-initialize it per\n             * above, and re-do the actual code generation.\n             */\n            goto buffer_overflow;\n\n        case -2:\n            /*\n             * The code generated for the TranslationBlock is too large.\n             * The maximum size allowed by the unwind info is 64k.\n             * There may be stricter constraints from relocations\n             * in the tcg backend.\n             *\n             * Try again with half as many insns as we attempted this time.\n             * If a single insn overflows, there's a bug somewhere...\n             */\n            max_insns = tb->icount;\n            assert(max_insns > 1);\n            max_insns /= 2;\n            goto tb_overflow;\n\n        default:\n            g_assert_not_reached();\n        }\n    }\n    search_size = encode_search(cpu->uc, tb, (uint8_t *)gen_code_buf + gen_code_size);\n    if (unlikely(search_size < 0)) {\n        goto buffer_overflow;\n    }\n    tb->tc.size = gen_code_size;\n\n    tcg_ctx->code_gen_ptr = (void *)\n        ROUND_UP((uintptr_t)gen_code_buf + gen_code_size + search_size,\n                 CODE_GEN_ALIGN);\n\n    /* init jump list */\n    tb->jmp_list_head = (uintptr_t)NULL;\n    tb->jmp_list_next[0] = (uintptr_t)NULL;\n    tb->jmp_list_next[1] = (uintptr_t)NULL;\n    tb->jmp_dest[0] = (uintptr_t)NULL;\n    tb->jmp_dest[1] = (uintptr_t)NULL;\n\n    /* init original jump addresses which have been set during tcg_gen_code() */\n    if (tb->jmp_reset_offset[0] != TB_JMP_RESET_OFFSET_INVALID) {\n        tb_reset_jump(tb, 0);\n    }\n    if (tb->jmp_reset_offset[1] != TB_JMP_RESET_OFFSET_INVALID) {\n        tb_reset_jump(tb, 1);\n    }\n\n    /* check next page if needed */\n    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;\n    phys_page2 = -1;\n    if ((pc & TARGET_PAGE_MASK) != virt_page2) {\n        phys_page2 = get_page_addr_code(env, virt_page2);\n    }\n    /*\n     * No explicit memory barrier is required -- tb_link_page() makes the\n     * TB visible in a consistent state.\n     */\n    existing_tb = tb_link_page(cpu->uc, tb, phys_pc, phys_page2);\n    /* if the TB already exists, discard what we just translated */\n    if (unlikely(existing_tb != tb)) {\n        uintptr_t orig_aligned = (uintptr_t)gen_code_buf;\n\n        orig_aligned -= ROUND_UP(sizeof(*tb), tcg_ctx->uc->qemu_icache_linesize);\n        tcg_ctx->code_gen_ptr = (void *)orig_aligned;\n        return existing_tb;\n    }\n    tcg_tb_insert(tcg_ctx, tb);\n    return tb;\n}\n\n/*\n * @p must be non-NULL.\n * user-mode: call with mmap_lock held.\n * !user-mode: call with all @pages locked.\n */\nstatic void\ntb_invalidate_phys_page_range__locked(struct uc_struct *uc, struct page_collection *pages,\n                                      PageDesc *p, tb_page_addr_t start,\n                                      tb_page_addr_t end,\n                                      uintptr_t retaddr)\n{\n    TranslationBlock *tb;\n    tb_page_addr_t tb_start, tb_end;\n    int n;\n#ifdef TARGET_HAS_PRECISE_SMC\n    CPUState *cpu = uc->cpu;\n    CPUArchState *env = NULL;\n    bool current_tb_not_found = retaddr != 0;\n    bool current_tb_modified = false;\n    TranslationBlock *current_tb = NULL;\n    target_ulong current_pc = 0;\n    target_ulong current_cs_base = 0;\n    uint32_t current_flags = 0;\n#endif /* TARGET_HAS_PRECISE_SMC */\n\n    assert_page_locked(p);\n\n#if defined(TARGET_HAS_PRECISE_SMC)\n    if (cpu != NULL) {\n        env = cpu->env_ptr;\n    }\n#endif\n\n    /* we remove all the TBs in the range [start, end[ */\n    /* XXX: see if in some cases it could be faster to invalidate all\n       the code */\n    PAGE_FOR_EACH_TB(p, tb, n) {\n        assert_page_locked(p);\n        /* NOTE: this is subtle as a TB may span two physical pages */\n        if (n == 0) {\n            /* NOTE: tb_end may be after the end of the page, but\n               it is not a problem */\n            tb_start = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);\n            tb_end = tb_start + tb->size;\n        } else {\n            tb_start = tb->page_addr[1];\n            tb_end = tb_start + ((tb->pc + tb->size) & ~TARGET_PAGE_MASK);\n        }\n        // Unicorn: We may indeed generate a TB without any instruction which breaks qemu assumption.\n        if ( (!(tb_end <= start || tb_start >= end)) || (tb_start == tb_end) ) {\n#ifdef TARGET_HAS_PRECISE_SMC\n            if (current_tb_not_found) {\n                current_tb_not_found = false;\n                /* now we have a real cpu fault */\n                current_tb = tcg_tb_lookup(uc->tcg_ctx, retaddr);\n            }\n            if (current_tb == tb &&\n                (tb_cflags(current_tb) & CF_COUNT_MASK) != 1) {\n                /*\n                 * If we are modifying the current TB, we must stop\n                 * its execution. We could be more precise by checking\n                 * that the modification is after the current PC, but it\n                 * would require a specialized function to partially\n                 * restore the CPU state.\n                 */\n                current_tb_modified = true;\n                cpu_restore_state_from_tb(cpu, current_tb, retaddr, true);\n                cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                                     &current_flags);\n            }\n#endif /* TARGET_HAS_PRECISE_SMC */\n            tb_phys_invalidate__locked(uc->tcg_ctx, tb);\n        }\n    }\n\n    /* if no code remaining, no need to continue to use slow writes */\n    if (!p->first_tb) {\n        invalidate_page_bitmap(p);\n        tlb_unprotect_code(uc, start);\n    }\n\n#ifdef TARGET_HAS_PRECISE_SMC\n    if (current_tb_modified) {\n        page_collection_unlock(pages);\n        /* Force execution of one insn next time.  */\n        cpu->cflags_next_tb = 1 | curr_cflags();\n        mmap_unlock();\n        cpu_loop_exit_noexc(cpu);\n    }\n#endif\n}\n\n/*\n * Invalidate all TBs which intersect with the target physical address range\n * [start;end[. NOTE: start and end must refer to the *same* physical page.\n * 'is_cpu_write_access' should be true if called from a real cpu write\n * access: the virtual CPU will exit the current TB if code is modified inside\n * this TB.\n *\n * Called with mmap_lock held for user-mode emulation\n */\nvoid tb_invalidate_phys_page_range(struct uc_struct *uc, tb_page_addr_t start, tb_page_addr_t end)\n{\n    struct page_collection *pages;\n    PageDesc *p;\n\n    assert_memory_lock();\n\n    p = page_find(uc, start >> TARGET_PAGE_BITS);\n    if (p == NULL) {\n        return;\n    }\n    pages = page_collection_lock(uc, start, end);\n    tb_invalidate_phys_page_range__locked(uc, pages, p, start, end, 0);\n    page_collection_unlock(pages);\n}\n\n/*\n * Invalidate all TBs which intersect with the target physical address range\n * [start;end[. NOTE: start and end may refer to *different* physical pages.\n * 'is_cpu_write_access' should be true if called from a real cpu write\n * access: the virtual CPU will exit the current TB if code is modified inside\n * this TB.\n *\n * Called with mmap_lock held for user-mode emulation.\n */\nvoid tb_invalidate_phys_range(struct uc_struct *uc, ram_addr_t start, ram_addr_t end)\n{\n    struct page_collection *pages;\n    tb_page_addr_t next;\n\n    assert_memory_lock();\n\n    pages = page_collection_lock(uc, start, end);\n    for (next = (start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n         //start < end; Unicorn: Fix possible wrap around\n         (intptr_t)(end - start) > 0;\n         start = next, next += TARGET_PAGE_SIZE) {\n        PageDesc *pd = page_find(uc, start >> TARGET_PAGE_BITS);\n        tb_page_addr_t bound = MIN(next, end);\n\n        if (pd == NULL) {\n            continue;\n        }\n        tb_invalidate_phys_page_range__locked(uc, pages, pd, start, bound, 0);\n    }\n    page_collection_unlock(pages);\n}\n\n/* len must be <= 8 and start must be a multiple of len.\n * Called via softmmu_template.h when code areas are written to with\n * iothread mutex not held.\n *\n * Call with all @pages in the range [@start, @start + len[ locked.\n */\nvoid tb_invalidate_phys_page_fast(struct uc_struct *uc, struct page_collection *pages,\n                                  tb_page_addr_t start, int len,\n                                  uintptr_t retaddr)\n{\n    PageDesc *p;\n\n    assert_memory_lock();\n\n    p = page_find(uc, start >> TARGET_PAGE_BITS);\n    if (!p) {\n        return;\n    }\n\n    assert_page_locked(p);\n    if (!p->code_bitmap &&\n        ++p->code_write_count >= SMC_BITMAP_USE_THRESHOLD) {\n        build_page_bitmap(uc, p);\n    }\n    if (p->code_bitmap) {\n        unsigned int nr;\n        unsigned long b;\n\n        nr = start & ~TARGET_PAGE_MASK;\n        b = p->code_bitmap[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG - 1));\n        if (b & ((1 << len) - 1)) {\n            goto do_invalidate;\n        }\n    } else {\n    do_invalidate:\n        tb_invalidate_phys_page_range__locked(uc, pages, p, start, start + len,\n                                              retaddr);\n    }\n}\n\n/* user-mode: call with mmap_lock held */\nvoid tb_check_watchpoint(CPUState *cpu, uintptr_t retaddr)\n{\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n    TranslationBlock *tb;\n\n    assert_memory_lock();\n\n    tb = tcg_tb_lookup(tcg_ctx, retaddr);\n    if (tb) {\n        /* We can use retranslation to find the PC.  */\n        cpu_restore_state_from_tb(cpu, tb, retaddr, true);\n        tb_phys_invalidate(tcg_ctx, tb, -1);\n    } else {\n        /* The exception probably happened in a helper.  The CPU state should\n           have been saved before calling it. Fetch the PC from there.  */\n        CPUArchState *env = cpu->env_ptr;\n        target_ulong pc, cs_base;\n        tb_page_addr_t addr;\n        uint32_t flags;\n\n        cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n        addr = get_page_addr_code(env, pc);\n        if (addr != -1) {\n            tb_invalidate_phys_range(cpu->uc, addr, addr + 1);\n        }\n    }\n}\n\n/* in deterministic execution mode, instructions doing device I/Os\n * must be at the end of the TB.\n *\n * Called by softmmu_template.h, with iothread mutex not held.\n */\nvoid cpu_io_recompile(CPUState *cpu, uintptr_t retaddr)\n{\n    TCGContext *tcg_ctx = cpu->uc->tcg_ctx;\n#if defined(TARGET_MIPS) || defined(TARGET_SH4)\n    CPUArchState *env = cpu->env_ptr;\n#endif\n    TranslationBlock *tb;\n    uint32_t n;\n\n    tb = tcg_tb_lookup(tcg_ctx, retaddr);\n    if (!tb) {\n        cpu_abort(cpu, \"cpu_io_recompile: could not find TB for pc=%p\",\n                  (void *)retaddr);\n    }\n    cpu_restore_state_from_tb(cpu, tb, retaddr, true);\n\n    /* On MIPS and SH, delay slot instructions can only be restarted if\n       they were already the first instruction in the TB.  If this is not\n       the first instruction in a TB then re-execute the preceding\n       branch.  */\n    n = 1;\n#if defined(TARGET_MIPS)\n    if ((env->hflags & MIPS_HFLAG_BMASK) != 0\n        && env->active_tc.PC != tb->pc) {\n        env->active_tc.PC -= (env->hflags & MIPS_HFLAG_B16 ? 2 : 4);\n        cpu_neg(cpu)->icount_decr.u16.low++;\n        env->hflags &= ~MIPS_HFLAG_BMASK;\n        n = 2;\n    }\n#elif defined(TARGET_SH4)\n    if ((env->flags & ((DELAY_SLOT | DELAY_SLOT_CONDITIONAL))) != 0\n        && env->pc != tb->pc) {\n        env->pc -= 2;\n        cpu_neg(cpu)->icount_decr.u16.low++;\n        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);\n        n = 2;\n    }\n#endif\n\n    /* Generate a new TB executing the I/O insn.  */\n    cpu->cflags_next_tb = curr_cflags() | CF_LAST_IO | n;\n\n    if (tb_cflags(tb) & CF_NOCACHE) {\n        if (tb->orig_tb) {\n            /* Invalidate original TB if this TB was generated in\n             * cpu_exec_nocache() */\n            tb_phys_invalidate(tcg_ctx, tb->orig_tb, -1);\n        }\n        tcg_tb_remove(tcg_ctx, tb);\n    }\n\n    /* TODO: If env->pc != tb->pc (i.e. the faulting instruction was not\n     * the first in the TB) then we end up generating a whole new TB and\n     *  repeating the fault, which is horribly inefficient.\n     *  Better would be to execute just this insn uncached, or generate a\n     *  second new TB.\n     */\n    cpu_loop_exit_noexc(cpu);\n}\n\nstatic void tb_jmp_cache_clear_page(CPUState *cpu, target_ulong page_addr)\n{\n    unsigned int i, i0 = tb_jmp_cache_hash_page(cpu->uc, page_addr);\n\n    for (i = 0; i < TB_JMP_PAGE_SIZE; i++) {\n        cpu->tb_jmp_cache[i0 + i] = NULL;\n    }\n}\n\nvoid tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n{\n#ifdef TARGET_ARM\n    struct uc_struct *uc = cpu->uc;\n#endif\n\n    /* Discard jump cache entries for any tb which might potentially\n       overlap the flushed page.  */\n    tb_jmp_cache_clear_page(cpu, addr - TARGET_PAGE_SIZE);\n    tb_jmp_cache_clear_page(cpu, addr);\n}\n\n/* This is a wrapper for common code that can not use CONFIG_SOFTMMU */\nvoid tcg_flush_softmmu_tlb(struct uc_struct *uc)\n{\n    tlb_flush(uc->cpu);\n}\n\n\n#ifdef HAVE_PTHREAD_JIT_PROTECT\nstatic bool tb_exec_is_locked(TCGContext *tcg_ctx)\n{\n    return tcg_ctx->code_gen_locked;\n}\n\nstatic void tb_exec_change(TCGContext *tcg_ctx, bool locked)\n{\n    jit_write_protect(locked);\n    tcg_ctx->code_gen_locked = locked;\n}\n#else /* not needed on non-Darwin platforms */\nstatic bool tb_exec_is_locked(TCGContext *tcg_ctx)\n{\n    return false;\n}\n\nstatic void tb_exec_change(TCGContext *tcg_ctx, bool locked) {}\n#endif\n\nvoid tb_exec_lock(TCGContext *tcg_ctx)\n{\n    /* assumes sys_icache_invalidate already called */\n    tb_exec_change(tcg_ctx, true);\n}\n\nvoid tb_exec_unlock(TCGContext *tcg_ctx)\n{\n    tb_exec_change(tcg_ctx, false);\n}\n", "/* Unicorn Emulator Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015 */\n/* Modified for Unicorn Engine by Chen Huitao<chenhuitao@hfmrit.com>, 2020 */\n\n#if defined(UNICORN_HAS_OSXKERNEL)\n#include <libkern/libkern.h>\n#else\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#endif\n\n#include <time.h> // nanosleep\n#include <string.h>\n\n#include \"uc_priv.h\"\n\n// target specific headers\n#include \"qemu/target/m68k/unicorn.h\"\n#include \"qemu/target/i386/unicorn.h\"\n#include \"qemu/target/arm/unicorn.h\"\n#include \"qemu/target/mips/unicorn.h\"\n#include \"qemu/target/sparc/unicorn.h\"\n#include \"qemu/target/ppc/unicorn.h\"\n#include \"qemu/target/riscv/unicorn.h\"\n\n#include \"qemu/include/qemu/queue.h\"\n#include \"qemu-common.h\"\n\nUNICORN_EXPORT\nunsigned int uc_version(unsigned int *major, unsigned int *minor)\n{\n    if (major != NULL && minor != NULL) {\n        *major = UC_API_MAJOR;\n        *minor = UC_API_MINOR;\n    }\n\n    return (UC_API_EXTRA << 16) + (UC_API_MAJOR << 8) + UC_API_MINOR;\n}\n\nUNICORN_EXPORT\nuc_err uc_errno(uc_engine *uc)\n{\n    return uc->errnum;\n}\n\nUNICORN_EXPORT\nconst char *uc_strerror(uc_err code)\n{\n    switch (code) {\n    default:\n        return \"Unknown error code\";\n    case UC_ERR_OK:\n        return \"OK (UC_ERR_OK)\";\n    case UC_ERR_NOMEM:\n        return \"No memory available or memory not present (UC_ERR_NOMEM)\";\n    case UC_ERR_ARCH:\n        return \"Invalid/unsupported architecture (UC_ERR_ARCH)\";\n    case UC_ERR_HANDLE:\n        return \"Invalid handle (UC_ERR_HANDLE)\";\n    case UC_ERR_MODE:\n        return \"Invalid mode (UC_ERR_MODE)\";\n    case UC_ERR_VERSION:\n        return \"Different API version between core & binding (UC_ERR_VERSION)\";\n    case UC_ERR_READ_UNMAPPED:\n        return \"Invalid memory read (UC_ERR_READ_UNMAPPED)\";\n    case UC_ERR_WRITE_UNMAPPED:\n        return \"Invalid memory write (UC_ERR_WRITE_UNMAPPED)\";\n    case UC_ERR_FETCH_UNMAPPED:\n        return \"Invalid memory fetch (UC_ERR_FETCH_UNMAPPED)\";\n    case UC_ERR_HOOK:\n        return \"Invalid hook type (UC_ERR_HOOK)\";\n    case UC_ERR_INSN_INVALID:\n        return \"Invalid instruction (UC_ERR_INSN_INVALID)\";\n    case UC_ERR_MAP:\n        return \"Invalid memory mapping (UC_ERR_MAP)\";\n    case UC_ERR_WRITE_PROT:\n        return \"Write to write-protected memory (UC_ERR_WRITE_PROT)\";\n    case UC_ERR_READ_PROT:\n        return \"Read from non-readable memory (UC_ERR_READ_PROT)\";\n    case UC_ERR_FETCH_PROT:\n        return \"Fetch from non-executable memory (UC_ERR_FETCH_PROT)\";\n    case UC_ERR_ARG:\n        return \"Invalid argument (UC_ERR_ARG)\";\n    case UC_ERR_READ_UNALIGNED:\n        return \"Read from unaligned memory (UC_ERR_READ_UNALIGNED)\";\n    case UC_ERR_WRITE_UNALIGNED:\n        return \"Write to unaligned memory (UC_ERR_WRITE_UNALIGNED)\";\n    case UC_ERR_FETCH_UNALIGNED:\n        return \"Fetch from unaligned memory (UC_ERR_FETCH_UNALIGNED)\";\n    case UC_ERR_RESOURCE:\n        return \"Insufficient resource (UC_ERR_RESOURCE)\";\n    case UC_ERR_EXCEPTION:\n        return \"Unhandled CPU exception (UC_ERR_EXCEPTION)\";\n    }\n}\n\nUNICORN_EXPORT\nbool uc_arch_supported(uc_arch arch)\n{\n    switch (arch) {\n#ifdef UNICORN_HAS_ARM\n    case UC_ARCH_ARM:\n        return true;\n#endif\n#ifdef UNICORN_HAS_ARM64\n    case UC_ARCH_ARM64:\n        return true;\n#endif\n#ifdef UNICORN_HAS_M68K\n    case UC_ARCH_M68K:\n        return true;\n#endif\n#ifdef UNICORN_HAS_MIPS\n    case UC_ARCH_MIPS:\n        return true;\n#endif\n#ifdef UNICORN_HAS_PPC\n    case UC_ARCH_PPC:\n        return true;\n#endif\n#ifdef UNICORN_HAS_SPARC\n    case UC_ARCH_SPARC:\n        return true;\n#endif\n#ifdef UNICORN_HAS_X86\n    case UC_ARCH_X86:\n        return true;\n#endif\n#ifdef UNICORN_HAS_RISCV\n    case UC_ARCH_RISCV:\n        return true;\n#endif\n    /* Invalid or disabled arch */\n    default:\n        return false;\n    }\n}\n\n#define UC_INIT(uc)                                                            \\\n    if (unlikely(!(uc)->init_done)) {                                          \\\n        int __init_ret = uc_init(uc);                                          \\\n        if (unlikely(__init_ret != UC_ERR_OK)) {                               \\\n            return __init_ret;                                                 \\\n        }                                                                      \\\n    }\n\nstatic gint uc_exits_cmp(gconstpointer a, gconstpointer b, gpointer user_data)\n{\n    uint64_t lhs = *((uint64_t *)a);\n    uint64_t rhs = *((uint64_t *)b);\n\n    if (lhs < rhs) {\n        return -1;\n    } else if (lhs == rhs) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\nstatic uc_err uc_init(uc_engine *uc)\n{\n\n    if (uc->init_done) {\n        return UC_ERR_HANDLE;\n    }\n\n    uc->exits = g_tree_new_full(uc_exits_cmp, NULL, g_free, NULL);\n\n    if (machine_initialize(uc)) {\n        return UC_ERR_RESOURCE;\n    }\n\n    // init fpu softfloat\n    uc->softfloat_initialize();\n\n    if (uc->reg_reset) {\n        uc->reg_reset(uc);\n    }\n\n    uc->init_done = true;\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_open(uc_arch arch, uc_mode mode, uc_engine **result)\n{\n    struct uc_struct *uc;\n\n    if (arch < UC_ARCH_MAX) {\n        uc = calloc(1, sizeof(*uc));\n        if (!uc) {\n            // memory insufficient\n            return UC_ERR_NOMEM;\n        }\n\n        /* qemu/exec.c: phys_map_node_reserve() */\n        uc->alloc_hint = 16;\n        uc->errnum = UC_ERR_OK;\n        uc->arch = arch;\n        uc->mode = mode;\n\n        // uc->ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) };\n        QLIST_INIT(&uc->ram_list.blocks);\n\n        QTAILQ_INIT(&uc->memory_listeners);\n\n        QTAILQ_INIT(&uc->address_spaces);\n\n        switch (arch) {\n        default:\n            break;\n#ifdef UNICORN_HAS_M68K\n        case UC_ARCH_M68K:\n            if ((mode & ~UC_MODE_M68K_MASK) || !(mode & UC_MODE_BIG_ENDIAN)) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            uc->init_arch = m68k_uc_init;\n            break;\n#endif\n#ifdef UNICORN_HAS_X86\n        case UC_ARCH_X86:\n            if ((mode & ~UC_MODE_X86_MASK) || (mode & UC_MODE_BIG_ENDIAN) ||\n                !(mode & (UC_MODE_16 | UC_MODE_32 | UC_MODE_64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            uc->init_arch = x86_uc_init;\n            break;\n#endif\n#ifdef UNICORN_HAS_ARM\n        case UC_ARCH_ARM:\n            if ((mode & ~UC_MODE_ARM_MASK)) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_BIG_ENDIAN) {\n                uc->init_arch = armeb_uc_init;\n            } else {\n                uc->init_arch = arm_uc_init;\n            }\n\n            if (mode & UC_MODE_THUMB) {\n                uc->thumb = 1;\n            }\n            break;\n#endif\n#ifdef UNICORN_HAS_ARM64\n        case UC_ARCH_ARM64:\n            if (mode & ~UC_MODE_ARM_MASK) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_BIG_ENDIAN) {\n                uc->init_arch = arm64eb_uc_init;\n            } else {\n                uc->init_arch = arm64_uc_init;\n            }\n            break;\n#endif\n\n#if defined(UNICORN_HAS_MIPS) || defined(UNICORN_HAS_MIPSEL) ||                \\\n    defined(UNICORN_HAS_MIPS64) || defined(UNICORN_HAS_MIPS64EL)\n        case UC_ARCH_MIPS:\n            if ((mode & ~UC_MODE_MIPS_MASK) ||\n                !(mode & (UC_MODE_MIPS32 | UC_MODE_MIPS64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_BIG_ENDIAN) {\n#ifdef UNICORN_HAS_MIPS\n                if (mode & UC_MODE_MIPS32) {\n                    uc->init_arch = mips_uc_init;\n                }\n#endif\n#ifdef UNICORN_HAS_MIPS64\n                if (mode & UC_MODE_MIPS64) {\n                    uc->init_arch = mips64_uc_init;\n                }\n#endif\n            } else { // little endian\n#ifdef UNICORN_HAS_MIPSEL\n                if (mode & UC_MODE_MIPS32) {\n                    uc->init_arch = mipsel_uc_init;\n                }\n#endif\n#ifdef UNICORN_HAS_MIPS64EL\n                if (mode & UC_MODE_MIPS64) {\n                    uc->init_arch = mips64el_uc_init;\n                }\n#endif\n            }\n            break;\n#endif\n\n#ifdef UNICORN_HAS_SPARC\n        case UC_ARCH_SPARC:\n            if ((mode & ~UC_MODE_SPARC_MASK) || !(mode & UC_MODE_BIG_ENDIAN) ||\n                !(mode & (UC_MODE_SPARC32 | UC_MODE_SPARC64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_SPARC64) {\n                uc->init_arch = sparc64_uc_init;\n            } else {\n                uc->init_arch = sparc_uc_init;\n            }\n            break;\n#endif\n#ifdef UNICORN_HAS_PPC\n        case UC_ARCH_PPC:\n            if ((mode & ~UC_MODE_PPC_MASK) || !(mode & UC_MODE_BIG_ENDIAN) ||\n                !(mode & (UC_MODE_PPC32 | UC_MODE_PPC64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_PPC64) {\n                uc->init_arch = ppc64_uc_init;\n            } else {\n                uc->init_arch = ppc_uc_init;\n            }\n            break;\n#endif\n#ifdef UNICORN_HAS_RISCV\n        case UC_ARCH_RISCV:\n            if ((mode & ~UC_MODE_RISCV_MASK) ||\n                !(mode & (UC_MODE_RISCV32 | UC_MODE_RISCV64))) {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            if (mode & UC_MODE_RISCV32) {\n                uc->init_arch = riscv32_uc_init;\n            } else if (mode & UC_MODE_RISCV64) {\n                uc->init_arch = riscv64_uc_init;\n            } else {\n                free(uc);\n                return UC_ERR_MODE;\n            }\n            break;\n#endif\n        }\n\n        if (uc->init_arch == NULL) {\n            return UC_ERR_ARCH;\n        }\n\n        uc->init_done = false;\n        uc->cpu_model = INT_MAX; // INT_MAX means the default cpu model.\n\n        *result = uc;\n\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_ARCH;\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_close(uc_engine *uc)\n{\n    int i;\n    struct list_item *cur;\n    struct hook *hook;\n    MemoryRegion *mr;\n\n    if (!uc->init_done) {\n        free(uc);\n        return UC_ERR_OK;\n    }\n\n    // Cleanup internally.\n    if (uc->release) {\n        uc->release(uc->tcg_ctx);\n    }\n    g_free(uc->tcg_ctx);\n\n    // Cleanup CPU.\n    g_free(uc->cpu->cpu_ases);\n    g_free(uc->cpu->thread);\n\n    /* cpu */\n    free(uc->cpu);\n\n    /* flatviews */\n    g_hash_table_destroy(uc->flat_views);\n\n    // During flatviews destruction, we may still access memory regions.\n    // So we free them afterwards.\n    /* memory */\n    mr = &uc->io_mem_unassigned;\n    mr->destructor(mr);\n    mr = uc->system_io;\n    mr->destructor(mr);\n    mr = uc->system_memory;\n    mr->destructor(mr);\n    g_free(uc->system_memory);\n    g_free(uc->system_io);\n\n    // Thread relateds.\n    if (uc->qemu_thread_data) {\n        g_free(uc->qemu_thread_data);\n    }\n\n    /* free */\n    g_free(uc->init_target_page);\n\n    // Other auxilaries.\n    g_free(uc->l1_map);\n\n    if (uc->bounce.buffer) {\n        free(uc->bounce.buffer);\n    }\n\n    // free hooks and hook lists\n    for (i = 0; i < UC_HOOK_MAX; i++) {\n        cur = uc->hook[i].head;\n        // hook can be in more than one list\n        // so we refcount to know when to free\n        while (cur) {\n            hook = (struct hook *)cur->data;\n            if (--hook->refs == 0) {\n                free(hook);\n            }\n            cur = cur->next;\n        }\n        list_clear(&uc->hook[i]);\n    }\n\n    free(uc->mapped_blocks);\n\n    g_tree_destroy(uc->exits);\n\n    // finally, free uc itself.\n    memset(uc, 0, sizeof(*uc));\n    free(uc);\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_read_batch(uc_engine *uc, int *ids, void **vals, int count)\n{\n    int ret = UC_ERR_OK;\n\n    UC_INIT(uc);\n\n    if (uc->reg_read) {\n        ret = uc->reg_read(uc, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_write_batch(uc_engine *uc, int *ids, void *const *vals, int count)\n{\n    int ret = UC_ERR_OK;\n\n    UC_INIT(uc);\n\n    if (uc->reg_write) {\n        ret = uc->reg_write(uc, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_read(uc_engine *uc, int regid, void *value)\n{\n    UC_INIT(uc);\n    return uc_reg_read_batch(uc, &regid, &value, 1);\n}\n\nUNICORN_EXPORT\nuc_err uc_reg_write(uc_engine *uc, int regid, const void *value)\n{\n    UC_INIT(uc);\n    return uc_reg_write_batch(uc, &regid, (void *const *)&value, 1);\n}\n\n// check if a memory area is mapped\n// this is complicated because an area can overlap adjacent blocks\nstatic bool check_mem_area(uc_engine *uc, uint64_t address, size_t size)\n{\n    size_t count = 0, len;\n\n    while (count < size) {\n        MemoryRegion *mr = memory_mapping(uc, address);\n        if (mr) {\n            len = (size_t)MIN(size - count, mr->end - address);\n            count += len;\n            address += len;\n        } else { // this address is not mapped in yet\n            break;\n        }\n    }\n\n    return (count == size);\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_read(uc_engine *uc, uint64_t address, void *_bytes, size_t size)\n{\n    size_t count = 0, len;\n    uint8_t *bytes = _bytes;\n\n    UC_INIT(uc);\n\n    // qemu cpu_physical_memory_rw() size is an int\n    if (size > INT_MAX)\n        return UC_ERR_ARG;\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_READ_UNMAPPED;\n    }\n\n    // memory area can overlap adjacent memory blocks\n    while (count < size) {\n        MemoryRegion *mr = memory_mapping(uc, address);\n        if (mr) {\n            len = (size_t)MIN(size - count, mr->end - address);\n            if (uc->read_mem(&uc->address_space_memory, address, bytes, len) ==\n                false) {\n                break;\n            }\n            count += len;\n            address += len;\n            bytes += len;\n        } else { // this address is not mapped in yet\n            break;\n        }\n    }\n\n    if (count == size) {\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_READ_UNMAPPED;\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_write(uc_engine *uc, uint64_t address, const void *_bytes,\n                    size_t size)\n{\n    size_t count = 0, len;\n    const uint8_t *bytes = _bytes;\n\n    UC_INIT(uc);\n\n    // qemu cpu_physical_memory_rw() size is an int\n    if (size > INT_MAX)\n        return UC_ERR_ARG;\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_WRITE_UNMAPPED;\n    }\n\n    // memory area can overlap adjacent memory blocks\n    while (count < size) {\n        MemoryRegion *mr = memory_mapping(uc, address);\n        if (mr) {\n            uint32_t operms = mr->perms;\n            if (!(operms & UC_PROT_WRITE)) { // write protected\n                // but this is not the program accessing memory, so temporarily\n                // mark writable\n                uc->readonly_mem(mr, false);\n            }\n\n            len = (size_t)MIN(size - count, mr->end - address);\n            if (uc->write_mem(&uc->address_space_memory, address, bytes, len) ==\n                false) {\n                break;\n            }\n\n            if (!(operms & UC_PROT_WRITE)) { // write protected\n                // now write protect it again\n                uc->readonly_mem(mr, true);\n            }\n\n            count += len;\n            address += len;\n            bytes += len;\n        } else { // this address is not mapped in yet\n            break;\n        }\n    }\n\n    if (count == size) {\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_WRITE_UNMAPPED;\n    }\n}\n\n#define TIMEOUT_STEP 2 // microseconds\nstatic void *_timeout_fn(void *arg)\n{\n    struct uc_struct *uc = arg;\n    int64_t current_time = get_clock();\n\n    do {\n        usleep(TIMEOUT_STEP);\n        // perhaps emulation is even done before timeout?\n        if (uc->emulation_done) {\n            break;\n        }\n    } while ((uint64_t)(get_clock() - current_time) < uc->timeout);\n\n    // timeout before emulation is done?\n    if (!uc->emulation_done) {\n        uc->timed_out = true;\n        // force emulation to stop\n        uc_emu_stop(uc);\n    }\n\n    return NULL;\n}\n\nstatic void enable_emu_timer(uc_engine *uc, uint64_t timeout)\n{\n    uc->timeout = timeout;\n    qemu_thread_create(uc, &uc->timer, \"timeout\", _timeout_fn, uc,\n                       QEMU_THREAD_JOINABLE);\n}\n\nstatic void hook_count_cb(struct uc_struct *uc, uint64_t address, uint32_t size,\n                          void *user_data)\n{\n    // count this instruction. ah ah ah.\n    uc->emu_counter++;\n    // printf(\":: emu counter = %u, at %lx\\n\", uc->emu_counter, address);\n\n    if (uc->emu_counter > uc->emu_count) {\n        // printf(\":: emu counter = %u, stop emulation\\n\", uc->emu_counter);\n        uc_emu_stop(uc);\n    }\n}\n\nstatic void clear_deleted_hooks(uc_engine *uc)\n{\n    struct list_item *cur;\n    struct hook *hook;\n    int i;\n\n    for (cur = uc->hooks_to_del.head;\n         cur != NULL && (hook = (struct hook *)cur->data); cur = cur->next) {\n        assert(hook->to_delete);\n        for (i = 0; i < UC_HOOK_MAX; i++) {\n            if (list_remove(&uc->hook[i], (void *)hook)) {\n                if (--hook->refs == 0) {\n                    uc->del_inline_hook(uc, hook);\n                    free(hook);\n                }\n\n                // a hook cannot be twice in the same list\n                break;\n            }\n        }\n    }\n\n    list_clear(&uc->hooks_to_del);\n}\n\nUNICORN_EXPORT\nuc_err uc_emu_start(uc_engine *uc, uint64_t begin, uint64_t until,\n                    uint64_t timeout, size_t count)\n{\n    // reset the counter\n    uc->emu_counter = 0;\n    uc->invalid_error = UC_ERR_OK;\n    uc->emulation_done = false;\n    uc->size_recur_mem = 0;\n    uc->timed_out = false;\n    uc->first_tb = true;\n\n    UC_INIT(uc);\n\n    // Advance the nested levels. We must decrease the level count by one when\n    // we return from uc_emu_start.\n    if (uc->nested_level >= UC_MAX_NESTED_LEVEL) {\n        // We can't support so many nested levels.\n        return UC_ERR_RESOURCE;\n    }\n    uc->nested_level++;\n\n    switch (uc->arch) {\n    default:\n        break;\n#ifdef UNICORN_HAS_M68K\n    case UC_ARCH_M68K:\n        uc_reg_write(uc, UC_M68K_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_X86\n    case UC_ARCH_X86:\n        switch (uc->mode) {\n        default:\n            break;\n        case UC_MODE_16: {\n            uint64_t ip;\n            uint16_t cs;\n\n            uc_reg_read(uc, UC_X86_REG_CS, &cs);\n            // compensate for later adding up IP & CS\n            ip = begin - cs * 16;\n            uc_reg_write(uc, UC_X86_REG_IP, &ip);\n            break;\n        }\n        case UC_MODE_32:\n            uc_reg_write(uc, UC_X86_REG_EIP, &begin);\n            break;\n        case UC_MODE_64:\n            uc_reg_write(uc, UC_X86_REG_RIP, &begin);\n            break;\n        }\n        break;\n#endif\n#ifdef UNICORN_HAS_ARM\n    case UC_ARCH_ARM:\n        uc_reg_write(uc, UC_ARM_REG_R15, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_ARM64\n    case UC_ARCH_ARM64:\n        uc_reg_write(uc, UC_ARM64_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_MIPS\n    case UC_ARCH_MIPS:\n        // TODO: MIPS32/MIPS64/BIGENDIAN etc\n        uc_reg_write(uc, UC_MIPS_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_SPARC\n    case UC_ARCH_SPARC:\n        // TODO: Sparc/Sparc64\n        uc_reg_write(uc, UC_SPARC_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_PPC\n    case UC_ARCH_PPC:\n        uc_reg_write(uc, UC_PPC_REG_PC, &begin);\n        break;\n#endif\n#ifdef UNICORN_HAS_RISCV\n    case UC_ARCH_RISCV:\n        uc_reg_write(uc, UC_RISCV_REG_PC, &begin);\n        break;\n#endif\n    }\n\n    uc->stop_request = false;\n\n    uc->emu_count = count;\n    // remove count hook if counting isn't necessary\n    if (count <= 0 && uc->count_hook != 0) {\n        uc_hook_del(uc, uc->count_hook);\n        uc->count_hook = 0;\n    }\n    // set up count hook to count instructions.\n    if (count > 0 && uc->count_hook == 0) {\n        uc_err err;\n        // callback to count instructions must be run before everything else,\n        // so instead of appending, we must insert the hook at the begin\n        // of the hook list\n        uc->hook_insert = 1;\n        err = uc_hook_add(uc, &uc->count_hook, UC_HOOK_CODE, hook_count_cb,\n                          NULL, 1, 0);\n        // restore to append mode for uc_hook_add()\n        uc->hook_insert = 0;\n        if (err != UC_ERR_OK) {\n            uc->nested_level--;\n            return err;\n        }\n    }\n\n    // If UC_CTL_UC_USE_EXITS is set, then the @until param won't have any\n    // effect. This is designed for the backward compatibility.\n    if (!uc->use_exits) {\n        g_tree_remove_all(uc->exits);\n        uc_add_exit(uc, until);\n    }\n\n    if (timeout) {\n        enable_emu_timer(uc, timeout * 1000); // microseconds -> nanoseconds\n    }\n\n    uc->vm_start(uc);\n\n    // emulation is done\n    uc->emulation_done = true;\n\n    // remove hooks to delete\n    clear_deleted_hooks(uc);\n\n    if (timeout) {\n        // wait for the timer to finish\n        qemu_thread_join(&uc->timer);\n    }\n\n    uc->nested_level--;\n    return uc->invalid_error;\n}\n\nUNICORN_EXPORT\nuc_err uc_emu_stop(uc_engine *uc)\n{\n    UC_INIT(uc);\n\n    if (uc->emulation_done) {\n        return UC_ERR_OK;\n    }\n\n    uc->stop_request = true;\n    // TODO: make this atomic somehow?\n    if (uc->cpu) {\n        // exit the current TB\n        cpu_exit(uc->cpu);\n    }\n\n    return UC_ERR_OK;\n}\n\n// return target index where a memory region at the address exists, or could be\n// inserted\n//\n// address either is inside the mapping at the returned index, or is in free\n// space before the next mapping.\n//\n// if there is overlap, between regions, ending address will be higher than the\n// starting address of the mapping at returned index\nstatic int bsearch_mapped_blocks(const uc_engine *uc, uint64_t address)\n{\n    int left, right, mid;\n    MemoryRegion *mapping;\n\n    left = 0;\n    right = uc->mapped_block_count;\n\n    while (left < right) {\n        mid = left + (right - left) / 2;\n\n        mapping = uc->mapped_blocks[mid];\n\n        if (mapping->end - 1 < address) {\n            left = mid + 1;\n        } else if (mapping->addr > address) {\n            right = mid;\n        } else {\n            return mid;\n        }\n    }\n\n    return left;\n}\n\n// find if a memory range overlaps with existing mapped regions\nstatic bool memory_overlap(struct uc_struct *uc, uint64_t begin, size_t size)\n{\n    unsigned int i;\n    uint64_t end = begin + size - 1;\n\n    i = bsearch_mapped_blocks(uc, begin);\n\n    // is this the highest region with no possible overlap?\n    if (i >= uc->mapped_block_count)\n        return false;\n\n    // end address overlaps this region?\n    if (end >= uc->mapped_blocks[i]->addr)\n        return true;\n\n    // not found\n    return false;\n}\n\n// common setup/error checking shared between uc_mem_map and uc_mem_map_ptr\nstatic uc_err mem_map(uc_engine *uc, uint64_t address, size_t size,\n                      uint32_t perms, MemoryRegion *block)\n{\n    MemoryRegion **regions;\n    int pos;\n\n    if (block == NULL) {\n        return UC_ERR_NOMEM;\n    }\n\n    if ((uc->mapped_block_count & (MEM_BLOCK_INCR - 1)) == 0) { // time to grow\n        regions = (MemoryRegion **)g_realloc(\n            uc->mapped_blocks,\n            sizeof(MemoryRegion *) * (uc->mapped_block_count + MEM_BLOCK_INCR));\n        if (regions == NULL) {\n            return UC_ERR_NOMEM;\n        }\n        uc->mapped_blocks = regions;\n    }\n\n    pos = bsearch_mapped_blocks(uc, block->addr);\n\n    // shift the array right to give space for the new pointer\n    memmove(&uc->mapped_blocks[pos + 1], &uc->mapped_blocks[pos],\n            sizeof(MemoryRegion *) * (uc->mapped_block_count - pos));\n\n    uc->mapped_blocks[pos] = block;\n    uc->mapped_block_count++;\n\n    return UC_ERR_OK;\n}\n\nstatic uc_err mem_map_check(uc_engine *uc, uint64_t address, size_t size,\n                            uint32_t perms)\n{\n    if (size == 0) {\n        // invalid memory mapping\n        return UC_ERR_ARG;\n    }\n\n    // address cannot wrapp around\n    if (address + size - 1 < address) {\n        return UC_ERR_ARG;\n    }\n\n    // address must be aligned to uc->target_page_size\n    if ((address & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // size must be multiple of uc->target_page_size\n    if ((size & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // check for only valid permissions\n    if ((perms & ~UC_PROT_ALL) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // this area overlaps existing mapped regions?\n    if (memory_overlap(uc, address, size)) {\n        return UC_ERR_MAP;\n    }\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_map(uc_engine *uc, uint64_t address, size_t size, uint32_t perms)\n{\n    uc_err res;\n\n    UC_INIT(uc);\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    res = mem_map_check(uc, address, size, perms);\n    if (res) {\n        return res;\n    }\n\n    return mem_map(uc, address, size, perms,\n                   uc->memory_map(uc, address, size, perms));\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_map_ptr(uc_engine *uc, uint64_t address, size_t size,\n                      uint32_t perms, void *ptr)\n{\n    uc_err res;\n\n    UC_INIT(uc);\n\n    if (ptr == NULL) {\n        return UC_ERR_ARG;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    res = mem_map_check(uc, address, size, perms);\n    if (res) {\n        return res;\n    }\n\n    return mem_map(uc, address, size, UC_PROT_ALL,\n                   uc->memory_map_ptr(uc, address, size, perms, ptr));\n}\n\nUNICORN_EXPORT\nuc_err uc_mmio_map(uc_engine *uc, uint64_t address, size_t size,\n                   uc_cb_mmio_read_t read_cb, void *user_data_read,\n                   uc_cb_mmio_write_t write_cb, void *user_data_write)\n{\n    uc_err res;\n\n    UC_INIT(uc);\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    res = mem_map_check(uc, address, size, UC_PROT_ALL);\n    if (res)\n        return res;\n\n    // The callbacks do not need to be checked for NULL here, as their presence\n    // (or lack thereof) will determine the permissions used.\n    return mem_map(uc, address, size, UC_PROT_NONE,\n                   uc->memory_map_io(uc, address, size, read_cb, write_cb,\n                                     user_data_read, user_data_write));\n}\n\n// Create a backup copy of the indicated MemoryRegion.\n// Generally used in prepartion for splitting a MemoryRegion.\nstatic uint8_t *copy_region(struct uc_struct *uc, MemoryRegion *mr)\n{\n    uint8_t *block = (uint8_t *)g_malloc0((size_t)int128_get64(mr->size));\n    if (block != NULL) {\n        uc_err err =\n            uc_mem_read(uc, mr->addr, block, (size_t)int128_get64(mr->size));\n        if (err != UC_ERR_OK) {\n            free(block);\n            block = NULL;\n        }\n    }\n\n    return block;\n}\n\n/*\n   Split the given MemoryRegion at the indicated address for the indicated size\n   this may result in the create of up to 3 spanning sections. If the delete\n   parameter is true, the no new section will be created to replace the indicate\n   range. This functions exists to support uc_mem_protect and uc_mem_unmap.\n\n   This is a static function and callers have already done some preliminary\n   parameter validation.\n\n   The do_delete argument indicates that we are being called to support\n   uc_mem_unmap. In this case we save some time by choosing NOT to remap\n   the areas that are intended to get unmapped\n */\n// TODO: investigate whether qemu region manipulation functions already offered\n// this capability\nstatic bool split_region(struct uc_struct *uc, MemoryRegion *mr,\n                         uint64_t address, size_t size, bool do_delete)\n{\n    uint8_t *backup;\n    uint32_t perms;\n    uint64_t begin, end, chunk_end;\n    size_t l_size, m_size, r_size;\n    RAMBlock *block = NULL;\n    bool prealloc = false;\n\n    chunk_end = address + size;\n\n    // if this region belongs to area [address, address+size],\n    // then there is no work to do.\n    if (address <= mr->addr && chunk_end >= mr->end) {\n        return true;\n    }\n\n    if (size == 0) {\n        // trivial case\n        return true;\n    }\n\n    if (address >= mr->end || chunk_end <= mr->addr) {\n        // impossible case\n        return false;\n    }\n\n    QLIST_FOREACH(block, &uc->ram_list.blocks, next)\n    {\n        // block->offset is the offset within ram_addr_t, not GPA\n        if (block->mr->addr <= mr->addr &&\n            block->used_length >= (mr->end - mr->addr)) {\n            break;\n        }\n    }\n\n    if (block == NULL) {\n        return false;\n    }\n\n    // RAM_PREALLOC is not defined outside exec.c and I didn't feel like\n    // moving it\n    prealloc = !!(block->flags & 1);\n\n    if (block->flags & 1) {\n        backup = block->host;\n    } else {\n        backup = copy_region(uc, mr);\n        if (backup == NULL) {\n            return false;\n        }\n    }\n\n    // save the essential information required for the split before mr gets\n    // deleted\n    perms = mr->perms;\n    begin = mr->addr;\n    end = mr->end;\n\n    // unmap this region first, then do split it later\n    if (uc_mem_unmap(uc, mr->addr, (size_t)int128_get64(mr->size)) !=\n        UC_ERR_OK) {\n        goto error;\n    }\n\n    /* overlapping cases\n     *               |------mr------|\n     * case 1    |---size--|\n     * case 2           |--size--|\n     * case 3                  |---size--|\n     */\n\n    // adjust some things\n    if (address < begin) {\n        address = begin;\n    }\n    if (chunk_end > end) {\n        chunk_end = end;\n    }\n\n    // compute sub region sizes\n    l_size = (size_t)(address - begin);\n    r_size = (size_t)(end - chunk_end);\n    m_size = (size_t)(chunk_end - address);\n\n    // If there are error in any of the below operations, things are too far\n    // gone at that point to recover. Could try to remap orignal region, but\n    // these smaller allocation just failed so no guarantee that we can recover\n    // the original allocation at this point\n    if (l_size > 0) {\n        if (!prealloc) {\n            if (uc_mem_map(uc, begin, l_size, perms) != UC_ERR_OK) {\n                goto error;\n            }\n            if (uc_mem_write(uc, begin, backup, l_size) != UC_ERR_OK) {\n                goto error;\n            }\n        } else {\n            if (uc_mem_map_ptr(uc, begin, l_size, perms, backup) != UC_ERR_OK) {\n                goto error;\n            }\n        }\n    }\n\n    if (m_size > 0 && !do_delete) {\n        if (!prealloc) {\n            if (uc_mem_map(uc, address, m_size, perms) != UC_ERR_OK) {\n                goto error;\n            }\n            if (uc_mem_write(uc, address, backup + l_size, m_size) !=\n                UC_ERR_OK) {\n                goto error;\n            }\n        } else {\n            if (uc_mem_map_ptr(uc, address, m_size, perms, backup + l_size) !=\n                UC_ERR_OK) {\n                goto error;\n            }\n        }\n    }\n\n    if (r_size > 0) {\n        if (!prealloc) {\n            if (uc_mem_map(uc, chunk_end, r_size, perms) != UC_ERR_OK) {\n                goto error;\n            }\n            if (uc_mem_write(uc, chunk_end, backup + l_size + m_size, r_size) !=\n                UC_ERR_OK) {\n                goto error;\n            }\n        } else {\n            if (uc_mem_map_ptr(uc, chunk_end, r_size, perms,\n                               backup + l_size + m_size) != UC_ERR_OK) {\n                goto error;\n            }\n        }\n    }\n\n    if (!prealloc) {\n        free(backup);\n    }\n    return true;\n\nerror:\n    if (!prealloc) {\n        free(backup);\n    }\n    return false;\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_protect(struct uc_struct *uc, uint64_t address, size_t size,\n                      uint32_t perms)\n{\n    MemoryRegion *mr;\n    uint64_t addr = address;\n    size_t count, len;\n    bool remove_exec = false;\n\n    UC_INIT(uc);\n\n    if (size == 0) {\n        // trivial case, no change\n        return UC_ERR_OK;\n    }\n\n    // address must be aligned to uc->target_page_size\n    if ((address & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // size must be multiple of uc->target_page_size\n    if ((size & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // check for only valid permissions\n    if ((perms & ~UC_PROT_ALL) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    // check that user's entire requested block is mapped\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_NOMEM;\n    }\n\n    // Now we know entire region is mapped, so change permissions\n    // We may need to split regions if this area spans adjacent regions\n    addr = address;\n    count = 0;\n    while (count < size) {\n        mr = memory_mapping(uc, addr);\n        len = (size_t)MIN(size - count, mr->end - addr);\n        if (!split_region(uc, mr, addr, len, false)) {\n            return UC_ERR_NOMEM;\n        }\n\n        mr = memory_mapping(uc, addr);\n        // will this remove EXEC permission?\n        if (((mr->perms & UC_PROT_EXEC) != 0) &&\n            ((perms & UC_PROT_EXEC) == 0)) {\n            remove_exec = true;\n        }\n        mr->perms = perms;\n        uc->readonly_mem(mr, (perms & UC_PROT_WRITE) == 0);\n\n        count += len;\n        addr += len;\n    }\n\n    // if EXEC permission is removed, then quit TB and continue at the same\n    // place\n    if (remove_exec) {\n        uc->quit_request = true;\n        uc_emu_stop(uc);\n    }\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_unmap(struct uc_struct *uc, uint64_t address, size_t size)\n{\n    MemoryRegion *mr;\n    uint64_t addr;\n    size_t count, len;\n\n    UC_INIT(uc);\n\n    if (size == 0) {\n        // nothing to unmap\n        return UC_ERR_OK;\n    }\n\n    // address must be aligned to uc->target_page_size\n    if ((address & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    // size must be multiple of uc->target_page_size\n    if ((size & uc->target_page_align) != 0) {\n        return UC_ERR_ARG;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    // check that user's entire requested block is mapped\n    if (!check_mem_area(uc, address, size)) {\n        return UC_ERR_NOMEM;\n    }\n\n    // Now we know entire region is mapped, so do the unmap\n    // We may need to split regions if this area spans adjacent regions\n    addr = address;\n    count = 0;\n    while (count < size) {\n        mr = memory_mapping(uc, addr);\n        len = (size_t)MIN(size - count, mr->end - addr);\n        if (!split_region(uc, mr, addr, len, true)) {\n            return UC_ERR_NOMEM;\n        }\n\n        // if we can retrieve the mapping, then no splitting took place\n        // so unmap here\n        mr = memory_mapping(uc, addr);\n        if (mr != NULL) {\n            uc->memory_unmap(uc, mr);\n        }\n        count += len;\n        addr += len;\n    }\n\n    return UC_ERR_OK;\n}\n\n// find the memory region of this address\nMemoryRegion *memory_mapping(struct uc_struct *uc, uint64_t address)\n{\n    unsigned int i;\n\n    if (uc->mapped_block_count == 0) {\n        return NULL;\n    }\n\n    if (uc->mem_redirect) {\n        address = uc->mem_redirect(address);\n    }\n\n    // try with the cache index first\n    i = uc->mapped_block_cache_index;\n\n    if (i < uc->mapped_block_count && address >= uc->mapped_blocks[i]->addr &&\n        address < uc->mapped_blocks[i]->end) {\n        return uc->mapped_blocks[i];\n    }\n\n    i = bsearch_mapped_blocks(uc, address);\n\n    if (i < uc->mapped_block_count && address >= uc->mapped_blocks[i]->addr &&\n        address <= uc->mapped_blocks[i]->end - 1)\n        return uc->mapped_blocks[i];\n\n    // not found\n    return NULL;\n}\n\nUNICORN_EXPORT\nuc_err uc_hook_add(uc_engine *uc, uc_hook *hh, int type, void *callback,\n                   void *user_data, uint64_t begin, uint64_t end, ...)\n{\n    int ret = UC_ERR_OK;\n    int i = 0;\n\n    UC_INIT(uc);\n\n    struct hook *hook = calloc(1, sizeof(struct hook));\n    if (hook == NULL) {\n        return UC_ERR_NOMEM;\n    }\n\n    hook->begin = begin;\n    hook->end = end;\n    hook->type = type;\n    hook->callback = callback;\n    hook->user_data = user_data;\n    hook->refs = 0;\n    hook->to_delete = false;\n    *hh = (uc_hook)hook;\n\n    // UC_HOOK_INSN has an extra argument for instruction ID\n    if (type & UC_HOOK_INSN) {\n        va_list valist;\n\n        va_start(valist, end);\n        hook->insn = va_arg(valist, int);\n        va_end(valist);\n\n        if (uc->insn_hook_validate) {\n            if (!uc->insn_hook_validate(hook->insn)) {\n                free(hook);\n                return UC_ERR_HOOK;\n            }\n        }\n\n        if (uc->hook_insert) {\n            if (list_insert(&uc->hook[UC_HOOK_INSN_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        } else {\n            if (list_append(&uc->hook[UC_HOOK_INSN_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        }\n\n        uc->hooks_count[UC_HOOK_INSN_IDX]++;\n        hook->refs++;\n        return UC_ERR_OK;\n    }\n\n    if (type & UC_HOOK_TCG_OPCODE) {\n        va_list valist;\n\n        va_start(valist, end);\n        hook->op = va_arg(valist, int);\n        hook->op_flags = va_arg(valist, int);\n        va_end(valist);\n\n        if (uc->opcode_hook_invalidate) {\n            if (!uc->opcode_hook_invalidate(hook->op, hook->op_flags)) {\n                free(hook);\n                return UC_ERR_HOOK;\n            }\n        }\n\n        if (uc->hook_insert) {\n            if (list_insert(&uc->hook[UC_HOOK_TCG_OPCODE_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        } else {\n            if (list_append(&uc->hook[UC_HOOK_TCG_OPCODE_IDX], hook) == NULL) {\n                free(hook);\n                return UC_ERR_NOMEM;\n            }\n        }\n\n        uc->hooks_count[UC_HOOK_TCG_OPCODE_IDX]++;\n        hook->refs++;\n        return UC_ERR_OK;\n    }\n\n    while ((type >> i) > 0) {\n        if ((type >> i) & 1) {\n            // TODO: invalid hook error?\n            if (i < UC_HOOK_MAX) {\n                if (uc->hook_insert) {\n                    if (list_insert(&uc->hook[i], hook) == NULL) {\n                        if (hook->refs == 0) {\n                            free(hook);\n                        }\n                        return UC_ERR_NOMEM;\n                    }\n                } else {\n                    if (list_append(&uc->hook[i], hook) == NULL) {\n                        if (hook->refs == 0) {\n                            free(hook);\n                        }\n                        return UC_ERR_NOMEM;\n                    }\n                }\n                uc->hooks_count[i]++;\n                hook->refs++;\n            }\n        }\n        i++;\n    }\n\n    // we didn't use the hook\n    // TODO: return an error?\n    if (hook->refs == 0) {\n        free(hook);\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_hook_del(uc_engine *uc, uc_hook hh)\n{\n    int i;\n    struct hook *hook = (struct hook *)hh;\n\n    UC_INIT(uc);\n\n    // we can't dereference hook->type if hook is invalid\n    // so for now we need to iterate over all possible types to remove the hook\n    // which is less efficient\n    // an optimization would be to align the hook pointer\n    // and store the type mask in the hook pointer.\n    for (i = 0; i < UC_HOOK_MAX; i++) {\n        if (list_exists(&uc->hook[i], (void *)hook)) {\n            hook->to_delete = true;\n            uc->hooks_count[i]--;\n            list_append(&uc->hooks_to_del, hook);\n        }\n    }\n\n    return UC_ERR_OK;\n}\n\n// TCG helper\n// 2 arguments are enough for most opcodes. Load/Store needs 3 arguments but we\n// have memory hooks already. We may exceed the maximum arguments of a tcg\n// helper but that's easy to extend.\nvoid helper_uc_traceopcode(struct hook *hook, uint64_t arg1, uint64_t arg2,\n                           uint32_t size, void *handle, uint64_t address);\nvoid helper_uc_traceopcode(struct hook *hook, uint64_t arg1, uint64_t arg2,\n                           uint32_t size, void *handle, uint64_t address)\n{\n    struct uc_struct *uc = handle;\n\n    if (unlikely(uc->stop_request)) {\n        return;\n    }\n\n    if (unlikely(hook->to_delete)) {\n        return;\n    }\n\n    // We did all checks in translation time.\n    //\n    // This could optimize the case that we have multiple hooks with different\n    // opcodes and have one callback per opcode. Note that the assumption don't\n    // hold in most cases for uc_tracecode.\n    //\n    // TODO: Shall we have a flag to allow users to control whether updating PC?\n    ((uc_hook_tcg_op_2)hook->callback)(uc, address, arg1, arg2, size,\n                                       hook->user_data);\n\n    if (unlikely(uc->stop_request)) {\n        return;\n    }\n}\n\nvoid helper_uc_tracecode(int32_t size, uc_hook_idx index, void *handle,\n                         int64_t address);\nvoid helper_uc_tracecode(int32_t size, uc_hook_idx index, void *handle,\n                         int64_t address)\n{\n    struct uc_struct *uc = handle;\n    struct list_item *cur;\n    struct hook *hook;\n    int hook_flags =\n        index &\n        UC_HOOK_FLAG_MASK; // The index here may contain additional flags. See\n                           // the comments of uc_hook_idx for details.\n\n    index = index & UC_HOOK_IDX_MASK;\n\n    // This has been done in tcg code.\n    // sync PC in CPUArchState with address\n    // if (uc->set_pc) {\n    //     uc->set_pc(uc, address);\n    // }\n\n    // the last callback may already asked to stop emulation\n    if (uc->stop_request && !(hook_flags & UC_HOOK_FLAG_NO_STOP)) {\n        return;\n    }\n\n    for (cur = uc->hook[index].head;\n         cur != NULL && (hook = (struct hook *)cur->data); cur = cur->next) {\n        if (hook->to_delete) {\n            continue;\n        }\n\n        // on invalid block/instruction, call instruction counter (if enable),\n        // then quit\n        if (size == 0) {\n            if (index == UC_HOOK_CODE_IDX && uc->count_hook) {\n                // this is the instruction counter (first hook in the list)\n                ((uc_cb_hookcode_t)hook->callback)(uc, address, size,\n                                                   hook->user_data);\n            }\n\n            return;\n        }\n\n        if (HOOK_BOUND_CHECK(hook, (uint64_t)address)) {\n            ((uc_cb_hookcode_t)hook->callback)(uc, address, size,\n                                               hook->user_data);\n        }\n\n        // the last callback may already asked to stop emulation\n        // Unicorn:\n        //   In an ARM IT block, we behave like the emulation continues\n        //   normally. No check_exit_request is generated and the hooks are\n        //   triggered normally. In other words, the whole IT block is treated\n        //   as a single instruction.\n        if (uc->stop_request && !(hook_flags & UC_HOOK_FLAG_NO_STOP)) {\n            break;\n        }\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_mem_regions(uc_engine *uc, uc_mem_region **regions, uint32_t *count)\n{\n    uint32_t i;\n    uc_mem_region *r = NULL;\n\n    UC_INIT(uc);\n\n    *count = uc->mapped_block_count;\n\n    if (*count) {\n        r = g_malloc0(*count * sizeof(uc_mem_region));\n        if (r == NULL) {\n            // out of memory\n            return UC_ERR_NOMEM;\n        }\n    }\n\n    for (i = 0; i < *count; i++) {\n        r[i].begin = uc->mapped_blocks[i]->addr;\n        r[i].end = uc->mapped_blocks[i]->end - 1;\n        r[i].perms = uc->mapped_blocks[i]->perms;\n    }\n\n    *regions = r;\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_query(uc_engine *uc, uc_query_type type, size_t *result)\n{\n    UC_INIT(uc);\n\n    switch (type) {\n    default:\n        return UC_ERR_ARG;\n\n    case UC_QUERY_PAGE_SIZE:\n        *result = uc->target_page_size;\n        break;\n\n    case UC_QUERY_ARCH:\n        *result = uc->arch;\n        break;\n\n    case UC_QUERY_MODE:\n#ifdef UNICORN_HAS_ARM\n        if (uc->arch == UC_ARCH_ARM) {\n            return uc->query(uc, type, result);\n        }\n#endif\n        *result = uc->mode;\n        break;\n\n    case UC_QUERY_TIMEOUT:\n        *result = uc->timed_out;\n        break;\n    }\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_alloc(uc_engine *uc, uc_context **context)\n{\n    struct uc_context **_context = context;\n    size_t size = uc_context_size(uc);\n\n    UC_INIT(uc);\n\n    *_context = g_malloc(size);\n    if (*_context) {\n        (*_context)->context_size = uc->cpu_context_size;\n        (*_context)->arch = uc->arch;\n        (*_context)->mode = uc->mode;\n        return UC_ERR_OK;\n    } else {\n        return UC_ERR_NOMEM;\n    }\n}\n\nUNICORN_EXPORT\nuc_err uc_free(void *mem)\n{\n    g_free(mem);\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nsize_t uc_context_size(uc_engine *uc)\n{\n    UC_INIT(uc);\n    // return the total size of struct uc_context\n    return sizeof(uc_context) + uc->cpu_context_size;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_save(uc_engine *uc, uc_context *context)\n{\n    UC_INIT(uc);\n\n    memcpy(context->data, uc->cpu->env_ptr, context->context_size);\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_write(uc_context *ctx, int regid, const void *value)\n{\n    return uc_context_reg_write_batch(ctx, &regid, (void *const *)&value, 1);\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_read(uc_context *ctx, int regid, void *value)\n{\n    return uc_context_reg_read_batch(ctx, &regid, &value, 1);\n}\n\n// Keep in mind that we don't a uc_engine when r/w the registers of a context.\nstatic void find_context_reg_rw_function(uc_arch arch, uc_mode mode,\n                                         context_reg_rw_t *rw)\n{\n    // We believe that the arch/mode pair is correct.\n    switch (arch) {\n    default:\n        rw->context_reg_read = NULL;\n        rw->context_reg_write = NULL;\n        break;\n#ifdef UNICORN_HAS_M68K\n    case UC_ARCH_M68K:\n        rw->context_reg_read = m68k_context_reg_read;\n        rw->context_reg_write = m68k_context_reg_write;\n        break;\n#endif\n#ifdef UNICORN_HAS_X86\n    case UC_ARCH_X86:\n        rw->context_reg_read = x86_context_reg_read;\n        rw->context_reg_write = x86_context_reg_write;\n        break;\n#endif\n#ifdef UNICORN_HAS_ARM\n    case UC_ARCH_ARM:\n        if (mode & UC_MODE_BIG_ENDIAN) {\n            rw->context_reg_read = armeb_context_reg_read;\n            rw->context_reg_write = armeb_context_reg_write;\n        } else {\n            rw->context_reg_read = arm_context_reg_read;\n            rw->context_reg_write = arm_context_reg_write;\n        }\n#endif\n#ifdef UNICORN_HAS_ARM64\n    case UC_ARCH_ARM64:\n        if (mode & UC_MODE_BIG_ENDIAN) {\n            rw->context_reg_read = arm64eb_context_reg_read;\n            rw->context_reg_write = arm64eb_context_reg_write;\n        } else {\n            rw->context_reg_read = arm64_context_reg_read;\n            rw->context_reg_write = arm64_context_reg_write;\n        }\n        break;\n#endif\n\n#if defined(UNICORN_HAS_MIPS) || defined(UNICORN_HAS_MIPSEL) ||                \\\n    defined(UNICORN_HAS_MIPS64) || defined(UNICORN_HAS_MIPS64EL)\n    case UC_ARCH_MIPS:\n        if (mode & UC_MODE_BIG_ENDIAN) {\n#ifdef UNICORN_HAS_MIPS\n            if (mode & UC_MODE_MIPS32) {\n                rw->context_reg_read = mips_context_reg_read;\n                rw->context_reg_write = mips_context_reg_write;\n            }\n#endif\n#ifdef UNICORN_HAS_MIPS64\n            if (mode & UC_MODE_MIPS64) {\n                rw->context_reg_read = mips64_context_reg_read;\n                rw->context_reg_write = mips64_context_reg_write;\n            }\n#endif\n        } else { // little endian\n#ifdef UNICORN_HAS_MIPSEL\n            if (mode & UC_MODE_MIPS32) {\n                rw->context_reg_read = mipsel_context_reg_read;\n                rw->context_reg_write = mipsel_context_reg_write;\n            }\n#endif\n#ifdef UNICORN_HAS_MIPS64EL\n            if (mode & UC_MODE_MIPS64) {\n                rw->context_reg_read = mips64el_context_reg_read;\n                rw->context_reg_write = mips64el_context_reg_write;\n            }\n#endif\n        }\n        break;\n#endif\n\n#ifdef UNICORN_HAS_SPARC\n    case UC_ARCH_SPARC:\n        if (mode & UC_MODE_SPARC64) {\n            rw->context_reg_read = sparc64_context_reg_read;\n            rw->context_reg_write = sparc64_context_reg_write;\n        } else {\n            rw->context_reg_read = sparc_context_reg_read;\n            rw->context_reg_write = sparc_context_reg_write;\n        }\n        break;\n#endif\n#ifdef UNICORN_HAS_PPC\n    case UC_ARCH_PPC:\n        if (mode & UC_MODE_PPC64) {\n            rw->context_reg_read = ppc64_context_reg_read;\n            rw->context_reg_write = ppc64_context_reg_write;\n        } else {\n            rw->context_reg_read = ppc_context_reg_read;\n            rw->context_reg_write = ppc_context_reg_write;\n        }\n        break;\n#endif\n#ifdef UNICORN_HAS_RISCV\n    case UC_ARCH_RISCV:\n        if (mode & UC_MODE_RISCV32) {\n            rw->context_reg_read = riscv32_context_reg_read;\n            rw->context_reg_write = riscv32_context_reg_write;\n        } else if (mode & UC_MODE_RISCV64) {\n            rw->context_reg_read = riscv64_context_reg_read;\n            rw->context_reg_write = riscv64_context_reg_write;\n        }\n        break;\n#endif\n    }\n\n    return;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_write_batch(uc_context *ctx, int *ids, void *const *vals,\n                                  int count)\n{\n    int ret = UC_ERR_OK;\n    context_reg_rw_t rw;\n\n    find_context_reg_rw_function(ctx->arch, ctx->mode, &rw);\n    if (rw.context_reg_write) {\n        ret = rw.context_reg_write(ctx, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_reg_read_batch(uc_context *ctx, int *ids, void **vals,\n                                 int count)\n{\n    int ret = UC_ERR_OK;\n    context_reg_rw_t rw;\n\n    find_context_reg_rw_function(ctx->arch, ctx->mode, &rw);\n    if (rw.context_reg_read) {\n        ret = rw.context_reg_read(ctx, (unsigned int *)ids, vals, count);\n    } else {\n        return UC_ERR_HANDLE;\n    }\n\n    return ret;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_restore(uc_engine *uc, uc_context *context)\n{\n    UC_INIT(uc);\n\n    memcpy(uc->cpu->env_ptr, context->data, context->context_size);\n\n    return UC_ERR_OK;\n}\n\nUNICORN_EXPORT\nuc_err uc_context_free(uc_context *context)\n{\n\n    return uc_free(context);\n}\n\ntypedef struct _uc_ctl_exit_request {\n    uint64_t *array;\n    size_t len;\n} uc_ctl_exit_request;\n\nstatic inline gboolean uc_read_exit_iter(gpointer key, gpointer val,\n                                         gpointer data)\n{\n    uc_ctl_exit_request *req = (uc_ctl_exit_request *)data;\n\n    req->array[req->len++] = *(uint64_t *)key;\n\n    return false;\n}\n\nUNICORN_EXPORT\nuc_err uc_ctl(uc_engine *uc, uc_control_type control, ...)\n{\n    int rw, type;\n    uc_err err = UC_ERR_OK;\n    va_list args;\n\n    // MSVC Would do signed shift on signed integers.\n    rw = (uint32_t)control >> 30;\n    type = (control & ((1 << 16) - 1));\n    va_start(args, control);\n\n    switch (type) {\n    case UC_CTL_UC_MODE: {\n        if (rw == UC_CTL_IO_READ) {\n            int *pmode = va_arg(args, int *);\n            *pmode = uc->mode;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_ARCH: {\n        if (rw == UC_CTL_IO_READ) {\n            int *arch = va_arg(args, int *);\n            *arch = uc->arch;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_TIMEOUT: {\n        if (rw == UC_CTL_IO_READ) {\n            uint64_t *arch = va_arg(args, uint64_t *);\n            *arch = uc->timeout;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_PAGE_SIZE: {\n        if (rw == UC_CTL_IO_READ) {\n\n            UC_INIT(uc);\n\n            uint32_t *page_size = va_arg(args, uint32_t *);\n            *page_size = uc->target_page_size;\n        } else {\n            uint32_t page_size = va_arg(args, uint32_t);\n            int bits = 0;\n\n            if (uc->init_done) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            if (uc->arch != UC_ARCH_ARM) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            if ((page_size & (page_size - 1))) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            while (page_size) {\n                bits++;\n                page_size >>= 1;\n            }\n\n            uc->target_bits = bits;\n\n            err = UC_ERR_OK;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_USE_EXITS: {\n        if (rw == UC_CTL_IO_WRITE) {\n            int use_exits = va_arg(args, int);\n            uc->use_exits = use_exits;\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_EXITS_CNT: {\n\n        UC_INIT(uc);\n\n        if (!uc->use_exits) {\n            err = UC_ERR_ARG;\n        } else if (rw == UC_CTL_IO_READ) {\n            size_t *exits_cnt = va_arg(args, size_t *);\n            *exits_cnt = g_tree_nnodes(uc->exits);\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_UC_EXITS: {\n\n        UC_INIT(uc);\n\n        if (!uc->use_exits) {\n            err = UC_ERR_ARG;\n        } else if (rw == UC_CTL_IO_READ) {\n            uint64_t *exits = va_arg(args, uint64_t *);\n            size_t cnt = va_arg(args, size_t);\n            if (cnt < g_tree_nnodes(uc->exits)) {\n                err = UC_ERR_ARG;\n            } else {\n                uc_ctl_exit_request req;\n                req.array = exits;\n                req.len = 0;\n\n                g_tree_foreach(uc->exits, uc_read_exit_iter, (void *)&req);\n            }\n        } else if (rw == UC_CTL_IO_WRITE) {\n            uint64_t *exits = va_arg(args, uint64_t *);\n            size_t cnt = va_arg(args, size_t);\n\n            g_tree_remove_all(uc->exits);\n\n            for (size_t i = 0; i < cnt; i++) {\n                uc_add_exit(uc, exits[i]);\n            }\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_CPU_MODEL: {\n        if (rw == UC_CTL_IO_READ) {\n\n            UC_INIT(uc);\n\n            int *model = va_arg(args, int *);\n            *model = uc->cpu_model;\n        } else {\n            int model = va_arg(args, int);\n\n            if (uc->init_done) {\n                err = UC_ERR_ARG;\n                break;\n            }\n\n            uc->cpu_model = model;\n\n            err = UC_ERR_OK;\n        }\n        break;\n    }\n\n    case UC_CTL_TB_REQUEST_CACHE: {\n\n        UC_INIT(uc);\n\n        if (rw == UC_CTL_IO_READ_WRITE) {\n            uint64_t addr = va_arg(args, uint64_t);\n            uc_tb *tb = va_arg(args, uc_tb *);\n            err = uc->uc_gen_tb(uc, addr, tb);\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    case UC_CTL_TB_REMOVE_CACHE: {\n\n        UC_INIT(uc);\n\n        if (rw == UC_CTL_IO_WRITE) {\n            uint64_t addr = va_arg(args, uint64_t);\n            uint64_t end = va_arg(args, uint64_t);\n            if (end <= addr) {\n                err = UC_ERR_ARG;\n            } else {\n                uc->uc_invalidate_tb(uc, addr, end - addr);\n            }\n        } else {\n            err = UC_ERR_ARG;\n        }\n        break;\n    }\n\n    default:\n        err = UC_ERR_ARG;\n        break;\n    }\n\n    va_end(args);\n\n    return err;\n}\n"], "filenames": ["qemu/accel/tcg/translate-all.c", "uc.c"], "buggy_code_start_loc": [988, 1093], "buggy_code_end_loc": [989, 1094], "fixing_code_start_loc": [988, 1093], "fixing_code_end_loc": [991, 1095], "type": "CWE-697", "message": "An issue was discovered in split_region in uc.c in Unicorn Engine before 2.0.0-rc5. It allows local attackers to escape the sandbox. An attacker must first obtain the ability to execute crafted code in the target sandbox in order to exploit this vulnerability. The specific flaw exists within the virtual memory manager. The issue results from the faulty comparison of GVA and GPA while calling uc_mem_map_ptr to free part of a claimed memory block. An attacker can leverage this vulnerability to escape the sandbox and execute arbitrary code on the host machine.", "other": {"cve": {"id": "CVE-2021-44078", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-26T05:15:07.270", "lastModified": "2022-01-07T18:29:48.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in split_region in uc.c in Unicorn Engine before 2.0.0-rc5. It allows local attackers to escape the sandbox. An attacker must first obtain the ability to execute crafted code in the target sandbox in order to exploit this vulnerability. The specific flaw exists within the virtual memory manager. The issue results from the faulty comparison of GVA and GPA while calling uc_mem_map_ptr to free part of a claimed memory block. An attacker can leverage this vulnerability to escape the sandbox and execute arbitrary code on the host machine."}, {"lang": "es", "value": "Se ha detectado un problema en la funci\u00f3n split_region en el archivo uc.c en Unicorn Engine versiones anteriores a 2.0.0-rc5. Permite a atacantes locales escapar del sandbox. Un atacante debe obtener primero la capacidad de ejecutar c\u00f3digo dise\u00f1ado en el sandbox de destino para poder explotar esta vulnerabilidad. El fallo espec\u00edfico se presenta en el administrador de memoria virtual. El problema resulta de la comparaci\u00f3n defectuosa de GVA y GPA mientras es llamado a uc_mem_map_ptr para liberar parte de un bloque de memoria reclamado. Un atacante puede aprovechar esta vulnerabilidad para escapar del sandbox y ejecutar c\u00f3digo arbitrario en la m\u00e1quina anfitriona"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-697"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unicorn-engine:unicorn_engine:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.3", "matchCriteriaId": "C41772E7-3BEF-495D-8CA8-02F494D9AF3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unicorn-engine:unicorn_engine:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "54D5A177-A072-4A7F-9C0A-57545CC04FDD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unicorn-engine:unicorn_engine:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B3D6EED4-B4EE-4486-A0FA-6932A27179F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unicorn-engine:unicorn_engine:2.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "2401D8B7-59B6-4FEC-8E1C-4D61FC5861C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unicorn-engine:unicorn_engine:2.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "564B499B-2038-4FBE-B503-1200E10D2DAC"}]}]}], "references": [{"url": "https://gist.github.com/jwang-a/cb4b6e9551457aa299066076b836a2cd", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/jwang-a/CTF/blob/master/MyChallenges/Pwn/Unicorns_Aisle/UnicornsAisle.pdf", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/unicorn-engine/unicorn/commit/c733bbada356b0373fa8aa72c044574bb855fd24", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/unicorn-engine/unicorn/compare/2.0.0-rc4...2.0.0-rc5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.unicorn-engine.org/changelog/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/unicorn-engine/unicorn/commit/c733bbada356b0373fa8aa72c044574bb855fd24"}}