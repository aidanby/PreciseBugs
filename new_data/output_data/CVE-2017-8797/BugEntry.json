{"buggy_code": ["/*\n *  Server-side procedures for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include <linux/file.h>\n#include <linux/falloc.h>\n#include <linux/slab.h>\n\n#include \"idmap.h\"\n#include \"cache.h\"\n#include \"xdr4.h\"\n#include \"vfs.h\"\n#include \"current_stateid.h\"\n#include \"netns.h\"\n#include \"acl.h\"\n#include \"pnfs.h\"\n#include \"trace.h\"\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n#include <linux/security.h>\n\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{\n\tstruct inode *inode = d_inode(resfh->fh_dentry);\n\tint status;\n\n\tinode_lock(inode);\n\tstatus = security_inode_setsecctx(resfh->fh_dentry,\n\t\tlabel->data, label->len);\n\tinode_unlock(inode);\n\n\tif (status)\n\t\t/*\n\t\t * XXX: We should really fail the whole open, but we may\n\t\t * already have created a new file, so it may be too\n\t\t * late.  For now this seems the least of evils:\n\t\t */\n\t\tbmval[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\treturn;\n}\n#else\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }\n#endif\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_PROC\n\nstatic u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};\n\nstatic u32 nfsd41_ex_attrmask[] = {\n\tNFSD_SUPPATTR_EXCLCREAT_WORD0,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD1,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD2\n};\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\tstruct svc_export *exp = cstate->current_fh.fh_export;\n\n\tif (!nfsd_attrs_supported(cstate->minorversion, bmval))\n\t\treturn nfserr_attrnotsupp;\n\tif ((bmval[0] & FATTR4_WORD0_ACL) && !IS_POSIXACL(d_inode(dentry)))\n\t\treturn nfserr_attrnotsupp;\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) &&\n\t\t\t!(exp->ex_flags & NFSEXP_SECURITY_LABEL))\n\t\treturn nfserr_attrnotsupp;\n\tif (writable && !bmval_is_subset(bmval, writable))\n\t\treturn nfserr_inval;\n\tif (writable && (bmval[2] & FATTR4_WORD2_MODE_UMASK) &&\n\t\t\t(bmval[1] & FATTR4_WORD1_MODE))\n\t\treturn nfserr_inval;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}\n\nstatic int\nis_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}\n\n/*\n * if error occurs when setting the acl, just clear the acl bit\n * in the returned attr bitmap.\n */\nstatic void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}\n\nstatic __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}\n\nstatic __be32 nfsd_check_obj_isreg(struct svc_fh *fh)\n{\n\tumode_t mode = d_inode(fh->fh_dentry)->i_mode;\n\n\tif (S_ISREG(mode))\n\t\treturn nfs_ok;\n\tif (S_ISDIR(mode))\n\t\treturn nfserr_isdir;\n\t/*\n\t * Using err_symlink as our catch-all case may look odd; but\n\t * there's no other obvious error for this case in 4.0, and we\n\t * happen to know that it will cause the linux v4 client to do\n\t * the right thing on attempts to open something other than a\n\t * regular file.\n\t */\n\treturn nfserr_symlink;\n}\n\nstatic void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}\n\nstatic __be32\ndo_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh **resfh)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode;\n\t__be32 status;\n\n\t*resfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\tif (!*resfh)\n\t\treturn nfserr_jukebox;\n\tfh_init(*resfh, NFS4_FHSIZE);\n\topen->op_truncate = 0;\n\n\tif (open->op_create) {\n\t\t/* FIXME: check session persistence and pnfs flags.\n\t\t * The nfsv4.1 spec requires the following semantics:\n\t\t *\n\t\t * Persistent   | pNFS   | Server REQUIRED | Client Allowed\n\t\t * Reply Cache  | server |                 |\n\t\t * -------------+--------+-----------------+--------------------\n\t\t * no           | no     | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t *              |        |                 | (SHOULD)\n\t\t *              |        | and EXCLUSIVE4  | or EXCLUSIVE4\n\t\t *              |        |                 | (SHOULD NOT)\n\t\t * no           | yes    | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t * yes          | no     | GUARDED4        | GUARDED4\n\t\t * yes          | yes    | GUARDED4        | GUARDED4\n\t\t */\n\n\t\t/*\n\t\t * Note: create modes (UNCHECKED,GUARDED...) are the same\n\t\t * in NFSv4 as in v3 except EXCLUSIVE4_1.\n\t\t */\n\t\tstatus = do_nfsd_create(rqstp, current_fh, open->op_fname.data,\n\t\t\t\t\topen->op_fname.len, &open->op_iattr,\n\t\t\t\t\t*resfh, open->op_createmode,\n\t\t\t\t\t(u32 *)open->op_verf.data,\n\t\t\t\t\t&open->op_truncate, &open->op_created);\n\n\t\tif (!status && open->op_label.len)\n\t\t\tnfsd4_security_inode_setsecctx(*resfh, &open->op_label, open->op_bmval);\n\n\t\t/*\n\t\t * Following rfc 3530 14.2.16, and rfc 5661 18.16.4\n\t\t * use the returned bitmask to indicate which attributes\n\t\t * we used to store the verifier:\n\t\t */\n\t\tif (nfsd_create_is_exclusive(open->op_createmode) && status == 0)\n\t\t\topen->op_bmval[1] |= (FATTR4_WORD1_TIME_ACCESS |\n\t\t\t\t\t\tFATTR4_WORD1_TIME_MODIFY);\n\t} else\n\t\t/*\n\t\t * Note this may exit with the parent still locked.\n\t\t * We will hold the lock until nfsd4_open's final\n\t\t * lookup, to prevent renames or unlinks until we've had\n\t\t * a chance to an acquire a delegation if appropriate.\n\t\t */\n\t\tstatus = nfsd_lookup(rqstp, current_fh,\n\t\t\t\t     open->op_fname.data, open->op_fname.len, *resfh);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_check_obj_isreg(*resfh);\n\tif (status)\n\t\tgoto out;\n\n\tif (is_create_with_attrs(open) && open->op_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, *resfh, open->op_acl, open->op_bmval);\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, *resfh);\n\taccmode = NFSD_MAY_NOP;\n\tif (open->op_created ||\n\t\t\topen->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR)\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\tstatus = do_open_permission(rqstp, *resfh, open, accmode);\n\tset_change_info(&open->op_cinfo, current_fh);\nout:\n\treturn status;\n}\n\nstatic __be32\ndo_open_fhandle(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 status;\n\tint accmode = 0;\n\n\t/* We don't know the target directory, and therefore can not\n\t* set the change info\n\t*/\n\n\tmemset(&open->op_cinfo, 0, sizeof(struct nfsd4_change_info));\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, current_fh);\n\n\topen->op_truncate = (open->op_iattr.ia_valid & ATTR_SIZE) &&\n\t\t(open->op_iattr.ia_size == 0);\n\t/*\n\t * In the delegation case, the client is telling us about an\n\t * open that it *already* performed locally, some time ago.  We\n\t * should let it succeed now if possible.\n\t *\n\t * In the case of a CLAIM_FH open, on the other hand, the client\n\t * may be counting on us to enforce permissions (the Linux 4.1\n\t * client uses this for normal opens, for example).\n\t */\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH)\n\t\taccmode = NFSD_MAY_OWNER_OVERRIDE;\n\n\tstatus = do_open_permission(rqstp, current_fh, open, accmode);\n\n\treturn status;\n}\n\nstatic void\ncopy_clientid(clientid_t *clid, struct nfsd4_session *session)\n{\n\tstruct nfsd4_sessionid *sid =\n\t\t\t(struct nfsd4_sessionid *)session->se_sessionid.data;\n\n\tclid->cl_boot = sid->clientid.cl_boot;\n\tclid->cl_id = sid->clientid.cl_id;\n}\n\nstatic __be32\nnfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_open *open)\n{\n\t__be32 status;\n\tstruct svc_fh *resfh = NULL;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open filename %.*s op_openowner %p\\n\",\n\t\t(int)open->op_fname.len, open->op_fname.data,\n\t\topen->op_openowner);\n\n\t/* This check required by spec. */\n\tif (open->op_create && open->op_claim_type != NFS4_OPEN_CLAIM_NULL)\n\t\treturn nfserr_inval;\n\n\topen->op_created = 0;\n\t/*\n\t * RFC5661 18.51.3\n\t * Before RECLAIM_COMPLETE done, server should deny new lock\n\t */\n\tif (nfsd4_has_session(cstate) &&\n\t    !test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t      &cstate->session->se_client->cl_flags) &&\n\t    open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn nfserr_grace;\n\n\tif (nfsd4_has_session(cstate))\n\t\tcopy_clientid(&open->op_clientid, cstate->session);\n\n\t/* check seqid for replay. set nfs4_owner */\n\tstatus = nfsd4_process_open1(cstate, open, nn);\n\tif (status == nfserr_replay_me) {\n\t\tstruct nfs4_replay *rp = &open->op_openowner->oo_owner.so_replay;\n\t\tfh_put(&cstate->current_fh);\n\t\tfh_copy_shallow(&cstate->current_fh.fh_handle,\n\t\t\t\t&rp->rp_openfh);\n\t\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\t\tif (status)\n\t\t\tdprintk(\"nfsd4_open: replay failed\"\n\t\t\t\t\" restoring previous filehandle\\n\");\n\t\telse\n\t\t\tstatus = nfserr_replay_me;\n\t}\n\tif (status)\n\t\tgoto out;\n\tif (open->op_xdr_error) {\n\t\tstatus = open->op_xdr_error;\n\t\tgoto out;\n\t}\n\n\tstatus = nfsd4_check_open_attributes(rqstp, cstate, open);\n\tif (status)\n\t\tgoto out;\n\n\t/* Openowner is now set, so sequence id will get bumped.  Now we need\n\t * these checks before we do any creates: */\n\tstatus = nfserr_grace;\n\tif (opens_in_grace(net) && open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!opens_in_grace(net) && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\t\tstatus = do_open_lookup(rqstp, cstate, open, &resfh);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tstatus = nfs4_check_open_reclaim(&open->op_clientid,\n\t\t\t\t\t\t\t cstate, nn);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\t\tstatus = do_open_fhandle(rqstp, cstate, open);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tresfh = &cstate->current_fh;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n             \tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\t\tdprintk(\"NFSD: unsupported OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_notsupp;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: Invalid OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out;\n\t}\n\t/*\n\t * nfsd4_process_open2() does the actual opening of the file.  If\n\t * successful, it (1) truncates the file if open->op_truncate was\n\t * set, (2) sets open->op_stateid, (3) sets open->op_delegation.\n\t */\n\tstatus = nfsd4_process_open2(rqstp, resfh, open);\n\tWARN(status && open->op_created,\n\t     \"nfsd4_process_open2 failed to open newly-created file! status=%u\\n\",\n\t     be32_to_cpu(status));\nout:\n\tif (resfh && resfh != &cstate->current_fh) {\n\t\tfh_dup2(&cstate->current_fh, resfh);\n\t\tfh_put(resfh);\n\t\tkfree(resfh);\n\t}\n\tnfsd4_cleanup_open_state(cstate, open);\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}\n\n/*\n * OPEN is the only seqid-mutating operation whose decoding can fail\n * with a seqid-mutating error (specifically, decoding of user names in\n * the attributes).  Therefore we have to do some processing to look up\n * the stateowner so that we can bump the seqid.\n */\nstatic __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = (struct nfsd4_open *)&op->u;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, open);\n}\n\n/*\n * filehandle-manipulating ops.\n */\nstatic __be32\nnfsd4_getfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct svc_fh **getfh)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\t*getfh = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_putfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_putfh *putfh)\n{\n\tfh_put(&cstate->current_fh);\n\tcstate->current_fh.fh_handle.fh_size = putfh->pf_fhlen;\n\tmemcpy(&cstate->current_fh.fh_handle.fh_base, putfh->pf_fhval,\n\t       putfh->pf_fhlen);\n\treturn fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_BYPASS_GSS);\n}\n\nstatic __be32\nnfsd4_putrootfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\t__be32 status;\n\n\tfh_put(&cstate->current_fh);\n\tstatus = exp_pseudoroot(rqstp, &cstate->current_fh);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_restorefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn nfserr_restorefh;\n\n\tfh_dup2(&cstate->current_fh, &cstate->save_fh);\n\tif (HAS_STATE_ID(cstate, SAVED_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->current_stateid, &cstate->save_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_savefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     void *arg)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\tfh_dup2(&cstate->save_fh, &cstate->current_fh);\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->save_stateid, &cstate->current_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, SAVED_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}\n\n/*\n * misc nfsv4 ops\n */\nstatic __be32\nnfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_access *access)\n{\n\tif (access->ac_req_access & ~NFS3_ACCESS_FULL)\n\t\treturn nfserr_inval;\n\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}\n\nstatic void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}\n\nstatic __be32\nnfsd4_commit(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_commit *commit)\n{\n\tgen_boot_verifier(&commit->co_verf, SVC_NET(rqstp));\n\treturn nfsd_commit(rqstp, &cstate->current_fh, commit->co_offset,\n\t\t\t     commit->co_count);\n}\n\nstatic __be32\nnfsd4_create(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_create *create)\n{\n\tstruct svc_fh resfh;\n\t__be32 status;\n\tdev_t rdev;\n\n\tfh_init(&resfh, NFS4_FHSIZE);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, create->cr_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\treturn status;\n\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tstatus = nfsd_symlink(rqstp, &cstate->current_fh,\n\t\t\t\t      create->cr_name, create->cr_namelen,\n\t\t\t\t      create->cr_data, &resfh);\n\t\tbreak;\n\n\tcase NF4BLK:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFBLK, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4CHR:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr,S_IFCHR, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4SOCK:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFSOCK, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4FIFO:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFIFO, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4DIR:\n\t\tcreate->cr_iattr.ia_valid &= ~ATTR_SIZE;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFDIR, 0, &resfh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = nfserr_badtype;\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tif (create->cr_label.len)\n\t\tnfsd4_security_inode_setsecctx(&resfh, &create->cr_label, create->cr_bmval);\n\n\tif (create->cr_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, &resfh, create->cr_acl,\n\t\t\t\tcreate->cr_bmval);\n\n\tfh_unlock(&cstate->current_fh);\n\tset_change_info(&create->cr_cinfo, &cstate->current_fh);\n\tfh_dup2(&cstate->current_fh, &resfh);\nout:\n\tfh_put(&resfh);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_getattr *getattr)\n{\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_link(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_link *link)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tstatus = nfsd_link(rqstp, &cstate->current_fh,\n\t\t\t   link->li_name, link->li_namelen, &cstate->save_fh);\n\tif (!status)\n\t\tset_change_info(&link->li_cinfo, &cstate->current_fh);\n\treturn status;\n}\n\nstatic __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}\n\nstatic __be32\nnfsd4_lookupp(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      void *arg)\n{\n\treturn nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n}\n\nstatic __be32\nnfsd4_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_lookup *lookup)\n{\n\treturn nfsd_lookup(rqstp, &cstate->current_fh,\n\t\t\t   lookup->lo_name, lookup->lo_len,\n\t\t\t   &cstate->current_fh);\n}\n\nstatic __be32\nnfsd4_read(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_read *read)\n{\n\t__be32 status;\n\n\tread->rd_filp = NULL;\n\tif (read->rd_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\t/*\n\t * If we do a zero copy read, then a client will see read data\n\t * that reflects the state of the file *after* performing the\n\t * following compound.\n\t *\n\t * To ensure proper ordering, we therefore turn off zero copy if\n\t * the client wants us to do more in this compound:\n\t */\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\tclear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\n\t/* check stateid */\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t&read->rd_stateid, RD_STATE,\n\t\t\t\t\t&read->rd_filp, &read->rd_tmp_file);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_read: couldn't process stateid!\\n\");\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tread->rd_rqstp = rqstp;\n\tread->rd_fhp = &cstate->current_fh;\n\treturn status;\n}\n\nstatic __be32\nnfsd4_readdir(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_readdir *readdir)\n{\n\tu64 cookie = readdir->rd_cookie;\n\tstatic const nfs4_verifier zeroverf;\n\n\t/* no need to check permission - this will be done in nfsd_readdir() */\n\n\tif (readdir->rd_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\treaddir->rd_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\treaddir->rd_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\treaddir->rd_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\n\tif ((cookie == 1) || (cookie == 2) ||\n\t    (cookie == 0 && memcmp(readdir->rd_verf.data, zeroverf.data, NFS4_VERIFIER_SIZE)))\n\t\treturn nfserr_bad_cookie;\n\n\treaddir->rd_rqstp = rqstp;\n\treaddir->rd_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_readlink(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_readlink *readlink)\n{\n\treadlink->rl_rqstp = rqstp;\n\treadlink->rl_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_remove(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_remove *remove)\n{\n\t__be32 status;\n\n\tif (opens_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_unlink(rqstp, &cstate->current_fh, 0,\n\t\t\t     remove->rm_name, remove->rm_namelen);\n\tif (!status) {\n\t\tfh_unlock(&cstate->current_fh);\n\t\tset_change_info(&remove->rm_cinfo, &cstate->current_fh);\n\t}\n\treturn status;\n}\n\nstatic __be32\nnfsd4_rename(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_rename *rename)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tif (opens_in_grace(SVC_NET(rqstp)) &&\n\t\t!(cstate->save_fh.fh_export->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_rename(rqstp, &cstate->save_fh, rename->rn_sname,\n\t\t\t     rename->rn_snamelen, &cstate->current_fh,\n\t\t\t     rename->rn_tname, rename->rn_tnamelen);\n\tif (status)\n\t\treturn status;\n\tset_change_info(&rename->rn_sinfo, &cstate->current_fh);\n\tset_change_info(&rename->rn_tinfo, &cstate->save_fh);\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_secinfo(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo *secinfo)\n{\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, &cstate->current_fh,\n\t\t\t\t    secinfo->si_name, secinfo->si_namelen,\n\t\t\t\t    &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\tfh_unlock(&cstate->current_fh);\n\tif (d_really_is_negative(dentry)) {\n\t\texp_put(exp);\n\t\terr = nfserr_noent;\n\t} else\n\t\tsecinfo->si_exp = exp;\n\tdput(dentry);\n\tif (cstate->minorversion)\n\t\t/* See rfc 5661 section 2.6.3.1.1.8 */\n\t\tfh_put(&cstate->current_fh);\n\treturn err;\n}\n\nstatic __be32\nnfsd4_secinfo_no_name(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo_no_name *sin)\n{\n\t__be32 err;\n\n\tswitch (sin->sin_style) {\n\tcase NFS4_SECINFO_STYLE4_CURRENT_FH:\n\t\tbreak;\n\tcase NFS4_SECINFO_STYLE4_PARENT:\n\t\terr = nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_inval;\n\t}\n\n\tsin->sin_exp = exp_get(cstate->current_fh.fh_export);\n\tfh_put(&cstate->current_fh);\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_setattr *setattr)\n{\n\t__be32 status = nfs_ok;\n\tint err;\n\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate,\n\t\t\t\t&cstate->current_fh, &setattr->sa_stateid,\n\t\t\t\tWR_STATE, NULL, NULL);\n\t\tif (status) {\n\t\t\tdprintk(\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\n\tif (setattr->sa_acl != NULL)\n\t\tstatus = nfsd4_set_nfs4_acl(rqstp, &cstate->current_fh,\n\t\t\t\t\t    setattr->sa_acl);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_label.len)\n\t\tstatus = nfsd4_set_nfs4_label(rqstp, &cstate->current_fh,\n\t\t\t\t&setattr->sa_label);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &setattr->sa_iattr,\n\t\t\t\t0, (time_t)0);\nout:\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}\n\nstatic int fill_in_write_vector(struct kvec *vec, struct nfsd4_write *write)\n{\n        int i = 1;\n        int buflen = write->wr_buflen;\n\n        vec[0].iov_base = write->wr_head.iov_base;\n        vec[0].iov_len = min_t(int, buflen, write->wr_head.iov_len);\n        buflen -= vec[0].iov_len;\n\n        while (buflen) {\n                vec[i].iov_base = page_address(write->wr_pagelist[i - 1]);\n                vec[i].iov_len = min_t(int, PAGE_SIZE, buflen);\n                buflen -= vec[i].iov_len;\n                i++;\n        }\n        return i;\n}\n\nstatic __be32\nnfsd4_write(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_write *write)\n{\n\tstateid_t *stateid = &write->wr_stateid;\n\tstruct file *filp = NULL;\n\t__be32 status = nfs_ok;\n\tunsigned long cnt;\n\tint nvecs;\n\n\tif (write->wr_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t\tstateid, WR_STATE, &filp, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_write: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tcnt = write->wr_buflen;\n\twrite->wr_how_written = write->wr_stable_how;\n\tgen_boot_verifier(&write->wr_verifier, SVC_NET(rqstp));\n\n\tnvecs = fill_in_write_vector(rqstp->rq_vec, write);\n\tWARN_ON_ONCE(nvecs > ARRAY_SIZE(rqstp->rq_vec));\n\n\tstatus = nfsd_vfs_write(rqstp, &cstate->current_fh, filp,\n\t\t\t\twrite->wr_offset, rqstp->rq_vec, nvecs, &cnt,\n\t\t\t\twrite->wr_how_written);\n\tfput(filp);\n\n\twrite->wr_bytes_written = cnt;\n\n\treturn status;\n}\n\nstatic __be32\nnfsd4_verify_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  stateid_t *src_stateid, struct file **src,\n\t\t  stateid_t *dst_stateid, struct file **dst)\n{\n\t__be32 status;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->save_fh,\n\t\t\t\t\t    src_stateid, RD_STATE, src, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: %s: couldn't process src stateid!\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    dst_stateid, WR_STATE, dst, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: %s: couldn't process dst stateid!\\n\", __func__);\n\t\tgoto out_put_src;\n\t}\n\n\t/* fix up for NFS-specific error code */\n\tif (!S_ISREG(file_inode(*src)->i_mode) ||\n\t    !S_ISREG(file_inode(*dst)->i_mode)) {\n\t\tstatus = nfserr_wrong_type;\n\t\tgoto out_put_dst;\n\t}\n\nout:\n\treturn status;\nout_put_dst:\n\tfput(*dst);\nout_put_src:\n\tfput(*src);\n\tgoto out;\n}\n\nstatic __be32\nnfsd4_clone(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_clone *clone)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &clone->cl_src_stateid, &src,\n\t\t\t\t   &clone->cl_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfsd4_clone_file_range(src, clone->cl_src_pos,\n\t\t\tdst, clone->cl_dst_pos, clone->cl_count);\n\n\tfput(dst);\n\tfput(src);\nout:\n\treturn status;\n}\n\nstatic __be32\nnfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_copy *copy)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\tssize_t bytes;\n\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid, &src,\n\t\t\t\t   &copy->cp_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\n\tbytes = nfsd_copy_file_range(src, copy->cp_src_pos,\n\t\t\tdst, copy->cp_dst_pos, copy->cp_count);\n\n\tif (bytes < 0)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tcopy->cp_res.wr_bytes_written = bytes;\n\t\tcopy->cp_res.wr_stable_how = NFS_UNSTABLE;\n\t\tcopy->cp_consecutive = 1;\n\t\tcopy->cp_synchronous = 1;\n\t\tgen_boot_verifier(&copy->cp_res.wr_verifier, SVC_NET(rqstp));\n\t\tstatus = nfs_ok;\n\t}\n\n\tfput(src);\n\tfput(dst);\nout:\n\treturn status;\n}\n\nstatic __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file, NULL);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_allocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate, 0);\n}\n\nstatic __be32\nnfsd4_deallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate,\n\t\t\t       FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE);\n}\n\nstatic __be32\nnfsd4_seek(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_seek *seek)\n{\n\tint whence;\n\t__be32 status;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    &seek->seek_stateid,\n\t\t\t\t\t    RD_STATE, &file, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_seek: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tswitch (seek->seek_whence) {\n\tcase NFS4_CONTENT_DATA:\n\t\twhence = SEEK_DATA;\n\t\tbreak;\n\tcase NFS4_CONTENT_HOLE:\n\t\twhence = SEEK_HOLE;\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_union_notsupp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Note:  This call does change file->f_pos, but nothing in NFSD\n\t *        should ever file->f_pos.\n\t */\n\tseek->seek_pos = vfs_llseek(file, seek->seek_offset, whence);\n\tif (seek->seek_pos < 0)\n\t\tstatus = nfserrno(seek->seek_pos);\n\telse if (seek->seek_pos >= i_size_read(file_inode(file)))\n\t\tseek->seek_eof = true;\n\nout:\n\tfput(file);\n\treturn status;\n}\n\n/* This routine never returns NFS_OK!  If there are no other errors, it\n * will return NFSERR_SAME or NFSERR_NOT_SAME depending on whether the\n * attributes matched.  VERIFY is implemented by mapping NFSERR_SAME\n * to NFS_OK after the call; NVERIFY by mapping NFSERR_NOT_SAME to NFS_OK.\n */\nstatic __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_nverify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_not_same ? nfs_ok : status;\n}\n\nstatic __be32\nnfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_same ? nfs_ok : status;\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}\n\nstatic __be32\nnfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0) {\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb,\n\t\t\t\trqstp, cstate->session->se_client, gdp);\n\t}\n\n\tgdp->gd_notify_types &= ops->notify_types;\nout:\n\texp_put(exp);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_layoutget(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\tint accmode;\n\n\tswitch (lgp->lg_seg.iomode) {\n\tcase IOMODE_READ:\n\t\taccmode = NFSD_MAY_READ;\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\taccmode = NFSD_MAY_READ | NFSD_MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\",\n\t\t\t__func__, lgp->lg_seg.iomode);\n\t\tnfserr = nfserr_badiomode;\n\t\tgoto out;\n\t}\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, accmode);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lgp->lg_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\t/*\n\t * Verify minlength and range as per RFC5661:\n\t *  o  If loga_length is less than loga_minlength,\n\t *     the metadata server MUST return NFS4ERR_INVAL.\n\t *  o  If the sum of loga_offset and loga_minlength exceeds\n\t *     NFS4_UINT64_MAX, and loga_minlength is not\n\t *     NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.\n\t *  o  If the sum of loga_offset and loga_length exceeds\n\t *     NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX,\n\t *     the error NFS4ERR_INVAL MUST result.\n\t */\n\tnfserr = nfserr_inval;\n\tif (lgp->lg_seg.length < lgp->lg_minlength ||\n\t    (lgp->lg_minlength != NFS4_MAX_UINT64 &&\n\t     lgp->lg_minlength > NFS4_MAX_UINT64 - lgp->lg_seg.offset) ||\n\t    (lgp->lg_seg.length != NFS4_MAX_UINT64 &&\n\t     lgp->lg_seg.length > NFS4_MAX_UINT64 - lgp->lg_seg.offset))\n\t\tgoto out;\n\tif (lgp->lg_seg.length == 0)\n\t\tgoto out;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lgp->lg_sid,\n\t\t\t\t\t\ttrue, lgp->lg_layout_type, &ls);\n\tif (nfserr) {\n\t\ttrace_layout_get_lookup_fail(&lgp->lg_sid);\n\t\tgoto out;\n\t}\n\n\tnfserr = nfserr_recallconflict;\n\tif (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))\n\t\tgoto out_put_stid;\n\n\tnfserr = ops->proc_layoutget(d_inode(current_fh->fh_dentry),\n\t\t\t\t     current_fh, lgp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tnfserr = nfsd4_insert_layout(lgp, ls);\n\nout_put_stid:\n\tmutex_unlock(&ls->ls_mutex);\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_layoutcommit(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tconst struct nfsd4_layout_seg *seg = &lcp->lc_seg;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct inode *inode;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_WRITE);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lcp->lc_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tinode = d_inode(current_fh->fh_dentry);\n\n\tnfserr = nfserr_inval;\n\tif (new_size <= seg->offset) {\n\t\tdprintk(\"pnfsd: last write before layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (new_size > seg->offset + seg->length) {\n\t\tdprintk(\"pnfsd: last write beyond layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (!lcp->lc_newoffset && new_size > i_size_read(inode)) {\n\t\tdprintk(\"pnfsd: layoutcommit beyond EOF\\n\");\n\t\tgoto out;\n\t}\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lcp->lc_sid,\n\t\t\t\t\t\tfalse, lcp->lc_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_commit_lookup_fail(&lcp->lc_sid);\n\t\t/* fixup error code as per RFC5661 */\n\t\tif (nfserr == nfserr_bad_stateid)\n\t\t\tnfserr = nfserr_badlayout;\n\t\tgoto out;\n\t}\n\n\t/* LAYOUTCOMMIT does not require any serialization */\n\tmutex_unlock(&ls->ls_mutex);\n\n\tif (new_size > i_size_read(inode)) {\n\t\tlcp->lc_size_chg = 1;\n\t\tlcp->lc_newsize = new_size;\n\t} else {\n\t\tlcp->lc_size_chg = 0;\n\t}\n\n\tnfserr = ops->proc_layoutcommit(inode, lcp);\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_layoutreturn(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tif (!nfsd4_layout_verify(current_fh->fh_export, lrp->lr_layout_type))\n\t\tgoto out;\n\n\tswitch (lrp->lr_seg.iomode) {\n\tcase IOMODE_READ:\n\tcase IOMODE_RW:\n\tcase IOMODE_ANY:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\", __func__,\n\t\t\tlrp->lr_seg.iomode);\n\t\tnfserr = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tswitch (lrp->lr_return_type) {\n\tcase RETURN_FILE:\n\t\tnfserr = nfsd4_return_file_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tcase RETURN_FSID:\n\tcase RETURN_ALL:\n\t\tnfserr = nfsd4_return_client_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid return_type %d\\n\", __func__,\n\t\t\tlrp->lr_return_type);\n\t\tnfserr = nfserr_inval;\n\t\tbreak;\n\t}\nout:\n\treturn nfserr;\n}\n#endif /* CONFIG_NFSD_PNFS */\n\n/*\n * NULL call.\n */\nstatic __be32\nnfsd4_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}\n\nstatic inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}\n\ntypedef __be32(*nfsd4op_func)(struct svc_rqst *, struct nfsd4_compound_state *,\n\t\t\t      void *);\ntypedef u32(*nfsd4op_rsize)(struct svc_rqst *, struct nfsd4_op *op);\ntypedef void(*stateid_setter)(struct nfsd4_compound_state *, void *);\ntypedef void(*stateid_getter)(struct nfsd4_compound_state *, void *);\n\nenum nfsd4_op_flags {\n\tALLOWED_WITHOUT_FH = 1 << 0,\t/* No current filehandle required */\n\tALLOWED_ON_ABSENT_FS = 1 << 1,\t/* ops processed on absent fs */\n\tALLOWED_AS_FIRST_OP = 1 << 2,\t/* ops reqired first in compound */\n\t/* For rfc 5661 section 2.6.3.1.1: */\n\tOP_HANDLES_WRONGSEC = 1 << 3,\n\tOP_IS_PUTFH_LIKE = 1 << 4,\n\t/*\n\t * These are the ops whose result size we estimate before\n\t * encoding, to avoid performing an op then not being able to\n\t * respond or cache a response.  This includes writes and setattrs\n\t * as well as the operations usually called \"nonidempotent\":\n\t */\n\tOP_MODIFIES_SOMETHING = 1 << 5,\n\t/*\n\t * Cache compounds containing these ops in the xid-based drc:\n\t * We use the DRC for compounds containing non-idempotent\n\t * operations, *except* those that are 4.1-specific (since\n\t * sessions provide their own EOS), and except for stateful\n\t * operations other than setclientid and setclientid_confirm\n\t * (since sequence numbers provide EOS for open, lock, etc in\n\t * the v4.0 case).\n\t */\n\tOP_CACHEME = 1 << 6,\n\t/*\n\t * These are ops which clear current state id.\n\t */\n\tOP_CLEAR_STATEID = 1 << 7,\n};\n\nstruct nfsd4_operation {\n\tnfsd4op_func op_func;\n\tu32 op_flags;\n\tchar *op_name;\n\t/* Try to get response size before operation */\n\tnfsd4op_rsize op_rsize_bop;\n\tstateid_getter op_get_currentstateid;\n\tstateid_setter op_set_currentstateid;\n};\n\nstatic struct nfsd4_operation nfsd4_ops[];\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\n/*\n * Enforce NFSv4.1 COMPOUND ordering rules:\n *\n * Also note, enforced elsewhere:\n *\t- SEQUENCE other than as first op results in\n *\t  NFS4ERR_SEQUENCE_POS. (Enforced in nfsd4_sequence().)\n *\t- BIND_CONN_TO_SESSION must be the only op in its compound.\n *\t  (Enforced in nfsd4_bind_conn_to_session().)\n *\t- DESTROY_SESSION must be the final operation in a compound, if\n *\t  sessionid's in SEQUENCE and DESTROY_SESSION are the same.\n *\t  (Enforced in nfsd4_destroy_session().)\n */\nstatic __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op *op = &args->ops[0];\n\n\t/* These ordering requirements don't apply to NFSv4.0: */\n\tif (args->minorversion == 0)\n\t\treturn nfs_ok;\n\t/* This is weird, but OK, not our problem: */\n\tif (args->opcnt == 0)\n\t\treturn nfs_ok;\n\tif (op->status == nfserr_op_illegal)\n\t\treturn nfs_ok;\n\tif (!(nfsd4_ops[op->opnum].op_flags & ALLOWED_AS_FIRST_OP))\n\t\treturn nfserr_op_not_in_session;\n\tif (op->opnum == OP_SEQUENCE)\n\t\treturn nfs_ok;\n\tif (args->opcnt != 1)\n\t\treturn nfserr_not_only_op;\n\treturn nfs_ok;\n}\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}\n\nbool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}\n\nstatic bool need_wrongsec_check(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_op *next = &argp->ops[resp->opcnt];\n\tstruct nfsd4_operation *thisd;\n\tstruct nfsd4_operation *nextd;\n\n\tthisd = OPDESC(this);\n\t/*\n\t * Most ops check wronsec on our own; only the putfh-like ops\n\t * have special rules.\n\t */\n\tif (!(thisd->op_flags & OP_IS_PUTFH_LIKE))\n\t\treturn false;\n\t/*\n\t * rfc 5661 2.6.3.1.1.6: don't bother erroring out a\n\t * put-filehandle operation if we're not going to use the\n\t * result:\n\t */\n\tif (argp->opcnt == resp->opcnt)\n\t\treturn false;\n\tif (next->opnum == OP_ILLEGAL)\n\t\treturn false;\n\tnextd = OPDESC(next);\n\t/*\n\t * Rest of 2.6.3.1.1: certain operations will return WRONGSEC\n\t * errors themselves as necessary; others should check for them\n\t * now:\n\t */\n\treturn !(nextd->op_flags & OP_HANDLES_WRONGSEC);\n}\n\nstatic void svcxdr_init_encode(struct svc_rqst *rqstp,\n\t\t\t       struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *head = buf->head;\n\n\txdr->buf = buf;\n\txdr->iov = head;\n\txdr->p   = head->iov_base + head->iov_len;\n\txdr->end = head->iov_base + PAGE_SIZE - rqstp->rq_auth_slack;\n\t/* Tail and page_len should be zero at this point: */\n\tbuf->len = buf->head[0].iov_len;\n\txdr->scratch.iov_len = 0;\n\txdr->page_ptr = buf->pages - 1;\n\tbuf->buflen = PAGE_SIZE * (1 + rqstp->rq_page_end - buf->pages)\n\t\t- rqstp->rq_auth_slack;\n}\n\n/*\n * COMPOUND call.\n */\nstatic __be32\nnfsd4_proc_compound(struct svc_rqst *rqstp,\n\t\t    struct nfsd4_compoundargs *args,\n\t\t    struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op\t*op;\n\tstruct nfsd4_operation *opdesc;\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct svc_fh *save_fh = &cstate->save_fh;\n\t__be32\t\tstatus;\n\n\tsvcxdr_init_encode(rqstp, resp);\n\tresp->tagp = resp->xdr.p;\n\t/* reserve space for: taglen, tag, and opcnt */\n\txdr_reserve_space(&resp->xdr, 8 + args->taglen);\n\tresp->taglen = args->taglen;\n\tresp->tag = args->tag;\n\tresp->rqstp = rqstp;\n\tcstate->minorversion = args->minorversion;\n\tfh_init(current_fh, NFS4_FHSIZE);\n\tfh_init(save_fh, NFS4_FHSIZE);\n\t/*\n\t * Don't use the deferral mechanism for NFSv4; compounds make it\n\t * too hard to avoid non-idempotency problems.\n\t */\n\tclear_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\n\t/*\n\t * According to RFC3010, this takes precedence over all other errors.\n\t */\n\tstatus = nfserr_minor_vers_mismatch;\n\tif (nfsd_minorversion(args->minorversion, NFSD_TEST) <= 0)\n\t\tgoto out;\n\n\tstatus = nfs41_check_op_ordering(args);\n\tif (status) {\n\t\top = &args->ops[0];\n\t\top->status = status;\n\t\tgoto encode_op;\n\t}\n\n\twhile (!status && resp->opcnt < args->opcnt) {\n\t\top = &args->ops[resp->opcnt++];\n\n\t\tdprintk(\"nfsv4 compound op #%d/%d: %d (%s)\\n\",\n\t\t\tresp->opcnt, args->opcnt, op->opnum,\n\t\t\tnfsd4_op_name(op->opnum));\n\t\t/*\n\t\t * The XDR decode routines may have pre-set op->status;\n\t\t * for example, if there is a miscellaneous XDR error\n\t\t * it will be set to nfserr_bad_xdr.\n\t\t */\n\t\tif (op->status) {\n\t\t\tif (op->opnum == OP_OPEN)\n\t\t\t\top->status = nfsd4_open_omfg(rqstp, cstate, op);\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\topdesc = OPDESC(op);\n\n\t\tif (!current_fh->fh_dentry) {\n\t\t\tif (!(opdesc->op_flags & ALLOWED_WITHOUT_FH)) {\n\t\t\t\top->status = nfserr_nofilehandle;\n\t\t\t\tgoto encode_op;\n\t\t\t}\n\t\t} else if (current_fh->fh_export->ex_fslocs.migrated &&\n\t\t\t  !(opdesc->op_flags & ALLOWED_ON_ABSENT_FS)) {\n\t\t\top->status = nfserr_moved;\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\tfh_clear_wcc(current_fh);\n\n\t\t/* If op is non-idempotent */\n\t\tif (opdesc->op_flags & OP_MODIFIES_SOMETHING) {\n\t\t\t/*\n\t\t\t * Don't execute this op if we couldn't encode a\n\t\t\t * succesful reply:\n\t\t\t */\n\t\t\tu32 plen = opdesc->op_rsize_bop(rqstp, op);\n\t\t\t/*\n\t\t\t * Plus if there's another operation, make sure\n\t\t\t * we'll have space to at least encode an error:\n\t\t\t */\n\t\t\tif (resp->opcnt < args->opcnt)\n\t\t\t\tplen += COMPOUND_ERR_SLACK_SPACE;\n\t\t\top->status = nfsd4_check_resp_size(resp, plen);\n\t\t}\n\n\t\tif (op->status)\n\t\t\tgoto encode_op;\n\n\t\tif (opdesc->op_get_currentstateid)\n\t\t\topdesc->op_get_currentstateid(cstate, &op->u);\n\t\top->status = opdesc->op_func(rqstp, cstate, &op->u);\n\n\t\tif (!op->status) {\n\t\t\tif (opdesc->op_set_currentstateid)\n\t\t\t\topdesc->op_set_currentstateid(cstate, &op->u);\n\n\t\t\tif (opdesc->op_flags & OP_CLEAR_STATEID)\n\t\t\t\tclear_current_stateid(cstate);\n\n\t\t\tif (need_wrongsec_check(rqstp))\n\t\t\t\top->status = check_nfsd_access(current_fh->fh_export, rqstp);\n\t\t}\n\nencode_op:\n\t\t/* Only from SEQUENCE */\n\t\tif (cstate->status == nfserr_replay_cache) {\n\t\t\tdprintk(\"%s NFS4.1 replay from cache\\n\", __func__);\n\t\t\tstatus = op->status;\n\t\t\tgoto out;\n\t\t}\n\t\tif (op->status == nfserr_replay_me) {\n\t\t\top->replay = &cstate->replay_owner->so_replay;\n\t\t\tnfsd4_encode_replay(&resp->xdr, op);\n\t\t\tstatus = op->status = op->replay->rp_status;\n\t\t} else {\n\t\t\tnfsd4_encode_operation(resp, op);\n\t\t\tstatus = op->status;\n\t\t}\n\n\t\tdprintk(\"nfsv4 compound op %p opcnt %d #%d: %d: status %d\\n\",\n\t\t\targs->ops, args->opcnt, resp->opcnt, op->opnum,\n\t\t\tbe32_to_cpu(status));\n\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\tnfsd4_increment_op_stats(op->opnum);\n\t}\n\n\tcstate->status = status;\n\tfh_put(current_fh);\n\tfh_put(save_fh);\n\tBUG_ON(cstate->replay_owner);\nout:\n\t/* Reset deferral mechanism for RPC deferrals */\n\tset_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\tdprintk(\"nfsv4 compound returned %d\\n\", ntohl(status));\n\treturn status;\n}\n\n#define op_encode_hdr_size\t\t(2)\n#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define op_encode_change_info_maxsz\t(5)\n#define nfs4_fattr_bitmap_maxsz\t\t(4)\n\n/* We'll fall back on returning no lockowner if run out of space: */\n#define op_encode_lockowner_maxsz\t(0)\n#define op_encode_lock_denied_maxsz\t(8 + op_encode_lockowner_maxsz)\n\n#define nfs4_owner_maxsz\t\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n\n#define op_encode_ace_maxsz\t\t(3 + nfs4_owner_maxsz)\n#define op_encode_delegation_maxsz\t(1 + op_encode_stateid_maxsz + 1 + \\\n\t\t\t\t\t op_encode_ace_maxsz)\n\n#define op_encode_channel_attrs_maxsz\t(6 + 1 + 1)\n\nstatic inline u32 nfsd4_only_status_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_status_stateid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz)* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_access_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\t/* ac_supported, ac_resp_access */\n\treturn (op_encode_hdr_size + 2)* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_commit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_create_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n\n/*\n * Note since this is an idempotent operation we won't insist on failing\n * the op prematurely if the estimate is too large.  We may turn off splice\n * reads unnecessarily.\n */\nstatic inline u32 nfsd4_getattr_rsize(struct svc_rqst *rqstp,\n\t\t\t\t      struct nfsd4_op *op)\n{\n\tu32 *bmap = op->u.getattr.ga_bmval;\n\tu32 bmap0 = bmap[0], bmap1 = bmap[1], bmap2 = bmap[2];\n\tu32 ret = 0;\n\n\tif (bmap0 & FATTR4_WORD0_ACL)\n\t\treturn svc_max_payload(rqstp);\n\tif (bmap0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\treturn svc_max_payload(rqstp);\n\n\tif (bmap1 & FATTR4_WORD1_OWNER) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER;\n\t}\n\tif (bmap1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tif (bmap0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tret += NFS4_FHSIZE + 4;\n\t\tbmap0 &= ~FATTR4_WORD0_FILEHANDLE;\n\t}\n\tif (bmap2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tret += NFS4_MAXLABELLEN + 12;\n\t\tbmap2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\t/*\n\t * Largest of remaining attributes are 16 bytes (e.g.,\n\t * supported_attributes)\n\t */\n\tret += 16 * (hweight32(bmap0) + hweight32(bmap1) + hweight32(bmap2));\n\t/* bitmask, length */\n\tret += 20;\n\treturn ret;\n}\n\nstatic inline u32 nfsd4_getfh_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + NFS4_FHSIZE;\n}\n\nstatic inline u32 nfsd4_link_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_lock_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_lock_denied_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_open_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz\n\t\t+ op_encode_change_info_maxsz + 1\n\t\t+ nfs4_fattr_bitmap_maxsz\n\t\t+ op_encode_delegation_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_read_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.read.rd_length, maxcount);\n\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_readdir_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.readdir.rd_maxcount, maxcount);\n\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_readlink_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + PAGE_SIZE;\n}\n\nstatic inline u32 nfsd4_remove_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_rename_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ op_encode_change_info_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_sequence_rsize(struct svc_rqst *rqstp,\n\t\t\t\t       struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size\n\t\t+ XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 5) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_test_stateid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1 + op->u.test_stateid.ts_num_ids)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_setattr_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_secinfo_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + RPC_AUTH_MAXFLAVOR *\n\t\t(4 + XDR_QUADLEN(GSS_OID_MAX_LEN))) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_setclientid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(NFS4_VERIFIER_SIZE)) *\n\t\t\t\t\t\t\t\tsizeof(__be32);\n}\n\nstatic inline u32 nfsd4_write_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + op_encode_verifier_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_exchange_id_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + 1 + /* eir_clientid, eir_sequenceid */\\\n\t\t1 + 1 + /* eir_flags, spr_how */\\\n\t\t4 + /* spo_must_enforce & _allow with bitmap */\\\n\t\t2 + /*eir_server_owner.so_minor_id */\\\n\t\t/* eir_server_owner.so_major_id<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t/* eir_server_scope<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t1 + /* eir_server_impl_id array length */\\\n\t\t0 /* ignored eir_server_impl_id contents */) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_bind_conn_to_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* bctsr_sessid */\\\n\t\t2 /* bctsr_dir, use_conn_in_rdma_mode */) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_create_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* sessionid */\\\n\t\t2 + /* csr_sequence, csr_flags */\\\n\t\top_encode_channel_attrs_maxsz + \\\n\t\top_encode_channel_attrs_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_copy_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* wr_callback */ +\n\t\top_encode_stateid_maxsz /* wr_callback */ +\n\t\t2 /* wr_count */ +\n\t\t1 /* wr_committed */ +\n\t\top_encode_verifier_maxsz +\n\t\t1 /* cr_consecutive */ +\n\t\t1 /* cr_synchronous */) * sizeof(__be32);\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic inline u32 nfsd4_getdeviceinfo_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.getdeviceinfo.gd_maxcount, maxcount);\n\n\treturn (op_encode_hdr_size +\n\t\t1 /* gd_layout_type*/ +\n\t\tXDR_QUADLEN(rlen) +\n\t\t2 /* gd_notify_types */) * sizeof(__be32);\n}\n\n/*\n * At this stage we don't really know what layout driver will handle the request,\n * so we need to define an arbitrary upper bound here.\n */\n#define MAX_LAYOUT_SIZE\t\t128\nstatic inline u32 nfsd4_layoutget_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* logr_return_on_close */ +\n\t\top_encode_stateid_maxsz +\n\t\t1 /* nr of layouts */ +\n\t\tMAX_LAYOUT_SIZE) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_layoutcommit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* locr_newsize */ +\n\t\t2 /* ns_size */) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_layoutreturn_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* lrs_stateid */ +\n\t\top_encode_stateid_maxsz) * sizeof(__be32);\n}\n#endif /* CONFIG_NFSD_PNFS */\n\n\nstatic inline u32 nfsd4_seek_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 3) * sizeof(__be32);\n}\n\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_access_rsize,\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_getfh_rsize,\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readlink_rsize,\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_secinfo_rsize,\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_secinfo_rsize,\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_test_stateid_rsize,\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_getdeviceinfo_rsize,\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_CLONE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_clone,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_CLONE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_COPY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_copy,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_COPY\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_copy_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_seek_rsize,\n\t},\n};\n\n/**\n * nfsd4_spo_must_allow - Determine if the compound op contains an\n * operation that is allowed to be sent with machine credentials\n *\n * @rqstp: a pointer to the struct svc_rqst\n *\n * Checks to see if the compound contains a spo_must_allow op\n * and confirms that it was sent with the proper machine creds.\n */\n\nbool nfsd4_spo_must_allow(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct nfs4_op_map *allow = &cstate->clp->cl_spo_must_allow;\n\tu32 opiter;\n\n\tif (!cstate->minorversion)\n\t\treturn false;\n\n\tif (cstate->spo_must_allowed == true)\n\t\treturn true;\n\n\topiter = resp->opcnt;\n\twhile (opiter < argp->opcnt) {\n\t\tthis = &argp->ops[opiter++];\n\t\tif (test_bit(this->opnum, allow->u.longs) &&\n\t\t\tcstate->clp->cl_mach_cred &&\n\t\t\tnfsd4_mach_creds_match(cstate->clp, rqstp)) {\n\t\t\tcstate->spo_must_allowed = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\tcstate->spo_must_allowed = false;\n\treturn false;\n}\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL || op->status == nfserr_notsupp)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\n\tBUG_ON(OPDESC(op)->op_rsize_bop == NULL);\n\treturn OPDESC(op)->op_rsize_bop(rqstp, op);\n}\n\nvoid warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}\n\n#define nfsd4_voidres\t\t\tnfsd4_voidargs\nstruct nfsd4_voidargs { int dummy; };\n\nstatic struct svc_procedure\t\tnfsd_procedures4[2] = {\n\t[NFSPROC4_NULL] = {\n\t\t.pc_func = (svc_procfunc) nfsd4_proc_null,\n\t\t.pc_encode = (kxdrproc_t) nfs4svc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd4_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd4_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = 1,\n\t},\n\t[NFSPROC4_COMPOUND] = {\n\t\t.pc_func = (svc_procfunc) nfsd4_proc_compound,\n\t\t.pc_decode = (kxdrproc_t) nfs4svc_decode_compoundargs,\n\t\t.pc_encode = (kxdrproc_t) nfs4svc_encode_compoundres,\n\t\t.pc_argsize = sizeof(struct nfsd4_compoundargs),\n\t\t.pc_ressize = sizeof(struct nfsd4_compoundres),\n\t\t.pc_release = nfsd4_release_compoundargs,\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = NFSD_BUFSIZE/4,\n\t},\n};\n\nstruct svc_version\tnfsd_version4 = {\n\t.vs_vers\t\t= 4,\n\t.vs_nproc\t\t= 2,\n\t.vs_proc\t\t= nfsd_procedures4,\n\t.vs_dispatch\t\t= nfsd_dispatch,\n\t.vs_xdrsize\t\t= NFS4_SVC_XDRSIZE,\n\t.vs_rpcb_optnl\t\t= true,\n\t.vs_need_cong_ctrl\t= true,\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n *  Server-side procedures for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include <linux/file.h>\n#include <linux/falloc.h>\n#include <linux/slab.h>\n\n#include \"idmap.h\"\n#include \"cache.h\"\n#include \"xdr4.h\"\n#include \"vfs.h\"\n#include \"current_stateid.h\"\n#include \"netns.h\"\n#include \"acl.h\"\n#include \"pnfs.h\"\n#include \"trace.h\"\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n#include <linux/security.h>\n\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{\n\tstruct inode *inode = d_inode(resfh->fh_dentry);\n\tint status;\n\n\tinode_lock(inode);\n\tstatus = security_inode_setsecctx(resfh->fh_dentry,\n\t\tlabel->data, label->len);\n\tinode_unlock(inode);\n\n\tif (status)\n\t\t/*\n\t\t * XXX: We should really fail the whole open, but we may\n\t\t * already have created a new file, so it may be too\n\t\t * late.  For now this seems the least of evils:\n\t\t */\n\t\tbmval[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\treturn;\n}\n#else\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }\n#endif\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_PROC\n\nstatic u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};\n\nstatic u32 nfsd41_ex_attrmask[] = {\n\tNFSD_SUPPATTR_EXCLCREAT_WORD0,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD1,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD2\n};\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\tstruct svc_export *exp = cstate->current_fh.fh_export;\n\n\tif (!nfsd_attrs_supported(cstate->minorversion, bmval))\n\t\treturn nfserr_attrnotsupp;\n\tif ((bmval[0] & FATTR4_WORD0_ACL) && !IS_POSIXACL(d_inode(dentry)))\n\t\treturn nfserr_attrnotsupp;\n\tif ((bmval[2] & FATTR4_WORD2_SECURITY_LABEL) &&\n\t\t\t!(exp->ex_flags & NFSEXP_SECURITY_LABEL))\n\t\treturn nfserr_attrnotsupp;\n\tif (writable && !bmval_is_subset(bmval, writable))\n\t\treturn nfserr_inval;\n\tif (writable && (bmval[2] & FATTR4_WORD2_MODE_UMASK) &&\n\t\t\t(bmval[1] & FATTR4_WORD1_MODE))\n\t\treturn nfserr_inval;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}\n\nstatic int\nis_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}\n\n/*\n * if error occurs when setting the acl, just clear the acl bit\n * in the returned attr bitmap.\n */\nstatic void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}\n\nstatic __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}\n\nstatic __be32 nfsd_check_obj_isreg(struct svc_fh *fh)\n{\n\tumode_t mode = d_inode(fh->fh_dentry)->i_mode;\n\n\tif (S_ISREG(mode))\n\t\treturn nfs_ok;\n\tif (S_ISDIR(mode))\n\t\treturn nfserr_isdir;\n\t/*\n\t * Using err_symlink as our catch-all case may look odd; but\n\t * there's no other obvious error for this case in 4.0, and we\n\t * happen to know that it will cause the linux v4 client to do\n\t * the right thing on attempts to open something other than a\n\t * regular file.\n\t */\n\treturn nfserr_symlink;\n}\n\nstatic void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}\n\nstatic __be32\ndo_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh **resfh)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode;\n\t__be32 status;\n\n\t*resfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\tif (!*resfh)\n\t\treturn nfserr_jukebox;\n\tfh_init(*resfh, NFS4_FHSIZE);\n\topen->op_truncate = 0;\n\n\tif (open->op_create) {\n\t\t/* FIXME: check session persistence and pnfs flags.\n\t\t * The nfsv4.1 spec requires the following semantics:\n\t\t *\n\t\t * Persistent   | pNFS   | Server REQUIRED | Client Allowed\n\t\t * Reply Cache  | server |                 |\n\t\t * -------------+--------+-----------------+--------------------\n\t\t * no           | no     | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t *              |        |                 | (SHOULD)\n\t\t *              |        | and EXCLUSIVE4  | or EXCLUSIVE4\n\t\t *              |        |                 | (SHOULD NOT)\n\t\t * no           | yes    | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t * yes          | no     | GUARDED4        | GUARDED4\n\t\t * yes          | yes    | GUARDED4        | GUARDED4\n\t\t */\n\n\t\t/*\n\t\t * Note: create modes (UNCHECKED,GUARDED...) are the same\n\t\t * in NFSv4 as in v3 except EXCLUSIVE4_1.\n\t\t */\n\t\tstatus = do_nfsd_create(rqstp, current_fh, open->op_fname.data,\n\t\t\t\t\topen->op_fname.len, &open->op_iattr,\n\t\t\t\t\t*resfh, open->op_createmode,\n\t\t\t\t\t(u32 *)open->op_verf.data,\n\t\t\t\t\t&open->op_truncate, &open->op_created);\n\n\t\tif (!status && open->op_label.len)\n\t\t\tnfsd4_security_inode_setsecctx(*resfh, &open->op_label, open->op_bmval);\n\n\t\t/*\n\t\t * Following rfc 3530 14.2.16, and rfc 5661 18.16.4\n\t\t * use the returned bitmask to indicate which attributes\n\t\t * we used to store the verifier:\n\t\t */\n\t\tif (nfsd_create_is_exclusive(open->op_createmode) && status == 0)\n\t\t\topen->op_bmval[1] |= (FATTR4_WORD1_TIME_ACCESS |\n\t\t\t\t\t\tFATTR4_WORD1_TIME_MODIFY);\n\t} else\n\t\t/*\n\t\t * Note this may exit with the parent still locked.\n\t\t * We will hold the lock until nfsd4_open's final\n\t\t * lookup, to prevent renames or unlinks until we've had\n\t\t * a chance to an acquire a delegation if appropriate.\n\t\t */\n\t\tstatus = nfsd_lookup(rqstp, current_fh,\n\t\t\t\t     open->op_fname.data, open->op_fname.len, *resfh);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_check_obj_isreg(*resfh);\n\tif (status)\n\t\tgoto out;\n\n\tif (is_create_with_attrs(open) && open->op_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, *resfh, open->op_acl, open->op_bmval);\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, *resfh);\n\taccmode = NFSD_MAY_NOP;\n\tif (open->op_created ||\n\t\t\topen->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR)\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\tstatus = do_open_permission(rqstp, *resfh, open, accmode);\n\tset_change_info(&open->op_cinfo, current_fh);\nout:\n\treturn status;\n}\n\nstatic __be32\ndo_open_fhandle(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 status;\n\tint accmode = 0;\n\n\t/* We don't know the target directory, and therefore can not\n\t* set the change info\n\t*/\n\n\tmemset(&open->op_cinfo, 0, sizeof(struct nfsd4_change_info));\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, current_fh);\n\n\topen->op_truncate = (open->op_iattr.ia_valid & ATTR_SIZE) &&\n\t\t(open->op_iattr.ia_size == 0);\n\t/*\n\t * In the delegation case, the client is telling us about an\n\t * open that it *already* performed locally, some time ago.  We\n\t * should let it succeed now if possible.\n\t *\n\t * In the case of a CLAIM_FH open, on the other hand, the client\n\t * may be counting on us to enforce permissions (the Linux 4.1\n\t * client uses this for normal opens, for example).\n\t */\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH)\n\t\taccmode = NFSD_MAY_OWNER_OVERRIDE;\n\n\tstatus = do_open_permission(rqstp, current_fh, open, accmode);\n\n\treturn status;\n}\n\nstatic void\ncopy_clientid(clientid_t *clid, struct nfsd4_session *session)\n{\n\tstruct nfsd4_sessionid *sid =\n\t\t\t(struct nfsd4_sessionid *)session->se_sessionid.data;\n\n\tclid->cl_boot = sid->clientid.cl_boot;\n\tclid->cl_id = sid->clientid.cl_id;\n}\n\nstatic __be32\nnfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_open *open)\n{\n\t__be32 status;\n\tstruct svc_fh *resfh = NULL;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open filename %.*s op_openowner %p\\n\",\n\t\t(int)open->op_fname.len, open->op_fname.data,\n\t\topen->op_openowner);\n\n\t/* This check required by spec. */\n\tif (open->op_create && open->op_claim_type != NFS4_OPEN_CLAIM_NULL)\n\t\treturn nfserr_inval;\n\n\topen->op_created = 0;\n\t/*\n\t * RFC5661 18.51.3\n\t * Before RECLAIM_COMPLETE done, server should deny new lock\n\t */\n\tif (nfsd4_has_session(cstate) &&\n\t    !test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t      &cstate->session->se_client->cl_flags) &&\n\t    open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn nfserr_grace;\n\n\tif (nfsd4_has_session(cstate))\n\t\tcopy_clientid(&open->op_clientid, cstate->session);\n\n\t/* check seqid for replay. set nfs4_owner */\n\tstatus = nfsd4_process_open1(cstate, open, nn);\n\tif (status == nfserr_replay_me) {\n\t\tstruct nfs4_replay *rp = &open->op_openowner->oo_owner.so_replay;\n\t\tfh_put(&cstate->current_fh);\n\t\tfh_copy_shallow(&cstate->current_fh.fh_handle,\n\t\t\t\t&rp->rp_openfh);\n\t\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\t\tif (status)\n\t\t\tdprintk(\"nfsd4_open: replay failed\"\n\t\t\t\t\" restoring previous filehandle\\n\");\n\t\telse\n\t\t\tstatus = nfserr_replay_me;\n\t}\n\tif (status)\n\t\tgoto out;\n\tif (open->op_xdr_error) {\n\t\tstatus = open->op_xdr_error;\n\t\tgoto out;\n\t}\n\n\tstatus = nfsd4_check_open_attributes(rqstp, cstate, open);\n\tif (status)\n\t\tgoto out;\n\n\t/* Openowner is now set, so sequence id will get bumped.  Now we need\n\t * these checks before we do any creates: */\n\tstatus = nfserr_grace;\n\tif (opens_in_grace(net) && open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!opens_in_grace(net) && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\t\tstatus = do_open_lookup(rqstp, cstate, open, &resfh);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tstatus = nfs4_check_open_reclaim(&open->op_clientid,\n\t\t\t\t\t\t\t cstate, nn);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\t\tstatus = do_open_fhandle(rqstp, cstate, open);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tresfh = &cstate->current_fh;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n             \tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\t\tdprintk(\"NFSD: unsupported OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_notsupp;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: Invalid OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out;\n\t}\n\t/*\n\t * nfsd4_process_open2() does the actual opening of the file.  If\n\t * successful, it (1) truncates the file if open->op_truncate was\n\t * set, (2) sets open->op_stateid, (3) sets open->op_delegation.\n\t */\n\tstatus = nfsd4_process_open2(rqstp, resfh, open);\n\tWARN(status && open->op_created,\n\t     \"nfsd4_process_open2 failed to open newly-created file! status=%u\\n\",\n\t     be32_to_cpu(status));\nout:\n\tif (resfh && resfh != &cstate->current_fh) {\n\t\tfh_dup2(&cstate->current_fh, resfh);\n\t\tfh_put(resfh);\n\t\tkfree(resfh);\n\t}\n\tnfsd4_cleanup_open_state(cstate, open);\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}\n\n/*\n * OPEN is the only seqid-mutating operation whose decoding can fail\n * with a seqid-mutating error (specifically, decoding of user names in\n * the attributes).  Therefore we have to do some processing to look up\n * the stateowner so that we can bump the seqid.\n */\nstatic __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = (struct nfsd4_open *)&op->u;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, open);\n}\n\n/*\n * filehandle-manipulating ops.\n */\nstatic __be32\nnfsd4_getfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct svc_fh **getfh)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\t*getfh = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_putfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_putfh *putfh)\n{\n\tfh_put(&cstate->current_fh);\n\tcstate->current_fh.fh_handle.fh_size = putfh->pf_fhlen;\n\tmemcpy(&cstate->current_fh.fh_handle.fh_base, putfh->pf_fhval,\n\t       putfh->pf_fhlen);\n\treturn fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_BYPASS_GSS);\n}\n\nstatic __be32\nnfsd4_putrootfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\t__be32 status;\n\n\tfh_put(&cstate->current_fh);\n\tstatus = exp_pseudoroot(rqstp, &cstate->current_fh);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_restorefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn nfserr_restorefh;\n\n\tfh_dup2(&cstate->current_fh, &cstate->save_fh);\n\tif (HAS_STATE_ID(cstate, SAVED_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->current_stateid, &cstate->save_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_savefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     void *arg)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\tfh_dup2(&cstate->save_fh, &cstate->current_fh);\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->save_stateid, &cstate->current_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, SAVED_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}\n\n/*\n * misc nfsv4 ops\n */\nstatic __be32\nnfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_access *access)\n{\n\tif (access->ac_req_access & ~NFS3_ACCESS_FULL)\n\t\treturn nfserr_inval;\n\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}\n\nstatic void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}\n\nstatic __be32\nnfsd4_commit(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_commit *commit)\n{\n\tgen_boot_verifier(&commit->co_verf, SVC_NET(rqstp));\n\treturn nfsd_commit(rqstp, &cstate->current_fh, commit->co_offset,\n\t\t\t     commit->co_count);\n}\n\nstatic __be32\nnfsd4_create(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_create *create)\n{\n\tstruct svc_fh resfh;\n\t__be32 status;\n\tdev_t rdev;\n\n\tfh_init(&resfh, NFS4_FHSIZE);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, create->cr_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\treturn status;\n\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tstatus = nfsd_symlink(rqstp, &cstate->current_fh,\n\t\t\t\t      create->cr_name, create->cr_namelen,\n\t\t\t\t      create->cr_data, &resfh);\n\t\tbreak;\n\n\tcase NF4BLK:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFBLK, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4CHR:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr,S_IFCHR, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4SOCK:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFSOCK, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4FIFO:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFIFO, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4DIR:\n\t\tcreate->cr_iattr.ia_valid &= ~ATTR_SIZE;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFDIR, 0, &resfh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = nfserr_badtype;\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tif (create->cr_label.len)\n\t\tnfsd4_security_inode_setsecctx(&resfh, &create->cr_label, create->cr_bmval);\n\n\tif (create->cr_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, &resfh, create->cr_acl,\n\t\t\t\tcreate->cr_bmval);\n\n\tfh_unlock(&cstate->current_fh);\n\tset_change_info(&create->cr_cinfo, &cstate->current_fh);\n\tfh_dup2(&cstate->current_fh, &resfh);\nout:\n\tfh_put(&resfh);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_getattr *getattr)\n{\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_link(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_link *link)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tstatus = nfsd_link(rqstp, &cstate->current_fh,\n\t\t\t   link->li_name, link->li_namelen, &cstate->save_fh);\n\tif (!status)\n\t\tset_change_info(&link->li_cinfo, &cstate->current_fh);\n\treturn status;\n}\n\nstatic __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}\n\nstatic __be32\nnfsd4_lookupp(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      void *arg)\n{\n\treturn nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n}\n\nstatic __be32\nnfsd4_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_lookup *lookup)\n{\n\treturn nfsd_lookup(rqstp, &cstate->current_fh,\n\t\t\t   lookup->lo_name, lookup->lo_len,\n\t\t\t   &cstate->current_fh);\n}\n\nstatic __be32\nnfsd4_read(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_read *read)\n{\n\t__be32 status;\n\n\tread->rd_filp = NULL;\n\tif (read->rd_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\t/*\n\t * If we do a zero copy read, then a client will see read data\n\t * that reflects the state of the file *after* performing the\n\t * following compound.\n\t *\n\t * To ensure proper ordering, we therefore turn off zero copy if\n\t * the client wants us to do more in this compound:\n\t */\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\tclear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\n\t/* check stateid */\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t&read->rd_stateid, RD_STATE,\n\t\t\t\t\t&read->rd_filp, &read->rd_tmp_file);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_read: couldn't process stateid!\\n\");\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tread->rd_rqstp = rqstp;\n\tread->rd_fhp = &cstate->current_fh;\n\treturn status;\n}\n\nstatic __be32\nnfsd4_readdir(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_readdir *readdir)\n{\n\tu64 cookie = readdir->rd_cookie;\n\tstatic const nfs4_verifier zeroverf;\n\n\t/* no need to check permission - this will be done in nfsd_readdir() */\n\n\tif (readdir->rd_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\treaddir->rd_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\treaddir->rd_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\treaddir->rd_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\n\tif ((cookie == 1) || (cookie == 2) ||\n\t    (cookie == 0 && memcmp(readdir->rd_verf.data, zeroverf.data, NFS4_VERIFIER_SIZE)))\n\t\treturn nfserr_bad_cookie;\n\n\treaddir->rd_rqstp = rqstp;\n\treaddir->rd_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_readlink(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_readlink *readlink)\n{\n\treadlink->rl_rqstp = rqstp;\n\treadlink->rl_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_remove(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_remove *remove)\n{\n\t__be32 status;\n\n\tif (opens_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_unlink(rqstp, &cstate->current_fh, 0,\n\t\t\t     remove->rm_name, remove->rm_namelen);\n\tif (!status) {\n\t\tfh_unlock(&cstate->current_fh);\n\t\tset_change_info(&remove->rm_cinfo, &cstate->current_fh);\n\t}\n\treturn status;\n}\n\nstatic __be32\nnfsd4_rename(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_rename *rename)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tif (opens_in_grace(SVC_NET(rqstp)) &&\n\t\t!(cstate->save_fh.fh_export->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_rename(rqstp, &cstate->save_fh, rename->rn_sname,\n\t\t\t     rename->rn_snamelen, &cstate->current_fh,\n\t\t\t     rename->rn_tname, rename->rn_tnamelen);\n\tif (status)\n\t\treturn status;\n\tset_change_info(&rename->rn_sinfo, &cstate->current_fh);\n\tset_change_info(&rename->rn_tinfo, &cstate->save_fh);\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_secinfo(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo *secinfo)\n{\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, &cstate->current_fh,\n\t\t\t\t    secinfo->si_name, secinfo->si_namelen,\n\t\t\t\t    &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\tfh_unlock(&cstate->current_fh);\n\tif (d_really_is_negative(dentry)) {\n\t\texp_put(exp);\n\t\terr = nfserr_noent;\n\t} else\n\t\tsecinfo->si_exp = exp;\n\tdput(dentry);\n\tif (cstate->minorversion)\n\t\t/* See rfc 5661 section 2.6.3.1.1.8 */\n\t\tfh_put(&cstate->current_fh);\n\treturn err;\n}\n\nstatic __be32\nnfsd4_secinfo_no_name(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo_no_name *sin)\n{\n\t__be32 err;\n\n\tswitch (sin->sin_style) {\n\tcase NFS4_SECINFO_STYLE4_CURRENT_FH:\n\t\tbreak;\n\tcase NFS4_SECINFO_STYLE4_PARENT:\n\t\terr = nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_inval;\n\t}\n\n\tsin->sin_exp = exp_get(cstate->current_fh.fh_export);\n\tfh_put(&cstate->current_fh);\n\treturn nfs_ok;\n}\n\nstatic __be32\nnfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_setattr *setattr)\n{\n\t__be32 status = nfs_ok;\n\tint err;\n\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate,\n\t\t\t\t&cstate->current_fh, &setattr->sa_stateid,\n\t\t\t\tWR_STATE, NULL, NULL);\n\t\tif (status) {\n\t\t\tdprintk(\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\n\tif (setattr->sa_acl != NULL)\n\t\tstatus = nfsd4_set_nfs4_acl(rqstp, &cstate->current_fh,\n\t\t\t\t\t    setattr->sa_acl);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_label.len)\n\t\tstatus = nfsd4_set_nfs4_label(rqstp, &cstate->current_fh,\n\t\t\t\t&setattr->sa_label);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &setattr->sa_iattr,\n\t\t\t\t0, (time_t)0);\nout:\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}\n\nstatic int fill_in_write_vector(struct kvec *vec, struct nfsd4_write *write)\n{\n        int i = 1;\n        int buflen = write->wr_buflen;\n\n        vec[0].iov_base = write->wr_head.iov_base;\n        vec[0].iov_len = min_t(int, buflen, write->wr_head.iov_len);\n        buflen -= vec[0].iov_len;\n\n        while (buflen) {\n                vec[i].iov_base = page_address(write->wr_pagelist[i - 1]);\n                vec[i].iov_len = min_t(int, PAGE_SIZE, buflen);\n                buflen -= vec[i].iov_len;\n                i++;\n        }\n        return i;\n}\n\nstatic __be32\nnfsd4_write(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_write *write)\n{\n\tstateid_t *stateid = &write->wr_stateid;\n\tstruct file *filp = NULL;\n\t__be32 status = nfs_ok;\n\tunsigned long cnt;\n\tint nvecs;\n\n\tif (write->wr_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t\tstateid, WR_STATE, &filp, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_write: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tcnt = write->wr_buflen;\n\twrite->wr_how_written = write->wr_stable_how;\n\tgen_boot_verifier(&write->wr_verifier, SVC_NET(rqstp));\n\n\tnvecs = fill_in_write_vector(rqstp->rq_vec, write);\n\tWARN_ON_ONCE(nvecs > ARRAY_SIZE(rqstp->rq_vec));\n\n\tstatus = nfsd_vfs_write(rqstp, &cstate->current_fh, filp,\n\t\t\t\twrite->wr_offset, rqstp->rq_vec, nvecs, &cnt,\n\t\t\t\twrite->wr_how_written);\n\tfput(filp);\n\n\twrite->wr_bytes_written = cnt;\n\n\treturn status;\n}\n\nstatic __be32\nnfsd4_verify_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  stateid_t *src_stateid, struct file **src,\n\t\t  stateid_t *dst_stateid, struct file **dst)\n{\n\t__be32 status;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->save_fh,\n\t\t\t\t\t    src_stateid, RD_STATE, src, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: %s: couldn't process src stateid!\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    dst_stateid, WR_STATE, dst, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: %s: couldn't process dst stateid!\\n\", __func__);\n\t\tgoto out_put_src;\n\t}\n\n\t/* fix up for NFS-specific error code */\n\tif (!S_ISREG(file_inode(*src)->i_mode) ||\n\t    !S_ISREG(file_inode(*dst)->i_mode)) {\n\t\tstatus = nfserr_wrong_type;\n\t\tgoto out_put_dst;\n\t}\n\nout:\n\treturn status;\nout_put_dst:\n\tfput(*dst);\nout_put_src:\n\tfput(*src);\n\tgoto out;\n}\n\nstatic __be32\nnfsd4_clone(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_clone *clone)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &clone->cl_src_stateid, &src,\n\t\t\t\t   &clone->cl_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfsd4_clone_file_range(src, clone->cl_src_pos,\n\t\t\tdst, clone->cl_dst_pos, clone->cl_count);\n\n\tfput(dst);\n\tfput(src);\nout:\n\treturn status;\n}\n\nstatic __be32\nnfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_copy *copy)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\tssize_t bytes;\n\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid, &src,\n\t\t\t\t   &copy->cp_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\n\tbytes = nfsd_copy_file_range(src, copy->cp_src_pos,\n\t\t\tdst, copy->cp_dst_pos, copy->cp_count);\n\n\tif (bytes < 0)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tcopy->cp_res.wr_bytes_written = bytes;\n\t\tcopy->cp_res.wr_stable_how = NFS_UNSTABLE;\n\t\tcopy->cp_consecutive = 1;\n\t\tcopy->cp_synchronous = 1;\n\t\tgen_boot_verifier(&copy->cp_res.wr_verifier, SVC_NET(rqstp));\n\t\tstatus = nfs_ok;\n\t}\n\n\tfput(src);\n\tfput(dst);\nout:\n\treturn status;\n}\n\nstatic __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file, NULL);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_allocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate, 0);\n}\n\nstatic __be32\nnfsd4_deallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate,\n\t\t\t       FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE);\n}\n\nstatic __be32\nnfsd4_seek(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_seek *seek)\n{\n\tint whence;\n\t__be32 status;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    &seek->seek_stateid,\n\t\t\t\t\t    RD_STATE, &file, NULL);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_seek: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tswitch (seek->seek_whence) {\n\tcase NFS4_CONTENT_DATA:\n\t\twhence = SEEK_DATA;\n\t\tbreak;\n\tcase NFS4_CONTENT_HOLE:\n\t\twhence = SEEK_HOLE;\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_union_notsupp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Note:  This call does change file->f_pos, but nothing in NFSD\n\t *        should ever file->f_pos.\n\t */\n\tseek->seek_pos = vfs_llseek(file, seek->seek_offset, whence);\n\tif (seek->seek_pos < 0)\n\t\tstatus = nfserrno(seek->seek_pos);\n\telse if (seek->seek_pos >= i_size_read(file_inode(file)))\n\t\tseek->seek_eof = true;\n\nout:\n\tfput(file);\n\treturn status;\n}\n\n/* This routine never returns NFS_OK!  If there are no other errors, it\n * will return NFSERR_SAME or NFSERR_NOT_SAME depending on whether the\n * attributes matched.  VERIFY is implemented by mapping NFSERR_SAME\n * to NFS_OK after the call; NVERIFY by mapping NFSERR_NOT_SAME to NFS_OK.\n */\nstatic __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}\n\nstatic __be32\nnfsd4_nverify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_not_same ? nfs_ok : status;\n}\n\nstatic __be32\nnfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_same ? nfs_ok : status;\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (layout_type >= LAYOUT_TYPE_MAX ||\n\t    !(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}\n\nstatic __be32\nnfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0) {\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb,\n\t\t\t\trqstp, cstate->session->se_client, gdp);\n\t}\n\n\tgdp->gd_notify_types &= ops->notify_types;\nout:\n\texp_put(exp);\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_layoutget(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\tint accmode;\n\n\tswitch (lgp->lg_seg.iomode) {\n\tcase IOMODE_READ:\n\t\taccmode = NFSD_MAY_READ;\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\taccmode = NFSD_MAY_READ | NFSD_MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\",\n\t\t\t__func__, lgp->lg_seg.iomode);\n\t\tnfserr = nfserr_badiomode;\n\t\tgoto out;\n\t}\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, accmode);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lgp->lg_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\t/*\n\t * Verify minlength and range as per RFC5661:\n\t *  o  If loga_length is less than loga_minlength,\n\t *     the metadata server MUST return NFS4ERR_INVAL.\n\t *  o  If the sum of loga_offset and loga_minlength exceeds\n\t *     NFS4_UINT64_MAX, and loga_minlength is not\n\t *     NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.\n\t *  o  If the sum of loga_offset and loga_length exceeds\n\t *     NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX,\n\t *     the error NFS4ERR_INVAL MUST result.\n\t */\n\tnfserr = nfserr_inval;\n\tif (lgp->lg_seg.length < lgp->lg_minlength ||\n\t    (lgp->lg_minlength != NFS4_MAX_UINT64 &&\n\t     lgp->lg_minlength > NFS4_MAX_UINT64 - lgp->lg_seg.offset) ||\n\t    (lgp->lg_seg.length != NFS4_MAX_UINT64 &&\n\t     lgp->lg_seg.length > NFS4_MAX_UINT64 - lgp->lg_seg.offset))\n\t\tgoto out;\n\tif (lgp->lg_seg.length == 0)\n\t\tgoto out;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lgp->lg_sid,\n\t\t\t\t\t\ttrue, lgp->lg_layout_type, &ls);\n\tif (nfserr) {\n\t\ttrace_layout_get_lookup_fail(&lgp->lg_sid);\n\t\tgoto out;\n\t}\n\n\tnfserr = nfserr_recallconflict;\n\tif (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))\n\t\tgoto out_put_stid;\n\n\tnfserr = ops->proc_layoutget(d_inode(current_fh->fh_dentry),\n\t\t\t\t     current_fh, lgp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tnfserr = nfsd4_insert_layout(lgp, ls);\n\nout_put_stid:\n\tmutex_unlock(&ls->ls_mutex);\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_layoutcommit(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tconst struct nfsd4_layout_seg *seg = &lcp->lc_seg;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct inode *inode;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_WRITE);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lcp->lc_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tinode = d_inode(current_fh->fh_dentry);\n\n\tnfserr = nfserr_inval;\n\tif (new_size <= seg->offset) {\n\t\tdprintk(\"pnfsd: last write before layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (new_size > seg->offset + seg->length) {\n\t\tdprintk(\"pnfsd: last write beyond layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (!lcp->lc_newoffset && new_size > i_size_read(inode)) {\n\t\tdprintk(\"pnfsd: layoutcommit beyond EOF\\n\");\n\t\tgoto out;\n\t}\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lcp->lc_sid,\n\t\t\t\t\t\tfalse, lcp->lc_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_commit_lookup_fail(&lcp->lc_sid);\n\t\t/* fixup error code as per RFC5661 */\n\t\tif (nfserr == nfserr_bad_stateid)\n\t\t\tnfserr = nfserr_badlayout;\n\t\tgoto out;\n\t}\n\n\t/* LAYOUTCOMMIT does not require any serialization */\n\tmutex_unlock(&ls->ls_mutex);\n\n\tif (new_size > i_size_read(inode)) {\n\t\tlcp->lc_size_chg = 1;\n\t\tlcp->lc_newsize = new_size;\n\t} else {\n\t\tlcp->lc_size_chg = 0;\n\t}\n\n\tnfserr = ops->proc_layoutcommit(inode, lcp);\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}\n\nstatic __be32\nnfsd4_layoutreturn(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tif (!nfsd4_layout_verify(current_fh->fh_export, lrp->lr_layout_type))\n\t\tgoto out;\n\n\tswitch (lrp->lr_seg.iomode) {\n\tcase IOMODE_READ:\n\tcase IOMODE_RW:\n\tcase IOMODE_ANY:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\", __func__,\n\t\t\tlrp->lr_seg.iomode);\n\t\tnfserr = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tswitch (lrp->lr_return_type) {\n\tcase RETURN_FILE:\n\t\tnfserr = nfsd4_return_file_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tcase RETURN_FSID:\n\tcase RETURN_ALL:\n\t\tnfserr = nfsd4_return_client_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid return_type %d\\n\", __func__,\n\t\t\tlrp->lr_return_type);\n\t\tnfserr = nfserr_inval;\n\t\tbreak;\n\t}\nout:\n\treturn nfserr;\n}\n#endif /* CONFIG_NFSD_PNFS */\n\n/*\n * NULL call.\n */\nstatic __be32\nnfsd4_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}\n\nstatic inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}\n\ntypedef __be32(*nfsd4op_func)(struct svc_rqst *, struct nfsd4_compound_state *,\n\t\t\t      void *);\ntypedef u32(*nfsd4op_rsize)(struct svc_rqst *, struct nfsd4_op *op);\ntypedef void(*stateid_setter)(struct nfsd4_compound_state *, void *);\ntypedef void(*stateid_getter)(struct nfsd4_compound_state *, void *);\n\nenum nfsd4_op_flags {\n\tALLOWED_WITHOUT_FH = 1 << 0,\t/* No current filehandle required */\n\tALLOWED_ON_ABSENT_FS = 1 << 1,\t/* ops processed on absent fs */\n\tALLOWED_AS_FIRST_OP = 1 << 2,\t/* ops reqired first in compound */\n\t/* For rfc 5661 section 2.6.3.1.1: */\n\tOP_HANDLES_WRONGSEC = 1 << 3,\n\tOP_IS_PUTFH_LIKE = 1 << 4,\n\t/*\n\t * These are the ops whose result size we estimate before\n\t * encoding, to avoid performing an op then not being able to\n\t * respond or cache a response.  This includes writes and setattrs\n\t * as well as the operations usually called \"nonidempotent\":\n\t */\n\tOP_MODIFIES_SOMETHING = 1 << 5,\n\t/*\n\t * Cache compounds containing these ops in the xid-based drc:\n\t * We use the DRC for compounds containing non-idempotent\n\t * operations, *except* those that are 4.1-specific (since\n\t * sessions provide their own EOS), and except for stateful\n\t * operations other than setclientid and setclientid_confirm\n\t * (since sequence numbers provide EOS for open, lock, etc in\n\t * the v4.0 case).\n\t */\n\tOP_CACHEME = 1 << 6,\n\t/*\n\t * These are ops which clear current state id.\n\t */\n\tOP_CLEAR_STATEID = 1 << 7,\n};\n\nstruct nfsd4_operation {\n\tnfsd4op_func op_func;\n\tu32 op_flags;\n\tchar *op_name;\n\t/* Try to get response size before operation */\n\tnfsd4op_rsize op_rsize_bop;\n\tstateid_getter op_get_currentstateid;\n\tstateid_setter op_set_currentstateid;\n};\n\nstatic struct nfsd4_operation nfsd4_ops[];\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\n/*\n * Enforce NFSv4.1 COMPOUND ordering rules:\n *\n * Also note, enforced elsewhere:\n *\t- SEQUENCE other than as first op results in\n *\t  NFS4ERR_SEQUENCE_POS. (Enforced in nfsd4_sequence().)\n *\t- BIND_CONN_TO_SESSION must be the only op in its compound.\n *\t  (Enforced in nfsd4_bind_conn_to_session().)\n *\t- DESTROY_SESSION must be the final operation in a compound, if\n *\t  sessionid's in SEQUENCE and DESTROY_SESSION are the same.\n *\t  (Enforced in nfsd4_destroy_session().)\n */\nstatic __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op *op = &args->ops[0];\n\n\t/* These ordering requirements don't apply to NFSv4.0: */\n\tif (args->minorversion == 0)\n\t\treturn nfs_ok;\n\t/* This is weird, but OK, not our problem: */\n\tif (args->opcnt == 0)\n\t\treturn nfs_ok;\n\tif (op->status == nfserr_op_illegal)\n\t\treturn nfs_ok;\n\tif (!(nfsd4_ops[op->opnum].op_flags & ALLOWED_AS_FIRST_OP))\n\t\treturn nfserr_op_not_in_session;\n\tif (op->opnum == OP_SEQUENCE)\n\t\treturn nfs_ok;\n\tif (args->opcnt != 1)\n\t\treturn nfserr_not_only_op;\n\treturn nfs_ok;\n}\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}\n\nbool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}\n\nstatic bool need_wrongsec_check(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_op *next = &argp->ops[resp->opcnt];\n\tstruct nfsd4_operation *thisd;\n\tstruct nfsd4_operation *nextd;\n\n\tthisd = OPDESC(this);\n\t/*\n\t * Most ops check wronsec on our own; only the putfh-like ops\n\t * have special rules.\n\t */\n\tif (!(thisd->op_flags & OP_IS_PUTFH_LIKE))\n\t\treturn false;\n\t/*\n\t * rfc 5661 2.6.3.1.1.6: don't bother erroring out a\n\t * put-filehandle operation if we're not going to use the\n\t * result:\n\t */\n\tif (argp->opcnt == resp->opcnt)\n\t\treturn false;\n\tif (next->opnum == OP_ILLEGAL)\n\t\treturn false;\n\tnextd = OPDESC(next);\n\t/*\n\t * Rest of 2.6.3.1.1: certain operations will return WRONGSEC\n\t * errors themselves as necessary; others should check for them\n\t * now:\n\t */\n\treturn !(nextd->op_flags & OP_HANDLES_WRONGSEC);\n}\n\nstatic void svcxdr_init_encode(struct svc_rqst *rqstp,\n\t\t\t       struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *head = buf->head;\n\n\txdr->buf = buf;\n\txdr->iov = head;\n\txdr->p   = head->iov_base + head->iov_len;\n\txdr->end = head->iov_base + PAGE_SIZE - rqstp->rq_auth_slack;\n\t/* Tail and page_len should be zero at this point: */\n\tbuf->len = buf->head[0].iov_len;\n\txdr->scratch.iov_len = 0;\n\txdr->page_ptr = buf->pages - 1;\n\tbuf->buflen = PAGE_SIZE * (1 + rqstp->rq_page_end - buf->pages)\n\t\t- rqstp->rq_auth_slack;\n}\n\n/*\n * COMPOUND call.\n */\nstatic __be32\nnfsd4_proc_compound(struct svc_rqst *rqstp,\n\t\t    struct nfsd4_compoundargs *args,\n\t\t    struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op\t*op;\n\tstruct nfsd4_operation *opdesc;\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct svc_fh *save_fh = &cstate->save_fh;\n\t__be32\t\tstatus;\n\n\tsvcxdr_init_encode(rqstp, resp);\n\tresp->tagp = resp->xdr.p;\n\t/* reserve space for: taglen, tag, and opcnt */\n\txdr_reserve_space(&resp->xdr, 8 + args->taglen);\n\tresp->taglen = args->taglen;\n\tresp->tag = args->tag;\n\tresp->rqstp = rqstp;\n\tcstate->minorversion = args->minorversion;\n\tfh_init(current_fh, NFS4_FHSIZE);\n\tfh_init(save_fh, NFS4_FHSIZE);\n\t/*\n\t * Don't use the deferral mechanism for NFSv4; compounds make it\n\t * too hard to avoid non-idempotency problems.\n\t */\n\tclear_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\n\t/*\n\t * According to RFC3010, this takes precedence over all other errors.\n\t */\n\tstatus = nfserr_minor_vers_mismatch;\n\tif (nfsd_minorversion(args->minorversion, NFSD_TEST) <= 0)\n\t\tgoto out;\n\n\tstatus = nfs41_check_op_ordering(args);\n\tif (status) {\n\t\top = &args->ops[0];\n\t\top->status = status;\n\t\tgoto encode_op;\n\t}\n\n\twhile (!status && resp->opcnt < args->opcnt) {\n\t\top = &args->ops[resp->opcnt++];\n\n\t\tdprintk(\"nfsv4 compound op #%d/%d: %d (%s)\\n\",\n\t\t\tresp->opcnt, args->opcnt, op->opnum,\n\t\t\tnfsd4_op_name(op->opnum));\n\t\t/*\n\t\t * The XDR decode routines may have pre-set op->status;\n\t\t * for example, if there is a miscellaneous XDR error\n\t\t * it will be set to nfserr_bad_xdr.\n\t\t */\n\t\tif (op->status) {\n\t\t\tif (op->opnum == OP_OPEN)\n\t\t\t\top->status = nfsd4_open_omfg(rqstp, cstate, op);\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\topdesc = OPDESC(op);\n\n\t\tif (!current_fh->fh_dentry) {\n\t\t\tif (!(opdesc->op_flags & ALLOWED_WITHOUT_FH)) {\n\t\t\t\top->status = nfserr_nofilehandle;\n\t\t\t\tgoto encode_op;\n\t\t\t}\n\t\t} else if (current_fh->fh_export->ex_fslocs.migrated &&\n\t\t\t  !(opdesc->op_flags & ALLOWED_ON_ABSENT_FS)) {\n\t\t\top->status = nfserr_moved;\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\tfh_clear_wcc(current_fh);\n\n\t\t/* If op is non-idempotent */\n\t\tif (opdesc->op_flags & OP_MODIFIES_SOMETHING) {\n\t\t\t/*\n\t\t\t * Don't execute this op if we couldn't encode a\n\t\t\t * succesful reply:\n\t\t\t */\n\t\t\tu32 plen = opdesc->op_rsize_bop(rqstp, op);\n\t\t\t/*\n\t\t\t * Plus if there's another operation, make sure\n\t\t\t * we'll have space to at least encode an error:\n\t\t\t */\n\t\t\tif (resp->opcnt < args->opcnt)\n\t\t\t\tplen += COMPOUND_ERR_SLACK_SPACE;\n\t\t\top->status = nfsd4_check_resp_size(resp, plen);\n\t\t}\n\n\t\tif (op->status)\n\t\t\tgoto encode_op;\n\n\t\tif (opdesc->op_get_currentstateid)\n\t\t\topdesc->op_get_currentstateid(cstate, &op->u);\n\t\top->status = opdesc->op_func(rqstp, cstate, &op->u);\n\n\t\tif (!op->status) {\n\t\t\tif (opdesc->op_set_currentstateid)\n\t\t\t\topdesc->op_set_currentstateid(cstate, &op->u);\n\n\t\t\tif (opdesc->op_flags & OP_CLEAR_STATEID)\n\t\t\t\tclear_current_stateid(cstate);\n\n\t\t\tif (need_wrongsec_check(rqstp))\n\t\t\t\top->status = check_nfsd_access(current_fh->fh_export, rqstp);\n\t\t}\n\nencode_op:\n\t\t/* Only from SEQUENCE */\n\t\tif (cstate->status == nfserr_replay_cache) {\n\t\t\tdprintk(\"%s NFS4.1 replay from cache\\n\", __func__);\n\t\t\tstatus = op->status;\n\t\t\tgoto out;\n\t\t}\n\t\tif (op->status == nfserr_replay_me) {\n\t\t\top->replay = &cstate->replay_owner->so_replay;\n\t\t\tnfsd4_encode_replay(&resp->xdr, op);\n\t\t\tstatus = op->status = op->replay->rp_status;\n\t\t} else {\n\t\t\tnfsd4_encode_operation(resp, op);\n\t\t\tstatus = op->status;\n\t\t}\n\n\t\tdprintk(\"nfsv4 compound op %p opcnt %d #%d: %d: status %d\\n\",\n\t\t\targs->ops, args->opcnt, resp->opcnt, op->opnum,\n\t\t\tbe32_to_cpu(status));\n\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\tnfsd4_increment_op_stats(op->opnum);\n\t}\n\n\tcstate->status = status;\n\tfh_put(current_fh);\n\tfh_put(save_fh);\n\tBUG_ON(cstate->replay_owner);\nout:\n\t/* Reset deferral mechanism for RPC deferrals */\n\tset_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\tdprintk(\"nfsv4 compound returned %d\\n\", ntohl(status));\n\treturn status;\n}\n\n#define op_encode_hdr_size\t\t(2)\n#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define op_encode_change_info_maxsz\t(5)\n#define nfs4_fattr_bitmap_maxsz\t\t(4)\n\n/* We'll fall back on returning no lockowner if run out of space: */\n#define op_encode_lockowner_maxsz\t(0)\n#define op_encode_lock_denied_maxsz\t(8 + op_encode_lockowner_maxsz)\n\n#define nfs4_owner_maxsz\t\t(1 + XDR_QUADLEN(IDMAP_NAMESZ))\n\n#define op_encode_ace_maxsz\t\t(3 + nfs4_owner_maxsz)\n#define op_encode_delegation_maxsz\t(1 + op_encode_stateid_maxsz + 1 + \\\n\t\t\t\t\t op_encode_ace_maxsz)\n\n#define op_encode_channel_attrs_maxsz\t(6 + 1 + 1)\n\nstatic inline u32 nfsd4_only_status_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_status_stateid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz)* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_access_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\t/* ac_supported, ac_resp_access */\n\treturn (op_encode_hdr_size + 2)* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_commit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_create_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n\n/*\n * Note since this is an idempotent operation we won't insist on failing\n * the op prematurely if the estimate is too large.  We may turn off splice\n * reads unnecessarily.\n */\nstatic inline u32 nfsd4_getattr_rsize(struct svc_rqst *rqstp,\n\t\t\t\t      struct nfsd4_op *op)\n{\n\tu32 *bmap = op->u.getattr.ga_bmval;\n\tu32 bmap0 = bmap[0], bmap1 = bmap[1], bmap2 = bmap[2];\n\tu32 ret = 0;\n\n\tif (bmap0 & FATTR4_WORD0_ACL)\n\t\treturn svc_max_payload(rqstp);\n\tif (bmap0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\treturn svc_max_payload(rqstp);\n\n\tif (bmap1 & FATTR4_WORD1_OWNER) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER;\n\t}\n\tif (bmap1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tif (bmap0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tret += NFS4_FHSIZE + 4;\n\t\tbmap0 &= ~FATTR4_WORD0_FILEHANDLE;\n\t}\n\tif (bmap2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tret += NFS4_MAXLABELLEN + 12;\n\t\tbmap2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\t/*\n\t * Largest of remaining attributes are 16 bytes (e.g.,\n\t * supported_attributes)\n\t */\n\tret += 16 * (hweight32(bmap0) + hweight32(bmap1) + hweight32(bmap2));\n\t/* bitmask, length */\n\tret += 20;\n\treturn ret;\n}\n\nstatic inline u32 nfsd4_getfh_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + NFS4_FHSIZE;\n}\n\nstatic inline u32 nfsd4_link_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_lock_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_lock_denied_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_open_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz\n\t\t+ op_encode_change_info_maxsz + 1\n\t\t+ nfs4_fattr_bitmap_maxsz\n\t\t+ op_encode_delegation_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_read_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.read.rd_length, maxcount);\n\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_readdir_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.readdir.rd_maxcount, maxcount);\n\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_readlink_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + PAGE_SIZE;\n}\n\nstatic inline u32 nfsd4_remove_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_rename_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ op_encode_change_info_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_sequence_rsize(struct svc_rqst *rqstp,\n\t\t\t\t       struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size\n\t\t+ XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 5) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_test_stateid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1 + op->u.test_stateid.ts_num_ids)\n\t\t* sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_setattr_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_secinfo_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + RPC_AUTH_MAXFLAVOR *\n\t\t(4 + XDR_QUADLEN(GSS_OID_MAX_LEN))) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_setclientid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(NFS4_VERIFIER_SIZE)) *\n\t\t\t\t\t\t\t\tsizeof(__be32);\n}\n\nstatic inline u32 nfsd4_write_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + op_encode_verifier_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_exchange_id_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + 1 + /* eir_clientid, eir_sequenceid */\\\n\t\t1 + 1 + /* eir_flags, spr_how */\\\n\t\t4 + /* spo_must_enforce & _allow with bitmap */\\\n\t\t2 + /*eir_server_owner.so_minor_id */\\\n\t\t/* eir_server_owner.so_major_id<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t/* eir_server_scope<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t1 + /* eir_server_impl_id array length */\\\n\t\t0 /* ignored eir_server_impl_id contents */) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_bind_conn_to_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* bctsr_sessid */\\\n\t\t2 /* bctsr_dir, use_conn_in_rdma_mode */) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_create_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* sessionid */\\\n\t\t2 + /* csr_sequence, csr_flags */\\\n\t\top_encode_channel_attrs_maxsz + \\\n\t\top_encode_channel_attrs_maxsz) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_copy_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* wr_callback */ +\n\t\top_encode_stateid_maxsz /* wr_callback */ +\n\t\t2 /* wr_count */ +\n\t\t1 /* wr_committed */ +\n\t\top_encode_verifier_maxsz +\n\t\t1 /* cr_consecutive */ +\n\t\t1 /* cr_synchronous */) * sizeof(__be32);\n}\n\n#ifdef CONFIG_NFSD_PNFS\nstatic inline u32 nfsd4_getdeviceinfo_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.getdeviceinfo.gd_maxcount, maxcount);\n\n\treturn (op_encode_hdr_size +\n\t\t1 /* gd_layout_type*/ +\n\t\tXDR_QUADLEN(rlen) +\n\t\t2 /* gd_notify_types */) * sizeof(__be32);\n}\n\n/*\n * At this stage we don't really know what layout driver will handle the request,\n * so we need to define an arbitrary upper bound here.\n */\n#define MAX_LAYOUT_SIZE\t\t128\nstatic inline u32 nfsd4_layoutget_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* logr_return_on_close */ +\n\t\top_encode_stateid_maxsz +\n\t\t1 /* nr of layouts */ +\n\t\tMAX_LAYOUT_SIZE) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_layoutcommit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* locr_newsize */ +\n\t\t2 /* ns_size */) * sizeof(__be32);\n}\n\nstatic inline u32 nfsd4_layoutreturn_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* lrs_stateid */ +\n\t\top_encode_stateid_maxsz) * sizeof(__be32);\n}\n#endif /* CONFIG_NFSD_PNFS */\n\n\nstatic inline u32 nfsd4_seek_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 3) * sizeof(__be32);\n}\n\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_access_rsize,\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_getfh_rsize,\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readlink_rsize,\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_secinfo_rsize,\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_secinfo_rsize,\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_test_stateid_rsize,\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_getdeviceinfo_rsize,\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_CLONE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_clone,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_CLONE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_COPY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_copy,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_COPY\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_copy_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_seek_rsize,\n\t},\n};\n\n/**\n * nfsd4_spo_must_allow - Determine if the compound op contains an\n * operation that is allowed to be sent with machine credentials\n *\n * @rqstp: a pointer to the struct svc_rqst\n *\n * Checks to see if the compound contains a spo_must_allow op\n * and confirms that it was sent with the proper machine creds.\n */\n\nbool nfsd4_spo_must_allow(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct nfs4_op_map *allow = &cstate->clp->cl_spo_must_allow;\n\tu32 opiter;\n\n\tif (!cstate->minorversion)\n\t\treturn false;\n\n\tif (cstate->spo_must_allowed == true)\n\t\treturn true;\n\n\topiter = resp->opcnt;\n\twhile (opiter < argp->opcnt) {\n\t\tthis = &argp->ops[opiter++];\n\t\tif (test_bit(this->opnum, allow->u.longs) &&\n\t\t\tcstate->clp->cl_mach_cred &&\n\t\t\tnfsd4_mach_creds_match(cstate->clp, rqstp)) {\n\t\t\tcstate->spo_must_allowed = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\tcstate->spo_must_allowed = false;\n\treturn false;\n}\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL || op->status == nfserr_notsupp)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\n\tBUG_ON(OPDESC(op)->op_rsize_bop == NULL);\n\treturn OPDESC(op)->op_rsize_bop(rqstp, op);\n}\n\nvoid warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}\n\n#define nfsd4_voidres\t\t\tnfsd4_voidargs\nstruct nfsd4_voidargs { int dummy; };\n\nstatic struct svc_procedure\t\tnfsd_procedures4[2] = {\n\t[NFSPROC4_NULL] = {\n\t\t.pc_func = (svc_procfunc) nfsd4_proc_null,\n\t\t.pc_encode = (kxdrproc_t) nfs4svc_encode_voidres,\n\t\t.pc_argsize = sizeof(struct nfsd4_voidargs),\n\t\t.pc_ressize = sizeof(struct nfsd4_voidres),\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = 1,\n\t},\n\t[NFSPROC4_COMPOUND] = {\n\t\t.pc_func = (svc_procfunc) nfsd4_proc_compound,\n\t\t.pc_decode = (kxdrproc_t) nfs4svc_decode_compoundargs,\n\t\t.pc_encode = (kxdrproc_t) nfs4svc_encode_compoundres,\n\t\t.pc_argsize = sizeof(struct nfsd4_compoundargs),\n\t\t.pc_ressize = sizeof(struct nfsd4_compoundres),\n\t\t.pc_release = nfsd4_release_compoundargs,\n\t\t.pc_cachetype = RC_NOCACHE,\n\t\t.pc_xdrressize = NFSD_BUFSIZE/4,\n\t},\n};\n\nstruct svc_version\tnfsd_version4 = {\n\t.vs_vers\t\t= 4,\n\t.vs_nproc\t\t= 2,\n\t.vs_proc\t\t= nfsd_procedures4,\n\t.vs_dispatch\t\t= nfsd_dispatch,\n\t.vs_xdrsize\t\t= NFS4_SVC_XDRSIZE,\n\t.vs_rpcb_optnl\t\t= true,\n\t.vs_need_cong_ctrl\t= true,\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n"], "filenames": ["fs/nfsd/nfs4proc.c"], "buggy_code_start_loc": [1262], "buggy_code_end_loc": [1263], "fixing_code_start_loc": [1262], "fixing_code_end_loc": [1264], "type": "CWE-129", "message": "The NFSv4 server in the Linux kernel before 4.11.3 does not properly validate the layout type when processing the NFSv4 pNFS GETDEVICEINFO or LAYOUTGET operand in a UDP packet from a remote attacker. This type value is uninitialized upon encountering certain error conditions. This value is used as an array index for dereferencing, which leads to an OOPS and eventually a DoS of knfsd and a soft-lockup of the whole system.", "other": {"cve": {"id": "CVE-2017-8797", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-02T17:29:00.177", "lastModified": "2023-02-03T02:02:19.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The NFSv4 server in the Linux kernel before 4.11.3 does not properly validate the layout type when processing the NFSv4 pNFS GETDEVICEINFO or LAYOUTGET operand in a UDP packet from a remote attacker. This type value is uninitialized upon encountering certain error conditions. This value is used as an array index for dereferencing, which leads to an OOPS and eventually a DoS of knfsd and a soft-lockup of the whole system."}, {"lang": "es", "value": "El servidor NFSv4 en el kernel de Linux en versiones anteriores a la 4.11.3 no valida correctamente el tipo de dise\u00f1o al procesar los operandos NFSv4 pNFS GETDEVICEINFO o LAYOUTGET en un paquete UDP de un atacante remoto. Este valor de tipo no se inicializa al encontrarse ciertas condiciones de error. Este valor se emplea como \u00edndice de arrays para desreferenciar, lo que conduce a un error OOPS y, finalmente, a una DoS de knfsd y a un bloqueo parcial de todo el sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.1.40", "matchCriteriaId": "D666D375-98D5-46EA-BE3F-818730173F5C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.70", "matchCriteriaId": "6B6B892D-2153-4B26-A53A-2757488ABBCD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.30", "matchCriteriaId": "05FA3C9C-F982-4407-89BC-F8936979C1D4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.11", "versionEndExcluding": "4.11.3", "matchCriteriaId": "E99AAEA7-96AE-4F7C-9347-B81325B63989"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b550a32e60a4941994b437a8d662432a486235a5", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f961e3f2acae94b727380c0b74e2d3954d0edf79", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.11.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/06/27/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/99298", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038790", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2437", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2669", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1466329", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/b550a32e60a4941994b437a8d662432a486235a5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f961e3f2acae94b727380c0b74e2d3954d0edf79", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b550a32e60a4941994b437a8d662432a486235a5"}}