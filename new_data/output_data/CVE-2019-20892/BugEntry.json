{"buggy_code": ["/*\n * snmp_client.c - a toolkit of common functions for an SNMP client.\n *\n */\n/* Portions of this file are subject to the following copyright(s).  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/**********************************************************************\n\tCopyright 1988, 1989, 1991, 1992 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n/*\n * Portions of this file are copyrighted by:\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n *\n * Portions of this file are copyrighted by:\n * Copyright (c) 2016 VMware, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n\n/** @defgroup snmp_client various PDU processing routines\n *  @ingroup library\n * \n *  @{\n */\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#include <stdio.h>\n#include <errno.h>\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <sys/types.h>\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#if HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#if HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#if HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#if HAVE_SYSLOG_H\n#include <syslog.h>\n#endif\n\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <net-snmp/types.h>\n\n#include <net-snmp/agent/ds_agent.h>\n#include <net-snmp/library/default_store.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/snmp_client.h>\n#include <net-snmp/library/snmp_secmod.h>\n#include <net-snmp/library/snmpusm.h>\n#include <net-snmp/library/mib.h>\n#include <net-snmp/library/snmp_logging.h>\n#include <net-snmp/library/snmp_assert.h>\n#include <net-snmp/library/large_fd_set.h>\n#include <net-snmp/pdu_api.h>\n\nnetsnmp_feature_child_of(snmp_client_all, libnetsnmp)\n\nnetsnmp_feature_child_of(snmp_split_pdu, snmp_client_all)\nnetsnmp_feature_child_of(snmp_reset_var_types, snmp_client_all)\nnetsnmp_feature_child_of(query_set_default_session, snmp_client_all)\nnetsnmp_feature_child_of(row_create, snmp_client_all)\n\n#ifndef BSD4_3\n#define BSD4_2\n#endif\n\n\n/*\n * Prototype definitions \n */\nstatic int      snmp_synch_input(int op, netsnmp_session * session,\n                                 int reqid, netsnmp_pdu *pdu, void *magic);\n\nnetsnmp_pdu    *\nsnmp_pdu_create(int command)\n{\n    netsnmp_pdu    *pdu;\n\n    pdu = (netsnmp_pdu *) calloc(1, sizeof(netsnmp_pdu));\n    if (pdu) {\n        pdu->version = SNMP_DEFAULT_VERSION;\n        pdu->command = command;\n        pdu->errstat = SNMP_DEFAULT_ERRSTAT;\n        pdu->errindex = SNMP_DEFAULT_ERRINDEX;\n        pdu->securityModel = SNMP_DEFAULT_SECMODEL;\n        pdu->transport_data = NULL;\n        pdu->transport_data_length = 0;\n        pdu->securityNameLen = 0;\n        pdu->contextNameLen = 0;\n        pdu->time = 0;\n        pdu->reqid = snmp_get_next_reqid();\n        pdu->msgid = snmp_get_next_msgid();\n    }\n    return pdu;\n\n}\n\n\n/*\n * Add a null variable with the requested name to the end of the list of\n * variables for this pdu.\n */\nnetsnmp_variable_list *\nsnmp_add_null_var(netsnmp_pdu *pdu, const oid * name, size_t name_length)\n{\n    return snmp_pdu_add_variable(pdu, name, name_length, ASN_NULL, NULL, 0);\n}\n\n\n#include <net-snmp/library/snmp_debug.h>\nstatic int\nsnmp_synch_input(int op,\n                 netsnmp_session * session,\n                 int reqid, netsnmp_pdu *pdu, void *magic)\n{\n    struct synch_state *state = (struct synch_state *) magic;\n    int             rpt_type;\n\n    if (reqid != state->reqid && pdu && pdu->command != SNMP_MSG_REPORT) {\n        DEBUGMSGTL((\"snmp_synch\", \"Unexpected response (ReqID: %d,%d - Cmd %d)\\n\",\n                                   reqid, state->reqid, pdu->command ));\n        return 0;\n    }\n\n    state->waiting = 0;\n    DEBUGMSGTL((\"snmp_synch\", \"Response (ReqID: %d - Cmd %d)\\n\",\n                               reqid, (pdu ? pdu->command : -1)));\n\n    if (op == NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE && pdu) {\n        if (pdu->command == SNMP_MSG_REPORT) {\n            rpt_type = snmpv3_get_report_type(pdu);\n            if (SNMPV3_IGNORE_UNAUTH_REPORTS ||\n                rpt_type == SNMPERR_NOT_IN_TIME_WINDOW) {\n                state->waiting = 1;\n            }\n            state->pdu = NULL;\n            state->status = STAT_ERROR;\n            session->s_snmp_errno = rpt_type;\n            SET_SNMP_ERROR(rpt_type);\n        } else if (pdu->command == SNMP_MSG_RESPONSE) {\n            /*\n             * clone the pdu to return to snmp_synch_response \n             */\n            state->pdu = snmp_clone_pdu(pdu);\n            state->status = STAT_SUCCESS;\n            session->s_snmp_errno = SNMPERR_SUCCESS;\n        }\n        else {\n            char msg_buf[50];\n            state->status = STAT_ERROR;\n            session->s_snmp_errno = SNMPERR_PROTOCOL;\n            SET_SNMP_ERROR(SNMPERR_PROTOCOL);\n            snprintf(msg_buf, sizeof(msg_buf), \"Expected RESPONSE-PDU but got %s-PDU\",\n                     snmp_pdu_type(pdu->command));\n            snmp_set_detail(msg_buf);\n            return 0;\n        }\n    } else if (op == NETSNMP_CALLBACK_OP_TIMED_OUT) {\n        state->pdu = NULL;\n        state->status = STAT_TIMEOUT;\n        session->s_snmp_errno = SNMPERR_TIMEOUT;\n        SET_SNMP_ERROR(SNMPERR_TIMEOUT);\n    } else if (op == NETSNMP_CALLBACK_OP_SEC_ERROR) {\n        state->pdu = NULL;\n        /*\n         * If we already have an error in status, then leave it alone.\n         */\n        if (state->status == STAT_SUCCESS) {\n            state->status = STAT_ERROR;\n            session->s_snmp_errno = SNMPERR_GENERR;\n            SET_SNMP_ERROR(SNMPERR_GENERR);\n        }\n    } else if (op == NETSNMP_CALLBACK_OP_DISCONNECT) {\n        state->pdu = NULL;\n        state->status = STAT_ERROR;\n        session->s_snmp_errno = SNMPERR_ABORT;\n        SET_SNMP_ERROR(SNMPERR_ABORT);\n    }\n    DEBUGMSGTL((\"snmp_synch\", \"status = %d errno = %d\\n\",\n                               state->status, session->s_snmp_errno));\n\n    return 1;\n}\n\n\n/*\n * Clone an SNMP variable data structure.\n * Sets pointers to structure private storage, or\n * allocates larger object identifiers and values as needed.\n *\n * Caller must make list association for cloned variable.\n *\n * Returns 0 if successful.\n */\nint\nsnmp_clone_var(netsnmp_variable_list * var, netsnmp_variable_list * newvar)\n{\n    if (!newvar || !var)\n        return 1;\n\n    memmove(newvar, var, sizeof(netsnmp_variable_list));\n    newvar->next_variable = NULL;\n    newvar->name = NULL;\n    newvar->val.string = NULL;\n    newvar->data = NULL;\n    newvar->dataFreeHook = NULL;\n    newvar->index = 0;\n\n    /*\n     * Clone the object identifier and the value.\n     * Allocate memory iff original will not fit into local storage.\n     */\n    if (snmp_set_var_objid(newvar, var->name, var->name_length))\n        return 1;\n\n    /*\n     * need a pointer to copy a string value. \n     */\n    if (var->val.string) {\n        if (var->val.string != &var->buf[0]) {\n            if (var->val_len <= sizeof(var->buf))\n                newvar->val.string = newvar->buf;\n            else {\n                newvar->val.string = (u_char *) malloc(var->val_len);\n                if (!newvar->val.string)\n                    return 1;\n            }\n            memmove(newvar->val.string, var->val.string, var->val_len);\n        } else {                /* fix the pointer to new local store */\n            newvar->val.string = newvar->buf;\n            /*\n             * no need for a memmove, since we copied the whole var\n             * struct (and thus var->buf) at the beginning of this function.\n             */\n        }\n    } else {\n        newvar->val.string = NULL;\n        newvar->val_len = 0;\n    }\n\n    return 0;\n}\n\n\n/*\n * Possibly make a copy of source memory buffer.\n * Will reset destination pointer if source pointer is NULL.\n * Returns 0 if successful, 1 if memory allocation fails.\n */\nint\nsnmp_clone_mem(void **dstPtr, const void *srcPtr, unsigned len)\n{\n    *dstPtr = NULL;\n    if (srcPtr) {\n        *dstPtr = malloc(len + 1);\n        if (!*dstPtr) {\n            return 1;\n        }\n        memmove(*dstPtr, srcPtr, len);\n        /*\n         * this is for those routines that expect 0-terminated strings!!!\n         * someone should rather have called strdup\n         */\n        ((char *) *dstPtr)[len] = 0;\n    }\n    return 0;\n}\n\n\n/*\n * Walks through a list of varbinds and frees and allocated memory,\n * restoring pointers to local buffers\n */\nvoid\nsnmp_reset_var_buffers(netsnmp_variable_list * var)\n{\n    while (var) {\n        if (var->name != var->name_loc) {\n            if(NULL != var->name)\n                free(var->name);\n            var->name = var->name_loc;\n            var->name_length = 0;\n        }\n        if (var->val.string != var->buf) {\n            if (NULL != var->val.string)\n                free(var->val.string);\n            var->val.string = var->buf;\n            var->val_len = 0;\n        }\n        var = var->next_variable;\n    }\n}\n\n/*\n * Creates and allocates a clone of the input PDU,\n * but does NOT copy the variables.\n * This function should be used with another function,\n * such as _copy_pdu_vars.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\nstatic\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n\n    if (!pdu)\n        return NULL;\n\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n\n    /*\n     * reset copied pointers if copy fails \n     */\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n\n    /*\n     * copy buffers individually. If any copy fails, all are freed. \n     */\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        /*\n         * call security model if it needs to know about this \n         */\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n\n    return newpdu;\n}\n\nstatic\nnetsnmp_variable_list *\n_copy_varlist(netsnmp_variable_list * var,      /* source varList */\n              int errindex,     /* index of variable to drop (if any) */\n              int copy_count)\n{                               /* !=0 number variables to copy */\n    netsnmp_variable_list *newhead, *newvar, *oldvar;\n    int             ii = 0;\n\n    newhead = NULL;\n    oldvar = NULL;\n\n    while (var && (copy_count-- > 0)) {\n        /*\n         * Drop the specified variable (if applicable) \n         * xxx hmm, is it intentional that dropping the errindex\n         *     counts towards copy_count?\n         */\n        if (++ii == errindex) {\n            var = var->next_variable;\n            continue;\n        }\n\n        /*\n         * clone the next variable. Cleanup if alloc fails \n         */\n        newvar = (netsnmp_variable_list *)\n            malloc(sizeof(netsnmp_variable_list));\n        if (snmp_clone_var(var, newvar)) {\n            if (newvar)\n                free((char *) newvar);\n            snmp_free_varbind(newhead);\n            return NULL;\n        }\n\n        /*\n         * add cloned variable to new list  \n         */\n        if (NULL == newhead)\n            newhead = newvar;\n        if (oldvar)\n            oldvar->next_variable = newvar;\n        oldvar = newvar;\n\n        var = var->next_variable;\n    }\n    return newhead;\n}\n\n\n/*\n * Copy some or all variables from source PDU to target PDU.\n * This function consolidates many of the needs of PDU variables:\n * Clone PDU : copy all the variables.\n * Split PDU : skip over some variables to copy other variables.\n * Fix PDU   : remove variable associated with error index.\n *\n * Designed to work with _clone_pdu_header.\n *\n * If drop_err is set, drop any variable associated with errindex.\n * If skip_count is set, skip the number of variable in pdu's list.\n * While copy_count is greater than zero, copy pdu variables to newpdu.\n *\n * If an error occurs, newpdu is freed and pointer is set to 0.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\nstatic\nnetsnmp_pdu    *\n_copy_pdu_vars(netsnmp_pdu *pdu,        /* source PDU */\n               netsnmp_pdu *newpdu,     /* target PDU */\n               int drop_err,    /* !=0 drop errored variable */\n               int skip_count,  /* !=0 number of variables to skip */\n               int copy_count)\n{                               /* !=0 number of variables to copy */\n    netsnmp_variable_list *var;\n#if TEMPORARILY_DISABLED\n    int             copied;\n#endif\n    int             drop_idx;\n\n    if (!newpdu)\n        return NULL;            /* where is PDU to copy to ? */\n\n    if (drop_err)\n        drop_idx = pdu->errindex - skip_count;\n    else\n        drop_idx = 0;\n\n    var = pdu->variables;\n    while (var && (skip_count-- > 0))   /* skip over pdu variables */\n        var = var->next_variable;\n\n#if TEMPORARILY_DISABLED\n    copied = 0;\n    if (pdu->flags & UCD_MSG_FLAG_FORCE_PDU_COPY)\n        copied = 1;             /* We're interested in 'empty' responses too */\n#endif\n\n    newpdu->variables = _copy_varlist(var, drop_idx, copy_count);\n#if TEMPORARILY_DISABLED\n    if (newpdu->variables)\n        copied = 1;\n#endif\n\n#if ALSO_TEMPORARILY_DISABLED\n    /*\n     * Error if bad errindex or if target PDU has no variables copied \n     */\n    if ((drop_err && (ii < pdu->errindex))\n#if TEMPORARILY_DISABLED\n        /*\n         * SNMPv3 engineID probes are allowed to be empty.\n         * See the comment in snmp_api.c for further details \n         */\n        || copied == 0\n#endif\n        ) {\n        snmp_free_pdu(newpdu);\n        return 0;\n    }\n#endif\n    return newpdu;\n}\n\n\n/*\n * Creates (allocates and copies) a clone of the input PDU.\n * If drop_err is set, don't copy any variable associated with errindex.\n * This function is called by snmp_clone_pdu and snmp_fix_pdu.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\nstatic\nnetsnmp_pdu    *\n_clone_pdu(netsnmp_pdu *pdu, int drop_err)\n{\n    netsnmp_pdu    *newpdu;\n    newpdu = _clone_pdu_header(pdu);\n    newpdu = _copy_pdu_vars(pdu, newpdu, drop_err, 0, 10000);   /* skip none, copy all */\n\n    return newpdu;\n}\n\n\n/*\n * This function will clone a full varbind list\n *\n * Returns a pointer to the cloned varbind list if successful.\n * Returns 0 if failure\n */\nnetsnmp_variable_list *\nsnmp_clone_varbind(netsnmp_variable_list * varlist)\n{\n    return _copy_varlist(varlist, 0, 10000);    /* skip none, copy all */\n}\n\n/*\n * This function will clone a PDU including all of its variables.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure\n */\nnetsnmp_pdu    *\nsnmp_clone_pdu(netsnmp_pdu *pdu)\n{\n    return _clone_pdu(pdu, 0);  /* copies all variables */\n}\n\n\n/*\n * This function will clone a PDU including some of its variables.\n *\n * If skip_count is not zero, it defines the number of variables to skip.\n * If copy_count is not zero, it defines the number of variables to copy.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\n#ifndef NETSNMP_FEATURE_REMOVE_SNMP_SPLIT_PDU\nnetsnmp_pdu    *\nsnmp_split_pdu(netsnmp_pdu *pdu, int skip_count, int copy_count)\n{\n    netsnmp_pdu    *newpdu;\n    newpdu = _clone_pdu_header(pdu);\n    newpdu = _copy_pdu_vars(pdu, newpdu, 0,     /* don't drop any variables */\n                            skip_count, copy_count);\n\n    return newpdu;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNMP_SPLIT_PDU */\n\n\n/*\n * If there was an error in the input pdu, creates a clone of the pdu\n * that includes all the variables except the one marked by the errindex.\n * The command is set to the input command and the reqid, errstat, and\n * errindex are set to default values.\n * If the error status didn't indicate an error, the error index didn't\n * indicate a variable, the pdu wasn't a get response message, the\n * marked variable was not present in the initial request, or there\n * would be no remaining variables, this function will return 0.\n * If everything was successful, a pointer to the fixed cloned pdu will\n * be returned.\n */\nnetsnmp_pdu    *\nsnmp_fix_pdu(netsnmp_pdu *pdu, int command)\n{\n    netsnmp_pdu    *newpdu;\n\n    if ((pdu->command != SNMP_MSG_RESPONSE)\n        || (pdu->errstat == SNMP_ERR_NOERROR)\n        || (NULL == pdu->variables)\n        || (pdu->errindex > (int)snmp_varbind_len(pdu))\n        || (pdu->errindex <= 0)) {\n        return NULL;            /* pre-condition tests fail */\n    }\n\n    newpdu = _clone_pdu(pdu, 1);        /* copies all except errored variable */\n    if (!newpdu)\n        return NULL;\n    if (!newpdu->variables) {\n        snmp_free_pdu(newpdu);\n        return NULL;            /* no variables. \"should not happen\" */\n    }\n    newpdu->command = command;\n    newpdu->reqid = snmp_get_next_reqid();\n    newpdu->msgid = snmp_get_next_msgid();\n    newpdu->errstat = SNMP_DEFAULT_ERRSTAT;\n    newpdu->errindex = SNMP_DEFAULT_ERRINDEX;\n\n    return newpdu;\n}\n\n\n/*\n * Returns the number of variables bound to a PDU structure\n */\nunsigned long\nsnmp_varbind_len(netsnmp_pdu *pdu)\n{\n    register netsnmp_variable_list *vars;\n    unsigned long   retVal = 0;\n    if (pdu)\n        for (vars = pdu->variables; vars; vars = vars->next_variable) {\n            retVal++;\n        }\n\n    return retVal;\n}\n\n/*\n * Add object identifier name to SNMP variable.\n * If the name is large, additional memory is allocated.\n * Returns 0 if successful.\n */\n\nint\nsnmp_set_var_objid(netsnmp_variable_list * vp,\n                   const oid * objid, size_t name_length)\n{\n    size_t          len = sizeof(oid) * name_length;\n\n    if (vp->name != vp->name_loc && vp->name != NULL) {\n        /*\n         * Probably previously-allocated \"big storage\".  Better free it\n         * else memory leaks possible.  \n         */\n        free(vp->name);\n    }\n\n    /*\n     * use built-in storage for smaller values \n     */\n    if (len <= sizeof(vp->name_loc)) {\n        vp->name = vp->name_loc;\n    } else {\n        vp->name = (oid *) malloc(len);\n        if (!vp->name)\n            return 1;\n    }\n    if (objid)\n        memmove(vp->name, objid, len);\n    vp->name_length = name_length;\n    return 0;\n}\n\n/**\n * snmp_set_var_typed_value is used to set data into the netsnmp_variable_list\n * structure.  Used to return data to the snmp request via the\n * netsnmp_request_info structure's requestvb pointer.\n *\n * @param newvar   the structure gets populated with the given data, type,\n *                 val_str, and val_len.\n * @param type     is the asn data type to be copied\n * @param val_str  is a buffer containing the value to be copied into the\n *                 newvar structure. \n * @param val_len  the length of val_str\n * \n * @return returns 0 on success and 1 on a malloc error\n */\n\nint\nsnmp_set_var_typed_value(netsnmp_variable_list * newvar, u_char type,\n                         const void * val_str, size_t val_len)\n{\n    newvar->type = type;\n    return snmp_set_var_value(newvar, val_str, val_len);\n}\n\nint\nsnmp_set_var_typed_integer(netsnmp_variable_list * newvar,\n                           u_char type, long val)\n{\n    newvar->type = type;\n    return snmp_set_var_value(newvar, &val, sizeof(long));\n}\n\nint\ncount_varbinds(netsnmp_variable_list * var_ptr)\n{\n    int             count = 0;\n\n    for (; var_ptr != NULL; var_ptr = var_ptr->next_variable)\n        count++;\n\n    return count;\n}\n\nnetsnmp_feature_child_of(count_varbinds_of_type, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_COUNT_VARBINDS_OF_TYPE\nint\ncount_varbinds_of_type(netsnmp_variable_list * var_ptr, u_char type)\n{\n    int             count = 0;\n\n    for (; var_ptr != NULL; var_ptr = var_ptr->next_variable)\n        if (var_ptr->type == type)\n            count++;\n\n    return count;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_COUNT_VARBINDS_OF_TYPE */\n\nnetsnmp_feature_child_of(find_varind_of_type, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_FIND_VARIND_OF_TYPE\nnetsnmp_variable_list *\nfind_varbind_of_type(netsnmp_variable_list * var_ptr, u_char type)\n{\n    for (; var_ptr != NULL && var_ptr->type != type;\n         var_ptr = var_ptr->next_variable);\n\n    return var_ptr;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_FIND_VARIND_OF_TYPE */\n\nnetsnmp_variable_list*\nfind_varbind_in_list( netsnmp_variable_list *vblist,\n                      const oid *name, size_t len)\n{\n    for (; vblist != NULL; vblist = vblist->next_variable)\n        if (!snmp_oid_compare(vblist->name, vblist->name_length, name, len))\n            return vblist;\n\n    return NULL;\n}\n\n/*\n * Add some value to SNMP variable.\n * If the value is large, additional memory is allocated.\n * Returns 0 if successful.\n */\n\nint\nsnmp_set_var_value(netsnmp_variable_list * vars,\n                   const void * value, size_t len)\n{\n    int             largeval = 1;\n\n    /*\n     * xxx-rks: why the unconditional free? why not use existing\n     * memory, if len < vars->val_len ?\n     */\n    if (vars->val.string && vars->val.string != vars->buf) {\n        free(vars->val.string);\n    }\n    vars->val.string = NULL;\n    vars->val_len = 0;\n\n    if (value == NULL && len > 0) {\n        snmp_log(LOG_ERR, \"bad size for NULL value\\n\");\n        return 1;\n    }\n\n    /*\n     * use built-in storage for smaller values \n     */\n    if (len <= sizeof(vars->buf)) {\n        vars->val.string = (u_char *) vars->buf;\n        largeval = 0;\n    }\n\n    if ((0 == len) || (NULL == value)) {\n        vars->val.string[0] = 0;\n        return 0;\n    }\n\n    vars->val_len = len;\n    switch (vars->type) {\n    case ASN_INTEGER:\n    case ASN_UNSIGNED:\n    case ASN_TIMETICKS:\n    case ASN_COUNTER:\n    case ASN_UINTEGER:\n        if (vars->val_len == sizeof(int)) {\n            if (ASN_INTEGER == vars->type) {\n                const int      *val_int \n                    = (const int *) value;\n                *(vars->val.integer) = (long) *val_int;\n            } else {\n                const u_int    *val_uint\n                    = (const u_int *) value;\n                *(vars->val.integer) = (unsigned long) *val_uint;\n            }\n        }\n#if SIZEOF_LONG != SIZEOF_INT\n        else if (vars->val_len == sizeof(long)){\n            const u_long   *val_ulong\n                = (const u_long *) value;\n            *(vars->val.integer) = *val_ulong;\n            if (*(vars->val.integer) > 0xffffffff) {\n                snmp_log(LOG_ERR,\"truncating integer value > 32 bits\\n\");\n                *(vars->val.integer) &= 0xffffffff;\n            }\n        }\n#endif\n#if defined(SIZEOF_LONG_LONG) && (SIZEOF_LONG != SIZEOF_LONG_LONG)\n#if !defined(SIZEOF_INTMAX_T) || (SIZEOF_LONG_LONG != SIZEOF_INTMAX_T)\n        else if (vars->val_len == sizeof(long long)){\n            const unsigned long long   *val_ullong\n                = (const unsigned long long *) value;\n            *(vars->val.integer) = (long) *val_ullong;\n            if (*(vars->val.integer) > 0xffffffff) {\n                snmp_log(LOG_ERR,\"truncating integer value > 32 bits\\n\");\n                *(vars->val.integer) &= 0xffffffff;\n            }\n        }\n#endif\n#endif\n#if defined(SIZEOF_INTMAX_T) && (SIZEOF_LONG != SIZEOF_INTMAX_T)\n        else if (vars->val_len == sizeof(intmax_t)){\n            const uintmax_t *val_uintmax_t\n                = (const uintmax_t *) value;\n            *(vars->val.integer) = (long) *val_uintmax_t;\n            if (*(vars->val.integer) > 0xffffffff) {\n                snmp_log(LOG_ERR,\"truncating integer value > 32 bits\\n\");\n                *(vars->val.integer) &= 0xffffffff;\n            }\n        }\n#endif\n#if SIZEOF_SHORT != SIZEOF_INT\n        else if (vars->val_len == sizeof(short)) {\n            if (ASN_INTEGER == vars->type) {\n                const short      *val_short \n                    = (const short *) value;\n                *(vars->val.integer) = (long) *val_short;\n            } else {\n                const u_short    *val_ushort\n                    = (const u_short *) value;\n                *(vars->val.integer) = (unsigned long) *val_ushort;\n            }\n        }\n#endif\n        else if (vars->val_len == sizeof(char)) {\n            if (ASN_INTEGER == vars->type) {\n                const char      *val_char \n                    = (const char *) value;\n                *(vars->val.integer) = (long) *val_char;\n            } else {\n                    const u_char    *val_uchar\n                    = (const u_char *) value;\n                *(vars->val.integer) = (unsigned long) *val_uchar;\n            }\n        }\n        else {\n            snmp_log(LOG_ERR,\"bad size for integer-like type (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(long);\n        break;\n\n    case ASN_OBJECT_ID:\n    case ASN_PRIV_IMPLIED_OBJECT_ID:\n    case ASN_PRIV_INCL_RANGE:\n    case ASN_PRIV_EXCL_RANGE:\n        if (largeval) {\n            vars->val.objid = (oid *) malloc(vars->val_len);\n        }\n        if (vars->val.objid == NULL) {\n            snmp_log(LOG_ERR,\"no storage for OID\\n\");\n            return 1;\n        }\n        memmove(vars->val.objid, value, vars->val_len);\n        break;\n\n    case ASN_IPADDRESS: /* snmp_build_var_op treats IPADDR like a string */\n        if (4 != vars->val_len) {\n            netsnmp_assert(\"ipaddress length == 4\");\n        }\n        /* FALL THROUGH */\n    case ASN_PRIV_IMPLIED_OCTET_STR:\n    case ASN_OCTET_STR:\n    case ASN_BIT_STR:\n    case ASN_OPAQUE:\n    case ASN_NSAP:\n        if (vars->val_len >= sizeof(vars->buf)) {\n            vars->val.string = (u_char *) malloc(vars->val_len + 1);\n        }\n        if (vars->val.string == NULL) {\n            snmp_log(LOG_ERR,\"no storage for string\\n\");\n            return 1;\n        }\n        memmove(vars->val.string, value, vars->val_len);\n        /*\n         * Make sure the string is zero-terminated; some bits of code make\n         * this assumption.  Easier to do this here than fix all these wrong\n         * assumptions.  \n         */\n        vars->val.string[vars->val_len] = '\\0';\n        break;\n\n    case SNMP_NOSUCHOBJECT:\n    case SNMP_NOSUCHINSTANCE:\n    case SNMP_ENDOFMIBVIEW:\n    case ASN_NULL:\n        vars->val_len = 0;\n        vars->val.string = NULL;\n        break;\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_U64:\n    case ASN_OPAQUE_I64:\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n    case ASN_COUNTER64:\n        if (largeval) {\n            snmp_log(LOG_ERR,\"bad size for counter 64 (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(struct counter64);\n        memmove(vars->val.counter64, value, vars->val_len);\n        break;\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_FLOAT:\n        if (largeval) {\n            snmp_log(LOG_ERR,\"bad size for opaque float (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(float);\n        memmove(vars->val.floatVal, value, vars->val_len);\n        break;\n\n    case ASN_OPAQUE_DOUBLE:\n        if (largeval) {\n            snmp_log(LOG_ERR,\"bad size for opaque double (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(double);\n        memmove(vars->val.doubleVal, value, vars->val_len);\n        break;\n\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n\n    default:\n        snmp_log(LOG_ERR,\"Internal error in type switching\\n\");\n        snmp_set_detail(\"Internal error in type switching\\n\");\n        return (1);\n    }\n\n    return 0;\n}\n\nvoid\nsnmp_replace_var_types(netsnmp_variable_list * vbl, u_char old_type,\n                       u_char new_type)\n{\n    while (vbl) {\n        if (vbl->type == old_type) {\n            snmp_set_var_typed_value(vbl, new_type, NULL, 0);\n        }\n        vbl = vbl->next_variable;\n    }\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SNMP_RESET_VAR_TYPES\nvoid\nsnmp_reset_var_types(netsnmp_variable_list * vbl, u_char new_type)\n{\n    while (vbl) {\n        snmp_set_var_typed_value(vbl, new_type, NULL, 0);\n        vbl = vbl->next_variable;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNMP_RESET_VAR_TYPES */\n\nint\nsnmp_synch_response_cb(netsnmp_session * ss,\n                       netsnmp_pdu *pdu,\n                       netsnmp_pdu **response, snmp_callback pcb)\n{\n    struct synch_state    lstate, *state;\n    snmp_callback         cbsav;\n    void                 *cbmagsav;\n    int                   numfds, count;\n    netsnmp_large_fd_set  fdset;\n    struct timeval        timeout, *tvp;\n    int                   block;\n\n    memset((void *) &lstate, 0, sizeof(lstate));\n    state = &lstate;\n    cbsav = ss->callback;\n    cbmagsav = ss->callback_magic;\n    ss->callback = pcb;\n    ss->callback_magic = (void *) state;\n    netsnmp_large_fd_set_init(&fdset, FD_SETSIZE);\n\n    if (snmp_send(ss, pdu) == 0) {\n        snmp_free_pdu(pdu);\n        state->status = STAT_ERROR;\n    } else {\n        state->reqid = pdu->reqid;\n        state->waiting = 1;\n    }\n\n    while (state->waiting) {\n        numfds = 0;\n        NETSNMP_LARGE_FD_ZERO(&fdset);\n        block = NETSNMP_SNMPBLOCK;\n        tvp = &timeout;\n        timerclear(tvp);\n        snmp_sess_select_info2_flags(NULL, &numfds, &fdset, tvp, &block,\n                                     NETSNMP_SELECT_NOALARMS);\n        if (block == 1)\n            tvp = NULL;         /* block without timeout */\n        count = netsnmp_large_fd_set_select(numfds, &fdset, NULL, NULL, tvp);\n        if (count > 0) {\n            snmp_read2(&fdset);\n        } else {\n            switch (count) {\n            case 0:\n                snmp_timeout();\n                break;\n            case -1:\n                if (errno == EINTR) {\n                    continue;\n                } else {\n                    snmp_errno = SNMPERR_GENERR;    /*MTCRITICAL_RESOURCE */\n                    /*\n                     * CAUTION! if another thread closed the socket(s)\n                     * waited on here, the session structure was freed.\n                     * It would be nice, but we can't rely on the pointer.\n                     * ss->s_snmp_errno = SNMPERR_GENERR;\n                     * ss->s_errno = errno;\n                     */\n                    snmp_set_detail(strerror(errno));\n                }\n                /* FALLTHRU */\n            default:\n                state->status = STAT_ERROR;\n                state->waiting = 0;\n            }\n        }\n\n        if ( ss->flags & SNMP_FLAGS_RESP_CALLBACK ) {\n            void (*cb)(void);\n            cb = (void (*)(void))(ss->myvoid);\n            cb();        /* Used to invoke 'netsnmp_check_outstanding_agent_requests();'\n                            on internal AgentX queries.  */\n        }\n    }\n    *response = state->pdu;\n    ss->callback = cbsav;\n    ss->callback_magic = cbmagsav;\n    netsnmp_large_fd_set_cleanup(&fdset);\n    return state->status;\n}\n\nint\nsnmp_synch_response(netsnmp_session * ss,\n                    netsnmp_pdu *pdu, netsnmp_pdu **response)\n{\n    return snmp_synch_response_cb(ss, pdu, response, snmp_synch_input);\n}\n\nint\nsnmp_sess_synch_response(void *sessp,\n                         netsnmp_pdu *pdu, netsnmp_pdu **response)\n{\n    netsnmp_session      *ss;\n    struct synch_state    lstate, *state;\n    snmp_callback         cbsav;\n    void                 *cbmagsav;\n    int                   numfds, count;\n    netsnmp_large_fd_set  fdset;\n    struct timeval        timeout, *tvp;\n    int                   block;\n\n    ss = snmp_sess_session(sessp);\n    if (ss == NULL) {\n        return STAT_ERROR;\n    }\n\n    memset((void *) &lstate, 0, sizeof(lstate));\n    state = &lstate;\n    cbsav = ss->callback;\n    cbmagsav = ss->callback_magic;\n    ss->callback = snmp_synch_input;\n    ss->callback_magic = (void *) state;\n    netsnmp_large_fd_set_init(&fdset, FD_SETSIZE);\n\n    if (snmp_sess_send(sessp, pdu) == 0) {\n        snmp_free_pdu(pdu);\n        state->status = STAT_ERROR;\n    } else {\n        state->waiting = 1;\n        state->reqid = pdu->reqid;\n    }\n\n    while (state->waiting) {\n        numfds = 0;\n        NETSNMP_LARGE_FD_ZERO(&fdset);\n        block = NETSNMP_SNMPBLOCK;\n        tvp = &timeout;\n        timerclear(tvp);\n        snmp_sess_select_info2_flags(sessp, &numfds, &fdset, tvp, &block,\n                                     NETSNMP_SELECT_NOALARMS);\n        if (block == 1)\n            tvp = NULL;         /* block without timeout */\n        count = netsnmp_large_fd_set_select(numfds, &fdset, NULL, NULL, tvp);\n        if (count > 0) {\n            snmp_sess_read2(sessp, &fdset);\n        } else\n            switch (count) {\n            case 0:\n                snmp_sess_timeout(sessp);\n                break;\n            case -1:\n                if (errno == EINTR) {\n                    continue;\n                } else {\n                    snmp_errno = SNMPERR_GENERR;    /*MTCRITICAL_RESOURCE */\n                    /*\n                     * CAUTION! if another thread closed the socket(s)\n                     * waited on here, the session structure was freed.\n                     * It would be nice, but we can't rely on the pointer.\n                     * ss->s_snmp_errno = SNMPERR_GENERR;\n                     * ss->s_errno = errno;\n                     */\n                    snmp_set_detail(strerror(errno));\n                }\n                /* FALLTHRU */\n            default:\n                state->status = STAT_ERROR;\n                state->waiting = 0;\n            }\n    }\n    *response = state->pdu;\n    ss->callback = cbsav;\n    ss->callback_magic = cbmagsav;\n    netsnmp_large_fd_set_cleanup(&fdset);\n    return state->status;\n}\n\n\nconst char     *\nsnmp_errstring(int errstat)\n{\n    const char * const error_string[19] = {\n        \"(noError) No Error\",\n        \"(tooBig) Response message would have been too large.\",\n        \"(noSuchName) There is no such variable name in this MIB.\",\n        \"(badValue) The value given has the wrong type or length.\",\n        \"(readOnly) The two parties used do not have access to use the specified SNMP PDU.\",\n        \"(genError) A general failure occured\",\n        \"noAccess\",\n        \"wrongType (The set datatype does not match the data type the agent expects)\",\n        \"wrongLength (The set value has an illegal length from what the agent expects)\",\n        \"wrongEncoding\",\n        \"wrongValue (The set value is illegal or unsupported in some way)\",\n        \"noCreation (That table does not support row creation or that object can not ever be created)\",\n        \"inconsistentValue (The set value is illegal or unsupported in some way)\",\n        \"resourceUnavailable (This is likely a out-of-memory failure within the agent)\",\n        \"commitFailed\",\n        \"undoFailed\",\n        \"authorizationError (access denied to that object)\",\n        \"notWritable (That object does not support modification)\",\n        \"inconsistentName (That object can not currently be created)\"\n    };\n\n    if (errstat <= MAX_SNMP_ERR && errstat >= SNMP_ERR_NOERROR) {\n        return error_string[errstat];\n    } else {\n        return \"Unknown Error\";\n    }\n}\n\n\n\n/*\n *\n *  Convenience routines to make various requests\n *  over the specified SNMP session.\n *\n */\n#include <net-snmp/library/snmp_debug.h>\n\nstatic netsnmp_session *_def_query_session = NULL;\n\n#ifndef NETSNMP_FEATURE_REMOVE_QUERY_SET_DEFAULT_SESSION\nvoid\nnetsnmp_query_set_default_session( netsnmp_session *sess) {\n    DEBUGMSGTL((\"iquery\", \"set default session %p\\n\", sess));\n    _def_query_session = sess;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_QUERY_SET_DEFAULT_SESSION */\n\n/**\n * Return a pointer to the default internal query session.\n */\nnetsnmp_session *\nnetsnmp_query_get_default_session_unchecked( void ) {\n    DEBUGMSGTL((\"iquery\", \"get default session %p\\n\", _def_query_session));\n    return _def_query_session;\n}\n\n/**\n * Return a pointer to the default internal query session and log a\n * warning message once if this session does not exist.\n */\nnetsnmp_session *\nnetsnmp_query_get_default_session( void ) {\n    static int warning_logged = 0;\n\n    if (! _def_query_session && ! warning_logged) {\n        if (! netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID,\n                                    NETSNMP_DS_AGENT_INTERNAL_SECNAME)) {\n            snmp_log(LOG_WARNING,\n                     \"iquerySecName has not been configured - internal queries will fail\\n\");\n        } else {\n            snmp_log(LOG_WARNING,\n                     \"default session is not available - internal queries will fail\\n\");\n        }\n        warning_logged = 1;\n    }\n\n    return netsnmp_query_get_default_session_unchecked();\n}\n\n\n/*\n * Internal utility routine to actually send the query\n */\nstatic int _query(netsnmp_variable_list *list,\n                  int                    request,\n                  netsnmp_session       *session) {\n\n    netsnmp_pdu *pdu;\n    netsnmp_pdu *response = NULL;\n    netsnmp_variable_list *vb1, *vb2, *vtmp;\n    int ret, count;\n\n    DEBUGMSGTL((\"iquery\", \"query on session %p\\n\", session));\n\n    if (NULL == list) {\n        snmp_log(LOG_ERR, \"empty variable list in _query\\n\");\n        return SNMP_ERR_GENERR;\n    }\n\n    pdu = snmp_pdu_create( request );\n    if (NULL == pdu) {\n        snmp_log(LOG_ERR, \"could not allocate pdu\\n\");\n        return SNMP_ERR_GENERR;\n    }\n\n    /*\n     * Clone the varbind list into the request PDU...\n     */\n    pdu->variables = snmp_clone_varbind( list );\n    if (NULL == pdu->variables) {\n        snmp_log(LOG_ERR, \"could not clone variable list\\n\");\n        snmp_free_pdu(pdu);\n        return SNMP_ERR_GENERR;\n    }\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nretry:\n#endif\n    if ( session )\n        ret = snmp_synch_response(            session, pdu, &response );\n    else if (_def_query_session)\n        ret = snmp_synch_response( _def_query_session, pdu, &response );\n    else {\n        /* No session specified */\n        snmp_free_pdu(pdu);\n        return SNMP_ERR_GENERR;\n    }\n    DEBUGMSGTL((\"iquery\", \"query returned %d\\n\", ret));\n\n    /*\n     * ....then copy the results back into the\n     * list (assuming the request succeeded!).\n     * This avoids having to worry about how this\n     * list was originally allocated.\n     */\n    if ( ret == SNMP_ERR_NOERROR ) {\n        if ( response->errstat != SNMP_ERR_NOERROR ) {\n            DEBUGMSGT((\"iquery\", \"Error in packet: %s\\n\",\n                       snmp_errstring(response->errstat)));\n            /*\n             * If the request failed, then remove the\n             *  offending varbind and try again.\n             *  (all except SET requests)\n             *\n             * XXX - implement a library version of\n             *       NETSNMP_DS_APP_DONT_FIX_PDUS ??\n             */\n            ret = response->errstat;\n            if (response->errindex != 0) {\n                DEBUGMSGT((\"iquery:result\", \"Failed object:\\n\"));\n                for (count = 1, vtmp = response->variables;\n                     vtmp && count != response->errindex;\n                     vtmp = vtmp->next_variable, count++)\n                    /*EMPTY*/;\n                if (vtmp)\n                    DEBUGMSGVAR((\"iquery:result\", vtmp));\n                DEBUGMSG((\"iquery:result\", \"\\n\"));\n            }\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n            if (request != SNMP_MSG_SET &&\n                response->errindex != 0) {\n                DEBUGMSGTL((\"iquery\", \"retrying query (%d, %ld)\\n\", ret, response->errindex));\n                pdu = snmp_fix_pdu( response, request );\n                snmp_free_pdu( response );\n                response = NULL;\n                if ( pdu != NULL )\n                    goto retry;\n            }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n        } else {\n            for (vb1 = response->variables, vb2 = list;\n                 vb1;\n                 vb1 = vb1->next_variable,  vb2 = vb2->next_variable) {\n                DEBUGMSGVAR((\"iquery:result\", vb1));\n                DEBUGMSG((\"iquery:results\", \"\\n\"));\n                if ( !vb2 ) {\n                    ret = SNMP_ERR_GENERR;\n                    break;\n                }\n                vtmp = vb2->next_variable;\n                snmp_free_var_internals( vb2 );\n                snmp_clone_var( vb1, vb2 ); /* xxx: check return? */\n                vb2->next_variable = vtmp;\n            }\n        }\n    } else {\n        /* Distinguish snmp_send errors from SNMP errStat errors */\n        ret = -ret;\n    }\n    snmp_free_pdu( response );\n    return ret;\n}\n\n/*\n * These are simple wrappers round the internal utility routine\n */\nint netsnmp_query_get(netsnmp_variable_list *list,\n                      netsnmp_session       *session){\n    return _query( list, SNMP_MSG_GET, session );\n}\n\n\nint netsnmp_query_getnext(netsnmp_variable_list *list,\n                          netsnmp_session       *session){\n    return _query( list, SNMP_MSG_GETNEXT, session );\n}\n\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nint netsnmp_query_set(netsnmp_variable_list *list,\n                      netsnmp_session       *session){\n    return _query( list, SNMP_MSG_SET, session );\n}\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n\n/*\n * A walk needs a bit more work.\n */\nint netsnmp_query_walk(netsnmp_variable_list *list,\n                       netsnmp_session       *session) {\n    /*\n     * Create a working copy of the original (single)\n     * varbind, so we can use this varbind parameter\n     * to check when we've finished walking this subtree.\n     */\n    netsnmp_variable_list *vb = snmp_clone_varbind( list );\n    netsnmp_variable_list *res_list = NULL;\n    netsnmp_variable_list *res_last = NULL;\n    int ret;\n\n    /*\n     * Now walk the tree as usual\n     */\n    ret = _query( vb, SNMP_MSG_GETNEXT, session );\n    while ( ret == SNMP_ERR_NOERROR &&\n        snmp_oidtree_compare( list->name, list->name_length,\n                                vb->name,   vb->name_length ) == 0) {\n\n\tif (vb->type == SNMP_ENDOFMIBVIEW ||\n\t    vb->type == SNMP_NOSUCHOBJECT ||\n\t    vb->type == SNMP_NOSUCHINSTANCE)\n\t    break;\n\n        /*\n         * Copy each response varbind to the end of the result list\n         * and then re-use this to ask for the next entry.\n         */\n        if ( res_last ) {\n            res_last->next_variable = snmp_clone_varbind( vb );\n            res_last = res_last->next_variable;\n        } else {\n            res_list = snmp_clone_varbind( vb );\n            res_last = res_list;\n        }\n        ret = _query( vb, SNMP_MSG_GETNEXT, session );\n    }\n    /*\n     * Copy the first result back into the original varbind parameter,\n     * add the rest of the results (if any), and clean up.\n     */\n    if ( res_list ) {\n        snmp_clone_var( res_list, list );\n        list->next_variable = res_list->next_variable;\n        res_list->next_variable = NULL;\n        snmp_free_varbind( res_list );\n    }\n    snmp_free_varbind( vb );\n    return ret;\n}\n\n/** **************************************************************************\n *\n * state machine\n *\n */\nint\nnetsnmp_state_machine_run( netsnmp_state_machine_input *input)\n{\n    netsnmp_state_machine_step *current, *last;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->steps, SNMPERR_GENERR );\n    last = current = input->steps;\n\n    DEBUGMSGT((\"state_machine:run\", \"starting step: %s\\n\", current->name));\n\n    while (current) {\n\n        /*\n         * log step and check for required data\n         */\n        DEBUGMSGT((\"state_machine:run\", \"at step: %s\\n\", current->name));\n        if (NULL == current->run) {\n            DEBUGMSGT((\"state_machine:run\", \"no run step\\n\"));\n            current->result = last->result;\n            break;\n        }\n\n        /*\n         * run step\n         */\n        DEBUGMSGT((\"state_machine:run\", \"running step: %s\\n\", current->name));\n        current->result = (*current->run)( input, current );\n        ++input->steps_so_far;\n        \n        /*\n         * log result and move to next step\n         */\n        input->last_run = current;\n        DEBUGMSGT((\"state_machine:run:result\", \"step %s returned %d\\n\",\n                   current->name, current->result));\n        if (SNMPERR_SUCCESS == current->result)\n            current = current->on_success;\n        else if (SNMPERR_ABORT == current->result) {\n            DEBUGMSGT((\"state_machine:run:result\", \"ABORT from %s\\n\",\n                       current->name));\n            break;\n        }\n        else\n            current = current->on_error;\n    }\n\n    /*\n     * run cleanup\n     */\n    if ((input->cleanup) && (input->cleanup->run))\n        (*input->cleanup->run)( input, input->last_run );\n\n    return input->last_run->result;\n}\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n#ifndef NETSNMP_FEATURE_REMOVE_ROW_CREATE\n/** **************************************************************************\n *\n * row create state machine steps\n *\n */\ntypedef struct rowcreate_state_s {\n\n    netsnmp_session        *session;\n    netsnmp_variable_list  *vars;\n    int                     row_status_index;\n} rowcreate_state;\n\nstatic netsnmp_variable_list *\n_get_vb_num(netsnmp_variable_list *vars, int index)\n{\n    for (; vars && index > 0; --index)\n        vars = vars->next_variable;\n\n    if (!vars || index > 0)\n        return NULL;\n    \n    return vars;\n}\n\n\n/*\n * cleanup\n */\nstatic int \n_row_status_state_cleanup(netsnmp_state_machine_input *input,\n                 netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_ABORT );\n    netsnmp_require_ptr_LRV( step, SNMPERR_ABORT );\n\n    DEBUGMSGT((\"row_create:called\", \"_row_status_state_cleanup, last run step was %s rc %d\\n\",\n               step->name, step->result));\n\n    ctx = (rowcreate_state *)input->input_context;\n    if (ctx && ctx->vars)\n        snmp_free_varbind( ctx->vars );\n\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * send a request to activate the row\n */\nstatic int \n_row_status_state_activate(netsnmp_state_machine_input *input,\n                  netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *rs_var, *var = NULL;\n    int32_t                rc, val = RS_ACTIVE;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    /*\n     * just send the rowstatus varbind\n     */\n    rs_var = _get_vb_num(ctx->vars, ctx->row_status_index);\n    netsnmp_require_ptr_LRV(rs_var, SNMPERR_GENERR);\n\n    var = snmp_varlist_add_variable(&var, rs_var->name, rs_var->name_length,\n                                    rs_var->type, &val, sizeof(val));\n    netsnmp_require_ptr_LRV( var, SNMPERR_GENERR );\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( var, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(var);\n\n    return rc;\n}\n\n/*\n * send each non-row status column, one at a time\n */\nstatic int \n_row_status_state_single_value_cols(netsnmp_state_machine_input *input,\n                                    netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *var, *tmp_next, *row_status;\n    int                    rc = SNMPERR_GENERR;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    row_status = _get_vb_num(ctx->vars, ctx->row_status_index);\n    netsnmp_require_ptr_LRV(row_status, SNMPERR_GENERR);\n\n    /*\n     * try one varbind at a time\n     */\n    for (var = ctx->vars; var; var = var->next_variable) {\n        if (var == row_status)\n            continue;\n\n        tmp_next = var->next_variable;\n        var->next_variable = NULL;\n\n        /*\n         * send set\n         */\n        rc = netsnmp_query_set( var, ctx->session );\n        var->next_variable = tmp_next;\n        if (-2 == rc)\n            rc = SNMPERR_ABORT;\n        if (rc != SNMPERR_SUCCESS)\n            break;\n    }\n\n    return rc;\n}\n\n/*\n * send all values except row status\n */\nstatic int \n_row_status_state_multiple_values_cols(netsnmp_state_machine_input *input,\n                                       netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *vars, *var, *last, *row_status;\n    int                    rc;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    vars = snmp_clone_varbind(ctx->vars);\n    netsnmp_require_ptr_LRV(vars, SNMPERR_GENERR);\n\n    row_status = _get_vb_num(vars, ctx->row_status_index);\n    if (NULL == row_status) {\n        snmp_free_varbind(vars);\n        return SNMPERR_GENERR;\n    }\n\n    /*\n     * remove row status varbind\n     */\n    if (row_status == vars) {\n        vars = row_status->next_variable;\n        row_status->next_variable = NULL;\n    }\n    else {\n        for (last=vars, var=last->next_variable;\n             var;\n             last=var, var = var->next_variable) {\n            if (var == row_status) {\n                last->next_variable = var->next_variable;\n                break;\n            }\n        }\n    }\n    snmp_free_var(row_status);\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( vars, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(vars);\n\n    return rc;\n}\n\n/*\n * send a createAndWait request with no other values\n */\nstatic int \n_row_status_state_single_value_createAndWait(netsnmp_state_machine_input *input,\n                                             netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *var = NULL, *rs_var;\n    int32_t                rc, val = RS_CREATEANDWAIT;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    rs_var = _get_vb_num(ctx->vars, ctx->row_status_index);\n    netsnmp_require_ptr_LRV(rs_var, SNMPERR_GENERR);\n\n    var = snmp_varlist_add_variable(&var, rs_var->name, rs_var->name_length,\n                                    rs_var->type, &val, sizeof(val));\n    netsnmp_require_ptr_LRV(var, SNMPERR_GENERR);\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( var, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(var);\n\n    return rc;\n}\n\n/*\n * send a creatAndWait request with all values\n */\nstatic int \n_row_status_state_all_values_createAndWait(netsnmp_state_machine_input *input,\n                                           netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *vars, *rs_var;\n    int                    rc;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    vars = snmp_clone_varbind(ctx->vars);\n    netsnmp_require_ptr_LRV(vars, SNMPERR_GENERR);\n\n    /*\n     * make sure row stats is createAndWait\n     */\n    rs_var = _get_vb_num(vars, ctx->row_status_index);\n    if (NULL == rs_var) {\n        snmp_free_varbind(vars);\n        return SNMPERR_GENERR;\n    }\n\n    if (*rs_var->val.integer != RS_CREATEANDWAIT)\n        *rs_var->val.integer = RS_CREATEANDWAIT;\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( vars, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(vars);\n\n    return rc;\n}\n\n\n/**\n * send createAndGo request with all values\n */\nstatic int \n_row_status_state_all_values_createAndGo(netsnmp_state_machine_input *input,\n                                         netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *vars, *rs_var;\n    int                    rc;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    vars = snmp_clone_varbind(ctx->vars);\n    netsnmp_require_ptr_LRV(vars, SNMPERR_GENERR);\n\n    /*\n     * make sure row stats is createAndGo\n     */\n    rs_var = _get_vb_num(vars, ctx->row_status_index + 1);\n    if (NULL == rs_var) {\n        snmp_free_varbind(vars);\n        return SNMPERR_GENERR;\n    }\n\n    if (*rs_var->val.integer != RS_CREATEANDGO)\n        *rs_var->val.integer = RS_CREATEANDGO;\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( vars, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(vars);\n\n    return rc;\n}\n\n/** **************************************************************************\n *\n * row api\n *\n */\nint\nnetsnmp_row_create(netsnmp_session *sess, netsnmp_variable_list *vars,\n                   int row_status_index)\n{\n    netsnmp_state_machine_step rc_cleanup =\n        { \"row_create_cleanup\", 0, _row_status_state_cleanup,\n          0, NULL, NULL, 0, NULL };\n    netsnmp_state_machine_step rc_activate =\n        { \"row_create_activate\", 0, _row_status_state_activate,\n          0, NULL, NULL, 0, NULL };\n    netsnmp_state_machine_step rc_sv_cols =\n        { \"row_create_single_value_cols\", 0,\n          _row_status_state_single_value_cols, 0, &rc_activate,NULL, 0, NULL };\n    netsnmp_state_machine_step rc_mv_cols =\n        { \"row_create_multiple_values_cols\", 0,\n          _row_status_state_multiple_values_cols, 0, &rc_activate, &rc_sv_cols,\n          0, NULL };\n    netsnmp_state_machine_step rc_sv_caw =\n        { \"row_create_single_value_createAndWait\", 0,\n          _row_status_state_single_value_createAndWait, 0, &rc_mv_cols, NULL,\n          0, NULL };\n    netsnmp_state_machine_step rc_av_caw =\n        { \"row_create_all_values_createAndWait\", 0,\n          _row_status_state_all_values_createAndWait, 0, &rc_activate,\n          &rc_sv_caw, 0, NULL };\n    netsnmp_state_machine_step rc_av_cag =\n        { \"row_create_all_values_createAndGo\", 0,\n          _row_status_state_all_values_createAndGo, 0, NULL, &rc_av_caw, 0,\n          NULL };\n\n    netsnmp_state_machine_input sm_input = { \"row_create_machine\", 0,\n                                             &rc_av_cag, &rc_cleanup };\n    rowcreate_state state;\n\n    netsnmp_require_ptr_LRV( sess, SNMPERR_GENERR);\n    netsnmp_require_ptr_LRV( vars, SNMPERR_GENERR);\n\n    state.session = sess;\n    state.vars = vars;\n\n    state.row_status_index = row_status_index;\n    sm_input.input_context = &state;\n\n    netsnmp_state_machine_run( &sm_input);\n\n    return SNMPERR_SUCCESS;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_ROW_CREATE */\n#endif /* NETSNMP_NO_WRITE_SUPPORT */\n\n\n/** @} */\n", "/* Portions of this file are subject to the following copyright(s).  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/*\n * Portions of this file are copyrighted by:\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n *\n * Portions of this file are copyrighted by:\n * Copyright (c) 2016 VMware, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n/*\n * snmpusm.c\n *\n * Routines to manipulate a information about a \"user\" as\n * defined by the SNMP-USER-BASED-SM-MIB MIB.\n *\n * All functions usm_set_usmStateReference_*() return 0 on success, -1\n * otherwise.\n *\n * !! Tab stops set to 4 in some parts of this file. !!\n *    (Designated on a per function.)\n */\n\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#include <sys/types.h>\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <net-snmp/types.h>\n#include <net-snmp/output_api.h>\n#include <net-snmp/config_api.h>\n#include <net-snmp/utilities.h>\n\n#include <net-snmp/library/asn1.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/callback.h>\n#include <net-snmp/library/tools.h>\n#include <net-snmp/library/keytools.h>\n#include <net-snmp/library/snmpv3.h>\n#include <net-snmp/library/lcd_time.h>\n#include <net-snmp/library/scapi.h>\n#include <net-snmp/library/callback.h>\n#include <net-snmp/library/snmp_secmod.h>\n#include <net-snmp/library/snmpusm.h>\n#include <net-snmp/library/transform_oids.h>\n#include <net-snmp/library/snmp_enum.h>\n\nnetsnmp_feature_child_of(usm_all, libnetsnmp)\nnetsnmp_feature_child_of(usm_support, usm_all)\n\nnetsnmp_feature_require(usm_support)\n\nstruct usmStateReference {\n    char           *usr_name;\n    size_t          usr_name_length;\n    u_char         *usr_engine_id;\n    size_t          usr_engine_id_length;\n    oid            *usr_auth_protocol;\n    size_t          usr_auth_protocol_length;\n    u_char         *usr_auth_key;\n    size_t          usr_auth_key_length;\n    oid            *usr_priv_protocol;\n    size_t          usr_priv_protocol_length;\n    u_char         *usr_priv_key;\n    size_t          usr_priv_key_length;\n    u_int           usr_sec_level;\n};\n\noid    usmNoAuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                 NETSNMP_USMAUTH_NOAUTH };\n#ifndef NETSNMP_DISABLE_MD5\noid    usmHMACMD5AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                      NETSNMP_USMAUTH_HMACMD5 };\n#endif\noid    usmHMACSHA1AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                       NETSNMP_USMAUTH_HMACSHA1 };\n\n#ifdef HAVE_EVP_SHA384\noid    usmHMAC384SHA512AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC384SHA512 };\noid    usmHMAC256SHA384AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC256SHA384 };\n#endif /* HAVE_EVP_SHA384 */\n\n#ifdef HAVE_EVP_SHA224\noid    usmHMAC192SHA256AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC192SHA256 };\noid    usmHMAC128SHA224AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC128SHA224 };\n#endif /* HAVE_EVP_SHA384 */\n\noid             usmNoPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 1 };\n\n#ifndef NETSNMP_DISABLE_DES\noid             usmDESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 2 };\n#endif\n\n\noid    usmAESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 4 };\n/* backwards compat */\noid    *usmAES128PrivProtocol = usmAESPrivProtocol;\n\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n    /* OIDs from http://www.snmp.com/eso/esoConsortiumMIB.txt */\noid    usmAES192PrivProtocol[9] = { 1,3,6,1,4,1,14832,1,3 };\noid    usmAES256PrivProtocol[9] = { 1,3,6,1,4,1,14832,1,4 };\n    /* OIDs from CISCO MIB */\noid    usmAES192CiscoPrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,1 };\noid    usmAES256CiscoPrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,2 };\n/*\n * these OIDs are in pySNMP source as OIDs for AES+Reeder. We'll just\n * use OIDS from CISCO-SNMP-USM-OIDS-MIB\n *\noid    usmAES192Cisco2PrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,101 };\noid    usmAES256Cisco2PrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,102 };\n */\n#endif /* NETSNMP_DRAFT_BLUMENTHAL_AES_04 */\n\ntypedef struct usm_alg_type_s {\n    const char *label;\n    int         value;\n} usm_alg_type_t;\n\nstatic usm_alg_type_t usm_auth_type[] = {\n    { \"NOAUTH\", NETSNMP_USMAUTH_NOAUTH },\n    { \"SHA\", NETSNMP_USMAUTH_HMACSHA1 },\n    { \"SHA-1\", NETSNMP_USMAUTH_HMACSHA1 },\n    { \"SHA1\", NETSNMP_USMAUTH_HMACSHA1 },\n#ifndef NETSNMP_DISABLE_MD5\n    { \"MD5\", NETSNMP_USMAUTH_HMACMD5 },\n#endif\n#ifdef HAVE_EVP_SHA224\n    { \"SHA-224\", NETSNMP_USMAUTH_HMAC128SHA224 },\n    { \"SHA224\", NETSNMP_USMAUTH_HMAC128SHA224 },\n    { \"SHA-256\", NETSNMP_USMAUTH_HMAC192SHA256 },\n    { \"SHA256\", NETSNMP_USMAUTH_HMAC192SHA256 },\n#endif\n#ifdef HAVE_EVP_SHA384\n    { \"SHA-384\", NETSNMP_USMAUTH_HMAC256SHA384 },\n    { \"SHA384\", NETSNMP_USMAUTH_HMAC256SHA384 },\n    { \"SHA-512\",  NETSNMP_USMAUTH_HMAC384SHA512 },\n    { \"SHA512\",  NETSNMP_USMAUTH_HMAC384SHA512 },\n#endif\n    { NULL, -1 }\n};\n\nstatic usm_alg_type_t usm_priv_type[] = {\n    { \"NOPRIV\", USM_CREATE_USER_PRIV_NONE },\n#ifndef NETSNMP_DISABLE_DES\n    { \"DES\", USM_CREATE_USER_PRIV_DES },\n#endif\n#ifdef HAVE_AES\n    { \"AES\", USM_CREATE_USER_PRIV_AES },\n    { \"AES-128\", USM_CREATE_USER_PRIV_AES },\n    { \"AES128\", USM_CREATE_USER_PRIV_AES },\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n    { \"AES-192\", USM_CREATE_USER_PRIV_AES192 },\n    { \"AES192\", USM_CREATE_USER_PRIV_AES192 },\n    { \"AES-256\", USM_CREATE_USER_PRIV_AES256 },\n    { \"AES256\", USM_CREATE_USER_PRIV_AES256 },\n    /** cisco / pysnmp variations */\n    { \"AES-192-C\", USM_CREATE_USER_PRIV_AES192_CISCO },\n    { \"AES192C\", USM_CREATE_USER_PRIV_AES192_CISCO },\n    { \"AES-256-C\", USM_CREATE_USER_PRIV_AES256_CISCO },\n    { \"AES256C\", USM_CREATE_USER_PRIV_AES256_CISCO },\n#endif\n#endif\n    { NULL, -1 },\n};\n\nstatic u_int    dummy_etime, dummy_eboot;       /* For ISENGINEKNOWN(). */\n\n/*\n * Set up default snmpv3 parameter value storage.\n */\n#ifdef NETSNMP_SECMOD_USM\nstatic const oid *defaultAuthType = NULL;\nstatic size_t   defaultAuthTypeLen = 0;\nstatic const oid *defaultPrivType = NULL;\nstatic size_t   defaultPrivTypeLen = 0;\n#endif /* NETSNMP_SECMOD_USM */\n\n/*\n * Globals.\n */\nstatic u_int    salt_integer;\n#ifdef HAVE_AES\nstatic u_int    salt_integer64_1, salt_integer64_2;\n#endif\n        /*\n         * 1/2 of seed for the salt.   Cf. RFC2274, Sect 8.1.1.1.\n         */\n\nstatic struct usmUser *noNameUser = NULL;\n/*\n * Local storage (LCD) of the default user list.\n */\nstatic struct usmUser *userList = NULL;\n\n/*\n * Set a given field of the secStateRef.\n *\n * Allocate <len> bytes for type <type> pointed to by ref-><field>.\n * Then copy in <item> and record its length in ref-><field_len>.\n *\n * Return 0 on success, -1 otherwise.\n */\n#define MAKE_ENTRY(ref, type, item, len, field, field_len)              \\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (ref == NULL)\t\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\t\t\\\n\tif (ref->field != NULL)\t{\t\t\t\t\t\\\n\t\tSNMP_ZERO(ref->field, ref->field_len);\t\t\t\\\n\t\tSNMP_FREE(ref->field);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tref->field_len = 0;\t\t\t\t\t\t\\\n        if (len == 0 || item == NULL) {\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t \t\t\t\\\n\tif ((ref->field = (type*) malloc (len * sizeof(type))) == NULL)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmemcpy (ref->field, item, len * sizeof(type));\t\t\t\\\n\tref->field_len = len;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nstatic int\nfree_enginetime_on_shutdown(int majorid, int minorid, void *serverarg,\n\t\t\t    void *clientarg)\n{\n    u_char engineID[SNMP_MAX_ENG_SIZE];\n    size_t engineID_len = sizeof(engineID);\n\n    DEBUGMSGTL((\"snmpv3\", \"free enginetime callback called\\n\"));\n\n    engineID_len = snmpv3_get_engineID(engineID, engineID_len);\n    if (engineID_len > 0)\n\tfree_enginetime(engineID, engineID_len);\n    return 0;\n}\n\nstatic struct usmStateReference *\nusm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}                               /* end usm_malloc_usmStateReference() */\n\nstatic void\nusm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n\n    if (old_ref) {\n\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n\n    }\n\n}                               /* end usm_free_usmStateReference() */\n\nstruct usmUser *\nusm_get_userList(void)\n{\n    return userList;\n}\n\nstatic int\nusm_set_usmStateReference_name(struct usmStateReference *ref,\n                               char *name, size_t name_len)\n{\n    MAKE_ENTRY(ref, char, name, name_len, usr_name, usr_name_length);\n}\n\nstatic int\nusm_set_usmStateReference_engine_id(struct usmStateReference *ref,\n                                    u_char * engine_id,\n                                    size_t engine_id_len)\n{\n    MAKE_ENTRY(ref, u_char, engine_id, engine_id_len,\n               usr_engine_id, usr_engine_id_length);\n}\n\nstatic int\nusm_set_usmStateReference_auth_protocol(struct usmStateReference *ref,\n                                        oid * auth_protocol,\n                                        size_t auth_protocol_len)\n{\n    MAKE_ENTRY(ref, oid, auth_protocol, auth_protocol_len,\n               usr_auth_protocol, usr_auth_protocol_length);\n}\n\nstatic int\nusm_set_usmStateReference_auth_key(struct usmStateReference *ref,\n                                   u_char * auth_key, size_t auth_key_len)\n{\n    MAKE_ENTRY(ref, u_char, auth_key, auth_key_len,\n               usr_auth_key, usr_auth_key_length);\n}\n\nstatic int\nusm_set_usmStateReference_priv_protocol(struct usmStateReference *ref,\n                                        oid * priv_protocol,\n                                        size_t priv_protocol_len)\n{\n    MAKE_ENTRY(ref, oid, priv_protocol, priv_protocol_len,\n               usr_priv_protocol, usr_priv_protocol_length);\n}\n\nstatic int\nusm_set_usmStateReference_priv_key(struct usmStateReference *ref,\n                                   u_char * priv_key, size_t priv_key_len)\n{\n    MAKE_ENTRY(ref, u_char, priv_key, priv_key_len,\n               usr_priv_key, usr_priv_key_length);\n}\n\nstatic int\nusm_set_usmStateReference_sec_level(struct usmStateReference *ref,\n                                    int sec_level)\n{\n    if (ref == NULL)\n        return -1;\n    ref->usr_sec_level = sec_level;\n    return 0;\n}\n\nint\nusm_clone_usmStateReference(struct usmStateReference *from, struct usmStateReference **to)\n{\n    struct usmStateReference *cloned_usmStateRef;\n\n    if (from == NULL || to == NULL)\n        return -1;\n\n    *to = usm_malloc_usmStateReference();\n    cloned_usmStateRef = *to;\n\n    if (usm_set_usmStateReference_name(cloned_usmStateRef, from->usr_name, from->usr_name_length) ||\n        usm_set_usmStateReference_engine_id(cloned_usmStateRef, from->usr_engine_id, from->usr_engine_id_length) ||\n        usm_set_usmStateReference_auth_protocol(cloned_usmStateRef, from->usr_auth_protocol, from->usr_auth_protocol_length) ||\n        usm_set_usmStateReference_auth_key(cloned_usmStateRef, from->usr_auth_key, from->usr_auth_key_length) ||\n        usm_set_usmStateReference_priv_protocol(cloned_usmStateRef, from->usr_priv_protocol, from->usr_priv_protocol_length) ||\n        usm_set_usmStateReference_priv_key(cloned_usmStateRef, from->usr_priv_key, from->usr_priv_key_length) ||\n        usm_set_usmStateReference_sec_level(cloned_usmStateRef, from->usr_sec_level))\n    {\n        usm_free_usmStateReference(*to);\n        *to = NULL;\n        return -1;\n    }\n\n    return 0;\n\n}\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n/*******************************************************************-o-******\n * emergency_print\n *\n * Parameters:\n *\t*field\n *\t length\n *      \n *\tThis is a print routine that is solely included so that it can be\n *\tused in gdb.  Don't use it as a function, it will be pulled before\n *\ta real release of the code.\n *\n *\ttab stop 4\n *\n *\tXXX fflush() only works on FreeBSD; core dumps on Sun OS's\n */\nvoid\nemergency_print(u_char * field, u_int length)\n{\n    int             iindex;\n    int             start = 0;\n    int             stop = 25;\n\n    while (start < stop) {\n        for (iindex = start; iindex < stop; iindex++)\n            printf(\"%02X \", field[iindex]);\n\n        printf(\"\\n\");\n        start = stop;\n        stop = stop + 25 < length ? stop + 25 : length;\n    }\n    fflush(0);\n\n}                               /* end emergency_print() */\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n\nstatic struct usmUser *\nusm_get_user_from_list(u_char * engineID, size_t engineIDLen,\n                       char *name, struct usmUser *puserList,\n                       int use_default)\n{\n    struct usmUser *ptr;\n    char            noName[] = \"\";\n    if (name == NULL)\n        name = noName;\n    for (ptr = puserList; ptr != NULL; ptr = ptr->next) {\n        if (ptr->name && !strcmp(ptr->name, name)) {\n          DEBUGMSGTL((\"usm\", \"match on user %s\\n\", ptr->name));\n          if (ptr->engineIDLen == engineIDLen &&\n            ((ptr->engineID == NULL && engineID == NULL) ||\n             (ptr->engineID != NULL && engineID != NULL &&\n              memcmp(ptr->engineID, engineID, engineIDLen) == 0)))\n            return ptr;\n          DEBUGMSGTL((\"usm\", \"no match on engineID (\"));\n          if (engineID) {\n              DEBUGMSGHEX((\"usm\", engineID, engineIDLen));\n          } else {\n              DEBUGMSGTL((\"usm\", \"Empty EngineID\"));\n          }\n          DEBUGMSG((\"usm\", \")\\n\"));\n        }\n    }\n\n    /*\n     * return \"\" user used to facilitate engineID discovery\n     */\n    if (use_default && !strcmp(name, \"\"))\n        return noNameUser;\n    return NULL;\n}\n\n/*\n * usm_get_user(): Returns a user from userList based on the engineID,\n * engineIDLen and name of the requested user.\n */\nstruct usmUser *\nusm_get_user(u_char * engineID, size_t engineIDLen, char *name)\n{\n    DEBUGMSGTL((\"usm\", \"getting user %s\\n\", name));\n    return usm_get_user_from_list(engineID, engineIDLen, name, userList,\n                                  1);\n}\n\nstatic struct usmUser *\nusm_add_user_to_list(struct usmUser *user, struct usmUser *puserList)\n{\n    struct usmUser *nptr, *pptr, *optr;\n\n    /*\n     * loop through puserList till we find the proper, sorted place to\n     * insert the new user\n     */\n    /* XXX - how to handle a NULL user->name ?? */\n    /* XXX - similarly for a NULL nptr->name ?? */\n    for (nptr = puserList, pptr = NULL; nptr != NULL;\n         pptr = nptr, nptr = nptr->next) {\n        if (nptr->engineIDLen > user->engineIDLen)\n            break;\n\n        if (user->engineID == NULL && nptr->engineID != NULL)\n            break;\n\n        if (nptr->engineIDLen == user->engineIDLen &&\n            (nptr->engineID != NULL && user->engineID != NULL &&\n             memcmp(nptr->engineID, user->engineID,\n                    user->engineIDLen) > 0))\n            break;\n\n        if (!(nptr->engineID == NULL && user->engineID != NULL)) {\n            if (nptr->engineIDLen == user->engineIDLen &&\n                ((nptr->engineID == NULL && user->engineID == NULL) ||\n                 memcmp(nptr->engineID, user->engineID,\n                        user->engineIDLen) == 0)\n                && strlen(nptr->name) > strlen(user->name))\n                break;\n\n            if (nptr->engineIDLen == user->engineIDLen &&\n                ((nptr->engineID == NULL && user->engineID == NULL) ||\n                 memcmp(nptr->engineID, user->engineID,\n                        user->engineIDLen) == 0)\n                && strlen(nptr->name) == strlen(user->name)\n                && strcmp(nptr->name, user->name) > 0)\n                break;\n\n            if (nptr->engineIDLen == user->engineIDLen &&\n                ((nptr->engineID == NULL && user->engineID == NULL) ||\n                 memcmp(nptr->engineID, user->engineID,\n                        user->engineIDLen) == 0)\n                && strlen(nptr->name) == strlen(user->name)\n                && strcmp(nptr->name, user->name) == 0) {\n                /*\n                 * the user is an exact match of a previous entry.\n                 * Credentials may be different, though, so remove\n                 * the old entry (and add the new one)!\n                 */\n                if (pptr) { /* change prev's next pointer */\n                  pptr->next = nptr->next;\n                }\n                if (nptr->next) { /* change next's prev pointer */\n                  nptr->next->prev = pptr;\n                }\n                optr = nptr;\n                nptr = optr->next; /* add new user at this position */\n                /* free the old user */\n                optr->next=NULL;\n                optr->prev=NULL;\n                usm_free_user(optr);\n                break; /* new user will be added below */\n            }\n        }\n    }\n\n    /*\n     * nptr should now point to the user that we need to add ourselves\n     * in front of, and pptr should be our new 'prev'.\n     */\n\n    /*\n     * change our pointers\n     */\n    user->prev = pptr;\n    user->next = nptr;\n\n    /*\n     * change the next's prev pointer\n     */\n    if (user->next)\n        user->next->prev = user;\n\n    /*\n     * change the prev's next pointer\n     */\n    if (user->prev)\n        user->prev->next = user;\n\n    /*\n     * rewind to the head of the list and return it (since the new head\n     * could be us, we need to notify the above routine who the head now is.\n     */\n    for (pptr = user; pptr->prev != NULL; pptr = pptr->prev);\n    return pptr;\n}\n\n/*\n * usm_add_user(): Add's a user to the userList, sorted by the\n * engineIDLength then the engineID then the name length then the name\n * to facilitate getNext calls on a usmUser table which is indexed by\n * these values.\n *\n * returns the head of the list (which could change due to this add).\n */\n\nstruct usmUser *\nusm_add_user(struct usmUser *user)\n{\n    struct usmUser *uptr;\n    uptr = usm_add_user_to_list(user, userList);\n    if (uptr != NULL)\n        userList = uptr;\n    return uptr;\n}\n\n/*\n * usm_remove_usmUser_from_list remove user from (optional) list\n *\n * if list is not specified, defaults to global userList.\n *\n * returns SNMPERR_SUCCESS or SNMPERR_USM_UNKNOWNSECURITYNAME\n */\nstatic int\nusm_remove_usmUser_from_list(struct usmUser *user, struct usmUser **ppuserList)\n{\n    struct usmUser *nptr, *pptr;\n\n    /*\n     * NULL pointers aren't allowed\n     */\n    if (ppuserList == NULL)\n        ppuserList = &userList;\n\n    if (*ppuserList == NULL)\n        return SNMPERR_USM_UNKNOWNSECURITYNAME;\n\n    /*\n     * find the user in the list\n     */\n    for (nptr = *ppuserList, pptr = NULL; nptr != NULL;\n         pptr = nptr, nptr = nptr->next) {\n        if (nptr == user)\n            break;\n    }\n\n    if (nptr) {\n        /*\n         * remove the user from the linked list\n         */\n        if (pptr) {\n            pptr->next = nptr->next;\n        }\n        if (nptr->next) {\n            nptr->next->prev = pptr;\n        }\n    } else {\n        /*\n         * user didn't exist\n         */\n        return SNMPERR_USM_UNKNOWNSECURITYNAME;\n    }\n    if (nptr == *ppuserList)    /* we're the head of the list, need to change\n                                 * * the head to the next user */\n        *ppuserList = nptr->next;\n    return SNMPERR_SUCCESS;\n}                               /* end usm_remove_usmUser_from_list() */\n\n/*\n * usm_remove_user_from_list\n *\n * removes user from list.\n *\n * returns new list head on success, or NULL on error.\n *\n * NOTE: if there was only one user in the list, list head will be NULL.\n *       So NULL can also mean success. Use the newer usm_remove_usmUser() for\n *       more specific return codes. This function is kept for backwards\n *       compatability with this ambiguous behaviour.\n */\nstatic struct usmUser *\nusm_remove_user_from_list(struct usmUser *user,\n                          struct usmUser **ppuserList)\n{\n    int rc = usm_remove_usmUser_from_list(user, ppuserList);\n    if (rc != SNMPERR_SUCCESS || NULL == ppuserList)\n        return NULL;\n\n    return *ppuserList;\n}                               /* end usm_remove_user_from_list() */\n\n/*\n * usm_remove_user(): finds and removes a user from a list\n */\nstruct usmUser *\nusm_remove_user(struct usmUser *user)\n{\n    return usm_remove_user_from_list(user, &userList);\n}\n\n/*\n * usm_free_user():  calls free() on all needed parts of struct usmUser and\n * the user himself.\n *\n * Note: This should *not* be called on an object in a list (IE,\n * remove it from the list first, and set next and prev to NULL), but\n * will try to reconnect the list pieces again if it is called this\n * way.  If called on the head of the list, the entire list will be\n * lost.\n */\nstruct usmUser *\nusm_free_user(struct usmUser *user)\n{\n    if (user == NULL)\n        return NULL;\n\n    SNMP_FREE(user->engineID);\n    SNMP_FREE(user->name);\n    SNMP_FREE(user->secName);\n    SNMP_FREE(user->cloneFrom);\n    SNMP_FREE(user->userPublicString);\n    SNMP_FREE(user->authProtocol);\n    SNMP_FREE(user->privProtocol);\n\n    if (user->authKey != NULL) {\n        SNMP_ZERO(user->authKey, user->authKeyLen);\n        SNMP_FREE(user->authKey);\n    }\n\n    if (user->privKey != NULL) {\n        SNMP_ZERO(user->privKey, user->privKeyLen);\n        SNMP_FREE(user->privKey);\n    }\n\n    if (user->authKeyKu != NULL) {\n        SNMP_ZERO(user->authKeyKu, user->authKeyKuLen);\n        SNMP_FREE(user->authKeyKu);\n    }\n\n    if (user->privKeyKu != NULL) {\n        SNMP_ZERO(user->privKeyKu, user->privKeyKuLen);\n        SNMP_FREE(user->privKeyKu);\n    }\n\n\n    /*\n     * FIX  Why not put this check *first?*\n     */\n    if (user->prev != NULL) {   /* ack, this shouldn't happen */\n        user->prev->next = user->next;\n    }\n    if (user->next != NULL) {\n        user->next->prev = user->prev;\n        if (user->prev != NULL) /* ack this is really bad, because it means\n                                 * * we'll loose the head of some structure tree */\n            DEBUGMSGTL((\"usm\",\n                        \"Severe: Asked to free the head of a usmUser tree somewhere.\"));\n    }\n\n\n    SNMP_ZERO(user, sizeof(*user));\n    SNMP_FREE(user);\n\n    return NULL;                /* for convenience to returns from calling functions */\n\n}                               /* end usm_free_user() */\n\n/*******************************************************************-o-******\n * asn_predict_int_length\n *\n * Parameters:\n *\ttype\t(UNUSED)\n *\tnumber\n *\tlen\n *      \n * Returns:\n *\tNumber of bytes necessary to store the ASN.1 encoded value of 'number'.\n *\n *\n *\tThis gives the number of bytes that the ASN.1 encoder (in asn1.c) will\n *\tuse to encode a particular integer value.\n *\n *\tReturns the length of the integer -- NOT THE HEADER!\n *\n *\tDo this the same way as asn_build_int()...\n */\nstatic int\nasn_predict_int_length(int type, long number, size_t len)\n{\n    register u_long mask;\n\n\n    if (len != sizeof(long))\n        return -1;\n\n    mask = ((u_long) 0x1FF) << ((8 * (sizeof(long) - 1)) - 1);\n    /*\n     * mask is 0xFF800000 on a big-endian machine \n     */\n\n    while ((((number & mask) == 0) || ((number & mask) == mask))\n           && len > 1) {\n        len--;\n        number <<= 8;\n    }\n\n    return len;\n\n}                               /* end asn_predict_length() */\n\n/*******************************************************************-o-******\n * asn_predict_length\n *\n * Parameters:\n *\t type\n *\t*ptr\n *\t u_char_len\n *      \n * Returns:\n *\tLength in bytes:\t1 + <n> + <u_char_len>, where\n *\n *\t\t1\t\tFor the ASN.1 type.\n *\t\t<n>\t\t# of bytes to store length of data.\n *\t\t<u_char_len>\tLength of data associated with ASN.1 type.\n *\n *\tThis gives the number of bytes that the ASN.1 encoder (in asn1.c) will\n *\tuse to encode a particular integer value.  This is as broken as the\n *\tcurrently used encoder.\n *\n * XXX\tHow is <n> chosen, exactly??\n */\nstatic int\nasn_predict_length(int type, u_char * ptr, size_t u_char_len)\n{\n\n    if (type & ASN_SEQUENCE)\n        return 1 + 3 + u_char_len;\n\n    if (type & ASN_INTEGER) {\n        u_long          value;\n        memcpy(&value, ptr, u_char_len);\n        u_char_len = asn_predict_int_length(type, value, u_char_len);\n    }\n\n    if (u_char_len < 0x80)\n        return 1 + 1 + u_char_len;\n    else if (u_char_len < 0xFF)\n        return 1 + 2 + u_char_len;\n    else\n        return 1 + 3 + u_char_len;\n\n}                               /* end asn_predict_length() */\n\n/*******************************************************************-o-******\n * usm_calc_offsets\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\n *\tThis routine calculates the offsets into an outgoing message buffer\n *\tfor the necessary values.  The outgoing buffer will generically\n *\tlook like this:\n *\n *\tSNMPv3 Message\n *\tSEQ len[11]\n *\t\tINT len version\n *\tHeader\n *\t\tSEQ len\n *\t\t\tINT len MsgID\n *\t\t\tINT len msgMaxSize\n *\t\t\tOST len msgFlags (OST = OCTET STRING)\n *\t\t\tINT len msgSecurityModel\n *\tMsgSecurityParameters\n *\t\t[1] OST len[2]\n *\t\t\tSEQ len[3]\n *\t\t\t\tOST len msgAuthoritativeEngineID\n *\t\t\t\tINT len msgAuthoritativeEngineBoots\n *\t\t\t\tINT len msgAuthoritativeEngineTime\n *\t\t\t\tOST len msgUserName\n *\t\t\t\tOST len[4] [5] msgAuthenticationParameters\n *\t\t\t\tOST len[6] [7] msgPrivacyParameters\n *\tMsgData\n *\t\t[8] OST len[9] [10] encryptedPDU\n *\t\tor\n *\t\t[8,10] SEQUENCE len[9] scopedPDU\n *\t[12]\n *\n *\tThe bracketed points will be needed to be identified ([x] is an index\n *\tvalue, len[x] means a length value).  Here is a semantic guide to them:\n *\n *\t[1] = globalDataLen (input)\n *\t[2] = otstlen\n *\t[3] = seq_len\n *\t[4] = msgAuthParmLen (may be 0 or 12)\n *\t[5] = authParamsOffset\n *\t[6] = msgPrivParmLen (may be 0 or 8)\n *\t[7] = privParamsOffset\n *\t[8] = globalDataLen + msgSecParmLen\n *\t[9] = datalen\n *\t[10] = dataOffset\n *\t[11] = theTotalLength - the length of the header itself\n *\t[12] = theTotalLength\n */\nstatic int\nusm_calc_offsets(size_t globalDataLen,  /* SNMPv3Message + HeaderData */\n                 int secLevel, size_t secEngineIDLen, size_t secNameLen, size_t scopedPduLen,   /* An BER encoded sequence. */\n                 u_long engineboots,    /* XXX (asn1.c works in long, not int.) */\n                 long engine_time,      /* XXX (asn1.c works in long, not int.) */\n                 size_t * theTotalLength,       /* globalDataLen + msgSecurityP. + msgData */\n                 size_t * authParamsOffset,     /* Distance to auth bytes.                 */\n                 size_t * privParamsOffset,     /* Distance to priv bytes.                 */\n                 size_t * dataOffset,   /* Distance to scopedPdu SEQ  -or-  the\n                                         *   crypted (data) portion of msgData.    */\n                 size_t * datalen,      /* Size of msgData OCTET STRING encoding.  */\n                 size_t * msgAuthParmLen,       /* Size of msgAuthenticationParameters.    */\n                 size_t * msgPrivParmLen,       /* Size of msgPrivacyParameters.           */\n                 size_t * otstlen,      /* Size of msgSecurityP. O.S. encoding.    */\n                 size_t * seq_len,      /* Size of msgSecurityP. SEQ data.         */\n                 size_t * msgSecParmLen)\n{                               /* Size of msgSecurityP. SEQ.              */\n    int             engIDlen,   /* Sizes of OCTET STRING and SEQ encodings */\n                    engBtlen,   /*   for fields within                     */\n                    engTmlen,   /*   msgSecurityParameters portion of      */\n                    namelen,    /*   SNMPv3Message.                        */\n                    authlen, privlen, ret;\n\n    /*\n     * If doing authentication, msgAuthParmLen = 12 else msgAuthParmLen = 0.\n     * If doing encryption,     msgPrivParmLen = 8  else msgPrivParmLen = 0.\n     */\n    *msgAuthParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n                       || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 12 : 0;\n\n    *msgPrivParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 8 : 0;\n\n\n    /*\n     * Calculate lengths.\n     */\n    if ((engIDlen = asn_predict_length(ASN_OCTET_STR,\n                                       NULL, secEngineIDLen)) == -1) {\n        return -1;\n    }\n\n    if ((engBtlen = asn_predict_length(ASN_INTEGER,\n                                       (u_char *) & engineboots,\n                                       sizeof(long))) == -1) {\n        return -1;\n    }\n\n    if ((engTmlen = asn_predict_length(ASN_INTEGER,\n                                       (u_char *) & engine_time,\n                                       sizeof(long))) == -1) {\n        return -1;\n    }\n\n    if ((namelen = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, secNameLen)) == -1) {\n        return -1;\n    }\n\n    if ((authlen = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, *msgAuthParmLen)) == -1) {\n        return -1;\n    }\n\n    if ((privlen = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, *msgPrivParmLen)) == -1) {\n        return -1;\n    }\n\n    *seq_len =\n        engIDlen + engBtlen + engTmlen + namelen + authlen + privlen;\n\n    if ((ret = asn_predict_length(ASN_SEQUENCE,\n                                      NULL, *seq_len)) == -1) {\n        return -1;\n    }\n    *otstlen = (size_t)ret;\n\n    if ((ret = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, *otstlen)) == -1) {\n        return -1;\n    }\n    *msgSecParmLen = (size_t)ret;\n\n    *authParamsOffset = globalDataLen + +(*msgSecParmLen - *seq_len)\n        + engIDlen + engBtlen + engTmlen + namelen\n        + (authlen - *msgAuthParmLen);\n\n    *privParamsOffset = *authParamsOffset + *msgAuthParmLen\n        + (privlen - *msgPrivParmLen);\n\n\n    /*\n     * Compute the size of the plaintext.  Round up to account for cipher\n     * block size, if necessary.\n     *\n     * XXX  This is hardwired for 1DES... If scopedPduLen is already\n     *      a multiple of 8, then *add* 8 more; otherwise, round up\n     *      to the next multiple of 8.\n     *\n     * FIX  Calculation of encrypted portion of msgData and consequent\n     *      setting and sanity checking of theTotalLength, et al. should\n     *      occur *after* encryption has taken place.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        scopedPduLen = ROUNDUP8(scopedPduLen);\n\n        if ((ret = asn_predict_length(ASN_OCTET_STR, NULL, scopedPduLen)) == -1) {\n            return -1;\n        }\n        *datalen = (size_t)ret;\n    } else {\n        *datalen = scopedPduLen;\n    }\n\n    *dataOffset = globalDataLen + *msgSecParmLen +\n        (*datalen - scopedPduLen);\n    *theTotalLength = globalDataLen + *msgSecParmLen + *datalen;\n\n    return 0;\n\n}                               /* end usm_calc_offsets() */\n\n#ifndef NETSNMP_DISABLE_DES\n/*******************************************************************-o-******\n * usm_set_salt\n *\n * Parameters:\n *\t*iv\t\t  (O)   Buffer to contain IV.\n *\t*iv_length\t  (O)   Length of iv.\n *\t*priv_salt\t  (I)   Salt portion of private key.\n *\t priv_salt_length (I)   Length of priv_salt.\n *\t*msgSalt\t  (I/O) Pointer salt portion of outgoing msg buffer.\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\tDetermine the initialization vector for the DES-CBC encryption.\n *\t(Cf. RFC 2274, 8.1.1.1.)\n *\n *\tiv is defined as the concatenation of engineBoots and the\n *\t\tsalt integer.\n *\tThe salt integer is incremented.\n *\tThe resulting salt is copied into the msgSalt buffer.\n *\tThe result of the concatenation is then XORed with the salt\n *\t\tportion of the private key (last 8 bytes).\n *\tThe IV result is returned individually for further use.\n */\nstatic int\nusm_set_salt(u_char * iv,\n             size_t * iv_length,\n             u_char * priv_salt, size_t priv_salt_length, u_char * msgSalt)\n{\n    size_t          propersize_salt = BYTESIZE(USM_DES_SALT_LENGTH);\n    int             net_boots;\n    int             net_salt_int;\n    /*\n     * net_* should be encoded in network byte order.  XXX  Why?\n     */\n    int             iindex;\n\n\n    /*\n     * Sanity check.\n     */\n    if (!iv || !iv_length || !priv_salt || (*iv_length != propersize_salt)\n        || (priv_salt_length < propersize_salt)) {\n        return -1;\n    }\n\n\n    net_boots = htonl(snmpv3_local_snmpEngineBoots());\n    net_salt_int = htonl(salt_integer);\n\n    salt_integer += 1;\n\n    memcpy(iv, &net_boots, propersize_salt / 2);\n    memcpy(iv + (propersize_salt / 2), &net_salt_int, propersize_salt / 2);\n\n    if (msgSalt)\n        memcpy(msgSalt, iv, propersize_salt);\n\n\n    /*\n     * Turn the salt into an IV: XOR <boots, salt_int> with salt\n     * portion of priv_key.\n     */\n    for (iindex = 0; iindex < (int) propersize_salt; iindex++)\n        iv[iindex] ^= priv_salt[iindex];\n\n\n    return 0;\n\n}                               /* end usm_set_salt() */\n#endif\n\n#ifdef HAVE_AES\n/*******************************************************************-o-******\n * usm_set_aes_iv\n *\n * Parameters:\n *\t*iv\t\t  (O)   Buffer to contain IV.\n *\t*iv_length\t  (O)   Length of iv.\n *      net_boots         (I)   the network byte order of the authEng boots val\n *      net_time         (I)   the network byte order of the authEng time val\n *      *salt             (O)   A buffer for the outgoing salt (= 8 bytes of iv)\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\tDetermine the initialization vector for AES encryption.\n *\t(draft-blumenthal-aes-usm-03.txt, 3.1.2.2)\n *\n *\tiv is defined as the concatenation of engineBoots, engineTime\n  \tand a 64 bit salt-integer.\n *\tThe 64 bit salt integer is incremented.\n *\tThe resulting salt is copied into the salt buffer.\n *\tThe IV result is returned individually for further use.\n */\nstatic int\nusm_set_aes_iv(u_char * iv,\n               size_t * iv_length,\n               u_int net_boots,\n               u_int net_time,\n               u_char * salt)\n{\n    /*\n     * net_* should be encoded in network byte order.\n     */\n    int             net_salt_int1, net_salt_int2;\n#define PROPER_AES_IV_SIZE 64\n\n    /*\n     * Sanity check.\n     */\n    if (!iv || !iv_length) {\n        return -1;\n    }\n\n    net_salt_int1 = htonl(salt_integer64_1);\n    net_salt_int2 = htonl(salt_integer64_2);\n\n    if ((salt_integer64_2 += 1) == 0)\n        salt_integer64_2 += 1;\n    \n    /* XXX: warning: hard coded proper lengths */\n    memcpy(iv, &net_boots, 4);\n    memcpy(iv+4, &net_time, 4);\n    memcpy(iv+8, &net_salt_int1, 4);\n    memcpy(iv+12, &net_salt_int2, 4);\n\n    memcpy(salt, iv+8, 8); /* only copy the needed portion */\n    return 0;\n}                               /* end usm_set_aes_iv() */\n#endif /* HAVE_AES */\n\n/*******************************************************************-o-******\n * usm_check_secLevel_vs_protocols\n *\n * Parameters:\n *\t level\n *\t*authProtocol\n *\t authProtocolLen\n *\t*privProtocol\n *\t privProtocolLen\n *\n * Returns:\n *\t0\tOn success,\n *\t1\tOtherwise.\n *\n * Same as above but with explicitly named transform types instead of taking\n * from the usmUser structure.\n */\nstatic int\nusm_check_secLevel_vs_protocols(int level,\n                                const oid * authProtocol,\n                                u_int authProtocolLen,\n                                const oid * privProtocol,\n                                u_int privProtocolLen)\n{\n\n    if (level == SNMP_SEC_LEVEL_AUTHPRIV\n        &&\n        (netsnmp_oid_equals\n         (privProtocol, privProtocolLen, usmNoPrivProtocol,\n          sizeof(usmNoPrivProtocol) / sizeof(oid)) == 0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"Auth Protocol: \"));\n        DEBUGMSGOID((\"usm\", authProtocol, authProtocolLen));\n        DEBUGMSG((\"usm\", \", Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", privProtocol, privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n    if ((level == SNMP_SEC_LEVEL_AUTHPRIV\n         || level == SNMP_SEC_LEVEL_AUTHNOPRIV)\n        &&\n        (netsnmp_oid_equals\n         (authProtocol, authProtocolLen, usmNoAuthProtocol,\n          sizeof(usmNoAuthProtocol) / sizeof(oid)) == 0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"Auth Protocol: \"));\n        DEBUGMSGOID((\"usm\", authProtocol, authProtocolLen));\n        DEBUGMSG((\"usm\", \", Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", privProtocol, privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n\n    return 0;\n\n}                               /* end usm_check_secLevel_vs_protocols() */\n\n/*******************************************************************-o-******\n * usm_generate_out_msg\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\tSNMPERR_SUCCESS\t\t\tOn success.\n *\tSNMPERR_USM_AUTHENTICATIONFAILURE\n *\tSNMPERR_USM_ENCRYPTIONERROR\n *\tSNMPERR_USM_GENERICERROR\n *\tSNMPERR_USM_UNKNOWNSECURITYNAME\n *\tSNMPERR_USM_GENERICERROR\n *\tSNMPERR_USM_UNSUPPORTEDSECURITYLEVEL\n *\t\n *\n * Generates an outgoing message.\n *\n * XXX\tBeware of misnomers!\n */\nstatic int\nusm_generate_out_msg(int msgProcModel,  /* (UNUSED) */\n                     u_char * globalData,       /* IN */\n                     /*\n                      * Pointer to msg header data will point to the beginning\n                      * * of the entire packet buffer to be transmitted on wire,\n                      * * memory will be contiguous with secParams, typically\n                      * * this pointer will be passed back as beginning of\n                      * * wholeMsg below.  asn seq. length is updated w/ new length.\n                      * *\n                      * * While this points to a buffer that should be big enough\n                      * * for the whole message, only the first two parts\n                      * * of the message are completed, namely SNMPv3Message and\n                      * * HeaderData.  globalDataLen (next parameter) represents\n                      * * the length of these two completed parts.\n                      */\n                     size_t globalDataLen,      /* IN - Length of msg header data.      */\n                     int maxMsgSize,    /* (UNUSED) */\n                     int secModel,      /* (UNUSED) */\n                     u_char * secEngineID,      /* IN - Pointer snmpEngineID.           */\n                     size_t secEngineIDLen,     /* IN - SnmpEngineID length.            */\n                     char *secName,     /* IN - Pointer to securityName.        */\n                     size_t secNameLen, /* IN - SecurityName length.            */\n                     int secLevel,      /* IN - AuthNoPriv, authPriv etc.       */\n                     u_char * scopedPdu,        /* IN */\n                     /*\n                      * Pointer to scopedPdu will be encrypted by USM if needed\n                      * * and written to packet buffer immediately following\n                      * * securityParameters, entire msg will be authenticated by\n                      * * USM if needed.\n                      */\n                     size_t scopedPduLen,       /* IN - scopedPdu length. */\n                     void *secStateRef, /* IN */\n                     /*\n                      * secStateRef, pointer to cached info provided only for\n                      * * Response, otherwise NULL.\n                      */\n                     u_char * secParams,        /* OUT */\n                     /*\n                      * BER encoded securityParameters pointer to offset within\n                      * * packet buffer where secParams should be written, the\n                      * * entire BER encoded OCTET STRING (including header) is\n                      * * written here by USM secParams = globalData +\n                      * * globalDataLen.\n                      */\n                     size_t * secParamsLen,     /* IN/OUT - Len available, len returned. */\n                     u_char ** wholeMsg,        /* OUT */\n                     /*\n                      * Complete authenticated/encrypted message - typically\n                      * * the pointer to start of packet buffer provided in\n                      * * globalData is returned here, could also be a separate\n                      * * buffer.\n                      */\n                     size_t * wholeMsgLen)\n{                               /* IN/OUT - Len available, len returned. */\n    size_t          otstlen;\n    size_t          seq_len;\n    size_t          msgAuthParmLen;\n    size_t          msgPrivParmLen;\n    size_t          msgSecParmLen;\n    size_t          authParamsOffset;\n    size_t          privParamsOffset;\n    size_t          datalen;\n    size_t          dataOffset;\n    size_t          theTotalLength;\n\n    u_char         *ptr;\n    size_t          ptr_len;\n    size_t          remaining;\n    size_t          offSet;\n    u_int           boots_uint;\n    u_int           time_uint;\n    long            boots_long;\n    long            time_long;\n\n    /*\n     * Indirection because secStateRef values override parameters.\n     * \n     * None of these are to be free'd - they are either pointing to\n     * what's in the secStateRef or to something either in the\n     * actual prarmeter list or the user list.\n     */\n\n    char           *theName = NULL;\n    u_int           theNameLength = 0;\n    u_char         *theEngineID = NULL;\n    u_int           theEngineIDLength = 0;\n    u_char         *theAuthKey = NULL;\n    u_int           theAuthKeyLength = 0;\n    const oid      *theAuthProtocol = NULL;\n    u_int           theAuthProtocolLength = 0;\n    u_char         *thePrivKey = NULL;\n    u_int           thePrivKeyLength = 0;\n    const oid      *thePrivProtocol = NULL;\n    u_int           thePrivProtocolLength = 0;\n    int             theSecLevel = 0;    /* No defined const for bad\n                                         * value (other then err).\n                                         */\n\n    DEBUGMSGTL((\"usm\", \"USM processing has begun.\\n\"));\n\n    if (secStateRef != NULL) {\n        /*\n         * To hush the compiler for now.  XXX \n         */\n        struct usmStateReference *ref\n            = (struct usmStateReference *) secStateRef;\n\n        theName = ref->usr_name;\n        theNameLength = ref->usr_name_length;\n        theEngineID = ref->usr_engine_id;\n        theEngineIDLength = ref->usr_engine_id_length;\n\n        if (!theEngineIDLength) {\n            theEngineID = secEngineID;\n            theEngineIDLength = secEngineIDLen;\n        }\n\n        theAuthProtocol = ref->usr_auth_protocol;\n        theAuthProtocolLength = ref->usr_auth_protocol_length;\n        theAuthKey = ref->usr_auth_key;\n        theAuthKeyLength = ref->usr_auth_key_length;\n        thePrivProtocol = ref->usr_priv_protocol;\n        thePrivProtocolLength = ref->usr_priv_protocol_length;\n        thePrivKey = ref->usr_priv_key;\n        thePrivKeyLength = ref->usr_priv_key_length;\n        theSecLevel = ref->usr_sec_level;\n    }\n\n    /*\n     * Identify the user record.\n     */\n    else {\n        struct usmUser *user;\n\n        /*\n         * we do allow an unknown user name for\n         * unauthenticated requests. \n         */\n        if ((user = usm_get_user(secEngineID, secEngineIDLen, secName))\n            == NULL && secLevel != SNMP_SEC_LEVEL_NOAUTH) {\n            DEBUGMSGTL((\"usm\", \"Unknown User(%s)\\n\", secName));\n            return SNMPERR_USM_UNKNOWNSECURITYNAME;\n        }\n\n        theName = secName;\n        theNameLength = secNameLen;\n        theEngineID = secEngineID;\n        theSecLevel = secLevel;\n        theEngineIDLength = secEngineIDLen;\n        if (user) {\n            theAuthProtocol = user->authProtocol;\n            theAuthProtocolLength = user->authProtocolLen;\n            theAuthKey = user->authKey;\n            theAuthKeyLength = user->authKeyLen;\n            thePrivProtocol = user->privProtocol;\n            thePrivProtocolLength = user->privProtocolLen;\n            thePrivKey = user->privKey;\n            thePrivKeyLength = user->privKeyLen;\n        } else {\n            /*\n             * unknown users can not do authentication (obviously) \n             */\n            theAuthProtocol = usmNoAuthProtocol;\n            theAuthProtocolLength =\n                sizeof(usmNoAuthProtocol) / sizeof(oid);\n            theAuthKey = NULL;\n            theAuthKeyLength = 0;\n            thePrivProtocol = usmNoPrivProtocol;\n            thePrivProtocolLength =\n                sizeof(usmNoPrivProtocol) / sizeof(oid);\n            thePrivKey = NULL;\n            thePrivKeyLength = 0;\n        }\n    }                           /* endif -- secStateRef==NULL */\n\n\n    /*\n     * From here to the end of the function, avoid reference to\n     * secName, secEngineID, secLevel, and associated lengths.\n     */\n\n\n    /*\n     * Check to see if the user can use the requested sec services.\n     */\n    if (usm_check_secLevel_vs_protocols(theSecLevel,\n                                        theAuthProtocol,\n                                        theAuthProtocolLength,\n                                        thePrivProtocol,\n                                        thePrivProtocolLength) == 1) {\n        DEBUGMSGTL((\"usm\", \"Unsupported Security Level (%d)\\n\",\n                    theSecLevel));\n        return SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;\n    }\n\n\n    /*\n     * Retrieve the engine information.\n     *\n     * XXX  No error is declared in the EoP when sending messages to\n     *      unknown engines, processing continues w/ boots/time == (0,0).\n     */\n    if (get_enginetime(theEngineID, theEngineIDLength,\n                       &boots_uint, &time_uint, FALSE) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Failed to find engine data.\"));\n    }\n\n    boots_long = boots_uint;\n    time_long = time_uint;\n\n\n    /*\n     * Set up the Offsets.\n     */\n    if (usm_calc_offsets(globalDataLen, theSecLevel, theEngineIDLength,\n                         theNameLength, scopedPduLen, boots_long,\n                         time_long, &theTotalLength, &authParamsOffset,\n                         &privParamsOffset, &dataOffset, &datalen,\n                         &msgAuthParmLen, &msgPrivParmLen, &otstlen,\n                         &seq_len, &msgSecParmLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"Failed calculating offsets.\\n\"));\n        return SNMPERR_USM_GENERICERROR;\n    }\n\n    /*\n     * So, we have the offsets for the three parts that need to be\n     * determined, and an overall length.  Now we need to make\n     * sure all of this would fit in the outgoing buffer, and\n     * whether or not we need to make a new buffer, etc.\n     */\n\n\n    /*\n     * Set wholeMsg as a pointer to globalData.  Sanity check for\n     * the proper size.\n     * \n     * Mark workspace in the message with bytes of all 1's to make it\n     * easier to find mistakes in raw message dumps.\n     */\n    ptr = *wholeMsg = globalData;\n    if (theTotalLength > *wholeMsgLen) {\n        DEBUGMSGTL((\"usm\", \"Message won't fit in buffer.\\n\"));\n        return SNMPERR_USM_GENERICERROR;\n    }\n\n    ptr_len = *wholeMsgLen = theTotalLength;\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n    memset(&ptr[globalDataLen], 0xFF, theTotalLength - globalDataLen);\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n\n    /*\n     * Do the encryption.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        size_t          encrypted_length = theTotalLength - dataOffset;\n        size_t          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);\n        u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];\n        int             priv_type = sc_get_privtype(thePrivProtocol,\n                                                    thePrivProtocolLength);\n#ifdef HAVE_AES\n        if (USM_CREATE_USER_PRIV_AES == (priv_type & USM_PRIV_MASK_ALG)) {\n            if (!thePrivKey ||\n                usm_set_aes_iv(salt, &salt_length,\n                               htonl(boots_uint), htonl(time_uint),\n                               &ptr[privParamsOffset]) == -1) {\n                DEBUGMSGTL((\"usm\", \"Can't set AES iv.\\n\"));\n                return SNMPERR_USM_GENERICERROR;\n            }\n        }\n#endif\n#ifndef NETSNMP_DISABLE_DES\n        /*\n         * XXX  Hardwired to seek into a 1DES private key!\n         */\n        if (USM_CREATE_USER_PRIV_DES == (priv_type & USM_PRIV_MASK_ALG)) {\n            if (!thePrivKey ||\n                (usm_set_salt(salt, &salt_length,\n                              thePrivKey + 8, thePrivKeyLength - 8,\n                              &ptr[privParamsOffset])\n                 == -1)) {\n                DEBUGMSGTL((\"usm\", \"Can't set DES-CBC salt.\\n\"));\n                return SNMPERR_USM_GENERICERROR;\n            }\n        }\n#endif\n\n        if (sc_encrypt(thePrivProtocol, thePrivProtocolLength,\n                       thePrivKey, thePrivKeyLength,\n                       salt, salt_length,\n                       scopedPdu, scopedPduLen,\n                       &ptr[dataOffset], &encrypted_length)\n            != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"encryption error.\\n\"));\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"This data was encrypted:\",\n                       scopedPdu, scopedPduLen);\n            dump_chunk(\"usm/dump\", \"salt + Encrypted form:\",\n                       salt, salt_length);\n            dump_chunk(\"usm/dump\", NULL,\n                       &ptr[dataOffset], encrypted_length);\n            dump_chunk(\"usm/dump\", \"*wholeMsg:\",\n                       *wholeMsg, theTotalLength);\n        }\n#endif\n\n\n        ptr = *wholeMsg;\n        ptr_len = *wholeMsgLen = theTotalLength;\n\n\n        /*\n         * XXX  Sanity check for salt length should be moved up\n         *      under usm_calc_offsets() or tossed.\n         */\n        if ((encrypted_length != (theTotalLength - dataOffset))\n            || (salt_length != msgPrivParmLen)) {\n            DEBUGMSGTL((\"usm\", \"encryption length error.\\n\"));\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n\n        DEBUGMSGTL((\"usm\", \"Encryption successful.\\n\"));\n    }\n\n    /*\n     * No encryption for you!\n     */\n    else {\n        memcpy(&ptr[dataOffset], scopedPdu, scopedPduLen);\n    }\n\n\n\n    /*\n     * Start filling in the other fields (in prep for authentication).\n     * \n     * offSet is an octet string header, which is different from all\n     * the other headers.\n     */\n    remaining = ptr_len - globalDataLen;\n\n    offSet = ptr_len - remaining;\n    asn_build_header(&ptr[offSet], &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), otstlen);\n\n    offSet = ptr_len - remaining;\n    asn_build_sequence(&ptr[offSet], &remaining,\n                       (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), seq_len);\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineID\");\n    asn_build_string(&ptr[offSet], &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), theEngineID,\n                     theEngineIDLength);\n    DEBUGINDENTLESS();\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineBoots\");\n    asn_build_int(&ptr[offSet], &remaining,\n                  (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),\n                  &boots_long, sizeof(long));\n    DEBUGINDENTLESS();\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineTime\");\n    asn_build_int(&ptr[offSet], &remaining,\n                  (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),\n                  &time_long, sizeof(long));\n    DEBUGINDENTLESS();\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgUserName\");\n    asn_build_string(&ptr[offSet], &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), (u_char *) theName,\n                     theNameLength);\n    DEBUGINDENTLESS();\n\n\n    /*\n     * Note: if there is no authentication being done,\n     * msgAuthParmLen is 0, and there is no effect (other than\n     * inserting a zero-length header) of the following\n     * statements.\n     */\n\n    offSet = ptr_len - remaining;\n    asn_build_header(&ptr[offSet],\n                     &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), msgAuthParmLen);\n\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        offSet = ptr_len - remaining;\n        memset(&ptr[offSet], 0, msgAuthParmLen);\n    }\n\n    remaining -= msgAuthParmLen;\n\n\n    /*\n     * Note: if there is no encryption being done, msgPrivParmLen\n     * is 0, and there is no effect (other than inserting a\n     * zero-length header) of the following statements.\n     */\n\n    offSet = ptr_len - remaining;\n    asn_build_header(&ptr[offSet],\n                     &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), msgPrivParmLen);\n\n    remaining -= msgPrivParmLen;        /* Skipping the IV already there. */\n\n\n    /*\n     * For privacy, need to add the octet string header for it.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        offSet = ptr_len - remaining;\n        asn_build_header(&ptr[offSet],\n                         &remaining,\n                         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                   ASN_OCTET_STR),\n                         theTotalLength - dataOffset);\n    }\n\n\n    /*\n     * Adjust overall length and store it as the first SEQ length\n     * of the SNMPv3Message.\n     *\n     * FIX  4 is a magic number!\n     */\n    remaining = theTotalLength;\n    asn_build_sequence(ptr, &remaining,\n                       (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),\n                       theTotalLength - 4);\n\n\n    /*\n     * Now, time to consider / do authentication.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        size_t          temp_sig_len = msgAuthParmLen;\n        u_char         *temp_sig = (u_char *) malloc(temp_sig_len);\n\n        if (temp_sig == NULL) {\n            DEBUGMSGTL((\"usm\", \"Out of memory.\\n\"));\n            return SNMPERR_USM_GENERICERROR;\n        }\n\n        if (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,\n                                   theAuthKey, theAuthKeyLength,\n                                   ptr, ptr_len, temp_sig, &temp_sig_len)\n            != SNMP_ERR_NOERROR) {\n            /*\n             * FIX temp_sig_len defined?!\n             */\n            SNMP_ZERO(temp_sig, temp_sig_len);\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        if (temp_sig_len != msgAuthParmLen) {\n            SNMP_ZERO(temp_sig, temp_sig_len);\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing lengths failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        memcpy(&ptr[authParamsOffset], temp_sig, msgAuthParmLen);\n\n        SNMP_ZERO(temp_sig, temp_sig_len);\n        SNMP_FREE(temp_sig);\n\n    }\n\n    /*\n     * endif -- create keyed hash \n     */\n\n    DEBUGMSGTL((\"usm\", \"USM processing completed.\\n\"));\n\n    return SNMPERR_SUCCESS;\n\n}                               /* end usm_generate_out_msg() */\n\nstatic int\nusm_secmod_generate_out_msg(struct snmp_secmod_outgoing_params *parms)\n{\n    if (!parms)\n        return SNMPERR_GENERR;\n\n    return usm_generate_out_msg(parms->msgProcModel,\n                                parms->globalData, parms->globalDataLen,\n                                parms->maxMsgSize, parms->secModel,\n                                parms->secEngineID, parms->secEngineIDLen,\n                                parms->secName, parms->secNameLen,\n                                parms->secLevel,\n                                parms->scopedPdu, parms->scopedPduLen,\n                                parms->secStateRef,\n                                parms->secParams, parms->secParamsLen,\n                                parms->wholeMsg, parms->wholeMsgLen);\n}\n\n#ifdef NETSNMP_USE_REVERSE_ASNENCODING\nstatic int\nusm_rgenerate_out_msg(int msgProcModel, /* (UNUSED) */\n                      u_char * globalData,      /* IN */\n                      /*\n                       * points at the msgGlobalData, which is of length given by next \n                       * parameter.  \n                       */\n                      size_t globalDataLen,     /* IN - Length of msg header data.      */\n                      int maxMsgSize,   /* (UNUSED) */\n                      int secModel,     /* (UNUSED) */\n                      u_char * secEngineID,     /* IN - Pointer snmpEngineID.           */\n                      size_t secEngineIDLen,    /* IN - SnmpEngineID length.            */\n                      char *secName,    /* IN - Pointer to securityName.        */\n                      size_t secNameLen,        /* IN - SecurityName length.            */\n                      int secLevel,     /* IN - AuthNoPriv, authPriv etc.       */\n                      u_char * scopedPdu,       /* IN */\n                      /*\n                       * Pointer to scopedPdu will be encrypted by USM if needed\n                       * * and written to packet buffer immediately following\n                       * * securityParameters, entire msg will be authenticated by\n                       * * USM if needed.\n                       */\n                      size_t scopedPduLen,      /* IN - scopedPdu length. */\n                      void *secStateRef,        /* IN */\n                      /*\n                       * secStateRef, pointer to cached info provided only for\n                       * * Response, otherwise NULL.\n                       */\n                      u_char ** wholeMsg,       /*  IN/OUT  */\n                      /*\n                       * Points at the pointer to the packet buffer, which might get extended\n                       * if necessary via realloc().  \n                       */\n                      size_t * wholeMsgLen,     /*  IN/OUT  */\n                      /*\n                       * Length of the entire packet buffer, **not** the length of the\n                       * packet.  \n                       */\n                      size_t * offset   /*  IN/OUT  */\n                      /*\n                       * Offset from the end of the packet buffer to the start of the packet,\n                       * also known as the packet length.  \n                       */\n    )\n{\n    size_t          msgAuthParmLen = 0;\n    u_int           boots_uint;\n    u_int           time_uint;\n    long            boots_long;\n    long            time_long;\n\n    /*\n     * Indirection because secStateRef values override parameters.\n     * \n     * None of these are to be free'd - they are either pointing to\n     * what's in the secStateRef or to something either in the\n     * actual parameter list or the user list.\n     */\n\n    char           *theName = NULL;\n    u_int           theNameLength = 0;\n    u_char         *theEngineID = NULL;\n    u_int           theEngineIDLength = 0;\n    u_char         *theAuthKey = NULL;\n    u_int           theAuthKeyLength = 0;\n    const oid      *theAuthProtocol = NULL;\n    u_int           theAuthProtocolLength = 0;\n    u_char         *thePrivKey = NULL;\n    u_int           thePrivKeyLength = 0;\n    const oid      *thePrivProtocol = NULL;\n    u_int           thePrivProtocolLength = 0;\n    int             theSecLevel = 0;    /* No defined const for bad\n                                         * value (other then err). */\n    size_t          salt_length = 0, save_salt_length = 0;\n    u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    u_char          authParams[USM_MAX_AUTHSIZE];\n    u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    size_t          sp_offset = 0, mac_offset = 0;\n    int             rc = 0;\n\n    DEBUGMSGTL((\"usm\", \"USM processing has begun (offset %d)\\n\", (int)*offset));\n\n    if (secStateRef != NULL) {\n        /*\n         * To hush the compiler for now.  XXX \n         */\n        struct usmStateReference *ref\n            = (struct usmStateReference *) secStateRef;\n\n        theName = ref->usr_name;\n        theNameLength = ref->usr_name_length;\n        theEngineID = ref->usr_engine_id;\n        theEngineIDLength = ref->usr_engine_id_length;\n\n        if (!theEngineIDLength) {\n            theEngineID = secEngineID;\n            theEngineIDLength = secEngineIDLen;\n        }\n\n        theAuthProtocol = ref->usr_auth_protocol;\n        theAuthProtocolLength = ref->usr_auth_protocol_length;\n        theAuthKey = ref->usr_auth_key;\n        theAuthKeyLength = ref->usr_auth_key_length;\n        thePrivProtocol = ref->usr_priv_protocol;\n        thePrivProtocolLength = ref->usr_priv_protocol_length;\n        thePrivKey = ref->usr_priv_key;\n        thePrivKeyLength = ref->usr_priv_key_length;\n        theSecLevel = ref->usr_sec_level;\n    }\n\n    /*\n     * * Identify the user record.\n     */\n    else {\n        struct usmUser *user;\n\n        /*\n         * we do allow an unknown user name for\n         * unauthenticated requests. \n         */\n        if ((user = usm_get_user(secEngineID, secEngineIDLen, secName))\n            == NULL && secLevel != SNMP_SEC_LEVEL_NOAUTH) {\n            DEBUGMSGTL((\"usm\", \"Unknown User\\n\"));\n            return SNMPERR_USM_UNKNOWNSECURITYNAME;\n        }\n\n        theName = secName;\n        theNameLength = secNameLen;\n        theEngineID = secEngineID;\n        theSecLevel = secLevel;\n        theEngineIDLength = secEngineIDLen;\n        if (user) {\n            theAuthProtocol = user->authProtocol;\n            theAuthProtocolLength = user->authProtocolLen;\n            theAuthKey = user->authKey;\n            theAuthKeyLength = user->authKeyLen;\n            thePrivProtocol = user->privProtocol;\n            thePrivProtocolLength = user->privProtocolLen;\n            thePrivKey = user->privKey;\n            thePrivKeyLength = user->privKeyLen;\n        } else {\n            /*\n             * unknown users can not do authentication (obviously) \n             */\n            theAuthProtocol = usmNoAuthProtocol;\n            theAuthProtocolLength =\n                sizeof(usmNoAuthProtocol) / sizeof(oid);\n            theAuthKey = NULL;\n            theAuthKeyLength = 0;\n            thePrivProtocol = usmNoPrivProtocol;\n            thePrivProtocolLength =\n                sizeof(usmNoPrivProtocol) / sizeof(oid);\n            thePrivKey = NULL;\n            thePrivKeyLength = 0;\n        }\n    }                           /* endif -- secStateRef==NULL */\n\n\n    /*\n     * From here to the end of the function, avoid reference to\n     * secName, secEngineID, secLevel, and associated lengths.\n     */\n\n\n    /*\n     * Check to see if the user can use the requested sec services.\n     */\n    if (usm_check_secLevel_vs_protocols(theSecLevel,\n                                        theAuthProtocol,\n                                        theAuthProtocolLength,\n                                        thePrivProtocol,\n                                        thePrivProtocolLength) == 1) {\n        DEBUGMSGTL((\"usm\", \"Unsupported Security Level or type (%d)\\n\",\n                    theSecLevel));\n\n        return SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;\n    }\n\n\n    /*\n     * * Retrieve the engine information.\n     * *\n     * * XXX    No error is declared in the EoP when sending messages to\n     * *        unknown engines, processing continues w/ boots/time == (0,0).\n     */\n    if (get_enginetime(theEngineID, theEngineIDLength,\n                       &boots_uint, &time_uint, FALSE) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Failed to find engine data.\"));\n    }\n\n    boots_long = boots_uint;\n    time_long = time_uint;\n\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        /*\n         * Initially assume that the ciphertext will end up the same size as\n         * the plaintext plus some padding.  Really sc_encrypt ought to be able\n         * to grow this for us, a la asn_realloc_rbuild_<type> functions, but\n         * this will do for now.  \n         */\n        u_char         *ciphertext = NULL;\n        size_t          ciphertextlen = scopedPduLen + 64;\n        int             priv_type = sc_get_privtype(thePrivProtocol,\n                                                    thePrivProtocolLength);\n\n        if ((ciphertext = (u_char *) malloc(ciphertextlen)) == NULL) {\n            DEBUGMSGTL((\"usm\",\n                        \"couldn't malloc %d bytes for encrypted PDU\\n\",\n                        (int)ciphertextlen));\n            return SNMPERR_MALLOC;\n        }\n\n        /*\n         * XXX Hardwired to seek into a 1DES private key!  \n         */\n#ifdef HAVE_AES\n        if (USM_CREATE_USER_PRIV_AES == (priv_type & USM_PRIV_MASK_ALG)) {\n            salt_length = BYTESIZE(USM_AES_SALT_LENGTH);\n            save_salt_length = BYTESIZE(USM_AES_SALT_LENGTH)/2;\n            if (!thePrivKey ||\n                usm_set_aes_iv(salt, &salt_length,\n                               htonl(boots_uint), htonl(time_uint),\n                               iv) == -1) {\n                DEBUGMSGTL((\"usm\", \"Can't set AES iv.\\n\"));\n                SNMP_FREE(ciphertext);\n                return SNMPERR_USM_GENERICERROR;\n            }\n        } \n#endif\n#ifndef NETSNMP_DISABLE_DES\n        if (USM_CREATE_USER_PRIV_DES == (priv_type & USM_PRIV_MASK_ALG)) {\n            salt_length = BYTESIZE(USM_DES_SALT_LENGTH);\n            save_salt_length = BYTESIZE(USM_DES_SALT_LENGTH);\n            if (!thePrivKey || (usm_set_salt(salt, &salt_length,\n                                             thePrivKey + 8,\n                                             thePrivKeyLength - 8,\n                                             iv) == -1)) {\n                DEBUGMSGTL((\"usm\", \"Can't set DES-CBC salt.\\n\"));\n                SNMP_FREE(ciphertext);\n                return SNMPERR_USM_GENERICERROR;\n            }\n        }\n#endif\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"This data was encrypted:\",\n                       scopedPdu, scopedPduLen);\n        }\n#endif\n\n        if (sc_encrypt(thePrivProtocol, thePrivProtocolLength,\n                       thePrivKey, thePrivKeyLength,\n                       salt, salt_length,\n                       scopedPdu, scopedPduLen,\n                       ciphertext, &ciphertextlen) != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"encryption error.\\n\"));\n            SNMP_FREE(ciphertext);\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n\n        /*\n         * Write the encrypted scopedPdu back into the packet buffer.  \n         */\n\n        *offset = 0;\n        rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                       (u_char) (ASN_UNIVERSAL |\n                                                 ASN_PRIMITIVE |\n                                                 ASN_OCTET_STR),\n                                       ciphertext, ciphertextlen);\n        if (rc == 0) {\n            DEBUGMSGTL((\"usm\", \"Encryption failed.\\n\"));\n            SNMP_FREE(ciphertext);\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"salt + Encrypted form: \", salt,\n                       salt_length);\n            dump_chunk(\"usm/dump\", \"wholeMsg:\",\n                       (*wholeMsg + *wholeMsgLen - *offset), *offset);\n        }\n#endif\n\n        DEBUGMSGTL((\"usm\", \"Encryption successful.\\n\"));\n        SNMP_FREE(ciphertext);\n    } else {\n        /*\n         * theSecLevel != SNMP_SEC_LEVEL_AUTHPRIV  \n         */\n    }\n\n    /*\n     * Start encoding the msgSecurityParameters.  \n     */\n\n    sp_offset = *offset;\n\n    DEBUGDUMPHEADER(\"send\", \"msgPrivacyParameters\");\n    /*\n     * msgPrivacyParameters (warning: assumes DES salt).  \n     */\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                   iv,\n                                   save_salt_length);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building privParams failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    DEBUGDUMPHEADER(\"send\", \"msgAuthenticationParameters\");\n    /*\n     * msgAuthenticationParameters.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        memset(authParams, 0, sizeof(authParams));\n        msgAuthParmLen =\n            sc_get_auth_maclen(sc_get_authtype(theAuthProtocol,\n                                               theAuthProtocolLength));\n    }\n\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR), authParams,\n                                   msgAuthParmLen);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building authParams failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * Remember where to put the actual HMAC we calculate later on.  An\n     * encoded OCTET STRING of length USM_MD5_AND_SHA_AUTH_LEN has an ASN.1\n     * header of length 2, hence the fudge factor.  This works as long as\n     * auth lengths stay < 127.\n     */\n    mac_offset = *offset - 2;\n\n    /*\n     * msgUserName.  \n     */\n    DEBUGDUMPHEADER(\"send\", \"msgUserName\");\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                   (u_char *) theName, theNameLength);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building authParams failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * msgAuthoritativeEngineTime.  \n     */\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineTime\");\n    rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,\n                                (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                          ASN_INTEGER), &time_long,\n                                sizeof(long));\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\",\n                    \"building msgAuthoritativeEngineTime failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * msgAuthoritativeEngineBoots.  \n     */\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineBoots\");\n    rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,\n                                (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                          ASN_INTEGER), &boots_long,\n                                sizeof(long));\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\",\n                    \"building msgAuthoritativeEngineBoots failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineID\");\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR), theEngineID,\n                                   theEngineIDLength);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building msgAuthoritativeEngineID failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * USM msgSecurityParameters sequence header  \n     */\n    rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,\n                                     (u_char) (ASN_SEQUENCE |\n                                               ASN_CONSTRUCTOR),\n                                     *offset - sp_offset);\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building usm security parameters failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * msgSecurityParameters OCTET STRING wrapper.  \n     */\n    rc = asn_realloc_rbuild_header(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                   *offset - sp_offset);\n\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building msgSecurityParameters failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * Copy in the msgGlobalData and msgVersion.  \n     */\n    while ((*wholeMsgLen - *offset) < globalDataLen) {\n        if (!asn_realloc(wholeMsg, wholeMsgLen)) {\n            DEBUGMSGTL((\"usm\", \"building global data failed.\\n\"));\n            return SNMPERR_TOO_LONG;\n        }\n    }\n\n    *offset += globalDataLen;\n    memcpy(*wholeMsg + *wholeMsgLen - *offset, globalData, globalDataLen);\n\n    /*\n     * Total packet sequence.  \n     */\n    rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,\n                                     (u_char) (ASN_SEQUENCE |\n                                               ASN_CONSTRUCTOR), *offset);\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building master packet sequence failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * Now consider / do authentication.  \n     */\n\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n        theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        size_t          temp_sig_len = msgAuthParmLen;\n        u_char         *temp_sig = (u_char *) malloc(temp_sig_len);\n        u_char         *proto_msg = *wholeMsg + *wholeMsgLen - *offset;\n        size_t          proto_msg_len = *offset;\n\n\n        if (temp_sig == NULL) {\n            DEBUGMSGTL((\"usm\", \"Out of memory.\\n\"));\n            return SNMPERR_USM_GENERICERROR;\n        }\n\n        if (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,\n                                   theAuthKey, theAuthKeyLength,\n                                   proto_msg, proto_msg_len,\n                                   temp_sig, &temp_sig_len)\n            != SNMP_ERR_NOERROR) {\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        if (temp_sig_len != msgAuthParmLen) {\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing lengths failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        memcpy(*wholeMsg + *wholeMsgLen - mac_offset, temp_sig,\n               msgAuthParmLen);\n        SNMP_FREE(temp_sig);\n    }\n    /*\n     * endif -- create keyed hash \n     */\n    DEBUGMSGTL((\"usm\", \"USM processing completed.\\n\"));\n    return SNMPERR_SUCCESS;\n}                               /* end usm_rgenerate_out_msg() */\n\nstatic int\nusm_secmod_rgenerate_out_msg(struct snmp_secmod_outgoing_params *parms)\n{\n    if (!parms)\n        return SNMPERR_GENERR;\n\n    return usm_rgenerate_out_msg(parms->msgProcModel,\n                                 parms->globalData, parms->globalDataLen,\n                                 parms->maxMsgSize, parms->secModel,\n                                 parms->secEngineID, parms->secEngineIDLen,\n                                 parms->secName, parms->secNameLen,\n                                 parms->secLevel,\n                                 parms->scopedPdu, parms->scopedPduLen,\n                                 parms->secStateRef,\n                                 parms->wholeMsg, parms->wholeMsgLen,\n                                 parms->wholeMsgOffset);\n}\n#endif                          /* */\n\n/*******************************************************************-o-******\n * usm_parse_security_parameters\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\ttab stop 4\n *\n *\tExtracts values from the security header and data portions of the\n *\tincoming buffer.\n */\nstatic int\nusm_parse_security_parameters(u_char * secParams,\n                              size_t remaining,\n                              u_char * secEngineID,\n                              size_t * secEngineIDLen,\n                              u_int * boots_uint,\n                              u_int * time_uint,\n                              char *secName,\n                              size_t * secNameLen,\n                              u_char * signature,\n                              size_t * signature_length,\n                              u_char * salt,\n                              size_t * salt_length, u_char ** data_ptr)\n{\n    u_char         *parse_ptr = secParams;\n    u_char         *value_ptr;\n    u_char         *next_ptr;\n    u_char          type_value;\n\n    size_t          octet_string_length = remaining;\n    size_t          sequence_length;\n    size_t          remaining_bytes;\n\n    long            boots_long;\n    long            time_long;\n\n    u_int           origNameLen;\n\n\n    /*\n     * Eat the first octet header.\n     */\n    if ((value_ptr = asn_parse_sequence(parse_ptr, &octet_string_length,\n                                        &type_value,\n                                        (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                         ASN_OCTET_STR),\n                                        \"usm first octet\")) == NULL) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Eat the sequence header.\n     */\n    parse_ptr = value_ptr;\n    sequence_length = octet_string_length;\n\n    if ((value_ptr = asn_parse_sequence(parse_ptr, &sequence_length,\n                                        &type_value,\n                                        (ASN_SEQUENCE | ASN_CONSTRUCTOR),\n                                        \"usm sequence\")) == NULL) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Retrieve the engineID.\n     */\n    parse_ptr = value_ptr;\n    remaining_bytes = sequence_length;\n\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthoritativeEngineID\");\n    if ((next_ptr\n         = asn_parse_string(parse_ptr, &remaining_bytes, &type_value,\n                            secEngineID, secEngineIDLen)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Retrieve the engine boots, notice switch in the way next_ptr and\n     * remaining_bytes are used (to accomodate the asn code).\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthoritativeEngineBoots\");\n    if ((next_ptr = asn_parse_int(next_ptr, &remaining_bytes, &type_value,\n                                  &boots_long, sizeof(long))) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n    *boots_uint = (u_int) boots_long;\n\n\n    /*\n     * Retrieve the time value.\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthoritativeEngineTime\");\n    if ((next_ptr = asn_parse_int(next_ptr, &remaining_bytes, &type_value,\n                                  &time_long, sizeof(long))) == NULL) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n    *time_uint = (u_int) time_long;\n\n    if (*boots_uint > ENGINEBOOT_MAX || *time_uint > ENGINETIME_MAX) {\n        return -1;\n    }\n\n    /*\n     * Retrieve the secName.\n     */\n    origNameLen = *secNameLen;\n\n\n    DEBUGDUMPHEADER(\"recv\", \"msgUserName\");\n    if ((next_ptr\n         = asn_parse_string(next_ptr, &remaining_bytes, &type_value,\n                            (u_char *) secName, secNameLen)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    /*\n     * FIX -- doesn't this also indicate a buffer overrun?\n     */\n    if (origNameLen < *secNameLen + 1) {\n        /*\n         * RETURN parse error, but it's really a parameter error \n         */\n        return -1;\n    }\n\n    if (*secNameLen > 32) {\n        /*\n         * This is a USM-specific limitation over and above the above\n         * limitation (which will probably default to the length of an\n         * SnmpAdminString, i.e. 255).  See RFC 2574, sec. 2.4.  \n         */\n        return -1;\n    }\n\n    secName[*secNameLen] = '\\0';\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Retrieve the signature and blank it if there.\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthenticationParameters\");\n    if ((next_ptr\n         = asn_parse_string(next_ptr, &remaining_bytes, &type_value,\n                            signature, signature_length)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n    if (*signature_length != 0) {       /* Blanking for authentication step later */\n        memset(next_ptr - (u_long) * signature_length,\n               0, *signature_length);\n    }\n\n\n    /*\n     * Retrieve the salt.\n     *\n     * Note that the next ptr is where the data section starts.\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgPrivacyParameters\");\n    if ((*data_ptr\n         = asn_parse_string(next_ptr, &remaining_bytes, &type_value,\n                            salt, salt_length)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -2;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -2;\n    }\n\n    return 0;\n\n}                               /* end usm_parse_security_parameters() */\n\n\n\n\n/*******************************************************************-o-******\n * usm_check_and_update_timeliness\n *\n * Parameters:\n *\t*secEngineID\n *\t secEngineIDen\n *\t boots_uint\n *\t time_uint\n *\t*error\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\t\n *\n * Performs the incoming timeliness checking and setting.\n */\nstatic int\nusm_check_and_update_timeliness(u_char * secEngineID,\n                                size_t secEngineIDLen,\n                                u_int boots_uint,\n                                u_int time_uint, int *error)\n{\n    u_char          myID[USM_MAX_ID_LENGTH];\n    u_long          myIDLength =\n        snmpv3_get_engineID(myID, USM_MAX_ID_LENGTH);\n    u_int           myBoots;\n    u_int           myTime;\n\n\n\n    if ((myIDLength > USM_MAX_ID_LENGTH) || (myIDLength == 0)) {\n        /*\n         * We're probably already screwed...buffer overwrite.  XXX? \n         */\n        DEBUGMSGTL((\"usm\", \"Buffer overflow.\\n\"));\n        *error = SNMPERR_USM_GENERICERROR;\n        return -1;\n    }\n\n    myBoots = snmpv3_local_snmpEngineBoots();\n    myTime = snmpv3_local_snmpEngineTime();\n\n\n    /*\n     * IF the time involved is local\n     *     Make sure  message is inside the time window \n     * ELSE \n     *      IF boots is higher or boots is the same and time is higher\n     *              remember this new data\n     *      ELSE\n     *              IF !(boots same and time within USM_TIME_WINDOW secs)\n     *                      Message is too old \n     *              ELSE    \n     *                      Message is ok, but don't take time\n     *              ENDIF\n     *      ENDIF\n     * ENDIF\n     */\n\n    /*\n     * This is a local reference.\n     */\n    if (secEngineIDLen == myIDLength\n        && memcmp(secEngineID, myID, myIDLength) == 0) {\n        u_int           time_difference = myTime > time_uint ?\n            myTime - time_uint : time_uint - myTime;\n\n        if (boots_uint == ENGINEBOOT_MAX\n            || boots_uint != myBoots\n            || time_difference > USM_TIME_WINDOW) {\n            snmp_increment_statistic(STAT_USMSTATSNOTINTIMEWINDOWS);\n\n            DEBUGMSGTL((\"usm\",\n                        \"boot_uint %u myBoots %u time_diff %u => not in time window\\n\",\n                        boots_uint, myBoots, time_difference));\n            *error = SNMPERR_USM_NOTINTIMEWINDOW;\n            return -1;\n        }\n\n        *error = SNMPERR_SUCCESS;\n        return 0;\n    }\n\n    /*\n     * This is a remote reference.\n     */\n    else {\n        u_int           theirBoots, theirTime, theirLastTime;\n        u_int           time_difference;\n\n        if (get_enginetime_ex(secEngineID, secEngineIDLen,\n                              &theirBoots, &theirTime,\n                              &theirLastTime, TRUE)\n            != SNMPERR_SUCCESS) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\",\n                        \"Failed to get remote engine's times.\"));\n\n            *error = SNMPERR_USM_GENERICERROR;\n            return -1;\n        }\n\n        time_difference = theirTime > time_uint ?\n            theirTime - time_uint : time_uint - theirTime;\n\n\n        /*\n         * XXX  Contrary to the pseudocode:\n         *      See if boots is invalid first.\n         */\n        if (theirBoots == ENGINEBOOT_MAX || theirBoots > boots_uint) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\", \"Remote boot count invalid.\"));\n\n            *error = SNMPERR_USM_NOTINTIMEWINDOW;\n            return -1;\n        }\n\n\n        /*\n         * Boots is ok, see if the boots is the same but the time\n         * is old.\n         */\n        if (theirBoots == boots_uint && time_uint < theirLastTime) {\n            if (time_difference > USM_TIME_WINDOW) {\n                DEBUGMSGTL((\"usm\", \"%s\\n\", \"Message too old.\"));\n                *error = SNMPERR_USM_NOTINTIMEWINDOW;\n                return -1;\n            }\n\n            else {              /* Old, but acceptable */\n\n                *error = SNMPERR_SUCCESS;\n                return 0;\n            }\n        }\n\n\n        /*\n         * Message is ok, either boots has been advanced, or\n         * time is greater than before with the same boots.\n         */\n\n        if (set_enginetime(secEngineID, secEngineIDLen,\n                           boots_uint, time_uint, TRUE)\n            != SNMPERR_SUCCESS) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\",\n                        \"Failed updating remote boot/time.\"));\n            *error = SNMPERR_USM_GENERICERROR;\n            return -1;\n        }\n\n        *error = SNMPERR_SUCCESS;\n        return 0;               /* Fresh message and time updated */\n\n    }                           /* endif -- local or remote time reference. */\n\n\n}                               /* end usm_check_and_update_timeliness() */\n\n/*******************************************************************-o-******\n * usm_check_secLevel\n *\n * Parameters:\n *\t level\n *\t*user\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n * Checks that a given security level is valid for a given user.\n */\nstatic int\nusm_check_secLevel(int level, struct usmUser *user)\n{\n\n    if (user->userStatus != RS_ACTIVE)\n        return -1;\n\n    DEBUGMSGTL((\"comparex\", \"Comparing: %\" NETSNMP_PRIo \"u %\" NETSNMP_PRIo \"u \",\n                usmNoPrivProtocol[0], usmNoPrivProtocol[1]));\n    DEBUGMSGOID((\"comparex\", usmNoPrivProtocol,\n                 sizeof(usmNoPrivProtocol) / sizeof(oid)));\n    DEBUGMSG((\"comparex\", \"\\n\"));\n    if (level == SNMP_SEC_LEVEL_AUTHPRIV\n        && (netsnmp_oid_equals(user->privProtocol, user->privProtocolLen,\n                             usmNoPrivProtocol,\n                             sizeof(usmNoPrivProtocol) / sizeof(oid)) ==\n            0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"User (%s) Auth Protocol: \", user->name));\n        DEBUGMSGOID((\"usm\", user->authProtocol, user->authProtocolLen));\n        DEBUGMSG((\"usm\", \", User Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", user->privProtocol, user->privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n    if ((level == SNMP_SEC_LEVEL_AUTHPRIV\n         || level == SNMP_SEC_LEVEL_AUTHNOPRIV)\n        &&\n        (netsnmp_oid_equals\n         (user->authProtocol, user->authProtocolLen, usmNoAuthProtocol,\n          sizeof(usmNoAuthProtocol) / sizeof(oid)) == 0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"User (%s) Auth Protocol: \", user->name));\n        DEBUGMSGOID((\"usm\", user->authProtocol, user->authProtocolLen));\n        DEBUGMSG((\"usm\", \", User Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", user->privProtocol, user->privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n\n    return 0;\n}                               /* end usm_check_secLevel() */\n\n/*******************************************************************-o-******\n * usm_process_in_msg\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\tSNMPERR_SUCCESS\t\t\tOn success.\n *\tSNMPERR_USM_AUTHENTICATIONFAILURE\n *\tSNMPERR_USM_DECRYPTIONERROR\n *\tSNMPERR_USM_GENERICERROR\n *\tSNMPERR_USM_PARSEERROR\n *\tSNMPERR_USM_UNKNOWNENGINEID\n *\tSNMPERR_USM_PARSEERROR\n *\tSNMPERR_USM_UNKNOWNSECURITYNAME\n *\tSNMPERR_USM_UNSUPPORTEDSECURITYLEVEL\n *\n *\n * ASSUMES size of decrypt_buf will always be >= size of encrypted sPDU.\n */\nstatic int\nusm_process_in_msg(int msgProcModel,    /* (UNUSED) */\n                   size_t maxMsgSize,   /* IN     - Used to calc maxSizeResponse.  */\n                   u_char * secParams,  /* IN     - BER encoded securityParameters. */\n                   int secModel,        /* (UNUSED) */\n                   int secLevel,        /* IN     - AuthNoPriv, authPriv etc.      */\n                   u_char * wholeMsg,   /* IN     - Original v3 message.           */\n                   size_t wholeMsgLen,  /* IN     - Msg length.                    */\n                   u_char * secEngineID,        /* OUT    - Pointer snmpEngineID.          */\n                   size_t * secEngineIDLen,     /* IN/OUT - Len available, len returned.   */\n                   /*\n                    * NOTE: Memory provided by caller.      \n                    */\n                   char *secName,       /* OUT    - Pointer to securityName.       */\n                   size_t * secNameLen, /* IN/OUT - Len available, len returned.   */\n                   u_char ** scopedPdu, /* OUT    - Pointer to plaintext scopedPdu. */\n                   size_t * scopedPduLen,       /* IN/OUT - Len available, len returned.   */\n                   size_t * maxSizeResponse,    /* OUT    - Max size of Response PDU.      */\n                   void **secStateRf,   /* OUT    - Ref to security state.         */\n                   netsnmp_session * sess,      /* IN     - session which got the message  */\n                   u_char msg_flags)\n{                               /* IN     - v3 Message flags.              */\n    size_t          remaining = wholeMsgLen - (u_int)\n        ((u_long) * secParams - (u_long) * wholeMsg);\n    u_int           boots_uint;\n    u_int           time_uint;\n#ifdef HAVE_AES\n    u_int           net_boots, net_time;\n#endif\n#ifndef NETSNMP_DISABLE_DES\n    int             i;\n#endif\n    u_char          signature[USM_MAX_AUTHSIZE];\n    size_t          signature_length = USM_MAX_AUTHSIZE;\n    u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    size_t          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);\n    u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    u_int           iv_length = BYTESIZE(USM_MAX_SALT_LENGTH);\n    u_char         *data_ptr;\n    u_char         *value_ptr;\n    u_char          type_value;\n    u_char         *end_of_overhead = NULL;\n    int             error;\n    int             rc = 0;\n    struct usmStateReference **secStateRef =\n        (struct usmStateReference **) secStateRf;\n\n    struct usmUser *user;\n\n\n    DEBUGMSGTL((\"usm\", \"USM processing begun...\\n\"));\n\n    netsnmp_assert(secStateRef);\n\n    usm_free_usmStateReference(*secStateRef);\n    *secStateRef = usm_malloc_usmStateReference();\n    if (*secStateRef == NULL) {\n        DEBUGMSGTL((\"usm\", \"Out of memory.\\n\"));\n        return SNMPERR_USM_GENERICERROR;\n    }\n\n    /*\n     * Make sure the *secParms is an OCTET STRING.\n     * Extract the user name, engine ID, and security level.\n     */\n    if ((rc = usm_parse_security_parameters(secParams, remaining,\n                                            secEngineID, secEngineIDLen,\n                                            &boots_uint, &time_uint,\n                                            secName, secNameLen,\n                                            signature, &signature_length,\n                                            salt, &salt_length,\n                                            &data_ptr)) < 0) {\n        DEBUGMSGTL((\"usm\", \"Parsing failed (rc %d).\\n\", rc));\n        if (rc == -2) {\n            /*\n             * This indicates a decryptionError.  \n             */\n            snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n            error = SNMPERR_USM_DECRYPTIONERROR;\n        } else {\n            snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);\n            error = SNMPERR_USM_PARSEERROR;\n        }\n        goto err;\n    }\n\n    /*\n     * RFC 2574 section 8.3.2\n     * 1)  If the privParameters field is not an 8-octet OCTET STRING,\n     * then an error indication (decryptionError) is returned to the\n     * calling module.\n     */\n    if ((secLevel == SNMP_SEC_LEVEL_AUTHPRIV) && (salt_length != 8)) {\n        snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n        error = SNMPERR_USM_DECRYPTIONERROR;\n        goto err;\n    }\n\n    if (secLevel != SNMP_SEC_LEVEL_AUTHPRIV) {\n        /*\n         * pull these out now so reports can use them \n         */\n        *scopedPdu = data_ptr;\n        *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);\n        end_of_overhead = data_ptr;\n    }\n\n    /*\n     * Cache the name, engine ID, and security level,\n     * * per step 2 (section 3.2)\n     */\n    if (usm_set_usmStateReference_name\n        (*secStateRef, secName, *secNameLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache name.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_engine_id\n        (*secStateRef, secEngineID, *secEngineIDLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache engine id.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_sec_level(*secStateRef, secLevel) ==\n        -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache security level.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    /*\n     * Locate the engine ID record.\n     * If it is unknown, then either create one or note this as an error.\n     */\n    if ((sess && (sess->isAuthoritative == SNMP_SESS_AUTHORITATIVE ||\n                  (sess->isAuthoritative == SNMP_SESS_UNKNOWNAUTH &&\n                   (msg_flags & SNMP_MSG_FLAG_RPRT_BIT)))) ||\n        (!sess && (msg_flags & SNMP_MSG_FLAG_RPRT_BIT))) {\n        if (ISENGINEKNOWN(secEngineID, *secEngineIDLen) == FALSE) {\n            DEBUGMSGTL((\"usm\", \"Unknown Engine ID.\\n\"));\n            snmp_increment_statistic(STAT_USMSTATSUNKNOWNENGINEIDS);\n            error = SNMPERR_USM_UNKNOWNENGINEID;\n            goto err;\n        }\n    } else {\n        if (ENSURE_ENGINE_RECORD(secEngineID, *secEngineIDLen)\n            != SNMPERR_SUCCESS) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't ensure engine record.\"));\n            error = SNMPERR_USM_GENERICERROR;\n            goto err;\n        }\n\n    }\n\n\n    /*\n     * Locate the User record.\n     * If the user/engine ID is unknown, report this as an error.\n     */\n    if ((user = usm_get_user_from_list(secEngineID, *secEngineIDLen,\n                                       secName, userList,\n                                       (((sess && sess->isAuthoritative ==\n                                          SNMP_SESS_AUTHORITATIVE) ||\n                                         (!sess)) ? 0 : 1)))\n        == NULL) {\n        DEBUGMSGTL((\"usm\", \"Unknown User(%s)\\n\", secName));\n        snmp_increment_statistic(STAT_USMSTATSUNKNOWNUSERNAMES);\n        error = SNMPERR_USM_UNKNOWNSECURITYNAME;\n        goto err;\n    }\n\n    /* ensure the user is active */\n    if (user->userStatus != RS_ACTIVE) {\n        DEBUGMSGTL((\"usm\", \"Attempt to use an inactive user.\\n\"));\n        error = SNMPERR_USM_UNKNOWNSECURITYNAME;\n        goto err;\n    }\n\n    /*\n     * Make sure the security level is appropriate.\n     */\n\n    rc = usm_check_secLevel(secLevel, user);\n    if (1 == rc) {\n        DEBUGMSGTL((\"usm\", \"Unsupported Security Level (%d).\\n\",\n                    secLevel));\n        snmp_increment_statistic(STAT_USMSTATSUNSUPPORTEDSECLEVELS);\n        error = SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;\n        goto err;\n    } else if (rc != 0) {\n        DEBUGMSGTL((\"usm\", \"Unknown issue.\\n\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    /*\n     * Check the authentication credentials of the message.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (sc_check_keyed_hash(user->authProtocol, user->authProtocolLen,\n                                user->authKey, user->authKeyLen,\n                                wholeMsg, wholeMsgLen,\n                                signature, signature_length)\n            != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"Verification failed.\\n\"));\n            snmp_increment_statistic(STAT_USMSTATSWRONGDIGESTS);\n\t    snmp_log(LOG_WARNING, \"Authentication failed for %s\\n\",\n\t\t\t\tuser->name);\n            error = SNMPERR_USM_AUTHENTICATIONFAILURE;\n            goto err;\n        }\n\n        DEBUGMSGTL((\"usm\", \"Verification succeeded.\\n\"));\n    }\n\n\n    /*\n     * Steps 10-11  user is already set - relocated before timeliness \n     * check in case it fails - still save user data for response.\n     *\n     * Cache the keys and protocol oids, per step 11 (s3.2).\n     */\n    if (usm_set_usmStateReference_auth_protocol(*secStateRef,\n                                                user->authProtocol,\n                                                user->\n                                                authProtocolLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\",\n                    \"Couldn't cache authentication protocol.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_auth_key(*secStateRef,\n                                           user->authKey,\n                                           user->authKeyLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\",\n                    \"Couldn't cache authentication key.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_priv_protocol(*secStateRef,\n                                                user->privProtocol,\n                                                user->\n                                                privProtocolLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\",\n                    \"Couldn't cache privacy protocol.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_priv_key(*secStateRef,\n                                           user->privKey,\n                                           user->privKeyLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache privacy key.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n\n    /*\n     * Perform the timeliness/time manager functions.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (usm_check_and_update_timeliness(secEngineID, *secEngineIDLen,\n                                            boots_uint, time_uint,\n                                            &error) == -1) {\n            goto err;\n        }\n    }\n#ifdef\t\t\t\t\t\t\tLCD_TIME_SYNC_OPT\n    /*\n     * Cache the unauthenticated time to use in case we don't have\n     * anything better - this guess will be no worse than (0,0)\n     * that we normally use.\n     */\n    else {\n        set_enginetime(secEngineID, *secEngineIDLen,\n                       boots_uint, time_uint, FALSE);\n    }\n#endif                          /* LCD_TIME_SYNC_OPT */\n\n\n    /*\n     * If needed, decrypt the scoped PDU.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        int priv_type = sc_get_privtype(user->privProtocol,\n                                        user->privProtocolLen);\n        remaining = wholeMsgLen - (data_ptr - wholeMsg);\n\n        if ((value_ptr = asn_parse_sequence(data_ptr, &remaining,\n                                            &type_value,\n                                            (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                            \"encrypted sPDU\")) == NULL) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\",\n                        \"Failed while parsing encrypted sPDU.\"));\n            snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);\n            usm_free_usmStateReference(*secStateRef);\n            *secStateRef = NULL;\n            error = SNMPERR_USM_PARSEERROR;\n            goto err;\n        }\n\n#ifndef NETSNMP_DISABLE_DES\n        if (USM_CREATE_USER_PRIV_DES == (priv_type & USM_PRIV_MASK_ALG)) {\n            /*\n             * From RFC2574:\n             * \n             * \"Before decryption, the encrypted data length is verified.\n             * If the length of the OCTET STRING to be decrypted is not\n             * an integral multiple of 8 octets, the decryption process\n             * is halted and an appropriate exception noted.\"  \n             */\n\n            if (remaining % 8 != 0) {\n                DEBUGMSGTL((\"usm\",\n                            \"Ciphertext is %lu bytes, not an integer multiple of 8 (rem %lu)\\n\",\n                            (unsigned long)remaining, (unsigned long)remaining % 8));\n                snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n                usm_free_usmStateReference(*secStateRef);\n                *secStateRef = NULL;\n                error = SNMPERR_USM_DECRYPTIONERROR;\n                goto err;\n            }\n\n            end_of_overhead = value_ptr;\n\n            if ( !user->privKey ) {\n                DEBUGMSGTL((\"usm\", \"No privacy pass phrase for %s\\n\", user->secName));\n                snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n                usm_free_usmStateReference(*secStateRef);\n                *secStateRef = NULL;\n                error = SNMPERR_USM_DECRYPTIONERROR;\n                goto err;\n            }\n\n            /*\n             * XOR the salt with the last (iv_length) bytes\n             * of the priv_key to obtain the IV.\n             */\n            iv_length = BYTESIZE(USM_DES_SALT_LENGTH);\n            for (i = 0; i < (int) iv_length; i++)\n                iv[i] = salt[i] ^ user->privKey[iv_length + i];\n        }\n#endif\n#ifdef HAVE_AES\n        if (USM_CREATE_USER_PRIV_AES == (priv_type & USM_PRIV_MASK_ALG)) {\n            iv_length = BYTESIZE(USM_AES_SALT_LENGTH);\n            net_boots = ntohl(boots_uint);\n            net_time = ntohl(time_uint);\n            memcpy(iv, &net_boots, 4);\n            memcpy(iv+4, &net_time, 4);\n            memcpy(iv+8, salt, salt_length);\n        }\n#endif\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"Cypher Text\", value_ptr, remaining);\n            dump_chunk(\"usm/dump\", \"salt + Encrypted form:\",\n                       salt, salt_length);\n            dump_chunk(\"usm/dump\", \"IV + Encrypted form:\", iv, iv_length);\n        }\n#endif\n        if (sc_decrypt(user->privProtocol, user->privProtocolLen,\n                       user->privKey, user->privKeyLen,\n                       iv, iv_length,\n                       value_ptr, remaining, *scopedPdu, scopedPduLen)\n            != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\", \"Failed decryption.\"));\n            snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n            error = SNMPERR_USM_DECRYPTIONERROR;\n            goto err;\n        }\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"Decrypted chunk:\",\n                       *scopedPdu, *scopedPduLen);\n        }\n#endif\n    }\n    /*\n     * sPDU is plaintext.\n     */\n    else {\n        *scopedPdu = data_ptr;\n        *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);\n        end_of_overhead = data_ptr;\n\n    }                           /* endif -- PDU decryption */\n\n\n    /*\n     * Calculate the biggest sPDU for the response (i.e., whole - ovrhd).\n     *\n     * FIX  Correct? \n     */\n    *maxSizeResponse = maxMsgSize - (end_of_overhead - wholeMsg);\n\n\n    DEBUGMSGTL((\"usm\", \"USM processing completed.\\n\"));\n\n    return SNMPERR_SUCCESS;\n\nerr:\n    usm_free_usmStateReference(*secStateRef);\n    *secStateRef = NULL;\n    netsnmp_assert(error != SNMPERR_SUCCESS);\n    return error;\n}                               /* end usm_process_in_msg() */\n\nstatic int\nusm_secmod_process_in_msg(struct snmp_secmod_incoming_params *parms)\n{\n    if (!parms)\n        return SNMPERR_GENERR;\n\n    return usm_process_in_msg(parms->msgProcModel,\n                              parms->maxMsgSize,\n                              parms->secParams,\n                              parms->secModel,\n                              parms->secLevel,\n                              parms->wholeMsg,\n                              parms->wholeMsgLen,\n                              parms->secEngineID,\n                              parms->secEngineIDLen,\n                              parms->secName,\n                              parms->secNameLen,\n                              parms->scopedPdu,\n                              parms->scopedPduLen,\n                              parms->maxSizeResponse,\n                              parms->secStateRef,\n                              parms->sess, parms->msg_flags);\n}\n\nstatic void\nusm_handle_report(struct session_list *slp,\n                  netsnmp_transport *transport, netsnmp_session *session,\n                  int result, netsnmp_pdu *pdu)\n{\n    /*\n     * handle reportable errors \n     */\n\n    /* this will get in our way */\n    usm_free_usmStateReference(pdu->securityStateRef);\n    pdu->securityStateRef = NULL;\n\n    switch (result) {\n    case SNMPERR_USM_AUTHENTICATIONFAILURE:\n    {\n        int res = session->s_snmp_errno;\n        session->s_snmp_errno = result;\n        if (session->callback) {\n            session->callback(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE,\n                              session, pdu->reqid, pdu,\n                              session->callback_magic);\n        }\n        session->s_snmp_errno = res;\n    }  \n    /* fallthrough */\n    case SNMPERR_USM_UNKNOWNENGINEID:\n    case SNMPERR_USM_UNKNOWNSECURITYNAME:\n    case SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL:\n    case SNMPERR_USM_NOTINTIMEWINDOW:\n    case SNMPERR_USM_DECRYPTIONERROR:\n\n        if (SNMP_CMD_CONFIRMED(pdu->command) ||\n            (pdu->command == 0\n             && (pdu->flags & SNMP_MSG_FLAG_RPRT_BIT))) {\n            netsnmp_pdu    *pdu2;\n            int             flags = pdu->flags;\n\n            pdu->flags |= UCD_MSG_FLAG_FORCE_PDU_COPY;\n            pdu2 = snmp_clone_pdu(pdu);\n            pdu->flags = pdu2->flags = flags;\n            snmpv3_make_report(pdu2, result);\n            if (0 == snmp_sess_send(slp, pdu2)) {\n                snmp_free_pdu(pdu2);\n                /*\n                 * TODO: indicate error \n                 */\n            }\n        }\n        break;\n    }       \n}\n\n/** utility function to call netsnmp_extend_kul for a usmUser */\nint\nusm_extend_user_kul(struct usmUser *user, u_int privKeyBufSize)\n{\n    netsnmp_priv_alg_info *pai;\n\n    DEBUGMSGTL((\"usm\", \"extending key\\n\"));\n\n    if (NULL == user) {\n        DEBUGMSGTL((\"usm\", \"null user!\\n\"));\n        return SNMPERR_GENERR;\n    }\n\n    pai = sc_get_priv_alg_byoid(user->privProtocol, user->privProtocolLen);\n    if (NULL == pai) {\n        DEBUGMSGTL((\"usm\", \"privProtocol lookup failed!\\n\"));\n        return SNMPERR_GENERR;\n    }\n\n    return netsnmp_extend_kul(pai->proper_length, user->authProtocol,\n                              user->authProtocolLen, pai->type, user->engineID,\n                              user->engineIDLen, &user->privKey,\n                              &user->privKeyLen, privKeyBufSize);\n}\n\n/* sets up initial default session parameters */\nstatic int\nusm_session_init(netsnmp_session *in_session, netsnmp_session *session)\n{\n    char *cp;\n    size_t i;\n    \n    if (in_session->securityAuthProtoLen > 0) {\n        session->securityAuthProto =\n            snmp_duplicate_objid(in_session->securityAuthProto,\n                                 in_session->securityAuthProtoLen);\n        if (session->securityAuthProto == NULL) {\n            in_session->s_snmp_errno = SNMPERR_MALLOC;\n            return SNMPERR_MALLOC;\n        }\n    } else if (get_default_authtype(&i) != NULL) {\n        session->securityAuthProto =\n            snmp_duplicate_objid(get_default_authtype(NULL), i);\n        session->securityAuthProtoLen = i;\n    }\n\n    if (in_session->securityPrivProtoLen > 0) {\n        session->securityPrivProto =\n            snmp_duplicate_objid(in_session->securityPrivProto,\n                                 in_session->securityPrivProtoLen);\n        if (session->securityPrivProto == NULL) {\n            in_session->s_snmp_errno = SNMPERR_MALLOC;\n            return SNMPERR_MALLOC;\n        }\n    } else if (get_default_privtype(&i) != NULL) {\n        session->securityPrivProto =\n            snmp_duplicate_objid(get_default_privtype(NULL), i);\n        session->securityPrivProtoLen = i;\n    }\n\n    if ((in_session->securityAuthKeyLen <= 0) &&\n        ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t     NETSNMP_DS_LIB_AUTHMASTERKEY)))) {\n        size_t buflen = sizeof(session->securityAuthKey);\n        u_char *tmpp = session->securityAuthKey;\n        session->securityAuthKeyLen = 0;\n        /* it will be a hex string */\n        if (!snmp_hex_to_binary(&tmpp, &buflen,\n                                &session->securityAuthKeyLen, 0, cp)) {\n            snmp_set_detail(\"error parsing authentication master key\");\n            return SNMP_ERR_GENERR;\n        }\n    } else if ((in_session->securityAuthKeyLen <= 0) &&\n               ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_AUTHPASSPHRASE)) ||\n                (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_PASSPHRASE)))) {\n        session->securityAuthKeyLen = USM_AUTH_KU_LEN;\n        if (generate_Ku(session->securityAuthProto,\n                        session->securityAuthProtoLen,\n                        (u_char *) cp, strlen(cp),\n                        session->securityAuthKey,\n                        &session->securityAuthKeyLen) != SNMPERR_SUCCESS) {\n            snmp_set_detail\n                (\"Error generating a key (Ku) from the supplied authentication pass phrase.\");\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n    \n    if ((in_session->securityPrivKeyLen <= 0) &&\n        ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t     NETSNMP_DS_LIB_PRIVMASTERKEY)))) {\n        size_t buflen = sizeof(session->securityPrivKey);\n        u_char *tmpp = session->securityPrivKey;\n        session->securityPrivKeyLen = 0;\n        /* it will be a hex string */\n        if (!snmp_hex_to_binary(&tmpp, &buflen,\n                                &session->securityPrivKeyLen, 0, cp)) {\n            snmp_set_detail(\"error parsing encryption master key\");\n            return SNMP_ERR_GENERR;\n        }\n    } else if ((in_session->securityPrivKeyLen <= 0) &&\n               ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_PRIVPASSPHRASE)) ||\n                (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_PASSPHRASE)))) {\n        session->securityPrivKeyLen = USM_PRIV_KU_LEN;\n        if (generate_Ku(session->securityAuthProto,\n                        session->securityAuthProtoLen,\n                        (u_char *) cp, strlen(cp),\n                        session->securityPrivKey,\n                        &session->securityPrivKeyLen) != SNMPERR_SUCCESS) {\n            snmp_set_detail\n                (\"Error generating a key (Ku) from the supplied privacy pass phrase.\");\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * usm_create_user_from_session(netsnmp_session *session):\n * \n * creates a user in the usm table from the information in a session.\n * If the user already exists, it is updated with the current\n * information from the session\n * \n * Parameters:\n * session -- IN: pointer to the session to use when creating the user.\n * \n * Returns:\n * SNMPERR_SUCCESS\n * SNMPERR_GENERR \n */\nint\nusm_create_user_from_session(netsnmp_session * session)\n{\n    struct usmUser *user;\n    int             user_just_created = 0;\n    char *cp;\n\n    /*\n     * - don't create-another/copy-into user for this session by default\n     * - bail now (no error) if we don't have an engineID\n     */\n    if (SNMP_FLAGS_USER_CREATED == (session->flags & SNMP_FLAGS_USER_CREATED) ||\n        session->securityModel != SNMP_SEC_MODEL_USM ||\n        session->version != SNMP_VERSION_3 ||\n        session->securityNameLen == 0 ||\n        session->securityEngineIDLen == 0)\n        return SNMPERR_SUCCESS;\n\n    DEBUGMSGTL((\"usm\", \"no flag defined...  continuing\\n\"));\n    session->flags |= SNMP_FLAGS_USER_CREATED;\n\n    /*\n     * now that we have the engineID, create an entry in the USM list\n     * for this user using the information in the session \n     */\n    user = usm_get_user_from_list(session->securityEngineID,\n                                  session->securityEngineIDLen,\n                                  session->securityName,\n                                  usm_get_userList(), 0);\n    if (NULL != user) \n        DEBUGMSGTL((\"usm\", \"user exists x=%p\\n\", user));\n    else\n    if (user == NULL) {\n        DEBUGMSGTL((\"usm\", \"Building user %s...\\n\",\n                    session->securityName));\n        /*\n         * user doesn't exist so we create and add it \n         */\n        user = (struct usmUser *) calloc(1, sizeof(struct usmUser));\n        if (user == NULL)\n            return SNMPERR_GENERR;\n\n        /*\n         * copy in the securityName \n         */\n        if (session->securityName) {\n            user->name = strdup(session->securityName);\n            user->secName = strdup(session->securityName);\n            if (user->name == NULL || user->secName == NULL) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        }\n\n        /*\n         * copy in the engineID \n         */\n        user->engineID = netsnmp_memdup(session->securityEngineID,\n                                        session->securityEngineIDLen);\n        if (session->securityEngineID && !user->engineID) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n        user->engineIDLen = session->securityEngineIDLen;\n\n        user_just_created = 1;\n    }\n\n    /*\n     * copy the auth protocol \n     */\n    if (user->authProtocol == NULL && session->securityAuthProto != NULL) {\n        SNMP_FREE(user->authProtocol);\n        user->authProtocol =\n            snmp_duplicate_objid(session->securityAuthProto,\n                                 session->securityAuthProtoLen);\n        if (user->authProtocol == NULL) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n        user->authProtocolLen = session->securityAuthProtoLen;\n    }\n\n    /*\n     * copy the priv protocol \n     */\n    if (user->privProtocol == NULL && session->securityPrivProto != NULL) {\n        SNMP_FREE(user->privProtocol);\n        user->privProtocol =\n            snmp_duplicate_objid(session->securityPrivProto,\n                                 session->securityPrivProtoLen);\n        if (user->privProtocol == NULL) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n        user->privProtocolLen = session->securityPrivProtoLen;\n    }\n\n    /*\n     * copy in the authentication Key.  If not localized, localize it \n     */\n    if (user->authKey == NULL) {\n        if (session->securityAuthLocalKey != NULL\n            && session->securityAuthLocalKeyLen != 0) {\n            /* already localized key passed in.  use it */\n            SNMP_FREE(user->authKey);\n            user->authKey = netsnmp_memdup(session->securityAuthLocalKey,\n                                           session->securityAuthLocalKeyLen);\n            if (!user->authKey) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n            user->authKeyLen = session->securityAuthLocalKeyLen;\n        } else if (session->securityAuthKeyLen != 0) {\n            SNMP_FREE(user->authKey);\n            user->authKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);\n            user->authKeyLen = USM_LENGTH_KU_HASHBLOCK;\n            if ((user->authKey == NULL) ||\n                generate_kul(user->authProtocol, user->authProtocolLen,\n                             user->engineID, user->engineIDLen,\n                             session->securityAuthKey,\n                             session->securityAuthKeyLen, user->authKey,\n                             &user->authKeyLen) != SNMPERR_SUCCESS) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        } else if ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                               NETSNMP_DS_LIB_AUTHLOCALIZEDKEY))) {\n            size_t buflen = USM_AUTH_KU_LEN;\n            SNMP_FREE(user->authKey);\n            user->authKey = (u_char *)malloc(buflen); /* max length needed */\n            user->authKeyLen = 0;\n            /* it will be a hex string */\n            if ((NULL == user->authKey) ||\n                !snmp_hex_to_binary(&user->authKey, &buflen, &user->authKeyLen,\n                                    0, cp)) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        }\n    }\n\n    /*\n     * copy in the privacy Key.  If not localized, localize it \n     */\n    if (user->privKey == NULL) {\n        /** save buffer size in case we need to extend key */\n        int keyBufSize = USM_PRIV_KU_LEN;\n\n        DEBUGMSGTL((\"usm\", \"copying privKey\\n\"));\n        if (session->securityPrivLocalKey != NULL\n            && session->securityPrivLocalKeyLen != 0) {\n            /* already localized key passed in.  use it */\n            SNMP_FREE(user->privKey);\n            user->privKey = netsnmp_memdup(session->securityPrivLocalKey,\n                                           session->securityPrivLocalKeyLen);\n            if (!user->privKey) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n            keyBufSize = user->privKeyLen = session->securityPrivLocalKeyLen;\n        } else if (session->securityPrivKeyLen != 0) {\n            SNMP_FREE(user->privKey);\n            user->privKey = (u_char *) calloc(1, keyBufSize);\n            user->privKeyLen = keyBufSize;\n            if ((user->privKey == NULL) ||\n                generate_kul(user->authProtocol, user->authProtocolLen,\n                             user->engineID, user->engineIDLen,\n                             session->securityPrivKey,\n                             session->securityPrivKeyLen, user->privKey,\n                             &user->privKeyLen) != SNMPERR_SUCCESS) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        } else if ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                               NETSNMP_DS_LIB_PRIVLOCALIZEDKEY))) {\n            size_t buflen = keyBufSize;\n            user->privKey = (u_char *)malloc(buflen); /* max length needed */\n            user->privKeyLen = 0;\n            /* it will be a hex string */\n            if ((NULL == user->privKey) ||\n                !snmp_hex_to_binary(&user->privKey, &buflen, &user->privKeyLen,\n                                    0, cp)) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        }\n        if (usm_extend_user_kul(user, keyBufSize) != SNMPERR_SUCCESS) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n    }\n\n    if (user_just_created) {\n        /*\n         * add the user into the database \n         */\n        user->userStatus = RS_ACTIVE;\n        user->userStorageType = ST_READONLY;\n        usm_add_user(user);\n    }\n    DEBUGMSGTL((\"9:usm\", \"user created\\n\"));\n\n    return SNMPERR_SUCCESS;\n\n\n}\n\n/* A wrapper around the hook */\nstatic int\nusm_create_user_from_session_hook(struct session_list *slp,\n                                  netsnmp_session *session)\n{\n    DEBUGMSGTL((\"usm\", \"potentially bootstrapping the USM table from session data\\n\"));\n    return usm_create_user_from_session(session);\n}\n\nstatic int\nusm_build_probe_pdu(netsnmp_pdu **pdu)\n{\n    struct usmUser *user;\n\n    /*\n     * create the pdu \n     */\n    if (!pdu)\n        return -1;\n    *pdu = snmp_pdu_create(SNMP_MSG_GET);\n    if (!(*pdu))\n        return -1;\n    (*pdu)->version = SNMP_VERSION_3;\n    (*pdu)->securityName = strdup(\"\");\n    (*pdu)->securityNameLen = strlen((*pdu)->securityName);\n    (*pdu)->securityLevel = SNMP_SEC_LEVEL_NOAUTH;\n    (*pdu)->securityModel = SNMP_SEC_MODEL_USM;\n\n    /*\n     * create the empty user \n     */\n    user = usm_get_user(NULL, 0, (*pdu)->securityName);\n    if (user == NULL) {\n        user = (struct usmUser *) calloc(1, sizeof(struct usmUser));\n        if (user == NULL) {\n            snmp_free_pdu(*pdu);\n            *pdu = (netsnmp_pdu *) NULL;\n            return -1;\n        }\n        user->name = strdup((*pdu)->securityName);\n        user->secName = strdup((*pdu)->securityName);\n        user->authProtocolLen = sizeof(usmNoAuthProtocol) / sizeof(oid);\n        user->authProtocol =\n            snmp_duplicate_objid(usmNoAuthProtocol, user->authProtocolLen);\n        user->privProtocolLen = sizeof(usmNoPrivProtocol) / sizeof(oid);\n        user->privProtocol =\n            snmp_duplicate_objid(usmNoPrivProtocol, user->privProtocolLen);\n        usm_add_user(user);\n    }\n    return 0;\n}\n\nstatic int usm_discover_engineid(struct session_list *slp,\n                                 netsnmp_session *session)\n{\n    netsnmp_pdu    *pdu = NULL, *response = NULL;\n    int status, i;\n\n    if (usm_build_probe_pdu(&pdu) != 0) {\n        DEBUGMSGTL((\"snmp_api\", \"unable to create probe PDU\\n\"));\n        return SNMP_ERR_GENERR;\n    }\n    DEBUGMSGTL((\"snmp_api\", \"probing for engineID...\\n\"));\n    session->flags |= SNMP_FLAGS_DONT_PROBE; /* prevent recursion */\n    status = snmp_sess_synch_response(slp, pdu, &response);\n\n    if ((response == NULL) && (status == STAT_SUCCESS)) {\n        status = STAT_ERROR;\n    }\n\n    switch (status) {\n    case STAT_SUCCESS:\n        session->s_snmp_errno = SNMPERR_INVALID_MSG; /* XX?? */\n        DEBUGMSGTL((\"snmp_sess_open\",\n                    \"error: expected Report as response to probe: %s (%ld)\\n\",\n                    snmp_errstring(response->errstat),\n                    response->errstat));\n        break;\n    case STAT_ERROR:   /* this is what we expected -> Report == STAT_ERROR */\n        session->s_snmp_errno = SNMPERR_UNKNOWN_ENG_ID;\n        break;\n    case STAT_TIMEOUT:\n        session->s_snmp_errno = SNMPERR_TIMEOUT;\n        break;\n    default:\n        DEBUGMSGTL((\"snmp_sess_open\",\n                    \"unable to connect with remote engine: %s (%d)\\n\",\n                    snmp_api_errstring(session->s_snmp_errno),\n                    session->s_snmp_errno));\n        break;\n    }\n\n    if (slp->session->securityEngineIDLen == 0) {\n        DEBUGMSGTL((\"snmp_api\",\n                    \"unable to determine remote engine ID\\n\"));\n        /* clear the flag so that probe occurs on next inform */\n        session->flags &= ~SNMP_FLAGS_DONT_PROBE;\n        return SNMP_ERR_GENERR;\n    }\n\n    session->s_snmp_errno = SNMPERR_SUCCESS;\n    if (snmp_get_do_debugging()) {\n        DEBUGMSGTL((\"snmp_sess_open\",\n                    \"  probe found engineID:  \"));\n        for (i = 0; i < slp->session->securityEngineIDLen; i++)\n            DEBUGMSG((\"snmp_sess_open\", \"%02x\",\n                      slp->session->securityEngineID[i]));\n        DEBUGMSG((\"snmp_sess_open\", \"\\n\"));\n    }\n\n    /*\n     * if boot/time supplied set it for this engineID \n     */\n    if (session->engineBoots || session->engineTime) {\n        set_enginetime(session->securityEngineID,\n                       session->securityEngineIDLen,\n                       session->engineBoots, session->engineTime,\n                       TRUE);\n    }\n    return SNMPERR_SUCCESS;\n}\n\nstatic int\nusm_lookup_alg_type(const char *str, usm_alg_type_t *types)\n{\n    int i, l;\n    l = strlen(str);\n    for (i = 0; types[i].label; ++i) {\n        if (0 == strncasecmp(types[i].label, str, l))\n            return types[i].value;\n    }\n\n    return -1;\n}\n\nstatic const char *\nusm_lookup_alg_str(int value, usm_alg_type_t *types)\n{\n    int i;\n    for (i = 0; types[i].label; ++i)\n        if (value == types[i].value)\n            return types[i].label;\n\n    return NULL;\n}\n\nint\nusm_lookup_auth_type(const char *str)\n{\n    return usm_lookup_alg_type(str, usm_auth_type );\n}\n\nint\nusm_lookup_priv_type(const char *str)\n{\n    return usm_lookup_alg_type(str, usm_priv_type );\n}\n\nconst char *\nusm_lookup_auth_str(int value)\n{\n    return usm_lookup_alg_str(value, usm_auth_type );\n}\n\nconst char *\nusm_lookup_priv_str(int value)\n{\n    return usm_lookup_alg_str(value, usm_priv_type );\n}\n\nstatic void\nclear_user_list(void)\n{\n    struct usmUser *tmp = userList, *next = NULL;\n\n    while (tmp != NULL) {\n\tnext = tmp->next;\n\tusm_free_user(tmp);\n\ttmp = next;\n    }\n    userList = NULL;\n\n}\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n/*\n * take a given user and clone the security info into another \n */\nstruct usmUser *\nusm_cloneFrom_user(struct usmUser *from, struct usmUser *to)\n{\n    to->flags = from->flags;\n\n    /*\n     * copy the authProtocol oid row pointer \n     */\n    SNMP_FREE(to->authProtocol);\n\n    if ((to->authProtocol =\n         snmp_duplicate_objid(from->authProtocol,\n                              from->authProtocolLen)) != NULL)\n        to->authProtocolLen = from->authProtocolLen;\n    else\n        to->authProtocolLen = 0;\n\n\n    /*\n     * copy the authKey \n     */\n    SNMP_FREE(to->authKey);\n\n    if (from->authKeyLen > 0 &&\n        (to->authKey = (u_char *) malloc(from->authKeyLen))\n        != NULL) {\n        to->authKeyLen = from->authKeyLen;\n        memcpy(to->authKey, from->authKey, to->authKeyLen);\n    } else {\n        to->authKey = NULL;\n        to->authKeyLen = 0;\n    }\n\n    /*\n     * copy the authKeyKu\n     */\n    SNMP_FREE(to->authKeyKu);\n\n    if (from->authKeyKuLen > 0 &&\n        (to->authKeyKu = (u_char *) malloc(from->authKeyKuLen)) != NULL) {\n        to->authKeyKuLen = from->authKeyKuLen;\n        memcpy(to->authKeyKu, from->authKeyKu, to->authKeyKuLen);\n    } else {\n        to->authKeyKu = NULL;\n        to->authKeyKuLen = 0;\n    }\n\n\n    /*\n     * copy the privProtocol oid row pointer \n     */\n    SNMP_FREE(to->privProtocol);\n\n    if ((to->privProtocol =\n         snmp_duplicate_objid(from->privProtocol,\n                              from->privProtocolLen)) != NULL)\n        to->privProtocolLen = from->privProtocolLen;\n    else\n        to->privProtocolLen = 0;\n\n    /*\n     * copy the privKey \n     */\n    SNMP_FREE(to->privKey);\n\n    if (from->privKeyLen > 0 &&\n        (to->privKey = (u_char *) malloc(from->privKeyLen))\n        != NULL) {\n        to->privKeyLen = from->privKeyLen;\n        memcpy(to->privKey, from->privKey, to->privKeyLen);\n    } else {\n        to->privKey = NULL;\n        to->privKeyLen = 0;\n    }\n\n    /*\n     * copy the privKeyKu\n     */\n    SNMP_FREE(to->privKeyKu);\n    if (from->privKeyKuLen > 0 &&\n        (to->privKeyKu = (u_char *) malloc(from->privKeyKuLen)) != NULL) {\n        to->privKeyKuLen = from->privKeyKuLen;\n        memcpy(to->privKeyKu, from->privKeyKu, to->privKeyKuLen);\n    } else {\n        to->privKeyKu = NULL;\n        to->privKeyKuLen = 0;\n    }\n    return to;\n}\n#endif /* NETSNMP_NO_WRITE_SUPPORT */\n\n/*\n * usm_create_user(void):\n * create a default empty user, instantiating only the auth/priv\n * protocols to noAuth and noPriv OID pointers\n */\nstruct usmUser *\nusm_create_user(void)\n{\n    struct usmUser *newUser;\n\n    /*\n     * create the new user \n     */\n    newUser = (struct usmUser *) calloc(1, sizeof(struct usmUser));\n    if (newUser == NULL)\n        return NULL;\n\n    /*\n     * fill the auth/priv protocols \n     */\n    if ((newUser->authProtocol =\n         snmp_duplicate_objid(usmNoAuthProtocol,\n                              sizeof(usmNoAuthProtocol) / sizeof(oid))) ==\n        NULL)\n        return usm_free_user(newUser);\n    newUser->authProtocolLen = sizeof(usmNoAuthProtocol) / sizeof(oid);\n\n    if ((newUser->privProtocol =\n         snmp_duplicate_objid(usmNoPrivProtocol,\n                              sizeof(usmNoPrivProtocol) / sizeof(oid))) ==\n        NULL)\n        return usm_free_user(newUser);\n    newUser->privProtocolLen = sizeof(usmNoPrivProtocol) / sizeof(oid);\n\n    /*\n     * set the storage type to nonvolatile, and the status to ACTIVE \n     */\n    newUser->userStorageType = ST_NONVOLATILE;\n    newUser->userStatus = RS_ACTIVE;\n    return newUser;\n\n}                               /* end usm_clone_user() */\n\n/*\n * usm_create_initial_user(void):\n * creates an initial user, filled with the defaults defined in the\n * USM document.\n */\nstatic struct usmUser *\nusm_create_initial_user(const char *name,\n                        const oid * authProtocol, size_t authProtocolLen,\n                        const oid * privProtocol, size_t privProtocolLen)\n{\n    struct usmUser *newUser = usm_create_user();\n    if (newUser == NULL)\n        return NULL;\n\n    if ((newUser->name = strdup(name)) == NULL)\n        return usm_free_user(newUser);\n\n    if ((newUser->secName = strdup(name)) == NULL)\n        return usm_free_user(newUser);\n\n    if ((newUser->engineID =\n         snmpv3_generate_engineID(&newUser->engineIDLen)) == NULL)\n        return usm_free_user(newUser);\n\n    if ((newUser->cloneFrom = (oid *) malloc(sizeof(oid) * 2)) == NULL)\n        return usm_free_user(newUser);\n    newUser->cloneFrom[0] = 0;\n    newUser->cloneFrom[1] = 0;\n    newUser->cloneFromLen = 2;\n\n    SNMP_FREE(newUser->privProtocol);\n    if ((newUser->privProtocol = snmp_duplicate_objid(privProtocol,\n                                                      privProtocolLen)) ==\n        NULL) {\n        return usm_free_user(newUser);\n    }\n    newUser->privProtocolLen = privProtocolLen;\n\n    SNMP_FREE(newUser->authProtocol);\n    if ((newUser->authProtocol = snmp_duplicate_objid(authProtocol,\n                                                      authProtocolLen)) ==\n        NULL) {\n        return usm_free_user(newUser);\n    }\n    newUser->authProtocolLen = authProtocolLen;\n\n    newUser->userStatus = RS_ACTIVE;\n    newUser->userStorageType = ST_READONLY;\n\n    return newUser;\n}\n\n/*\n * usm_save_user(): saves a user to the persistent cache \n */\nstatic void\nusm_save_user(struct usmUser *user, const char *token, const char *type)\n{\n    char            line[4096];\n    char           *cptr;\n\n    memset(line, 0, sizeof(line));\n\n    sprintf(line, \"%s %d %d \", token, user->userStatus,\n            user->userStorageType);\n    cptr = &line[strlen(line)]; /* the NULL */\n    cptr =\n        read_config_save_octet_string(cptr, user->engineID,\n                                      user->engineIDLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_octet_string(cptr, (u_char *) user->name,\n                                         (user->name == NULL) ? 0 :\n                                         strlen(user->name));\n    *cptr++ = ' ';\n    cptr = read_config_save_octet_string(cptr, (u_char *) user->secName,\n                                         (user->secName == NULL) ? 0 :\n                                         strlen(user->secName));\n    *cptr++ = ' ';\n    cptr =\n        read_config_save_objid(cptr, user->cloneFrom, user->cloneFromLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_objid(cptr, user->authProtocol,\n                                  user->authProtocolLen);\n    *cptr++ = ' ';\n    cptr =\n        read_config_save_octet_string(cptr, user->authKey,\n                                      user->authKeyLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_objid(cptr, user->privProtocol,\n                                  user->privProtocolLen);\n    *cptr++ = ' ';\n    cptr =\n        read_config_save_octet_string(cptr, user->privKey,\n                                      user->privKeyLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_octet_string(cptr, user->userPublicString,\n                                         user->userPublicStringLen);\n\n    read_config_store(type, line);\n}\n\nstatic void\nusm_save_users_from_list(struct usmUser *puserList, const char *token,\n                         const char *type)\n{\n    struct usmUser *uptr;\n    for (uptr = puserList; uptr != NULL; uptr = uptr->next) {\n        if (uptr->userStorageType == ST_NONVOLATILE)\n            usm_save_user(uptr, token, type);\n    }\n}\n\n/*\n * usm_save_users(): saves a list of users to the persistent cache \n */\nstatic void\nusm_save_users(const char *token, const char *type)\n{\n    usm_save_users_from_list(userList, token, type);\n}\n\n/*\n * this is a callback that can store all known users based on a\n * previously registered application ID \n */\nstatic int\nusm_store_users(int majorID, int minorID, void *serverarg, void *clientarg)\n{\n    /*\n     * figure out our application name \n     */\n    char           *appname = (char *) clientarg;\n    if (appname == NULL) {\n        appname = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\tNETSNMP_DS_LIB_APPTYPE);\n    }\n\n    /*\n     * save the user base \n     */\n    usm_save_users(\"usmUser\", appname);\n\n    /*\n     * never fails \n     */\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * usm_parse_user(): reads in a line containing a saved user profile\n * and returns a pointer to a newly created struct usmUser. \n */\nstatic struct usmUser *\nusm_read_user(const char *line)\n{\n    struct usmUser *user;\n    size_t          len, proper_length, privtype;\n\n    user = usm_create_user();\n    if (user == NULL)\n        return NULL;\n\n    user->userStatus = atoi(line);\n    line = skip_token_const(line);\n    user->userStorageType = atoi(line);\n    line = skip_token_const(line);\n    line = read_config_read_octet_string_const(line, &user->engineID,\n                                               &user->engineIDLen);\n\n    /*\n     * set the lcd entry for this engineID to the minimum boots/time\n     * values so that its a known engineid and won't return a report pdu.\n     * This is mostly important when receiving v3 traps so that the usm\n     * will at least continue processing them. \n     */\n    set_enginetime(user->engineID, user->engineIDLen, 1, 0, 0);\n\n    line = read_config_read_octet_string(line, (u_char **) & user->name,\n                                         &len);\n    line = read_config_read_octet_string(line, (u_char **) & user->secName,\n                                         &len);\n    SNMP_FREE(user->cloneFrom);\n    user->cloneFromLen = 0;\n\n    line = read_config_read_objid_const(line, &user->cloneFrom,\n                                        &user->cloneFromLen);\n\n    SNMP_FREE(user->authProtocol);\n    user->authProtocolLen = 0;\n\n    line = read_config_read_objid_const(line, &user->authProtocol,\n                                        &user->authProtocolLen);\n    line = read_config_read_octet_string_const(line, &user->authKey,\n                                               &user->authKeyLen);\n    SNMP_FREE(user->privProtocol);\n    user->privProtocolLen = 0;\n\n    line = read_config_read_objid_const(line, &user->privProtocol,\n                                        &user->privProtocolLen);\n    line = read_config_read_octet_string(line, &user->privKey,\n                                         &user->privKeyLen);\n\n    privtype = sc_get_privtype(user->privProtocol, user->privProtocolLen);\n    proper_length = sc_get_proper_priv_length_bytype(privtype);\n    if (USM_CREATE_USER_PRIV_DES == privtype)\n        proper_length *= 2; /* ?? we store salt with key */\n    /* For backwards compatibility */\n    if (user->privKeyLen > proper_length) {\n        user->privKeyLen = proper_length;\n    }\n\n    line = read_config_read_octet_string(line, &user->userPublicString,\n                                         &user->userPublicStringLen);\n    return user;\n}\n\n/*\n * snmpd.conf parsing routines \n */\nstatic void\nusm_parse_config_usmUser(const char *token, char *line)\n{\n    struct usmUser *uptr;\n\n    uptr = usm_read_user(line);\n    if ( uptr)\n        usm_add_user(uptr);\n}\n\n/*******************************************************************-o-******\n * usm_set_password\n *\n * Parameters:\n *\t*token\n *\t*line\n *      \n *\n * format: userSetAuthPass     secname engineIDLen engineID pass\n *     or: userSetPrivPass     secname engineIDLen engineID pass \n *     or: userSetAuthKey      secname engineIDLen engineID KuLen Ku\n *     or: userSetPrivKey      secname engineIDLen engineID KuLen Ku \n *     or: userSetAuthLocalKey secname engineIDLen engineID KulLen Kul\n *     or: userSetPrivLocalKey secname engineIDLen engineID KulLen Kul \n *\n * type is:\t1=passphrase; 2=Ku; 3=Kul.\n *\n *\n * ASSUMES  Passwords are null-terminated printable strings.\n */\nstatic void\nusm_set_password(const char *token, char *line)\n{\n    char           *cp;\n    char            nameBuf[SNMP_MAXBUF];\n    u_char         *engineID = NULL;\n    size_t          engineIDLen = 0;\n    struct usmUser *user;\n\n    cp = copy_nword(line, nameBuf, sizeof(nameBuf));\n    if (cp == NULL) {\n        config_perror(\"invalid name specifier\");\n        return;\n    }\n\n    DEBUGMSGTL((\"usm\", \"comparing: %s and %s\\n\", cp, WILDCARDSTRING));\n    if (strncmp(cp, WILDCARDSTRING, strlen(WILDCARDSTRING)) == 0) {\n        /*\n         * match against all engineIDs we know about \n         */\n        cp = skip_token(cp);\n        for (user = userList; user != NULL; user = user->next) {\n            if (user->secName && strcmp(user->secName, nameBuf) == 0) {\n                usm_set_user_password(user, token, cp);\n            }\n        }\n    } else {\n        cp = read_config_read_octet_string(cp, &engineID, &engineIDLen);\n        if (cp == NULL) {\n            config_perror(\"invalid engineID specifier\");\n            SNMP_FREE(engineID);\n            return;\n        }\n\n        user = usm_get_user(engineID, engineIDLen, nameBuf);\n        if (user == NULL) {\n            config_perror(\"not a valid user/engineID pair\");\n            SNMP_FREE(engineID);\n            return;\n        }\n        usm_set_user_password(user, token, cp);\n        SNMP_FREE(engineID);\n    }\n}\n\n/*\n * uses the rest of LINE to configure USER's password of type TOKEN \n */\nvoid\nusm_set_user_password(struct usmUser *user, const char *token, char *line)\n{\n    char           *cp = line;\n    u_char         *engineID = user->engineID;\n    size_t          engineIDLen = user->engineIDLen;\n\n    u_char        **key;\n    size_t         *keyLen;\n    u_char          userKey[SNMP_MAXBUF_SMALL];\n    size_t          userKeyLen = SNMP_MAXBUF_SMALL;\n    u_char         *userKeyP = userKey;\n    int             type, ret;\n\n    /*\n     * Retrieve the \"old\" key and set the key type.\n     */\n    if (!token) {\n        return;\n    } else if (strcmp(token, \"userSetAuthPass\") == 0) {\n        key = &user->authKey;\n        keyLen = &user->authKeyLen;\n        type = 0;\n    } else if (strcmp(token, \"userSetPrivPass\") == 0) {\n        key = &user->privKey;\n        keyLen = &user->privKeyLen;\n        type = 0;\n    } else if (strcmp(token, \"userSetAuthKey\") == 0) {\n        key = &user->authKey;\n        keyLen = &user->authKeyLen;\n        type = 1;\n    } else if (strcmp(token, \"userSetPrivKey\") == 0) {\n        key = &user->privKey;\n        keyLen = &user->privKeyLen;\n        type = 1;\n    } else if (strcmp(token, \"userSetAuthLocalKey\") == 0) {\n        key = &user->authKey;\n        keyLen = &user->authKeyLen;\n        type = 2;\n    } else if (strcmp(token, \"userSetPrivLocalKey\") == 0) {\n        key = &user->privKey;\n        keyLen = &user->privKeyLen;\n        type = 2;\n    } else {\n        /*\n         * no old key, or token was not recognized \n         */\n        return;\n    }\n\n    if (*key) {\n        /*\n         * (destroy and) free the old key \n         */\n        memset(*key, 0, *keyLen);\n        SNMP_FREE(*key);\n    }\n\n    if (type == 0) {\n        /*\n         * convert the password into a key \n         */\n        if (cp == NULL) {\n            config_perror(\"missing user password\");\n            return;\n        }\n        ret = generate_Ku(user->authProtocol, user->authProtocolLen,\n                          (u_char *) cp, strlen(cp), userKey, &userKeyLen);\n\n        if (ret != SNMPERR_SUCCESS) {\n            config_perror(\"setting key failed (in sc_genKu())\");\n            return;\n        }\n        /* save master key */\n        if (user->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            if (userKey == user->privKey) {\n                user->privKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                user->privKeyKuLen = userKeyLen;\n            } else if (userKey == user->authKey) {\n                user->authKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                user->authKeyKuLen = userKeyLen;\n            }\n        }\n    } else if (type == 1) {\n        cp = read_config_read_octet_string(cp, &userKeyP, &userKeyLen);\n\n        if (cp == NULL) {\n            config_perror(\"invalid user key\");\n            return;\n        }\n    }\n\n    if (type < 2) {\n        *key = (u_char *) malloc(SNMP_MAXBUF_SMALL);\n        *keyLen = SNMP_MAXBUF_SMALL;\n        ret = generate_kul(user->authProtocol, user->authProtocolLen,\n                           engineID, engineIDLen,\n                           userKey, userKeyLen, *key, keyLen);\n        if (ret != SNMPERR_SUCCESS) {\n            config_perror(\"setting key failed (in generate_kul())\");\n            return;\n        }\n\n        /*\n         * (destroy and) free the old key \n         */\n        memset(userKey, 0, sizeof(userKey));\n\n    } else {\n        /*\n         * the key is given, copy it in \n         */\n        cp = read_config_read_octet_string(cp, key, keyLen);\n\n        if (cp == NULL) {\n            config_perror(\"invalid localized user key\");\n            return;\n        }\n    }\n\n    if (key == &user->privKey) {\n        ret = usm_extend_user_kul(user, *keyLen);\n        if (SNMPERR_SUCCESS != ret) {\n            config_perror(\"error extending localized user key\");\n            return;\n        }\n    }\n}                               /* end usm_set_password() */\n\n/*\n * create a usm user from a string.\n *\n * The format for the string is described in the createUser\n * secion of the snmpd.conf man page.\n *\n * On success, a pointer to the created usmUser struct is returned.\n * On error, a NULL pointer is returned. In this case, if a pointer to a\n *    char pointer is provided in errorMsg, an error string is returned.\n *    This error string points to a static message, and should not be\n *    freed.\n */\nstatic struct usmUser *\nusm_create_usmUser_from_string(char *line, const char **errorMsg)\n{\n    char           *cp;\n    const char     *dummy;\n    char            buf[SNMP_MAXBUF_MEDIUM];\n    struct usmUser *newuser;\n    u_char          userKey[SNMP_MAXBUF_SMALL], *tmpp;\n    size_t          userKeyLen = SNMP_MAXBUF_SMALL;\n    size_t          privKeySize;\n    size_t          ret;\n    int             ret2, properLen, properPrivKeyLen;\n    const oid      *def_auth_prot, *def_priv_prot;\n    size_t          def_auth_prot_len, def_priv_prot_len;\n    netsnmp_priv_alg_info *pai;\n\n    def_auth_prot = get_default_authtype(&def_auth_prot_len);\n    def_priv_prot = get_default_privtype(&def_priv_prot_len);\n\n    if (NULL == line)\n        return NULL;\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n    DEBUGMSGTL((\"usmUser\", \"new user %s\\n\", line)); /* logs passphrases */\n#endif\n\n    if (NULL == errorMsg)\n        errorMsg = &dummy;\n    *errorMsg = NULL; /* no errors yet */\n\n    newuser = usm_create_user();\n    if (newuser == NULL) {\n        *errorMsg = \"malloc failure creating new user\";\n        goto fail;\n    }\n\n    /*\n     * READ: Security Name \n     */\n    cp = copy_nword(line, buf, sizeof(buf));\n\n    /*\n     * check for (undocumented) 'keep master key' flag. so far, this is\n     * just used for users for informs (who need non-localized keys).\n     */\n    if (strcmp(buf, \"-M\") == 0) {\n        newuser->flags |= USMUSER_FLAG_KEEP_MASTER_KEY;\n        cp = copy_nword(cp, buf, sizeof(buf));\n    }\n\n    /*\n     * might be a -e ENGINEID argument \n     */\n    if (strcmp(buf, \"-e\") == 0) {\n        size_t          ebuf_len = 32, eout_len = 0;\n        u_char         *ebuf = (u_char *) malloc(ebuf_len);\n\n        if (ebuf == NULL) {\n            *errorMsg = \"malloc failure processing -e flag\";\n            goto fail;\n        }\n\n        /*\n         * Get the specified engineid from the line.  \n         */\n        cp = copy_nword(cp, buf, sizeof(buf));\n        if (!snmp_hex_to_binary(&ebuf, &ebuf_len, &eout_len, 1, buf)) {\n            *errorMsg = \"invalid EngineID argument to -e\";\n            SNMP_FREE(ebuf);\n            goto fail;\n        }\n\n        newuser->engineID = ebuf;\n        newuser->engineIDLen = eout_len;\n        cp = copy_nword(cp, buf, sizeof(buf));\n    } else {\n        newuser->engineID = snmpv3_generate_engineID(&ret);\n        if (ret == 0) {\n            goto fail;\n        }\n        newuser->engineIDLen = ret;\n    }\n\n    newuser->secName = strdup(buf);\n    newuser->name = strdup(buf);\n\n    if (!cp) {\n#ifdef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n        /** no passwords ok iff defaults are noauth/nopriv */\n        if (snmp_oid_compare(usmNoAuthProtocol, OID_LENGTH(usmNoAuthProtocol),\n                             def_auth_prot, def_auth_prot_len) != 0) {\n            *errorMsg = \"no authentication pass phrase\";\n            goto fail;\n        }\n        if (snmp_oid_compare(usmNoPrivProtocol, OID_LENGTH(usmNoPrivProtocol),\n                             def_priv_prot, def_priv_prot_len) != 0) {\n            *errorMsg = \"no privacy pass phrase\";\n            goto fail;\n        }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n        goto add;               /* no authentication or privacy type */\n    }\n\n    /*\n     * READ: Authentication Type \n     */\n    newuser->authProtocol[0] = 0;\n    cp = copy_nword(cp, buf, sizeof(buf));\n    if ((strncmp(cp, \"default\", 7) == 0) && (NULL != def_auth_prot)) {\n        SNMP_FREE(newuser->authProtocol);\n        newuser->authProtocol = snmp_duplicate_objid(def_auth_prot,\n                                                     def_auth_prot_len);\n        if (newuser->authProtocol == NULL) {\n            *errorMsg = \"malloc failed\";\n            goto fail;\n        }\n        newuser->authProtocolLen = def_auth_prot_len;\n    } else {\n        const oid *auth_prot;\n        int auth_type = usm_lookup_auth_type(buf);\n        if (auth_type < 0) {\n            *errorMsg = \"unknown authProtocol\";\n            goto fail;\n        }\n        auth_prot = sc_get_auth_oid(auth_type, &newuser->authProtocolLen);\n        if (auth_prot) {\n            SNMP_FREE(newuser->authProtocol);\n            newuser->authProtocol =\n                snmp_duplicate_objid(auth_prot, newuser->authProtocolLen);\n        }\n        if (newuser->authProtocol == NULL) {\n            *errorMsg = \"malloc failed\";\n            goto fail;\n        }\n    }\n    if (0 == newuser->authProtocol[0]) {\n        *errorMsg = \"Unknown authentication protocol\";\n        goto fail;\n    }\n#ifdef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n    if (snmp_oid_compare(newuser->authProtocol, newuser->authProtocolLen,\n                         def_auth_prot, def_auth_prot_len) != 0) {\n        *errorMsg = \"auth protocol does not match system policy\";\n        goto fail;\n    }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n\n    /*\n     * READ: Authentication Pass Phrase or key\n     */\n    cp = copy_nword(cp, buf, sizeof(buf));\n    if (strcmp(buf,\"-m\") == 0) {\n        /* a master key is specified */\n        cp = copy_nword(cp, buf, sizeof(buf));\n        ret = sizeof(userKey);\n        tmpp = userKey;\n        userKeyLen = 0;\n        if (!snmp_hex_to_binary(&tmpp, &ret, &userKeyLen, 0, buf)) {\n            *errorMsg = \"invalid key value argument to -m\";\n            goto fail;\n        }\n        /* save master key */\n        if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            newuser->authKeyKu = netsnmp_memdup(userKey, userKeyLen);\n            newuser->authKeyKuLen = userKeyLen;\n        }\n    } else if (strcmp(buf,\"-l\") != 0) {\n        /* a password is specified */\n        userKeyLen = sizeof(userKey);\n        ret2 = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,\n                          (u_char *) buf, strlen(buf), userKey, &userKeyLen);\n        if (ret2 != SNMPERR_SUCCESS) {\n            *errorMsg = \"could not generate the authentication key from the supplied pass phrase.\";\n            goto fail;\n        }\n        /* save master key */\n        if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            newuser->authKeyKu = netsnmp_memdup(userKey, userKeyLen);\n            newuser->authKeyKuLen = userKeyLen;\n        }\n    }        \n        \n    /*\n     * And turn it into a localized key \n     */\n    properLen = sc_get_proper_auth_length_bytype(\n        sc_get_authtype(newuser->authProtocol, newuser->authProtocolLen));\n    if (properLen <= 0) {\n        *errorMsg = \"Could not get proper authentication protocol key length\";\n        goto fail;\n    }\n    newuser->authKey = (u_char *) malloc(properLen);\n    newuser->authKeyLen = properLen;\n\n    if (strcmp(buf,\"-l\") == 0) {\n        /* a local key is directly specified */\n        cp = copy_nword(cp, buf, sizeof(buf));\n        ret = newuser->authKeyLen;\n        newuser->authKeyLen = 0;\n        if (!snmp_hex_to_binary(&newuser->authKey, &ret,\n                                &newuser->authKeyLen, 0, buf)) {\n            *errorMsg = \"invalid key value argument to -l\";\n            goto fail;\n        }\n        if (properLen != newuser->authKeyLen) {\n            *errorMsg = \"improper key length to -l\";\n            goto fail;\n        }\n    } else {\n        ret2 = generate_kul(newuser->authProtocol, newuser->authProtocolLen,\n                           newuser->engineID, newuser->engineIDLen,\n                           userKey, userKeyLen,\n                           newuser->authKey, &newuser->authKeyLen);\n        if (ret2 != SNMPERR_SUCCESS) {\n            *errorMsg = \"could not generate localized authentication key (Kul) from the master key (Ku).\";\n            goto fail;\n        }\n    }\n\n    if (!cp) {\n#ifndef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n        goto add;               /* no privacy type (which is legal) */\n#else\n        if (snmp_oid_compare(usmNoPrivProtocol, OID_LENGTH(usmNoPrivProtocol),\n                             def_priv_prot, def_priv_prot_len) == 0)\n            goto add;\n        else {\n            *errorMsg = \"priv protocol does not match system policy\";\n            goto fail;\n        }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n    }\n\n    /*\n     * READ: Privacy Type \n     */\n    newuser->privProtocol[0] = 0;\n    cp = copy_nword(cp, buf, sizeof(buf));\n    if ((strncmp(buf, \"default\", 7) == 0) && (NULL != def_priv_prot)) {\n        SNMP_FREE(newuser->privProtocol);\n        newuser->privProtocol =\n            snmp_duplicate_objid(def_priv_prot, def_priv_prot_len);\n        if (newuser->privProtocol == NULL) {\n            *errorMsg = \"malloc failed\";\n            goto fail;\n        }\n        newuser->privProtocolLen = def_priv_prot_len;\n        pai = sc_get_priv_alg_byoid(newuser->privProtocol,\n                                    newuser->privProtocolLen);\n    } else {\n        int priv_type = usm_lookup_priv_type(buf);\n        if (priv_type < 0) {\n            *errorMsg = \"unknown privProtocol\";\n            DEBUGMSGTL((\"usmUser\", \"%s %s\\n\", *errorMsg, buf));\n            goto fail;\n        }\n        DEBUGMSGTL((\"9:usmUser\", \"privProtocol %s\\n\", buf));\n        pai = sc_get_priv_alg_bytype(priv_type);\n        if (pai) {\n            SNMP_FREE(newuser->privProtocol);\n            newuser->privProtocolLen = pai->oid_len;\n            newuser->privProtocol =\n                snmp_duplicate_objid(pai->alg_oid, newuser->privProtocolLen);\n            DEBUGMSGTL((\"9:usmUser\", \"pai %s\\n\", pai->name));\n            if (newuser->privProtocol == NULL) {\n                *errorMsg = \"malloc failed\";\n                goto fail;\n            }\n        }\n    }\n    if (NULL == pai) {\n        *errorMsg = \"priv protocol lookup failed\";\n        goto fail;\n    }\n\n    if (0 == newuser->privProtocol[0] && NULL == *errorMsg)\n        *errorMsg = \"Unknown privacy protocol\";\n    if (NULL != *errorMsg)\n        goto fail;\n#ifdef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n    if (snmp_oid_compare(newuser->privProtocol, newuser->privProtocolLen,\n                         def_priv_prot, def_priv_prot_len) != 0) {\n        *errorMsg = \"priv protocol does not match system policy\";\n        goto fail;\n    }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n\n    properPrivKeyLen = pai->proper_length;\n    if (USM_CREATE_USER_PRIV_DES == pai->type)\n        properPrivKeyLen *= 2; /* ?? we store salt with key */\n\n    /*\n     * READ: Encryption Pass Phrase or key\n     */\n    if (!cp) {\n        /*\n         * assume the same as the authentication key \n         */\n        newuser->privKey = netsnmp_memdup(newuser->authKey,\n                                          newuser->authKeyLen);\n        privKeySize = newuser->privKeyLen = newuser->authKeyLen;\n        if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            newuser->privKeyKu = netsnmp_memdup(newuser->authKeyKu,\n                                                newuser->authKeyKuLen);\n            newuser->privKeyKuLen = newuser->authKeyKuLen;\n        }\n    } else {\n        cp = copy_nword(cp, buf, sizeof(buf));\n        \n        if (strcmp(buf,\"-m\") == 0) {\n            /* a master key is specified */\n            cp = copy_nword(cp, buf, sizeof(buf));\n            ret = sizeof(userKey);\n            tmpp = userKey;\n            userKeyLen = 0;\n            if (!snmp_hex_to_binary(&tmpp, &ret, &userKeyLen, 0, buf)) {\n                *errorMsg = \"invalid key value argument to -m\";\n                goto fail;\n            }\n            /* save master key */\n            if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n                newuser->privKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                newuser->privKeyKuLen = userKeyLen;\n            }\n        } else if (strcmp(buf,\"-l\") != 0) {\n            /* a password is specified */\n            userKeyLen = sizeof(userKey);\n            ret2 = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,\n                              (u_char*)buf, strlen(buf), userKey, &userKeyLen);\n            if (ret2 != SNMPERR_SUCCESS) {\n                *errorMsg = \"could not generate the privacy key from the supplied pass phrase.\";\n                goto fail;\n            }\n            /* save master key */\n            if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n                newuser->privKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                newuser->privKeyKuLen = userKeyLen;\n            }\n        }\n\n        /*\n         * And turn it into a localized key\n         * Allocate enough space for greater of auth mac and privKey len.\n         */\n        privKeySize = SNMP_MAX(properPrivKeyLen, properLen);\n        newuser->privKey = (u_char *) malloc(privKeySize);\n        newuser->privKeyLen = privKeySize;\n\n        if (strcmp(buf,\"-l\") == 0) {\n            /* a local key is directly specified */\n            cp = copy_nword(cp, buf, sizeof(buf));\n            ret = newuser->privKeyLen;\n            newuser->privKeyLen = 0;\n            if (!snmp_hex_to_binary(&newuser->privKey, &ret,\n                                    &newuser->privKeyLen, 0, buf)) {\n                *errorMsg = \"invalid key value argument to -l\";\n                goto fail;\n            }\n        } else {\n            ret2 = generate_kul(newuser->authProtocol, newuser->authProtocolLen,\n                               newuser->engineID, newuser->engineIDLen,\n                               userKey, userKeyLen,\n                               newuser->privKey, &newuser->privKeyLen);\n            if (ret2 != SNMPERR_SUCCESS) {\n                *errorMsg = \"could not generate localized privacy key (Kul) from the master key (Ku).\";\n                goto fail;\n            }\n        }\n\n        if (newuser->privKeyLen < properPrivKeyLen) {\n            ret = usm_extend_user_kul(newuser, properPrivKeyLen);\n            if (ret != SNMPERR_SUCCESS) {\n                *errorMsg = \"could not extend localized privacy key to required length.\";\n                goto fail;\n            }\n        }\n    }\n\n    if ((newuser->privKeyLen >= properPrivKeyLen) || (properPrivKeyLen == 0)){\n        DEBUGMSGTL((\"9:usmUser\", \"truncating privKeyLen from %\" NETSNMP_PRIz \"d to %d\\n\",\n                    newuser->privKeyLen, properPrivKeyLen));\n        newuser->privKeyLen = properPrivKeyLen;\n    }\n    else {\n        DEBUGMSGTL((\"usmUser\",\n                    \"privKey length %\" NETSNMP_PRIz \"d < %d required by privProtocol\\n\",\n                    newuser->privKeyLen, properPrivKeyLen));\n      *errorMsg = \"privKey length is less than required by privProtocol\";\n      goto fail;\n    }\n\n  add:\n    usm_add_user(newuser);\n    DEBUGMSGTL((\"usmUser\", \"created a new user %s at \", newuser->secName));\n    DEBUGMSGHEX((\"usmUser\", newuser->engineID, newuser->engineIDLen));\n    DEBUGMSG((\"usmUser\", \"\\n\"));\n\n    return newuser;\n\n  fail:\n    usm_free_user(newuser);\n    return NULL;\n}\n\nstatic void\nusm_parse_create_usmUser(const char *token, char *line)\n{\n    const char *error = NULL;\n    usm_create_usmUser_from_string(line, &error);\n    if (error)\n        config_perror(error);\n}\n\nstatic void\nsnmpv3_authtype_conf(const char *word, char *cptr)\n{\n    int auth_type = usm_lookup_auth_type(cptr);\n    if (auth_type < 0)\n        config_perror(\"Unknown authentication type\");\n    defaultAuthType = sc_get_auth_oid(auth_type, &defaultAuthTypeLen);\n    DEBUGMSGTL((\"snmpv3\", \"set default authentication type: %s\\n\", cptr));\n}\n\nconst oid      *\nget_default_authtype(size_t * len)\n{\n    if (defaultAuthType == NULL) {\n        defaultAuthType = SNMP_DEFAULT_AUTH_PROTO;\n        defaultAuthTypeLen = SNMP_DEFAULT_AUTH_PROTOLEN;\n    }\n    if (len)\n        *len = defaultAuthTypeLen;\n    return defaultAuthType;\n}\n\nstatic void\nsnmpv3_privtype_conf(const char *word, char *cptr)\n{\n    int priv_type = usm_lookup_priv_type(cptr);\n    if (priv_type < 0)\n        config_perror(\"Unknown privacy type\");\n    defaultPrivType = sc_get_priv_oid(priv_type, &defaultPrivTypeLen);\n    DEBUGMSGTL((\"snmpv3\", \"set default privacy type: %s\\n\", cptr));\n}\n\nconst oid      *\nget_default_privtype(size_t * len)\n{\n    if (defaultPrivType == NULL) {\n        defaultPrivType = SNMP_DEFAULT_PRIV_PROTO;\n        defaultPrivTypeLen = SNMP_DEFAULT_PRIV_PROTOLEN;\n    }\n    if (len)\n        *len = defaultPrivTypeLen;\n    return defaultPrivType;\n}\n\nvoid\ninit_usm_conf(const char *app)\n{\n    register_config_handler(app, \"usmUser\",\n                                  usm_parse_config_usmUser, NULL, NULL);\n    register_config_handler(app, \"createUser\",\n                                  usm_parse_create_usmUser, NULL,\n                                  \"username [-e ENGINEID] (MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224|default) authpassphrase [(DES|AES|default) [privpassphrase]]\");\n\n    /*\n     * we need to be called back later\n     */\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,\n                           usm_store_users, NULL);\n}\n\n/*\n * initializations for the USM.\n *\n * Should be called after the (engineid) configuration files have been read.\n *\n * Set \"arbitrary\" portion of salt to a random number.\n */\nstatic int\ninit_usm_post_config(int majorid, int minorid, void *serverarg,\n                     void *clientarg)\n{\n    size_t          salt_integer_len = sizeof(salt_integer);\n\n    if (sc_random((u_char *) & salt_integer, &salt_integer_len) !=\n        SNMPERR_SUCCESS) {\n        DEBUGMSGTL((\"usm\", \"sc_random() failed: using time() as salt.\\n\"));\n        salt_integer = (u_int) time(NULL);\n    }\n\n#ifdef HAVE_AES\n    salt_integer_len = sizeof (salt_integer64_1);\n    if (sc_random((u_char *) & salt_integer64_1, &salt_integer_len) !=\n        SNMPERR_SUCCESS) {\n        DEBUGMSGTL((\"usm\", \"sc_random() failed: using time() as aes1 salt.\\n\"));\n        salt_integer64_1 = (u_int) time(NULL);\n    }\n    salt_integer_len = sizeof (salt_integer64_1);\n    if (sc_random((u_char *) & salt_integer64_2, &salt_integer_len) !=\n        SNMPERR_SUCCESS) {\n        DEBUGMSGTL((\"usm\", \"sc_random() failed: using time() as aes2 salt.\\n\"));\n        salt_integer64_2 = (u_int) time(NULL);\n    }\n#endif\n\n#ifndef NETSNMP_DISABLE_MD5\n    noNameUser = usm_create_initial_user(\"\", usmHMACMD5AuthProtocol,\n                                         OID_LENGTH(usmHMACMD5AuthProtocol),\n                                         SNMP_DEFAULT_PRIV_PROTO,\n                                         SNMP_DEFAULT_PRIV_PROTOLEN);\n#else\n    noNameUser = usm_create_initial_user(\"\", usmHMACSHA1AuthProtocol,\n                                         OID_LENGTH(usmHMACSHA1AuthProtocol),\n                                         SNMP_DEFAULT_PRIV_PROTO,\n                                         SNMP_DEFAULT_PRIV_PROTOLEN);\n#endif\n\n    if ( noNameUser ) {\n        SNMP_FREE(noNameUser->engineID);\n        noNameUser->engineIDLen = 0;\n    }\n\n    return SNMPERR_SUCCESS;\n}                               /* end init_usm_post_config() */\n\nstatic int\ndeinit_usm_post_config(int majorid, int minorid, void *serverarg,\n\t\t       void *clientarg)\n{\n    if (usm_free_user(noNameUser) != NULL) {\n\tDEBUGMSGTL((\"deinit_usm_post_config\", \"could not free initial user\\n\"));\n\treturn SNMPERR_GENERR;\n    }\n    noNameUser = NULL;\n\n    DEBUGMSGTL((\"deinit_usm_post_config\", \"initial user removed\\n\"));\n    return SNMPERR_SUCCESS;\n}                               /* end deinit_usm_post_config() */\n\nvoid\ninit_usm(void)\n{\n    struct snmp_secmod_def *def;\n    char *type;\n\n    DEBUGMSGTL((\"init_usm\", \"unit_usm: %\" NETSNMP_PRIo \"u %\" NETSNMP_PRIo \"u\\n\",\n                usmNoPrivProtocol[0], usmNoPrivProtocol[1]));\n\n    sc_init();                  /* initalize scapi code */\n\n    /*\n     * register ourselves as a security service\n     */\n    def = SNMP_MALLOC_STRUCT(snmp_secmod_def);\n    if (def == NULL)\n        return;\n    /*\n     * XXX: def->init_sess_secmod move stuff from snmp_api.c\n     */\n    def->encode_reverse = usm_secmod_rgenerate_out_msg;\n    def->encode_forward = usm_secmod_generate_out_msg;\n    def->decode = usm_secmod_process_in_msg;\n    def->pdu_free_state_ref = usm_free_usmStateReference;\n    def->session_setup = usm_session_init;\n    def->handle_report = usm_handle_report;\n    def->probe_engineid = usm_discover_engineid;\n    def->post_probe_engineid = usm_create_user_from_session_hook;\n    if (register_sec_mod(USM_SEC_MODEL_NUMBER, \"usm\", def) != SNMPERR_SUCCESS) {\n        SNMP_FREE(def);\n        snmp_log(LOG_ERR, \"could not register usm sec mod\\n\");\n        return;\n    }\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,\n                           init_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           deinit_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_engineID, NULL);\n\n    register_config_handler(\"snmp\", \"defAuthType\", snmpv3_authtype_conf,\n                            NULL, \"MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224\");\n    register_config_handler(\"snmp\", \"defPrivType\", snmpv3_privtype_conf,\n                            NULL,\n                            \"DES\"\n#ifdef HAVE_AES\n                            \"|AES|AES-128\"\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n                            \"|AES-192|AES-256\"\n#endif /* NETSNMP_DRAFT_BLUMENTHAL_AES_04 */\n#else\n                            \" (AES support not available)\"\n#endif\n                           );\n\n    /*\n     * Free stuff at shutdown time\n     */\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_enginetime_on_shutdown, NULL);\n\n\n    type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE);\n\n    register_config_handler(type, \"userSetAuthPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetAuthKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetPrivKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetAuthLocalKey\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivLocalKey\", usm_set_password,\n                            NULL, NULL);\n}\n\nvoid\nshutdown_usm(void)\n{\n    free_etimelist();\n    clear_user_list();\n}\n"], "fixing_code": ["/*\n * snmp_client.c - a toolkit of common functions for an SNMP client.\n *\n */\n/* Portions of this file are subject to the following copyright(s).  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/**********************************************************************\n\tCopyright 1988, 1989, 1991, 1992 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n/*\n * Portions of this file are copyrighted by:\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n *\n * Portions of this file are copyrighted by:\n * Copyright (c) 2016 VMware, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n\n/** @defgroup snmp_client various PDU processing routines\n *  @ingroup library\n * \n *  @{\n */\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#include <stdio.h>\n#include <errno.h>\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <sys/types.h>\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#if HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#if HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#if HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#if HAVE_SYSLOG_H\n#include <syslog.h>\n#endif\n\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <net-snmp/types.h>\n\n#include <net-snmp/agent/ds_agent.h>\n#include <net-snmp/library/default_store.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/snmp_client.h>\n#include <net-snmp/library/snmp_secmod.h>\n#include <net-snmp/library/snmpusm.h>\n#include <net-snmp/library/mib.h>\n#include <net-snmp/library/snmp_logging.h>\n#include <net-snmp/library/snmp_assert.h>\n#include <net-snmp/library/large_fd_set.h>\n#include <net-snmp/pdu_api.h>\n\nnetsnmp_feature_child_of(snmp_client_all, libnetsnmp)\n\nnetsnmp_feature_child_of(snmp_split_pdu, snmp_client_all)\nnetsnmp_feature_child_of(snmp_reset_var_types, snmp_client_all)\nnetsnmp_feature_child_of(query_set_default_session, snmp_client_all)\nnetsnmp_feature_child_of(row_create, snmp_client_all)\n\n#ifndef BSD4_3\n#define BSD4_2\n#endif\n\n\n/*\n * Prototype definitions \n */\nstatic int      snmp_synch_input(int op, netsnmp_session * session,\n                                 int reqid, netsnmp_pdu *pdu, void *magic);\n\nnetsnmp_pdu    *\nsnmp_pdu_create(int command)\n{\n    netsnmp_pdu    *pdu;\n\n    pdu = (netsnmp_pdu *) calloc(1, sizeof(netsnmp_pdu));\n    if (pdu) {\n        pdu->version = SNMP_DEFAULT_VERSION;\n        pdu->command = command;\n        pdu->errstat = SNMP_DEFAULT_ERRSTAT;\n        pdu->errindex = SNMP_DEFAULT_ERRINDEX;\n        pdu->securityModel = SNMP_DEFAULT_SECMODEL;\n        pdu->transport_data = NULL;\n        pdu->transport_data_length = 0;\n        pdu->securityNameLen = 0;\n        pdu->contextNameLen = 0;\n        pdu->time = 0;\n        pdu->reqid = snmp_get_next_reqid();\n        pdu->msgid = snmp_get_next_msgid();\n    }\n    return pdu;\n\n}\n\n\n/*\n * Add a null variable with the requested name to the end of the list of\n * variables for this pdu.\n */\nnetsnmp_variable_list *\nsnmp_add_null_var(netsnmp_pdu *pdu, const oid * name, size_t name_length)\n{\n    return snmp_pdu_add_variable(pdu, name, name_length, ASN_NULL, NULL, 0);\n}\n\n\n#include <net-snmp/library/snmp_debug.h>\nstatic int\nsnmp_synch_input(int op,\n                 netsnmp_session * session,\n                 int reqid, netsnmp_pdu *pdu, void *magic)\n{\n    struct synch_state *state = (struct synch_state *) magic;\n    int             rpt_type;\n\n    if (reqid != state->reqid && pdu && pdu->command != SNMP_MSG_REPORT) {\n        DEBUGMSGTL((\"snmp_synch\", \"Unexpected response (ReqID: %d,%d - Cmd %d)\\n\",\n                                   reqid, state->reqid, pdu->command ));\n        return 0;\n    }\n\n    state->waiting = 0;\n    DEBUGMSGTL((\"snmp_synch\", \"Response (ReqID: %d - Cmd %d)\\n\",\n                               reqid, (pdu ? pdu->command : -1)));\n\n    if (op == NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE && pdu) {\n        if (pdu->command == SNMP_MSG_REPORT) {\n            rpt_type = snmpv3_get_report_type(pdu);\n            if (SNMPV3_IGNORE_UNAUTH_REPORTS ||\n                rpt_type == SNMPERR_NOT_IN_TIME_WINDOW) {\n                state->waiting = 1;\n            }\n            state->pdu = NULL;\n            state->status = STAT_ERROR;\n            session->s_snmp_errno = rpt_type;\n            SET_SNMP_ERROR(rpt_type);\n        } else if (pdu->command == SNMP_MSG_RESPONSE) {\n            /*\n             * clone the pdu to return to snmp_synch_response \n             */\n            state->pdu = snmp_clone_pdu(pdu);\n            state->status = STAT_SUCCESS;\n            session->s_snmp_errno = SNMPERR_SUCCESS;\n        }\n        else {\n            char msg_buf[50];\n            state->status = STAT_ERROR;\n            session->s_snmp_errno = SNMPERR_PROTOCOL;\n            SET_SNMP_ERROR(SNMPERR_PROTOCOL);\n            snprintf(msg_buf, sizeof(msg_buf), \"Expected RESPONSE-PDU but got %s-PDU\",\n                     snmp_pdu_type(pdu->command));\n            snmp_set_detail(msg_buf);\n            return 0;\n        }\n    } else if (op == NETSNMP_CALLBACK_OP_TIMED_OUT) {\n        state->pdu = NULL;\n        state->status = STAT_TIMEOUT;\n        session->s_snmp_errno = SNMPERR_TIMEOUT;\n        SET_SNMP_ERROR(SNMPERR_TIMEOUT);\n    } else if (op == NETSNMP_CALLBACK_OP_SEC_ERROR) {\n        state->pdu = NULL;\n        /*\n         * If we already have an error in status, then leave it alone.\n         */\n        if (state->status == STAT_SUCCESS) {\n            state->status = STAT_ERROR;\n            session->s_snmp_errno = SNMPERR_GENERR;\n            SET_SNMP_ERROR(SNMPERR_GENERR);\n        }\n    } else if (op == NETSNMP_CALLBACK_OP_DISCONNECT) {\n        state->pdu = NULL;\n        state->status = STAT_ERROR;\n        session->s_snmp_errno = SNMPERR_ABORT;\n        SET_SNMP_ERROR(SNMPERR_ABORT);\n    }\n    DEBUGMSGTL((\"snmp_synch\", \"status = %d errno = %d\\n\",\n                               state->status, session->s_snmp_errno));\n\n    return 1;\n}\n\n\n/*\n * Clone an SNMP variable data structure.\n * Sets pointers to structure private storage, or\n * allocates larger object identifiers and values as needed.\n *\n * Caller must make list association for cloned variable.\n *\n * Returns 0 if successful.\n */\nint\nsnmp_clone_var(netsnmp_variable_list * var, netsnmp_variable_list * newvar)\n{\n    if (!newvar || !var)\n        return 1;\n\n    memmove(newvar, var, sizeof(netsnmp_variable_list));\n    newvar->next_variable = NULL;\n    newvar->name = NULL;\n    newvar->val.string = NULL;\n    newvar->data = NULL;\n    newvar->dataFreeHook = NULL;\n    newvar->index = 0;\n\n    /*\n     * Clone the object identifier and the value.\n     * Allocate memory iff original will not fit into local storage.\n     */\n    if (snmp_set_var_objid(newvar, var->name, var->name_length))\n        return 1;\n\n    /*\n     * need a pointer to copy a string value. \n     */\n    if (var->val.string) {\n        if (var->val.string != &var->buf[0]) {\n            if (var->val_len <= sizeof(var->buf))\n                newvar->val.string = newvar->buf;\n            else {\n                newvar->val.string = (u_char *) malloc(var->val_len);\n                if (!newvar->val.string)\n                    return 1;\n            }\n            memmove(newvar->val.string, var->val.string, var->val_len);\n        } else {                /* fix the pointer to new local store */\n            newvar->val.string = newvar->buf;\n            /*\n             * no need for a memmove, since we copied the whole var\n             * struct (and thus var->buf) at the beginning of this function.\n             */\n        }\n    } else {\n        newvar->val.string = NULL;\n        newvar->val_len = 0;\n    }\n\n    return 0;\n}\n\n\n/*\n * Possibly make a copy of source memory buffer.\n * Will reset destination pointer if source pointer is NULL.\n * Returns 0 if successful, 1 if memory allocation fails.\n */\nint\nsnmp_clone_mem(void **dstPtr, const void *srcPtr, unsigned len)\n{\n    *dstPtr = NULL;\n    if (srcPtr) {\n        *dstPtr = malloc(len + 1);\n        if (!*dstPtr) {\n            return 1;\n        }\n        memmove(*dstPtr, srcPtr, len);\n        /*\n         * this is for those routines that expect 0-terminated strings!!!\n         * someone should rather have called strdup\n         */\n        ((char *) *dstPtr)[len] = 0;\n    }\n    return 0;\n}\n\n\n/*\n * Walks through a list of varbinds and frees and allocated memory,\n * restoring pointers to local buffers\n */\nvoid\nsnmp_reset_var_buffers(netsnmp_variable_list * var)\n{\n    while (var) {\n        if (var->name != var->name_loc) {\n            if(NULL != var->name)\n                free(var->name);\n            var->name = var->name_loc;\n            var->name_length = 0;\n        }\n        if (var->val.string != var->buf) {\n            if (NULL != var->val.string)\n                free(var->val.string);\n            var->val.string = var->buf;\n            var->val_len = 0;\n        }\n        var = var->next_variable;\n    }\n}\n\n/*\n * Creates and allocates a clone of the input PDU,\n * but does NOT copy the variables.\n * This function should be used with another function,\n * such as _copy_pdu_vars.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\nstatic\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n\n    if (!pdu)\n        return NULL;\n\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n\n    /*\n     * reset copied pointers if copy fails \n     */\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n\n    /*\n     * copy buffers individually. If any copy fails, all are freed. \n     */\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n\n    sptr = find_sec_mod(newpdu->securityModel);\n    if (sptr && sptr->pdu_clone) {\n        /* call security model if it needs to know about this */\n        ret = sptr->pdu_clone(pdu, newpdu);\n        if (ret) {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n\n    return newpdu;\n}\n\nstatic\nnetsnmp_variable_list *\n_copy_varlist(netsnmp_variable_list * var,      /* source varList */\n              int errindex,     /* index of variable to drop (if any) */\n              int copy_count)\n{                               /* !=0 number variables to copy */\n    netsnmp_variable_list *newhead, *newvar, *oldvar;\n    int             ii = 0;\n\n    newhead = NULL;\n    oldvar = NULL;\n\n    while (var && (copy_count-- > 0)) {\n        /*\n         * Drop the specified variable (if applicable) \n         * xxx hmm, is it intentional that dropping the errindex\n         *     counts towards copy_count?\n         */\n        if (++ii == errindex) {\n            var = var->next_variable;\n            continue;\n        }\n\n        /*\n         * clone the next variable. Cleanup if alloc fails \n         */\n        newvar = (netsnmp_variable_list *)\n            malloc(sizeof(netsnmp_variable_list));\n        if (snmp_clone_var(var, newvar)) {\n            if (newvar)\n                free((char *) newvar);\n            snmp_free_varbind(newhead);\n            return NULL;\n        }\n\n        /*\n         * add cloned variable to new list  \n         */\n        if (NULL == newhead)\n            newhead = newvar;\n        if (oldvar)\n            oldvar->next_variable = newvar;\n        oldvar = newvar;\n\n        var = var->next_variable;\n    }\n    return newhead;\n}\n\n\n/*\n * Copy some or all variables from source PDU to target PDU.\n * This function consolidates many of the needs of PDU variables:\n * Clone PDU : copy all the variables.\n * Split PDU : skip over some variables to copy other variables.\n * Fix PDU   : remove variable associated with error index.\n *\n * Designed to work with _clone_pdu_header.\n *\n * If drop_err is set, drop any variable associated with errindex.\n * If skip_count is set, skip the number of variable in pdu's list.\n * While copy_count is greater than zero, copy pdu variables to newpdu.\n *\n * If an error occurs, newpdu is freed and pointer is set to 0.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\nstatic\nnetsnmp_pdu    *\n_copy_pdu_vars(netsnmp_pdu *pdu,        /* source PDU */\n               netsnmp_pdu *newpdu,     /* target PDU */\n               int drop_err,    /* !=0 drop errored variable */\n               int skip_count,  /* !=0 number of variables to skip */\n               int copy_count)\n{                               /* !=0 number of variables to copy */\n    netsnmp_variable_list *var;\n#if TEMPORARILY_DISABLED\n    int             copied;\n#endif\n    int             drop_idx;\n\n    if (!newpdu)\n        return NULL;            /* where is PDU to copy to ? */\n\n    if (drop_err)\n        drop_idx = pdu->errindex - skip_count;\n    else\n        drop_idx = 0;\n\n    var = pdu->variables;\n    while (var && (skip_count-- > 0))   /* skip over pdu variables */\n        var = var->next_variable;\n\n#if TEMPORARILY_DISABLED\n    copied = 0;\n    if (pdu->flags & UCD_MSG_FLAG_FORCE_PDU_COPY)\n        copied = 1;             /* We're interested in 'empty' responses too */\n#endif\n\n    newpdu->variables = _copy_varlist(var, drop_idx, copy_count);\n#if TEMPORARILY_DISABLED\n    if (newpdu->variables)\n        copied = 1;\n#endif\n\n#if ALSO_TEMPORARILY_DISABLED\n    /*\n     * Error if bad errindex or if target PDU has no variables copied \n     */\n    if ((drop_err && (ii < pdu->errindex))\n#if TEMPORARILY_DISABLED\n        /*\n         * SNMPv3 engineID probes are allowed to be empty.\n         * See the comment in snmp_api.c for further details \n         */\n        || copied == 0\n#endif\n        ) {\n        snmp_free_pdu(newpdu);\n        return 0;\n    }\n#endif\n    return newpdu;\n}\n\n\n/*\n * Creates (allocates and copies) a clone of the input PDU.\n * If drop_err is set, don't copy any variable associated with errindex.\n * This function is called by snmp_clone_pdu and snmp_fix_pdu.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\nstatic\nnetsnmp_pdu    *\n_clone_pdu(netsnmp_pdu *pdu, int drop_err)\n{\n    netsnmp_pdu    *newpdu;\n    newpdu = _clone_pdu_header(pdu);\n    newpdu = _copy_pdu_vars(pdu, newpdu, drop_err, 0, 10000);   /* skip none, copy all */\n\n    return newpdu;\n}\n\n\n/*\n * This function will clone a full varbind list\n *\n * Returns a pointer to the cloned varbind list if successful.\n * Returns 0 if failure\n */\nnetsnmp_variable_list *\nsnmp_clone_varbind(netsnmp_variable_list * varlist)\n{\n    return _copy_varlist(varlist, 0, 10000);    /* skip none, copy all */\n}\n\n/*\n * This function will clone a PDU including all of its variables.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure\n */\nnetsnmp_pdu    *\nsnmp_clone_pdu(netsnmp_pdu *pdu)\n{\n    return _clone_pdu(pdu, 0);  /* copies all variables */\n}\n\n\n/*\n * This function will clone a PDU including some of its variables.\n *\n * If skip_count is not zero, it defines the number of variables to skip.\n * If copy_count is not zero, it defines the number of variables to copy.\n *\n * Returns a pointer to the cloned PDU if successful.\n * Returns 0 if failure.\n */\n#ifndef NETSNMP_FEATURE_REMOVE_SNMP_SPLIT_PDU\nnetsnmp_pdu    *\nsnmp_split_pdu(netsnmp_pdu *pdu, int skip_count, int copy_count)\n{\n    netsnmp_pdu    *newpdu;\n    newpdu = _clone_pdu_header(pdu);\n    newpdu = _copy_pdu_vars(pdu, newpdu, 0,     /* don't drop any variables */\n                            skip_count, copy_count);\n\n    return newpdu;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNMP_SPLIT_PDU */\n\n\n/*\n * If there was an error in the input pdu, creates a clone of the pdu\n * that includes all the variables except the one marked by the errindex.\n * The command is set to the input command and the reqid, errstat, and\n * errindex are set to default values.\n * If the error status didn't indicate an error, the error index didn't\n * indicate a variable, the pdu wasn't a get response message, the\n * marked variable was not present in the initial request, or there\n * would be no remaining variables, this function will return 0.\n * If everything was successful, a pointer to the fixed cloned pdu will\n * be returned.\n */\nnetsnmp_pdu    *\nsnmp_fix_pdu(netsnmp_pdu *pdu, int command)\n{\n    netsnmp_pdu    *newpdu;\n\n    if ((pdu->command != SNMP_MSG_RESPONSE)\n        || (pdu->errstat == SNMP_ERR_NOERROR)\n        || (NULL == pdu->variables)\n        || (pdu->errindex > (int)snmp_varbind_len(pdu))\n        || (pdu->errindex <= 0)) {\n        return NULL;            /* pre-condition tests fail */\n    }\n\n    newpdu = _clone_pdu(pdu, 1);        /* copies all except errored variable */\n    if (!newpdu)\n        return NULL;\n    if (!newpdu->variables) {\n        snmp_free_pdu(newpdu);\n        return NULL;            /* no variables. \"should not happen\" */\n    }\n    newpdu->command = command;\n    newpdu->reqid = snmp_get_next_reqid();\n    newpdu->msgid = snmp_get_next_msgid();\n    newpdu->errstat = SNMP_DEFAULT_ERRSTAT;\n    newpdu->errindex = SNMP_DEFAULT_ERRINDEX;\n\n    return newpdu;\n}\n\n\n/*\n * Returns the number of variables bound to a PDU structure\n */\nunsigned long\nsnmp_varbind_len(netsnmp_pdu *pdu)\n{\n    register netsnmp_variable_list *vars;\n    unsigned long   retVal = 0;\n    if (pdu)\n        for (vars = pdu->variables; vars; vars = vars->next_variable) {\n            retVal++;\n        }\n\n    return retVal;\n}\n\n/*\n * Add object identifier name to SNMP variable.\n * If the name is large, additional memory is allocated.\n * Returns 0 if successful.\n */\n\nint\nsnmp_set_var_objid(netsnmp_variable_list * vp,\n                   const oid * objid, size_t name_length)\n{\n    size_t          len = sizeof(oid) * name_length;\n\n    if (vp->name != vp->name_loc && vp->name != NULL) {\n        /*\n         * Probably previously-allocated \"big storage\".  Better free it\n         * else memory leaks possible.  \n         */\n        free(vp->name);\n    }\n\n    /*\n     * use built-in storage for smaller values \n     */\n    if (len <= sizeof(vp->name_loc)) {\n        vp->name = vp->name_loc;\n    } else {\n        vp->name = (oid *) malloc(len);\n        if (!vp->name)\n            return 1;\n    }\n    if (objid)\n        memmove(vp->name, objid, len);\n    vp->name_length = name_length;\n    return 0;\n}\n\n/**\n * snmp_set_var_typed_value is used to set data into the netsnmp_variable_list\n * structure.  Used to return data to the snmp request via the\n * netsnmp_request_info structure's requestvb pointer.\n *\n * @param newvar   the structure gets populated with the given data, type,\n *                 val_str, and val_len.\n * @param type     is the asn data type to be copied\n * @param val_str  is a buffer containing the value to be copied into the\n *                 newvar structure. \n * @param val_len  the length of val_str\n * \n * @return returns 0 on success and 1 on a malloc error\n */\n\nint\nsnmp_set_var_typed_value(netsnmp_variable_list * newvar, u_char type,\n                         const void * val_str, size_t val_len)\n{\n    newvar->type = type;\n    return snmp_set_var_value(newvar, val_str, val_len);\n}\n\nint\nsnmp_set_var_typed_integer(netsnmp_variable_list * newvar,\n                           u_char type, long val)\n{\n    newvar->type = type;\n    return snmp_set_var_value(newvar, &val, sizeof(long));\n}\n\nint\ncount_varbinds(netsnmp_variable_list * var_ptr)\n{\n    int             count = 0;\n\n    for (; var_ptr != NULL; var_ptr = var_ptr->next_variable)\n        count++;\n\n    return count;\n}\n\nnetsnmp_feature_child_of(count_varbinds_of_type, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_COUNT_VARBINDS_OF_TYPE\nint\ncount_varbinds_of_type(netsnmp_variable_list * var_ptr, u_char type)\n{\n    int             count = 0;\n\n    for (; var_ptr != NULL; var_ptr = var_ptr->next_variable)\n        if (var_ptr->type == type)\n            count++;\n\n    return count;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_COUNT_VARBINDS_OF_TYPE */\n\nnetsnmp_feature_child_of(find_varind_of_type, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_FIND_VARIND_OF_TYPE\nnetsnmp_variable_list *\nfind_varbind_of_type(netsnmp_variable_list * var_ptr, u_char type)\n{\n    for (; var_ptr != NULL && var_ptr->type != type;\n         var_ptr = var_ptr->next_variable);\n\n    return var_ptr;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_FIND_VARIND_OF_TYPE */\n\nnetsnmp_variable_list*\nfind_varbind_in_list( netsnmp_variable_list *vblist,\n                      const oid *name, size_t len)\n{\n    for (; vblist != NULL; vblist = vblist->next_variable)\n        if (!snmp_oid_compare(vblist->name, vblist->name_length, name, len))\n            return vblist;\n\n    return NULL;\n}\n\n/*\n * Add some value to SNMP variable.\n * If the value is large, additional memory is allocated.\n * Returns 0 if successful.\n */\n\nint\nsnmp_set_var_value(netsnmp_variable_list * vars,\n                   const void * value, size_t len)\n{\n    int             largeval = 1;\n\n    /*\n     * xxx-rks: why the unconditional free? why not use existing\n     * memory, if len < vars->val_len ?\n     */\n    if (vars->val.string && vars->val.string != vars->buf) {\n        free(vars->val.string);\n    }\n    vars->val.string = NULL;\n    vars->val_len = 0;\n\n    if (value == NULL && len > 0) {\n        snmp_log(LOG_ERR, \"bad size for NULL value\\n\");\n        return 1;\n    }\n\n    /*\n     * use built-in storage for smaller values \n     */\n    if (len <= sizeof(vars->buf)) {\n        vars->val.string = (u_char *) vars->buf;\n        largeval = 0;\n    }\n\n    if ((0 == len) || (NULL == value)) {\n        vars->val.string[0] = 0;\n        return 0;\n    }\n\n    vars->val_len = len;\n    switch (vars->type) {\n    case ASN_INTEGER:\n    case ASN_UNSIGNED:\n    case ASN_TIMETICKS:\n    case ASN_COUNTER:\n    case ASN_UINTEGER:\n        if (vars->val_len == sizeof(int)) {\n            if (ASN_INTEGER == vars->type) {\n                const int      *val_int \n                    = (const int *) value;\n                *(vars->val.integer) = (long) *val_int;\n            } else {\n                const u_int    *val_uint\n                    = (const u_int *) value;\n                *(vars->val.integer) = (unsigned long) *val_uint;\n            }\n        }\n#if SIZEOF_LONG != SIZEOF_INT\n        else if (vars->val_len == sizeof(long)){\n            const u_long   *val_ulong\n                = (const u_long *) value;\n            *(vars->val.integer) = *val_ulong;\n            if (*(vars->val.integer) > 0xffffffff) {\n                snmp_log(LOG_ERR,\"truncating integer value > 32 bits\\n\");\n                *(vars->val.integer) &= 0xffffffff;\n            }\n        }\n#endif\n#if defined(SIZEOF_LONG_LONG) && (SIZEOF_LONG != SIZEOF_LONG_LONG)\n#if !defined(SIZEOF_INTMAX_T) || (SIZEOF_LONG_LONG != SIZEOF_INTMAX_T)\n        else if (vars->val_len == sizeof(long long)){\n            const unsigned long long   *val_ullong\n                = (const unsigned long long *) value;\n            *(vars->val.integer) = (long) *val_ullong;\n            if (*(vars->val.integer) > 0xffffffff) {\n                snmp_log(LOG_ERR,\"truncating integer value > 32 bits\\n\");\n                *(vars->val.integer) &= 0xffffffff;\n            }\n        }\n#endif\n#endif\n#if defined(SIZEOF_INTMAX_T) && (SIZEOF_LONG != SIZEOF_INTMAX_T)\n        else if (vars->val_len == sizeof(intmax_t)){\n            const uintmax_t *val_uintmax_t\n                = (const uintmax_t *) value;\n            *(vars->val.integer) = (long) *val_uintmax_t;\n            if (*(vars->val.integer) > 0xffffffff) {\n                snmp_log(LOG_ERR,\"truncating integer value > 32 bits\\n\");\n                *(vars->val.integer) &= 0xffffffff;\n            }\n        }\n#endif\n#if SIZEOF_SHORT != SIZEOF_INT\n        else if (vars->val_len == sizeof(short)) {\n            if (ASN_INTEGER == vars->type) {\n                const short      *val_short \n                    = (const short *) value;\n                *(vars->val.integer) = (long) *val_short;\n            } else {\n                const u_short    *val_ushort\n                    = (const u_short *) value;\n                *(vars->val.integer) = (unsigned long) *val_ushort;\n            }\n        }\n#endif\n        else if (vars->val_len == sizeof(char)) {\n            if (ASN_INTEGER == vars->type) {\n                const char      *val_char \n                    = (const char *) value;\n                *(vars->val.integer) = (long) *val_char;\n            } else {\n                    const u_char    *val_uchar\n                    = (const u_char *) value;\n                *(vars->val.integer) = (unsigned long) *val_uchar;\n            }\n        }\n        else {\n            snmp_log(LOG_ERR,\"bad size for integer-like type (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(long);\n        break;\n\n    case ASN_OBJECT_ID:\n    case ASN_PRIV_IMPLIED_OBJECT_ID:\n    case ASN_PRIV_INCL_RANGE:\n    case ASN_PRIV_EXCL_RANGE:\n        if (largeval) {\n            vars->val.objid = (oid *) malloc(vars->val_len);\n        }\n        if (vars->val.objid == NULL) {\n            snmp_log(LOG_ERR,\"no storage for OID\\n\");\n            return 1;\n        }\n        memmove(vars->val.objid, value, vars->val_len);\n        break;\n\n    case ASN_IPADDRESS: /* snmp_build_var_op treats IPADDR like a string */\n        if (4 != vars->val_len) {\n            netsnmp_assert(\"ipaddress length == 4\");\n        }\n        /* FALL THROUGH */\n    case ASN_PRIV_IMPLIED_OCTET_STR:\n    case ASN_OCTET_STR:\n    case ASN_BIT_STR:\n    case ASN_OPAQUE:\n    case ASN_NSAP:\n        if (vars->val_len >= sizeof(vars->buf)) {\n            vars->val.string = (u_char *) malloc(vars->val_len + 1);\n        }\n        if (vars->val.string == NULL) {\n            snmp_log(LOG_ERR,\"no storage for string\\n\");\n            return 1;\n        }\n        memmove(vars->val.string, value, vars->val_len);\n        /*\n         * Make sure the string is zero-terminated; some bits of code make\n         * this assumption.  Easier to do this here than fix all these wrong\n         * assumptions.  \n         */\n        vars->val.string[vars->val_len] = '\\0';\n        break;\n\n    case SNMP_NOSUCHOBJECT:\n    case SNMP_NOSUCHINSTANCE:\n    case SNMP_ENDOFMIBVIEW:\n    case ASN_NULL:\n        vars->val_len = 0;\n        vars->val.string = NULL;\n        break;\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_U64:\n    case ASN_OPAQUE_I64:\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n    case ASN_COUNTER64:\n        if (largeval) {\n            snmp_log(LOG_ERR,\"bad size for counter 64 (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(struct counter64);\n        memmove(vars->val.counter64, value, vars->val_len);\n        break;\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_FLOAT:\n        if (largeval) {\n            snmp_log(LOG_ERR,\"bad size for opaque float (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(float);\n        memmove(vars->val.floatVal, value, vars->val_len);\n        break;\n\n    case ASN_OPAQUE_DOUBLE:\n        if (largeval) {\n            snmp_log(LOG_ERR,\"bad size for opaque double (%d)\\n\",\n                     (int)vars->val_len);\n            return (1);\n        }\n        vars->val_len = sizeof(double);\n        memmove(vars->val.doubleVal, value, vars->val_len);\n        break;\n\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n\n    default:\n        snmp_log(LOG_ERR,\"Internal error in type switching\\n\");\n        snmp_set_detail(\"Internal error in type switching\\n\");\n        return (1);\n    }\n\n    return 0;\n}\n\nvoid\nsnmp_replace_var_types(netsnmp_variable_list * vbl, u_char old_type,\n                       u_char new_type)\n{\n    while (vbl) {\n        if (vbl->type == old_type) {\n            snmp_set_var_typed_value(vbl, new_type, NULL, 0);\n        }\n        vbl = vbl->next_variable;\n    }\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SNMP_RESET_VAR_TYPES\nvoid\nsnmp_reset_var_types(netsnmp_variable_list * vbl, u_char new_type)\n{\n    while (vbl) {\n        snmp_set_var_typed_value(vbl, new_type, NULL, 0);\n        vbl = vbl->next_variable;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNMP_RESET_VAR_TYPES */\n\nint\nsnmp_synch_response_cb(netsnmp_session * ss,\n                       netsnmp_pdu *pdu,\n                       netsnmp_pdu **response, snmp_callback pcb)\n{\n    struct synch_state    lstate, *state;\n    snmp_callback         cbsav;\n    void                 *cbmagsav;\n    int                   numfds, count;\n    netsnmp_large_fd_set  fdset;\n    struct timeval        timeout, *tvp;\n    int                   block;\n\n    memset((void *) &lstate, 0, sizeof(lstate));\n    state = &lstate;\n    cbsav = ss->callback;\n    cbmagsav = ss->callback_magic;\n    ss->callback = pcb;\n    ss->callback_magic = (void *) state;\n    netsnmp_large_fd_set_init(&fdset, FD_SETSIZE);\n\n    if (snmp_send(ss, pdu) == 0) {\n        snmp_free_pdu(pdu);\n        state->status = STAT_ERROR;\n    } else {\n        state->reqid = pdu->reqid;\n        state->waiting = 1;\n    }\n\n    while (state->waiting) {\n        numfds = 0;\n        NETSNMP_LARGE_FD_ZERO(&fdset);\n        block = NETSNMP_SNMPBLOCK;\n        tvp = &timeout;\n        timerclear(tvp);\n        snmp_sess_select_info2_flags(NULL, &numfds, &fdset, tvp, &block,\n                                     NETSNMP_SELECT_NOALARMS);\n        if (block == 1)\n            tvp = NULL;         /* block without timeout */\n        count = netsnmp_large_fd_set_select(numfds, &fdset, NULL, NULL, tvp);\n        if (count > 0) {\n            snmp_read2(&fdset);\n        } else {\n            switch (count) {\n            case 0:\n                snmp_timeout();\n                break;\n            case -1:\n                if (errno == EINTR) {\n                    continue;\n                } else {\n                    snmp_errno = SNMPERR_GENERR;    /*MTCRITICAL_RESOURCE */\n                    /*\n                     * CAUTION! if another thread closed the socket(s)\n                     * waited on here, the session structure was freed.\n                     * It would be nice, but we can't rely on the pointer.\n                     * ss->s_snmp_errno = SNMPERR_GENERR;\n                     * ss->s_errno = errno;\n                     */\n                    snmp_set_detail(strerror(errno));\n                }\n                /* FALLTHRU */\n            default:\n                state->status = STAT_ERROR;\n                state->waiting = 0;\n            }\n        }\n\n        if ( ss->flags & SNMP_FLAGS_RESP_CALLBACK ) {\n            void (*cb)(void);\n            cb = (void (*)(void))(ss->myvoid);\n            cb();        /* Used to invoke 'netsnmp_check_outstanding_agent_requests();'\n                            on internal AgentX queries.  */\n        }\n    }\n    *response = state->pdu;\n    ss->callback = cbsav;\n    ss->callback_magic = cbmagsav;\n    netsnmp_large_fd_set_cleanup(&fdset);\n    return state->status;\n}\n\nint\nsnmp_synch_response(netsnmp_session * ss,\n                    netsnmp_pdu *pdu, netsnmp_pdu **response)\n{\n    return snmp_synch_response_cb(ss, pdu, response, snmp_synch_input);\n}\n\nint\nsnmp_sess_synch_response(void *sessp,\n                         netsnmp_pdu *pdu, netsnmp_pdu **response)\n{\n    netsnmp_session      *ss;\n    struct synch_state    lstate, *state;\n    snmp_callback         cbsav;\n    void                 *cbmagsav;\n    int                   numfds, count;\n    netsnmp_large_fd_set  fdset;\n    struct timeval        timeout, *tvp;\n    int                   block;\n\n    ss = snmp_sess_session(sessp);\n    if (ss == NULL) {\n        return STAT_ERROR;\n    }\n\n    memset((void *) &lstate, 0, sizeof(lstate));\n    state = &lstate;\n    cbsav = ss->callback;\n    cbmagsav = ss->callback_magic;\n    ss->callback = snmp_synch_input;\n    ss->callback_magic = (void *) state;\n    netsnmp_large_fd_set_init(&fdset, FD_SETSIZE);\n\n    if (snmp_sess_send(sessp, pdu) == 0) {\n        snmp_free_pdu(pdu);\n        state->status = STAT_ERROR;\n    } else {\n        state->waiting = 1;\n        state->reqid = pdu->reqid;\n    }\n\n    while (state->waiting) {\n        numfds = 0;\n        NETSNMP_LARGE_FD_ZERO(&fdset);\n        block = NETSNMP_SNMPBLOCK;\n        tvp = &timeout;\n        timerclear(tvp);\n        snmp_sess_select_info2_flags(sessp, &numfds, &fdset, tvp, &block,\n                                     NETSNMP_SELECT_NOALARMS);\n        if (block == 1)\n            tvp = NULL;         /* block without timeout */\n        count = netsnmp_large_fd_set_select(numfds, &fdset, NULL, NULL, tvp);\n        if (count > 0) {\n            snmp_sess_read2(sessp, &fdset);\n        } else\n            switch (count) {\n            case 0:\n                snmp_sess_timeout(sessp);\n                break;\n            case -1:\n                if (errno == EINTR) {\n                    continue;\n                } else {\n                    snmp_errno = SNMPERR_GENERR;    /*MTCRITICAL_RESOURCE */\n                    /*\n                     * CAUTION! if another thread closed the socket(s)\n                     * waited on here, the session structure was freed.\n                     * It would be nice, but we can't rely on the pointer.\n                     * ss->s_snmp_errno = SNMPERR_GENERR;\n                     * ss->s_errno = errno;\n                     */\n                    snmp_set_detail(strerror(errno));\n                }\n                /* FALLTHRU */\n            default:\n                state->status = STAT_ERROR;\n                state->waiting = 0;\n            }\n    }\n    *response = state->pdu;\n    ss->callback = cbsav;\n    ss->callback_magic = cbmagsav;\n    netsnmp_large_fd_set_cleanup(&fdset);\n    return state->status;\n}\n\n\nconst char     *\nsnmp_errstring(int errstat)\n{\n    const char * const error_string[19] = {\n        \"(noError) No Error\",\n        \"(tooBig) Response message would have been too large.\",\n        \"(noSuchName) There is no such variable name in this MIB.\",\n        \"(badValue) The value given has the wrong type or length.\",\n        \"(readOnly) The two parties used do not have access to use the specified SNMP PDU.\",\n        \"(genError) A general failure occured\",\n        \"noAccess\",\n        \"wrongType (The set datatype does not match the data type the agent expects)\",\n        \"wrongLength (The set value has an illegal length from what the agent expects)\",\n        \"wrongEncoding\",\n        \"wrongValue (The set value is illegal or unsupported in some way)\",\n        \"noCreation (That table does not support row creation or that object can not ever be created)\",\n        \"inconsistentValue (The set value is illegal or unsupported in some way)\",\n        \"resourceUnavailable (This is likely a out-of-memory failure within the agent)\",\n        \"commitFailed\",\n        \"undoFailed\",\n        \"authorizationError (access denied to that object)\",\n        \"notWritable (That object does not support modification)\",\n        \"inconsistentName (That object can not currently be created)\"\n    };\n\n    if (errstat <= MAX_SNMP_ERR && errstat >= SNMP_ERR_NOERROR) {\n        return error_string[errstat];\n    } else {\n        return \"Unknown Error\";\n    }\n}\n\n\n\n/*\n *\n *  Convenience routines to make various requests\n *  over the specified SNMP session.\n *\n */\n#include <net-snmp/library/snmp_debug.h>\n\nstatic netsnmp_session *_def_query_session = NULL;\n\n#ifndef NETSNMP_FEATURE_REMOVE_QUERY_SET_DEFAULT_SESSION\nvoid\nnetsnmp_query_set_default_session( netsnmp_session *sess) {\n    DEBUGMSGTL((\"iquery\", \"set default session %p\\n\", sess));\n    _def_query_session = sess;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_QUERY_SET_DEFAULT_SESSION */\n\n/**\n * Return a pointer to the default internal query session.\n */\nnetsnmp_session *\nnetsnmp_query_get_default_session_unchecked( void ) {\n    DEBUGMSGTL((\"iquery\", \"get default session %p\\n\", _def_query_session));\n    return _def_query_session;\n}\n\n/**\n * Return a pointer to the default internal query session and log a\n * warning message once if this session does not exist.\n */\nnetsnmp_session *\nnetsnmp_query_get_default_session( void ) {\n    static int warning_logged = 0;\n\n    if (! _def_query_session && ! warning_logged) {\n        if (! netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID,\n                                    NETSNMP_DS_AGENT_INTERNAL_SECNAME)) {\n            snmp_log(LOG_WARNING,\n                     \"iquerySecName has not been configured - internal queries will fail\\n\");\n        } else {\n            snmp_log(LOG_WARNING,\n                     \"default session is not available - internal queries will fail\\n\");\n        }\n        warning_logged = 1;\n    }\n\n    return netsnmp_query_get_default_session_unchecked();\n}\n\n\n/*\n * Internal utility routine to actually send the query\n */\nstatic int _query(netsnmp_variable_list *list,\n                  int                    request,\n                  netsnmp_session       *session) {\n\n    netsnmp_pdu *pdu;\n    netsnmp_pdu *response = NULL;\n    netsnmp_variable_list *vb1, *vb2, *vtmp;\n    int ret, count;\n\n    DEBUGMSGTL((\"iquery\", \"query on session %p\\n\", session));\n\n    if (NULL == list) {\n        snmp_log(LOG_ERR, \"empty variable list in _query\\n\");\n        return SNMP_ERR_GENERR;\n    }\n\n    pdu = snmp_pdu_create( request );\n    if (NULL == pdu) {\n        snmp_log(LOG_ERR, \"could not allocate pdu\\n\");\n        return SNMP_ERR_GENERR;\n    }\n\n    /*\n     * Clone the varbind list into the request PDU...\n     */\n    pdu->variables = snmp_clone_varbind( list );\n    if (NULL == pdu->variables) {\n        snmp_log(LOG_ERR, \"could not clone variable list\\n\");\n        snmp_free_pdu(pdu);\n        return SNMP_ERR_GENERR;\n    }\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nretry:\n#endif\n    if ( session )\n        ret = snmp_synch_response(            session, pdu, &response );\n    else if (_def_query_session)\n        ret = snmp_synch_response( _def_query_session, pdu, &response );\n    else {\n        /* No session specified */\n        snmp_free_pdu(pdu);\n        return SNMP_ERR_GENERR;\n    }\n    DEBUGMSGTL((\"iquery\", \"query returned %d\\n\", ret));\n\n    /*\n     * ....then copy the results back into the\n     * list (assuming the request succeeded!).\n     * This avoids having to worry about how this\n     * list was originally allocated.\n     */\n    if ( ret == SNMP_ERR_NOERROR ) {\n        if ( response->errstat != SNMP_ERR_NOERROR ) {\n            DEBUGMSGT((\"iquery\", \"Error in packet: %s\\n\",\n                       snmp_errstring(response->errstat)));\n            /*\n             * If the request failed, then remove the\n             *  offending varbind and try again.\n             *  (all except SET requests)\n             *\n             * XXX - implement a library version of\n             *       NETSNMP_DS_APP_DONT_FIX_PDUS ??\n             */\n            ret = response->errstat;\n            if (response->errindex != 0) {\n                DEBUGMSGT((\"iquery:result\", \"Failed object:\\n\"));\n                for (count = 1, vtmp = response->variables;\n                     vtmp && count != response->errindex;\n                     vtmp = vtmp->next_variable, count++)\n                    /*EMPTY*/;\n                if (vtmp)\n                    DEBUGMSGVAR((\"iquery:result\", vtmp));\n                DEBUGMSG((\"iquery:result\", \"\\n\"));\n            }\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n            if (request != SNMP_MSG_SET &&\n                response->errindex != 0) {\n                DEBUGMSGTL((\"iquery\", \"retrying query (%d, %ld)\\n\", ret, response->errindex));\n                pdu = snmp_fix_pdu( response, request );\n                snmp_free_pdu( response );\n                response = NULL;\n                if ( pdu != NULL )\n                    goto retry;\n            }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n        } else {\n            for (vb1 = response->variables, vb2 = list;\n                 vb1;\n                 vb1 = vb1->next_variable,  vb2 = vb2->next_variable) {\n                DEBUGMSGVAR((\"iquery:result\", vb1));\n                DEBUGMSG((\"iquery:results\", \"\\n\"));\n                if ( !vb2 ) {\n                    ret = SNMP_ERR_GENERR;\n                    break;\n                }\n                vtmp = vb2->next_variable;\n                snmp_free_var_internals( vb2 );\n                snmp_clone_var( vb1, vb2 ); /* xxx: check return? */\n                vb2->next_variable = vtmp;\n            }\n        }\n    } else {\n        /* Distinguish snmp_send errors from SNMP errStat errors */\n        ret = -ret;\n    }\n    snmp_free_pdu( response );\n    return ret;\n}\n\n/*\n * These are simple wrappers round the internal utility routine\n */\nint netsnmp_query_get(netsnmp_variable_list *list,\n                      netsnmp_session       *session){\n    return _query( list, SNMP_MSG_GET, session );\n}\n\n\nint netsnmp_query_getnext(netsnmp_variable_list *list,\n                          netsnmp_session       *session){\n    return _query( list, SNMP_MSG_GETNEXT, session );\n}\n\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\nint netsnmp_query_set(netsnmp_variable_list *list,\n                      netsnmp_session       *session){\n    return _query( list, SNMP_MSG_SET, session );\n}\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n\n/*\n * A walk needs a bit more work.\n */\nint netsnmp_query_walk(netsnmp_variable_list *list,\n                       netsnmp_session       *session) {\n    /*\n     * Create a working copy of the original (single)\n     * varbind, so we can use this varbind parameter\n     * to check when we've finished walking this subtree.\n     */\n    netsnmp_variable_list *vb = snmp_clone_varbind( list );\n    netsnmp_variable_list *res_list = NULL;\n    netsnmp_variable_list *res_last = NULL;\n    int ret;\n\n    /*\n     * Now walk the tree as usual\n     */\n    ret = _query( vb, SNMP_MSG_GETNEXT, session );\n    while ( ret == SNMP_ERR_NOERROR &&\n        snmp_oidtree_compare( list->name, list->name_length,\n                                vb->name,   vb->name_length ) == 0) {\n\n\tif (vb->type == SNMP_ENDOFMIBVIEW ||\n\t    vb->type == SNMP_NOSUCHOBJECT ||\n\t    vb->type == SNMP_NOSUCHINSTANCE)\n\t    break;\n\n        /*\n         * Copy each response varbind to the end of the result list\n         * and then re-use this to ask for the next entry.\n         */\n        if ( res_last ) {\n            res_last->next_variable = snmp_clone_varbind( vb );\n            res_last = res_last->next_variable;\n        } else {\n            res_list = snmp_clone_varbind( vb );\n            res_last = res_list;\n        }\n        ret = _query( vb, SNMP_MSG_GETNEXT, session );\n    }\n    /*\n     * Copy the first result back into the original varbind parameter,\n     * add the rest of the results (if any), and clean up.\n     */\n    if ( res_list ) {\n        snmp_clone_var( res_list, list );\n        list->next_variable = res_list->next_variable;\n        res_list->next_variable = NULL;\n        snmp_free_varbind( res_list );\n    }\n    snmp_free_varbind( vb );\n    return ret;\n}\n\n/** **************************************************************************\n *\n * state machine\n *\n */\nint\nnetsnmp_state_machine_run( netsnmp_state_machine_input *input)\n{\n    netsnmp_state_machine_step *current, *last;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->steps, SNMPERR_GENERR );\n    last = current = input->steps;\n\n    DEBUGMSGT((\"state_machine:run\", \"starting step: %s\\n\", current->name));\n\n    while (current) {\n\n        /*\n         * log step and check for required data\n         */\n        DEBUGMSGT((\"state_machine:run\", \"at step: %s\\n\", current->name));\n        if (NULL == current->run) {\n            DEBUGMSGT((\"state_machine:run\", \"no run step\\n\"));\n            current->result = last->result;\n            break;\n        }\n\n        /*\n         * run step\n         */\n        DEBUGMSGT((\"state_machine:run\", \"running step: %s\\n\", current->name));\n        current->result = (*current->run)( input, current );\n        ++input->steps_so_far;\n        \n        /*\n         * log result and move to next step\n         */\n        input->last_run = current;\n        DEBUGMSGT((\"state_machine:run:result\", \"step %s returned %d\\n\",\n                   current->name, current->result));\n        if (SNMPERR_SUCCESS == current->result)\n            current = current->on_success;\n        else if (SNMPERR_ABORT == current->result) {\n            DEBUGMSGT((\"state_machine:run:result\", \"ABORT from %s\\n\",\n                       current->name));\n            break;\n        }\n        else\n            current = current->on_error;\n    }\n\n    /*\n     * run cleanup\n     */\n    if ((input->cleanup) && (input->cleanup->run))\n        (*input->cleanup->run)( input, input->last_run );\n\n    return input->last_run->result;\n}\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n#ifndef NETSNMP_FEATURE_REMOVE_ROW_CREATE\n/** **************************************************************************\n *\n * row create state machine steps\n *\n */\ntypedef struct rowcreate_state_s {\n\n    netsnmp_session        *session;\n    netsnmp_variable_list  *vars;\n    int                     row_status_index;\n} rowcreate_state;\n\nstatic netsnmp_variable_list *\n_get_vb_num(netsnmp_variable_list *vars, int index)\n{\n    for (; vars && index > 0; --index)\n        vars = vars->next_variable;\n\n    if (!vars || index > 0)\n        return NULL;\n    \n    return vars;\n}\n\n\n/*\n * cleanup\n */\nstatic int \n_row_status_state_cleanup(netsnmp_state_machine_input *input,\n                 netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_ABORT );\n    netsnmp_require_ptr_LRV( step, SNMPERR_ABORT );\n\n    DEBUGMSGT((\"row_create:called\", \"_row_status_state_cleanup, last run step was %s rc %d\\n\",\n               step->name, step->result));\n\n    ctx = (rowcreate_state *)input->input_context;\n    if (ctx && ctx->vars)\n        snmp_free_varbind( ctx->vars );\n\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * send a request to activate the row\n */\nstatic int \n_row_status_state_activate(netsnmp_state_machine_input *input,\n                  netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *rs_var, *var = NULL;\n    int32_t                rc, val = RS_ACTIVE;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    /*\n     * just send the rowstatus varbind\n     */\n    rs_var = _get_vb_num(ctx->vars, ctx->row_status_index);\n    netsnmp_require_ptr_LRV(rs_var, SNMPERR_GENERR);\n\n    var = snmp_varlist_add_variable(&var, rs_var->name, rs_var->name_length,\n                                    rs_var->type, &val, sizeof(val));\n    netsnmp_require_ptr_LRV( var, SNMPERR_GENERR );\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( var, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(var);\n\n    return rc;\n}\n\n/*\n * send each non-row status column, one at a time\n */\nstatic int \n_row_status_state_single_value_cols(netsnmp_state_machine_input *input,\n                                    netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *var, *tmp_next, *row_status;\n    int                    rc = SNMPERR_GENERR;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    row_status = _get_vb_num(ctx->vars, ctx->row_status_index);\n    netsnmp_require_ptr_LRV(row_status, SNMPERR_GENERR);\n\n    /*\n     * try one varbind at a time\n     */\n    for (var = ctx->vars; var; var = var->next_variable) {\n        if (var == row_status)\n            continue;\n\n        tmp_next = var->next_variable;\n        var->next_variable = NULL;\n\n        /*\n         * send set\n         */\n        rc = netsnmp_query_set( var, ctx->session );\n        var->next_variable = tmp_next;\n        if (-2 == rc)\n            rc = SNMPERR_ABORT;\n        if (rc != SNMPERR_SUCCESS)\n            break;\n    }\n\n    return rc;\n}\n\n/*\n * send all values except row status\n */\nstatic int \n_row_status_state_multiple_values_cols(netsnmp_state_machine_input *input,\n                                       netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *vars, *var, *last, *row_status;\n    int                    rc;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    vars = snmp_clone_varbind(ctx->vars);\n    netsnmp_require_ptr_LRV(vars, SNMPERR_GENERR);\n\n    row_status = _get_vb_num(vars, ctx->row_status_index);\n    if (NULL == row_status) {\n        snmp_free_varbind(vars);\n        return SNMPERR_GENERR;\n    }\n\n    /*\n     * remove row status varbind\n     */\n    if (row_status == vars) {\n        vars = row_status->next_variable;\n        row_status->next_variable = NULL;\n    }\n    else {\n        for (last=vars, var=last->next_variable;\n             var;\n             last=var, var = var->next_variable) {\n            if (var == row_status) {\n                last->next_variable = var->next_variable;\n                break;\n            }\n        }\n    }\n    snmp_free_var(row_status);\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( vars, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(vars);\n\n    return rc;\n}\n\n/*\n * send a createAndWait request with no other values\n */\nstatic int \n_row_status_state_single_value_createAndWait(netsnmp_state_machine_input *input,\n                                             netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *var = NULL, *rs_var;\n    int32_t                rc, val = RS_CREATEANDWAIT;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    rs_var = _get_vb_num(ctx->vars, ctx->row_status_index);\n    netsnmp_require_ptr_LRV(rs_var, SNMPERR_GENERR);\n\n    var = snmp_varlist_add_variable(&var, rs_var->name, rs_var->name_length,\n                                    rs_var->type, &val, sizeof(val));\n    netsnmp_require_ptr_LRV(var, SNMPERR_GENERR);\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( var, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(var);\n\n    return rc;\n}\n\n/*\n * send a creatAndWait request with all values\n */\nstatic int \n_row_status_state_all_values_createAndWait(netsnmp_state_machine_input *input,\n                                           netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *vars, *rs_var;\n    int                    rc;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    vars = snmp_clone_varbind(ctx->vars);\n    netsnmp_require_ptr_LRV(vars, SNMPERR_GENERR);\n\n    /*\n     * make sure row stats is createAndWait\n     */\n    rs_var = _get_vb_num(vars, ctx->row_status_index);\n    if (NULL == rs_var) {\n        snmp_free_varbind(vars);\n        return SNMPERR_GENERR;\n    }\n\n    if (*rs_var->val.integer != RS_CREATEANDWAIT)\n        *rs_var->val.integer = RS_CREATEANDWAIT;\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( vars, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(vars);\n\n    return rc;\n}\n\n\n/**\n * send createAndGo request with all values\n */\nstatic int \n_row_status_state_all_values_createAndGo(netsnmp_state_machine_input *input,\n                                         netsnmp_state_machine_step *step)\n{\n    rowcreate_state       *ctx;\n    netsnmp_variable_list *vars, *rs_var;\n    int                    rc;\n\n    netsnmp_require_ptr_LRV( input, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( step, SNMPERR_GENERR );\n    netsnmp_require_ptr_LRV( input->input_context, SNMPERR_GENERR );\n\n    ctx = (rowcreate_state *)input->input_context;\n\n    DEBUGMSGT((\"row_create:called\", \"called %s\\n\", step->name));\n\n    vars = snmp_clone_varbind(ctx->vars);\n    netsnmp_require_ptr_LRV(vars, SNMPERR_GENERR);\n\n    /*\n     * make sure row stats is createAndGo\n     */\n    rs_var = _get_vb_num(vars, ctx->row_status_index + 1);\n    if (NULL == rs_var) {\n        snmp_free_varbind(vars);\n        return SNMPERR_GENERR;\n    }\n\n    if (*rs_var->val.integer != RS_CREATEANDGO)\n        *rs_var->val.integer = RS_CREATEANDGO;\n\n    /*\n     * send set\n     */\n    rc = netsnmp_query_set( vars, ctx->session );\n    if (-2 == rc)\n        rc = SNMPERR_ABORT;\n\n    snmp_free_varbind(vars);\n\n    return rc;\n}\n\n/** **************************************************************************\n *\n * row api\n *\n */\nint\nnetsnmp_row_create(netsnmp_session *sess, netsnmp_variable_list *vars,\n                   int row_status_index)\n{\n    netsnmp_state_machine_step rc_cleanup =\n        { \"row_create_cleanup\", 0, _row_status_state_cleanup,\n          0, NULL, NULL, 0, NULL };\n    netsnmp_state_machine_step rc_activate =\n        { \"row_create_activate\", 0, _row_status_state_activate,\n          0, NULL, NULL, 0, NULL };\n    netsnmp_state_machine_step rc_sv_cols =\n        { \"row_create_single_value_cols\", 0,\n          _row_status_state_single_value_cols, 0, &rc_activate,NULL, 0, NULL };\n    netsnmp_state_machine_step rc_mv_cols =\n        { \"row_create_multiple_values_cols\", 0,\n          _row_status_state_multiple_values_cols, 0, &rc_activate, &rc_sv_cols,\n          0, NULL };\n    netsnmp_state_machine_step rc_sv_caw =\n        { \"row_create_single_value_createAndWait\", 0,\n          _row_status_state_single_value_createAndWait, 0, &rc_mv_cols, NULL,\n          0, NULL };\n    netsnmp_state_machine_step rc_av_caw =\n        { \"row_create_all_values_createAndWait\", 0,\n          _row_status_state_all_values_createAndWait, 0, &rc_activate,\n          &rc_sv_caw, 0, NULL };\n    netsnmp_state_machine_step rc_av_cag =\n        { \"row_create_all_values_createAndGo\", 0,\n          _row_status_state_all_values_createAndGo, 0, NULL, &rc_av_caw, 0,\n          NULL };\n\n    netsnmp_state_machine_input sm_input = { \"row_create_machine\", 0,\n                                             &rc_av_cag, &rc_cleanup };\n    rowcreate_state state;\n\n    netsnmp_require_ptr_LRV( sess, SNMPERR_GENERR);\n    netsnmp_require_ptr_LRV( vars, SNMPERR_GENERR);\n\n    state.session = sess;\n    state.vars = vars;\n\n    state.row_status_index = row_status_index;\n    sm_input.input_context = &state;\n\n    netsnmp_state_machine_run( &sm_input);\n\n    return SNMPERR_SUCCESS;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_ROW_CREATE */\n#endif /* NETSNMP_NO_WRITE_SUPPORT */\n\n\n/** @} */\n", "/* Portions of this file are subject to the following copyright(s).  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/*\n * Portions of this file are copyrighted by:\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n *\n * Portions of this file are copyrighted by:\n * Copyright (c) 2016 VMware, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n/*\n * snmpusm.c\n *\n * Routines to manipulate a information about a \"user\" as\n * defined by the SNMP-USER-BASED-SM-MIB MIB.\n *\n * All functions usm_set_usmStateReference_*() return 0 on success, -1\n * otherwise.\n *\n * !! Tab stops set to 4 in some parts of this file. !!\n *    (Designated on a per function.)\n */\n\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#include <sys/types.h>\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <net-snmp/types.h>\n#include <net-snmp/output_api.h>\n#include <net-snmp/config_api.h>\n#include <net-snmp/utilities.h>\n\n#include <net-snmp/library/asn1.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/callback.h>\n#include <net-snmp/library/tools.h>\n#include <net-snmp/library/keytools.h>\n#include <net-snmp/library/snmpv3.h>\n#include <net-snmp/library/lcd_time.h>\n#include <net-snmp/library/scapi.h>\n#include <net-snmp/library/callback.h>\n#include <net-snmp/library/snmp_secmod.h>\n#include <net-snmp/library/snmpusm.h>\n#include <net-snmp/library/transform_oids.h>\n#include <net-snmp/library/snmp_enum.h>\n\nnetsnmp_feature_child_of(usm_all, libnetsnmp)\nnetsnmp_feature_child_of(usm_support, usm_all)\n\nnetsnmp_feature_require(usm_support)\n\nstruct usmStateReference {\n    int             refcnt;\n    char           *usr_name;\n    size_t          usr_name_length;\n    u_char         *usr_engine_id;\n    size_t          usr_engine_id_length;\n    oid            *usr_auth_protocol;\n    size_t          usr_auth_protocol_length;\n    u_char         *usr_auth_key;\n    size_t          usr_auth_key_length;\n    oid            *usr_priv_protocol;\n    size_t          usr_priv_protocol_length;\n    u_char         *usr_priv_key;\n    size_t          usr_priv_key_length;\n    u_int           usr_sec_level;\n};\n\noid    usmNoAuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                 NETSNMP_USMAUTH_NOAUTH };\n#ifndef NETSNMP_DISABLE_MD5\noid    usmHMACMD5AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                      NETSNMP_USMAUTH_HMACMD5 };\n#endif\noid    usmHMACSHA1AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                       NETSNMP_USMAUTH_HMACSHA1 };\n\n#ifdef HAVE_EVP_SHA384\noid    usmHMAC384SHA512AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC384SHA512 };\noid    usmHMAC256SHA384AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC256SHA384 };\n#endif /* HAVE_EVP_SHA384 */\n\n#ifdef HAVE_EVP_SHA224\noid    usmHMAC192SHA256AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC192SHA256 };\noid    usmHMAC128SHA224AuthProtocol[10] = { NETSNMP_USMAUTH_BASE_OID,\n                                            NETSNMP_USMAUTH_HMAC128SHA224 };\n#endif /* HAVE_EVP_SHA384 */\n\noid             usmNoPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 1 };\n\n#ifndef NETSNMP_DISABLE_DES\noid             usmDESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 2 };\n#endif\n\n\noid    usmAESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 4 };\n/* backwards compat */\noid    *usmAES128PrivProtocol = usmAESPrivProtocol;\n\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n    /* OIDs from http://www.snmp.com/eso/esoConsortiumMIB.txt */\noid    usmAES192PrivProtocol[9] = { 1,3,6,1,4,1,14832,1,3 };\noid    usmAES256PrivProtocol[9] = { 1,3,6,1,4,1,14832,1,4 };\n    /* OIDs from CISCO MIB */\noid    usmAES192CiscoPrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,1 };\noid    usmAES256CiscoPrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,2 };\n/*\n * these OIDs are in pySNMP source as OIDs for AES+Reeder. We'll just\n * use OIDS from CISCO-SNMP-USM-OIDS-MIB\n *\noid    usmAES192Cisco2PrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,101 };\noid    usmAES256Cisco2PrivProtocol[11]  = { 1,3,6,1,4,1,9,12,6,1,102 };\n */\n#endif /* NETSNMP_DRAFT_BLUMENTHAL_AES_04 */\n\ntypedef struct usm_alg_type_s {\n    const char *label;\n    int         value;\n} usm_alg_type_t;\n\nstatic usm_alg_type_t usm_auth_type[] = {\n    { \"NOAUTH\", NETSNMP_USMAUTH_NOAUTH },\n    { \"SHA\", NETSNMP_USMAUTH_HMACSHA1 },\n    { \"SHA-1\", NETSNMP_USMAUTH_HMACSHA1 },\n    { \"SHA1\", NETSNMP_USMAUTH_HMACSHA1 },\n#ifndef NETSNMP_DISABLE_MD5\n    { \"MD5\", NETSNMP_USMAUTH_HMACMD5 },\n#endif\n#ifdef HAVE_EVP_SHA224\n    { \"SHA-224\", NETSNMP_USMAUTH_HMAC128SHA224 },\n    { \"SHA224\", NETSNMP_USMAUTH_HMAC128SHA224 },\n    { \"SHA-256\", NETSNMP_USMAUTH_HMAC192SHA256 },\n    { \"SHA256\", NETSNMP_USMAUTH_HMAC192SHA256 },\n#endif\n#ifdef HAVE_EVP_SHA384\n    { \"SHA-384\", NETSNMP_USMAUTH_HMAC256SHA384 },\n    { \"SHA384\", NETSNMP_USMAUTH_HMAC256SHA384 },\n    { \"SHA-512\",  NETSNMP_USMAUTH_HMAC384SHA512 },\n    { \"SHA512\",  NETSNMP_USMAUTH_HMAC384SHA512 },\n#endif\n    { NULL, -1 }\n};\n\nstatic usm_alg_type_t usm_priv_type[] = {\n    { \"NOPRIV\", USM_CREATE_USER_PRIV_NONE },\n#ifndef NETSNMP_DISABLE_DES\n    { \"DES\", USM_CREATE_USER_PRIV_DES },\n#endif\n#ifdef HAVE_AES\n    { \"AES\", USM_CREATE_USER_PRIV_AES },\n    { \"AES-128\", USM_CREATE_USER_PRIV_AES },\n    { \"AES128\", USM_CREATE_USER_PRIV_AES },\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n    { \"AES-192\", USM_CREATE_USER_PRIV_AES192 },\n    { \"AES192\", USM_CREATE_USER_PRIV_AES192 },\n    { \"AES-256\", USM_CREATE_USER_PRIV_AES256 },\n    { \"AES256\", USM_CREATE_USER_PRIV_AES256 },\n    /** cisco / pysnmp variations */\n    { \"AES-192-C\", USM_CREATE_USER_PRIV_AES192_CISCO },\n    { \"AES192C\", USM_CREATE_USER_PRIV_AES192_CISCO },\n    { \"AES-256-C\", USM_CREATE_USER_PRIV_AES256_CISCO },\n    { \"AES256C\", USM_CREATE_USER_PRIV_AES256_CISCO },\n#endif\n#endif\n    { NULL, -1 },\n};\n\nstatic u_int    dummy_etime, dummy_eboot;       /* For ISENGINEKNOWN(). */\n\n/*\n * Set up default snmpv3 parameter value storage.\n */\n#ifdef NETSNMP_SECMOD_USM\nstatic const oid *defaultAuthType = NULL;\nstatic size_t   defaultAuthTypeLen = 0;\nstatic const oid *defaultPrivType = NULL;\nstatic size_t   defaultPrivTypeLen = 0;\n#endif /* NETSNMP_SECMOD_USM */\n\n/*\n * Globals.\n */\nstatic u_int    salt_integer;\n#ifdef HAVE_AES\nstatic u_int    salt_integer64_1, salt_integer64_2;\n#endif\n        /*\n         * 1/2 of seed for the salt.   Cf. RFC2274, Sect 8.1.1.1.\n         */\n\nstatic struct usmUser *noNameUser = NULL;\n/*\n * Local storage (LCD) of the default user list.\n */\nstatic struct usmUser *userList = NULL;\n\n/*\n * Set a given field of the secStateRef.\n *\n * Allocate <len> bytes for type <type> pointed to by ref-><field>.\n * Then copy in <item> and record its length in ref-><field_len>.\n *\n * Return 0 on success, -1 otherwise.\n */\n#define MAKE_ENTRY(ref, type, item, len, field, field_len)              \\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (ref == NULL)\t\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\t\t\\\n\tif (ref->field != NULL)\t{\t\t\t\t\t\\\n\t\tSNMP_ZERO(ref->field, ref->field_len);\t\t\t\\\n\t\tSNMP_FREE(ref->field);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tref->field_len = 0;\t\t\t\t\t\t\\\n        if (len == 0 || item == NULL) {\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t \t\t\t\\\n\tif ((ref->field = (type*) malloc (len * sizeof(type))) == NULL)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmemcpy (ref->field, item, len * sizeof(type));\t\t\t\\\n\tref->field_len = len;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nstatic int\nfree_enginetime_on_shutdown(int majorid, int minorid, void *serverarg,\n\t\t\t    void *clientarg)\n{\n    u_char engineID[SNMP_MAX_ENG_SIZE];\n    size_t engineID_len = sizeof(engineID);\n\n    DEBUGMSGTL((\"snmpv3\", \"free enginetime callback called\\n\"));\n\n    engineID_len = snmpv3_get_engineID(engineID, engineID_len);\n    if (engineID_len > 0)\n\tfree_enginetime(engineID, engineID_len);\n    return 0;\n}\n\nstatic struct usmStateReference *\nusm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval;\n\n    retval = calloc(1, sizeof(struct usmStateReference));\n    if (retval)\n        retval->refcnt = 1;\n\n    return retval;\n}                               /* end usm_malloc_usmStateReference() */\n\nstatic int\nusm_clone(netsnmp_pdu *pdu, netsnmp_pdu *new_pdu)\n{\n    struct usmStateReference *ref = pdu->securityStateRef;\n    struct usmStateReference **new_ref =\n        (struct usmStateReference **)&new_pdu->securityStateRef;\n    int ret = 0;\n\n    if (!ref)\n        return ret;\n\n    if (pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference(ref, new_ref);\n    } else {\n        netsnmp_assert(ref == *new_ref);\n        ref->refcnt++;\n    }\n\n    return ret;\n}\n\nstatic void\nusm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *ref = old;\n\n    if (!ref)\n        return;\n\n    if (--ref->refcnt > 0)\n        return;\n\n    SNMP_FREE(ref->usr_name);\n    SNMP_FREE(ref->usr_engine_id);\n    SNMP_FREE(ref->usr_auth_protocol);\n    SNMP_FREE(ref->usr_priv_protocol);\n\n    if (ref->usr_auth_key_length && ref->usr_auth_key) {\n        SNMP_ZERO(ref->usr_auth_key, ref->usr_auth_key_length);\n        SNMP_FREE(ref->usr_auth_key);\n    }\n    if (ref->usr_priv_key_length && ref->usr_priv_key) {\n        SNMP_ZERO(ref->usr_priv_key, ref->usr_priv_key_length);\n        SNMP_FREE(ref->usr_priv_key);\n    }\n\n    SNMP_FREE(ref);\n}                               /* end usm_free_usmStateReference() */\n\nstruct usmUser *\nusm_get_userList(void)\n{\n    return userList;\n}\n\nstatic int\nusm_set_usmStateReference_name(struct usmStateReference *ref,\n                               char *name, size_t name_len)\n{\n    MAKE_ENTRY(ref, char, name, name_len, usr_name, usr_name_length);\n}\n\nstatic int\nusm_set_usmStateReference_engine_id(struct usmStateReference *ref,\n                                    u_char * engine_id,\n                                    size_t engine_id_len)\n{\n    MAKE_ENTRY(ref, u_char, engine_id, engine_id_len,\n               usr_engine_id, usr_engine_id_length);\n}\n\nstatic int\nusm_set_usmStateReference_auth_protocol(struct usmStateReference *ref,\n                                        oid * auth_protocol,\n                                        size_t auth_protocol_len)\n{\n    MAKE_ENTRY(ref, oid, auth_protocol, auth_protocol_len,\n               usr_auth_protocol, usr_auth_protocol_length);\n}\n\nstatic int\nusm_set_usmStateReference_auth_key(struct usmStateReference *ref,\n                                   u_char * auth_key, size_t auth_key_len)\n{\n    MAKE_ENTRY(ref, u_char, auth_key, auth_key_len,\n               usr_auth_key, usr_auth_key_length);\n}\n\nstatic int\nusm_set_usmStateReference_priv_protocol(struct usmStateReference *ref,\n                                        oid * priv_protocol,\n                                        size_t priv_protocol_len)\n{\n    MAKE_ENTRY(ref, oid, priv_protocol, priv_protocol_len,\n               usr_priv_protocol, usr_priv_protocol_length);\n}\n\nstatic int\nusm_set_usmStateReference_priv_key(struct usmStateReference *ref,\n                                   u_char * priv_key, size_t priv_key_len)\n{\n    MAKE_ENTRY(ref, u_char, priv_key, priv_key_len,\n               usr_priv_key, usr_priv_key_length);\n}\n\nstatic int\nusm_set_usmStateReference_sec_level(struct usmStateReference *ref,\n                                    int sec_level)\n{\n    if (ref == NULL)\n        return -1;\n    ref->usr_sec_level = sec_level;\n    return 0;\n}\n\nint\nusm_clone_usmStateReference(struct usmStateReference *from, struct usmStateReference **to)\n{\n    struct usmStateReference *cloned_usmStateRef;\n\n    if (from == NULL || to == NULL)\n        return -1;\n\n    *to = usm_malloc_usmStateReference();\n    cloned_usmStateRef = *to;\n\n    if (usm_set_usmStateReference_name(cloned_usmStateRef, from->usr_name, from->usr_name_length) ||\n        usm_set_usmStateReference_engine_id(cloned_usmStateRef, from->usr_engine_id, from->usr_engine_id_length) ||\n        usm_set_usmStateReference_auth_protocol(cloned_usmStateRef, from->usr_auth_protocol, from->usr_auth_protocol_length) ||\n        usm_set_usmStateReference_auth_key(cloned_usmStateRef, from->usr_auth_key, from->usr_auth_key_length) ||\n        usm_set_usmStateReference_priv_protocol(cloned_usmStateRef, from->usr_priv_protocol, from->usr_priv_protocol_length) ||\n        usm_set_usmStateReference_priv_key(cloned_usmStateRef, from->usr_priv_key, from->usr_priv_key_length) ||\n        usm_set_usmStateReference_sec_level(cloned_usmStateRef, from->usr_sec_level))\n    {\n        usm_free_usmStateReference(*to);\n        *to = NULL;\n        return -1;\n    }\n\n    return 0;\n\n}\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n/*******************************************************************-o-******\n * emergency_print\n *\n * Parameters:\n *\t*field\n *\t length\n *      \n *\tThis is a print routine that is solely included so that it can be\n *\tused in gdb.  Don't use it as a function, it will be pulled before\n *\ta real release of the code.\n *\n *\ttab stop 4\n *\n *\tXXX fflush() only works on FreeBSD; core dumps on Sun OS's\n */\nvoid\nemergency_print(u_char * field, u_int length)\n{\n    int             iindex;\n    int             start = 0;\n    int             stop = 25;\n\n    while (start < stop) {\n        for (iindex = start; iindex < stop; iindex++)\n            printf(\"%02X \", field[iindex]);\n\n        printf(\"\\n\");\n        start = stop;\n        stop = stop + 25 < length ? stop + 25 : length;\n    }\n    fflush(0);\n\n}                               /* end emergency_print() */\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n\nstatic struct usmUser *\nusm_get_user_from_list(u_char * engineID, size_t engineIDLen,\n                       char *name, struct usmUser *puserList,\n                       int use_default)\n{\n    struct usmUser *ptr;\n    char            noName[] = \"\";\n    if (name == NULL)\n        name = noName;\n    for (ptr = puserList; ptr != NULL; ptr = ptr->next) {\n        if (ptr->name && !strcmp(ptr->name, name)) {\n          DEBUGMSGTL((\"usm\", \"match on user %s\\n\", ptr->name));\n          if (ptr->engineIDLen == engineIDLen &&\n            ((ptr->engineID == NULL && engineID == NULL) ||\n             (ptr->engineID != NULL && engineID != NULL &&\n              memcmp(ptr->engineID, engineID, engineIDLen) == 0)))\n            return ptr;\n          DEBUGMSGTL((\"usm\", \"no match on engineID (\"));\n          if (engineID) {\n              DEBUGMSGHEX((\"usm\", engineID, engineIDLen));\n          } else {\n              DEBUGMSGTL((\"usm\", \"Empty EngineID\"));\n          }\n          DEBUGMSG((\"usm\", \")\\n\"));\n        }\n    }\n\n    /*\n     * return \"\" user used to facilitate engineID discovery\n     */\n    if (use_default && !strcmp(name, \"\"))\n        return noNameUser;\n    return NULL;\n}\n\n/*\n * usm_get_user(): Returns a user from userList based on the engineID,\n * engineIDLen and name of the requested user.\n */\nstruct usmUser *\nusm_get_user(u_char * engineID, size_t engineIDLen, char *name)\n{\n    DEBUGMSGTL((\"usm\", \"getting user %s\\n\", name));\n    return usm_get_user_from_list(engineID, engineIDLen, name, userList,\n                                  1);\n}\n\nstatic struct usmUser *\nusm_add_user_to_list(struct usmUser *user, struct usmUser *puserList)\n{\n    struct usmUser *nptr, *pptr, *optr;\n\n    /*\n     * loop through puserList till we find the proper, sorted place to\n     * insert the new user\n     */\n    /* XXX - how to handle a NULL user->name ?? */\n    /* XXX - similarly for a NULL nptr->name ?? */\n    for (nptr = puserList, pptr = NULL; nptr != NULL;\n         pptr = nptr, nptr = nptr->next) {\n        if (nptr->engineIDLen > user->engineIDLen)\n            break;\n\n        if (user->engineID == NULL && nptr->engineID != NULL)\n            break;\n\n        if (nptr->engineIDLen == user->engineIDLen &&\n            (nptr->engineID != NULL && user->engineID != NULL &&\n             memcmp(nptr->engineID, user->engineID,\n                    user->engineIDLen) > 0))\n            break;\n\n        if (!(nptr->engineID == NULL && user->engineID != NULL)) {\n            if (nptr->engineIDLen == user->engineIDLen &&\n                ((nptr->engineID == NULL && user->engineID == NULL) ||\n                 memcmp(nptr->engineID, user->engineID,\n                        user->engineIDLen) == 0)\n                && strlen(nptr->name) > strlen(user->name))\n                break;\n\n            if (nptr->engineIDLen == user->engineIDLen &&\n                ((nptr->engineID == NULL && user->engineID == NULL) ||\n                 memcmp(nptr->engineID, user->engineID,\n                        user->engineIDLen) == 0)\n                && strlen(nptr->name) == strlen(user->name)\n                && strcmp(nptr->name, user->name) > 0)\n                break;\n\n            if (nptr->engineIDLen == user->engineIDLen &&\n                ((nptr->engineID == NULL && user->engineID == NULL) ||\n                 memcmp(nptr->engineID, user->engineID,\n                        user->engineIDLen) == 0)\n                && strlen(nptr->name) == strlen(user->name)\n                && strcmp(nptr->name, user->name) == 0) {\n                /*\n                 * the user is an exact match of a previous entry.\n                 * Credentials may be different, though, so remove\n                 * the old entry (and add the new one)!\n                 */\n                if (pptr) { /* change prev's next pointer */\n                  pptr->next = nptr->next;\n                }\n                if (nptr->next) { /* change next's prev pointer */\n                  nptr->next->prev = pptr;\n                }\n                optr = nptr;\n                nptr = optr->next; /* add new user at this position */\n                /* free the old user */\n                optr->next=NULL;\n                optr->prev=NULL;\n                usm_free_user(optr);\n                break; /* new user will be added below */\n            }\n        }\n    }\n\n    /*\n     * nptr should now point to the user that we need to add ourselves\n     * in front of, and pptr should be our new 'prev'.\n     */\n\n    /*\n     * change our pointers\n     */\n    user->prev = pptr;\n    user->next = nptr;\n\n    /*\n     * change the next's prev pointer\n     */\n    if (user->next)\n        user->next->prev = user;\n\n    /*\n     * change the prev's next pointer\n     */\n    if (user->prev)\n        user->prev->next = user;\n\n    /*\n     * rewind to the head of the list and return it (since the new head\n     * could be us, we need to notify the above routine who the head now is.\n     */\n    for (pptr = user; pptr->prev != NULL; pptr = pptr->prev);\n    return pptr;\n}\n\n/*\n * usm_add_user(): Add's a user to the userList, sorted by the\n * engineIDLength then the engineID then the name length then the name\n * to facilitate getNext calls on a usmUser table which is indexed by\n * these values.\n *\n * returns the head of the list (which could change due to this add).\n */\n\nstruct usmUser *\nusm_add_user(struct usmUser *user)\n{\n    struct usmUser *uptr;\n    uptr = usm_add_user_to_list(user, userList);\n    if (uptr != NULL)\n        userList = uptr;\n    return uptr;\n}\n\n/*\n * usm_remove_usmUser_from_list remove user from (optional) list\n *\n * if list is not specified, defaults to global userList.\n *\n * returns SNMPERR_SUCCESS or SNMPERR_USM_UNKNOWNSECURITYNAME\n */\nstatic int\nusm_remove_usmUser_from_list(struct usmUser *user, struct usmUser **ppuserList)\n{\n    struct usmUser *nptr, *pptr;\n\n    /*\n     * NULL pointers aren't allowed\n     */\n    if (ppuserList == NULL)\n        ppuserList = &userList;\n\n    if (*ppuserList == NULL)\n        return SNMPERR_USM_UNKNOWNSECURITYNAME;\n\n    /*\n     * find the user in the list\n     */\n    for (nptr = *ppuserList, pptr = NULL; nptr != NULL;\n         pptr = nptr, nptr = nptr->next) {\n        if (nptr == user)\n            break;\n    }\n\n    if (nptr) {\n        /*\n         * remove the user from the linked list\n         */\n        if (pptr) {\n            pptr->next = nptr->next;\n        }\n        if (nptr->next) {\n            nptr->next->prev = pptr;\n        }\n    } else {\n        /*\n         * user didn't exist\n         */\n        return SNMPERR_USM_UNKNOWNSECURITYNAME;\n    }\n    if (nptr == *ppuserList)    /* we're the head of the list, need to change\n                                 * * the head to the next user */\n        *ppuserList = nptr->next;\n    return SNMPERR_SUCCESS;\n}                               /* end usm_remove_usmUser_from_list() */\n\n/*\n * usm_remove_user_from_list\n *\n * removes user from list.\n *\n * returns new list head on success, or NULL on error.\n *\n * NOTE: if there was only one user in the list, list head will be NULL.\n *       So NULL can also mean success. Use the newer usm_remove_usmUser() for\n *       more specific return codes. This function is kept for backwards\n *       compatability with this ambiguous behaviour.\n */\nstatic struct usmUser *\nusm_remove_user_from_list(struct usmUser *user,\n                          struct usmUser **ppuserList)\n{\n    int rc = usm_remove_usmUser_from_list(user, ppuserList);\n    if (rc != SNMPERR_SUCCESS || NULL == ppuserList)\n        return NULL;\n\n    return *ppuserList;\n}                               /* end usm_remove_user_from_list() */\n\n/*\n * usm_remove_user(): finds and removes a user from a list\n */\nstruct usmUser *\nusm_remove_user(struct usmUser *user)\n{\n    return usm_remove_user_from_list(user, &userList);\n}\n\n/*\n * usm_free_user():  calls free() on all needed parts of struct usmUser and\n * the user himself.\n *\n * Note: This should *not* be called on an object in a list (IE,\n * remove it from the list first, and set next and prev to NULL), but\n * will try to reconnect the list pieces again if it is called this\n * way.  If called on the head of the list, the entire list will be\n * lost.\n */\nstruct usmUser *\nusm_free_user(struct usmUser *user)\n{\n    if (user == NULL)\n        return NULL;\n\n    SNMP_FREE(user->engineID);\n    SNMP_FREE(user->name);\n    SNMP_FREE(user->secName);\n    SNMP_FREE(user->cloneFrom);\n    SNMP_FREE(user->userPublicString);\n    SNMP_FREE(user->authProtocol);\n    SNMP_FREE(user->privProtocol);\n\n    if (user->authKey != NULL) {\n        SNMP_ZERO(user->authKey, user->authKeyLen);\n        SNMP_FREE(user->authKey);\n    }\n\n    if (user->privKey != NULL) {\n        SNMP_ZERO(user->privKey, user->privKeyLen);\n        SNMP_FREE(user->privKey);\n    }\n\n    if (user->authKeyKu != NULL) {\n        SNMP_ZERO(user->authKeyKu, user->authKeyKuLen);\n        SNMP_FREE(user->authKeyKu);\n    }\n\n    if (user->privKeyKu != NULL) {\n        SNMP_ZERO(user->privKeyKu, user->privKeyKuLen);\n        SNMP_FREE(user->privKeyKu);\n    }\n\n\n    /*\n     * FIX  Why not put this check *first?*\n     */\n    if (user->prev != NULL) {   /* ack, this shouldn't happen */\n        user->prev->next = user->next;\n    }\n    if (user->next != NULL) {\n        user->next->prev = user->prev;\n        if (user->prev != NULL) /* ack this is really bad, because it means\n                                 * * we'll loose the head of some structure tree */\n            DEBUGMSGTL((\"usm\",\n                        \"Severe: Asked to free the head of a usmUser tree somewhere.\"));\n    }\n\n\n    SNMP_ZERO(user, sizeof(*user));\n    SNMP_FREE(user);\n\n    return NULL;                /* for convenience to returns from calling functions */\n\n}                               /* end usm_free_user() */\n\n/*******************************************************************-o-******\n * asn_predict_int_length\n *\n * Parameters:\n *\ttype\t(UNUSED)\n *\tnumber\n *\tlen\n *      \n * Returns:\n *\tNumber of bytes necessary to store the ASN.1 encoded value of 'number'.\n *\n *\n *\tThis gives the number of bytes that the ASN.1 encoder (in asn1.c) will\n *\tuse to encode a particular integer value.\n *\n *\tReturns the length of the integer -- NOT THE HEADER!\n *\n *\tDo this the same way as asn_build_int()...\n */\nstatic int\nasn_predict_int_length(int type, long number, size_t len)\n{\n    register u_long mask;\n\n\n    if (len != sizeof(long))\n        return -1;\n\n    mask = ((u_long) 0x1FF) << ((8 * (sizeof(long) - 1)) - 1);\n    /*\n     * mask is 0xFF800000 on a big-endian machine \n     */\n\n    while ((((number & mask) == 0) || ((number & mask) == mask))\n           && len > 1) {\n        len--;\n        number <<= 8;\n    }\n\n    return len;\n\n}                               /* end asn_predict_length() */\n\n/*******************************************************************-o-******\n * asn_predict_length\n *\n * Parameters:\n *\t type\n *\t*ptr\n *\t u_char_len\n *      \n * Returns:\n *\tLength in bytes:\t1 + <n> + <u_char_len>, where\n *\n *\t\t1\t\tFor the ASN.1 type.\n *\t\t<n>\t\t# of bytes to store length of data.\n *\t\t<u_char_len>\tLength of data associated with ASN.1 type.\n *\n *\tThis gives the number of bytes that the ASN.1 encoder (in asn1.c) will\n *\tuse to encode a particular integer value.  This is as broken as the\n *\tcurrently used encoder.\n *\n * XXX\tHow is <n> chosen, exactly??\n */\nstatic int\nasn_predict_length(int type, u_char * ptr, size_t u_char_len)\n{\n\n    if (type & ASN_SEQUENCE)\n        return 1 + 3 + u_char_len;\n\n    if (type & ASN_INTEGER) {\n        u_long          value;\n        memcpy(&value, ptr, u_char_len);\n        u_char_len = asn_predict_int_length(type, value, u_char_len);\n    }\n\n    if (u_char_len < 0x80)\n        return 1 + 1 + u_char_len;\n    else if (u_char_len < 0xFF)\n        return 1 + 2 + u_char_len;\n    else\n        return 1 + 3 + u_char_len;\n\n}                               /* end asn_predict_length() */\n\n/*******************************************************************-o-******\n * usm_calc_offsets\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\n *\tThis routine calculates the offsets into an outgoing message buffer\n *\tfor the necessary values.  The outgoing buffer will generically\n *\tlook like this:\n *\n *\tSNMPv3 Message\n *\tSEQ len[11]\n *\t\tINT len version\n *\tHeader\n *\t\tSEQ len\n *\t\t\tINT len MsgID\n *\t\t\tINT len msgMaxSize\n *\t\t\tOST len msgFlags (OST = OCTET STRING)\n *\t\t\tINT len msgSecurityModel\n *\tMsgSecurityParameters\n *\t\t[1] OST len[2]\n *\t\t\tSEQ len[3]\n *\t\t\t\tOST len msgAuthoritativeEngineID\n *\t\t\t\tINT len msgAuthoritativeEngineBoots\n *\t\t\t\tINT len msgAuthoritativeEngineTime\n *\t\t\t\tOST len msgUserName\n *\t\t\t\tOST len[4] [5] msgAuthenticationParameters\n *\t\t\t\tOST len[6] [7] msgPrivacyParameters\n *\tMsgData\n *\t\t[8] OST len[9] [10] encryptedPDU\n *\t\tor\n *\t\t[8,10] SEQUENCE len[9] scopedPDU\n *\t[12]\n *\n *\tThe bracketed points will be needed to be identified ([x] is an index\n *\tvalue, len[x] means a length value).  Here is a semantic guide to them:\n *\n *\t[1] = globalDataLen (input)\n *\t[2] = otstlen\n *\t[3] = seq_len\n *\t[4] = msgAuthParmLen (may be 0 or 12)\n *\t[5] = authParamsOffset\n *\t[6] = msgPrivParmLen (may be 0 or 8)\n *\t[7] = privParamsOffset\n *\t[8] = globalDataLen + msgSecParmLen\n *\t[9] = datalen\n *\t[10] = dataOffset\n *\t[11] = theTotalLength - the length of the header itself\n *\t[12] = theTotalLength\n */\nstatic int\nusm_calc_offsets(size_t globalDataLen,  /* SNMPv3Message + HeaderData */\n                 int secLevel, size_t secEngineIDLen, size_t secNameLen, size_t scopedPduLen,   /* An BER encoded sequence. */\n                 u_long engineboots,    /* XXX (asn1.c works in long, not int.) */\n                 long engine_time,      /* XXX (asn1.c works in long, not int.) */\n                 size_t * theTotalLength,       /* globalDataLen + msgSecurityP. + msgData */\n                 size_t * authParamsOffset,     /* Distance to auth bytes.                 */\n                 size_t * privParamsOffset,     /* Distance to priv bytes.                 */\n                 size_t * dataOffset,   /* Distance to scopedPdu SEQ  -or-  the\n                                         *   crypted (data) portion of msgData.    */\n                 size_t * datalen,      /* Size of msgData OCTET STRING encoding.  */\n                 size_t * msgAuthParmLen,       /* Size of msgAuthenticationParameters.    */\n                 size_t * msgPrivParmLen,       /* Size of msgPrivacyParameters.           */\n                 size_t * otstlen,      /* Size of msgSecurityP. O.S. encoding.    */\n                 size_t * seq_len,      /* Size of msgSecurityP. SEQ data.         */\n                 size_t * msgSecParmLen)\n{                               /* Size of msgSecurityP. SEQ.              */\n    int             engIDlen,   /* Sizes of OCTET STRING and SEQ encodings */\n                    engBtlen,   /*   for fields within                     */\n                    engTmlen,   /*   msgSecurityParameters portion of      */\n                    namelen,    /*   SNMPv3Message.                        */\n                    authlen, privlen, ret;\n\n    /*\n     * If doing authentication, msgAuthParmLen = 12 else msgAuthParmLen = 0.\n     * If doing encryption,     msgPrivParmLen = 8  else msgPrivParmLen = 0.\n     */\n    *msgAuthParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n                       || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 12 : 0;\n\n    *msgPrivParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 8 : 0;\n\n\n    /*\n     * Calculate lengths.\n     */\n    if ((engIDlen = asn_predict_length(ASN_OCTET_STR,\n                                       NULL, secEngineIDLen)) == -1) {\n        return -1;\n    }\n\n    if ((engBtlen = asn_predict_length(ASN_INTEGER,\n                                       (u_char *) & engineboots,\n                                       sizeof(long))) == -1) {\n        return -1;\n    }\n\n    if ((engTmlen = asn_predict_length(ASN_INTEGER,\n                                       (u_char *) & engine_time,\n                                       sizeof(long))) == -1) {\n        return -1;\n    }\n\n    if ((namelen = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, secNameLen)) == -1) {\n        return -1;\n    }\n\n    if ((authlen = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, *msgAuthParmLen)) == -1) {\n        return -1;\n    }\n\n    if ((privlen = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, *msgPrivParmLen)) == -1) {\n        return -1;\n    }\n\n    *seq_len =\n        engIDlen + engBtlen + engTmlen + namelen + authlen + privlen;\n\n    if ((ret = asn_predict_length(ASN_SEQUENCE,\n                                      NULL, *seq_len)) == -1) {\n        return -1;\n    }\n    *otstlen = (size_t)ret;\n\n    if ((ret = asn_predict_length(ASN_OCTET_STR,\n                                      NULL, *otstlen)) == -1) {\n        return -1;\n    }\n    *msgSecParmLen = (size_t)ret;\n\n    *authParamsOffset = globalDataLen + +(*msgSecParmLen - *seq_len)\n        + engIDlen + engBtlen + engTmlen + namelen\n        + (authlen - *msgAuthParmLen);\n\n    *privParamsOffset = *authParamsOffset + *msgAuthParmLen\n        + (privlen - *msgPrivParmLen);\n\n\n    /*\n     * Compute the size of the plaintext.  Round up to account for cipher\n     * block size, if necessary.\n     *\n     * XXX  This is hardwired for 1DES... If scopedPduLen is already\n     *      a multiple of 8, then *add* 8 more; otherwise, round up\n     *      to the next multiple of 8.\n     *\n     * FIX  Calculation of encrypted portion of msgData and consequent\n     *      setting and sanity checking of theTotalLength, et al. should\n     *      occur *after* encryption has taken place.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        scopedPduLen = ROUNDUP8(scopedPduLen);\n\n        if ((ret = asn_predict_length(ASN_OCTET_STR, NULL, scopedPduLen)) == -1) {\n            return -1;\n        }\n        *datalen = (size_t)ret;\n    } else {\n        *datalen = scopedPduLen;\n    }\n\n    *dataOffset = globalDataLen + *msgSecParmLen +\n        (*datalen - scopedPduLen);\n    *theTotalLength = globalDataLen + *msgSecParmLen + *datalen;\n\n    return 0;\n\n}                               /* end usm_calc_offsets() */\n\n#ifndef NETSNMP_DISABLE_DES\n/*******************************************************************-o-******\n * usm_set_salt\n *\n * Parameters:\n *\t*iv\t\t  (O)   Buffer to contain IV.\n *\t*iv_length\t  (O)   Length of iv.\n *\t*priv_salt\t  (I)   Salt portion of private key.\n *\t priv_salt_length (I)   Length of priv_salt.\n *\t*msgSalt\t  (I/O) Pointer salt portion of outgoing msg buffer.\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\tDetermine the initialization vector for the DES-CBC encryption.\n *\t(Cf. RFC 2274, 8.1.1.1.)\n *\n *\tiv is defined as the concatenation of engineBoots and the\n *\t\tsalt integer.\n *\tThe salt integer is incremented.\n *\tThe resulting salt is copied into the msgSalt buffer.\n *\tThe result of the concatenation is then XORed with the salt\n *\t\tportion of the private key (last 8 bytes).\n *\tThe IV result is returned individually for further use.\n */\nstatic int\nusm_set_salt(u_char * iv,\n             size_t * iv_length,\n             u_char * priv_salt, size_t priv_salt_length, u_char * msgSalt)\n{\n    size_t          propersize_salt = BYTESIZE(USM_DES_SALT_LENGTH);\n    int             net_boots;\n    int             net_salt_int;\n    /*\n     * net_* should be encoded in network byte order.  XXX  Why?\n     */\n    int             iindex;\n\n\n    /*\n     * Sanity check.\n     */\n    if (!iv || !iv_length || !priv_salt || (*iv_length != propersize_salt)\n        || (priv_salt_length < propersize_salt)) {\n        return -1;\n    }\n\n\n    net_boots = htonl(snmpv3_local_snmpEngineBoots());\n    net_salt_int = htonl(salt_integer);\n\n    salt_integer += 1;\n\n    memcpy(iv, &net_boots, propersize_salt / 2);\n    memcpy(iv + (propersize_salt / 2), &net_salt_int, propersize_salt / 2);\n\n    if (msgSalt)\n        memcpy(msgSalt, iv, propersize_salt);\n\n\n    /*\n     * Turn the salt into an IV: XOR <boots, salt_int> with salt\n     * portion of priv_key.\n     */\n    for (iindex = 0; iindex < (int) propersize_salt; iindex++)\n        iv[iindex] ^= priv_salt[iindex];\n\n\n    return 0;\n\n}                               /* end usm_set_salt() */\n#endif\n\n#ifdef HAVE_AES\n/*******************************************************************-o-******\n * usm_set_aes_iv\n *\n * Parameters:\n *\t*iv\t\t  (O)   Buffer to contain IV.\n *\t*iv_length\t  (O)   Length of iv.\n *      net_boots         (I)   the network byte order of the authEng boots val\n *      net_time         (I)   the network byte order of the authEng time val\n *      *salt             (O)   A buffer for the outgoing salt (= 8 bytes of iv)\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\tDetermine the initialization vector for AES encryption.\n *\t(draft-blumenthal-aes-usm-03.txt, 3.1.2.2)\n *\n *\tiv is defined as the concatenation of engineBoots, engineTime\n  \tand a 64 bit salt-integer.\n *\tThe 64 bit salt integer is incremented.\n *\tThe resulting salt is copied into the salt buffer.\n *\tThe IV result is returned individually for further use.\n */\nstatic int\nusm_set_aes_iv(u_char * iv,\n               size_t * iv_length,\n               u_int net_boots,\n               u_int net_time,\n               u_char * salt)\n{\n    /*\n     * net_* should be encoded in network byte order.\n     */\n    int             net_salt_int1, net_salt_int2;\n#define PROPER_AES_IV_SIZE 64\n\n    /*\n     * Sanity check.\n     */\n    if (!iv || !iv_length) {\n        return -1;\n    }\n\n    net_salt_int1 = htonl(salt_integer64_1);\n    net_salt_int2 = htonl(salt_integer64_2);\n\n    if ((salt_integer64_2 += 1) == 0)\n        salt_integer64_2 += 1;\n    \n    /* XXX: warning: hard coded proper lengths */\n    memcpy(iv, &net_boots, 4);\n    memcpy(iv+4, &net_time, 4);\n    memcpy(iv+8, &net_salt_int1, 4);\n    memcpy(iv+12, &net_salt_int2, 4);\n\n    memcpy(salt, iv+8, 8); /* only copy the needed portion */\n    return 0;\n}                               /* end usm_set_aes_iv() */\n#endif /* HAVE_AES */\n\n/*******************************************************************-o-******\n * usm_check_secLevel_vs_protocols\n *\n * Parameters:\n *\t level\n *\t*authProtocol\n *\t authProtocolLen\n *\t*privProtocol\n *\t privProtocolLen\n *\n * Returns:\n *\t0\tOn success,\n *\t1\tOtherwise.\n *\n * Same as above but with explicitly named transform types instead of taking\n * from the usmUser structure.\n */\nstatic int\nusm_check_secLevel_vs_protocols(int level,\n                                const oid * authProtocol,\n                                u_int authProtocolLen,\n                                const oid * privProtocol,\n                                u_int privProtocolLen)\n{\n\n    if (level == SNMP_SEC_LEVEL_AUTHPRIV\n        &&\n        (netsnmp_oid_equals\n         (privProtocol, privProtocolLen, usmNoPrivProtocol,\n          sizeof(usmNoPrivProtocol) / sizeof(oid)) == 0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"Auth Protocol: \"));\n        DEBUGMSGOID((\"usm\", authProtocol, authProtocolLen));\n        DEBUGMSG((\"usm\", \", Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", privProtocol, privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n    if ((level == SNMP_SEC_LEVEL_AUTHPRIV\n         || level == SNMP_SEC_LEVEL_AUTHNOPRIV)\n        &&\n        (netsnmp_oid_equals\n         (authProtocol, authProtocolLen, usmNoAuthProtocol,\n          sizeof(usmNoAuthProtocol) / sizeof(oid)) == 0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"Auth Protocol: \"));\n        DEBUGMSGOID((\"usm\", authProtocol, authProtocolLen));\n        DEBUGMSG((\"usm\", \", Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", privProtocol, privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n\n    return 0;\n\n}                               /* end usm_check_secLevel_vs_protocols() */\n\n/*******************************************************************-o-******\n * usm_generate_out_msg\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\tSNMPERR_SUCCESS\t\t\tOn success.\n *\tSNMPERR_USM_AUTHENTICATIONFAILURE\n *\tSNMPERR_USM_ENCRYPTIONERROR\n *\tSNMPERR_USM_GENERICERROR\n *\tSNMPERR_USM_UNKNOWNSECURITYNAME\n *\tSNMPERR_USM_GENERICERROR\n *\tSNMPERR_USM_UNSUPPORTEDSECURITYLEVEL\n *\t\n *\n * Generates an outgoing message.\n *\n * XXX\tBeware of misnomers!\n */\nstatic int\nusm_generate_out_msg(int msgProcModel,  /* (UNUSED) */\n                     u_char * globalData,       /* IN */\n                     /*\n                      * Pointer to msg header data will point to the beginning\n                      * * of the entire packet buffer to be transmitted on wire,\n                      * * memory will be contiguous with secParams, typically\n                      * * this pointer will be passed back as beginning of\n                      * * wholeMsg below.  asn seq. length is updated w/ new length.\n                      * *\n                      * * While this points to a buffer that should be big enough\n                      * * for the whole message, only the first two parts\n                      * * of the message are completed, namely SNMPv3Message and\n                      * * HeaderData.  globalDataLen (next parameter) represents\n                      * * the length of these two completed parts.\n                      */\n                     size_t globalDataLen,      /* IN - Length of msg header data.      */\n                     int maxMsgSize,    /* (UNUSED) */\n                     int secModel,      /* (UNUSED) */\n                     u_char * secEngineID,      /* IN - Pointer snmpEngineID.           */\n                     size_t secEngineIDLen,     /* IN - SnmpEngineID length.            */\n                     char *secName,     /* IN - Pointer to securityName.        */\n                     size_t secNameLen, /* IN - SecurityName length.            */\n                     int secLevel,      /* IN - AuthNoPriv, authPriv etc.       */\n                     u_char * scopedPdu,        /* IN */\n                     /*\n                      * Pointer to scopedPdu will be encrypted by USM if needed\n                      * * and written to packet buffer immediately following\n                      * * securityParameters, entire msg will be authenticated by\n                      * * USM if needed.\n                      */\n                     size_t scopedPduLen,       /* IN - scopedPdu length. */\n                     void *secStateRef, /* IN */\n                     /*\n                      * secStateRef, pointer to cached info provided only for\n                      * * Response, otherwise NULL.\n                      */\n                     u_char * secParams,        /* OUT */\n                     /*\n                      * BER encoded securityParameters pointer to offset within\n                      * * packet buffer where secParams should be written, the\n                      * * entire BER encoded OCTET STRING (including header) is\n                      * * written here by USM secParams = globalData +\n                      * * globalDataLen.\n                      */\n                     size_t * secParamsLen,     /* IN/OUT - Len available, len returned. */\n                     u_char ** wholeMsg,        /* OUT */\n                     /*\n                      * Complete authenticated/encrypted message - typically\n                      * * the pointer to start of packet buffer provided in\n                      * * globalData is returned here, could also be a separate\n                      * * buffer.\n                      */\n                     size_t * wholeMsgLen)\n{                               /* IN/OUT - Len available, len returned. */\n    size_t          otstlen;\n    size_t          seq_len;\n    size_t          msgAuthParmLen;\n    size_t          msgPrivParmLen;\n    size_t          msgSecParmLen;\n    size_t          authParamsOffset;\n    size_t          privParamsOffset;\n    size_t          datalen;\n    size_t          dataOffset;\n    size_t          theTotalLength;\n\n    u_char         *ptr;\n    size_t          ptr_len;\n    size_t          remaining;\n    size_t          offSet;\n    u_int           boots_uint;\n    u_int           time_uint;\n    long            boots_long;\n    long            time_long;\n\n    /*\n     * Indirection because secStateRef values override parameters.\n     * \n     * None of these are to be free'd - they are either pointing to\n     * what's in the secStateRef or to something either in the\n     * actual prarmeter list or the user list.\n     */\n\n    char           *theName = NULL;\n    u_int           theNameLength = 0;\n    u_char         *theEngineID = NULL;\n    u_int           theEngineIDLength = 0;\n    u_char         *theAuthKey = NULL;\n    u_int           theAuthKeyLength = 0;\n    const oid      *theAuthProtocol = NULL;\n    u_int           theAuthProtocolLength = 0;\n    u_char         *thePrivKey = NULL;\n    u_int           thePrivKeyLength = 0;\n    const oid      *thePrivProtocol = NULL;\n    u_int           thePrivProtocolLength = 0;\n    int             theSecLevel = 0;    /* No defined const for bad\n                                         * value (other then err).\n                                         */\n\n    DEBUGMSGTL((\"usm\", \"USM processing has begun.\\n\"));\n\n    if (secStateRef != NULL) {\n        /*\n         * To hush the compiler for now.  XXX \n         */\n        struct usmStateReference *ref\n            = (struct usmStateReference *) secStateRef;\n\n        theName = ref->usr_name;\n        theNameLength = ref->usr_name_length;\n        theEngineID = ref->usr_engine_id;\n        theEngineIDLength = ref->usr_engine_id_length;\n\n        if (!theEngineIDLength) {\n            theEngineID = secEngineID;\n            theEngineIDLength = secEngineIDLen;\n        }\n\n        theAuthProtocol = ref->usr_auth_protocol;\n        theAuthProtocolLength = ref->usr_auth_protocol_length;\n        theAuthKey = ref->usr_auth_key;\n        theAuthKeyLength = ref->usr_auth_key_length;\n        thePrivProtocol = ref->usr_priv_protocol;\n        thePrivProtocolLength = ref->usr_priv_protocol_length;\n        thePrivKey = ref->usr_priv_key;\n        thePrivKeyLength = ref->usr_priv_key_length;\n        theSecLevel = ref->usr_sec_level;\n    }\n\n    /*\n     * Identify the user record.\n     */\n    else {\n        struct usmUser *user;\n\n        /*\n         * we do allow an unknown user name for\n         * unauthenticated requests. \n         */\n        if ((user = usm_get_user(secEngineID, secEngineIDLen, secName))\n            == NULL && secLevel != SNMP_SEC_LEVEL_NOAUTH) {\n            DEBUGMSGTL((\"usm\", \"Unknown User(%s)\\n\", secName));\n            return SNMPERR_USM_UNKNOWNSECURITYNAME;\n        }\n\n        theName = secName;\n        theNameLength = secNameLen;\n        theEngineID = secEngineID;\n        theSecLevel = secLevel;\n        theEngineIDLength = secEngineIDLen;\n        if (user) {\n            theAuthProtocol = user->authProtocol;\n            theAuthProtocolLength = user->authProtocolLen;\n            theAuthKey = user->authKey;\n            theAuthKeyLength = user->authKeyLen;\n            thePrivProtocol = user->privProtocol;\n            thePrivProtocolLength = user->privProtocolLen;\n            thePrivKey = user->privKey;\n            thePrivKeyLength = user->privKeyLen;\n        } else {\n            /*\n             * unknown users can not do authentication (obviously) \n             */\n            theAuthProtocol = usmNoAuthProtocol;\n            theAuthProtocolLength =\n                sizeof(usmNoAuthProtocol) / sizeof(oid);\n            theAuthKey = NULL;\n            theAuthKeyLength = 0;\n            thePrivProtocol = usmNoPrivProtocol;\n            thePrivProtocolLength =\n                sizeof(usmNoPrivProtocol) / sizeof(oid);\n            thePrivKey = NULL;\n            thePrivKeyLength = 0;\n        }\n    }                           /* endif -- secStateRef==NULL */\n\n\n    /*\n     * From here to the end of the function, avoid reference to\n     * secName, secEngineID, secLevel, and associated lengths.\n     */\n\n\n    /*\n     * Check to see if the user can use the requested sec services.\n     */\n    if (usm_check_secLevel_vs_protocols(theSecLevel,\n                                        theAuthProtocol,\n                                        theAuthProtocolLength,\n                                        thePrivProtocol,\n                                        thePrivProtocolLength) == 1) {\n        DEBUGMSGTL((\"usm\", \"Unsupported Security Level (%d)\\n\",\n                    theSecLevel));\n        return SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;\n    }\n\n\n    /*\n     * Retrieve the engine information.\n     *\n     * XXX  No error is declared in the EoP when sending messages to\n     *      unknown engines, processing continues w/ boots/time == (0,0).\n     */\n    if (get_enginetime(theEngineID, theEngineIDLength,\n                       &boots_uint, &time_uint, FALSE) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Failed to find engine data.\"));\n    }\n\n    boots_long = boots_uint;\n    time_long = time_uint;\n\n\n    /*\n     * Set up the Offsets.\n     */\n    if (usm_calc_offsets(globalDataLen, theSecLevel, theEngineIDLength,\n                         theNameLength, scopedPduLen, boots_long,\n                         time_long, &theTotalLength, &authParamsOffset,\n                         &privParamsOffset, &dataOffset, &datalen,\n                         &msgAuthParmLen, &msgPrivParmLen, &otstlen,\n                         &seq_len, &msgSecParmLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"Failed calculating offsets.\\n\"));\n        return SNMPERR_USM_GENERICERROR;\n    }\n\n    /*\n     * So, we have the offsets for the three parts that need to be\n     * determined, and an overall length.  Now we need to make\n     * sure all of this would fit in the outgoing buffer, and\n     * whether or not we need to make a new buffer, etc.\n     */\n\n\n    /*\n     * Set wholeMsg as a pointer to globalData.  Sanity check for\n     * the proper size.\n     * \n     * Mark workspace in the message with bytes of all 1's to make it\n     * easier to find mistakes in raw message dumps.\n     */\n    ptr = *wholeMsg = globalData;\n    if (theTotalLength > *wholeMsgLen) {\n        DEBUGMSGTL((\"usm\", \"Message won't fit in buffer.\\n\"));\n        return SNMPERR_USM_GENERICERROR;\n    }\n\n    ptr_len = *wholeMsgLen = theTotalLength;\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n    memset(&ptr[globalDataLen], 0xFF, theTotalLength - globalDataLen);\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n\n    /*\n     * Do the encryption.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        size_t          encrypted_length = theTotalLength - dataOffset;\n        size_t          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);\n        u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];\n        int             priv_type = sc_get_privtype(thePrivProtocol,\n                                                    thePrivProtocolLength);\n#ifdef HAVE_AES\n        if (USM_CREATE_USER_PRIV_AES == (priv_type & USM_PRIV_MASK_ALG)) {\n            if (!thePrivKey ||\n                usm_set_aes_iv(salt, &salt_length,\n                               htonl(boots_uint), htonl(time_uint),\n                               &ptr[privParamsOffset]) == -1) {\n                DEBUGMSGTL((\"usm\", \"Can't set AES iv.\\n\"));\n                return SNMPERR_USM_GENERICERROR;\n            }\n        }\n#endif\n#ifndef NETSNMP_DISABLE_DES\n        /*\n         * XXX  Hardwired to seek into a 1DES private key!\n         */\n        if (USM_CREATE_USER_PRIV_DES == (priv_type & USM_PRIV_MASK_ALG)) {\n            if (!thePrivKey ||\n                (usm_set_salt(salt, &salt_length,\n                              thePrivKey + 8, thePrivKeyLength - 8,\n                              &ptr[privParamsOffset])\n                 == -1)) {\n                DEBUGMSGTL((\"usm\", \"Can't set DES-CBC salt.\\n\"));\n                return SNMPERR_USM_GENERICERROR;\n            }\n        }\n#endif\n\n        if (sc_encrypt(thePrivProtocol, thePrivProtocolLength,\n                       thePrivKey, thePrivKeyLength,\n                       salt, salt_length,\n                       scopedPdu, scopedPduLen,\n                       &ptr[dataOffset], &encrypted_length)\n            != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"encryption error.\\n\"));\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"This data was encrypted:\",\n                       scopedPdu, scopedPduLen);\n            dump_chunk(\"usm/dump\", \"salt + Encrypted form:\",\n                       salt, salt_length);\n            dump_chunk(\"usm/dump\", NULL,\n                       &ptr[dataOffset], encrypted_length);\n            dump_chunk(\"usm/dump\", \"*wholeMsg:\",\n                       *wholeMsg, theTotalLength);\n        }\n#endif\n\n\n        ptr = *wholeMsg;\n        ptr_len = *wholeMsgLen = theTotalLength;\n\n\n        /*\n         * XXX  Sanity check for salt length should be moved up\n         *      under usm_calc_offsets() or tossed.\n         */\n        if ((encrypted_length != (theTotalLength - dataOffset))\n            || (salt_length != msgPrivParmLen)) {\n            DEBUGMSGTL((\"usm\", \"encryption length error.\\n\"));\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n\n        DEBUGMSGTL((\"usm\", \"Encryption successful.\\n\"));\n    }\n\n    /*\n     * No encryption for you!\n     */\n    else {\n        memcpy(&ptr[dataOffset], scopedPdu, scopedPduLen);\n    }\n\n\n\n    /*\n     * Start filling in the other fields (in prep for authentication).\n     * \n     * offSet is an octet string header, which is different from all\n     * the other headers.\n     */\n    remaining = ptr_len - globalDataLen;\n\n    offSet = ptr_len - remaining;\n    asn_build_header(&ptr[offSet], &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), otstlen);\n\n    offSet = ptr_len - remaining;\n    asn_build_sequence(&ptr[offSet], &remaining,\n                       (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), seq_len);\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineID\");\n    asn_build_string(&ptr[offSet], &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), theEngineID,\n                     theEngineIDLength);\n    DEBUGINDENTLESS();\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineBoots\");\n    asn_build_int(&ptr[offSet], &remaining,\n                  (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),\n                  &boots_long, sizeof(long));\n    DEBUGINDENTLESS();\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineTime\");\n    asn_build_int(&ptr[offSet], &remaining,\n                  (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),\n                  &time_long, sizeof(long));\n    DEBUGINDENTLESS();\n\n    offSet = ptr_len - remaining;\n    DEBUGDUMPHEADER(\"send\", \"msgUserName\");\n    asn_build_string(&ptr[offSet], &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), (u_char *) theName,\n                     theNameLength);\n    DEBUGINDENTLESS();\n\n\n    /*\n     * Note: if there is no authentication being done,\n     * msgAuthParmLen is 0, and there is no effect (other than\n     * inserting a zero-length header) of the following\n     * statements.\n     */\n\n    offSet = ptr_len - remaining;\n    asn_build_header(&ptr[offSet],\n                     &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), msgAuthParmLen);\n\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        offSet = ptr_len - remaining;\n        memset(&ptr[offSet], 0, msgAuthParmLen);\n    }\n\n    remaining -= msgAuthParmLen;\n\n\n    /*\n     * Note: if there is no encryption being done, msgPrivParmLen\n     * is 0, and there is no effect (other than inserting a\n     * zero-length header) of the following statements.\n     */\n\n    offSet = ptr_len - remaining;\n    asn_build_header(&ptr[offSet],\n                     &remaining,\n                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                               ASN_OCTET_STR), msgPrivParmLen);\n\n    remaining -= msgPrivParmLen;        /* Skipping the IV already there. */\n\n\n    /*\n     * For privacy, need to add the octet string header for it.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        offSet = ptr_len - remaining;\n        asn_build_header(&ptr[offSet],\n                         &remaining,\n                         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                   ASN_OCTET_STR),\n                         theTotalLength - dataOffset);\n    }\n\n\n    /*\n     * Adjust overall length and store it as the first SEQ length\n     * of the SNMPv3Message.\n     *\n     * FIX  4 is a magic number!\n     */\n    remaining = theTotalLength;\n    asn_build_sequence(ptr, &remaining,\n                       (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),\n                       theTotalLength - 4);\n\n\n    /*\n     * Now, time to consider / do authentication.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        size_t          temp_sig_len = msgAuthParmLen;\n        u_char         *temp_sig = (u_char *) malloc(temp_sig_len);\n\n        if (temp_sig == NULL) {\n            DEBUGMSGTL((\"usm\", \"Out of memory.\\n\"));\n            return SNMPERR_USM_GENERICERROR;\n        }\n\n        if (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,\n                                   theAuthKey, theAuthKeyLength,\n                                   ptr, ptr_len, temp_sig, &temp_sig_len)\n            != SNMP_ERR_NOERROR) {\n            /*\n             * FIX temp_sig_len defined?!\n             */\n            SNMP_ZERO(temp_sig, temp_sig_len);\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        if (temp_sig_len != msgAuthParmLen) {\n            SNMP_ZERO(temp_sig, temp_sig_len);\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing lengths failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        memcpy(&ptr[authParamsOffset], temp_sig, msgAuthParmLen);\n\n        SNMP_ZERO(temp_sig, temp_sig_len);\n        SNMP_FREE(temp_sig);\n\n    }\n\n    /*\n     * endif -- create keyed hash \n     */\n\n    DEBUGMSGTL((\"usm\", \"USM processing completed.\\n\"));\n\n    return SNMPERR_SUCCESS;\n\n}                               /* end usm_generate_out_msg() */\n\nstatic int\nusm_secmod_generate_out_msg(struct snmp_secmod_outgoing_params *parms)\n{\n    if (!parms)\n        return SNMPERR_GENERR;\n\n    return usm_generate_out_msg(parms->msgProcModel,\n                                parms->globalData, parms->globalDataLen,\n                                parms->maxMsgSize, parms->secModel,\n                                parms->secEngineID, parms->secEngineIDLen,\n                                parms->secName, parms->secNameLen,\n                                parms->secLevel,\n                                parms->scopedPdu, parms->scopedPduLen,\n                                parms->secStateRef,\n                                parms->secParams, parms->secParamsLen,\n                                parms->wholeMsg, parms->wholeMsgLen);\n}\n\n#ifdef NETSNMP_USE_REVERSE_ASNENCODING\nstatic int\nusm_rgenerate_out_msg(int msgProcModel, /* (UNUSED) */\n                      u_char * globalData,      /* IN */\n                      /*\n                       * points at the msgGlobalData, which is of length given by next \n                       * parameter.  \n                       */\n                      size_t globalDataLen,     /* IN - Length of msg header data.      */\n                      int maxMsgSize,   /* (UNUSED) */\n                      int secModel,     /* (UNUSED) */\n                      u_char * secEngineID,     /* IN - Pointer snmpEngineID.           */\n                      size_t secEngineIDLen,    /* IN - SnmpEngineID length.            */\n                      char *secName,    /* IN - Pointer to securityName.        */\n                      size_t secNameLen,        /* IN - SecurityName length.            */\n                      int secLevel,     /* IN - AuthNoPriv, authPriv etc.       */\n                      u_char * scopedPdu,       /* IN */\n                      /*\n                       * Pointer to scopedPdu will be encrypted by USM if needed\n                       * * and written to packet buffer immediately following\n                       * * securityParameters, entire msg will be authenticated by\n                       * * USM if needed.\n                       */\n                      size_t scopedPduLen,      /* IN - scopedPdu length. */\n                      void *secStateRef,        /* IN */\n                      /*\n                       * secStateRef, pointer to cached info provided only for\n                       * * Response, otherwise NULL.\n                       */\n                      u_char ** wholeMsg,       /*  IN/OUT  */\n                      /*\n                       * Points at the pointer to the packet buffer, which might get extended\n                       * if necessary via realloc().  \n                       */\n                      size_t * wholeMsgLen,     /*  IN/OUT  */\n                      /*\n                       * Length of the entire packet buffer, **not** the length of the\n                       * packet.  \n                       */\n                      size_t * offset   /*  IN/OUT  */\n                      /*\n                       * Offset from the end of the packet buffer to the start of the packet,\n                       * also known as the packet length.  \n                       */\n    )\n{\n    size_t          msgAuthParmLen = 0;\n    u_int           boots_uint;\n    u_int           time_uint;\n    long            boots_long;\n    long            time_long;\n\n    /*\n     * Indirection because secStateRef values override parameters.\n     * \n     * None of these are to be free'd - they are either pointing to\n     * what's in the secStateRef or to something either in the\n     * actual parameter list or the user list.\n     */\n\n    char           *theName = NULL;\n    u_int           theNameLength = 0;\n    u_char         *theEngineID = NULL;\n    u_int           theEngineIDLength = 0;\n    u_char         *theAuthKey = NULL;\n    u_int           theAuthKeyLength = 0;\n    const oid      *theAuthProtocol = NULL;\n    u_int           theAuthProtocolLength = 0;\n    u_char         *thePrivKey = NULL;\n    u_int           thePrivKeyLength = 0;\n    const oid      *thePrivProtocol = NULL;\n    u_int           thePrivProtocolLength = 0;\n    int             theSecLevel = 0;    /* No defined const for bad\n                                         * value (other then err). */\n    size_t          salt_length = 0, save_salt_length = 0;\n    u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    u_char          authParams[USM_MAX_AUTHSIZE];\n    u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    size_t          sp_offset = 0, mac_offset = 0;\n    int             rc = 0;\n\n    DEBUGMSGTL((\"usm\", \"USM processing has begun (offset %d)\\n\", (int)*offset));\n\n    if (secStateRef != NULL) {\n        /*\n         * To hush the compiler for now.  XXX \n         */\n        struct usmStateReference *ref\n            = (struct usmStateReference *) secStateRef;\n\n        theName = ref->usr_name;\n        theNameLength = ref->usr_name_length;\n        theEngineID = ref->usr_engine_id;\n        theEngineIDLength = ref->usr_engine_id_length;\n\n        if (!theEngineIDLength) {\n            theEngineID = secEngineID;\n            theEngineIDLength = secEngineIDLen;\n        }\n\n        theAuthProtocol = ref->usr_auth_protocol;\n        theAuthProtocolLength = ref->usr_auth_protocol_length;\n        theAuthKey = ref->usr_auth_key;\n        theAuthKeyLength = ref->usr_auth_key_length;\n        thePrivProtocol = ref->usr_priv_protocol;\n        thePrivProtocolLength = ref->usr_priv_protocol_length;\n        thePrivKey = ref->usr_priv_key;\n        thePrivKeyLength = ref->usr_priv_key_length;\n        theSecLevel = ref->usr_sec_level;\n    }\n\n    /*\n     * * Identify the user record.\n     */\n    else {\n        struct usmUser *user;\n\n        /*\n         * we do allow an unknown user name for\n         * unauthenticated requests. \n         */\n        if ((user = usm_get_user(secEngineID, secEngineIDLen, secName))\n            == NULL && secLevel != SNMP_SEC_LEVEL_NOAUTH) {\n            DEBUGMSGTL((\"usm\", \"Unknown User\\n\"));\n            return SNMPERR_USM_UNKNOWNSECURITYNAME;\n        }\n\n        theName = secName;\n        theNameLength = secNameLen;\n        theEngineID = secEngineID;\n        theSecLevel = secLevel;\n        theEngineIDLength = secEngineIDLen;\n        if (user) {\n            theAuthProtocol = user->authProtocol;\n            theAuthProtocolLength = user->authProtocolLen;\n            theAuthKey = user->authKey;\n            theAuthKeyLength = user->authKeyLen;\n            thePrivProtocol = user->privProtocol;\n            thePrivProtocolLength = user->privProtocolLen;\n            thePrivKey = user->privKey;\n            thePrivKeyLength = user->privKeyLen;\n        } else {\n            /*\n             * unknown users can not do authentication (obviously) \n             */\n            theAuthProtocol = usmNoAuthProtocol;\n            theAuthProtocolLength =\n                sizeof(usmNoAuthProtocol) / sizeof(oid);\n            theAuthKey = NULL;\n            theAuthKeyLength = 0;\n            thePrivProtocol = usmNoPrivProtocol;\n            thePrivProtocolLength =\n                sizeof(usmNoPrivProtocol) / sizeof(oid);\n            thePrivKey = NULL;\n            thePrivKeyLength = 0;\n        }\n    }                           /* endif -- secStateRef==NULL */\n\n\n    /*\n     * From here to the end of the function, avoid reference to\n     * secName, secEngineID, secLevel, and associated lengths.\n     */\n\n\n    /*\n     * Check to see if the user can use the requested sec services.\n     */\n    if (usm_check_secLevel_vs_protocols(theSecLevel,\n                                        theAuthProtocol,\n                                        theAuthProtocolLength,\n                                        thePrivProtocol,\n                                        thePrivProtocolLength) == 1) {\n        DEBUGMSGTL((\"usm\", \"Unsupported Security Level or type (%d)\\n\",\n                    theSecLevel));\n\n        return SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;\n    }\n\n\n    /*\n     * * Retrieve the engine information.\n     * *\n     * * XXX    No error is declared in the EoP when sending messages to\n     * *        unknown engines, processing continues w/ boots/time == (0,0).\n     */\n    if (get_enginetime(theEngineID, theEngineIDLength,\n                       &boots_uint, &time_uint, FALSE) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Failed to find engine data.\"));\n    }\n\n    boots_long = boots_uint;\n    time_long = time_uint;\n\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        /*\n         * Initially assume that the ciphertext will end up the same size as\n         * the plaintext plus some padding.  Really sc_encrypt ought to be able\n         * to grow this for us, a la asn_realloc_rbuild_<type> functions, but\n         * this will do for now.  \n         */\n        u_char         *ciphertext = NULL;\n        size_t          ciphertextlen = scopedPduLen + 64;\n        int             priv_type = sc_get_privtype(thePrivProtocol,\n                                                    thePrivProtocolLength);\n\n        if ((ciphertext = (u_char *) malloc(ciphertextlen)) == NULL) {\n            DEBUGMSGTL((\"usm\",\n                        \"couldn't malloc %d bytes for encrypted PDU\\n\",\n                        (int)ciphertextlen));\n            return SNMPERR_MALLOC;\n        }\n\n        /*\n         * XXX Hardwired to seek into a 1DES private key!  \n         */\n#ifdef HAVE_AES\n        if (USM_CREATE_USER_PRIV_AES == (priv_type & USM_PRIV_MASK_ALG)) {\n            salt_length = BYTESIZE(USM_AES_SALT_LENGTH);\n            save_salt_length = BYTESIZE(USM_AES_SALT_LENGTH)/2;\n            if (!thePrivKey ||\n                usm_set_aes_iv(salt, &salt_length,\n                               htonl(boots_uint), htonl(time_uint),\n                               iv) == -1) {\n                DEBUGMSGTL((\"usm\", \"Can't set AES iv.\\n\"));\n                SNMP_FREE(ciphertext);\n                return SNMPERR_USM_GENERICERROR;\n            }\n        } \n#endif\n#ifndef NETSNMP_DISABLE_DES\n        if (USM_CREATE_USER_PRIV_DES == (priv_type & USM_PRIV_MASK_ALG)) {\n            salt_length = BYTESIZE(USM_DES_SALT_LENGTH);\n            save_salt_length = BYTESIZE(USM_DES_SALT_LENGTH);\n            if (!thePrivKey || (usm_set_salt(salt, &salt_length,\n                                             thePrivKey + 8,\n                                             thePrivKeyLength - 8,\n                                             iv) == -1)) {\n                DEBUGMSGTL((\"usm\", \"Can't set DES-CBC salt.\\n\"));\n                SNMP_FREE(ciphertext);\n                return SNMPERR_USM_GENERICERROR;\n            }\n        }\n#endif\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"This data was encrypted:\",\n                       scopedPdu, scopedPduLen);\n        }\n#endif\n\n        if (sc_encrypt(thePrivProtocol, thePrivProtocolLength,\n                       thePrivKey, thePrivKeyLength,\n                       salt, salt_length,\n                       scopedPdu, scopedPduLen,\n                       ciphertext, &ciphertextlen) != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"encryption error.\\n\"));\n            SNMP_FREE(ciphertext);\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n\n        /*\n         * Write the encrypted scopedPdu back into the packet buffer.  \n         */\n\n        *offset = 0;\n        rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                       (u_char) (ASN_UNIVERSAL |\n                                                 ASN_PRIMITIVE |\n                                                 ASN_OCTET_STR),\n                                       ciphertext, ciphertextlen);\n        if (rc == 0) {\n            DEBUGMSGTL((\"usm\", \"Encryption failed.\\n\"));\n            SNMP_FREE(ciphertext);\n            return SNMPERR_USM_ENCRYPTIONERROR;\n        }\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"salt + Encrypted form: \", salt,\n                       salt_length);\n            dump_chunk(\"usm/dump\", \"wholeMsg:\",\n                       (*wholeMsg + *wholeMsgLen - *offset), *offset);\n        }\n#endif\n\n        DEBUGMSGTL((\"usm\", \"Encryption successful.\\n\"));\n        SNMP_FREE(ciphertext);\n    } else {\n        /*\n         * theSecLevel != SNMP_SEC_LEVEL_AUTHPRIV  \n         */\n    }\n\n    /*\n     * Start encoding the msgSecurityParameters.  \n     */\n\n    sp_offset = *offset;\n\n    DEBUGDUMPHEADER(\"send\", \"msgPrivacyParameters\");\n    /*\n     * msgPrivacyParameters (warning: assumes DES salt).  \n     */\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                   iv,\n                                   save_salt_length);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building privParams failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    DEBUGDUMPHEADER(\"send\", \"msgAuthenticationParameters\");\n    /*\n     * msgAuthenticationParameters.\n     */\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        memset(authParams, 0, sizeof(authParams));\n        msgAuthParmLen =\n            sc_get_auth_maclen(sc_get_authtype(theAuthProtocol,\n                                               theAuthProtocolLength));\n    }\n\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR), authParams,\n                                   msgAuthParmLen);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building authParams failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * Remember where to put the actual HMAC we calculate later on.  An\n     * encoded OCTET STRING of length USM_MD5_AND_SHA_AUTH_LEN has an ASN.1\n     * header of length 2, hence the fudge factor.  This works as long as\n     * auth lengths stay < 127.\n     */\n    mac_offset = *offset - 2;\n\n    /*\n     * msgUserName.  \n     */\n    DEBUGDUMPHEADER(\"send\", \"msgUserName\");\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                   (u_char *) theName, theNameLength);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building authParams failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * msgAuthoritativeEngineTime.  \n     */\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineTime\");\n    rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,\n                                (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                          ASN_INTEGER), &time_long,\n                                sizeof(long));\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\",\n                    \"building msgAuthoritativeEngineTime failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * msgAuthoritativeEngineBoots.  \n     */\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineBoots\");\n    rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,\n                                (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                          ASN_INTEGER), &boots_long,\n                                sizeof(long));\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\",\n                    \"building msgAuthoritativeEngineBoots failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    DEBUGDUMPHEADER(\"send\", \"msgAuthoritativeEngineID\");\n    rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR), theEngineID,\n                                   theEngineIDLength);\n    DEBUGINDENTLESS();\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building msgAuthoritativeEngineID failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * USM msgSecurityParameters sequence header  \n     */\n    rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,\n                                     (u_char) (ASN_SEQUENCE |\n                                               ASN_CONSTRUCTOR),\n                                     *offset - sp_offset);\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building usm security parameters failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * msgSecurityParameters OCTET STRING wrapper.  \n     */\n    rc = asn_realloc_rbuild_header(wholeMsg, wholeMsgLen, offset, 1,\n                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                   *offset - sp_offset);\n\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building msgSecurityParameters failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * Copy in the msgGlobalData and msgVersion.  \n     */\n    while ((*wholeMsgLen - *offset) < globalDataLen) {\n        if (!asn_realloc(wholeMsg, wholeMsgLen)) {\n            DEBUGMSGTL((\"usm\", \"building global data failed.\\n\"));\n            return SNMPERR_TOO_LONG;\n        }\n    }\n\n    *offset += globalDataLen;\n    memcpy(*wholeMsg + *wholeMsgLen - *offset, globalData, globalDataLen);\n\n    /*\n     * Total packet sequence.  \n     */\n    rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,\n                                     (u_char) (ASN_SEQUENCE |\n                                               ASN_CONSTRUCTOR), *offset);\n    if (rc == 0) {\n        DEBUGMSGTL((\"usm\", \"building master packet sequence failed.\\n\"));\n        return SNMPERR_TOO_LONG;\n    }\n\n    /*\n     * Now consider / do authentication.  \n     */\n\n    if (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n        theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        size_t          temp_sig_len = msgAuthParmLen;\n        u_char         *temp_sig = (u_char *) malloc(temp_sig_len);\n        u_char         *proto_msg = *wholeMsg + *wholeMsgLen - *offset;\n        size_t          proto_msg_len = *offset;\n\n\n        if (temp_sig == NULL) {\n            DEBUGMSGTL((\"usm\", \"Out of memory.\\n\"));\n            return SNMPERR_USM_GENERICERROR;\n        }\n\n        if (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,\n                                   theAuthKey, theAuthKeyLength,\n                                   proto_msg, proto_msg_len,\n                                   temp_sig, &temp_sig_len)\n            != SNMP_ERR_NOERROR) {\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        if (temp_sig_len != msgAuthParmLen) {\n            SNMP_FREE(temp_sig);\n            DEBUGMSGTL((\"usm\", \"Signing lengths failed.\\n\"));\n            return SNMPERR_USM_AUTHENTICATIONFAILURE;\n        }\n\n        memcpy(*wholeMsg + *wholeMsgLen - mac_offset, temp_sig,\n               msgAuthParmLen);\n        SNMP_FREE(temp_sig);\n    }\n    /*\n     * endif -- create keyed hash \n     */\n    DEBUGMSGTL((\"usm\", \"USM processing completed.\\n\"));\n    return SNMPERR_SUCCESS;\n}                               /* end usm_rgenerate_out_msg() */\n\nstatic int\nusm_secmod_rgenerate_out_msg(struct snmp_secmod_outgoing_params *parms)\n{\n    if (!parms)\n        return SNMPERR_GENERR;\n\n    return usm_rgenerate_out_msg(parms->msgProcModel,\n                                 parms->globalData, parms->globalDataLen,\n                                 parms->maxMsgSize, parms->secModel,\n                                 parms->secEngineID, parms->secEngineIDLen,\n                                 parms->secName, parms->secNameLen,\n                                 parms->secLevel,\n                                 parms->scopedPdu, parms->scopedPduLen,\n                                 parms->secStateRef,\n                                 parms->wholeMsg, parms->wholeMsgLen,\n                                 parms->wholeMsgOffset);\n}\n#endif                          /* */\n\n/*******************************************************************-o-******\n * usm_parse_security_parameters\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n *\ttab stop 4\n *\n *\tExtracts values from the security header and data portions of the\n *\tincoming buffer.\n */\nstatic int\nusm_parse_security_parameters(u_char * secParams,\n                              size_t remaining,\n                              u_char * secEngineID,\n                              size_t * secEngineIDLen,\n                              u_int * boots_uint,\n                              u_int * time_uint,\n                              char *secName,\n                              size_t * secNameLen,\n                              u_char * signature,\n                              size_t * signature_length,\n                              u_char * salt,\n                              size_t * salt_length, u_char ** data_ptr)\n{\n    u_char         *parse_ptr = secParams;\n    u_char         *value_ptr;\n    u_char         *next_ptr;\n    u_char          type_value;\n\n    size_t          octet_string_length = remaining;\n    size_t          sequence_length;\n    size_t          remaining_bytes;\n\n    long            boots_long;\n    long            time_long;\n\n    u_int           origNameLen;\n\n\n    /*\n     * Eat the first octet header.\n     */\n    if ((value_ptr = asn_parse_sequence(parse_ptr, &octet_string_length,\n                                        &type_value,\n                                        (ASN_UNIVERSAL | ASN_PRIMITIVE |\n                                         ASN_OCTET_STR),\n                                        \"usm first octet\")) == NULL) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Eat the sequence header.\n     */\n    parse_ptr = value_ptr;\n    sequence_length = octet_string_length;\n\n    if ((value_ptr = asn_parse_sequence(parse_ptr, &sequence_length,\n                                        &type_value,\n                                        (ASN_SEQUENCE | ASN_CONSTRUCTOR),\n                                        \"usm sequence\")) == NULL) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Retrieve the engineID.\n     */\n    parse_ptr = value_ptr;\n    remaining_bytes = sequence_length;\n\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthoritativeEngineID\");\n    if ((next_ptr\n         = asn_parse_string(parse_ptr, &remaining_bytes, &type_value,\n                            secEngineID, secEngineIDLen)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Retrieve the engine boots, notice switch in the way next_ptr and\n     * remaining_bytes are used (to accomodate the asn code).\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthoritativeEngineBoots\");\n    if ((next_ptr = asn_parse_int(next_ptr, &remaining_bytes, &type_value,\n                                  &boots_long, sizeof(long))) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n    *boots_uint = (u_int) boots_long;\n\n\n    /*\n     * Retrieve the time value.\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthoritativeEngineTime\");\n    if ((next_ptr = asn_parse_int(next_ptr, &remaining_bytes, &type_value,\n                                  &time_long, sizeof(long))) == NULL) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n    *time_uint = (u_int) time_long;\n\n    if (*boots_uint > ENGINEBOOT_MAX || *time_uint > ENGINETIME_MAX) {\n        return -1;\n    }\n\n    /*\n     * Retrieve the secName.\n     */\n    origNameLen = *secNameLen;\n\n\n    DEBUGDUMPHEADER(\"recv\", \"msgUserName\");\n    if ((next_ptr\n         = asn_parse_string(next_ptr, &remaining_bytes, &type_value,\n                            (u_char *) secName, secNameLen)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    /*\n     * FIX -- doesn't this also indicate a buffer overrun?\n     */\n    if (origNameLen < *secNameLen + 1) {\n        /*\n         * RETURN parse error, but it's really a parameter error \n         */\n        return -1;\n    }\n\n    if (*secNameLen > 32) {\n        /*\n         * This is a USM-specific limitation over and above the above\n         * limitation (which will probably default to the length of an\n         * SnmpAdminString, i.e. 255).  See RFC 2574, sec. 2.4.  \n         */\n        return -1;\n    }\n\n    secName[*secNameLen] = '\\0';\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n\n    /*\n     * Retrieve the signature and blank it if there.\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgAuthenticationParameters\");\n    if ((next_ptr\n         = asn_parse_string(next_ptr, &remaining_bytes, &type_value,\n                            signature, signature_length)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -1;\n    }\n\n    if (*signature_length != 0) {       /* Blanking for authentication step later */\n        memset(next_ptr - (u_long) * signature_length,\n               0, *signature_length);\n    }\n\n\n    /*\n     * Retrieve the salt.\n     *\n     * Note that the next ptr is where the data section starts.\n     */\n    DEBUGDUMPHEADER(\"recv\", \"msgPrivacyParameters\");\n    if ((*data_ptr\n         = asn_parse_string(next_ptr, &remaining_bytes, &type_value,\n                            salt, salt_length)) == NULL) {\n        DEBUGINDENTLESS();\n        /*\n         * RETURN parse error \n         */ return -2;\n    }\n    DEBUGINDENTLESS();\n\n    if (type_value !=\n        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {\n        /*\n         * RETURN parse error \n         */ return -2;\n    }\n\n    return 0;\n\n}                               /* end usm_parse_security_parameters() */\n\n\n\n\n/*******************************************************************-o-******\n * usm_check_and_update_timeliness\n *\n * Parameters:\n *\t*secEngineID\n *\t secEngineIDen\n *\t boots_uint\n *\t time_uint\n *\t*error\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\t\n *\n * Performs the incoming timeliness checking and setting.\n */\nstatic int\nusm_check_and_update_timeliness(u_char * secEngineID,\n                                size_t secEngineIDLen,\n                                u_int boots_uint,\n                                u_int time_uint, int *error)\n{\n    u_char          myID[USM_MAX_ID_LENGTH];\n    u_long          myIDLength =\n        snmpv3_get_engineID(myID, USM_MAX_ID_LENGTH);\n    u_int           myBoots;\n    u_int           myTime;\n\n\n\n    if ((myIDLength > USM_MAX_ID_LENGTH) || (myIDLength == 0)) {\n        /*\n         * We're probably already screwed...buffer overwrite.  XXX? \n         */\n        DEBUGMSGTL((\"usm\", \"Buffer overflow.\\n\"));\n        *error = SNMPERR_USM_GENERICERROR;\n        return -1;\n    }\n\n    myBoots = snmpv3_local_snmpEngineBoots();\n    myTime = snmpv3_local_snmpEngineTime();\n\n\n    /*\n     * IF the time involved is local\n     *     Make sure  message is inside the time window \n     * ELSE \n     *      IF boots is higher or boots is the same and time is higher\n     *              remember this new data\n     *      ELSE\n     *              IF !(boots same and time within USM_TIME_WINDOW secs)\n     *                      Message is too old \n     *              ELSE    \n     *                      Message is ok, but don't take time\n     *              ENDIF\n     *      ENDIF\n     * ENDIF\n     */\n\n    /*\n     * This is a local reference.\n     */\n    if (secEngineIDLen == myIDLength\n        && memcmp(secEngineID, myID, myIDLength) == 0) {\n        u_int           time_difference = myTime > time_uint ?\n            myTime - time_uint : time_uint - myTime;\n\n        if (boots_uint == ENGINEBOOT_MAX\n            || boots_uint != myBoots\n            || time_difference > USM_TIME_WINDOW) {\n            snmp_increment_statistic(STAT_USMSTATSNOTINTIMEWINDOWS);\n\n            DEBUGMSGTL((\"usm\",\n                        \"boot_uint %u myBoots %u time_diff %u => not in time window\\n\",\n                        boots_uint, myBoots, time_difference));\n            *error = SNMPERR_USM_NOTINTIMEWINDOW;\n            return -1;\n        }\n\n        *error = SNMPERR_SUCCESS;\n        return 0;\n    }\n\n    /*\n     * This is a remote reference.\n     */\n    else {\n        u_int           theirBoots, theirTime, theirLastTime;\n        u_int           time_difference;\n\n        if (get_enginetime_ex(secEngineID, secEngineIDLen,\n                              &theirBoots, &theirTime,\n                              &theirLastTime, TRUE)\n            != SNMPERR_SUCCESS) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\",\n                        \"Failed to get remote engine's times.\"));\n\n            *error = SNMPERR_USM_GENERICERROR;\n            return -1;\n        }\n\n        time_difference = theirTime > time_uint ?\n            theirTime - time_uint : time_uint - theirTime;\n\n\n        /*\n         * XXX  Contrary to the pseudocode:\n         *      See if boots is invalid first.\n         */\n        if (theirBoots == ENGINEBOOT_MAX || theirBoots > boots_uint) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\", \"Remote boot count invalid.\"));\n\n            *error = SNMPERR_USM_NOTINTIMEWINDOW;\n            return -1;\n        }\n\n\n        /*\n         * Boots is ok, see if the boots is the same but the time\n         * is old.\n         */\n        if (theirBoots == boots_uint && time_uint < theirLastTime) {\n            if (time_difference > USM_TIME_WINDOW) {\n                DEBUGMSGTL((\"usm\", \"%s\\n\", \"Message too old.\"));\n                *error = SNMPERR_USM_NOTINTIMEWINDOW;\n                return -1;\n            }\n\n            else {              /* Old, but acceptable */\n\n                *error = SNMPERR_SUCCESS;\n                return 0;\n            }\n        }\n\n\n        /*\n         * Message is ok, either boots has been advanced, or\n         * time is greater than before with the same boots.\n         */\n\n        if (set_enginetime(secEngineID, secEngineIDLen,\n                           boots_uint, time_uint, TRUE)\n            != SNMPERR_SUCCESS) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\",\n                        \"Failed updating remote boot/time.\"));\n            *error = SNMPERR_USM_GENERICERROR;\n            return -1;\n        }\n\n        *error = SNMPERR_SUCCESS;\n        return 0;               /* Fresh message and time updated */\n\n    }                           /* endif -- local or remote time reference. */\n\n\n}                               /* end usm_check_and_update_timeliness() */\n\n/*******************************************************************-o-******\n * usm_check_secLevel\n *\n * Parameters:\n *\t level\n *\t*user\n *      \n * Returns:\n *\t0\tOn success,\n *\t-1\tOtherwise.\n *\n * Checks that a given security level is valid for a given user.\n */\nstatic int\nusm_check_secLevel(int level, struct usmUser *user)\n{\n\n    if (user->userStatus != RS_ACTIVE)\n        return -1;\n\n    DEBUGMSGTL((\"comparex\", \"Comparing: %\" NETSNMP_PRIo \"u %\" NETSNMP_PRIo \"u \",\n                usmNoPrivProtocol[0], usmNoPrivProtocol[1]));\n    DEBUGMSGOID((\"comparex\", usmNoPrivProtocol,\n                 sizeof(usmNoPrivProtocol) / sizeof(oid)));\n    DEBUGMSG((\"comparex\", \"\\n\"));\n    if (level == SNMP_SEC_LEVEL_AUTHPRIV\n        && (netsnmp_oid_equals(user->privProtocol, user->privProtocolLen,\n                             usmNoPrivProtocol,\n                             sizeof(usmNoPrivProtocol) / sizeof(oid)) ==\n            0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"User (%s) Auth Protocol: \", user->name));\n        DEBUGMSGOID((\"usm\", user->authProtocol, user->authProtocolLen));\n        DEBUGMSG((\"usm\", \", User Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", user->privProtocol, user->privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n    if ((level == SNMP_SEC_LEVEL_AUTHPRIV\n         || level == SNMP_SEC_LEVEL_AUTHNOPRIV)\n        &&\n        (netsnmp_oid_equals\n         (user->authProtocol, user->authProtocolLen, usmNoAuthProtocol,\n          sizeof(usmNoAuthProtocol) / sizeof(oid)) == 0)) {\n        DEBUGMSGTL((\"usm\", \"Level: %d\\n\", level));\n        DEBUGMSGTL((\"usm\", \"User (%s) Auth Protocol: \", user->name));\n        DEBUGMSGOID((\"usm\", user->authProtocol, user->authProtocolLen));\n        DEBUGMSG((\"usm\", \", User Priv Protocol: \"));\n        DEBUGMSGOID((\"usm\", user->privProtocol, user->privProtocolLen));\n        DEBUGMSG((\"usm\", \"\\n\"));\n        return 1;\n    }\n\n    return 0;\n}                               /* end usm_check_secLevel() */\n\n/*******************************************************************-o-******\n * usm_process_in_msg\n *\n * Parameters:\n *\t(See list below...)\n *      \n * Returns:\n *\tSNMPERR_SUCCESS\t\t\tOn success.\n *\tSNMPERR_USM_AUTHENTICATIONFAILURE\n *\tSNMPERR_USM_DECRYPTIONERROR\n *\tSNMPERR_USM_GENERICERROR\n *\tSNMPERR_USM_PARSEERROR\n *\tSNMPERR_USM_UNKNOWNENGINEID\n *\tSNMPERR_USM_PARSEERROR\n *\tSNMPERR_USM_UNKNOWNSECURITYNAME\n *\tSNMPERR_USM_UNSUPPORTEDSECURITYLEVEL\n *\n *\n * ASSUMES size of decrypt_buf will always be >= size of encrypted sPDU.\n */\nstatic int\nusm_process_in_msg(int msgProcModel,    /* (UNUSED) */\n                   size_t maxMsgSize,   /* IN     - Used to calc maxSizeResponse.  */\n                   u_char * secParams,  /* IN     - BER encoded securityParameters. */\n                   int secModel,        /* (UNUSED) */\n                   int secLevel,        /* IN     - AuthNoPriv, authPriv etc.      */\n                   u_char * wholeMsg,   /* IN     - Original v3 message.           */\n                   size_t wholeMsgLen,  /* IN     - Msg length.                    */\n                   u_char * secEngineID,        /* OUT    - Pointer snmpEngineID.          */\n                   size_t * secEngineIDLen,     /* IN/OUT - Len available, len returned.   */\n                   /*\n                    * NOTE: Memory provided by caller.      \n                    */\n                   char *secName,       /* OUT    - Pointer to securityName.       */\n                   size_t * secNameLen, /* IN/OUT - Len available, len returned.   */\n                   u_char ** scopedPdu, /* OUT    - Pointer to plaintext scopedPdu. */\n                   size_t * scopedPduLen,       /* IN/OUT - Len available, len returned.   */\n                   size_t * maxSizeResponse,    /* OUT    - Max size of Response PDU.      */\n                   void **secStateRf,   /* OUT    - Ref to security state.         */\n                   netsnmp_session * sess,      /* IN     - session which got the message  */\n                   u_char msg_flags)\n{                               /* IN     - v3 Message flags.              */\n    size_t          remaining = wholeMsgLen - (u_int)\n        ((u_long) * secParams - (u_long) * wholeMsg);\n    u_int           boots_uint;\n    u_int           time_uint;\n#ifdef HAVE_AES\n    u_int           net_boots, net_time;\n#endif\n#ifndef NETSNMP_DISABLE_DES\n    int             i;\n#endif\n    u_char          signature[USM_MAX_AUTHSIZE];\n    size_t          signature_length = USM_MAX_AUTHSIZE;\n    u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    size_t          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);\n    u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];\n    u_int           iv_length = BYTESIZE(USM_MAX_SALT_LENGTH);\n    u_char         *data_ptr;\n    u_char         *value_ptr;\n    u_char          type_value;\n    u_char         *end_of_overhead = NULL;\n    int             error;\n    int             rc = 0;\n    struct usmStateReference **secStateRef =\n        (struct usmStateReference **) secStateRf;\n\n    struct usmUser *user;\n\n\n    DEBUGMSGTL((\"usm\", \"USM processing begun...\\n\"));\n\n    netsnmp_assert(secStateRef);\n\n    usm_free_usmStateReference(*secStateRef);\n    *secStateRef = usm_malloc_usmStateReference();\n    if (*secStateRef == NULL) {\n        DEBUGMSGTL((\"usm\", \"Out of memory.\\n\"));\n        return SNMPERR_USM_GENERICERROR;\n    }\n\n    /*\n     * Make sure the *secParms is an OCTET STRING.\n     * Extract the user name, engine ID, and security level.\n     */\n    if ((rc = usm_parse_security_parameters(secParams, remaining,\n                                            secEngineID, secEngineIDLen,\n                                            &boots_uint, &time_uint,\n                                            secName, secNameLen,\n                                            signature, &signature_length,\n                                            salt, &salt_length,\n                                            &data_ptr)) < 0) {\n        DEBUGMSGTL((\"usm\", \"Parsing failed (rc %d).\\n\", rc));\n        if (rc == -2) {\n            /*\n             * This indicates a decryptionError.  \n             */\n            snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n            error = SNMPERR_USM_DECRYPTIONERROR;\n        } else {\n            snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);\n            error = SNMPERR_USM_PARSEERROR;\n        }\n        goto err;\n    }\n\n    /*\n     * RFC 2574 section 8.3.2\n     * 1)  If the privParameters field is not an 8-octet OCTET STRING,\n     * then an error indication (decryptionError) is returned to the\n     * calling module.\n     */\n    if ((secLevel == SNMP_SEC_LEVEL_AUTHPRIV) && (salt_length != 8)) {\n        snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n        error = SNMPERR_USM_DECRYPTIONERROR;\n        goto err;\n    }\n\n    if (secLevel != SNMP_SEC_LEVEL_AUTHPRIV) {\n        /*\n         * pull these out now so reports can use them \n         */\n        *scopedPdu = data_ptr;\n        *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);\n        end_of_overhead = data_ptr;\n    }\n\n    /*\n     * Cache the name, engine ID, and security level,\n     * * per step 2 (section 3.2)\n     */\n    if (usm_set_usmStateReference_name\n        (*secStateRef, secName, *secNameLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache name.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_engine_id\n        (*secStateRef, secEngineID, *secEngineIDLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache engine id.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_sec_level(*secStateRef, secLevel) ==\n        -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache security level.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    /*\n     * Locate the engine ID record.\n     * If it is unknown, then either create one or note this as an error.\n     */\n    if ((sess && (sess->isAuthoritative == SNMP_SESS_AUTHORITATIVE ||\n                  (sess->isAuthoritative == SNMP_SESS_UNKNOWNAUTH &&\n                   (msg_flags & SNMP_MSG_FLAG_RPRT_BIT)))) ||\n        (!sess && (msg_flags & SNMP_MSG_FLAG_RPRT_BIT))) {\n        if (ISENGINEKNOWN(secEngineID, *secEngineIDLen) == FALSE) {\n            DEBUGMSGTL((\"usm\", \"Unknown Engine ID.\\n\"));\n            snmp_increment_statistic(STAT_USMSTATSUNKNOWNENGINEIDS);\n            error = SNMPERR_USM_UNKNOWNENGINEID;\n            goto err;\n        }\n    } else {\n        if (ENSURE_ENGINE_RECORD(secEngineID, *secEngineIDLen)\n            != SNMPERR_SUCCESS) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't ensure engine record.\"));\n            error = SNMPERR_USM_GENERICERROR;\n            goto err;\n        }\n\n    }\n\n\n    /*\n     * Locate the User record.\n     * If the user/engine ID is unknown, report this as an error.\n     */\n    if ((user = usm_get_user_from_list(secEngineID, *secEngineIDLen,\n                                       secName, userList,\n                                       (((sess && sess->isAuthoritative ==\n                                          SNMP_SESS_AUTHORITATIVE) ||\n                                         (!sess)) ? 0 : 1)))\n        == NULL) {\n        DEBUGMSGTL((\"usm\", \"Unknown User(%s)\\n\", secName));\n        snmp_increment_statistic(STAT_USMSTATSUNKNOWNUSERNAMES);\n        error = SNMPERR_USM_UNKNOWNSECURITYNAME;\n        goto err;\n    }\n\n    /* ensure the user is active */\n    if (user->userStatus != RS_ACTIVE) {\n        DEBUGMSGTL((\"usm\", \"Attempt to use an inactive user.\\n\"));\n        error = SNMPERR_USM_UNKNOWNSECURITYNAME;\n        goto err;\n    }\n\n    /*\n     * Make sure the security level is appropriate.\n     */\n\n    rc = usm_check_secLevel(secLevel, user);\n    if (1 == rc) {\n        DEBUGMSGTL((\"usm\", \"Unsupported Security Level (%d).\\n\",\n                    secLevel));\n        snmp_increment_statistic(STAT_USMSTATSUNSUPPORTEDSECLEVELS);\n        error = SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;\n        goto err;\n    } else if (rc != 0) {\n        DEBUGMSGTL((\"usm\", \"Unknown issue.\\n\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    /*\n     * Check the authentication credentials of the message.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (sc_check_keyed_hash(user->authProtocol, user->authProtocolLen,\n                                user->authKey, user->authKeyLen,\n                                wholeMsg, wholeMsgLen,\n                                signature, signature_length)\n            != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"Verification failed.\\n\"));\n            snmp_increment_statistic(STAT_USMSTATSWRONGDIGESTS);\n\t    snmp_log(LOG_WARNING, \"Authentication failed for %s\\n\",\n\t\t\t\tuser->name);\n            error = SNMPERR_USM_AUTHENTICATIONFAILURE;\n            goto err;\n        }\n\n        DEBUGMSGTL((\"usm\", \"Verification succeeded.\\n\"));\n    }\n\n\n    /*\n     * Steps 10-11  user is already set - relocated before timeliness \n     * check in case it fails - still save user data for response.\n     *\n     * Cache the keys and protocol oids, per step 11 (s3.2).\n     */\n    if (usm_set_usmStateReference_auth_protocol(*secStateRef,\n                                                user->authProtocol,\n                                                user->\n                                                authProtocolLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\",\n                    \"Couldn't cache authentication protocol.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_auth_key(*secStateRef,\n                                           user->authKey,\n                                           user->authKeyLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\",\n                    \"Couldn't cache authentication key.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_priv_protocol(*secStateRef,\n                                                user->privProtocol,\n                                                user->\n                                                privProtocolLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\",\n                    \"Couldn't cache privacy protocol.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n    if (usm_set_usmStateReference_priv_key(*secStateRef,\n                                           user->privKey,\n                                           user->privKeyLen) == -1) {\n        DEBUGMSGTL((\"usm\", \"%s\\n\", \"Couldn't cache privacy key.\"));\n        error = SNMPERR_USM_GENERICERROR;\n        goto err;\n    }\n\n\n    /*\n     * Perform the timeliness/time manager functions.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV\n        || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (usm_check_and_update_timeliness(secEngineID, *secEngineIDLen,\n                                            boots_uint, time_uint,\n                                            &error) == -1) {\n            goto err;\n        }\n    }\n#ifdef\t\t\t\t\t\t\tLCD_TIME_SYNC_OPT\n    /*\n     * Cache the unauthenticated time to use in case we don't have\n     * anything better - this guess will be no worse than (0,0)\n     * that we normally use.\n     */\n    else {\n        set_enginetime(secEngineID, *secEngineIDLen,\n                       boots_uint, time_uint, FALSE);\n    }\n#endif                          /* LCD_TIME_SYNC_OPT */\n\n\n    /*\n     * If needed, decrypt the scoped PDU.\n     */\n    if (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n        int priv_type = sc_get_privtype(user->privProtocol,\n                                        user->privProtocolLen);\n        remaining = wholeMsgLen - (data_ptr - wholeMsg);\n\n        if ((value_ptr = asn_parse_sequence(data_ptr, &remaining,\n                                            &type_value,\n                                            (ASN_UNIVERSAL | ASN_PRIMITIVE\n                                             | ASN_OCTET_STR),\n                                            \"encrypted sPDU\")) == NULL) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\",\n                        \"Failed while parsing encrypted sPDU.\"));\n            snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);\n            usm_free_usmStateReference(*secStateRef);\n            *secStateRef = NULL;\n            error = SNMPERR_USM_PARSEERROR;\n            goto err;\n        }\n\n#ifndef NETSNMP_DISABLE_DES\n        if (USM_CREATE_USER_PRIV_DES == (priv_type & USM_PRIV_MASK_ALG)) {\n            /*\n             * From RFC2574:\n             * \n             * \"Before decryption, the encrypted data length is verified.\n             * If the length of the OCTET STRING to be decrypted is not\n             * an integral multiple of 8 octets, the decryption process\n             * is halted and an appropriate exception noted.\"  \n             */\n\n            if (remaining % 8 != 0) {\n                DEBUGMSGTL((\"usm\",\n                            \"Ciphertext is %lu bytes, not an integer multiple of 8 (rem %lu)\\n\",\n                            (unsigned long)remaining, (unsigned long)remaining % 8));\n                snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n                usm_free_usmStateReference(*secStateRef);\n                *secStateRef = NULL;\n                error = SNMPERR_USM_DECRYPTIONERROR;\n                goto err;\n            }\n\n            end_of_overhead = value_ptr;\n\n            if ( !user->privKey ) {\n                DEBUGMSGTL((\"usm\", \"No privacy pass phrase for %s\\n\", user->secName));\n                snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n                usm_free_usmStateReference(*secStateRef);\n                *secStateRef = NULL;\n                error = SNMPERR_USM_DECRYPTIONERROR;\n                goto err;\n            }\n\n            /*\n             * XOR the salt with the last (iv_length) bytes\n             * of the priv_key to obtain the IV.\n             */\n            iv_length = BYTESIZE(USM_DES_SALT_LENGTH);\n            for (i = 0; i < (int) iv_length; i++)\n                iv[i] = salt[i] ^ user->privKey[iv_length + i];\n        }\n#endif\n#ifdef HAVE_AES\n        if (USM_CREATE_USER_PRIV_AES == (priv_type & USM_PRIV_MASK_ALG)) {\n            iv_length = BYTESIZE(USM_AES_SALT_LENGTH);\n            net_boots = ntohl(boots_uint);\n            net_time = ntohl(time_uint);\n            memcpy(iv, &net_boots, 4);\n            memcpy(iv+4, &net_time, 4);\n            memcpy(iv+8, salt, salt_length);\n        }\n#endif\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"Cypher Text\", value_ptr, remaining);\n            dump_chunk(\"usm/dump\", \"salt + Encrypted form:\",\n                       salt, salt_length);\n            dump_chunk(\"usm/dump\", \"IV + Encrypted form:\", iv, iv_length);\n        }\n#endif\n        if (sc_decrypt(user->privProtocol, user->privProtocolLen,\n                       user->privKey, user->privKeyLen,\n                       iv, iv_length,\n                       value_ptr, remaining, *scopedPdu, scopedPduLen)\n            != SNMP_ERR_NOERROR) {\n            DEBUGMSGTL((\"usm\", \"%s\\n\", \"Failed decryption.\"));\n            snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);\n            error = SNMPERR_USM_DECRYPTIONERROR;\n            goto err;\n        }\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n        if (debug_is_token_registered(\"usm/dump\") == SNMPERR_SUCCESS) {\n            dump_chunk(\"usm/dump\", \"Decrypted chunk:\",\n                       *scopedPdu, *scopedPduLen);\n        }\n#endif\n    }\n    /*\n     * sPDU is plaintext.\n     */\n    else {\n        *scopedPdu = data_ptr;\n        *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);\n        end_of_overhead = data_ptr;\n\n    }                           /* endif -- PDU decryption */\n\n\n    /*\n     * Calculate the biggest sPDU for the response (i.e., whole - ovrhd).\n     *\n     * FIX  Correct? \n     */\n    *maxSizeResponse = maxMsgSize - (end_of_overhead - wholeMsg);\n\n\n    DEBUGMSGTL((\"usm\", \"USM processing completed.\\n\"));\n\n    return SNMPERR_SUCCESS;\n\nerr:\n    usm_free_usmStateReference(*secStateRef);\n    *secStateRef = NULL;\n    netsnmp_assert(error != SNMPERR_SUCCESS);\n    return error;\n}                               /* end usm_process_in_msg() */\n\nstatic int\nusm_secmod_process_in_msg(struct snmp_secmod_incoming_params *parms)\n{\n    if (!parms)\n        return SNMPERR_GENERR;\n\n    return usm_process_in_msg(parms->msgProcModel,\n                              parms->maxMsgSize,\n                              parms->secParams,\n                              parms->secModel,\n                              parms->secLevel,\n                              parms->wholeMsg,\n                              parms->wholeMsgLen,\n                              parms->secEngineID,\n                              parms->secEngineIDLen,\n                              parms->secName,\n                              parms->secNameLen,\n                              parms->scopedPdu,\n                              parms->scopedPduLen,\n                              parms->maxSizeResponse,\n                              parms->secStateRef,\n                              parms->sess, parms->msg_flags);\n}\n\nstatic void\nusm_handle_report(struct session_list *slp,\n                  netsnmp_transport *transport, netsnmp_session *session,\n                  int result, netsnmp_pdu *pdu)\n{\n    /*\n     * handle reportable errors \n     */\n\n    /* this will get in our way */\n    usm_free_usmStateReference(pdu->securityStateRef);\n    pdu->securityStateRef = NULL;\n\n    switch (result) {\n    case SNMPERR_USM_AUTHENTICATIONFAILURE:\n    {\n        int res = session->s_snmp_errno;\n        session->s_snmp_errno = result;\n        if (session->callback) {\n            session->callback(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE,\n                              session, pdu->reqid, pdu,\n                              session->callback_magic);\n        }\n        session->s_snmp_errno = res;\n    }  \n    /* fallthrough */\n    case SNMPERR_USM_UNKNOWNENGINEID:\n    case SNMPERR_USM_UNKNOWNSECURITYNAME:\n    case SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL:\n    case SNMPERR_USM_NOTINTIMEWINDOW:\n    case SNMPERR_USM_DECRYPTIONERROR:\n\n        if (SNMP_CMD_CONFIRMED(pdu->command) ||\n            (pdu->command == 0\n             && (pdu->flags & SNMP_MSG_FLAG_RPRT_BIT))) {\n            netsnmp_pdu    *pdu2;\n            int             flags = pdu->flags;\n\n            pdu->flags |= UCD_MSG_FLAG_FORCE_PDU_COPY;\n            pdu2 = snmp_clone_pdu(pdu);\n            pdu->flags = pdu2->flags = flags;\n            snmpv3_make_report(pdu2, result);\n            if (0 == snmp_sess_send(slp, pdu2)) {\n                snmp_free_pdu(pdu2);\n                /*\n                 * TODO: indicate error \n                 */\n            }\n        }\n        break;\n    }       \n}\n\n/** utility function to call netsnmp_extend_kul for a usmUser */\nint\nusm_extend_user_kul(struct usmUser *user, u_int privKeyBufSize)\n{\n    netsnmp_priv_alg_info *pai;\n\n    DEBUGMSGTL((\"usm\", \"extending key\\n\"));\n\n    if (NULL == user) {\n        DEBUGMSGTL((\"usm\", \"null user!\\n\"));\n        return SNMPERR_GENERR;\n    }\n\n    pai = sc_get_priv_alg_byoid(user->privProtocol, user->privProtocolLen);\n    if (NULL == pai) {\n        DEBUGMSGTL((\"usm\", \"privProtocol lookup failed!\\n\"));\n        return SNMPERR_GENERR;\n    }\n\n    return netsnmp_extend_kul(pai->proper_length, user->authProtocol,\n                              user->authProtocolLen, pai->type, user->engineID,\n                              user->engineIDLen, &user->privKey,\n                              &user->privKeyLen, privKeyBufSize);\n}\n\n/* sets up initial default session parameters */\nstatic int\nusm_session_init(netsnmp_session *in_session, netsnmp_session *session)\n{\n    char *cp;\n    size_t i;\n    \n    if (in_session->securityAuthProtoLen > 0) {\n        session->securityAuthProto =\n            snmp_duplicate_objid(in_session->securityAuthProto,\n                                 in_session->securityAuthProtoLen);\n        if (session->securityAuthProto == NULL) {\n            in_session->s_snmp_errno = SNMPERR_MALLOC;\n            return SNMPERR_MALLOC;\n        }\n    } else if (get_default_authtype(&i) != NULL) {\n        session->securityAuthProto =\n            snmp_duplicate_objid(get_default_authtype(NULL), i);\n        session->securityAuthProtoLen = i;\n    }\n\n    if (in_session->securityPrivProtoLen > 0) {\n        session->securityPrivProto =\n            snmp_duplicate_objid(in_session->securityPrivProto,\n                                 in_session->securityPrivProtoLen);\n        if (session->securityPrivProto == NULL) {\n            in_session->s_snmp_errno = SNMPERR_MALLOC;\n            return SNMPERR_MALLOC;\n        }\n    } else if (get_default_privtype(&i) != NULL) {\n        session->securityPrivProto =\n            snmp_duplicate_objid(get_default_privtype(NULL), i);\n        session->securityPrivProtoLen = i;\n    }\n\n    if ((in_session->securityAuthKeyLen <= 0) &&\n        ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t     NETSNMP_DS_LIB_AUTHMASTERKEY)))) {\n        size_t buflen = sizeof(session->securityAuthKey);\n        u_char *tmpp = session->securityAuthKey;\n        session->securityAuthKeyLen = 0;\n        /* it will be a hex string */\n        if (!snmp_hex_to_binary(&tmpp, &buflen,\n                                &session->securityAuthKeyLen, 0, cp)) {\n            snmp_set_detail(\"error parsing authentication master key\");\n            return SNMP_ERR_GENERR;\n        }\n    } else if ((in_session->securityAuthKeyLen <= 0) &&\n               ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_AUTHPASSPHRASE)) ||\n                (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_PASSPHRASE)))) {\n        session->securityAuthKeyLen = USM_AUTH_KU_LEN;\n        if (generate_Ku(session->securityAuthProto,\n                        session->securityAuthProtoLen,\n                        (u_char *) cp, strlen(cp),\n                        session->securityAuthKey,\n                        &session->securityAuthKeyLen) != SNMPERR_SUCCESS) {\n            snmp_set_detail\n                (\"Error generating a key (Ku) from the supplied authentication pass phrase.\");\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n    \n    if ((in_session->securityPrivKeyLen <= 0) &&\n        ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t     NETSNMP_DS_LIB_PRIVMASTERKEY)))) {\n        size_t buflen = sizeof(session->securityPrivKey);\n        u_char *tmpp = session->securityPrivKey;\n        session->securityPrivKeyLen = 0;\n        /* it will be a hex string */\n        if (!snmp_hex_to_binary(&tmpp, &buflen,\n                                &session->securityPrivKeyLen, 0, cp)) {\n            snmp_set_detail(\"error parsing encryption master key\");\n            return SNMP_ERR_GENERR;\n        }\n    } else if ((in_session->securityPrivKeyLen <= 0) &&\n               ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_PRIVPASSPHRASE)) ||\n                (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                            NETSNMP_DS_LIB_PASSPHRASE)))) {\n        session->securityPrivKeyLen = USM_PRIV_KU_LEN;\n        if (generate_Ku(session->securityAuthProto,\n                        session->securityAuthProtoLen,\n                        (u_char *) cp, strlen(cp),\n                        session->securityPrivKey,\n                        &session->securityPrivKeyLen) != SNMPERR_SUCCESS) {\n            snmp_set_detail\n                (\"Error generating a key (Ku) from the supplied privacy pass phrase.\");\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * usm_create_user_from_session(netsnmp_session *session):\n * \n * creates a user in the usm table from the information in a session.\n * If the user already exists, it is updated with the current\n * information from the session\n * \n * Parameters:\n * session -- IN: pointer to the session to use when creating the user.\n * \n * Returns:\n * SNMPERR_SUCCESS\n * SNMPERR_GENERR \n */\nint\nusm_create_user_from_session(netsnmp_session * session)\n{\n    struct usmUser *user;\n    int             user_just_created = 0;\n    char *cp;\n\n    /*\n     * - don't create-another/copy-into user for this session by default\n     * - bail now (no error) if we don't have an engineID\n     */\n    if (SNMP_FLAGS_USER_CREATED == (session->flags & SNMP_FLAGS_USER_CREATED) ||\n        session->securityModel != SNMP_SEC_MODEL_USM ||\n        session->version != SNMP_VERSION_3 ||\n        session->securityNameLen == 0 ||\n        session->securityEngineIDLen == 0)\n        return SNMPERR_SUCCESS;\n\n    DEBUGMSGTL((\"usm\", \"no flag defined...  continuing\\n\"));\n    session->flags |= SNMP_FLAGS_USER_CREATED;\n\n    /*\n     * now that we have the engineID, create an entry in the USM list\n     * for this user using the information in the session \n     */\n    user = usm_get_user_from_list(session->securityEngineID,\n                                  session->securityEngineIDLen,\n                                  session->securityName,\n                                  usm_get_userList(), 0);\n    if (NULL != user) \n        DEBUGMSGTL((\"usm\", \"user exists x=%p\\n\", user));\n    else\n    if (user == NULL) {\n        DEBUGMSGTL((\"usm\", \"Building user %s...\\n\",\n                    session->securityName));\n        /*\n         * user doesn't exist so we create and add it \n         */\n        user = (struct usmUser *) calloc(1, sizeof(struct usmUser));\n        if (user == NULL)\n            return SNMPERR_GENERR;\n\n        /*\n         * copy in the securityName \n         */\n        if (session->securityName) {\n            user->name = strdup(session->securityName);\n            user->secName = strdup(session->securityName);\n            if (user->name == NULL || user->secName == NULL) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        }\n\n        /*\n         * copy in the engineID \n         */\n        user->engineID = netsnmp_memdup(session->securityEngineID,\n                                        session->securityEngineIDLen);\n        if (session->securityEngineID && !user->engineID) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n        user->engineIDLen = session->securityEngineIDLen;\n\n        user_just_created = 1;\n    }\n\n    /*\n     * copy the auth protocol \n     */\n    if (user->authProtocol == NULL && session->securityAuthProto != NULL) {\n        SNMP_FREE(user->authProtocol);\n        user->authProtocol =\n            snmp_duplicate_objid(session->securityAuthProto,\n                                 session->securityAuthProtoLen);\n        if (user->authProtocol == NULL) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n        user->authProtocolLen = session->securityAuthProtoLen;\n    }\n\n    /*\n     * copy the priv protocol \n     */\n    if (user->privProtocol == NULL && session->securityPrivProto != NULL) {\n        SNMP_FREE(user->privProtocol);\n        user->privProtocol =\n            snmp_duplicate_objid(session->securityPrivProto,\n                                 session->securityPrivProtoLen);\n        if (user->privProtocol == NULL) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n        user->privProtocolLen = session->securityPrivProtoLen;\n    }\n\n    /*\n     * copy in the authentication Key.  If not localized, localize it \n     */\n    if (user->authKey == NULL) {\n        if (session->securityAuthLocalKey != NULL\n            && session->securityAuthLocalKeyLen != 0) {\n            /* already localized key passed in.  use it */\n            SNMP_FREE(user->authKey);\n            user->authKey = netsnmp_memdup(session->securityAuthLocalKey,\n                                           session->securityAuthLocalKeyLen);\n            if (!user->authKey) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n            user->authKeyLen = session->securityAuthLocalKeyLen;\n        } else if (session->securityAuthKeyLen != 0) {\n            SNMP_FREE(user->authKey);\n            user->authKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);\n            user->authKeyLen = USM_LENGTH_KU_HASHBLOCK;\n            if ((user->authKey == NULL) ||\n                generate_kul(user->authProtocol, user->authProtocolLen,\n                             user->engineID, user->engineIDLen,\n                             session->securityAuthKey,\n                             session->securityAuthKeyLen, user->authKey,\n                             &user->authKeyLen) != SNMPERR_SUCCESS) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        } else if ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                               NETSNMP_DS_LIB_AUTHLOCALIZEDKEY))) {\n            size_t buflen = USM_AUTH_KU_LEN;\n            SNMP_FREE(user->authKey);\n            user->authKey = (u_char *)malloc(buflen); /* max length needed */\n            user->authKeyLen = 0;\n            /* it will be a hex string */\n            if ((NULL == user->authKey) ||\n                !snmp_hex_to_binary(&user->authKey, &buflen, &user->authKeyLen,\n                                    0, cp)) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        }\n    }\n\n    /*\n     * copy in the privacy Key.  If not localized, localize it \n     */\n    if (user->privKey == NULL) {\n        /** save buffer size in case we need to extend key */\n        int keyBufSize = USM_PRIV_KU_LEN;\n\n        DEBUGMSGTL((\"usm\", \"copying privKey\\n\"));\n        if (session->securityPrivLocalKey != NULL\n            && session->securityPrivLocalKeyLen != 0) {\n            /* already localized key passed in.  use it */\n            SNMP_FREE(user->privKey);\n            user->privKey = netsnmp_memdup(session->securityPrivLocalKey,\n                                           session->securityPrivLocalKeyLen);\n            if (!user->privKey) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n            keyBufSize = user->privKeyLen = session->securityPrivLocalKeyLen;\n        } else if (session->securityPrivKeyLen != 0) {\n            SNMP_FREE(user->privKey);\n            user->privKey = (u_char *) calloc(1, keyBufSize);\n            user->privKeyLen = keyBufSize;\n            if ((user->privKey == NULL) ||\n                generate_kul(user->authProtocol, user->authProtocolLen,\n                             user->engineID, user->engineIDLen,\n                             session->securityPrivKey,\n                             session->securityPrivKeyLen, user->privKey,\n                             &user->privKeyLen) != SNMPERR_SUCCESS) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        } else if ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n                                               NETSNMP_DS_LIB_PRIVLOCALIZEDKEY))) {\n            size_t buflen = keyBufSize;\n            user->privKey = (u_char *)malloc(buflen); /* max length needed */\n            user->privKeyLen = 0;\n            /* it will be a hex string */\n            if ((NULL == user->privKey) ||\n                !snmp_hex_to_binary(&user->privKey, &buflen, &user->privKeyLen,\n                                    0, cp)) {\n                usm_free_user(user);\n                return SNMPERR_GENERR;\n            }\n        }\n        if (usm_extend_user_kul(user, keyBufSize) != SNMPERR_SUCCESS) {\n            usm_free_user(user);\n            return SNMPERR_GENERR;\n        }\n    }\n\n    if (user_just_created) {\n        /*\n         * add the user into the database \n         */\n        user->userStatus = RS_ACTIVE;\n        user->userStorageType = ST_READONLY;\n        usm_add_user(user);\n    }\n    DEBUGMSGTL((\"9:usm\", \"user created\\n\"));\n\n    return SNMPERR_SUCCESS;\n\n\n}\n\n/* A wrapper around the hook */\nstatic int\nusm_create_user_from_session_hook(struct session_list *slp,\n                                  netsnmp_session *session)\n{\n    DEBUGMSGTL((\"usm\", \"potentially bootstrapping the USM table from session data\\n\"));\n    return usm_create_user_from_session(session);\n}\n\nstatic int\nusm_build_probe_pdu(netsnmp_pdu **pdu)\n{\n    struct usmUser *user;\n\n    /*\n     * create the pdu \n     */\n    if (!pdu)\n        return -1;\n    *pdu = snmp_pdu_create(SNMP_MSG_GET);\n    if (!(*pdu))\n        return -1;\n    (*pdu)->version = SNMP_VERSION_3;\n    (*pdu)->securityName = strdup(\"\");\n    (*pdu)->securityNameLen = strlen((*pdu)->securityName);\n    (*pdu)->securityLevel = SNMP_SEC_LEVEL_NOAUTH;\n    (*pdu)->securityModel = SNMP_SEC_MODEL_USM;\n\n    /*\n     * create the empty user \n     */\n    user = usm_get_user(NULL, 0, (*pdu)->securityName);\n    if (user == NULL) {\n        user = (struct usmUser *) calloc(1, sizeof(struct usmUser));\n        if (user == NULL) {\n            snmp_free_pdu(*pdu);\n            *pdu = (netsnmp_pdu *) NULL;\n            return -1;\n        }\n        user->name = strdup((*pdu)->securityName);\n        user->secName = strdup((*pdu)->securityName);\n        user->authProtocolLen = sizeof(usmNoAuthProtocol) / sizeof(oid);\n        user->authProtocol =\n            snmp_duplicate_objid(usmNoAuthProtocol, user->authProtocolLen);\n        user->privProtocolLen = sizeof(usmNoPrivProtocol) / sizeof(oid);\n        user->privProtocol =\n            snmp_duplicate_objid(usmNoPrivProtocol, user->privProtocolLen);\n        usm_add_user(user);\n    }\n    return 0;\n}\n\nstatic int usm_discover_engineid(struct session_list *slp,\n                                 netsnmp_session *session)\n{\n    netsnmp_pdu    *pdu = NULL, *response = NULL;\n    int status, i;\n\n    if (usm_build_probe_pdu(&pdu) != 0) {\n        DEBUGMSGTL((\"snmp_api\", \"unable to create probe PDU\\n\"));\n        return SNMP_ERR_GENERR;\n    }\n    DEBUGMSGTL((\"snmp_api\", \"probing for engineID...\\n\"));\n    session->flags |= SNMP_FLAGS_DONT_PROBE; /* prevent recursion */\n    status = snmp_sess_synch_response(slp, pdu, &response);\n\n    if ((response == NULL) && (status == STAT_SUCCESS)) {\n        status = STAT_ERROR;\n    }\n\n    switch (status) {\n    case STAT_SUCCESS:\n        session->s_snmp_errno = SNMPERR_INVALID_MSG; /* XX?? */\n        DEBUGMSGTL((\"snmp_sess_open\",\n                    \"error: expected Report as response to probe: %s (%ld)\\n\",\n                    snmp_errstring(response->errstat),\n                    response->errstat));\n        break;\n    case STAT_ERROR:   /* this is what we expected -> Report == STAT_ERROR */\n        session->s_snmp_errno = SNMPERR_UNKNOWN_ENG_ID;\n        break;\n    case STAT_TIMEOUT:\n        session->s_snmp_errno = SNMPERR_TIMEOUT;\n        break;\n    default:\n        DEBUGMSGTL((\"snmp_sess_open\",\n                    \"unable to connect with remote engine: %s (%d)\\n\",\n                    snmp_api_errstring(session->s_snmp_errno),\n                    session->s_snmp_errno));\n        break;\n    }\n\n    if (slp->session->securityEngineIDLen == 0) {\n        DEBUGMSGTL((\"snmp_api\",\n                    \"unable to determine remote engine ID\\n\"));\n        /* clear the flag so that probe occurs on next inform */\n        session->flags &= ~SNMP_FLAGS_DONT_PROBE;\n        return SNMP_ERR_GENERR;\n    }\n\n    session->s_snmp_errno = SNMPERR_SUCCESS;\n    if (snmp_get_do_debugging()) {\n        DEBUGMSGTL((\"snmp_sess_open\",\n                    \"  probe found engineID:  \"));\n        for (i = 0; i < slp->session->securityEngineIDLen; i++)\n            DEBUGMSG((\"snmp_sess_open\", \"%02x\",\n                      slp->session->securityEngineID[i]));\n        DEBUGMSG((\"snmp_sess_open\", \"\\n\"));\n    }\n\n    /*\n     * if boot/time supplied set it for this engineID \n     */\n    if (session->engineBoots || session->engineTime) {\n        set_enginetime(session->securityEngineID,\n                       session->securityEngineIDLen,\n                       session->engineBoots, session->engineTime,\n                       TRUE);\n    }\n    return SNMPERR_SUCCESS;\n}\n\nstatic int\nusm_lookup_alg_type(const char *str, usm_alg_type_t *types)\n{\n    int i, l;\n    l = strlen(str);\n    for (i = 0; types[i].label; ++i) {\n        if (0 == strncasecmp(types[i].label, str, l))\n            return types[i].value;\n    }\n\n    return -1;\n}\n\nstatic const char *\nusm_lookup_alg_str(int value, usm_alg_type_t *types)\n{\n    int i;\n    for (i = 0; types[i].label; ++i)\n        if (value == types[i].value)\n            return types[i].label;\n\n    return NULL;\n}\n\nint\nusm_lookup_auth_type(const char *str)\n{\n    return usm_lookup_alg_type(str, usm_auth_type );\n}\n\nint\nusm_lookup_priv_type(const char *str)\n{\n    return usm_lookup_alg_type(str, usm_priv_type );\n}\n\nconst char *\nusm_lookup_auth_str(int value)\n{\n    return usm_lookup_alg_str(value, usm_auth_type );\n}\n\nconst char *\nusm_lookup_priv_str(int value)\n{\n    return usm_lookup_alg_str(value, usm_priv_type );\n}\n\nstatic void\nclear_user_list(void)\n{\n    struct usmUser *tmp = userList, *next = NULL;\n\n    while (tmp != NULL) {\n\tnext = tmp->next;\n\tusm_free_user(tmp);\n\ttmp = next;\n    }\n    userList = NULL;\n\n}\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n/*\n * take a given user and clone the security info into another \n */\nstruct usmUser *\nusm_cloneFrom_user(struct usmUser *from, struct usmUser *to)\n{\n    to->flags = from->flags;\n\n    /*\n     * copy the authProtocol oid row pointer \n     */\n    SNMP_FREE(to->authProtocol);\n\n    if ((to->authProtocol =\n         snmp_duplicate_objid(from->authProtocol,\n                              from->authProtocolLen)) != NULL)\n        to->authProtocolLen = from->authProtocolLen;\n    else\n        to->authProtocolLen = 0;\n\n\n    /*\n     * copy the authKey \n     */\n    SNMP_FREE(to->authKey);\n\n    if (from->authKeyLen > 0 &&\n        (to->authKey = (u_char *) malloc(from->authKeyLen))\n        != NULL) {\n        to->authKeyLen = from->authKeyLen;\n        memcpy(to->authKey, from->authKey, to->authKeyLen);\n    } else {\n        to->authKey = NULL;\n        to->authKeyLen = 0;\n    }\n\n    /*\n     * copy the authKeyKu\n     */\n    SNMP_FREE(to->authKeyKu);\n\n    if (from->authKeyKuLen > 0 &&\n        (to->authKeyKu = (u_char *) malloc(from->authKeyKuLen)) != NULL) {\n        to->authKeyKuLen = from->authKeyKuLen;\n        memcpy(to->authKeyKu, from->authKeyKu, to->authKeyKuLen);\n    } else {\n        to->authKeyKu = NULL;\n        to->authKeyKuLen = 0;\n    }\n\n\n    /*\n     * copy the privProtocol oid row pointer \n     */\n    SNMP_FREE(to->privProtocol);\n\n    if ((to->privProtocol =\n         snmp_duplicate_objid(from->privProtocol,\n                              from->privProtocolLen)) != NULL)\n        to->privProtocolLen = from->privProtocolLen;\n    else\n        to->privProtocolLen = 0;\n\n    /*\n     * copy the privKey \n     */\n    SNMP_FREE(to->privKey);\n\n    if (from->privKeyLen > 0 &&\n        (to->privKey = (u_char *) malloc(from->privKeyLen))\n        != NULL) {\n        to->privKeyLen = from->privKeyLen;\n        memcpy(to->privKey, from->privKey, to->privKeyLen);\n    } else {\n        to->privKey = NULL;\n        to->privKeyLen = 0;\n    }\n\n    /*\n     * copy the privKeyKu\n     */\n    SNMP_FREE(to->privKeyKu);\n    if (from->privKeyKuLen > 0 &&\n        (to->privKeyKu = (u_char *) malloc(from->privKeyKuLen)) != NULL) {\n        to->privKeyKuLen = from->privKeyKuLen;\n        memcpy(to->privKeyKu, from->privKeyKu, to->privKeyKuLen);\n    } else {\n        to->privKeyKu = NULL;\n        to->privKeyKuLen = 0;\n    }\n    return to;\n}\n#endif /* NETSNMP_NO_WRITE_SUPPORT */\n\n/*\n * usm_create_user(void):\n * create a default empty user, instantiating only the auth/priv\n * protocols to noAuth and noPriv OID pointers\n */\nstruct usmUser *\nusm_create_user(void)\n{\n    struct usmUser *newUser;\n\n    /*\n     * create the new user \n     */\n    newUser = (struct usmUser *) calloc(1, sizeof(struct usmUser));\n    if (newUser == NULL)\n        return NULL;\n\n    /*\n     * fill the auth/priv protocols \n     */\n    if ((newUser->authProtocol =\n         snmp_duplicate_objid(usmNoAuthProtocol,\n                              sizeof(usmNoAuthProtocol) / sizeof(oid))) ==\n        NULL)\n        return usm_free_user(newUser);\n    newUser->authProtocolLen = sizeof(usmNoAuthProtocol) / sizeof(oid);\n\n    if ((newUser->privProtocol =\n         snmp_duplicate_objid(usmNoPrivProtocol,\n                              sizeof(usmNoPrivProtocol) / sizeof(oid))) ==\n        NULL)\n        return usm_free_user(newUser);\n    newUser->privProtocolLen = sizeof(usmNoPrivProtocol) / sizeof(oid);\n\n    /*\n     * set the storage type to nonvolatile, and the status to ACTIVE \n     */\n    newUser->userStorageType = ST_NONVOLATILE;\n    newUser->userStatus = RS_ACTIVE;\n    return newUser;\n\n}                               /* end usm_clone_user() */\n\n/*\n * usm_create_initial_user(void):\n * creates an initial user, filled with the defaults defined in the\n * USM document.\n */\nstatic struct usmUser *\nusm_create_initial_user(const char *name,\n                        const oid * authProtocol, size_t authProtocolLen,\n                        const oid * privProtocol, size_t privProtocolLen)\n{\n    struct usmUser *newUser = usm_create_user();\n    if (newUser == NULL)\n        return NULL;\n\n    if ((newUser->name = strdup(name)) == NULL)\n        return usm_free_user(newUser);\n\n    if ((newUser->secName = strdup(name)) == NULL)\n        return usm_free_user(newUser);\n\n    if ((newUser->engineID =\n         snmpv3_generate_engineID(&newUser->engineIDLen)) == NULL)\n        return usm_free_user(newUser);\n\n    if ((newUser->cloneFrom = (oid *) malloc(sizeof(oid) * 2)) == NULL)\n        return usm_free_user(newUser);\n    newUser->cloneFrom[0] = 0;\n    newUser->cloneFrom[1] = 0;\n    newUser->cloneFromLen = 2;\n\n    SNMP_FREE(newUser->privProtocol);\n    if ((newUser->privProtocol = snmp_duplicate_objid(privProtocol,\n                                                      privProtocolLen)) ==\n        NULL) {\n        return usm_free_user(newUser);\n    }\n    newUser->privProtocolLen = privProtocolLen;\n\n    SNMP_FREE(newUser->authProtocol);\n    if ((newUser->authProtocol = snmp_duplicate_objid(authProtocol,\n                                                      authProtocolLen)) ==\n        NULL) {\n        return usm_free_user(newUser);\n    }\n    newUser->authProtocolLen = authProtocolLen;\n\n    newUser->userStatus = RS_ACTIVE;\n    newUser->userStorageType = ST_READONLY;\n\n    return newUser;\n}\n\n/*\n * usm_save_user(): saves a user to the persistent cache \n */\nstatic void\nusm_save_user(struct usmUser *user, const char *token, const char *type)\n{\n    char            line[4096];\n    char           *cptr;\n\n    memset(line, 0, sizeof(line));\n\n    sprintf(line, \"%s %d %d \", token, user->userStatus,\n            user->userStorageType);\n    cptr = &line[strlen(line)]; /* the NULL */\n    cptr =\n        read_config_save_octet_string(cptr, user->engineID,\n                                      user->engineIDLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_octet_string(cptr, (u_char *) user->name,\n                                         (user->name == NULL) ? 0 :\n                                         strlen(user->name));\n    *cptr++ = ' ';\n    cptr = read_config_save_octet_string(cptr, (u_char *) user->secName,\n                                         (user->secName == NULL) ? 0 :\n                                         strlen(user->secName));\n    *cptr++ = ' ';\n    cptr =\n        read_config_save_objid(cptr, user->cloneFrom, user->cloneFromLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_objid(cptr, user->authProtocol,\n                                  user->authProtocolLen);\n    *cptr++ = ' ';\n    cptr =\n        read_config_save_octet_string(cptr, user->authKey,\n                                      user->authKeyLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_objid(cptr, user->privProtocol,\n                                  user->privProtocolLen);\n    *cptr++ = ' ';\n    cptr =\n        read_config_save_octet_string(cptr, user->privKey,\n                                      user->privKeyLen);\n    *cptr++ = ' ';\n    cptr = read_config_save_octet_string(cptr, user->userPublicString,\n                                         user->userPublicStringLen);\n\n    read_config_store(type, line);\n}\n\nstatic void\nusm_save_users_from_list(struct usmUser *puserList, const char *token,\n                         const char *type)\n{\n    struct usmUser *uptr;\n    for (uptr = puserList; uptr != NULL; uptr = uptr->next) {\n        if (uptr->userStorageType == ST_NONVOLATILE)\n            usm_save_user(uptr, token, type);\n    }\n}\n\n/*\n * usm_save_users(): saves a list of users to the persistent cache \n */\nstatic void\nusm_save_users(const char *token, const char *type)\n{\n    usm_save_users_from_list(userList, token, type);\n}\n\n/*\n * this is a callback that can store all known users based on a\n * previously registered application ID \n */\nstatic int\nusm_store_users(int majorID, int minorID, void *serverarg, void *clientarg)\n{\n    /*\n     * figure out our application name \n     */\n    char           *appname = (char *) clientarg;\n    if (appname == NULL) {\n        appname = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\tNETSNMP_DS_LIB_APPTYPE);\n    }\n\n    /*\n     * save the user base \n     */\n    usm_save_users(\"usmUser\", appname);\n\n    /*\n     * never fails \n     */\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * usm_parse_user(): reads in a line containing a saved user profile\n * and returns a pointer to a newly created struct usmUser. \n */\nstatic struct usmUser *\nusm_read_user(const char *line)\n{\n    struct usmUser *user;\n    size_t          len, proper_length, privtype;\n\n    user = usm_create_user();\n    if (user == NULL)\n        return NULL;\n\n    user->userStatus = atoi(line);\n    line = skip_token_const(line);\n    user->userStorageType = atoi(line);\n    line = skip_token_const(line);\n    line = read_config_read_octet_string_const(line, &user->engineID,\n                                               &user->engineIDLen);\n\n    /*\n     * set the lcd entry for this engineID to the minimum boots/time\n     * values so that its a known engineid and won't return a report pdu.\n     * This is mostly important when receiving v3 traps so that the usm\n     * will at least continue processing them. \n     */\n    set_enginetime(user->engineID, user->engineIDLen, 1, 0, 0);\n\n    line = read_config_read_octet_string(line, (u_char **) & user->name,\n                                         &len);\n    line = read_config_read_octet_string(line, (u_char **) & user->secName,\n                                         &len);\n    SNMP_FREE(user->cloneFrom);\n    user->cloneFromLen = 0;\n\n    line = read_config_read_objid_const(line, &user->cloneFrom,\n                                        &user->cloneFromLen);\n\n    SNMP_FREE(user->authProtocol);\n    user->authProtocolLen = 0;\n\n    line = read_config_read_objid_const(line, &user->authProtocol,\n                                        &user->authProtocolLen);\n    line = read_config_read_octet_string_const(line, &user->authKey,\n                                               &user->authKeyLen);\n    SNMP_FREE(user->privProtocol);\n    user->privProtocolLen = 0;\n\n    line = read_config_read_objid_const(line, &user->privProtocol,\n                                        &user->privProtocolLen);\n    line = read_config_read_octet_string(line, &user->privKey,\n                                         &user->privKeyLen);\n\n    privtype = sc_get_privtype(user->privProtocol, user->privProtocolLen);\n    proper_length = sc_get_proper_priv_length_bytype(privtype);\n    if (USM_CREATE_USER_PRIV_DES == privtype)\n        proper_length *= 2; /* ?? we store salt with key */\n    /* For backwards compatibility */\n    if (user->privKeyLen > proper_length) {\n        user->privKeyLen = proper_length;\n    }\n\n    line = read_config_read_octet_string(line, &user->userPublicString,\n                                         &user->userPublicStringLen);\n    return user;\n}\n\n/*\n * snmpd.conf parsing routines \n */\nstatic void\nusm_parse_config_usmUser(const char *token, char *line)\n{\n    struct usmUser *uptr;\n\n    uptr = usm_read_user(line);\n    if ( uptr)\n        usm_add_user(uptr);\n}\n\n/*******************************************************************-o-******\n * usm_set_password\n *\n * Parameters:\n *\t*token\n *\t*line\n *      \n *\n * format: userSetAuthPass     secname engineIDLen engineID pass\n *     or: userSetPrivPass     secname engineIDLen engineID pass \n *     or: userSetAuthKey      secname engineIDLen engineID KuLen Ku\n *     or: userSetPrivKey      secname engineIDLen engineID KuLen Ku \n *     or: userSetAuthLocalKey secname engineIDLen engineID KulLen Kul\n *     or: userSetPrivLocalKey secname engineIDLen engineID KulLen Kul \n *\n * type is:\t1=passphrase; 2=Ku; 3=Kul.\n *\n *\n * ASSUMES  Passwords are null-terminated printable strings.\n */\nstatic void\nusm_set_password(const char *token, char *line)\n{\n    char           *cp;\n    char            nameBuf[SNMP_MAXBUF];\n    u_char         *engineID = NULL;\n    size_t          engineIDLen = 0;\n    struct usmUser *user;\n\n    cp = copy_nword(line, nameBuf, sizeof(nameBuf));\n    if (cp == NULL) {\n        config_perror(\"invalid name specifier\");\n        return;\n    }\n\n    DEBUGMSGTL((\"usm\", \"comparing: %s and %s\\n\", cp, WILDCARDSTRING));\n    if (strncmp(cp, WILDCARDSTRING, strlen(WILDCARDSTRING)) == 0) {\n        /*\n         * match against all engineIDs we know about \n         */\n        cp = skip_token(cp);\n        for (user = userList; user != NULL; user = user->next) {\n            if (user->secName && strcmp(user->secName, nameBuf) == 0) {\n                usm_set_user_password(user, token, cp);\n            }\n        }\n    } else {\n        cp = read_config_read_octet_string(cp, &engineID, &engineIDLen);\n        if (cp == NULL) {\n            config_perror(\"invalid engineID specifier\");\n            SNMP_FREE(engineID);\n            return;\n        }\n\n        user = usm_get_user(engineID, engineIDLen, nameBuf);\n        if (user == NULL) {\n            config_perror(\"not a valid user/engineID pair\");\n            SNMP_FREE(engineID);\n            return;\n        }\n        usm_set_user_password(user, token, cp);\n        SNMP_FREE(engineID);\n    }\n}\n\n/*\n * uses the rest of LINE to configure USER's password of type TOKEN \n */\nvoid\nusm_set_user_password(struct usmUser *user, const char *token, char *line)\n{\n    char           *cp = line;\n    u_char         *engineID = user->engineID;\n    size_t          engineIDLen = user->engineIDLen;\n\n    u_char        **key;\n    size_t         *keyLen;\n    u_char          userKey[SNMP_MAXBUF_SMALL];\n    size_t          userKeyLen = SNMP_MAXBUF_SMALL;\n    u_char         *userKeyP = userKey;\n    int             type, ret;\n\n    /*\n     * Retrieve the \"old\" key and set the key type.\n     */\n    if (!token) {\n        return;\n    } else if (strcmp(token, \"userSetAuthPass\") == 0) {\n        key = &user->authKey;\n        keyLen = &user->authKeyLen;\n        type = 0;\n    } else if (strcmp(token, \"userSetPrivPass\") == 0) {\n        key = &user->privKey;\n        keyLen = &user->privKeyLen;\n        type = 0;\n    } else if (strcmp(token, \"userSetAuthKey\") == 0) {\n        key = &user->authKey;\n        keyLen = &user->authKeyLen;\n        type = 1;\n    } else if (strcmp(token, \"userSetPrivKey\") == 0) {\n        key = &user->privKey;\n        keyLen = &user->privKeyLen;\n        type = 1;\n    } else if (strcmp(token, \"userSetAuthLocalKey\") == 0) {\n        key = &user->authKey;\n        keyLen = &user->authKeyLen;\n        type = 2;\n    } else if (strcmp(token, \"userSetPrivLocalKey\") == 0) {\n        key = &user->privKey;\n        keyLen = &user->privKeyLen;\n        type = 2;\n    } else {\n        /*\n         * no old key, or token was not recognized \n         */\n        return;\n    }\n\n    if (*key) {\n        /*\n         * (destroy and) free the old key \n         */\n        memset(*key, 0, *keyLen);\n        SNMP_FREE(*key);\n    }\n\n    if (type == 0) {\n        /*\n         * convert the password into a key \n         */\n        if (cp == NULL) {\n            config_perror(\"missing user password\");\n            return;\n        }\n        ret = generate_Ku(user->authProtocol, user->authProtocolLen,\n                          (u_char *) cp, strlen(cp), userKey, &userKeyLen);\n\n        if (ret != SNMPERR_SUCCESS) {\n            config_perror(\"setting key failed (in sc_genKu())\");\n            return;\n        }\n        /* save master key */\n        if (user->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            if (userKey == user->privKey) {\n                user->privKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                user->privKeyKuLen = userKeyLen;\n            } else if (userKey == user->authKey) {\n                user->authKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                user->authKeyKuLen = userKeyLen;\n            }\n        }\n    } else if (type == 1) {\n        cp = read_config_read_octet_string(cp, &userKeyP, &userKeyLen);\n\n        if (cp == NULL) {\n            config_perror(\"invalid user key\");\n            return;\n        }\n    }\n\n    if (type < 2) {\n        *key = (u_char *) malloc(SNMP_MAXBUF_SMALL);\n        *keyLen = SNMP_MAXBUF_SMALL;\n        ret = generate_kul(user->authProtocol, user->authProtocolLen,\n                           engineID, engineIDLen,\n                           userKey, userKeyLen, *key, keyLen);\n        if (ret != SNMPERR_SUCCESS) {\n            config_perror(\"setting key failed (in generate_kul())\");\n            return;\n        }\n\n        /*\n         * (destroy and) free the old key \n         */\n        memset(userKey, 0, sizeof(userKey));\n\n    } else {\n        /*\n         * the key is given, copy it in \n         */\n        cp = read_config_read_octet_string(cp, key, keyLen);\n\n        if (cp == NULL) {\n            config_perror(\"invalid localized user key\");\n            return;\n        }\n    }\n\n    if (key == &user->privKey) {\n        ret = usm_extend_user_kul(user, *keyLen);\n        if (SNMPERR_SUCCESS != ret) {\n            config_perror(\"error extending localized user key\");\n            return;\n        }\n    }\n}                               /* end usm_set_password() */\n\n/*\n * create a usm user from a string.\n *\n * The format for the string is described in the createUser\n * secion of the snmpd.conf man page.\n *\n * On success, a pointer to the created usmUser struct is returned.\n * On error, a NULL pointer is returned. In this case, if a pointer to a\n *    char pointer is provided in errorMsg, an error string is returned.\n *    This error string points to a static message, and should not be\n *    freed.\n */\nstatic struct usmUser *\nusm_create_usmUser_from_string(char *line, const char **errorMsg)\n{\n    char           *cp;\n    const char     *dummy;\n    char            buf[SNMP_MAXBUF_MEDIUM];\n    struct usmUser *newuser;\n    u_char          userKey[SNMP_MAXBUF_SMALL], *tmpp;\n    size_t          userKeyLen = SNMP_MAXBUF_SMALL;\n    size_t          privKeySize;\n    size_t          ret;\n    int             ret2, properLen, properPrivKeyLen;\n    const oid      *def_auth_prot, *def_priv_prot;\n    size_t          def_auth_prot_len, def_priv_prot_len;\n    netsnmp_priv_alg_info *pai;\n\n    def_auth_prot = get_default_authtype(&def_auth_prot_len);\n    def_priv_prot = get_default_privtype(&def_priv_prot_len);\n\n    if (NULL == line)\n        return NULL;\n\n#ifdef NETSNMP_ENABLE_TESTING_CODE\n    DEBUGMSGTL((\"usmUser\", \"new user %s\\n\", line)); /* logs passphrases */\n#endif\n\n    if (NULL == errorMsg)\n        errorMsg = &dummy;\n    *errorMsg = NULL; /* no errors yet */\n\n    newuser = usm_create_user();\n    if (newuser == NULL) {\n        *errorMsg = \"malloc failure creating new user\";\n        goto fail;\n    }\n\n    /*\n     * READ: Security Name \n     */\n    cp = copy_nword(line, buf, sizeof(buf));\n\n    /*\n     * check for (undocumented) 'keep master key' flag. so far, this is\n     * just used for users for informs (who need non-localized keys).\n     */\n    if (strcmp(buf, \"-M\") == 0) {\n        newuser->flags |= USMUSER_FLAG_KEEP_MASTER_KEY;\n        cp = copy_nword(cp, buf, sizeof(buf));\n    }\n\n    /*\n     * might be a -e ENGINEID argument \n     */\n    if (strcmp(buf, \"-e\") == 0) {\n        size_t          ebuf_len = 32, eout_len = 0;\n        u_char         *ebuf = (u_char *) malloc(ebuf_len);\n\n        if (ebuf == NULL) {\n            *errorMsg = \"malloc failure processing -e flag\";\n            goto fail;\n        }\n\n        /*\n         * Get the specified engineid from the line.  \n         */\n        cp = copy_nword(cp, buf, sizeof(buf));\n        if (!snmp_hex_to_binary(&ebuf, &ebuf_len, &eout_len, 1, buf)) {\n            *errorMsg = \"invalid EngineID argument to -e\";\n            SNMP_FREE(ebuf);\n            goto fail;\n        }\n\n        newuser->engineID = ebuf;\n        newuser->engineIDLen = eout_len;\n        cp = copy_nword(cp, buf, sizeof(buf));\n    } else {\n        newuser->engineID = snmpv3_generate_engineID(&ret);\n        if (ret == 0) {\n            goto fail;\n        }\n        newuser->engineIDLen = ret;\n    }\n\n    newuser->secName = strdup(buf);\n    newuser->name = strdup(buf);\n\n    if (!cp) {\n#ifdef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n        /** no passwords ok iff defaults are noauth/nopriv */\n        if (snmp_oid_compare(usmNoAuthProtocol, OID_LENGTH(usmNoAuthProtocol),\n                             def_auth_prot, def_auth_prot_len) != 0) {\n            *errorMsg = \"no authentication pass phrase\";\n            goto fail;\n        }\n        if (snmp_oid_compare(usmNoPrivProtocol, OID_LENGTH(usmNoPrivProtocol),\n                             def_priv_prot, def_priv_prot_len) != 0) {\n            *errorMsg = \"no privacy pass phrase\";\n            goto fail;\n        }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n        goto add;               /* no authentication or privacy type */\n    }\n\n    /*\n     * READ: Authentication Type \n     */\n    newuser->authProtocol[0] = 0;\n    cp = copy_nword(cp, buf, sizeof(buf));\n    if ((strncmp(cp, \"default\", 7) == 0) && (NULL != def_auth_prot)) {\n        SNMP_FREE(newuser->authProtocol);\n        newuser->authProtocol = snmp_duplicate_objid(def_auth_prot,\n                                                     def_auth_prot_len);\n        if (newuser->authProtocol == NULL) {\n            *errorMsg = \"malloc failed\";\n            goto fail;\n        }\n        newuser->authProtocolLen = def_auth_prot_len;\n    } else {\n        const oid *auth_prot;\n        int auth_type = usm_lookup_auth_type(buf);\n        if (auth_type < 0) {\n            *errorMsg = \"unknown authProtocol\";\n            goto fail;\n        }\n        auth_prot = sc_get_auth_oid(auth_type, &newuser->authProtocolLen);\n        if (auth_prot) {\n            SNMP_FREE(newuser->authProtocol);\n            newuser->authProtocol =\n                snmp_duplicate_objid(auth_prot, newuser->authProtocolLen);\n        }\n        if (newuser->authProtocol == NULL) {\n            *errorMsg = \"malloc failed\";\n            goto fail;\n        }\n    }\n    if (0 == newuser->authProtocol[0]) {\n        *errorMsg = \"Unknown authentication protocol\";\n        goto fail;\n    }\n#ifdef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n    if (snmp_oid_compare(newuser->authProtocol, newuser->authProtocolLen,\n                         def_auth_prot, def_auth_prot_len) != 0) {\n        *errorMsg = \"auth protocol does not match system policy\";\n        goto fail;\n    }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n\n    /*\n     * READ: Authentication Pass Phrase or key\n     */\n    cp = copy_nword(cp, buf, sizeof(buf));\n    if (strcmp(buf,\"-m\") == 0) {\n        /* a master key is specified */\n        cp = copy_nword(cp, buf, sizeof(buf));\n        ret = sizeof(userKey);\n        tmpp = userKey;\n        userKeyLen = 0;\n        if (!snmp_hex_to_binary(&tmpp, &ret, &userKeyLen, 0, buf)) {\n            *errorMsg = \"invalid key value argument to -m\";\n            goto fail;\n        }\n        /* save master key */\n        if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            newuser->authKeyKu = netsnmp_memdup(userKey, userKeyLen);\n            newuser->authKeyKuLen = userKeyLen;\n        }\n    } else if (strcmp(buf,\"-l\") != 0) {\n        /* a password is specified */\n        userKeyLen = sizeof(userKey);\n        ret2 = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,\n                          (u_char *) buf, strlen(buf), userKey, &userKeyLen);\n        if (ret2 != SNMPERR_SUCCESS) {\n            *errorMsg = \"could not generate the authentication key from the supplied pass phrase.\";\n            goto fail;\n        }\n        /* save master key */\n        if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            newuser->authKeyKu = netsnmp_memdup(userKey, userKeyLen);\n            newuser->authKeyKuLen = userKeyLen;\n        }\n    }        \n        \n    /*\n     * And turn it into a localized key \n     */\n    properLen = sc_get_proper_auth_length_bytype(\n        sc_get_authtype(newuser->authProtocol, newuser->authProtocolLen));\n    if (properLen <= 0) {\n        *errorMsg = \"Could not get proper authentication protocol key length\";\n        goto fail;\n    }\n    newuser->authKey = (u_char *) malloc(properLen);\n    newuser->authKeyLen = properLen;\n\n    if (strcmp(buf,\"-l\") == 0) {\n        /* a local key is directly specified */\n        cp = copy_nword(cp, buf, sizeof(buf));\n        ret = newuser->authKeyLen;\n        newuser->authKeyLen = 0;\n        if (!snmp_hex_to_binary(&newuser->authKey, &ret,\n                                &newuser->authKeyLen, 0, buf)) {\n            *errorMsg = \"invalid key value argument to -l\";\n            goto fail;\n        }\n        if (properLen != newuser->authKeyLen) {\n            *errorMsg = \"improper key length to -l\";\n            goto fail;\n        }\n    } else {\n        ret2 = generate_kul(newuser->authProtocol, newuser->authProtocolLen,\n                           newuser->engineID, newuser->engineIDLen,\n                           userKey, userKeyLen,\n                           newuser->authKey, &newuser->authKeyLen);\n        if (ret2 != SNMPERR_SUCCESS) {\n            *errorMsg = \"could not generate localized authentication key (Kul) from the master key (Ku).\";\n            goto fail;\n        }\n    }\n\n    if (!cp) {\n#ifndef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n        goto add;               /* no privacy type (which is legal) */\n#else\n        if (snmp_oid_compare(usmNoPrivProtocol, OID_LENGTH(usmNoPrivProtocol),\n                             def_priv_prot, def_priv_prot_len) == 0)\n            goto add;\n        else {\n            *errorMsg = \"priv protocol does not match system policy\";\n            goto fail;\n        }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n    }\n\n    /*\n     * READ: Privacy Type \n     */\n    newuser->privProtocol[0] = 0;\n    cp = copy_nword(cp, buf, sizeof(buf));\n    if ((strncmp(buf, \"default\", 7) == 0) && (NULL != def_priv_prot)) {\n        SNMP_FREE(newuser->privProtocol);\n        newuser->privProtocol =\n            snmp_duplicate_objid(def_priv_prot, def_priv_prot_len);\n        if (newuser->privProtocol == NULL) {\n            *errorMsg = \"malloc failed\";\n            goto fail;\n        }\n        newuser->privProtocolLen = def_priv_prot_len;\n        pai = sc_get_priv_alg_byoid(newuser->privProtocol,\n                                    newuser->privProtocolLen);\n    } else {\n        int priv_type = usm_lookup_priv_type(buf);\n        if (priv_type < 0) {\n            *errorMsg = \"unknown privProtocol\";\n            DEBUGMSGTL((\"usmUser\", \"%s %s\\n\", *errorMsg, buf));\n            goto fail;\n        }\n        DEBUGMSGTL((\"9:usmUser\", \"privProtocol %s\\n\", buf));\n        pai = sc_get_priv_alg_bytype(priv_type);\n        if (pai) {\n            SNMP_FREE(newuser->privProtocol);\n            newuser->privProtocolLen = pai->oid_len;\n            newuser->privProtocol =\n                snmp_duplicate_objid(pai->alg_oid, newuser->privProtocolLen);\n            DEBUGMSGTL((\"9:usmUser\", \"pai %s\\n\", pai->name));\n            if (newuser->privProtocol == NULL) {\n                *errorMsg = \"malloc failed\";\n                goto fail;\n            }\n        }\n    }\n    if (NULL == pai) {\n        *errorMsg = \"priv protocol lookup failed\";\n        goto fail;\n    }\n\n    if (0 == newuser->privProtocol[0] && NULL == *errorMsg)\n        *errorMsg = \"Unknown privacy protocol\";\n    if (NULL != *errorMsg)\n        goto fail;\n#ifdef NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV\n    if (snmp_oid_compare(newuser->privProtocol, newuser->privProtocolLen,\n                         def_priv_prot, def_priv_prot_len) != 0) {\n        *errorMsg = \"priv protocol does not match system policy\";\n        goto fail;\n    }\n#endif /* NETSNMP_FORCE_SYSTEM_V3_AUTHPRIV */\n\n    properPrivKeyLen = pai->proper_length;\n    if (USM_CREATE_USER_PRIV_DES == pai->type)\n        properPrivKeyLen *= 2; /* ?? we store salt with key */\n\n    /*\n     * READ: Encryption Pass Phrase or key\n     */\n    if (!cp) {\n        /*\n         * assume the same as the authentication key \n         */\n        newuser->privKey = netsnmp_memdup(newuser->authKey,\n                                          newuser->authKeyLen);\n        privKeySize = newuser->privKeyLen = newuser->authKeyLen;\n        if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n            newuser->privKeyKu = netsnmp_memdup(newuser->authKeyKu,\n                                                newuser->authKeyKuLen);\n            newuser->privKeyKuLen = newuser->authKeyKuLen;\n        }\n    } else {\n        cp = copy_nword(cp, buf, sizeof(buf));\n        \n        if (strcmp(buf,\"-m\") == 0) {\n            /* a master key is specified */\n            cp = copy_nword(cp, buf, sizeof(buf));\n            ret = sizeof(userKey);\n            tmpp = userKey;\n            userKeyLen = 0;\n            if (!snmp_hex_to_binary(&tmpp, &ret, &userKeyLen, 0, buf)) {\n                *errorMsg = \"invalid key value argument to -m\";\n                goto fail;\n            }\n            /* save master key */\n            if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n                newuser->privKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                newuser->privKeyKuLen = userKeyLen;\n            }\n        } else if (strcmp(buf,\"-l\") != 0) {\n            /* a password is specified */\n            userKeyLen = sizeof(userKey);\n            ret2 = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,\n                              (u_char*)buf, strlen(buf), userKey, &userKeyLen);\n            if (ret2 != SNMPERR_SUCCESS) {\n                *errorMsg = \"could not generate the privacy key from the supplied pass phrase.\";\n                goto fail;\n            }\n            /* save master key */\n            if (newuser->flags & USMUSER_FLAG_KEEP_MASTER_KEY) {\n                newuser->privKeyKu = netsnmp_memdup(userKey, userKeyLen);\n                newuser->privKeyKuLen = userKeyLen;\n            }\n        }\n\n        /*\n         * And turn it into a localized key\n         * Allocate enough space for greater of auth mac and privKey len.\n         */\n        privKeySize = SNMP_MAX(properPrivKeyLen, properLen);\n        newuser->privKey = (u_char *) malloc(privKeySize);\n        newuser->privKeyLen = privKeySize;\n\n        if (strcmp(buf,\"-l\") == 0) {\n            /* a local key is directly specified */\n            cp = copy_nword(cp, buf, sizeof(buf));\n            ret = newuser->privKeyLen;\n            newuser->privKeyLen = 0;\n            if (!snmp_hex_to_binary(&newuser->privKey, &ret,\n                                    &newuser->privKeyLen, 0, buf)) {\n                *errorMsg = \"invalid key value argument to -l\";\n                goto fail;\n            }\n        } else {\n            ret2 = generate_kul(newuser->authProtocol, newuser->authProtocolLen,\n                               newuser->engineID, newuser->engineIDLen,\n                               userKey, userKeyLen,\n                               newuser->privKey, &newuser->privKeyLen);\n            if (ret2 != SNMPERR_SUCCESS) {\n                *errorMsg = \"could not generate localized privacy key (Kul) from the master key (Ku).\";\n                goto fail;\n            }\n        }\n\n        if (newuser->privKeyLen < properPrivKeyLen) {\n            ret = usm_extend_user_kul(newuser, properPrivKeyLen);\n            if (ret != SNMPERR_SUCCESS) {\n                *errorMsg = \"could not extend localized privacy key to required length.\";\n                goto fail;\n            }\n        }\n    }\n\n    if ((newuser->privKeyLen >= properPrivKeyLen) || (properPrivKeyLen == 0)){\n        DEBUGMSGTL((\"9:usmUser\", \"truncating privKeyLen from %\" NETSNMP_PRIz \"d to %d\\n\",\n                    newuser->privKeyLen, properPrivKeyLen));\n        newuser->privKeyLen = properPrivKeyLen;\n    }\n    else {\n        DEBUGMSGTL((\"usmUser\",\n                    \"privKey length %\" NETSNMP_PRIz \"d < %d required by privProtocol\\n\",\n                    newuser->privKeyLen, properPrivKeyLen));\n      *errorMsg = \"privKey length is less than required by privProtocol\";\n      goto fail;\n    }\n\n  add:\n    usm_add_user(newuser);\n    DEBUGMSGTL((\"usmUser\", \"created a new user %s at \", newuser->secName));\n    DEBUGMSGHEX((\"usmUser\", newuser->engineID, newuser->engineIDLen));\n    DEBUGMSG((\"usmUser\", \"\\n\"));\n\n    return newuser;\n\n  fail:\n    usm_free_user(newuser);\n    return NULL;\n}\n\nstatic void\nusm_parse_create_usmUser(const char *token, char *line)\n{\n    const char *error = NULL;\n    usm_create_usmUser_from_string(line, &error);\n    if (error)\n        config_perror(error);\n}\n\nstatic void\nsnmpv3_authtype_conf(const char *word, char *cptr)\n{\n    int auth_type = usm_lookup_auth_type(cptr);\n    if (auth_type < 0)\n        config_perror(\"Unknown authentication type\");\n    defaultAuthType = sc_get_auth_oid(auth_type, &defaultAuthTypeLen);\n    DEBUGMSGTL((\"snmpv3\", \"set default authentication type: %s\\n\", cptr));\n}\n\nconst oid      *\nget_default_authtype(size_t * len)\n{\n    if (defaultAuthType == NULL) {\n        defaultAuthType = SNMP_DEFAULT_AUTH_PROTO;\n        defaultAuthTypeLen = SNMP_DEFAULT_AUTH_PROTOLEN;\n    }\n    if (len)\n        *len = defaultAuthTypeLen;\n    return defaultAuthType;\n}\n\nstatic void\nsnmpv3_privtype_conf(const char *word, char *cptr)\n{\n    int priv_type = usm_lookup_priv_type(cptr);\n    if (priv_type < 0)\n        config_perror(\"Unknown privacy type\");\n    defaultPrivType = sc_get_priv_oid(priv_type, &defaultPrivTypeLen);\n    DEBUGMSGTL((\"snmpv3\", \"set default privacy type: %s\\n\", cptr));\n}\n\nconst oid      *\nget_default_privtype(size_t * len)\n{\n    if (defaultPrivType == NULL) {\n        defaultPrivType = SNMP_DEFAULT_PRIV_PROTO;\n        defaultPrivTypeLen = SNMP_DEFAULT_PRIV_PROTOLEN;\n    }\n    if (len)\n        *len = defaultPrivTypeLen;\n    return defaultPrivType;\n}\n\nvoid\ninit_usm_conf(const char *app)\n{\n    register_config_handler(app, \"usmUser\",\n                                  usm_parse_config_usmUser, NULL, NULL);\n    register_config_handler(app, \"createUser\",\n                                  usm_parse_create_usmUser, NULL,\n                                  \"username [-e ENGINEID] (MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224|default) authpassphrase [(DES|AES|default) [privpassphrase]]\");\n\n    /*\n     * we need to be called back later\n     */\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,\n                           usm_store_users, NULL);\n}\n\n/*\n * initializations for the USM.\n *\n * Should be called after the (engineid) configuration files have been read.\n *\n * Set \"arbitrary\" portion of salt to a random number.\n */\nstatic int\ninit_usm_post_config(int majorid, int minorid, void *serverarg,\n                     void *clientarg)\n{\n    size_t          salt_integer_len = sizeof(salt_integer);\n\n    if (sc_random((u_char *) & salt_integer, &salt_integer_len) !=\n        SNMPERR_SUCCESS) {\n        DEBUGMSGTL((\"usm\", \"sc_random() failed: using time() as salt.\\n\"));\n        salt_integer = (u_int) time(NULL);\n    }\n\n#ifdef HAVE_AES\n    salt_integer_len = sizeof (salt_integer64_1);\n    if (sc_random((u_char *) & salt_integer64_1, &salt_integer_len) !=\n        SNMPERR_SUCCESS) {\n        DEBUGMSGTL((\"usm\", \"sc_random() failed: using time() as aes1 salt.\\n\"));\n        salt_integer64_1 = (u_int) time(NULL);\n    }\n    salt_integer_len = sizeof (salt_integer64_1);\n    if (sc_random((u_char *) & salt_integer64_2, &salt_integer_len) !=\n        SNMPERR_SUCCESS) {\n        DEBUGMSGTL((\"usm\", \"sc_random() failed: using time() as aes2 salt.\\n\"));\n        salt_integer64_2 = (u_int) time(NULL);\n    }\n#endif\n\n#ifndef NETSNMP_DISABLE_MD5\n    noNameUser = usm_create_initial_user(\"\", usmHMACMD5AuthProtocol,\n                                         OID_LENGTH(usmHMACMD5AuthProtocol),\n                                         SNMP_DEFAULT_PRIV_PROTO,\n                                         SNMP_DEFAULT_PRIV_PROTOLEN);\n#else\n    noNameUser = usm_create_initial_user(\"\", usmHMACSHA1AuthProtocol,\n                                         OID_LENGTH(usmHMACSHA1AuthProtocol),\n                                         SNMP_DEFAULT_PRIV_PROTO,\n                                         SNMP_DEFAULT_PRIV_PROTOLEN);\n#endif\n\n    if ( noNameUser ) {\n        SNMP_FREE(noNameUser->engineID);\n        noNameUser->engineIDLen = 0;\n    }\n\n    return SNMPERR_SUCCESS;\n}                               /* end init_usm_post_config() */\n\nstatic int\ndeinit_usm_post_config(int majorid, int minorid, void *serverarg,\n\t\t       void *clientarg)\n{\n    if (usm_free_user(noNameUser) != NULL) {\n\tDEBUGMSGTL((\"deinit_usm_post_config\", \"could not free initial user\\n\"));\n\treturn SNMPERR_GENERR;\n    }\n    noNameUser = NULL;\n\n    DEBUGMSGTL((\"deinit_usm_post_config\", \"initial user removed\\n\"));\n    return SNMPERR_SUCCESS;\n}                               /* end deinit_usm_post_config() */\n\nvoid\ninit_usm(void)\n{\n    struct snmp_secmod_def *def;\n    char *type;\n\n    DEBUGMSGTL((\"init_usm\", \"unit_usm: %\" NETSNMP_PRIo \"u %\" NETSNMP_PRIo \"u\\n\",\n                usmNoPrivProtocol[0], usmNoPrivProtocol[1]));\n\n    sc_init();                  /* initalize scapi code */\n\n    /*\n     * register ourselves as a security service\n     */\n    def = SNMP_MALLOC_STRUCT(snmp_secmod_def);\n    if (def == NULL)\n        return;\n    /*\n     * XXX: def->init_sess_secmod move stuff from snmp_api.c\n     */\n    def->encode_reverse = usm_secmod_rgenerate_out_msg;\n    def->encode_forward = usm_secmod_generate_out_msg;\n    def->decode = usm_secmod_process_in_msg;\n    def->pdu_clone = usm_clone;\n    def->pdu_free_state_ref = usm_free_usmStateReference;\n    def->session_setup = usm_session_init;\n    def->handle_report = usm_handle_report;\n    def->probe_engineid = usm_discover_engineid;\n    def->post_probe_engineid = usm_create_user_from_session_hook;\n    if (register_sec_mod(USM_SEC_MODEL_NUMBER, \"usm\", def) != SNMPERR_SUCCESS) {\n        SNMP_FREE(def);\n        snmp_log(LOG_ERR, \"could not register usm sec mod\\n\");\n        return;\n    }\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,\n                           init_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           deinit_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_engineID, NULL);\n\n    register_config_handler(\"snmp\", \"defAuthType\", snmpv3_authtype_conf,\n                            NULL, \"MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224\");\n    register_config_handler(\"snmp\", \"defPrivType\", snmpv3_privtype_conf,\n                            NULL,\n                            \"DES\"\n#ifdef HAVE_AES\n                            \"|AES|AES-128\"\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n                            \"|AES-192|AES-256\"\n#endif /* NETSNMP_DRAFT_BLUMENTHAL_AES_04 */\n#else\n                            \" (AES support not available)\"\n#endif\n                           );\n\n    /*\n     * Free stuff at shutdown time\n     */\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_enginetime_on_shutdown, NULL);\n\n\n    type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE);\n\n    register_config_handler(type, \"userSetAuthPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetAuthKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetPrivKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetAuthLocalKey\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivLocalKey\", usm_set_password,\n                            NULL, NULL);\n}\n\nvoid\nshutdown_usm(void)\n{\n    free_etimelist();\n    clear_user_list();\n}\n"], "filenames": ["snmplib/snmp_client.c", "snmplib/snmpusm.c"], "buggy_code_start_loc": [408, 87], "buggy_code_end_loc": [428, 4918], "fixing_code_start_loc": [408, 88], "fixing_code_end_loc": [415, 4942], "type": "CWE-415", "message": "net-snmp before 5.8.1.pre1 has a double free in usm_free_usmStateReference in snmplib/snmpusm.c via an SNMPv3 GetBulk request. NOTE: this affects net-snmp packages shipped to end users by multiple Linux distributions, but might not affect an upstream release.", "other": {"cve": {"id": "CVE-2019-20892", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-25T10:15:10.667", "lastModified": "2022-09-02T15:31:24.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "net-snmp before 5.8.1.pre1 has a double free in usm_free_usmStateReference in snmplib/snmpusm.c via an SNMPv3 GetBulk request. NOTE: this affects net-snmp packages shipped to end users by multiple Linux distributions, but might not affect an upstream release."}, {"lang": "es", "value": "net-snmp versiones anteriores a 5.8.1.pre1 presenta una doble liberaci\u00f3n en la funci\u00f3n usm_free_usmStateReference en el archivo snmplib/snmpusm.c por medio de una petici\u00f3n SNMPv3 GetBulk. NOTA: esto afecta a los paquetes net-snmp enviados a los usuarios finales por m\u00faltiples distribuciones de Linux, pero podr\u00eda no afectar una versi\u00f3n anterior"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:net-snmp:net-snmp:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.8", "matchCriteriaId": "16D20F6E-7F28-4453-8537-2AF8AC5E45CB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:zfs_storage_appliance_kit:8.8:*:*:*:*:*:*:*", "matchCriteriaId": "D3E503FB-6279-4D4A-91D8-E237ECF9D2B0"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2020/06/25/4", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/net-snmp/+bug/1877027", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1663027", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202008-12", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://sourceforge.net/p/net-snmp/bugs/2923/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4410-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9"}}