{"buggy_code": ["/*****************************************************************************\n * schroedinger.c: Dirac decoder module making use of libschroedinger.\n *          (http://www.bbc.co.uk/rd/projects/dirac/index.shtml)\n *          (http://diracvideo.org)\n *****************************************************************************\n * Copyright (C) 2008-2011 VLC authors and VideoLAN\n *\n * Authors: Jonathan Rosser <jonathan.rosser@gmail.com>\n *          David Flynn <davidf at rd dot bbc.co.uk>\n *          Anuradha Suraparaju <asuraparaju at gmail dot com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n/*****************************************************************************\n * Preamble\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include <vlc_common.h>\n#include <vlc_plugin.h>\n#include <vlc_codec.h>\n\n#include <schroedinger/schro.h>\n\n/*****************************************************************************\n * Module descriptor\n *****************************************************************************/\nstatic int        OpenDecoder  ( vlc_object_t * );\nstatic void       CloseDecoder ( vlc_object_t * );\nstatic int        OpenEncoder  ( vlc_object_t * );\nstatic void       CloseEncoder ( vlc_object_t * );\n\n#define ENC_CFG_PREFIX \"sout-schro-\"\n\n#define ENC_CHROMAFMT \"chroma-fmt\"\n#define ENC_CHROMAFMT_TEXT N_(\"Chroma format\")\n#define ENC_CHROMAFMT_LONGTEXT N_(\"Picking chroma format will force a \" \\\n                                  \"conversion of the video into that format\")\nstatic const char *const enc_chromafmt_list[] =\n  { \"420\", \"422\", \"444\" };\nstatic const char *const enc_chromafmt_list_text[] =\n  { N_(\"4:2:0\"), N_(\"4:2:2\"), N_(\"4:4:4\") };\n\n#define ENC_RATE_CONTROL \"rate-control\"\n#define ENC_RATE_CONTROL_TEXT N_(\"Rate control method\")\n#define ENC_RATE_CONTROL_LONGTEXT N_(\"Method used to encode the video sequence\")\n\nstatic const char *enc_rate_control_list[] = {\n  \"constant_noise_threshold\",\n  \"constant_bitrate\",\n  \"low_delay\",\n  \"lossless\",\n  \"constant_lambda\",\n  \"constant_error\",\n  \"constant_quality\"\n};\n\nstatic const char *enc_rate_control_list_text[] = {\n  N_(\"Constant noise threshold mode\"),\n  N_(\"Constant bitrate mode (CBR)\"),\n  N_(\"Low Delay mode\"),\n  N_(\"Lossless mode\"),\n  N_(\"Constant lambda mode\"),\n  N_(\"Constant error mode\"),\n  N_(\"Constant quality mode\")\n};\n\n#define ENC_GOP_STRUCTURE \"gop-structure\"\n#define ENC_GOP_STRUCTURE_TEXT N_(\"GOP structure\")\n#define ENC_GOP_STRUCTURE_LONGTEXT N_(\"GOP structure used to encode the video sequence\")\n\nstatic const char *enc_gop_structure_list[] = {\n  \"adaptive\",\n  \"intra_only\",\n  \"backref\",\n  \"chained_backref\",\n  \"biref\",\n  \"chained_biref\"\n};\n\nstatic const char *enc_gop_structure_list_text[] = {\n  N_(\"No fixed gop structure. A picture can be intra or inter and refer to previous or future pictures.\"),\n  N_(\"I-frame only sequence\"),\n  N_(\"Inter pictures refere to previous pictures only\"),\n  N_(\"Inter pictures refere to previous pictures only\"),\n  N_(\"Inter pictures can refer to previous or future pictures\"),\n  N_(\"Inter pictures can refer to previous or future pictures\")\n};\n\n#define ENC_QUALITY \"quality\"\n#define ENC_QUALITY_TEXT N_(\"Constant quality factor\")\n#define ENC_QUALITY_LONGTEXT N_(\"Quality factor to use in constant quality mode\")\n\n#define ENC_NOISE_THRESHOLD \"noise-threshold\"\n#define ENC_NOISE_THRESHOLD_TEXT N_(\"Noise Threshold\")\n#define ENC_NOISE_THRESHOLD_LONGTEXT N_(\"Noise threshold to use in constant noise threshold mode\")\n\n#define ENC_BITRATE \"bitrate\"\n#define ENC_BITRATE_TEXT N_(\"CBR bitrate (kbps)\")\n#define ENC_BITRATE_LONGTEXT N_(\"Target bitrate in kbps when encoding in constant bitrate mode\")\n\n#define ENC_MAX_BITRATE \"max-bitrate\"\n#define ENC_MAX_BITRATE_TEXT N_(\"Maximum bitrate (kbps)\")\n#define ENC_MAX_BITRATE_LONGTEXT N_(\"Maximum bitrate in kbps when encoding in constant bitrate mode\")\n\n#define ENC_MIN_BITRATE \"min-bitrate\"\n#define ENC_MIN_BITRATE_TEXT N_(\"Minimum bitrate (kbps)\")\n#define ENC_MIN_BITRATE_LONGTEXT N_(\"Minimum bitrate in kbps when encoding in constant bitrate mode\")\n\n#define ENC_AU_DISTANCE \"gop-length\"\n#define ENC_AU_DISTANCE_TEXT N_(\"GOP length\")\n#define ENC_AU_DISTANCE_LONGTEXT N_(\"Number of pictures between successive sequence headers i.e. length of the group of pictures\")\n\n\n#define ENC_PREFILTER \"filtering\"\n#define ENC_PREFILTER_TEXT N_(\"Prefilter\")\n#define ENC_PREFILTER_LONGTEXT N_(\"Enable adaptive prefiltering\")\n\nstatic const char *enc_filtering_list[] = {\n  \"none\",\n  \"center_weighted_median\",\n  \"gaussian\",\n  \"add_noise\",\n  \"adaptive_gaussian\",\n  \"lowpass\"\n};\n\nstatic const char *enc_filtering_list_text[] = {\n  N_(\"No pre-filtering\"),\n  N_(\"Centre Weighted Median\"),\n  N_(\"Gaussian Low Pass Filter\"),\n  N_(\"Add Noise\"),\n  N_(\"Gaussian Adaptive Low Pass Filter\"),\n  N_(\"Low Pass Filter\"),\n};\n\n#define ENC_PREFILTER_STRENGTH \"filter-value\"\n#define ENC_PREFILTER_STRENGTH_TEXT N_(\"Amount of prefiltering\")\n#define ENC_PREFILTER_STRENGTH_LONGTEXT N_(\"Higher value implies more prefiltering\")\n\n#define ENC_CODINGMODE \"coding-mode\"\n#define ENC_CODINGMODE_TEXT N_(\"Picture coding mode\")\n#define ENC_CODINGMODE_LONGTEXT N_(\"Field coding is where interlaced fields are coded\" \\\n                                   \" separately as opposed to a pseudo-progressive frame\")\nstatic const char *const enc_codingmode_list[] =\n  { \"auto\", \"progressive\", \"field\" };\nstatic const char *const enc_codingmode_list_text[] =\n  { N_(\"auto - let encoder decide based upon input (Best)\"),\n    N_(\"force coding frame as single picture\"),\n    N_(\"force coding frame as separate interlaced fields\"),\n  };\n\n/* advanced option only */\n#define ENC_MCBLK_SIZE \"motion-block-size\"\n#define ENC_MCBLK_SIZE_TEXT N_(\"Size of motion compensation blocks\")\n\nstatic const char *enc_block_size_list[] = {\n  \"automatic\",\n  \"small\",\n  \"medium\",\n  \"large\"\n};\nstatic const char *const enc_block_size_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"small - use small motion compensation blocks\"),\n    N_(\"medium - use medium motion compensation blocks\"),\n    N_(\"large - use large motion compensation blocks\"),\n  };\n\n/* advanced option only */\n#define ENC_MCBLK_OVERLAP \"motion-block-overlap\"\n#define ENC_MCBLK_OVERLAP_TEXT N_(\"Overlap of motion compensation blocks\")\n\nstatic const char *enc_block_overlap_list[] = {\n  \"automatic\",\n  \"none\",\n  \"partial\",\n  \"full\"\n};\nstatic const char *const enc_block_overlap_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"none - Motion compensation blocks do not overlap\"),\n    N_(\"partial - Motion compensation blocks only partially overlap\"),\n    N_(\"full - Motion compensation blocks fully overlap\"),\n  };\n\n\n#define ENC_MVPREC \"mv-precision\"\n#define ENC_MVPREC_TEXT N_(\"Motion Vector precision\")\n#define ENC_MVPREC_LONGTEXT N_(\"Motion Vector precision in pels\")\nstatic const char *const enc_mvprec_list[] =\n  { \"1\", \"1/2\", \"1/4\", \"1/8\" };\n\n/* advanced option only */\n#define ENC_ME_COMBINED \"me-combined\"\n#define ENC_ME_COMBINED_TEXT N_(\"Three component motion estimation\")\n#define ENC_ME_COMBINED_LONGTEXT N_(\"Use chroma as part of the motion estimation process\")\n\n#define ENC_DWTINTRA \"intra-wavelet\"\n#define ENC_DWTINTRA_TEXT N_(\"Intra picture DWT filter\")\n\n#define ENC_DWTINTER \"inter-wavelet\"\n#define ENC_DWTINTER_TEXT N_(\"Inter picture DWT filter\")\n\nstatic const char *enc_wavelet_list[] = {\n  \"desl_dubuc_9_7\",\n  \"le_gall_5_3\",\n  \"desl_dubuc_13_7\",\n  \"haar_0\",\n  \"haar_1\",\n  \"fidelity\",\n  \"daub_9_7\"\n};\n\nstatic const char *enc_wavelet_list_text[] = {\n  \"Deslauriers-Dubuc (9,7)\",\n  \"LeGall (5,3)\",\n  \"Deslauriers-Dubuc (13,7)\",\n  \"Haar with no shift\",\n  \"Haar with single shift per level\",\n  \"Fidelity filter\",\n  \"Daubechies (9,7) integer approximation\"\n};\n\n#define ENC_DWTDEPTH \"transform-depth\"\n#define ENC_DWTDEPTH_TEXT N_(\"Number of DWT iterations\")\n#define ENC_DWTDEPTH_LONGTEXT N_(\"Also known as DWT levels\")\n\n\n/* advanced option only */\n#define ENC_MULTIQUANT \"enable-multiquant\"\n#define ENC_MULTIQUANT_TEXT N_(\"Enable multiple quantizers\")\n#define ENC_MULTIQUANT_LONGTEXT N_(\"Enable multiple quantizers per subband (one per codeblock)\")\n\n/* advanced option only */\n#define ENC_NOAC \"enable-noarith\"\n#define ENC_NOAC_TEXT N_(\"Disable arithmetic coding\")\n#define ENC_NOAC_LONGTEXT N_(\"Use variable length codes instead, useful for very high bitrates\")\n\n/* visual modelling */\n/* advanced option only */\n#define ENC_PWT \"perceptual-weighting\"\n#define ENC_PWT_TEXT N_(\"perceptual weighting method\")\n\nstatic const char *enc_perceptual_weighting_list[] = {\n  \"none\",\n  \"ccir959\",\n  \"moo\",\n  \"manos_sakrison\"\n};\n\n/* advanced option only */\n#define ENC_PDIST \"perceptual-distance\"\n#define ENC_PDIST_TEXT N_(\"perceptual distance\")\n#define ENC_PDIST_LONGTEXT N_(\"perceptual distance to calculate perceptual weight\")\n\n/* advanced option only */\n#define ENC_HSLICES \"horiz-slices\"\n#define ENC_HSLICES_TEXT N_(\"Horizontal slices per frame\")\n#define ENC_HSLICES_LONGTEXT N_(\"Number of horizontal slices per frame in low delay mode\")\n\n/* advanced option only */\n#define ENC_VSLICES \"vert-slices\"\n#define ENC_VSLICES_TEXT N_(\"Vertical slices per frame\")\n#define ENC_VSLICES_LONGTEXT N_(\"Number of vertical slices per frame in low delay mode\")\n\n/* advanced option only */\n#define ENC_SCBLK_SIZE \"codeblock-size\"\n#define ENC_SCBLK_SIZE_TEXT N_(\"Size of code blocks in each subband\")\n\nstatic const char *enc_codeblock_size_list[] = {\n  \"automatic\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"full\"\n};\nstatic const char *const enc_codeblock_size_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"small - use small code blocks\"),\n    N_(\"medium - use medium sized code blocks\"),\n    N_(\"large - use large code blocks\"),\n    N_(\"full - One code block per subband\"),\n  };\n\n/* advanced option only */\n#define ENC_ME_HIERARCHICAL \"enable-hierarchical-me\"\n#define ENC_ME_HIERARCHICAL_TEXT N_(\"Enable hierarchical Motion Estimation\")\n\n/* advanced option only */\n#define ENC_ME_DOWNSAMPLE_LEVELS \"downsample-levels\"\n#define ENC_ME_DOWNSAMPLE_LEVELS_TEXT N_(\"Number of levels of downsampling\")\n#define ENC_ME_DOWNSAMPLE_LEVELS_LONGTEXT N_(\"Number of levels of downsampling in hierarchical motion estimation mode\")\n\n/* advanced option only */\n#define ENC_ME_GLOBAL_MOTION \"enable-global-me\"\n#define ENC_ME_GLOBAL_MOTION_TEXT N_(\"Enable Global Motion Estimation\")\n\n/* advanced option only */\n#define ENC_ME_PHASECORR \"enable-phasecorr-me\"\n#define ENC_ME_PHASECORR_TEXT N_(\"Enable Phase Correlation Estimation\")\n\n/* advanced option only */\n#define ENC_SCD \"enable-scd\"\n#define ENC_SCD_TEXT N_(\"Enable Scene Change Detection\")\n\n/* advanced option only */\n#define ENC_FORCE_PROFILE \"force-profile\"\n#define ENC_FORCE_PROFILE_TEXT N_(\"Force Profile\")\n\nstatic const char *enc_profile_list[] = {\n  \"auto\",\n  \"vc2_low_delay\",\n  \"vc2_simple\",\n  \"vc2_main\",\n  \"main\"\n};\n\nstatic const char *const enc_profile_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"VC2 Low Delay Profile\"),\n    N_(\"VC2 Simple Profile\"),\n    N_(\"VC2 Main Profile\"),\n    N_(\"Main Profile\"),\n  };\n\nstatic const char *const ppsz_enc_options[] = {\n    ENC_RATE_CONTROL, ENC_GOP_STRUCTURE, ENC_QUALITY, ENC_NOISE_THRESHOLD, ENC_BITRATE,\n    ENC_MIN_BITRATE, ENC_MAX_BITRATE, ENC_AU_DISTANCE, ENC_CHROMAFMT,\n    ENC_PREFILTER, ENC_PREFILTER_STRENGTH, ENC_CODINGMODE, ENC_MCBLK_SIZE,\n    ENC_MCBLK_OVERLAP, ENC_MVPREC, ENC_ME_COMBINED, ENC_DWTINTRA, ENC_DWTINTER,\n    ENC_DWTDEPTH, ENC_MULTIQUANT, ENC_NOAC, ENC_PWT, ENC_PDIST, ENC_HSLICES,\n    ENC_VSLICES, ENC_SCBLK_SIZE, ENC_ME_HIERARCHICAL, ENC_ME_DOWNSAMPLE_LEVELS,\n    ENC_ME_GLOBAL_MOTION, ENC_ME_PHASECORR, ENC_SCD, ENC_FORCE_PROFILE,\n    NULL\n};\n\n\n/* Module declaration */\n\nvlc_module_begin ()\n    set_category( CAT_INPUT )\n    set_subcategory( SUBCAT_INPUT_VCODEC )\n    set_shortname( \"Schroedinger\" )\n    set_description( N_(\"Dirac video decoder using libschroedinger\") )\n    set_capability( \"decoder\", 200 )\n    set_callbacks( OpenDecoder, CloseDecoder )\n    add_shortcut( \"schroedinger\" )\n\n    /* encoder */\n    add_submodule()\n    set_section( N_(\"Encoding\") , NULL )\n    set_description( N_(\"Dirac video encoder using libschroedinger\") )\n    set_capability( \"encoder\", 110 )\n    set_callbacks( OpenEncoder, CloseEncoder )\n    add_shortcut( \"schroedinger\", \"schro\" )\n\n    add_string( ENC_CFG_PREFIX ENC_RATE_CONTROL, NULL,\n                 ENC_RATE_CONTROL_TEXT, ENC_RATE_CONTROL_LONGTEXT, false )\n    change_string_list( enc_rate_control_list, enc_rate_control_list_text )\n\n    add_float( ENC_CFG_PREFIX ENC_QUALITY, -1.,\n               ENC_QUALITY_TEXT, ENC_QUALITY_LONGTEXT, false )\n    change_float_range(-1., 10.);\n\n    add_float( ENC_CFG_PREFIX ENC_NOISE_THRESHOLD, -1.,\n               ENC_NOISE_THRESHOLD_TEXT, ENC_NOISE_THRESHOLD_LONGTEXT, false )\n    change_float_range(-1., 100.);\n\n    add_integer( ENC_CFG_PREFIX ENC_BITRATE, -1,\n                 ENC_BITRATE_TEXT, ENC_BITRATE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_integer( ENC_CFG_PREFIX ENC_MAX_BITRATE, -1,\n                 ENC_MAX_BITRATE_TEXT, ENC_MAX_BITRATE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_integer( ENC_CFG_PREFIX ENC_MIN_BITRATE, -1,\n                 ENC_MIN_BITRATE_TEXT, ENC_MIN_BITRATE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_string( ENC_CFG_PREFIX ENC_GOP_STRUCTURE, NULL,\n                 ENC_GOP_STRUCTURE_TEXT, ENC_GOP_STRUCTURE_LONGTEXT, false )\n    change_string_list( enc_gop_structure_list, enc_gop_structure_list_text )\n\n    add_integer( ENC_CFG_PREFIX ENC_AU_DISTANCE, -1,\n                 ENC_AU_DISTANCE_TEXT, ENC_AU_DISTANCE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_string( ENC_CFG_PREFIX ENC_CHROMAFMT, \"420\",\n                ENC_CHROMAFMT_TEXT, ENC_CHROMAFMT_LONGTEXT, false )\n    change_string_list( enc_chromafmt_list, enc_chromafmt_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_CODINGMODE, \"auto\",\n                ENC_CODINGMODE_TEXT, ENC_CODINGMODE_LONGTEXT, false )\n    change_string_list( enc_codingmode_list, enc_codingmode_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_MVPREC, NULL,\n                ENC_MVPREC_TEXT, ENC_MVPREC_LONGTEXT, false )\n    change_string_list( enc_mvprec_list, enc_mvprec_list )\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_MCBLK_SIZE, NULL,\n                ENC_MCBLK_SIZE_TEXT, ENC_MCBLK_SIZE_TEXT, true )\n    change_string_list( enc_block_size_list, enc_block_size_list_text )\n\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_MCBLK_OVERLAP, NULL,\n                ENC_MCBLK_OVERLAP_TEXT, ENC_MCBLK_OVERLAP_TEXT, true )\n    change_string_list( enc_block_overlap_list, enc_block_overlap_list_text )\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_COMBINED, -1,\n              ENC_ME_COMBINED_TEXT, ENC_ME_COMBINED_LONGTEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_HIERARCHICAL, -1,\n                 ENC_ME_HIERARCHICAL_TEXT, ENC_ME_HIERARCHICAL_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_DOWNSAMPLE_LEVELS, -1,\n                 ENC_ME_DOWNSAMPLE_LEVELS_TEXT, ENC_ME_DOWNSAMPLE_LEVELS_LONGTEXT, true )\n    change_integer_range(-1, 8 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_GLOBAL_MOTION, -1,\n                 ENC_ME_GLOBAL_MOTION_TEXT, ENC_ME_GLOBAL_MOTION_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_PHASECORR, -1,\n                 ENC_ME_PHASECORR_TEXT, ENC_ME_PHASECORR_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    add_string( ENC_CFG_PREFIX ENC_DWTINTRA, NULL,\n                ENC_DWTINTRA_TEXT, ENC_DWTINTRA_TEXT, false )\n    change_string_list( enc_wavelet_list, enc_wavelet_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_DWTINTER, NULL,\n                ENC_DWTINTER_TEXT, ENC_DWTINTER_TEXT, false )\n    change_string_list( enc_wavelet_list, enc_wavelet_list_text )\n\n    add_integer( ENC_CFG_PREFIX ENC_DWTDEPTH, -1,\n                 ENC_DWTDEPTH_TEXT, ENC_DWTDEPTH_LONGTEXT, false )\n    change_integer_range(-1, SCHRO_LIMIT_ENCODER_TRANSFORM_DEPTH );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_MULTIQUANT, -1,\n                 ENC_MULTIQUANT_TEXT, ENC_MULTIQUANT_LONGTEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_SCBLK_SIZE, NULL,\n                ENC_SCBLK_SIZE_TEXT, ENC_SCBLK_SIZE_TEXT, true )\n    change_string_list( enc_codeblock_size_list, enc_codeblock_size_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_PREFILTER, NULL,\n                ENC_PREFILTER_TEXT, ENC_PREFILTER_LONGTEXT, false )\n    change_string_list( enc_filtering_list, enc_filtering_list_text )\n\n    add_float( ENC_CFG_PREFIX ENC_PREFILTER_STRENGTH, -1.,\n                 ENC_PREFILTER_STRENGTH_TEXT, ENC_PREFILTER_STRENGTH_LONGTEXT, false )\n    change_float_range(-1., 100.0);\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_SCD, -1,\n                 ENC_SCD_TEXT, ENC_SCD_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_PWT, NULL,\n                ENC_PWT_TEXT, ENC_PWT_TEXT, true )\n    change_string_list( enc_perceptual_weighting_list, enc_perceptual_weighting_list )\n\n    /* advanced option only */\n    add_float( ENC_CFG_PREFIX ENC_PDIST, -1,\n               ENC_PDIST_TEXT, ENC_PDIST_LONGTEXT, true )\n    change_float_range(-1., 100.);\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_NOAC, -1,\n              ENC_NOAC_TEXT, ENC_NOAC_LONGTEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_HSLICES, -1,\n                 ENC_HSLICES_TEXT, ENC_HSLICES_LONGTEXT, true )\n    change_integer_range(-1, INT_MAX );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_VSLICES, -1,\n                 ENC_VSLICES_TEXT, ENC_VSLICES_LONGTEXT, true )\n    change_integer_range(-1, INT_MAX );\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_FORCE_PROFILE, NULL,\n                ENC_FORCE_PROFILE_TEXT, ENC_FORCE_PROFILE_TEXT, true )\n    change_string_list( enc_profile_list, enc_profile_list_text )\n\nvlc_module_end ()\n\n\n/*****************************************************************************\n * Local prototypes\n *****************************************************************************/\nstatic picture_t *DecodeBlock  ( decoder_t *p_dec, block_t **pp_block );\n\nstruct picture_free_t\n{\n   picture_t *p_pic;\n   decoder_t *p_dec;\n};\n\n/*****************************************************************************\n * decoder_sys_t : Schroedinger decoder descriptor\n *****************************************************************************/\nstruct decoder_sys_t\n{\n    /*\n     * Dirac properties\n     */\n    mtime_t i_lastpts;\n    mtime_t i_frame_pts_delta;\n    SchroDecoder *p_schro;\n    SchroVideoFormat *p_format;\n};\n\n/*****************************************************************************\n * OpenDecoder: probe the decoder and return score\n *****************************************************************************/\nstatic int OpenDecoder( vlc_object_t *p_this )\n{\n    decoder_t *p_dec = (decoder_t*)p_this;\n    decoder_sys_t *p_sys;\n    SchroDecoder *p_schro;\n\n    if( p_dec->fmt_in.i_codec != VLC_CODEC_DIRAC )\n    {\n        return VLC_EGENERIC;\n    }\n\n    /* Allocate the memory needed to store the decoder's structure */\n    p_sys = malloc(sizeof(decoder_sys_t));\n    if( p_sys == NULL )\n        return VLC_ENOMEM;\n\n    /* Initialise the schroedinger (and hence liboil libraries */\n    /* This does no allocation and is safe to call */\n    schro_init();\n\n    /* Initialise the schroedinger decoder */\n    if( !(p_schro = schro_decoder_new()) )\n    {\n        free( p_sys );\n        return VLC_EGENERIC;\n    }\n\n    p_dec->p_sys = p_sys;\n    p_sys->p_schro = p_schro;\n    p_sys->p_format = NULL;\n    p_sys->i_lastpts = VLC_TS_INVALID;\n    p_sys->i_frame_pts_delta = 0;\n\n    /* Set output properties */\n    p_dec->fmt_out.i_cat = VIDEO_ES;\n    p_dec->fmt_out.i_codec = VLC_CODEC_I420;\n\n    /* Set callbacks */\n    p_dec->pf_decode_video = DecodeBlock;\n\n    return VLC_SUCCESS;\n}\n\n/*****************************************************************************\n * SetPictureFormat: Set the decoded picture params to the ones from the stream\n *****************************************************************************/\nstatic void SetVideoFormat( decoder_t *p_dec )\n{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    p_sys->p_format = schro_decoder_get_video_format(p_sys->p_schro);\n    if( p_sys->p_format == NULL ) return;\n\n    p_sys->i_frame_pts_delta = CLOCK_FREQ\n                            * p_sys->p_format->frame_rate_denominator\n                            / p_sys->p_format->frame_rate_numerator;\n\n    switch( p_sys->p_format->chroma_format )\n    {\n    case SCHRO_CHROMA_420: p_dec->fmt_out.i_codec = VLC_CODEC_I420; break;\n    case SCHRO_CHROMA_422: p_dec->fmt_out.i_codec = VLC_CODEC_I422; break;\n    case SCHRO_CHROMA_444: p_dec->fmt_out.i_codec = VLC_CODEC_I444; break;\n    default:\n        p_dec->fmt_out.i_codec = 0;\n        break;\n    }\n\n    p_dec->fmt_out.video.i_visible_width = p_sys->p_format->clean_width;\n    p_dec->fmt_out.video.i_x_offset = p_sys->p_format->left_offset;\n    p_dec->fmt_out.video.i_width = p_sys->p_format->width;\n\n    p_dec->fmt_out.video.i_visible_height = p_sys->p_format->clean_height;\n    p_dec->fmt_out.video.i_y_offset = p_sys->p_format->top_offset;\n    p_dec->fmt_out.video.i_height = p_sys->p_format->height;\n\n    /* aspect_ratio_[numerator|denominator] describes the pixel aspect ratio */\n    p_dec->fmt_out.video.i_sar_num = p_sys->p_format->aspect_ratio_numerator;\n    p_dec->fmt_out.video.i_sar_den = p_sys->p_format->aspect_ratio_denominator;\n\n    p_dec->fmt_out.video.i_frame_rate =\n        p_sys->p_format->frame_rate_numerator;\n    p_dec->fmt_out.video.i_frame_rate_base =\n        p_sys->p_format->frame_rate_denominator;\n}\n\n/*****************************************************************************\n * SchroFrameFree: schro_frame callback to release the associated picture_t\n * When schro_decoder_reset() is called there will be pictures in the\n * decoding pipeline that need to be released rather than displayed.\n *****************************************************************************/\nstatic void SchroFrameFree( SchroFrame *frame, void *priv)\n{\n    struct picture_free_t *p_free = priv;\n\n    if( !p_free )\n        return;\n\n    picture_Release( p_free->p_pic );\n    free(p_free);\n    (void)frame;\n}\n\n/*****************************************************************************\n * CreateSchroFrameFromPic: wrap a picture_t in a SchroFrame\n *****************************************************************************/\nstatic SchroFrame *CreateSchroFrameFromPic( decoder_t *p_dec )\n{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n    SchroFrame *p_schroframe = schro_frame_new();\n    picture_t *p_pic = NULL;\n    struct picture_free_t *p_free;\n\n    if( !p_schroframe )\n        return NULL;\n\n    p_pic = decoder_NewPicture( p_dec );\n\n    if( !p_pic )\n        return NULL;\n\n    p_schroframe->format = SCHRO_FRAME_FORMAT_U8_420;\n    if( p_sys->p_format->chroma_format == SCHRO_CHROMA_422 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_422;\n    }\n    else if( p_sys->p_format->chroma_format == SCHRO_CHROMA_444 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_444;\n    }\n\n    p_schroframe->width = p_sys->p_format->width;\n    p_schroframe->height = p_sys->p_format->height;\n\n    p_free = malloc( sizeof( *p_free ) );\n    p_free->p_pic = p_pic;\n    p_free->p_dec = p_dec;\n    schro_frame_set_free_callback( p_schroframe, SchroFrameFree, p_free );\n\n    for( int i=0; i<3; i++ )\n    {\n        p_schroframe->components[i].width = p_pic->p[i].i_visible_pitch;\n        p_schroframe->components[i].stride = p_pic->p[i].i_pitch;\n        p_schroframe->components[i].height = p_pic->p[i].i_visible_lines;\n        p_schroframe->components[i].length =\n            p_pic->p[i].i_pitch * p_pic->p[i].i_lines;\n        p_schroframe->components[i].data = p_pic->p[i].p_pixels;\n\n        if(i!=0)\n        {\n            p_schroframe->components[i].v_shift =\n                SCHRO_FRAME_FORMAT_V_SHIFT( p_schroframe->format );\n            p_schroframe->components[i].h_shift =\n                SCHRO_FRAME_FORMAT_H_SHIFT( p_schroframe->format );\n        }\n    }\n\n    p_pic->b_progressive = !p_sys->p_format->interlaced;\n    p_pic->b_top_field_first = p_sys->p_format->top_field_first;\n    p_pic->i_nb_fields = 2;\n\n    return p_schroframe;\n}\n\n/*****************************************************************************\n * SchroBufferFree: schro_buffer callback to release the associated block_t\n *****************************************************************************/\nstatic void SchroBufferFree( SchroBuffer *buf, void *priv )\n{\n    block_t *p_block = priv;\n\n    if( !p_block )\n        return;\n\n    block_Release( p_block );\n    (void)buf;\n}\n\n/*****************************************************************************\n * CloseDecoder: decoder destruction\n *****************************************************************************/\nstatic void CloseDecoder( vlc_object_t *p_this )\n{\n    decoder_t *p_dec = (decoder_t *)p_this;\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    schro_decoder_free( p_sys->p_schro );\n    free( p_sys );\n}\n\n/****************************************************************************\n * DecodeBlock: the whole thing\n ****************************************************************************\n * Blocks need not be Dirac dataunit aligned.\n * If a block has a PTS signaled, it applies to the first picture at or after p_block\n *\n * If this function returns a picture (!NULL), it is called again and the\n * same block is resubmitted.  To avoid this, set *pp_block to NULL;\n * If this function returns NULL, the *pp_block is lost (and leaked).\n * This function must free all blocks when finished with them.\n ****************************************************************************/\nstatic picture_t *DecodeBlock( decoder_t *p_dec, block_t **pp_block )\n{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    if( !pp_block ) return NULL;\n\n    if ( *pp_block ) {\n        block_t *p_block = *pp_block;\n\n        /* reset the decoder when seeking as the decode in progress is invalid */\n        /* discard the block as it is just a null magic block */\n        if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY ) {\n            schro_decoder_reset( p_sys->p_schro );\n\n            p_sys->i_lastpts = VLC_TS_INVALID;\n            block_Release( p_block );\n            *pp_block = NULL;\n            return NULL;\n        }\n\n        SchroBuffer *p_schrobuffer;\n        p_schrobuffer = schro_buffer_new_with_data( p_block->p_buffer, p_block->i_buffer );\n        p_schrobuffer->free = SchroBufferFree;\n        p_schrobuffer->priv = p_block;\n        if( p_block->i_pts > VLC_TS_INVALID ) {\n            mtime_t *p_pts = malloc( sizeof(*p_pts) );\n            if( p_pts ) {\n                *p_pts = p_block->i_pts;\n                /* if this call fails, p_pts is freed automatically */\n                p_schrobuffer->tag = schro_tag_new( p_pts, free );\n            }\n        }\n\n        /* this stops the same block being fed back into this function if\n         * we were on the next iteration of this loop to output a picture */\n        *pp_block = NULL;\n        schro_decoder_autoparse_push( p_sys->p_schro, p_schrobuffer );\n        /* DO NOT refer to p_block after this point, it may have been freed */\n    }\n\n    while( 1 )\n    {\n        SchroFrame *p_schroframe;\n        picture_t *p_pic;\n        int state = schro_decoder_autoparse_wait( p_sys->p_schro );\n\n        switch( state )\n        {\n        case SCHRO_DECODER_FIRST_ACCESS_UNIT:\n            SetVideoFormat( p_dec );\n            break;\n\n        case SCHRO_DECODER_NEED_BITS:\n            return NULL;\n\n        case SCHRO_DECODER_NEED_FRAME:\n            p_schroframe = CreateSchroFrameFromPic( p_dec );\n\n            if( !p_schroframe )\n            {\n                msg_Err( p_dec, \"Could not allocate picture for decoder\");\n                return NULL;\n            }\n\n            schro_decoder_add_output_picture( p_sys->p_schro, p_schroframe);\n            break;\n\n        case SCHRO_DECODER_OK: {\n            SchroTag *p_tag = schro_decoder_get_picture_tag( p_sys->p_schro );\n            p_schroframe = schro_decoder_pull( p_sys->p_schro );\n            if( !p_schroframe || !p_schroframe->priv )\n            {\n                /* frame can't be one that was allocated by us\n                 *   -- no private data: discard */\n                if( p_tag ) schro_tag_free( p_tag );\n                if( p_schroframe ) schro_frame_unref( p_schroframe );\n                break;\n            }\n            p_pic = ((struct picture_free_t*) p_schroframe->priv)->p_pic;\n            p_schroframe->priv = NULL;\n\n            if( p_tag )\n            {\n                /* free is handled by schro_frame_unref */\n                p_pic->date = *(mtime_t*) p_tag->value;\n                schro_tag_free( p_tag );\n            }\n            else if( p_sys->i_lastpts > VLC_TS_INVALID )\n            {\n                /* NB, this shouldn't happen since the packetizer does a\n                 * very thorough job of inventing timestamps.  The\n                 * following is just a very rough fall back incase packetizer\n                 * is missing. */\n                /* maybe it would be better to set p_pic->b_force ? */\n                p_pic->date = p_sys->i_lastpts + p_sys->i_frame_pts_delta;\n            }\n            p_sys->i_lastpts = p_pic->date;\n\n            schro_frame_unref( p_schroframe );\n            return p_pic;\n        }\n        case SCHRO_DECODER_EOS:\n            /* NB, the new api will not emit _EOS, it handles the reset internally */\n            break;\n\n        case SCHRO_DECODER_ERROR:\n            msg_Err( p_dec, \"SCHRO_DECODER_ERROR\");\n            return NULL;\n        }\n    }\n}\n\n/*****************************************************************************\n * Local prototypes\n *****************************************************************************/\nstatic block_t *Encode( encoder_t *p_enc, picture_t *p_pict );\n\n\n/*****************************************************************************\n * picture_pts_t : store pts alongside picture number, not carried through\n * encoder\n *****************************************************************************/\nstruct picture_pts_t\n{\n   mtime_t i_pts;    /* associated pts */\n   uint32_t u_pnum;  /* dirac picture number */\n   bool b_empty;     /* entry is invalid */\n};\n\n/*****************************************************************************\n * encoder_sys_t : Schroedinger encoder descriptor\n *****************************************************************************/\n#define SCHRO_PTS_TLB_SIZE 256\nstruct encoder_sys_t\n{\n    /*\n     * Schro properties\n     */\n    SchroEncoder *p_schro;\n    SchroVideoFormat *p_format;\n    int started;\n    bool b_auto_field_coding;\n\n    uint32_t i_input_picnum;\n    block_fifo_t *p_dts_fifo;\n\n    block_t *p_chain;\n\n    struct picture_pts_t pts_tlb[SCHRO_PTS_TLB_SIZE];\n    mtime_t i_pts_offset;\n    mtime_t i_field_time;\n\n    bool b_eos_signalled;\n    bool b_eos_pulled;\n};\n\nstatic struct\n{\n    unsigned int i_height;\n    int i_approx_fps;\n    SchroVideoFormatEnum i_vf;\n} schro_format_guess[] = {\n    /* Important: Keep this list ordered in ascending picture height */\n    {1, 0, SCHRO_VIDEO_FORMAT_CUSTOM},\n    {120, 15, SCHRO_VIDEO_FORMAT_QSIF},\n    {144, 12, SCHRO_VIDEO_FORMAT_QCIF},\n    {240, 15, SCHRO_VIDEO_FORMAT_SIF},\n    {288, 12, SCHRO_VIDEO_FORMAT_CIF},\n    {480, 30, SCHRO_VIDEO_FORMAT_SD480I_60},\n    {480, 15, SCHRO_VIDEO_FORMAT_4SIF},\n    {576, 12, SCHRO_VIDEO_FORMAT_4CIF},\n    {576, 25, SCHRO_VIDEO_FORMAT_SD576I_50},\n    {720, 50, SCHRO_VIDEO_FORMAT_HD720P_50},\n    {720, 60, SCHRO_VIDEO_FORMAT_HD720P_60},\n    {1080, 24, SCHRO_VIDEO_FORMAT_DC2K_24},\n    {1080, 25, SCHRO_VIDEO_FORMAT_HD1080I_50},\n    {1080, 30, SCHRO_VIDEO_FORMAT_HD1080I_60},\n    {1080, 50, SCHRO_VIDEO_FORMAT_HD1080P_50},\n    {1080, 60, SCHRO_VIDEO_FORMAT_HD1080P_60},\n    {2160, 24, SCHRO_VIDEO_FORMAT_DC4K_24},\n    {0, 0, 0},\n};\n\n/*****************************************************************************\n * ResetPTStlb: Purge all entries in @p_enc@'s PTS-tlb\n *****************************************************************************/\nstatic void ResetPTStlb( encoder_t *p_enc )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    for( int i = 0; i < SCHRO_PTS_TLB_SIZE; i++ )\n    {\n        p_sys->pts_tlb[i].b_empty = true;\n    }\n}\n\n\n/*****************************************************************************\n * StorePicturePTS: Store the PTS value for a particular picture number\n *****************************************************************************/\nstatic void StorePicturePTS( encoder_t *p_enc, uint32_t u_pnum, mtime_t i_pts )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    for( int i = 0; i<SCHRO_PTS_TLB_SIZE; i++ )\n    {\n        if( p_sys->pts_tlb[i].b_empty )\n        {\n            p_sys->pts_tlb[i].u_pnum = u_pnum;\n            p_sys->pts_tlb[i].i_pts = i_pts;\n            p_sys->pts_tlb[i].b_empty = false;\n\n            return;\n        }\n    }\n\n    msg_Err( p_enc, \"Could not store PTS %\"PRId64\" for frame %u\", i_pts, u_pnum );\n}\n\n/*****************************************************************************\n * GetPicturePTS: Retrieve the PTS value for a particular picture number\n *****************************************************************************/\nstatic mtime_t GetPicturePTS( encoder_t *p_enc, uint32_t u_pnum )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    for( int i = 0; i < SCHRO_PTS_TLB_SIZE; i++ )\n    {\n        if( !p_sys->pts_tlb[i].b_empty &&\n            p_sys->pts_tlb[i].u_pnum == u_pnum )\n        {\n             p_sys->pts_tlb[i].b_empty = true;\n             return p_sys->pts_tlb[i].i_pts;\n        }\n    }\n\n    msg_Err( p_enc, \"Could not retrieve PTS for picture %u\", u_pnum );\n    return 0;\n}\n\nstatic inline bool SchroSetEnum( const encoder_t *p_enc, int i_list_size, const char *list[],\n                  const char *psz_name,  const char *psz_name_text,  const char *psz_value)\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    if( list && psz_name_text && psz_name && psz_value ) {\n        for( int i = 0; i < i_list_size; ++i ) {\n            if( strcmp( list[i], psz_value ) )\n                continue;\n            schro_encoder_setting_set_double( p_sys->p_schro, psz_name, i );\n            return true;\n        }\n        msg_Err( p_enc, \"Invalid %s: %s\", psz_name_text, psz_value );\n    }\n    return false;\n}\n\nstatic bool SetEncChromaFormat( encoder_t *p_enc, uint32_t i_codec )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    switch( i_codec ) {\n    case VLC_CODEC_I420:\n        p_enc->fmt_in.i_codec = i_codec;\n        p_enc->fmt_in.video.i_bits_per_pixel = 12;\n        p_sys->p_format->chroma_format = SCHRO_CHROMA_420;\n           break;\n    case VLC_CODEC_I422:\n        p_enc->fmt_in.i_codec = i_codec;\n        p_enc->fmt_in.video.i_bits_per_pixel = 16;\n        p_sys->p_format->chroma_format = SCHRO_CHROMA_422;\n        break;\n    case VLC_CODEC_I444:\n        p_enc->fmt_in.i_codec = i_codec;\n        p_enc->fmt_in.video.i_bits_per_pixel = 24;\n        p_sys->p_format->chroma_format = SCHRO_CHROMA_444;\n        break;\n    default:\n        return false;\n    }\n\n    return true;\n}\n\n#define SCHRO_SET_FLOAT(psz_name, pschro_name) \\\n    f_tmp = var_GetFloat( p_enc, ENC_CFG_PREFIX psz_name ); \\\n    if( f_tmp >= 0.0 ) \\\n        schro_encoder_setting_set_double( p_sys->p_schro, pschro_name, f_tmp );\n\n#define SCHRO_SET_INTEGER(psz_name, pschro_name, ignore_val) \\\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX psz_name ); \\\n    if( i_tmp > ignore_val ) \\\n        schro_encoder_setting_set_double( p_sys->p_schro, pschro_name, i_tmp );\n\n#define SCHRO_SET_ENUM(list, psz_name, psz_name_text, pschro_name) \\\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX psz_name ); \\\n    if( !psz_tmp ) \\\n        goto error; \\\n    else if ( *psz_tmp != '\\0' ) { \\\n        int i_list_size = ARRAY_SIZE(list); \\\n        if( !SchroSetEnum( p_enc, i_list_size, list, pschro_name, psz_name_text, psz_tmp ) ) { \\\n            free( psz_tmp ); \\\n            goto error; \\\n        } \\\n    } \\\n    free( psz_tmp );\n\n/*****************************************************************************\n * OpenEncoder: probe the encoder and return score\n *****************************************************************************/\nstatic int OpenEncoder( vlc_object_t *p_this )\n{\n    encoder_t *p_enc = (encoder_t *)p_this;\n    encoder_sys_t *p_sys;\n    int i_tmp;\n    float f_tmp;\n    char *psz_tmp;\n\n    if( p_enc->fmt_out.i_codec != VLC_CODEC_DIRAC &&\n        !p_enc->b_force )\n    {\n        return VLC_EGENERIC;\n    }\n\n    if( !p_enc->fmt_in.video.i_frame_rate || !p_enc->fmt_in.video.i_frame_rate_base ||\n        !p_enc->fmt_in.video.i_visible_height || !p_enc->fmt_in.video.i_visible_width )\n    {\n        msg_Err( p_enc, \"Framerate and picture dimensions must be non-zero\" );\n        return VLC_EGENERIC;\n    }\n\n    /* Allocate the memory needed to store the decoder's structure */\n    if( ( p_sys = calloc( 1, sizeof( *p_sys ) ) ) == NULL )\n        return VLC_ENOMEM;\n\n    p_enc->p_sys = p_sys;\n    p_enc->pf_encode_video = Encode;\n    p_enc->fmt_out.i_codec = VLC_CODEC_DIRAC;\n    p_enc->fmt_out.i_cat = VIDEO_ES;\n\n    if( ( p_sys->p_dts_fifo = block_FifoNew() ) == NULL )\n    {\n        CloseEncoder( p_this );\n        return VLC_ENOMEM;\n    }\n\n    ResetPTStlb( p_enc );\n\n    /* guess the video format based upon number of lines and picture height */\n    int i = 0;\n    SchroVideoFormatEnum guessed_video_fmt = SCHRO_VIDEO_FORMAT_CUSTOM;\n    /* Pick the dirac_video_format in this order of preference:\n     *  1. an exact match in frame height and an approximate fps match\n     *  2. the previous preset with a smaller number of lines.\n     */\n    do\n    {\n        if( schro_format_guess[i].i_height > p_enc->fmt_in.video.i_height )\n        {\n            guessed_video_fmt = schro_format_guess[i-1].i_vf;\n            break;\n        }\n        if( schro_format_guess[i].i_height != p_enc->fmt_in.video.i_height )\n            continue;\n        int src_fps = p_enc->fmt_in.video.i_frame_rate / p_enc->fmt_in.video.i_frame_rate_base;\n        int delta_fps = abs( schro_format_guess[i].i_approx_fps - src_fps );\n        if( delta_fps > 2 )\n            continue;\n\n        guessed_video_fmt = schro_format_guess[i].i_vf;\n        break;\n    } while( schro_format_guess[++i].i_height );\n\n    schro_init();\n    p_sys->p_schro = schro_encoder_new();\n    if( !p_sys->p_schro ) {\n        msg_Err( p_enc, \"Failed to initialize libschroedinger encoder\" );\n        return VLC_EGENERIC;\n    }\n    schro_encoder_set_packet_assembly( p_sys->p_schro, true );\n\n    if( !( p_sys->p_format = schro_encoder_get_video_format( p_sys->p_schro ) ) ) {\n        msg_Err( p_enc, \"Failed to get Schroedigner video format\" );\n        schro_encoder_free( p_sys->p_schro );\n        return VLC_EGENERIC;\n    }\n\n    /* initialise the video format parameters to the guessed format */\n    schro_video_format_set_std_video_format( p_sys->p_format, guessed_video_fmt );\n\n    /* constants set from the input video format */\n    p_sys->p_format->width                  = p_enc->fmt_in.video.i_visible_width;\n    p_sys->p_format->height                 = p_enc->fmt_in.video.i_visible_height;\n    p_sys->p_format->frame_rate_numerator   = p_enc->fmt_in.video.i_frame_rate;\n    p_sys->p_format->frame_rate_denominator = p_enc->fmt_in.video.i_frame_rate_base;\n    unsigned u_asr_num, u_asr_den;\n    vlc_ureduce( &u_asr_num, &u_asr_den,\n                 p_enc->fmt_in.video.i_sar_num,\n                 p_enc->fmt_in.video.i_sar_den, 0 );\n    p_sys->p_format->aspect_ratio_numerator   = u_asr_num;\n    p_sys->p_format->aspect_ratio_denominator = u_asr_den;\n\n    config_ChainParse( p_enc, ENC_CFG_PREFIX, ppsz_enc_options, p_enc->p_cfg );\n\n    SCHRO_SET_ENUM(enc_rate_control_list, ENC_RATE_CONTROL, ENC_RATE_CONTROL_TEXT, \"rate_control\")\n\n    SCHRO_SET_ENUM(enc_gop_structure_list, ENC_GOP_STRUCTURE, ENC_GOP_STRUCTURE_TEXT, \"gop_structure\")\n\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX ENC_CHROMAFMT );\n    if( !psz_tmp )\n        goto error;\n    else {\n        uint32_t i_codec;\n        if( !strcmp( psz_tmp, \"420\" ) ) {\n            i_codec = VLC_CODEC_I420;\n        }\n        else if( !strcmp( psz_tmp, \"422\" ) ) {\n            i_codec = VLC_CODEC_I422;\n        }\n        else if( !strcmp( psz_tmp, \"444\" ) ) {\n            i_codec = VLC_CODEC_I444;\n        }\n        else {\n            msg_Err( p_enc, \"Invalid chroma format: %s\", psz_tmp );\n            free( psz_tmp );\n            goto error;\n        }\n        SetEncChromaFormat( p_enc, i_codec );\n    }\n    free( psz_tmp );\n\n    SCHRO_SET_FLOAT(ENC_QUALITY, \"quality\")\n\n    SCHRO_SET_FLOAT(ENC_NOISE_THRESHOLD, \"noise_threshold\")\n\n    /* use bitrate from sout-transcode-vb in kbps */\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX ENC_BITRATE );\n    if( i_tmp > -1 )\n        schro_encoder_setting_set_double( p_sys->p_schro, \"bitrate\", i_tmp * 1000 );\n    else\n        schro_encoder_setting_set_double( p_sys->p_schro, \"bitrate\", p_enc->fmt_out.i_bitrate );\n\n       p_enc->fmt_out.i_bitrate = schro_encoder_setting_get_double( p_sys->p_schro, \"bitrate\" );\n\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX ENC_MIN_BITRATE );\n    if( i_tmp > -1 )\n        schro_encoder_setting_set_double( p_sys->p_schro, \"min_bitrate\", i_tmp * 1000 );\n\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX ENC_MAX_BITRATE );\n    if( i_tmp > -1 )\n        schro_encoder_setting_set_double( p_sys->p_schro, \"max_bitrate\", i_tmp * 1000 );\n\n    SCHRO_SET_INTEGER(ENC_AU_DISTANCE, \"au_distance\", -1)\n\n    SCHRO_SET_ENUM(enc_filtering_list, ENC_PREFILTER, ENC_PREFILTER_TEXT, \"filtering\")\n\n    SCHRO_SET_FLOAT(ENC_PREFILTER_STRENGTH, \"filter_value\")\n\n\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX ENC_CODINGMODE );\n    if( !psz_tmp )\n        goto error;\n    else if( !strcmp( psz_tmp, \"auto\" ) ) {\n        p_sys->b_auto_field_coding = true;\n    }\n    else if( !strcmp( psz_tmp, \"progressive\" ) ) {\n        p_sys->b_auto_field_coding = false;\n        schro_encoder_setting_set_double( p_sys->p_schro, \"interlaced_coding\", false);\n    }\n    else if( !strcmp( psz_tmp, \"field\" ) ) {\n        p_sys->b_auto_field_coding = false;\n        schro_encoder_setting_set_double( p_sys->p_schro, \"interlaced_coding\", true);\n    }\n    else {\n        msg_Err( p_enc, \"Invalid codingmode: %s\", psz_tmp );\n        free( psz_tmp );\n        goto error;\n    }\n    free( psz_tmp );\n\n    SCHRO_SET_ENUM(enc_block_size_list, ENC_MCBLK_SIZE, ENC_MCBLK_SIZE_TEXT, \"motion_block_size\")\n\n    SCHRO_SET_ENUM(enc_block_overlap_list, ENC_MCBLK_OVERLAP, ENC_MCBLK_OVERLAP_TEXT, \"motion_block_overlap\")\n\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX ENC_MVPREC );\n    if( !psz_tmp )\n        goto error;\n    else if( *psz_tmp != '\\0') {\n        if( !strcmp( psz_tmp, \"1\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 0 );\n        }\n        else if( !strcmp( psz_tmp, \"1/2\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 1 );\n        }\n        else if( !strcmp( psz_tmp, \"1/4\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 2 );\n        }\n        else if( !strcmp( psz_tmp, \"1/8\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 3 );\n        }\n        else {\n            msg_Err( p_enc, \"Invalid mv_precision: %s\", psz_tmp );\n            free( psz_tmp );\n            goto error;\n        }\n    }\n    free( psz_tmp );\n\n    SCHRO_SET_INTEGER(ENC_ME_COMBINED, \"enable_chroma_me\", -1)\n\n    SCHRO_SET_ENUM(enc_wavelet_list, ENC_DWTINTRA, ENC_DWTINTRA_TEXT, \"intra_wavelet\")\n\n    SCHRO_SET_ENUM(enc_wavelet_list, ENC_DWTINTER, ENC_DWTINTER_TEXT, \"inter_wavelet\")\n\n    SCHRO_SET_INTEGER(ENC_DWTDEPTH, \"transform_depth\", -1)\n\n    SCHRO_SET_INTEGER(ENC_MULTIQUANT, \"enable_multiquant\", -1)\n\n    SCHRO_SET_INTEGER(ENC_NOAC, \"enable_noarith\", -1)\n\n    SCHRO_SET_ENUM(enc_perceptual_weighting_list, ENC_PWT, ENC_PWT_TEXT, \"perceptual_weighting\")\n\n    SCHRO_SET_FLOAT(ENC_PDIST, \"perceptual_distance\")\n\n    SCHRO_SET_INTEGER(ENC_HSLICES, \"horiz_slices\", -1)\n\n    SCHRO_SET_INTEGER(ENC_VSLICES, \"vert_slices\", -1)\n\n    SCHRO_SET_ENUM(enc_codeblock_size_list, ENC_SCBLK_SIZE, ENC_SCBLK_SIZE_TEXT, \"codeblock_size\")\n\n    SCHRO_SET_INTEGER(ENC_ME_HIERARCHICAL, \"enable_hierarchical_estimation\", -1)\n\n    SCHRO_SET_INTEGER(ENC_ME_DOWNSAMPLE_LEVELS, \"downsample_levels\", 1)\n\n    SCHRO_SET_INTEGER(ENC_ME_GLOBAL_MOTION, \"enable_global_motion\", -1)\n\n    SCHRO_SET_INTEGER(ENC_ME_PHASECORR, \"enable_phasecorr_estimation\", -1)\n\n    SCHRO_SET_INTEGER(ENC_SCD, \"enable_scene_change_detection\", -1)\n\n    SCHRO_SET_ENUM(enc_profile_list, ENC_FORCE_PROFILE, ENC_FORCE_PROFILE_TEXT, \"force_profile\")\n\n    p_sys->started = 0;\n\n    return VLC_SUCCESS;\nerror:\n    CloseEncoder( p_this );\n    return VLC_EGENERIC;\n}\n\n\nstruct enc_picture_free_t\n{\n   picture_t *p_pic;\n   encoder_t *p_enc;\n};\n\n/*****************************************************************************\n * EncSchroFrameFree: schro_frame callback to release the associated picture_t\n * When schro_encoder_reset() is called there will be pictures in the\n * encoding pipeline that need to be released rather than displayed.\n *****************************************************************************/\nstatic void EncSchroFrameFree( SchroFrame *frame, void *priv )\n{\n    struct enc_picture_free_t *p_free = priv;\n\n    if( !p_free )\n        return;\n\n    picture_Release( p_free->p_pic );\n    free( p_free );\n    (void)frame;\n}\n\n/*****************************************************************************\n * CreateSchroFrameFromPic: wrap a picture_t in a SchroFrame\n *****************************************************************************/\nstatic SchroFrame *CreateSchroFrameFromInputPic( encoder_t *p_enc,  picture_t *p_pic )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    SchroFrame *p_schroframe = schro_frame_new();\n    struct enc_picture_free_t *p_free;\n\n    if( !p_schroframe )\n        return NULL;\n\n    if( !p_pic )\n        return NULL;\n\n    p_schroframe->format = SCHRO_FRAME_FORMAT_U8_420;\n    if( p_sys->p_format->chroma_format == SCHRO_CHROMA_422 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_422;\n    }\n    else if( p_sys->p_format->chroma_format == SCHRO_CHROMA_444 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_444;\n    }\n\n    p_schroframe->width  = p_sys->p_format->width;\n    p_schroframe->height = p_sys->p_format->height;\n\n    p_free = malloc( sizeof( *p_free ) );\n    if( unlikely( p_free == NULL ) ) {\n        schro_frame_unref( p_schroframe );\n        return NULL;\n    }\n\n    p_free->p_pic = p_pic;\n    p_free->p_enc = p_enc;\n    schro_frame_set_free_callback( p_schroframe, EncSchroFrameFree, p_free );\n\n    for( int i=0; i<3; i++ )\n    {\n        p_schroframe->components[i].width  = p_pic->p[i].i_visible_pitch;\n        p_schroframe->components[i].stride = p_pic->p[i].i_pitch;\n        p_schroframe->components[i].height = p_pic->p[i].i_visible_lines;\n        p_schroframe->components[i].length =\n            p_pic->p[i].i_pitch * p_pic->p[i].i_lines;\n        p_schroframe->components[i].data   = p_pic->p[i].p_pixels;\n\n        if( i!=0 )\n        {\n            p_schroframe->components[i].v_shift =\n                SCHRO_FRAME_FORMAT_V_SHIFT( p_schroframe->format );\n            p_schroframe->components[i].h_shift =\n                SCHRO_FRAME_FORMAT_H_SHIFT( p_schroframe->format );\n        }\n    }\n\n    return p_schroframe;\n}\n\n/* Attempt to find dirac picture number in an encapsulation unit */\nstatic int ReadDiracPictureNumber( uint32_t *p_picnum, block_t *p_block )\n{\n    uint32_t u_pos = 4;\n    /* protect against falling off the edge */\n    while( u_pos + 13 < p_block->i_buffer )\n    {\n        /* find the picture startcode */\n        if( p_block->p_buffer[u_pos] & 0x08 )\n        {\n            *p_picnum = GetDWBE( p_block->p_buffer + u_pos + 9 );\n            return 1;\n        }\n        /* skip to the next dirac data unit */\n        uint32_t u_npo = GetDWBE( p_block->p_buffer + u_pos + 1 );\n        assert( u_npo <= UINT32_MAX - u_pos );\n        if( u_npo == 0 )\n            u_npo = 13;\n        u_pos += u_npo;\n    }\n    return 0;\n}\n\n\nstatic block_t *Encode( encoder_t *p_enc, picture_t *p_pic )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    block_t *p_block, *p_output_chain = NULL;\n    SchroFrame *p_frame;\n    bool b_go = true;\n\n    if( !p_pic ) {\n        if( !p_sys->started || p_sys->b_eos_pulled )\n            return NULL;\n\n        if( !p_sys->b_eos_signalled ) {\n            p_sys->b_eos_signalled = 1;\n            schro_encoder_end_of_stream( p_sys->p_schro );\n        }\n    } else {\n        /* we only know if the sequence is interlaced when the first\n         * picture arrives, so final setup is done here */\n        /* XXX todo, detect change of interlace */\n        p_sys->p_format->interlaced = !p_pic->b_progressive;\n        p_sys->p_format->top_field_first = p_pic->b_top_field_first;\n\n        if( p_sys->b_auto_field_coding )\n            schro_encoder_setting_set_double( p_sys->p_schro, \"interlaced_coding\", !p_pic->b_progressive );\n    }\n\n    if( !p_sys->started ) {\n        date_t date;\n\n        if( p_pic->format.i_chroma != p_enc->fmt_in.i_codec ) {\n            char chroma_in[5], chroma_out[5];\n            vlc_fourcc_to_char( p_pic->format.i_chroma, chroma_in );\n            chroma_in[4]  = '\\0';\n            chroma_out[4] = '\\0';\n            vlc_fourcc_to_char( p_enc->fmt_in.i_codec, chroma_out );\n            msg_Warn( p_enc, \"Resetting chroma from %s to %s\", chroma_out, chroma_in );\n            if( !SetEncChromaFormat( p_enc, p_pic->format.i_chroma ) ) {\n                msg_Err( p_enc, \"Could not reset chroma format to %s\", chroma_in );\n                return NULL;\n            }\n        }\n\n        date_Init( &date, p_enc->fmt_in.video.i_frame_rate, p_enc->fmt_in.video.i_frame_rate_base );\n        /* FIXME - Unlike dirac-research codec Schro doesn't have a function that returns the delay in pics yet.\n         *   Use a default of 1\n         */\n        date_Increment( &date, 1 );\n        p_sys->i_pts_offset = date_Get( &date );\n        if( schro_encoder_setting_get_double( p_sys->p_schro, \"interlaced_coding\" ) > 0.0 ) {\n            date_Set( &date, 0 );\n            date_Increment( &date, 1);\n            p_sys->i_field_time = date_Get( &date ) / 2;\n        }\n\n        schro_video_format_set_std_signal_range( p_sys->p_format, SCHRO_SIGNAL_RANGE_8BIT_VIDEO );\n        schro_encoder_set_video_format( p_sys->p_schro, p_sys->p_format );\n        schro_encoder_start( p_sys->p_schro );\n        p_sys->started = 1;\n    }\n\n    if( !p_sys->b_eos_signalled ) {\n        /* create a schro frame from the input pic and load */\n        /* Increase ref count by 1 so that the picture is not freed until\n           Schro finishes with it */\n        picture_Hold( p_pic );\n\n        p_frame = CreateSchroFrameFromInputPic( p_enc, p_pic );\n        if( !p_frame )\n            return NULL;\n        schro_encoder_push_frame( p_sys->p_schro, p_frame );\n\n\n        /* store pts in a lookaside buffer, so that the same pts may\n        * be used for the picture in coded order */\n        StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date );\n        p_sys->i_input_picnum++;\n\n        /* store dts in a queue, so that they appear in order in\n         * coded order */\n        p_block = block_Alloc( 1 );\n        if( !p_block )\n            return NULL;\n        p_block->i_dts = p_pic->date - p_sys->i_pts_offset;\n        block_FifoPut( p_sys->p_dts_fifo, p_block );\n        p_block = NULL;\n\n        /* for field coding mode, insert an extra value into both the\n         * pts lookaside buffer and dts queue, offset to correspond\n         * to a one field delay. */\n        if( schro_encoder_setting_get_double( p_sys->p_schro, \"interlaced_coding\" ) > 0.0 ) {\n            StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date + p_sys->i_field_time );\n            p_sys->i_input_picnum++;\n\n            p_block = block_Alloc( 1 );\n            if( !p_block )\n                return NULL;\n            p_block->i_dts = p_pic->date - p_sys->i_pts_offset + p_sys->i_field_time;\n            block_FifoPut( p_sys->p_dts_fifo, p_block );\n            p_block = NULL;\n        }\n    }\n\n    do\n    {\n        SchroStateEnum state;\n        state = schro_encoder_wait( p_sys->p_schro );\n        switch( state )\n        {\n        case SCHRO_STATE_NEED_FRAME:\n            b_go = false;\n            break;\n        case SCHRO_STATE_AGAIN:\n            break;\n        case SCHRO_STATE_END_OF_STREAM:\n            p_sys->b_eos_pulled = 1;\n            b_go = false;\n            break;\n        case SCHRO_STATE_HAVE_BUFFER:\n        {\n            SchroBuffer *p_enc_buf;\n            uint32_t u_pic_num;\n            int i_presentation_frame;\n            p_enc_buf = schro_encoder_pull( p_sys->p_schro, &i_presentation_frame );\n            p_block = block_Alloc( p_enc_buf->length );\n            if( !p_block )\n                return NULL;\n\n            memcpy( p_block->p_buffer, p_enc_buf->data, p_enc_buf->length );\n            schro_buffer_unref( p_enc_buf );\n\n            /* Presence of a Sequence header indicates a seek point */\n            if( 0 == p_block->p_buffer[4] )\n            {\n                p_block->i_flags |= BLOCK_FLAG_TYPE_I;\n\n                if( !p_enc->fmt_out.p_extra ) {\n                    const uint8_t eos[] = { 'B','B','C','D',0x10,0,0,0,13,0,0,0,0 };\n                    uint32_t len = GetDWBE( p_block->p_buffer + 5 );\n                    /* if it hasn't been done so far, stash a copy of the\n                     * sequence header for muxers such as ogg */\n                    /* The OggDirac spec advises that a Dirac EOS DataUnit\n                     * is appended to the sequence header to allow guard\n                     * against poor streaming servers */\n                    /* XXX, should this be done using the packetizer ? */\n                    p_enc->fmt_out.p_extra = malloc( len + sizeof( eos ) );\n                    if( !p_enc->fmt_out.p_extra )\n                        return NULL;\n                    memcpy( p_enc->fmt_out.p_extra, p_block->p_buffer, len );\n                    memcpy( (uint8_t*)p_enc->fmt_out.p_extra + len, eos, sizeof( eos ) );\n                    SetDWBE( (uint8_t*)p_enc->fmt_out.p_extra + len + sizeof(eos) - 4, len );\n                    p_enc->fmt_out.i_extra = len + sizeof( eos );\n                }\n            }\n\n            if( ReadDiracPictureNumber( &u_pic_num, p_block ) ) {\n                block_t *p_dts_block = block_FifoGet( p_sys->p_dts_fifo );\n                p_block->i_dts = p_dts_block->i_dts;\n                   p_block->i_pts = GetPicturePTS( p_enc, u_pic_num );\n                block_Release( p_dts_block );\n                block_ChainAppend( &p_output_chain, p_block );\n            } else {\n                /* End of sequence */\n                block_ChainAppend( &p_output_chain, p_block );\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    } while( b_go );\n\n    return p_output_chain;\n}\n\n/*****************************************************************************\n * CloseEncoder: Schro encoder destruction\n *****************************************************************************/\nstatic void CloseEncoder( vlc_object_t *p_this )\n{\n    encoder_t *p_enc = (encoder_t *)p_this;\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    /* Free the encoder resources */\n    if( p_sys->p_schro )\n        schro_encoder_free( p_sys->p_schro );\n\n    free( p_sys->p_format );\n\n    if( p_sys->p_dts_fifo )\n        block_FifoRelease( p_sys->p_dts_fifo );\n\n    block_ChainRelease( p_sys->p_chain );\n\n    free( p_sys );\n}\n"], "fixing_code": ["/*****************************************************************************\n * schroedinger.c: Dirac decoder module making use of libschroedinger.\n *          (http://www.bbc.co.uk/rd/projects/dirac/index.shtml)\n *          (http://diracvideo.org)\n *****************************************************************************\n * Copyright (C) 2008-2011 VLC authors and VideoLAN\n *\n * Authors: Jonathan Rosser <jonathan.rosser@gmail.com>\n *          David Flynn <davidf at rd dot bbc.co.uk>\n *          Anuradha Suraparaju <asuraparaju at gmail dot com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n/*****************************************************************************\n * Preamble\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <assert.h>\n\n#include <vlc_common.h>\n#include <vlc_plugin.h>\n#include <vlc_codec.h>\n\n#include <schroedinger/schro.h>\n\n/*****************************************************************************\n * Module descriptor\n *****************************************************************************/\nstatic int        OpenDecoder  ( vlc_object_t * );\nstatic void       CloseDecoder ( vlc_object_t * );\nstatic int        OpenEncoder  ( vlc_object_t * );\nstatic void       CloseEncoder ( vlc_object_t * );\n\n#define ENC_CFG_PREFIX \"sout-schro-\"\n\n#define ENC_CHROMAFMT \"chroma-fmt\"\n#define ENC_CHROMAFMT_TEXT N_(\"Chroma format\")\n#define ENC_CHROMAFMT_LONGTEXT N_(\"Picking chroma format will force a \" \\\n                                  \"conversion of the video into that format\")\nstatic const char *const enc_chromafmt_list[] =\n  { \"420\", \"422\", \"444\" };\nstatic const char *const enc_chromafmt_list_text[] =\n  { N_(\"4:2:0\"), N_(\"4:2:2\"), N_(\"4:4:4\") };\n\n#define ENC_RATE_CONTROL \"rate-control\"\n#define ENC_RATE_CONTROL_TEXT N_(\"Rate control method\")\n#define ENC_RATE_CONTROL_LONGTEXT N_(\"Method used to encode the video sequence\")\n\nstatic const char *enc_rate_control_list[] = {\n  \"constant_noise_threshold\",\n  \"constant_bitrate\",\n  \"low_delay\",\n  \"lossless\",\n  \"constant_lambda\",\n  \"constant_error\",\n  \"constant_quality\"\n};\n\nstatic const char *enc_rate_control_list_text[] = {\n  N_(\"Constant noise threshold mode\"),\n  N_(\"Constant bitrate mode (CBR)\"),\n  N_(\"Low Delay mode\"),\n  N_(\"Lossless mode\"),\n  N_(\"Constant lambda mode\"),\n  N_(\"Constant error mode\"),\n  N_(\"Constant quality mode\")\n};\n\n#define ENC_GOP_STRUCTURE \"gop-structure\"\n#define ENC_GOP_STRUCTURE_TEXT N_(\"GOP structure\")\n#define ENC_GOP_STRUCTURE_LONGTEXT N_(\"GOP structure used to encode the video sequence\")\n\nstatic const char *enc_gop_structure_list[] = {\n  \"adaptive\",\n  \"intra_only\",\n  \"backref\",\n  \"chained_backref\",\n  \"biref\",\n  \"chained_biref\"\n};\n\nstatic const char *enc_gop_structure_list_text[] = {\n  N_(\"No fixed gop structure. A picture can be intra or inter and refer to previous or future pictures.\"),\n  N_(\"I-frame only sequence\"),\n  N_(\"Inter pictures refere to previous pictures only\"),\n  N_(\"Inter pictures refere to previous pictures only\"),\n  N_(\"Inter pictures can refer to previous or future pictures\"),\n  N_(\"Inter pictures can refer to previous or future pictures\")\n};\n\n#define ENC_QUALITY \"quality\"\n#define ENC_QUALITY_TEXT N_(\"Constant quality factor\")\n#define ENC_QUALITY_LONGTEXT N_(\"Quality factor to use in constant quality mode\")\n\n#define ENC_NOISE_THRESHOLD \"noise-threshold\"\n#define ENC_NOISE_THRESHOLD_TEXT N_(\"Noise Threshold\")\n#define ENC_NOISE_THRESHOLD_LONGTEXT N_(\"Noise threshold to use in constant noise threshold mode\")\n\n#define ENC_BITRATE \"bitrate\"\n#define ENC_BITRATE_TEXT N_(\"CBR bitrate (kbps)\")\n#define ENC_BITRATE_LONGTEXT N_(\"Target bitrate in kbps when encoding in constant bitrate mode\")\n\n#define ENC_MAX_BITRATE \"max-bitrate\"\n#define ENC_MAX_BITRATE_TEXT N_(\"Maximum bitrate (kbps)\")\n#define ENC_MAX_BITRATE_LONGTEXT N_(\"Maximum bitrate in kbps when encoding in constant bitrate mode\")\n\n#define ENC_MIN_BITRATE \"min-bitrate\"\n#define ENC_MIN_BITRATE_TEXT N_(\"Minimum bitrate (kbps)\")\n#define ENC_MIN_BITRATE_LONGTEXT N_(\"Minimum bitrate in kbps when encoding in constant bitrate mode\")\n\n#define ENC_AU_DISTANCE \"gop-length\"\n#define ENC_AU_DISTANCE_TEXT N_(\"GOP length\")\n#define ENC_AU_DISTANCE_LONGTEXT N_(\"Number of pictures between successive sequence headers i.e. length of the group of pictures\")\n\n\n#define ENC_PREFILTER \"filtering\"\n#define ENC_PREFILTER_TEXT N_(\"Prefilter\")\n#define ENC_PREFILTER_LONGTEXT N_(\"Enable adaptive prefiltering\")\n\nstatic const char *enc_filtering_list[] = {\n  \"none\",\n  \"center_weighted_median\",\n  \"gaussian\",\n  \"add_noise\",\n  \"adaptive_gaussian\",\n  \"lowpass\"\n};\n\nstatic const char *enc_filtering_list_text[] = {\n  N_(\"No pre-filtering\"),\n  N_(\"Centre Weighted Median\"),\n  N_(\"Gaussian Low Pass Filter\"),\n  N_(\"Add Noise\"),\n  N_(\"Gaussian Adaptive Low Pass Filter\"),\n  N_(\"Low Pass Filter\"),\n};\n\n#define ENC_PREFILTER_STRENGTH \"filter-value\"\n#define ENC_PREFILTER_STRENGTH_TEXT N_(\"Amount of prefiltering\")\n#define ENC_PREFILTER_STRENGTH_LONGTEXT N_(\"Higher value implies more prefiltering\")\n\n#define ENC_CODINGMODE \"coding-mode\"\n#define ENC_CODINGMODE_TEXT N_(\"Picture coding mode\")\n#define ENC_CODINGMODE_LONGTEXT N_(\"Field coding is where interlaced fields are coded\" \\\n                                   \" separately as opposed to a pseudo-progressive frame\")\nstatic const char *const enc_codingmode_list[] =\n  { \"auto\", \"progressive\", \"field\" };\nstatic const char *const enc_codingmode_list_text[] =\n  { N_(\"auto - let encoder decide based upon input (Best)\"),\n    N_(\"force coding frame as single picture\"),\n    N_(\"force coding frame as separate interlaced fields\"),\n  };\n\n/* advanced option only */\n#define ENC_MCBLK_SIZE \"motion-block-size\"\n#define ENC_MCBLK_SIZE_TEXT N_(\"Size of motion compensation blocks\")\n\nstatic const char *enc_block_size_list[] = {\n  \"automatic\",\n  \"small\",\n  \"medium\",\n  \"large\"\n};\nstatic const char *const enc_block_size_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"small - use small motion compensation blocks\"),\n    N_(\"medium - use medium motion compensation blocks\"),\n    N_(\"large - use large motion compensation blocks\"),\n  };\n\n/* advanced option only */\n#define ENC_MCBLK_OVERLAP \"motion-block-overlap\"\n#define ENC_MCBLK_OVERLAP_TEXT N_(\"Overlap of motion compensation blocks\")\n\nstatic const char *enc_block_overlap_list[] = {\n  \"automatic\",\n  \"none\",\n  \"partial\",\n  \"full\"\n};\nstatic const char *const enc_block_overlap_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"none - Motion compensation blocks do not overlap\"),\n    N_(\"partial - Motion compensation blocks only partially overlap\"),\n    N_(\"full - Motion compensation blocks fully overlap\"),\n  };\n\n\n#define ENC_MVPREC \"mv-precision\"\n#define ENC_MVPREC_TEXT N_(\"Motion Vector precision\")\n#define ENC_MVPREC_LONGTEXT N_(\"Motion Vector precision in pels\")\nstatic const char *const enc_mvprec_list[] =\n  { \"1\", \"1/2\", \"1/4\", \"1/8\" };\n\n/* advanced option only */\n#define ENC_ME_COMBINED \"me-combined\"\n#define ENC_ME_COMBINED_TEXT N_(\"Three component motion estimation\")\n#define ENC_ME_COMBINED_LONGTEXT N_(\"Use chroma as part of the motion estimation process\")\n\n#define ENC_DWTINTRA \"intra-wavelet\"\n#define ENC_DWTINTRA_TEXT N_(\"Intra picture DWT filter\")\n\n#define ENC_DWTINTER \"inter-wavelet\"\n#define ENC_DWTINTER_TEXT N_(\"Inter picture DWT filter\")\n\nstatic const char *enc_wavelet_list[] = {\n  \"desl_dubuc_9_7\",\n  \"le_gall_5_3\",\n  \"desl_dubuc_13_7\",\n  \"haar_0\",\n  \"haar_1\",\n  \"fidelity\",\n  \"daub_9_7\"\n};\n\nstatic const char *enc_wavelet_list_text[] = {\n  \"Deslauriers-Dubuc (9,7)\",\n  \"LeGall (5,3)\",\n  \"Deslauriers-Dubuc (13,7)\",\n  \"Haar with no shift\",\n  \"Haar with single shift per level\",\n  \"Fidelity filter\",\n  \"Daubechies (9,7) integer approximation\"\n};\n\n#define ENC_DWTDEPTH \"transform-depth\"\n#define ENC_DWTDEPTH_TEXT N_(\"Number of DWT iterations\")\n#define ENC_DWTDEPTH_LONGTEXT N_(\"Also known as DWT levels\")\n\n\n/* advanced option only */\n#define ENC_MULTIQUANT \"enable-multiquant\"\n#define ENC_MULTIQUANT_TEXT N_(\"Enable multiple quantizers\")\n#define ENC_MULTIQUANT_LONGTEXT N_(\"Enable multiple quantizers per subband (one per codeblock)\")\n\n/* advanced option only */\n#define ENC_NOAC \"enable-noarith\"\n#define ENC_NOAC_TEXT N_(\"Disable arithmetic coding\")\n#define ENC_NOAC_LONGTEXT N_(\"Use variable length codes instead, useful for very high bitrates\")\n\n/* visual modelling */\n/* advanced option only */\n#define ENC_PWT \"perceptual-weighting\"\n#define ENC_PWT_TEXT N_(\"perceptual weighting method\")\n\nstatic const char *enc_perceptual_weighting_list[] = {\n  \"none\",\n  \"ccir959\",\n  \"moo\",\n  \"manos_sakrison\"\n};\n\n/* advanced option only */\n#define ENC_PDIST \"perceptual-distance\"\n#define ENC_PDIST_TEXT N_(\"perceptual distance\")\n#define ENC_PDIST_LONGTEXT N_(\"perceptual distance to calculate perceptual weight\")\n\n/* advanced option only */\n#define ENC_HSLICES \"horiz-slices\"\n#define ENC_HSLICES_TEXT N_(\"Horizontal slices per frame\")\n#define ENC_HSLICES_LONGTEXT N_(\"Number of horizontal slices per frame in low delay mode\")\n\n/* advanced option only */\n#define ENC_VSLICES \"vert-slices\"\n#define ENC_VSLICES_TEXT N_(\"Vertical slices per frame\")\n#define ENC_VSLICES_LONGTEXT N_(\"Number of vertical slices per frame in low delay mode\")\n\n/* advanced option only */\n#define ENC_SCBLK_SIZE \"codeblock-size\"\n#define ENC_SCBLK_SIZE_TEXT N_(\"Size of code blocks in each subband\")\n\nstatic const char *enc_codeblock_size_list[] = {\n  \"automatic\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"full\"\n};\nstatic const char *const enc_codeblock_size_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"small - use small code blocks\"),\n    N_(\"medium - use medium sized code blocks\"),\n    N_(\"large - use large code blocks\"),\n    N_(\"full - One code block per subband\"),\n  };\n\n/* advanced option only */\n#define ENC_ME_HIERARCHICAL \"enable-hierarchical-me\"\n#define ENC_ME_HIERARCHICAL_TEXT N_(\"Enable hierarchical Motion Estimation\")\n\n/* advanced option only */\n#define ENC_ME_DOWNSAMPLE_LEVELS \"downsample-levels\"\n#define ENC_ME_DOWNSAMPLE_LEVELS_TEXT N_(\"Number of levels of downsampling\")\n#define ENC_ME_DOWNSAMPLE_LEVELS_LONGTEXT N_(\"Number of levels of downsampling in hierarchical motion estimation mode\")\n\n/* advanced option only */\n#define ENC_ME_GLOBAL_MOTION \"enable-global-me\"\n#define ENC_ME_GLOBAL_MOTION_TEXT N_(\"Enable Global Motion Estimation\")\n\n/* advanced option only */\n#define ENC_ME_PHASECORR \"enable-phasecorr-me\"\n#define ENC_ME_PHASECORR_TEXT N_(\"Enable Phase Correlation Estimation\")\n\n/* advanced option only */\n#define ENC_SCD \"enable-scd\"\n#define ENC_SCD_TEXT N_(\"Enable Scene Change Detection\")\n\n/* advanced option only */\n#define ENC_FORCE_PROFILE \"force-profile\"\n#define ENC_FORCE_PROFILE_TEXT N_(\"Force Profile\")\n\nstatic const char *enc_profile_list[] = {\n  \"auto\",\n  \"vc2_low_delay\",\n  \"vc2_simple\",\n  \"vc2_main\",\n  \"main\"\n};\n\nstatic const char *const enc_profile_list_text[] =\n  { N_(\"automatic - let encoder decide based upon input (Best)\"),\n    N_(\"VC2 Low Delay Profile\"),\n    N_(\"VC2 Simple Profile\"),\n    N_(\"VC2 Main Profile\"),\n    N_(\"Main Profile\"),\n  };\n\nstatic const char *const ppsz_enc_options[] = {\n    ENC_RATE_CONTROL, ENC_GOP_STRUCTURE, ENC_QUALITY, ENC_NOISE_THRESHOLD, ENC_BITRATE,\n    ENC_MIN_BITRATE, ENC_MAX_BITRATE, ENC_AU_DISTANCE, ENC_CHROMAFMT,\n    ENC_PREFILTER, ENC_PREFILTER_STRENGTH, ENC_CODINGMODE, ENC_MCBLK_SIZE,\n    ENC_MCBLK_OVERLAP, ENC_MVPREC, ENC_ME_COMBINED, ENC_DWTINTRA, ENC_DWTINTER,\n    ENC_DWTDEPTH, ENC_MULTIQUANT, ENC_NOAC, ENC_PWT, ENC_PDIST, ENC_HSLICES,\n    ENC_VSLICES, ENC_SCBLK_SIZE, ENC_ME_HIERARCHICAL, ENC_ME_DOWNSAMPLE_LEVELS,\n    ENC_ME_GLOBAL_MOTION, ENC_ME_PHASECORR, ENC_SCD, ENC_FORCE_PROFILE,\n    NULL\n};\n\n\n/* Module declaration */\n\nvlc_module_begin ()\n    set_category( CAT_INPUT )\n    set_subcategory( SUBCAT_INPUT_VCODEC )\n    set_shortname( \"Schroedinger\" )\n    set_description( N_(\"Dirac video decoder using libschroedinger\") )\n    set_capability( \"decoder\", 200 )\n    set_callbacks( OpenDecoder, CloseDecoder )\n    add_shortcut( \"schroedinger\" )\n\n    /* encoder */\n    add_submodule()\n    set_section( N_(\"Encoding\") , NULL )\n    set_description( N_(\"Dirac video encoder using libschroedinger\") )\n    set_capability( \"encoder\", 110 )\n    set_callbacks( OpenEncoder, CloseEncoder )\n    add_shortcut( \"schroedinger\", \"schro\" )\n\n    add_string( ENC_CFG_PREFIX ENC_RATE_CONTROL, NULL,\n                 ENC_RATE_CONTROL_TEXT, ENC_RATE_CONTROL_LONGTEXT, false )\n    change_string_list( enc_rate_control_list, enc_rate_control_list_text )\n\n    add_float( ENC_CFG_PREFIX ENC_QUALITY, -1.,\n               ENC_QUALITY_TEXT, ENC_QUALITY_LONGTEXT, false )\n    change_float_range(-1., 10.);\n\n    add_float( ENC_CFG_PREFIX ENC_NOISE_THRESHOLD, -1.,\n               ENC_NOISE_THRESHOLD_TEXT, ENC_NOISE_THRESHOLD_LONGTEXT, false )\n    change_float_range(-1., 100.);\n\n    add_integer( ENC_CFG_PREFIX ENC_BITRATE, -1,\n                 ENC_BITRATE_TEXT, ENC_BITRATE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_integer( ENC_CFG_PREFIX ENC_MAX_BITRATE, -1,\n                 ENC_MAX_BITRATE_TEXT, ENC_MAX_BITRATE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_integer( ENC_CFG_PREFIX ENC_MIN_BITRATE, -1,\n                 ENC_MIN_BITRATE_TEXT, ENC_MIN_BITRATE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_string( ENC_CFG_PREFIX ENC_GOP_STRUCTURE, NULL,\n                 ENC_GOP_STRUCTURE_TEXT, ENC_GOP_STRUCTURE_LONGTEXT, false )\n    change_string_list( enc_gop_structure_list, enc_gop_structure_list_text )\n\n    add_integer( ENC_CFG_PREFIX ENC_AU_DISTANCE, -1,\n                 ENC_AU_DISTANCE_TEXT, ENC_AU_DISTANCE_LONGTEXT, false )\n    change_integer_range(-1, INT_MAX);\n\n    add_string( ENC_CFG_PREFIX ENC_CHROMAFMT, \"420\",\n                ENC_CHROMAFMT_TEXT, ENC_CHROMAFMT_LONGTEXT, false )\n    change_string_list( enc_chromafmt_list, enc_chromafmt_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_CODINGMODE, \"auto\",\n                ENC_CODINGMODE_TEXT, ENC_CODINGMODE_LONGTEXT, false )\n    change_string_list( enc_codingmode_list, enc_codingmode_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_MVPREC, NULL,\n                ENC_MVPREC_TEXT, ENC_MVPREC_LONGTEXT, false )\n    change_string_list( enc_mvprec_list, enc_mvprec_list )\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_MCBLK_SIZE, NULL,\n                ENC_MCBLK_SIZE_TEXT, ENC_MCBLK_SIZE_TEXT, true )\n    change_string_list( enc_block_size_list, enc_block_size_list_text )\n\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_MCBLK_OVERLAP, NULL,\n                ENC_MCBLK_OVERLAP_TEXT, ENC_MCBLK_OVERLAP_TEXT, true )\n    change_string_list( enc_block_overlap_list, enc_block_overlap_list_text )\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_COMBINED, -1,\n              ENC_ME_COMBINED_TEXT, ENC_ME_COMBINED_LONGTEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_HIERARCHICAL, -1,\n                 ENC_ME_HIERARCHICAL_TEXT, ENC_ME_HIERARCHICAL_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_DOWNSAMPLE_LEVELS, -1,\n                 ENC_ME_DOWNSAMPLE_LEVELS_TEXT, ENC_ME_DOWNSAMPLE_LEVELS_LONGTEXT, true )\n    change_integer_range(-1, 8 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_GLOBAL_MOTION, -1,\n                 ENC_ME_GLOBAL_MOTION_TEXT, ENC_ME_GLOBAL_MOTION_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_ME_PHASECORR, -1,\n                 ENC_ME_PHASECORR_TEXT, ENC_ME_PHASECORR_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    add_string( ENC_CFG_PREFIX ENC_DWTINTRA, NULL,\n                ENC_DWTINTRA_TEXT, ENC_DWTINTRA_TEXT, false )\n    change_string_list( enc_wavelet_list, enc_wavelet_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_DWTINTER, NULL,\n                ENC_DWTINTER_TEXT, ENC_DWTINTER_TEXT, false )\n    change_string_list( enc_wavelet_list, enc_wavelet_list_text )\n\n    add_integer( ENC_CFG_PREFIX ENC_DWTDEPTH, -1,\n                 ENC_DWTDEPTH_TEXT, ENC_DWTDEPTH_LONGTEXT, false )\n    change_integer_range(-1, SCHRO_LIMIT_ENCODER_TRANSFORM_DEPTH );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_MULTIQUANT, -1,\n                 ENC_MULTIQUANT_TEXT, ENC_MULTIQUANT_LONGTEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_SCBLK_SIZE, NULL,\n                ENC_SCBLK_SIZE_TEXT, ENC_SCBLK_SIZE_TEXT, true )\n    change_string_list( enc_codeblock_size_list, enc_codeblock_size_list_text )\n\n    add_string( ENC_CFG_PREFIX ENC_PREFILTER, NULL,\n                ENC_PREFILTER_TEXT, ENC_PREFILTER_LONGTEXT, false )\n    change_string_list( enc_filtering_list, enc_filtering_list_text )\n\n    add_float( ENC_CFG_PREFIX ENC_PREFILTER_STRENGTH, -1.,\n                 ENC_PREFILTER_STRENGTH_TEXT, ENC_PREFILTER_STRENGTH_LONGTEXT, false )\n    change_float_range(-1., 100.0);\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_SCD, -1,\n                 ENC_SCD_TEXT, ENC_SCD_TEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_PWT, NULL,\n                ENC_PWT_TEXT, ENC_PWT_TEXT, true )\n    change_string_list( enc_perceptual_weighting_list, enc_perceptual_weighting_list )\n\n    /* advanced option only */\n    add_float( ENC_CFG_PREFIX ENC_PDIST, -1,\n               ENC_PDIST_TEXT, ENC_PDIST_LONGTEXT, true )\n    change_float_range(-1., 100.);\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_NOAC, -1,\n              ENC_NOAC_TEXT, ENC_NOAC_LONGTEXT, true )\n    change_integer_range(-1, 1 );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_HSLICES, -1,\n                 ENC_HSLICES_TEXT, ENC_HSLICES_LONGTEXT, true )\n    change_integer_range(-1, INT_MAX );\n\n    /* advanced option only */\n    add_integer( ENC_CFG_PREFIX ENC_VSLICES, -1,\n                 ENC_VSLICES_TEXT, ENC_VSLICES_LONGTEXT, true )\n    change_integer_range(-1, INT_MAX );\n\n    /* advanced option only */\n    add_string( ENC_CFG_PREFIX ENC_FORCE_PROFILE, NULL,\n                ENC_FORCE_PROFILE_TEXT, ENC_FORCE_PROFILE_TEXT, true )\n    change_string_list( enc_profile_list, enc_profile_list_text )\n\nvlc_module_end ()\n\n\n/*****************************************************************************\n * Local prototypes\n *****************************************************************************/\nstatic picture_t *DecodeBlock  ( decoder_t *p_dec, block_t **pp_block );\n\nstruct picture_free_t\n{\n   picture_t *p_pic;\n   decoder_t *p_dec;\n};\n\n/*****************************************************************************\n * decoder_sys_t : Schroedinger decoder descriptor\n *****************************************************************************/\nstruct decoder_sys_t\n{\n    /*\n     * Dirac properties\n     */\n    mtime_t i_lastpts;\n    mtime_t i_frame_pts_delta;\n    SchroDecoder *p_schro;\n    SchroVideoFormat *p_format;\n};\n\n/*****************************************************************************\n * OpenDecoder: probe the decoder and return score\n *****************************************************************************/\nstatic int OpenDecoder( vlc_object_t *p_this )\n{\n    decoder_t *p_dec = (decoder_t*)p_this;\n    decoder_sys_t *p_sys;\n    SchroDecoder *p_schro;\n\n    if( p_dec->fmt_in.i_codec != VLC_CODEC_DIRAC )\n    {\n        return VLC_EGENERIC;\n    }\n\n    /* Allocate the memory needed to store the decoder's structure */\n    p_sys = malloc(sizeof(decoder_sys_t));\n    if( p_sys == NULL )\n        return VLC_ENOMEM;\n\n    /* Initialise the schroedinger (and hence liboil libraries */\n    /* This does no allocation and is safe to call */\n    schro_init();\n\n    /* Initialise the schroedinger decoder */\n    if( !(p_schro = schro_decoder_new()) )\n    {\n        free( p_sys );\n        return VLC_EGENERIC;\n    }\n\n    p_dec->p_sys = p_sys;\n    p_sys->p_schro = p_schro;\n    p_sys->p_format = NULL;\n    p_sys->i_lastpts = VLC_TS_INVALID;\n    p_sys->i_frame_pts_delta = 0;\n\n    /* Set output properties */\n    p_dec->fmt_out.i_cat = VIDEO_ES;\n    p_dec->fmt_out.i_codec = VLC_CODEC_I420;\n\n    /* Set callbacks */\n    p_dec->pf_decode_video = DecodeBlock;\n\n    return VLC_SUCCESS;\n}\n\n/*****************************************************************************\n * SetPictureFormat: Set the decoded picture params to the ones from the stream\n *****************************************************************************/\nstatic void SetVideoFormat( decoder_t *p_dec )\n{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    p_sys->p_format = schro_decoder_get_video_format(p_sys->p_schro);\n    if( p_sys->p_format == NULL ) return;\n\n    p_sys->i_frame_pts_delta = CLOCK_FREQ\n                            * p_sys->p_format->frame_rate_denominator\n                            / p_sys->p_format->frame_rate_numerator;\n\n    switch( p_sys->p_format->chroma_format )\n    {\n    case SCHRO_CHROMA_420: p_dec->fmt_out.i_codec = VLC_CODEC_I420; break;\n    case SCHRO_CHROMA_422: p_dec->fmt_out.i_codec = VLC_CODEC_I422; break;\n    case SCHRO_CHROMA_444: p_dec->fmt_out.i_codec = VLC_CODEC_I444; break;\n    default:\n        p_dec->fmt_out.i_codec = 0;\n        break;\n    }\n\n    p_dec->fmt_out.video.i_visible_width = p_sys->p_format->clean_width;\n    p_dec->fmt_out.video.i_x_offset = p_sys->p_format->left_offset;\n    p_dec->fmt_out.video.i_width = p_sys->p_format->width;\n\n    p_dec->fmt_out.video.i_visible_height = p_sys->p_format->clean_height;\n    p_dec->fmt_out.video.i_y_offset = p_sys->p_format->top_offset;\n    p_dec->fmt_out.video.i_height = p_sys->p_format->height;\n\n    /* aspect_ratio_[numerator|denominator] describes the pixel aspect ratio */\n    p_dec->fmt_out.video.i_sar_num = p_sys->p_format->aspect_ratio_numerator;\n    p_dec->fmt_out.video.i_sar_den = p_sys->p_format->aspect_ratio_denominator;\n\n    p_dec->fmt_out.video.i_frame_rate =\n        p_sys->p_format->frame_rate_numerator;\n    p_dec->fmt_out.video.i_frame_rate_base =\n        p_sys->p_format->frame_rate_denominator;\n}\n\n/*****************************************************************************\n * SchroFrameFree: schro_frame callback to release the associated picture_t\n * When schro_decoder_reset() is called there will be pictures in the\n * decoding pipeline that need to be released rather than displayed.\n *****************************************************************************/\nstatic void SchroFrameFree( SchroFrame *frame, void *priv)\n{\n    struct picture_free_t *p_free = priv;\n\n    if( !p_free )\n        return;\n\n    picture_Release( p_free->p_pic );\n    free(p_free);\n    (void)frame;\n}\n\n/*****************************************************************************\n * CreateSchroFrameFromPic: wrap a picture_t in a SchroFrame\n *****************************************************************************/\nstatic SchroFrame *CreateSchroFrameFromPic( decoder_t *p_dec )\n{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n    SchroFrame *p_schroframe = schro_frame_new();\n    picture_t *p_pic = NULL;\n    struct picture_free_t *p_free;\n\n    if( !p_schroframe )\n        return NULL;\n\n    p_pic = decoder_NewPicture( p_dec );\n\n    if( !p_pic )\n        return NULL;\n\n    p_schroframe->format = SCHRO_FRAME_FORMAT_U8_420;\n    if( p_sys->p_format->chroma_format == SCHRO_CHROMA_422 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_422;\n    }\n    else if( p_sys->p_format->chroma_format == SCHRO_CHROMA_444 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_444;\n    }\n\n    p_schroframe->width = p_sys->p_format->width;\n    p_schroframe->height = p_sys->p_format->height;\n\n    p_free = malloc( sizeof( *p_free ) );\n    p_free->p_pic = p_pic;\n    p_free->p_dec = p_dec;\n    schro_frame_set_free_callback( p_schroframe, SchroFrameFree, p_free );\n\n    for( int i=0; i<3; i++ )\n    {\n        p_schroframe->components[i].width = p_pic->p[i].i_visible_pitch;\n        p_schroframe->components[i].stride = p_pic->p[i].i_pitch;\n        p_schroframe->components[i].height = p_pic->p[i].i_visible_lines;\n        p_schroframe->components[i].length =\n            p_pic->p[i].i_pitch * p_pic->p[i].i_lines;\n        p_schroframe->components[i].data = p_pic->p[i].p_pixels;\n\n        if(i!=0)\n        {\n            p_schroframe->components[i].v_shift =\n                SCHRO_FRAME_FORMAT_V_SHIFT( p_schroframe->format );\n            p_schroframe->components[i].h_shift =\n                SCHRO_FRAME_FORMAT_H_SHIFT( p_schroframe->format );\n        }\n    }\n\n    p_pic->b_progressive = !p_sys->p_format->interlaced;\n    p_pic->b_top_field_first = p_sys->p_format->top_field_first;\n    p_pic->i_nb_fields = 2;\n\n    return p_schroframe;\n}\n\n/*****************************************************************************\n * SchroBufferFree: schro_buffer callback to release the associated block_t\n *****************************************************************************/\nstatic void SchroBufferFree( SchroBuffer *buf, void *priv )\n{\n    block_t *p_block = priv;\n\n    if( !p_block )\n        return;\n\n    block_Release( p_block );\n    (void)buf;\n}\n\n/*****************************************************************************\n * CloseDecoder: decoder destruction\n *****************************************************************************/\nstatic void CloseDecoder( vlc_object_t *p_this )\n{\n    decoder_t *p_dec = (decoder_t *)p_this;\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    schro_decoder_free( p_sys->p_schro );\n    free( p_sys );\n}\n\n/****************************************************************************\n * DecodeBlock: the whole thing\n ****************************************************************************\n * Blocks need not be Dirac dataunit aligned.\n * If a block has a PTS signaled, it applies to the first picture at or after p_block\n *\n * If this function returns a picture (!NULL), it is called again and the\n * same block is resubmitted.  To avoid this, set *pp_block to NULL;\n * If this function returns NULL, the *pp_block is lost (and leaked).\n * This function must free all blocks when finished with them.\n ****************************************************************************/\nstatic picture_t *DecodeBlock( decoder_t *p_dec, block_t **pp_block )\n{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    if( !pp_block ) return NULL;\n\n    if ( *pp_block ) {\n        block_t *p_block = *pp_block;\n\n        /* reset the decoder when seeking as the decode in progress is invalid */\n        /* discard the block as it is just a null magic block */\n        if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY ) {\n            schro_decoder_reset( p_sys->p_schro );\n\n            p_sys->i_lastpts = VLC_TS_INVALID;\n            block_Release( p_block );\n            *pp_block = NULL;\n            return NULL;\n        }\n\n        SchroBuffer *p_schrobuffer;\n        p_schrobuffer = schro_buffer_new_with_data( p_block->p_buffer, p_block->i_buffer );\n        p_schrobuffer->free = SchroBufferFree;\n        p_schrobuffer->priv = p_block;\n        if( p_block->i_pts > VLC_TS_INVALID ) {\n            mtime_t *p_pts = malloc( sizeof(*p_pts) );\n            if( p_pts ) {\n                *p_pts = p_block->i_pts;\n                /* if this call fails, p_pts is freed automatically */\n                p_schrobuffer->tag = schro_tag_new( p_pts, free );\n            }\n        }\n\n        /* this stops the same block being fed back into this function if\n         * we were on the next iteration of this loop to output a picture */\n        *pp_block = NULL;\n        schro_decoder_autoparse_push( p_sys->p_schro, p_schrobuffer );\n        /* DO NOT refer to p_block after this point, it may have been freed */\n    }\n\n    while( 1 )\n    {\n        SchroFrame *p_schroframe;\n        picture_t *p_pic;\n        int state = schro_decoder_autoparse_wait( p_sys->p_schro );\n\n        switch( state )\n        {\n        case SCHRO_DECODER_FIRST_ACCESS_UNIT:\n            SetVideoFormat( p_dec );\n            break;\n\n        case SCHRO_DECODER_NEED_BITS:\n            return NULL;\n\n        case SCHRO_DECODER_NEED_FRAME:\n            p_schroframe = CreateSchroFrameFromPic( p_dec );\n\n            if( !p_schroframe )\n            {\n                msg_Err( p_dec, \"Could not allocate picture for decoder\");\n                return NULL;\n            }\n\n            schro_decoder_add_output_picture( p_sys->p_schro, p_schroframe);\n            break;\n\n        case SCHRO_DECODER_OK: {\n            SchroTag *p_tag = schro_decoder_get_picture_tag( p_sys->p_schro );\n            p_schroframe = schro_decoder_pull( p_sys->p_schro );\n            if( !p_schroframe || !p_schroframe->priv )\n            {\n                /* frame can't be one that was allocated by us\n                 *   -- no private data: discard */\n                if( p_tag ) schro_tag_free( p_tag );\n                if( p_schroframe ) schro_frame_unref( p_schroframe );\n                break;\n            }\n            p_pic = ((struct picture_free_t*) p_schroframe->priv)->p_pic;\n            p_schroframe->priv = NULL;\n\n            if( p_tag )\n            {\n                /* free is handled by schro_frame_unref */\n                p_pic->date = *(mtime_t*) p_tag->value;\n                schro_tag_free( p_tag );\n            }\n            else if( p_sys->i_lastpts > VLC_TS_INVALID )\n            {\n                /* NB, this shouldn't happen since the packetizer does a\n                 * very thorough job of inventing timestamps.  The\n                 * following is just a very rough fall back incase packetizer\n                 * is missing. */\n                /* maybe it would be better to set p_pic->b_force ? */\n                p_pic->date = p_sys->i_lastpts + p_sys->i_frame_pts_delta;\n            }\n            p_sys->i_lastpts = p_pic->date;\n\n            schro_frame_unref( p_schroframe );\n            return p_pic;\n        }\n        case SCHRO_DECODER_EOS:\n            /* NB, the new api will not emit _EOS, it handles the reset internally */\n            break;\n\n        case SCHRO_DECODER_ERROR:\n            msg_Err( p_dec, \"SCHRO_DECODER_ERROR\");\n            return NULL;\n        }\n    }\n}\n\n/*****************************************************************************\n * Local prototypes\n *****************************************************************************/\nstatic block_t *Encode( encoder_t *p_enc, picture_t *p_pict );\n\n\n/*****************************************************************************\n * picture_pts_t : store pts alongside picture number, not carried through\n * encoder\n *****************************************************************************/\nstruct picture_pts_t\n{\n   mtime_t i_pts;    /* associated pts */\n   uint32_t u_pnum;  /* dirac picture number */\n   bool b_empty;     /* entry is invalid */\n};\n\n/*****************************************************************************\n * encoder_sys_t : Schroedinger encoder descriptor\n *****************************************************************************/\n#define SCHRO_PTS_TLB_SIZE 256\nstruct encoder_sys_t\n{\n    /*\n     * Schro properties\n     */\n    SchroEncoder *p_schro;\n    SchroVideoFormat *p_format;\n    int started;\n    bool b_auto_field_coding;\n\n    uint32_t i_input_picnum;\n    block_fifo_t *p_dts_fifo;\n\n    block_t *p_chain;\n\n    struct picture_pts_t pts_tlb[SCHRO_PTS_TLB_SIZE];\n    mtime_t i_pts_offset;\n    mtime_t i_field_time;\n\n    bool b_eos_signalled;\n    bool b_eos_pulled;\n};\n\nstatic struct\n{\n    unsigned int i_height;\n    int i_approx_fps;\n    SchroVideoFormatEnum i_vf;\n} schro_format_guess[] = {\n    /* Important: Keep this list ordered in ascending picture height */\n    {1, 0, SCHRO_VIDEO_FORMAT_CUSTOM},\n    {120, 15, SCHRO_VIDEO_FORMAT_QSIF},\n    {144, 12, SCHRO_VIDEO_FORMAT_QCIF},\n    {240, 15, SCHRO_VIDEO_FORMAT_SIF},\n    {288, 12, SCHRO_VIDEO_FORMAT_CIF},\n    {480, 30, SCHRO_VIDEO_FORMAT_SD480I_60},\n    {480, 15, SCHRO_VIDEO_FORMAT_4SIF},\n    {576, 12, SCHRO_VIDEO_FORMAT_4CIF},\n    {576, 25, SCHRO_VIDEO_FORMAT_SD576I_50},\n    {720, 50, SCHRO_VIDEO_FORMAT_HD720P_50},\n    {720, 60, SCHRO_VIDEO_FORMAT_HD720P_60},\n    {1080, 24, SCHRO_VIDEO_FORMAT_DC2K_24},\n    {1080, 25, SCHRO_VIDEO_FORMAT_HD1080I_50},\n    {1080, 30, SCHRO_VIDEO_FORMAT_HD1080I_60},\n    {1080, 50, SCHRO_VIDEO_FORMAT_HD1080P_50},\n    {1080, 60, SCHRO_VIDEO_FORMAT_HD1080P_60},\n    {2160, 24, SCHRO_VIDEO_FORMAT_DC4K_24},\n    {0, 0, 0},\n};\n\n/*****************************************************************************\n * ResetPTStlb: Purge all entries in @p_enc@'s PTS-tlb\n *****************************************************************************/\nstatic void ResetPTStlb( encoder_t *p_enc )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    for( int i = 0; i < SCHRO_PTS_TLB_SIZE; i++ )\n    {\n        p_sys->pts_tlb[i].b_empty = true;\n    }\n}\n\n\n/*****************************************************************************\n * StorePicturePTS: Store the PTS value for a particular picture number\n *****************************************************************************/\nstatic void StorePicturePTS( encoder_t *p_enc, uint32_t u_pnum, mtime_t i_pts )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    for( int i = 0; i<SCHRO_PTS_TLB_SIZE; i++ )\n    {\n        if( p_sys->pts_tlb[i].b_empty )\n        {\n            p_sys->pts_tlb[i].u_pnum = u_pnum;\n            p_sys->pts_tlb[i].i_pts = i_pts;\n            p_sys->pts_tlb[i].b_empty = false;\n\n            return;\n        }\n    }\n\n    msg_Err( p_enc, \"Could not store PTS %\"PRId64\" for frame %u\", i_pts, u_pnum );\n}\n\n/*****************************************************************************\n * GetPicturePTS: Retrieve the PTS value for a particular picture number\n *****************************************************************************/\nstatic mtime_t GetPicturePTS( encoder_t *p_enc, uint32_t u_pnum )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    for( int i = 0; i < SCHRO_PTS_TLB_SIZE; i++ )\n    {\n        if( !p_sys->pts_tlb[i].b_empty &&\n            p_sys->pts_tlb[i].u_pnum == u_pnum )\n        {\n             p_sys->pts_tlb[i].b_empty = true;\n             return p_sys->pts_tlb[i].i_pts;\n        }\n    }\n\n    msg_Err( p_enc, \"Could not retrieve PTS for picture %u\", u_pnum );\n    return 0;\n}\n\nstatic inline bool SchroSetEnum( const encoder_t *p_enc, int i_list_size, const char *list[],\n                  const char *psz_name,  const char *psz_name_text,  const char *psz_value)\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    if( list && psz_name_text && psz_name && psz_value ) {\n        for( int i = 0; i < i_list_size; ++i ) {\n            if( strcmp( list[i], psz_value ) )\n                continue;\n            schro_encoder_setting_set_double( p_sys->p_schro, psz_name, i );\n            return true;\n        }\n        msg_Err( p_enc, \"Invalid %s: %s\", psz_name_text, psz_value );\n    }\n    return false;\n}\n\nstatic bool SetEncChromaFormat( encoder_t *p_enc, uint32_t i_codec )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    switch( i_codec ) {\n    case VLC_CODEC_I420:\n        p_enc->fmt_in.i_codec = i_codec;\n        p_enc->fmt_in.video.i_bits_per_pixel = 12;\n        p_sys->p_format->chroma_format = SCHRO_CHROMA_420;\n           break;\n    case VLC_CODEC_I422:\n        p_enc->fmt_in.i_codec = i_codec;\n        p_enc->fmt_in.video.i_bits_per_pixel = 16;\n        p_sys->p_format->chroma_format = SCHRO_CHROMA_422;\n        break;\n    case VLC_CODEC_I444:\n        p_enc->fmt_in.i_codec = i_codec;\n        p_enc->fmt_in.video.i_bits_per_pixel = 24;\n        p_sys->p_format->chroma_format = SCHRO_CHROMA_444;\n        break;\n    default:\n        return false;\n    }\n\n    return true;\n}\n\n#define SCHRO_SET_FLOAT(psz_name, pschro_name) \\\n    f_tmp = var_GetFloat( p_enc, ENC_CFG_PREFIX psz_name ); \\\n    if( f_tmp >= 0.0 ) \\\n        schro_encoder_setting_set_double( p_sys->p_schro, pschro_name, f_tmp );\n\n#define SCHRO_SET_INTEGER(psz_name, pschro_name, ignore_val) \\\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX psz_name ); \\\n    if( i_tmp > ignore_val ) \\\n        schro_encoder_setting_set_double( p_sys->p_schro, pschro_name, i_tmp );\n\n#define SCHRO_SET_ENUM(list, psz_name, psz_name_text, pschro_name) \\\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX psz_name ); \\\n    if( !psz_tmp ) \\\n        goto error; \\\n    else if ( *psz_tmp != '\\0' ) { \\\n        int i_list_size = ARRAY_SIZE(list); \\\n        if( !SchroSetEnum( p_enc, i_list_size, list, pschro_name, psz_name_text, psz_tmp ) ) { \\\n            free( psz_tmp ); \\\n            goto error; \\\n        } \\\n    } \\\n    free( psz_tmp );\n\n/*****************************************************************************\n * OpenEncoder: probe the encoder and return score\n *****************************************************************************/\nstatic int OpenEncoder( vlc_object_t *p_this )\n{\n    encoder_t *p_enc = (encoder_t *)p_this;\n    encoder_sys_t *p_sys;\n    int i_tmp;\n    float f_tmp;\n    char *psz_tmp;\n\n    if( p_enc->fmt_out.i_codec != VLC_CODEC_DIRAC &&\n        !p_enc->b_force )\n    {\n        return VLC_EGENERIC;\n    }\n\n    if( !p_enc->fmt_in.video.i_frame_rate || !p_enc->fmt_in.video.i_frame_rate_base ||\n        !p_enc->fmt_in.video.i_visible_height || !p_enc->fmt_in.video.i_visible_width )\n    {\n        msg_Err( p_enc, \"Framerate and picture dimensions must be non-zero\" );\n        return VLC_EGENERIC;\n    }\n\n    /* Allocate the memory needed to store the decoder's structure */\n    if( ( p_sys = calloc( 1, sizeof( *p_sys ) ) ) == NULL )\n        return VLC_ENOMEM;\n\n    p_enc->p_sys = p_sys;\n    p_enc->pf_encode_video = Encode;\n    p_enc->fmt_out.i_codec = VLC_CODEC_DIRAC;\n    p_enc->fmt_out.i_cat = VIDEO_ES;\n\n    if( ( p_sys->p_dts_fifo = block_FifoNew() ) == NULL )\n    {\n        CloseEncoder( p_this );\n        return VLC_ENOMEM;\n    }\n\n    ResetPTStlb( p_enc );\n\n    /* guess the video format based upon number of lines and picture height */\n    int i = 0;\n    SchroVideoFormatEnum guessed_video_fmt = SCHRO_VIDEO_FORMAT_CUSTOM;\n    /* Pick the dirac_video_format in this order of preference:\n     *  1. an exact match in frame height and an approximate fps match\n     *  2. the previous preset with a smaller number of lines.\n     */\n    do\n    {\n        if( schro_format_guess[i].i_height > p_enc->fmt_in.video.i_height )\n        {\n            guessed_video_fmt = schro_format_guess[i-1].i_vf;\n            break;\n        }\n        if( schro_format_guess[i].i_height != p_enc->fmt_in.video.i_height )\n            continue;\n        int src_fps = p_enc->fmt_in.video.i_frame_rate / p_enc->fmt_in.video.i_frame_rate_base;\n        int delta_fps = abs( schro_format_guess[i].i_approx_fps - src_fps );\n        if( delta_fps > 2 )\n            continue;\n\n        guessed_video_fmt = schro_format_guess[i].i_vf;\n        break;\n    } while( schro_format_guess[++i].i_height );\n\n    schro_init();\n    p_sys->p_schro = schro_encoder_new();\n    if( !p_sys->p_schro ) {\n        msg_Err( p_enc, \"Failed to initialize libschroedinger encoder\" );\n        return VLC_EGENERIC;\n    }\n    schro_encoder_set_packet_assembly( p_sys->p_schro, true );\n\n    if( !( p_sys->p_format = schro_encoder_get_video_format( p_sys->p_schro ) ) ) {\n        msg_Err( p_enc, \"Failed to get Schroedigner video format\" );\n        schro_encoder_free( p_sys->p_schro );\n        return VLC_EGENERIC;\n    }\n\n    /* initialise the video format parameters to the guessed format */\n    schro_video_format_set_std_video_format( p_sys->p_format, guessed_video_fmt );\n\n    /* constants set from the input video format */\n    p_sys->p_format->width                  = p_enc->fmt_in.video.i_visible_width;\n    p_sys->p_format->height                 = p_enc->fmt_in.video.i_visible_height;\n    p_sys->p_format->frame_rate_numerator   = p_enc->fmt_in.video.i_frame_rate;\n    p_sys->p_format->frame_rate_denominator = p_enc->fmt_in.video.i_frame_rate_base;\n    unsigned u_asr_num, u_asr_den;\n    vlc_ureduce( &u_asr_num, &u_asr_den,\n                 p_enc->fmt_in.video.i_sar_num,\n                 p_enc->fmt_in.video.i_sar_den, 0 );\n    p_sys->p_format->aspect_ratio_numerator   = u_asr_num;\n    p_sys->p_format->aspect_ratio_denominator = u_asr_den;\n\n    config_ChainParse( p_enc, ENC_CFG_PREFIX, ppsz_enc_options, p_enc->p_cfg );\n\n    SCHRO_SET_ENUM(enc_rate_control_list, ENC_RATE_CONTROL, ENC_RATE_CONTROL_TEXT, \"rate_control\")\n\n    SCHRO_SET_ENUM(enc_gop_structure_list, ENC_GOP_STRUCTURE, ENC_GOP_STRUCTURE_TEXT, \"gop_structure\")\n\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX ENC_CHROMAFMT );\n    if( !psz_tmp )\n        goto error;\n    else {\n        uint32_t i_codec;\n        if( !strcmp( psz_tmp, \"420\" ) ) {\n            i_codec = VLC_CODEC_I420;\n        }\n        else if( !strcmp( psz_tmp, \"422\" ) ) {\n            i_codec = VLC_CODEC_I422;\n        }\n        else if( !strcmp( psz_tmp, \"444\" ) ) {\n            i_codec = VLC_CODEC_I444;\n        }\n        else {\n            msg_Err( p_enc, \"Invalid chroma format: %s\", psz_tmp );\n            free( psz_tmp );\n            goto error;\n        }\n        SetEncChromaFormat( p_enc, i_codec );\n    }\n    free( psz_tmp );\n\n    SCHRO_SET_FLOAT(ENC_QUALITY, \"quality\")\n\n    SCHRO_SET_FLOAT(ENC_NOISE_THRESHOLD, \"noise_threshold\")\n\n    /* use bitrate from sout-transcode-vb in kbps */\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX ENC_BITRATE );\n    if( i_tmp > -1 )\n        schro_encoder_setting_set_double( p_sys->p_schro, \"bitrate\", i_tmp * 1000 );\n    else\n        schro_encoder_setting_set_double( p_sys->p_schro, \"bitrate\", p_enc->fmt_out.i_bitrate );\n\n       p_enc->fmt_out.i_bitrate = schro_encoder_setting_get_double( p_sys->p_schro, \"bitrate\" );\n\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX ENC_MIN_BITRATE );\n    if( i_tmp > -1 )\n        schro_encoder_setting_set_double( p_sys->p_schro, \"min_bitrate\", i_tmp * 1000 );\n\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX ENC_MAX_BITRATE );\n    if( i_tmp > -1 )\n        schro_encoder_setting_set_double( p_sys->p_schro, \"max_bitrate\", i_tmp * 1000 );\n\n    SCHRO_SET_INTEGER(ENC_AU_DISTANCE, \"au_distance\", -1)\n\n    SCHRO_SET_ENUM(enc_filtering_list, ENC_PREFILTER, ENC_PREFILTER_TEXT, \"filtering\")\n\n    SCHRO_SET_FLOAT(ENC_PREFILTER_STRENGTH, \"filter_value\")\n\n\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX ENC_CODINGMODE );\n    if( !psz_tmp )\n        goto error;\n    else if( !strcmp( psz_tmp, \"auto\" ) ) {\n        p_sys->b_auto_field_coding = true;\n    }\n    else if( !strcmp( psz_tmp, \"progressive\" ) ) {\n        p_sys->b_auto_field_coding = false;\n        schro_encoder_setting_set_double( p_sys->p_schro, \"interlaced_coding\", false);\n    }\n    else if( !strcmp( psz_tmp, \"field\" ) ) {\n        p_sys->b_auto_field_coding = false;\n        schro_encoder_setting_set_double( p_sys->p_schro, \"interlaced_coding\", true);\n    }\n    else {\n        msg_Err( p_enc, \"Invalid codingmode: %s\", psz_tmp );\n        free( psz_tmp );\n        goto error;\n    }\n    free( psz_tmp );\n\n    SCHRO_SET_ENUM(enc_block_size_list, ENC_MCBLK_SIZE, ENC_MCBLK_SIZE_TEXT, \"motion_block_size\")\n\n    SCHRO_SET_ENUM(enc_block_overlap_list, ENC_MCBLK_OVERLAP, ENC_MCBLK_OVERLAP_TEXT, \"motion_block_overlap\")\n\n    psz_tmp = var_GetString( p_enc, ENC_CFG_PREFIX ENC_MVPREC );\n    if( !psz_tmp )\n        goto error;\n    else if( *psz_tmp != '\\0') {\n        if( !strcmp( psz_tmp, \"1\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 0 );\n        }\n        else if( !strcmp( psz_tmp, \"1/2\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 1 );\n        }\n        else if( !strcmp( psz_tmp, \"1/4\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 2 );\n        }\n        else if( !strcmp( psz_tmp, \"1/8\" ) ) {\n            schro_encoder_setting_set_double( p_sys->p_schro, \"mv_precision\", 3 );\n        }\n        else {\n            msg_Err( p_enc, \"Invalid mv_precision: %s\", psz_tmp );\n            free( psz_tmp );\n            goto error;\n        }\n    }\n    free( psz_tmp );\n\n    SCHRO_SET_INTEGER(ENC_ME_COMBINED, \"enable_chroma_me\", -1)\n\n    SCHRO_SET_ENUM(enc_wavelet_list, ENC_DWTINTRA, ENC_DWTINTRA_TEXT, \"intra_wavelet\")\n\n    SCHRO_SET_ENUM(enc_wavelet_list, ENC_DWTINTER, ENC_DWTINTER_TEXT, \"inter_wavelet\")\n\n    SCHRO_SET_INTEGER(ENC_DWTDEPTH, \"transform_depth\", -1)\n\n    SCHRO_SET_INTEGER(ENC_MULTIQUANT, \"enable_multiquant\", -1)\n\n    SCHRO_SET_INTEGER(ENC_NOAC, \"enable_noarith\", -1)\n\n    SCHRO_SET_ENUM(enc_perceptual_weighting_list, ENC_PWT, ENC_PWT_TEXT, \"perceptual_weighting\")\n\n    SCHRO_SET_FLOAT(ENC_PDIST, \"perceptual_distance\")\n\n    SCHRO_SET_INTEGER(ENC_HSLICES, \"horiz_slices\", -1)\n\n    SCHRO_SET_INTEGER(ENC_VSLICES, \"vert_slices\", -1)\n\n    SCHRO_SET_ENUM(enc_codeblock_size_list, ENC_SCBLK_SIZE, ENC_SCBLK_SIZE_TEXT, \"codeblock_size\")\n\n    SCHRO_SET_INTEGER(ENC_ME_HIERARCHICAL, \"enable_hierarchical_estimation\", -1)\n\n    SCHRO_SET_INTEGER(ENC_ME_DOWNSAMPLE_LEVELS, \"downsample_levels\", 1)\n\n    SCHRO_SET_INTEGER(ENC_ME_GLOBAL_MOTION, \"enable_global_motion\", -1)\n\n    SCHRO_SET_INTEGER(ENC_ME_PHASECORR, \"enable_phasecorr_estimation\", -1)\n\n    SCHRO_SET_INTEGER(ENC_SCD, \"enable_scene_change_detection\", -1)\n\n    SCHRO_SET_ENUM(enc_profile_list, ENC_FORCE_PROFILE, ENC_FORCE_PROFILE_TEXT, \"force_profile\")\n\n    p_sys->started = 0;\n\n    return VLC_SUCCESS;\nerror:\n    CloseEncoder( p_this );\n    return VLC_EGENERIC;\n}\n\n\nstruct enc_picture_free_t\n{\n   picture_t *p_pic;\n   encoder_t *p_enc;\n};\n\n/*****************************************************************************\n * EncSchroFrameFree: schro_frame callback to release the associated picture_t\n * When schro_encoder_reset() is called there will be pictures in the\n * encoding pipeline that need to be released rather than displayed.\n *****************************************************************************/\nstatic void EncSchroFrameFree( SchroFrame *frame, void *priv )\n{\n    struct enc_picture_free_t *p_free = priv;\n\n    if( !p_free )\n        return;\n\n    picture_Release( p_free->p_pic );\n    free( p_free );\n    (void)frame;\n}\n\n/*****************************************************************************\n * CreateSchroFrameFromPic: wrap a picture_t in a SchroFrame\n *****************************************************************************/\nstatic SchroFrame *CreateSchroFrameFromInputPic( encoder_t *p_enc,  picture_t *p_pic )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    SchroFrame *p_schroframe = schro_frame_new();\n    struct enc_picture_free_t *p_free;\n\n    if( !p_schroframe )\n        return NULL;\n\n    if( !p_pic )\n        return NULL;\n\n    p_schroframe->format = SCHRO_FRAME_FORMAT_U8_420;\n    if( p_sys->p_format->chroma_format == SCHRO_CHROMA_422 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_422;\n    }\n    else if( p_sys->p_format->chroma_format == SCHRO_CHROMA_444 )\n    {\n        p_schroframe->format = SCHRO_FRAME_FORMAT_U8_444;\n    }\n\n    p_schroframe->width  = p_sys->p_format->width;\n    p_schroframe->height = p_sys->p_format->height;\n\n    p_free = malloc( sizeof( *p_free ) );\n    if( unlikely( p_free == NULL ) ) {\n        schro_frame_unref( p_schroframe );\n        return NULL;\n    }\n\n    p_free->p_pic = p_pic;\n    p_free->p_enc = p_enc;\n    schro_frame_set_free_callback( p_schroframe, EncSchroFrameFree, p_free );\n\n    for( int i=0; i<3; i++ )\n    {\n        p_schroframe->components[i].width  = p_pic->p[i].i_visible_pitch;\n        p_schroframe->components[i].stride = p_pic->p[i].i_pitch;\n        p_schroframe->components[i].height = p_pic->p[i].i_visible_lines;\n        p_schroframe->components[i].length =\n            p_pic->p[i].i_pitch * p_pic->p[i].i_lines;\n        p_schroframe->components[i].data   = p_pic->p[i].p_pixels;\n\n        if( i!=0 )\n        {\n            p_schroframe->components[i].v_shift =\n                SCHRO_FRAME_FORMAT_V_SHIFT( p_schroframe->format );\n            p_schroframe->components[i].h_shift =\n                SCHRO_FRAME_FORMAT_H_SHIFT( p_schroframe->format );\n        }\n    }\n\n    return p_schroframe;\n}\n\n/* Attempt to find dirac picture number in an encapsulation unit */\nstatic int ReadDiracPictureNumber( uint32_t *p_picnum, block_t *p_block )\n{\n    uint32_t u_pos = 4;\n    /* protect against falling off the edge */\n    while( u_pos + 13 < p_block->i_buffer )\n    {\n        /* find the picture startcode */\n        if( p_block->p_buffer[u_pos] & 0x08 )\n        {\n            *p_picnum = GetDWBE( p_block->p_buffer + u_pos + 9 );\n            return 1;\n        }\n        /* skip to the next dirac data unit */\n        uint32_t u_npo = GetDWBE( p_block->p_buffer + u_pos + 1 );\n        assert( u_npo <= UINT32_MAX - u_pos );\n        if( u_npo == 0 )\n            u_npo = 13;\n        u_pos += u_npo;\n    }\n    return 0;\n}\n\n\nstatic block_t *Encode( encoder_t *p_enc, picture_t *p_pic )\n{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    block_t *p_block, *p_output_chain = NULL;\n    SchroFrame *p_frame;\n    bool b_go = true;\n\n    if( !p_pic ) {\n        if( !p_sys->started || p_sys->b_eos_pulled )\n            return NULL;\n\n        if( !p_sys->b_eos_signalled ) {\n            p_sys->b_eos_signalled = 1;\n            schro_encoder_end_of_stream( p_sys->p_schro );\n        }\n    } else {\n        /* we only know if the sequence is interlaced when the first\n         * picture arrives, so final setup is done here */\n        /* XXX todo, detect change of interlace */\n        p_sys->p_format->interlaced = !p_pic->b_progressive;\n        p_sys->p_format->top_field_first = p_pic->b_top_field_first;\n\n        if( p_sys->b_auto_field_coding )\n            schro_encoder_setting_set_double( p_sys->p_schro, \"interlaced_coding\", !p_pic->b_progressive );\n    }\n\n    if( !p_sys->started ) {\n        date_t date;\n\n        if( p_pic->format.i_chroma != p_enc->fmt_in.i_codec ) {\n            char chroma_in[5], chroma_out[5];\n            vlc_fourcc_to_char( p_pic->format.i_chroma, chroma_in );\n            chroma_in[4]  = '\\0';\n            chroma_out[4] = '\\0';\n            vlc_fourcc_to_char( p_enc->fmt_in.i_codec, chroma_out );\n            msg_Warn( p_enc, \"Resetting chroma from %s to %s\", chroma_out, chroma_in );\n            if( !SetEncChromaFormat( p_enc, p_pic->format.i_chroma ) ) {\n                msg_Err( p_enc, \"Could not reset chroma format to %s\", chroma_in );\n                return NULL;\n            }\n        }\n\n        date_Init( &date, p_enc->fmt_in.video.i_frame_rate, p_enc->fmt_in.video.i_frame_rate_base );\n        /* FIXME - Unlike dirac-research codec Schro doesn't have a function that returns the delay in pics yet.\n         *   Use a default of 1\n         */\n        date_Increment( &date, 1 );\n        p_sys->i_pts_offset = date_Get( &date );\n        if( schro_encoder_setting_get_double( p_sys->p_schro, \"interlaced_coding\" ) > 0.0 ) {\n            date_Set( &date, 0 );\n            date_Increment( &date, 1);\n            p_sys->i_field_time = date_Get( &date ) / 2;\n        }\n\n        schro_video_format_set_std_signal_range( p_sys->p_format, SCHRO_SIGNAL_RANGE_8BIT_VIDEO );\n        schro_encoder_set_video_format( p_sys->p_schro, p_sys->p_format );\n        schro_encoder_start( p_sys->p_schro );\n        p_sys->started = 1;\n    }\n\n    if( !p_sys->b_eos_signalled ) {\n        /* create a schro frame from the input pic and load */\n        /* Increase ref count by 1 so that the picture is not freed until\n           Schro finishes with it */\n        picture_Hold( p_pic );\n\n        p_frame = CreateSchroFrameFromInputPic( p_enc, p_pic );\n        if( !p_frame )\n            return NULL;\n        schro_encoder_push_frame( p_sys->p_schro, p_frame );\n\n\n        /* store pts in a lookaside buffer, so that the same pts may\n        * be used for the picture in coded order */\n        StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date );\n        p_sys->i_input_picnum++;\n\n        /* store dts in a queue, so that they appear in order in\n         * coded order */\n        p_block = block_Alloc( 1 );\n        if( !p_block )\n            return NULL;\n        p_block->i_dts = p_pic->date - p_sys->i_pts_offset;\n        block_FifoPut( p_sys->p_dts_fifo, p_block );\n        p_block = NULL;\n\n        /* for field coding mode, insert an extra value into both the\n         * pts lookaside buffer and dts queue, offset to correspond\n         * to a one field delay. */\n        if( schro_encoder_setting_get_double( p_sys->p_schro, \"interlaced_coding\" ) > 0.0 ) {\n            StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date + p_sys->i_field_time );\n            p_sys->i_input_picnum++;\n\n            p_block = block_Alloc( 1 );\n            if( !p_block )\n                return NULL;\n            p_block->i_dts = p_pic->date - p_sys->i_pts_offset + p_sys->i_field_time;\n            block_FifoPut( p_sys->p_dts_fifo, p_block );\n            p_block = NULL;\n        }\n    }\n\n    do\n    {\n        SchroStateEnum state;\n        state = schro_encoder_wait( p_sys->p_schro );\n        switch( state )\n        {\n        case SCHRO_STATE_NEED_FRAME:\n            b_go = false;\n            break;\n        case SCHRO_STATE_AGAIN:\n            break;\n        case SCHRO_STATE_END_OF_STREAM:\n            p_sys->b_eos_pulled = 1;\n            b_go = false;\n            break;\n        case SCHRO_STATE_HAVE_BUFFER:\n        {\n            SchroBuffer *p_enc_buf;\n            uint32_t u_pic_num;\n            int i_presentation_frame;\n            p_enc_buf = schro_encoder_pull( p_sys->p_schro, &i_presentation_frame );\n            p_block = block_Alloc( p_enc_buf->length );\n            if( !p_block )\n                return NULL;\n\n            memcpy( p_block->p_buffer, p_enc_buf->data, p_enc_buf->length );\n            schro_buffer_unref( p_enc_buf );\n\n            /* Presence of a Sequence header indicates a seek point */\n            if( 0 == p_block->p_buffer[4] )\n            {\n                p_block->i_flags |= BLOCK_FLAG_TYPE_I;\n\n                if( !p_enc->fmt_out.p_extra ) {\n                    const uint8_t eos[] = { 'B','B','C','D',0x10,0,0,0,13,0,0,0,0 };\n                    uint32_t len = GetDWBE( p_block->p_buffer + 5 );\n                    /* if it hasn't been done so far, stash a copy of the\n                     * sequence header for muxers such as ogg */\n                    /* The OggDirac spec advises that a Dirac EOS DataUnit\n                     * is appended to the sequence header to allow guard\n                     * against poor streaming servers */\n                    /* XXX, should this be done using the packetizer ? */\n\n                    if( len > UINT32_MAX - sizeof( eos ) )\n                        return NULL;\n\n                    p_enc->fmt_out.p_extra = malloc( len + sizeof( eos ) );\n                    if( !p_enc->fmt_out.p_extra )\n                        return NULL;\n                    memcpy( p_enc->fmt_out.p_extra, p_block->p_buffer, len );\n                    memcpy( (uint8_t*)p_enc->fmt_out.p_extra + len, eos, sizeof( eos ) );\n                    SetDWBE( (uint8_t*)p_enc->fmt_out.p_extra + len + sizeof(eos) - 4, len );\n                    p_enc->fmt_out.i_extra = len + sizeof( eos );\n                }\n            }\n\n            if( ReadDiracPictureNumber( &u_pic_num, p_block ) ) {\n                block_t *p_dts_block = block_FifoGet( p_sys->p_dts_fifo );\n                p_block->i_dts = p_dts_block->i_dts;\n                   p_block->i_pts = GetPicturePTS( p_enc, u_pic_num );\n                block_Release( p_dts_block );\n                block_ChainAppend( &p_output_chain, p_block );\n            } else {\n                /* End of sequence */\n                block_ChainAppend( &p_output_chain, p_block );\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    } while( b_go );\n\n    return p_output_chain;\n}\n\n/*****************************************************************************\n * CloseEncoder: Schro encoder destruction\n *****************************************************************************/\nstatic void CloseEncoder( vlc_object_t *p_this )\n{\n    encoder_t *p_enc = (encoder_t *)p_this;\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    /* Free the encoder resources */\n    if( p_sys->p_schro )\n        schro_encoder_free( p_sys->p_schro );\n\n    free( p_sys->p_format );\n\n    if( p_sys->p_dts_fifo )\n        block_FifoRelease( p_sys->p_dts_fifo );\n\n    block_ChainRelease( p_sys->p_chain );\n\n    free( p_sys );\n}\n"], "filenames": ["modules/codec/schroedinger.c"], "buggy_code_start_loc": [1550], "buggy_code_end_loc": [1550], "fixing_code_start_loc": [1551], "fixing_code_end_loc": [1555], "type": "CWE-120", "message": "Integer overflow in the Encode function in modules/codec/schroedinger.c in VideoLAN VLC media player before 2.1.6 and 2.2.x before 2.2.1 allows remote attackers to conduct buffer overflow attacks and execute arbitrary code via a crafted length value.", "other": {"cve": {"id": "CVE-2014-9629", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-24T22:15:12.597", "lastModified": "2020-01-29T16:43:08.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow in the Encode function in modules/codec/schroedinger.c in VideoLAN VLC media player before 2.1.6 and 2.2.x before 2.2.1 allows remote attackers to conduct buffer overflow attacks and execute arbitrary code via a crafted length value."}, {"lang": "es", "value": "Un desbordamiento de enteros en la funci\u00f3n Encode en el archivo modules/codec/schroedinger.c en el reproductor multimedia VLC de VideoLAN versiones anteriores a 2.1.6 y versiones 2.2.x anteriores a 2.2.1, permite a atacantes remotos llevar a cabo ataques de desbordamiento de b\u00fafer y ejecutar c\u00f3digo arbitrario por medio de un valor de longitud dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:videolan:vlc_media_player:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.6", "matchCriteriaId": "6E9B8F06-93FB-4A2B-B550-A30BD8F1C5D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:videolan:vlc_media_player:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.1", "matchCriteriaId": "98F1290A-93D8-442E-BD60-6B7E25A21DB0"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2015/01/20/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/videolan/vlc/commit/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.videolan.org/security/sa1501.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/videolan/vlc/commit/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5"}}