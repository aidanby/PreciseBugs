{"buggy_code": ["#!/usr/bin/env python3\n\n# Copyright (c) Facebook, Inc. and its affiliates.\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport json\nimport os\nimport pickle\nimport random\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom threading import Semaphore, Condition\nfrom typing import Any, Dict, List, Optional, TYPE_CHECKING\n\nimport numpy as np\nimport torch\nimport yaml\nfrom mephisto.operations.registry import register_mephisto_abstraction\nfrom mephisto.abstractions.blueprint import SharedTaskState\nfrom mephisto.abstractions.blueprints.parlai_chat.parlai_chat_blueprint import (\n    ParlAIChatBlueprint,\n    SharedParlAITaskState,\n    ParlAIChatBlueprintArgs,\n)\nfrom omegaconf import DictConfig, MISSING\n\nfrom parlai.crowdsourcing.tasks.model_chat.bot_agent import TurkLikeAgent\nfrom parlai.crowdsourcing.tasks.model_chat.utils import (\n    ImageStack,\n    get_context_generator,\n)\nfrom parlai.tasks.blended_skill_talk.agents import ContextGenerator\n\nif TYPE_CHECKING:\n    from mephisto.data_model.task import TaskRun\n\n\ndef get_task_path():\n    return os.path.dirname(os.path.realpath(__file__))\n\n\nBLUEPRINT_TYPE = 'model_chat_blueprint'\nIMAGE_CHAT_BLUEPRINT_TYPE = 'model_image_chat_blueprint'\n\n\n@dataclass\nclass SharedBaseModelChatTaskState(SharedParlAITaskState):\n    \"\"\"\n    Base shared-state class from which all model-chat tasks inherit.\n    \"\"\"\n\n    shared_models: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass\nclass SharedModelChatTaskState(SharedBaseModelChatTaskState):\n    context_generator: Optional[ContextGenerator] = None\n    conversations_needed: Dict[str, Any] = field(default_factory=dict)\n    run_statistics: Dict[str, int] = field(default_factory=dict)\n    onboard_statistics: Dict[str, int] = field(default_factory=dict)\n    statistics_condition: Optional[Condition] = None\n\n\n@dataclass\nclass SharedModelImageChatTaskState(SharedBaseModelChatTaskState):\n    image_contexts: List[Dict[str, Any]] = None\n    image_stack: ImageStack = None\n\n\n@dataclass\nclass BaseModelChatBlueprintArgs(ParlAIChatBlueprintArgs):\n    _group: str = field(\n        default=\"BaseModelChatBlueprint\",\n        metadata={'help': \"Args that are common to all model-chat tasks\"},\n    )\n    custom_source_dir: str = field(\n        default=os.path.join(get_task_path(), 'frontend'),\n        metadata={\"help\": \"Path to frontend code\"},\n    )\n    num_turns: int = field(default=6, metadata={\"help\": 'minimum number of turns'})\n    random_seed: int = field(\n        default=42, metadata={\"help\": 'Seed for random operations'}\n    )\n    annotation_question: str = field(\n        default='Does this comment require any annotations? (Check all that apply)',\n        metadata={\n            \"help\": \"The string displayed above the checkboxes for each annotation in the task.\"\n        },\n    )\n    model_opt_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/model_opts.yaml\",\n        metadata={\"help\": \"Path to YAML of opts for each model\"},\n    )\n    task_model_parallel: bool = field(\n        default=True,\n        metadata={\n            \"help\": 'Whether to load models to be used with model_parallel True.'\n        },\n    )\n    max_resp_time: int = field(\n        default=180, metadata={\"help\": \"time limit for entering a dialog message\"}\n    )\n    chat_data_folder: str = field(\n        default=MISSING,\n        metadata={\"help\": \"Folder in which to save collected conversation data\"},\n    )\n    check_acceptability: bool = field(\n        default=False,\n        metadata={\n            \"help\": \"Check worker's responses against several metrics of acceptability\"\n        },\n    )\n    context_seed: int = field(\n        default=MISSING,\n        metadata={\"help\": \"Set seed for pulling the context info (for testing)\"},\n    )\n    task_config_path: str = field(\n        default=os.path.join(get_task_path(), 'task_config'),\n        metadata={\"help\": \"Base path to pull task configuration information\"},\n    )\n    task_description_file: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/task_description.html\",\n        metadata={\"help\": \"Path to file of HTML to show on the task-description page\"},\n    )\n    left_pane_text_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/left_pane_text.html\",\n        metadata={\n            \"help\": \"Path to file of HTML to show on the left-hand pane of the chat window\"\n        },\n    )\n    annotations_config_path: str = field(\n        default=\"\",\n        metadata={\n            \"help\": 'Path to JSON of annotation categories. Set to \"\" to disable annotations'\n        },\n    )\n    final_rating_question: str = field(\n        default='Please rate your partner on a scale of 1-5.',\n        metadata={\"help\": \"Text to show when asking worker to make their final rating\"},\n    )\n    max_concurrent_responses: int = field(\n        default=1,\n        metadata={\"help\": \"Limit on the number of models that can generate at once\"},\n    )\n    override_opt: Dict[str, Any] = field(\n        default_factory=dict,\n        metadata={\n            \"help\": \"Additional args to pass to initialize the context generator \"\n            \"in order to override the parlai parser defaults.\"\n        },\n    )\n\n\nclass BaseModelChatBlueprint(ParlAIChatBlueprint, ABC):\n    \"\"\"\n    This Blueprint uses somewhat specialized arguments for turn annotations, manages\n    their validation, and also has specialized data storage for the result format.\n\n    It also has options for the onboarding data answers and the annotation bucket\n    definitions.\n    \"\"\"\n\n    ArgsClass = BaseModelChatBlueprintArgs\n    SharedStateClass = SharedBaseModelChatTaskState\n\n    @classmethod\n    def assert_task_args(\n        cls, args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ) -> None:\n        \"\"\"\n        Ensure that arguments are properly configured to launch this task.\n        \"\"\"\n        super().assert_task_args(args, shared_state)\n        assert (\n            args.blueprint.get(\"task_description_file\", None) is not None\n        ), \"Must provide a task description file\"\n        full_path = os.path.expanduser(args.blueprint.task_description_file)\n        assert os.path.exists(\n            full_path\n        ), f\"Target task description path {full_path} doesn't exist\"\n\n        assert (\n            args.blueprint.get(\"left_pane_text_path\", None) is not None\n        ), \"Must provide a left pane text file\"\n        full_path = os.path.expanduser(args.blueprint.left_pane_text_path)\n        assert os.path.exists(\n            full_path\n        ), f\"Target left pane text path {full_path} doesn't exist\"\n\n        if args.blueprint.get(\"chat_data_folder\") == '':\n            raise ValueError('Must provide a valid chat data folder')\n        assert '~' not in args.blueprint.chat_data_folder, (\n            f'\"~\" can\\'t currently be parsed in the chat data folder path '\n            f'{args.blueprint.chat_data_folder}'\n        )\n        # TODO: allow ~ to be parsed correctly\n\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            full_path = os.path.expanduser(args.blueprint.annotations_config_path)\n            assert os.path.exists(\n                full_path\n            ), f\"Target annotation config path {full_path} doesn't exist\"\n\n    def __init__(\n        self, task_run: \"TaskRun\", args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ):\n\n        # Default conversation initialization\n        super().__init__(task_run, args=args, shared_state=shared_state)\n        random.seed(self.args.blueprint.random_seed)\n        np.random.seed(self.args.blueprint.random_seed)\n        torch.manual_seed(self.args.blueprint.random_seed)\n\n        # Load task configuration data beyond the task description, as the super does\n        # that\n        left_pane_path = os.path.expanduser(args.blueprint.left_pane_text_path)\n        with open(left_pane_path, \"r\") as left_pane_file:\n            self.left_pane_text = left_pane_file.read()\n        self.annotations_config: Optional[str] = None\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            annotations_config_path = os.path.expanduser(\n                args.blueprint.annotations_config_path\n            )\n            with open(annotations_config_path, \"r\") as annotations_config_file:\n                self.annotations_config = annotations_config_file.read()\n\n        # Initialize models\n        shared_state.shared_models = self._get_shared_models(args)\n\n        # Limits the number of models that can generate at once\n        semaphore = Semaphore(args.blueprint.max_concurrent_responses)\n\n        # Move shared state into the world opt, so that it can be used by the world\n        shared_state.onboarding_world_opt.update(\n            {'skip_onboarding': self.annotations_config is None}\n        )\n        # The onboarding checks how well workers annotate conversations, so it should be\n        # skipped if we are not annotating\n        shared_state.world_opt.update(\n            {\n                'block_qualification': args.blueprint.block_qualification,\n                'annotations_config': self.annotations_config,\n                'semaphore': semaphore,\n                'shared_bot_agents': shared_state.shared_models,\n                'num_turns': args.blueprint.num_turns,\n                'max_resp_time': args.blueprint.max_resp_time,\n                'is_sandbox': args.provider.requester_name == 'MOCK_REQUESTER',\n                'check_acceptability': args.blueprint.check_acceptability,\n                'chat_data_folder': args.blueprint.chat_data_folder,\n            }\n        )\n\n    @abstractmethod\n    def _get_shared_models(self, args: \"DictConfig\") -> Dict[str, dict]:\n        \"\"\"\n        Return a dictionary whose values are the shared models.\n        \"\"\"\n\n    def get_frontend_args(self) -> Dict[str, Any]:\n        \"\"\"\n        Specifies what options within a task_config should be forwarded to the client\n        for use by the task's frontend.\n        \"\"\"\n        if self.args.blueprint.get('annotations_config_path', '') != '':\n            with open(\n                self.args.blueprint.annotations_config_path, \"r\", encoding=\"utf-8-sig\"\n            ) as f:\n                annotation_buckets = json.loads(f.read())\n        else:\n            annotation_buckets = None\n\n        return {\n            \"min_num_turns\": self.args.blueprint.num_turns,\n            \"task_description\": self.full_task_description,\n            \"task_title\": self.args.task.get('task_title', None),\n            \"annotation_question\": self.args.blueprint.annotation_question,\n            \"annotation_buckets\": annotation_buckets,\n            \"onboarding_data\": getattr(self, 'onboard_task_data', None),\n            \"left_pane_text\": self.left_pane_text,\n            \"frame_height\": '650px',\n            \"final_rating_question\": self.args.blueprint.final_rating_question,\n            \"block_mobile\": True,\n        }\n\n\n@dataclass\nclass ModelChatBlueprintArgs(BaseModelChatBlueprintArgs):\n    _blueprint_type: str = BLUEPRINT_TYPE\n    _group: str = field(\n        default=\"ModelChatBlueprint\",\n        metadata={\n            'help': \"This task runs conversations between a human and one of a set of \"\n            \"provided models, asking workers to evaluate individual turns and \"\n            \"the overall model quality.\"\n        },\n    )\n    conversation_start_mode: str = field(\n        default='hi',\n        metadata={\n            \"help\": 'Whether to show \"Hi!\" or two previous utterances (as in BlendedSkillTalk) at the beginning of the conversation',\n            \"choices\": ['hi', 'bst'],\n        },\n    )\n    include_persona: bool = field(\n        default=False, metadata={\"help\": \"Show persona to the bot\"}\n    )\n    conversations_needed_string: str = field(\n        default=MISSING,\n        metadata={\n            \"help\": 'Number of convos needed for each model. For example: \"modelA:50,modelB:20\"'\n        },\n    )\n    max_onboard_time: int = field(\n        default=300, metadata={\"help\": \"time limit accepting onboarding\"}\n    )\n    onboard_task_data_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/onboard_task_data.json\",\n        metadata={\n            \"help\": \"Path to JSON containing settings for running onboarding. Not used if not annotating model responses\"\n        },\n    )\n    world_file: str = field(\n        default=os.path.join(get_task_path(), 'worlds.py'),\n        metadata={\"help\": \"Path to file containing parlai world\"},\n    )\n\n\n@register_mephisto_abstraction()\nclass ModelChatBlueprint(BaseModelChatBlueprint):\n    \"\"\"\n    Blueprint for model chat without images.\n\n    This blueprint subclasses BaseModelChatBlueprint to provide logic for keeping track\n    of how many more conversations are needed per model; this logic is not shared with\n    other model-chat blueprints.\n    \"\"\"\n\n    ArgsClass = ModelChatBlueprintArgs\n    SharedStateClass = SharedModelChatTaskState\n    BLUEPRINT_TYPE = BLUEPRINT_TYPE\n\n    @classmethod\n    def assert_task_args(\n        cls, args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ) -> None:\n        \"\"\"\n        Ensure that arguments are properly configured to launch this task.\n        \"\"\"\n\n        if (\n            not isinstance(shared_state.conversations_needed, dict)\n            or len(shared_state.conversations_needed) == 0\n        ):\n            assert (\n                args.blueprint.get('conversations_needed_string', None) is not None\n            ), (\n                \"Must provide a string of needed conversations per model if not providing \"\n                \"a conversations needed dict\"\n            )\n            try:\n                conversations_needed = {}\n                parts = args.blueprint.conversations_needed_string.split(',')\n                for part in parts:\n                    model_name, num_string = part.split(':')\n                    conversations_needed[model_name] = int(num_string)\n            except Exception as e:\n                raise Exception(\n                    \"Could not create conversations needed dict from given string. \"\n                    f\"Error was {e}.\\n\"\n                    \"Be sure the format is like modelA:50,modelB:20\"\n                )\n        else:\n            conversations_needed = shared_state.conversations_needed\n        args.blueprint.num_conversations = sum(conversations_needed.values())\n        super().assert_task_args(args=args, shared_state=shared_state)\n\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            # We are going to do annotations, so check for the presence of an onboarding\n            # data file that will be used to onboard users into knowing how to do the\n            # annotations properly\n            assert (\n                args.blueprint.get(\"onboard_task_data_path\", None) is not None\n            ), \"Must provide an onboarding data file\"\n            full_path = os.path.expanduser(args.blueprint.onboard_task_data_path)\n            assert os.path.exists(\n                full_path\n            ), f\"Target onboarding data path {full_path} doesn't exist\"\n\n    def __init__(\n        self, task_run: \"TaskRun\", args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ):\n\n        # Set the number of conversations needed\n        conversations_needed_string = args.blueprint.conversations_needed_string\n        conversations_needed = {}\n        parts = conversations_needed_string.split(',')\n        for part in parts:\n            model_name, num_string = part.split(':')\n            conversations_needed[model_name] = int(num_string)\n        self.conversations_needed = conversations_needed\n        shared_state.conversations_needed = conversations_needed\n        args.blueprint.num_conversations = sum(conversations_needed.values())\n\n        super().__init__(task_run=task_run, args=args, shared_state=shared_state)\n\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            # We are going to do annotations, so load the onboarding data file that will\n            # be used to onboard users into knowing how to do the annotations properly\n            onboard_task_data_path = os.path.expanduser(\n                args.blueprint.onboard_task_data_path\n            )\n            with open(onboard_task_data_path, \"r\") as onboard_task_data_file:\n                self.onboard_task_data = json.load(onboard_task_data_file)\n        else:\n            self.onboard_task_data = None\n\n        run_statistics = {r: 0 for (r, v) in self.conversations_needed.items()}\n        shared_state.run_statistics = run_statistics\n\n        context_generator: Optional[ContextGenerator] = None\n        if (\n            args.blueprint.include_persona\n            or args.blueprint.conversation_start_mode == 'bst'\n        ):\n            context_generator = get_context_generator(args.blueprint.override_opt)\n        shared_state.context_generator = context_generator\n\n        # Lock for editing run statistics between threads\n        statistics_condition = Condition()\n\n        # Move shared state into the world and onboarding opts, such that these\n        # can be used by the worlds\n        shared_state.onboarding_world_opt.update(\n            {\n                'onboard_statistics': shared_state.onboard_statistics,\n                'statistics_condition': statistics_condition,\n                'max_onboard_time': args.blueprint.max_onboard_time,\n                'onboard_task_data': self.onboard_task_data,\n                'onboarding_qualification': args.blueprint.onboarding_qualification,\n            }\n        )\n        shared_state.world_opt.update(\n            {\n                'conversations_needed': conversations_needed,\n                'run_statistics': shared_state.run_statistics,\n                'context_generator': context_generator,\n                'statistics_condition': statistics_condition,\n                'conversation_start_mode': args.blueprint.conversation_start_mode,\n                'include_persona': args.blueprint.include_persona,\n            }\n        )\n\n    def _get_shared_models(self, args: \"DictConfig\") -> Dict[str, dict]:\n        with open(args.blueprint.model_opt_path) as f:\n            all_model_opts = yaml.load(f.read())\n        active_model_opts = {\n            model: opt\n            for model, opt in all_model_opts.items()\n            if self.conversations_needed[model] > 0\n        }\n        return TurkLikeAgent.get_bot_agents(args=args, model_opts=active_model_opts)\n\n\n@dataclass\nclass ModelImageChatBlueprintArgs(BaseModelChatBlueprintArgs):\n    _blueprint_type: str = IMAGE_CHAT_BLUEPRINT_TYPE\n    _group: str = field(\n        default=\"ModelImageChatBlueprint\",\n        metadata={\n            'help': \"This task runs conversations between a human and one of a set of \"\n            \"provided models, asking workers chat about a provided image.\"\n        },\n    )\n    evals_per_image_model_combo: int = field(\n        default=1,\n        metadata={\n            \"help\": \"The number of HITs to perform per combination of image and model\"\n        },\n    )\n    image_context_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/image_contexts\",\n        metadata={\n            \"help\": \"Path to pickle file containing images and the context information that goes with each one\"\n        },\n    )\n    num_conversations: int = field(\n        default=10, metadata={'help': 'The number of conversations to collect'}\n    )\n    stack_folder: str = field(\n        default=os.path.join(get_task_path(), 'image_stack'),\n        metadata={\n            \"help\": 'Folder in which to save backups of the stack of which image-and-model combinations have had HITs launched'\n        },\n    )\n    world_file: str = field(\n        default=os.path.join(get_task_path(), 'worlds_image_chat.py'),\n        metadata={\"help\": \"Path to file containing ParlAI world for image chat\"},\n    )\n\n\n@register_mephisto_abstraction()\nclass ModelImageChatBlueprint(BaseModelChatBlueprint):\n    \"\"\"\n    Subclass of BaseModelChatBlueprint to show the speakers an image on the first turn.\n\n    The image is drawn from a stack that keeps track of how many HITs have been launched\n    for a given combination of image and model.\n    \"\"\"\n\n    ArgsClass = ModelImageChatBlueprintArgs\n    SharedStateClass = SharedModelImageChatTaskState\n    BLUEPRINT_TYPE = IMAGE_CHAT_BLUEPRINT_TYPE\n\n    @classmethod\n    def assert_task_args(\n        cls, args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ) -> None:\n        \"\"\"\n        Ensure that arguments are properly configured to launch this task.\n        \"\"\"\n        super().assert_task_args(args=args, shared_state=shared_state)\n        image_context_path = os.path.expanduser(args.blueprint.image_context_path)\n        assert os.path.exists(\n            image_context_path\n        ), f\"The image context path {image_context_path} doesn't exist!\"\n        model_opt_path = os.path.expanduser(args.blueprint.model_opt_path)\n        assert os.path.exists(\n            model_opt_path\n        ), f\"The model opt path {model_opt_path} doesn't exist!\"\n\n    def __init__(\n        self, task_run: \"TaskRun\", args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ):\n\n        super().__init__(task_run=task_run, args=args, shared_state=shared_state)\n\n        with open(args.blueprint.image_context_path, 'rb') as f:\n            shared_state.image_contexts = pickle.load(f)\n\n        # Create the stack to keep track of how many workers have seen which\n        # combinations of images and models\n        image_opt = {\n            'evals_per_image_model_combo': args.blueprint.evals_per_image_model_combo,\n            'num_images': len(shared_state.image_contexts),\n            'models': list(shared_state.shared_models.keys()),\n            'stack_folder': args.blueprint.stack_folder,\n        }\n        shared_state.image_stack = ImageStack(image_opt)\n\n        shared_state.world_opt.update(\n            {\n                'image_contexts': shared_state.image_contexts,\n                'image_stack': shared_state.image_stack,\n            }\n        )\n\n    def _get_shared_models(self, args: \"DictConfig\") -> Dict[str, dict]:\n        with open(args.blueprint.model_opt_path) as f:\n            model_opts = yaml.load(f.read())\n        return TurkLikeAgent.get_bot_agents(args=args, model_opts=model_opts)\n"], "fixing_code": ["#!/usr/bin/env python3\n\n# Copyright (c) Facebook, Inc. and its affiliates.\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport json\nimport os\nimport pickle\nimport random\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom threading import Semaphore, Condition\nfrom typing import Any, Dict, List, Optional, TYPE_CHECKING\n\nimport numpy as np\nimport torch\nimport yaml\nfrom mephisto.operations.registry import register_mephisto_abstraction\nfrom mephisto.abstractions.blueprint import SharedTaskState\nfrom mephisto.abstractions.blueprints.parlai_chat.parlai_chat_blueprint import (\n    ParlAIChatBlueprint,\n    SharedParlAITaskState,\n    ParlAIChatBlueprintArgs,\n)\nfrom omegaconf import DictConfig, MISSING\n\nfrom parlai.crowdsourcing.tasks.model_chat.bot_agent import TurkLikeAgent\nfrom parlai.crowdsourcing.tasks.model_chat.utils import (\n    ImageStack,\n    get_context_generator,\n)\nfrom parlai.tasks.blended_skill_talk.agents import ContextGenerator\n\nif TYPE_CHECKING:\n    from mephisto.data_model.task import TaskRun\n\n\ndef get_task_path():\n    return os.path.dirname(os.path.realpath(__file__))\n\n\nBLUEPRINT_TYPE = 'model_chat_blueprint'\nIMAGE_CHAT_BLUEPRINT_TYPE = 'model_image_chat_blueprint'\n\n\n@dataclass\nclass SharedBaseModelChatTaskState(SharedParlAITaskState):\n    \"\"\"\n    Base shared-state class from which all model-chat tasks inherit.\n    \"\"\"\n\n    shared_models: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass\nclass SharedModelChatTaskState(SharedBaseModelChatTaskState):\n    context_generator: Optional[ContextGenerator] = None\n    conversations_needed: Dict[str, Any] = field(default_factory=dict)\n    run_statistics: Dict[str, int] = field(default_factory=dict)\n    onboard_statistics: Dict[str, int] = field(default_factory=dict)\n    statistics_condition: Optional[Condition] = None\n\n\n@dataclass\nclass SharedModelImageChatTaskState(SharedBaseModelChatTaskState):\n    image_contexts: List[Dict[str, Any]] = None\n    image_stack: ImageStack = None\n\n\n@dataclass\nclass BaseModelChatBlueprintArgs(ParlAIChatBlueprintArgs):\n    _group: str = field(\n        default=\"BaseModelChatBlueprint\",\n        metadata={'help': \"Args that are common to all model-chat tasks\"},\n    )\n    custom_source_dir: str = field(\n        default=os.path.join(get_task_path(), 'frontend'),\n        metadata={\"help\": \"Path to frontend code\"},\n    )\n    num_turns: int = field(default=6, metadata={\"help\": 'minimum number of turns'})\n    random_seed: int = field(\n        default=42, metadata={\"help\": 'Seed for random operations'}\n    )\n    annotation_question: str = field(\n        default='Does this comment require any annotations? (Check all that apply)',\n        metadata={\n            \"help\": \"The string displayed above the checkboxes for each annotation in the task.\"\n        },\n    )\n    model_opt_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/model_opts.yaml\",\n        metadata={\"help\": \"Path to YAML of opts for each model\"},\n    )\n    task_model_parallel: bool = field(\n        default=True,\n        metadata={\n            \"help\": 'Whether to load models to be used with model_parallel True.'\n        },\n    )\n    max_resp_time: int = field(\n        default=180, metadata={\"help\": \"time limit for entering a dialog message\"}\n    )\n    chat_data_folder: str = field(\n        default=MISSING,\n        metadata={\"help\": \"Folder in which to save collected conversation data\"},\n    )\n    check_acceptability: bool = field(\n        default=False,\n        metadata={\n            \"help\": \"Check worker's responses against several metrics of acceptability\"\n        },\n    )\n    context_seed: int = field(\n        default=MISSING,\n        metadata={\"help\": \"Set seed for pulling the context info (for testing)\"},\n    )\n    task_config_path: str = field(\n        default=os.path.join(get_task_path(), 'task_config'),\n        metadata={\"help\": \"Base path to pull task configuration information\"},\n    )\n    task_description_file: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/task_description.html\",\n        metadata={\"help\": \"Path to file of HTML to show on the task-description page\"},\n    )\n    left_pane_text_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/left_pane_text.html\",\n        metadata={\n            \"help\": \"Path to file of HTML to show on the left-hand pane of the chat window\"\n        },\n    )\n    annotations_config_path: str = field(\n        default=\"\",\n        metadata={\n            \"help\": 'Path to JSON of annotation categories. Set to \"\" to disable annotations'\n        },\n    )\n    final_rating_question: str = field(\n        default='Please rate your partner on a scale of 1-5.',\n        metadata={\"help\": \"Text to show when asking worker to make their final rating\"},\n    )\n    max_concurrent_responses: int = field(\n        default=1,\n        metadata={\"help\": \"Limit on the number of models that can generate at once\"},\n    )\n    override_opt: Dict[str, Any] = field(\n        default_factory=dict,\n        metadata={\n            \"help\": \"Additional args to pass to initialize the context generator \"\n            \"in order to override the parlai parser defaults.\"\n        },\n    )\n\n\nclass BaseModelChatBlueprint(ParlAIChatBlueprint, ABC):\n    \"\"\"\n    This Blueprint uses somewhat specialized arguments for turn annotations, manages\n    their validation, and also has specialized data storage for the result format.\n\n    It also has options for the onboarding data answers and the annotation bucket\n    definitions.\n    \"\"\"\n\n    ArgsClass = BaseModelChatBlueprintArgs\n    SharedStateClass = SharedBaseModelChatTaskState\n\n    @classmethod\n    def assert_task_args(\n        cls, args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ) -> None:\n        \"\"\"\n        Ensure that arguments are properly configured to launch this task.\n        \"\"\"\n        super().assert_task_args(args, shared_state)\n        assert (\n            args.blueprint.get(\"task_description_file\", None) is not None\n        ), \"Must provide a task description file\"\n        full_path = os.path.expanduser(args.blueprint.task_description_file)\n        assert os.path.exists(\n            full_path\n        ), f\"Target task description path {full_path} doesn't exist\"\n\n        assert (\n            args.blueprint.get(\"left_pane_text_path\", None) is not None\n        ), \"Must provide a left pane text file\"\n        full_path = os.path.expanduser(args.blueprint.left_pane_text_path)\n        assert os.path.exists(\n            full_path\n        ), f\"Target left pane text path {full_path} doesn't exist\"\n\n        if args.blueprint.get(\"chat_data_folder\") == '':\n            raise ValueError('Must provide a valid chat data folder')\n        assert '~' not in args.blueprint.chat_data_folder, (\n            f'\"~\" can\\'t currently be parsed in the chat data folder path '\n            f'{args.blueprint.chat_data_folder}'\n        )\n        # TODO: allow ~ to be parsed correctly\n\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            full_path = os.path.expanduser(args.blueprint.annotations_config_path)\n            assert os.path.exists(\n                full_path\n            ), f\"Target annotation config path {full_path} doesn't exist\"\n\n    def __init__(\n        self, task_run: \"TaskRun\", args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ):\n\n        # Default conversation initialization\n        super().__init__(task_run, args=args, shared_state=shared_state)\n        random.seed(self.args.blueprint.random_seed)\n        np.random.seed(self.args.blueprint.random_seed)\n        torch.manual_seed(self.args.blueprint.random_seed)\n\n        # Load task configuration data beyond the task description, as the super does\n        # that\n        left_pane_path = os.path.expanduser(args.blueprint.left_pane_text_path)\n        with open(left_pane_path, \"r\") as left_pane_file:\n            self.left_pane_text = left_pane_file.read()\n        self.annotations_config: Optional[str] = None\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            annotations_config_path = os.path.expanduser(\n                args.blueprint.annotations_config_path\n            )\n            with open(annotations_config_path, \"r\") as annotations_config_file:\n                self.annotations_config = annotations_config_file.read()\n\n        # Initialize models\n        shared_state.shared_models = self._get_shared_models(args)\n\n        # Limits the number of models that can generate at once\n        semaphore = Semaphore(args.blueprint.max_concurrent_responses)\n\n        # Move shared state into the world opt, so that it can be used by the world\n        shared_state.onboarding_world_opt.update(\n            {'skip_onboarding': self.annotations_config is None}\n        )\n        # The onboarding checks how well workers annotate conversations, so it should be\n        # skipped if we are not annotating\n        shared_state.world_opt.update(\n            {\n                'block_qualification': args.blueprint.block_qualification,\n                'annotations_config': self.annotations_config,\n                'semaphore': semaphore,\n                'shared_bot_agents': shared_state.shared_models,\n                'num_turns': args.blueprint.num_turns,\n                'max_resp_time': args.blueprint.max_resp_time,\n                'is_sandbox': args.provider.requester_name == 'MOCK_REQUESTER',\n                'check_acceptability': args.blueprint.check_acceptability,\n                'chat_data_folder': args.blueprint.chat_data_folder,\n            }\n        )\n\n    @abstractmethod\n    def _get_shared_models(self, args: \"DictConfig\") -> Dict[str, dict]:\n        \"\"\"\n        Return a dictionary whose values are the shared models.\n        \"\"\"\n\n    def get_frontend_args(self) -> Dict[str, Any]:\n        \"\"\"\n        Specifies what options within a task_config should be forwarded to the client\n        for use by the task's frontend.\n        \"\"\"\n        if self.args.blueprint.get('annotations_config_path', '') != '':\n            with open(\n                self.args.blueprint.annotations_config_path, \"r\", encoding=\"utf-8-sig\"\n            ) as f:\n                annotation_buckets = json.loads(f.read())\n        else:\n            annotation_buckets = None\n\n        return {\n            \"min_num_turns\": self.args.blueprint.num_turns,\n            \"task_description\": self.full_task_description,\n            \"task_title\": self.args.task.get('task_title', None),\n            \"annotation_question\": self.args.blueprint.annotation_question,\n            \"annotation_buckets\": annotation_buckets,\n            \"onboarding_data\": getattr(self, 'onboard_task_data', None),\n            \"left_pane_text\": self.left_pane_text,\n            \"frame_height\": '650px',\n            \"final_rating_question\": self.args.blueprint.final_rating_question,\n            \"block_mobile\": True,\n        }\n\n\n@dataclass\nclass ModelChatBlueprintArgs(BaseModelChatBlueprintArgs):\n    _blueprint_type: str = BLUEPRINT_TYPE\n    _group: str = field(\n        default=\"ModelChatBlueprint\",\n        metadata={\n            'help': \"This task runs conversations between a human and one of a set of \"\n            \"provided models, asking workers to evaluate individual turns and \"\n            \"the overall model quality.\"\n        },\n    )\n    conversation_start_mode: str = field(\n        default='hi',\n        metadata={\n            \"help\": 'Whether to show \"Hi!\" or two previous utterances (as in BlendedSkillTalk) at the beginning of the conversation',\n            \"choices\": ['hi', 'bst'],\n        },\n    )\n    include_persona: bool = field(\n        default=False, metadata={\"help\": \"Show persona to the bot\"}\n    )\n    conversations_needed_string: str = field(\n        default=MISSING,\n        metadata={\n            \"help\": 'Number of convos needed for each model. For example: \"modelA:50,modelB:20\"'\n        },\n    )\n    max_onboard_time: int = field(\n        default=300, metadata={\"help\": \"time limit accepting onboarding\"}\n    )\n    onboard_task_data_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/onboard_task_data.json\",\n        metadata={\n            \"help\": \"Path to JSON containing settings for running onboarding. Not used if not annotating model responses\"\n        },\n    )\n    world_file: str = field(\n        default=os.path.join(get_task_path(), 'worlds.py'),\n        metadata={\"help\": \"Path to file containing parlai world\"},\n    )\n\n\n@register_mephisto_abstraction()\nclass ModelChatBlueprint(BaseModelChatBlueprint):\n    \"\"\"\n    Blueprint for model chat without images.\n\n    This blueprint subclasses BaseModelChatBlueprint to provide logic for keeping track\n    of how many more conversations are needed per model; this logic is not shared with\n    other model-chat blueprints.\n    \"\"\"\n\n    ArgsClass = ModelChatBlueprintArgs\n    SharedStateClass = SharedModelChatTaskState\n    BLUEPRINT_TYPE = BLUEPRINT_TYPE\n\n    @classmethod\n    def assert_task_args(\n        cls, args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ) -> None:\n        \"\"\"\n        Ensure that arguments are properly configured to launch this task.\n        \"\"\"\n\n        if (\n            not isinstance(shared_state.conversations_needed, dict)\n            or len(shared_state.conversations_needed) == 0\n        ):\n            assert (\n                args.blueprint.get('conversations_needed_string', None) is not None\n            ), (\n                \"Must provide a string of needed conversations per model if not providing \"\n                \"a conversations needed dict\"\n            )\n            try:\n                conversations_needed = {}\n                parts = args.blueprint.conversations_needed_string.split(',')\n                for part in parts:\n                    model_name, num_string = part.split(':')\n                    conversations_needed[model_name] = int(num_string)\n            except Exception as e:\n                raise Exception(\n                    \"Could not create conversations needed dict from given string. \"\n                    f\"Error was {e}.\\n\"\n                    \"Be sure the format is like modelA:50,modelB:20\"\n                )\n        else:\n            conversations_needed = shared_state.conversations_needed\n        args.blueprint.num_conversations = sum(conversations_needed.values())\n        super().assert_task_args(args=args, shared_state=shared_state)\n\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            # We are going to do annotations, so check for the presence of an onboarding\n            # data file that will be used to onboard users into knowing how to do the\n            # annotations properly\n            assert (\n                args.blueprint.get(\"onboard_task_data_path\", None) is not None\n            ), \"Must provide an onboarding data file\"\n            full_path = os.path.expanduser(args.blueprint.onboard_task_data_path)\n            assert os.path.exists(\n                full_path\n            ), f\"Target onboarding data path {full_path} doesn't exist\"\n\n    def __init__(\n        self, task_run: \"TaskRun\", args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ):\n\n        # Set the number of conversations needed\n        conversations_needed_string = args.blueprint.conversations_needed_string\n        conversations_needed = {}\n        parts = conversations_needed_string.split(',')\n        for part in parts:\n            model_name, num_string = part.split(':')\n            conversations_needed[model_name] = int(num_string)\n        self.conversations_needed = conversations_needed\n        shared_state.conversations_needed = conversations_needed\n        args.blueprint.num_conversations = sum(conversations_needed.values())\n\n        super().__init__(task_run=task_run, args=args, shared_state=shared_state)\n\n        if args.blueprint.get(\"annotations_config_path\", \"\") != \"\":\n            # We are going to do annotations, so load the onboarding data file that will\n            # be used to onboard users into knowing how to do the annotations properly\n            onboard_task_data_path = os.path.expanduser(\n                args.blueprint.onboard_task_data_path\n            )\n            with open(onboard_task_data_path, \"r\") as onboard_task_data_file:\n                self.onboard_task_data = json.load(onboard_task_data_file)\n        else:\n            self.onboard_task_data = None\n\n        run_statistics = {r: 0 for (r, v) in self.conversations_needed.items()}\n        shared_state.run_statistics = run_statistics\n\n        context_generator: Optional[ContextGenerator] = None\n        if (\n            args.blueprint.include_persona\n            or args.blueprint.conversation_start_mode == 'bst'\n        ):\n            context_generator = get_context_generator(args.blueprint.override_opt)\n        shared_state.context_generator = context_generator\n\n        # Lock for editing run statistics between threads\n        statistics_condition = Condition()\n\n        # Move shared state into the world and onboarding opts, such that these\n        # can be used by the worlds\n        shared_state.onboarding_world_opt.update(\n            {\n                'onboard_statistics': shared_state.onboard_statistics,\n                'statistics_condition': statistics_condition,\n                'max_onboard_time': args.blueprint.max_onboard_time,\n                'onboard_task_data': self.onboard_task_data,\n                'onboarding_qualification': args.blueprint.onboarding_qualification,\n            }\n        )\n        shared_state.world_opt.update(\n            {\n                'conversations_needed': conversations_needed,\n                'run_statistics': shared_state.run_statistics,\n                'context_generator': context_generator,\n                'statistics_condition': statistics_condition,\n                'conversation_start_mode': args.blueprint.conversation_start_mode,\n                'include_persona': args.blueprint.include_persona,\n            }\n        )\n\n    def _get_shared_models(self, args: \"DictConfig\") -> Dict[str, dict]:\n        with open(args.blueprint.model_opt_path) as f:\n            all_model_opts = yaml.safe_load(f.read())\n        active_model_opts = {\n            model: opt\n            for model, opt in all_model_opts.items()\n            if self.conversations_needed[model] > 0\n        }\n        return TurkLikeAgent.get_bot_agents(args=args, model_opts=active_model_opts)\n\n\n@dataclass\nclass ModelImageChatBlueprintArgs(BaseModelChatBlueprintArgs):\n    _blueprint_type: str = IMAGE_CHAT_BLUEPRINT_TYPE\n    _group: str = field(\n        default=\"ModelImageChatBlueprint\",\n        metadata={\n            'help': \"This task runs conversations between a human and one of a set of \"\n            \"provided models, asking workers chat about a provided image.\"\n        },\n    )\n    evals_per_image_model_combo: int = field(\n        default=1,\n        metadata={\n            \"help\": \"The number of HITs to perform per combination of image and model\"\n        },\n    )\n    image_context_path: str = field(\n        default=\"${mephisto.blueprint.task_config_path}/image_contexts\",\n        metadata={\n            \"help\": \"Path to pickle file containing images and the context information that goes with each one\"\n        },\n    )\n    num_conversations: int = field(\n        default=10, metadata={'help': 'The number of conversations to collect'}\n    )\n    stack_folder: str = field(\n        default=os.path.join(get_task_path(), 'image_stack'),\n        metadata={\n            \"help\": 'Folder in which to save backups of the stack of which image-and-model combinations have had HITs launched'\n        },\n    )\n    world_file: str = field(\n        default=os.path.join(get_task_path(), 'worlds_image_chat.py'),\n        metadata={\"help\": \"Path to file containing ParlAI world for image chat\"},\n    )\n\n\n@register_mephisto_abstraction()\nclass ModelImageChatBlueprint(BaseModelChatBlueprint):\n    \"\"\"\n    Subclass of BaseModelChatBlueprint to show the speakers an image on the first turn.\n\n    The image is drawn from a stack that keeps track of how many HITs have been launched\n    for a given combination of image and model.\n    \"\"\"\n\n    ArgsClass = ModelImageChatBlueprintArgs\n    SharedStateClass = SharedModelImageChatTaskState\n    BLUEPRINT_TYPE = IMAGE_CHAT_BLUEPRINT_TYPE\n\n    @classmethod\n    def assert_task_args(\n        cls, args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ) -> None:\n        \"\"\"\n        Ensure that arguments are properly configured to launch this task.\n        \"\"\"\n        super().assert_task_args(args=args, shared_state=shared_state)\n        image_context_path = os.path.expanduser(args.blueprint.image_context_path)\n        assert os.path.exists(\n            image_context_path\n        ), f\"The image context path {image_context_path} doesn't exist!\"\n        model_opt_path = os.path.expanduser(args.blueprint.model_opt_path)\n        assert os.path.exists(\n            model_opt_path\n        ), f\"The model opt path {model_opt_path} doesn't exist!\"\n\n    def __init__(\n        self, task_run: \"TaskRun\", args: \"DictConfig\", shared_state: \"SharedTaskState\"\n    ):\n\n        super().__init__(task_run=task_run, args=args, shared_state=shared_state)\n\n        with open(args.blueprint.image_context_path, 'rb') as f:\n            shared_state.image_contexts = pickle.load(f)\n\n        # Create the stack to keep track of how many workers have seen which\n        # combinations of images and models\n        image_opt = {\n            'evals_per_image_model_combo': args.blueprint.evals_per_image_model_combo,\n            'num_images': len(shared_state.image_contexts),\n            'models': list(shared_state.shared_models.keys()),\n            'stack_folder': args.blueprint.stack_folder,\n        }\n        shared_state.image_stack = ImageStack(image_opt)\n\n        shared_state.world_opt.update(\n            {\n                'image_contexts': shared_state.image_contexts,\n                'image_stack': shared_state.image_stack,\n            }\n        )\n\n    def _get_shared_models(self, args: \"DictConfig\") -> Dict[str, dict]:\n        with open(args.blueprint.model_opt_path) as f:\n            model_opts = yaml.safe_load(f.read())\n        return TurkLikeAgent.get_bot_agents(args=args, model_opts=model_opts)\n"], "filenames": ["parlai/crowdsourcing/tasks/model_chat/model_chat_blueprint.py"], "buggy_code_start_loc": [456], "buggy_code_end_loc": [561], "fixing_code_start_loc": [456], "fixing_code_end_loc": [561], "type": "CWE-502", "message": "parlai is a framework for training and evaluating AI models on a variety of openly available dialogue datasets. In affected versions the package is vulnerable to YAML deserialization attack caused by unsafe loading which leads to Arbitary code execution. This security bug is patched by avoiding unsafe loader users should update to version above v1.1.0. If upgrading is not possible then users can change the Loader used to SafeLoader as a workaround. See commit 507d066ef432ea27d3e201da08009872a2f37725 for details.", "other": {"cve": {"id": "CVE-2021-39207", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-10T23:15:07.343", "lastModified": "2021-09-23T15:47:49.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "parlai is a framework for training and evaluating AI models on a variety of openly available dialogue datasets. In affected versions the package is vulnerable to YAML deserialization attack caused by unsafe loading which leads to Arbitary code execution. This security bug is patched by avoiding unsafe loader users should update to version above v1.1.0. If upgrading is not possible then users can change the Loader used to SafeLoader as a workaround. See commit 507d066ef432ea27d3e201da08009872a2f37725 for details."}, {"lang": "es", "value": "parlai es un marco de trabajo para entrenar y evaluar modelos de IA en una variedad de conjuntos de datos de di\u00e1logo disponibles abiertamente. En las versiones afectadas el paquete es vulnerable a un ataque de deserializaci\u00f3n de YAML causado por una carga no segura que conlleva a una ejecuci\u00f3n de c\u00f3digo arbitrario. Este bug de seguridad es parcheado al evitar una carga no segura, los usuarios deben actualizar a una versi\u00f3n superior a v1.1.0. Si la actualizaci\u00f3n no es posible, entonces los usuarios pueden cambiar el Cargador usado a SafeLoader como soluci\u00f3n. Consulte el commit 507d066ef432ea27d3e201da08009872a2f37725 para m\u00e1s detalles"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:parlai:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.0", "matchCriteriaId": "024C0A42-7DCA-4692-8BFD-E6BEFF796D84"}]}]}], "references": [{"url": "https://github.com/facebookresearch/ParlAI/commit/4374fa2aba383db6526ab36e939eb1cf8ef99879", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/facebookresearch/ParlAI/commit/507d066ef432ea27d3e201da08009872a2f37725", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/facebookresearch/ParlAI/security/advisories/GHSA-m87f-9fvv-2mgg", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebookresearch/ParlAI/commit/4374fa2aba383db6526ab36e939eb1cf8ef99879"}}