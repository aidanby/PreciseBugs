{"buggy_code": ["import _ from 'lodash';\nimport $ from 'jquery';\nimport V from '../V/index.mjs';\nimport { config } from '../config/index.mjs';\n\nexport const addClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, config.classNamePrefix.length) !== config.classNamePrefix) {\n            _className = config.classNamePrefix + _className;\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nexport const removeClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, config.classNamePrefix.length) === config.classNamePrefix) {\n            _className = _className.substr(config.classNamePrefix.length);\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nexport const parseDOMJSON = function(json, namespace) {\n\n    var selectors = {};\n    var groupSelectors = {};\n    var svgNamespace = V.namespace.svg;\n\n    var ns = namespace || svgNamespace;\n    var fragment = document.createDocumentFragment();\n    var queue = [json, fragment, ns];\n    while (queue.length > 0) {\n        ns = queue.pop();\n        var parentNode = queue.pop();\n        var siblingsDef = queue.pop();\n        for (var i = 0, n = siblingsDef.length; i < n; i++) {\n            var nodeDef = siblingsDef[i];\n            // TagName\n            if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');\n            var tagName = nodeDef.tagName;\n            // Namespace URI\n            if (nodeDef.hasOwnProperty('namespaceURI')) ns = nodeDef.namespaceURI;\n            var node = document.createElementNS(ns, tagName);\n            var svg = (ns === svgNamespace);\n\n            var wrapper = (svg) ? V : $;\n            // Attributes\n            var attributes = nodeDef.attributes;\n            if (attributes) wrapper(node).attr(attributes);\n            // Style\n            var style = nodeDef.style;\n            if (style) $(node).css(style);\n            // ClassName\n            if (nodeDef.hasOwnProperty('className')) {\n                var className = nodeDef.className;\n                if (svg) {\n                    node.className.baseVal = className;\n                } else {\n                    node.className = className;\n                }\n            }\n            // TextContent\n            if (nodeDef.hasOwnProperty('textContent')) {\n                node.textContent = nodeDef.textContent;\n            }\n            // Selector\n            if (nodeDef.hasOwnProperty('selector')) {\n                var nodeSelector = nodeDef.selector;\n                if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');\n                selectors[nodeSelector] = node;\n                wrapper(node).attr('joint-selector', nodeSelector);\n            }\n            // Groups\n            if (nodeDef.hasOwnProperty('groupSelector')) {\n                var nodeGroups = nodeDef.groupSelector;\n                if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];\n                for (var j = 0, m = nodeGroups.length; j < m; j++) {\n                    var nodeGroup = nodeGroups[j];\n                    var group = groupSelectors[nodeGroup];\n                    if (!group) group = groupSelectors[nodeGroup] = [];\n                    group.push(node);\n                }\n            }\n            parentNode.appendChild(node);\n            // Children\n            var childrenDef = nodeDef.children;\n            if (Array.isArray(childrenDef)) queue.push(childrenDef, node, ns);\n        }\n    }\n    return {\n        fragment: fragment,\n        selectors: selectors,\n        groupSelectors: groupSelectors\n    };\n};\n\n// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\nexport const hashCode = function(str) {\n\n    let hash = 0;\n    if (str.length === 0) return hash;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + c;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\n\nexport const getByPath = function(obj, path, delimiter) {\n\n    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    var key;\n    var i = 0;\n    var length = keys.length;\n    while (i < length) {\n        key = keys[i++];\n        if (Object(obj) === obj && key in obj) {\n            obj = obj[key];\n        } else {\n            return undefined;\n        }\n    }\n    return obj;\n};\n\nconst isGetSafe = function(obj, key) {\n    // Prevent prototype pollution\n    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n    if (key === 'constructor' && typeof obj[key] === 'function') {\n        return false;\n    }\n    if (key === '__proto__') {\n        return false;\n    }\n    return true;\n};\n\nexport const setByPath = function(obj, path, value, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        // diver creates an empty object if there is no nested object under such a key.\n        // This means that one can populate an empty nested object with setByPath().\n        diver = value || (diver[key] = {});\n    }\n\n    diver[keys[last]] = value;\n\n    return obj;\n};\n\nexport const unsetByPath = function(obj, path, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        if (!value) return obj;\n        diver = value;\n    }\n\n    delete diver[keys[last]];\n\n    return obj;\n};\n\nexport const flattenObject = function(obj, delim, stop) {\n\n    delim = delim || '/';\n    var ret = {};\n\n    for (var key in obj) {\n\n        if (!obj.hasOwnProperty(key)) continue;\n\n        var shouldGoDeeper = typeof obj[key] === 'object';\n        if (shouldGoDeeper && stop && stop(obj[key])) {\n            shouldGoDeeper = false;\n        }\n\n        if (shouldGoDeeper) {\n\n            var flatObject = flattenObject(obj[key], delim, stop);\n\n            for (var flatKey in flatObject) {\n                if (!flatObject.hasOwnProperty(flatKey)) continue;\n                ret[key + delim + flatKey] = flatObject[flatKey];\n            }\n\n        } else {\n\n            ret[key] = obj[key];\n        }\n    }\n\n    return ret;\n};\n\nexport const uuid = function() {\n\n    // credit: http://stackoverflow.com/posts/2117523/revisions\n\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0;\n        var v = (c === 'x') ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n};\n\n// Generate global unique id for obj and store it as a property of the object.\nexport const guid = function(obj) {\n\n    guid.id = guid.id || 1;\n    obj.id = (obj.id === undefined ? 'j_' + guid.id++ : obj.id);\n    return obj.id;\n};\n\nexport const toKebabCase = function(string) {\n\n    return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n\nexport const normalizeEvent = function(evt) {\n\n    var normalizedEvent = evt;\n    var touchEvt = evt.originalEvent && evt.originalEvent.changedTouches && evt.originalEvent.changedTouches[0];\n    if (touchEvt) {\n        for (var property in evt) {\n            // copy all the properties from the input event that are not\n            // defined on the touch event (functions included).\n            if (touchEvt[property] === undefined) {\n                touchEvt[property] = evt[property];\n            }\n        }\n        normalizedEvent = touchEvt;\n    }\n\n    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n    var target = normalizedEvent.target;\n    if (target) {\n        var useElement = target.correspondingUseElement;\n        if (useElement) normalizedEvent.target = useElement;\n    }\n\n    return normalizedEvent;\n};\n\nexport const nextFrame = (function() {\n\n    var raf;\n\n    if (typeof window !== 'undefined') {\n\n        raf = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame;\n    }\n\n    if (!raf) {\n\n        var lastTime = 0;\n\n        raf = function(callback) {\n\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n\n            lastTime = currTime + timeToCall;\n\n            return id;\n        };\n    }\n\n    return function(callback, context, ...rest) {\n        return (context !== undefined)\n            ? raf(callback.bind(context, ...rest))\n            : raf(callback);\n    };\n\n})();\n\nexport const cancelFrame = (function() {\n\n    var caf;\n    var client = typeof window != 'undefined';\n\n    if (client) {\n\n        caf = window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.webkitCancelRequestAnimationFrame ||\n            window.msCancelAnimationFrame ||\n            window.msCancelRequestAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            window.oCancelRequestAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.mozCancelRequestAnimationFrame;\n    }\n\n    caf = caf || clearTimeout;\n\n    return client ? caf.bind(window) : caf;\n\n})();\n\n/**\n * @deprecated\n */\nexport const shapePerimeterConnectionPoint = function(linkView, view, magnet, reference) {\n\n    var bbox;\n    var spot;\n\n    if (!magnet) {\n\n        // There is no magnet, try to make the best guess what is the\n        // wrapping SVG element. This is because we want this \"smart\"\n        // connection points to work out of the box without the\n        // programmer to put magnet marks to any of the subelements.\n        // For example, we want the function to work on basic.Path elements\n        // without any special treatment of such elements.\n        // The code below guesses the wrapping element based on\n        // one simple assumption. The wrapping elemnet is the\n        // first child of the scalable group if such a group exists\n        // or the first child of the rotatable group if not.\n        // This makese sense because usually the wrapping element\n        // is below any other sub element in the shapes.\n        var scalable = view.$('.scalable')[0];\n        var rotatable = view.$('.rotatable')[0];\n\n        if (scalable && scalable.firstChild) {\n\n            magnet = scalable.firstChild;\n\n        } else if (rotatable && rotatable.firstChild) {\n\n            magnet = rotatable.firstChild;\n        }\n    }\n\n    if (magnet) {\n\n        spot = V(magnet).findIntersection(reference, linkView.paper.cells);\n        if (!spot) {\n            bbox = V(magnet).getBBox({ target: linkView.paper.cells });\n        }\n\n    } else {\n\n        bbox = view.model.getBBox();\n        spot = bbox.intersectionWithLineFromCenterToPoint(reference);\n    }\n    return spot || bbox.center();\n};\n\nexport const isPercentage = function(val) {\n\n    return isString(val) && val.slice(-1) === '%';\n};\n\nexport const parseCssNumeric = function(val, restrictUnits) {\n\n    function getUnit(validUnitExp) {\n\n        // one or more numbers, followed by\n        // any number of (\n        //  `.`, followed by\n        //  one or more numbers\n        // ), followed by\n        // `validUnitExp`, followed by\n        // end of string\n        var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\n        if (!matches) return null;\n        return matches[1];\n    }\n\n    var number = parseFloat(val);\n\n    // if `val` cannot be parsed as a number, return `null`\n    if (Number.isNaN(number)) return null;\n\n    // else: we know `output.value`\n    var output = {};\n    output.value = number;\n\n    // determine the unit\n    var validUnitExp;\n    if (restrictUnits == null) {\n        // no restriction\n        // accept any unit, as well as no unit\n        validUnitExp = '[A-Za-z]*';\n\n    } else if (Array.isArray(restrictUnits)) {\n        // if this is an empty array, top restriction - return `null`\n        if (restrictUnits.length === 0) return null;\n\n        // else: restriction - an array of valid unit strings\n        validUnitExp = restrictUnits.join('|');\n\n    } else if (isString(restrictUnits)) {\n        // restriction - a single valid unit string\n        validUnitExp = restrictUnits;\n    }\n    var unit = getUnit(validUnitExp);\n\n    // if we found no matches for `restrictUnits`, return `null`\n    if (unit === null) return null;\n\n    // else: we know the unit\n    output.unit = unit;\n    return output;\n};\n\nexport const breakText = function(text, size, styles = {}, opt = {}) {\n\n    var width = size.width;\n    var height = size.height;\n\n    var svgDocument = opt.svgDocument || V('svg').node;\n    var textSpan = V('tspan').node;\n    var textElement = V('text').attr(styles).append(textSpan).node;\n    var textNode = document.createTextNode('');\n\n    // Prevent flickering\n    textElement.style.opacity = 0;\n    // Prevent FF from throwing an uncaught exception when `getBBox()`\n    // called on element that is not in the render tree (is not measurable).\n    // <tspan>.getComputedTextLength() returns always 0 in this case.\n    // Note that the `textElement` resp. `textSpan` can become hidden\n    // when it's appended to the DOM and a `display: none` CSS stylesheet\n    // rule gets applied.\n    textElement.style.display = 'block';\n    textSpan.style.display = 'block';\n\n    textSpan.appendChild(textNode);\n    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n    if (!opt.svgDocument) {\n\n        document.body.appendChild(svgDocument);\n    }\n\n    var separator = opt.separator || ' ';\n    var eol = opt.eol || '\\n';\n    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d]/;\n    var maxLineCount = opt.maxLineCount;\n    if (!isNumber(maxLineCount)) maxLineCount = Infinity;\n\n    var words = text.split(separator);\n    var full = [];\n    var lines = [];\n    var p, h;\n    var lineHeight;\n\n    for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\n        var word = words[i];\n\n        if (!word) continue;\n\n        var isEol = false;\n        if (eol && word.indexOf(eol) >= 0) {\n            // word contains end-of-line character\n            if (word.length > 1) {\n                // separate word and continue cycle\n                var eolWords = word.split(eol);\n                for (var j = 0, jl = eolWords.length - 1; j < jl; j++) {\n                    eolWords.splice(2 * j + 1, 0, eol);\n                }\n                words.splice(i, 1, ...eolWords.filter(word => word !== ''));\n                i--;\n                len = words.length;\n                continue;\n            } else {\n                // creates a new line\n                lines[++l] = '';\n                isEol = true;\n            }\n        }\n\n        if (!isEol) {\n            textNode.data = lines[l] ? lines[l] + ' ' + word : word;\n\n            if (textSpan.getComputedTextLength() <= width) {\n\n                // the current line fits\n                lines[l] = textNode.data;\n\n                if (p || h) {\n                // We were partitioning. Put rest of the word onto next line\n                    full[l++] = true;\n\n                    // cancel partitioning and splitting by hyphens\n                    p = 0;\n                    h = 0;\n                }\n\n            } else {\n\n                if (!lines[l] || p) {\n\n                    var partition = !!p;\n\n                    p = word.length - 1;\n\n                    if (partition || !p) {\n\n                        // word has only one character.\n                        if (!p) {\n\n                            if (!lines[l]) {\n\n                                // we won't fit this text within our rect\n                                lines = [];\n\n                                break;\n                            }\n\n                            // partitioning didn't help on the non-empty line\n                            // try again, but this time start with a new line\n\n                            // cancel partitions created\n                            words.splice(i, 2, word + words[i + 1]);\n\n                            // adjust word length\n                            len--;\n\n                            full[l++] = true;\n                            i--;\n\n                            continue;\n                        }\n\n                        // move last letter to the beginning of the next word\n                        words[i] = word.substring(0, p);\n                        words[i + 1] = word.substring(p) + (words[i + 1] === undefined ? '' : words[i + 1]);\n\n                    } else {\n\n                        if (h) {\n                        // cancel splitting and put the words together again\n                            words.splice(i, 2, words[i] + words[i + 1]);\n                            h = 0;\n                        } else {\n                            var hyphenIndex = word.search(hyphen);\n                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n                                h = hyphenIndex + 1;\n                                p = 0;\n                            }\n\n                            // We initiate partitioning or splitting\n                            // split the long word into two words\n                            words.splice(i, 1, word.substring(0, h || p), word.substring(h|| p));\n                            // adjust words length\n                            len++;\n\n                        }\n\n                        if (l && !full[l - 1]) {\n                        // if the previous line is not full, try to fit max part of\n                        // the current word there\n                            l--;\n                        }\n                    }\n\n                    i--;\n\n                    continue;\n                }\n\n                l++;\n                i--;\n            }\n        }\n        var lastL = null;\n\n        if (lines.length > maxLineCount) {\n\n            lastL = maxLineCount - 1;\n\n        } else if (height !== undefined) {\n\n            // if size.height is defined we have to check whether the height of the entire\n            // text exceeds the rect height\n\n            if (lineHeight === undefined) {\n\n                var heightValue;\n\n                // use the same defaults as in V.prototype.text\n                if (styles.lineHeight === 'auto') {\n                    heightValue = { value: 1.5, unit: 'em' };\n                } else {\n                    heightValue = parseCssNumeric(styles.lineHeight, ['em']) || { value: 1, unit: 'em' };\n                }\n\n                lineHeight = heightValue.value;\n                if (heightValue.unit === 'em') {\n                    lineHeight *= textElement.getBBox().height;\n                }\n            }\n\n            if (lineHeight * lines.length > height) {\n\n                // remove overflowing lines\n                lastL = Math.floor(height / lineHeight) - 1;\n            }\n        }\n\n        if (lastL !== null) {\n\n            lines.splice(lastL + 1);\n\n            // add ellipsis\n            var ellipsis = opt.ellipsis;\n            if (!ellipsis || lastL < 0) break;\n            if (typeof ellipsis !== 'string') ellipsis = '\\u2026';\n\n            var lastLine = lines[lastL];\n            if (!lastLine && !isEol) break;\n            var k = lastLine.length;\n            var lastLineWithOmission, lastChar, separatorChar;\n            do {\n                lastChar = lastLine[k];\n                lastLineWithOmission = lastLine.substring(0, k);\n                if (!lastChar) {\n                    separatorChar = (typeof separator === 'string') ? separator : ' ';\n                    lastLineWithOmission += separatorChar;\n                } else if (lastChar.match(separator)) {\n                    lastLineWithOmission += lastChar;\n                }\n                lastLineWithOmission += ellipsis;\n                textNode.data = lastLineWithOmission;\n                if (textSpan.getComputedTextLength() <= width) {\n                    lines[lastL] = lastLineWithOmission;\n                    break;\n                }\n                k--;\n            } while (k >= 0);\n            break;\n        }\n    }\n\n    if (opt.svgDocument) {\n\n        // svg document was provided, remove the text element only\n        svgDocument.removeChild(textElement);\n\n    } else {\n\n        // clean svg document\n        document.body.removeChild(svgDocument);\n    }\n\n    return lines.join(eol);\n};\n\n// Sanitize HTML\n// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n// Parses a string into an array of DOM nodes.\n// Then outputs it back as a string.\nexport const sanitizeHTML = function(html) {\n\n    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n\n    // If documentContext (second parameter) is not specified or given as `null` or `undefined`, a new document is used.\n    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n\n    // If keepScripts (last parameter) is `false`, scripts are not executed.\n    var output = $($.parseHTML('<div>' + html + '</div>', null, false));\n\n    output.find('*').each(function() { // for all nodes\n        var currentNode = this;\n\n        $.each(currentNode.attributes, function() { // for all attributes in each node\n            var currentAttribute = this;\n\n            var attrName = currentAttribute.name;\n            var attrValue = currentAttribute.value;\n\n            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n            if (attrName.startsWith('on') || attrValue.startsWith('javascript:') || attrValue.startsWith('data:') || attrValue.startsWith('vbscript:')) {\n                $(currentNode).removeAttr(attrName);\n            }\n        });\n    });\n\n    return output.html();\n};\n\n// Download `blob` as file with `fileName`.\n// Does not work in IE9.\nexport const downloadBlob = function(blob, fileName) {\n\n    if (window.navigator.msSaveBlob) { // requires IE 10+\n        // pulls up a save dialog\n        window.navigator.msSaveBlob(blob, fileName);\n\n    } else { // other browsers\n        // downloads directly in Chrome and Safari\n\n        // presents a save/open dialog in Firefox\n        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement('a');\n\n        link.href = url;\n        link.download = fileName;\n        document.body.appendChild(link);\n\n        link.click();\n\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n    }\n};\n\n// Download `dataUri` as file with `fileName`.\n// Does not work in IE9.\nexport const downloadDataUri = function(dataUri, fileName) {\n\n    const blob = dataUriToBlob(dataUri);\n    downloadBlob(blob, fileName);\n};\n\n// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\nexport const dataUriToBlob = function(dataUri) {\n\n    // first, make sure there are no newlines in the data uri\n    dataUri = dataUri.replace(/\\s/g, '');\n    dataUri = decodeURIComponent(dataUri);\n\n    var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n    var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n    var data = dataUri.slice(firstCommaIndex + 1);\n    var decodedString;\n    if (dataTypeString.indexOf('base64') >= 0) { // data may be encoded in base64\n        decodedString = atob(data); // decode data\n    } else {\n        // convert the decoded string to UTF-8\n        decodedString = unescape(encodeURIComponent(data));\n    }\n    // write the bytes of the string to a typed array\n    var ia = new Uint8Array(decodedString.length);\n    for (var i = 0; i < decodedString.length; i++) {\n        ia[i] = decodedString.charCodeAt(i);\n    }\n\n    return new Blob([ia], { type: mimeString }); // return the typed array as Blob\n};\n\n// Read an image at `url` and return it as base64-encoded data uri.\n// The mime type of the image is inferred from the `url` file extension.\n// If data uri is provided as `url`, it is returned back unchanged.\n// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n// Works with IE9.\nexport const imageToDataUri = function(url, callback) {\n\n    if (!url || url.substr(0, 'data:'.length) === 'data:') {\n        // No need to convert to data uri if it is already in data uri.\n\n        // This not only convenient but desired. For example,\n        // IE throws a security error if data:image/svg+xml is used to render\n        // an image to the canvas and an attempt is made to read out data uri.\n        // Now if our image is already in data uri, there is no need to render it to the canvas\n        // and so we can bypass this error.\n\n        // Keep the async nature of the function.\n        return setTimeout(function() {\n            callback(null, url);\n        }, 0);\n    }\n\n    // chrome, IE10+\n    var modernHandler = function(xhr, callback) {\n\n        if (xhr.status === 200) {\n\n            var reader = new FileReader();\n\n            reader.onload = function(evt) {\n                var dataUri = evt.target.result;\n                callback(null, dataUri);\n            };\n\n            reader.onerror = function() {\n                callback(new Error('Failed to load image ' + url));\n            };\n\n            reader.readAsDataURL(xhr.response);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var legacyHandler = function(xhr, callback) {\n\n        var Uint8ToString = function(u8a) {\n            var CHUNK_SZ = 0x8000;\n            var c = [];\n            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n            }\n            return c.join('');\n        };\n\n        if (xhr.status === 200) {\n\n            var bytes = new Uint8Array(xhr.response);\n\n            var suffix = (url.split('.').pop()) || 'png';\n            var map = {\n                'svg': 'svg+xml'\n            };\n            var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n            var b64encoded = meta + btoa(Uint8ToString(bytes));\n            callback(null, b64encoded);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.open('GET', url, true);\n    xhr.addEventListener('error', function() {\n        callback(new Error('Failed to load image ' + url));\n    });\n\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\n    xhr.addEventListener('load', function() {\n        if (window.FileReader) {\n            modernHandler(xhr, callback);\n        } else {\n            legacyHandler(xhr, callback);\n        }\n    });\n\n    xhr.send();\n};\n\nexport const getElementBBox = function(el) {\n\n    var $el = $(el);\n    if ($el.length === 0) {\n        throw new Error('Element not found');\n    }\n\n    var element = $el[0];\n    var doc = element.ownerDocument;\n    var clientBBox = element.getBoundingClientRect();\n\n    var strokeWidthX = 0;\n    var strokeWidthY = 0;\n\n    // Firefox correction\n    if (element.ownerSVGElement) {\n\n        var vel = V(element);\n        var bbox = vel.getBBox({ target: vel.svg() });\n\n        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n        strokeWidthX = (clientBBox.width - bbox.width);\n        strokeWidthY = (clientBBox.height - bbox.height);\n    }\n\n    return {\n        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n        width: clientBBox.width - strokeWidthX,\n        height: clientBBox.height - strokeWidthY\n    };\n};\n\n\n// Highly inspired by the jquery.sortElements plugin by Padolsey.\n// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\nexport const sortElements = function(elements, comparator) {\n\n    var $elements = $(elements);\n    var placements = $elements.map(function() {\n\n        var sortElement = this;\n        var parentNode = sortElement.parentNode;\n        // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n        var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\n        return function() {\n\n            if (parentNode === this) {\n                throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n            }\n\n            // Insert before flag:\n            parentNode.insertBefore(this, nextSibling);\n            // Remove flag:\n            parentNode.removeChild(nextSibling);\n        };\n    });\n\n    return Array.prototype.sort.call($elements, comparator).each(function(i) {\n        placements[i].call(this);\n    });\n};\n\n// Sets attributes on the given element and its descendants based on the selector.\n// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\nexport const setAttributesBySelector = function(element, attrs) {\n\n    var $element = $(element);\n\n    forIn(attrs, function(attrs, selector) {\n        var $elements = $element.find(selector).addBack().filter(selector);\n        // Make a special case for setting classes.\n        // We do not want to overwrite any existing class.\n        if (has(attrs, 'class')) {\n            $elements.addClass(attrs['class']);\n            attrs = omit(attrs, 'class');\n        }\n        $elements.attr(attrs);\n    });\n};\n\n// Return a new object with all four sides (top, right, bottom, left) in it.\n// Value of each side is taken from the given argument (either number or object).\n// Default value for a side is 0.\n// Examples:\n// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\nexport const normalizeSides = function(box) {\n\n    if (Object(box) !== box) { // `box` is not an object\n        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n        if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n\n        return { top: val, right: val, bottom: val, left: val };\n    }\n\n    // `box` is an object\n    var top, right, bottom, left;\n    top = right = bottom = left = 0;\n\n    if (isFinite(box.vertical)) top = bottom = +box.vertical;\n    if (isFinite(box.horizontal)) right = left = +box.horizontal;\n\n    if (isFinite(box.top)) top = +box.top; // overwrite vertical\n    if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n    if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n    if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n\n    return { top: top, right: right, bottom: bottom, left: left };\n};\n\nexport const timing = {\n\n    linear: function(t) {\n        return t;\n    },\n\n    quad: function(t) {\n        return t * t;\n    },\n\n    cubic: function(t) {\n        return t * t * t;\n    },\n\n    inout: function(t) {\n        if (t <= 0) return 0;\n        if (t >= 1) return 1;\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n    },\n\n    exponential: function(t) {\n        return Math.pow(2, 10 * (t - 1));\n    },\n\n    bounce: function(t) {\n        for (var a = 0, b = 1; 1; a += b, b /= 2) {\n            if (t >= (7 - 4 * a) / 11) {\n                var q = (11 - 6 * a - 11 * t) / 4;\n                return -q * q + b * b;\n            }\n        }\n    },\n\n    reverse: function(f) {\n        return function(t) {\n            return 1 - f(1 - t);\n        };\n    },\n\n    reflect: function(f) {\n        return function(t) {\n            return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n        };\n    },\n\n    clamp: function(f, n, x) {\n        n = n || 0;\n        x = x || 1;\n        return function(t) {\n            var r = f(t);\n            return r < n ? n : r > x ? x : r;\n        };\n    },\n\n    back: function(s) {\n        if (!s) s = 1.70158;\n        return function(t) {\n            return t * t * ((s + 1) * t - s);\n        };\n    },\n\n    elastic: function(x) {\n        if (!x) x = 1.5;\n        return function(t) {\n            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n        };\n    }\n};\n\nexport const interpolate = {\n\n    number: function(a, b) {\n        var d = b - a;\n        return function(t) {\n            return a + d * t;\n        };\n    },\n\n    object: function(a, b) {\n        var s = Object.keys(a);\n        return function(t) {\n            var i, p;\n            var r = {};\n            for (i = s.length - 1; i != -1; i--) {\n                p = s[i];\n                r[p] = a[p] + (b[p] - a[p]) * t;\n            }\n            return r;\n        };\n    },\n\n    hexColor: function(a, b) {\n\n        var ca = parseInt(a.slice(1), 16);\n        var cb = parseInt(b.slice(1), 16);\n        var ra = ca & 0x0000ff;\n        var rd = (cb & 0x0000ff) - ra;\n        var ga = ca & 0x00ff00;\n        var gd = (cb & 0x00ff00) - ga;\n        var ba = ca & 0xff0000;\n        var bd = (cb & 0xff0000) - ba;\n\n        return function(t) {\n\n            var r = (ra + rd * t) & 0x000000ff;\n            var g = (ga + gd * t) & 0x0000ff00;\n            var b = (ba + bd * t) & 0x00ff0000;\n\n            return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n        };\n    },\n\n    unit: function(a, b) {\n\n        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n        var ma = r.exec(a);\n        var mb = r.exec(b);\n        var p = mb[1].indexOf('.');\n        var f = p > 0 ? mb[1].length - p - 1 : 0;\n        a = +ma[1];\n        var d = +mb[1] - a;\n        var u = ma[2];\n\n        return function(t) {\n            return (a + d * t).toFixed(f) + u;\n        };\n    }\n};\n\n// SVG filters.\n// (values in parentheses are default values)\nexport const filter = {\n\n    // `color` ... outline color ('blue')\n    // `width`... outline width (1)\n    // `opacity` ... outline opacity (1)\n    // `margin` ... gap between outline and the element (2)\n    outline: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n        var width = Number.isFinite(args.width) ? args.width : 1;\n\n        return template(tpl)({\n            color: args.color || 'blue',\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            outerRadius: margin + width,\n            innerRadius: margin\n        });\n    },\n\n    // `color` ... color ('red')\n    // `width`... width (1)\n    // `blur` ... blur (0)\n    // `opacity` ... opacity (1)\n    highlight: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\n        return template(tpl)({\n            color: args.color || 'red',\n            width: Number.isFinite(args.width) ? args.width : 1,\n            blur: Number.isFinite(args.blur) ? args.blur : 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n        });\n    },\n\n    // `x` ... horizontal blur (2)\n    // `y` ... vertical blur (optional)\n    blur: function(args) {\n\n        var x = Number.isFinite(args.x) ? args.x : 2;\n\n        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n        });\n    },\n\n    // `dx` ... horizontal shift (0)\n    // `dy` ... vertical shift (0)\n    // `blur` ... blur (4)\n    // `color` ... color ('black')\n    // `opacity` ... opacity (1)\n    dropShadow: function(args) {\n\n        var tpl = 'SVGFEDropShadowElement' in window\n            ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\n            : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        return template(tpl)({\n            dx: args.dx || 0,\n            dy: args.dy || 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            color: args.color || 'black',\n            blur: Number.isFinite(args.blur) ? args.blur : 4\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n    grayscale: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n    sepia: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n    saturate: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n            amount: 1 - amount\n        });\n    },\n\n    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n    hueRotate: function(args) {\n\n        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n            angle: args.angle || 0\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n    invert: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: 1 - amount\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    brightness: function(args) {\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n            amount: Number.isFinite(args.amount) ? args.amount : 1\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    contrast: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    }\n};\n\nexport const format = {\n\n    // Formatting numbers via the Python Format Specification Mini-language.\n    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n    // Heavilly inspired by the D3.js library implementation.\n    number: function(specifier, value, locale) {\n\n        locale = locale || {\n\n            currency: ['$', ''],\n            decimal: '.',\n            thousands: ',',\n            grouping: [3]\n        };\n\n        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\n        var match = re.exec(specifier);\n        var fill = match[1] || ' ';\n        var align = match[2] || '>';\n        var sign = match[3] || '';\n        var symbol = match[4] || '';\n        var zfill = match[5];\n        var width = +match[6];\n        var comma = match[7];\n        var precision = match[8];\n        var type = match[9];\n        var scale = 1;\n        var prefix = '';\n        var suffix = '';\n        var integer = false;\n\n        if (precision) precision = +precision.substring(1);\n\n        if (zfill || fill === '0' && align === '=') {\n            zfill = fill = '0';\n            align = '=';\n            if (comma) width -= Math.floor((width - 1) / 4);\n        }\n\n        switch (type) {\n            case 'n':\n                comma = true;\n                type = 'g';\n                break;\n            case '%':\n                scale = 100;\n                suffix = '%';\n                type = 'f';\n                break;\n            case 'p':\n                scale = 100;\n                suffix = '%';\n                type = 'r';\n                break;\n            case 'b':\n            case 'o':\n            case 'x':\n            case 'X':\n                if (symbol === '#') prefix = '0' + type.toLowerCase();\n                break;\n            case 'c':\n            case 'd':\n                integer = true;\n                precision = 0;\n                break;\n            case 's':\n                scale = -1;\n                type = 'r';\n                break;\n        }\n\n        if (symbol === '$') {\n            prefix = locale.currency[0];\n            suffix = locale.currency[1];\n        }\n\n        // If no precision is specified for `'r'`, fallback to general notation.\n        if (type == 'r' && !precision) type = 'g';\n\n        // Ensure that the requested precision is in the supported range.\n        if (precision != null) {\n            if (type == 'g') precision = Math.max(1, Math.min(21, precision));\n            else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\n        }\n\n        var zcomma = zfill && comma;\n\n        // Return the empty string for floats formatted as ints.\n        if (integer && (value % 1)) return '';\n\n        // Convert negative to positive, and record the sign prefix.\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\n        var fullSuffix = suffix;\n\n        // Apply the scale, computing it from the value's exponent for si format.\n        // Preserve the existing suffix, if any, such as the currency symbol.\n        if (scale < 0) {\n            var unit = this.prefix(value, precision);\n            value = unit.scale(value);\n            fullSuffix = unit.symbol + suffix;\n        } else {\n            value *= scale;\n        }\n\n        // Convert to the desired precision.\n        value = this.convert(type, value, precision);\n\n        // Break the value into the integer part (before) and decimal part (after).\n        var i = value.lastIndexOf('.');\n        var before = i < 0 ? value : value.substring(0, i);\n        var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\n        function formatGroup(value) {\n\n            var i = value.length;\n            var t = [];\n            var j = 0;\n            var g = locale.grouping[0];\n            while (i > 0 && g > 0) {\n                t.push(value.substring(i -= g, i + g));\n                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n            }\n            return t.reverse().join(locale.thousands);\n        }\n\n        // If the fill character is not `'0'`, grouping is applied before padding.\n        if (!zfill && comma && locale.grouping) {\n\n            before = formatGroup(before);\n        }\n\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n        var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n        // If the fill character is `'0'`, grouping is applied after padding.\n        if (zcomma) before = formatGroup(padding + before);\n\n        // Apply prefix.\n        negative += prefix;\n\n        // Rejoin integer and decimal parts.\n        value = before + after;\n\n        return (align === '<' ? negative + value + padding\n            : align === '>' ? padding + negative + value\n                : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\n                    : negative + (zcomma ? value : padding + value)) + fullSuffix;\n    },\n\n    // Formatting string via the Python Format string.\n    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n    string: function(formatString, value) {\n\n        var fieldDelimiterIndex;\n        var fieldDelimiter = '{';\n        var endPlaceholder = false;\n        var formattedStringArray = [];\n\n        while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\n            var pieceFormattedString, formatSpec, fieldName;\n\n            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\n            if (endPlaceholder) {\n                formatSpec = pieceFormattedString.split(':');\n                fieldName = formatSpec.shift().split('.');\n                pieceFormattedString = value;\n\n                for (var i = 0; i < fieldName.length; i++)\n                    pieceFormattedString = pieceFormattedString[fieldName[i]];\n\n                if (formatSpec.length)\n                    pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n            }\n\n            formattedStringArray.push(pieceFormattedString);\n\n            formatString = formatString.slice(fieldDelimiterIndex + 1);\n            endPlaceholder = !endPlaceholder;\n            fieldDelimiter = (endPlaceholder) ? '}' : '{';\n        }\n        formattedStringArray.push(formatString);\n\n        return formattedStringArray.join('');\n    },\n\n    convert: function(type, value, precision) {\n\n        switch (type) {\n            case 'b':\n                return value.toString(2);\n            case 'c':\n                return String.fromCharCode(value);\n            case 'o':\n                return value.toString(8);\n            case 'x':\n                return value.toString(16);\n            case 'X':\n                return value.toString(16).toUpperCase();\n            case 'g':\n                return value.toPrecision(precision);\n            case 'e':\n                return value.toExponential(precision);\n            case 'f':\n                return value.toFixed(precision);\n            case 'r':\n                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n            default:\n                return value + '';\n        }\n    },\n\n    round: function(value, precision) {\n\n        return precision\n            ? Math.round(value * (precision = Math.pow(10, precision))) / precision\n            : Math.round(value);\n    },\n\n    precision: function(value, precision) {\n\n        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n    },\n\n    prefix: function(value, precision) {\n\n        var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '\u00b5', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function(d, i) {\n            var k = Math.pow(10, Math.abs(8 - i) * 3);\n            return {\n                scale: i > 8 ? function(d) {\n                    return d / k;\n                } : function(d) {\n                    return d * k;\n                },\n                symbol: d\n            };\n        });\n\n        var i = 0;\n        if (value) {\n            if (value < 0) value *= -1;\n            if (precision) value = this.round(value, this.precision(value, precision));\n            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n        }\n        return prefixes[8 + i / 3];\n    }\n};\n\n/*\n    Pre-compile the HTML to be used as a template.\n*/\nexport const template = function(html) {\n\n    /*\n        Must support the variation in templating syntax found here:\n        https://lodash.com/docs#template\n    */\n    var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\n    return function(data) {\n\n        data = data || {};\n\n        return html.replace(regex, function(match) {\n\n            var args = Array.from(arguments);\n            var attr = args.slice(1, 4).find(function(_attr) {\n                return !!_attr;\n            });\n\n            var attrArray = attr.split('.');\n            var value = data[attrArray.shift()];\n\n            while (value !== undefined && attrArray.length) {\n                value = value[attrArray.shift()];\n            }\n\n            return value !== undefined ? value : '';\n        });\n    };\n};\n\n/**\n * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n */\nexport const toggleFullScreen = function(el) {\n\n    var topDocument = window.top.document;\n    el = el || topDocument.body;\n\n    function prefixedResult(el, prop) {\n\n        var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n        for (var i = 0; i < prefixes.length; i++) {\n            var prefix = prefixes[i];\n            var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\n            if (el[propName] !== undefined) {\n                return isFunction(el[propName]) ? el[propName]() : el[propName];\n            }\n        }\n    }\n\n    if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n        prefixedResult(topDocument, 'ExitFullscreen') || // Spec.\n        prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n    } else {\n        prefixedResult(el, 'RequestFullscreen') || // Spec.\n        prefixedResult(el, 'RequestFullScreen'); // Firefox\n    }\n};\n\n// Deprecated\n// Copy all the properties to the first argument from the following arguments.\n// All the properties will be overwritten by the properties from the following\n// arguments. Inherited properties are ignored.\nexport const mixin = _.assign;\n\n// Deprecated\n// Copy all properties to the first argument from the following\n// arguments only in case if they don't exists in the first argument.\n// All the function propererties in the first argument will get\n// additional property base pointing to the extenders same named\n// property function's call method.\nexport const supplement = _.defaults;\n\n// Same as `mixin()` but deep version.\nexport const deepMixin = mixin;\n\n// Deprecated\n// Same as `supplement()` but deep version.\nexport const deepSupplement = _.defaultsDeep;\n\n// Replacements for deprecated functions\nexport const assign = _.assign;\nexport const defaults = _.defaults;\n// no better-named replacement for `deepMixin`\nexport const defaultsDeep = _.defaultsDeep;\n\n// Lodash 3 vs 4 incompatible\nexport const invoke = _.invokeMap || _.invoke;\nexport const sortedIndex = _.sortedIndexBy || _.sortedIndex;\nexport const uniq = _.uniqBy || _.uniq;\n\nexport const clone = _.clone;\nexport const cloneDeep = _.cloneDeep;\nexport const isEmpty = _.isEmpty;\nexport const isEqual = _.isEqual;\nexport const isFunction = _.isFunction;\nexport const isPlainObject = _.isPlainObject;\nexport const toArray = _.toArray;\nexport const debounce = _.debounce;\nexport const groupBy = _.groupBy;\nexport const sortBy = _.sortBy;\nexport const flattenDeep = _.flattenDeep;\nexport const without = _.without;\nexport const difference = _.difference;\nexport const intersection = _.intersection;\nexport const union = _.union;\nexport const has = _.has;\nexport const result = _.result;\nexport const omit = _.omit;\nexport const pick = _.pick;\nexport const bindAll = _.bindAll;\nexport const forIn = _.forIn;\nexport const camelCase = _.camelCase;\nexport const uniqueId = _.uniqueId;\n\nexport const merge = function() {\n    if (_.mergeWith) {\n        var args = Array.from(arguments);\n        var last = args[args.length - 1];\n\n        var customizer = isFunction(last) ? last : noop;\n        args.push(function(a, b) {\n            var customResult = customizer(a, b);\n            if (customResult !== undefined) {\n                return customResult;\n            }\n\n            if (Array.isArray(a) && !Array.isArray(b)) {\n                return b;\n            }\n        });\n\n        return _.mergeWith.apply(this, args);\n    }\n    return _.merge.apply(this, arguments);\n};\n\nexport const isBoolean = function(value) {\n    var toString = Object.prototype.toString;\n    return value === true || value === false || (!!value && typeof value === 'object' && toString.call(value) === '[object Boolean]');\n};\n\nexport const isObject = function(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function');\n};\n\nexport const isNumber = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'number' || (!!value && typeof value === 'object' && toString.call(value) === '[object Number]');\n};\n\nexport const isString = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'string' || (!!value && typeof value === 'object' && toString.call(value) === '[object String]');\n};\n\nexport const noop = function() {\n};\n", "'use strict';\n\nQUnit.module('util', function(hooks) {\n\n    QUnit.test('util.interpolate', function(assert) {\n\n        var values = [0, .25, .5, .75, 1];\n\n        var numberInterpolation = joint.util.interpolate.number(0, 100);\n        var objectInterpolation = joint.util.interpolate.object({ x: 100, y: 200 }, { x: 200, y: 0 });\n        var hexColorInterpolation = joint.util.interpolate.hexColor('#FFFFFF', '#00FF77');\n        var unitInterpolation = joint.util.interpolate.unit('1em', '0.50em');\n\n        var numberArray = _.map(values, numberInterpolation);\n        var objectArray = _.map(values, objectInterpolation);\n        var hexColorArray = _.map(values, hexColorInterpolation);\n        var unitArray = _.map(values, unitInterpolation);\n\n        assert.deepEqual(numberArray, [\n            0, 25, 50, 75, 100\n        ], 'Numbers interpolated.');\n\n        assert.deepEqual(objectArray, [\n            { x: 100, y: 200 }, { x: 125, y: 150 }, { x: 150, y: 100 }, { x: 175, y: 50 }, { x: 200,    y: 0 }\n        ], 'Objects interpolated.');\n\n        assert.deepEqual(hexColorArray, [\n            '#ffffff', '#bfffdd', '#7fffbb', '#3fff99', '#00ff77'\n        ], 'String hex colors interpolated.');\n\n        assert.deepEqual(unitArray, [\n            '1.00em', '0.88em', '0.75em', '0.63em', '0.50em'\n        ], 'Numbers with units interpolated.');\n    });\n\n    QUnit.test('util.isPercentage', function(assert) {\n\n        assert.equal(joint.util.isPercentage(undefined), false, 'undefined => false');\n        assert.equal(joint.util.isPercentage(null), false, 'null => false');\n        assert.equal(joint.util.isPercentage(true), false, 'true => false');\n        assert.equal(joint.util.isPercentage(false), false, 'false => false');\n        assert.equal(joint.util.isPercentage(0), false, '0 => false');\n        assert.equal(joint.util.isPercentage(10), false, '10 => false');\n        assert.equal(joint.util.isPercentage(''), false, '\\'\\' => false');\n        assert.equal(joint.util.isPercentage('10'), false, '\\'10\\' => false');\n\n        assert.equal(joint.util.isPercentage('%'), true, '\\'%\\' => true');\n        assert.equal(joint.util.isPercentage('10%'), true, '\\'10%\\' => true');\n        assert.equal(joint.util.isPercentage('-10%'), true, '\\'-10%\\' => true');\n    });\n\n    QUnit.test('util.format.number', function(assert) {\n\n        var res = {\n            '5.00': ['.2f', 5],\n            '005': ['03d', 5],\n            '05.02': ['05.2f', 5.02],\n            '20.5%': ['.1%', .205],\n            '****5****': ['*^9', '5'],\n            '5********': ['*<9', '5'],\n            '********5': ['*>9', '5'],\n            '+3.14': ['+.f', 3.14],\n            '3.14': ['.f', 3.14],\n            '-3.14': ['+.f', -3.14],\n            'a': ['x', 10],\n            'A': ['X', 10],\n            'C0': ['02X', 192],\n            '1,234,567,890': [',', 1234567890]\n        };\n\n        _.each(res, function(input, output) {\n\n            assert.equal(joint.util.format.number(input[0], input[1]), output, 'number(' + input[0] + ', ' + input[1] + ') = ' + output);\n        });\n    });\n\n    QUnit.module('util.breakText', function(assert) {\n\n        // tests can't compare exact results as they may vary in different browsers\n\n        // This ensures that the tests will be more deterministic.\n        // For example, some browsers might have a different default font size/family.\n        var styles = {\n            'font-size': '12px',\n            'font-family': 'Courier New'\n        };\n\n        var text = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';\n\n        QUnit.test('sanity', function(assert) {\n\n            assert.equal(joint.util.breakText('', { width: 100 }, styles), '', 'An empty text was correctly broken.');\n\n            assert.equal(joint.util.breakText(text, { width: 0, height: 0 }, styles), '', 'A text was correctly broken when zero width and height provided.');\n\n            assert.ok(_.includes(joint.util.breakText(text, { width: 100 }, styles), '\\n'),\n                'A text was broken when width A specified.');\n\n            assert.ok(_.includes(joint.util.breakText(text, { width: 15 }, styles), '\\n'), 'A text was broken when width B specified.');\n\n            var brokenText = joint.util.breakText(text, { width: 100, height: 40 }, styles);\n\n            assert.ok(_.includes(brokenText, 'Lorem') && !_.includes(brokenText, 'elit.'), 'A text was trimmed when width & height specified.');\n\n            brokenText = joint.util.breakText(text, { width: 100, height: 50 }, _.extend({}, styles, { 'font-size': '18px' }));\n\n            assert.ok(_.includes(brokenText, '\\n') || !_.includes(brokenText, 'elit.'), 'A text was broken when style specified.');\n\n            assert.throws(function() {\n                joint.util.breakText(text, { width: 100, height: 50 }, _.extend({}, styles, { 'font-size': '18px' }), { svgDocument: 'not-svg' });\n            }, /appendChild|undefined/, 'A custom svgDocument provided was recognized.');\n        });\n\n        function measureText(text, styles) {\n            var vText = V('text').text(text).attr(styles || {});\n            var svgDoc = V('svg').append(vText);\n            document.body.appendChild(svgDoc.node);\n            var bbox = vText.getBBox();\n            svgDoc.remove();\n            return bbox;\n        }\n\n        QUnit.test('maxLineCount', function(assert) {\n\n            var WIDTH = 100;\n            var t, r;\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 0 });\n            assert.equal(r, '');\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 1 });\n            assert.equal(r.split('\\n').length, 1);\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 2 });\n            assert.equal(r.split('\\n').length, 2);\n\n            t = 'test\\n\\n\\n\\n';\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 2 });\n            assert.equal(r.split('\\n').length, 2);\n        });\n\n\n        QUnit.test('ellipsis', function(assert) {\n\n            var WIDTH = 100;\n            var HEIGHT = 20;\n            var ELLIPSIS = '\\u2026';\n            var t, r;\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: false });\n            assert.ok(r.indexOf(ELLIPSIS) === -1);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: true });\n            assert.ok(r.indexOf(ELLIPSIS) === r.length - ELLIPSIS.length);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n\n            var customEllipsis = 'CUSTOM';\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: customEllipsis });\n            assert.ok(r.indexOf(customEllipsis) === r.length - customEllipsis.length);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n\n            // '...' vs ' ...'\n            [WIDTH, WIDTH - 3, WIDTH - 6, WIDTH - 9, WIDTH -12].forEach(function(w, i) {\n\n                t = 'NoSpacesNoSpacesNoSpaces';\n                r = joint.util.breakText(t, { width: w, height: HEIGHT }, styles, { ellipsis: true });\n                assert.notOk(r[r.length - 1 - ELLIPSIS.length] === ' ');\n\n                t = 'S P A C E S S P A C E S';\n                r = joint.util.breakText(t, { width: w, height: HEIGHT }, styles, { ellipsis: true });\n                assert.ok(r[r.length - 1 - ELLIPSIS.length] === ' ');\n            });\n\n            t = 'text\\n\\n\\n\\n\\n';\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: true });\n            assert.ok(r.indexOf(ELLIPSIS) === r.length - ELLIPSIS.length);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n        });\n\n        QUnit.test('hyphen', function(assert) {\n\n            var WIDTH = 50;\n            var t, t2, t3, t4, r;\n\n            t = 'test-hyphen';\n            t2 = 'asdfWETUIOPj[JF';\n            t3 = 'as[dsdfgdfWETUfIOPj';\n            t4 = 'WETUIOP[JF';\n\n            r = joint.util.breakText(t, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'test-hyphen');\n\n            r = joint.util.breakText(t2, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'asdfWETUIOPj[\\nJF', 'Inserts new line character after \"[\" character.');\n\n            r = joint.util.breakText(t3, { width: 2 * WIDTH + 20 }, styles);\n            assert.equal(r, 'as[\\ndsdfgdfWETUfIOPj', 'Inserts new line character after \"[\" character.');\n\n            r = joint.util.breakText(t3, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'as[\\ndsdfgdfWETUfI\\nOPj', 'Inserts two new line characters, one after \"[\" and one in second line when text is too long.');\n\n            r = joint.util.breakText(t4, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'WETUIOP[JF', 'Does not insert new line character when text fits in a single line.');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles);\n            assert.equal(r, 'test-\\nhyphen');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { hyphen: '-' });\n            assert.equal(r, 'test-\\nhyphen');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { hyphen: 'h' });\n            assert.equal(r, 'test-h\\nyphen');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { hyphen: /h/ });\n            assert.equal(r, 'test-h\\nyphen');\n        });\n\n\n        QUnit.test('new line', function(assert) {\n\n            var WIDTH = 50;\n            var r;\n\n            r = joint.util.breakText('a\\n', { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'a\\n');\n\n            r = joint.util.breakText('a\\n\\n', { width: WIDTH }, styles);\n            assert.equal(r, 'a\\n\\n');\n\n            r = joint.util.breakText('\\na', { width: WIDTH }, styles);\n            assert.equal(r, '\\na');\n\n            r = joint.util.breakText('\\n\\na', { width: WIDTH }, styles);\n            assert.equal(r, '\\n\\na');\n\n            r = joint.util.breakText('\\na\\n\\nb\\n\\n', { width: WIDTH }, styles);\n            assert.equal(r, '\\na\\n\\nb\\n\\n');\n        });\n\n    });\n\n    QUnit.test('util.parseCssNumeric', function(assert) {\n\n        assert.equal(joint.util.parseCssNumeric('auto'), null, 'no number to parse');\n\n        assert.deepEqual(joint.util.parseCssNumeric(1.1), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1'), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px'), { value: 1.1, unit: 'px' });\n\n        assert.deepEqual(joint.util.parseCssNumeric(1.1, ''), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1', ''), { value: 1.1, unit: '' });\n        assert.equal(joint.util.parseCssNumeric('1.1px', ''), null, '\\'px\\' found, expects no unit');\n\n        assert.equal(joint.util.parseCssNumeric(1.1, 'px'), null, 'no unit found, expects \\'px\\'');\n        assert.equal(joint.util.parseCssNumeric('1.1', 'px'), null, 'no unit found, expects \\'px\\'');\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', 'px'), { value: 1.1, unit: 'px' });\n        assert.equal(joint.util.parseCssNumeric('1.1em', 'px'), null, '\\'em\\' found, expects \\'px\\'');\n\n        assert.equal(joint.util.parseCssNumeric(1.1, []), null, 'always return null');\n        assert.equal(joint.util.parseCssNumeric('1.1', []), null, 'always return null');\n        assert.equal(joint.util.parseCssNumeric('1.1px', []), null, 'always return null');\n\n        assert.deepEqual(joint.util.parseCssNumeric(1.1, ['']), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1', ['']), { value: 1.1, unit: '' });\n        assert.equal(joint.util.parseCssNumeric('1.1px', ['']), null, '\\'px\\' found, expects no unit');\n\n        assert.equal(joint.util.parseCssNumeric(1.1, ['px']), null, 'no unit found, expects \\'px\\'');\n        assert.equal(joint.util.parseCssNumeric('1.1', ['px']), null, 'no unit found, expects \\'px\\'');\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', ['px']), { value: 1.1, unit: 'px' });\n        assert.equal(joint.util.parseCssNumeric('1.1em', ['px']), null, '\\'em\\' found, expects \\'px\\'');\n\n        assert.equal(joint.util.parseCssNumeric('1.1', ['px', 'em']), null, 'no unit found, expects \\'px\\' or \\'em\\'');\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', ['px', 'em']), { value: 1.1, unit: 'px' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1em', ['px', 'em']), { value: 1.1, unit: 'em' });\n\n        assert.deepEqual(joint.util.parseCssNumeric('1.1', ['', 'px']), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', ['', 'px']), { value: 1.1, unit: 'px' });\n        assert.equal(joint.util.parseCssNumeric('1.1em', ['', 'px']), null, '\\'em\\' found, expects no unit or \\'px\\'');\n    });\n\n    QUnit.test('util.getByPath()', function(assert) {\n\n        var obj = {\n            a: 1,\n            b: {\n                c: 2,\n                d: 3\n            },\n            f: {},\n            g: [],\n            h: [null, 4, {\n                i: { j: 6 }\n            }],\n            'a/b/c': { d: 'abcd' }\n        };\n\n        assert.deepEqual(joint.util.getByPath(obj, 'none'), undefined, 'non-existing property is undefined');\n        assert.equal(joint.util.getByPath(obj, 'a'), 1, 'existing property is a number');\n        assert.deepEqual(joint.util.getByPath(obj, 'b'), { c: 2, d: 3 }, 'existing property is an object');\n        assert.equal(joint.util.getByPath(obj, 'b/c'), 2, 'nested property is a number');\n        assert.deepEqual(joint.util.getByPath(obj, 'b/none'), undefined, 'non-existing nested property is undefined');\n        assert.deepEqual(joint.util.getByPath(obj, 'f'), {}, 'property is an empty object');\n        assert.deepEqual(joint.util.getByPath(obj, 'g'), [], 'property is an empty array');\n        assert.deepEqual(joint.util.getByPath(obj, 'g/0'), undefined, 'first item of an empty array is undefined');\n        assert.deepEqual(joint.util.getByPath(obj, 'h/0'), null, 'first item of an array is null');\n        assert.deepEqual(joint.util.getByPath(obj, 'h/0/none'), undefined, 'nested property in null is undefined');\n        assert.equal(joint.util.getByPath(obj, 'h/1'), 4, 'nth item of an array is number');\n        assert.deepEqual(joint.util.getByPath(obj, 'h/1/none'), undefined, 'non-existing property of nth item of an array is undefined');\n        assert.equal(joint.util.getByPath(obj, 'h/2/i/j'), 6, 'nested property of nth item of an array is number');\n        assert.equal(joint.util.getByPath(obj, 'h.2.i.j', '.'), 6, 'same but this time with a custom delimiter');\n        assert.equal(joint.util.getByPath(obj, ['h', '2', 'i', 'j']), 6, 'path as array');\n        assert.equal(joint.util.getByPath(obj, ['a/b/c', 'd']), 'abcd', 'path as array, separator in name');\n    });\n\n    QUnit.module('util.setByPath()', function() {\n\n        QUnit.test('sets a value at any given path', function(assert) {\n\n            assert.deepEqual(joint.util.setByPath({}, 'property', 1), { property: 1 }, 'non-existing property in an obj set as a number');\n            assert.deepEqual(joint.util.setByPath({ property: 2 }, 'property', 3), { property: 3 }, 'existing property in an obj set as a number');\n            assert.deepEqual(joint.util.setByPath([], '0', 4), [4], 'add an item to an empty array');\n            assert.deepEqual(joint.util.setByPath([5, 6], '1', 7), [5, 7], 'change an item in an array');\n            assert.deepEqual(joint.util.setByPath({}, 'first/second/third', 8), { first: { second: { third: 8 }}}, 'populate an empty object with nested objects');\n            assert.deepEqual(joint.util.setByPath({}, 'first.second.third', 9, '.'), { first: { second: { third: 9 }}}, 'same but this time with a custom delimiter');\n            assert.deepEqual(joint.util.setByPath([null], '0/property', 10), [{ property: 10 }], 'replace null item with an object');\n            assert.deepEqual(joint.util.setByPath({ array: [] }, 'array/1', 'index'), { array: [undefined, 'index'] }, 'define array');\n            assert.deepEqual(joint.util.setByPath({ object: {}}, 'object/1', 'property'), { object: { '1': 'property' }}, 'define property');\n        });\n\n        ['__proto__/polluted', 'constructor/prototype/polluted'].forEach(function(path) {\n            QUnit.test('setting \"' + path + '\" does not pollute prototype' , function(assert) {\n                var obj = {};\n                assert.notOk(obj.polluted);\n                joint.util.setByPath({}, path, true, '/');\n                assert.notOk(obj.polluted);\n            });\n        });\n    });\n\n\n    QUnit.module('util.unsetByPath', function(hooks) {\n\n        QUnit.test('path defined as string', function(assert) {\n\n            var obj = {\n                a: 1,\n                b: {\n                    c: 2,\n                    d: 3\n                }\n            };\n\n            joint.util.unsetByPath(obj, 'b/c', '/');\n            assert.deepEqual(obj, { a: 1, b: { d: 3 }}, 'A nested attribute was removed.');\n\n            joint.util.unsetByPath(obj, 'b');\n            assert.deepEqual(obj, { a: 1 }, 'A primitive attribute was removed.');\n\n            joint.util.unsetByPath(obj, 'c/d');\n            assert.deepEqual(obj, { a: 1 }, 'Attempt to delete non-existing attribute doesn\\'t affect object.');\n\n        });\n\n        QUnit.test('path defined as array - remove from objects and arrays', function(assert) {\n\n            var obj = {\n                object: { 1: 'property', 2: 'property2', 3: 'property3' },\n                array: ['a', 'b', 'c'],\n                objectArray: [{ a: 'a_value', b: 'b_value' }, { c: 'c_value', d: 'd_value' }]\n            };\n\n            joint.util.unsetByPath(obj, ['object', 1]);\n            assert.deepEqual(obj.object, { 2: 'property2', 3: 'property3' });\n\n            joint.util.unsetByPath(obj, ['object', 2]);\n            assert.deepEqual(obj.object, { 3: 'property3' });\n\n            joint.util.unsetByPath(obj, ['array', 1]);\n            assert.deepEqual(obj.array, ['a', undefined, 'c']);\n\n            joint.util.unsetByPath(obj, ['array', 2]);\n            assert.deepEqual(obj.array, ['a', undefined, undefined]);\n\n            joint.util.unsetByPath(obj, ['objectArray', 1, 'c']);\n            assert.deepEqual(obj.objectArray, [{ a: 'a_value', b: 'b_value' }, { d: 'd_value' }]);\n\n            joint.util.unsetByPath(obj, ['objectArray', '1', 'd']);\n            assert.deepEqual(obj.objectArray, [{ a: 'a_value', b: 'b_value' }, {}]);\n        });\n\n        QUnit.test('path defined as array', function(assert) {\n\n            var obj = {\n                a: 1,\n                b: {\n                    c: 2,\n                    d: 3\n                }\n            };\n\n            joint.util.unsetByPath(obj, ['b', 'c'], '/');\n            assert.deepEqual(obj, { a: 1, b: { d: 3 }}, 'A nested attribute was removed.');\n\n            joint.util.unsetByPath(obj, ['b']);\n            assert.deepEqual(obj, { a: 1 }, 'A primitive attribute was removed.');\n\n            joint.util.unsetByPath(obj, ['c', 'd']);\n            assert.deepEqual(obj, { a: 1 }, 'Attempt to delete non-existing attribute doesn\\'t affect object.');\n        });\n\n        ['__proto__/toString', 'constructor/prototype/toString'].forEach(function(path) {\n            QUnit.test('unsetting \"' + path + '\" does not modify prototype' , function(assert) {\n                var obj = {};\n                assert.equal(typeof obj.toString, 'function');\n                joint.util.unsetByPath({}, path, '/');\n                assert.equal(typeof obj.toString, 'function');\n            });\n        });\n    });\n\n    QUnit.test('util.normalizeSides()', function(assert) {\n\n        assert.deepEqual(joint.util.normalizeSides(undefined), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Undefined becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(null), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Null becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(''), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Empty string becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides('a'), { top: 0, right: 0, bottom: 0, left: 0 },\n            'String becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides('5'), { top: 5, right: 5, bottom: 5, left: 5 },\n            'String number becomes number');\n\n        assert.deepEqual(joint.util.normalizeSides('Infinity'), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides('NaN'), { top: 0, right: 0, bottom: 0, left: 0 },\n            'NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(Infinity), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(NaN), { top: 0, right: 0, bottom: 0, left: 0 },\n            'NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: undefined }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific undefined becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: null }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific null becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: '' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific empty string becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 'a' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific string becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: '5' }), { top: 0, right: 0, bottom: 0, left: 5 },\n            'Specific string number becomes number');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 'Infinity' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific string Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 'NaN' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific string NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: Infinity }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: NaN }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Returns sides defaulted to 0 if called without an argument.');\n\n        assert.deepEqual(joint.util.normalizeSides(5), { top: 5, right: 5, bottom: 5, left: 5 },\n            'Returns sides equaled to a number if called with this number as an argument.');\n\n        assert.deepEqual(joint.util.normalizeSides({ horizontal: 5 }), { top: 0, right: 5, bottom: 0, left: 5 },\n            'If called with an object, horizontal sides are applied to right and left and the rest is defaulted to 0.');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 5 }), { top: 0, right: 0, bottom: 0, left: 5 },\n            'If called with an object, the existing sides are copied from the object and the rest is defaulted to 0.');\n\n        assert.deepEqual(joint.util.normalizeSides({ horizontal: 10, left: 5 }), { top: 0, right: 10, bottom: 0, left: 5 },\n            'If called with an object, horizontal sides are overriden by more specific sides from the object and the rest is defaulted to 0.');\n\n        assert.deepEqual(joint.util.normalizeSides({ horizontal: 5, left: 0 }), { top: 0, right: 5, bottom: 0, left: 0 },\n            'If called with an object, horizontal sides are overriden by more specific sides from the object and the rest is defaulted to 0.');\n    });\n\n    QUnit.module('util.normalizeEvent()', function() {\n\n        QUnit.test('correspondingUseElement', function(assert) {\n            var useElement = V('use').node;\n            var event = new $.Event('mouseover', { target: { correspondingUseElement: useElement }});\n            assert.equal(joint.util.normalizeEvent(event).target, useElement);\n        });\n\n    });\n\n    QUnit.test('util.merge', function(assert) {\n\n        var types = joint.util.merge({ a: [99] }, { a: { b: 1 }});\n        assert.deepEqual(types, { a: { b: 1 }}, 'array is not merged with object');\n\n\n        var custom = joint.util.merge({ a: [99] }, { a: { b: 1 }}, function(a) {\n            return 'x';\n        });\n        assert.deepEqual(custom, { a: 'x' });\n    });\n\n    QUnit.test('joint.setTheme()', function(assert) {\n\n        assert.ok(typeof joint.setTheme === 'function', 'should be a function');\n\n        var theme = 'set-global-theme-test';\n        var view1 = new joint.mvc.View();\n        var view2 = new joint.mvc.View();\n\n        joint.setTheme(theme);\n\n        assert.ok(view1.theme === theme && view2.theme === theme, 'should set the theme for all views');\n        assert.equal(joint.mvc.View.prototype.defaultTheme, theme, 'should update the default theme on the view prototype');\n\n        var view3 = new joint.mvc.View();\n\n        assert.equal(view3.theme, theme, 'newly created views should use the updated theme');\n\n        var localTheme = 'local-theme';\n\n        joint.mvc.View.extend({\n            options: {\n                theme: localTheme\n            }\n        });\n\n        var view4 = new joint.mvc.View({\n            theme: localTheme\n        });\n\n        joint.setTheme(theme);\n\n        assert.ok(view4.theme === localTheme, 'by default, should not override local theme settings');\n\n        joint.setTheme(theme, { override: true });\n\n        assert.ok(view4.theme === theme, 'when \"override\" set to true, should override local theme settings');\n    });\n\n    QUnit.module('template(html)', function(hooks) {\n\n        QUnit.test('should be a function', function(assert) {\n\n            assert.equal(typeof joint.util.template, 'function');\n        });\n\n        QUnit.test('should correctly render the sample HTML templates', function(assert) {\n\n            var samples = [\n                {\n                    html: '<p>No embedded data in this template.</p>',\n                    data: {},\n                    expectedOutput: '<p>No embedded data in this template.</p>'\n                },\n                {\n                    html: '<p>no data!</p>',\n                    data: null,\n                    expectedOutput: '<p>no data!</p>'\n                },\n                {\n                    html: [\n                        '<p>Some simple text with a value: <%= someValue %></p>',\n                        '<p>Another line with another value: <%= anotherValue %></p>'\n                    ].join(''),\n                    data: {\n                        someValue: 12345,\n                        anotherValue: 678\n                    },\n                    expectedOutput: [\n                        '<p>Some simple text with a value: 12345</p>',\n                        '<p>Another line with another value: 678</p>'\n                    ].join('')\n                },\n                {\n                    html: '<p>With a complex data attribute <%= some.value %></p>',\n                    data: {\n                        some: {\n                            value: 123\n                        }\n                    },\n                    expectedOutput: '<p>With a complex data attribute 123</p>'\n                },\n                {\n                    html: '<p>With a more <%= some.value.text %> data attribute</p>',\n                    data: {\n                        some: {\n                            value: {\n                                text: 'complex'\n                            }\n                        }\n                    },\n                    expectedOutput: '<p>With a more complex data attribute</p>'\n                },\n                {\n                    html: '<p>Alternative syntax #${num}</p>',\n                    data: {\n                        num: 1\n                    },\n                    expectedOutput: '<p>Alternative syntax #1</p>'\n                },\n                {\n                    html: '<p>Alternative syntax #${ num }</p>',\n                    data: {\n                        num: 2\n                    },\n                    expectedOutput: '<p>Alternative syntax #2</p>'\n                },\n                {\n                    html: '<p>Alternative syntax #{{num}}</p>',\n                    data: {\n                        num: 3\n                    },\n                    expectedOutput: '<p>Alternative syntax #3</p>'\n                }\n            ];\n\n            _.each(samples, function(sample) {\n\n                var template = joint.util.template(sample.html);\n                var actualOutput = template(sample.data);\n\n                assert.equal(actualOutput, sample.expectedOutput, 'should return expected output');\n            });\n        });\n    });\n\n    QUnit.module('addClassNamePrefix', function(hooks) {\n\n        QUnit.test('should be a function', function(assert) {\n\n            assert.equal(typeof joint.util.addClassNamePrefix, 'function');\n        });\n\n        QUnit.test('falsey value provided', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix(null), null);\n            assert.equal(joint.util.addClassNamePrefix(undefined), undefined);\n            assert.equal(joint.util.addClassNamePrefix(0), 0);\n            assert.equal(joint.util.addClassNamePrefix(''), '');\n            assert.ok(_.isNaN(joint.util.addClassNamePrefix(NaN)));\n        });\n\n        QUnit.test('non-string value provided', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix(1), joint.config.classNamePrefix + '1');\n        });\n\n        QUnit.test('one class name', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix('some-class'), joint.config.classNamePrefix + 'some-class');\n        });\n\n        QUnit.test('multiple class names', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix('some-class some-other-class'), joint.config.classNamePrefix + 'some-class ' + joint.config.classNamePrefix + 'some-other-class');\n        });\n    });\n\n    QUnit.module('removeClassNamePrefix', function(hooks) {\n\n        QUnit.test('should be a function', function(assert) {\n\n            assert.equal(typeof joint.util.removeClassNamePrefix, 'function');\n        });\n\n        QUnit.test('falsey value provided', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(null), null);\n            assert.equal(joint.util.removeClassNamePrefix(undefined), undefined);\n            assert.equal(joint.util.removeClassNamePrefix(0), 0);\n            assert.equal(joint.util.removeClassNamePrefix(''), '');\n            assert.ok(_.isNaN(joint.util.removeClassNamePrefix(NaN)));\n        });\n\n        QUnit.test('non-string value provided', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(1), '1');\n        });\n\n        QUnit.test('one prefixed class name', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(joint.config.classNamePrefix + 'some-class'), 'some-class');\n        });\n\n        QUnit.test('multiple prefixed class names', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(joint.config.classNamePrefix + 'some-class ' + joint.config.classNamePrefix + 'some-other-class'), 'some-class some-other-class');\n        });\n\n        QUnit.test('mix of prefixed and non-prefixed class names', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(joint.config.classNamePrefix + 'some-class without-prefix'), 'some-class without-prefix');\n        });\n    });\n\n    QUnit.module('wrapWith', function(hooks) {\n\n        QUnit.test('wraps object\\'s methods with wrapper function', function(assert) {\n\n            var someObject = {\n\n                someFunction: function() {\n\n                },\n\n                someOtherFunction: function() {\n\n                },\n\n                yetAnotherFunction: function() {\n\n                }\n            };\n\n            var methods = ['someFunction', 'someOtherFunction'];\n\n            var innerWrapper = function() { };\n\n            var wrapper = function() {\n\n                return innerWrapper;\n            };\n\n            joint.util.wrapWith(someObject, methods, wrapper);\n\n            _.each(someObject, function(fn, method) {\n\n                if (_.includes(methods, method)) {\n                    // Should be wrapped.\n                    assert.equal(someObject[method], innerWrapper);\n                } else {\n                    // Should not be wrapped.\n                    assert.equal(someObject[method], fn);\n                }\n            });\n        });\n\n        QUnit.test('can specify wrapper method by name', function(assert) {\n\n            var someObject = {\n\n                someFunction: function() {\n\n                }\n            };\n\n            var methods = ['someFunction'];\n            var wrapper = 'someWrapper';\n            var innerWrapper = function() { };\n\n            joint.util.wrappers[wrapper] = function() {\n\n                return innerWrapper;\n            };\n\n            joint.util.wrapWith(someObject, methods, wrapper);\n\n            _.each(someObject, function(fn, method) {\n\n                if (_.includes(methods, method)) {\n                    // Should be wrapped.\n                    assert.equal(someObject[method], innerWrapper);\n                } else {\n                    // Should not be wrapped.\n                    assert.equal(someObject[method], fn);\n                }\n            });\n\n            // Clean up.\n            delete joint.util.wrappers[wrapper];\n        });\n    });\n\n    QUnit.module('wrappers', function(hooks) {\n\n        QUnit.module('cells', function(hooks) {\n\n            var expected;\n\n            hooks.beforeEach(function() {\n\n                expected = {\n                    cells: [\n                        new joint.dia.Cell,\n                        new joint.dia.Cell,\n                        new joint.dia.Cell\n                    ],\n                    opt: {\n                        someOption: 'testing',\n                        anotherOption: 50\n                    }\n                };\n            });\n\n            QUnit.test('fn([cell, cell, cell], opt)', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, expected.opt), 'opt is as expected');\n                });\n\n                fn(expected.cells, expected.opt);\n            });\n\n            QUnit.test('fn([cell, cell, cell])', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, {}), 'opt is an empty object');\n                });\n\n                fn(expected.cells);\n            });\n\n            QUnit.test('fn(cell, cell, cell)', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, {}), 'opt is an empty object');\n                });\n\n                fn.apply(undefined, expected.cells);\n            });\n\n            QUnit.test('fn(cell, cell, cell, opt)', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, expected.opt), 'opt is as expected');\n                });\n\n                fn.apply(undefined, [].concat(expected.cells, [expected.opt]));\n            });\n\n            QUnit.test('fn(cell)', function(assert) {\n\n                var cell = _.first(expected.cells);\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, [cell]), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, {}), 'opt is an empty object');\n                });\n\n                fn(cell);\n            });\n        });\n    });\n\n    QUnit.module('getElementBBox', function(hooks) {\n\n        QUnit.module('html', function(hooks) {\n\n            var $htmlElement;\n            hooks.beforeEach(function() {\n                $htmlElement = $('<div/>').css({\n                    position: 'absolute',\n                    top: 10,\n                    left: 20,\n                    width: 50,\n                    height: 60\n                });\n\n                $htmlElement.appendTo(document.body);\n            });\n\n            hooks.afterEach(function() {\n                $htmlElement.remove();\n            });\n\n            QUnit.test('html element', function(assert) {\n\n                var bBox = joint.util.getElementBBox($htmlElement[0]);\n\n                assert.equal(bBox.x, 20);\n                assert.equal(bBox.y, 10);\n                assert.equal(bBox.width, 50);\n                assert.equal(bBox.height, 60);\n            });\n\n            QUnit.test('possible input argument types', function(assert) {\n\n                assert.ok(joint.util.getElementBBox('html'));\n                assert.ok(joint.util.getElementBBox($htmlElement));\n                assert.ok(joint.util.getElementBBox($htmlElement[0]));\n\n                assert.throws(function() {\n                    joint.util.getElementBBox('xxx');\n                });\n\n                assert.throws(function() {\n                    joint.util.getElementBBox();\n                });\n            });\n        });\n\n        QUnit.module('svg', function(hooks) {\n\n            hooks.beforeEach(function() {\n                this.svgDoc = V(V.createSvgDocument()).attr('style', 'position:absolute;top:50px;left:60px');\n                V($('body')[0]).append(this.svgDoc);\n            });\n\n            hooks.afterEach(function() {\n                this.svgDoc.remove();\n            });\n\n            QUnit.test('simple element', function(assert) {\n\n                var svgElement = V('<rect width=\"70\" height=\"80\"/>');\n                this.svgDoc.append(svgElement);\n\n                var bBox = joint.util.getElementBBox(svgElement.node);\n\n                assert.equal(bBox.x, 60);\n                assert.equal(bBox.y, 50);\n                assert.equal(bBox.width, 70);\n                assert.equal(bBox.height, 80);\n            });\n\n            QUnit.test('with position, with stroke', function(assert) {\n\n                // firefox measures differently - includes the stroke as well.\n                // joint.util.getElementBBox should return consistent values across all browsers.\n                var svgElement = V('<rect width=\"70\" height=\"80\" x=\"50\" y=\"50\" stroke-width=\"10\" stroke=\"red\"/>');\n                this.svgDoc.append(svgElement);\n\n                var bBox = joint.util.getElementBBox(svgElement.node);\n\n                assert.equal(bBox.x, 60 + 50);\n                assert.equal(bBox.y, 50 + 50);\n                assert.equal(bBox.width, 70);\n                assert.equal(bBox.height, 80);\n            });\n        });\n    });\n\n    QUnit.module('parseDOMJSON', function(hooks) {\n\n        var util = joint.util;\n\n        QUnit.test('sanity', function(assert) {\n            var res = util.parseDOMJSON([{ tagName: 'rect' }], V.namespace.xmls);\n            assert.ok(res.fragment instanceof DocumentFragment);\n            assert.equal(Object(res.selectors), res.selectors);\n        });\n\n        QUnit.module('tagName', function() {\n\n            QUnit.test('required', function(assert) {\n                assert.throws(function() {\n                    util.parseDOMJSON([{ /* tagName missing */ }]);\n                });\n            });\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'rect' }], V.namespace.xmls);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof SVGRectElement);\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div' }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof HTMLDivElement);\n            });\n        });\n\n        QUnit.module('attributes', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'rect',\n                    attributes: { 'fill': 'red', 'xlink:href': '#test' }\n                }]);\n                var node = res.fragment.firstChild;\n                assert.equal(node.attributes.getNamedItem('fill').value, 'red');\n                assert.equal(node.attributes.getNamedItemNS(V.namespace.xlink, 'href').value, '#test');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'div',\n                    attributes: { 'title': 'test' }\n                }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.equal(node.attributes.getNamedItem('title').value, 'test');\n            });\n        });\n\n        QUnit.module('style', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'rect',\n                    style: { 'fill': 'red' }\n                }]);\n                var node = res.fragment.firstChild;\n                assert.ok(/fill:/.test(node.attributes.getNamedItem('style').value));\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'div',\n                    style: { 'color': 'red' }\n                }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.ok(/color:/.test(node.attributes.getNamedItem('style').value));\n            });\n        });\n\n        QUnit.module('className', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'rect', className: 'test' }]);\n                var node = res.fragment.firstChild;\n                assert.equal(node.className.baseVal, 'test');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div', className: 'test' }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.equal(node.className, 'test');\n            });\n        });\n\n        QUnit.module('textContent', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'text', textContent: 'test' }]);\n                var node = res.fragment.firstChild;\n                assert.equal(node.textContent, 'test');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div', textContent: 'test' }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.equal(node.textContent, 'test');\n            });\n        });\n\n        QUnit.module('selector', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'rect', selector: 'test1' },\n                    { tagName: 'circle', selector: 'test2' }\n                ]);\n                assert.ok(res.selectors.test1 instanceof SVGRectElement);\n                assert.ok(res.selectors.test2 instanceof SVGCircleElement);\n                assert.equal(res.selectors.test1.getAttribute('joint-selector'), 'test1');\n                assert.equal(res.selectors.test2.getAttribute('joint-selector'), 'test2');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'div', selector: 'test1' },\n                    { tagName: 'img', selector: 'test2' },\n                ], V.namespace.xhtml);\n                assert.ok(res.selectors.test1 instanceof HTMLDivElement);\n                assert.ok(res.selectors.test2 instanceof HTMLImageElement);\n                assert.equal(res.selectors.test1.getAttribute('joint-selector'), 'test1');\n                assert.equal(res.selectors.test2.getAttribute('joint-selector'), 'test2');\n            });\n\n            QUnit.test('uniqueness', function(assert) {\n                assert.throws(function() {\n                    util.parseDOMJSON([\n                        { tagName: 'rect', selector: 'test' },\n                        { tagName: 'circle', selector: 'test' },\n                    ]);\n                });\n            });\n        });\n\n        QUnit.module('groupSelector', function() {\n\n            QUnit.test('svg - string', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'rect', groupSelector: 'test' },\n                    { tagName: 'circle' },\n                    { tagName: 'ellipse', groupSelector: 'test' }\n                ]);\n                assert.deepEqual(Object.keys(res.groupSelectors), ['test']);\n                assert.equal(res.groupSelectors.test.length, 2);\n                assert.ok(res.groupSelectors.test[0] instanceof SVGRectElement);\n                assert.ok(res.groupSelectors.test[1] instanceof SVGEllipseElement);\n            });\n\n            QUnit.test('html - string', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'div', groupSelector: 'test' },\n                    { tagName: 'img' },\n                    { tagName: 'p', groupSelector: 'test' },\n                ], V.namespace.xhtml);\n                assert.deepEqual(Object.keys(res.groupSelectors), ['test']);\n                assert.equal(res.groupSelectors.test.length, 2);\n                assert.ok(res.groupSelectors.test[0] instanceof HTMLDivElement);\n                assert.ok(res.groupSelectors.test[1] instanceof HTMLParagraphElement);\n            });\n\n            QUnit.test('svg - array', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'rect', groupSelector: ['test0', 'test1'] },\n                    { tagName: 'circle', groupSelector: ['test1', 'test2'] },\n                    { tagName: 'ellipse', groupSelector: ['test0', 'test2'] }\n                ]);\n                assert.deepEqual(Object.keys(res.groupSelectors).sort(), ['test0', 'test1', 'test2']);\n                assert.equal(res.groupSelectors.test0.length, 2);\n                assert.equal(res.groupSelectors.test1.length, 2);\n                assert.equal(res.groupSelectors.test2.length, 2);\n                assert.ok(res.groupSelectors.test0[0] instanceof SVGRectElement);\n                assert.ok(res.groupSelectors.test0[1] instanceof SVGEllipseElement);\n                assert.ok(res.groupSelectors.test1[0] instanceof SVGRectElement);\n                assert.ok(res.groupSelectors.test1[1] instanceof SVGCircleElement);\n                assert.ok(res.groupSelectors.test2[0] instanceof SVGCircleElement);\n                assert.ok(res.groupSelectors.test2[1] instanceof SVGEllipseElement);\n            });\n\n            QUnit.test('html - array', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'div', groupSelector: ['test0', 'test1'] },\n                    { tagName: 'img', groupSelector: ['test1', 'test2'] },\n                    { tagName: 'p', groupSelector: ['test0', 'test2'] },\n                ], V.namespace.xhtml);\n                assert.deepEqual(Object.keys(res.groupSelectors).sort(), ['test0', 'test1', 'test2']);\n                assert.equal(res.groupSelectors.test0.length, 2);\n                assert.equal(res.groupSelectors.test1.length, 2);\n                assert.equal(res.groupSelectors.test2.length, 2);\n                assert.ok(res.groupSelectors.test0[0] instanceof HTMLDivElement);\n                assert.ok(res.groupSelectors.test0[1] instanceof HTMLParagraphElement);\n                assert.ok(res.groupSelectors.test1[0] instanceof HTMLDivElement);\n                assert.ok(res.groupSelectors.test1[1] instanceof HTMLImageElement);\n                assert.ok(res.groupSelectors.test2[0] instanceof HTMLImageElement);\n                assert.ok(res.groupSelectors.test2[1] instanceof HTMLParagraphElement);\n            });\n\n\n        });\n\n        QUnit.module('namespaceURI', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'rect', namespaceURI: V.namespace.svg }]);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof SVGRectElement);\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div', namespaceURI: V.namespace.xhtml }]);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof HTMLDivElement);\n            });\n        });\n\n        QUnit.module('children', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'g',\n                    children: [{ tagName: 'rect' }, { tagName: 'circle' }]\n                }]);\n                var group = res.fragment.firstChild;\n                assert.ok(group instanceof SVGGElement);\n                assert.ok(group.firstChild instanceof SVGRectElement);\n                assert.ok(group.lastChild instanceof SVGCircleElement);\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'div',\n                    children: [{ tagName: 'p' }, { tagName: 'img' }]\n                }], V.namespace.xhtml);\n                var div = res.fragment.firstChild;\n                assert.ok(div instanceof HTMLDivElement);\n                assert.ok(div.firstChild instanceof HTMLParagraphElement);\n                assert.ok(div.lastChild instanceof HTMLImageElement);\n            });\n        });\n    });\n});\n"], "fixing_code": ["import _ from 'lodash';\nimport $ from 'jquery';\nimport V from '../V/index.mjs';\nimport { config } from '../config/index.mjs';\n\nexport const addClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, config.classNamePrefix.length) !== config.classNamePrefix) {\n            _className = config.classNamePrefix + _className;\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nexport const removeClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, config.classNamePrefix.length) === config.classNamePrefix) {\n            _className = _className.substr(config.classNamePrefix.length);\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nexport const parseDOMJSON = function(json, namespace) {\n\n    var selectors = {};\n    var groupSelectors = {};\n    var svgNamespace = V.namespace.svg;\n\n    var ns = namespace || svgNamespace;\n    var fragment = document.createDocumentFragment();\n    var queue = [json, fragment, ns];\n    while (queue.length > 0) {\n        ns = queue.pop();\n        var parentNode = queue.pop();\n        var siblingsDef = queue.pop();\n        for (var i = 0, n = siblingsDef.length; i < n; i++) {\n            var nodeDef = siblingsDef[i];\n            // TagName\n            if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');\n            var tagName = nodeDef.tagName;\n            // Namespace URI\n            if (nodeDef.hasOwnProperty('namespaceURI')) ns = nodeDef.namespaceURI;\n            var node = document.createElementNS(ns, tagName);\n            var svg = (ns === svgNamespace);\n\n            var wrapper = (svg) ? V : $;\n            // Attributes\n            var attributes = nodeDef.attributes;\n            if (attributes) wrapper(node).attr(attributes);\n            // Style\n            var style = nodeDef.style;\n            if (style) $(node).css(style);\n            // ClassName\n            if (nodeDef.hasOwnProperty('className')) {\n                var className = nodeDef.className;\n                if (svg) {\n                    node.className.baseVal = className;\n                } else {\n                    node.className = className;\n                }\n            }\n            // TextContent\n            if (nodeDef.hasOwnProperty('textContent')) {\n                node.textContent = nodeDef.textContent;\n            }\n            // Selector\n            if (nodeDef.hasOwnProperty('selector')) {\n                var nodeSelector = nodeDef.selector;\n                if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');\n                selectors[nodeSelector] = node;\n                wrapper(node).attr('joint-selector', nodeSelector);\n            }\n            // Groups\n            if (nodeDef.hasOwnProperty('groupSelector')) {\n                var nodeGroups = nodeDef.groupSelector;\n                if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];\n                for (var j = 0, m = nodeGroups.length; j < m; j++) {\n                    var nodeGroup = nodeGroups[j];\n                    var group = groupSelectors[nodeGroup];\n                    if (!group) group = groupSelectors[nodeGroup] = [];\n                    group.push(node);\n                }\n            }\n            parentNode.appendChild(node);\n            // Children\n            var childrenDef = nodeDef.children;\n            if (Array.isArray(childrenDef)) queue.push(childrenDef, node, ns);\n        }\n    }\n    return {\n        fragment: fragment,\n        selectors: selectors,\n        groupSelectors: groupSelectors\n    };\n};\n\n// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\nexport const hashCode = function(str) {\n\n    let hash = 0;\n    if (str.length === 0) return hash;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + c;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\n\nexport const getByPath = function(obj, path, delimiter) {\n\n    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    var key;\n    var i = 0;\n    var length = keys.length;\n    while (i < length) {\n        key = keys[i++];\n        if (Object(obj) === obj && key in obj) {\n            obj = obj[key];\n        } else {\n            return undefined;\n        }\n    }\n    return obj;\n};\n\nconst isGetSafe = function(obj, key) {\n    // Prevent prototype pollution\n    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n    if (typeof key !== 'string' && typeof key !== 'number') {\n        key = String(key);\n    }\n    if (key === 'constructor' && typeof obj[key] === 'function') {\n        return false;\n    }\n    if (key === '__proto__') {\n        return false;\n    }\n    return true;\n};\n\nexport const setByPath = function(obj, path, value, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        // diver creates an empty object if there is no nested object under such a key.\n        // This means that one can populate an empty nested object with setByPath().\n        diver = value || (diver[key] = {});\n    }\n\n    diver[keys[last]] = value;\n\n    return obj;\n};\n\nexport const unsetByPath = function(obj, path, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        if (!value) return obj;\n        diver = value;\n    }\n\n    delete diver[keys[last]];\n\n    return obj;\n};\n\nexport const flattenObject = function(obj, delim, stop) {\n\n    delim = delim || '/';\n    var ret = {};\n\n    for (var key in obj) {\n\n        if (!obj.hasOwnProperty(key)) continue;\n\n        var shouldGoDeeper = typeof obj[key] === 'object';\n        if (shouldGoDeeper && stop && stop(obj[key])) {\n            shouldGoDeeper = false;\n        }\n\n        if (shouldGoDeeper) {\n\n            var flatObject = flattenObject(obj[key], delim, stop);\n\n            for (var flatKey in flatObject) {\n                if (!flatObject.hasOwnProperty(flatKey)) continue;\n                ret[key + delim + flatKey] = flatObject[flatKey];\n            }\n\n        } else {\n\n            ret[key] = obj[key];\n        }\n    }\n\n    return ret;\n};\n\nexport const uuid = function() {\n\n    // credit: http://stackoverflow.com/posts/2117523/revisions\n\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0;\n        var v = (c === 'x') ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n};\n\n// Generate global unique id for obj and store it as a property of the object.\nexport const guid = function(obj) {\n\n    guid.id = guid.id || 1;\n    obj.id = (obj.id === undefined ? 'j_' + guid.id++ : obj.id);\n    return obj.id;\n};\n\nexport const toKebabCase = function(string) {\n\n    return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n\nexport const normalizeEvent = function(evt) {\n\n    var normalizedEvent = evt;\n    var touchEvt = evt.originalEvent && evt.originalEvent.changedTouches && evt.originalEvent.changedTouches[0];\n    if (touchEvt) {\n        for (var property in evt) {\n            // copy all the properties from the input event that are not\n            // defined on the touch event (functions included).\n            if (touchEvt[property] === undefined) {\n                touchEvt[property] = evt[property];\n            }\n        }\n        normalizedEvent = touchEvt;\n    }\n\n    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n    var target = normalizedEvent.target;\n    if (target) {\n        var useElement = target.correspondingUseElement;\n        if (useElement) normalizedEvent.target = useElement;\n    }\n\n    return normalizedEvent;\n};\n\nexport const nextFrame = (function() {\n\n    var raf;\n\n    if (typeof window !== 'undefined') {\n\n        raf = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame;\n    }\n\n    if (!raf) {\n\n        var lastTime = 0;\n\n        raf = function(callback) {\n\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n\n            lastTime = currTime + timeToCall;\n\n            return id;\n        };\n    }\n\n    return function(callback, context, ...rest) {\n        return (context !== undefined)\n            ? raf(callback.bind(context, ...rest))\n            : raf(callback);\n    };\n\n})();\n\nexport const cancelFrame = (function() {\n\n    var caf;\n    var client = typeof window != 'undefined';\n\n    if (client) {\n\n        caf = window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.webkitCancelRequestAnimationFrame ||\n            window.msCancelAnimationFrame ||\n            window.msCancelRequestAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            window.oCancelRequestAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.mozCancelRequestAnimationFrame;\n    }\n\n    caf = caf || clearTimeout;\n\n    return client ? caf.bind(window) : caf;\n\n})();\n\n/**\n * @deprecated\n */\nexport const shapePerimeterConnectionPoint = function(linkView, view, magnet, reference) {\n\n    var bbox;\n    var spot;\n\n    if (!magnet) {\n\n        // There is no magnet, try to make the best guess what is the\n        // wrapping SVG element. This is because we want this \"smart\"\n        // connection points to work out of the box without the\n        // programmer to put magnet marks to any of the subelements.\n        // For example, we want the function to work on basic.Path elements\n        // without any special treatment of such elements.\n        // The code below guesses the wrapping element based on\n        // one simple assumption. The wrapping elemnet is the\n        // first child of the scalable group if such a group exists\n        // or the first child of the rotatable group if not.\n        // This makese sense because usually the wrapping element\n        // is below any other sub element in the shapes.\n        var scalable = view.$('.scalable')[0];\n        var rotatable = view.$('.rotatable')[0];\n\n        if (scalable && scalable.firstChild) {\n\n            magnet = scalable.firstChild;\n\n        } else if (rotatable && rotatable.firstChild) {\n\n            magnet = rotatable.firstChild;\n        }\n    }\n\n    if (magnet) {\n\n        spot = V(magnet).findIntersection(reference, linkView.paper.cells);\n        if (!spot) {\n            bbox = V(magnet).getBBox({ target: linkView.paper.cells });\n        }\n\n    } else {\n\n        bbox = view.model.getBBox();\n        spot = bbox.intersectionWithLineFromCenterToPoint(reference);\n    }\n    return spot || bbox.center();\n};\n\nexport const isPercentage = function(val) {\n\n    return isString(val) && val.slice(-1) === '%';\n};\n\nexport const parseCssNumeric = function(val, restrictUnits) {\n\n    function getUnit(validUnitExp) {\n\n        // one or more numbers, followed by\n        // any number of (\n        //  `.`, followed by\n        //  one or more numbers\n        // ), followed by\n        // `validUnitExp`, followed by\n        // end of string\n        var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\n        if (!matches) return null;\n        return matches[1];\n    }\n\n    var number = parseFloat(val);\n\n    // if `val` cannot be parsed as a number, return `null`\n    if (Number.isNaN(number)) return null;\n\n    // else: we know `output.value`\n    var output = {};\n    output.value = number;\n\n    // determine the unit\n    var validUnitExp;\n    if (restrictUnits == null) {\n        // no restriction\n        // accept any unit, as well as no unit\n        validUnitExp = '[A-Za-z]*';\n\n    } else if (Array.isArray(restrictUnits)) {\n        // if this is an empty array, top restriction - return `null`\n        if (restrictUnits.length === 0) return null;\n\n        // else: restriction - an array of valid unit strings\n        validUnitExp = restrictUnits.join('|');\n\n    } else if (isString(restrictUnits)) {\n        // restriction - a single valid unit string\n        validUnitExp = restrictUnits;\n    }\n    var unit = getUnit(validUnitExp);\n\n    // if we found no matches for `restrictUnits`, return `null`\n    if (unit === null) return null;\n\n    // else: we know the unit\n    output.unit = unit;\n    return output;\n};\n\nexport const breakText = function(text, size, styles = {}, opt = {}) {\n\n    var width = size.width;\n    var height = size.height;\n\n    var svgDocument = opt.svgDocument || V('svg').node;\n    var textSpan = V('tspan').node;\n    var textElement = V('text').attr(styles).append(textSpan).node;\n    var textNode = document.createTextNode('');\n\n    // Prevent flickering\n    textElement.style.opacity = 0;\n    // Prevent FF from throwing an uncaught exception when `getBBox()`\n    // called on element that is not in the render tree (is not measurable).\n    // <tspan>.getComputedTextLength() returns always 0 in this case.\n    // Note that the `textElement` resp. `textSpan` can become hidden\n    // when it's appended to the DOM and a `display: none` CSS stylesheet\n    // rule gets applied.\n    textElement.style.display = 'block';\n    textSpan.style.display = 'block';\n\n    textSpan.appendChild(textNode);\n    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n    if (!opt.svgDocument) {\n\n        document.body.appendChild(svgDocument);\n    }\n\n    var separator = opt.separator || ' ';\n    var eol = opt.eol || '\\n';\n    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d]/;\n    var maxLineCount = opt.maxLineCount;\n    if (!isNumber(maxLineCount)) maxLineCount = Infinity;\n\n    var words = text.split(separator);\n    var full = [];\n    var lines = [];\n    var p, h;\n    var lineHeight;\n\n    for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\n        var word = words[i];\n\n        if (!word) continue;\n\n        var isEol = false;\n        if (eol && word.indexOf(eol) >= 0) {\n            // word contains end-of-line character\n            if (word.length > 1) {\n                // separate word and continue cycle\n                var eolWords = word.split(eol);\n                for (var j = 0, jl = eolWords.length - 1; j < jl; j++) {\n                    eolWords.splice(2 * j + 1, 0, eol);\n                }\n                words.splice(i, 1, ...eolWords.filter(word => word !== ''));\n                i--;\n                len = words.length;\n                continue;\n            } else {\n                // creates a new line\n                lines[++l] = '';\n                isEol = true;\n            }\n        }\n\n        if (!isEol) {\n            textNode.data = lines[l] ? lines[l] + ' ' + word : word;\n\n            if (textSpan.getComputedTextLength() <= width) {\n\n                // the current line fits\n                lines[l] = textNode.data;\n\n                if (p || h) {\n                // We were partitioning. Put rest of the word onto next line\n                    full[l++] = true;\n\n                    // cancel partitioning and splitting by hyphens\n                    p = 0;\n                    h = 0;\n                }\n\n            } else {\n\n                if (!lines[l] || p) {\n\n                    var partition = !!p;\n\n                    p = word.length - 1;\n\n                    if (partition || !p) {\n\n                        // word has only one character.\n                        if (!p) {\n\n                            if (!lines[l]) {\n\n                                // we won't fit this text within our rect\n                                lines = [];\n\n                                break;\n                            }\n\n                            // partitioning didn't help on the non-empty line\n                            // try again, but this time start with a new line\n\n                            // cancel partitions created\n                            words.splice(i, 2, word + words[i + 1]);\n\n                            // adjust word length\n                            len--;\n\n                            full[l++] = true;\n                            i--;\n\n                            continue;\n                        }\n\n                        // move last letter to the beginning of the next word\n                        words[i] = word.substring(0, p);\n                        words[i + 1] = word.substring(p) + (words[i + 1] === undefined ? '' : words[i + 1]);\n\n                    } else {\n\n                        if (h) {\n                        // cancel splitting and put the words together again\n                            words.splice(i, 2, words[i] + words[i + 1]);\n                            h = 0;\n                        } else {\n                            var hyphenIndex = word.search(hyphen);\n                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n                                h = hyphenIndex + 1;\n                                p = 0;\n                            }\n\n                            // We initiate partitioning or splitting\n                            // split the long word into two words\n                            words.splice(i, 1, word.substring(0, h || p), word.substring(h|| p));\n                            // adjust words length\n                            len++;\n\n                        }\n\n                        if (l && !full[l - 1]) {\n                        // if the previous line is not full, try to fit max part of\n                        // the current word there\n                            l--;\n                        }\n                    }\n\n                    i--;\n\n                    continue;\n                }\n\n                l++;\n                i--;\n            }\n        }\n        var lastL = null;\n\n        if (lines.length > maxLineCount) {\n\n            lastL = maxLineCount - 1;\n\n        } else if (height !== undefined) {\n\n            // if size.height is defined we have to check whether the height of the entire\n            // text exceeds the rect height\n\n            if (lineHeight === undefined) {\n\n                var heightValue;\n\n                // use the same defaults as in V.prototype.text\n                if (styles.lineHeight === 'auto') {\n                    heightValue = { value: 1.5, unit: 'em' };\n                } else {\n                    heightValue = parseCssNumeric(styles.lineHeight, ['em']) || { value: 1, unit: 'em' };\n                }\n\n                lineHeight = heightValue.value;\n                if (heightValue.unit === 'em') {\n                    lineHeight *= textElement.getBBox().height;\n                }\n            }\n\n            if (lineHeight * lines.length > height) {\n\n                // remove overflowing lines\n                lastL = Math.floor(height / lineHeight) - 1;\n            }\n        }\n\n        if (lastL !== null) {\n\n            lines.splice(lastL + 1);\n\n            // add ellipsis\n            var ellipsis = opt.ellipsis;\n            if (!ellipsis || lastL < 0) break;\n            if (typeof ellipsis !== 'string') ellipsis = '\\u2026';\n\n            var lastLine = lines[lastL];\n            if (!lastLine && !isEol) break;\n            var k = lastLine.length;\n            var lastLineWithOmission, lastChar, separatorChar;\n            do {\n                lastChar = lastLine[k];\n                lastLineWithOmission = lastLine.substring(0, k);\n                if (!lastChar) {\n                    separatorChar = (typeof separator === 'string') ? separator : ' ';\n                    lastLineWithOmission += separatorChar;\n                } else if (lastChar.match(separator)) {\n                    lastLineWithOmission += lastChar;\n                }\n                lastLineWithOmission += ellipsis;\n                textNode.data = lastLineWithOmission;\n                if (textSpan.getComputedTextLength() <= width) {\n                    lines[lastL] = lastLineWithOmission;\n                    break;\n                }\n                k--;\n            } while (k >= 0);\n            break;\n        }\n    }\n\n    if (opt.svgDocument) {\n\n        // svg document was provided, remove the text element only\n        svgDocument.removeChild(textElement);\n\n    } else {\n\n        // clean svg document\n        document.body.removeChild(svgDocument);\n    }\n\n    return lines.join(eol);\n};\n\n// Sanitize HTML\n// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n// Parses a string into an array of DOM nodes.\n// Then outputs it back as a string.\nexport const sanitizeHTML = function(html) {\n\n    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n\n    // If documentContext (second parameter) is not specified or given as `null` or `undefined`, a new document is used.\n    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n\n    // If keepScripts (last parameter) is `false`, scripts are not executed.\n    var output = $($.parseHTML('<div>' + html + '</div>', null, false));\n\n    output.find('*').each(function() { // for all nodes\n        var currentNode = this;\n\n        $.each(currentNode.attributes, function() { // for all attributes in each node\n            var currentAttribute = this;\n\n            var attrName = currentAttribute.name;\n            var attrValue = currentAttribute.value;\n\n            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n            if (attrName.startsWith('on') || attrValue.startsWith('javascript:') || attrValue.startsWith('data:') || attrValue.startsWith('vbscript:')) {\n                $(currentNode).removeAttr(attrName);\n            }\n        });\n    });\n\n    return output.html();\n};\n\n// Download `blob` as file with `fileName`.\n// Does not work in IE9.\nexport const downloadBlob = function(blob, fileName) {\n\n    if (window.navigator.msSaveBlob) { // requires IE 10+\n        // pulls up a save dialog\n        window.navigator.msSaveBlob(blob, fileName);\n\n    } else { // other browsers\n        // downloads directly in Chrome and Safari\n\n        // presents a save/open dialog in Firefox\n        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement('a');\n\n        link.href = url;\n        link.download = fileName;\n        document.body.appendChild(link);\n\n        link.click();\n\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n    }\n};\n\n// Download `dataUri` as file with `fileName`.\n// Does not work in IE9.\nexport const downloadDataUri = function(dataUri, fileName) {\n\n    const blob = dataUriToBlob(dataUri);\n    downloadBlob(blob, fileName);\n};\n\n// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\nexport const dataUriToBlob = function(dataUri) {\n\n    // first, make sure there are no newlines in the data uri\n    dataUri = dataUri.replace(/\\s/g, '');\n    dataUri = decodeURIComponent(dataUri);\n\n    var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n    var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n    var data = dataUri.slice(firstCommaIndex + 1);\n    var decodedString;\n    if (dataTypeString.indexOf('base64') >= 0) { // data may be encoded in base64\n        decodedString = atob(data); // decode data\n    } else {\n        // convert the decoded string to UTF-8\n        decodedString = unescape(encodeURIComponent(data));\n    }\n    // write the bytes of the string to a typed array\n    var ia = new Uint8Array(decodedString.length);\n    for (var i = 0; i < decodedString.length; i++) {\n        ia[i] = decodedString.charCodeAt(i);\n    }\n\n    return new Blob([ia], { type: mimeString }); // return the typed array as Blob\n};\n\n// Read an image at `url` and return it as base64-encoded data uri.\n// The mime type of the image is inferred from the `url` file extension.\n// If data uri is provided as `url`, it is returned back unchanged.\n// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n// Works with IE9.\nexport const imageToDataUri = function(url, callback) {\n\n    if (!url || url.substr(0, 'data:'.length) === 'data:') {\n        // No need to convert to data uri if it is already in data uri.\n\n        // This not only convenient but desired. For example,\n        // IE throws a security error if data:image/svg+xml is used to render\n        // an image to the canvas and an attempt is made to read out data uri.\n        // Now if our image is already in data uri, there is no need to render it to the canvas\n        // and so we can bypass this error.\n\n        // Keep the async nature of the function.\n        return setTimeout(function() {\n            callback(null, url);\n        }, 0);\n    }\n\n    // chrome, IE10+\n    var modernHandler = function(xhr, callback) {\n\n        if (xhr.status === 200) {\n\n            var reader = new FileReader();\n\n            reader.onload = function(evt) {\n                var dataUri = evt.target.result;\n                callback(null, dataUri);\n            };\n\n            reader.onerror = function() {\n                callback(new Error('Failed to load image ' + url));\n            };\n\n            reader.readAsDataURL(xhr.response);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var legacyHandler = function(xhr, callback) {\n\n        var Uint8ToString = function(u8a) {\n            var CHUNK_SZ = 0x8000;\n            var c = [];\n            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n            }\n            return c.join('');\n        };\n\n        if (xhr.status === 200) {\n\n            var bytes = new Uint8Array(xhr.response);\n\n            var suffix = (url.split('.').pop()) || 'png';\n            var map = {\n                'svg': 'svg+xml'\n            };\n            var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n            var b64encoded = meta + btoa(Uint8ToString(bytes));\n            callback(null, b64encoded);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.open('GET', url, true);\n    xhr.addEventListener('error', function() {\n        callback(new Error('Failed to load image ' + url));\n    });\n\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\n    xhr.addEventListener('load', function() {\n        if (window.FileReader) {\n            modernHandler(xhr, callback);\n        } else {\n            legacyHandler(xhr, callback);\n        }\n    });\n\n    xhr.send();\n};\n\nexport const getElementBBox = function(el) {\n\n    var $el = $(el);\n    if ($el.length === 0) {\n        throw new Error('Element not found');\n    }\n\n    var element = $el[0];\n    var doc = element.ownerDocument;\n    var clientBBox = element.getBoundingClientRect();\n\n    var strokeWidthX = 0;\n    var strokeWidthY = 0;\n\n    // Firefox correction\n    if (element.ownerSVGElement) {\n\n        var vel = V(element);\n        var bbox = vel.getBBox({ target: vel.svg() });\n\n        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n        strokeWidthX = (clientBBox.width - bbox.width);\n        strokeWidthY = (clientBBox.height - bbox.height);\n    }\n\n    return {\n        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n        width: clientBBox.width - strokeWidthX,\n        height: clientBBox.height - strokeWidthY\n    };\n};\n\n\n// Highly inspired by the jquery.sortElements plugin by Padolsey.\n// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\nexport const sortElements = function(elements, comparator) {\n\n    var $elements = $(elements);\n    var placements = $elements.map(function() {\n\n        var sortElement = this;\n        var parentNode = sortElement.parentNode;\n        // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n        var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\n        return function() {\n\n            if (parentNode === this) {\n                throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n            }\n\n            // Insert before flag:\n            parentNode.insertBefore(this, nextSibling);\n            // Remove flag:\n            parentNode.removeChild(nextSibling);\n        };\n    });\n\n    return Array.prototype.sort.call($elements, comparator).each(function(i) {\n        placements[i].call(this);\n    });\n};\n\n// Sets attributes on the given element and its descendants based on the selector.\n// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\nexport const setAttributesBySelector = function(element, attrs) {\n\n    var $element = $(element);\n\n    forIn(attrs, function(attrs, selector) {\n        var $elements = $element.find(selector).addBack().filter(selector);\n        // Make a special case for setting classes.\n        // We do not want to overwrite any existing class.\n        if (has(attrs, 'class')) {\n            $elements.addClass(attrs['class']);\n            attrs = omit(attrs, 'class');\n        }\n        $elements.attr(attrs);\n    });\n};\n\n// Return a new object with all four sides (top, right, bottom, left) in it.\n// Value of each side is taken from the given argument (either number or object).\n// Default value for a side is 0.\n// Examples:\n// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\nexport const normalizeSides = function(box) {\n\n    if (Object(box) !== box) { // `box` is not an object\n        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n        if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n\n        return { top: val, right: val, bottom: val, left: val };\n    }\n\n    // `box` is an object\n    var top, right, bottom, left;\n    top = right = bottom = left = 0;\n\n    if (isFinite(box.vertical)) top = bottom = +box.vertical;\n    if (isFinite(box.horizontal)) right = left = +box.horizontal;\n\n    if (isFinite(box.top)) top = +box.top; // overwrite vertical\n    if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n    if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n    if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n\n    return { top: top, right: right, bottom: bottom, left: left };\n};\n\nexport const timing = {\n\n    linear: function(t) {\n        return t;\n    },\n\n    quad: function(t) {\n        return t * t;\n    },\n\n    cubic: function(t) {\n        return t * t * t;\n    },\n\n    inout: function(t) {\n        if (t <= 0) return 0;\n        if (t >= 1) return 1;\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n    },\n\n    exponential: function(t) {\n        return Math.pow(2, 10 * (t - 1));\n    },\n\n    bounce: function(t) {\n        for (var a = 0, b = 1; 1; a += b, b /= 2) {\n            if (t >= (7 - 4 * a) / 11) {\n                var q = (11 - 6 * a - 11 * t) / 4;\n                return -q * q + b * b;\n            }\n        }\n    },\n\n    reverse: function(f) {\n        return function(t) {\n            return 1 - f(1 - t);\n        };\n    },\n\n    reflect: function(f) {\n        return function(t) {\n            return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n        };\n    },\n\n    clamp: function(f, n, x) {\n        n = n || 0;\n        x = x || 1;\n        return function(t) {\n            var r = f(t);\n            return r < n ? n : r > x ? x : r;\n        };\n    },\n\n    back: function(s) {\n        if (!s) s = 1.70158;\n        return function(t) {\n            return t * t * ((s + 1) * t - s);\n        };\n    },\n\n    elastic: function(x) {\n        if (!x) x = 1.5;\n        return function(t) {\n            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n        };\n    }\n};\n\nexport const interpolate = {\n\n    number: function(a, b) {\n        var d = b - a;\n        return function(t) {\n            return a + d * t;\n        };\n    },\n\n    object: function(a, b) {\n        var s = Object.keys(a);\n        return function(t) {\n            var i, p;\n            var r = {};\n            for (i = s.length - 1; i != -1; i--) {\n                p = s[i];\n                r[p] = a[p] + (b[p] - a[p]) * t;\n            }\n            return r;\n        };\n    },\n\n    hexColor: function(a, b) {\n\n        var ca = parseInt(a.slice(1), 16);\n        var cb = parseInt(b.slice(1), 16);\n        var ra = ca & 0x0000ff;\n        var rd = (cb & 0x0000ff) - ra;\n        var ga = ca & 0x00ff00;\n        var gd = (cb & 0x00ff00) - ga;\n        var ba = ca & 0xff0000;\n        var bd = (cb & 0xff0000) - ba;\n\n        return function(t) {\n\n            var r = (ra + rd * t) & 0x000000ff;\n            var g = (ga + gd * t) & 0x0000ff00;\n            var b = (ba + bd * t) & 0x00ff0000;\n\n            return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n        };\n    },\n\n    unit: function(a, b) {\n\n        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n        var ma = r.exec(a);\n        var mb = r.exec(b);\n        var p = mb[1].indexOf('.');\n        var f = p > 0 ? mb[1].length - p - 1 : 0;\n        a = +ma[1];\n        var d = +mb[1] - a;\n        var u = ma[2];\n\n        return function(t) {\n            return (a + d * t).toFixed(f) + u;\n        };\n    }\n};\n\n// SVG filters.\n// (values in parentheses are default values)\nexport const filter = {\n\n    // `color` ... outline color ('blue')\n    // `width`... outline width (1)\n    // `opacity` ... outline opacity (1)\n    // `margin` ... gap between outline and the element (2)\n    outline: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n        var width = Number.isFinite(args.width) ? args.width : 1;\n\n        return template(tpl)({\n            color: args.color || 'blue',\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            outerRadius: margin + width,\n            innerRadius: margin\n        });\n    },\n\n    // `color` ... color ('red')\n    // `width`... width (1)\n    // `blur` ... blur (0)\n    // `opacity` ... opacity (1)\n    highlight: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\n        return template(tpl)({\n            color: args.color || 'red',\n            width: Number.isFinite(args.width) ? args.width : 1,\n            blur: Number.isFinite(args.blur) ? args.blur : 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n        });\n    },\n\n    // `x` ... horizontal blur (2)\n    // `y` ... vertical blur (optional)\n    blur: function(args) {\n\n        var x = Number.isFinite(args.x) ? args.x : 2;\n\n        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n        });\n    },\n\n    // `dx` ... horizontal shift (0)\n    // `dy` ... vertical shift (0)\n    // `blur` ... blur (4)\n    // `color` ... color ('black')\n    // `opacity` ... opacity (1)\n    dropShadow: function(args) {\n\n        var tpl = 'SVGFEDropShadowElement' in window\n            ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\n            : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        return template(tpl)({\n            dx: args.dx || 0,\n            dy: args.dy || 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            color: args.color || 'black',\n            blur: Number.isFinite(args.blur) ? args.blur : 4\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n    grayscale: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n    sepia: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n    saturate: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n            amount: 1 - amount\n        });\n    },\n\n    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n    hueRotate: function(args) {\n\n        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n            angle: args.angle || 0\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n    invert: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: 1 - amount\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    brightness: function(args) {\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n            amount: Number.isFinite(args.amount) ? args.amount : 1\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    contrast: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    }\n};\n\nexport const format = {\n\n    // Formatting numbers via the Python Format Specification Mini-language.\n    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n    // Heavilly inspired by the D3.js library implementation.\n    number: function(specifier, value, locale) {\n\n        locale = locale || {\n\n            currency: ['$', ''],\n            decimal: '.',\n            thousands: ',',\n            grouping: [3]\n        };\n\n        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\n        var match = re.exec(specifier);\n        var fill = match[1] || ' ';\n        var align = match[2] || '>';\n        var sign = match[3] || '';\n        var symbol = match[4] || '';\n        var zfill = match[5];\n        var width = +match[6];\n        var comma = match[7];\n        var precision = match[8];\n        var type = match[9];\n        var scale = 1;\n        var prefix = '';\n        var suffix = '';\n        var integer = false;\n\n        if (precision) precision = +precision.substring(1);\n\n        if (zfill || fill === '0' && align === '=') {\n            zfill = fill = '0';\n            align = '=';\n            if (comma) width -= Math.floor((width - 1) / 4);\n        }\n\n        switch (type) {\n            case 'n':\n                comma = true;\n                type = 'g';\n                break;\n            case '%':\n                scale = 100;\n                suffix = '%';\n                type = 'f';\n                break;\n            case 'p':\n                scale = 100;\n                suffix = '%';\n                type = 'r';\n                break;\n            case 'b':\n            case 'o':\n            case 'x':\n            case 'X':\n                if (symbol === '#') prefix = '0' + type.toLowerCase();\n                break;\n            case 'c':\n            case 'd':\n                integer = true;\n                precision = 0;\n                break;\n            case 's':\n                scale = -1;\n                type = 'r';\n                break;\n        }\n\n        if (symbol === '$') {\n            prefix = locale.currency[0];\n            suffix = locale.currency[1];\n        }\n\n        // If no precision is specified for `'r'`, fallback to general notation.\n        if (type == 'r' && !precision) type = 'g';\n\n        // Ensure that the requested precision is in the supported range.\n        if (precision != null) {\n            if (type == 'g') precision = Math.max(1, Math.min(21, precision));\n            else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\n        }\n\n        var zcomma = zfill && comma;\n\n        // Return the empty string for floats formatted as ints.\n        if (integer && (value % 1)) return '';\n\n        // Convert negative to positive, and record the sign prefix.\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\n        var fullSuffix = suffix;\n\n        // Apply the scale, computing it from the value's exponent for si format.\n        // Preserve the existing suffix, if any, such as the currency symbol.\n        if (scale < 0) {\n            var unit = this.prefix(value, precision);\n            value = unit.scale(value);\n            fullSuffix = unit.symbol + suffix;\n        } else {\n            value *= scale;\n        }\n\n        // Convert to the desired precision.\n        value = this.convert(type, value, precision);\n\n        // Break the value into the integer part (before) and decimal part (after).\n        var i = value.lastIndexOf('.');\n        var before = i < 0 ? value : value.substring(0, i);\n        var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\n        function formatGroup(value) {\n\n            var i = value.length;\n            var t = [];\n            var j = 0;\n            var g = locale.grouping[0];\n            while (i > 0 && g > 0) {\n                t.push(value.substring(i -= g, i + g));\n                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n            }\n            return t.reverse().join(locale.thousands);\n        }\n\n        // If the fill character is not `'0'`, grouping is applied before padding.\n        if (!zfill && comma && locale.grouping) {\n\n            before = formatGroup(before);\n        }\n\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n        var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n        // If the fill character is `'0'`, grouping is applied after padding.\n        if (zcomma) before = formatGroup(padding + before);\n\n        // Apply prefix.\n        negative += prefix;\n\n        // Rejoin integer and decimal parts.\n        value = before + after;\n\n        return (align === '<' ? negative + value + padding\n            : align === '>' ? padding + negative + value\n                : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\n                    : negative + (zcomma ? value : padding + value)) + fullSuffix;\n    },\n\n    // Formatting string via the Python Format string.\n    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n    string: function(formatString, value) {\n\n        var fieldDelimiterIndex;\n        var fieldDelimiter = '{';\n        var endPlaceholder = false;\n        var formattedStringArray = [];\n\n        while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\n            var pieceFormattedString, formatSpec, fieldName;\n\n            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\n            if (endPlaceholder) {\n                formatSpec = pieceFormattedString.split(':');\n                fieldName = formatSpec.shift().split('.');\n                pieceFormattedString = value;\n\n                for (var i = 0; i < fieldName.length; i++)\n                    pieceFormattedString = pieceFormattedString[fieldName[i]];\n\n                if (formatSpec.length)\n                    pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n            }\n\n            formattedStringArray.push(pieceFormattedString);\n\n            formatString = formatString.slice(fieldDelimiterIndex + 1);\n            endPlaceholder = !endPlaceholder;\n            fieldDelimiter = (endPlaceholder) ? '}' : '{';\n        }\n        formattedStringArray.push(formatString);\n\n        return formattedStringArray.join('');\n    },\n\n    convert: function(type, value, precision) {\n\n        switch (type) {\n            case 'b':\n                return value.toString(2);\n            case 'c':\n                return String.fromCharCode(value);\n            case 'o':\n                return value.toString(8);\n            case 'x':\n                return value.toString(16);\n            case 'X':\n                return value.toString(16).toUpperCase();\n            case 'g':\n                return value.toPrecision(precision);\n            case 'e':\n                return value.toExponential(precision);\n            case 'f':\n                return value.toFixed(precision);\n            case 'r':\n                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n            default:\n                return value + '';\n        }\n    },\n\n    round: function(value, precision) {\n\n        return precision\n            ? Math.round(value * (precision = Math.pow(10, precision))) / precision\n            : Math.round(value);\n    },\n\n    precision: function(value, precision) {\n\n        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n    },\n\n    prefix: function(value, precision) {\n\n        var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '\u00b5', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function(d, i) {\n            var k = Math.pow(10, Math.abs(8 - i) * 3);\n            return {\n                scale: i > 8 ? function(d) {\n                    return d / k;\n                } : function(d) {\n                    return d * k;\n                },\n                symbol: d\n            };\n        });\n\n        var i = 0;\n        if (value) {\n            if (value < 0) value *= -1;\n            if (precision) value = this.round(value, this.precision(value, precision));\n            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n        }\n        return prefixes[8 + i / 3];\n    }\n};\n\n/*\n    Pre-compile the HTML to be used as a template.\n*/\nexport const template = function(html) {\n\n    /*\n        Must support the variation in templating syntax found here:\n        https://lodash.com/docs#template\n    */\n    var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\n    return function(data) {\n\n        data = data || {};\n\n        return html.replace(regex, function(match) {\n\n            var args = Array.from(arguments);\n            var attr = args.slice(1, 4).find(function(_attr) {\n                return !!_attr;\n            });\n\n            var attrArray = attr.split('.');\n            var value = data[attrArray.shift()];\n\n            while (value !== undefined && attrArray.length) {\n                value = value[attrArray.shift()];\n            }\n\n            return value !== undefined ? value : '';\n        });\n    };\n};\n\n/**\n * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n */\nexport const toggleFullScreen = function(el) {\n\n    var topDocument = window.top.document;\n    el = el || topDocument.body;\n\n    function prefixedResult(el, prop) {\n\n        var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n        for (var i = 0; i < prefixes.length; i++) {\n            var prefix = prefixes[i];\n            var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\n            if (el[propName] !== undefined) {\n                return isFunction(el[propName]) ? el[propName]() : el[propName];\n            }\n        }\n    }\n\n    if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n        prefixedResult(topDocument, 'ExitFullscreen') || // Spec.\n        prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n    } else {\n        prefixedResult(el, 'RequestFullscreen') || // Spec.\n        prefixedResult(el, 'RequestFullScreen'); // Firefox\n    }\n};\n\n// Deprecated\n// Copy all the properties to the first argument from the following arguments.\n// All the properties will be overwritten by the properties from the following\n// arguments. Inherited properties are ignored.\nexport const mixin = _.assign;\n\n// Deprecated\n// Copy all properties to the first argument from the following\n// arguments only in case if they don't exists in the first argument.\n// All the function propererties in the first argument will get\n// additional property base pointing to the extenders same named\n// property function's call method.\nexport const supplement = _.defaults;\n\n// Same as `mixin()` but deep version.\nexport const deepMixin = mixin;\n\n// Deprecated\n// Same as `supplement()` but deep version.\nexport const deepSupplement = _.defaultsDeep;\n\n// Replacements for deprecated functions\nexport const assign = _.assign;\nexport const defaults = _.defaults;\n// no better-named replacement for `deepMixin`\nexport const defaultsDeep = _.defaultsDeep;\n\n// Lodash 3 vs 4 incompatible\nexport const invoke = _.invokeMap || _.invoke;\nexport const sortedIndex = _.sortedIndexBy || _.sortedIndex;\nexport const uniq = _.uniqBy || _.uniq;\n\nexport const clone = _.clone;\nexport const cloneDeep = _.cloneDeep;\nexport const isEmpty = _.isEmpty;\nexport const isEqual = _.isEqual;\nexport const isFunction = _.isFunction;\nexport const isPlainObject = _.isPlainObject;\nexport const toArray = _.toArray;\nexport const debounce = _.debounce;\nexport const groupBy = _.groupBy;\nexport const sortBy = _.sortBy;\nexport const flattenDeep = _.flattenDeep;\nexport const without = _.without;\nexport const difference = _.difference;\nexport const intersection = _.intersection;\nexport const union = _.union;\nexport const has = _.has;\nexport const result = _.result;\nexport const omit = _.omit;\nexport const pick = _.pick;\nexport const bindAll = _.bindAll;\nexport const forIn = _.forIn;\nexport const camelCase = _.camelCase;\nexport const uniqueId = _.uniqueId;\n\nexport const merge = function() {\n    if (_.mergeWith) {\n        var args = Array.from(arguments);\n        var last = args[args.length - 1];\n\n        var customizer = isFunction(last) ? last : noop;\n        args.push(function(a, b) {\n            var customResult = customizer(a, b);\n            if (customResult !== undefined) {\n                return customResult;\n            }\n\n            if (Array.isArray(a) && !Array.isArray(b)) {\n                return b;\n            }\n        });\n\n        return _.mergeWith.apply(this, args);\n    }\n    return _.merge.apply(this, arguments);\n};\n\nexport const isBoolean = function(value) {\n    var toString = Object.prototype.toString;\n    return value === true || value === false || (!!value && typeof value === 'object' && toString.call(value) === '[object Boolean]');\n};\n\nexport const isObject = function(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function');\n};\n\nexport const isNumber = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'number' || (!!value && typeof value === 'object' && toString.call(value) === '[object Number]');\n};\n\nexport const isString = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'string' || (!!value && typeof value === 'object' && toString.call(value) === '[object String]');\n};\n\nexport const noop = function() {\n};\n", "'use strict';\n\nQUnit.module('util', function(hooks) {\n\n    QUnit.test('util.interpolate', function(assert) {\n\n        var values = [0, .25, .5, .75, 1];\n\n        var numberInterpolation = joint.util.interpolate.number(0, 100);\n        var objectInterpolation = joint.util.interpolate.object({ x: 100, y: 200 }, { x: 200, y: 0 });\n        var hexColorInterpolation = joint.util.interpolate.hexColor('#FFFFFF', '#00FF77');\n        var unitInterpolation = joint.util.interpolate.unit('1em', '0.50em');\n\n        var numberArray = _.map(values, numberInterpolation);\n        var objectArray = _.map(values, objectInterpolation);\n        var hexColorArray = _.map(values, hexColorInterpolation);\n        var unitArray = _.map(values, unitInterpolation);\n\n        assert.deepEqual(numberArray, [\n            0, 25, 50, 75, 100\n        ], 'Numbers interpolated.');\n\n        assert.deepEqual(objectArray, [\n            { x: 100, y: 200 }, { x: 125, y: 150 }, { x: 150, y: 100 }, { x: 175, y: 50 }, { x: 200,    y: 0 }\n        ], 'Objects interpolated.');\n\n        assert.deepEqual(hexColorArray, [\n            '#ffffff', '#bfffdd', '#7fffbb', '#3fff99', '#00ff77'\n        ], 'String hex colors interpolated.');\n\n        assert.deepEqual(unitArray, [\n            '1.00em', '0.88em', '0.75em', '0.63em', '0.50em'\n        ], 'Numbers with units interpolated.');\n    });\n\n    QUnit.test('util.isPercentage', function(assert) {\n\n        assert.equal(joint.util.isPercentage(undefined), false, 'undefined => false');\n        assert.equal(joint.util.isPercentage(null), false, 'null => false');\n        assert.equal(joint.util.isPercentage(true), false, 'true => false');\n        assert.equal(joint.util.isPercentage(false), false, 'false => false');\n        assert.equal(joint.util.isPercentage(0), false, '0 => false');\n        assert.equal(joint.util.isPercentage(10), false, '10 => false');\n        assert.equal(joint.util.isPercentage(''), false, '\\'\\' => false');\n        assert.equal(joint.util.isPercentage('10'), false, '\\'10\\' => false');\n\n        assert.equal(joint.util.isPercentage('%'), true, '\\'%\\' => true');\n        assert.equal(joint.util.isPercentage('10%'), true, '\\'10%\\' => true');\n        assert.equal(joint.util.isPercentage('-10%'), true, '\\'-10%\\' => true');\n    });\n\n    QUnit.test('util.format.number', function(assert) {\n\n        var res = {\n            '5.00': ['.2f', 5],\n            '005': ['03d', 5],\n            '05.02': ['05.2f', 5.02],\n            '20.5%': ['.1%', .205],\n            '****5****': ['*^9', '5'],\n            '5********': ['*<9', '5'],\n            '********5': ['*>9', '5'],\n            '+3.14': ['+.f', 3.14],\n            '3.14': ['.f', 3.14],\n            '-3.14': ['+.f', -3.14],\n            'a': ['x', 10],\n            'A': ['X', 10],\n            'C0': ['02X', 192],\n            '1,234,567,890': [',', 1234567890]\n        };\n\n        _.each(res, function(input, output) {\n\n            assert.equal(joint.util.format.number(input[0], input[1]), output, 'number(' + input[0] + ', ' + input[1] + ') = ' + output);\n        });\n    });\n\n    QUnit.module('util.breakText', function(assert) {\n\n        // tests can't compare exact results as they may vary in different browsers\n\n        // This ensures that the tests will be more deterministic.\n        // For example, some browsers might have a different default font size/family.\n        var styles = {\n            'font-size': '12px',\n            'font-family': 'Courier New'\n        };\n\n        var text = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';\n\n        QUnit.test('sanity', function(assert) {\n\n            assert.equal(joint.util.breakText('', { width: 100 }, styles), '', 'An empty text was correctly broken.');\n\n            assert.equal(joint.util.breakText(text, { width: 0, height: 0 }, styles), '', 'A text was correctly broken when zero width and height provided.');\n\n            assert.ok(_.includes(joint.util.breakText(text, { width: 100 }, styles), '\\n'),\n                'A text was broken when width A specified.');\n\n            assert.ok(_.includes(joint.util.breakText(text, { width: 15 }, styles), '\\n'), 'A text was broken when width B specified.');\n\n            var brokenText = joint.util.breakText(text, { width: 100, height: 40 }, styles);\n\n            assert.ok(_.includes(brokenText, 'Lorem') && !_.includes(brokenText, 'elit.'), 'A text was trimmed when width & height specified.');\n\n            brokenText = joint.util.breakText(text, { width: 100, height: 50 }, _.extend({}, styles, { 'font-size': '18px' }));\n\n            assert.ok(_.includes(brokenText, '\\n') || !_.includes(brokenText, 'elit.'), 'A text was broken when style specified.');\n\n            assert.throws(function() {\n                joint.util.breakText(text, { width: 100, height: 50 }, _.extend({}, styles, { 'font-size': '18px' }), { svgDocument: 'not-svg' });\n            }, /appendChild|undefined/, 'A custom svgDocument provided was recognized.');\n        });\n\n        function measureText(text, styles) {\n            var vText = V('text').text(text).attr(styles || {});\n            var svgDoc = V('svg').append(vText);\n            document.body.appendChild(svgDoc.node);\n            var bbox = vText.getBBox();\n            svgDoc.remove();\n            return bbox;\n        }\n\n        QUnit.test('maxLineCount', function(assert) {\n\n            var WIDTH = 100;\n            var t, r;\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 0 });\n            assert.equal(r, '');\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 1 });\n            assert.equal(r.split('\\n').length, 1);\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 2 });\n            assert.equal(r.split('\\n').length, 2);\n\n            t = 'test\\n\\n\\n\\n';\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { maxLineCount: 2 });\n            assert.equal(r.split('\\n').length, 2);\n        });\n\n\n        QUnit.test('ellipsis', function(assert) {\n\n            var WIDTH = 100;\n            var HEIGHT = 20;\n            var ELLIPSIS = '\\u2026';\n            var t, r;\n\n            t = text;\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: false });\n            assert.ok(r.indexOf(ELLIPSIS) === -1);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: true });\n            assert.ok(r.indexOf(ELLIPSIS) === r.length - ELLIPSIS.length);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n\n            var customEllipsis = 'CUSTOM';\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: customEllipsis });\n            assert.ok(r.indexOf(customEllipsis) === r.length - customEllipsis.length);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n\n            // '...' vs ' ...'\n            [WIDTH, WIDTH - 3, WIDTH - 6, WIDTH - 9, WIDTH -12].forEach(function(w, i) {\n\n                t = 'NoSpacesNoSpacesNoSpaces';\n                r = joint.util.breakText(t, { width: w, height: HEIGHT }, styles, { ellipsis: true });\n                assert.notOk(r[r.length - 1 - ELLIPSIS.length] === ' ');\n\n                t = 'S P A C E S S P A C E S';\n                r = joint.util.breakText(t, { width: w, height: HEIGHT }, styles, { ellipsis: true });\n                assert.ok(r[r.length - 1 - ELLIPSIS.length] === ' ');\n            });\n\n            t = 'text\\n\\n\\n\\n\\n';\n            r = joint.util.breakText(t, { width: WIDTH, height: HEIGHT }, styles, { ellipsis: true });\n            assert.ok(r.indexOf(ELLIPSIS) === r.length - ELLIPSIS.length);\n            assert.ok(measureText(r, styles).width < WIDTH);\n            assert.ok(measureText(r, styles).height < HEIGHT);\n        });\n\n        QUnit.test('hyphen', function(assert) {\n\n            var WIDTH = 50;\n            var t, t2, t3, t4, r;\n\n            t = 'test-hyphen';\n            t2 = 'asdfWETUIOPj[JF';\n            t3 = 'as[dsdfgdfWETUfIOPj';\n            t4 = 'WETUIOP[JF';\n\n            r = joint.util.breakText(t, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'test-hyphen');\n\n            r = joint.util.breakText(t2, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'asdfWETUIOPj[\\nJF', 'Inserts new line character after \"[\" character.');\n\n            r = joint.util.breakText(t3, { width: 2 * WIDTH + 20 }, styles);\n            assert.equal(r, 'as[\\ndsdfgdfWETUfIOPj', 'Inserts new line character after \"[\" character.');\n\n            r = joint.util.breakText(t3, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'as[\\ndsdfgdfWETUfI\\nOPj', 'Inserts two new line characters, one after \"[\" and one in second line when text is too long.');\n\n            r = joint.util.breakText(t4, { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'WETUIOP[JF', 'Does not insert new line character when text fits in a single line.');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles);\n            assert.equal(r, 'test-\\nhyphen');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { hyphen: '-' });\n            assert.equal(r, 'test-\\nhyphen');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { hyphen: 'h' });\n            assert.equal(r, 'test-h\\nyphen');\n\n            r = joint.util.breakText(t, { width: WIDTH }, styles, { hyphen: /h/ });\n            assert.equal(r, 'test-h\\nyphen');\n        });\n\n\n        QUnit.test('new line', function(assert) {\n\n            var WIDTH = 50;\n            var r;\n\n            r = joint.util.breakText('a\\n', { width: 2 * WIDTH }, styles);\n            assert.equal(r, 'a\\n');\n\n            r = joint.util.breakText('a\\n\\n', { width: WIDTH }, styles);\n            assert.equal(r, 'a\\n\\n');\n\n            r = joint.util.breakText('\\na', { width: WIDTH }, styles);\n            assert.equal(r, '\\na');\n\n            r = joint.util.breakText('\\n\\na', { width: WIDTH }, styles);\n            assert.equal(r, '\\n\\na');\n\n            r = joint.util.breakText('\\na\\n\\nb\\n\\n', { width: WIDTH }, styles);\n            assert.equal(r, '\\na\\n\\nb\\n\\n');\n        });\n\n    });\n\n    QUnit.test('util.parseCssNumeric', function(assert) {\n\n        assert.equal(joint.util.parseCssNumeric('auto'), null, 'no number to parse');\n\n        assert.deepEqual(joint.util.parseCssNumeric(1.1), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1'), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px'), { value: 1.1, unit: 'px' });\n\n        assert.deepEqual(joint.util.parseCssNumeric(1.1, ''), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1', ''), { value: 1.1, unit: '' });\n        assert.equal(joint.util.parseCssNumeric('1.1px', ''), null, '\\'px\\' found, expects no unit');\n\n        assert.equal(joint.util.parseCssNumeric(1.1, 'px'), null, 'no unit found, expects \\'px\\'');\n        assert.equal(joint.util.parseCssNumeric('1.1', 'px'), null, 'no unit found, expects \\'px\\'');\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', 'px'), { value: 1.1, unit: 'px' });\n        assert.equal(joint.util.parseCssNumeric('1.1em', 'px'), null, '\\'em\\' found, expects \\'px\\'');\n\n        assert.equal(joint.util.parseCssNumeric(1.1, []), null, 'always return null');\n        assert.equal(joint.util.parseCssNumeric('1.1', []), null, 'always return null');\n        assert.equal(joint.util.parseCssNumeric('1.1px', []), null, 'always return null');\n\n        assert.deepEqual(joint.util.parseCssNumeric(1.1, ['']), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1', ['']), { value: 1.1, unit: '' });\n        assert.equal(joint.util.parseCssNumeric('1.1px', ['']), null, '\\'px\\' found, expects no unit');\n\n        assert.equal(joint.util.parseCssNumeric(1.1, ['px']), null, 'no unit found, expects \\'px\\'');\n        assert.equal(joint.util.parseCssNumeric('1.1', ['px']), null, 'no unit found, expects \\'px\\'');\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', ['px']), { value: 1.1, unit: 'px' });\n        assert.equal(joint.util.parseCssNumeric('1.1em', ['px']), null, '\\'em\\' found, expects \\'px\\'');\n\n        assert.equal(joint.util.parseCssNumeric('1.1', ['px', 'em']), null, 'no unit found, expects \\'px\\' or \\'em\\'');\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', ['px', 'em']), { value: 1.1, unit: 'px' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1em', ['px', 'em']), { value: 1.1, unit: 'em' });\n\n        assert.deepEqual(joint.util.parseCssNumeric('1.1', ['', 'px']), { value: 1.1, unit: '' });\n        assert.deepEqual(joint.util.parseCssNumeric('1.1px', ['', 'px']), { value: 1.1, unit: 'px' });\n        assert.equal(joint.util.parseCssNumeric('1.1em', ['', 'px']), null, '\\'em\\' found, expects no unit or \\'px\\'');\n    });\n\n    QUnit.test('util.getByPath()', function(assert) {\n\n        var obj = {\n            a: 1,\n            b: {\n                c: 2,\n                d: 3\n            },\n            f: {},\n            g: [],\n            h: [null, 4, {\n                i: { j: 6 }\n            }],\n            'a/b/c': { d: 'abcd' }\n        };\n\n        assert.deepEqual(joint.util.getByPath(obj, 'none'), undefined, 'non-existing property is undefined');\n        assert.equal(joint.util.getByPath(obj, 'a'), 1, 'existing property is a number');\n        assert.deepEqual(joint.util.getByPath(obj, 'b'), { c: 2, d: 3 }, 'existing property is an object');\n        assert.equal(joint.util.getByPath(obj, 'b/c'), 2, 'nested property is a number');\n        assert.deepEqual(joint.util.getByPath(obj, 'b/none'), undefined, 'non-existing nested property is undefined');\n        assert.deepEqual(joint.util.getByPath(obj, 'f'), {}, 'property is an empty object');\n        assert.deepEqual(joint.util.getByPath(obj, 'g'), [], 'property is an empty array');\n        assert.deepEqual(joint.util.getByPath(obj, 'g/0'), undefined, 'first item of an empty array is undefined');\n        assert.deepEqual(joint.util.getByPath(obj, 'h/0'), null, 'first item of an array is null');\n        assert.deepEqual(joint.util.getByPath(obj, 'h/0/none'), undefined, 'nested property in null is undefined');\n        assert.equal(joint.util.getByPath(obj, 'h/1'), 4, 'nth item of an array is number');\n        assert.deepEqual(joint.util.getByPath(obj, 'h/1/none'), undefined, 'non-existing property of nth item of an array is undefined');\n        assert.equal(joint.util.getByPath(obj, 'h/2/i/j'), 6, 'nested property of nth item of an array is number');\n        assert.equal(joint.util.getByPath(obj, 'h.2.i.j', '.'), 6, 'same but this time with a custom delimiter');\n        assert.equal(joint.util.getByPath(obj, ['h', '2', 'i', 'j']), 6, 'path as array');\n        assert.equal(joint.util.getByPath(obj, ['a/b/c', 'd']), 'abcd', 'path as array, separator in name');\n    });\n\n    QUnit.module('util.setByPath()', function() {\n\n        QUnit.test('sets a value at any given path', function(assert) {\n\n            assert.deepEqual(joint.util.setByPath({}, 'property', 1), { property: 1 }, 'non-existing property in an obj set as a number');\n            assert.deepEqual(joint.util.setByPath({ property: 2 }, 'property', 3), { property: 3 }, 'existing property in an obj set as a number');\n            assert.deepEqual(joint.util.setByPath([], '0', 4), [4], 'add an item to an empty array');\n            assert.deepEqual(joint.util.setByPath([5, 6], '1', 7), [5, 7], 'change an item in an array');\n            assert.deepEqual(joint.util.setByPath({}, 'first/second/third', 8), { first: { second: { third: 8 }}}, 'populate an empty object with nested objects');\n            assert.deepEqual(joint.util.setByPath({}, 'first.second.third', 9, '.'), { first: { second: { third: 9 }}}, 'same but this time with a custom delimiter');\n            assert.deepEqual(joint.util.setByPath([null], '0/property', 10), [{ property: 10 }], 'replace null item with an object');\n            assert.deepEqual(joint.util.setByPath({ array: [] }, 'array/1', 'index'), { array: [undefined, 'index'] }, 'define array');\n            assert.deepEqual(joint.util.setByPath({ object: {}}, 'object/1', 'property'), { object: { '1': 'property' }}, 'define property');\n        });\n\n        [\n            '__proto__/polluted',\n            'constructor/prototype/polluted',\n            [['__proto__'], 'polluted']\n        ].forEach(function(path) {\n            QUnit.test('setting \"' + path + '\" does not pollute prototype' , function(assert) {\n                var obj = {};\n                assert.notOk(obj.polluted);\n                joint.util.setByPath({}, path, true, '/');\n                assert.notOk(obj.polluted);\n            });\n        });\n    });\n\n\n    QUnit.module('util.unsetByPath', function(hooks) {\n\n        QUnit.test('path defined as string', function(assert) {\n\n            var obj = {\n                a: 1,\n                b: {\n                    c: 2,\n                    d: 3\n                }\n            };\n\n            joint.util.unsetByPath(obj, 'b/c', '/');\n            assert.deepEqual(obj, { a: 1, b: { d: 3 }}, 'A nested attribute was removed.');\n\n            joint.util.unsetByPath(obj, 'b');\n            assert.deepEqual(obj, { a: 1 }, 'A primitive attribute was removed.');\n\n            joint.util.unsetByPath(obj, 'c/d');\n            assert.deepEqual(obj, { a: 1 }, 'Attempt to delete non-existing attribute doesn\\'t affect object.');\n\n        });\n\n        QUnit.test('path defined as array - remove from objects and arrays', function(assert) {\n\n            var obj = {\n                object: { 1: 'property', 2: 'property2', 3: 'property3' },\n                array: ['a', 'b', 'c'],\n                objectArray: [{ a: 'a_value', b: 'b_value' }, { c: 'c_value', d: 'd_value' }]\n            };\n\n            joint.util.unsetByPath(obj, ['object', 1]);\n            assert.deepEqual(obj.object, { 2: 'property2', 3: 'property3' });\n\n            joint.util.unsetByPath(obj, ['object', 2]);\n            assert.deepEqual(obj.object, { 3: 'property3' });\n\n            joint.util.unsetByPath(obj, ['array', 1]);\n            assert.deepEqual(obj.array, ['a', undefined, 'c']);\n\n            joint.util.unsetByPath(obj, ['array', 2]);\n            assert.deepEqual(obj.array, ['a', undefined, undefined]);\n\n            joint.util.unsetByPath(obj, ['objectArray', 1, 'c']);\n            assert.deepEqual(obj.objectArray, [{ a: 'a_value', b: 'b_value' }, { d: 'd_value' }]);\n\n            joint.util.unsetByPath(obj, ['objectArray', '1', 'd']);\n            assert.deepEqual(obj.objectArray, [{ a: 'a_value', b: 'b_value' }, {}]);\n        });\n\n        QUnit.test('path defined as array', function(assert) {\n\n            var obj = {\n                a: 1,\n                b: {\n                    c: 2,\n                    d: 3\n                }\n            };\n\n            joint.util.unsetByPath(obj, ['b', 'c'], '/');\n            assert.deepEqual(obj, { a: 1, b: { d: 3 }}, 'A nested attribute was removed.');\n\n            joint.util.unsetByPath(obj, ['b']);\n            assert.deepEqual(obj, { a: 1 }, 'A primitive attribute was removed.');\n\n            joint.util.unsetByPath(obj, ['c', 'd']);\n            assert.deepEqual(obj, { a: 1 }, 'Attempt to delete non-existing attribute doesn\\'t affect object.');\n        });\n\n        ['__proto__/toString', 'constructor/prototype/toString'].forEach(function(path) {\n            QUnit.test('unsetting \"' + path + '\" does not modify prototype' , function(assert) {\n                var obj = {};\n                assert.equal(typeof obj.toString, 'function');\n                joint.util.unsetByPath({}, path, '/');\n                assert.equal(typeof obj.toString, 'function');\n            });\n        });\n    });\n\n    QUnit.test('util.normalizeSides()', function(assert) {\n\n        assert.deepEqual(joint.util.normalizeSides(undefined), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Undefined becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(null), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Null becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(''), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Empty string becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides('a'), { top: 0, right: 0, bottom: 0, left: 0 },\n            'String becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides('5'), { top: 5, right: 5, bottom: 5, left: 5 },\n            'String number becomes number');\n\n        assert.deepEqual(joint.util.normalizeSides('Infinity'), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides('NaN'), { top: 0, right: 0, bottom: 0, left: 0 },\n            'NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(Infinity), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(NaN), { top: 0, right: 0, bottom: 0, left: 0 },\n            'NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: undefined }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific undefined becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: null }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific null becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: '' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific empty string becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 'a' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific string becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: '5' }), { top: 0, right: 0, bottom: 0, left: 5 },\n            'Specific string number becomes number');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 'Infinity' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific string Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 'NaN' }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific string NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: Infinity }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific Infinity becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: NaN }), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Specific NaN becomes 0');\n\n        assert.deepEqual(joint.util.normalizeSides(), { top: 0, right: 0, bottom: 0, left: 0 },\n            'Returns sides defaulted to 0 if called without an argument.');\n\n        assert.deepEqual(joint.util.normalizeSides(5), { top: 5, right: 5, bottom: 5, left: 5 },\n            'Returns sides equaled to a number if called with this number as an argument.');\n\n        assert.deepEqual(joint.util.normalizeSides({ horizontal: 5 }), { top: 0, right: 5, bottom: 0, left: 5 },\n            'If called with an object, horizontal sides are applied to right and left and the rest is defaulted to 0.');\n\n        assert.deepEqual(joint.util.normalizeSides({ left: 5 }), { top: 0, right: 0, bottom: 0, left: 5 },\n            'If called with an object, the existing sides are copied from the object and the rest is defaulted to 0.');\n\n        assert.deepEqual(joint.util.normalizeSides({ horizontal: 10, left: 5 }), { top: 0, right: 10, bottom: 0, left: 5 },\n            'If called with an object, horizontal sides are overriden by more specific sides from the object and the rest is defaulted to 0.');\n\n        assert.deepEqual(joint.util.normalizeSides({ horizontal: 5, left: 0 }), { top: 0, right: 5, bottom: 0, left: 0 },\n            'If called with an object, horizontal sides are overriden by more specific sides from the object and the rest is defaulted to 0.');\n    });\n\n    QUnit.module('util.normalizeEvent()', function() {\n\n        QUnit.test('correspondingUseElement', function(assert) {\n            var useElement = V('use').node;\n            var event = new $.Event('mouseover', { target: { correspondingUseElement: useElement }});\n            assert.equal(joint.util.normalizeEvent(event).target, useElement);\n        });\n\n    });\n\n    QUnit.test('util.merge', function(assert) {\n\n        var types = joint.util.merge({ a: [99] }, { a: { b: 1 }});\n        assert.deepEqual(types, { a: { b: 1 }}, 'array is not merged with object');\n\n\n        var custom = joint.util.merge({ a: [99] }, { a: { b: 1 }}, function(a) {\n            return 'x';\n        });\n        assert.deepEqual(custom, { a: 'x' });\n    });\n\n    QUnit.test('joint.setTheme()', function(assert) {\n\n        assert.ok(typeof joint.setTheme === 'function', 'should be a function');\n\n        var theme = 'set-global-theme-test';\n        var view1 = new joint.mvc.View();\n        var view2 = new joint.mvc.View();\n\n        joint.setTheme(theme);\n\n        assert.ok(view1.theme === theme && view2.theme === theme, 'should set the theme for all views');\n        assert.equal(joint.mvc.View.prototype.defaultTheme, theme, 'should update the default theme on the view prototype');\n\n        var view3 = new joint.mvc.View();\n\n        assert.equal(view3.theme, theme, 'newly created views should use the updated theme');\n\n        var localTheme = 'local-theme';\n\n        joint.mvc.View.extend({\n            options: {\n                theme: localTheme\n            }\n        });\n\n        var view4 = new joint.mvc.View({\n            theme: localTheme\n        });\n\n        joint.setTheme(theme);\n\n        assert.ok(view4.theme === localTheme, 'by default, should not override local theme settings');\n\n        joint.setTheme(theme, { override: true });\n\n        assert.ok(view4.theme === theme, 'when \"override\" set to true, should override local theme settings');\n    });\n\n    QUnit.module('template(html)', function(hooks) {\n\n        QUnit.test('should be a function', function(assert) {\n\n            assert.equal(typeof joint.util.template, 'function');\n        });\n\n        QUnit.test('should correctly render the sample HTML templates', function(assert) {\n\n            var samples = [\n                {\n                    html: '<p>No embedded data in this template.</p>',\n                    data: {},\n                    expectedOutput: '<p>No embedded data in this template.</p>'\n                },\n                {\n                    html: '<p>no data!</p>',\n                    data: null,\n                    expectedOutput: '<p>no data!</p>'\n                },\n                {\n                    html: [\n                        '<p>Some simple text with a value: <%= someValue %></p>',\n                        '<p>Another line with another value: <%= anotherValue %></p>'\n                    ].join(''),\n                    data: {\n                        someValue: 12345,\n                        anotherValue: 678\n                    },\n                    expectedOutput: [\n                        '<p>Some simple text with a value: 12345</p>',\n                        '<p>Another line with another value: 678</p>'\n                    ].join('')\n                },\n                {\n                    html: '<p>With a complex data attribute <%= some.value %></p>',\n                    data: {\n                        some: {\n                            value: 123\n                        }\n                    },\n                    expectedOutput: '<p>With a complex data attribute 123</p>'\n                },\n                {\n                    html: '<p>With a more <%= some.value.text %> data attribute</p>',\n                    data: {\n                        some: {\n                            value: {\n                                text: 'complex'\n                            }\n                        }\n                    },\n                    expectedOutput: '<p>With a more complex data attribute</p>'\n                },\n                {\n                    html: '<p>Alternative syntax #${num}</p>',\n                    data: {\n                        num: 1\n                    },\n                    expectedOutput: '<p>Alternative syntax #1</p>'\n                },\n                {\n                    html: '<p>Alternative syntax #${ num }</p>',\n                    data: {\n                        num: 2\n                    },\n                    expectedOutput: '<p>Alternative syntax #2</p>'\n                },\n                {\n                    html: '<p>Alternative syntax #{{num}}</p>',\n                    data: {\n                        num: 3\n                    },\n                    expectedOutput: '<p>Alternative syntax #3</p>'\n                }\n            ];\n\n            _.each(samples, function(sample) {\n\n                var template = joint.util.template(sample.html);\n                var actualOutput = template(sample.data);\n\n                assert.equal(actualOutput, sample.expectedOutput, 'should return expected output');\n            });\n        });\n    });\n\n    QUnit.module('addClassNamePrefix', function(hooks) {\n\n        QUnit.test('should be a function', function(assert) {\n\n            assert.equal(typeof joint.util.addClassNamePrefix, 'function');\n        });\n\n        QUnit.test('falsey value provided', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix(null), null);\n            assert.equal(joint.util.addClassNamePrefix(undefined), undefined);\n            assert.equal(joint.util.addClassNamePrefix(0), 0);\n            assert.equal(joint.util.addClassNamePrefix(''), '');\n            assert.ok(_.isNaN(joint.util.addClassNamePrefix(NaN)));\n        });\n\n        QUnit.test('non-string value provided', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix(1), joint.config.classNamePrefix + '1');\n        });\n\n        QUnit.test('one class name', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix('some-class'), joint.config.classNamePrefix + 'some-class');\n        });\n\n        QUnit.test('multiple class names', function(assert) {\n\n            assert.equal(joint.util.addClassNamePrefix('some-class some-other-class'), joint.config.classNamePrefix + 'some-class ' + joint.config.classNamePrefix + 'some-other-class');\n        });\n    });\n\n    QUnit.module('removeClassNamePrefix', function(hooks) {\n\n        QUnit.test('should be a function', function(assert) {\n\n            assert.equal(typeof joint.util.removeClassNamePrefix, 'function');\n        });\n\n        QUnit.test('falsey value provided', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(null), null);\n            assert.equal(joint.util.removeClassNamePrefix(undefined), undefined);\n            assert.equal(joint.util.removeClassNamePrefix(0), 0);\n            assert.equal(joint.util.removeClassNamePrefix(''), '');\n            assert.ok(_.isNaN(joint.util.removeClassNamePrefix(NaN)));\n        });\n\n        QUnit.test('non-string value provided', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(1), '1');\n        });\n\n        QUnit.test('one prefixed class name', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(joint.config.classNamePrefix + 'some-class'), 'some-class');\n        });\n\n        QUnit.test('multiple prefixed class names', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(joint.config.classNamePrefix + 'some-class ' + joint.config.classNamePrefix + 'some-other-class'), 'some-class some-other-class');\n        });\n\n        QUnit.test('mix of prefixed and non-prefixed class names', function(assert) {\n\n            assert.equal(joint.util.removeClassNamePrefix(joint.config.classNamePrefix + 'some-class without-prefix'), 'some-class without-prefix');\n        });\n    });\n\n    QUnit.module('wrapWith', function(hooks) {\n\n        QUnit.test('wraps object\\'s methods with wrapper function', function(assert) {\n\n            var someObject = {\n\n                someFunction: function() {\n\n                },\n\n                someOtherFunction: function() {\n\n                },\n\n                yetAnotherFunction: function() {\n\n                }\n            };\n\n            var methods = ['someFunction', 'someOtherFunction'];\n\n            var innerWrapper = function() { };\n\n            var wrapper = function() {\n\n                return innerWrapper;\n            };\n\n            joint.util.wrapWith(someObject, methods, wrapper);\n\n            _.each(someObject, function(fn, method) {\n\n                if (_.includes(methods, method)) {\n                    // Should be wrapped.\n                    assert.equal(someObject[method], innerWrapper);\n                } else {\n                    // Should not be wrapped.\n                    assert.equal(someObject[method], fn);\n                }\n            });\n        });\n\n        QUnit.test('can specify wrapper method by name', function(assert) {\n\n            var someObject = {\n\n                someFunction: function() {\n\n                }\n            };\n\n            var methods = ['someFunction'];\n            var wrapper = 'someWrapper';\n            var innerWrapper = function() { };\n\n            joint.util.wrappers[wrapper] = function() {\n\n                return innerWrapper;\n            };\n\n            joint.util.wrapWith(someObject, methods, wrapper);\n\n            _.each(someObject, function(fn, method) {\n\n                if (_.includes(methods, method)) {\n                    // Should be wrapped.\n                    assert.equal(someObject[method], innerWrapper);\n                } else {\n                    // Should not be wrapped.\n                    assert.equal(someObject[method], fn);\n                }\n            });\n\n            // Clean up.\n            delete joint.util.wrappers[wrapper];\n        });\n    });\n\n    QUnit.module('wrappers', function(hooks) {\n\n        QUnit.module('cells', function(hooks) {\n\n            var expected;\n\n            hooks.beforeEach(function() {\n\n                expected = {\n                    cells: [\n                        new joint.dia.Cell,\n                        new joint.dia.Cell,\n                        new joint.dia.Cell\n                    ],\n                    opt: {\n                        someOption: 'testing',\n                        anotherOption: 50\n                    }\n                };\n            });\n\n            QUnit.test('fn([cell, cell, cell], opt)', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, expected.opt), 'opt is as expected');\n                });\n\n                fn(expected.cells, expected.opt);\n            });\n\n            QUnit.test('fn([cell, cell, cell])', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, {}), 'opt is an empty object');\n                });\n\n                fn(expected.cells);\n            });\n\n            QUnit.test('fn(cell, cell, cell)', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, {}), 'opt is an empty object');\n                });\n\n                fn.apply(undefined, expected.cells);\n            });\n\n            QUnit.test('fn(cell, cell, cell, opt)', function(assert) {\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, expected.cells), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, expected.opt), 'opt is as expected');\n                });\n\n                fn.apply(undefined, [].concat(expected.cells, [expected.opt]));\n            });\n\n            QUnit.test('fn(cell)', function(assert) {\n\n                var cell = _.first(expected.cells);\n\n                var fn = joint.util.wrappers.cells(function(cells, opt) {\n                    assert.ok(_.isArray(cells), 'cells is an array');\n                    assert.ok(_.isEqual(cells, [cell]), 'cells is as expected');\n                    assert.ok(_.isObject(opt), 'opt is an object');\n                    assert.ok(_.isEqual(opt, {}), 'opt is an empty object');\n                });\n\n                fn(cell);\n            });\n        });\n    });\n\n    QUnit.module('getElementBBox', function(hooks) {\n\n        QUnit.module('html', function(hooks) {\n\n            var $htmlElement;\n            hooks.beforeEach(function() {\n                $htmlElement = $('<div/>').css({\n                    position: 'absolute',\n                    top: 10,\n                    left: 20,\n                    width: 50,\n                    height: 60\n                });\n\n                $htmlElement.appendTo(document.body);\n            });\n\n            hooks.afterEach(function() {\n                $htmlElement.remove();\n            });\n\n            QUnit.test('html element', function(assert) {\n\n                var bBox = joint.util.getElementBBox($htmlElement[0]);\n\n                assert.equal(bBox.x, 20);\n                assert.equal(bBox.y, 10);\n                assert.equal(bBox.width, 50);\n                assert.equal(bBox.height, 60);\n            });\n\n            QUnit.test('possible input argument types', function(assert) {\n\n                assert.ok(joint.util.getElementBBox('html'));\n                assert.ok(joint.util.getElementBBox($htmlElement));\n                assert.ok(joint.util.getElementBBox($htmlElement[0]));\n\n                assert.throws(function() {\n                    joint.util.getElementBBox('xxx');\n                });\n\n                assert.throws(function() {\n                    joint.util.getElementBBox();\n                });\n            });\n        });\n\n        QUnit.module('svg', function(hooks) {\n\n            hooks.beforeEach(function() {\n                this.svgDoc = V(V.createSvgDocument()).attr('style', 'position:absolute;top:50px;left:60px');\n                V($('body')[0]).append(this.svgDoc);\n            });\n\n            hooks.afterEach(function() {\n                this.svgDoc.remove();\n            });\n\n            QUnit.test('simple element', function(assert) {\n\n                var svgElement = V('<rect width=\"70\" height=\"80\"/>');\n                this.svgDoc.append(svgElement);\n\n                var bBox = joint.util.getElementBBox(svgElement.node);\n\n                assert.equal(bBox.x, 60);\n                assert.equal(bBox.y, 50);\n                assert.equal(bBox.width, 70);\n                assert.equal(bBox.height, 80);\n            });\n\n            QUnit.test('with position, with stroke', function(assert) {\n\n                // firefox measures differently - includes the stroke as well.\n                // joint.util.getElementBBox should return consistent values across all browsers.\n                var svgElement = V('<rect width=\"70\" height=\"80\" x=\"50\" y=\"50\" stroke-width=\"10\" stroke=\"red\"/>');\n                this.svgDoc.append(svgElement);\n\n                var bBox = joint.util.getElementBBox(svgElement.node);\n\n                assert.equal(bBox.x, 60 + 50);\n                assert.equal(bBox.y, 50 + 50);\n                assert.equal(bBox.width, 70);\n                assert.equal(bBox.height, 80);\n            });\n        });\n    });\n\n    QUnit.module('parseDOMJSON', function(hooks) {\n\n        var util = joint.util;\n\n        QUnit.test('sanity', function(assert) {\n            var res = util.parseDOMJSON([{ tagName: 'rect' }], V.namespace.xmls);\n            assert.ok(res.fragment instanceof DocumentFragment);\n            assert.equal(Object(res.selectors), res.selectors);\n        });\n\n        QUnit.module('tagName', function() {\n\n            QUnit.test('required', function(assert) {\n                assert.throws(function() {\n                    util.parseDOMJSON([{ /* tagName missing */ }]);\n                });\n            });\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'rect' }], V.namespace.xmls);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof SVGRectElement);\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div' }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof HTMLDivElement);\n            });\n        });\n\n        QUnit.module('attributes', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'rect',\n                    attributes: { 'fill': 'red', 'xlink:href': '#test' }\n                }]);\n                var node = res.fragment.firstChild;\n                assert.equal(node.attributes.getNamedItem('fill').value, 'red');\n                assert.equal(node.attributes.getNamedItemNS(V.namespace.xlink, 'href').value, '#test');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'div',\n                    attributes: { 'title': 'test' }\n                }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.equal(node.attributes.getNamedItem('title').value, 'test');\n            });\n        });\n\n        QUnit.module('style', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'rect',\n                    style: { 'fill': 'red' }\n                }]);\n                var node = res.fragment.firstChild;\n                assert.ok(/fill:/.test(node.attributes.getNamedItem('style').value));\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'div',\n                    style: { 'color': 'red' }\n                }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.ok(/color:/.test(node.attributes.getNamedItem('style').value));\n            });\n        });\n\n        QUnit.module('className', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'rect', className: 'test' }]);\n                var node = res.fragment.firstChild;\n                assert.equal(node.className.baseVal, 'test');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div', className: 'test' }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.equal(node.className, 'test');\n            });\n        });\n\n        QUnit.module('textContent', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'text', textContent: 'test' }]);\n                var node = res.fragment.firstChild;\n                assert.equal(node.textContent, 'test');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div', textContent: 'test' }], V.namespace.xhtml);\n                var node = res.fragment.firstChild;\n                assert.equal(node.textContent, 'test');\n            });\n        });\n\n        QUnit.module('selector', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'rect', selector: 'test1' },\n                    { tagName: 'circle', selector: 'test2' }\n                ]);\n                assert.ok(res.selectors.test1 instanceof SVGRectElement);\n                assert.ok(res.selectors.test2 instanceof SVGCircleElement);\n                assert.equal(res.selectors.test1.getAttribute('joint-selector'), 'test1');\n                assert.equal(res.selectors.test2.getAttribute('joint-selector'), 'test2');\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'div', selector: 'test1' },\n                    { tagName: 'img', selector: 'test2' },\n                ], V.namespace.xhtml);\n                assert.ok(res.selectors.test1 instanceof HTMLDivElement);\n                assert.ok(res.selectors.test2 instanceof HTMLImageElement);\n                assert.equal(res.selectors.test1.getAttribute('joint-selector'), 'test1');\n                assert.equal(res.selectors.test2.getAttribute('joint-selector'), 'test2');\n            });\n\n            QUnit.test('uniqueness', function(assert) {\n                assert.throws(function() {\n                    util.parseDOMJSON([\n                        { tagName: 'rect', selector: 'test' },\n                        { tagName: 'circle', selector: 'test' },\n                    ]);\n                });\n            });\n        });\n\n        QUnit.module('groupSelector', function() {\n\n            QUnit.test('svg - string', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'rect', groupSelector: 'test' },\n                    { tagName: 'circle' },\n                    { tagName: 'ellipse', groupSelector: 'test' }\n                ]);\n                assert.deepEqual(Object.keys(res.groupSelectors), ['test']);\n                assert.equal(res.groupSelectors.test.length, 2);\n                assert.ok(res.groupSelectors.test[0] instanceof SVGRectElement);\n                assert.ok(res.groupSelectors.test[1] instanceof SVGEllipseElement);\n            });\n\n            QUnit.test('html - string', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'div', groupSelector: 'test' },\n                    { tagName: 'img' },\n                    { tagName: 'p', groupSelector: 'test' },\n                ], V.namespace.xhtml);\n                assert.deepEqual(Object.keys(res.groupSelectors), ['test']);\n                assert.equal(res.groupSelectors.test.length, 2);\n                assert.ok(res.groupSelectors.test[0] instanceof HTMLDivElement);\n                assert.ok(res.groupSelectors.test[1] instanceof HTMLParagraphElement);\n            });\n\n            QUnit.test('svg - array', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'rect', groupSelector: ['test0', 'test1'] },\n                    { tagName: 'circle', groupSelector: ['test1', 'test2'] },\n                    { tagName: 'ellipse', groupSelector: ['test0', 'test2'] }\n                ]);\n                assert.deepEqual(Object.keys(res.groupSelectors).sort(), ['test0', 'test1', 'test2']);\n                assert.equal(res.groupSelectors.test0.length, 2);\n                assert.equal(res.groupSelectors.test1.length, 2);\n                assert.equal(res.groupSelectors.test2.length, 2);\n                assert.ok(res.groupSelectors.test0[0] instanceof SVGRectElement);\n                assert.ok(res.groupSelectors.test0[1] instanceof SVGEllipseElement);\n                assert.ok(res.groupSelectors.test1[0] instanceof SVGRectElement);\n                assert.ok(res.groupSelectors.test1[1] instanceof SVGCircleElement);\n                assert.ok(res.groupSelectors.test2[0] instanceof SVGCircleElement);\n                assert.ok(res.groupSelectors.test2[1] instanceof SVGEllipseElement);\n            });\n\n            QUnit.test('html - array', function(assert) {\n                var res = util.parseDOMJSON([\n                    { tagName: 'div', groupSelector: ['test0', 'test1'] },\n                    { tagName: 'img', groupSelector: ['test1', 'test2'] },\n                    { tagName: 'p', groupSelector: ['test0', 'test2'] },\n                ], V.namespace.xhtml);\n                assert.deepEqual(Object.keys(res.groupSelectors).sort(), ['test0', 'test1', 'test2']);\n                assert.equal(res.groupSelectors.test0.length, 2);\n                assert.equal(res.groupSelectors.test1.length, 2);\n                assert.equal(res.groupSelectors.test2.length, 2);\n                assert.ok(res.groupSelectors.test0[0] instanceof HTMLDivElement);\n                assert.ok(res.groupSelectors.test0[1] instanceof HTMLParagraphElement);\n                assert.ok(res.groupSelectors.test1[0] instanceof HTMLDivElement);\n                assert.ok(res.groupSelectors.test1[1] instanceof HTMLImageElement);\n                assert.ok(res.groupSelectors.test2[0] instanceof HTMLImageElement);\n                assert.ok(res.groupSelectors.test2[1] instanceof HTMLParagraphElement);\n            });\n\n\n        });\n\n        QUnit.module('namespaceURI', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'rect', namespaceURI: V.namespace.svg }]);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof SVGRectElement);\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{ tagName: 'div', namespaceURI: V.namespace.xhtml }]);\n                var node = res.fragment.firstChild;\n                assert.ok(node instanceof HTMLDivElement);\n            });\n        });\n\n        QUnit.module('children', function() {\n\n            QUnit.test('svg', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'g',\n                    children: [{ tagName: 'rect' }, { tagName: 'circle' }]\n                }]);\n                var group = res.fragment.firstChild;\n                assert.ok(group instanceof SVGGElement);\n                assert.ok(group.firstChild instanceof SVGRectElement);\n                assert.ok(group.lastChild instanceof SVGCircleElement);\n            });\n\n            QUnit.test('html', function(assert) {\n                var res = util.parseDOMJSON([{\n                    tagName: 'div',\n                    children: [{ tagName: 'p' }, { tagName: 'img' }]\n                }], V.namespace.xhtml);\n                var div = res.fragment.firstChild;\n                assert.ok(div instanceof HTMLDivElement);\n                assert.ok(div.firstChild instanceof HTMLParagraphElement);\n                assert.ok(div.lastChild instanceof HTMLImageElement);\n            });\n        });\n    });\n});\n"], "filenames": ["src/util/util.mjs", "test/jointjs/core/util.js"], "buggy_code_start_loc": [142, 339], "buggy_code_end_loc": [142, 340], "fixing_code_start_loc": [143, 339], "fixing_code_end_loc": [146, 344], "type": "CWE-843", "message": "This affects the package jointjs before 3.4.2. A type confusion vulnerability can lead to a bypass of CVE-2020-28480 when the user-provided keys used in the path parameter are arrays in the setByPath function.", "other": {"cve": {"id": "CVE-2021-23444", "sourceIdentifier": "report@snyk.io", "published": "2021-09-21T17:15:09.390", "lastModified": "2021-10-02T02:12:45.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package jointjs before 3.4.2. A type confusion vulnerability can lead to a bypass of CVE-2020-28480 when the user-provided keys used in the path parameter are arrays in the setByPath function."}, {"lang": "es", "value": "Esto afecta al paquete jointjs versiones anteriores a 3.4.2. Una vulnerabilidad de confusi\u00f3n de tipo puede conllevar a una omisi\u00f3n de CVE-2020-28480 cuando las claves proporcionadas por el usuario usadas en el par\u00e1metro path son arrays en la funci\u00f3n setByPath"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:client:jointjs:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.4.2", "matchCriteriaId": "A9559862-C493-4AF2-B803-EC0AE106CE53"}]}]}], "references": [{"url": "https://github.com/clientIO/joint/commit/e5bf89efef6d5ea572d66870ffd86560de7830a8", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/clientIO/joint/pull/1514", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/clientIO/joint/releases/tag/v3.4.2", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWER-1655817", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1655816", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-JOINTJS-1579578", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/clientIO/joint/commit/e5bf89efef6d5ea572d66870ffd86560de7830a8"}}