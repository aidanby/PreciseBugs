{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright(c) 2009-2012  Realtek Corporation.*/\n\n#include \"wifi.h\"\n#include \"core.h\"\n#include \"usb.h\"\n#include \"base.h\"\n#include \"ps.h\"\n#include \"rtl8192c/fw_common.h\"\n#include <linux/export.h>\n#include <linux/module.h>\n\nMODULE_AUTHOR(\"lizhaoming\t<chaoming_li@realsil.com.cn>\");\nMODULE_AUTHOR(\"Realtek WlanFAE\t<wlanfae@realtek.com>\");\nMODULE_AUTHOR(\"Larry Finger\t<Larry.FInger@lwfinger.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"USB basic driver for rtlwifi\");\n\n#define\tREALTEK_USB_VENQT_READ\t\t\t0xC0\n#define\tREALTEK_USB_VENQT_WRITE\t\t\t0x40\n#define REALTEK_USB_VENQT_CMD_REQ\t\t0x05\n#define\tREALTEK_USB_VENQT_CMD_IDX\t\t0x00\n\n#define MAX_USBCTRL_VENDORREQ_TIMES\t\t10\n\nstatic void usbctrl_async_callback(struct urb *urb)\n{\n\tif (urb) {\n\t\t/* free dr */\n\t\tkfree(urb->setup_packet);\n\t\t/* free databuf */\n\t\tkfree(urb->transfer_buffer);\n\t}\n}\n\nstatic int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,\n\t\t\t\t\t  u16 value, u16 index, void *pdata,\n\t\t\t\t\t  u16 len)\n{\n\tint rc;\n\tunsigned int pipe;\n\tu8 reqtype;\n\tstruct usb_ctrlrequest *dr;\n\tstruct urb *urb;\n\tconst u16 databuf_maxlen = REALTEK_USB_VENQT_MAX_BUF_SIZE;\n\tu8 *databuf;\n\n\tif (WARN_ON_ONCE(len > databuf_maxlen))\n\t\tlen = databuf_maxlen;\n\n\tpipe = usb_sndctrlpipe(udev, 0); /* write_out */\n\treqtype =  REALTEK_USB_VENQT_WRITE;\n\n\tdr = kzalloc(sizeof(*dr), GFP_ATOMIC);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdatabuf = kzalloc(databuf_maxlen, GFP_ATOMIC);\n\tif (!databuf) {\n\t\tkfree(dr);\n\t\treturn -ENOMEM;\n\t}\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tkfree(databuf);\n\t\tkfree(dr);\n\t\treturn -ENOMEM;\n\t}\n\n\tdr->bRequestType = reqtype;\n\tdr->bRequest = request;\n\tdr->wValue = cpu_to_le16(value);\n\tdr->wIndex = cpu_to_le16(index);\n\tdr->wLength = cpu_to_le16(len);\n\t/* data are already in little-endian order */\n\tmemcpy(databuf, pdata, len);\n\tusb_fill_control_urb(urb, udev, pipe,\n\t\t\t     (unsigned char *)dr, databuf, len,\n\t\t\t     usbctrl_async_callback, NULL);\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc < 0) {\n\t\tkfree(databuf);\n\t\tkfree(dr);\n\t}\n\tusb_free_urb(urb);\n\treturn rc;\n}\n\nstatic int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,\n\t\t\t\t\tu16 value, u16 index, void *pdata,\n\t\t\t\t\tu16 len)\n{\n\tunsigned int pipe;\n\tint status;\n\tu8 reqtype;\n\tint vendorreq_times = 0;\n\tstatic int count;\n\n\tpipe = usb_rcvctrlpipe(udev, 0); /* read_in */\n\treqtype =  REALTEK_USB_VENQT_READ;\n\n\tdo {\n\t\tstatus = usb_control_msg(udev, pipe, request, reqtype, value,\n\t\t\t\t\t index, pdata, len, 1000);\n\t\tif (status < 0) {\n\t\t\t/* firmware download is checksumed, don't retry */\n\t\t\tif ((value >= FW_8192C_START_ADDRESS &&\n\t\t\t    value <= FW_8192C_END_ADDRESS))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (++vendorreq_times < MAX_USBCTRL_VENDORREQ_TIMES);\n\n\tif (status < 0 && count++ < 4)\n\t\tpr_err(\"reg 0x%x, usbctrl_vendorreq TimeOut! status:0x%x value=0x%x\\n\",\n\t\t       value, status, *(u32 *)pdata);\n\treturn status;\n}\n\nstatic u32 _usb_read_sync(struct rtl_priv *rtlpriv, u32 addr, u16 len)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\tstruct usb_device *udev = to_usb_device(dev);\n\tu8 request;\n\tu16 wvalue;\n\tu16 index;\n\t__le32 *data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtlpriv->locks.usb_lock, flags);\n\tif (++rtlpriv->usb_data_index >= RTL_USB_MAX_RX_COUNT)\n\t\trtlpriv->usb_data_index = 0;\n\tdata = &rtlpriv->usb_data[rtlpriv->usb_data_index];\n\tspin_unlock_irqrestore(&rtlpriv->locks.usb_lock, flags);\n\trequest = REALTEK_USB_VENQT_CMD_REQ;\n\tindex = REALTEK_USB_VENQT_CMD_IDX; /* n/a */\n\n\twvalue = (u16)addr;\n\t_usbctrl_vendorreq_sync_read(udev, request, wvalue, index, data, len);\n\treturn le32_to_cpu(*data);\n}\n\nstatic u8 _usb_read8_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn (u8)_usb_read_sync(rtlpriv, addr, 1);\n}\n\nstatic u16 _usb_read16_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn (u16)_usb_read_sync(rtlpriv, addr, 2);\n}\n\nstatic u32 _usb_read32_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn _usb_read_sync(rtlpriv, addr, 4);\n}\n\nstatic void _usb_write_async(struct usb_device *udev, u32 addr, u32 val,\n\t\t\t     u16 len)\n{\n\tu8 request;\n\tu16 wvalue;\n\tu16 index;\n\t__le32 data;\n\n\trequest = REALTEK_USB_VENQT_CMD_REQ;\n\tindex = REALTEK_USB_VENQT_CMD_IDX; /* n/a */\n\twvalue = (u16)(addr&0x0000ffff);\n\tdata = cpu_to_le32(val);\n\t_usbctrl_vendorreq_async_write(udev, request, wvalue, index, &data,\n\t\t\t\t       len);\n}\n\nstatic void _usb_write8_async(struct rtl_priv *rtlpriv, u32 addr, u8 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 1);\n}\n\nstatic void _usb_write16_async(struct rtl_priv *rtlpriv, u32 addr, u16 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 2);\n}\n\nstatic void _usb_write32_async(struct rtl_priv *rtlpriv, u32 addr, u32 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 4);\n}\n\nstatic void _usb_writen_sync(struct rtl_priv *rtlpriv, u32 addr, void *data,\n\t\t\t     u16 len)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\tstruct usb_device *udev = to_usb_device(dev);\n\tu8 request = REALTEK_USB_VENQT_CMD_REQ;\n\tu8 reqtype =  REALTEK_USB_VENQT_WRITE;\n\tu16 wvalue;\n\tu16 index = REALTEK_USB_VENQT_CMD_IDX;\n\tint pipe = usb_sndctrlpipe(udev, 0); /* write_out */\n\tu8 *buffer;\n\n\twvalue = (u16)(addr & 0x0000ffff);\n\tbuffer = kmemdup(data, len, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn;\n\tusb_control_msg(udev, pipe, request, reqtype, wvalue,\n\t\t\tindex, buffer, len, 50);\n\n\tkfree(buffer);\n}\n\nstatic void _rtl_usb_io_handler_init(struct device *dev,\n\t\t\t\t     struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->io.dev = dev;\n\tmutex_init(&rtlpriv->io.bb_mutex);\n\trtlpriv->io.write8_async\t= _usb_write8_async;\n\trtlpriv->io.write16_async\t= _usb_write16_async;\n\trtlpriv->io.write32_async\t= _usb_write32_async;\n\trtlpriv->io.read8_sync\t\t= _usb_read8_sync;\n\trtlpriv->io.read16_sync\t\t= _usb_read16_sync;\n\trtlpriv->io.read32_sync\t\t= _usb_read32_sync;\n\trtlpriv->io.writen_sync\t\t= _usb_writen_sync;\n}\n\nstatic void _rtl_usb_io_handler_release(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv __maybe_unused *rtlpriv = rtl_priv(hw);\n\n\tmutex_destroy(&rtlpriv->io.bb_mutex);\n}\n\n/*\tDefault aggregation handler. Do nothing and just return the oldest skb.  */\nstatic struct sk_buff *_none_usb_tx_aggregate_hdl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct sk_buff_head *list)\n{\n\treturn skb_dequeue(list);\n}\n\n#define IS_HIGH_SPEED_USB(udev) \\\n\t\t((USB_SPEED_HIGH == (udev)->speed) ? true : false)\n\nstatic int _rtl_usb_init_tx(struct ieee80211_hw *hw)\n{\n\tu32 i;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\trtlusb->max_bulk_out_size = IS_HIGH_SPEED_USB(rtlusb->udev)\n\t\t\t\t\t\t    ? USB_HIGH_SPEED_BULK_SIZE\n\t\t\t\t\t\t    : USB_FULL_SPEED_BULK_SIZE;\n\n\tRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, \"USB Max Bulk-out Size=%d\\n\",\n\t\t rtlusb->max_bulk_out_size);\n\n\tfor (i = 0; i < __RTL_TXQ_NUM; i++) {\n\t\tu32 ep_num = rtlusb->ep_map.ep_mapping[i];\n\n\t\tif (!ep_num) {\n\t\t\tRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t \"Invalid endpoint map setting!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trtlusb->usb_tx_post_hdl =\n\t\t rtlpriv->cfg->usb_interface_cfg->usb_tx_post_hdl;\n\trtlusb->usb_tx_cleanup\t=\n\t\t rtlpriv->cfg->usb_interface_cfg->usb_tx_cleanup;\n\trtlusb->usb_tx_aggregate_hdl =\n\t\t (rtlpriv->cfg->usb_interface_cfg->usb_tx_aggregate_hdl)\n\t\t ? rtlpriv->cfg->usb_interface_cfg->usb_tx_aggregate_hdl\n\t\t : &_none_usb_tx_aggregate_hdl;\n\n\tinit_usb_anchor(&rtlusb->tx_submitted);\n\tfor (i = 0; i < RTL_USB_MAX_EP_NUM; i++) {\n\t\tskb_queue_head_init(&rtlusb->tx_skb_queue[i]);\n\t\tinit_usb_anchor(&rtlusb->tx_pending[i]);\n\t}\n\treturn 0;\n}\n\nstatic void _rtl_rx_work(unsigned long param);\n\nstatic int _rtl_usb_init_rx(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\n\trtlusb->rx_max_size = rtlpriv->cfg->usb_interface_cfg->rx_max_size;\n\trtlusb->rx_urb_num = rtlpriv->cfg->usb_interface_cfg->rx_urb_num;\n\trtlusb->in_ep = rtlpriv->cfg->usb_interface_cfg->in_ep_num;\n\trtlusb->usb_rx_hdl = rtlpriv->cfg->usb_interface_cfg->usb_rx_hdl;\n\trtlusb->usb_rx_segregate_hdl =\n\t\trtlpriv->cfg->usb_interface_cfg->usb_rx_segregate_hdl;\n\n\tpr_info(\"rx_max_size %d, rx_urb_num %d, in_ep %d\\n\",\n\t\trtlusb->rx_max_size, rtlusb->rx_urb_num, rtlusb->in_ep);\n\tinit_usb_anchor(&rtlusb->rx_submitted);\n\tinit_usb_anchor(&rtlusb->rx_cleanup_urbs);\n\n\tskb_queue_head_init(&rtlusb->rx_queue);\n\trtlusb->rx_work_tasklet.func = _rtl_rx_work;\n\trtlusb->rx_work_tasklet.data = (unsigned long)rtlusb;\n\n\treturn 0;\n}\n\nstatic int _rtl_usb_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\tint err;\n\tu8 epidx;\n\tstruct usb_interface\t*usb_intf = rtlusb->intf;\n\tu8 epnums = usb_intf->cur_altsetting->desc.bNumEndpoints;\n\n\trtlusb->out_ep_nums = rtlusb->in_ep_nums = 0;\n\tfor (epidx = 0; epidx < epnums; epidx++) {\n\t\tstruct usb_endpoint_descriptor *pep_desc;\n\n\t\tpep_desc = &usb_intf->cur_altsetting->endpoint[epidx].desc;\n\n\t\tif (usb_endpoint_dir_in(pep_desc))\n\t\t\trtlusb->in_ep_nums++;\n\t\telse if (usb_endpoint_dir_out(pep_desc))\n\t\t\trtlusb->out_ep_nums++;\n\n\t\tRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t \"USB EP(0x%02x), MaxPacketSize=%d, Interval=%d\\n\",\n\t\t\t pep_desc->bEndpointAddress, pep_desc->wMaxPacketSize,\n\t\t\t pep_desc->bInterval);\n\t}\n\tif (rtlusb->in_ep_nums <  rtlpriv->cfg->usb_interface_cfg->in_ep_num) {\n\t\tpr_err(\"Too few input end points found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtlusb->out_ep_nums == 0) {\n\t\tpr_err(\"No output end points found\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* usb endpoint mapping */\n\terr = rtlpriv->cfg->usb_interface_cfg->usb_endpoint_mapping(hw);\n\trtlusb->usb_mq_to_hwq =  rtlpriv->cfg->usb_interface_cfg->usb_mq_to_hwq;\n\t_rtl_usb_init_tx(hw);\n\t_rtl_usb_init_rx(hw);\n\treturn err;\n}\n\nstatic void rtl_usb_init_sw(struct ieee80211_hw *hw)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\trtlhal->hw = hw;\n\tppsc->inactiveps = false;\n\tppsc->leisure_ps = false;\n\tppsc->fwctrl_lps = false;\n\tppsc->reg_fwctrl_lps = 3;\n\tppsc->reg_max_lps_awakeintvl = 5;\n\tppsc->fwctrl_psmode = FW_PS_DTIM_MODE;\n\n\t /* IBSS */\n\tmac->beacon_interval = 100;\n\n\t /* AMPDU */\n\tmac->min_space_cfg = 0;\n\tmac->max_mss_density = 0;\n\n\t/* set sane AMPDU defaults */\n\tmac->current_ampdu_density = 7;\n\tmac->current_ampdu_factor = 3;\n\n\t/* QOS */\n\trtlusb->acm_method = EACMWAY2_SW;\n\n\t/* IRQ */\n\t/* HIMR - turn all on */\n\trtlusb->irq_mask[0] = 0xFFFFFFFF;\n\t/* HIMR_EX - turn all on */\n\trtlusb->irq_mask[1] = 0xFFFFFFFF;\n\trtlusb->disablehwsm =  true;\n}\n\nstatic void _rtl_rx_completed(struct urb *urb);\n\nstatic int _rtl_prep_rx_urb(struct ieee80211_hw *hw, struct rtl_usb *rtlusb,\n\t\t\t      struct urb *urb, gfp_t gfp_mask)\n{\n\tvoid *buf;\n\n\tbuf = usb_alloc_coherent(rtlusb->udev, rtlusb->rx_max_size, gfp_mask,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tpr_err(\"Failed to usb_alloc_coherent!!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_fill_bulk_urb(urb, rtlusb->udev,\n\t\t\t  usb_rcvbulkpipe(rtlusb->udev, rtlusb->in_ep),\n\t\t\t  buf, rtlusb->rx_max_size, _rtl_rx_completed, rtlusb);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn 0;\n}\n\nstatic void _rtl_usb_rx_process_agg(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *rxdesc = skb->data;\n\tstruct ieee80211_hdr *hdr;\n\tbool unicast = false;\n\t__le16 fc;\n\tstruct ieee80211_rx_status rx_status = {0};\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\n\tskb_pull(skb, RTL_RX_DESC_SIZE);\n\trtlpriv->cfg->ops->query_rx_desc(hw, &stats, &rx_status, rxdesc, skb);\n\tskb_pull(skb, (stats.rx_drvinfo_size + stats.rx_bufshift));\n\thdr = (struct ieee80211_hdr *)(skb->data);\n\tfc = hdr->frame_control;\n\tif (!stats.crc) {\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\t\tif (is_broadcast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/;\n\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/\n\t\t} else {\n\t\t\tunicast = true;\n\t\t\trtlpriv->stats.rxbytesunicast +=  skb->len;\n\t\t}\n\n\t\tif (ieee80211_is_data(fc)) {\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);\n\n\t\t\tif (unicast)\n\t\t\t\trtlpriv->link_info.num_rx_inperiod++;\n\t\t}\n\t\t/* static bcn for roaming */\n\t\trtl_beacon_statistic(hw, skb);\n\t}\n}\n\nstatic void _rtl_usb_rx_process_noagg(struct ieee80211_hw *hw,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *rxdesc = skb->data;\n\tstruct ieee80211_hdr *hdr;\n\tbool unicast = false;\n\t__le16 fc;\n\tstruct ieee80211_rx_status rx_status = {0};\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\n\tskb_pull(skb, RTL_RX_DESC_SIZE);\n\trtlpriv->cfg->ops->query_rx_desc(hw, &stats, &rx_status, rxdesc, skb);\n\tskb_pull(skb, (stats.rx_drvinfo_size + stats.rx_bufshift));\n\thdr = (struct ieee80211_hdr *)(skb->data);\n\tfc = hdr->frame_control;\n\tif (!stats.crc) {\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\t\tif (is_broadcast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/;\n\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/\n\t\t} else {\n\t\t\tunicast = true;\n\t\t\trtlpriv->stats.rxbytesunicast +=  skb->len;\n\t\t}\n\n\t\tif (ieee80211_is_data(fc)) {\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);\n\n\t\t\tif (unicast)\n\t\t\t\trtlpriv->link_info.num_rx_inperiod++;\n\t\t}\n\n\t\t/* static bcn for roaming */\n\t\trtl_beacon_statistic(hw, skb);\n\n\t\tif (likely(rtl_action_proc(hw, skb, false)))\n\t\t\tieee80211_rx(hw, skb);\n\t\telse\n\t\t\tdev_kfree_skb_any(skb);\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void _rtl_rx_pre_process(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct sk_buff *_skb;\n\tstruct sk_buff_head rx_queue;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tskb_queue_head_init(&rx_queue);\n\tif (rtlusb->usb_rx_segregate_hdl)\n\t\trtlusb->usb_rx_segregate_hdl(hw, skb, &rx_queue);\n\tWARN_ON(skb_queue_empty(&rx_queue));\n\twhile (!skb_queue_empty(&rx_queue)) {\n\t\t_skb = skb_dequeue(&rx_queue);\n\t\t_rtl_usb_rx_process_agg(hw, _skb);\n\t\tieee80211_rx(hw, _skb);\n\t}\n}\n\n#define __RX_SKB_MAX_QUEUED\t64\n\nstatic void _rtl_rx_work(unsigned long param)\n{\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)param;\n\tstruct ieee80211_hw *hw = usb_get_intfdata(rtlusb->intf);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&rtlusb->rx_queue))) {\n\t\tif (unlikely(IS_USB_STOP(rtlusb))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (likely(!rtlusb->usb_rx_segregate_hdl)) {\n\t\t\t_rtl_usb_rx_process_noagg(hw, skb);\n\t\t} else {\n\t\t\t/* TO DO */\n\t\t\t_rtl_rx_pre_process(hw, skb);\n\t\t\tpr_err(\"rx agg not supported\\n\");\n\t\t}\n\t}\n}\n\nstatic unsigned int _rtl_rx_get_padding(struct ieee80211_hdr *hdr,\n\t\t\t\t\tunsigned int len)\n{\n#if NET_IP_ALIGN != 0\n\tunsigned int padding = 0;\n#endif\n\n\t/* make function no-op when possible */\n\tif (NET_IP_ALIGN == 0 || len < sizeof(*hdr))\n\t\treturn 0;\n\n#if NET_IP_ALIGN != 0\n\t/* alignment calculation as in lbtf_rx() / carl9170_rx_copy_data() */\n\t/* TODO: deduplicate common code, define helper function instead? */\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\n\t\tpadding ^= NET_IP_ALIGN;\n\n\t\t/* Input might be invalid, avoid accessing memory outside\n\t\t * the buffer.\n\t\t */\n\t\tif ((unsigned long)qc - (unsigned long)hdr < len &&\n\t\t    *qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)\n\t\t\tpadding ^= NET_IP_ALIGN;\n\t}\n\n\tif (ieee80211_has_a4(hdr->frame_control))\n\t\tpadding ^= NET_IP_ALIGN;\n\n\treturn padding;\n#endif\n}\n\n#define __RADIO_TAP_SIZE_RSV\t32\n\nstatic void _rtl_rx_completed(struct urb *_urb)\n{\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)_urb->context;\n\tint err = 0;\n\n\tif (unlikely(IS_USB_STOP(rtlusb)))\n\t\tgoto free;\n\n\tif (likely(0 == _urb->status)) {\n\t\tunsigned int padding;\n\t\tstruct sk_buff *skb;\n\t\tunsigned int qlen;\n\t\tunsigned int size = _urb->actual_length;\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tif (size < RTL_RX_DESC_SIZE + sizeof(struct ieee80211_hdr)) {\n\t\t\tpr_err(\"Too short packet from bulk IN! (len: %d)\\n\",\n\t\t\t       size);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\tqlen = skb_queue_len(&rtlusb->rx_queue);\n\t\tif (qlen >= __RX_SKB_MAX_QUEUED) {\n\t\t\tpr_err(\"Pending RX skbuff queue full! (qlen: %d)\\n\",\n\t\t\t       qlen);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\thdr = (void *)(_urb->transfer_buffer + RTL_RX_DESC_SIZE);\n\t\tpadding = _rtl_rx_get_padding(hdr, size - RTL_RX_DESC_SIZE);\n\n\t\tskb = dev_alloc_skb(size + __RADIO_TAP_SIZE_RSV + padding);\n\t\tif (!skb) {\n\t\t\tpr_err(\"Can't allocate skb for bulk IN!\\n\");\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\t_rtl_install_trx_info(rtlusb, skb, rtlusb->in_ep);\n\n\t\t/* Make sure the payload data is 4 byte aligned. */\n\t\tskb_reserve(skb, padding);\n\n\t\t/* reserve some space for mac80211's radiotap */\n\t\tskb_reserve(skb, __RADIO_TAP_SIZE_RSV);\n\n\t\tskb_put_data(skb, _urb->transfer_buffer, size);\n\n\t\tskb_queue_tail(&rtlusb->rx_queue, skb);\n\t\ttasklet_schedule(&rtlusb->rx_work_tasklet);\n\n\t\tgoto resubmit;\n\t}\n\n\tswitch (_urb->status) {\n\t/* disconnect */\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\tgoto free;\n\tdefault:\n\t\tbreak;\n\t}\n\nresubmit:\n\tusb_anchor_urb(_urb, &rtlusb->rx_submitted);\n\terr = usb_submit_urb(_urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tusb_unanchor_urb(_urb);\n\t\tgoto free;\n\t}\n\treturn;\n\nfree:\n\t/* On some architectures, usb_free_coherent must not be called from\n\t * hardirq context. Queue urb to cleanup list.\n\t */\n\tusb_anchor_urb(_urb, &rtlusb->rx_cleanup_urbs);\n}\n\n#undef __RADIO_TAP_SIZE_RSV\n\nstatic void _rtl_usb_cleanup_rx(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *urb;\n\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\n\ttasklet_kill(&rtlusb->rx_work_tasklet);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\n\tflush_workqueue(rtlpriv->works.rtl_wq);\n\tdestroy_workqueue(rtlpriv->works.rtl_wq);\n\n\tskb_queue_purge(&rtlusb->rx_queue);\n\n\twhile ((urb = usb_get_from_anchor(&rtlusb->rx_cleanup_urbs))) {\n\t\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t\turb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int _rtl_usb_receive(struct ieee80211_hw *hw)\n{\n\tstruct urb *urb;\n\tint err;\n\tint i;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tWARN_ON(0 == rtlusb->rx_urb_num);\n\t/* 1600 == 1514 + max WLAN header + rtk info */\n\tWARN_ON(rtlusb->rx_max_size < 1600);\n\n\tfor (i = 0; i < rtlusb->rx_urb_num; i++) {\n\t\terr = -ENOMEM;\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\tgoto err_out;\n\n\t\terr = _rtl_prep_rx_urb(hw, rtlusb, urb, GFP_KERNEL);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Failed to prep_rx_urb!!\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &rtlusb->rx_submitted);\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\n\nerr_out:\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\t_rtl_usb_cleanup_rx(hw);\n\treturn err;\n}\n\nstatic int rtl_usb_start(struct ieee80211_hw *hw)\n{\n\tint err;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\terr = rtlpriv->cfg->ops->hw_init(hw);\n\tif (!err) {\n\t\trtl_init_rx_config(hw);\n\n\t\t/* Enable software */\n\t\tSET_USB_START(rtlusb);\n\t\t/* should after adapter start and interrupt enable. */\n\t\tset_hal_start(rtlhal);\n\n\t\t/* Start bulk IN */\n\t\terr = _rtl_usb_receive(hw);\n\t}\n\n\treturn err;\n}\n\n/*=======================  tx =========================================*/\nstatic void rtl_usb_cleanup(struct ieee80211_hw *hw)\n{\n\tu32 i;\n\tstruct sk_buff *_skb;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct ieee80211_tx_info *txinfo;\n\n\t/* clean up rx stuff. */\n\t_rtl_usb_cleanup_rx(hw);\n\n\t/* clean up tx stuff */\n\tfor (i = 0; i < RTL_USB_MAX_EP_NUM; i++) {\n\t\twhile ((_skb = skb_dequeue(&rtlusb->tx_skb_queue[i]))) {\n\t\t\trtlusb->usb_tx_cleanup(hw, _skb);\n\t\t\ttxinfo = IEEE80211_SKB_CB(_skb);\n\t\t\tieee80211_tx_info_clear_status(txinfo);\n\t\t\ttxinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\tieee80211_tx_status_irqsafe(hw, _skb);\n\t\t}\n\t\tusb_kill_anchored_urbs(&rtlusb->tx_pending[i]);\n\t}\n\tusb_kill_anchored_urbs(&rtlusb->tx_submitted);\n}\n\n/* We may add some struct into struct rtl_usb later. Do deinit here.  */\nstatic void rtl_usb_deinit(struct ieee80211_hw *hw)\n{\n\trtl_usb_cleanup(hw);\n}\n\nstatic void rtl_usb_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *urb;\n\n\t/* should after adapter start and interrupt enable. */\n\tset_hal_stop(rtlhal);\n\tcancel_work_sync(&rtlpriv->works.fill_h2c_cmd);\n\t/* Enable software */\n\tSET_USB_STOP(rtlusb);\n\n\t/* free pre-allocated URBs from rtl_usb_start() */\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\n\ttasklet_kill(&rtlusb->rx_work_tasklet);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\n\tflush_workqueue(rtlpriv->works.rtl_wq);\n\n\tskb_queue_purge(&rtlusb->rx_queue);\n\n\twhile ((urb = usb_get_from_anchor(&rtlusb->rx_cleanup_urbs))) {\n\t\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t\turb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n\n\trtlpriv->cfg->ops->hw_disable(hw);\n}\n\nstatic void _rtl_submit_tx_urb(struct ieee80211_hw *hw, struct urb *_urb)\n{\n\tint err;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tusb_anchor_urb(_urb, &rtlusb->tx_submitted);\n\terr = usb_submit_urb(_urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tstruct sk_buff *skb;\n\n\t\tpr_err(\"Failed to submit urb\\n\");\n\t\tusb_unanchor_urb(_urb);\n\t\tskb = (struct sk_buff *)_urb->context;\n\t\tkfree_skb(skb);\n\t}\n\tusb_free_urb(_urb);\n}\n\nstatic int _usb_tx_post(struct ieee80211_hw *hw, struct urb *urb,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct ieee80211_tx_info *txinfo;\n\n\trtlusb->usb_tx_post_hdl(hw, urb, skb);\n\tskb_pull(skb, RTL_TX_HEADER_SIZE);\n\ttxinfo = IEEE80211_SKB_CB(skb);\n\tieee80211_tx_info_clear_status(txinfo);\n\ttxinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tif (urb->status) {\n\t\tpr_err(\"Urb has error status 0x%X\\n\", urb->status);\n\t\tgoto out;\n\t}\n\t/*  TODO:\tstatistics */\nout:\n\tieee80211_tx_status_irqsafe(hw, skb);\n\treturn urb->status;\n}\n\nstatic void _rtl_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)info->rate_driver_data[0];\n\tstruct ieee80211_hw *hw = usb_get_intfdata(rtlusb->intf);\n\tint err;\n\n\tif (unlikely(IS_USB_STOP(rtlusb)))\n\t\treturn;\n\terr = _usb_tx_post(hw, urb, skb);\n\tif (err) {\n\t\t/* Ignore error and keep issuiing other urbs */\n\t\treturn;\n\t}\n}\n\nstatic struct urb *_rtl_usb_tx_urb_setup(struct ieee80211_hw *hw,\n\t\t\t\tstruct sk_buff *skb, u32 ep_num)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *_urb;\n\n\tWARN_ON(NULL == skb);\n\t_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!_urb) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\t_rtl_install_trx_info(rtlusb, skb, ep_num);\n\tusb_fill_bulk_urb(_urb, rtlusb->udev, usb_sndbulkpipe(rtlusb->udev,\n\t\t\t  ep_num), skb->data, skb->len, _rtl_tx_complete, skb);\n\t_urb->transfer_flags |= URB_ZERO_PACKET;\n\treturn _urb;\n}\n\nstatic void _rtl_usb_transmit(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t       enum rtl_txq qnum)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tu32 ep_num;\n\tstruct urb *_urb = NULL;\n\tstruct sk_buff *_skb = NULL;\n\n\tWARN_ON(NULL == rtlusb->usb_tx_aggregate_hdl);\n\tif (unlikely(IS_USB_STOP(rtlusb))) {\n\t\tpr_err(\"USB device is stopping...\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tep_num = rtlusb->ep_map.ep_mapping[qnum];\n\t_skb = skb;\n\t_urb = _rtl_usb_tx_urb_setup(hw, _skb, ep_num);\n\tif (unlikely(!_urb)) {\n\t\tpr_err(\"Can't allocate urb. Drop skb!\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\t_rtl_submit_tx_urb(hw, _urb);\n}\n\nstatic void _rtl_usb_tx_preprocess(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u16 hw_queue)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl_tx_desc *pdesc = NULL;\n\tstruct rtl_tcb_desc tcb_desc;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);\n\t__le16 fc = hdr->frame_control;\n\tu8 *pda_addr = hdr->addr1;\n\n\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\tif (ieee80211_is_auth(fc)) {\n\t\tRT_TRACE(rtlpriv, COMP_SEND, DBG_DMESG, \"MAC80211_LINKING\\n\");\n\t}\n\n\tif (rtlpriv->psc.sw_ps_enabled) {\n\t\tif (ieee80211_is_data(fc) && !ieee80211_is_nullfunc(fc) &&\n\t\t    !ieee80211_has_pm(fc))\n\t\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t}\n\n\trtl_action_proc(hw, skb, true);\n\tif (is_multicast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesmulticast += skb->len;\n\telse if (is_broadcast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesbroadcast += skb->len;\n\telse\n\t\trtlpriv->stats.txbytesunicast += skb->len;\n\trtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *)pdesc, NULL, info, sta, skb,\n\t\t\t\t\thw_queue, &tcb_desc);\n\tif (ieee80211_is_data(fc))\n\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_TX);\n}\n\nstatic int rtl_usb_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_sta *sta,\n\t\t      struct sk_buff *skb,\n\t\t      struct rtl_tcb_desc *dummy)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);\n\t__le16 fc = hdr->frame_control;\n\tu16 hw_queue;\n\n\tif (unlikely(is_hal_stop(rtlhal)))\n\t\tgoto err_free;\n\thw_queue = rtlusb->usb_mq_to_hwq(fc, skb_get_queue_mapping(skb));\n\t_rtl_usb_tx_preprocess(hw, sta, skb, hw_queue);\n\t_rtl_usb_transmit(hw, skb, hw_queue);\n\treturn NETDEV_TX_OK;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic bool rtl_usb_tx_chk_waitq_insert(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\treturn false;\n}\n\nstatic void rtl_fill_h2c_cmd_work_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks =\n\t    container_of(work, struct rtl_works, fill_h2c_cmd);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->cfg->ops->fill_h2c_cmd(hw, H2C_RA_MASK, 5, rtlpriv->rate_mask);\n}\n\nstatic const struct rtl_intf_ops rtl_usb_ops = {\n\t.adapter_start = rtl_usb_start,\n\t.adapter_stop = rtl_usb_stop,\n\t.adapter_tx = rtl_usb_tx,\n\t.waitq_insert = rtl_usb_tx_chk_waitq_insert,\n};\n\nint rtl_usb_probe(struct usb_interface *intf,\n\t\t  const struct usb_device_id *id,\n\t\t  struct rtl_hal_cfg *rtl_hal_cfg)\n{\n\tint err;\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct rtl_priv *rtlpriv = NULL;\n\tstruct usb_device\t*udev;\n\tstruct rtl_usb_priv *usb_priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +\n\t\t\t\tsizeof(struct rtl_usb_priv), &rtl_ops);\n\tif (!hw) {\n\t\tWARN_ONCE(true, \"rtl_usb: ieee80211 alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trtlpriv = hw->priv;\n\trtlpriv->hw = hw;\n\trtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rtlpriv->usb_data)\n\t\treturn -ENOMEM;\n\n\t/* this spin lock must be initialized early */\n\tspin_lock_init(&rtlpriv->locks.usb_lock);\n\tINIT_WORK(&rtlpriv->works.fill_h2c_cmd,\n\t\t  rtl_fill_h2c_cmd_work_callback);\n\tINIT_WORK(&rtlpriv->works.lps_change_work,\n\t\t  rtl_lps_change_work_callback);\n\n\trtlpriv->usb_data_index = 0;\n\tinit_completion(&rtlpriv->firmware_loading_complete);\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\tudev = interface_to_usbdev(intf);\n\tusb_get_dev(udev);\n\tusb_priv = rtl_usbpriv(hw);\n\tmemset(usb_priv, 0, sizeof(*usb_priv));\n\tusb_priv->dev.intf = intf;\n\tusb_priv->dev.udev = udev;\n\tusb_set_intfdata(intf, hw);\n\t/* init cfg & intf_ops */\n\trtlpriv->rtlhal.interface = INTF_USB;\n\trtlpriv->cfg = rtl_hal_cfg;\n\trtlpriv->intf_ops = &rtl_usb_ops;\n\t/* Init IO handler */\n\t_rtl_usb_io_handler_init(&udev->dev, hw);\n\trtlpriv->cfg->ops->read_chip_version(hw);\n\t/*like read eeprom and so on */\n\trtlpriv->cfg->ops->read_eeprom_info(hw);\n\terr = _rtl_usb_init(hw);\n\tif (err)\n\t\tgoto error_out2;\n\trtl_usb_init_sw(hw);\n\t/* Init mac80211 sw */\n\terr = rtl_init_core(hw);\n\tif (err) {\n\t\tpr_err(\"Can't allocate sw for mac80211\\n\");\n\t\tgoto error_out2;\n\t}\n\tif (rtlpriv->cfg->ops->init_sw_vars(hw)) {\n\t\tpr_err(\"Can't init_sw_vars\\n\");\n\t\tgoto error_out;\n\t}\n\trtlpriv->cfg->ops->init_sw_leds(hw);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err) {\n\t\tpr_err(\"Can't register mac80211 hw.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error_out;\n\t}\n\trtlpriv->mac80211.mac80211_registered = 1;\n\n\tset_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\treturn 0;\n\nerror_out:\n\trtl_deinit_core(hw);\nerror_out2:\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(udev);\n\tcomplete(&rtlpriv->firmware_loading_complete);\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(rtl_usb_probe);\n\nvoid rtl_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tif (unlikely(!rtlpriv))\n\t\treturn;\n\t/* just in case driver is removed before firmware callback */\n\twait_for_completion(&rtlpriv->firmware_loading_complete);\n\tclear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\t/*ieee80211_unregister_hw will call ops_stop */\n\tif (rtlmac->mac80211_registered == 1) {\n\t\tieee80211_unregister_hw(hw);\n\t\trtlmac->mac80211_registered = 0;\n\t} else {\n\t\trtl_deinit_deferred_work(hw, false);\n\t\trtlpriv->intf_ops->adapter_stop(hw);\n\t}\n\t/*deinit rfkill */\n\t/* rtl_deinit_rfkill(hw); */\n\trtl_usb_deinit(hw);\n\trtl_deinit_core(hw);\n\tkfree(rtlpriv->usb_data);\n\trtlpriv->cfg->ops->deinit_sw_leds(hw);\n\trtlpriv->cfg->ops->deinit_sw_vars(hw);\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(rtlusb->udev);\n\tusb_set_intfdata(intf, NULL);\n\tieee80211_free_hw(hw);\n}\nEXPORT_SYMBOL(rtl_usb_disconnect);\n\nint rtl_usb_suspend(struct usb_interface *pusb_intf, pm_message_t message)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_usb_suspend);\n\nint rtl_usb_resume(struct usb_interface *pusb_intf)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_usb_resume);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright(c) 2009-2012  Realtek Corporation.*/\n\n#include \"wifi.h\"\n#include \"core.h\"\n#include \"usb.h\"\n#include \"base.h\"\n#include \"ps.h\"\n#include \"rtl8192c/fw_common.h\"\n#include <linux/export.h>\n#include <linux/module.h>\n\nMODULE_AUTHOR(\"lizhaoming\t<chaoming_li@realsil.com.cn>\");\nMODULE_AUTHOR(\"Realtek WlanFAE\t<wlanfae@realtek.com>\");\nMODULE_AUTHOR(\"Larry Finger\t<Larry.FInger@lwfinger.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"USB basic driver for rtlwifi\");\n\n#define\tREALTEK_USB_VENQT_READ\t\t\t0xC0\n#define\tREALTEK_USB_VENQT_WRITE\t\t\t0x40\n#define REALTEK_USB_VENQT_CMD_REQ\t\t0x05\n#define\tREALTEK_USB_VENQT_CMD_IDX\t\t0x00\n\n#define MAX_USBCTRL_VENDORREQ_TIMES\t\t10\n\nstatic void usbctrl_async_callback(struct urb *urb)\n{\n\tif (urb) {\n\t\t/* free dr */\n\t\tkfree(urb->setup_packet);\n\t\t/* free databuf */\n\t\tkfree(urb->transfer_buffer);\n\t}\n}\n\nstatic int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,\n\t\t\t\t\t  u16 value, u16 index, void *pdata,\n\t\t\t\t\t  u16 len)\n{\n\tint rc;\n\tunsigned int pipe;\n\tu8 reqtype;\n\tstruct usb_ctrlrequest *dr;\n\tstruct urb *urb;\n\tconst u16 databuf_maxlen = REALTEK_USB_VENQT_MAX_BUF_SIZE;\n\tu8 *databuf;\n\n\tif (WARN_ON_ONCE(len > databuf_maxlen))\n\t\tlen = databuf_maxlen;\n\n\tpipe = usb_sndctrlpipe(udev, 0); /* write_out */\n\treqtype =  REALTEK_USB_VENQT_WRITE;\n\n\tdr = kzalloc(sizeof(*dr), GFP_ATOMIC);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdatabuf = kzalloc(databuf_maxlen, GFP_ATOMIC);\n\tif (!databuf) {\n\t\tkfree(dr);\n\t\treturn -ENOMEM;\n\t}\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tkfree(databuf);\n\t\tkfree(dr);\n\t\treturn -ENOMEM;\n\t}\n\n\tdr->bRequestType = reqtype;\n\tdr->bRequest = request;\n\tdr->wValue = cpu_to_le16(value);\n\tdr->wIndex = cpu_to_le16(index);\n\tdr->wLength = cpu_to_le16(len);\n\t/* data are already in little-endian order */\n\tmemcpy(databuf, pdata, len);\n\tusb_fill_control_urb(urb, udev, pipe,\n\t\t\t     (unsigned char *)dr, databuf, len,\n\t\t\t     usbctrl_async_callback, NULL);\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc < 0) {\n\t\tkfree(databuf);\n\t\tkfree(dr);\n\t}\n\tusb_free_urb(urb);\n\treturn rc;\n}\n\nstatic int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,\n\t\t\t\t\tu16 value, u16 index, void *pdata,\n\t\t\t\t\tu16 len)\n{\n\tunsigned int pipe;\n\tint status;\n\tu8 reqtype;\n\tint vendorreq_times = 0;\n\tstatic int count;\n\n\tpipe = usb_rcvctrlpipe(udev, 0); /* read_in */\n\treqtype =  REALTEK_USB_VENQT_READ;\n\n\tdo {\n\t\tstatus = usb_control_msg(udev, pipe, request, reqtype, value,\n\t\t\t\t\t index, pdata, len, 1000);\n\t\tif (status < 0) {\n\t\t\t/* firmware download is checksumed, don't retry */\n\t\t\tif ((value >= FW_8192C_START_ADDRESS &&\n\t\t\t    value <= FW_8192C_END_ADDRESS))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (++vendorreq_times < MAX_USBCTRL_VENDORREQ_TIMES);\n\n\tif (status < 0 && count++ < 4)\n\t\tpr_err(\"reg 0x%x, usbctrl_vendorreq TimeOut! status:0x%x value=0x%x\\n\",\n\t\t       value, status, *(u32 *)pdata);\n\treturn status;\n}\n\nstatic u32 _usb_read_sync(struct rtl_priv *rtlpriv, u32 addr, u16 len)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\tstruct usb_device *udev = to_usb_device(dev);\n\tu8 request;\n\tu16 wvalue;\n\tu16 index;\n\t__le32 *data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtlpriv->locks.usb_lock, flags);\n\tif (++rtlpriv->usb_data_index >= RTL_USB_MAX_RX_COUNT)\n\t\trtlpriv->usb_data_index = 0;\n\tdata = &rtlpriv->usb_data[rtlpriv->usb_data_index];\n\tspin_unlock_irqrestore(&rtlpriv->locks.usb_lock, flags);\n\trequest = REALTEK_USB_VENQT_CMD_REQ;\n\tindex = REALTEK_USB_VENQT_CMD_IDX; /* n/a */\n\n\twvalue = (u16)addr;\n\t_usbctrl_vendorreq_sync_read(udev, request, wvalue, index, data, len);\n\treturn le32_to_cpu(*data);\n}\n\nstatic u8 _usb_read8_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn (u8)_usb_read_sync(rtlpriv, addr, 1);\n}\n\nstatic u16 _usb_read16_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn (u16)_usb_read_sync(rtlpriv, addr, 2);\n}\n\nstatic u32 _usb_read32_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn _usb_read_sync(rtlpriv, addr, 4);\n}\n\nstatic void _usb_write_async(struct usb_device *udev, u32 addr, u32 val,\n\t\t\t     u16 len)\n{\n\tu8 request;\n\tu16 wvalue;\n\tu16 index;\n\t__le32 data;\n\n\trequest = REALTEK_USB_VENQT_CMD_REQ;\n\tindex = REALTEK_USB_VENQT_CMD_IDX; /* n/a */\n\twvalue = (u16)(addr&0x0000ffff);\n\tdata = cpu_to_le32(val);\n\t_usbctrl_vendorreq_async_write(udev, request, wvalue, index, &data,\n\t\t\t\t       len);\n}\n\nstatic void _usb_write8_async(struct rtl_priv *rtlpriv, u32 addr, u8 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 1);\n}\n\nstatic void _usb_write16_async(struct rtl_priv *rtlpriv, u32 addr, u16 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 2);\n}\n\nstatic void _usb_write32_async(struct rtl_priv *rtlpriv, u32 addr, u32 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 4);\n}\n\nstatic void _usb_writen_sync(struct rtl_priv *rtlpriv, u32 addr, void *data,\n\t\t\t     u16 len)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\tstruct usb_device *udev = to_usb_device(dev);\n\tu8 request = REALTEK_USB_VENQT_CMD_REQ;\n\tu8 reqtype =  REALTEK_USB_VENQT_WRITE;\n\tu16 wvalue;\n\tu16 index = REALTEK_USB_VENQT_CMD_IDX;\n\tint pipe = usb_sndctrlpipe(udev, 0); /* write_out */\n\tu8 *buffer;\n\n\twvalue = (u16)(addr & 0x0000ffff);\n\tbuffer = kmemdup(data, len, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn;\n\tusb_control_msg(udev, pipe, request, reqtype, wvalue,\n\t\t\tindex, buffer, len, 50);\n\n\tkfree(buffer);\n}\n\nstatic void _rtl_usb_io_handler_init(struct device *dev,\n\t\t\t\t     struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->io.dev = dev;\n\tmutex_init(&rtlpriv->io.bb_mutex);\n\trtlpriv->io.write8_async\t= _usb_write8_async;\n\trtlpriv->io.write16_async\t= _usb_write16_async;\n\trtlpriv->io.write32_async\t= _usb_write32_async;\n\trtlpriv->io.read8_sync\t\t= _usb_read8_sync;\n\trtlpriv->io.read16_sync\t\t= _usb_read16_sync;\n\trtlpriv->io.read32_sync\t\t= _usb_read32_sync;\n\trtlpriv->io.writen_sync\t\t= _usb_writen_sync;\n}\n\nstatic void _rtl_usb_io_handler_release(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv __maybe_unused *rtlpriv = rtl_priv(hw);\n\n\tmutex_destroy(&rtlpriv->io.bb_mutex);\n}\n\n/*\tDefault aggregation handler. Do nothing and just return the oldest skb.  */\nstatic struct sk_buff *_none_usb_tx_aggregate_hdl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct sk_buff_head *list)\n{\n\treturn skb_dequeue(list);\n}\n\n#define IS_HIGH_SPEED_USB(udev) \\\n\t\t((USB_SPEED_HIGH == (udev)->speed) ? true : false)\n\nstatic int _rtl_usb_init_tx(struct ieee80211_hw *hw)\n{\n\tu32 i;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\trtlusb->max_bulk_out_size = IS_HIGH_SPEED_USB(rtlusb->udev)\n\t\t\t\t\t\t    ? USB_HIGH_SPEED_BULK_SIZE\n\t\t\t\t\t\t    : USB_FULL_SPEED_BULK_SIZE;\n\n\tRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, \"USB Max Bulk-out Size=%d\\n\",\n\t\t rtlusb->max_bulk_out_size);\n\n\tfor (i = 0; i < __RTL_TXQ_NUM; i++) {\n\t\tu32 ep_num = rtlusb->ep_map.ep_mapping[i];\n\n\t\tif (!ep_num) {\n\t\t\tRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t \"Invalid endpoint map setting!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trtlusb->usb_tx_post_hdl =\n\t\t rtlpriv->cfg->usb_interface_cfg->usb_tx_post_hdl;\n\trtlusb->usb_tx_cleanup\t=\n\t\t rtlpriv->cfg->usb_interface_cfg->usb_tx_cleanup;\n\trtlusb->usb_tx_aggregate_hdl =\n\t\t (rtlpriv->cfg->usb_interface_cfg->usb_tx_aggregate_hdl)\n\t\t ? rtlpriv->cfg->usb_interface_cfg->usb_tx_aggregate_hdl\n\t\t : &_none_usb_tx_aggregate_hdl;\n\n\tinit_usb_anchor(&rtlusb->tx_submitted);\n\tfor (i = 0; i < RTL_USB_MAX_EP_NUM; i++) {\n\t\tskb_queue_head_init(&rtlusb->tx_skb_queue[i]);\n\t\tinit_usb_anchor(&rtlusb->tx_pending[i]);\n\t}\n\treturn 0;\n}\n\nstatic void _rtl_rx_work(unsigned long param);\n\nstatic int _rtl_usb_init_rx(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\n\trtlusb->rx_max_size = rtlpriv->cfg->usb_interface_cfg->rx_max_size;\n\trtlusb->rx_urb_num = rtlpriv->cfg->usb_interface_cfg->rx_urb_num;\n\trtlusb->in_ep = rtlpriv->cfg->usb_interface_cfg->in_ep_num;\n\trtlusb->usb_rx_hdl = rtlpriv->cfg->usb_interface_cfg->usb_rx_hdl;\n\trtlusb->usb_rx_segregate_hdl =\n\t\trtlpriv->cfg->usb_interface_cfg->usb_rx_segregate_hdl;\n\n\tpr_info(\"rx_max_size %d, rx_urb_num %d, in_ep %d\\n\",\n\t\trtlusb->rx_max_size, rtlusb->rx_urb_num, rtlusb->in_ep);\n\tinit_usb_anchor(&rtlusb->rx_submitted);\n\tinit_usb_anchor(&rtlusb->rx_cleanup_urbs);\n\n\tskb_queue_head_init(&rtlusb->rx_queue);\n\trtlusb->rx_work_tasklet.func = _rtl_rx_work;\n\trtlusb->rx_work_tasklet.data = (unsigned long)rtlusb;\n\n\treturn 0;\n}\n\nstatic int _rtl_usb_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\tint err;\n\tu8 epidx;\n\tstruct usb_interface\t*usb_intf = rtlusb->intf;\n\tu8 epnums = usb_intf->cur_altsetting->desc.bNumEndpoints;\n\n\trtlusb->out_ep_nums = rtlusb->in_ep_nums = 0;\n\tfor (epidx = 0; epidx < epnums; epidx++) {\n\t\tstruct usb_endpoint_descriptor *pep_desc;\n\n\t\tpep_desc = &usb_intf->cur_altsetting->endpoint[epidx].desc;\n\n\t\tif (usb_endpoint_dir_in(pep_desc))\n\t\t\trtlusb->in_ep_nums++;\n\t\telse if (usb_endpoint_dir_out(pep_desc))\n\t\t\trtlusb->out_ep_nums++;\n\n\t\tRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t \"USB EP(0x%02x), MaxPacketSize=%d, Interval=%d\\n\",\n\t\t\t pep_desc->bEndpointAddress, pep_desc->wMaxPacketSize,\n\t\t\t pep_desc->bInterval);\n\t}\n\tif (rtlusb->in_ep_nums <  rtlpriv->cfg->usb_interface_cfg->in_ep_num) {\n\t\tpr_err(\"Too few input end points found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtlusb->out_ep_nums == 0) {\n\t\tpr_err(\"No output end points found\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* usb endpoint mapping */\n\terr = rtlpriv->cfg->usb_interface_cfg->usb_endpoint_mapping(hw);\n\trtlusb->usb_mq_to_hwq =  rtlpriv->cfg->usb_interface_cfg->usb_mq_to_hwq;\n\t_rtl_usb_init_tx(hw);\n\t_rtl_usb_init_rx(hw);\n\treturn err;\n}\n\nstatic void rtl_usb_init_sw(struct ieee80211_hw *hw)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\trtlhal->hw = hw;\n\tppsc->inactiveps = false;\n\tppsc->leisure_ps = false;\n\tppsc->fwctrl_lps = false;\n\tppsc->reg_fwctrl_lps = 3;\n\tppsc->reg_max_lps_awakeintvl = 5;\n\tppsc->fwctrl_psmode = FW_PS_DTIM_MODE;\n\n\t /* IBSS */\n\tmac->beacon_interval = 100;\n\n\t /* AMPDU */\n\tmac->min_space_cfg = 0;\n\tmac->max_mss_density = 0;\n\n\t/* set sane AMPDU defaults */\n\tmac->current_ampdu_density = 7;\n\tmac->current_ampdu_factor = 3;\n\n\t/* QOS */\n\trtlusb->acm_method = EACMWAY2_SW;\n\n\t/* IRQ */\n\t/* HIMR - turn all on */\n\trtlusb->irq_mask[0] = 0xFFFFFFFF;\n\t/* HIMR_EX - turn all on */\n\trtlusb->irq_mask[1] = 0xFFFFFFFF;\n\trtlusb->disablehwsm =  true;\n}\n\nstatic void _rtl_rx_completed(struct urb *urb);\n\nstatic int _rtl_prep_rx_urb(struct ieee80211_hw *hw, struct rtl_usb *rtlusb,\n\t\t\t      struct urb *urb, gfp_t gfp_mask)\n{\n\tvoid *buf;\n\n\tbuf = usb_alloc_coherent(rtlusb->udev, rtlusb->rx_max_size, gfp_mask,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tpr_err(\"Failed to usb_alloc_coherent!!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_fill_bulk_urb(urb, rtlusb->udev,\n\t\t\t  usb_rcvbulkpipe(rtlusb->udev, rtlusb->in_ep),\n\t\t\t  buf, rtlusb->rx_max_size, _rtl_rx_completed, rtlusb);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn 0;\n}\n\nstatic void _rtl_usb_rx_process_agg(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *rxdesc = skb->data;\n\tstruct ieee80211_hdr *hdr;\n\tbool unicast = false;\n\t__le16 fc;\n\tstruct ieee80211_rx_status rx_status = {0};\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\n\tskb_pull(skb, RTL_RX_DESC_SIZE);\n\trtlpriv->cfg->ops->query_rx_desc(hw, &stats, &rx_status, rxdesc, skb);\n\tskb_pull(skb, (stats.rx_drvinfo_size + stats.rx_bufshift));\n\thdr = (struct ieee80211_hdr *)(skb->data);\n\tfc = hdr->frame_control;\n\tif (!stats.crc) {\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\t\tif (is_broadcast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/;\n\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/\n\t\t} else {\n\t\t\tunicast = true;\n\t\t\trtlpriv->stats.rxbytesunicast +=  skb->len;\n\t\t}\n\n\t\tif (ieee80211_is_data(fc)) {\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);\n\n\t\t\tif (unicast)\n\t\t\t\trtlpriv->link_info.num_rx_inperiod++;\n\t\t}\n\t\t/* static bcn for roaming */\n\t\trtl_beacon_statistic(hw, skb);\n\t}\n}\n\nstatic void _rtl_usb_rx_process_noagg(struct ieee80211_hw *hw,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *rxdesc = skb->data;\n\tstruct ieee80211_hdr *hdr;\n\tbool unicast = false;\n\t__le16 fc;\n\tstruct ieee80211_rx_status rx_status = {0};\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\n\tskb_pull(skb, RTL_RX_DESC_SIZE);\n\trtlpriv->cfg->ops->query_rx_desc(hw, &stats, &rx_status, rxdesc, skb);\n\tskb_pull(skb, (stats.rx_drvinfo_size + stats.rx_bufshift));\n\thdr = (struct ieee80211_hdr *)(skb->data);\n\tfc = hdr->frame_control;\n\tif (!stats.crc) {\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\t\tif (is_broadcast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/;\n\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t/*TODO*/\n\t\t} else {\n\t\t\tunicast = true;\n\t\t\trtlpriv->stats.rxbytesunicast +=  skb->len;\n\t\t}\n\n\t\tif (ieee80211_is_data(fc)) {\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);\n\n\t\t\tif (unicast)\n\t\t\t\trtlpriv->link_info.num_rx_inperiod++;\n\t\t}\n\n\t\t/* static bcn for roaming */\n\t\trtl_beacon_statistic(hw, skb);\n\n\t\tif (likely(rtl_action_proc(hw, skb, false)))\n\t\t\tieee80211_rx(hw, skb);\n\t\telse\n\t\t\tdev_kfree_skb_any(skb);\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void _rtl_rx_pre_process(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct sk_buff *_skb;\n\tstruct sk_buff_head rx_queue;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tskb_queue_head_init(&rx_queue);\n\tif (rtlusb->usb_rx_segregate_hdl)\n\t\trtlusb->usb_rx_segregate_hdl(hw, skb, &rx_queue);\n\tWARN_ON(skb_queue_empty(&rx_queue));\n\twhile (!skb_queue_empty(&rx_queue)) {\n\t\t_skb = skb_dequeue(&rx_queue);\n\t\t_rtl_usb_rx_process_agg(hw, _skb);\n\t\tieee80211_rx(hw, _skb);\n\t}\n}\n\n#define __RX_SKB_MAX_QUEUED\t64\n\nstatic void _rtl_rx_work(unsigned long param)\n{\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)param;\n\tstruct ieee80211_hw *hw = usb_get_intfdata(rtlusb->intf);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&rtlusb->rx_queue))) {\n\t\tif (unlikely(IS_USB_STOP(rtlusb))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (likely(!rtlusb->usb_rx_segregate_hdl)) {\n\t\t\t_rtl_usb_rx_process_noagg(hw, skb);\n\t\t} else {\n\t\t\t/* TO DO */\n\t\t\t_rtl_rx_pre_process(hw, skb);\n\t\t\tpr_err(\"rx agg not supported\\n\");\n\t\t}\n\t}\n}\n\nstatic unsigned int _rtl_rx_get_padding(struct ieee80211_hdr *hdr,\n\t\t\t\t\tunsigned int len)\n{\n#if NET_IP_ALIGN != 0\n\tunsigned int padding = 0;\n#endif\n\n\t/* make function no-op when possible */\n\tif (NET_IP_ALIGN == 0 || len < sizeof(*hdr))\n\t\treturn 0;\n\n#if NET_IP_ALIGN != 0\n\t/* alignment calculation as in lbtf_rx() / carl9170_rx_copy_data() */\n\t/* TODO: deduplicate common code, define helper function instead? */\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\n\t\tpadding ^= NET_IP_ALIGN;\n\n\t\t/* Input might be invalid, avoid accessing memory outside\n\t\t * the buffer.\n\t\t */\n\t\tif ((unsigned long)qc - (unsigned long)hdr < len &&\n\t\t    *qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)\n\t\t\tpadding ^= NET_IP_ALIGN;\n\t}\n\n\tif (ieee80211_has_a4(hdr->frame_control))\n\t\tpadding ^= NET_IP_ALIGN;\n\n\treturn padding;\n#endif\n}\n\n#define __RADIO_TAP_SIZE_RSV\t32\n\nstatic void _rtl_rx_completed(struct urb *_urb)\n{\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)_urb->context;\n\tint err = 0;\n\n\tif (unlikely(IS_USB_STOP(rtlusb)))\n\t\tgoto free;\n\n\tif (likely(0 == _urb->status)) {\n\t\tunsigned int padding;\n\t\tstruct sk_buff *skb;\n\t\tunsigned int qlen;\n\t\tunsigned int size = _urb->actual_length;\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tif (size < RTL_RX_DESC_SIZE + sizeof(struct ieee80211_hdr)) {\n\t\t\tpr_err(\"Too short packet from bulk IN! (len: %d)\\n\",\n\t\t\t       size);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\tqlen = skb_queue_len(&rtlusb->rx_queue);\n\t\tif (qlen >= __RX_SKB_MAX_QUEUED) {\n\t\t\tpr_err(\"Pending RX skbuff queue full! (qlen: %d)\\n\",\n\t\t\t       qlen);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\thdr = (void *)(_urb->transfer_buffer + RTL_RX_DESC_SIZE);\n\t\tpadding = _rtl_rx_get_padding(hdr, size - RTL_RX_DESC_SIZE);\n\n\t\tskb = dev_alloc_skb(size + __RADIO_TAP_SIZE_RSV + padding);\n\t\tif (!skb) {\n\t\t\tpr_err(\"Can't allocate skb for bulk IN!\\n\");\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\t_rtl_install_trx_info(rtlusb, skb, rtlusb->in_ep);\n\n\t\t/* Make sure the payload data is 4 byte aligned. */\n\t\tskb_reserve(skb, padding);\n\n\t\t/* reserve some space for mac80211's radiotap */\n\t\tskb_reserve(skb, __RADIO_TAP_SIZE_RSV);\n\n\t\tskb_put_data(skb, _urb->transfer_buffer, size);\n\n\t\tskb_queue_tail(&rtlusb->rx_queue, skb);\n\t\ttasklet_schedule(&rtlusb->rx_work_tasklet);\n\n\t\tgoto resubmit;\n\t}\n\n\tswitch (_urb->status) {\n\t/* disconnect */\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\tgoto free;\n\tdefault:\n\t\tbreak;\n\t}\n\nresubmit:\n\tusb_anchor_urb(_urb, &rtlusb->rx_submitted);\n\terr = usb_submit_urb(_urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tusb_unanchor_urb(_urb);\n\t\tgoto free;\n\t}\n\treturn;\n\nfree:\n\t/* On some architectures, usb_free_coherent must not be called from\n\t * hardirq context. Queue urb to cleanup list.\n\t */\n\tusb_anchor_urb(_urb, &rtlusb->rx_cleanup_urbs);\n}\n\n#undef __RADIO_TAP_SIZE_RSV\n\nstatic void _rtl_usb_cleanup_rx(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *urb;\n\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\n\ttasklet_kill(&rtlusb->rx_work_tasklet);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\n\tflush_workqueue(rtlpriv->works.rtl_wq);\n\tdestroy_workqueue(rtlpriv->works.rtl_wq);\n\n\tskb_queue_purge(&rtlusb->rx_queue);\n\n\twhile ((urb = usb_get_from_anchor(&rtlusb->rx_cleanup_urbs))) {\n\t\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t\turb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int _rtl_usb_receive(struct ieee80211_hw *hw)\n{\n\tstruct urb *urb;\n\tint err;\n\tint i;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tWARN_ON(0 == rtlusb->rx_urb_num);\n\t/* 1600 == 1514 + max WLAN header + rtk info */\n\tWARN_ON(rtlusb->rx_max_size < 1600);\n\n\tfor (i = 0; i < rtlusb->rx_urb_num; i++) {\n\t\terr = -ENOMEM;\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\tgoto err_out;\n\n\t\terr = _rtl_prep_rx_urb(hw, rtlusb, urb, GFP_KERNEL);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Failed to prep_rx_urb!!\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &rtlusb->rx_submitted);\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\n\nerr_out:\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\t_rtl_usb_cleanup_rx(hw);\n\treturn err;\n}\n\nstatic int rtl_usb_start(struct ieee80211_hw *hw)\n{\n\tint err;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\terr = rtlpriv->cfg->ops->hw_init(hw);\n\tif (!err) {\n\t\trtl_init_rx_config(hw);\n\n\t\t/* Enable software */\n\t\tSET_USB_START(rtlusb);\n\t\t/* should after adapter start and interrupt enable. */\n\t\tset_hal_start(rtlhal);\n\n\t\t/* Start bulk IN */\n\t\terr = _rtl_usb_receive(hw);\n\t}\n\n\treturn err;\n}\n\n/*=======================  tx =========================================*/\nstatic void rtl_usb_cleanup(struct ieee80211_hw *hw)\n{\n\tu32 i;\n\tstruct sk_buff *_skb;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct ieee80211_tx_info *txinfo;\n\n\t/* clean up rx stuff. */\n\t_rtl_usb_cleanup_rx(hw);\n\n\t/* clean up tx stuff */\n\tfor (i = 0; i < RTL_USB_MAX_EP_NUM; i++) {\n\t\twhile ((_skb = skb_dequeue(&rtlusb->tx_skb_queue[i]))) {\n\t\t\trtlusb->usb_tx_cleanup(hw, _skb);\n\t\t\ttxinfo = IEEE80211_SKB_CB(_skb);\n\t\t\tieee80211_tx_info_clear_status(txinfo);\n\t\t\ttxinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\tieee80211_tx_status_irqsafe(hw, _skb);\n\t\t}\n\t\tusb_kill_anchored_urbs(&rtlusb->tx_pending[i]);\n\t}\n\tusb_kill_anchored_urbs(&rtlusb->tx_submitted);\n}\n\n/* We may add some struct into struct rtl_usb later. Do deinit here.  */\nstatic void rtl_usb_deinit(struct ieee80211_hw *hw)\n{\n\trtl_usb_cleanup(hw);\n}\n\nstatic void rtl_usb_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *urb;\n\n\t/* should after adapter start and interrupt enable. */\n\tset_hal_stop(rtlhal);\n\tcancel_work_sync(&rtlpriv->works.fill_h2c_cmd);\n\t/* Enable software */\n\tSET_USB_STOP(rtlusb);\n\n\t/* free pre-allocated URBs from rtl_usb_start() */\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\n\ttasklet_kill(&rtlusb->rx_work_tasklet);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\n\tflush_workqueue(rtlpriv->works.rtl_wq);\n\n\tskb_queue_purge(&rtlusb->rx_queue);\n\n\twhile ((urb = usb_get_from_anchor(&rtlusb->rx_cleanup_urbs))) {\n\t\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t\turb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n\n\trtlpriv->cfg->ops->hw_disable(hw);\n}\n\nstatic void _rtl_submit_tx_urb(struct ieee80211_hw *hw, struct urb *_urb)\n{\n\tint err;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tusb_anchor_urb(_urb, &rtlusb->tx_submitted);\n\terr = usb_submit_urb(_urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tstruct sk_buff *skb;\n\n\t\tpr_err(\"Failed to submit urb\\n\");\n\t\tusb_unanchor_urb(_urb);\n\t\tskb = (struct sk_buff *)_urb->context;\n\t\tkfree_skb(skb);\n\t}\n\tusb_free_urb(_urb);\n}\n\nstatic int _usb_tx_post(struct ieee80211_hw *hw, struct urb *urb,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct ieee80211_tx_info *txinfo;\n\n\trtlusb->usb_tx_post_hdl(hw, urb, skb);\n\tskb_pull(skb, RTL_TX_HEADER_SIZE);\n\ttxinfo = IEEE80211_SKB_CB(skb);\n\tieee80211_tx_info_clear_status(txinfo);\n\ttxinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tif (urb->status) {\n\t\tpr_err(\"Urb has error status 0x%X\\n\", urb->status);\n\t\tgoto out;\n\t}\n\t/*  TODO:\tstatistics */\nout:\n\tieee80211_tx_status_irqsafe(hw, skb);\n\treturn urb->status;\n}\n\nstatic void _rtl_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)info->rate_driver_data[0];\n\tstruct ieee80211_hw *hw = usb_get_intfdata(rtlusb->intf);\n\tint err;\n\n\tif (unlikely(IS_USB_STOP(rtlusb)))\n\t\treturn;\n\terr = _usb_tx_post(hw, urb, skb);\n\tif (err) {\n\t\t/* Ignore error and keep issuiing other urbs */\n\t\treturn;\n\t}\n}\n\nstatic struct urb *_rtl_usb_tx_urb_setup(struct ieee80211_hw *hw,\n\t\t\t\tstruct sk_buff *skb, u32 ep_num)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *_urb;\n\n\tWARN_ON(NULL == skb);\n\t_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!_urb) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\t_rtl_install_trx_info(rtlusb, skb, ep_num);\n\tusb_fill_bulk_urb(_urb, rtlusb->udev, usb_sndbulkpipe(rtlusb->udev,\n\t\t\t  ep_num), skb->data, skb->len, _rtl_tx_complete, skb);\n\t_urb->transfer_flags |= URB_ZERO_PACKET;\n\treturn _urb;\n}\n\nstatic void _rtl_usb_transmit(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t       enum rtl_txq qnum)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tu32 ep_num;\n\tstruct urb *_urb = NULL;\n\tstruct sk_buff *_skb = NULL;\n\n\tWARN_ON(NULL == rtlusb->usb_tx_aggregate_hdl);\n\tif (unlikely(IS_USB_STOP(rtlusb))) {\n\t\tpr_err(\"USB device is stopping...\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tep_num = rtlusb->ep_map.ep_mapping[qnum];\n\t_skb = skb;\n\t_urb = _rtl_usb_tx_urb_setup(hw, _skb, ep_num);\n\tif (unlikely(!_urb)) {\n\t\tpr_err(\"Can't allocate urb. Drop skb!\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\t_rtl_submit_tx_urb(hw, _urb);\n}\n\nstatic void _rtl_usb_tx_preprocess(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u16 hw_queue)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl_tx_desc *pdesc = NULL;\n\tstruct rtl_tcb_desc tcb_desc;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);\n\t__le16 fc = hdr->frame_control;\n\tu8 *pda_addr = hdr->addr1;\n\n\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\tif (ieee80211_is_auth(fc)) {\n\t\tRT_TRACE(rtlpriv, COMP_SEND, DBG_DMESG, \"MAC80211_LINKING\\n\");\n\t}\n\n\tif (rtlpriv->psc.sw_ps_enabled) {\n\t\tif (ieee80211_is_data(fc) && !ieee80211_is_nullfunc(fc) &&\n\t\t    !ieee80211_has_pm(fc))\n\t\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t}\n\n\trtl_action_proc(hw, skb, true);\n\tif (is_multicast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesmulticast += skb->len;\n\telse if (is_broadcast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesbroadcast += skb->len;\n\telse\n\t\trtlpriv->stats.txbytesunicast += skb->len;\n\trtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *)pdesc, NULL, info, sta, skb,\n\t\t\t\t\thw_queue, &tcb_desc);\n\tif (ieee80211_is_data(fc))\n\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_TX);\n}\n\nstatic int rtl_usb_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_sta *sta,\n\t\t      struct sk_buff *skb,\n\t\t      struct rtl_tcb_desc *dummy)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)(skb->data);\n\t__le16 fc = hdr->frame_control;\n\tu16 hw_queue;\n\n\tif (unlikely(is_hal_stop(rtlhal)))\n\t\tgoto err_free;\n\thw_queue = rtlusb->usb_mq_to_hwq(fc, skb_get_queue_mapping(skb));\n\t_rtl_usb_tx_preprocess(hw, sta, skb, hw_queue);\n\t_rtl_usb_transmit(hw, skb, hw_queue);\n\treturn NETDEV_TX_OK;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic bool rtl_usb_tx_chk_waitq_insert(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\treturn false;\n}\n\nstatic void rtl_fill_h2c_cmd_work_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks =\n\t    container_of(work, struct rtl_works, fill_h2c_cmd);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->cfg->ops->fill_h2c_cmd(hw, H2C_RA_MASK, 5, rtlpriv->rate_mask);\n}\n\nstatic const struct rtl_intf_ops rtl_usb_ops = {\n\t.adapter_start = rtl_usb_start,\n\t.adapter_stop = rtl_usb_stop,\n\t.adapter_tx = rtl_usb_tx,\n\t.waitq_insert = rtl_usb_tx_chk_waitq_insert,\n};\n\nint rtl_usb_probe(struct usb_interface *intf,\n\t\t  const struct usb_device_id *id,\n\t\t  struct rtl_hal_cfg *rtl_hal_cfg)\n{\n\tint err;\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct rtl_priv *rtlpriv = NULL;\n\tstruct usb_device\t*udev;\n\tstruct rtl_usb_priv *usb_priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +\n\t\t\t\tsizeof(struct rtl_usb_priv), &rtl_ops);\n\tif (!hw) {\n\t\tWARN_ONCE(true, \"rtl_usb: ieee80211 alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trtlpriv = hw->priv;\n\trtlpriv->hw = hw;\n\trtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rtlpriv->usb_data) {\n\t\tieee80211_free_hw(hw);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* this spin lock must be initialized early */\n\tspin_lock_init(&rtlpriv->locks.usb_lock);\n\tINIT_WORK(&rtlpriv->works.fill_h2c_cmd,\n\t\t  rtl_fill_h2c_cmd_work_callback);\n\tINIT_WORK(&rtlpriv->works.lps_change_work,\n\t\t  rtl_lps_change_work_callback);\n\n\trtlpriv->usb_data_index = 0;\n\tinit_completion(&rtlpriv->firmware_loading_complete);\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\tudev = interface_to_usbdev(intf);\n\tusb_get_dev(udev);\n\tusb_priv = rtl_usbpriv(hw);\n\tmemset(usb_priv, 0, sizeof(*usb_priv));\n\tusb_priv->dev.intf = intf;\n\tusb_priv->dev.udev = udev;\n\tusb_set_intfdata(intf, hw);\n\t/* init cfg & intf_ops */\n\trtlpriv->rtlhal.interface = INTF_USB;\n\trtlpriv->cfg = rtl_hal_cfg;\n\trtlpriv->intf_ops = &rtl_usb_ops;\n\t/* Init IO handler */\n\t_rtl_usb_io_handler_init(&udev->dev, hw);\n\trtlpriv->cfg->ops->read_chip_version(hw);\n\t/*like read eeprom and so on */\n\trtlpriv->cfg->ops->read_eeprom_info(hw);\n\terr = _rtl_usb_init(hw);\n\tif (err)\n\t\tgoto error_out2;\n\trtl_usb_init_sw(hw);\n\t/* Init mac80211 sw */\n\terr = rtl_init_core(hw);\n\tif (err) {\n\t\tpr_err(\"Can't allocate sw for mac80211\\n\");\n\t\tgoto error_out2;\n\t}\n\tif (rtlpriv->cfg->ops->init_sw_vars(hw)) {\n\t\tpr_err(\"Can't init_sw_vars\\n\");\n\t\tgoto error_out;\n\t}\n\trtlpriv->cfg->ops->init_sw_leds(hw);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err) {\n\t\tpr_err(\"Can't register mac80211 hw.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error_out;\n\t}\n\trtlpriv->mac80211.mac80211_registered = 1;\n\n\tset_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\treturn 0;\n\nerror_out:\n\trtl_deinit_core(hw);\nerror_out2:\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(udev);\n\tcomplete(&rtlpriv->firmware_loading_complete);\n\tkfree(rtlpriv->usb_data);\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(rtl_usb_probe);\n\nvoid rtl_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tif (unlikely(!rtlpriv))\n\t\treturn;\n\t/* just in case driver is removed before firmware callback */\n\twait_for_completion(&rtlpriv->firmware_loading_complete);\n\tclear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\t/*ieee80211_unregister_hw will call ops_stop */\n\tif (rtlmac->mac80211_registered == 1) {\n\t\tieee80211_unregister_hw(hw);\n\t\trtlmac->mac80211_registered = 0;\n\t} else {\n\t\trtl_deinit_deferred_work(hw, false);\n\t\trtlpriv->intf_ops->adapter_stop(hw);\n\t}\n\t/*deinit rfkill */\n\t/* rtl_deinit_rfkill(hw); */\n\trtl_usb_deinit(hw);\n\trtl_deinit_core(hw);\n\tkfree(rtlpriv->usb_data);\n\trtlpriv->cfg->ops->deinit_sw_leds(hw);\n\trtlpriv->cfg->ops->deinit_sw_vars(hw);\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(rtlusb->udev);\n\tusb_set_intfdata(intf, NULL);\n\tieee80211_free_hw(hw);\n}\nEXPORT_SYMBOL(rtl_usb_disconnect);\n\nint rtl_usb_suspend(struct usb_interface *pusb_intf, pm_message_t message)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_usb_suspend);\n\nint rtl_usb_resume(struct usb_interface *pusb_intf)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_usb_resume);\n"], "filenames": ["drivers/net/wireless/realtek/rtlwifi/usb.c"], "buggy_code_start_loc": [1024], "buggy_code_end_loc": [1085], "fixing_code_start_loc": [1024], "fixing_code_end_loc": [1089], "type": "CWE-401", "message": "Two memory leaks in the rtl_usb_probe() function in drivers/net/wireless/realtek/rtlwifi/usb.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption), aka CID-3f9361695113.", "other": {"cve": {"id": "CVE-2019-19063", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.547", "lastModified": "2022-11-07T17:20:46.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Two memory leaks in the rtl_usb_probe() function in drivers/net/wireless/realtek/rtlwifi/usb.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption), aka CID-3f9361695113."}, {"lang": "es", "value": "Dos p\u00e9rdidas de memoria en la funci\u00f3n rtl_usb_probe() en el archivo drivers/net/wireless/realtek/rtlwifi/usb.c en el kernel de Linux versiones hasta la versi\u00f3n  5.3.11, permiten a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria), tambi\u00e9n se conoce como CID-3f9361695113."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:sd-wan_edge:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "78C99571-0F3C-43E6-84B3-7D80E045EF8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C0ADE5D-F91D-4E0D-B6C5-3511B19665F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "8AFF1109-26F3-43A5-A4CB-0F169FDBC0DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5AF71C49-ADEF-4EE2-802C-6159ADD51355"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.20:*:*:*:*:*:*:*", "matchCriteriaId": "B3BC6E59-2134-4A28-AAD2-77C8AE236BCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.25:*:*:*:*:*:*:*", "matchCriteriaId": "24377899-5389-4BDC-AC82-0E4186F4DE53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30:*:*:*:*:*:*:*", "matchCriteriaId": "23FE83DE-AE7C-4313-88E3-886110C31302"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30.5r3:*:*:*:*:*:*:*", "matchCriteriaId": "490B327B-AC20-419B-BB76-8AB6971304BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40:*:*:*:*:*:*:*", "matchCriteriaId": "8DCE2754-7A9E-4B3B-91D1-DCF90C1BABE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.3r2:*:*:*:*:*:*:*", "matchCriteriaId": "6CA74E8B-51E2-4A7C-8A98-0583D31134A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B64AB37-A1D9-4163-A51B-4C780361F1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.1:*:*:*:*:*:*:*", "matchCriteriaId": "7BE9C9D7-9CED-4184-A190-1024A6FB8C82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:-:*:*:*:*:*:*", "matchCriteriaId": "B73D4C3C-A511-4E14-B19F-91F561ACB1B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:p1:*:*:*:*:*:*", "matchCriteriaId": "0C47D72C-9B6B-4E52-AF0E-56AD58E4A930"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60:*:*:*:*:*:*:*", "matchCriteriaId": "039C3790-5AA2-4895-AEAE-CC84A71DB907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4592238-D1F2-43D6-9BAB-2F63ECF9C965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.1:*:*:*:*:*:*:*", "matchCriteriaId": "0BA78068-80E9-4E49-9056-88EAB7E3682C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.3:*:*:*:*:*:*:*", "matchCriteriaId": "092F366C-E8B0-4BE5-B106-0B7A73B08D34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.1:*:*:*:*:*:*:*", "matchCriteriaId": "E7992E92-B159-4810-B895-01A9B944058A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.2:*:*:*:*:*:*:*", "matchCriteriaId": "5BDD7AAB-2BF3-4E8C-BEE2-5217E2926C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:fas\\/aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "66EEA3CA-8CC7-4F0B-8204-6132D4114873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h610s:*:*:*:*:*:*:*", "matchCriteriaId": "DE7C6010-F736-4BDA-9E3B-C4370BBFA149"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:broadcom:brocade_fabric_operating_system_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "B2748912-FC54-47F6-8C0C-B96784765B8E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "090AA6F4-4404-4E26-82AB-C3A22636F276"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/155890/Slackware-Security-Advisory-Slackware-14.2-kernel-Updates.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/3f93616951138a598d930dcaec40f2bfd9ce43bb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Jan/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4254-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4254-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4284-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4285-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3f93616951138a598d930dcaec40f2bfd9ce43bb"}}