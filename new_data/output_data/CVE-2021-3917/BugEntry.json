{"buggy_code": ["// Copyright 2019 CoreOS, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse anyhow::{bail, Context, Result};\nuse lazy_static::lazy_static;\nuse nix::mount;\nuse regex::Regex;\nuse std::fs::{copy as fscopy, create_dir_all, read_dir, File, OpenOptions};\nuse std::io::{copy, Read, Seek, SeekFrom, Write};\nuse std::os::unix::fs::FileTypeExt;\nuse std::path::{Path, PathBuf};\n\nuse crate::blockdev::*;\nuse crate::cmdline::*;\nuse crate::download::*;\nuse crate::io::*;\n#[cfg(target_arch = \"s390x\")]\nuse crate::s390x;\nuse crate::source::*;\n\npub fn install(config: &InstallConfig) -> Result<()> {\n    // set up image source\n    // we only support installing from a single artifact\n    let mut sources = config.location.sources()?;\n    let mut source = sources.pop().context(\"no artifacts found\")?;\n    if !sources.is_empty() {\n        bail!(\"found multiple artifacts\");\n    }\n    if source.signature.is_none() && config.location.require_signature() {\n        if config.insecure {\n            eprintln!(\"Signature not found; skipping verification as requested\");\n        } else {\n            bail!(\"--insecure not specified and signature not found\");\n        }\n    }\n\n    #[cfg(target_arch = \"s390x\")]\n    {\n        if is_dasd(&config.device, None)? {\n            if !config.save_partitions.is_empty() {\n                // The user requested partition saving, but SavedPartitions\n                // doesn't understand DASD VTOCs and won't find any partitions\n                // to save.\n                bail!(\"saving DASD partitions is not supported\");\n            }\n            s390x::prepare_dasd(&config.device)?;\n        }\n    }\n\n    // open output; ensure it's a block device and we have exclusive access\n    let mut dest = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .open(&config.device)\n        .with_context(|| format!(\"opening {}\", &config.device))?;\n    if !dest\n        .metadata()\n        .with_context(|| format!(\"getting metadata for {}\", &config.device))?\n        .file_type()\n        .is_block_device()\n    {\n        bail!(\"{} is not a block device\", &config.device);\n    }\n    ensure_exclusive_access(&config.device)\n        .with_context(|| format!(\"checking for exclusive access to {}\", &config.device))?;\n\n    // save partitions that we plan to keep\n    let saved = SavedPartitions::new_from_disk(&mut dest, &config.save_partitions)\n        .with_context(|| format!(\"saving partitions from {}\", config.device))?;\n\n    // get reference to partition table\n    // For kpartx partitioning, this will conditionally call kpartx -d\n    // when dropped\n    let mut table = Disk::new(&config.device)?\n        .get_partition_table()\n        .with_context(|| format!(\"getting partition table for {}\", &config.device))?;\n\n    // copy and postprocess disk image\n    // On failure, clear and reread the partition table to prevent the disk\n    // from accidentally being used.\n    dest.seek(SeekFrom::Start(0))\n        .with_context(|| format!(\"seeking {}\", config.device))?;\n    if let Err(err) = write_disk(&config, &mut source, &mut dest, &mut *table, &saved) {\n        // log the error so the details aren't dropped if we encounter\n        // another error during cleanup\n        eprintln!(\"\\nError: {:?}\\n\", err);\n\n        // clean up\n        if config.preserve_on_error {\n            eprintln!(\"Preserving partition table as requested\");\n            if saved.is_saved() {\n                // The user asked to preserve the damaged partition table\n                // for debugging.  We also have saved partitions, and those\n                // may or may not be in the damaged table depending where we\n                // failed.  Preserve the saved partitions by writing them to\n                // a file in /tmp and telling the user about it.  Hey, it's\n                // a debug flag.\n                stash_saved_partitions(&mut dest, &saved)?;\n            }\n        } else {\n            reset_partition_table(config, &mut dest, &mut *table, &saved)?;\n        }\n\n        // return a generic error so our exit status is right\n        bail!(\"install failed\");\n    }\n\n    eprintln!(\"Install complete.\");\n    Ok(())\n}\n\nfn ensure_exclusive_access(device: &str) -> Result<()> {\n    let mut parts = Disk::new(device)?.get_busy_partitions()?;\n    if parts.is_empty() {\n        return Ok(());\n    }\n    parts.sort_unstable_by_key(|p| p.path.to_string());\n    eprintln!(\"Partitions in use on {}:\", device);\n    for part in parts {\n        if let Some(mountpoint) = part.mountpoint.as_ref() {\n            eprintln!(\"    {} mounted on {}\", part.path, mountpoint);\n        }\n        if part.swap {\n            eprintln!(\"    {} is swap device\", part.path);\n        }\n        for holder in part.get_holders()? {\n            eprintln!(\"    {} in use by {}\", part.path, holder);\n        }\n    }\n    bail!(\"found busy partitions\");\n}\n\n/// Copy the image source to the target disk and do all post-processing.\n/// If this function fails, the caller should wipe the partition table\n/// to ensure the user doesn't boot from a partially-written disk.\nfn write_disk(\n    config: &InstallConfig,\n    source: &mut ImageSource,\n    dest: &mut File,\n    table: &mut dyn PartTable,\n    saved: &SavedPartitions,\n) -> Result<()> {\n    // Get sector size of destination, for comparing with image\n    let sector_size = get_sector_size(dest)?;\n\n    // copy the image\n    #[allow(clippy::match_bool, clippy::match_single_binding)]\n    let image_copy = match is_dasd(&config.device, Some(dest))? {\n        #[cfg(target_arch = \"s390x\")]\n        true => s390x::image_copy_s390x,\n        _ => image_copy_default,\n    };\n    write_image(\n        source,\n        dest,\n        Path::new(&config.device),\n        image_copy,\n        true,\n        Some(&saved),\n        Some(sector_size),\n    )?;\n    table.reread()?;\n\n    // postprocess\n    if config.ignition.is_some()\n        || config.firstboot_kargs.is_some()\n        || !config.append_kargs.is_empty()\n        || !config.delete_kargs.is_empty()\n        || config.platform.is_some()\n        || config.network_config.is_some()\n        || cfg!(target_arch = \"s390x\")\n    {\n        let mount = Disk::new(&config.device)?.mount_partition_by_label(\n            \"boot\",\n            false,\n            mount::MsFlags::empty(),\n        )?;\n        if let Some(ignition) = config.ignition.as_ref() {\n            write_ignition(mount.mountpoint(), &config.ignition_hash, ignition)\n                .context(\"writing Ignition configuration\")?;\n        }\n        if let Some(firstboot_kargs) = config.firstboot_kargs.as_ref() {\n            write_firstboot_kargs(mount.mountpoint(), firstboot_kargs)\n                .context(\"writing firstboot kargs\")?;\n        }\n        if !config.append_kargs.is_empty() || !config.delete_kargs.is_empty() {\n            eprintln!(\"Modifying kernel arguments\");\n\n            visit_bls_entry_options(mount.mountpoint(), |orig_options: &str| {\n                bls_entry_options_delete_and_append_kargs(\n                    orig_options,\n                    config.delete_kargs.as_slice(),\n                    config.append_kargs.as_slice(),\n                    &[],\n                )\n            })\n            .context(\"deleting and appending kargs\")?;\n        }\n        if let Some(platform) = config.platform.as_ref() {\n            write_platform(mount.mountpoint(), platform).context(\"writing platform ID\")?;\n        }\n        if let Some(network_config) = config.network_config.as_ref() {\n            copy_network_config(mount.mountpoint(), network_config)?;\n        }\n        #[cfg(target_arch = \"s390x\")]\n        s390x::install_bootloader(\n            mount.mountpoint(),\n            &config.device,\n            config.firstboot_kargs.as_ref().map(|s| s.as_str()),\n        )?;\n    }\n\n    // detect any latent write errors\n    dest.sync_all().context(\"syncing data to disk\")?;\n\n    Ok(())\n}\n\n/// Write the Ignition config.\nfn write_ignition(\n    mountpoint: &Path,\n    digest_in: &Option<IgnitionHash>,\n    mut config_in: &File,\n) -> Result<()> {\n    eprintln!(\"Writing Ignition config\");\n\n    // Verify configuration digest, if any.\n    if let Some(ref digest) = digest_in {\n        digest\n            .validate(&mut config_in)\n            .context(\"failed to validate Ignition configuration digest\")?;\n        config_in\n            .seek(SeekFrom::Start(0))\n            .context(\"rewinding Ignition configuration file\")?;\n    };\n\n    // make parent directory\n    let mut config_dest = mountpoint.to_path_buf();\n    config_dest.push(\"ignition\");\n    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;\n\n    // do the copy\n    config_dest.push(\"config.ign\");\n    let mut config_out = OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(&config_dest)\n        .with_context(|| {\n            format!(\n                \"opening destination Ignition config {}\",\n                config_dest.display()\n            )\n        })?;\n    copy(&mut config_in, &mut config_out).context(\"writing Ignition config\")?;\n\n    Ok(())\n}\n\n/// Write first-boot kernel arguments.\nfn write_firstboot_kargs(mountpoint: &Path, args: &str) -> Result<()> {\n    eprintln!(\"Writing first-boot kernel arguments\");\n\n    // write the arguments\n    let mut config_dest = mountpoint.to_path_buf();\n    config_dest.push(\"ignition.firstboot\");\n    // if the file doesn't already exist, fail, since our assumptions\n    // are wrong\n    let mut config_out = OpenOptions::new()\n        .append(true)\n        .open(&config_dest)\n        .with_context(|| format!(\"opening first-boot file {}\", config_dest.display()))?;\n    let contents = format!(\"set ignition_network_kcmdline=\\\"{}\\\"\\n\", args);\n    config_out\n        .write_all(contents.as_bytes())\n        .context(\"writing first-boot kernel arguments\")?;\n\n    Ok(())\n}\n\n/// To be used with `visit_bls_entry_options()`. Modifies the BLS config as instructed by\n/// `delete_args` and `append_args`.\npub fn bls_entry_options_delete_and_append_kargs(\n    orig_options: &str,\n    delete_args: &[String],\n    append_args: &[String],\n    append_args_if_missing: &[String],\n) -> Result<Option<String>> {\n    if delete_args.is_empty() && append_args.is_empty() && append_args_if_missing.is_empty() {\n        return Ok(None);\n    }\n    Ok(Some(modify_kargs(\n        orig_options,\n        append_args,\n        append_args_if_missing,\n        &[],\n        delete_args,\n    )?))\n}\n\n// XXX: Need a proper parser here and share it with afterburn. The approach we use here\n// is to just do a dumb substring search and replace. This is naive (e.g. doesn't\n// handle occurrences in quoted args) but will work for now (one thing that saves us is\n// that we're acting on our baked configs, which have straight-forward kargs).\npub fn modify_kargs(\n    current_kargs: &str,\n    kargs_append: &[String],\n    kargs_append_if_missing: &[String],\n    kargs_replace: &[String],\n    kargs_delete: &[String],\n) -> Result<String> {\n    lazy_static! {\n        static ref RE: Regex = Regex::new(r\"^([^=]+)=([^=]+)=([^=]+)$\").unwrap();\n    }\n    let mut new_kargs: String = format!(\" {} \", current_kargs);\n    for karg in kargs_delete {\n        let s = format!(\" {} \", karg.trim());\n        new_kargs = new_kargs.replace(&s, \" \");\n    }\n    for karg in kargs_append {\n        new_kargs.push_str(karg.trim());\n        new_kargs.push(' ');\n    }\n    for karg in kargs_append_if_missing {\n        let karg = karg.trim();\n        let s = format!(\" {} \", karg);\n        if !new_kargs.contains(&s) {\n            new_kargs.push_str(karg);\n            new_kargs.push(' ');\n        }\n    }\n    for karg in kargs_replace {\n        let caps = match RE.captures(karg) {\n            Some(caps) => caps,\n            None => bail!(\"Wrong input, format should be: KEY=OLD=NEW\"),\n        };\n        let old = format!(\" {}={} \", &caps[1], &caps[2]);\n        let new = format!(\" {}={} \", &caps[1], &caps[3]);\n        new_kargs = new_kargs.replace(&old, &new);\n    }\n    Ok(new_kargs.trim().into())\n}\n\n/// Override the platform ID.\nfn write_platform(mountpoint: &Path, platform: &str) -> Result<()> {\n    // early return if setting the platform to the default value, since\n    // otherwise we'll think we failed to set it\n    if platform == \"metal\" {\n        return Ok(());\n    }\n\n    eprintln!(\"Setting platform to {}\", platform);\n    visit_bls_entry_options(mountpoint, |orig_options: &str| {\n        bls_entry_options_write_platform(orig_options, platform)\n    })?;\n\n    Ok(())\n}\n\n/// To be used with `visit_bls_entry_options()`. Modifies the BLS config, only changing the\n/// `ignition.platform.id`. This assumes that we will only install from metal images and that the\n/// bootloader configs will always set ignition.platform.id.  Fail if those assumptions change.\n/// This is deliberately simplistic.\nfn bls_entry_options_write_platform(orig_options: &str, platform: &str) -> Result<Option<String>> {\n    let new_options = orig_options.replace(\n        \"ignition.platform.id=metal\",\n        &format!(\"ignition.platform.id={}\", platform),\n    );\n    if orig_options == new_options {\n        bail!(\"Couldn't locate platform ID\");\n    }\n    Ok(Some(new_options))\n}\n\n/// Calls a function on the latest (default) BLS entry and optionally updates it if the function\n/// returns new content. Errors out if no BLS entry was found.\npub fn visit_bls_entry(\n    mountpoint: &Path,\n    f: impl Fn(&str) -> Result<Option<String>>,\n) -> Result<()> {\n    // walk /boot/loader/entries/*.conf\n    let mut config_path = mountpoint.to_path_buf();\n    config_path.push(\"loader/entries\");\n\n    // We only want to affect the latest BLS entry (i.e. the default one). This confusingly is the\n    // *last* BLS config in the directory because they are sorted by reverse order:\n    // https://github.com/ostreedev/ostree/pull/1654\n    //\n    // Because `read_dir` doesn't guarantee any ordering, we gather all the filenames up front and\n    // sort them before picking the last one.\n    let mut entries: Vec<PathBuf> = Vec::new();\n    for entry in read_dir(&config_path)\n        .with_context(|| format!(\"reading directory {}\", config_path.display()))?\n    {\n        let path = entry\n            .with_context(|| format!(\"reading directory {}\", config_path.display()))?\n            .path();\n        if path.extension().unwrap_or_default() != \"conf\" {\n            continue;\n        }\n        entries.push(path);\n    }\n    entries.sort();\n\n    if let Some(path) = entries.pop() {\n        // slurp in the file\n        let mut config = OpenOptions::new()\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"opening bootloader config {}\", path.display()))?;\n        let orig_contents = {\n            let mut s = String::new();\n            config\n                .read_to_string(&mut s)\n                .with_context(|| format!(\"reading {}\", path.display()))?;\n            s\n        };\n\n        let r = f(&orig_contents).with_context(|| format!(\"visiting {}\", path.display()))?;\n\n        if let Some(new_contents) = r {\n            // write out the modified data\n            config\n                .seek(SeekFrom::Start(0))\n                .with_context(|| format!(\"seeking {}\", path.display()))?;\n            config\n                .set_len(0)\n                .with_context(|| format!(\"truncating {}\", path.display()))?;\n            config\n                .write(new_contents.as_bytes())\n                .with_context(|| format!(\"writing {}\", path.display()))?;\n        }\n    } else {\n        bail!(\"Found no BLS entries in {}\", config_path.display());\n    }\n\n    Ok(())\n}\n\n/// Wrapper around `visit_bls_entry` to specifically visit just the BLS entry's `options` line and\n/// optionally update it if the function returns new content. Errors out if none or more than one\n/// `options` field was found.\npub fn visit_bls_entry_options(\n    mountpoint: &Path,\n    f: impl Fn(&str) -> Result<Option<String>>,\n) -> Result<()> {\n    visit_bls_entry(mountpoint, |orig_contents: &str| {\n        let mut new_contents = String::with_capacity(orig_contents.len());\n        let mut found_options = false;\n        let mut modified = false;\n        for line in orig_contents.lines() {\n            if !line.starts_with(\"options \") {\n                new_contents.push_str(line.trim_end());\n            } else if found_options {\n                bail!(\"Multiple 'options' lines found\");\n            } else {\n                let r = f(line[\"options \".len()..].trim()).context(\"visiting options\")?;\n                if let Some(new_options) = r {\n                    new_contents.push_str(\"options \");\n                    new_contents.push_str(new_options.trim());\n                    modified = true;\n                }\n                found_options = true;\n            }\n            new_contents.push('\\n');\n        }\n        if !found_options {\n            bail!(\"Couldn't locate 'options' line\");\n        }\n        if !modified {\n            Ok(None)\n        } else {\n            Ok(Some(new_contents))\n        }\n    })\n}\n\n/// Copy networking config if asked to do so\nfn copy_network_config(mountpoint: &Path, net_config_src: &str) -> Result<()> {\n    eprintln!(\"Copying networking configuration from {}\", net_config_src);\n\n    // get the path to the destination directory\n    let net_config_dest = mountpoint.join(\"coreos-firstboot-network\");\n\n    // make the directory if it doesn't exist\n    create_dir_all(&net_config_dest).with_context(|| {\n        format!(\n            \"creating destination networking config directory {}\",\n            net_config_dest.display()\n        )\n    })?;\n\n    // copy files from source to destination directories\n    for entry in read_dir(&net_config_src)\n        .with_context(|| format!(\"reading directory {}\", net_config_src))?\n    {\n        let entry = entry.with_context(|| format!(\"reading directory {}\", net_config_src))?;\n        let srcpath = entry.path();\n        let destpath = net_config_dest.join(entry.file_name());\n        if srcpath.is_file() {\n            eprintln!(\"Copying {} to installed system\", srcpath.display());\n            fscopy(&srcpath, &destpath).context(\"Copying networking config\")?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Clear the partition table and restore saved partitions.  For use after\n/// a failure.\nfn reset_partition_table(\n    config: &InstallConfig,\n    dest: &mut File,\n    table: &mut dyn PartTable,\n    saved: &SavedPartitions,\n) -> Result<()> {\n    eprintln!(\"Resetting partition table\");\n\n    if is_dasd(&config.device, Some(dest))? {\n        // Don't write out a GPT, since the backup GPT may overwrite\n        // something we're not allowed to touch.  Just clear the first MiB\n        // of disk.\n        dest.seek(SeekFrom::Start(0))\n            .context(\"seeking to start of disk\")?;\n        let zeroes = [0u8; 1024 * 1024];\n        dest.write_all(&zeroes)\n            .context(\"clearing primary partition table\")?;\n    } else {\n        // Write a new GPT including any saved partitions.\n        saved\n            .overwrite(dest)\n            .context(\"restoring saved partitions\")?;\n    }\n\n    // Finish writeback and reread the partition table.\n    dest.sync_all().context(\"syncing partition table to disk\")?;\n    table.reread()?;\n\n    Ok(())\n}\n\n// Preserve saved partitions by writing them to a file in /tmp and reporting\n// the path.\nfn stash_saved_partitions(disk: &mut File, saved: &SavedPartitions) -> Result<()> {\n    let mut stash = tempfile::Builder::new()\n        .prefix(\"coreos-installer-partitions.\")\n        .tempfile()\n        .context(\"creating partition stash file\")?;\n    let path = stash.path().to_owned();\n    eprintln!(\"Storing saved partition entries to {}\", path.display());\n    let len = disk.seek(SeekFrom::End(0)).context(\"seeking disk\")?;\n    stash\n        .as_file()\n        .set_len(len)\n        .with_context(|| format!(\"extending partition stash file {}\", path.display()))?;\n    saved\n        .overwrite(stash.as_file_mut())\n        .with_context(|| format!(\"stashing saved partitions to {}\", path.display()))?;\n    stash\n        .keep()\n        .with_context(|| format!(\"retaining saved partition stash in {}\", path.display()))?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_platform_id() {\n        let orig_content = \"ignition.platform.id=metal foo bar\";\n        let new_content = bls_entry_options_write_platform(orig_content, \"openstack\").unwrap();\n        assert_eq!(\n            new_content.unwrap(),\n            \"ignition.platform.id=openstack foo bar\"\n        );\n\n        let orig_content = \"foo ignition.platform.id=metal bar\";\n        let new_content = bls_entry_options_write_platform(orig_content, \"openstack\").unwrap();\n        assert_eq!(\n            new_content.unwrap(),\n            \"foo ignition.platform.id=openstack bar\"\n        );\n\n        let orig_content = \"foo bar ignition.platform.id=metal\";\n        let new_content = bls_entry_options_write_platform(orig_content, \"openstack\").unwrap();\n        assert_eq!(\n            new_content.unwrap(),\n            \"foo bar ignition.platform.id=openstack\"\n        );\n    }\n\n    #[test]\n    fn test_modify_kargs() {\n        let orig_kargs = \"foo bar foobar\";\n\n        let delete_kargs = vec![\"foo\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"bar foobar\");\n\n        let delete_kargs = vec![\"bar\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foo foobar\");\n\n        let delete_kargs = vec![\"foobar\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foo bar\");\n\n        let delete_kargs = vec![\"foo bar\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foobar\");\n\n        let delete_kargs = vec![\"bar\".into(), \"foo\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foobar\");\n\n        let orig_kargs = \"foo=val bar baz=val\";\n\n        let delete_kargs = vec![\"   foo=val\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"bar baz=val\");\n\n        let delete_kargs = vec![\"baz=val  \".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foo=val bar\");\n\n        let orig_kargs = \"foo mitigations=auto,nosmt console=tty0 bar console=ttyS0,115200n8 baz\";\n\n        let delete_kargs = vec![\n            \"mitigations=auto,nosmt\".into(),\n            \"console=ttyS0,115200n8\".into(),\n        ];\n        let append_kargs = vec![\"console=ttyS1,115200n8  \".into()];\n        let append_kargs_if_missing =\n                 // base       // append_kargs dupe             // missing\n            vec![\"bar\".into(), \"console=ttyS1,115200n8\".into(), \"boo\".into()];\n        let new_kargs = modify_kargs(\n            orig_kargs,\n            &append_kargs,\n            &append_kargs_if_missing,\n            &[],\n            &delete_kargs,\n        )\n        .unwrap();\n        assert_eq!(\n            new_kargs,\n            \"foo console=tty0 bar baz console=ttyS1,115200n8 boo\"\n        );\n\n        let orig_kargs = \"foo mitigations=auto,nosmt console=tty0 bar console=ttyS0,115200n8 baz\";\n\n        let append_kargs = vec![\"console=ttyS1,115200n8\".into()];\n        let replace_kargs = vec![\"mitigations=auto,nosmt=auto\".into()];\n        let delete_kargs = vec![\"console=ttyS0,115200n8\".into()];\n        let new_kargs = modify_kargs(\n            orig_kargs,\n            &append_kargs,\n            &[],\n            &replace_kargs,\n            &delete_kargs,\n        )\n        .unwrap();\n        assert_eq!(\n            new_kargs,\n            \"foo mitigations=auto console=tty0 bar baz console=ttyS1,115200n8\"\n        );\n    }\n}\n"], "fixing_code": ["// Copyright 2019 CoreOS, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse anyhow::{bail, Context, Result};\nuse lazy_static::lazy_static;\nuse nix::mount;\nuse regex::Regex;\nuse std::fs::{\n    copy as fscopy, create_dir_all, read_dir, set_permissions, File, OpenOptions, Permissions,\n};\nuse std::io::{copy, Read, Seek, SeekFrom, Write};\nuse std::os::unix::fs::{FileTypeExt, PermissionsExt};\nuse std::path::{Path, PathBuf};\n\nuse crate::blockdev::*;\nuse crate::cmdline::*;\nuse crate::download::*;\nuse crate::io::*;\n#[cfg(target_arch = \"s390x\")]\nuse crate::s390x;\nuse crate::source::*;\n\npub fn install(config: &InstallConfig) -> Result<()> {\n    // set up image source\n    // we only support installing from a single artifact\n    let mut sources = config.location.sources()?;\n    let mut source = sources.pop().context(\"no artifacts found\")?;\n    if !sources.is_empty() {\n        bail!(\"found multiple artifacts\");\n    }\n    if source.signature.is_none() && config.location.require_signature() {\n        if config.insecure {\n            eprintln!(\"Signature not found; skipping verification as requested\");\n        } else {\n            bail!(\"--insecure not specified and signature not found\");\n        }\n    }\n\n    #[cfg(target_arch = \"s390x\")]\n    {\n        if is_dasd(&config.device, None)? {\n            if !config.save_partitions.is_empty() {\n                // The user requested partition saving, but SavedPartitions\n                // doesn't understand DASD VTOCs and won't find any partitions\n                // to save.\n                bail!(\"saving DASD partitions is not supported\");\n            }\n            s390x::prepare_dasd(&config.device)?;\n        }\n    }\n\n    // open output; ensure it's a block device and we have exclusive access\n    let mut dest = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .open(&config.device)\n        .with_context(|| format!(\"opening {}\", &config.device))?;\n    if !dest\n        .metadata()\n        .with_context(|| format!(\"getting metadata for {}\", &config.device))?\n        .file_type()\n        .is_block_device()\n    {\n        bail!(\"{} is not a block device\", &config.device);\n    }\n    ensure_exclusive_access(&config.device)\n        .with_context(|| format!(\"checking for exclusive access to {}\", &config.device))?;\n\n    // save partitions that we plan to keep\n    let saved = SavedPartitions::new_from_disk(&mut dest, &config.save_partitions)\n        .with_context(|| format!(\"saving partitions from {}\", config.device))?;\n\n    // get reference to partition table\n    // For kpartx partitioning, this will conditionally call kpartx -d\n    // when dropped\n    let mut table = Disk::new(&config.device)?\n        .get_partition_table()\n        .with_context(|| format!(\"getting partition table for {}\", &config.device))?;\n\n    // copy and postprocess disk image\n    // On failure, clear and reread the partition table to prevent the disk\n    // from accidentally being used.\n    dest.seek(SeekFrom::Start(0))\n        .with_context(|| format!(\"seeking {}\", config.device))?;\n    if let Err(err) = write_disk(&config, &mut source, &mut dest, &mut *table, &saved) {\n        // log the error so the details aren't dropped if we encounter\n        // another error during cleanup\n        eprintln!(\"\\nError: {:?}\\n\", err);\n\n        // clean up\n        if config.preserve_on_error {\n            eprintln!(\"Preserving partition table as requested\");\n            if saved.is_saved() {\n                // The user asked to preserve the damaged partition table\n                // for debugging.  We also have saved partitions, and those\n                // may or may not be in the damaged table depending where we\n                // failed.  Preserve the saved partitions by writing them to\n                // a file in /tmp and telling the user about it.  Hey, it's\n                // a debug flag.\n                stash_saved_partitions(&mut dest, &saved)?;\n            }\n        } else {\n            reset_partition_table(config, &mut dest, &mut *table, &saved)?;\n        }\n\n        // return a generic error so our exit status is right\n        bail!(\"install failed\");\n    }\n\n    eprintln!(\"Install complete.\");\n    Ok(())\n}\n\nfn ensure_exclusive_access(device: &str) -> Result<()> {\n    let mut parts = Disk::new(device)?.get_busy_partitions()?;\n    if parts.is_empty() {\n        return Ok(());\n    }\n    parts.sort_unstable_by_key(|p| p.path.to_string());\n    eprintln!(\"Partitions in use on {}:\", device);\n    for part in parts {\n        if let Some(mountpoint) = part.mountpoint.as_ref() {\n            eprintln!(\"    {} mounted on {}\", part.path, mountpoint);\n        }\n        if part.swap {\n            eprintln!(\"    {} is swap device\", part.path);\n        }\n        for holder in part.get_holders()? {\n            eprintln!(\"    {} in use by {}\", part.path, holder);\n        }\n    }\n    bail!(\"found busy partitions\");\n}\n\n/// Copy the image source to the target disk and do all post-processing.\n/// If this function fails, the caller should wipe the partition table\n/// to ensure the user doesn't boot from a partially-written disk.\nfn write_disk(\n    config: &InstallConfig,\n    source: &mut ImageSource,\n    dest: &mut File,\n    table: &mut dyn PartTable,\n    saved: &SavedPartitions,\n) -> Result<()> {\n    // Get sector size of destination, for comparing with image\n    let sector_size = get_sector_size(dest)?;\n\n    // copy the image\n    #[allow(clippy::match_bool, clippy::match_single_binding)]\n    let image_copy = match is_dasd(&config.device, Some(dest))? {\n        #[cfg(target_arch = \"s390x\")]\n        true => s390x::image_copy_s390x,\n        _ => image_copy_default,\n    };\n    write_image(\n        source,\n        dest,\n        Path::new(&config.device),\n        image_copy,\n        true,\n        Some(&saved),\n        Some(sector_size),\n    )?;\n    table.reread()?;\n\n    // postprocess\n    if config.ignition.is_some()\n        || config.firstboot_kargs.is_some()\n        || !config.append_kargs.is_empty()\n        || !config.delete_kargs.is_empty()\n        || config.platform.is_some()\n        || config.network_config.is_some()\n        || cfg!(target_arch = \"s390x\")\n    {\n        let mount = Disk::new(&config.device)?.mount_partition_by_label(\n            \"boot\",\n            false,\n            mount::MsFlags::empty(),\n        )?;\n        if let Some(ignition) = config.ignition.as_ref() {\n            write_ignition(mount.mountpoint(), &config.ignition_hash, ignition)\n                .context(\"writing Ignition configuration\")?;\n        }\n        if let Some(firstboot_kargs) = config.firstboot_kargs.as_ref() {\n            write_firstboot_kargs(mount.mountpoint(), firstboot_kargs)\n                .context(\"writing firstboot kargs\")?;\n        }\n        if !config.append_kargs.is_empty() || !config.delete_kargs.is_empty() {\n            eprintln!(\"Modifying kernel arguments\");\n\n            visit_bls_entry_options(mount.mountpoint(), |orig_options: &str| {\n                bls_entry_options_delete_and_append_kargs(\n                    orig_options,\n                    config.delete_kargs.as_slice(),\n                    config.append_kargs.as_slice(),\n                    &[],\n                )\n            })\n            .context(\"deleting and appending kargs\")?;\n        }\n        if let Some(platform) = config.platform.as_ref() {\n            write_platform(mount.mountpoint(), platform).context(\"writing platform ID\")?;\n        }\n        if let Some(network_config) = config.network_config.as_ref() {\n            copy_network_config(mount.mountpoint(), network_config)?;\n        }\n        #[cfg(target_arch = \"s390x\")]\n        s390x::install_bootloader(\n            mount.mountpoint(),\n            &config.device,\n            config.firstboot_kargs.as_ref().map(|s| s.as_str()),\n        )?;\n    }\n\n    // detect any latent write errors\n    dest.sync_all().context(\"syncing data to disk\")?;\n\n    Ok(())\n}\n\n/// Write the Ignition config.\nfn write_ignition(\n    mountpoint: &Path,\n    digest_in: &Option<IgnitionHash>,\n    mut config_in: &File,\n) -> Result<()> {\n    eprintln!(\"Writing Ignition config\");\n\n    // Verify configuration digest, if any.\n    if let Some(ref digest) = digest_in {\n        digest\n            .validate(&mut config_in)\n            .context(\"failed to validate Ignition configuration digest\")?;\n        config_in\n            .seek(SeekFrom::Start(0))\n            .context(\"rewinding Ignition configuration file\")?;\n    };\n\n    // make parent directory\n    let mut config_dest = mountpoint.to_path_buf();\n    config_dest.push(\"ignition\");\n    if !config_dest.is_dir() {\n        create_dir_all(&config_dest).with_context(|| {\n            format!(\n                \"creating Ignition config directory {}\",\n                config_dest.display()\n            )\n        })?;\n        // Ignition data may contain secrets; restrict to root\n        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {\n            format!(\n                \"setting file mode for Ignition directory {}\",\n                config_dest.display()\n            )\n        })?;\n    }\n\n    // do the copy\n    config_dest.push(\"config.ign\");\n    let mut config_out = OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(&config_dest)\n        .with_context(|| {\n            format!(\n                \"opening destination Ignition config {}\",\n                config_dest.display()\n            )\n        })?;\n    // Ignition config may contain secrets; restrict to root\n    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {\n        format!(\n            \"setting file mode for destination Ignition config {}\",\n            config_dest.display()\n        )\n    })?;\n    copy(&mut config_in, &mut config_out).context(\"writing Ignition config\")?;\n\n    Ok(())\n}\n\n/// Write first-boot kernel arguments.\nfn write_firstboot_kargs(mountpoint: &Path, args: &str) -> Result<()> {\n    eprintln!(\"Writing first-boot kernel arguments\");\n\n    // write the arguments\n    let mut config_dest = mountpoint.to_path_buf();\n    config_dest.push(\"ignition.firstboot\");\n    // if the file doesn't already exist, fail, since our assumptions\n    // are wrong\n    let mut config_out = OpenOptions::new()\n        .append(true)\n        .open(&config_dest)\n        .with_context(|| format!(\"opening first-boot file {}\", config_dest.display()))?;\n    let contents = format!(\"set ignition_network_kcmdline=\\\"{}\\\"\\n\", args);\n    config_out\n        .write_all(contents.as_bytes())\n        .context(\"writing first-boot kernel arguments\")?;\n\n    Ok(())\n}\n\n/// To be used with `visit_bls_entry_options()`. Modifies the BLS config as instructed by\n/// `delete_args` and `append_args`.\npub fn bls_entry_options_delete_and_append_kargs(\n    orig_options: &str,\n    delete_args: &[String],\n    append_args: &[String],\n    append_args_if_missing: &[String],\n) -> Result<Option<String>> {\n    if delete_args.is_empty() && append_args.is_empty() && append_args_if_missing.is_empty() {\n        return Ok(None);\n    }\n    Ok(Some(modify_kargs(\n        orig_options,\n        append_args,\n        append_args_if_missing,\n        &[],\n        delete_args,\n    )?))\n}\n\n// XXX: Need a proper parser here and share it with afterburn. The approach we use here\n// is to just do a dumb substring search and replace. This is naive (e.g. doesn't\n// handle occurrences in quoted args) but will work for now (one thing that saves us is\n// that we're acting on our baked configs, which have straight-forward kargs).\npub fn modify_kargs(\n    current_kargs: &str,\n    kargs_append: &[String],\n    kargs_append_if_missing: &[String],\n    kargs_replace: &[String],\n    kargs_delete: &[String],\n) -> Result<String> {\n    lazy_static! {\n        static ref RE: Regex = Regex::new(r\"^([^=]+)=([^=]+)=([^=]+)$\").unwrap();\n    }\n    let mut new_kargs: String = format!(\" {} \", current_kargs);\n    for karg in kargs_delete {\n        let s = format!(\" {} \", karg.trim());\n        new_kargs = new_kargs.replace(&s, \" \");\n    }\n    for karg in kargs_append {\n        new_kargs.push_str(karg.trim());\n        new_kargs.push(' ');\n    }\n    for karg in kargs_append_if_missing {\n        let karg = karg.trim();\n        let s = format!(\" {} \", karg);\n        if !new_kargs.contains(&s) {\n            new_kargs.push_str(karg);\n            new_kargs.push(' ');\n        }\n    }\n    for karg in kargs_replace {\n        let caps = match RE.captures(karg) {\n            Some(caps) => caps,\n            None => bail!(\"Wrong input, format should be: KEY=OLD=NEW\"),\n        };\n        let old = format!(\" {}={} \", &caps[1], &caps[2]);\n        let new = format!(\" {}={} \", &caps[1], &caps[3]);\n        new_kargs = new_kargs.replace(&old, &new);\n    }\n    Ok(new_kargs.trim().into())\n}\n\n/// Override the platform ID.\nfn write_platform(mountpoint: &Path, platform: &str) -> Result<()> {\n    // early return if setting the platform to the default value, since\n    // otherwise we'll think we failed to set it\n    if platform == \"metal\" {\n        return Ok(());\n    }\n\n    eprintln!(\"Setting platform to {}\", platform);\n    visit_bls_entry_options(mountpoint, |orig_options: &str| {\n        bls_entry_options_write_platform(orig_options, platform)\n    })?;\n\n    Ok(())\n}\n\n/// To be used with `visit_bls_entry_options()`. Modifies the BLS config, only changing the\n/// `ignition.platform.id`. This assumes that we will only install from metal images and that the\n/// bootloader configs will always set ignition.platform.id.  Fail if those assumptions change.\n/// This is deliberately simplistic.\nfn bls_entry_options_write_platform(orig_options: &str, platform: &str) -> Result<Option<String>> {\n    let new_options = orig_options.replace(\n        \"ignition.platform.id=metal\",\n        &format!(\"ignition.platform.id={}\", platform),\n    );\n    if orig_options == new_options {\n        bail!(\"Couldn't locate platform ID\");\n    }\n    Ok(Some(new_options))\n}\n\n/// Calls a function on the latest (default) BLS entry and optionally updates it if the function\n/// returns new content. Errors out if no BLS entry was found.\npub fn visit_bls_entry(\n    mountpoint: &Path,\n    f: impl Fn(&str) -> Result<Option<String>>,\n) -> Result<()> {\n    // walk /boot/loader/entries/*.conf\n    let mut config_path = mountpoint.to_path_buf();\n    config_path.push(\"loader/entries\");\n\n    // We only want to affect the latest BLS entry (i.e. the default one). This confusingly is the\n    // *last* BLS config in the directory because they are sorted by reverse order:\n    // https://github.com/ostreedev/ostree/pull/1654\n    //\n    // Because `read_dir` doesn't guarantee any ordering, we gather all the filenames up front and\n    // sort them before picking the last one.\n    let mut entries: Vec<PathBuf> = Vec::new();\n    for entry in read_dir(&config_path)\n        .with_context(|| format!(\"reading directory {}\", config_path.display()))?\n    {\n        let path = entry\n            .with_context(|| format!(\"reading directory {}\", config_path.display()))?\n            .path();\n        if path.extension().unwrap_or_default() != \"conf\" {\n            continue;\n        }\n        entries.push(path);\n    }\n    entries.sort();\n\n    if let Some(path) = entries.pop() {\n        // slurp in the file\n        let mut config = OpenOptions::new()\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"opening bootloader config {}\", path.display()))?;\n        let orig_contents = {\n            let mut s = String::new();\n            config\n                .read_to_string(&mut s)\n                .with_context(|| format!(\"reading {}\", path.display()))?;\n            s\n        };\n\n        let r = f(&orig_contents).with_context(|| format!(\"visiting {}\", path.display()))?;\n\n        if let Some(new_contents) = r {\n            // write out the modified data\n            config\n                .seek(SeekFrom::Start(0))\n                .with_context(|| format!(\"seeking {}\", path.display()))?;\n            config\n                .set_len(0)\n                .with_context(|| format!(\"truncating {}\", path.display()))?;\n            config\n                .write(new_contents.as_bytes())\n                .with_context(|| format!(\"writing {}\", path.display()))?;\n        }\n    } else {\n        bail!(\"Found no BLS entries in {}\", config_path.display());\n    }\n\n    Ok(())\n}\n\n/// Wrapper around `visit_bls_entry` to specifically visit just the BLS entry's `options` line and\n/// optionally update it if the function returns new content. Errors out if none or more than one\n/// `options` field was found.\npub fn visit_bls_entry_options(\n    mountpoint: &Path,\n    f: impl Fn(&str) -> Result<Option<String>>,\n) -> Result<()> {\n    visit_bls_entry(mountpoint, |orig_contents: &str| {\n        let mut new_contents = String::with_capacity(orig_contents.len());\n        let mut found_options = false;\n        let mut modified = false;\n        for line in orig_contents.lines() {\n            if !line.starts_with(\"options \") {\n                new_contents.push_str(line.trim_end());\n            } else if found_options {\n                bail!(\"Multiple 'options' lines found\");\n            } else {\n                let r = f(line[\"options \".len()..].trim()).context(\"visiting options\")?;\n                if let Some(new_options) = r {\n                    new_contents.push_str(\"options \");\n                    new_contents.push_str(new_options.trim());\n                    modified = true;\n                }\n                found_options = true;\n            }\n            new_contents.push('\\n');\n        }\n        if !found_options {\n            bail!(\"Couldn't locate 'options' line\");\n        }\n        if !modified {\n            Ok(None)\n        } else {\n            Ok(Some(new_contents))\n        }\n    })\n}\n\n/// Copy networking config if asked to do so\nfn copy_network_config(mountpoint: &Path, net_config_src: &str) -> Result<()> {\n    eprintln!(\"Copying networking configuration from {}\", net_config_src);\n\n    // get the path to the destination directory\n    let net_config_dest = mountpoint.join(\"coreos-firstboot-network\");\n\n    // make the directory if it doesn't exist\n    create_dir_all(&net_config_dest).with_context(|| {\n        format!(\n            \"creating destination networking config directory {}\",\n            net_config_dest.display()\n        )\n    })?;\n\n    // copy files from source to destination directories\n    for entry in read_dir(&net_config_src)\n        .with_context(|| format!(\"reading directory {}\", net_config_src))?\n    {\n        let entry = entry.with_context(|| format!(\"reading directory {}\", net_config_src))?;\n        let srcpath = entry.path();\n        let destpath = net_config_dest.join(entry.file_name());\n        if srcpath.is_file() {\n            eprintln!(\"Copying {} to installed system\", srcpath.display());\n            fscopy(&srcpath, &destpath).context(\"Copying networking config\")?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Clear the partition table and restore saved partitions.  For use after\n/// a failure.\nfn reset_partition_table(\n    config: &InstallConfig,\n    dest: &mut File,\n    table: &mut dyn PartTable,\n    saved: &SavedPartitions,\n) -> Result<()> {\n    eprintln!(\"Resetting partition table\");\n\n    if is_dasd(&config.device, Some(dest))? {\n        // Don't write out a GPT, since the backup GPT may overwrite\n        // something we're not allowed to touch.  Just clear the first MiB\n        // of disk.\n        dest.seek(SeekFrom::Start(0))\n            .context(\"seeking to start of disk\")?;\n        let zeroes = [0u8; 1024 * 1024];\n        dest.write_all(&zeroes)\n            .context(\"clearing primary partition table\")?;\n    } else {\n        // Write a new GPT including any saved partitions.\n        saved\n            .overwrite(dest)\n            .context(\"restoring saved partitions\")?;\n    }\n\n    // Finish writeback and reread the partition table.\n    dest.sync_all().context(\"syncing partition table to disk\")?;\n    table.reread()?;\n\n    Ok(())\n}\n\n// Preserve saved partitions by writing them to a file in /tmp and reporting\n// the path.\nfn stash_saved_partitions(disk: &mut File, saved: &SavedPartitions) -> Result<()> {\n    let mut stash = tempfile::Builder::new()\n        .prefix(\"coreos-installer-partitions.\")\n        .tempfile()\n        .context(\"creating partition stash file\")?;\n    let path = stash.path().to_owned();\n    eprintln!(\"Storing saved partition entries to {}\", path.display());\n    let len = disk.seek(SeekFrom::End(0)).context(\"seeking disk\")?;\n    stash\n        .as_file()\n        .set_len(len)\n        .with_context(|| format!(\"extending partition stash file {}\", path.display()))?;\n    saved\n        .overwrite(stash.as_file_mut())\n        .with_context(|| format!(\"stashing saved partitions to {}\", path.display()))?;\n    stash\n        .keep()\n        .with_context(|| format!(\"retaining saved partition stash in {}\", path.display()))?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_platform_id() {\n        let orig_content = \"ignition.platform.id=metal foo bar\";\n        let new_content = bls_entry_options_write_platform(orig_content, \"openstack\").unwrap();\n        assert_eq!(\n            new_content.unwrap(),\n            \"ignition.platform.id=openstack foo bar\"\n        );\n\n        let orig_content = \"foo ignition.platform.id=metal bar\";\n        let new_content = bls_entry_options_write_platform(orig_content, \"openstack\").unwrap();\n        assert_eq!(\n            new_content.unwrap(),\n            \"foo ignition.platform.id=openstack bar\"\n        );\n\n        let orig_content = \"foo bar ignition.platform.id=metal\";\n        let new_content = bls_entry_options_write_platform(orig_content, \"openstack\").unwrap();\n        assert_eq!(\n            new_content.unwrap(),\n            \"foo bar ignition.platform.id=openstack\"\n        );\n    }\n\n    #[test]\n    fn test_modify_kargs() {\n        let orig_kargs = \"foo bar foobar\";\n\n        let delete_kargs = vec![\"foo\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"bar foobar\");\n\n        let delete_kargs = vec![\"bar\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foo foobar\");\n\n        let delete_kargs = vec![\"foobar\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foo bar\");\n\n        let delete_kargs = vec![\"foo bar\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foobar\");\n\n        let delete_kargs = vec![\"bar\".into(), \"foo\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foobar\");\n\n        let orig_kargs = \"foo=val bar baz=val\";\n\n        let delete_kargs = vec![\"   foo=val\".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"bar baz=val\");\n\n        let delete_kargs = vec![\"baz=val  \".into()];\n        let new_kargs = modify_kargs(orig_kargs, &[], &[], &[], &delete_kargs).unwrap();\n        assert_eq!(new_kargs, \"foo=val bar\");\n\n        let orig_kargs = \"foo mitigations=auto,nosmt console=tty0 bar console=ttyS0,115200n8 baz\";\n\n        let delete_kargs = vec![\n            \"mitigations=auto,nosmt\".into(),\n            \"console=ttyS0,115200n8\".into(),\n        ];\n        let append_kargs = vec![\"console=ttyS1,115200n8  \".into()];\n        let append_kargs_if_missing =\n                 // base       // append_kargs dupe             // missing\n            vec![\"bar\".into(), \"console=ttyS1,115200n8\".into(), \"boo\".into()];\n        let new_kargs = modify_kargs(\n            orig_kargs,\n            &append_kargs,\n            &append_kargs_if_missing,\n            &[],\n            &delete_kargs,\n        )\n        .unwrap();\n        assert_eq!(\n            new_kargs,\n            \"foo console=tty0 bar baz console=ttyS1,115200n8 boo\"\n        );\n\n        let orig_kargs = \"foo mitigations=auto,nosmt console=tty0 bar console=ttyS0,115200n8 baz\";\n\n        let append_kargs = vec![\"console=ttyS1,115200n8\".into()];\n        let replace_kargs = vec![\"mitigations=auto,nosmt=auto\".into()];\n        let delete_kargs = vec![\"console=ttyS0,115200n8\".into()];\n        let new_kargs = modify_kargs(\n            orig_kargs,\n            &append_kargs,\n            &[],\n            &replace_kargs,\n            &delete_kargs,\n        )\n        .unwrap();\n        assert_eq!(\n            new_kargs,\n            \"foo mitigations=auto console=tty0 bar baz console=ttyS1,115200n8\"\n        );\n    }\n}\n"], "filenames": ["src/install.rs"], "buggy_code_start_loc": [19], "buggy_code_end_loc": [264], "fixing_code_start_loc": [19], "fixing_code_end_loc": [288], "type": "CWE-276", "message": "A flaw was found in the coreos-installer, where it writes the Ignition config to the target system with world-readable access permissions. This flaw allows a local attacker to have read access to potentially sensitive data. The highest threat from this vulnerability is to confidentiality.", "other": {"cve": {"id": "CVE-2021-3917", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T20:15:08.360", "lastModified": "2022-08-26T19:15:25.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the coreos-installer, where it writes the Ignition config to the target system with world-readable access permissions. This flaw allows a local attacker to have read access to potentially sensitive data. The highest threat from this vulnerability is to confidentiality."}, {"lang": "es", "value": "Se ha encontrado un fallo en coreos-installer, que escribe la configuraci\u00f3n de Ignition en el sistema de destino con permisos de acceso de lectura general. Este fallo permite a un atacante local tener acceso de lectura a datos potencialmente confidenciales. La mayor amenaza de esta vulnerabilidad es la confidencialidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:coreos-installer:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.10.0", "matchCriteriaId": "A5FB7948-D4C7-4806-A707-B1F4FC340F97"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3917", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2018478", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/coreos/coreos-installer/commit/2a36405339c87b16ed6c76e91ad5b76638fbdb0c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/coreos/fedora-coreos-tracker/issues/889", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/coreos/coreos-installer/commit/2a36405339c87b16ed6c76e91ad5b76638fbdb0c"}}