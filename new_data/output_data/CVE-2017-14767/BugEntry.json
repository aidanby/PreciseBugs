{"buggy_code": ["/*\n * RTP H.264 Protocol (RFC3984)\n * Copyright (c) 2006 Ryan Martell\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * @brief H.264 / RTP Code (RFC3984)\n * @author Ryan Martell <rdm4@martellventures.com>\n *\n * @note Notes:\n * Notes:\n * This currently supports packetization mode:\n * Single Nal Unit Mode (0), or\n * Non-Interleaved Mode (1).  It currently does not support\n * Interleaved Mode (2). (This requires implementing STAP-B, MTAP16, MTAP24,\n *                        FU-B packet types)\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/base64.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/avstring.h\"\n#include \"avformat.h\"\n\n#include \"rtpdec.h\"\n#include \"rtpdec_formats.h\"\n\nstruct PayloadContext {\n    // sdp setup parameters\n    uint8_t profile_idc;\n    uint8_t profile_iop;\n    uint8_t level_idc;\n    int packetization_mode;\n#ifdef DEBUG\n    int packet_types_received[32];\n#endif\n};\n\n#ifdef DEBUG\n#define COUNT_NAL_TYPE(data, nal) data->packet_types_received[(nal) & 0x1f]++\n#define NAL_COUNTERS data->packet_types_received\n#else\n#define COUNT_NAL_TYPE(data, nal) do { } while (0)\n#define NAL_COUNTERS NULL\n#endif\n#define NAL_MASK 0x1f\n\nstatic const uint8_t start_sequence[] = { 0, 0, 0, 1 };\n\nstatic void parse_profile_level_id(AVFormatContext *s,\n                                   PayloadContext *h264_data,\n                                   const char *value)\n{\n    char buffer[3];\n    // 6 characters=3 bytes, in hex.\n    uint8_t profile_idc;\n    uint8_t profile_iop;\n    uint8_t level_idc;\n\n    buffer[0]   = value[0];\n    buffer[1]   = value[1];\n    buffer[2]   = '\\0';\n    profile_idc = strtol(buffer, NULL, 16);\n    buffer[0]   = value[2];\n    buffer[1]   = value[3];\n    profile_iop = strtol(buffer, NULL, 16);\n    buffer[0]   = value[4];\n    buffer[1]   = value[5];\n    level_idc   = strtol(buffer, NULL, 16);\n\n    av_log(s, AV_LOG_DEBUG,\n           \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n           profile_idc, profile_iop, level_idc);\n    h264_data->profile_idc = profile_idc;\n    h264_data->profile_iop = profile_iop;\n    h264_data->level_idc   = level_idc;\n}\n\nint ff_h264_parse_sprop_parameter_sets(AVFormatContext *s,\n                                       uint8_t **data_ptr, int *size_ptr,\n                                       const char *value)\n{\n    char base64packet[1024];\n    uint8_t decoded_packet[1024];\n    int packet_size;\n\n    while (*value) {\n        char *dst = base64packet;\n\n        while (*value && *value != ','\n               && (dst - base64packet) < sizeof(base64packet) - 1) {\n            *dst++ = *value++;\n        }\n        *dst++ = '\\0';\n\n        if (*value == ',')\n            value++;\n\n        packet_size = av_base64_decode(decoded_packet, base64packet,\n                                       sizeof(decoded_packet));\n        if (packet_size > 0) {\n            uint8_t *dest = av_realloc(*data_ptr,\n                                       packet_size + sizeof(start_sequence) +\n                                       *size_ptr +\n                                       AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!dest) {\n                av_log(s, AV_LOG_ERROR,\n                       \"Unable to allocate memory for extradata!\\n\");\n                return AVERROR(ENOMEM);\n            }\n            *data_ptr = dest;\n\n            memcpy(dest + *size_ptr, start_sequence,\n                   sizeof(start_sequence));\n            memcpy(dest + *size_ptr + sizeof(start_sequence),\n                   decoded_packet, packet_size);\n            memset(dest + *size_ptr + sizeof(start_sequence) +\n                   packet_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n            *size_ptr += sizeof(start_sequence) + packet_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n         * Packetization Mode:\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n         *                      and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}\n\nvoid ff_h264_parse_framesize(AVCodecParameters *par, const char *p)\n{\n    char buf1[50];\n    char *dst = buf1;\n\n    // remove the protocol identifier\n    while (*p && *p == ' ')\n        p++;                     // strip spaces.\n    while (*p && *p != ' ')\n        p++;                     // eat protocol identifier\n    while (*p && *p == ' ')\n        p++;                     // strip trailing spaces.\n    while (*p && *p != '-' && (dst - buf1) < sizeof(buf1) - 1)\n        *dst++ = *p++;\n    *dst = '\\0';\n\n    // a='framesize:96 320-240'\n    // set our parameters\n    par->width   = atoi(buf1);\n    par->height  = atoi(p + 1); // skip the -\n}\n\nint ff_h264_handle_aggregated_packet(AVFormatContext *ctx, PayloadContext *data, AVPacket *pkt,\n                                     const uint8_t *buf, int len,\n                                     int skip_between, int *nal_counters,\n                                     int nal_mask)\n{\n    int pass         = 0;\n    int total_length = 0;\n    uint8_t *dst     = NULL;\n    int ret;\n\n    // first we are going to figure out the total size\n    for (pass = 0; pass < 2; pass++) {\n        const uint8_t *src = buf;\n        int src_len        = len;\n\n        while (src_len > 2) {\n            uint16_t nal_size = AV_RB16(src);\n\n            // consume the length of the aggregate\n            src     += 2;\n            src_len -= 2;\n\n            if (nal_size <= src_len) {\n                if (pass == 0) {\n                    // counting\n                    total_length += sizeof(start_sequence) + nal_size;\n                } else {\n                    // copying\n                    memcpy(dst, start_sequence, sizeof(start_sequence));\n                    dst += sizeof(start_sequence);\n                    memcpy(dst, src, nal_size);\n                    if (nal_counters)\n                        nal_counters[(*src) & nal_mask]++;\n                    dst += nal_size;\n                }\n            } else {\n                av_log(ctx, AV_LOG_ERROR,\n                       \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            // eat what we handled\n            src     += nal_size + skip_between;\n            src_len -= nal_size + skip_between;\n        }\n\n        if (pass == 0) {\n            /* now we know the total size of the packet (with the\n             * start sequences added) */\n            if ((ret = av_new_packet(pkt, total_length)) < 0)\n                return ret;\n            dst = pkt->data;\n        }\n    }\n\n    return 0;\n}\n\nint ff_h264_handle_frag_packet(AVPacket *pkt, const uint8_t *buf, int len,\n                               int start_bit, const uint8_t *nal_header,\n                               int nal_header_len)\n{\n    int ret;\n    int tot_len = len;\n    int pos = 0;\n    if (start_bit)\n        tot_len += sizeof(start_sequence) + nal_header_len;\n    if ((ret = av_new_packet(pkt, tot_len)) < 0)\n        return ret;\n    if (start_bit) {\n        memcpy(pkt->data + pos, start_sequence, sizeof(start_sequence));\n        pos += sizeof(start_sequence);\n        memcpy(pkt->data + pos, nal_header, nal_header_len);\n        pos += nal_header_len;\n    }\n    memcpy(pkt->data + pos, buf, len);\n    return 0;\n}\n\nstatic int h264_handle_packet_fu_a(AVFormatContext *ctx, PayloadContext *data, AVPacket *pkt,\n                                   const uint8_t *buf, int len,\n                                   int *nal_counters, int nal_mask)\n{\n    uint8_t fu_indicator, fu_header, start_bit, nal_type, nal;\n\n    if (len < 3) {\n        av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H.264 RTP packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    fu_indicator = buf[0];\n    fu_header    = buf[1];\n    start_bit    = fu_header >> 7;\n    nal_type     = fu_header & 0x1f;\n    nal          = fu_indicator & 0xe0 | nal_type;\n\n    // skip the fu_indicator and fu_header\n    buf += 2;\n    len -= 2;\n\n    if (start_bit && nal_counters)\n        nal_counters[nal_type & nal_mask]++;\n    return ff_h264_handle_frag_packet(pkt, buf, len, start_bit, &nal, 1);\n}\n\n// return 0 on packet, no more left, 1 on packet, 1 on partial packet\nstatic int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n                              const uint8_t *buf, int len, uint16_t seq,\n                              int flags)\n{\n    uint8_t nal;\n    uint8_t type;\n    int result = 0;\n\n    if (!len) {\n        av_log(ctx, AV_LOG_ERROR, \"Empty H.264 RTP packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    nal  = buf[0];\n    type = nal & 0x1f;\n\n    /* Simplify the case (these are all the NAL types used internally by\n     * the H.264 codec). */\n    if (type >= 1 && type <= 23)\n        type = 1;\n    switch (type) {\n    case 0:                    // undefined, but pass them through\n    case 1:\n        if ((result = av_new_packet(pkt, len + sizeof(start_sequence))) < 0)\n            return result;\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n        COUNT_NAL_TYPE(data, nal);\n        break;\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n        // consume the STAP-A NAL\n        buf++;\n        len--;\n        result = ff_h264_handle_aggregated_packet(ctx, data, pkt, buf, len, 0,\n                                                  NAL_COUNTERS, NAL_MASK);\n        break;\n\n    case 25:                   // STAP-B\n    case 26:                   // MTAP-16\n    case 27:                   // MTAP-24\n    case 29:                   // FU-B\n        avpriv_report_missing_feature(ctx, \"RTP H.264 NAL unit type %d\", type);\n        result = AVERROR_PATCHWELCOME;\n        break;\n\n    case 28:                   // FU-A (fragmented nal)\n        result = h264_handle_packet_fu_a(ctx, data, pkt, buf, len,\n                                         NAL_COUNTERS, NAL_MASK);\n        break;\n\n    case 30:                   // undefined\n    case 31:                   // undefined\n    default:\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n        result = AVERROR_INVALIDDATA;\n        break;\n    }\n\n    pkt->stream_index = st->index;\n\n    return result;\n}\n\nstatic void h264_close_context(PayloadContext *data)\n{\n#ifdef DEBUG\n    int ii;\n\n    for (ii = 0; ii < 32; ii++) {\n        if (data->packet_types_received[ii])\n            av_log(NULL, AV_LOG_DEBUG, \"Received %d packets of type %d\\n\",\n                   data->packet_types_received[ii], ii);\n    }\n#endif\n}\n\nstatic int parse_h264_sdp_line(AVFormatContext *s, int st_index,\n                               PayloadContext *h264_data, const char *line)\n{\n    AVStream *stream;\n    const char *p = line;\n\n    if (st_index < 0)\n        return 0;\n\n    stream = s->streams[st_index];\n\n    if (av_strstart(p, \"framesize:\", &p)) {\n        ff_h264_parse_framesize(stream->codecpar, p);\n    } else if (av_strstart(p, \"fmtp:\", &p)) {\n        return ff_parse_fmtp(s, stream, h264_data, p, sdp_parse_fmtp_config_h264);\n    } else if (av_strstart(p, \"cliprect:\", &p)) {\n        // could use this if we wanted.\n    }\n\n    return 0;\n}\n\nRTPDynamicProtocolHandler ff_h264_dynamic_handler = {\n    .enc_name         = \"H264\",\n    .codec_type       = AVMEDIA_TYPE_VIDEO,\n    .codec_id         = AV_CODEC_ID_H264,\n    .need_parsing     = AVSTREAM_PARSE_FULL,\n    .priv_data_size   = sizeof(PayloadContext),\n    .parse_sdp_a_line = parse_h264_sdp_line,\n    .close            = h264_close_context,\n    .parse_packet     = h264_handle_packet,\n};\n"], "fixing_code": ["/*\n * RTP H.264 Protocol (RFC3984)\n * Copyright (c) 2006 Ryan Martell\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * @brief H.264 / RTP Code (RFC3984)\n * @author Ryan Martell <rdm4@martellventures.com>\n *\n * @note Notes:\n * Notes:\n * This currently supports packetization mode:\n * Single Nal Unit Mode (0), or\n * Non-Interleaved Mode (1).  It currently does not support\n * Interleaved Mode (2). (This requires implementing STAP-B, MTAP16, MTAP24,\n *                        FU-B packet types)\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/base64.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/avstring.h\"\n#include \"avformat.h\"\n\n#include \"rtpdec.h\"\n#include \"rtpdec_formats.h\"\n\nstruct PayloadContext {\n    // sdp setup parameters\n    uint8_t profile_idc;\n    uint8_t profile_iop;\n    uint8_t level_idc;\n    int packetization_mode;\n#ifdef DEBUG\n    int packet_types_received[32];\n#endif\n};\n\n#ifdef DEBUG\n#define COUNT_NAL_TYPE(data, nal) data->packet_types_received[(nal) & 0x1f]++\n#define NAL_COUNTERS data->packet_types_received\n#else\n#define COUNT_NAL_TYPE(data, nal) do { } while (0)\n#define NAL_COUNTERS NULL\n#endif\n#define NAL_MASK 0x1f\n\nstatic const uint8_t start_sequence[] = { 0, 0, 0, 1 };\n\nstatic void parse_profile_level_id(AVFormatContext *s,\n                                   PayloadContext *h264_data,\n                                   const char *value)\n{\n    char buffer[3];\n    // 6 characters=3 bytes, in hex.\n    uint8_t profile_idc;\n    uint8_t profile_iop;\n    uint8_t level_idc;\n\n    buffer[0]   = value[0];\n    buffer[1]   = value[1];\n    buffer[2]   = '\\0';\n    profile_idc = strtol(buffer, NULL, 16);\n    buffer[0]   = value[2];\n    buffer[1]   = value[3];\n    profile_iop = strtol(buffer, NULL, 16);\n    buffer[0]   = value[4];\n    buffer[1]   = value[5];\n    level_idc   = strtol(buffer, NULL, 16);\n\n    av_log(s, AV_LOG_DEBUG,\n           \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n           profile_idc, profile_iop, level_idc);\n    h264_data->profile_idc = profile_idc;\n    h264_data->profile_iop = profile_iop;\n    h264_data->level_idc   = level_idc;\n}\n\nint ff_h264_parse_sprop_parameter_sets(AVFormatContext *s,\n                                       uint8_t **data_ptr, int *size_ptr,\n                                       const char *value)\n{\n    char base64packet[1024];\n    uint8_t decoded_packet[1024];\n    int packet_size;\n\n    while (*value) {\n        char *dst = base64packet;\n\n        while (*value && *value != ','\n               && (dst - base64packet) < sizeof(base64packet) - 1) {\n            *dst++ = *value++;\n        }\n        *dst++ = '\\0';\n\n        if (*value == ',')\n            value++;\n\n        packet_size = av_base64_decode(decoded_packet, base64packet,\n                                       sizeof(decoded_packet));\n        if (packet_size > 0) {\n            uint8_t *dest = av_realloc(*data_ptr,\n                                       packet_size + sizeof(start_sequence) +\n                                       *size_ptr +\n                                       AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!dest) {\n                av_log(s, AV_LOG_ERROR,\n                       \"Unable to allocate memory for extradata!\\n\");\n                return AVERROR(ENOMEM);\n            }\n            *data_ptr = dest;\n\n            memcpy(dest + *size_ptr, start_sequence,\n                   sizeof(start_sequence));\n            memcpy(dest + *size_ptr + sizeof(start_sequence),\n                   decoded_packet, packet_size);\n            memset(dest + *size_ptr + sizeof(start_sequence) +\n                   packet_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n            *size_ptr += sizeof(start_sequence) + packet_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n         * Packetization Mode:\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n         *                      and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (*value == 0 || value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}\n\nvoid ff_h264_parse_framesize(AVCodecParameters *par, const char *p)\n{\n    char buf1[50];\n    char *dst = buf1;\n\n    // remove the protocol identifier\n    while (*p && *p == ' ')\n        p++;                     // strip spaces.\n    while (*p && *p != ' ')\n        p++;                     // eat protocol identifier\n    while (*p && *p == ' ')\n        p++;                     // strip trailing spaces.\n    while (*p && *p != '-' && (dst - buf1) < sizeof(buf1) - 1)\n        *dst++ = *p++;\n    *dst = '\\0';\n\n    // a='framesize:96 320-240'\n    // set our parameters\n    par->width   = atoi(buf1);\n    par->height  = atoi(p + 1); // skip the -\n}\n\nint ff_h264_handle_aggregated_packet(AVFormatContext *ctx, PayloadContext *data, AVPacket *pkt,\n                                     const uint8_t *buf, int len,\n                                     int skip_between, int *nal_counters,\n                                     int nal_mask)\n{\n    int pass         = 0;\n    int total_length = 0;\n    uint8_t *dst     = NULL;\n    int ret;\n\n    // first we are going to figure out the total size\n    for (pass = 0; pass < 2; pass++) {\n        const uint8_t *src = buf;\n        int src_len        = len;\n\n        while (src_len > 2) {\n            uint16_t nal_size = AV_RB16(src);\n\n            // consume the length of the aggregate\n            src     += 2;\n            src_len -= 2;\n\n            if (nal_size <= src_len) {\n                if (pass == 0) {\n                    // counting\n                    total_length += sizeof(start_sequence) + nal_size;\n                } else {\n                    // copying\n                    memcpy(dst, start_sequence, sizeof(start_sequence));\n                    dst += sizeof(start_sequence);\n                    memcpy(dst, src, nal_size);\n                    if (nal_counters)\n                        nal_counters[(*src) & nal_mask]++;\n                    dst += nal_size;\n                }\n            } else {\n                av_log(ctx, AV_LOG_ERROR,\n                       \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            // eat what we handled\n            src     += nal_size + skip_between;\n            src_len -= nal_size + skip_between;\n        }\n\n        if (pass == 0) {\n            /* now we know the total size of the packet (with the\n             * start sequences added) */\n            if ((ret = av_new_packet(pkt, total_length)) < 0)\n                return ret;\n            dst = pkt->data;\n        }\n    }\n\n    return 0;\n}\n\nint ff_h264_handle_frag_packet(AVPacket *pkt, const uint8_t *buf, int len,\n                               int start_bit, const uint8_t *nal_header,\n                               int nal_header_len)\n{\n    int ret;\n    int tot_len = len;\n    int pos = 0;\n    if (start_bit)\n        tot_len += sizeof(start_sequence) + nal_header_len;\n    if ((ret = av_new_packet(pkt, tot_len)) < 0)\n        return ret;\n    if (start_bit) {\n        memcpy(pkt->data + pos, start_sequence, sizeof(start_sequence));\n        pos += sizeof(start_sequence);\n        memcpy(pkt->data + pos, nal_header, nal_header_len);\n        pos += nal_header_len;\n    }\n    memcpy(pkt->data + pos, buf, len);\n    return 0;\n}\n\nstatic int h264_handle_packet_fu_a(AVFormatContext *ctx, PayloadContext *data, AVPacket *pkt,\n                                   const uint8_t *buf, int len,\n                                   int *nal_counters, int nal_mask)\n{\n    uint8_t fu_indicator, fu_header, start_bit, nal_type, nal;\n\n    if (len < 3) {\n        av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H.264 RTP packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    fu_indicator = buf[0];\n    fu_header    = buf[1];\n    start_bit    = fu_header >> 7;\n    nal_type     = fu_header & 0x1f;\n    nal          = fu_indicator & 0xe0 | nal_type;\n\n    // skip the fu_indicator and fu_header\n    buf += 2;\n    len -= 2;\n\n    if (start_bit && nal_counters)\n        nal_counters[nal_type & nal_mask]++;\n    return ff_h264_handle_frag_packet(pkt, buf, len, start_bit, &nal, 1);\n}\n\n// return 0 on packet, no more left, 1 on packet, 1 on partial packet\nstatic int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n                              const uint8_t *buf, int len, uint16_t seq,\n                              int flags)\n{\n    uint8_t nal;\n    uint8_t type;\n    int result = 0;\n\n    if (!len) {\n        av_log(ctx, AV_LOG_ERROR, \"Empty H.264 RTP packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    nal  = buf[0];\n    type = nal & 0x1f;\n\n    /* Simplify the case (these are all the NAL types used internally by\n     * the H.264 codec). */\n    if (type >= 1 && type <= 23)\n        type = 1;\n    switch (type) {\n    case 0:                    // undefined, but pass them through\n    case 1:\n        if ((result = av_new_packet(pkt, len + sizeof(start_sequence))) < 0)\n            return result;\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n        COUNT_NAL_TYPE(data, nal);\n        break;\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n        // consume the STAP-A NAL\n        buf++;\n        len--;\n        result = ff_h264_handle_aggregated_packet(ctx, data, pkt, buf, len, 0,\n                                                  NAL_COUNTERS, NAL_MASK);\n        break;\n\n    case 25:                   // STAP-B\n    case 26:                   // MTAP-16\n    case 27:                   // MTAP-24\n    case 29:                   // FU-B\n        avpriv_report_missing_feature(ctx, \"RTP H.264 NAL unit type %d\", type);\n        result = AVERROR_PATCHWELCOME;\n        break;\n\n    case 28:                   // FU-A (fragmented nal)\n        result = h264_handle_packet_fu_a(ctx, data, pkt, buf, len,\n                                         NAL_COUNTERS, NAL_MASK);\n        break;\n\n    case 30:                   // undefined\n    case 31:                   // undefined\n    default:\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n        result = AVERROR_INVALIDDATA;\n        break;\n    }\n\n    pkt->stream_index = st->index;\n\n    return result;\n}\n\nstatic void h264_close_context(PayloadContext *data)\n{\n#ifdef DEBUG\n    int ii;\n\n    for (ii = 0; ii < 32; ii++) {\n        if (data->packet_types_received[ii])\n            av_log(NULL, AV_LOG_DEBUG, \"Received %d packets of type %d\\n\",\n                   data->packet_types_received[ii], ii);\n    }\n#endif\n}\n\nstatic int parse_h264_sdp_line(AVFormatContext *s, int st_index,\n                               PayloadContext *h264_data, const char *line)\n{\n    AVStream *stream;\n    const char *p = line;\n\n    if (st_index < 0)\n        return 0;\n\n    stream = s->streams[st_index];\n\n    if (av_strstart(p, \"framesize:\", &p)) {\n        ff_h264_parse_framesize(stream->codecpar, p);\n    } else if (av_strstart(p, \"fmtp:\", &p)) {\n        return ff_parse_fmtp(s, stream, h264_data, p, sdp_parse_fmtp_config_h264);\n    } else if (av_strstart(p, \"cliprect:\", &p)) {\n        // could use this if we wanted.\n    }\n\n    return 0;\n}\n\nRTPDynamicProtocolHandler ff_h264_dynamic_handler = {\n    .enc_name         = \"H264\",\n    .codec_type       = AVMEDIA_TYPE_VIDEO,\n    .codec_id         = AV_CODEC_ID_H264,\n    .need_parsing     = AVSTREAM_PARSE_FULL,\n    .priv_data_size   = sizeof(PayloadContext),\n    .parse_sdp_a_line = parse_h264_sdp_line,\n    .close            = h264_close_context,\n    .parse_packet     = h264_handle_packet,\n};\n"], "filenames": ["libavformat/rtpdec_h264.c"], "buggy_code_start_loc": [169], "buggy_code_end_loc": [170], "fixing_code_start_loc": [169], "fixing_code_end_loc": [170], "type": "CWE-119", "message": "The sdp_parse_fmtp_config_h264 function in libavformat/rtpdec_h264.c in FFmpeg before 3.3.4 mishandles empty sprop-parameter-sets values, which allows remote attackers to cause a denial of service (heap buffer overflow) or possibly have unspecified other impact via a crafted sdp file.", "other": {"cve": {"id": "CVE-2017-14767", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-27T08:29:00.577", "lastModified": "2019-01-08T11:29:01.003", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The sdp_parse_fmtp_config_h264 function in libavformat/rtpdec_h264.c in FFmpeg before 3.3.4 mishandles empty sprop-parameter-sets values, which allows remote attackers to cause a denial of service (heap buffer overflow) or possibly have unspecified other impact via a crafted sdp file."}, {"lang": "es", "value": "La funci\u00f3n sdp_parse_fmtp_config_h264 en libavformat/rtpdec_h264.c en FFmpeg en versiones anteriores a la 3.3.4 gestiona incorrectamente los valores sprop-paremeter-sets vac\u00edos, lo que permite que los atacantes causen una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica o heap) o posiblemente otro impacto no especificado mediante un archivo sdp manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.3", "matchCriteriaId": "2B5DAA40-CAB2-4B80-9B3D-36709C4E12E7"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/101019", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/c42a1388a6d1bfd8001bf6a4241d8ca27e49326d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c42a1388a6d1bfd8001bf6a4241d8ca27e49326d"}}