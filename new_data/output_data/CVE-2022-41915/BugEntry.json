{"buggy_code": ["/*\n * Copyright 2015 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.handler.codec.http.HttpHeadersTestUtils.HeaderValue;\nimport io.netty.util.AsciiString;\nimport io.netty.util.internal.EmptyArrays;\nimport io.netty.util.internal.StringUtil;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport static io.netty.handler.codec.http.HttpHeadersTestUtils.of;\nimport static io.netty.util.AsciiString.contentEquals;\nimport static java.util.Arrays.asList;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DefaultHttpHeadersTest {\n    private static final CharSequence HEADER_NAME = \"testHeader\";\n\n    @Test\n    public void nullHeaderNameNotAllowed() {\n        assertThrows(IllegalArgumentException.class, new Executable() {\n            @Override\n            public void execute() {\n                new DefaultHttpHeaders().add(null, \"foo\");\n            }\n        });\n    }\n\n    @Test\n    public void emptyHeaderNameNotAllowed() {\n        assertThrows(IllegalArgumentException.class, new Executable() {\n            @Override\n            public void execute() {\n                new DefaultHttpHeaders().add(StringUtil.EMPTY_STRING, \"foo\");\n            }\n        });\n    }\n\n    @Test\n    public void keysShouldBeCaseInsensitive() {\n        DefaultHttpHeaders headers = new DefaultHttpHeaders();\n        headers.add(of(\"Name\"), of(\"value1\"));\n        headers.add(of(\"name\"), of(\"value2\"));\n        headers.add(of(\"NAME\"), of(\"value3\"));\n        assertEquals(3, headers.size());\n\n        List<String> values = asList(\"value1\", \"value2\", \"value3\");\n\n        assertEquals(values, headers.getAll(of(\"NAME\")));\n        assertEquals(values, headers.getAll(of(\"name\")));\n        assertEquals(values, headers.getAll(of(\"Name\")));\n        assertEquals(values, headers.getAll(of(\"nAmE\")));\n    }\n\n    @Test\n    public void keysShouldBeCaseInsensitiveInHeadersEquals() {\n        DefaultHttpHeaders headers1 = new DefaultHttpHeaders();\n        headers1.add(of(\"name1\"), asList(\"value1\", \"value2\", \"value3\"));\n        headers1.add(of(\"nAmE2\"), of(\"value4\"));\n\n        DefaultHttpHeaders headers2 = new DefaultHttpHeaders();\n        headers2.add(of(\"naMe1\"), asList(\"value1\", \"value2\", \"value3\"));\n        headers2.add(of(\"NAME2\"), of(\"value4\"));\n\n        assertEquals(headers1, headers1);\n        assertEquals(headers2, headers2);\n        assertEquals(headers1, headers2);\n        assertEquals(headers2, headers1);\n        assertEquals(headers1.hashCode(), headers2.hashCode());\n    }\n\n    @Test\n    public void testStringKeyRetrievedAsAsciiString() {\n        final HttpHeaders headers = new DefaultHttpHeaders(false);\n\n        // Test adding String key and retrieving it using a AsciiString key\n        final String connection = \"keep-alive\";\n        headers.add(of(\"Connection\"), connection);\n\n        // Passes\n        final String value = headers.getAsString(HttpHeaderNames.CONNECTION.toString());\n        assertNotNull(value);\n        assertEquals(connection, value);\n\n        // Passes\n        final String value2 = headers.getAsString(HttpHeaderNames.CONNECTION);\n        assertNotNull(value2);\n        assertEquals(connection, value2);\n    }\n\n    @Test\n    public void testAsciiStringKeyRetrievedAsString() {\n        final HttpHeaders headers = new DefaultHttpHeaders(false);\n\n        // Test adding AsciiString key and retrieving it using a String key\n        final String cacheControl = \"no-cache\";\n        headers.add(HttpHeaderNames.CACHE_CONTROL, cacheControl);\n\n        final String value = headers.getAsString(HttpHeaderNames.CACHE_CONTROL);\n        assertNotNull(value);\n        assertEquals(cacheControl, value);\n\n        final String value2 = headers.getAsString(HttpHeaderNames.CACHE_CONTROL.toString());\n        assertNotNull(value2);\n        assertEquals(cacheControl, value2);\n    }\n\n    @Test\n    public void testRemoveTransferEncodingIgnoreCase() {\n        HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n        message.headers().set(HttpHeaderNames.TRANSFER_ENCODING, \"Chunked\");\n        assertFalse(message.headers().isEmpty());\n        HttpUtil.setTransferEncodingChunked(message, false);\n        assertTrue(message.headers().isEmpty());\n    }\n\n    // Test for https://github.com/netty/netty/issues/1690\n    @Test\n    public void testGetOperations() {\n        HttpHeaders headers = new DefaultHttpHeaders();\n        headers.add(of(\"Foo\"), of(\"1\"));\n        headers.add(of(\"Foo\"), of(\"2\"));\n\n        assertEquals(\"1\", headers.get(of(\"Foo\")));\n\n        List<String> values = headers.getAll(of(\"Foo\"));\n        assertEquals(2, values.size());\n        assertEquals(\"1\", values.get(0));\n        assertEquals(\"2\", values.get(1));\n    }\n\n    @Test\n    public void testEqualsIgnoreCase() {\n        assertThat(AsciiString.contentEqualsIgnoreCase(null, null), is(true));\n        assertThat(AsciiString.contentEqualsIgnoreCase(null, \"foo\"), is(false));\n        assertThat(AsciiString.contentEqualsIgnoreCase(\"bar\", null), is(false));\n        assertThat(AsciiString.contentEqualsIgnoreCase(\"FoO\", \"fOo\"), is(true));\n    }\n\n    @Test\n    public void testSetNullHeaderValueValidate() {\n        final HttpHeaders headers = new DefaultHttpHeaders(true);\n        assertThrows(NullPointerException.class, new Executable() {\n            @Override\n            public void execute() {\n                headers.set(of(\"test\"), (CharSequence) null);\n            }\n        });\n    }\n\n    @Test\n    public void testSetNullHeaderValueNotValidate() {\n        final HttpHeaders headers = new DefaultHttpHeaders(false);\n        assertThrows(NullPointerException.class, new Executable() {\n            @Override\n            public void execute() {\n                headers.set(of(\"test\"), (CharSequence) null);\n            }\n        });\n    }\n\n    @Test\n    public void addCharSequences() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.add(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void addIterable() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.add(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void addObjects() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.add(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setCharSequences() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setIterable() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setObjectObjects() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setObjectIterable() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void toStringOnEmptyHeaders() {\n        assertEquals(\"DefaultHttpHeaders[]\", newDefaultDefaultHttpHeaders().toString());\n    }\n\n    @Test\n    public void toStringOnSingleHeader() {\n        assertEquals(\"DefaultHttpHeaders[foo: bar]\", newDefaultDefaultHttpHeaders()\n                .add(\"foo\", \"bar\")\n                .toString());\n    }\n\n    @Test\n    public void toStringOnMultipleHeaders() {\n        assertEquals(\"DefaultHttpHeaders[foo: bar, baz: qix]\", newDefaultDefaultHttpHeaders()\n                .add(\"foo\", \"bar\")\n                .add(\"baz\", \"qix\")\n                .toString());\n    }\n\n    @Test\n    public void providesHeaderNamesAsArray() throws Exception {\n        Set<String> nettyHeaders = new DefaultHttpHeaders()\n                .add(HttpHeaderNames.CONTENT_LENGTH, 10)\n                .names();\n\n        String[] namesArray = nettyHeaders.toArray(EmptyArrays.EMPTY_STRINGS);\n        assertArrayEquals(namesArray, new String[] { HttpHeaderNames.CONTENT_LENGTH.toString() });\n    }\n\n    private static void assertDefaultValues(final DefaultHttpHeaders headers, final HeaderValue headerValue) {\n        assertTrue(contentEquals(headerValue.asList().get(0), headers.get(HEADER_NAME)));\n        List<CharSequence> expected = headerValue.asList();\n        List<String> actual = headers.getAll(HEADER_NAME);\n        assertEquals(expected.size(), actual.size());\n        Iterator<CharSequence> eItr = expected.iterator();\n        Iterator<String> aItr = actual.iterator();\n        while (eItr.hasNext()) {\n            assertTrue(contentEquals(eItr.next(), aItr.next()));\n        }\n    }\n\n    private static DefaultHttpHeaders newDefaultDefaultHttpHeaders() {\n        return new DefaultHttpHeaders(true);\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec;\n\nimport io.netty.util.HashingStrategy;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport static io.netty.util.HashingStrategy.JAVA_HASHER;\nimport static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n/**\n * Default implementation of {@link Headers};\n *\n * @param <K> the type of the header name.\n * @param <V> the type of the header value.\n * @param <T> the type to use for return values when the intention is to return {@code this} object.\n */\npublic class DefaultHeaders<K, V, T extends Headers<K, V, T>> implements Headers<K, V, T> {\n    /**\n     * Constant used to seed the hash code generation. Could be anything but this was borrowed from murmur3.\n     */\n    static final int HASH_CODE_SEED = 0xc2b2ae35;\n\n    private final HeaderEntry<K, V>[] entries;\n    protected final HeaderEntry<K, V> head;\n\n    private final byte hashMask;\n    private final ValueConverter<V> valueConverter;\n    private final NameValidator<K> nameValidator;\n    private final ValueValidator<V> valueValidator;\n    private final HashingStrategy<K> hashingStrategy;\n    int size;\n\n    public interface NameValidator<K> {\n        /**\n         * Verify that {@code name} is valid.\n         * @param name The name to validate.\n         * @throws RuntimeException if {@code name} is not valid.\n         */\n        void validateName(K name);\n\n        @SuppressWarnings(\"rawtypes\")\n        NameValidator NOT_NULL = new NameValidator() {\n            @Override\n            public void validateName(Object name) {\n                checkNotNull(name, \"name\");\n            }\n        };\n    }\n\n    public interface ValueValidator<V> {\n        /**\n         * Validate the given value. If the validation fails, then an implementation specific runtime exception may be\n         * thrown.\n         *\n         * @param value The value to validate.\n         */\n        void validate(V value);\n\n        ValueValidator<?> NO_VALIDATION = new ValueValidator<Object>() {\n            @Override\n            public void validate(Object value) {\n            }\n        };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(ValueConverter<V> valueConverter) {\n        this(JAVA_HASHER, valueConverter);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(ValueConverter<V> valueConverter, NameValidator<K> nameValidator) {\n        this(JAVA_HASHER, valueConverter, nameValidator);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter) {\n        this(nameHashingStrategy, valueConverter, NameValidator.NOT_NULL);\n    }\n\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy,\n            ValueConverter<V> valueConverter, NameValidator<K> nameValidator) {\n        this(nameHashingStrategy, valueConverter, nameValidator, 16);\n    }\n\n    /**\n     * Create a new instance.\n     * @param nameHashingStrategy Used to hash and equality compare names.\n     * @param valueConverter Used to convert values to/from native types.\n     * @param nameValidator Used to validate name elements.\n     * @param arraySizeHint A hint as to how large the hash data structure should be.\n     * The next positive power of two will be used. An upper bound may be enforced.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy,\n                          ValueConverter<V> valueConverter, NameValidator<K> nameValidator, int arraySizeHint) {\n        this(nameHashingStrategy, valueConverter, nameValidator, arraySizeHint,\n                (ValueValidator<V>) ValueValidator.NO_VALIDATION);\n    }\n\n    /**\n     * Create a new instance.\n     * @param nameHashingStrategy Used to hash and equality compare names.\n     * @param valueConverter Used to convert values to/from native types.\n     * @param nameValidator Used to validate name elements.\n     * @param arraySizeHint A hint as to how large the hash data structure should be.\n     * The next positive power of two will be used. An upper bound may be enforced.\n     * @param valueValidator The validation strategy for entry values.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter,\n                          NameValidator<K> nameValidator, int arraySizeHint, ValueValidator<V> valueValidator) {\n        this.valueConverter = checkNotNull(valueConverter, \"valueConverter\");\n        this.nameValidator = checkNotNull(nameValidator, \"nameValidator\");\n        hashingStrategy = checkNotNull(nameHashingStrategy, \"nameHashingStrategy\");\n        this.valueValidator = checkNotNull(valueValidator, \"valueValidator\");\n        // Enforce a bound of [2, 128] because hashMask is a byte. The max possible value of hashMask is one less\n        // than the length of this array, and we want the mask to be > 0.\n        entries = new HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];\n        hashMask = (byte) (entries.length - 1);\n        head = new HeaderEntry<K, V>();\n    }\n\n    @Override\n    public V get(K name) {\n        checkNotNull(name, \"name\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        HeaderEntry<K, V> e = entries[i];\n        V value = null;\n        // loop until the first header was found\n        while (e != null) {\n            if (e.hash == h && hashingStrategy.equals(name, e.key)) {\n                value = e.value;\n            }\n\n            e = e.next;\n        }\n        return value;\n    }\n\n    @Override\n    public V get(K name, V defaultValue) {\n        V value = get(name);\n        if (value == null) {\n            return defaultValue;\n        }\n        return value;\n    }\n\n    @Override\n    public V getAndRemove(K name) {\n        int h = hashingStrategy.hashCode(name);\n        return remove0(h, index(h), checkNotNull(name, \"name\"));\n    }\n\n    @Override\n    public V getAndRemove(K name, V defaultValue) {\n        V value = getAndRemove(name);\n        if (value == null) {\n            return defaultValue;\n        }\n        return value;\n    }\n\n    @Override\n    public List<V> getAll(K name) {\n        checkNotNull(name, \"name\");\n\n        LinkedList<V> values = new LinkedList<V>();\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        HeaderEntry<K, V> e = entries[i];\n        while (e != null) {\n            if (e.hash == h && hashingStrategy.equals(name, e.key)) {\n                values.addFirst(e.getValue());\n            }\n            e = e.next;\n        }\n        return values;\n    }\n\n    /**\n     * Equivalent to {@link #getAll(Object)} but no intermediate list is generated.\n     * @param name the name of the header to retrieve\n     * @return an {@link Iterator} of header values corresponding to {@code name}.\n     */\n    public Iterator<V> valueIterator(K name) {\n        return new ValueIterator(name);\n    }\n\n    @Override\n    public List<V> getAllAndRemove(K name) {\n        List<V> all = getAll(name);\n        remove(name);\n        return all;\n    }\n\n    @Override\n    public boolean contains(K name) {\n        return get(name) != null;\n    }\n\n    @Override\n    public boolean containsObject(K name, Object value) {\n        return contains(name, fromObject(name, value));\n    }\n\n    @Override\n    public boolean containsBoolean(K name, boolean value) {\n        return contains(name, fromBoolean(name, value));\n    }\n\n    @Override\n    public boolean containsByte(K name, byte value) {\n        return contains(name, fromByte(name, value));\n    }\n\n    @Override\n    public boolean containsChar(K name, char value) {\n        return contains(name, fromChar(name, value));\n    }\n\n    @Override\n    public boolean containsShort(K name, short value) {\n        return contains(name, fromShort(name, value));\n    }\n\n    @Override\n    public boolean containsInt(K name, int value) {\n        return contains(name, fromInt(name, value));\n    }\n\n    @Override\n    public boolean containsLong(K name, long value) {\n        return contains(name, fromLong(name, value));\n    }\n\n    @Override\n    public boolean containsFloat(K name, float value) {\n        return contains(name, fromFloat(name, value));\n    }\n\n    @Override\n    public boolean containsDouble(K name, double value) {\n        return contains(name, fromDouble(name, value));\n    }\n\n    @Override\n    public boolean containsTimeMillis(K name, long value) {\n        return contains(name, fromTimeMillis(name, value));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean contains(K name, V value) {\n        return contains(name, value, JAVA_HASHER);\n    }\n\n    public final boolean contains(K name, V value, HashingStrategy<? super V> valueHashingStrategy) {\n        checkNotNull(name, \"name\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        HeaderEntry<K, V> e = entries[i];\n        while (e != null) {\n            if (e.hash == h && hashingStrategy.equals(name, e.key) && valueHashingStrategy.equals(value, e.value)) {\n                return true;\n            }\n            e = e.next;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == head.after;\n    }\n\n    @Override\n    public Set<K> names() {\n        if (isEmpty()) {\n            return Collections.emptySet();\n        }\n        Set<K> names = new LinkedHashSet<K>(size());\n        HeaderEntry<K, V> e = head.after;\n        while (e != head) {\n            names.add(e.getKey());\n            e = e.after;\n        }\n        return names;\n    }\n\n    @Override\n    public T add(K name, V value) {\n        validateName(nameValidator, true, name);\n        validateValue(valueValidator, name, value);\n        checkNotNull(value, \"value\");\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        add0(h, i, name, value);\n        return thisT();\n    }\n\n    @Override\n    public T add(K name, Iterable<? extends V> values) {\n        validateName(nameValidator, true, name);\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        for (V v: values) {\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T add(K name, V... values) {\n        validateName(nameValidator, true, name);\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        for (V v: values) {\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T addObject(K name, Object value) {\n        return add(name, fromObject(name, value));\n    }\n\n    @Override\n    public T addObject(K name, Iterable<?> values) {\n        for (Object value : values) {\n            addObject(name, value);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T addObject(K name, Object... values) {\n        for (Object value: values) {\n            addObject(name, value);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T addInt(K name, int value) {\n        return add(name, fromInt(name, value));\n    }\n\n    @Override\n    public T addLong(K name, long value) {\n        return add(name, fromLong(name, value));\n    }\n\n    @Override\n    public T addDouble(K name, double value) {\n        return add(name, fromDouble(name, value));\n    }\n\n    @Override\n    public T addTimeMillis(K name, long value) {\n        return add(name, fromTimeMillis(name, value));\n    }\n\n    @Override\n    public T addChar(K name, char value) {\n        return add(name, fromChar(name, value));\n    }\n\n    @Override\n    public T addBoolean(K name, boolean value) {\n        return add(name, fromBoolean(name, value));\n    }\n\n    @Override\n    public T addFloat(K name, float value) {\n        return add(name, fromFloat(name, value));\n    }\n\n    @Override\n    public T addByte(K name, byte value) {\n        return add(name, fromByte(name, value));\n    }\n\n    @Override\n    public T addShort(K name, short value) {\n        return add(name, fromShort(name, value));\n    }\n\n    @Override\n    public T add(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers == this) {\n            throw new IllegalArgumentException(\"can't add to itself.\");\n        }\n        addImpl(headers);\n        return thisT();\n    }\n\n    protected void addImpl(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers instanceof DefaultHeaders) {\n            @SuppressWarnings(\"unchecked\")\n            final DefaultHeaders<? extends K, ? extends V, T> defaultHeaders =\n                    (DefaultHeaders<? extends K, ? extends V, T>) headers;\n            HeaderEntry<? extends K, ? extends V> e = defaultHeaders.head.after;\n            if (defaultHeaders.hashingStrategy == hashingStrategy &&\n                    defaultHeaders.nameValidator == nameValidator) {\n                // Fastest copy\n                while (e != defaultHeaders.head) {\n                    add0(e.hash, index(e.hash), e.key, e.value);\n                    e = e.after;\n                }\n            } else {\n                // Fast copy\n                while (e != defaultHeaders.head) {\n                    add(e.key, e.value);\n                    e = e.after;\n                }\n            }\n        } else {\n            // Slow copy\n            for (Entry<? extends K, ? extends V> header : headers) {\n                add(header.getKey(), header.getValue());\n            }\n        }\n    }\n\n    @Override\n    public T set(K name, V value) {\n        validateName(nameValidator, false, name);\n        validateValue(valueValidator, name, value);\n        checkNotNull(value, \"value\");\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        remove0(h, i, name);\n        add0(h, i, name, value);\n        return thisT();\n    }\n\n    @Override\n    public T set(K name, Iterable<? extends V> values) {\n        validateName(nameValidator, false, name);\n        checkNotNull(values, \"values\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (V v: values) {\n            if (v == null) {\n                break;\n            }\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T set(K name, V... values) {\n        validateName(nameValidator, false, name);\n        checkNotNull(values, \"values\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (V v: values) {\n            if (v == null) {\n                break;\n            }\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T setObject(K name, Object value) {\n        V convertedValue = checkNotNull(fromObject(name, value), \"convertedValue\");\n        return set(name, convertedValue);\n    }\n\n    @Override\n    public T setObject(K name, Iterable<?> values) {\n        validateName(nameValidator, false, name);\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (Object v: values) {\n            if (v == null) {\n                break;\n            }\n            add0(h, i, name, fromObject(name, v));\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T setObject(K name, Object... values) {\n        validateName(nameValidator, false, name);\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (Object v: values) {\n            if (v == null) {\n                break;\n            }\n            add0(h, i, name, fromObject(name, v));\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T setInt(K name, int value) {\n        return set(name, fromInt(name, value));\n    }\n\n    @Override\n    public T setLong(K name, long value) {\n        return set(name, fromLong(name, value));\n    }\n\n    @Override\n    public T setDouble(K name, double value) {\n        return set(name, fromDouble(name, value));\n    }\n\n    @Override\n    public T setTimeMillis(K name, long value) {\n        return set(name, fromTimeMillis(name, value));\n    }\n\n    @Override\n    public T setFloat(K name, float value) {\n        return set(name, fromFloat(name, value));\n    }\n\n    @Override\n    public T setChar(K name, char value) {\n        return set(name, fromChar(name, value));\n    }\n\n    @Override\n    public T setBoolean(K name, boolean value) {\n        return set(name, fromBoolean(name, value));\n    }\n\n    @Override\n    public T setByte(K name, byte value) {\n        return set(name, fromByte(name, value));\n    }\n\n    @Override\n    public T setShort(K name, short value) {\n        return set(name, fromShort(name, value));\n    }\n\n    @Override\n    public T set(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers != this) {\n            clear();\n            addImpl(headers);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T setAll(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers != this) {\n            for (K key : headers.names()) {\n                remove(key);\n            }\n            addImpl(headers);\n        }\n        return thisT();\n    }\n\n    @Override\n    public boolean remove(K name) {\n        return getAndRemove(name) != null;\n    }\n\n    @Override\n    public T clear() {\n        Arrays.fill(entries, null);\n        head.before = head.after = head;\n        size = 0;\n        return thisT();\n    }\n\n    @Override\n    public Iterator<Entry<K, V>> iterator() {\n        return new HeaderIterator();\n    }\n\n    @Override\n    public Boolean getBoolean(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toBoolean(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public boolean getBoolean(K name, boolean defaultValue) {\n        Boolean v = getBoolean(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Byte getByte(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toByte(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public byte getByte(K name, byte defaultValue) {\n        Byte v = getByte(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Character getChar(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toChar(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public char getChar(K name, char defaultValue) {\n        Character v = getChar(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Short getShort(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toShort(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public short getShort(K name, short defaultValue) {\n        Short v = getShort(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Integer getInt(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toInt(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public int getInt(K name, int defaultValue) {\n        Integer v = getInt(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getLong(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toLong(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getLong(K name, long defaultValue) {\n        Long v = getLong(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Float getFloat(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toFloat(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public float getFloat(K name, float defaultValue) {\n        Float v = getFloat(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Double getDouble(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toDouble(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public double getDouble(K name, double defaultValue) {\n        Double v = getDouble(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getTimeMillis(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toTimeMillis(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getTimeMillis(K name, long defaultValue) {\n        Long v = getTimeMillis(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Boolean getBooleanAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toBoolean(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public boolean getBooleanAndRemove(K name, boolean defaultValue) {\n        Boolean v = getBooleanAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Byte getByteAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toByte(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public byte getByteAndRemove(K name, byte defaultValue) {\n        Byte v = getByteAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Character getCharAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toChar(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public char getCharAndRemove(K name, char defaultValue) {\n        Character v = getCharAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Short getShortAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toShort(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public short getShortAndRemove(K name, short defaultValue) {\n        Short v = getShortAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Integer getIntAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toInt(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public int getIntAndRemove(K name, int defaultValue) {\n        Integer v = getIntAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getLongAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toLong(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getLongAndRemove(K name, long defaultValue) {\n        Long v = getLongAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Float getFloatAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toFloat(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public float getFloatAndRemove(K name, float defaultValue) {\n        Float v = getFloatAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Double getDoubleAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toDouble(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public double getDoubleAndRemove(K name, double defaultValue) {\n        Double v = getDoubleAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getTimeMillisAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toTimeMillis(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getTimeMillisAndRemove(K name, long defaultValue) {\n        Long v = getTimeMillisAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof Headers)) {\n            return false;\n        }\n\n        return equals((Headers<K, V, ?>) o, JAVA_HASHER);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public int hashCode() {\n        return hashCode(JAVA_HASHER);\n    }\n\n    /**\n     * Test this object for equality against {@code h2}.\n     * @param h2 The object to check equality for.\n     * @param valueHashingStrategy Defines how values will be compared for equality.\n     * @return {@code true} if this object equals {@code h2} given {@code valueHashingStrategy}.\n     * {@code false} otherwise.\n     */\n    public final boolean equals(Headers<K, V, ?> h2, HashingStrategy<V> valueHashingStrategy) {\n        if (h2.size() != size()) {\n            return false;\n        }\n\n        if (this == h2) {\n            return true;\n        }\n\n        for (K name : names()) {\n            List<V> otherValues = h2.getAll(name);\n            List<V> values = getAll(name);\n            if (otherValues.size() != values.size()) {\n                return false;\n            }\n            for (int i = 0; i < otherValues.size(); i++) {\n                if (!valueHashingStrategy.equals(otherValues.get(i), values.get(i))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Generate a hash code for this object given a {@link HashingStrategy} to generate hash codes for\n     * individual values.\n     * @param valueHashingStrategy Defines how values will be hashed.\n     */\n    public final int hashCode(HashingStrategy<V> valueHashingStrategy) {\n        int result = HASH_CODE_SEED;\n        for (K name : names()) {\n            result = 31 * result + hashingStrategy.hashCode(name);\n            List<V> values = getAll(name);\n            for (int i = 0; i < values.size(); ++i) {\n                result = 31 * result + valueHashingStrategy.hashCode(values.get(i));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return HeadersUtils.toString(getClass(), iterator(), size());\n    }\n\n    /**\n     * Call out to the given {@link NameValidator} to validate the given name.\n     *\n     * @param validator the validator to use\n     * @param forAdd {@code true } if this validation is for adding to the headers, or {@code false} if this is for\n     * setting (overwriting) the given header.\n     * @param name the name to validate.\n     */\n    protected void validateName(NameValidator<K> validator, boolean forAdd, K name) {\n        validator.validateName(name);\n    }\n\n    protected void validateValue(ValueValidator<V> validator, K name, V value) {\n        validator.validate(value);\n    }\n\n    protected HeaderEntry<K, V> newHeaderEntry(int h, K name, V value, HeaderEntry<K, V> next) {\n        return new HeaderEntry<K, V>(h, name, value, next, head);\n    }\n\n    protected ValueConverter<V> valueConverter() {\n        return valueConverter;\n    }\n\n    protected NameValidator<K> nameValidator() {\n        return nameValidator;\n    }\n\n    protected ValueValidator<V> valueValidator() {\n        return valueValidator;\n    }\n\n    private int index(int hash) {\n        return hash & hashMask;\n    }\n\n    private void add0(int h, int i, K name, V value) {\n        // Update the hash table.\n        entries[i] = newHeaderEntry(h, name, value, entries[i]);\n        ++size;\n    }\n\n    /**\n     * @return the first value inserted whose hash code equals {@code h} and whose name is equal to {@code name}.\n     */\n    private V remove0(int h, int i, K name) {\n        HeaderEntry<K, V> e = entries[i];\n        if (e == null) {\n            return null;\n        }\n\n        V value = null;\n        HeaderEntry<K, V> next = e.next;\n        while (next != null) {\n            if (next.hash == h && hashingStrategy.equals(name, next.key)) {\n                value = next.value;\n                e.next = next.next;\n                next.remove();\n                --size;\n            } else {\n                e = next;\n            }\n\n            next = e.next;\n        }\n\n        e = entries[i];\n        if (e.hash == h && hashingStrategy.equals(name, e.key)) {\n            if (value == null) {\n                value = e.value;\n            }\n            entries[i] = e.next;\n            e.remove();\n            --size;\n        }\n\n        return value;\n    }\n\n    HeaderEntry<K, V> remove0(HeaderEntry<K, V> entry, HeaderEntry<K, V> previous) {\n        int i = index(entry.hash);\n        HeaderEntry<K, V> firstEntry = entries[i];\n        if (firstEntry == entry) {\n            entries[i] = entry.next;\n            previous = entries[i];\n        } else if (previous == null) {\n            // If we don't have any existing starting point, then start from the beginning.\n            previous = firstEntry;\n            HeaderEntry<K, V> next = firstEntry.next;\n            while (next != null && next != entry) {\n                previous = next;\n                next = next.next;\n            }\n            assert next != null: \"Entry not found in its hash bucket: \" + entry;\n            previous.next = entry.next;\n        } else {\n            previous.next = entry.next;\n        }\n        entry.remove();\n        --size;\n        return previous;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T thisT() {\n        return (T) this;\n    }\n\n    private V fromObject(K name, Object value) {\n        try {\n            return valueConverter.convertObject(checkNotNull(value, \"value\"));\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert object value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromBoolean(K name, boolean value) {\n        try {\n            return valueConverter.convertBoolean(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert boolean value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromByte(K name, byte value) {\n        try {\n            return valueConverter.convertByte(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert byte value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromChar(K name, char value) {\n        try {\n            return valueConverter.convertChar(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert char value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromShort(K name, short value) {\n        try {\n            return valueConverter.convertShort(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert short value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromInt(K name, int value) {\n        try {\n            return valueConverter.convertInt(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert int value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromLong(K name, long value) {\n        try {\n            return valueConverter.convertLong(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert long value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromFloat(K name, float value) {\n        try {\n            return valueConverter.convertFloat(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert float value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromDouble(K name, double value) {\n        try {\n            return valueConverter.convertDouble(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert double value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromTimeMillis(K name, long value) {\n        try {\n            return valueConverter.convertTimeMillis(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert millsecond value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private boolean toBoolean(K name, V value) {\n        try {\n            return valueConverter.convertToBoolean(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to boolean for header '\" + name + '\\'');\n        }\n    }\n\n    private byte toByte(K name, V value) {\n        try {\n            return valueConverter.convertToByte(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to byte for header '\" + name + '\\'');\n        }\n    }\n\n    private char toChar(K name, V value) {\n        try {\n            return valueConverter.convertToChar(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to char for header '\" + name + '\\'');\n        }\n    }\n\n    private short toShort(K name, V value) {\n        try {\n            return valueConverter.convertToShort(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to short for header '\" + name + '\\'');\n        }\n    }\n\n    private int toInt(K name, V value) {\n        try {\n            return valueConverter.convertToInt(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to int for header '\" + name + '\\'');\n        }\n    }\n\n    private long toLong(K name, V value) {\n        try {\n            return valueConverter.convertToLong(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to long for header '\" + name + '\\'');\n        }\n    }\n\n    private float toFloat(K name, V value) {\n        try {\n            return valueConverter.convertToFloat(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to float for header '\" + name + '\\'');\n        }\n    }\n\n    private double toDouble(K name, V value) {\n        try {\n            return valueConverter.convertToDouble(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to double for header '\" + name + '\\'');\n        }\n    }\n\n    private long toTimeMillis(K name, V value) {\n        try {\n            return valueConverter.convertToTimeMillis(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\n                    \"Failed to convert header value to millsecond for header '\" + name + '\\'');\n        }\n    }\n\n    /**\n     * Returns a deep copy of this instance.\n     */\n    public DefaultHeaders<K, V, T> copy() {\n        DefaultHeaders<K, V, T> copy = new DefaultHeaders<K, V, T>(\n                hashingStrategy, valueConverter, nameValidator, entries.length);\n        copy.addImpl(this);\n        return copy;\n    }\n\n    private final class HeaderIterator implements Iterator<Entry<K, V>> {\n        private HeaderEntry<K, V> current = head;\n\n        @Override\n        public boolean hasNext() {\n            return current.after != head;\n        }\n\n        @Override\n        public Entry<K, V> next() {\n            current = current.after;\n\n            if (current == head) {\n                throw new NoSuchElementException();\n            }\n\n            return current;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"read only\");\n        }\n    }\n\n    private final class ValueIterator implements Iterator<V> {\n        private final K name;\n        private final int hash;\n        private HeaderEntry<K, V> removalPrevious;\n        private HeaderEntry<K, V> previous;\n        private HeaderEntry<K, V> next;\n\n        ValueIterator(K name) {\n            this.name = checkNotNull(name, \"name\");\n            hash = hashingStrategy.hashCode(name);\n            calculateNext(entries[index(hash)]);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        @Override\n        public V next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (previous != null) {\n                removalPrevious = previous;\n            }\n            previous = next;\n            calculateNext(next.next);\n            return previous.value;\n        }\n\n        @Override\n        public void remove() {\n            if (previous == null) {\n                throw new IllegalStateException();\n            }\n            removalPrevious = remove0(previous, removalPrevious);\n            previous = null;\n        }\n\n        private void calculateNext(HeaderEntry<K, V> entry) {\n            while (entry != null) {\n                if (entry.hash == hash && hashingStrategy.equals(name, entry.key)) {\n                    next = entry;\n                    return;\n                }\n                entry = entry.next;\n            }\n            next = null;\n        }\n    }\n\n    protected static class HeaderEntry<K, V> implements Entry<K, V> {\n        protected final int hash;\n        protected final K key;\n        protected V value;\n        /**\n         * In bucket linked list\n         */\n        protected HeaderEntry<K, V> next;\n        /**\n         * Overall insertion order linked list\n         */\n        protected HeaderEntry<K, V> before, after;\n\n        protected HeaderEntry(int hash, K key) {\n            this.hash = hash;\n            this.key = key;\n        }\n\n        HeaderEntry(int hash, K key, V value, HeaderEntry<K, V> next, HeaderEntry<K, V> head) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n\n            after = head;\n            before = head.before;\n            pointNeighborsToThis();\n        }\n\n        HeaderEntry() {\n            hash = -1;\n            key = null;\n            before = after = this;\n        }\n\n        protected final void pointNeighborsToThis() {\n            before.after = this;\n            after.before = this;\n        }\n\n        public final HeaderEntry<K, V> before() {\n            return before;\n        }\n\n        public final HeaderEntry<K, V> after() {\n            return after;\n        }\n\n        protected void remove() {\n            before.after = after;\n            after.before = before;\n        }\n\n        @Override\n        public final K getKey() {\n            return key;\n        }\n\n        @Override\n        public final V getValue() {\n            return value;\n        }\n\n        @Override\n        public final V setValue(V value) {\n            checkNotNull(value, \"value\");\n            V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        @Override\n        public final String toString() {\n            return key.toString() + '=' + value.toString();\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n            Entry<?, ?> other = (Entry<?, ?>) o;\n            return (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey()))  &&\n                   (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n        }\n\n        @Override\n        public int hashCode() {\n            return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2015 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.handler.codec.http.HttpHeadersTestUtils.HeaderValue;\nimport io.netty.util.AsciiString;\nimport io.netty.util.internal.EmptyArrays;\nimport io.netty.util.internal.StringUtil;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nimport static io.netty.handler.codec.http.HttpHeadersTestUtils.of;\nimport static io.netty.util.AsciiString.contentEquals;\nimport static java.util.Arrays.asList;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DefaultHttpHeadersTest {\n    private static final CharSequence HEADER_NAME = \"testHeader\";\n    private static final CharSequence ILLEGAL_VALUE = \"testHeader\\r\\nContent-Length:45\\r\\n\\r\\n\";\n\n    @Test\n    public void nullHeaderNameNotAllowed() {\n        assertThrows(IllegalArgumentException.class, new Executable() {\n            @Override\n            public void execute() {\n                new DefaultHttpHeaders().add(null, \"foo\");\n            }\n        });\n    }\n\n    @Test\n    public void emptyHeaderNameNotAllowed() {\n        assertThrows(IllegalArgumentException.class, new Executable() {\n            @Override\n            public void execute() {\n                new DefaultHttpHeaders().add(StringUtil.EMPTY_STRING, \"foo\");\n            }\n        });\n    }\n\n    @Test\n    public void keysShouldBeCaseInsensitive() {\n        DefaultHttpHeaders headers = new DefaultHttpHeaders();\n        headers.add(of(\"Name\"), of(\"value1\"));\n        headers.add(of(\"name\"), of(\"value2\"));\n        headers.add(of(\"NAME\"), of(\"value3\"));\n        assertEquals(3, headers.size());\n\n        List<String> values = asList(\"value1\", \"value2\", \"value3\");\n\n        assertEquals(values, headers.getAll(of(\"NAME\")));\n        assertEquals(values, headers.getAll(of(\"name\")));\n        assertEquals(values, headers.getAll(of(\"Name\")));\n        assertEquals(values, headers.getAll(of(\"nAmE\")));\n    }\n\n    @Test\n    public void keysShouldBeCaseInsensitiveInHeadersEquals() {\n        DefaultHttpHeaders headers1 = new DefaultHttpHeaders();\n        headers1.add(of(\"name1\"), asList(\"value1\", \"value2\", \"value3\"));\n        headers1.add(of(\"nAmE2\"), of(\"value4\"));\n\n        DefaultHttpHeaders headers2 = new DefaultHttpHeaders();\n        headers2.add(of(\"naMe1\"), asList(\"value1\", \"value2\", \"value3\"));\n        headers2.add(of(\"NAME2\"), of(\"value4\"));\n\n        assertEquals(headers1, headers1);\n        assertEquals(headers2, headers2);\n        assertEquals(headers1, headers2);\n        assertEquals(headers2, headers1);\n        assertEquals(headers1.hashCode(), headers2.hashCode());\n    }\n\n    @Test\n    public void testStringKeyRetrievedAsAsciiString() {\n        final HttpHeaders headers = new DefaultHttpHeaders(false);\n\n        // Test adding String key and retrieving it using a AsciiString key\n        final String connection = \"keep-alive\";\n        headers.add(of(\"Connection\"), connection);\n\n        // Passes\n        final String value = headers.getAsString(HttpHeaderNames.CONNECTION.toString());\n        assertNotNull(value);\n        assertEquals(connection, value);\n\n        // Passes\n        final String value2 = headers.getAsString(HttpHeaderNames.CONNECTION);\n        assertNotNull(value2);\n        assertEquals(connection, value2);\n    }\n\n    @Test\n    public void testAsciiStringKeyRetrievedAsString() {\n        final HttpHeaders headers = new DefaultHttpHeaders(false);\n\n        // Test adding AsciiString key and retrieving it using a String key\n        final String cacheControl = \"no-cache\";\n        headers.add(HttpHeaderNames.CACHE_CONTROL, cacheControl);\n\n        final String value = headers.getAsString(HttpHeaderNames.CACHE_CONTROL);\n        assertNotNull(value);\n        assertEquals(cacheControl, value);\n\n        final String value2 = headers.getAsString(HttpHeaderNames.CACHE_CONTROL.toString());\n        assertNotNull(value2);\n        assertEquals(cacheControl, value2);\n    }\n\n    @Test\n    public void testRemoveTransferEncodingIgnoreCase() {\n        HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n        message.headers().set(HttpHeaderNames.TRANSFER_ENCODING, \"Chunked\");\n        assertFalse(message.headers().isEmpty());\n        HttpUtil.setTransferEncodingChunked(message, false);\n        assertTrue(message.headers().isEmpty());\n    }\n\n    // Test for https://github.com/netty/netty/issues/1690\n    @Test\n    public void testGetOperations() {\n        HttpHeaders headers = new DefaultHttpHeaders();\n        headers.add(of(\"Foo\"), of(\"1\"));\n        headers.add(of(\"Foo\"), of(\"2\"));\n\n        assertEquals(\"1\", headers.get(of(\"Foo\")));\n\n        List<String> values = headers.getAll(of(\"Foo\"));\n        assertEquals(2, values.size());\n        assertEquals(\"1\", values.get(0));\n        assertEquals(\"2\", values.get(1));\n    }\n\n    @Test\n    public void testEqualsIgnoreCase() {\n        assertThat(AsciiString.contentEqualsIgnoreCase(null, null), is(true));\n        assertThat(AsciiString.contentEqualsIgnoreCase(null, \"foo\"), is(false));\n        assertThat(AsciiString.contentEqualsIgnoreCase(\"bar\", null), is(false));\n        assertThat(AsciiString.contentEqualsIgnoreCase(\"FoO\", \"fOo\"), is(true));\n    }\n\n    @Test\n    public void testSetNullHeaderValueValidate() {\n        final HttpHeaders headers = new DefaultHttpHeaders(true);\n        assertThrows(NullPointerException.class, new Executable() {\n            @Override\n            public void execute() {\n                headers.set(of(\"test\"), (CharSequence) null);\n            }\n        });\n    }\n\n    @Test\n    public void testSetNullHeaderValueNotValidate() {\n        final HttpHeaders headers = new DefaultHttpHeaders(false);\n        assertThrows(NullPointerException.class, new Executable() {\n            @Override\n            public void execute() {\n                headers.set(of(\"test\"), (CharSequence) null);\n            }\n        });\n    }\n\n    @Test\n    public void addCharSequences() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.add(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void addIterable() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.add(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void addObjects() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.add(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setCharSequences() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setIterable() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setObjectObjects() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setObjectIterable() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        headers.set(HEADER_NAME, HeaderValue.THREE.asList());\n        assertDefaultValues(headers, HeaderValue.THREE);\n    }\n\n    @Test\n    public void setCharSequenceValidatesValue() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        assertThrows(IllegalArgumentException.class, new Executable() {\n            @Override\n            public void execute() throws Throwable {\n                headers.set(HEADER_NAME, ILLEGAL_VALUE);\n            }\n        });\n    }\n\n    @Test\n    public void setIterableValidatesValue() {\n        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();\n        assertThrows(IllegalArgumentException.class, new Executable() {\n            @Override\n            public void execute() throws Throwable {\n                headers.set(HEADER_NAME, Collections.singleton(ILLEGAL_VALUE));\n            }\n        });\n    }\n\n    @Test\n    public void toStringOnEmptyHeaders() {\n        assertEquals(\"DefaultHttpHeaders[]\", newDefaultDefaultHttpHeaders().toString());\n    }\n\n    @Test\n    public void toStringOnSingleHeader() {\n        assertEquals(\"DefaultHttpHeaders[foo: bar]\", newDefaultDefaultHttpHeaders()\n                .add(\"foo\", \"bar\")\n                .toString());\n    }\n\n    @Test\n    public void toStringOnMultipleHeaders() {\n        assertEquals(\"DefaultHttpHeaders[foo: bar, baz: qix]\", newDefaultDefaultHttpHeaders()\n                .add(\"foo\", \"bar\")\n                .add(\"baz\", \"qix\")\n                .toString());\n    }\n\n    @Test\n    public void providesHeaderNamesAsArray() throws Exception {\n        Set<String> nettyHeaders = new DefaultHttpHeaders()\n                .add(HttpHeaderNames.CONTENT_LENGTH, 10)\n                .names();\n\n        String[] namesArray = nettyHeaders.toArray(EmptyArrays.EMPTY_STRINGS);\n        assertArrayEquals(namesArray, new String[] { HttpHeaderNames.CONTENT_LENGTH.toString() });\n    }\n\n    private static void assertDefaultValues(final DefaultHttpHeaders headers, final HeaderValue headerValue) {\n        assertTrue(contentEquals(headerValue.asList().get(0), headers.get(HEADER_NAME)));\n        List<CharSequence> expected = headerValue.asList();\n        List<String> actual = headers.getAll(HEADER_NAME);\n        assertEquals(expected.size(), actual.size());\n        Iterator<CharSequence> eItr = expected.iterator();\n        Iterator<String> aItr = actual.iterator();\n        while (eItr.hasNext()) {\n            assertTrue(contentEquals(eItr.next(), aItr.next()));\n        }\n    }\n\n    private static DefaultHttpHeaders newDefaultDefaultHttpHeaders() {\n        return new DefaultHttpHeaders(true);\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec;\n\nimport io.netty.util.HashingStrategy;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport static io.netty.util.HashingStrategy.JAVA_HASHER;\nimport static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n/**\n * Default implementation of {@link Headers};\n *\n * @param <K> the type of the header name.\n * @param <V> the type of the header value.\n * @param <T> the type to use for return values when the intention is to return {@code this} object.\n */\npublic class DefaultHeaders<K, V, T extends Headers<K, V, T>> implements Headers<K, V, T> {\n    /**\n     * Constant used to seed the hash code generation. Could be anything but this was borrowed from murmur3.\n     */\n    static final int HASH_CODE_SEED = 0xc2b2ae35;\n\n    private final HeaderEntry<K, V>[] entries;\n    protected final HeaderEntry<K, V> head;\n\n    private final byte hashMask;\n    private final ValueConverter<V> valueConverter;\n    private final NameValidator<K> nameValidator;\n    private final ValueValidator<V> valueValidator;\n    private final HashingStrategy<K> hashingStrategy;\n    int size;\n\n    public interface NameValidator<K> {\n        /**\n         * Verify that {@code name} is valid.\n         * @param name The name to validate.\n         * @throws RuntimeException if {@code name} is not valid.\n         */\n        void validateName(K name);\n\n        @SuppressWarnings(\"rawtypes\")\n        NameValidator NOT_NULL = new NameValidator() {\n            @Override\n            public void validateName(Object name) {\n                checkNotNull(name, \"name\");\n            }\n        };\n    }\n\n    public interface ValueValidator<V> {\n        /**\n         * Validate the given value. If the validation fails, then an implementation specific runtime exception may be\n         * thrown.\n         *\n         * @param value The value to validate.\n         */\n        void validate(V value);\n\n        ValueValidator<?> NO_VALIDATION = new ValueValidator<Object>() {\n            @Override\n            public void validate(Object value) {\n            }\n        };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(ValueConverter<V> valueConverter) {\n        this(JAVA_HASHER, valueConverter);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(ValueConverter<V> valueConverter, NameValidator<K> nameValidator) {\n        this(JAVA_HASHER, valueConverter, nameValidator);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter) {\n        this(nameHashingStrategy, valueConverter, NameValidator.NOT_NULL);\n    }\n\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy,\n            ValueConverter<V> valueConverter, NameValidator<K> nameValidator) {\n        this(nameHashingStrategy, valueConverter, nameValidator, 16);\n    }\n\n    /**\n     * Create a new instance.\n     * @param nameHashingStrategy Used to hash and equality compare names.\n     * @param valueConverter Used to convert values to/from native types.\n     * @param nameValidator Used to validate name elements.\n     * @param arraySizeHint A hint as to how large the hash data structure should be.\n     * The next positive power of two will be used. An upper bound may be enforced.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy,\n                          ValueConverter<V> valueConverter, NameValidator<K> nameValidator, int arraySizeHint) {\n        this(nameHashingStrategy, valueConverter, nameValidator, arraySizeHint,\n                (ValueValidator<V>) ValueValidator.NO_VALIDATION);\n    }\n\n    /**\n     * Create a new instance.\n     * @param nameHashingStrategy Used to hash and equality compare names.\n     * @param valueConverter Used to convert values to/from native types.\n     * @param nameValidator Used to validate name elements.\n     * @param arraySizeHint A hint as to how large the hash data structure should be.\n     * The next positive power of two will be used. An upper bound may be enforced.\n     * @param valueValidator The validation strategy for entry values.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter,\n                          NameValidator<K> nameValidator, int arraySizeHint, ValueValidator<V> valueValidator) {\n        this.valueConverter = checkNotNull(valueConverter, \"valueConverter\");\n        this.nameValidator = checkNotNull(nameValidator, \"nameValidator\");\n        hashingStrategy = checkNotNull(nameHashingStrategy, \"nameHashingStrategy\");\n        this.valueValidator = checkNotNull(valueValidator, \"valueValidator\");\n        // Enforce a bound of [2, 128] because hashMask is a byte. The max possible value of hashMask is one less\n        // than the length of this array, and we want the mask to be > 0.\n        entries = new HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];\n        hashMask = (byte) (entries.length - 1);\n        head = new HeaderEntry<K, V>();\n    }\n\n    @Override\n    public V get(K name) {\n        checkNotNull(name, \"name\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        HeaderEntry<K, V> e = entries[i];\n        V value = null;\n        // loop until the first header was found\n        while (e != null) {\n            if (e.hash == h && hashingStrategy.equals(name, e.key)) {\n                value = e.value;\n            }\n\n            e = e.next;\n        }\n        return value;\n    }\n\n    @Override\n    public V get(K name, V defaultValue) {\n        V value = get(name);\n        if (value == null) {\n            return defaultValue;\n        }\n        return value;\n    }\n\n    @Override\n    public V getAndRemove(K name) {\n        int h = hashingStrategy.hashCode(name);\n        return remove0(h, index(h), checkNotNull(name, \"name\"));\n    }\n\n    @Override\n    public V getAndRemove(K name, V defaultValue) {\n        V value = getAndRemove(name);\n        if (value == null) {\n            return defaultValue;\n        }\n        return value;\n    }\n\n    @Override\n    public List<V> getAll(K name) {\n        checkNotNull(name, \"name\");\n\n        LinkedList<V> values = new LinkedList<V>();\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        HeaderEntry<K, V> e = entries[i];\n        while (e != null) {\n            if (e.hash == h && hashingStrategy.equals(name, e.key)) {\n                values.addFirst(e.getValue());\n            }\n            e = e.next;\n        }\n        return values;\n    }\n\n    /**\n     * Equivalent to {@link #getAll(Object)} but no intermediate list is generated.\n     * @param name the name of the header to retrieve\n     * @return an {@link Iterator} of header values corresponding to {@code name}.\n     */\n    public Iterator<V> valueIterator(K name) {\n        return new ValueIterator(name);\n    }\n\n    @Override\n    public List<V> getAllAndRemove(K name) {\n        List<V> all = getAll(name);\n        remove(name);\n        return all;\n    }\n\n    @Override\n    public boolean contains(K name) {\n        return get(name) != null;\n    }\n\n    @Override\n    public boolean containsObject(K name, Object value) {\n        return contains(name, fromObject(name, value));\n    }\n\n    @Override\n    public boolean containsBoolean(K name, boolean value) {\n        return contains(name, fromBoolean(name, value));\n    }\n\n    @Override\n    public boolean containsByte(K name, byte value) {\n        return contains(name, fromByte(name, value));\n    }\n\n    @Override\n    public boolean containsChar(K name, char value) {\n        return contains(name, fromChar(name, value));\n    }\n\n    @Override\n    public boolean containsShort(K name, short value) {\n        return contains(name, fromShort(name, value));\n    }\n\n    @Override\n    public boolean containsInt(K name, int value) {\n        return contains(name, fromInt(name, value));\n    }\n\n    @Override\n    public boolean containsLong(K name, long value) {\n        return contains(name, fromLong(name, value));\n    }\n\n    @Override\n    public boolean containsFloat(K name, float value) {\n        return contains(name, fromFloat(name, value));\n    }\n\n    @Override\n    public boolean containsDouble(K name, double value) {\n        return contains(name, fromDouble(name, value));\n    }\n\n    @Override\n    public boolean containsTimeMillis(K name, long value) {\n        return contains(name, fromTimeMillis(name, value));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean contains(K name, V value) {\n        return contains(name, value, JAVA_HASHER);\n    }\n\n    public final boolean contains(K name, V value, HashingStrategy<? super V> valueHashingStrategy) {\n        checkNotNull(name, \"name\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        HeaderEntry<K, V> e = entries[i];\n        while (e != null) {\n            if (e.hash == h && hashingStrategy.equals(name, e.key) && valueHashingStrategy.equals(value, e.value)) {\n                return true;\n            }\n            e = e.next;\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return head == head.after;\n    }\n\n    @Override\n    public Set<K> names() {\n        if (isEmpty()) {\n            return Collections.emptySet();\n        }\n        Set<K> names = new LinkedHashSet<K>(size());\n        HeaderEntry<K, V> e = head.after;\n        while (e != head) {\n            names.add(e.getKey());\n            e = e.after;\n        }\n        return names;\n    }\n\n    @Override\n    public T add(K name, V value) {\n        validateName(nameValidator, true, name);\n        validateValue(valueValidator, name, value);\n        checkNotNull(value, \"value\");\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        add0(h, i, name, value);\n        return thisT();\n    }\n\n    @Override\n    public T add(K name, Iterable<? extends V> values) {\n        validateName(nameValidator, true, name);\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        for (V v: values) {\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T add(K name, V... values) {\n        validateName(nameValidator, true, name);\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        for (V v: values) {\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T addObject(K name, Object value) {\n        return add(name, fromObject(name, value));\n    }\n\n    @Override\n    public T addObject(K name, Iterable<?> values) {\n        for (Object value : values) {\n            addObject(name, value);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T addObject(K name, Object... values) {\n        for (Object value: values) {\n            addObject(name, value);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T addInt(K name, int value) {\n        return add(name, fromInt(name, value));\n    }\n\n    @Override\n    public T addLong(K name, long value) {\n        return add(name, fromLong(name, value));\n    }\n\n    @Override\n    public T addDouble(K name, double value) {\n        return add(name, fromDouble(name, value));\n    }\n\n    @Override\n    public T addTimeMillis(K name, long value) {\n        return add(name, fromTimeMillis(name, value));\n    }\n\n    @Override\n    public T addChar(K name, char value) {\n        return add(name, fromChar(name, value));\n    }\n\n    @Override\n    public T addBoolean(K name, boolean value) {\n        return add(name, fromBoolean(name, value));\n    }\n\n    @Override\n    public T addFloat(K name, float value) {\n        return add(name, fromFloat(name, value));\n    }\n\n    @Override\n    public T addByte(K name, byte value) {\n        return add(name, fromByte(name, value));\n    }\n\n    @Override\n    public T addShort(K name, short value) {\n        return add(name, fromShort(name, value));\n    }\n\n    @Override\n    public T add(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers == this) {\n            throw new IllegalArgumentException(\"can't add to itself.\");\n        }\n        addImpl(headers);\n        return thisT();\n    }\n\n    protected void addImpl(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers instanceof DefaultHeaders) {\n            @SuppressWarnings(\"unchecked\")\n            final DefaultHeaders<? extends K, ? extends V, T> defaultHeaders =\n                    (DefaultHeaders<? extends K, ? extends V, T>) headers;\n            HeaderEntry<? extends K, ? extends V> e = defaultHeaders.head.after;\n            if (defaultHeaders.hashingStrategy == hashingStrategy &&\n                    defaultHeaders.nameValidator == nameValidator) {\n                // Fastest copy\n                while (e != defaultHeaders.head) {\n                    add0(e.hash, index(e.hash), e.key, e.value);\n                    e = e.after;\n                }\n            } else {\n                // Fast copy\n                while (e != defaultHeaders.head) {\n                    add(e.key, e.value);\n                    e = e.after;\n                }\n            }\n        } else {\n            // Slow copy\n            for (Entry<? extends K, ? extends V> header : headers) {\n                add(header.getKey(), header.getValue());\n            }\n        }\n    }\n\n    @Override\n    public T set(K name, V value) {\n        validateName(nameValidator, false, name);\n        validateValue(valueValidator, name, value);\n        checkNotNull(value, \"value\");\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n        remove0(h, i, name);\n        add0(h, i, name, value);\n        return thisT();\n    }\n\n    @Override\n    public T set(K name, Iterable<? extends V> values) {\n        validateName(nameValidator, false, name);\n        checkNotNull(values, \"values\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (V v: values) {\n            if (v == null) {\n                break;\n            }\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T set(K name, V... values) {\n        validateName(nameValidator, false, name);\n        checkNotNull(values, \"values\");\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (V v: values) {\n            if (v == null) {\n                break;\n            }\n            validateValue(valueValidator, name, v);\n            add0(h, i, name, v);\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T setObject(K name, Object value) {\n        V convertedValue = checkNotNull(fromObject(name, value), \"convertedValue\");\n        return set(name, convertedValue);\n    }\n\n    @Override\n    public T setObject(K name, Iterable<?> values) {\n        validateName(nameValidator, false, name);\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (Object v: values) {\n            if (v == null) {\n                break;\n            }\n            V converted = fromObject(name, v);\n            validateValue(valueValidator, name, converted);\n            add0(h, i, name, converted);\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T setObject(K name, Object... values) {\n        validateName(nameValidator, false, name);\n\n        int h = hashingStrategy.hashCode(name);\n        int i = index(h);\n\n        remove0(h, i, name);\n        for (Object v: values) {\n            if (v == null) {\n                break;\n            }\n            V converted = fromObject(name, v);\n            validateValue(valueValidator, name, converted);\n            add0(h, i, name, converted);\n        }\n\n        return thisT();\n    }\n\n    @Override\n    public T setInt(K name, int value) {\n        return set(name, fromInt(name, value));\n    }\n\n    @Override\n    public T setLong(K name, long value) {\n        return set(name, fromLong(name, value));\n    }\n\n    @Override\n    public T setDouble(K name, double value) {\n        return set(name, fromDouble(name, value));\n    }\n\n    @Override\n    public T setTimeMillis(K name, long value) {\n        return set(name, fromTimeMillis(name, value));\n    }\n\n    @Override\n    public T setFloat(K name, float value) {\n        return set(name, fromFloat(name, value));\n    }\n\n    @Override\n    public T setChar(K name, char value) {\n        return set(name, fromChar(name, value));\n    }\n\n    @Override\n    public T setBoolean(K name, boolean value) {\n        return set(name, fromBoolean(name, value));\n    }\n\n    @Override\n    public T setByte(K name, byte value) {\n        return set(name, fromByte(name, value));\n    }\n\n    @Override\n    public T setShort(K name, short value) {\n        return set(name, fromShort(name, value));\n    }\n\n    @Override\n    public T set(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers != this) {\n            clear();\n            addImpl(headers);\n        }\n        return thisT();\n    }\n\n    @Override\n    public T setAll(Headers<? extends K, ? extends V, ?> headers) {\n        if (headers != this) {\n            for (K key : headers.names()) {\n                remove(key);\n            }\n            addImpl(headers);\n        }\n        return thisT();\n    }\n\n    @Override\n    public boolean remove(K name) {\n        return getAndRemove(name) != null;\n    }\n\n    @Override\n    public T clear() {\n        Arrays.fill(entries, null);\n        head.before = head.after = head;\n        size = 0;\n        return thisT();\n    }\n\n    @Override\n    public Iterator<Entry<K, V>> iterator() {\n        return new HeaderIterator();\n    }\n\n    @Override\n    public Boolean getBoolean(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toBoolean(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public boolean getBoolean(K name, boolean defaultValue) {\n        Boolean v = getBoolean(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Byte getByte(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toByte(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public byte getByte(K name, byte defaultValue) {\n        Byte v = getByte(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Character getChar(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toChar(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public char getChar(K name, char defaultValue) {\n        Character v = getChar(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Short getShort(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toShort(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public short getShort(K name, short defaultValue) {\n        Short v = getShort(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Integer getInt(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toInt(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public int getInt(K name, int defaultValue) {\n        Integer v = getInt(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getLong(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toLong(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getLong(K name, long defaultValue) {\n        Long v = getLong(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Float getFloat(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toFloat(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public float getFloat(K name, float defaultValue) {\n        Float v = getFloat(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Double getDouble(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toDouble(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public double getDouble(K name, double defaultValue) {\n        Double v = getDouble(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getTimeMillis(K name) {\n        V v = get(name);\n        try {\n            return v != null ? toTimeMillis(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getTimeMillis(K name, long defaultValue) {\n        Long v = getTimeMillis(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Boolean getBooleanAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toBoolean(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public boolean getBooleanAndRemove(K name, boolean defaultValue) {\n        Boolean v = getBooleanAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Byte getByteAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toByte(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public byte getByteAndRemove(K name, byte defaultValue) {\n        Byte v = getByteAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Character getCharAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toChar(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public char getCharAndRemove(K name, char defaultValue) {\n        Character v = getCharAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Short getShortAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toShort(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public short getShortAndRemove(K name, short defaultValue) {\n        Short v = getShortAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Integer getIntAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toInt(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public int getIntAndRemove(K name, int defaultValue) {\n        Integer v = getIntAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getLongAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toLong(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getLongAndRemove(K name, long defaultValue) {\n        Long v = getLongAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Float getFloatAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toFloat(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public float getFloatAndRemove(K name, float defaultValue) {\n        Float v = getFloatAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Double getDoubleAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toDouble(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public double getDoubleAndRemove(K name, double defaultValue) {\n        Double v = getDoubleAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @Override\n    public Long getTimeMillisAndRemove(K name) {\n        V v = getAndRemove(name);\n        try {\n            return v != null ? toTimeMillis(name, v) : null;\n        } catch (RuntimeException ignore) {\n            return null;\n        }\n    }\n\n    @Override\n    public long getTimeMillisAndRemove(K name, long defaultValue) {\n        Long v = getTimeMillisAndRemove(name);\n        return v != null ? v : defaultValue;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof Headers)) {\n            return false;\n        }\n\n        return equals((Headers<K, V, ?>) o, JAVA_HASHER);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public int hashCode() {\n        return hashCode(JAVA_HASHER);\n    }\n\n    /**\n     * Test this object for equality against {@code h2}.\n     * @param h2 The object to check equality for.\n     * @param valueHashingStrategy Defines how values will be compared for equality.\n     * @return {@code true} if this object equals {@code h2} given {@code valueHashingStrategy}.\n     * {@code false} otherwise.\n     */\n    public final boolean equals(Headers<K, V, ?> h2, HashingStrategy<V> valueHashingStrategy) {\n        if (h2.size() != size()) {\n            return false;\n        }\n\n        if (this == h2) {\n            return true;\n        }\n\n        for (K name : names()) {\n            List<V> otherValues = h2.getAll(name);\n            List<V> values = getAll(name);\n            if (otherValues.size() != values.size()) {\n                return false;\n            }\n            for (int i = 0; i < otherValues.size(); i++) {\n                if (!valueHashingStrategy.equals(otherValues.get(i), values.get(i))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Generate a hash code for this object given a {@link HashingStrategy} to generate hash codes for\n     * individual values.\n     * @param valueHashingStrategy Defines how values will be hashed.\n     */\n    public final int hashCode(HashingStrategy<V> valueHashingStrategy) {\n        int result = HASH_CODE_SEED;\n        for (K name : names()) {\n            result = 31 * result + hashingStrategy.hashCode(name);\n            List<V> values = getAll(name);\n            for (int i = 0; i < values.size(); ++i) {\n                result = 31 * result + valueHashingStrategy.hashCode(values.get(i));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return HeadersUtils.toString(getClass(), iterator(), size());\n    }\n\n    /**\n     * Call out to the given {@link NameValidator} to validate the given name.\n     *\n     * @param validator the validator to use\n     * @param forAdd {@code true } if this validation is for adding to the headers, or {@code false} if this is for\n     * setting (overwriting) the given header.\n     * @param name the name to validate.\n     */\n    protected void validateName(NameValidator<K> validator, boolean forAdd, K name) {\n        validator.validateName(name);\n    }\n\n    protected void validateValue(ValueValidator<V> validator, K name, V value) {\n        validator.validate(value);\n    }\n\n    protected HeaderEntry<K, V> newHeaderEntry(int h, K name, V value, HeaderEntry<K, V> next) {\n        return new HeaderEntry<K, V>(h, name, value, next, head);\n    }\n\n    protected ValueConverter<V> valueConverter() {\n        return valueConverter;\n    }\n\n    protected NameValidator<K> nameValidator() {\n        return nameValidator;\n    }\n\n    protected ValueValidator<V> valueValidator() {\n        return valueValidator;\n    }\n\n    private int index(int hash) {\n        return hash & hashMask;\n    }\n\n    private void add0(int h, int i, K name, V value) {\n        // Update the hash table.\n        entries[i] = newHeaderEntry(h, name, value, entries[i]);\n        ++size;\n    }\n\n    /**\n     * @return the first value inserted whose hash code equals {@code h} and whose name is equal to {@code name}.\n     */\n    private V remove0(int h, int i, K name) {\n        HeaderEntry<K, V> e = entries[i];\n        if (e == null) {\n            return null;\n        }\n\n        V value = null;\n        HeaderEntry<K, V> next = e.next;\n        while (next != null) {\n            if (next.hash == h && hashingStrategy.equals(name, next.key)) {\n                value = next.value;\n                e.next = next.next;\n                next.remove();\n                --size;\n            } else {\n                e = next;\n            }\n\n            next = e.next;\n        }\n\n        e = entries[i];\n        if (e.hash == h && hashingStrategy.equals(name, e.key)) {\n            if (value == null) {\n                value = e.value;\n            }\n            entries[i] = e.next;\n            e.remove();\n            --size;\n        }\n\n        return value;\n    }\n\n    HeaderEntry<K, V> remove0(HeaderEntry<K, V> entry, HeaderEntry<K, V> previous) {\n        int i = index(entry.hash);\n        HeaderEntry<K, V> firstEntry = entries[i];\n        if (firstEntry == entry) {\n            entries[i] = entry.next;\n            previous = entries[i];\n        } else if (previous == null) {\n            // If we don't have any existing starting point, then start from the beginning.\n            previous = firstEntry;\n            HeaderEntry<K, V> next = firstEntry.next;\n            while (next != null && next != entry) {\n                previous = next;\n                next = next.next;\n            }\n            assert next != null: \"Entry not found in its hash bucket: \" + entry;\n            previous.next = entry.next;\n        } else {\n            previous.next = entry.next;\n        }\n        entry.remove();\n        --size;\n        return previous;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T thisT() {\n        return (T) this;\n    }\n\n    private V fromObject(K name, Object value) {\n        try {\n            return valueConverter.convertObject(checkNotNull(value, \"value\"));\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert object value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromBoolean(K name, boolean value) {\n        try {\n            return valueConverter.convertBoolean(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert boolean value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromByte(K name, byte value) {\n        try {\n            return valueConverter.convertByte(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert byte value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromChar(K name, char value) {\n        try {\n            return valueConverter.convertChar(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert char value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromShort(K name, short value) {\n        try {\n            return valueConverter.convertShort(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert short value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromInt(K name, int value) {\n        try {\n            return valueConverter.convertInt(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert int value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromLong(K name, long value) {\n        try {\n            return valueConverter.convertLong(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert long value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromFloat(K name, float value) {\n        try {\n            return valueConverter.convertFloat(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert float value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromDouble(K name, double value) {\n        try {\n            return valueConverter.convertDouble(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert double value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private V fromTimeMillis(K name, long value) {\n        try {\n            return valueConverter.convertTimeMillis(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert millsecond value for header '\" + name + '\\'', e);\n        }\n    }\n\n    private boolean toBoolean(K name, V value) {\n        try {\n            return valueConverter.convertToBoolean(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to boolean for header '\" + name + '\\'');\n        }\n    }\n\n    private byte toByte(K name, V value) {\n        try {\n            return valueConverter.convertToByte(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to byte for header '\" + name + '\\'');\n        }\n    }\n\n    private char toChar(K name, V value) {\n        try {\n            return valueConverter.convertToChar(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to char for header '\" + name + '\\'');\n        }\n    }\n\n    private short toShort(K name, V value) {\n        try {\n            return valueConverter.convertToShort(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to short for header '\" + name + '\\'');\n        }\n    }\n\n    private int toInt(K name, V value) {\n        try {\n            return valueConverter.convertToInt(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to int for header '\" + name + '\\'');\n        }\n    }\n\n    private long toLong(K name, V value) {\n        try {\n            return valueConverter.convertToLong(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to long for header '\" + name + '\\'');\n        }\n    }\n\n    private float toFloat(K name, V value) {\n        try {\n            return valueConverter.convertToFloat(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to float for header '\" + name + '\\'');\n        }\n    }\n\n    private double toDouble(K name, V value) {\n        try {\n            return valueConverter.convertToDouble(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\"Failed to convert header value to double for header '\" + name + '\\'');\n        }\n    }\n\n    private long toTimeMillis(K name, V value) {\n        try {\n            return valueConverter.convertToTimeMillis(value);\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\n                    \"Failed to convert header value to millsecond for header '\" + name + '\\'');\n        }\n    }\n\n    /**\n     * Returns a deep copy of this instance.\n     */\n    public DefaultHeaders<K, V, T> copy() {\n        DefaultHeaders<K, V, T> copy = new DefaultHeaders<K, V, T>(\n                hashingStrategy, valueConverter, nameValidator, entries.length);\n        copy.addImpl(this);\n        return copy;\n    }\n\n    private final class HeaderIterator implements Iterator<Entry<K, V>> {\n        private HeaderEntry<K, V> current = head;\n\n        @Override\n        public boolean hasNext() {\n            return current.after != head;\n        }\n\n        @Override\n        public Entry<K, V> next() {\n            current = current.after;\n\n            if (current == head) {\n                throw new NoSuchElementException();\n            }\n\n            return current;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"read only\");\n        }\n    }\n\n    private final class ValueIterator implements Iterator<V> {\n        private final K name;\n        private final int hash;\n        private HeaderEntry<K, V> removalPrevious;\n        private HeaderEntry<K, V> previous;\n        private HeaderEntry<K, V> next;\n\n        ValueIterator(K name) {\n            this.name = checkNotNull(name, \"name\");\n            hash = hashingStrategy.hashCode(name);\n            calculateNext(entries[index(hash)]);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        @Override\n        public V next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (previous != null) {\n                removalPrevious = previous;\n            }\n            previous = next;\n            calculateNext(next.next);\n            return previous.value;\n        }\n\n        @Override\n        public void remove() {\n            if (previous == null) {\n                throw new IllegalStateException();\n            }\n            removalPrevious = remove0(previous, removalPrevious);\n            previous = null;\n        }\n\n        private void calculateNext(HeaderEntry<K, V> entry) {\n            while (entry != null) {\n                if (entry.hash == hash && hashingStrategy.equals(name, entry.key)) {\n                    next = entry;\n                    return;\n                }\n                entry = entry.next;\n            }\n            next = null;\n        }\n    }\n\n    protected static class HeaderEntry<K, V> implements Entry<K, V> {\n        protected final int hash;\n        protected final K key;\n        protected V value;\n        /**\n         * In bucket linked list\n         */\n        protected HeaderEntry<K, V> next;\n        /**\n         * Overall insertion order linked list\n         */\n        protected HeaderEntry<K, V> before, after;\n\n        protected HeaderEntry(int hash, K key) {\n            this.hash = hash;\n            this.key = key;\n        }\n\n        HeaderEntry(int hash, K key, V value, HeaderEntry<K, V> next, HeaderEntry<K, V> head) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n\n            after = head;\n            before = head.before;\n            pointNeighborsToThis();\n        }\n\n        HeaderEntry() {\n            hash = -1;\n            key = null;\n            before = after = this;\n        }\n\n        protected final void pointNeighborsToThis() {\n            before.after = this;\n            after.before = this;\n        }\n\n        public final HeaderEntry<K, V> before() {\n            return before;\n        }\n\n        public final HeaderEntry<K, V> after() {\n            return after;\n        }\n\n        protected void remove() {\n            before.after = after;\n            after.before = before;\n        }\n\n        @Override\n        public final K getKey() {\n            return key;\n        }\n\n        @Override\n        public final V getValue() {\n            return value;\n        }\n\n        @Override\n        public final V setValue(V value) {\n            checkNotNull(value, \"value\");\n            V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        @Override\n        public final String toString() {\n            return key.toString() + '=' + value.toString();\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n            Entry<?, ?> other = (Entry<?, ?>) o;\n            return (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey()))  &&\n                   (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n        }\n\n        @Override\n        public int hashCode() {\n            return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());\n        }\n    }\n}\n"], "filenames": ["codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java", "codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java"], "buggy_code_start_loc": [25, 535], "buggy_code_end_loc": [234, 554], "fixing_code_start_loc": [25, 535], "fixing_code_end_loc": [258, 558], "type": "CWE-113", "message": "Netty project is an event-driven asynchronous network application framework. Starting in version 4.1.83.Final and prior to 4.1.86.Final, when calling `DefaultHttpHeadesr.set` with an _iterator_ of values, header value validation was not performed, allowing malicious header values in the iterator to perform HTTP Response Splitting. This issue has been patched in version 4.1.86.Final. Integrators can work around the issue by changing the `DefaultHttpHeaders.set(CharSequence, Iterator<?>)` call, into a `remove()` call, and call `add()` in a loop over the iterator of values.", "other": {"cve": {"id": "CVE-2022-41915", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-13T07:15:13.557", "lastModified": "2023-03-01T15:09:57.060", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netty project is an event-driven asynchronous network application framework. Starting in version 4.1.83.Final and prior to 4.1.86.Final, when calling `DefaultHttpHeadesr.set` with an _iterator_ of values, header value validation was not performed, allowing malicious header values in the iterator to perform HTTP Response Splitting. This issue has been patched in version 4.1.86.Final. Integrators can work around the issue by changing the `DefaultHttpHeaders.set(CharSequence, Iterator<?>)` call, into a `remove()` call, and call `add()` in a loop over the iterator of values."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-113"}, {"lang": "en", "value": "CWE-436"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netty:netty:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.83", "versionEndExcluding": "4.1.86", "matchCriteriaId": "B032F19E-5D82-4C06-8D4B-AE3810E893B7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/netty/netty/commit/fe18adff1c2b333acb135ab779a3b9ba3295a1c4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/issues/13084", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/pull/12760", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-hh82-3pmq-7frp", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/01/msg00008.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230113-0004/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5316", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netty/netty/commit/fe18adff1c2b333acb135ab779a3b9ba3295a1c4"}}