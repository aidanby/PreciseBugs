{"buggy_code": ["/** \\ingroup header\n * \\file lib/package.c\n */\n\n#include \"system.h\"\n\n#include <netinet/in.h>\n#include <pthread.h>\n\n#include <rpm/rpmlib.h>\t\t\t/* XXX RPMSIGTAG, other sig stuff */\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n#include <rpm/rpmstring.h>\n#include <rpm/rpmkeyring.h>\n\n#include \"lib/rpmlead.h\"\n#include \"rpmio/rpmio_internal.h\"\t/* fd digest bits */\n#include \"lib/header_internal.h\"\t/* XXX headerCheck */\n#include \"lib/rpmvs.h\"\n\n#include \"debug.h\"\n\ntypedef struct pkgdata_s *pkgdatap;\n\ntypedef void (*hdrvsmsg)(struct rpmsinfo_s *sinfo, pkgdatap pkgdata, const char *msg);\n\nstruct pkgdata_s {\n    hdrvsmsg msgfunc;\n    const char *fn;\n    char *msg;\n    rpmRC rc;\n};\n\n/** \\ingroup header\n * Translate and merge legacy signature tags into header.\n * @param h\t\theader (dest)\n * @param sigh\t\tsignature header (src)\n */\nstatic\nvoid headerMergeLegacySigs(Header h, Header sigh)\n{\n    HeaderIterator hi;\n    struct rpmtd_s td;\n\n    hi = headerInitIterator(sigh);\n    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n    {\n\tswitch (td.tag) {\n\t/* XXX Translate legacy signature tag values. */\n\tcase RPMSIGTAG_SIZE:\n\t    td.tag = RPMTAG_SIGSIZE;\n\t    break;\n\tcase RPMSIGTAG_PGP:\n\t    td.tag = RPMTAG_SIGPGP;\n\t    break;\n\tcase RPMSIGTAG_MD5:\n\t    td.tag = RPMTAG_SIGMD5;\n\t    break;\n\tcase RPMSIGTAG_GPG:\n\t    td.tag = RPMTAG_SIGGPG;\n\t    break;\n\tcase RPMSIGTAG_PGP5:\n\t    td.tag = RPMTAG_SIGPGP5;\n\t    break;\n\tcase RPMSIGTAG_PAYLOADSIZE:\n\t    td.tag = RPMTAG_ARCHIVESIZE;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURES:\n\t    td.tag = RPMTAG_FILESIGNATURES;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n\t    break;\n\tcase RPMSIGTAG_VERITYSIGNATURES:\n\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n\tcase RPMSIGTAG_SHA1:\n\tcase RPMSIGTAG_SHA256:\n\tcase RPMSIGTAG_DSA:\n\tcase RPMSIGTAG_RSA:\n\tdefault:\n\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(h, td.tag)) {\n\t    switch (td.type) {\n\t    case RPM_NULL_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    case RPM_CHAR_TYPE:\n\t    case RPM_INT8_TYPE:\n\t    case RPM_INT16_TYPE:\n\t    case RPM_INT32_TYPE:\n\t    case RPM_INT64_TYPE:\n\t\tif (td.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_STRING_TYPE:\n\t    case RPM_STRING_ARRAY_TYPE:\n\t    case RPM_BIN_TYPE:\n\t\tif (td.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_I18NSTRING_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n\t}\n    }\n    headerFreeIterator(hi);\n}\n\n/**\n * Remember current key id.\n * XXX: This s*** needs to die. Hook it into keyring or sumthin...\n * @param keyid\t\tsignature keyid\n * @return\t\t0 if new keyid, otherwise 1\n */\nstatic int stashKeyid(unsigned int keyid)\n{\n    static pthread_mutex_t keyid_lock = PTHREAD_MUTEX_INITIALIZER;\n    static const unsigned int nkeyids_max = 256;\n    static unsigned int nkeyids = 0;\n    static unsigned int nextkeyid  = 0;\n    static unsigned int * keyids;\n\n    int i;\n    int seen = 0;\n\n    if (keyid == 0)\n\treturn 0;\n\n    /* Just pretend we didn't see the keyid if we fail to lock */\n    if (pthread_mutex_lock(&keyid_lock))\n\treturn 0;\n\n    if (keyids != NULL)\n    for (i = 0; i < nkeyids; i++) {\n\tif (keyid == keyids[i]) {\n\t    seen = 1;\n\t    goto exit;\n        }\n    }\n\n    if (nkeyids < nkeyids_max) {\n\tnkeyids++;\n\tkeyids = xrealloc(keyids, nkeyids * sizeof(*keyids));\n    }\n    if (keyids)\t\t/* XXX can't happen */\n\tkeyids[nextkeyid] = keyid;\n    nextkeyid++;\n    nextkeyid %= nkeyids_max;\n\nexit:\n    pthread_mutex_unlock(&keyid_lock);\n    return seen;\n}\n\nstatic int handleHdrVS(struct rpmsinfo_s *sinfo, void *cbdata)\n{\n    struct pkgdata_s *pkgdata = cbdata;\n\n    if (pkgdata->msgfunc) {\n\tchar *vsmsg = rpmsinfoMsg(sinfo);\n\tpkgdata->msgfunc(sinfo, pkgdata, vsmsg);\n\tfree(vsmsg);\n    }\n\n    /* Remember actual return code, but don't override a previous failure */\n    if (sinfo->rc && pkgdata->rc != RPMRC_FAIL)\n\tpkgdata->rc = sinfo->rc;\n\n    /* Preserve traditional behavior for now: only failure prevents read */\n    if (sinfo->rc != RPMRC_FAIL)\n\tsinfo->rc = RPMRC_OK;\n\n    return 1;\n}\n\n\nstatic void appendhdrmsg(struct rpmsinfo_s *sinfo, struct pkgdata_s *pkgdata,\n\t\t\tconst char *msg)\n{\n    pkgdata->msg = rstrscat(&pkgdata->msg, \"\\n\", msg, NULL);\n}\n\nstatic void updateHdrDigests(rpmDigestBundle bundle, struct hdrblob_s *blob)\n{\n    int32_t ildl[2] = { htonl(blob->ril), htonl(blob->rdl) };\n\n    rpmDigestBundleUpdate(bundle, rpm_header_magic, sizeof(rpm_header_magic));\n    rpmDigestBundleUpdate(bundle, ildl, sizeof(ildl));\n    rpmDigestBundleUpdate(bundle, blob->pe, (blob->ril * sizeof(*blob->pe)));\n    rpmDigestBundleUpdate(bundle, blob->dataStart, blob->rdl);\n}\n\nrpmRC headerCheck(rpmts ts, const void * uh, size_t uc, char ** msg)\n{\n    rpmRC rc = RPMRC_FAIL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct hdrblob_s blob;\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = appendhdrmsg,\n\t.fn = NULL,\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    if (hdrblobInit(uh, uc, 0, 0, &blob, msg) == RPMRC_OK) {\n\tstruct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n\trpmDigestBundle bundle = rpmDigestBundleNew();\n\n\trpmswEnter(rpmtsOp(ts, RPMTS_OP_DIGEST), 0);\n\n\trpmvsInit(vs, &blob, bundle);\n\trpmvsInitRange(vs, RPMSIG_HEADER);\n\tupdateHdrDigests(bundle, &blob);\n\trpmvsFiniRange(vs, RPMSIG_HEADER);\n\n\trpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata);\n\n\trpmswExit(rpmtsOp(ts, RPMTS_OP_DIGEST), uc);\n\n\trc = pkgdata.rc;\n\n\tif (rc == RPMRC_OK && pkgdata.msg == NULL)\n\t    pkgdata.msg = xstrdup(\"Header sanity check: OK\");\n\n\tif (msg)\n\t    *msg = pkgdata.msg;\n\telse\n\t    free(pkgdata.msg);\n\n\trpmDigestBundleFree(bundle);\n\trpmvsFree(vs);\n    }\n\n    rpmKeyringFree(keyring);\n\n    return rc;\n}\n\nrpmRC rpmReadHeader(rpmts ts, FD_t fd, Header *hdrp, char ** msg)\n{\n    char *buf = NULL;\n    struct hdrblob_s blob;\n    Header h = NULL;\n    rpmRC rc = RPMRC_FAIL;\t\t/* assume failure */\n\n    if (hdrp)\n\t*hdrp = NULL;\n    if (msg)\n\t*msg = NULL;\n\n    if (hdrblobRead(fd, 1, 1, RPMTAG_HEADERIMMUTABLE, &blob, &buf) != RPMRC_OK)\n\tgoto exit;\n\n    /* OK, blob looks sane, load the header. */\n    rc = hdrblobImport(&blob, 0, &h, &buf);\n    \nexit:\n    if (hdrp && h && rc == RPMRC_OK)\n\t*hdrp = headerLink(h);\n    headerFree(h);\n\n    if (msg != NULL && *msg == NULL && buf != NULL) {\n\t*msg = buf;\n    } else {\n\tfree(buf);\n    }\n\n    return rc;\n}\n\nstatic\nvoid applyRetrofits(Header h)\n{\n    int v3 = 0;\n    /*\n     * Make sure that either RPMTAG_SOURCERPM or RPMTAG_SOURCEPACKAGE\n     * is set. Use a simple heuristic to find the type if both are unset.\n     */\n    if (!headerIsEntry(h, RPMTAG_SOURCERPM) && !headerIsEntry(h, RPMTAG_SOURCEPACKAGE)) {\n\t/* the heuristic needs the compressed file list */\n\tif (headerIsEntry(h, RPMTAG_OLDFILENAMES))\n\t    headerConvert(h, HEADERCONV_COMPRESSFILELIST);\n\tif (headerIsSourceHeuristic(h)) {\n\t    /* Retrofit RPMTAG_SOURCEPACKAGE to srpms for compatibility */\n\t    uint32_t one = 1;\n\t    headerPutUint32(h, RPMTAG_SOURCEPACKAGE, &one, 1);\n\t} else {\n\t    /*\n\t     * Make sure binary rpms have RPMTAG_SOURCERPM set as that's\n\t     * what we use for differentiating binary vs source elsewhere.\n\t     */\n\t    headerPutString(h, RPMTAG_SOURCERPM, \"(none)\");\n\t}\n    }\n\n    /*\n     * Convert legacy headers on the fly. Not having immutable region\n     * equals a truly ancient package, do full retrofit. OTOH newer\n     * packages might have been built with --nodirtokens, test and handle\n     * the non-compressed filelist case separately.\n     */\n    if (!headerIsEntry(h, RPMTAG_HEADERIMMUTABLE)) {\n\tv3 = 1;\n\theaderConvert(h, HEADERCONV_RETROFIT_V3);\n    } else if (headerIsEntry(h, RPMTAG_OLDFILENAMES)) {\n\theaderConvert(h, HEADERCONV_COMPRESSFILELIST);\n\tv3 = 1;\n    }\n    if (v3) {\n\tchar *s = headerGetAsString(h, RPMTAG_NEVRA);\n\trpmlog(RPMLOG_WARNING, _(\"RPM v3 packages are deprecated: %s\\n\"), s);\n\tfree(s);\n    }\n}\n\nstatic void loghdrmsg(struct rpmsinfo_s *sinfo, struct pkgdata_s *pkgdata,\n\t\t\tconst char *msg)\n{\n    int lvl = RPMLOG_DEBUG;\n    switch (sinfo->rc) {\n    case RPMRC_OK:\t\t/* Signature is OK. */\n\tbreak;\n    case RPMRC_NOTTRUSTED:\t/* Signature is OK, but key is not trusted. */\n    case RPMRC_NOKEY:\t\t/* Public key is unavailable. */\n\t/* XXX Print NOKEY/NOTTRUSTED warning only once. */\n\tif (stashKeyid(sinfo->keyid) == 0)\n\t    lvl = RPMLOG_WARNING;\n\tbreak;\n    case RPMRC_NOTFOUND:\t/* Signature/digest not present. */\n\tlvl = RPMLOG_WARNING;\n\tbreak;\n    default:\n    case RPMRC_FAIL:\t\t/* Signature does not verify. */\n\tlvl = RPMLOG_ERR;\n\tbreak;\n    }\n\n    rpmlog(lvl, \"%s: %s\\n\", pkgdata->fn, msg);\n}\n\nrpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    /* XXX: lots of 3rd party software relies on the behavior */\n    if (hdrp)\n\t*hdrp = NULL;\n\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n\n    /* Actually all verify discovered signatures and digests */\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\t/* Finally import the headers and do whatever required retrofits etc */\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\n\t    /* Append (and remap) signature tags to the metadata. */\n\t    headerMergeLegacySigs(h, sigh);\n\t    applyRetrofits(h);\n\n\t    /* Bump reference count for return. */\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n\n    /* If there was a \"substatus\" (NOKEY in practise), return that instead */\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\n\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n\n    return rc;\n}\n\n\n\n"], "fixing_code": ["/** \\ingroup header\n * \\file lib/package.c\n */\n\n#include \"system.h\"\n\n#include <netinet/in.h>\n#include <pthread.h>\n\n#include <rpm/rpmlib.h>\t\t\t/* XXX RPMSIGTAG, other sig stuff */\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n#include <rpm/rpmstring.h>\n#include <rpm/rpmkeyring.h>\n\n#include \"lib/rpmlead.h\"\n#include \"rpmio/rpmio_internal.h\"\t/* fd digest bits */\n#include \"lib/header_internal.h\"\t/* XXX headerCheck */\n#include \"lib/rpmvs.h\"\n\n#include \"debug.h\"\n\ntypedef struct pkgdata_s *pkgdatap;\n\ntypedef void (*hdrvsmsg)(struct rpmsinfo_s *sinfo, pkgdatap pkgdata, const char *msg);\n\nstruct pkgdata_s {\n    hdrvsmsg msgfunc;\n    const char *fn;\n    char *msg;\n    rpmRC rc;\n};\n\nstruct taglate_s {\n    rpmTagVal stag;\n    rpmTagVal xtag;\n    rpm_count_t count;\n} const xlateTags[] = {\n    { RPMSIGTAG_SIZE, RPMTAG_SIGSIZE, 1 },\n    { RPMSIGTAG_PGP, RPMTAG_SIGPGP, 0 },\n    { RPMSIGTAG_MD5, RPMTAG_SIGMD5, 16 },\n    { RPMSIGTAG_GPG, RPMTAG_SIGGPG, 0 },\n    /* { RPMSIGTAG_PGP5, RPMTAG_SIGPGP5, 0 }, */ /* long obsolete, dont use */\n    { RPMSIGTAG_PAYLOADSIZE, RPMTAG_ARCHIVESIZE, 1 },\n    { RPMSIGTAG_FILESIGNATURES, RPMTAG_FILESIGNATURES, 0 },\n    { RPMSIGTAG_FILESIGNATURELENGTH, RPMTAG_FILESIGNATURELENGTH, 1 },\n    { RPMSIGTAG_VERITYSIGNATURES, RPMTAG_VERITYSIGNATURES, 0 },\n    { RPMSIGTAG_VERITYSIGNATUREALGO, RPMTAG_VERITYSIGNATUREALGO, 1 },\n    { RPMSIGTAG_SHA1, RPMTAG_SHA1HEADER, 1 },\n    { RPMSIGTAG_SHA256, RPMTAG_SHA256HEADER, 1 },\n    { RPMSIGTAG_DSA, RPMTAG_DSAHEADER, 0 },\n    { RPMSIGTAG_RSA, RPMTAG_RSAHEADER, 0 },\n    { RPMSIGTAG_LONGSIZE, RPMTAG_LONGSIGSIZE, 1 },\n    { RPMSIGTAG_LONGARCHIVESIZE, RPMTAG_LONGARCHIVESIZE, 1 },\n    { 0 }\n};\n\n/** \\ingroup header\n * Translate and merge legacy signature tags into header.\n * @param h\t\theader (dest)\n * @param sigh\t\tsignature header (src)\n * @return\t\tfailing tag number, 0 on success\n */\nstatic\nrpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)\n{\n    const struct taglate_s *xl;\n    struct rpmtd_s td;\n\n    rpmtdReset(&td);\n    for (xl = xlateTags; xl->stag; xl++) {\n\t/* There mustn't be one in the main header */\n\tif (headerIsEntry(h, xl->xtag))\n\t    break;\n\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {\n\t    /* Translate legacy tags */\n\t    if (xl->stag != xl->xtag)\n\t\ttd.tag = xl->xtag;\n\t    /* Ensure type and tag size match expectations */\n\t    if (td.type != rpmTagGetTagType(td.tag))\n\t\tbreak;\n\t    if (td.count < 1 || td.count > 16*1024*1024)\n\t\tbreak;\n\t    if (xl->count && td.count != xl->count)\n\t\tbreak;\n\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))\n\t\tbreak;\n\t    rpmtdFreeData(&td);\n\t}\n    }\n    rpmtdFreeData(&td);\n\n    if (xl->stag) {\n\trasprintf(msg, \"invalid signature tag %s (%d)\",\n\t\t\trpmTagGetName(xl->xtag), xl->xtag);\n    }\n\n    return xl->stag;\n}\n\n/**\n * Remember current key id.\n * XXX: This s*** needs to die. Hook it into keyring or sumthin...\n * @param keyid\t\tsignature keyid\n * @return\t\t0 if new keyid, otherwise 1\n */\nstatic int stashKeyid(unsigned int keyid)\n{\n    static pthread_mutex_t keyid_lock = PTHREAD_MUTEX_INITIALIZER;\n    static const unsigned int nkeyids_max = 256;\n    static unsigned int nkeyids = 0;\n    static unsigned int nextkeyid  = 0;\n    static unsigned int * keyids;\n\n    int i;\n    int seen = 0;\n\n    if (keyid == 0)\n\treturn 0;\n\n    /* Just pretend we didn't see the keyid if we fail to lock */\n    if (pthread_mutex_lock(&keyid_lock))\n\treturn 0;\n\n    if (keyids != NULL)\n    for (i = 0; i < nkeyids; i++) {\n\tif (keyid == keyids[i]) {\n\t    seen = 1;\n\t    goto exit;\n        }\n    }\n\n    if (nkeyids < nkeyids_max) {\n\tnkeyids++;\n\tkeyids = xrealloc(keyids, nkeyids * sizeof(*keyids));\n    }\n    if (keyids)\t\t/* XXX can't happen */\n\tkeyids[nextkeyid] = keyid;\n    nextkeyid++;\n    nextkeyid %= nkeyids_max;\n\nexit:\n    pthread_mutex_unlock(&keyid_lock);\n    return seen;\n}\n\nstatic int handleHdrVS(struct rpmsinfo_s *sinfo, void *cbdata)\n{\n    struct pkgdata_s *pkgdata = cbdata;\n\n    if (pkgdata->msgfunc) {\n\tchar *vsmsg = rpmsinfoMsg(sinfo);\n\tpkgdata->msgfunc(sinfo, pkgdata, vsmsg);\n\tfree(vsmsg);\n    }\n\n    /* Remember actual return code, but don't override a previous failure */\n    if (sinfo->rc && pkgdata->rc != RPMRC_FAIL)\n\tpkgdata->rc = sinfo->rc;\n\n    /* Preserve traditional behavior for now: only failure prevents read */\n    if (sinfo->rc != RPMRC_FAIL)\n\tsinfo->rc = RPMRC_OK;\n\n    return 1;\n}\n\n\nstatic void appendhdrmsg(struct rpmsinfo_s *sinfo, struct pkgdata_s *pkgdata,\n\t\t\tconst char *msg)\n{\n    pkgdata->msg = rstrscat(&pkgdata->msg, \"\\n\", msg, NULL);\n}\n\nstatic void updateHdrDigests(rpmDigestBundle bundle, struct hdrblob_s *blob)\n{\n    int32_t ildl[2] = { htonl(blob->ril), htonl(blob->rdl) };\n\n    rpmDigestBundleUpdate(bundle, rpm_header_magic, sizeof(rpm_header_magic));\n    rpmDigestBundleUpdate(bundle, ildl, sizeof(ildl));\n    rpmDigestBundleUpdate(bundle, blob->pe, (blob->ril * sizeof(*blob->pe)));\n    rpmDigestBundleUpdate(bundle, blob->dataStart, blob->rdl);\n}\n\nrpmRC headerCheck(rpmts ts, const void * uh, size_t uc, char ** msg)\n{\n    rpmRC rc = RPMRC_FAIL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct hdrblob_s blob;\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = appendhdrmsg,\n\t.fn = NULL,\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    if (hdrblobInit(uh, uc, 0, 0, &blob, msg) == RPMRC_OK) {\n\tstruct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n\trpmDigestBundle bundle = rpmDigestBundleNew();\n\n\trpmswEnter(rpmtsOp(ts, RPMTS_OP_DIGEST), 0);\n\n\trpmvsInit(vs, &blob, bundle);\n\trpmvsInitRange(vs, RPMSIG_HEADER);\n\tupdateHdrDigests(bundle, &blob);\n\trpmvsFiniRange(vs, RPMSIG_HEADER);\n\n\trpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata);\n\n\trpmswExit(rpmtsOp(ts, RPMTS_OP_DIGEST), uc);\n\n\trc = pkgdata.rc;\n\n\tif (rc == RPMRC_OK && pkgdata.msg == NULL)\n\t    pkgdata.msg = xstrdup(\"Header sanity check: OK\");\n\n\tif (msg)\n\t    *msg = pkgdata.msg;\n\telse\n\t    free(pkgdata.msg);\n\n\trpmDigestBundleFree(bundle);\n\trpmvsFree(vs);\n    }\n\n    rpmKeyringFree(keyring);\n\n    return rc;\n}\n\nrpmRC rpmReadHeader(rpmts ts, FD_t fd, Header *hdrp, char ** msg)\n{\n    char *buf = NULL;\n    struct hdrblob_s blob;\n    Header h = NULL;\n    rpmRC rc = RPMRC_FAIL;\t\t/* assume failure */\n\n    if (hdrp)\n\t*hdrp = NULL;\n    if (msg)\n\t*msg = NULL;\n\n    if (hdrblobRead(fd, 1, 1, RPMTAG_HEADERIMMUTABLE, &blob, &buf) != RPMRC_OK)\n\tgoto exit;\n\n    /* OK, blob looks sane, load the header. */\n    rc = hdrblobImport(&blob, 0, &h, &buf);\n    \nexit:\n    if (hdrp && h && rc == RPMRC_OK)\n\t*hdrp = headerLink(h);\n    headerFree(h);\n\n    if (msg != NULL && *msg == NULL && buf != NULL) {\n\t*msg = buf;\n    } else {\n\tfree(buf);\n    }\n\n    return rc;\n}\n\nstatic\nvoid applyRetrofits(Header h)\n{\n    int v3 = 0;\n    /*\n     * Make sure that either RPMTAG_SOURCERPM or RPMTAG_SOURCEPACKAGE\n     * is set. Use a simple heuristic to find the type if both are unset.\n     */\n    if (!headerIsEntry(h, RPMTAG_SOURCERPM) && !headerIsEntry(h, RPMTAG_SOURCEPACKAGE)) {\n\t/* the heuristic needs the compressed file list */\n\tif (headerIsEntry(h, RPMTAG_OLDFILENAMES))\n\t    headerConvert(h, HEADERCONV_COMPRESSFILELIST);\n\tif (headerIsSourceHeuristic(h)) {\n\t    /* Retrofit RPMTAG_SOURCEPACKAGE to srpms for compatibility */\n\t    uint32_t one = 1;\n\t    headerPutUint32(h, RPMTAG_SOURCEPACKAGE, &one, 1);\n\t} else {\n\t    /*\n\t     * Make sure binary rpms have RPMTAG_SOURCERPM set as that's\n\t     * what we use for differentiating binary vs source elsewhere.\n\t     */\n\t    headerPutString(h, RPMTAG_SOURCERPM, \"(none)\");\n\t}\n    }\n\n    /*\n     * Convert legacy headers on the fly. Not having immutable region\n     * equals a truly ancient package, do full retrofit. OTOH newer\n     * packages might have been built with --nodirtokens, test and handle\n     * the non-compressed filelist case separately.\n     */\n    if (!headerIsEntry(h, RPMTAG_HEADERIMMUTABLE)) {\n\tv3 = 1;\n\theaderConvert(h, HEADERCONV_RETROFIT_V3);\n    } else if (headerIsEntry(h, RPMTAG_OLDFILENAMES)) {\n\theaderConvert(h, HEADERCONV_COMPRESSFILELIST);\n\tv3 = 1;\n    }\n    if (v3) {\n\tchar *s = headerGetAsString(h, RPMTAG_NEVRA);\n\trpmlog(RPMLOG_WARNING, _(\"RPM v3 packages are deprecated: %s\\n\"), s);\n\tfree(s);\n    }\n}\n\nstatic void loghdrmsg(struct rpmsinfo_s *sinfo, struct pkgdata_s *pkgdata,\n\t\t\tconst char *msg)\n{\n    int lvl = RPMLOG_DEBUG;\n    switch (sinfo->rc) {\n    case RPMRC_OK:\t\t/* Signature is OK. */\n\tbreak;\n    case RPMRC_NOTTRUSTED:\t/* Signature is OK, but key is not trusted. */\n    case RPMRC_NOKEY:\t\t/* Public key is unavailable. */\n\t/* XXX Print NOKEY/NOTTRUSTED warning only once. */\n\tif (stashKeyid(sinfo->keyid) == 0)\n\t    lvl = RPMLOG_WARNING;\n\tbreak;\n    case RPMRC_NOTFOUND:\t/* Signature/digest not present. */\n\tlvl = RPMLOG_WARNING;\n\tbreak;\n    default:\n    case RPMRC_FAIL:\t\t/* Signature does not verify. */\n\tlvl = RPMLOG_ERR;\n\tbreak;\n    }\n\n    rpmlog(lvl, \"%s: %s\\n\", pkgdata->fn, msg);\n}\n\nrpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    /* XXX: lots of 3rd party software relies on the behavior */\n    if (hdrp)\n\t*hdrp = NULL;\n\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n\n    /* Actually all verify discovered signatures and digests */\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\t/* Finally import the headers and do whatever required retrofits etc */\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\n\t    /* Append (and remap) signature tags to the metadata. */\n\t    if (headerMergeLegacySigs(h, sigh, &msg))\n\t\tgoto exit;\n\t    applyRetrofits(h);\n\n\t    /* Bump reference count for return. */\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n\n    /* If there was a \"substatus\" (NOKEY in practise), return that instead */\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\n\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n\n    return rc;\n}\n\n\n\n"], "filenames": ["lib/package.c"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [384], "fixing_code_start_loc": [34], "fixing_code_end_loc": [372], "type": "CWE-345", "message": "A flaw was found in RPM's signature check functionality when reading a package file. This flaw allows an attacker who can convince a victim to install a seemingly verifiable package, whose signature header was modified, to cause RPM database corruption and execute code. The highest threat from this vulnerability is to data integrity, confidentiality, and system availability.", "other": {"cve": {"id": "CVE-2021-20271", "sourceIdentifier": "secalert@redhat.com", "published": "2021-03-26T17:15:13.000", "lastModified": "2023-02-12T22:15:17.920", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in RPM's signature check functionality when reading a package file. This flaw allows an attacker who can convince a victim to install a seemingly verifiable package, whose signature header was modified, to cause RPM database corruption and execute code. The highest threat from this vulnerability is to data integrity, confidentiality, and system availability."}, {"lang": "es", "value": "Se detect\u00f3 un fallo en la funcionalidad de comprobaci\u00f3n de firmas de RPM cuando se lee un archivo de paquete. Este fallo permite a un atacante que pueda convencer a una v\u00edctima de instalar un paquete aparentemente verificable, cuyo encabezado de firma fue modificado, causar una corrupci\u00f3n de la base de datos de RPM y ejecutar c\u00f3digo. La mayor amenaza de esta vulnerabilidad es la integridad de los datos, la confidencialidad y la disponibilidad del sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15.0", "versionEndExcluding": "4.15.1.3", "matchCriteriaId": "5017E785-D9A4-40BE-ADD8-4421BB138131"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.16.0", "versionEndExcluding": "4.16.1.3", "matchCriteriaId": "F22989FC-E9C0-4189-BDFE-69346C3F8495"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:4.15.0:alpha:*:*:*:*:*:*", "matchCriteriaId": "6E77F834-98D9-45CA-A442-97362CEAB09C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:4.15.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "40503D12-35BC-4515-A293-F39A37B23A38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:4.15.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "19299515-DF82-48A3-BA65-0DE705E75CA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:4.16.0:alpha:*:*:*:*:*:*", "matchCriteriaId": "0565E985-6BD3-45E1-928C-B67E18B7B56E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:4.16.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "96BDFF27-D2ED-48F9-91FB-377D1244A0A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:4.16.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "EA51C420-EFCB-4068-A981-E99722C5FAD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:4.16.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "653B69E5-0E47-49EF-AD3D-218C86252E7C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:starwindsoftware:starwind_virtual_san:v8:build14398:*:*:*:*:*:*", "matchCriteriaId": "2561CD5F-82A9-464E-B571-44634187B497"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1934125", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TMGXO3W6DHPO62GJ4VVF5DEUX5DRUR5K/", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VHRPNBCRPDJHHQE3MBPSZK4H7X2IM7AC/", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YILPBTPSBRYL4POBI3F4YUSVPSOQNJBY/", "source": "secalert@redhat.com"}, {"url": "https://security.gentoo.org/glsa/202107-43", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.starwindsoftware.com/security/sw-20220805-0002/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21"}}