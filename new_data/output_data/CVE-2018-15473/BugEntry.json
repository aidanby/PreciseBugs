{"buggy_code": ["/* $OpenBSD: auth2-gss.c,v 1.28 2018/07/10 09:13:30 djm Exp $ */\n\n/*\n * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef GSSAPI\n\n#include <sys/types.h>\n\n#include \"xmalloc.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"packet.h\"\n#include \"ssh-gss.h\"\n#include \"monitor_wrap.h\"\n\nextern ServerOptions options;\n\nstatic int input_gssapi_token(int type, u_int32_t plen, struct ssh *ssh);\nstatic int input_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh);\nstatic int input_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh);\nstatic int input_gssapi_errtok(int, u_int32_t, struct ssh *);\n\n/*\n * We only support those mechanisms that we know about (ie ones that we know\n * how to check local user kuserok and the like)\n */\nstatic int\nuserauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tmechs--;\n\n\t\tfree(doid);\n\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\t/* Return the OID that we received */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfree(doid);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}\n\nstatic int\ninput_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status, min_status, flags;\n\tu_char *p;\n\tsize_t len;\n\tint r;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, &flags));\n\n\tfree(p);\n\n\tif (GSS_ERROR(maj_status)) {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tauthctxt->postponed = 0;\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\tuserauth_finish(ssh, 0, \"gssapi-with-mic\", NULL);\n\t} else {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tif (maj_status == GSS_S_COMPLETE) {\n\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\t\tif (flags & GSS_C_INTEG_FLAG)\n\t\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC,\n\t\t\t\t    &input_gssapi_mic);\n\t\t\telse\n\t\t\t\tssh_dispatch_set(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,\n\t\t\t\t    &input_gssapi_exchange_complete);\n\t\t}\n\t}\n\n\tgss_release_buffer(&min_status, &send_tok);\n\treturn 0;\n}\n\nstatic int\ninput_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status;\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\n\t/* Push the error token into GSSAPI to see what it says */\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, NULL));\n\n\tfree(recv_tok.value);\n\n\t/* We can't return anything to the client, even if we wanted to */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\n\t/* The client will have already moved on to the next auth */\n\n\tgss_release_buffer(&maj_status, &send_tok);\n\treturn 0;\n}\n\n/*\n * This is called when the client thinks we've completed authentication.\n * It should only be enabled in the dispatch handler by the function above,\n * which only enables it once the GSSAPI exchange is complete.\n */\n\nstatic int\ninput_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r, authenticated;\n\tconst char *displayname;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\t/*\n\t * We don't need to check the status, because we're only enabled in\n\t * the dispatcher once the exchange is complete\n\t */\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}\n\nstatic int\ninput_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tint r, authenticated = 0;\n\tstruct sshbuf *b;\n\tgss_buffer_desc mic, gssbuf;\n\tconst char *displayname;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmic.value = p;\n\tmic.length = len;\n\tssh_gssapi_buildmic(b, authctxt->user, authctxt->service,\n\t    \"gssapi-with-mic\");\n\n\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\tgssbuf.length = sshbuf_len(b);\n\n\tif (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))\n\t\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\telse\n\t\tlogit(\"GSSAPI MIC check failed\");\n\n\tsshbuf_free(b);\n\tfree(mic.value);\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}\n\nAuthmethod method_gssapi = {\n\t\"gssapi-with-mic\",\n\tuserauth_gssapi,\n\t&options.gss_authentication\n};\n#endif\n", "/* $OpenBSD: auth2-hostbased.c,v 1.35 2018/07/09 21:35:50 markus Exp $ */\n/*\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"xmalloc.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"compat.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"pathnames.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n\n/* import */\nextern ServerOptions options;\nextern u_char *session_id2;\nextern u_int session_id2_len;\n\nstatic int\nuserauth_hostbased(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg, *cuser, *chost;\n\tu_char *pkblob, *sig;\n\tsize_t alen, blen, slen;\n\tint r, pktype, authenticated = 0;\n\n\tif (!authctxt->valid) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\treturn 0;\n\t}\n\t/* XXX use sshkey_froms() */\n\tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)\n\t\tfatal(\"%s: packet parsing: %s\", __func__, ssh_err(r));\n\n\tdebug(\"%s: cuser %s chost %s pkalg %s slen %zu\", __func__,\n\t    cuser, chost, pkalg, slen);\n#ifdef DEBUG_PK\n\tdebug(\"signature:\");\n\tsshbuf_dump_data(sig, siglen, stderr);\n#endif\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tlogit(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: key_from_blob: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\terror(\"Refusing RSA key because peer uses unsafe \"\n\t\t    \"signature format\");\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in HostbasedAcceptedKeyTypes\",\n\t\t    __func__, sshkey_type(key));\n\t\tgoto done;\n\t}\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* reconstruct packet */\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, \"hostbased\")) != 0 ||\n\t    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||\n\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, cuser)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\n\tauth2_record_info(authctxt,\n\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\", cuser, chost);\n\n\t/* test for allowed key and correct signature */\n\tauthenticated = 0;\n\tif (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&\n\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)\n\t\tauthenticated = 1;\n\n\tauth2_record_key(authctxt, authenticated, key);\n\tsshbuf_free(b);\ndone:\n\tdebug2(\"%s: authenticated %d\", __func__, authenticated);\n\tsshkey_free(key);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(cuser);\n\tfree(chost);\n\tfree(sig);\n\treturn authenticated;\n}\n\n/* return 1 if given hostkey is allowed */\nint\nhostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,\n    struct sshkey *key)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst char *resolvedname, *ipaddr, *lookup, *reason;\n\tHostStatus host_status;\n\tint len;\n\tchar *fp;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\n\tresolvedname = auth_get_canonical_hostname(ssh, options.use_dns);\n\tipaddr = ssh_remote_ipaddr(ssh);\n\n\tdebug2(\"%s: chost %s resolvedname %s ipaddr %s\", __func__,\n\t    chost, resolvedname, ipaddr);\n\n\tif (((len = strlen(chost)) > 0) && chost[len - 1] == '.') {\n\t\tdebug2(\"stripping trailing dot from chost %s\", chost);\n\t\tchost[len - 1] = '\\0';\n\t}\n\n\tif (options.hostbased_uses_name_from_packet_only) {\n\t\tif (auth_rhosts2(pw, cuser, chost, chost) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" (from packet)\",\n\t\t\t    __func__, cuser, chost);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = chost;\n\t} else {\n\t\tif (strcasecmp(resolvedname, chost) != 0)\n\t\t\tlogit(\"userauth_hostbased mismatch: \"\n\t\t\t    \"client sends %s, but we resolve %s to %s\",\n\t\t\t    chost, ipaddr, resolvedname);\n\t\tif (auth_rhosts2(pw, cuser, resolvedname, ipaddr) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" addr \\\"%.100s\\\"\",\n\t\t\t    __func__, cuser, resolvedname, ipaddr);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = resolvedname;\n\t}\n\tdebug2(\"%s: access allowed by auth_rhosts2\", __func__);\n\n\tif (sshkey_is_cert(key) &&\n\t    sshkey_cert_check_authority(key, 1, 0, lookup, &reason)) {\n\t\terror(\"%s\", reason);\n\t\tauth_debug_add(\"%s\", reason);\n\t\treturn 0;\n\t}\n\n\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t    _PATH_SSH_SYSTEM_HOSTFILE,\n\t    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);\n\n\t/* backward compat if no key has been found. */\n\tif (host_status == HOST_NEW) {\n\t\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t\t    _PATH_SSH_SYSTEM_HOSTFILE2,\n\t\t    options.ignore_user_known_hosts ? NULL :\n\t\t    _PATH_SSH_USER_HOSTFILE2);\n\t}\n\n\tif (host_status == HOST_OK) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif ((fp = sshkey_fingerprint(key->cert->signature_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted certificate ID \\\"%s\\\" signed by \"\n\t\t\t    \"%s CA %s from %s@%s\", key->cert->key_id,\n\t\t\t    sshkey_type(key->cert->signature_key), fp,\n\t\t\t    cuser, lookup);\n\t\t} else {\n\t\t\tif ((fp = sshkey_fingerprint(key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted %s public key %s from %s@%s\",\n\t\t\t    sshkey_type(key), fp, cuser, lookup);\n\t\t}\n\t\tfree(fp);\n\t}\n\n\treturn (host_status == HOST_OK);\n}\n\nAuthmethod method_hostbased = {\n\t\"hostbased\",\n\tuserauth_hostbased,\n\t&options.hostbased_authentication\n};\n", "/* $OpenBSD: auth2-pubkey.c,v 1.82 2018/07/11 18:55:11 markus Exp $ */\n/*\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"compat.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"pathnames.h\"\n#include \"uidswap.h\"\n#include \"auth-options.h\"\n#include \"canohost.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"channels.h\" /* XXX for session.h */\n#include \"session.h\" /* XXX for child_set_env(); refactor? */\n\n/* import */\nextern ServerOptions options;\nextern u_char *session_id2;\nextern u_int session_id2_len;\n\nstatic char *\nformat_key(const struct sshkey *key)\n{\n\tchar *ret, *fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\n\txasprintf(&ret, \"%s %s\", sshkey_type(key), fp);\n\tfree(fp);\n\treturn ret;\n}\n\nstatic int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n\tu_char *pkblob, *sig, have_sig;\n\tsize_t blen, slen;\n\tint r, pktype;\n\tint authenticated = 0;\n\tstruct sshauthopt *authopts = NULL;\n\n\tif (!authctxt->valid) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\treturn 0;\n\t}\n\tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tverbose(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: could not parse key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Refusing RSA key because client uses unsafe \"\n\t\t    \"signature scheme\");\n\t\tgoto done;\n\t}\n\tif (auth2_key_already_used(authctxt, key)) {\n\t\tlogit(\"refusing previously-used %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\",\n\t\t    __func__, sshkey_ssh_name(key));\n\t\tgoto done;\n\t}\n\n\tkey_s = format_key(key);\n\tif (sshkey_is_cert(key))\n\t\tca_s = format_key(key->cert->signature_key);\n\n\tif (have_sig) {\n\t\tdebug3(\"%s: have %s signature for %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\t\tif ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n\t\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_string session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\t/* reconstruct packet */\n\t\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t\t    authctxt->style ? \":\" : \"\",\n\t\t    authctxt->style ? authctxt->style : \"\");\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, pkalg) != 0) ||\n\t\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n\t\t\tfatal(\"%s: build packet failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\t\tsshbuf_dump(b, stderr);\n#endif\n\n\t\t/* test for correct signature */\n\t\tauthenticated = 0;\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n\t\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat)) == 0) {\n\t\t\tauthenticated = 1;\n\t\t}\n\t\tsshbuf_free(b);\n\t\tfree(sig);\n\t\tauth2_record_key(authctxt, authenticated, key);\n\t} else {\n\t\tdebug(\"%s: test pkalg %s pkblob %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\t/* XXX fake reply and always send PK_OK ? */\n\t\t/*\n\t\t * XXX this allows testing whether a user is allowed\n\t\t * to login: if you happen to have a valid pubkey this\n\t\t * message is sent. the message is NEVER sent at all\n\t\t * if a user is not allowed to login. is this an\n\t\t * issue? -markus\n\t\t */\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n\t\t\t    != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\tauthctxt->postponed = 1;\n\t\t}\n\t}\ndone:\n\tif (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n\t\tdebug(\"%s: key options inconsistent with existing\", __func__);\n\t\tauthenticated = 0;\n\t}\n\tdebug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);\n\n\tsshauthopt_free(authopts);\n\tsshkey_free(key);\n\tfree(userstyle);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(key_s);\n\tfree(ca_s);\n\treturn authenticated;\n}\n\nstatic int\nmatch_principals_option(const char *principal_list, struct sshkey_cert *cert)\n{\n\tchar *result;\n\tu_int i;\n\n\t/* XXX percent_expand() sequences for authorized_principals? */\n\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif ((result = match_list(cert->principals[i],\n\t\t    principal_list, NULL)) != NULL) {\n\t\t\tdebug3(\"matched principal from key options \\\"%.100s\\\"\",\n\t\t\t    result);\n\t\t\tfree(result);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Process a single authorized_principals format line. Returns 0 and sets\n * authoptsp is principal is authorised, -1 otherwise. \"loc\" is used as a\n * log preamble for file/line information.\n */\nstatic int\ncheck_principals_line(struct ssh *ssh, char *cp, const struct sshkey_cert *cert,\n    const char *loc, struct sshauthopt **authoptsp)\n{\n\tu_int i, found = 0;\n\tchar *ep, *line_opts;\n\tconst char *reason = NULL;\n\tstruct sshauthopt *opts = NULL;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Trim trailing whitespace. */\n\tep = cp + strlen(cp) - 1;\n\twhile (ep > cp && (*ep == '\\n' || *ep == ' ' || *ep == '\\t'))\n\t\t*ep-- = '\\0';\n\n\t/*\n\t * If the line has internal whitespace then assume it has\n\t * key options.\n\t */\n\tline_opts = NULL;\n\tif ((ep = strrchr(cp, ' ')) != NULL ||\n\t    (ep = strrchr(cp, '\\t')) != NULL) {\n\t\tfor (; *ep == ' ' || *ep == '\\t'; ep++)\n\t\t\t;\n\t\tline_opts = cp;\n\t\tcp = ep;\n\t}\n\tif ((opts = sshauthopt_parse(line_opts, &reason)) == NULL) {\n\t\tdebug(\"%s: bad principals options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad principals options: %s\", loc, reason);\n\t\treturn -1;\n\t}\n\t/* Check principals in cert against those on line */\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif (strcmp(cp, cert->principals[i]) != 0)\n\t\t\tcontinue;\n\t\tdebug3(\"%s: matched principal \\\"%.100s\\\"\",\n\t\t    loc, cert->principals[i]);\n\t\tfound = 1;\n\t}\n\tif (found && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn found ? 0 : -1;\n}\n\nstatic int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}\n\n/* XXX remove pw args here and elsewhere once ssh->authctxt is guaranteed */\n\nstatic int\nmatch_principals_file(struct ssh *ssh, struct passwd *pw, char *file,\n    struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint success;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\ttemporarily_use_uid(pw);\n\tdebug(\"trying authorized principals file %s\", file);\n\tif ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tsuccess = process_principals(ssh, f, file, cert, authoptsp);\n\tfclose(f);\n\trestore_uid();\n\treturn success;\n}\n\n/*\n * Checks whether principal is allowed in output of command.\n * returns 1 if the principal is allowed or 0 otherwise.\n */\nstatic int\nmatch_principals_command(struct ssh *ssh, struct passwd *user_pw,\n    const struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tconst struct sshkey_cert *cert = key->cert;\n\tFILE *f = NULL;\n\tint r, ok, found_principal = 0;\n\tint i, ac = 0, uid_swapped = 0;\n\tpid_t pid;\n\tchar *tmp, *username = NULL, *command = NULL, **av = NULL;\n\tchar *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;\n\tchar serial_s[16], uidstr[32];\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_principals_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_principals_command_user == NULL) {\n\t\terror(\"No user for AuthorizedPrincipalsCommand specified, \"\n\t\t    \"skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_principals_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_principals_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" contains \"\n\t\t    \"invalid quotes\", command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif ((ca_fp = sshkey_fingerprint(cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((key_fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsnprintf(serial_s, sizeof(serial_s), \"%llu\",\n\t    (unsigned long long)cert->serial);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"T\", sshkey_ssh_name(cert->signature_key),\n\t\t    \"f\", key_fp,\n\t\t    \"F\", ca_fp,\n\t\t    \"k\", keytext,\n\t\t    \"K\", catext,\n\t\t    \"i\", cert->key_id,\n\t\t    \"s\", serial_s,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(\"AuthorizedPrincipalsCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = process_principals(ssh, f, \"(command)\", cert, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedPrincipalsCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_principal = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(ca_fp);\n\tfree(key_fp);\n\tfree(catext);\n\tfree(keytext);\n\treturn found_principal;\n}\n\nstatic void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}\n\n/*\n * Advanced *cpp past the end of key options, defined as the first unquoted\n * whitespace character. Returns 0 on success or -1 on failure (e.g.\n * unterminated quotes).\n */\nstatic int\nadvance_past_options(char **cpp)\n{\n\tchar *cp = *cpp;\n\tint quoted = 0;\n\n\tfor (; *cp && (quoted || (*cp != ' ' && *cp != '\\t')); cp++) {\n\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\tcp++;\t/* Skip both */\n\t\telse if (*cp == '\"')\n\t\t\tquoted = !quoted;\n\t}\n\t*cpp = cp;\n\t/* return failure for unterminated quotes */\n\treturn (*cp == '\\0' && quoted) ? -1 : 0;\n}\n\n/*\n * Check a single line of an authorized_keys-format file. Returns 0 if key\n * matches, -1 otherwise. Will return key/cert options via *authoptsp\n * on success. \"loc\" is used as file/line location in log messages.\n */\nstatic int\ncheck_authkey_line(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *cp, const char *loc, struct sshauthopt **authoptsp)\n{\n\tint want_keytype = sshkey_is_cert(key) ? KEY_UNSPEC : key->type;\n\tstruct sshkey *found = NULL;\n\tstruct sshauthopt *keyopts = NULL, *certopts = NULL, *finalopts = NULL;\n\tchar *key_options = NULL, *fp = NULL;\n\tconst char *reason = NULL;\n\tint ret = -1;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif ((found = sshkey_new(want_keytype)) == NULL) {\n\t\tdebug3(\"%s: keytype %d failed\", __func__, want_keytype);\n\t\tgoto out;\n\t}\n\n\t/* XXX djm: peek at key type in line and skip if unwanted */\n\n\tif (sshkey_read(found, &cp) != 0) {\n\t\t/* no key?  check for options */\n\t\tdebug2(\"%s: check options: '%s'\", loc, cp);\n\t\tkey_options = cp;\n\t\tif (advance_past_options(&cp) != 0) {\n\t\t\treason = \"invalid key option string\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(found, &cp) != 0) {\n\t\t\t/* still no key?  advance to next line*/\n\t\t\tdebug2(\"%s: advance: '%s'\", loc, cp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Parse key options now; we need to know if this is a CA key */\n\tif ((keyopts = sshauthopt_parse(key_options, &reason)) == NULL) {\n\t\tdebug(\"%s: bad key options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad key options: %s\", loc, reason);\n\t\tgoto out;\n\t}\n\t/* Ignore keys that don't match or incorrectly marked as CAs */\n\tif (sshkey_is_cert(key)) {\n\t\t/* Certificate; check signature key against CA */\n\t\tif (!sshkey_equal(found, key->cert->signature_key) ||\n\t\t    !keyopts->cert_authority)\n\t\t\tgoto out;\n\t} else {\n\t\t/* Plain key: check it against key found in file */\n\t\tif (!sshkey_equal(found, key) || keyopts->cert_authority)\n\t\t\tgoto out;\n\t}\n\n\t/* We have a candidate key, perform authorisation checks */\n\tif ((fp = sshkey_fingerprint(found,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\tfatal(\"%s: fingerprint failed\", __func__);\n\n\tdebug(\"%s: matching %s found: %s %s\", loc,\n\t    sshkey_is_cert(key) ? \"CA\" : \"key\", sshkey_type(found), fp);\n\n\tif (auth_authorise_keyopts(ssh, pw, keyopts,\n\t    sshkey_is_cert(key), loc) != 0) {\n\t\treason = \"Refused by key options\";\n\t\tgoto fail_reason;\n\t}\n\t/* That's all we need for plain keys. */\n\tif (!sshkey_is_cert(key)) {\n\t\tverbose(\"Accepted key %s %s found at %s\",\n\t\t    sshkey_type(found), fp, loc);\n\t\tfinalopts = keyopts;\n\t\tkeyopts = NULL;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Additional authorisation for certificates.\n\t */\n\n\t/* Parse and check options present in certificate */\n\tif ((certopts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, certopts, 0, loc) != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif ((finalopts = sshauthopt_merge(keyopts, certopts, &reason)) == NULL)\n\t\tgoto fail_reason;\n\n\t/*\n\t * If the user has specified a list of principals as\n\t * a key option, then prefer that list to matching\n\t * their username in the certificate principals list.\n\t */\n\tif (keyopts->cert_principals != NULL &&\n\t    !match_principals_option(keyopts->cert_principals, key->cert)) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (sshkey_cert_check_authority(key, 0, 0,\n\t   keyopts->cert_principals == NULL ? pw->pw_name : NULL, &reason) != 0)\n\t\tgoto fail_reason;\n\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\",\n\t    key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(found), fp, loc);\n\n success:\n\tif (finalopts == NULL)\n\t\tfatal(\"%s: internal error: missing options\", __func__);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = finalopts;\n\t\tfinalopts = NULL;\n\t}\n\t/* success */\n\tret = 0;\n\tgoto out;\n\n fail_reason:\n\terror(\"%s\", reason);\n\tauth_debug_add(\"%s\", reason);\n out:\n\tfree(fp);\n\tsshauthopt_free(keyopts);\n\tsshauthopt_free(certopts);\n\tsshauthopt_free(finalopts);\n\tsshkey_free(found);\n\treturn ret;\n}\n\n/*\n * Checks whether key is allowed in authorized_keys-format file,\n * returns 1 if the key is allowed or 0 otherwise.\n */\nstatic int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}\n\n/* Authenticate a certificate key against TrustedUserCAKeys */\nstatic int\nuser_cert_trusted_ca(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    struct sshauthopt **authoptsp)\n{\n\tchar *ca_fp, *principals_file = NULL;\n\tconst char *reason;\n\tstruct sshauthopt *principals_opts = NULL, *cert_opts = NULL;\n\tstruct sshauthopt *final_opts = NULL;\n\tint r, ret = 0, found_principal = 0, use_authorized_principals;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)\n\t\treturn 0;\n\n\tif ((ca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tif ((r = sshkey_in_file(key->cert->signature_key,\n\t    options.trusted_user_ca_keys, 1, 0)) != 0) {\n\t\tdebug2(\"%s: CA %s %s is not listed in %s: %s\", __func__,\n\t\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t\t    options.trusted_user_ca_keys, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/*\n\t * If AuthorizedPrincipals is in use, then compare the certificate\n\t * principals against the names in that file rather than matching\n\t * against the username.\n\t */\n\tif ((principals_file = authorized_principals_file(pw)) != NULL) {\n\t\tif (match_principals_file(ssh, pw, principals_file,\n\t\t    key->cert, &principals_opts))\n\t\t\tfound_principal = 1;\n\t}\n\t/* Try querying command if specified */\n\tif (!found_principal && match_principals_command(ssh, pw, key,\n\t    &principals_opts))\n\t\tfound_principal = 1;\n\t/* If principals file or command is specified, then require a match */\n\tuse_authorized_principals = principals_file != NULL ||\n            options.authorized_principals_command != NULL;\n\tif (!found_principal && use_authorized_principals) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (use_authorized_principals && principals_opts == NULL)\n\t\tfatal(\"%s: internal error: missing principals_opts\", __func__);\n\tif (sshkey_cert_check_authority(key, 0, 1,\n\t    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)\n\t\tgoto fail_reason;\n\n\t/* Check authority from options in key and from principals file/cmd */\n\tif ((cert_opts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, cert_opts, 0, \"cert\") != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (principals_opts == NULL) {\n\t\tfinal_opts = cert_opts;\n\t\tcert_opts = NULL;\n\t} else {\n\t\tif (auth_authorise_keyopts(ssh, pw, principals_opts, 0,\n\t\t    \"principals\") != 0) {\n\t\t\treason = \"Refused by certificate principals options\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tif ((final_opts = sshauthopt_merge(principals_opts,\n\t\t    cert_opts, &reason)) == NULL) {\n fail_reason:\n\t\t\terror(\"%s\", reason);\n\t\t\tauth_debug_add(\"%s\", reason);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\", key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    options.trusted_user_ca_keys);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = final_opts;\n\t\tfinal_opts = NULL;\n\t}\n\tret = 1;\n out:\n\tsshauthopt_free(principals_opts);\n\tsshauthopt_free(cert_opts);\n\tsshauthopt_free(final_opts);\n\tfree(principals_file);\n\tfree(ca_fp);\n\treturn ret;\n}\n\n/*\n * Checks whether key is allowed in file.\n * returns 1 if the key is allowed or 0 otherwise.\n */\nstatic int\nuser_key_allowed2(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *file, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint found_key = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\tdebug(\"trying public key file %s\", file);\n\tif ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {\n\t\tfound_key = check_authkeys_file(ssh, pw, f, file,\n\t\t    key, authoptsp);\n\t\tfclose(f);\n\t}\n\n\trestore_uid();\n\treturn found_key;\n}\n\n/*\n * Checks whether key is allowed in output of command.\n * returns 1 if the key is allowed or 0 otherwise.\n */\nstatic int\nuser_key_command_allowed2(struct ssh *ssh, struct passwd *user_pw,\n    struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tFILE *f = NULL;\n\tint r, ok, found_key = 0;\n\tint i, uid_swapped = 0, ac = 0;\n\tpid_t pid;\n\tchar *username = NULL, *key_fp = NULL, *keytext = NULL;\n\tchar uidstr[32], *tmp, *command = NULL, **av = NULL;\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_keys_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_keys_command_user == NULL) {\n\t\terror(\"No user for AuthorizedKeysCommand specified, skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_keys_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Prepare AuthorizedKeysCommand */\n\tif ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_keys_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"f\", key_fp,\n\t\t    \"k\", keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\t/*\n\t * If AuthorizedKeysCommand was run without arguments\n\t * then fall back to the old behaviour of passing the\n\t * target username as a single argument.\n\t */\n\tif (ac == 1) {\n\t\tav = xreallocarray(av, ac + 2, sizeof(*av));\n\t\tav[1] = xstrdup(user_pw->pw_name);\n\t\tav[2] = NULL;\n\t\t/* Fix up command too, since it is used in log messages */\n\t\tfree(command);\n\t\txasprintf(&command, \"%s %s\", av[0], av[1]);\n\t}\n\n\tif ((pid = subprocess(\"AuthorizedKeysCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = check_authkeys_file(ssh, user_pw, f,\n\t    options.authorized_keys_command, key, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedKeysCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_key = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(key_fp);\n\tfree(keytext);\n\treturn found_key;\n}\n\n/*\n * Check whether key authenticates and authorises the user.\n */\nint\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}\n\nAuthmethod method_pubkey = {\n\t\"publickey\",\n\tuserauth_pubkey,\n\t&options.pubkey_authentication\n};\n"], "fixing_code": ["/* $OpenBSD: auth2-gss.c,v 1.29 2018/07/31 03:10:27 djm Exp $ */\n\n/*\n * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef GSSAPI\n\n#include <sys/types.h>\n\n#include \"xmalloc.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"packet.h\"\n#include \"ssh-gss.h\"\n#include \"monitor_wrap.h\"\n\nextern ServerOptions options;\n\nstatic int input_gssapi_token(int type, u_int32_t plen, struct ssh *ssh);\nstatic int input_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh);\nstatic int input_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh);\nstatic int input_gssapi_errtok(int, u_int32_t, struct ssh *);\n\n/*\n * We only support those mechanisms that we know about (ie ones that we know\n * how to check local user kuserok and the like)\n */\nstatic int\nuserauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tmechs--;\n\n\t\tfree(doid);\n\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\tfree(doid);\n\t\treturn (0);\n\t}\n\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\t/* Return the OID that we received */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfree(doid);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}\n\nstatic int\ninput_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status, min_status, flags;\n\tu_char *p;\n\tsize_t len;\n\tint r;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, &flags));\n\n\tfree(p);\n\n\tif (GSS_ERROR(maj_status)) {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tauthctxt->postponed = 0;\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\tuserauth_finish(ssh, 0, \"gssapi-with-mic\", NULL);\n\t} else {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tif (maj_status == GSS_S_COMPLETE) {\n\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\t\tif (flags & GSS_C_INTEG_FLAG)\n\t\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC,\n\t\t\t\t    &input_gssapi_mic);\n\t\t\telse\n\t\t\t\tssh_dispatch_set(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,\n\t\t\t\t    &input_gssapi_exchange_complete);\n\t\t}\n\t}\n\n\tgss_release_buffer(&min_status, &send_tok);\n\treturn 0;\n}\n\nstatic int\ninput_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status;\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\n\t/* Push the error token into GSSAPI to see what it says */\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, NULL));\n\n\tfree(recv_tok.value);\n\n\t/* We can't return anything to the client, even if we wanted to */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\n\t/* The client will have already moved on to the next auth */\n\n\tgss_release_buffer(&maj_status, &send_tok);\n\treturn 0;\n}\n\n/*\n * This is called when the client thinks we've completed authentication.\n * It should only be enabled in the dispatch handler by the function above,\n * which only enables it once the GSSAPI exchange is complete.\n */\n\nstatic int\ninput_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r, authenticated;\n\tconst char *displayname;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\t/*\n\t * We don't need to check the status, because we're only enabled in\n\t * the dispatcher once the exchange is complete\n\t */\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}\n\nstatic int\ninput_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tint r, authenticated = 0;\n\tstruct sshbuf *b;\n\tgss_buffer_desc mic, gssbuf;\n\tconst char *displayname;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmic.value = p;\n\tmic.length = len;\n\tssh_gssapi_buildmic(b, authctxt->user, authctxt->service,\n\t    \"gssapi-with-mic\");\n\n\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\tgssbuf.length = sshbuf_len(b);\n\n\tif (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))\n\t\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\telse\n\t\tlogit(\"GSSAPI MIC check failed\");\n\n\tsshbuf_free(b);\n\tfree(mic.value);\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}\n\nAuthmethod method_gssapi = {\n\t\"gssapi-with-mic\",\n\tuserauth_gssapi,\n\t&options.gss_authentication\n};\n#endif\n", "/* $OpenBSD: auth2-hostbased.c,v 1.36 2018/07/31 03:10:27 djm Exp $ */\n/*\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"xmalloc.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"compat.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"pathnames.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n\n/* import */\nextern ServerOptions options;\nextern u_char *session_id2;\nextern u_int session_id2_len;\n\nstatic int\nuserauth_hostbased(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg, *cuser, *chost;\n\tu_char *pkblob, *sig;\n\tsize_t alen, blen, slen;\n\tint r, pktype, authenticated = 0;\n\n\t/* XXX use sshkey_froms() */\n\tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)\n\t\tfatal(\"%s: packet parsing: %s\", __func__, ssh_err(r));\n\n\tdebug(\"%s: cuser %s chost %s pkalg %s slen %zu\", __func__,\n\t    cuser, chost, pkalg, slen);\n#ifdef DEBUG_PK\n\tdebug(\"signature:\");\n\tsshbuf_dump_data(sig, siglen, stderr);\n#endif\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tlogit(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: key_from_blob: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\terror(\"Refusing RSA key because peer uses unsafe \"\n\t\t    \"signature format\");\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in HostbasedAcceptedKeyTypes\",\n\t\t    __func__, sshkey_type(key));\n\t\tgoto done;\n\t}\n\n\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\tgoto done;\n\t}\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* reconstruct packet */\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, \"hostbased\")) != 0 ||\n\t    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||\n\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, cuser)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\n\tauth2_record_info(authctxt,\n\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\", cuser, chost);\n\n\t/* test for allowed key and correct signature */\n\tauthenticated = 0;\n\tif (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&\n\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)\n\t\tauthenticated = 1;\n\n\tauth2_record_key(authctxt, authenticated, key);\n\tsshbuf_free(b);\ndone:\n\tdebug2(\"%s: authenticated %d\", __func__, authenticated);\n\tsshkey_free(key);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(cuser);\n\tfree(chost);\n\tfree(sig);\n\treturn authenticated;\n}\n\n/* return 1 if given hostkey is allowed */\nint\nhostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,\n    struct sshkey *key)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tconst char *resolvedname, *ipaddr, *lookup, *reason;\n\tHostStatus host_status;\n\tint len;\n\tchar *fp;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\n\tresolvedname = auth_get_canonical_hostname(ssh, options.use_dns);\n\tipaddr = ssh_remote_ipaddr(ssh);\n\n\tdebug2(\"%s: chost %s resolvedname %s ipaddr %s\", __func__,\n\t    chost, resolvedname, ipaddr);\n\n\tif (((len = strlen(chost)) > 0) && chost[len - 1] == '.') {\n\t\tdebug2(\"stripping trailing dot from chost %s\", chost);\n\t\tchost[len - 1] = '\\0';\n\t}\n\n\tif (options.hostbased_uses_name_from_packet_only) {\n\t\tif (auth_rhosts2(pw, cuser, chost, chost) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" (from packet)\",\n\t\t\t    __func__, cuser, chost);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = chost;\n\t} else {\n\t\tif (strcasecmp(resolvedname, chost) != 0)\n\t\t\tlogit(\"userauth_hostbased mismatch: \"\n\t\t\t    \"client sends %s, but we resolve %s to %s\",\n\t\t\t    chost, ipaddr, resolvedname);\n\t\tif (auth_rhosts2(pw, cuser, resolvedname, ipaddr) == 0) {\n\t\t\tdebug2(\"%s: auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" addr \\\"%.100s\\\"\",\n\t\t\t    __func__, cuser, resolvedname, ipaddr);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = resolvedname;\n\t}\n\tdebug2(\"%s: access allowed by auth_rhosts2\", __func__);\n\n\tif (sshkey_is_cert(key) &&\n\t    sshkey_cert_check_authority(key, 1, 0, lookup, &reason)) {\n\t\terror(\"%s\", reason);\n\t\tauth_debug_add(\"%s\", reason);\n\t\treturn 0;\n\t}\n\n\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t    _PATH_SSH_SYSTEM_HOSTFILE,\n\t    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);\n\n\t/* backward compat if no key has been found. */\n\tif (host_status == HOST_NEW) {\n\t\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t\t    _PATH_SSH_SYSTEM_HOSTFILE2,\n\t\t    options.ignore_user_known_hosts ? NULL :\n\t\t    _PATH_SSH_USER_HOSTFILE2);\n\t}\n\n\tif (host_status == HOST_OK) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif ((fp = sshkey_fingerprint(key->cert->signature_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted certificate ID \\\"%s\\\" signed by \"\n\t\t\t    \"%s CA %s from %s@%s\", key->cert->key_id,\n\t\t\t    sshkey_type(key->cert->signature_key), fp,\n\t\t\t    cuser, lookup);\n\t\t} else {\n\t\t\tif ((fp = sshkey_fingerprint(key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\t\t\tverbose(\"Accepted %s public key %s from %s@%s\",\n\t\t\t    sshkey_type(key), fp, cuser, lookup);\n\t\t}\n\t\tfree(fp);\n\t}\n\n\treturn (host_status == HOST_OK);\n}\n\nAuthmethod method_hostbased = {\n\t\"hostbased\",\n\tuserauth_hostbased,\n\t&options.hostbased_authentication\n};\n", "/* $OpenBSD: auth2-pubkey.c,v 1.83 2018/07/31 03:10:27 djm Exp $ */\n/*\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"compat.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"pathnames.h\"\n#include \"uidswap.h\"\n#include \"auth-options.h\"\n#include \"canohost.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"channels.h\" /* XXX for session.h */\n#include \"session.h\" /* XXX for child_set_env(); refactor? */\n\n/* import */\nextern ServerOptions options;\nextern u_char *session_id2;\nextern u_int session_id2_len;\n\nstatic char *\nformat_key(const struct sshkey *key)\n{\n\tchar *ret, *fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\n\txasprintf(&ret, \"%s %s\", sshkey_type(key), fp);\n\tfree(fp);\n\treturn ret;\n}\n\nstatic int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tstruct sshbuf *b = NULL;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n\tsize_t blen, slen;\n\tint r, pktype;\n\tint authenticated = 0;\n\tstruct sshauthopt *authopts = NULL;\n\n\tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tverbose(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: could not parse key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Refusing RSA key because client uses unsafe \"\n\t\t    \"signature scheme\");\n\t\tgoto done;\n\t}\n\tif (auth2_key_already_used(authctxt, key)) {\n\t\tlogit(\"refusing previously-used %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\",\n\t\t    __func__, sshkey_ssh_name(key));\n\t\tgoto done;\n\t}\n\n\tkey_s = format_key(key);\n\tif (sshkey_is_cert(key))\n\t\tca_s = format_key(key->cert->signature_key);\n\n\tif (have_sig) {\n\t\tdebug3(\"%s: have %s signature for %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\t\tif ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n\t\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put_string session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n\t\t/* reconstruct packet */\n\t\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t\t    authctxt->style ? \":\" : \"\",\n\t\t    authctxt->style ? authctxt->style : \"\");\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, pkalg) != 0) ||\n\t\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n\t\t\tfatal(\"%s: build packet failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\t\tsshbuf_dump(b, stderr);\n#endif\n\t\t/* test for correct signature */\n\t\tauthenticated = 0;\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n\t\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat)) == 0) {\n\t\t\tauthenticated = 1;\n\t\t}\n\t\tsshbuf_free(b);\n\t\tauth2_record_key(authctxt, authenticated, key);\n\t} else {\n\t\tdebug(\"%s: test pkalg %s pkblob %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n\t\t/* XXX fake reply and always send PK_OK ? */\n\t\t/*\n\t\t * XXX this allows testing whether a user is allowed\n\t\t * to login: if you happen to have a valid pubkey this\n\t\t * message is sent. the message is NEVER sent at all\n\t\t * if a user is not allowed to login. is this an\n\t\t * issue? -markus\n\t\t */\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n\t\t\t    != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\tauthctxt->postponed = 1;\n\t\t}\n\t}\ndone:\n\tif (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n\t\tdebug(\"%s: key options inconsistent with existing\", __func__);\n\t\tauthenticated = 0;\n\t}\n\tdebug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);\n\n\tsshauthopt_free(authopts);\n\tsshkey_free(key);\n\tfree(userstyle);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(key_s);\n\tfree(ca_s);\n\tfree(sig);\n\treturn authenticated;\n}\n\nstatic int\nmatch_principals_option(const char *principal_list, struct sshkey_cert *cert)\n{\n\tchar *result;\n\tu_int i;\n\n\t/* XXX percent_expand() sequences for authorized_principals? */\n\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif ((result = match_list(cert->principals[i],\n\t\t    principal_list, NULL)) != NULL) {\n\t\t\tdebug3(\"matched principal from key options \\\"%.100s\\\"\",\n\t\t\t    result);\n\t\t\tfree(result);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Process a single authorized_principals format line. Returns 0 and sets\n * authoptsp is principal is authorised, -1 otherwise. \"loc\" is used as a\n * log preamble for file/line information.\n */\nstatic int\ncheck_principals_line(struct ssh *ssh, char *cp, const struct sshkey_cert *cert,\n    const char *loc, struct sshauthopt **authoptsp)\n{\n\tu_int i, found = 0;\n\tchar *ep, *line_opts;\n\tconst char *reason = NULL;\n\tstruct sshauthopt *opts = NULL;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Trim trailing whitespace. */\n\tep = cp + strlen(cp) - 1;\n\twhile (ep > cp && (*ep == '\\n' || *ep == ' ' || *ep == '\\t'))\n\t\t*ep-- = '\\0';\n\n\t/*\n\t * If the line has internal whitespace then assume it has\n\t * key options.\n\t */\n\tline_opts = NULL;\n\tif ((ep = strrchr(cp, ' ')) != NULL ||\n\t    (ep = strrchr(cp, '\\t')) != NULL) {\n\t\tfor (; *ep == ' ' || *ep == '\\t'; ep++)\n\t\t\t;\n\t\tline_opts = cp;\n\t\tcp = ep;\n\t}\n\tif ((opts = sshauthopt_parse(line_opts, &reason)) == NULL) {\n\t\tdebug(\"%s: bad principals options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad principals options: %s\", loc, reason);\n\t\treturn -1;\n\t}\n\t/* Check principals in cert against those on line */\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif (strcmp(cp, cert->principals[i]) != 0)\n\t\t\tcontinue;\n\t\tdebug3(\"%s: matched principal \\\"%.100s\\\"\",\n\t\t    loc, cert->principals[i]);\n\t\tfound = 1;\n\t}\n\tif (found && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn found ? 0 : -1;\n}\n\nstatic int\nprocess_principals(struct ssh *ssh, FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire input */\n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t/* Skip blank and comment lines. */\n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_principals_line(ssh, cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tfree(line);\n\treturn found_principal;\n}\n\n/* XXX remove pw args here and elsewhere once ssh->authctxt is guaranteed */\n\nstatic int\nmatch_principals_file(struct ssh *ssh, struct passwd *pw, char *file,\n    struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint success;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\ttemporarily_use_uid(pw);\n\tdebug(\"trying authorized principals file %s\", file);\n\tif ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tsuccess = process_principals(ssh, f, file, cert, authoptsp);\n\tfclose(f);\n\trestore_uid();\n\treturn success;\n}\n\n/*\n * Checks whether principal is allowed in output of command.\n * returns 1 if the principal is allowed or 0 otherwise.\n */\nstatic int\nmatch_principals_command(struct ssh *ssh, struct passwd *user_pw,\n    const struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tconst struct sshkey_cert *cert = key->cert;\n\tFILE *f = NULL;\n\tint r, ok, found_principal = 0;\n\tint i, ac = 0, uid_swapped = 0;\n\tpid_t pid;\n\tchar *tmp, *username = NULL, *command = NULL, **av = NULL;\n\tchar *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;\n\tchar serial_s[16], uidstr[32];\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_principals_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_principals_command_user == NULL) {\n\t\terror(\"No user for AuthorizedPrincipalsCommand specified, \"\n\t\t    \"skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_principals_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_principals_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" contains \"\n\t\t    \"invalid quotes\", command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif ((ca_fp = sshkey_fingerprint(cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((key_fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsnprintf(serial_s, sizeof(serial_s), \"%llu\",\n\t    (unsigned long long)cert->serial);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"T\", sshkey_ssh_name(cert->signature_key),\n\t\t    \"f\", key_fp,\n\t\t    \"F\", ca_fp,\n\t\t    \"k\", keytext,\n\t\t    \"K\", catext,\n\t\t    \"i\", cert->key_id,\n\t\t    \"s\", serial_s,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(\"AuthorizedPrincipalsCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = process_principals(ssh, f, \"(command)\", cert, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedPrincipalsCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_principal = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(ca_fp);\n\tfree(key_fp);\n\tfree(catext);\n\tfree(keytext);\n\treturn found_principal;\n}\n\nstatic void\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}\n\n/*\n * Advanced *cpp past the end of key options, defined as the first unquoted\n * whitespace character. Returns 0 on success or -1 on failure (e.g.\n * unterminated quotes).\n */\nstatic int\nadvance_past_options(char **cpp)\n{\n\tchar *cp = *cpp;\n\tint quoted = 0;\n\n\tfor (; *cp && (quoted || (*cp != ' ' && *cp != '\\t')); cp++) {\n\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\tcp++;\t/* Skip both */\n\t\telse if (*cp == '\"')\n\t\t\tquoted = !quoted;\n\t}\n\t*cpp = cp;\n\t/* return failure for unterminated quotes */\n\treturn (*cp == '\\0' && quoted) ? -1 : 0;\n}\n\n/*\n * Check a single line of an authorized_keys-format file. Returns 0 if key\n * matches, -1 otherwise. Will return key/cert options via *authoptsp\n * on success. \"loc\" is used as file/line location in log messages.\n */\nstatic int\ncheck_authkey_line(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *cp, const char *loc, struct sshauthopt **authoptsp)\n{\n\tint want_keytype = sshkey_is_cert(key) ? KEY_UNSPEC : key->type;\n\tstruct sshkey *found = NULL;\n\tstruct sshauthopt *keyopts = NULL, *certopts = NULL, *finalopts = NULL;\n\tchar *key_options = NULL, *fp = NULL;\n\tconst char *reason = NULL;\n\tint ret = -1;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif ((found = sshkey_new(want_keytype)) == NULL) {\n\t\tdebug3(\"%s: keytype %d failed\", __func__, want_keytype);\n\t\tgoto out;\n\t}\n\n\t/* XXX djm: peek at key type in line and skip if unwanted */\n\n\tif (sshkey_read(found, &cp) != 0) {\n\t\t/* no key?  check for options */\n\t\tdebug2(\"%s: check options: '%s'\", loc, cp);\n\t\tkey_options = cp;\n\t\tif (advance_past_options(&cp) != 0) {\n\t\t\treason = \"invalid key option string\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(found, &cp) != 0) {\n\t\t\t/* still no key?  advance to next line*/\n\t\t\tdebug2(\"%s: advance: '%s'\", loc, cp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Parse key options now; we need to know if this is a CA key */\n\tif ((keyopts = sshauthopt_parse(key_options, &reason)) == NULL) {\n\t\tdebug(\"%s: bad key options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad key options: %s\", loc, reason);\n\t\tgoto out;\n\t}\n\t/* Ignore keys that don't match or incorrectly marked as CAs */\n\tif (sshkey_is_cert(key)) {\n\t\t/* Certificate; check signature key against CA */\n\t\tif (!sshkey_equal(found, key->cert->signature_key) ||\n\t\t    !keyopts->cert_authority)\n\t\t\tgoto out;\n\t} else {\n\t\t/* Plain key: check it against key found in file */\n\t\tif (!sshkey_equal(found, key) || keyopts->cert_authority)\n\t\t\tgoto out;\n\t}\n\n\t/* We have a candidate key, perform authorisation checks */\n\tif ((fp = sshkey_fingerprint(found,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\tfatal(\"%s: fingerprint failed\", __func__);\n\n\tdebug(\"%s: matching %s found: %s %s\", loc,\n\t    sshkey_is_cert(key) ? \"CA\" : \"key\", sshkey_type(found), fp);\n\n\tif (auth_authorise_keyopts(ssh, pw, keyopts,\n\t    sshkey_is_cert(key), loc) != 0) {\n\t\treason = \"Refused by key options\";\n\t\tgoto fail_reason;\n\t}\n\t/* That's all we need for plain keys. */\n\tif (!sshkey_is_cert(key)) {\n\t\tverbose(\"Accepted key %s %s found at %s\",\n\t\t    sshkey_type(found), fp, loc);\n\t\tfinalopts = keyopts;\n\t\tkeyopts = NULL;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Additional authorisation for certificates.\n\t */\n\n\t/* Parse and check options present in certificate */\n\tif ((certopts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, certopts, 0, loc) != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif ((finalopts = sshauthopt_merge(keyopts, certopts, &reason)) == NULL)\n\t\tgoto fail_reason;\n\n\t/*\n\t * If the user has specified a list of principals as\n\t * a key option, then prefer that list to matching\n\t * their username in the certificate principals list.\n\t */\n\tif (keyopts->cert_principals != NULL &&\n\t    !match_principals_option(keyopts->cert_principals, key->cert)) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (sshkey_cert_check_authority(key, 0, 0,\n\t   keyopts->cert_principals == NULL ? pw->pw_name : NULL, &reason) != 0)\n\t\tgoto fail_reason;\n\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\",\n\t    key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(found), fp, loc);\n\n success:\n\tif (finalopts == NULL)\n\t\tfatal(\"%s: internal error: missing options\", __func__);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = finalopts;\n\t\tfinalopts = NULL;\n\t}\n\t/* success */\n\tret = 0;\n\tgoto out;\n\n fail_reason:\n\terror(\"%s\", reason);\n\tauth_debug_add(\"%s\", reason);\n out:\n\tfree(fp);\n\tsshauthopt_free(keyopts);\n\tsshauthopt_free(certopts);\n\tsshauthopt_free(finalopts);\n\tsshkey_free(found);\n\treturn ret;\n}\n\n/*\n * Checks whether key is allowed in authorized_keys-format file,\n * returns 1 if the key is allowed or 0 otherwise.\n */\nstatic int\ncheck_authkeys_file(struct ssh *ssh, struct passwd *pw, FILE *f,\n    char *file, struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t/* Always consume entire file */\n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t/* Skip leading whitespace, empty and comment lines. */\n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (check_authkey_line(ssh, pw, key, cp, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\treturn found_key;\n}\n\n/* Authenticate a certificate key against TrustedUserCAKeys */\nstatic int\nuser_cert_trusted_ca(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    struct sshauthopt **authoptsp)\n{\n\tchar *ca_fp, *principals_file = NULL;\n\tconst char *reason;\n\tstruct sshauthopt *principals_opts = NULL, *cert_opts = NULL;\n\tstruct sshauthopt *final_opts = NULL;\n\tint r, ret = 0, found_principal = 0, use_authorized_principals;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)\n\t\treturn 0;\n\n\tif ((ca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tif ((r = sshkey_in_file(key->cert->signature_key,\n\t    options.trusted_user_ca_keys, 1, 0)) != 0) {\n\t\tdebug2(\"%s: CA %s %s is not listed in %s: %s\", __func__,\n\t\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t\t    options.trusted_user_ca_keys, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/*\n\t * If AuthorizedPrincipals is in use, then compare the certificate\n\t * principals against the names in that file rather than matching\n\t * against the username.\n\t */\n\tif ((principals_file = authorized_principals_file(pw)) != NULL) {\n\t\tif (match_principals_file(ssh, pw, principals_file,\n\t\t    key->cert, &principals_opts))\n\t\t\tfound_principal = 1;\n\t}\n\t/* Try querying command if specified */\n\tif (!found_principal && match_principals_command(ssh, pw, key,\n\t    &principals_opts))\n\t\tfound_principal = 1;\n\t/* If principals file or command is specified, then require a match */\n\tuse_authorized_principals = principals_file != NULL ||\n            options.authorized_principals_command != NULL;\n\tif (!found_principal && use_authorized_principals) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (use_authorized_principals && principals_opts == NULL)\n\t\tfatal(\"%s: internal error: missing principals_opts\", __func__);\n\tif (sshkey_cert_check_authority(key, 0, 1,\n\t    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)\n\t\tgoto fail_reason;\n\n\t/* Check authority from options in key and from principals file/cmd */\n\tif ((cert_opts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(ssh, pw, cert_opts, 0, \"cert\") != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (principals_opts == NULL) {\n\t\tfinal_opts = cert_opts;\n\t\tcert_opts = NULL;\n\t} else {\n\t\tif (auth_authorise_keyopts(ssh, pw, principals_opts, 0,\n\t\t    \"principals\") != 0) {\n\t\t\treason = \"Refused by certificate principals options\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tif ((final_opts = sshauthopt_merge(principals_opts,\n\t\t    cert_opts, &reason)) == NULL) {\n fail_reason:\n\t\t\terror(\"%s\", reason);\n\t\t\tauth_debug_add(\"%s\", reason);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\", key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    options.trusted_user_ca_keys);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = final_opts;\n\t\tfinal_opts = NULL;\n\t}\n\tret = 1;\n out:\n\tsshauthopt_free(principals_opts);\n\tsshauthopt_free(cert_opts);\n\tsshauthopt_free(final_opts);\n\tfree(principals_file);\n\tfree(ca_fp);\n\treturn ret;\n}\n\n/*\n * Checks whether key is allowed in file.\n * returns 1 if the key is allowed or 0 otherwise.\n */\nstatic int\nuser_key_allowed2(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    char *file, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint found_key = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\tdebug(\"trying public key file %s\", file);\n\tif ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {\n\t\tfound_key = check_authkeys_file(ssh, pw, f, file,\n\t\t    key, authoptsp);\n\t\tfclose(f);\n\t}\n\n\trestore_uid();\n\treturn found_key;\n}\n\n/*\n * Checks whether key is allowed in output of command.\n * returns 1 if the key is allowed or 0 otherwise.\n */\nstatic int\nuser_key_command_allowed2(struct ssh *ssh, struct passwd *user_pw,\n    struct sshkey *key, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tFILE *f = NULL;\n\tint r, ok, found_key = 0;\n\tint i, uid_swapped = 0, ac = 0;\n\tpid_t pid;\n\tchar *username = NULL, *key_fp = NULL, *keytext = NULL;\n\tchar uidstr[32], *tmp, *command = NULL, **av = NULL;\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_keys_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_keys_command_user == NULL) {\n\t\terror(\"No user for AuthorizedKeysCommand specified, skipping\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * NB. all returns later this function should go via \"out\" to\n\t * ensure the original SIGCHLD handler is restored properly.\n\t */\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\n\t/* Prepare and verify the user for the command */\n\tusername = percent_expand(options.authorized_keys_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* Prepare AuthorizedKeysCommand */\n\tif ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror(\"%s: sshkey_to_base64 failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Turn the command into an argument vector */\n\tif (argv_split(options.authorized_keys_command, &ac, &av) != 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\",\n\t\t    command);\n\t\tgoto out;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"f\", key_fp,\n\t\t    \"k\", keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal(\"%s: percent_expand failed\", __func__);\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t/* Prepare a printable command for logs, etc. */\n\tcommand = argv_assemble(ac, av);\n\n\t/*\n\t * If AuthorizedKeysCommand was run without arguments\n\t * then fall back to the old behaviour of passing the\n\t * target username as a single argument.\n\t */\n\tif (ac == 1) {\n\t\tav = xreallocarray(av, ac + 2, sizeof(*av));\n\t\tav[1] = xstrdup(user_pw->pw_name);\n\t\tav[2] = NULL;\n\t\t/* Fix up command too, since it is used in log messages */\n\t\tfree(command);\n\t\txasprintf(&command, \"%s %s\", av[0], av[1]);\n\t}\n\n\tif ((pid = subprocess(\"AuthorizedKeysCommand\", runas_pw, command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = check_authkeys_file(ssh, user_pw, f,\n\t    options.authorized_keys_command, key, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedKeysCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t/* Read completed successfully */\n\tfound_key = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tsignal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(key_fp);\n\tfree(keytext);\n\treturn found_key;\n}\n\n/*\n * Check whether key authenticates and authorises the user.\n */\nint\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}\n\nAuthmethod method_pubkey = {\n\t\"publickey\",\n\tuserauth_pubkey,\n\t&options.pubkey_authentication\n};\n"], "filenames": ["usr.bin/ssh/auth2-gss.c", "usr.bin/ssh/auth2-hostbased.c", "usr.bin/ssh/auth2-pubkey.c"], "buggy_code_start_loc": [1, 1, 1], "buggy_code_end_loc": [100, 115, 237], "fixing_code_start_loc": [1, 1, 1], "fixing_code_end_loc": [104, 117, 243], "type": "CWE-362", "message": "OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.", "other": {"cve": {"id": "CVE-2018-15473", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-17T19:29:00.223", "lastModified": "2023-02-23T23:13:42.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c."}, {"lang": "es", "value": "OpenSSH hasta la versi\u00f3n 7.7 es propenso a una vulnerabilidad de enumeraci\u00f3n de usuarios debido a que no retrasa el rescate de un usuario de autenticaci\u00f3n no v\u00e1lido hasta que el paquete que contiene la petici\u00f3n haya sido analizado completamente. Esto est\u00e1 relacionado con auth2-gss.c, auth2-hostbased.c, y auth2-pubkey.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.7", "matchCriteriaId": "FC6DE0EB-7AC6-47A3-9759-43FFF9268312"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:cn1610_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "EB30733E-68FC-49C4-86C0-7FEE75C366BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:cn1610:-:*:*:*:*:*:*:*", "matchCriteriaId": "6361DAC6-600F-4B15-8797-D67F298F46FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C0ADE5D-F91D-4E0D-B6C5-3511B19665F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_ontap_edge:-:*:*:*:*:*:*:*", "matchCriteriaId": "E0C4B1E5-75BF-43AE-BBAC-0DD4124C71ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:fas_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "6DD5AF44-1C16-4F25-84C1-8AE3CD89B7B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_unified_manager:*:*:*:*:*:vsphere:*:*", "versionStartIncluding": "9.4", "matchCriteriaId": "7E49ACFC-FD48-4ED7-86E8-68B5B753852C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy:-:*:*:*:*:*:*:*", "matchCriteriaId": "7E968916-8CE0-4165-851F-14E37ECEA948"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:service_processor:-:*:*:*:*:*:*:*", "matchCriteriaId": "146A767F-DC04-454B-9913-17D3A2B5AAA4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:virtual_storage_console:*:*:*:*:*:vsphere:*:*", "versionStartIncluding": "7.2", "matchCriteriaId": "066C2961-E9C4-418E-82AF-1A7C35D5C085"}, {"vulnerable": true, "criteria": "cpe:2.3:o:netapp:clustered_data_ontap:-:*:*:*:*:*:*:*", "matchCriteriaId": "1FED6CAE-D97F-49E0-9D00-1642A3A427B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:netapp:data_ontap:-:*:*:*:*:7-mode:*:*", "matchCriteriaId": "392A1364-2739-450D-9E19-DFF93081C2C6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:vasa_provider:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.2", "matchCriteriaId": "B65B11A5-728E-4952-824E-051DFC00259B"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:netapp:clustered_data_ontap:-:*:*:*:*:*:*:*", "matchCriteriaId": "1FED6CAE-D97F-49E0-9D00-1642A3A427B4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:storage_replication_adapter:*:*:*:*:*:vsphere:*:*", "versionStartIncluding": "7.2", "matchCriteriaId": "5717C329-984A-4A42-8FA6-7B4CF1D6F2D3"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:netapp:clustered_data_ontap:-:*:*:*:*:*:*:*", "matchCriteriaId": "1FED6CAE-D97F-49E0-9D00-1642A3A427B4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:sun_zfs_storage_appliance_kit:8.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "517A2282-C254-49EB-A52D-FC2B45E70ADD"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:scalance_x204rna_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.7", "matchCriteriaId": "0D3A0312-1249-4257-98F1-57E8959989C5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:scalance_x204rna:-:*:*:*:*:*:*:*", "matchCriteriaId": "EA8B483F-0FD2-49F8-A86A-672A6E007949"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2018/08/15/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/105140", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1041487", "source": "cve@mitre.org", "tags": ["Broken Link", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0711", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2143", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.debian.org/906236", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-412672.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2018-0011", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20181101-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3809-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4280", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/45210/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.exploit-db.com/exploits/45233/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.exploit-db.com/exploits/45939/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"}}