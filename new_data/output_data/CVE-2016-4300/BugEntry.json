{"buggy_code": ["/*-\n * Copyright (c) 2011 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD$\");\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_BZLIB_H\n#include <bzlib.h>\n#endif\n#ifdef HAVE_LZMA_H\n#include <lzma.h>\n#endif\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_ppmd7_private.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n#include \"archive_endian.h\"\n\n#ifndef HAVE_ZLIB_H\n#include \"archive_crc32.h\"\n#endif\n\n#define _7ZIP_SIGNATURE\t\"7z\\xBC\\xAF\\x27\\x1C\"\n#define SFX_MIN_ADDR\t0x27000\n#define SFX_MAX_ADDR\t0x60000\n\n\n/*\n * Codec ID\n */\n#define _7Z_COPY\t0\n#define _7Z_LZMA\t0x030101\n#define _7Z_LZMA2\t0x21\n#define _7Z_DEFLATE\t0x040108\n#define _7Z_BZ2\t\t0x040202\n#define _7Z_PPMD\t0x030401\n#define _7Z_DELTA\t0x03\n#define _7Z_CRYPTO_MAIN_ZIP\t\t\t0x06F10101 /* Main Zip crypto algo */\n#define _7Z_CRYPTO_RAR_29\t\t\t0x06F10303 /* Rar29 AES-128 + (modified SHA-1) */\n#define _7Z_CRYPTO_AES_256_SHA_256\t0x06F10701 /* AES-256 + SHA-256 */\n\n\n#define _7Z_X86\t\t0x03030103\n#define _7Z_X86_BCJ2\t0x0303011B\n#define _7Z_POWERPC\t0x03030205\n#define _7Z_IA64\t0x03030401\n#define _7Z_ARM\t\t0x03030501\n#define _7Z_ARMTHUMB\t0x03030701\n#define _7Z_SPARC\t0x03030805\n\n/*\n * 7-Zip header property IDs.\n */\n#define kEnd\t\t\t0x00\n#define kHeader\t\t\t0x01\n#define kArchiveProperties\t0x02\n#define kAdditionalStreamsInfo\t0x03\n#define kMainStreamsInfo\t0x04\n#define kFilesInfo\t\t0x05\n#define kPackInfo\t\t0x06\n#define kUnPackInfo\t\t0x07\n#define kSubStreamsInfo\t\t0x08\n#define kSize\t\t\t0x09\n#define kCRC\t\t\t0x0A\n#define kFolder\t\t\t0x0B\n#define kCodersUnPackSize\t0x0C\n#define kNumUnPackStream\t0x0D\n#define kEmptyStream\t\t0x0E\n#define kEmptyFile\t\t0x0F\n#define kAnti\t\t\t0x10\n#define kName\t\t\t0x11\n#define kCTime\t\t\t0x12\n#define kATime\t\t\t0x13\n#define kMTime\t\t\t0x14\n#define kAttributes\t\t0x15\n#define kEncodedHeader\t\t0x17\n#define kDummy\t\t\t0x19\n\nstruct _7z_digests {\n\tunsigned char\t*defineds;\n\tuint32_t\t*digests;\n};\n\n\nstruct _7z_folder {\n\tuint64_t\t\t numCoders;\n\tstruct _7z_coder {\n\t\tunsigned long\t codec;\n\t\tuint64_t\t numInStreams;\n\t\tuint64_t\t numOutStreams;\n\t\tuint64_t\t propertiesSize;\n\t\tunsigned char\t*properties;\n\t} *coders;\n\tuint64_t\t\t numBindPairs;\n\tstruct {\n\t\tuint64_t\t inIndex;\n\t\tuint64_t\t outIndex;\n\t} *bindPairs;\n\tuint64_t\t\t numPackedStreams;\n\tuint64_t\t\t*packedStreams;\n\tuint64_t\t\t numInStreams;\n\tuint64_t\t\t numOutStreams;\n\tuint64_t\t\t*unPackSize;\n\tunsigned char\t\t digest_defined;\n\tuint32_t\t\t digest;\n\tuint64_t\t\t numUnpackStreams;\n\tuint32_t\t\t packIndex;\n\t/* Unoperated bytes. */\n\tuint64_t\t\t skipped_bytes;\n};\n\nstruct _7z_coders_info {\n\tuint64_t\t\t numFolders;\n\tstruct _7z_folder\t*folders;\n\tuint64_t\t\t dataStreamIndex;\n};\n\nstruct _7z_pack_info {\n\tuint64_t\t\t pos;\n\tuint64_t\t\t numPackStreams;\n\tuint64_t\t\t*sizes;\n\tstruct _7z_digests\t digest;\n\t/* Calculated from pos and numPackStreams. */\n\tuint64_t\t\t*positions;\n};\n\nstruct _7z_substream_info {\n\tsize_t\t\t\t unpack_streams;\n\tuint64_t\t\t*unpackSizes;\n\tunsigned char\t\t*digestsDefined;\n\tuint32_t\t\t*digests;\n};\n\nstruct _7z_stream_info {\n\tstruct _7z_pack_info\t pi;\n\tstruct _7z_coders_info\t ci;\n\tstruct _7z_substream_info ss;\n};\n\nstruct _7z_header_info {\n\tuint64_t\t\t dataIndex;\n\n\tunsigned char\t\t*emptyStreamBools;\n\tunsigned char\t\t*emptyFileBools;\n\tunsigned char\t\t*antiBools;\n\tunsigned char\t\t*attrBools;\n};\n\nstruct _7zip_entry {\n\tsize_t\t\t\t name_len;\n\tunsigned char\t\t*utf16name;\n#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)\n\tconst wchar_t\t\t*wname;\n#endif\n\tuint32_t\t\t folderIndex;\n\tuint32_t\t\t ssIndex;\n\tunsigned\t\t flg;\n#define MTIME_IS_SET\t(1<<0)\n#define ATIME_IS_SET\t(1<<1)\n#define CTIME_IS_SET\t(1<<2)\n#define CRC32_IS_SET\t(1<<3)\n#define HAS_STREAM\t(1<<4)\n\n\ttime_t\t\t\t mtime;\n\ttime_t\t\t\t atime;\n\ttime_t\t\t\t ctime;\n\tlong\t\t\t mtime_ns;\n\tlong\t\t\t atime_ns;\n\tlong\t\t\t ctime_ns;\n\tuint32_t\t\t mode;\n\tuint32_t\t\t attr;\n};\n\nstruct _7zip {\n\t/* Structural information about the archive. */\n\tstruct _7z_stream_info\t si;\n\n\tint\t\t\t header_is_being_read;\n\tint\t\t\t header_is_encoded;\n\tuint64_t\t\t header_bytes_remaining;\n\tunsigned long\t\t header_crc32;\n\t/* Header offset to check that reading pointes of the file contens\n\t * will not exceed the header. */\n\tuint64_t\t\t header_offset;\n\t/* Base offset of the archive file for a seek in case reading SFX. */\n\tuint64_t\t\t seek_base;\n\n\t/* List of entries */\n\tsize_t\t\t\t entries_remaining;\n\tuint64_t\t\t numFiles;\n\tstruct _7zip_entry\t*entries;\n\tstruct _7zip_entry\t*entry;\n\tunsigned char\t\t*entry_names;\n\n\t/* entry_bytes_remaining is the number of bytes we expect. */\n\tint64_t\t\t\t entry_offset;\n\tuint64_t\t\t entry_bytes_remaining;\n\n\t/* Running CRC32 of the decompressed data */\n\tunsigned long\t\t entry_crc32;\n\n\t/* Flags to mark progress of decompression. */\n\tchar\t\t\t end_of_entry;\n\n\t/* Uncompressed buffer control.  */\n#define UBUFF_SIZE\t(64 * 1024)\n\tunsigned char \t\t*uncompressed_buffer;\n\tunsigned char \t\t*uncompressed_buffer_pointer;\n\tsize_t \t\t\t uncompressed_buffer_size;\n\tsize_t\t\t\t uncompressed_buffer_bytes_remaining;\n\n\t/* Offset of the compressed data. */\n\tint64_t\t\t\t stream_offset;\n\n\t/*\n\t * Decompressing control data.\n\t */\n\tunsigned\t\t folder_index;\n\tuint64_t\t\t folder_outbytes_remaining;\n\tunsigned\t\t pack_stream_index;\n\tunsigned\t\t pack_stream_remaining;\n\tuint64_t\t\t pack_stream_inbytes_remaining;\n\tsize_t\t\t\t pack_stream_bytes_unconsumed;\n\n\t/* The codec information of a folder. */\n\tunsigned long\t\t codec;\n\tunsigned long\t\t codec2;\n\n\t/*\n\t * Decompressor controllers.\n\t */\n\t/* Decording LZMA1 and LZMA2 data. */\n#ifdef HAVE_LZMA_H\n\tlzma_stream\t\t lzstream;\n\tint\t\t\t lzstream_valid;\n#endif\n\t/* Decording bzip2 data. */\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tbz_stream\t\t bzstream;\n\tint\t\t\t bzstream_valid;\n#endif\n\t/* Decording deflate data. */\n#ifdef HAVE_ZLIB_H\n\tz_stream\t\t stream;\n\tint\t\t\t stream_valid;\n#endif\n\t/* Decording PPMd data. */\n\tint\t\t\t ppmd7_stat;\n\tCPpmd7\t\t\t ppmd7_context;\n\tCPpmd7z_RangeDec\t range_dec;\n\tIByteIn\t\t\t bytein;\n\tstruct {\n\t\tconst unsigned char\t*next_in;\n\t\tint64_t\t\t\t avail_in;\n\t\tint64_t\t\t\t total_in;\n\t\tunsigned char\t\t*next_out;\n\t\tint64_t\t\t\t avail_out;\n\t\tint64_t\t\t\t total_out;\n\t\tint\t\t\t overconsumed;\n\t} ppstream;\n\tint\t\t\t ppmd7_valid;\n\n\t/* Decoding BCJ and BCJ2 data. */\n\tuint32_t\t\t bcj_state;\n\tsize_t\t\t\t odd_bcj_size;\n\tunsigned char\t\t odd_bcj[4];\n\t/* Decoding BCJ data. */\n\tsize_t\t\t\t bcj_prevPosT;\n\tuint32_t\t\t bcj_prevMask;\n\tuint32_t\t\t bcj_ip;\n\n\t/* Decoding BCJ2 data. */\n\tsize_t\t\t\t main_stream_bytes_remaining;\n\tunsigned char\t\t*sub_stream_buff[3];\n\tsize_t\t\t\t sub_stream_size[3];\n\tsize_t\t\t\t sub_stream_bytes_remaining[3];\n\tunsigned char\t\t*tmp_stream_buff;\n\tsize_t\t\t\t tmp_stream_buff_size;\n\tsize_t\t\t\t tmp_stream_bytes_avail;\n\tsize_t\t\t\t tmp_stream_bytes_remaining;\n#ifdef _LZMA_PROB32\n#define CProb uint32_t\n#else\n#define CProb uint16_t\n#endif\n\tCProb\t\t\t bcj2_p[256 + 2];\n\tuint8_t\t\t\t bcj2_prevByte;\n\tuint32_t\t\t bcj2_range;\n\tuint32_t\t\t bcj2_code;\n\tuint64_t\t\t bcj2_outPos;\n\n\t/* Filename character-set conversion data. */\n\tstruct archive_string_conv *sconv;\n\n\tchar\t\t\t format_name[64];\n\n\t/* Custom value that is non-zero if this archive contains encrypted entries. */\n\tint\t\t\t has_encrypted_entries;\n};\n\n/* Maximum entry size. This limitation prevents reading intentional\n * corrupted 7-zip files on assuming there are not so many entries in\n * the files. */\n#define UMAX_ENTRY\tARCHIVE_LITERAL_ULL(100000000)\n\nstatic int\tarchive_read_format_7zip_has_encrypted_entries(struct archive_read *);\nstatic int\tarchive_read_support_format_7zip_capabilities(struct archive_read *a);\nstatic int\tarchive_read_format_7zip_bid(struct archive_read *, int);\nstatic int\tarchive_read_format_7zip_cleanup(struct archive_read *);\nstatic int\tarchive_read_format_7zip_read_data(struct archive_read *,\n\t\t    const void **, size_t *, int64_t *);\nstatic int\tarchive_read_format_7zip_read_data_skip(struct archive_read *);\nstatic int\tarchive_read_format_7zip_read_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int\tcheck_7zip_header_in_sfx(const char *);\nstatic unsigned long decode_codec_id(const unsigned char *, size_t);\nstatic int\tdecode_encoded_header_info(struct archive_read *,\n\t\t    struct _7z_stream_info *);\nstatic int\tdecompress(struct archive_read *, struct _7zip *,\n\t\t    void *, size_t *, const void *, size_t *);\nstatic ssize_t\textract_pack_stream(struct archive_read *, size_t);\nstatic void\tfileTimeToUtc(uint64_t, time_t *, long *);\nstatic uint64_t folder_uncompressed_size(struct _7z_folder *);\nstatic void\tfree_CodersInfo(struct _7z_coders_info *);\nstatic void\tfree_Digest(struct _7z_digests *);\nstatic void\tfree_Folder(struct _7z_folder *);\nstatic void\tfree_Header(struct _7z_header_info *);\nstatic void\tfree_PackInfo(struct _7z_pack_info *);\nstatic void\tfree_StreamsInfo(struct _7z_stream_info *);\nstatic void\tfree_SubStreamsInfo(struct _7z_substream_info *);\nstatic int\tfree_decompression(struct archive_read *, struct _7zip *);\nstatic ssize_t\tget_uncompressed_data(struct archive_read *, const void **,\n\t\t    size_t, size_t);\nstatic const unsigned char * header_bytes(struct archive_read *, size_t);\nstatic int\tinit_decompression(struct archive_read *, struct _7zip *,\n\t\t    const struct _7z_coder *, const struct _7z_coder *);\nstatic int\tparse_7zip_uint64(struct archive_read *, uint64_t *);\nstatic int\tread_Bools(struct archive_read *, unsigned char *, size_t);\nstatic int\tread_CodersInfo(struct archive_read *,\n\t\t    struct _7z_coders_info *);\nstatic int\tread_Digests(struct archive_read *, struct _7z_digests *,\n\t\t    size_t);\nstatic int\tread_Folder(struct archive_read *, struct _7z_folder *);\nstatic int\tread_Header(struct archive_read *, struct _7z_header_info *,\n\t\t    int);\nstatic int\tread_PackInfo(struct archive_read *, struct _7z_pack_info *);\nstatic int\tread_StreamsInfo(struct archive_read *,\n\t\t    struct _7z_stream_info *);\nstatic int\tread_SubStreamsInfo(struct archive_read *,\n\t\t    struct _7z_substream_info *, struct _7z_folder *, size_t);\nstatic int\tread_Times(struct archive_read *, struct _7z_header_info *,\n\t\t    int);\nstatic void\tread_consume(struct archive_read *);\nstatic ssize_t\tread_stream(struct archive_read *, const void **, size_t,\n\t\t    size_t);\nstatic int\tseek_pack(struct archive_read *);\nstatic int64_t\tskip_stream(struct archive_read *, size_t);\nstatic int\tskip_sfx(struct archive_read *, ssize_t);\nstatic int\tslurp_central_directory(struct archive_read *, struct _7zip *,\n\t\t    struct _7z_header_info *);\nstatic int\tsetup_decode_folder(struct archive_read *, struct _7z_folder *,\n\t\t    int);\nstatic void\tx86_Init(struct _7zip *);\nstatic size_t\tx86_Convert(struct _7zip *, uint8_t *, size_t);\nstatic ssize_t\t\tBcj2_Decode(struct _7zip *, uint8_t *, size_t);\n\n\nint\narchive_read_support_format_7zip(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct _7zip *zip;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_7zip\");\n\n\tzip = calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate 7zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\n\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"7zip\",\n\t    archive_read_format_7zip_bid,\n\t    NULL,\n\t    archive_read_format_7zip_read_header,\n\t    archive_read_format_7zip_read_data,\n\t    archive_read_format_7zip_read_data_skip,\n\t    NULL,\n\t    archive_read_format_7zip_cleanup,\n\t    archive_read_support_format_7zip_capabilities,\n\t    archive_read_format_7zip_has_encrypted_entries);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_support_format_7zip_capabilities(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |\n\t\t\tARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\n\nstatic int\narchive_read_format_7zip_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct _7zip * zip = (struct _7zip *)_a->format->data;\n\t\tif (zip) {\n\t\t\treturn zip->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}\n\nstatic int\narchive_read_format_7zip_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\n\t/* If someone has already bid more than 32, then avoid\n\t   trashing the look-ahead buffers with a seek. */\n\tif (best_bid > 32)\n\t\treturn (-1);\n\n\tif ((p = __archive_read_ahead(a, 6, NULL)) == NULL)\n\t\treturn (0);\n\n\t/* If first six bytes are the 7-Zip signature,\n\t * return the bid right now. */\n\tif (memcmp(p, _7ZIP_SIGNATURE, 6) == 0)\n\t\treturn (48);\n\n\t/*\n\t * It may a 7-Zip SFX archive file. If first two bytes are\n\t * 'M' and 'Z' available on Windows or first four bytes are\n\t * \"\\x7F\\x45LF\" available on posix like system, seek the 7-Zip\n\t * signature. Although we will perform a seek when reading\n\t * a header, what we do not use __archive_read_seek() here is\n\t * due to a bidding performance.\n\t */\n\tif ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0) {\n\t\tssize_t offset = SFX_MIN_ADDR;\n\t\tssize_t window = 4096;\n\t\tssize_t bytes_avail;\n\t\twhile (offset + window <= (SFX_MAX_ADDR)) {\n\t\t\tconst char *buff = __archive_read_ahead(a,\n\t\t\t\t\toffset + window, &bytes_avail);\n\t\t\tif (buff == NULL) {\n\t\t\t\t/* Remaining bytes are less than window. */\n\t\t\t\twindow >>= 1;\n\t\t\t\tif (window < 0x40)\n\t\t\t\t\treturn (0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = buff + offset;\n\t\t\twhile (p + 32 < buff + bytes_avail) {\n\t\t\t\tint step = check_7zip_header_in_sfx(p);\n\t\t\t\tif (step == 0)\n\t\t\t\t\treturn (48);\n\t\t\t\tp += step;\n\t\t\t}\n\t\t\toffset = p - buff;\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\ncheck_7zip_header_in_sfx(const char *p)\n{\n\tswitch ((unsigned char)p[5]) {\n\tcase 0x1C:\n\t\tif (memcmp(p, _7ZIP_SIGNATURE, 6) != 0)\n\t\t\treturn (6);\n\t\t/*\n\t\t * Test the CRC because its extraction code has 7-Zip\n\t\t * Magic Code, so we should do this in order not to\n\t\t * make a mis-detection.\n\t\t */\n\t\tif (crc32(0, (const unsigned char *)p + 12, 20)\n\t\t\t!= archive_le32dec(p + 8))\n\t\t\treturn (6);\n\t\t/* Hit the header! */\n\t\treturn (0);\n\tcase 0x37: return (5);\n\tcase 0x7A: return (4);\n\tcase 0xBC: return (3);\n\tcase 0xAF: return (2);\n\tcase 0x27: return (1);\n\tdefault: return (6);\n\t}\n}\n\nstatic int\nskip_sfx(struct archive_read *a, ssize_t bytes_avail)\n{\n\tconst void *h;\n\tconst char *p, *q;\n\tsize_t skip, offset;\n\tssize_t bytes, window;\n\n\t/*\n\t * If bytes_avail > SFX_MIN_ADDR we do not have to call\n\t * __archive_read_seek() at this time since we have\n\t * alredy had enough data.\n\t */\n\tif (bytes_avail > SFX_MIN_ADDR)\n\t\t__archive_read_consume(a, SFX_MIN_ADDR);\n\telse if (__archive_read_seek(a, SFX_MIN_ADDR, SEEK_SET) < 0)\n\t\treturn (ARCHIVE_FATAL);\n\n\toffset = 0;\n\twindow = 1;\n\twhile (offset + window <= SFX_MAX_ADDR - SFX_MIN_ADDR) {\n\t\th = __archive_read_ahead(a, window, &bytes);\n\t\tif (h == NULL) {\n\t\t\t/* Remaining bytes are less than window. */\n\t\t\twindow >>= 1;\n\t\t\tif (window < 0x40)\n\t\t\t\tgoto fatal;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bytes < 6) {\n\t\t\t/* This case might happen when window == 1. */\n\t\t\twindow = 4096;\n\t\t\tcontinue;\n\t\t}\n\t\tp = (const char *)h;\n\t\tq = p + bytes;\n\n\t\t/*\n\t\t * Scan ahead until we find something that looks\n\t\t * like the 7-Zip header.\n\t\t */\n\t\twhile (p + 32 < q) {\n\t\t\tint step = check_7zip_header_in_sfx(p);\n\t\t\tif (step == 0) {\n\t\t\t\tstruct _7zip *zip =\n\t\t\t\t    (struct _7zip *)a->format->data;\n\t\t\t\tskip = p - (const char *)h;\n\t\t\t\t__archive_read_consume(a, skip);\n\t\t\t\tzip->seek_base = SFX_MIN_ADDR + offset + skip;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tp += step;\n\t\t}\n\t\tskip = p - (const char *)h;\n\t\t__archive_read_consume(a, skip);\n\t\toffset += skip;\n\t\tif (window == 1)\n\t\t\twindow = 4096;\n\t}\nfatal:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Couldn't find out 7-Zip header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_7zip_read_header(struct archive_read *a,\n\tstruct archive_entry *entry)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tstruct _7zip_entry *zip_entry;\n\tint r, ret = ARCHIVE_OK;\n\tstruct _7z_folder *folder = 0;\n\tuint64_t fidx = 0;\n\n\t/*\n\t * It should be sufficient to call archive_read_next_header() for\n\t * a reader to determine if an entry is encrypted or not. If the\n\t * encryption of an entry is only detectable when calling\n\t * archive_read_data(), so be it. We'll do the same check there\n\t * as well.\n\t */\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_7ZIP;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"7-Zip\";\n\n\tif (zip->entries == NULL) {\n\t\tstruct _7z_header_info header;\n\n\t\tmemset(&header, 0, sizeof(header));\n\t\tr = slurp_central_directory(a, zip, &header);\n\t\tfree_Header(&header);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tzip->entries_remaining = (size_t)zip->numFiles;\n\t\tzip->entry = zip->entries;\n\t} else {\n\t\t++zip->entry;\n\t}\n\tzip_entry = zip->entry;\n\n\tif (zip->entries_remaining <= 0 || zip_entry == NULL)\n\t\treturn ARCHIVE_EOF;\n\t--zip->entries_remaining;\n\n\tzip->entry_offset = 0;\n\tzip->end_of_entry = 0;\n\tzip->entry_crc32 = crc32(0, NULL, 0);\n\n\t/* Setup a string conversion for a filename. */\n\tif (zip->sconv == NULL) {\n\t\tzip->sconv = archive_string_conversion_from_charset(\n\t\t    &a->archive, \"UTF-16LE\", 1);\n\t\tif (zip->sconv == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Figure out if the entry is encrypted by looking at the folder\n\t   that is associated to the current 7zip entry. If the folder\n\t   has a coder with a _7Z_CRYPTO codec then the folder is encrypted.\n\t   Hence the entry must also be encrypted. */\n\tif (zip_entry && zip_entry->folderIndex < zip->si.ci.numFolders) {\n\t\tfolder = &(zip->si.ci.folders[zip_entry->folderIndex]);\n\t\tfor (fidx=0; folder && fidx<folder->numCoders; fidx++) {\n\t\t\tswitch(folder->coders[fidx].codec) {\n\t\t\t\tcase _7Z_CRYPTO_MAIN_ZIP:\n\t\t\t\tcase _7Z_CRYPTO_RAR_29:\n\t\t\t\tcase _7Z_CRYPTO_AES_256_SHA_256: {\n\t\t\t\t\tarchive_entry_set_is_data_encrypted(entry, 1);\n\t\t\t\t\tzip->has_encrypted_entries = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Now that we've checked for encryption, if there were still no\n\t * encrypted entries found we can say for sure that there are none.\n\t */\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\tif (archive_entry_copy_pathname_l(entry,\n\t    (const char *)zip_entry->utf16name,\n\t    zip_entry->name_len, zip->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted \"\n\t\t    \"from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(zip->sconv));\n\t\tret = ARCHIVE_WARN;\n\t}\n\n\t/* Populate some additional entry fields: */\n\tarchive_entry_set_mode(entry, zip_entry->mode);\n\tif (zip_entry->flg & MTIME_IS_SET)\n\t\tarchive_entry_set_mtime(entry, zip_entry->mtime,\n\t\t\tzip_entry->mtime_ns);\n\tif (zip_entry->flg & CTIME_IS_SET)\n\t\tarchive_entry_set_ctime(entry, zip_entry->ctime,\n\t\t    zip_entry->ctime_ns);\n\tif (zip_entry->flg & ATIME_IS_SET)\n\t\tarchive_entry_set_atime(entry, zip_entry->atime,\n\t\t    zip_entry->atime_ns);\n\tif (zip_entry->ssIndex != (uint32_t)-1) {\n\t\tzip->entry_bytes_remaining =\n\t\t    zip->si.ss.unpackSizes[zip_entry->ssIndex];\n\t\tarchive_entry_set_size(entry, zip->entry_bytes_remaining);\n\t} else {\n\t\tzip->entry_bytes_remaining = 0;\n\t\tarchive_entry_set_size(entry, 0);\n\t}\n\n\t/* If there's no body, force read_data() to return EOF immediately. */\n\tif (zip->entry_bytes_remaining < 1)\n\t\tzip->end_of_entry = 1;\n\n\tif ((zip_entry->mode & AE_IFMT) == AE_IFLNK) {\n\t\tunsigned char *symname = NULL;\n\t\tsize_t symsize = 0;\n\n\t\t/*\n\t\t * Symbolic-name is recorded as its contents. We have to\n\t\t * read the contents at this time.\n\t\t */\n\t\twhile (zip->entry_bytes_remaining > 0) {\n\t\t\tconst void *buff;\n\t\t\tunsigned char *mem;\n\t\t\tsize_t size;\n\t\t\tint64_t offset;\n\n\t\t\tr = archive_read_format_7zip_read_data(a, &buff,\n\t\t\t\t&size, &offset);\n\t\t\tif (r < ARCHIVE_WARN) {\n\t\t\t\tfree(symname);\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t\tmem = realloc(symname, symsize + size + 1);\n\t\t\tif (mem == NULL) {\n\t\t\t\tfree(symname);\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Symname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tsymname = mem;\n\t\t\tmemcpy(symname+symsize, buff, size);\n\t\t\tsymsize += size;\n\t\t}\n\t\tif (symsize == 0) {\n\t\t\t/* If there is no synname, handle it as a regular\n\t\t\t * file. */\n\t\t\tzip_entry->mode &= ~AE_IFMT;\n\t\t\tzip_entry->mode |= AE_IFREG;\n\t\t\tarchive_entry_set_mode(entry, zip_entry->mode);\n\t\t} else {\n\t\t\tsymname[symsize] = '\\0';\n\t\t\tarchive_entry_copy_symlink(entry,\n\t\t\t    (const char *)symname);\n\t\t}\n\t\tfree(symname);\n\t\tarchive_entry_set_size(entry, 0);\n\t}\n\n\t/* Set up a more descriptive format name. */\n\tsprintf(zip->format_name, \"7-Zip\");\n\ta->archive.archive_format_name = zip->format_name;\n\n\treturn (ret);\n}\n\nstatic int\narchive_read_format_7zip_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tstruct _7zip *zip;\n\tssize_t bytes;\n\tint ret = ARCHIVE_OK;\n\n\tzip = (struct _7zip *)(a->format->data);\n\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\tif (zip->pack_stream_bytes_unconsumed)\n\t\tread_consume(a);\n\n\t*offset = zip->entry_offset;\n\t*size = 0;\n\t*buff = NULL;\n\t/*\n\t * If we hit end-of-entry last time, clean up and return\n\t * ARCHIVE_EOF this time.\n\t */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_EOF);\n\n\tbytes = read_stream(a, buff,\n\t\t(size_t)zip->entry_bytes_remaining, 0);\n\tif (bytes < 0)\n\t\treturn ((int)bytes);\n\tif (bytes == 0) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated 7-Zip file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->entry_bytes_remaining -= bytes;\n\tif (zip->entry_bytes_remaining == 0)\n\t\tzip->end_of_entry = 1;\n\n\t/* Update checksum */\n\tif ((zip->entry->flg & CRC32_IS_SET) && bytes)\n\t\tzip->entry_crc32 = crc32(zip->entry_crc32, *buff,\n\t\t    (unsigned)bytes);\n\n\t/* If we hit the end, swallow any end-of-data marker. */\n\tif (zip->end_of_entry) {\n\t\t/* Check computed CRC against file contents. */\n\t\tif ((zip->entry->flg & CRC32_IS_SET) &&\n\t\t\tzip->si.ss.digests[zip->entry->ssIndex] !=\n\t\t    zip->entry_crc32) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"7-Zip bad CRC: 0x%lx should be 0x%lx\",\n\t\t\t    (unsigned long)zip->entry_crc32,\n\t\t\t    (unsigned long)zip->si.ss.digests[\n\t\t\t    \t\tzip->entry->ssIndex]);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\n\t*size = bytes;\n\t*offset = zip->entry_offset;\n\tzip->entry_offset += bytes;\n\n\treturn (ret);\n}\n\nstatic int\narchive_read_format_7zip_read_data_skip(struct archive_read *a)\n{\n\tstruct _7zip *zip;\n\tint64_t bytes_skipped;\n\n\tzip = (struct _7zip *)(a->format->data);\n\n\tif (zip->pack_stream_bytes_unconsumed)\n\t\tread_consume(a);\n\n\t/* If we've already read to end of data, we're done. */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * If the length is at the beginning, we can skip the\n\t * compressed data much more quickly.\n\t */\n\tbytes_skipped = skip_stream(a, (size_t)zip->entry_bytes_remaining);\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\tzip->entry_bytes_remaining = 0;\n\n\t/* This entry is finished and done. */\n\tzip->end_of_entry = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_7zip_cleanup(struct archive_read *a)\n{\n\tstruct _7zip *zip;\n\n\tzip = (struct _7zip *)(a->format->data);\n\tfree_StreamsInfo(&(zip->si));\n\tfree(zip->entries);\n\tfree(zip->entry_names);\n\tfree_decompression(a, zip);\n\tfree(zip->uncompressed_buffer);\n\tfree(zip->sub_stream_buff[0]);\n\tfree(zip->sub_stream_buff[1]);\n\tfree(zip->sub_stream_buff[2]);\n\tfree(zip->tmp_stream_buff);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nread_consume(struct archive_read *a)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\n\tif (zip->pack_stream_bytes_unconsumed) {\n\t\t__archive_read_consume(a, zip->pack_stream_bytes_unconsumed);\n\t\tzip->stream_offset += zip->pack_stream_bytes_unconsumed;\n\t\tzip->pack_stream_bytes_unconsumed = 0;\n\t}\n}\n\n#ifdef HAVE_LZMA_H\n\n/*\n * Set an error code and choose an error message for liblzma.\n */\nstatic void\nset_error(struct archive_read *a, int ret)\n{\n\n\tswitch (ret) {\n\tcase LZMA_STREAM_END: /* Found end of stream. */\n\tcase LZMA_OK: /* Decompressor made some progress. */\n\t\tbreak;\n\tcase LZMA_MEM_ERROR:\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Lzma library error: Cannot allocate memory\");\n\t\tbreak;\n\tcase LZMA_MEMLIMIT_ERROR:\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Lzma library error: Out of memory\");\n\t\tbreak;\n\tcase LZMA_FORMAT_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error: format not recognized\");\n\t\tbreak;\n\tcase LZMA_OPTIONS_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error: Invalid options\");\n\t\tbreak;\n\tcase LZMA_DATA_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error: Corrupted input data\");\n\t\tbreak;\n\tcase LZMA_BUF_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error:  No progress is possible\");\n\t\tbreak;\n\tdefault:\n\t\t/* Return an error. */\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma decompression failed:  Unknown error\");\n\t\tbreak;\n\t}\n}\n\n#endif\n\nstatic unsigned long\ndecode_codec_id(const unsigned char *codecId, size_t id_size)\n{\n\tunsigned i;\n\tunsigned long id = 0;\n\n\tfor (i = 0; i < id_size; i++) {\n\t\tid <<= 8;\n\t\tid += codecId[i];\n\t}\n\treturn (id);\n}\n\nstatic void *\nppmd_alloc(void *p, size_t size)\n{\n\t(void)p;\n\treturn malloc(size);\n}\nstatic void\nppmd_free(void *p, void *address)\n{\n\t(void)p;\n\tfree(address);\n}\nstatic Byte\nppmd_read(void *p)\n{\n\tstruct archive_read *a = ((IByteIn*)p)->a;\n\tstruct _7zip *zip = (struct _7zip *)(a->format->data);\n\tByte b;\n\n\tif (zip->ppstream.avail_in == 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated RAR file data\");\n\t\tzip->ppstream.overconsumed = 1;\n\t\treturn (0);\n\t}\n\tb = *zip->ppstream.next_in++;\n\tzip->ppstream.avail_in--;\n\tzip->ppstream.total_in++;\n\treturn (b);\n}\n\nstatic ISzAlloc g_szalloc = { ppmd_alloc, ppmd_free };\n\nstatic int\ninit_decompression(struct archive_read *a, struct _7zip *zip,\n    const struct _7z_coder *coder1, const struct _7z_coder *coder2)\n{\n\tint r;\n\n\tzip->codec = coder1->codec;\n\tzip->codec2 = -1;\n\n\tswitch (zip->codec) {\n\tcase _7Z_COPY:\n\tcase _7Z_BZ2:\n\tcase _7Z_DEFLATE:\n\tcase _7Z_PPMD:\n\t\tif (coder2 != NULL) {\n\t\t\tif (coder2->codec != _7Z_X86 &&\n\t\t\t    coder2->codec != _7Z_X86_BCJ2) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Unsupported filter %lx for %lx\",\n\t\t\t\t    coder2->codec, coder1->codec);\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->codec2 = coder2->codec;\n\t\t\tzip->bcj_state = 0;\n\t\t\tif (coder2->codec == _7Z_X86)\n\t\t\t\tx86_Init(zip);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (zip->codec) {\n\tcase _7Z_COPY:\n\t\tbreak;\n\n\tcase _7Z_LZMA: case _7Z_LZMA2:\n#ifdef HAVE_LZMA_H\n#if LZMA_VERSION_MAJOR >= 5\n/* Effectively disable the limiter. */\n#define LZMA_MEMLIMIT   UINT64_MAX\n#else\n/* NOTE: This needs to check memory size which running system has. */\n#define LZMA_MEMLIMIT   (1U << 30)\n#endif\n\t{\n\t\tlzma_options_delta delta_opt;\n\t\tlzma_filter filters[LZMA_FILTERS_MAX];\n#if LZMA_VERSION < 50010000\n\t\tlzma_filter *ff;\n#endif\n\t\tint fi = 0;\n\n\t\tif (zip->lzstream_valid) {\n\t\t\tlzma_end(&(zip->lzstream));\n\t\t\tzip->lzstream_valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: liblzma incompletely handle the BCJ+LZMA compressed\n\t\t * data made by 7-Zip because 7-Zip does not add End-Of-\n\t\t * Payload Marker(EOPM) at the end of LZMA compressed data,\n\t\t * and so liblzma cannot know the end of the compressed data\n\t\t * without EOPM. So consequently liblzma will not return last\n\t\t * three or four bytes of uncompressed data because\n\t\t * LZMA_FILTER_X86 filter does not handle input data if its\n\t\t * data size is less than five bytes. If liblzma detect EOPM\n\t\t * or know the uncompressed data size, liblzma will flush out\n\t\t * the remaining that three or four bytes of uncompressed\n\t\t * data. That is why we have to use our converting program\n\t\t * for BCJ+LZMA. If we were able to tell the uncompressed\n\t\t * size to liblzma when using lzma_raw_decoder() liblzma\n\t\t * could correctly deal with BCJ+LZMA. But unfortunately\n\t\t * there is no way to do that.\n\t\t * Discussion about this can be found at XZ Utils forum.\n\t\t */\n\t\tif (coder2 != NULL) {\n\t\t\tzip->codec2 = coder2->codec;\n\n\t\t\tfilters[fi].options = NULL;\n\t\t\tswitch (zip->codec2) {\n\t\t\tcase _7Z_X86:\n\t\t\t\tif (zip->codec == _7Z_LZMA2) {\n\t\t\t\t\tfilters[fi].id = LZMA_FILTER_X86;\n\t\t\t\t\tfi++;\n\t\t\t\t} else\n\t\t\t\t\t/* Use our filter. */\n\t\t\t\t\tx86_Init(zip);\n\t\t\t\tbreak;\n\t\t\tcase _7Z_X86_BCJ2:\n\t\t\t\t/* Use our filter. */\n\t\t\t\tzip->bcj_state = 0;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_DELTA:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_DELTA;\n\t\t\t\tmemset(&delta_opt, 0, sizeof(delta_opt));\n\t\t\t\tdelta_opt.type = LZMA_DELTA_TYPE_BYTE;\n\t\t\t\tdelta_opt.dist = 1;\n\t\t\t\tfilters[fi].options = &delta_opt;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\t/* Following filters have not been tested yet. */\n\t\t\tcase _7Z_POWERPC:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_POWERPC;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_IA64:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_IA64;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_ARM:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_ARM;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_ARMTHUMB:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_ARMTHUMB;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_SPARC:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_SPARC;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Unexpected codec ID: %lX\", zip->codec2);\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t}\n\n\t\tif (zip->codec == _7Z_LZMA2)\n\t\t\tfilters[fi].id = LZMA_FILTER_LZMA2;\n\t\telse\n\t\t\tfilters[fi].id = LZMA_FILTER_LZMA1;\n\t\tfilters[fi].options = NULL;\n#if LZMA_VERSION < 50010000\n\t\tff = &filters[fi];\n#endif\n\t\tr = lzma_properties_decode(&filters[fi], NULL,\n\t\t    coder1->properties, (size_t)coder1->propertiesSize);\n\t\tif (r != LZMA_OK) {\n\t\t\tset_error(a, r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tfi++;\n\n\t\tfilters[fi].id = LZMA_VLI_UNKNOWN;\n\t\tfilters[fi].options = NULL;\n\t\tr = lzma_raw_decoder(&(zip->lzstream), filters);\n#if LZMA_VERSION < 50010000\n\t\tfree(ff->options);\n#endif\n\t\tif (r != LZMA_OK) {\n\t\t\tset_error(a, r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->lzstream_valid = 1;\n\t\tzip->lzstream.total_in = 0;\n\t\tzip->lzstream.total_out = 0;\n\t\tbreak;\n\t}\n#else\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LZMA codec is unsupported\");\n\t\treturn (ARCHIVE_FAILED);\n#endif\n\tcase _7Z_BZ2:\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\t\tif (zip->bzstream_valid) {\n\t\t\tBZ2_bzDecompressEnd(&(zip->bzstream));\n\t\t\tzip->bzstream_valid = 0;\n\t\t}\n\t\tr = BZ2_bzDecompressInit(&(zip->bzstream), 0, 0);\n\t\tif (r == BZ_MEM_ERROR)\n\t\t\tr = BZ2_bzDecompressInit(&(zip->bzstream), 0, 1);\n\t\tif (r != BZ_OK) {\n\t\t\tint err = ARCHIVE_ERRNO_MISC;\n\t\t\tconst char *detail = NULL;\n\t\t\tswitch (r) {\n\t\t\tcase BZ_PARAM_ERROR:\n\t\t\t\tdetail = \"invalid setup parameter\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_MEM_ERROR:\n\t\t\t\terr = ENOMEM;\n\t\t\t\tdetail = \"out of memory\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_CONFIG_ERROR:\n\t\t\t\tdetail = \"mis-compiled library\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive, err,\n\t\t\t    \"Internal error initializing decompressor: %s\",\n\t\t\t    detail != NULL ? detail : \"??\");\n\t\t\tzip->bzstream_valid = 0;\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->bzstream_valid = 1;\n\t\tzip->bzstream.total_in_lo32 = 0;\n\t\tzip->bzstream.total_in_hi32 = 0;\n\t\tzip->bzstream.total_out_lo32 = 0;\n\t\tzip->bzstream.total_out_hi32 = 0;\n\t\tbreak;\n#else\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"BZ2 codec is unsupported\");\n\t\treturn (ARCHIVE_FAILED);\n#endif\n\tcase _7Z_DEFLATE:\n#ifdef HAVE_ZLIB_H\n\t\tif (zip->stream_valid)\n\t\t\tr = inflateReset(&(zip->stream));\n\t\telse\n\t\t\tr = inflateInit2(&(zip->stream),\n\t\t\t    -15 /* Don't check for zlib header */);\n\t\tif (r != Z_OK) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Couldn't initialize zlib stream.\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->stream_valid = 1;\n\t\tzip->stream.total_in = 0;\n\t\tzip->stream.total_out = 0;\n\t\tbreak;\n#else\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"DEFLATE codec is unsupported\");\n\t\treturn (ARCHIVE_FAILED);\n#endif\n\tcase _7Z_PPMD:\n\t{\n\t\tunsigned order;\n\t\tuint32_t msize;\n\n\t\tif (zip->ppmd7_valid) {\n\t\t\t__archive_ppmd7_functions.Ppmd7_Free(\n\t\t\t    &zip->ppmd7_context, &g_szalloc);\n\t\t\tzip->ppmd7_valid = 0;\n\t\t}\n\n\t\tif (coder1->propertiesSize < 5) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Malformed PPMd parameter\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\torder = coder1->properties[0];\n\t\tmsize = archive_le32dec(&(coder1->properties[1]));\n\t\tif (order < PPMD7_MIN_ORDER || order > PPMD7_MAX_ORDER ||\n\t\t    msize < PPMD7_MIN_MEM_SIZE || msize > PPMD7_MAX_MEM_SIZE) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Malformed PPMd parameter\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\t__archive_ppmd7_functions.Ppmd7_Construct(&zip->ppmd7_context);\n\t\tr = __archive_ppmd7_functions.Ppmd7_Alloc(\n\t\t\t&zip->ppmd7_context, msize, &g_szalloc);\n\t\tif (r == 0) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Coludn't allocate memory for PPMd\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t__archive_ppmd7_functions.Ppmd7_Init(\n\t\t\t&zip->ppmd7_context, order);\n\t\t__archive_ppmd7_functions.Ppmd7z_RangeDec_CreateVTable(\n\t\t\t&zip->range_dec);\n\t\tzip->ppmd7_valid = 1;\n\t\tzip->ppmd7_stat = 0;\n\t\tzip->ppstream.overconsumed = 0;\n\t\tzip->ppstream.total_in = 0;\n\t\tzip->ppstream.total_out = 0;\n\t\tbreak;\n\t}\n\tcase _7Z_X86:\n\tcase _7Z_X86_BCJ2:\n\tcase _7Z_POWERPC:\n\tcase _7Z_IA64:\n\tcase _7Z_ARM:\n\tcase _7Z_ARMTHUMB:\n\tcase _7Z_SPARC:\n\tcase _7Z_DELTA:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Unexpected codec ID: %lX\", zip->codec);\n\t\treturn (ARCHIVE_FAILED);\n\tcase _7Z_CRYPTO_MAIN_ZIP:\n\tcase _7Z_CRYPTO_RAR_29:\n\tcase _7Z_CRYPTO_AES_256_SHA_256:\n\t\tif (a->entry) {\n\t\t\tarchive_entry_set_is_metadata_encrypted(a->entry, 1);\n\t\t\tarchive_entry_set_is_data_encrypted(a->entry, 1);\n\t\t\tzip->has_encrypted_entries = 1;\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Crypto codec not supported yet (ID: 0x%lX)\", zip->codec);\n\t\treturn (ARCHIVE_FAILED);\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Unknown codec ID: %lX\", zip->codec);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ndecompress(struct archive_read *a, struct _7zip *zip,\n    void *buff, size_t *outbytes, const void *b, size_t *used)\n{\n\tconst uint8_t *t_next_in;\n\tuint8_t *t_next_out;\n\tsize_t o_avail_in, o_avail_out;\n\tsize_t t_avail_in, t_avail_out;\n\tuint8_t *bcj2_next_out;\n\tsize_t bcj2_avail_out;\n\tint r, ret = ARCHIVE_OK;\n\n\tt_avail_in = o_avail_in = *used;\n\tt_avail_out = o_avail_out = *outbytes;\n\tt_next_in = b;\n\tt_next_out = buff;\n\n\tif (zip->codec != _7Z_LZMA2 && zip->codec2 == _7Z_X86) {\n\t\tint i;\n\n\t\t/* Do not copy out the BCJ remaining bytes when the output\n\t\t * buffer size is less than five bytes. */\n\t\tif (o_avail_in != 0 && t_avail_out < 5 && zip->odd_bcj_size) {\n\t\t\t*used = 0;\n\t\t\t*outbytes = 0;\n\t\t\treturn (ret);\n\t\t}\n\t\tfor (i = 0; zip->odd_bcj_size > 0 && t_avail_out; i++) {\n\t\t\t*t_next_out++ = zip->odd_bcj[i];\n\t\t\tt_avail_out--;\n\t\t\tzip->odd_bcj_size--;\n\t\t}\n\t\tif (o_avail_in == 0 || t_avail_out == 0) {\n\t\t\t*used = o_avail_in - t_avail_in;\n\t\t\t*outbytes = o_avail_out - t_avail_out;\n\t\t\tif (o_avail_in == 0)\n\t\t\t\tret = ARCHIVE_EOF;\n\t\t\treturn (ret);\n\t\t}\n\t}\n\n\tbcj2_next_out = t_next_out;\n\tbcj2_avail_out = t_avail_out;\n\tif (zip->codec2 == _7Z_X86_BCJ2) {\n\t\t/*\n\t\t * Decord a remaining decompressed main stream for BCJ2.\n\t\t */\n\t\tif (zip->tmp_stream_bytes_remaining) {\n\t\t\tssize_t bytes;\n\t\t\tsize_t remaining = zip->tmp_stream_bytes_remaining;\n\t\t\tbytes = Bcj2_Decode(zip, t_next_out, t_avail_out);\n\t\t\tif (bytes < 0) {\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"BCJ2 conversion Failed\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->main_stream_bytes_remaining -=\n\t\t\t    remaining - zip->tmp_stream_bytes_remaining;\n\t\t\tt_avail_out -= bytes;\n\t\t\tif (o_avail_in == 0 || t_avail_out == 0) {\n\t\t\t\t*used = 0;\n\t\t\t\t*outbytes = o_avail_out - t_avail_out;\n\t\t\t\tif (o_avail_in == 0 &&\n\t\t\t\t    zip->tmp_stream_bytes_remaining)\n\t\t\t\t\tret = ARCHIVE_EOF;\n\t\t\t\treturn (ret);\n\t\t\t}\n\t\t\tt_next_out += bytes;\n\t\t\tbcj2_next_out = t_next_out;\n\t\t\tbcj2_avail_out = t_avail_out;\n\t\t}\n\t\tt_next_out = zip->tmp_stream_buff;\n\t\tt_avail_out = zip->tmp_stream_buff_size;\n\t}\n\n\tswitch (zip->codec) {\n\tcase _7Z_COPY:\n\t{\n\t\tsize_t bytes =\n\t\t    (t_avail_in > t_avail_out)?t_avail_out:t_avail_in;\n\n\t\tmemcpy(t_next_out, t_next_in, bytes);\n\t\tt_avail_in -= bytes;\n\t\tt_avail_out -= bytes;\n\t\tif (o_avail_in == 0)\n\t\t\tret = ARCHIVE_EOF;\n\t\tbreak;\n\t}\n#ifdef HAVE_LZMA_H\n\tcase _7Z_LZMA: case _7Z_LZMA2:\n\t\tzip->lzstream.next_in = t_next_in;\n\t\tzip->lzstream.avail_in = t_avail_in;\n\t\tzip->lzstream.next_out = t_next_out;\n\t\tzip->lzstream.avail_out = t_avail_out;\n\n\t\tr = lzma_code(&(zip->lzstream), LZMA_RUN);\n\t\tswitch (r) {\n\t\tcase LZMA_STREAM_END: /* Found end of stream. */\n\t\t\tlzma_end(&(zip->lzstream));\n\t\t\tzip->lzstream_valid = 0;\n\t\t\tret = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\tcase LZMA_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\"Decompression failed(%d)\",\n\t\t\t    r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tt_avail_in = zip->lzstream.avail_in;\n\t\tt_avail_out = zip->lzstream.avail_out;\n\t\tbreak;\n#endif\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tcase _7Z_BZ2:\n\t\tzip->bzstream.next_in = (char *)(uintptr_t)t_next_in;\n\t\tzip->bzstream.avail_in = t_avail_in;\n\t\tzip->bzstream.next_out = (char *)(uintptr_t)t_next_out;\n\t\tzip->bzstream.avail_out = t_avail_out;\n\t\tr = BZ2_bzDecompress(&(zip->bzstream));\n\t\tswitch (r) {\n\t\tcase BZ_STREAM_END: /* Found end of stream. */\n\t\t\tswitch (BZ2_bzDecompressEnd(&(zip->bzstream))) {\n\t\t\tcase BZ_OK:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to clean up decompressor\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->bzstream_valid = 0;\n\t\t\tret = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\tcase BZ_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"bzip decompression failed\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tt_avail_in = zip->bzstream.avail_in;\n\t\tt_avail_out = zip->bzstream.avail_out;\n\t\tbreak;\n#endif\n#ifdef HAVE_ZLIB_H\n\tcase _7Z_DEFLATE:\n\t\tzip->stream.next_in = (Bytef *)(uintptr_t)t_next_in;\n\t\tzip->stream.avail_in = (uInt)t_avail_in;\n\t\tzip->stream.next_out = t_next_out;\n\t\tzip->stream.avail_out = (uInt)t_avail_out;\n\t\tr = inflate(&(zip->stream), 0);\n\t\tswitch (r) {\n\t\tcase Z_STREAM_END: /* Found end of stream. */\n\t\t\tret = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\tcase Z_OK: /* Decompressor made some progress.*/\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"File decompression failed (%d)\", r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tt_avail_in = zip->stream.avail_in;\n\t\tt_avail_out = zip->stream.avail_out;\n\t\tbreak;\n#endif\n\tcase _7Z_PPMD:\n\t{\n\t\tuint64_t flush_bytes;\n\n\t\tif (!zip->ppmd7_valid || zip->ppmd7_stat < 0 ||\n\t\t    t_avail_out <= 0) {\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decompression internal error\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->ppstream.next_in = t_next_in;\n\t\tzip->ppstream.avail_in = t_avail_in;\n\t\tzip->ppstream.next_out = t_next_out;\n\t\tzip->ppstream.avail_out = t_avail_out;\n\t\tif (zip->ppmd7_stat == 0) {\n\t\t\tzip->bytein.a = a;\n\t\t\tzip->bytein.Read = &ppmd_read;\n\t\t\tzip->range_dec.Stream = &zip->bytein;\n\t\t\tr = __archive_ppmd7_functions.Ppmd7z_RangeDec_Init(\n\t\t\t\t&(zip->range_dec));\n\t\t\tif (r == 0) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to initialize PPMd range decorder\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tif (zip->ppstream.overconsumed) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->ppmd7_stat = 1;\n\t\t}\n\n\t\tif (t_avail_in == 0)\n\t\t\t/* XXX Flush out remaining decoded data XXX */\n\t\t\tflush_bytes = zip->folder_outbytes_remaining;\n\t\telse\n\t\t\tflush_bytes = 0;\n\n\t\tdo {\n\t\t\tint sym;\n\n\t\t\tsym = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n\t\t\t\t&(zip->ppmd7_context), &(zip->range_dec.p));\n\t\t\tif (sym < 0) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Failed to decode PPMd\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tif (zip->ppstream.overconsumed) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\t*zip->ppstream.next_out++ = (unsigned char)sym;\n\t\t\tzip->ppstream.avail_out--;\n\t\t\tzip->ppstream.total_out++;\n\t\t\tif (flush_bytes)\n\t\t\t\tflush_bytes--;\n\t\t} while (zip->ppstream.avail_out &&\n\t\t\t(zip->ppstream.avail_in || flush_bytes));\n\n\t\tt_avail_in = (size_t)zip->ppstream.avail_in;\n\t\tt_avail_out = (size_t)zip->ppstream.avail_out;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"Decompression internal error\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tif (ret != ARCHIVE_OK && ret != ARCHIVE_EOF)\n\t\treturn (ret);\n\n\t*used = o_avail_in - t_avail_in;\n\t*outbytes = o_avail_out - t_avail_out;\n\n\t/*\n\t * Decord BCJ.\n\t */\n\tif (zip->codec != _7Z_LZMA2 && zip->codec2 == _7Z_X86) {\n\t\tsize_t l = x86_Convert(zip, buff, *outbytes);\n\t\tzip->odd_bcj_size = *outbytes - l;\n\t\tif (zip->odd_bcj_size > 0 && zip->odd_bcj_size <= 4 &&\n\t\t    o_avail_in && ret != ARCHIVE_EOF) {\n\t\t\tmemcpy(zip->odd_bcj, ((unsigned char *)buff) + l,\n\t\t\t    zip->odd_bcj_size);\n\t\t\t*outbytes = l;\n\t\t} else\n\t\t\tzip->odd_bcj_size = 0;\n\t}\n\n\t/*\n\t * Decord BCJ2 with a decompressed main stream.\n\t */\n\tif (zip->codec2 == _7Z_X86_BCJ2) {\n\t\tssize_t bytes;\n\n\t\tzip->tmp_stream_bytes_avail =\n\t\t    zip->tmp_stream_buff_size - t_avail_out;\n\t\tif (zip->tmp_stream_bytes_avail >\n\t\t      zip->main_stream_bytes_remaining)\n\t\t\tzip->tmp_stream_bytes_avail =\n\t\t\t    zip->main_stream_bytes_remaining;\n\t\tzip->tmp_stream_bytes_remaining = zip->tmp_stream_bytes_avail;\n\t\tbytes = Bcj2_Decode(zip, bcj2_next_out, bcj2_avail_out);\n\t\tif (bytes < 0) {\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC, \"BCJ2 conversion Failed\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->main_stream_bytes_remaining -=\n\t\t    zip->tmp_stream_bytes_avail\n\t\t      - zip->tmp_stream_bytes_remaining;\n\t\tbcj2_avail_out -= bytes;\n\t\t*outbytes = o_avail_out - bcj2_avail_out;\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nfree_decompression(struct archive_read *a, struct _7zip *zip)\n{\n\tint r = ARCHIVE_OK;\n\n#if !defined(HAVE_ZLIB_H) &&\\\n\t!(defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR))\n\t(void)a;/* UNUSED */\n#endif\n#ifdef HAVE_LZMA_H\n\tif (zip->lzstream_valid)\n\t\tlzma_end(&(zip->lzstream));\n#endif\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tif (zip->bzstream_valid) {\n\t\tif (BZ2_bzDecompressEnd(&(zip->bzstream)) != BZ_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up bzip2 decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t\tzip->bzstream_valid = 0;\n\t}\n#endif\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid) {\n\t\tif (inflateEnd(&(zip->stream)) != Z_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up zlib decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t\tzip->stream_valid = 0;\n\t}\n#endif\n\tif (zip->ppmd7_valid) {\n\t\t__archive_ppmd7_functions.Ppmd7_Free(\n\t\t\t&zip->ppmd7_context, &g_szalloc);\n\t\tzip->ppmd7_valid = 0;\n\t}\n\treturn (r);\n}\n\nstatic int\nparse_7zip_uint64(struct archive_read *a, uint64_t *val)\n{\n\tconst unsigned char *p;\n\tunsigned char avail, mask;\n\tint i;\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tavail = *p;\n\tmask = 0x80;\n\t*val = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (avail & mask) {\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\t*val |= ((uint64_t)*p) << (8 * i);\n\t\t\tmask >>= 1;\n\t\t\tcontinue;\n\t\t}\n\t\t*val += ((uint64_t)(avail & (mask -1))) << (8 * i);\n\t\tbreak;\n\t}\n\treturn (0);\n}\n\nstatic int\nread_Bools(struct archive_read *a, unsigned char *data, size_t num)\n{\n\tconst unsigned char *p;\n\tunsigned i, mask = 0, avail = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (mask == 0) {\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tavail = *p;\n\t\t\tmask = 0x80;\n\t\t}\n\t\tdata[i] = (avail & mask)?1:0;\n\t\tmask >>= 1;\n\t}\n\treturn (0);\n}\n\nstatic void\nfree_Digest(struct _7z_digests *d)\n{\n\tfree(d->defineds);\n\tfree(d->digests);\n}\n\nstatic int\nread_Digests(struct archive_read *a, struct _7z_digests *d, size_t num)\n{\n\tconst unsigned char *p;\n\tunsigned i;\n\n\tif (num == 0)\n\t\treturn (-1);\n\tmemset(d, 0, sizeof(*d));\n\n\td->defineds = malloc(num);\n\tif (d->defineds == NULL)\n\t\treturn (-1);\n\t/*\n\t * Read Bools.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == 0) {\n\t\tif (read_Bools(a, d->defineds, num) < 0)\n\t\t\treturn (-1);\n\t} else\n\t\t/* All are defined */\n\t\tmemset(d->defineds, 1, num);\n\n\td->digests = calloc(num, sizeof(*d->digests));\n\tif (d->digests == NULL)\n\t\treturn (-1);\n\tfor (i = 0; i < num; i++) {\n\t\tif (d->defineds[i]) {\n\t\t\tif ((p = header_bytes(a, 4)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\td->digests[i] = archive_le32dec(p);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic void\nfree_PackInfo(struct _7z_pack_info *pi)\n{\n\tfree(pi->sizes);\n\tfree(pi->positions);\n\tfree_Digest(&(pi->digest));\n}\n\nstatic int\nread_PackInfo(struct archive_read *a, struct _7z_pack_info *pi)\n{\n\tconst unsigned char *p;\n\tunsigned i;\n\n\tmemset(pi, 0, sizeof(*pi));\n\n\t/*\n\t * Read PackPos.\n\t */\n\tif (parse_7zip_uint64(a, &(pi->pos)) < 0)\n\t\treturn (-1);\n\n\t/*\n\t * Read NumPackStreams.\n\t */\n\tif (parse_7zip_uint64(a, &(pi->numPackStreams)) < 0)\n\t\treturn (-1);\n\tif (pi->numPackStreams == 0)\n\t\treturn (-1);\n\tif (UMAX_ENTRY < pi->numPackStreams)\n\t\treturn (-1);\n\n\t/*\n\t * Read PackSizes[num]\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kEnd)\n\t\t/* PackSizes[num] are not present. */\n\t\treturn (0);\n\tif (*p != kSize)\n\t\treturn (-1);\n\tpi->sizes = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));\n\tpi->positions = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));\n\tif (pi->sizes == NULL || pi->positions == NULL)\n\t\treturn (-1);\n\n\tfor (i = 0; i < pi->numPackStreams; i++) {\n\t\tif (parse_7zip_uint64(a, &(pi->sizes[i])) < 0)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read PackStreamDigests[num]\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kEnd) {\n\t\t/* PackStreamDigests[num] are not present. */\n\t\tpi->digest.defineds =\n\t\t    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.defineds));\n\t\tpi->digest.digests =\n\t\t    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.digests));\n\t\tif (pi->digest.defineds == NULL || pi->digest.digests == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\tif (*p != kSize)\n\t\treturn (-1);\n\n\tif (read_Digests(a, &(pi->digest), (size_t)pi->numPackStreams) < 0)\n\t\treturn (-1);\n\n\t/*\n\t *  Must be marked by kEnd.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}\n\nstatic void\nfree_Folder(struct _7z_folder *f)\n{\n\tunsigned i;\n\n\tif (f->coders) {\n\t\tfor (i = 0; i< f->numCoders; i++) {\n\t\t\tfree(f->coders[i].properties);\n\t\t}\n\t\tfree(f->coders);\n\t}\n\tfree(f->bindPairs);\n\tfree(f->packedStreams);\n\tfree(f->unPackSize);\n}\n\nstatic int\nread_Folder(struct archive_read *a, struct _7z_folder *f)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tuint64_t numInStreamsTotal = 0;\n\tuint64_t numOutStreamsTotal = 0;\n\tunsigned i;\n\n\tmemset(f, 0, sizeof(*f));\n\n\t/*\n\t * Read NumCoders.\n\t */\n\tif (parse_7zip_uint64(a, &(f->numCoders)) < 0)\n\t\treturn (-1);\n\tif (f->numCoders > 4)\n\t\t/* Too many coders. */\n\t\treturn (-1);\n\n\tf->coders = calloc((size_t)f->numCoders, sizeof(*f->coders));\n\tif (f->coders == NULL)\n\t\treturn (-1);\n\tfor (i = 0; i< f->numCoders; i++) {\n\t\tsize_t codec_size;\n\t\tint simple, attr;\n\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\t/*\n\t\t * 0:3 CodecIdSize\n\t\t * 4:  0 - IsSimple\n\t\t *     1 - Is not Simple\n\t\t * 5:  0 - No Attributes\n\t\t *     1 - There are Attributes;\n\t\t * 7:  Must be zero.\n\t\t */\n\t\tcodec_size = *p & 0xf;\n\t\tsimple = (*p & 0x10)?0:1;\n\t\tattr = *p & 0x20;\n\t\tif (*p & 0x80)\n\t\t\treturn (-1);/* Not supported. */\n\n\t\t/*\n\t\t * Read Decompression Method IDs.\n\t\t */\n\t\tif ((p = header_bytes(a, codec_size)) == NULL)\n\t\t\treturn (-1);\n\n\t\tf->coders[i].codec = decode_codec_id(p, codec_size);\n\n\t\tif (simple) {\n\t\t\tf->coders[i].numInStreams = 1;\n\t\t\tf->coders[i].numOutStreams = 1;\n\t\t} else {\n\t\t\tif (parse_7zip_uint64(\n\t\t\t    a, &(f->coders[i].numInStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f->coders[i].numInStreams)\n\t\t\t\treturn (-1);\n\t\t\tif (parse_7zip_uint64(\n\t\t\t    a, &(f->coders[i].numOutStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f->coders[i].numOutStreams)\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\tif (attr) {\n\t\t\tif (parse_7zip_uint64(\n\t\t\t    a, &(f->coders[i].propertiesSize)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif ((p = header_bytes(\n\t\t\t    a, (size_t)f->coders[i].propertiesSize)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tf->coders[i].properties =\n\t\t\t    malloc((size_t)f->coders[i].propertiesSize);\n\t\t\tif (f->coders[i].properties == NULL)\n\t\t\t\treturn (-1);\n\t\t\tmemcpy(f->coders[i].properties, p,\n\t\t\t    (size_t)f->coders[i].propertiesSize);\n\t\t}\n\n\t\tnumInStreamsTotal += f->coders[i].numInStreams;\n\t\tnumOutStreamsTotal += f->coders[i].numOutStreams;\n\t}\n\n\tif (numOutStreamsTotal == 0 ||\n\t    numInStreamsTotal < numOutStreamsTotal-1)\n\t\treturn (-1);\n\n\tf->numBindPairs = numOutStreamsTotal - 1;\n\tif (zip->header_bytes_remaining < f->numBindPairs)\n\t\t\treturn (-1);\n\tif (f->numBindPairs > 0) {\n\t\tf->bindPairs =\n\t\t\tcalloc((size_t)f->numBindPairs, sizeof(*f->bindPairs));\n\t\tif (f->bindPairs == NULL)\n\t\t\treturn (-1);\n\t} else\n\t\tf->bindPairs = NULL;\n\tfor (i = 0; i < f->numBindPairs; i++) {\n\t\tif (parse_7zip_uint64(a, &(f->bindPairs[i].inIndex)) < 0)\n\t\t\treturn (-1);\n\t\tif (UMAX_ENTRY < f->bindPairs[i].inIndex)\n\t\t\treturn (-1);\n\t\tif (parse_7zip_uint64(a, &(f->bindPairs[i].outIndex)) < 0)\n\t\t\treturn (-1);\n\t\tif (UMAX_ENTRY < f->bindPairs[i].outIndex)\n\t\t\treturn (-1);\n\t}\n\n\tf->numPackedStreams = numInStreamsTotal - f->numBindPairs;\n\tf->packedStreams =\n\t    calloc((size_t)f->numPackedStreams, sizeof(*f->packedStreams));\n\tif (f->packedStreams == NULL)\n\t\treturn (-1);\n\tif (f->numPackedStreams == 1) {\n\t\tfor (i = 0; i < numInStreamsTotal; i++) {\n\t\t\tunsigned j;\n\t\t\tfor (j = 0; j < f->numBindPairs; j++) {\n\t\t\t\tif (f->bindPairs[j].inIndex == i)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == f->numBindPairs)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == numInStreamsTotal)\n\t\t\treturn (-1);\n\t\tf->packedStreams[0] = i;\n\t} else {\n\t\tfor (i = 0; i < f->numPackedStreams; i++) {\n\t\t\tif (parse_7zip_uint64(a, &(f->packedStreams[i])) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f->packedStreams[i])\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\tf->numInStreams = numInStreamsTotal;\n\tf->numOutStreams = numOutStreamsTotal;\n\n\treturn (0);\n}\n\nstatic void\nfree_CodersInfo(struct _7z_coders_info *ci)\n{\n\tunsigned i;\n\n\tif (ci->folders) {\n\t\tfor (i = 0; i < ci->numFolders; i++)\n\t\t\tfree_Folder(&(ci->folders[i]));\n\t\tfree(ci->folders);\n\t}\n}\n\nstatic int\nread_CodersInfo(struct archive_read *a, struct _7z_coders_info *ci)\n{\n\tconst unsigned char *p;\n\tstruct _7z_digests digest;\n\tunsigned i;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(&digest, 0, sizeof(digest));\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p != kFolder)\n\t\tgoto failed;\n\n\t/*\n\t * Read NumFolders.\n\t */\n\tif (parse_7zip_uint64(a, &(ci->numFolders)) < 0)\n\t\tgoto failed;\n\tif (UMAX_ENTRY < ci->numFolders)\n\t\treturn (-1);\n\n\t/*\n\t * Read External.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tswitch (*p) {\n\tcase 0:\n\t\tci->folders =\n\t\t\tcalloc((size_t)ci->numFolders, sizeof(*ci->folders));\n\t\tif (ci->folders == NULL)\n\t\t\treturn (-1);\n\t\tfor (i = 0; i < ci->numFolders; i++) {\n\t\t\tif (read_Folder(a, &(ci->folders[i])) < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tif (parse_7zip_uint64(a, &(ci->dataStreamIndex)) < 0)\n\t\t\treturn (-1);\n\t\tif (UMAX_ENTRY < ci->dataStreamIndex)\n\t\t\treturn (-1);\n\t\tif (ci->numFolders > 0) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\t\tgoto failed;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, -1,\n\t\t    \"Malformed 7-Zip archive\");\n\t\tgoto failed;\n\t}\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p != kCodersUnPackSize)\n\t\tgoto failed;\n\n\tfor (i = 0; i < ci->numFolders; i++) {\n\t\tstruct _7z_folder *folder = &(ci->folders[i]);\n\t\tunsigned j;\n\n\t\tfolder->unPackSize =\n\t\t    calloc((size_t)folder->numOutStreams, sizeof(*folder->unPackSize));\n\t\tif (folder->unPackSize == NULL)\n\t\t\tgoto failed;\n\t\tfor (j = 0; j < folder->numOutStreams; j++) {\n\t\t\tif (parse_7zip_uint64(a, &(folder->unPackSize[j])) < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\t}\n\n\t/*\n\t * Read CRCs.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p == kEnd)\n\t\treturn (0);\n\tif (*p != kCRC)\n\t\tgoto failed;\n\tif (read_Digests(a, &digest, (size_t)ci->numFolders) < 0)\n\t\tgoto failed;\n\tfor (i = 0; i < ci->numFolders; i++) {\n\t\tci->folders[i].digest_defined = digest.defineds[i];\n\t\tci->folders[i].digest = digest.digests[i];\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p != kEnd)\n\t\tgoto failed;\n\tfree_Digest(&digest);\n\treturn (0);\nfailed:\n\tfree_Digest(&digest);\n\treturn (-1);\n}\n\nstatic uint64_t\nfolder_uncompressed_size(struct _7z_folder *f)\n{\n\tint n = (int)f->numOutStreams;\n\tunsigned pairs = (unsigned)f->numBindPairs;\n\n\twhile (--n >= 0) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < pairs; i++) {\n\t\t\tif (f->bindPairs[i].outIndex == (uint64_t)n)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= pairs)\n\t\t\treturn (f->unPackSize[n]);\n\t}\n\treturn (0);\n}\n\nstatic void\nfree_SubStreamsInfo(struct _7z_substream_info *ss)\n{\n\tfree(ss->unpackSizes);\n\tfree(ss->digestsDefined);\n\tfree(ss->digests);\n}\n\nstatic int\nread_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,\n    struct _7z_folder *f, size_t numFolders)\n{\n\tconst unsigned char *p;\n\tuint64_t *usizes;\n\tsize_t unpack_streams;\n\tint type;\n\tunsigned i;\n\tuint32_t numDigests;\n\n\tmemset(ss, 0, sizeof(*ss));\n\n\tfor (i = 0; i < numFolders; i++)\n\t\tf[i].numUnpackStreams = 1;\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\ttype = *p;\n\n\tif (type == kNumUnPackStream) {\n\t\tunpack_streams = 0;\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (parse_7zip_uint64(a, &(f[i].numUnpackStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f[i].numUnpackStreams)\n\t\t\t\treturn (-1);\n\t\t\tunpack_streams += (size_t)f[i].numUnpackStreams;\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t} else\n\t\tunpack_streams = numFolders;\n\n\tss->unpack_streams = unpack_streams;\n\tif (unpack_streams) {\n\t\tss->unpackSizes = calloc(unpack_streams,\n\t\t    sizeof(*ss->unpackSizes));\n\t\tss->digestsDefined = calloc(unpack_streams,\n\t\t    sizeof(*ss->digestsDefined));\n\t\tss->digests = calloc(unpack_streams,\n\t\t    sizeof(*ss->digests));\n\t\tif (ss->unpackSizes == NULL || ss->digestsDefined == NULL ||\n\t\t    ss->digests == NULL)\n\t\t\treturn (-1);\n\t}\n\n\tusizes = ss->unpackSizes;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tunsigned pack;\n\t\tuint64_t sum;\n\n\t\tif (f[i].numUnpackStreams == 0)\n\t\t\tcontinue;\n\n\t\tsum = 0;\n\t\tif (type == kSize) {\n\t\t\tfor (pack = 1; pack < f[i].numUnpackStreams; pack++) {\n\t\t\t\tif (parse_7zip_uint64(a, usizes) < 0)\n\t\t\t\t\treturn (-1);\n\t\t\t\tsum += *usizes++;\n\t\t\t}\n\t\t}\n\t\t*usizes++ = folder_uncompressed_size(&f[i]) - sum;\n\t}\n\n\tif (type == kSize) {\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\tfor (i = 0; i < unpack_streams; i++) {\n\t\tss->digestsDefined[i] = 0;\n\t\tss->digests[i] = 0;\n\t}\n\n\tnumDigests = 0;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tif (f[i].numUnpackStreams != 1 || !f[i].digest_defined)\n\t\t\tnumDigests += (uint32_t)f[i].numUnpackStreams;\n\t}\n\n\tif (type == kCRC) {\n\t\tstruct _7z_digests tmpDigests;\n\t\tunsigned char *digestsDefined = ss->digestsDefined;\n\t\tuint32_t * digests = ss->digests;\n\t\tint di = 0;\n\n\t\tmemset(&tmpDigests, 0, sizeof(tmpDigests));\n\t\tif (read_Digests(a, &(tmpDigests), numDigests) < 0) {\n\t\t\tfree_Digest(&tmpDigests);\n\t\t\treturn (-1);\n\t\t}\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (f[i].numUnpackStreams == 1 && f[i].digest_defined) {\n\t\t\t\t*digestsDefined++ = 1;\n\t\t\t\t*digests++ = f[i].digest;\n\t\t\t} else {\n\t\t\t\tunsigned j;\n\n\t\t\t\tfor (j = 0; j < f[i].numUnpackStreams;\n\t\t\t\t    j++, di++) {\n\t\t\t\t\t*digestsDefined++ =\n\t\t\t\t\t    tmpDigests.defineds[di];\n\t\t\t\t\t*digests++ =\n\t\t\t\t\t    tmpDigests.digests[di];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree_Digest(&tmpDigests);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif (type != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}\n\nstatic void\nfree_StreamsInfo(struct _7z_stream_info *si)\n{\n\tfree_PackInfo(&(si->pi));\n\tfree_CodersInfo(&(si->ci));\n\tfree_SubStreamsInfo(&(si->ss));\n}\n\nstatic int\nread_StreamsInfo(struct archive_read *a, struct _7z_stream_info *si)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tunsigned i;\n\n\tmemset(si, 0, sizeof(*si));\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kPackInfo) {\n\t\tuint64_t packPos;\n\n\t\tif (read_PackInfo(a, &(si->pi)) < 0)\n\t\t\treturn (-1);\n\n\t\tif (si->pi.positions == NULL || si->pi.sizes == NULL)\n\t\t\treturn (-1);\n\t\t/*\n\t\t * Calculate packed stream positions.\n\t\t */\n\t\tpackPos = si->pi.pos;\n\t\tfor (i = 0; i < si->pi.numPackStreams; i++) {\n\t\t\tsi->pi.positions[i] = packPos;\n\t\t\tpackPos += si->pi.sizes[i];\n\t\t\tif (packPos > zip->header_offset)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p == kUnPackInfo) {\n\t\tuint32_t packIndex;\n\t\tstruct _7z_folder *f;\n\n\t\tif (read_CodersInfo(a, &(si->ci)) < 0)\n\t\t\treturn (-1);\n\n\t\t/*\n\t\t * Calculate packed stream indexes.\n\t\t */\n\t\tpackIndex = 0;\n\t\tf = si->ci.folders;\n\t\tfor (i = 0; i < si->ci.numFolders; i++) {\n\t\t\tf[i].packIndex = packIndex;\n\t\t\tpackIndex += (uint32_t)f[i].numPackedStreams;\n\t\t\tif (packIndex > si->pi.numPackStreams)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\n\tif (*p == kSubStreamsInfo) {\n\t\tif (read_SubStreamsInfo(a, &(si->ss),\n\t\t    si->ci.folders, (size_t)si->ci.numFolders) < 0)\n\t\t\treturn (-1);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif (*p != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}\n\nstatic void\nfree_Header(struct _7z_header_info *h)\n{\n\tfree(h->emptyStreamBools);\n\tfree(h->emptyFileBools);\n\tfree(h->antiBools);\n\tfree(h->attrBools);\n}\n\nstatic int\nread_Header(struct archive_read *a, struct _7z_header_info *h,\n    int check_header_id)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tstruct _7z_folder *folders;\n\tstruct _7z_stream_info *si = &(zip->si);\n\tstruct _7zip_entry *entries;\n\tuint32_t folderIndex, indexInFolder;\n\tunsigned i;\n\tint eindex, empty_streams, sindex;\n\n\tif (check_header_id) {\n\t\t/*\n\t\t * Read Header.\n\t\t */\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\tif (*p != kHeader)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read ArchiveProperties.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kArchiveProperties) {\n\t\tfor (;;) {\n\t\t\tuint64_t size;\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (*p == 0)\n\t\t\t\tbreak;\n\t\t\tif (parse_7zip_uint64(a, &size) < 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read MainStreamsInfo.\n\t */\n\tif (*p == kMainStreamsInfo) {\n\t\tif (read_StreamsInfo(a, &(zip->si)) < 0)\n\t\t\treturn (-1);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p == kEnd)\n\t\treturn (0);\n\n\t/*\n\t * Read FilesInfo.\n\t */\n\tif (*p != kFilesInfo)\n\t\treturn (-1);\n\n\tif (parse_7zip_uint64(a, &(zip->numFiles)) < 0)\n\t\treturn (-1);\n\tif (UMAX_ENTRY < zip->numFiles)\n\t\treturn (-1);\n\n\tzip->entries = calloc((size_t)zip->numFiles, sizeof(*zip->entries));\n\tif (zip->entries == NULL)\n\t\treturn (-1);\n\tentries = zip->entries;\n\n\tempty_streams = 0;\n\tfor (;;) {\n\t\tint type;\n\t\tuint64_t size;\n\t\tsize_t ll;\n\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t\tif (type == kEnd)\n\t\t\tbreak;\n\n\t\tif (parse_7zip_uint64(a, &size) < 0)\n\t\t\treturn (-1);\n\t\tif (zip->header_bytes_remaining < size)\n\t\t\treturn (-1);\n\t\tll = (size_t)size;\n\n\t\tswitch (type) {\n\t\tcase kEmptyStream:\n\t\t\th->emptyStreamBools = calloc((size_t)zip->numFiles,\n\t\t\t    sizeof(*h->emptyStreamBools));\n\t\t\tif (h->emptyStreamBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(\n\t\t\t    a, h->emptyStreamBools, (size_t)zip->numFiles) < 0)\n\t\t\t\treturn (-1);\n\t\t\tempty_streams = 0;\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tif (h->emptyStreamBools[i])\n\t\t\t\t\tempty_streams++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase kEmptyFile:\n\t\t\tif (empty_streams <= 0) {\n\t\t\t\t/* Unexcepted sequence. Skip this. */\n\t\t\t\tif (header_bytes(a, ll) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th->emptyFileBools = calloc(empty_streams,\n\t\t\t    sizeof(*h->emptyFileBools));\n\t\t\tif (h->emptyFileBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(a, h->emptyFileBools, empty_streams) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kAnti:\n\t\t\tif (empty_streams <= 0) {\n\t\t\t\t/* Unexcepted sequence. Skip this. */\n\t\t\t\tif (header_bytes(a, ll) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th->antiBools = calloc(empty_streams,\n\t\t\t    sizeof(*h->antiBools));\n\t\t\tif (h->antiBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(a, h->antiBools, empty_streams) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kCTime:\n\t\tcase kATime:\n\t\tcase kMTime:\n\t\t\tif (read_Times(a, h, type) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kName:\n\t\t{\n\t\t\tunsigned char *np;\n\t\t\tsize_t nl, nb;\n\n\t\t\t/* Skip one byte. */\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tll--;\n\n\t\t\tif ((ll & 1) || ll < zip->numFiles * 4)\n\t\t\t\treturn (-1);\n\n\t\t\tzip->entry_names = malloc(ll);\n\t\t\tif (zip->entry_names == NULL)\n\t\t\t\treturn (-1);\n\t\t\tnp = zip->entry_names;\n\t\t\tnb = ll;\n\t\t\t/*\n\t\t\t * Copy whole file names.\n\t\t\t * NOTE: This loop prevents from expanding\n\t\t\t * the uncompressed buffer in order not to\n\t\t\t * use extra memory resource.\n\t\t\t */\n\t\t\twhile (nb) {\n\t\t\t\tsize_t b;\n\t\t\t\tif (nb > UBUFF_SIZE)\n\t\t\t\t\tb = UBUFF_SIZE;\n\t\t\t\telse\n\t\t\t\t\tb = nb;\n\t\t\t\tif ((p = header_bytes(a, b)) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tmemcpy(np, p, b);\n\t\t\t\tnp += b;\n\t\t\t\tnb -= b;\n\t\t\t}\n\t\t\tnp = zip->entry_names;\n\t\t\tnl = ll;\n\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tentries[i].utf16name = np;\n#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)\n\t\t\t\tentries[i].wname = (wchar_t *)np;\n#endif\n\n\t\t\t\t/* Find a terminator. */\n\t\t\t\twhile (nl >= 2 && (np[0] || np[1])) {\n\t\t\t\t\tnp += 2;\n\t\t\t\t\tnl -= 2;\n\t\t\t\t}\n\t\t\t\tif (nl < 2)\n\t\t\t\t\treturn (-1);/* Terminator not found */\n\t\t\t\tentries[i].name_len = np - entries[i].utf16name;\n\t\t\t\tnp += 2;\n\t\t\t\tnl -= 2;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase kAttributes:\n\t\t{\n\t\t\tint allAreDefined;\n\n\t\t\tif ((p = header_bytes(a, 2)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tallAreDefined = *p;\n\t\t\th->attrBools = calloc((size_t)zip->numFiles,\n\t\t\t    sizeof(*h->attrBools));\n\t\t\tif (h->attrBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (allAreDefined)\n\t\t\t\tmemset(h->attrBools, 1, (size_t)zip->numFiles);\n\t\t\telse {\n\t\t\t\tif (read_Bools(a, h->attrBools,\n\t\t\t\t      (size_t)zip->numFiles) < 0)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tif (h->attrBools[i]) {\n\t\t\t\t\tif ((p = header_bytes(a, 4)) == NULL)\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\tentries[i].attr = archive_le32dec(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase kDummy:\n\t\t\tif (ll == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (header_bytes(a, ll) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Set up entry's attributes.\n\t */\n\tfolders = si->ci.folders;\n\teindex = sindex = 0;\n\tfolderIndex = indexInFolder = 0;\n\tfor (i = 0; i < zip->numFiles; i++) {\n\t\tif (h->emptyStreamBools == NULL || h->emptyStreamBools[i] == 0)\n\t\t\tentries[i].flg |= HAS_STREAM;\n\t\t/* The high 16 bits of attributes is a posix file mode. */\n\t\tentries[i].mode = entries[i].attr >> 16;\n\t\tif (entries[i].flg & HAS_STREAM) {\n\t\t\tif ((size_t)sindex >= si->ss.unpack_streams)\n\t\t\t\treturn (-1);\n\t\t\tif (entries[i].mode == 0)\n\t\t\t\tentries[i].mode = AE_IFREG | 0666;\n\t\t\tif (si->ss.digestsDefined[sindex])\n\t\t\t\tentries[i].flg |= CRC32_IS_SET;\n\t\t\tentries[i].ssIndex = sindex;\n\t\t\tsindex++;\n\t\t} else {\n\t\t\tint dir;\n\t\t\tif (h->emptyFileBools == NULL)\n\t\t\t\tdir = 1;\n\t\t\telse {\n\t\t\t\tif (h->emptyFileBools[eindex])\n\t\t\t\t\tdir = 0;\n\t\t\t\telse\n\t\t\t\t\tdir = 1;\n\t\t\t\teindex++;\n\t\t\t}\n\t\t\tif (entries[i].mode == 0) {\n\t\t\t\tif (dir)\n\t\t\t\t\tentries[i].mode = AE_IFDIR | 0777;\n\t\t\t\telse\n\t\t\t\t\tentries[i].mode = AE_IFREG | 0666;\n\t\t\t} else if (dir &&\n\t\t\t    (entries[i].mode & AE_IFMT) != AE_IFDIR) {\n\t\t\t\tentries[i].mode &= ~AE_IFMT;\n\t\t\t\tentries[i].mode |= AE_IFDIR;\n\t\t\t}\n\t\t\tif ((entries[i].mode & AE_IFMT) == AE_IFDIR &&\n\t\t\t    entries[i].name_len >= 2 &&\n\t\t\t    (entries[i].utf16name[entries[i].name_len-2] != '/' ||\n\t\t\t     entries[i].utf16name[entries[i].name_len-1] != 0)) {\n\t\t\t\tentries[i].utf16name[entries[i].name_len] = '/';\n\t\t\t\tentries[i].utf16name[entries[i].name_len+1] = 0;\n\t\t\t\tentries[i].name_len += 2;\n\t\t\t}\n\t\t\tentries[i].ssIndex = -1;\n\t\t}\n\t\tif (entries[i].attr & 0x01)\n\t\t\tentries[i].mode &= ~0222;/* Read only. */\n\n\t\tif ((entries[i].flg & HAS_STREAM) == 0 && indexInFolder == 0) {\n\t\t\t/*\n\t\t\t * The entry is an empty file or a directory file,\n\t\t\t * those both have no contents.\n\t\t\t */\n\t\t\tentries[i].folderIndex = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (indexInFolder == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tif (folderIndex >= si->ci.numFolders)\n\t\t\t\t\treturn (-1);\n\t\t\t\tif (folders[folderIndex].numUnpackStreams)\n\t\t\t\t\tbreak;\n\t\t\t\tfolderIndex++;\n\t\t\t}\n\t\t}\n\t\tentries[i].folderIndex = folderIndex;\n\t\tif ((entries[i].flg & HAS_STREAM) == 0)\n\t\t\tcontinue;\n\t\tindexInFolder++;\n\t\tif (indexInFolder >= folders[folderIndex].numUnpackStreams) {\n\t\t\tfolderIndex++;\n\t\t\tindexInFolder = 0;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n#define EPOC_TIME ARCHIVE_LITERAL_ULL(116444736000000000)\nstatic void\nfileTimeToUtc(uint64_t fileTime, time_t *timep, long *ns)\n{\n\n\tif (fileTime >= EPOC_TIME) {\n\t\tfileTime -= EPOC_TIME;\n\t\t/* milli seconds base */\n\t\t*timep = (time_t)(fileTime / 10000000);\n\t\t/* nano seconds base */\n\t\t*ns = (long)(fileTime % 10000000) * 100;\n\t} else {\n\t\t*timep = 0;\n\t\t*ns = 0;\n\t}\n}\n\nstatic int\nread_Times(struct archive_read *a, struct _7z_header_info *h, int type)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tstruct _7zip_entry *entries = zip->entries;\n\tunsigned char *timeBools;\n\tint allAreDefined;\n\tunsigned i;\n\n\ttimeBools = calloc((size_t)zip->numFiles, sizeof(*timeBools));\n\tif (timeBools == NULL)\n\t\treturn (-1);\n\n\t/* Read allAreDefined. */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tallAreDefined = *p;\n\tif (allAreDefined)\n\t\tmemset(timeBools, 1, (size_t)zip->numFiles);\n\telse {\n\t\tif (read_Bools(a, timeBools, (size_t)zip->numFiles) < 0)\n\t\t\tgoto failed;\n\t}\n\n\t/* Read external. */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p) {\n\t\tif (parse_7zip_uint64(a, &(h->dataIndex)) < 0)\n\t\t\tgoto failed;\n\t\tif (UMAX_ENTRY < h->dataIndex)\n\t\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < zip->numFiles; i++) {\n\t\tif (!timeBools[i])\n\t\t\tcontinue;\n\t\tif ((p = header_bytes(a, 8)) == NULL)\n\t\t\tgoto failed;\n\t\tswitch (type) {\n\t\tcase kCTime:\n\t\t\tfileTimeToUtc(archive_le64dec(p),\n\t\t\t    &(entries[i].ctime),\n\t\t\t    &(entries[i].ctime_ns));\n\t\t\tentries[i].flg |= CTIME_IS_SET;\n\t\t\tbreak;\n\t\tcase kATime:\n\t\t\tfileTimeToUtc(archive_le64dec(p),\n\t\t\t    &(entries[i].atime),\n\t\t\t    &(entries[i].atime_ns));\n\t\t\tentries[i].flg |= ATIME_IS_SET;\n\t\t\tbreak;\n\t\tcase kMTime:\n\t\t\tfileTimeToUtc(archive_le64dec(p),\n\t\t\t    &(entries[i].mtime),\n\t\t\t    &(entries[i].mtime_ns));\n\t\t\tentries[i].flg |= MTIME_IS_SET;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(timeBools);\n\treturn (0);\nfailed:\n\tfree(timeBools);\n\treturn (-1);\n}\n\nstatic int\ndecode_encoded_header_info(struct archive_read *a, struct _7z_stream_info *si)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\n\terrno = 0;\n\tif (read_StreamsInfo(a, si) < 0) {\n\t\tif (errno == ENOMEM)\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Couldn't allocate memory\");\n\t\telse\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (si->pi.numPackStreams == 0 || si->ci.numFolders == 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Malformed 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (zip->header_offset < si->pi.pos + si->pi.sizes[0] ||\n\t    (int64_t)(si->pi.pos + si->pi.sizes[0]) < 0 ||\n\t    si->pi.sizes[0] == 0 || (int64_t)si->pi.pos < 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Malformed Header offset\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic const unsigned char *\nheader_bytes(struct archive_read *a, size_t rbytes)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\n\tif (zip->header_bytes_remaining < rbytes)\n\t\treturn (NULL);\n\tif (zip->pack_stream_bytes_unconsumed)\n\t\tread_consume(a);\n\n\tif (zip->header_is_encoded == 0) {\n\t\tp = __archive_read_ahead(a, rbytes, NULL);\n\t\tif (p == NULL)\n\t\t\treturn (NULL);\n\t\tzip->header_bytes_remaining -= rbytes;\n\t\tzip->pack_stream_bytes_unconsumed = rbytes;\n\t} else {\n\t\tconst void *buff;\n\t\tssize_t bytes;\n\n\t\tbytes = read_stream(a, &buff, rbytes, rbytes);\n\t\tif (bytes <= 0)\n\t\t\treturn (NULL);\n\t\tzip->header_bytes_remaining -= bytes;\n\t\tp = buff;\n\t}\n\n\t/* Update checksum */\n\tzip->header_crc32 = crc32(zip->header_crc32, p, (unsigned)rbytes);\n\treturn (p);\n}\n\nstatic int\nslurp_central_directory(struct archive_read *a, struct _7zip *zip,\n    struct _7z_header_info *header)\n{\n\tconst unsigned char *p;\n\tuint64_t next_header_offset;\n\tuint64_t next_header_size;\n\tuint32_t next_header_crc;\n\tssize_t bytes_avail;\n\tint check_header_crc, r;\n\n\tif ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\n\tif ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0) {\n\t\t/* This is an executable ? Must be self-extracting... */\n\t\tr = skip_sfx(a, bytes_avail);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->seek_base += 32;\n\n\tif (memcmp(p, _7ZIP_SIGNATURE, 6) != 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Not 7-Zip archive file\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* CRC check. */\n\tif (crc32(0, (const unsigned char *)p + 12, 20)\n\t    != archive_le32dec(p + 8)) {\n\t\tarchive_set_error(&a->archive, -1, \"Header CRC error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tnext_header_offset = archive_le64dec(p + 12);\n\tnext_header_size = archive_le64dec(p + 20);\n\tnext_header_crc = archive_le32dec(p + 28);\n\n\tif (next_header_size == 0)\n\t\t/* There is no entry in an archive file. */\n\t\treturn (ARCHIVE_EOF);\n\n\tif (((int64_t)next_header_offset) < 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Malformed 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\t__archive_read_consume(a, 32);\n\tif (next_header_offset != 0) {\n\t\tif (bytes_avail >= (ssize_t)next_header_offset)\n\t\t\t__archive_read_consume(a, next_header_offset);\n\t\telse if (__archive_read_seek(a,\n\t\t    next_header_offset + zip->seek_base, SEEK_SET) < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->stream_offset = next_header_offset;\n\tzip->header_offset = next_header_offset;\n\tzip->header_bytes_remaining = next_header_size;\n\tzip->header_crc32 = 0;\n\tzip->header_is_encoded = 0;\n\tzip->header_is_being_read = 1;\n\tzip->has_encrypted_entries = 0;\n\tcheck_header_crc = 1;\n\n\tif ((p = header_bytes(a, 1)) == NULL) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated 7-Zip file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\t/* Parse ArchiveProperties. */\n\tswitch (p[0]) {\n\tcase kEncodedHeader:\n\t\t/*\n\t\t * The archive has an encoded header and we have to decode it\n\t\t * in order to parse the header correctly.\n\t\t */\n\t\tr = decode_encoded_header_info(a, &(zip->si));\n\n\t\t/* Check the EncodedHeader CRC.*/\n\t\tif (r == 0 && zip->header_crc32 != next_header_crc) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Damaged 7-Zip archive\");\n\t\t\tr = -1;\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (zip->si.ci.folders[0].digest_defined)\n\t\t\t\tnext_header_crc = zip->si.ci.folders[0].digest;\n\t\t\telse\n\t\t\t\tcheck_header_crc = 0;\n\t\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\t\tread_consume(a);\n\t\t\tr = setup_decode_folder(a, zip->si.ci.folders, 1);\n\t\t\tif (r == 0) {\n\t\t\t\tzip->header_bytes_remaining =\n\t\t\t\t\tzip->folder_outbytes_remaining;\n\t\t\t\tr = seek_pack(a);\n\t\t\t}\n\t\t}\n\t\t/* Clean up StreamsInfo. */\n\t\tfree_StreamsInfo(&(zip->si));\n\t\tmemset(&(zip->si), 0, sizeof(zip->si));\n\t\tif (r < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tzip->header_is_encoded = 1;\n\t\tzip->header_crc32 = 0;\n\t\t/* FALL THROUGH */\n\tcase kHeader:\n\t\t/*\n\t\t * Parse the header.\n\t\t */\n\t\terrno = 0;\n\t\tr = read_Header(a, header, zip->header_is_encoded);\n\t\tif (r < 0) {\n\t\t\tif (errno == ENOMEM)\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Couldn't allocate memory\");\n\t\t\telse\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Damaged 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/*\n\t\t *  Must be kEnd.\n\t\t */\n\t\tif ((p = header_bytes(a, 1)) == NULL ||*p != kEnd) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/* Check the Header CRC.*/\n\t\tif (check_header_crc && zip->header_crc32 != next_header_crc) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, -1,\n\t\t    \"Unexpected Property ID = %X\", p[0]);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Clean up variables be used for decoding the archive header */\n\tzip->pack_stream_remaining = 0;\n\tzip->pack_stream_index = 0;\n\tzip->folder_outbytes_remaining = 0;\n\tzip->uncompressed_buffer_bytes_remaining = 0;\n\tzip->pack_stream_bytes_unconsumed = 0;\n\tzip->header_is_being_read = 0;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nget_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t/* Copy mode. */\n\n\t\t/*\n\t\t * Note: '1' here is a performance optimization.\n\t\t * Recall that the decompression layer returns a count of\n\t\t * available bytes; asking for more than that forces the\n\t\t * decompressor to combine reads by copying data.\n\t\t */\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\t/* Decompression has failed. */\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\t/* Packed mode. */\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\t/*\n\t\t\t * If remaining uncompressed data size is less than\n\t\t\t * the minimum size, fill the buffer up to the\n\t\t\t * minimum size.\n\t\t\t */\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}\n\nstatic ssize_t\nextract_pack_stream(struct archive_read *a, size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\tint r;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\tif (minimum == 0)\n\t\t\tminimum = 1;\n\t\tif (__archive_read_ahead(a, minimum, &bytes_avail) == NULL\n\t\t    || bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (bytes_avail > (ssize_t)zip->pack_stream_inbytes_remaining)\n\t\t\tbytes_avail = (ssize_t)zip->pack_stream_inbytes_remaining;\n\t\tzip->pack_stream_inbytes_remaining -= bytes_avail;\n\t\tif (bytes_avail > (ssize_t)zip->folder_outbytes_remaining)\n\t\t\tbytes_avail = (ssize_t)zip->folder_outbytes_remaining;\n\t\tzip->folder_outbytes_remaining -= bytes_avail;\n\t\tzip->uncompressed_buffer_bytes_remaining = bytes_avail;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* If the buffer hasn't been allocated, allocate it now. */\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tzip->uncompressed_buffer_size = UBUFF_SIZE;\n\t\tif (zip->uncompressed_buffer_size < minimum) {\n\t\t\tzip->uncompressed_buffer_size = minimum + 1023;\n\t\t\tzip->uncompressed_buffer_size &= ~0x3ff;\n\t\t}\n\t\tzip->uncompressed_buffer =\n\t\t    malloc(zip->uncompressed_buffer_size);\n\t\tif (zip->uncompressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tzip->uncompressed_buffer_bytes_remaining = 0;\n\t} else if (zip->uncompressed_buffer_size < minimum ||\n\t    zip->uncompressed_buffer_bytes_remaining < minimum) {\n\t\t/*\n\t\t * Make sure the uncompressed buffer can have bytes\n\t\t * at least `minimum' bytes.\n\t\t * NOTE: This case happen when reading the header.\n\t\t */\n\t\tsize_t used;\n\t\tif (zip->uncompressed_buffer_pointer != 0)\n\t\t\tused = zip->uncompressed_buffer_pointer -\n\t\t\t\tzip->uncompressed_buffer;\n\t\telse\n\t\t\tused = 0;\n\t\tif (zip->uncompressed_buffer_size < minimum) {\n\t\t\t/*\n\t\t\t * Expand the uncompressed buffer up to\n\t\t\t * the minimum size.\n\t\t\t */\n\t\t\tvoid *p;\n\t\t\tsize_t new_size;\n\n\t\t\tnew_size = minimum + 1023;\n\t\t\tnew_size &= ~0x3ff;\n\t\t\tp = realloc(zip->uncompressed_buffer, new_size);\n\t\t\tif (p == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tzip->uncompressed_buffer = (unsigned char *)p;\n\t\t\tzip->uncompressed_buffer_size = new_size;\n\t\t}\n\t\t/*\n\t\t * Move unconsumed bytes to the head.\n\t\t */\n\t\tif (used) {\n\t\t\tmemmove(zip->uncompressed_buffer,\n\t\t\t\tzip->uncompressed_buffer + used,\n\t\t\t\tzip->uncompressed_buffer_bytes_remaining);\n\t\t}\n\t} else\n\t\tzip->uncompressed_buffer_bytes_remaining = 0;\n\tzip->uncompressed_buffer_pointer = NULL;\n\tfor (;;) {\n\t\tsize_t bytes_in, bytes_out;\n\t\tconst void *buff_in;\n\t\tunsigned char *buff_out;\n\t\tint end_of_data;\n\n\t\t/*\n\t\t * Note: '1' here is a performance optimization.\n\t\t * Recall that the decompression layer returns a count of\n\t\t * available bytes; asking for more than that forces the\n\t\t * decompressor to combine reads by copying data.\n\t\t */\n\t\tbuff_in = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tbuff_out = zip->uncompressed_buffer\n\t\t\t+ zip->uncompressed_buffer_bytes_remaining;\n\t\tbytes_out = zip->uncompressed_buffer_size\n\t\t\t- zip->uncompressed_buffer_bytes_remaining;\n\t\tbytes_in = bytes_avail;\n\t\tif (bytes_in > zip->pack_stream_inbytes_remaining)\n\t\t\tbytes_in = (size_t)zip->pack_stream_inbytes_remaining;\n\t\t/* Drive decompression. */\n\t\tr = decompress(a, zip, buff_out, &bytes_out,\n\t\t\tbuff_in, &bytes_in);\n\t\tswitch (r) {\n\t\tcase ARCHIVE_OK:\n\t\t\tend_of_data = 0;\n\t\t\tbreak;\n\t\tcase ARCHIVE_EOF:\n\t\t\tend_of_data = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tzip->pack_stream_inbytes_remaining -= bytes_in;\n\t\tif (bytes_out > zip->folder_outbytes_remaining)\n\t\t\tbytes_out = (size_t)zip->folder_outbytes_remaining;\n\t\tzip->folder_outbytes_remaining -= bytes_out;\n\t\tzip->uncompressed_buffer_bytes_remaining += bytes_out;\n\t\tzip->pack_stream_bytes_unconsumed = bytes_in;\n\n\t\t/*\n\t\t * Continue decompression until uncompressed_buffer is full.\n\t\t */\n\t\tif (zip->uncompressed_buffer_bytes_remaining ==\n\t\t    zip->uncompressed_buffer_size)\n\t\t\tbreak;\n\t\tif (zip->codec2 == _7Z_X86 && zip->odd_bcj_size &&\n\t\t    zip->uncompressed_buffer_bytes_remaining + 5 >\n\t\t    zip->uncompressed_buffer_size)\n\t\t\tbreak;\n\t\tif (zip->pack_stream_inbytes_remaining == 0 &&\n\t\t    zip->folder_outbytes_remaining == 0)\n\t\t\tbreak;\n\t\tif (end_of_data || (bytes_in == 0 && bytes_out == 0)) {\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tread_consume(a);\n\t}\n\tif (zip->uncompressed_buffer_bytes_remaining < minimum) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->uncompressed_buffer_pointer = zip->uncompressed_buffer;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nseek_pack(struct archive_read *a)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tint64_t pack_offset;\n\n\tif (zip->pack_stream_remaining <= 0) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->pack_stream_inbytes_remaining =\n\t    zip->si.pi.sizes[zip->pack_stream_index];\n\tpack_offset = zip->si.pi.positions[zip->pack_stream_index];\n\tif (zip->stream_offset != pack_offset) {\n\t\tif (0 > __archive_read_seek(a, pack_offset + zip->seek_base,\n\t\t    SEEK_SET))\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tzip->stream_offset = pack_offset;\n\t}\n\tzip->pack_stream_index++;\n\tzip->pack_stream_remaining--;\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nread_stream(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tuint64_t skip_bytes = 0;\n\tssize_t r;\n\n\tif (zip->uncompressed_buffer_bytes_remaining == 0) {\n\t\tif (zip->pack_stream_inbytes_remaining > 0) {\n\t\t\tr = extract_pack_stream(a, 0);\n\t\t\tif (r < 0)\n\t\t\t\treturn (r);\n\t\t\treturn (get_uncompressed_data(a, buff, size, minimum));\n\t\t} else if (zip->folder_outbytes_remaining > 0) {\n\t\t\t/* Extract a remaining pack stream. */\n\t\t\tr = extract_pack_stream(a, 0);\n\t\t\tif (r < 0)\n\t\t\t\treturn (r);\n\t\t\treturn (get_uncompressed_data(a, buff, size, minimum));\n\t\t}\n\t} else\n\t\treturn (get_uncompressed_data(a, buff, size, minimum));\n\n\t/*\n\t * Current pack stream has been consumed.\n\t */\n\tif (zip->pack_stream_remaining == 0) {\n\t\tif (zip->header_is_being_read) {\n\t\t\t/* Invalid sequence. This might happen when\n\t\t\t * reading a malformed archive. */\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC, \"Malformed 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/*\n\t\t * All current folder's pack streams have been\n\t\t * consumed. Switch to next folder.\n\t\t */\n\t\tif (zip->folder_index == 0 &&\n\t\t    (zip->si.ci.folders[zip->entry->folderIndex].skipped_bytes\n\t\t     || zip->folder_index != zip->entry->folderIndex)) {\n\t\t\tzip->folder_index = zip->entry->folderIndex;\n\t\t\tskip_bytes =\n\t\t\t    zip->si.ci.folders[zip->folder_index].skipped_bytes;\n\t\t}\n\n\t\tif (zip->folder_index >= zip->si.ci.numFolders) {\n\t\t\t/*\n\t\t\t * We have consumed all folders and its pack streams.\n\t\t\t */\n\t\t\t*buff = NULL;\n\t\t\treturn (0);\n\t\t}\n\t\tr = setup_decode_folder(a,\n\t\t\t&(zip->si.ci.folders[zip->folder_index]), 0);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tzip->folder_index++;\n\t}\n\n\t/*\n\t * Switch to next pack stream.\n\t */\n\tr = seek_pack(a);\n\tif (r < 0)\n\t\treturn (r);\n\n\t/* Extract a new pack stream. */\n\tr = extract_pack_stream(a, 0);\n\tif (r < 0)\n\t\treturn (r);\n\n\t/*\n\t * Skip the bytes we alrady has skipped in skip_stream().\n\t */\n\twhile (skip_bytes) {\n\t\tssize_t skipped;\n\n\t\tif (zip->uncompressed_buffer_bytes_remaining == 0) {\n\t\t\tif (zip->pack_stream_inbytes_remaining > 0) {\n\t\t\t\tr = extract_pack_stream(a, 0);\n\t\t\t\tif (r < 0)\n\t\t\t\t\treturn (r);\n\t\t\t} else if (zip->folder_outbytes_remaining > 0) {\n\t\t\t\t/* Extract a remaining pack stream. */\n\t\t\t\tr = extract_pack_stream(a, 0);\n\t\t\t\tif (r < 0)\n\t\t\t\t\treturn (r);\n\t\t\t} else {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tskipped = get_uncompressed_data(\n\t\t\ta, buff, (size_t)skip_bytes, 0);\n\t\tif (skipped < 0)\n\t\t\treturn (skipped);\n\t\tskip_bytes -= skipped;\n\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\tread_consume(a);\n\t}\n\n\treturn (get_uncompressed_data(a, buff, size, minimum));\n}\n\nstatic int\nsetup_decode_folder(struct archive_read *a, struct _7z_folder *folder,\n    int header)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst struct _7z_coder *coder1, *coder2;\n\tconst char *cname = (header)?\"archive header\":\"file content\";\n\tunsigned i;\n\tint r, found_bcj2 = 0;\n\n\t/*\n\t * Release the memory which the previous folder used for BCJ2.\n\t */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (zip->sub_stream_buff[i] != NULL)\n\t\t\tfree(zip->sub_stream_buff[i]);\n\t\tzip->sub_stream_buff[i] = NULL;\n\t}\n\n\t/*\n\t * Initialize a stream reader.\n\t */\n\tzip->pack_stream_remaining = (unsigned)folder->numPackedStreams;\n\tzip->pack_stream_index = (unsigned)folder->packIndex;\n\tzip->folder_outbytes_remaining = folder_uncompressed_size(folder);\n\tzip->uncompressed_buffer_bytes_remaining = 0;\n\n\t/*\n\t * Check coder types.\n\t */\n\tfor (i = 0; i < folder->numCoders; i++) {\n\t\tswitch(folder->coders[i].codec) {\n\t\t\tcase _7Z_CRYPTO_MAIN_ZIP:\n\t\t\tcase _7Z_CRYPTO_RAR_29:\n\t\t\tcase _7Z_CRYPTO_AES_256_SHA_256: {\n\t\t\t\t/* For entry that is associated with this folder, mark\n\t\t\t\t   it as encrypted (data+metadata). */\n\t\t\t\tzip->has_encrypted_entries = 1;\n\t\t\t\tif (a->entry) {\n\t\t\t\t\tarchive_entry_set_is_data_encrypted(a->entry, 1);\n\t\t\t\t\tarchive_entry_set_is_metadata_encrypted(a->entry, 1);\n\t\t\t\t}\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t\tARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\"The %s is encrypted, \"\n\t\t\t\t\t\"but currently not supported\", cname);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tcase _7Z_X86_BCJ2: {\n\t\t\t\tfound_bcj2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* Now that we've checked for encryption, if there were still no\n\t * encrypted entries found we can say for sure that there are none.\n\t */\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\tif ((folder->numCoders > 2 && !found_bcj2) || found_bcj2 > 1) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"The %s is encoded with many filters, \"\n\t\t    \"but currently not supported\", cname);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tcoder1 = &(folder->coders[0]);\n\tif (folder->numCoders == 2)\n\t\tcoder2 = &(folder->coders[1]);\n\telse\n\t\tcoder2 = NULL;\n\n\tif (found_bcj2) {\n\t\t/*\n\t\t * Preparation to decode BCJ2.\n\t\t * Decoding BCJ2 requires four sources. Those are at least,\n\t\t * as far as I know, two types of the storage form.\n\t\t */\n\t\tconst struct _7z_coder *fc = folder->coders;\n\t\tstatic const struct _7z_coder coder_copy = {0, 1, 1, 0, NULL};\n\t\tconst struct _7z_coder *scoder[3] =\n\t\t\t{&coder_copy, &coder_copy, &coder_copy};\n\t\tconst void *buff;\n\t\tssize_t bytes;\n\t\tunsigned char *b[3] = {NULL, NULL, NULL};\n\t\tuint64_t sunpack[3] ={-1, -1, -1};\n\t\tsize_t s[3] = {0, 0, 0};\n\t\tint idx[3] = {0, 1, 2};\n\n\t\tif (folder->numCoders == 4 && fc[3].codec == _7Z_X86_BCJ2 &&\n\t\t    folder->numInStreams == 7 && folder->numOutStreams == 4 &&\n\t\t    zip->pack_stream_remaining == 4) {\n\t\t\t/* Source type 1 made by 7zr or 7z with -m options. */\n\t\t\tif (folder->bindPairs[0].inIndex == 5) {\n\t\t\t\t/* The form made by 7zr */\n\t\t\t\tidx[0] = 1; idx[1] = 2; idx[2] = 0;\n\t\t\t\tscoder[1] = &(fc[1]);\n\t\t\t\tscoder[2] = &(fc[0]);\n\t\t\t\tsunpack[1] = folder->unPackSize[1];\n\t\t\t\tsunpack[2] = folder->unPackSize[0];\n\t\t\t\tcoder1 = &(fc[2]);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * NOTE: Some patterns do not work.\n\t\t\t\t * work:\n\t\t\t\t *  7z a -m0=BCJ2 -m1=COPY -m2=COPY\n\t\t\t\t *       -m3=(any)\n\t\t\t\t *  7z a -m0=BCJ2 -m1=COPY -m2=(any)\n\t\t\t\t *       -m3=COPY\n\t\t\t\t *  7z a -m0=BCJ2 -m1=(any) -m2=COPY\n\t\t\t\t *       -m3=COPY\n\t\t\t\t * not work:\n\t\t\t\t *  other patterns.\n\t\t\t\t *\n\t\t\t\t * We have to handle this like `pipe' or\n\t\t\t\t * our libarchive7s filter frame work,\n\t\t\t\t * decoding the BCJ2 main stream sequentially,\n\t\t\t\t * m3 -> m2 -> m1 -> BCJ2.\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (fc[0].codec == _7Z_COPY &&\n\t\t\t\t    fc[1].codec == _7Z_COPY)\n\t\t\t\t\tcoder1 = &(folder->coders[2]);\n\t\t\t\telse if (fc[0].codec == _7Z_COPY &&\n\t\t\t\t    fc[2].codec == _7Z_COPY)\n\t\t\t\t\tcoder1 = &(folder->coders[1]);\n\t\t\t\telse if (fc[1].codec == _7Z_COPY &&\n\t\t\t\t    fc[2].codec == _7Z_COPY)\n\t\t\t\t\tcoder1 = &(folder->coders[0]);\n\t\t\t\telse {\n\t\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t    \"Unsupported form of \"\n\t\t\t\t\t    \"BCJ2 streams\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcoder2 = &(fc[3]);\n\t\t\tzip->main_stream_bytes_remaining =\n\t\t\t\t(size_t)folder->unPackSize[2];\n\t\t} else if (coder2 != NULL && coder2->codec == _7Z_X86_BCJ2 &&\n\t\t    zip->pack_stream_remaining == 4 &&\n\t\t    folder->numInStreams == 5 && folder->numOutStreams == 2) {\n\t\t\t/* Source type 0 made by 7z */\n\t\t\tzip->main_stream_bytes_remaining =\n\t\t\t\t(size_t)folder->unPackSize[0];\n\t\t} else {\n\t\t\t/* We got an unexpected form. */\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported form of BCJ2 streams\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/* Skip the main stream at this time. */\n\t\tif ((r = seek_pack(a)) < 0)\n\t\t\treturn (r);\n\t\tzip->pack_stream_bytes_unconsumed =\n\t\t    (size_t)zip->pack_stream_inbytes_remaining;\n\t\tread_consume(a);\n\n\t\t/* Read following three sub streams. */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tconst struct _7z_coder *coder = scoder[i];\n\n\t\t\tif ((r = seek_pack(a)) < 0) {\n\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\treturn (r);\n\t\t\t}\n\n\t\t\tif (sunpack[i] == (uint64_t)-1)\n\t\t\t\tzip->folder_outbytes_remaining =\n\t\t\t\t    zip->pack_stream_inbytes_remaining;\n\t\t\telse\n\t\t\t\tzip->folder_outbytes_remaining = sunpack[i];\n\n\t\t\tr = init_decompression(a, zip, coder, NULL);\n\t\t\tif (r != ARCHIVE_OK) {\n\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\n\t\t\t/* Allocate memory for the decorded data of a sub\n\t\t\t * stream. */\n\t\t\tb[i] = malloc((size_t)zip->folder_outbytes_remaining);\n\t\t\tif (b[i] == NULL) {\n\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\n\t\t\t/* Extract a sub stream. */\n\t\t\twhile (zip->pack_stream_inbytes_remaining > 0) {\n\t\t\t\tr = (int)extract_pack_stream(a, 0);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\t\treturn (r);\n\t\t\t\t}\n\t\t\t\tbytes = get_uncompressed_data(a, &buff,\n\t\t\t\t    zip->uncompressed_buffer_bytes_remaining,\n\t\t\t\t    0);\n\t\t\t\tif (bytes < 0) {\n\t\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\t\treturn ((int)bytes);\n\t\t\t\t}\n\t\t\t\tmemcpy(b[i]+s[i], buff, bytes);\n\t\t\t\ts[i] += bytes;\n\t\t\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\t\t\tread_consume(a);\n\t\t\t}\n\t\t}\n\n\t\t/* Set the sub streams to the right place. */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tzip->sub_stream_buff[i] = b[idx[i]];\n\t\t\tzip->sub_stream_size[i] = s[idx[i]];\n\t\t\tzip->sub_stream_bytes_remaining[i] = s[idx[i]];\n\t\t}\n\n\t\t/* Allocate memory used for decoded main stream bytes. */\n\t\tif (zip->tmp_stream_buff == NULL) {\n\t\t\tzip->tmp_stream_buff_size = 32 * 1024;\n\t\t\tzip->tmp_stream_buff =\n\t\t\t    malloc(zip->tmp_stream_buff_size);\n\t\t\tif (zip->tmp_stream_buff == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tzip->tmp_stream_bytes_avail = 0;\n\t\tzip->tmp_stream_bytes_remaining = 0;\n\t\tzip->odd_bcj_size = 0;\n\t\tzip->bcj2_outPos = 0;\n\n\t\t/*\n\t\t * Reset a stream reader in order to read the main stream\n\t\t * of BCJ2.\n\t\t */\n\t\tzip->pack_stream_remaining = 1;\n\t\tzip->pack_stream_index = (unsigned)folder->packIndex;\n\t\tzip->folder_outbytes_remaining =\n\t\t    folder_uncompressed_size(folder);\n\t\tzip->uncompressed_buffer_bytes_remaining = 0;\n\t}\n\n\t/*\n\t * Initialize the decompressor for the new folder's pack streams.\n\t */\n\tr = init_decompression(a, zip, coder1, coder2);\n\tif (r != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int64_t\nskip_stream(struct archive_read *a, size_t skip_bytes)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst void *p;\n\tint64_t skipped_bytes;\n\tsize_t bytes = skip_bytes;\n\n\tif (zip->folder_index == 0) {\n\t\t/*\n\t\t * Optimization for a list mode.\n\t\t * Avoid unncecessary decoding operations.\n\t\t */\n\t\tzip->si.ci.folders[zip->entry->folderIndex].skipped_bytes\n\t\t    += skip_bytes;\n\t\treturn (skip_bytes);\n\t}\n\n\twhile (bytes) {\n\t\tskipped_bytes = read_stream(a, &p, bytes, 0);\n\t\tif (skipped_bytes < 0)\n\t\t\treturn (skipped_bytes);\n\t\tif (skipped_bytes == 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tbytes -= (size_t)skipped_bytes;\n\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\tread_consume(a);\n\t}\n\treturn (skip_bytes);\n}\n\n/*\n * Brought from LZMA SDK.\n *\n * Bra86.c -- Converter for x86 code (BCJ)\n * 2008-10-04 : Igor Pavlov : Public domain\n *\n */\n\n#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)\n\nstatic void\nx86_Init(struct _7zip *zip)\n{\n\tzip->bcj_state = 0;\n\tzip->bcj_prevPosT = (size_t)0 - 1;\n\tzip->bcj_prevMask = 0;\n\tzip->bcj_ip = 5;\n}\n\nstatic size_t\nx86_Convert(struct _7zip *zip, uint8_t *data, size_t size)\n{\n\tstatic const uint8_t kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};\n\tstatic const uint8_t kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};\n\tsize_t bufferPos, prevPosT;\n\tuint32_t ip, prevMask;\n\n\tif (size < 5)\n\t\treturn 0;\n\n\tbufferPos = 0;\n\tprevPosT = zip->bcj_prevPosT;\n\tprevMask = zip->bcj_prevMask;\n\tip = zip->bcj_ip;\n\n\tfor (;;) {\n\t\tuint8_t *p = data + bufferPos;\n\t\tuint8_t *limit = data + size - 4;\n\n\t\tfor (; p < limit; p++)\n\t\t\tif ((*p & 0xFE) == 0xE8)\n\t\t\t\tbreak;\n\t\tbufferPos = (size_t)(p - data);\n\t\tif (p >= limit)\n\t\t\tbreak;\n\t\tprevPosT = bufferPos - prevPosT;\n\t\tif (prevPosT > 3)\n\t\t\tprevMask = 0;\n\t\telse {\n\t\t\tprevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;\n\t\t\tif (prevMask != 0) {\n\t\t\t\tunsigned char b =\n\t\t\t\t\tp[4 - kMaskToBitNumber[prevMask]];\n\t\t\t\tif (!kMaskToAllowedStatus[prevMask] ||\n\t\t\t\t    Test86MSByte(b)) {\n\t\t\t\t\tprevPosT = bufferPos;\n\t\t\t\t\tprevMask = ((prevMask << 1) & 0x7) | 1;\n\t\t\t\t\tbufferPos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprevPosT = bufferPos;\n\n\t\tif (Test86MSByte(p[4])) {\n\t\t\tuint32_t src = ((uint32_t)p[4] << 24) |\n\t\t\t\t((uint32_t)p[3] << 16) | ((uint32_t)p[2] << 8) |\n\t\t\t\t((uint32_t)p[1]);\n\t\t\tuint32_t dest;\n\t\t\tfor (;;) {\n\t\t\t\tuint8_t b;\n\t\t\t\tint b_index;\n\n\t\t\t\tdest = src - (ip + (uint32_t)bufferPos);\n\t\t\t\tif (prevMask == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb_index = kMaskToBitNumber[prevMask] * 8;\n\t\t\t\tb = (uint8_t)(dest >> (24 - b_index));\n\t\t\t\tif (!Test86MSByte(b))\n\t\t\t\t\tbreak;\n\t\t\t\tsrc = dest ^ ((1 << (32 - b_index)) - 1);\n\t\t\t}\n\t\t\tp[4] = (uint8_t)(~(((dest >> 24) & 1) - 1));\n\t\t\tp[3] = (uint8_t)(dest >> 16);\n\t\t\tp[2] = (uint8_t)(dest >> 8);\n\t\t\tp[1] = (uint8_t)dest;\n\t\t\tbufferPos += 5;\n\t\t} else {\n\t\t\tprevMask = ((prevMask << 1) & 0x7) | 1;\n\t\t\tbufferPos++;\n\t\t}\n\t}\n\tzip->bcj_prevPosT = prevPosT;\n\tzip->bcj_prevMask = prevMask;\n\tzip->bcj_ip += (uint32_t)bufferPos;\n\treturn (bufferPos);\n}\n\n/*\n * Brought from LZMA SDK.\n *\n * Bcj2.c -- Converter for x86 code (BCJ2)\n * 2008-10-04 : Igor Pavlov : Public domain\n *\n */\n\n#define SZ_ERROR_DATA\t ARCHIVE_FAILED\n\n#define IsJcc(b0, b1) ((b0) == 0x0F && ((b1) & 0xF0) == 0x80)\n#define IsJ(b0, b1) ((b1 & 0xFE) == 0xE8 || IsJcc(b0, b1))\n\n#define kNumTopBits 24\n#define kTopValue ((uint32_t)1 << kNumTopBits)\n\n#define kNumBitModelTotalBits 11\n#define kBitModelTotal (1 << kNumBitModelTotalBits)\n#define kNumMoveBits 5\n\n#define RC_READ_BYTE (*buffer++)\n#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }\n#define RC_INIT2 zip->bcj2_code = 0; zip->bcj2_range = 0xFFFFFFFF; \\\n  { int ii; for (ii = 0; ii < 5; ii++) { RC_TEST; zip->bcj2_code = (zip->bcj2_code << 8) | RC_READ_BYTE; }}\n\n#define NORMALIZE if (zip->bcj2_range < kTopValue) { RC_TEST; zip->bcj2_range <<= 8; zip->bcj2_code = (zip->bcj2_code << 8) | RC_READ_BYTE; }\n\n#define IF_BIT_0(p) ttt = *(p); bound = (zip->bcj2_range >> kNumBitModelTotalBits) * ttt; if (zip->bcj2_code < bound)\n#define UPDATE_0(p) zip->bcj2_range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits)); NORMALIZE;\n#define UPDATE_1(p) zip->bcj2_range -= bound; zip->bcj2_code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;\n\nstatic ssize_t\nBcj2_Decode(struct _7zip *zip, uint8_t *outBuf, size_t outSize)\n{\n\tsize_t inPos = 0, outPos = 0;\n\tconst uint8_t *buf0, *buf1, *buf2, *buf3;\n\tsize_t size0, size1, size2, size3;\n\tconst uint8_t *buffer, *bufferLim;\n\tunsigned int i, j;\n\n\tsize0 = zip->tmp_stream_bytes_remaining;\n\tbuf0 = zip->tmp_stream_buff + zip->tmp_stream_bytes_avail - size0;\n\tsize1 = zip->sub_stream_bytes_remaining[0];\n\tbuf1 = zip->sub_stream_buff[0] + zip->sub_stream_size[0] - size1;\n\tsize2 = zip->sub_stream_bytes_remaining[1];\n\tbuf2 = zip->sub_stream_buff[1] + zip->sub_stream_size[1] - size2;\n\tsize3 = zip->sub_stream_bytes_remaining[2];\n\tbuf3 = zip->sub_stream_buff[2] + zip->sub_stream_size[2] - size3;\n\n\tbuffer = buf3;\n\tbufferLim = buffer + size3;\n\n\tif (zip->bcj_state == 0) {\n\t\t/*\n\t\t * Initialize.\n\t\t */\n\t\tzip->bcj2_prevByte = 0;\n\t\tfor (i = 0;\n\t\t    i < sizeof(zip->bcj2_p) / sizeof(zip->bcj2_p[0]); i++)\n\t\t\tzip->bcj2_p[i] = kBitModelTotal >> 1;\n\t\tRC_INIT2;\n\t\tzip->bcj_state = 1;\n\t}\n\n\t/*\n\t * Gather the odd bytes of a previous call.\n\t */\n\tfor (i = 0; zip->odd_bcj_size > 0 && outPos < outSize; i++) {\n\t\toutBuf[outPos++] = zip->odd_bcj[i];\n\t\tzip->odd_bcj_size--;\n\t}\n\n\tif (outSize == 0) {\n\t\tzip->bcj2_outPos += outPos;\n\t\treturn (outPos);\n\t}\n\n\tfor (;;) {\n\t\tuint8_t b;\n\t\tCProb *prob;\n\t\tuint32_t bound;\n\t\tuint32_t ttt;\n\n\t\tsize_t limit = size0 - inPos;\n\t\tif (outSize - outPos < limit)\n\t\t\tlimit = outSize - outPos;\n\n\t\tif (zip->bcj_state == 1) {\n\t\t\twhile (limit != 0) {\n\t\t\t\tuint8_t bb = buf0[inPos];\n\t\t\t\toutBuf[outPos++] = bb;\n\t\t\t\tif (IsJ(zip->bcj2_prevByte, bb)) {\n\t\t\t\t\tzip->bcj_state = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinPos++;\n\t\t\t\tzip->bcj2_prevByte = bb;\n\t\t\t\tlimit--;\n\t\t\t}\n\t\t}\n\n\t\tif (limit == 0 || outPos == outSize)\n\t\t\tbreak;\n\t\tzip->bcj_state = 1;\n\n\t\tb = buf0[inPos++];\n\n\t\tif (b == 0xE8)\n\t\t\tprob = zip->bcj2_p + zip->bcj2_prevByte;\n\t\telse if (b == 0xE9)\n\t\t\tprob = zip->bcj2_p + 256;\n\t\telse\n\t\t\tprob = zip->bcj2_p + 257;\n\n\t\tIF_BIT_0(prob) {\n\t\t\tUPDATE_0(prob)\n\t\t\tzip->bcj2_prevByte = b;\n\t\t} else {\n\t\t\tuint32_t dest;\n\t\t\tconst uint8_t *v;\n\t\t\tuint8_t out[4];\n\n\t\t\tUPDATE_1(prob)\n\t\t\tif (b == 0xE8) {\n\t\t\t\tv = buf1;\n\t\t\t\tif (size1 < 4)\n\t\t\t\t\treturn SZ_ERROR_DATA;\n\t\t\t\tbuf1 += 4;\n\t\t\t\tsize1 -= 4;\n\t\t\t} else {\n\t\t\t\tv = buf2;\n\t\t\t\tif (size2 < 4)\n\t\t\t\t\treturn SZ_ERROR_DATA;\n\t\t\t\tbuf2 += 4;\n\t\t\t\tsize2 -= 4;\n\t\t\t}\n\t\t\tdest = (((uint32_t)v[0] << 24) |\n\t\t\t    ((uint32_t)v[1] << 16) |\n\t\t\t    ((uint32_t)v[2] << 8) |\n\t\t\t    ((uint32_t)v[3])) -\n\t\t\t    ((uint32_t)zip->bcj2_outPos + (uint32_t)outPos + 4);\n\t\t\tout[0] = (uint8_t)dest;\n\t\t\tout[1] = (uint8_t)(dest >> 8);\n\t\t\tout[2] = (uint8_t)(dest >> 16);\n\t\t\tout[3] = zip->bcj2_prevByte = (uint8_t)(dest >> 24);\n\n\t\t\tfor (i = 0; i < 4 && outPos < outSize; i++)\n\t\t\t\toutBuf[outPos++] = out[i];\n\t\t\tif (i < 4) {\n\t\t\t\t/*\n\t\t\t\t * Save odd bytes which we could not add into\n\t\t\t\t * the output buffer because of out of space.\n\t\t\t\t */\n\t\t\t\tzip->odd_bcj_size = 4 -i;\n\t\t\t\tfor (; i < 4; i++) {\n\t\t\t\t\tj = i - 4 + (unsigned)zip->odd_bcj_size;\n\t\t\t\t\tzip->odd_bcj[j] = out[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tzip->tmp_stream_bytes_remaining -= inPos;\n\tzip->sub_stream_bytes_remaining[0] = size1;\n\tzip->sub_stream_bytes_remaining[1] = size2;\n\tzip->sub_stream_bytes_remaining[2] = bufferLim - buffer;\n\tzip->bcj2_outPos += outPos;\n\n\treturn ((ssize_t)outPos);\n}\n\n"], "fixing_code": ["/*-\n * Copyright (c) 2011 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD$\");\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_BZLIB_H\n#include <bzlib.h>\n#endif\n#ifdef HAVE_LZMA_H\n#include <lzma.h>\n#endif\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_ppmd7_private.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n#include \"archive_endian.h\"\n\n#ifndef HAVE_ZLIB_H\n#include \"archive_crc32.h\"\n#endif\n\n#define _7ZIP_SIGNATURE\t\"7z\\xBC\\xAF\\x27\\x1C\"\n#define SFX_MIN_ADDR\t0x27000\n#define SFX_MAX_ADDR\t0x60000\n\n\n/*\n * Codec ID\n */\n#define _7Z_COPY\t0\n#define _7Z_LZMA\t0x030101\n#define _7Z_LZMA2\t0x21\n#define _7Z_DEFLATE\t0x040108\n#define _7Z_BZ2\t\t0x040202\n#define _7Z_PPMD\t0x030401\n#define _7Z_DELTA\t0x03\n#define _7Z_CRYPTO_MAIN_ZIP\t\t\t0x06F10101 /* Main Zip crypto algo */\n#define _7Z_CRYPTO_RAR_29\t\t\t0x06F10303 /* Rar29 AES-128 + (modified SHA-1) */\n#define _7Z_CRYPTO_AES_256_SHA_256\t0x06F10701 /* AES-256 + SHA-256 */\n\n\n#define _7Z_X86\t\t0x03030103\n#define _7Z_X86_BCJ2\t0x0303011B\n#define _7Z_POWERPC\t0x03030205\n#define _7Z_IA64\t0x03030401\n#define _7Z_ARM\t\t0x03030501\n#define _7Z_ARMTHUMB\t0x03030701\n#define _7Z_SPARC\t0x03030805\n\n/*\n * 7-Zip header property IDs.\n */\n#define kEnd\t\t\t0x00\n#define kHeader\t\t\t0x01\n#define kArchiveProperties\t0x02\n#define kAdditionalStreamsInfo\t0x03\n#define kMainStreamsInfo\t0x04\n#define kFilesInfo\t\t0x05\n#define kPackInfo\t\t0x06\n#define kUnPackInfo\t\t0x07\n#define kSubStreamsInfo\t\t0x08\n#define kSize\t\t\t0x09\n#define kCRC\t\t\t0x0A\n#define kFolder\t\t\t0x0B\n#define kCodersUnPackSize\t0x0C\n#define kNumUnPackStream\t0x0D\n#define kEmptyStream\t\t0x0E\n#define kEmptyFile\t\t0x0F\n#define kAnti\t\t\t0x10\n#define kName\t\t\t0x11\n#define kCTime\t\t\t0x12\n#define kATime\t\t\t0x13\n#define kMTime\t\t\t0x14\n#define kAttributes\t\t0x15\n#define kEncodedHeader\t\t0x17\n#define kDummy\t\t\t0x19\n\nstruct _7z_digests {\n\tunsigned char\t*defineds;\n\tuint32_t\t*digests;\n};\n\n\nstruct _7z_folder {\n\tuint64_t\t\t numCoders;\n\tstruct _7z_coder {\n\t\tunsigned long\t codec;\n\t\tuint64_t\t numInStreams;\n\t\tuint64_t\t numOutStreams;\n\t\tuint64_t\t propertiesSize;\n\t\tunsigned char\t*properties;\n\t} *coders;\n\tuint64_t\t\t numBindPairs;\n\tstruct {\n\t\tuint64_t\t inIndex;\n\t\tuint64_t\t outIndex;\n\t} *bindPairs;\n\tuint64_t\t\t numPackedStreams;\n\tuint64_t\t\t*packedStreams;\n\tuint64_t\t\t numInStreams;\n\tuint64_t\t\t numOutStreams;\n\tuint64_t\t\t*unPackSize;\n\tunsigned char\t\t digest_defined;\n\tuint32_t\t\t digest;\n\tuint64_t\t\t numUnpackStreams;\n\tuint32_t\t\t packIndex;\n\t/* Unoperated bytes. */\n\tuint64_t\t\t skipped_bytes;\n};\n\nstruct _7z_coders_info {\n\tuint64_t\t\t numFolders;\n\tstruct _7z_folder\t*folders;\n\tuint64_t\t\t dataStreamIndex;\n};\n\nstruct _7z_pack_info {\n\tuint64_t\t\t pos;\n\tuint64_t\t\t numPackStreams;\n\tuint64_t\t\t*sizes;\n\tstruct _7z_digests\t digest;\n\t/* Calculated from pos and numPackStreams. */\n\tuint64_t\t\t*positions;\n};\n\nstruct _7z_substream_info {\n\tsize_t\t\t\t unpack_streams;\n\tuint64_t\t\t*unpackSizes;\n\tunsigned char\t\t*digestsDefined;\n\tuint32_t\t\t*digests;\n};\n\nstruct _7z_stream_info {\n\tstruct _7z_pack_info\t pi;\n\tstruct _7z_coders_info\t ci;\n\tstruct _7z_substream_info ss;\n};\n\nstruct _7z_header_info {\n\tuint64_t\t\t dataIndex;\n\n\tunsigned char\t\t*emptyStreamBools;\n\tunsigned char\t\t*emptyFileBools;\n\tunsigned char\t\t*antiBools;\n\tunsigned char\t\t*attrBools;\n};\n\nstruct _7zip_entry {\n\tsize_t\t\t\t name_len;\n\tunsigned char\t\t*utf16name;\n#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)\n\tconst wchar_t\t\t*wname;\n#endif\n\tuint32_t\t\t folderIndex;\n\tuint32_t\t\t ssIndex;\n\tunsigned\t\t flg;\n#define MTIME_IS_SET\t(1<<0)\n#define ATIME_IS_SET\t(1<<1)\n#define CTIME_IS_SET\t(1<<2)\n#define CRC32_IS_SET\t(1<<3)\n#define HAS_STREAM\t(1<<4)\n\n\ttime_t\t\t\t mtime;\n\ttime_t\t\t\t atime;\n\ttime_t\t\t\t ctime;\n\tlong\t\t\t mtime_ns;\n\tlong\t\t\t atime_ns;\n\tlong\t\t\t ctime_ns;\n\tuint32_t\t\t mode;\n\tuint32_t\t\t attr;\n};\n\nstruct _7zip {\n\t/* Structural information about the archive. */\n\tstruct _7z_stream_info\t si;\n\n\tint\t\t\t header_is_being_read;\n\tint\t\t\t header_is_encoded;\n\tuint64_t\t\t header_bytes_remaining;\n\tunsigned long\t\t header_crc32;\n\t/* Header offset to check that reading pointes of the file contens\n\t * will not exceed the header. */\n\tuint64_t\t\t header_offset;\n\t/* Base offset of the archive file for a seek in case reading SFX. */\n\tuint64_t\t\t seek_base;\n\n\t/* List of entries */\n\tsize_t\t\t\t entries_remaining;\n\tuint64_t\t\t numFiles;\n\tstruct _7zip_entry\t*entries;\n\tstruct _7zip_entry\t*entry;\n\tunsigned char\t\t*entry_names;\n\n\t/* entry_bytes_remaining is the number of bytes we expect. */\n\tint64_t\t\t\t entry_offset;\n\tuint64_t\t\t entry_bytes_remaining;\n\n\t/* Running CRC32 of the decompressed data */\n\tunsigned long\t\t entry_crc32;\n\n\t/* Flags to mark progress of decompression. */\n\tchar\t\t\t end_of_entry;\n\n\t/* Uncompressed buffer control.  */\n#define UBUFF_SIZE\t(64 * 1024)\n\tunsigned char \t\t*uncompressed_buffer;\n\tunsigned char \t\t*uncompressed_buffer_pointer;\n\tsize_t \t\t\t uncompressed_buffer_size;\n\tsize_t\t\t\t uncompressed_buffer_bytes_remaining;\n\n\t/* Offset of the compressed data. */\n\tint64_t\t\t\t stream_offset;\n\n\t/*\n\t * Decompressing control data.\n\t */\n\tunsigned\t\t folder_index;\n\tuint64_t\t\t folder_outbytes_remaining;\n\tunsigned\t\t pack_stream_index;\n\tunsigned\t\t pack_stream_remaining;\n\tuint64_t\t\t pack_stream_inbytes_remaining;\n\tsize_t\t\t\t pack_stream_bytes_unconsumed;\n\n\t/* The codec information of a folder. */\n\tunsigned long\t\t codec;\n\tunsigned long\t\t codec2;\n\n\t/*\n\t * Decompressor controllers.\n\t */\n\t/* Decording LZMA1 and LZMA2 data. */\n#ifdef HAVE_LZMA_H\n\tlzma_stream\t\t lzstream;\n\tint\t\t\t lzstream_valid;\n#endif\n\t/* Decording bzip2 data. */\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tbz_stream\t\t bzstream;\n\tint\t\t\t bzstream_valid;\n#endif\n\t/* Decording deflate data. */\n#ifdef HAVE_ZLIB_H\n\tz_stream\t\t stream;\n\tint\t\t\t stream_valid;\n#endif\n\t/* Decording PPMd data. */\n\tint\t\t\t ppmd7_stat;\n\tCPpmd7\t\t\t ppmd7_context;\n\tCPpmd7z_RangeDec\t range_dec;\n\tIByteIn\t\t\t bytein;\n\tstruct {\n\t\tconst unsigned char\t*next_in;\n\t\tint64_t\t\t\t avail_in;\n\t\tint64_t\t\t\t total_in;\n\t\tunsigned char\t\t*next_out;\n\t\tint64_t\t\t\t avail_out;\n\t\tint64_t\t\t\t total_out;\n\t\tint\t\t\t overconsumed;\n\t} ppstream;\n\tint\t\t\t ppmd7_valid;\n\n\t/* Decoding BCJ and BCJ2 data. */\n\tuint32_t\t\t bcj_state;\n\tsize_t\t\t\t odd_bcj_size;\n\tunsigned char\t\t odd_bcj[4];\n\t/* Decoding BCJ data. */\n\tsize_t\t\t\t bcj_prevPosT;\n\tuint32_t\t\t bcj_prevMask;\n\tuint32_t\t\t bcj_ip;\n\n\t/* Decoding BCJ2 data. */\n\tsize_t\t\t\t main_stream_bytes_remaining;\n\tunsigned char\t\t*sub_stream_buff[3];\n\tsize_t\t\t\t sub_stream_size[3];\n\tsize_t\t\t\t sub_stream_bytes_remaining[3];\n\tunsigned char\t\t*tmp_stream_buff;\n\tsize_t\t\t\t tmp_stream_buff_size;\n\tsize_t\t\t\t tmp_stream_bytes_avail;\n\tsize_t\t\t\t tmp_stream_bytes_remaining;\n#ifdef _LZMA_PROB32\n#define CProb uint32_t\n#else\n#define CProb uint16_t\n#endif\n\tCProb\t\t\t bcj2_p[256 + 2];\n\tuint8_t\t\t\t bcj2_prevByte;\n\tuint32_t\t\t bcj2_range;\n\tuint32_t\t\t bcj2_code;\n\tuint64_t\t\t bcj2_outPos;\n\n\t/* Filename character-set conversion data. */\n\tstruct archive_string_conv *sconv;\n\n\tchar\t\t\t format_name[64];\n\n\t/* Custom value that is non-zero if this archive contains encrypted entries. */\n\tint\t\t\t has_encrypted_entries;\n};\n\n/* Maximum entry size. This limitation prevents reading intentional\n * corrupted 7-zip files on assuming there are not so many entries in\n * the files. */\n#define UMAX_ENTRY\tARCHIVE_LITERAL_ULL(100000000)\n\nstatic int\tarchive_read_format_7zip_has_encrypted_entries(struct archive_read *);\nstatic int\tarchive_read_support_format_7zip_capabilities(struct archive_read *a);\nstatic int\tarchive_read_format_7zip_bid(struct archive_read *, int);\nstatic int\tarchive_read_format_7zip_cleanup(struct archive_read *);\nstatic int\tarchive_read_format_7zip_read_data(struct archive_read *,\n\t\t    const void **, size_t *, int64_t *);\nstatic int\tarchive_read_format_7zip_read_data_skip(struct archive_read *);\nstatic int\tarchive_read_format_7zip_read_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int\tcheck_7zip_header_in_sfx(const char *);\nstatic unsigned long decode_codec_id(const unsigned char *, size_t);\nstatic int\tdecode_encoded_header_info(struct archive_read *,\n\t\t    struct _7z_stream_info *);\nstatic int\tdecompress(struct archive_read *, struct _7zip *,\n\t\t    void *, size_t *, const void *, size_t *);\nstatic ssize_t\textract_pack_stream(struct archive_read *, size_t);\nstatic void\tfileTimeToUtc(uint64_t, time_t *, long *);\nstatic uint64_t folder_uncompressed_size(struct _7z_folder *);\nstatic void\tfree_CodersInfo(struct _7z_coders_info *);\nstatic void\tfree_Digest(struct _7z_digests *);\nstatic void\tfree_Folder(struct _7z_folder *);\nstatic void\tfree_Header(struct _7z_header_info *);\nstatic void\tfree_PackInfo(struct _7z_pack_info *);\nstatic void\tfree_StreamsInfo(struct _7z_stream_info *);\nstatic void\tfree_SubStreamsInfo(struct _7z_substream_info *);\nstatic int\tfree_decompression(struct archive_read *, struct _7zip *);\nstatic ssize_t\tget_uncompressed_data(struct archive_read *, const void **,\n\t\t    size_t, size_t);\nstatic const unsigned char * header_bytes(struct archive_read *, size_t);\nstatic int\tinit_decompression(struct archive_read *, struct _7zip *,\n\t\t    const struct _7z_coder *, const struct _7z_coder *);\nstatic int\tparse_7zip_uint64(struct archive_read *, uint64_t *);\nstatic int\tread_Bools(struct archive_read *, unsigned char *, size_t);\nstatic int\tread_CodersInfo(struct archive_read *,\n\t\t    struct _7z_coders_info *);\nstatic int\tread_Digests(struct archive_read *, struct _7z_digests *,\n\t\t    size_t);\nstatic int\tread_Folder(struct archive_read *, struct _7z_folder *);\nstatic int\tread_Header(struct archive_read *, struct _7z_header_info *,\n\t\t    int);\nstatic int\tread_PackInfo(struct archive_read *, struct _7z_pack_info *);\nstatic int\tread_StreamsInfo(struct archive_read *,\n\t\t    struct _7z_stream_info *);\nstatic int\tread_SubStreamsInfo(struct archive_read *,\n\t\t    struct _7z_substream_info *, struct _7z_folder *, size_t);\nstatic int\tread_Times(struct archive_read *, struct _7z_header_info *,\n\t\t    int);\nstatic void\tread_consume(struct archive_read *);\nstatic ssize_t\tread_stream(struct archive_read *, const void **, size_t,\n\t\t    size_t);\nstatic int\tseek_pack(struct archive_read *);\nstatic int64_t\tskip_stream(struct archive_read *, size_t);\nstatic int\tskip_sfx(struct archive_read *, ssize_t);\nstatic int\tslurp_central_directory(struct archive_read *, struct _7zip *,\n\t\t    struct _7z_header_info *);\nstatic int\tsetup_decode_folder(struct archive_read *, struct _7z_folder *,\n\t\t    int);\nstatic void\tx86_Init(struct _7zip *);\nstatic size_t\tx86_Convert(struct _7zip *, uint8_t *, size_t);\nstatic ssize_t\t\tBcj2_Decode(struct _7zip *, uint8_t *, size_t);\n\n\nint\narchive_read_support_format_7zip(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct _7zip *zip;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_7zip\");\n\n\tzip = calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate 7zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\n\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"7zip\",\n\t    archive_read_format_7zip_bid,\n\t    NULL,\n\t    archive_read_format_7zip_read_header,\n\t    archive_read_format_7zip_read_data,\n\t    archive_read_format_7zip_read_data_skip,\n\t    NULL,\n\t    archive_read_format_7zip_cleanup,\n\t    archive_read_support_format_7zip_capabilities,\n\t    archive_read_format_7zip_has_encrypted_entries);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_support_format_7zip_capabilities(struct archive_read * a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA |\n\t\t\tARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n}\n\n\nstatic int\narchive_read_format_7zip_has_encrypted_entries(struct archive_read *_a)\n{\n\tif (_a && _a->format) {\n\t\tstruct _7zip * zip = (struct _7zip *)_a->format->data;\n\t\tif (zip) {\n\t\t\treturn zip->has_encrypted_entries;\n\t\t}\n\t}\n\treturn ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n}\n\nstatic int\narchive_read_format_7zip_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\n\t/* If someone has already bid more than 32, then avoid\n\t   trashing the look-ahead buffers with a seek. */\n\tif (best_bid > 32)\n\t\treturn (-1);\n\n\tif ((p = __archive_read_ahead(a, 6, NULL)) == NULL)\n\t\treturn (0);\n\n\t/* If first six bytes are the 7-Zip signature,\n\t * return the bid right now. */\n\tif (memcmp(p, _7ZIP_SIGNATURE, 6) == 0)\n\t\treturn (48);\n\n\t/*\n\t * It may a 7-Zip SFX archive file. If first two bytes are\n\t * 'M' and 'Z' available on Windows or first four bytes are\n\t * \"\\x7F\\x45LF\" available on posix like system, seek the 7-Zip\n\t * signature. Although we will perform a seek when reading\n\t * a header, what we do not use __archive_read_seek() here is\n\t * due to a bidding performance.\n\t */\n\tif ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0) {\n\t\tssize_t offset = SFX_MIN_ADDR;\n\t\tssize_t window = 4096;\n\t\tssize_t bytes_avail;\n\t\twhile (offset + window <= (SFX_MAX_ADDR)) {\n\t\t\tconst char *buff = __archive_read_ahead(a,\n\t\t\t\t\toffset + window, &bytes_avail);\n\t\t\tif (buff == NULL) {\n\t\t\t\t/* Remaining bytes are less than window. */\n\t\t\t\twindow >>= 1;\n\t\t\t\tif (window < 0x40)\n\t\t\t\t\treturn (0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = buff + offset;\n\t\t\twhile (p + 32 < buff + bytes_avail) {\n\t\t\t\tint step = check_7zip_header_in_sfx(p);\n\t\t\t\tif (step == 0)\n\t\t\t\t\treturn (48);\n\t\t\t\tp += step;\n\t\t\t}\n\t\t\toffset = p - buff;\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\ncheck_7zip_header_in_sfx(const char *p)\n{\n\tswitch ((unsigned char)p[5]) {\n\tcase 0x1C:\n\t\tif (memcmp(p, _7ZIP_SIGNATURE, 6) != 0)\n\t\t\treturn (6);\n\t\t/*\n\t\t * Test the CRC because its extraction code has 7-Zip\n\t\t * Magic Code, so we should do this in order not to\n\t\t * make a mis-detection.\n\t\t */\n\t\tif (crc32(0, (const unsigned char *)p + 12, 20)\n\t\t\t!= archive_le32dec(p + 8))\n\t\t\treturn (6);\n\t\t/* Hit the header! */\n\t\treturn (0);\n\tcase 0x37: return (5);\n\tcase 0x7A: return (4);\n\tcase 0xBC: return (3);\n\tcase 0xAF: return (2);\n\tcase 0x27: return (1);\n\tdefault: return (6);\n\t}\n}\n\nstatic int\nskip_sfx(struct archive_read *a, ssize_t bytes_avail)\n{\n\tconst void *h;\n\tconst char *p, *q;\n\tsize_t skip, offset;\n\tssize_t bytes, window;\n\n\t/*\n\t * If bytes_avail > SFX_MIN_ADDR we do not have to call\n\t * __archive_read_seek() at this time since we have\n\t * alredy had enough data.\n\t */\n\tif (bytes_avail > SFX_MIN_ADDR)\n\t\t__archive_read_consume(a, SFX_MIN_ADDR);\n\telse if (__archive_read_seek(a, SFX_MIN_ADDR, SEEK_SET) < 0)\n\t\treturn (ARCHIVE_FATAL);\n\n\toffset = 0;\n\twindow = 1;\n\twhile (offset + window <= SFX_MAX_ADDR - SFX_MIN_ADDR) {\n\t\th = __archive_read_ahead(a, window, &bytes);\n\t\tif (h == NULL) {\n\t\t\t/* Remaining bytes are less than window. */\n\t\t\twindow >>= 1;\n\t\t\tif (window < 0x40)\n\t\t\t\tgoto fatal;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bytes < 6) {\n\t\t\t/* This case might happen when window == 1. */\n\t\t\twindow = 4096;\n\t\t\tcontinue;\n\t\t}\n\t\tp = (const char *)h;\n\t\tq = p + bytes;\n\n\t\t/*\n\t\t * Scan ahead until we find something that looks\n\t\t * like the 7-Zip header.\n\t\t */\n\t\twhile (p + 32 < q) {\n\t\t\tint step = check_7zip_header_in_sfx(p);\n\t\t\tif (step == 0) {\n\t\t\t\tstruct _7zip *zip =\n\t\t\t\t    (struct _7zip *)a->format->data;\n\t\t\t\tskip = p - (const char *)h;\n\t\t\t\t__archive_read_consume(a, skip);\n\t\t\t\tzip->seek_base = SFX_MIN_ADDR + offset + skip;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tp += step;\n\t\t}\n\t\tskip = p - (const char *)h;\n\t\t__archive_read_consume(a, skip);\n\t\toffset += skip;\n\t\tif (window == 1)\n\t\t\twindow = 4096;\n\t}\nfatal:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Couldn't find out 7-Zip header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_7zip_read_header(struct archive_read *a,\n\tstruct archive_entry *entry)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tstruct _7zip_entry *zip_entry;\n\tint r, ret = ARCHIVE_OK;\n\tstruct _7z_folder *folder = 0;\n\tuint64_t fidx = 0;\n\n\t/*\n\t * It should be sufficient to call archive_read_next_header() for\n\t * a reader to determine if an entry is encrypted or not. If the\n\t * encryption of an entry is only detectable when calling\n\t * archive_read_data(), so be it. We'll do the same check there\n\t * as well.\n\t */\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_7ZIP;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"7-Zip\";\n\n\tif (zip->entries == NULL) {\n\t\tstruct _7z_header_info header;\n\n\t\tmemset(&header, 0, sizeof(header));\n\t\tr = slurp_central_directory(a, zip, &header);\n\t\tfree_Header(&header);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tzip->entries_remaining = (size_t)zip->numFiles;\n\t\tzip->entry = zip->entries;\n\t} else {\n\t\t++zip->entry;\n\t}\n\tzip_entry = zip->entry;\n\n\tif (zip->entries_remaining <= 0 || zip_entry == NULL)\n\t\treturn ARCHIVE_EOF;\n\t--zip->entries_remaining;\n\n\tzip->entry_offset = 0;\n\tzip->end_of_entry = 0;\n\tzip->entry_crc32 = crc32(0, NULL, 0);\n\n\t/* Setup a string conversion for a filename. */\n\tif (zip->sconv == NULL) {\n\t\tzip->sconv = archive_string_conversion_from_charset(\n\t\t    &a->archive, \"UTF-16LE\", 1);\n\t\tif (zip->sconv == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Figure out if the entry is encrypted by looking at the folder\n\t   that is associated to the current 7zip entry. If the folder\n\t   has a coder with a _7Z_CRYPTO codec then the folder is encrypted.\n\t   Hence the entry must also be encrypted. */\n\tif (zip_entry && zip_entry->folderIndex < zip->si.ci.numFolders) {\n\t\tfolder = &(zip->si.ci.folders[zip_entry->folderIndex]);\n\t\tfor (fidx=0; folder && fidx<folder->numCoders; fidx++) {\n\t\t\tswitch(folder->coders[fidx].codec) {\n\t\t\t\tcase _7Z_CRYPTO_MAIN_ZIP:\n\t\t\t\tcase _7Z_CRYPTO_RAR_29:\n\t\t\t\tcase _7Z_CRYPTO_AES_256_SHA_256: {\n\t\t\t\t\tarchive_entry_set_is_data_encrypted(entry, 1);\n\t\t\t\t\tzip->has_encrypted_entries = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Now that we've checked for encryption, if there were still no\n\t * encrypted entries found we can say for sure that there are none.\n\t */\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\tif (archive_entry_copy_pathname_l(entry,\n\t    (const char *)zip_entry->utf16name,\n\t    zip_entry->name_len, zip->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted \"\n\t\t    \"from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(zip->sconv));\n\t\tret = ARCHIVE_WARN;\n\t}\n\n\t/* Populate some additional entry fields: */\n\tarchive_entry_set_mode(entry, zip_entry->mode);\n\tif (zip_entry->flg & MTIME_IS_SET)\n\t\tarchive_entry_set_mtime(entry, zip_entry->mtime,\n\t\t\tzip_entry->mtime_ns);\n\tif (zip_entry->flg & CTIME_IS_SET)\n\t\tarchive_entry_set_ctime(entry, zip_entry->ctime,\n\t\t    zip_entry->ctime_ns);\n\tif (zip_entry->flg & ATIME_IS_SET)\n\t\tarchive_entry_set_atime(entry, zip_entry->atime,\n\t\t    zip_entry->atime_ns);\n\tif (zip_entry->ssIndex != (uint32_t)-1) {\n\t\tzip->entry_bytes_remaining =\n\t\t    zip->si.ss.unpackSizes[zip_entry->ssIndex];\n\t\tarchive_entry_set_size(entry, zip->entry_bytes_remaining);\n\t} else {\n\t\tzip->entry_bytes_remaining = 0;\n\t\tarchive_entry_set_size(entry, 0);\n\t}\n\n\t/* If there's no body, force read_data() to return EOF immediately. */\n\tif (zip->entry_bytes_remaining < 1)\n\t\tzip->end_of_entry = 1;\n\n\tif ((zip_entry->mode & AE_IFMT) == AE_IFLNK) {\n\t\tunsigned char *symname = NULL;\n\t\tsize_t symsize = 0;\n\n\t\t/*\n\t\t * Symbolic-name is recorded as its contents. We have to\n\t\t * read the contents at this time.\n\t\t */\n\t\twhile (zip->entry_bytes_remaining > 0) {\n\t\t\tconst void *buff;\n\t\t\tunsigned char *mem;\n\t\t\tsize_t size;\n\t\t\tint64_t offset;\n\n\t\t\tr = archive_read_format_7zip_read_data(a, &buff,\n\t\t\t\t&size, &offset);\n\t\t\tif (r < ARCHIVE_WARN) {\n\t\t\t\tfree(symname);\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t\tmem = realloc(symname, symsize + size + 1);\n\t\t\tif (mem == NULL) {\n\t\t\t\tfree(symname);\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Symname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tsymname = mem;\n\t\t\tmemcpy(symname+symsize, buff, size);\n\t\t\tsymsize += size;\n\t\t}\n\t\tif (symsize == 0) {\n\t\t\t/* If there is no synname, handle it as a regular\n\t\t\t * file. */\n\t\t\tzip_entry->mode &= ~AE_IFMT;\n\t\t\tzip_entry->mode |= AE_IFREG;\n\t\t\tarchive_entry_set_mode(entry, zip_entry->mode);\n\t\t} else {\n\t\t\tsymname[symsize] = '\\0';\n\t\t\tarchive_entry_copy_symlink(entry,\n\t\t\t    (const char *)symname);\n\t\t}\n\t\tfree(symname);\n\t\tarchive_entry_set_size(entry, 0);\n\t}\n\n\t/* Set up a more descriptive format name. */\n\tsprintf(zip->format_name, \"7-Zip\");\n\ta->archive.archive_format_name = zip->format_name;\n\n\treturn (ret);\n}\n\nstatic int\narchive_read_format_7zip_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tstruct _7zip *zip;\n\tssize_t bytes;\n\tint ret = ARCHIVE_OK;\n\n\tzip = (struct _7zip *)(a->format->data);\n\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\tif (zip->pack_stream_bytes_unconsumed)\n\t\tread_consume(a);\n\n\t*offset = zip->entry_offset;\n\t*size = 0;\n\t*buff = NULL;\n\t/*\n\t * If we hit end-of-entry last time, clean up and return\n\t * ARCHIVE_EOF this time.\n\t */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_EOF);\n\n\tbytes = read_stream(a, buff,\n\t\t(size_t)zip->entry_bytes_remaining, 0);\n\tif (bytes < 0)\n\t\treturn ((int)bytes);\n\tif (bytes == 0) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated 7-Zip file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->entry_bytes_remaining -= bytes;\n\tif (zip->entry_bytes_remaining == 0)\n\t\tzip->end_of_entry = 1;\n\n\t/* Update checksum */\n\tif ((zip->entry->flg & CRC32_IS_SET) && bytes)\n\t\tzip->entry_crc32 = crc32(zip->entry_crc32, *buff,\n\t\t    (unsigned)bytes);\n\n\t/* If we hit the end, swallow any end-of-data marker. */\n\tif (zip->end_of_entry) {\n\t\t/* Check computed CRC against file contents. */\n\t\tif ((zip->entry->flg & CRC32_IS_SET) &&\n\t\t\tzip->si.ss.digests[zip->entry->ssIndex] !=\n\t\t    zip->entry_crc32) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"7-Zip bad CRC: 0x%lx should be 0x%lx\",\n\t\t\t    (unsigned long)zip->entry_crc32,\n\t\t\t    (unsigned long)zip->si.ss.digests[\n\t\t\t    \t\tzip->entry->ssIndex]);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\n\t*size = bytes;\n\t*offset = zip->entry_offset;\n\tzip->entry_offset += bytes;\n\n\treturn (ret);\n}\n\nstatic int\narchive_read_format_7zip_read_data_skip(struct archive_read *a)\n{\n\tstruct _7zip *zip;\n\tint64_t bytes_skipped;\n\n\tzip = (struct _7zip *)(a->format->data);\n\n\tif (zip->pack_stream_bytes_unconsumed)\n\t\tread_consume(a);\n\n\t/* If we've already read to end of data, we're done. */\n\tif (zip->end_of_entry)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * If the length is at the beginning, we can skip the\n\t * compressed data much more quickly.\n\t */\n\tbytes_skipped = skip_stream(a, (size_t)zip->entry_bytes_remaining);\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\tzip->entry_bytes_remaining = 0;\n\n\t/* This entry is finished and done. */\n\tzip->end_of_entry = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_7zip_cleanup(struct archive_read *a)\n{\n\tstruct _7zip *zip;\n\n\tzip = (struct _7zip *)(a->format->data);\n\tfree_StreamsInfo(&(zip->si));\n\tfree(zip->entries);\n\tfree(zip->entry_names);\n\tfree_decompression(a, zip);\n\tfree(zip->uncompressed_buffer);\n\tfree(zip->sub_stream_buff[0]);\n\tfree(zip->sub_stream_buff[1]);\n\tfree(zip->sub_stream_buff[2]);\n\tfree(zip->tmp_stream_buff);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nread_consume(struct archive_read *a)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\n\tif (zip->pack_stream_bytes_unconsumed) {\n\t\t__archive_read_consume(a, zip->pack_stream_bytes_unconsumed);\n\t\tzip->stream_offset += zip->pack_stream_bytes_unconsumed;\n\t\tzip->pack_stream_bytes_unconsumed = 0;\n\t}\n}\n\n#ifdef HAVE_LZMA_H\n\n/*\n * Set an error code and choose an error message for liblzma.\n */\nstatic void\nset_error(struct archive_read *a, int ret)\n{\n\n\tswitch (ret) {\n\tcase LZMA_STREAM_END: /* Found end of stream. */\n\tcase LZMA_OK: /* Decompressor made some progress. */\n\t\tbreak;\n\tcase LZMA_MEM_ERROR:\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Lzma library error: Cannot allocate memory\");\n\t\tbreak;\n\tcase LZMA_MEMLIMIT_ERROR:\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Lzma library error: Out of memory\");\n\t\tbreak;\n\tcase LZMA_FORMAT_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error: format not recognized\");\n\t\tbreak;\n\tcase LZMA_OPTIONS_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error: Invalid options\");\n\t\tbreak;\n\tcase LZMA_DATA_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error: Corrupted input data\");\n\t\tbreak;\n\tcase LZMA_BUF_ERROR:\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma library error:  No progress is possible\");\n\t\tbreak;\n\tdefault:\n\t\t/* Return an error. */\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"Lzma decompression failed:  Unknown error\");\n\t\tbreak;\n\t}\n}\n\n#endif\n\nstatic unsigned long\ndecode_codec_id(const unsigned char *codecId, size_t id_size)\n{\n\tunsigned i;\n\tunsigned long id = 0;\n\n\tfor (i = 0; i < id_size; i++) {\n\t\tid <<= 8;\n\t\tid += codecId[i];\n\t}\n\treturn (id);\n}\n\nstatic void *\nppmd_alloc(void *p, size_t size)\n{\n\t(void)p;\n\treturn malloc(size);\n}\nstatic void\nppmd_free(void *p, void *address)\n{\n\t(void)p;\n\tfree(address);\n}\nstatic Byte\nppmd_read(void *p)\n{\n\tstruct archive_read *a = ((IByteIn*)p)->a;\n\tstruct _7zip *zip = (struct _7zip *)(a->format->data);\n\tByte b;\n\n\tif (zip->ppstream.avail_in == 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated RAR file data\");\n\t\tzip->ppstream.overconsumed = 1;\n\t\treturn (0);\n\t}\n\tb = *zip->ppstream.next_in++;\n\tzip->ppstream.avail_in--;\n\tzip->ppstream.total_in++;\n\treturn (b);\n}\n\nstatic ISzAlloc g_szalloc = { ppmd_alloc, ppmd_free };\n\nstatic int\ninit_decompression(struct archive_read *a, struct _7zip *zip,\n    const struct _7z_coder *coder1, const struct _7z_coder *coder2)\n{\n\tint r;\n\n\tzip->codec = coder1->codec;\n\tzip->codec2 = -1;\n\n\tswitch (zip->codec) {\n\tcase _7Z_COPY:\n\tcase _7Z_BZ2:\n\tcase _7Z_DEFLATE:\n\tcase _7Z_PPMD:\n\t\tif (coder2 != NULL) {\n\t\t\tif (coder2->codec != _7Z_X86 &&\n\t\t\t    coder2->codec != _7Z_X86_BCJ2) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Unsupported filter %lx for %lx\",\n\t\t\t\t    coder2->codec, coder1->codec);\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->codec2 = coder2->codec;\n\t\t\tzip->bcj_state = 0;\n\t\t\tif (coder2->codec == _7Z_X86)\n\t\t\t\tx86_Init(zip);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (zip->codec) {\n\tcase _7Z_COPY:\n\t\tbreak;\n\n\tcase _7Z_LZMA: case _7Z_LZMA2:\n#ifdef HAVE_LZMA_H\n#if LZMA_VERSION_MAJOR >= 5\n/* Effectively disable the limiter. */\n#define LZMA_MEMLIMIT   UINT64_MAX\n#else\n/* NOTE: This needs to check memory size which running system has. */\n#define LZMA_MEMLIMIT   (1U << 30)\n#endif\n\t{\n\t\tlzma_options_delta delta_opt;\n\t\tlzma_filter filters[LZMA_FILTERS_MAX];\n#if LZMA_VERSION < 50010000\n\t\tlzma_filter *ff;\n#endif\n\t\tint fi = 0;\n\n\t\tif (zip->lzstream_valid) {\n\t\t\tlzma_end(&(zip->lzstream));\n\t\t\tzip->lzstream_valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: liblzma incompletely handle the BCJ+LZMA compressed\n\t\t * data made by 7-Zip because 7-Zip does not add End-Of-\n\t\t * Payload Marker(EOPM) at the end of LZMA compressed data,\n\t\t * and so liblzma cannot know the end of the compressed data\n\t\t * without EOPM. So consequently liblzma will not return last\n\t\t * three or four bytes of uncompressed data because\n\t\t * LZMA_FILTER_X86 filter does not handle input data if its\n\t\t * data size is less than five bytes. If liblzma detect EOPM\n\t\t * or know the uncompressed data size, liblzma will flush out\n\t\t * the remaining that three or four bytes of uncompressed\n\t\t * data. That is why we have to use our converting program\n\t\t * for BCJ+LZMA. If we were able to tell the uncompressed\n\t\t * size to liblzma when using lzma_raw_decoder() liblzma\n\t\t * could correctly deal with BCJ+LZMA. But unfortunately\n\t\t * there is no way to do that.\n\t\t * Discussion about this can be found at XZ Utils forum.\n\t\t */\n\t\tif (coder2 != NULL) {\n\t\t\tzip->codec2 = coder2->codec;\n\n\t\t\tfilters[fi].options = NULL;\n\t\t\tswitch (zip->codec2) {\n\t\t\tcase _7Z_X86:\n\t\t\t\tif (zip->codec == _7Z_LZMA2) {\n\t\t\t\t\tfilters[fi].id = LZMA_FILTER_X86;\n\t\t\t\t\tfi++;\n\t\t\t\t} else\n\t\t\t\t\t/* Use our filter. */\n\t\t\t\t\tx86_Init(zip);\n\t\t\t\tbreak;\n\t\t\tcase _7Z_X86_BCJ2:\n\t\t\t\t/* Use our filter. */\n\t\t\t\tzip->bcj_state = 0;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_DELTA:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_DELTA;\n\t\t\t\tmemset(&delta_opt, 0, sizeof(delta_opt));\n\t\t\t\tdelta_opt.type = LZMA_DELTA_TYPE_BYTE;\n\t\t\t\tdelta_opt.dist = 1;\n\t\t\t\tfilters[fi].options = &delta_opt;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\t/* Following filters have not been tested yet. */\n\t\t\tcase _7Z_POWERPC:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_POWERPC;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_IA64:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_IA64;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_ARM:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_ARM;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_ARMTHUMB:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_ARMTHUMB;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tcase _7Z_SPARC:\n\t\t\t\tfilters[fi].id = LZMA_FILTER_SPARC;\n\t\t\t\tfi++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Unexpected codec ID: %lX\", zip->codec2);\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t}\n\n\t\tif (zip->codec == _7Z_LZMA2)\n\t\t\tfilters[fi].id = LZMA_FILTER_LZMA2;\n\t\telse\n\t\t\tfilters[fi].id = LZMA_FILTER_LZMA1;\n\t\tfilters[fi].options = NULL;\n#if LZMA_VERSION < 50010000\n\t\tff = &filters[fi];\n#endif\n\t\tr = lzma_properties_decode(&filters[fi], NULL,\n\t\t    coder1->properties, (size_t)coder1->propertiesSize);\n\t\tif (r != LZMA_OK) {\n\t\t\tset_error(a, r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tfi++;\n\n\t\tfilters[fi].id = LZMA_VLI_UNKNOWN;\n\t\tfilters[fi].options = NULL;\n\t\tr = lzma_raw_decoder(&(zip->lzstream), filters);\n#if LZMA_VERSION < 50010000\n\t\tfree(ff->options);\n#endif\n\t\tif (r != LZMA_OK) {\n\t\t\tset_error(a, r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->lzstream_valid = 1;\n\t\tzip->lzstream.total_in = 0;\n\t\tzip->lzstream.total_out = 0;\n\t\tbreak;\n\t}\n#else\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LZMA codec is unsupported\");\n\t\treturn (ARCHIVE_FAILED);\n#endif\n\tcase _7Z_BZ2:\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\t\tif (zip->bzstream_valid) {\n\t\t\tBZ2_bzDecompressEnd(&(zip->bzstream));\n\t\t\tzip->bzstream_valid = 0;\n\t\t}\n\t\tr = BZ2_bzDecompressInit(&(zip->bzstream), 0, 0);\n\t\tif (r == BZ_MEM_ERROR)\n\t\t\tr = BZ2_bzDecompressInit(&(zip->bzstream), 0, 1);\n\t\tif (r != BZ_OK) {\n\t\t\tint err = ARCHIVE_ERRNO_MISC;\n\t\t\tconst char *detail = NULL;\n\t\t\tswitch (r) {\n\t\t\tcase BZ_PARAM_ERROR:\n\t\t\t\tdetail = \"invalid setup parameter\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_MEM_ERROR:\n\t\t\t\terr = ENOMEM;\n\t\t\t\tdetail = \"out of memory\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_CONFIG_ERROR:\n\t\t\t\tdetail = \"mis-compiled library\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive, err,\n\t\t\t    \"Internal error initializing decompressor: %s\",\n\t\t\t    detail != NULL ? detail : \"??\");\n\t\t\tzip->bzstream_valid = 0;\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->bzstream_valid = 1;\n\t\tzip->bzstream.total_in_lo32 = 0;\n\t\tzip->bzstream.total_in_hi32 = 0;\n\t\tzip->bzstream.total_out_lo32 = 0;\n\t\tzip->bzstream.total_out_hi32 = 0;\n\t\tbreak;\n#else\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"BZ2 codec is unsupported\");\n\t\treturn (ARCHIVE_FAILED);\n#endif\n\tcase _7Z_DEFLATE:\n#ifdef HAVE_ZLIB_H\n\t\tif (zip->stream_valid)\n\t\t\tr = inflateReset(&(zip->stream));\n\t\telse\n\t\t\tr = inflateInit2(&(zip->stream),\n\t\t\t    -15 /* Don't check for zlib header */);\n\t\tif (r != Z_OK) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Couldn't initialize zlib stream.\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->stream_valid = 1;\n\t\tzip->stream.total_in = 0;\n\t\tzip->stream.total_out = 0;\n\t\tbreak;\n#else\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"DEFLATE codec is unsupported\");\n\t\treturn (ARCHIVE_FAILED);\n#endif\n\tcase _7Z_PPMD:\n\t{\n\t\tunsigned order;\n\t\tuint32_t msize;\n\n\t\tif (zip->ppmd7_valid) {\n\t\t\t__archive_ppmd7_functions.Ppmd7_Free(\n\t\t\t    &zip->ppmd7_context, &g_szalloc);\n\t\t\tzip->ppmd7_valid = 0;\n\t\t}\n\n\t\tif (coder1->propertiesSize < 5) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Malformed PPMd parameter\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\torder = coder1->properties[0];\n\t\tmsize = archive_le32dec(&(coder1->properties[1]));\n\t\tif (order < PPMD7_MIN_ORDER || order > PPMD7_MAX_ORDER ||\n\t\t    msize < PPMD7_MIN_MEM_SIZE || msize > PPMD7_MAX_MEM_SIZE) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Malformed PPMd parameter\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\t__archive_ppmd7_functions.Ppmd7_Construct(&zip->ppmd7_context);\n\t\tr = __archive_ppmd7_functions.Ppmd7_Alloc(\n\t\t\t&zip->ppmd7_context, msize, &g_szalloc);\n\t\tif (r == 0) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Coludn't allocate memory for PPMd\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t__archive_ppmd7_functions.Ppmd7_Init(\n\t\t\t&zip->ppmd7_context, order);\n\t\t__archive_ppmd7_functions.Ppmd7z_RangeDec_CreateVTable(\n\t\t\t&zip->range_dec);\n\t\tzip->ppmd7_valid = 1;\n\t\tzip->ppmd7_stat = 0;\n\t\tzip->ppstream.overconsumed = 0;\n\t\tzip->ppstream.total_in = 0;\n\t\tzip->ppstream.total_out = 0;\n\t\tbreak;\n\t}\n\tcase _7Z_X86:\n\tcase _7Z_X86_BCJ2:\n\tcase _7Z_POWERPC:\n\tcase _7Z_IA64:\n\tcase _7Z_ARM:\n\tcase _7Z_ARMTHUMB:\n\tcase _7Z_SPARC:\n\tcase _7Z_DELTA:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Unexpected codec ID: %lX\", zip->codec);\n\t\treturn (ARCHIVE_FAILED);\n\tcase _7Z_CRYPTO_MAIN_ZIP:\n\tcase _7Z_CRYPTO_RAR_29:\n\tcase _7Z_CRYPTO_AES_256_SHA_256:\n\t\tif (a->entry) {\n\t\t\tarchive_entry_set_is_metadata_encrypted(a->entry, 1);\n\t\t\tarchive_entry_set_is_data_encrypted(a->entry, 1);\n\t\t\tzip->has_encrypted_entries = 1;\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Crypto codec not supported yet (ID: 0x%lX)\", zip->codec);\n\t\treturn (ARCHIVE_FAILED);\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Unknown codec ID: %lX\", zip->codec);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ndecompress(struct archive_read *a, struct _7zip *zip,\n    void *buff, size_t *outbytes, const void *b, size_t *used)\n{\n\tconst uint8_t *t_next_in;\n\tuint8_t *t_next_out;\n\tsize_t o_avail_in, o_avail_out;\n\tsize_t t_avail_in, t_avail_out;\n\tuint8_t *bcj2_next_out;\n\tsize_t bcj2_avail_out;\n\tint r, ret = ARCHIVE_OK;\n\n\tt_avail_in = o_avail_in = *used;\n\tt_avail_out = o_avail_out = *outbytes;\n\tt_next_in = b;\n\tt_next_out = buff;\n\n\tif (zip->codec != _7Z_LZMA2 && zip->codec2 == _7Z_X86) {\n\t\tint i;\n\n\t\t/* Do not copy out the BCJ remaining bytes when the output\n\t\t * buffer size is less than five bytes. */\n\t\tif (o_avail_in != 0 && t_avail_out < 5 && zip->odd_bcj_size) {\n\t\t\t*used = 0;\n\t\t\t*outbytes = 0;\n\t\t\treturn (ret);\n\t\t}\n\t\tfor (i = 0; zip->odd_bcj_size > 0 && t_avail_out; i++) {\n\t\t\t*t_next_out++ = zip->odd_bcj[i];\n\t\t\tt_avail_out--;\n\t\t\tzip->odd_bcj_size--;\n\t\t}\n\t\tif (o_avail_in == 0 || t_avail_out == 0) {\n\t\t\t*used = o_avail_in - t_avail_in;\n\t\t\t*outbytes = o_avail_out - t_avail_out;\n\t\t\tif (o_avail_in == 0)\n\t\t\t\tret = ARCHIVE_EOF;\n\t\t\treturn (ret);\n\t\t}\n\t}\n\n\tbcj2_next_out = t_next_out;\n\tbcj2_avail_out = t_avail_out;\n\tif (zip->codec2 == _7Z_X86_BCJ2) {\n\t\t/*\n\t\t * Decord a remaining decompressed main stream for BCJ2.\n\t\t */\n\t\tif (zip->tmp_stream_bytes_remaining) {\n\t\t\tssize_t bytes;\n\t\t\tsize_t remaining = zip->tmp_stream_bytes_remaining;\n\t\t\tbytes = Bcj2_Decode(zip, t_next_out, t_avail_out);\n\t\t\tif (bytes < 0) {\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"BCJ2 conversion Failed\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->main_stream_bytes_remaining -=\n\t\t\t    remaining - zip->tmp_stream_bytes_remaining;\n\t\t\tt_avail_out -= bytes;\n\t\t\tif (o_avail_in == 0 || t_avail_out == 0) {\n\t\t\t\t*used = 0;\n\t\t\t\t*outbytes = o_avail_out - t_avail_out;\n\t\t\t\tif (o_avail_in == 0 &&\n\t\t\t\t    zip->tmp_stream_bytes_remaining)\n\t\t\t\t\tret = ARCHIVE_EOF;\n\t\t\t\treturn (ret);\n\t\t\t}\n\t\t\tt_next_out += bytes;\n\t\t\tbcj2_next_out = t_next_out;\n\t\t\tbcj2_avail_out = t_avail_out;\n\t\t}\n\t\tt_next_out = zip->tmp_stream_buff;\n\t\tt_avail_out = zip->tmp_stream_buff_size;\n\t}\n\n\tswitch (zip->codec) {\n\tcase _7Z_COPY:\n\t{\n\t\tsize_t bytes =\n\t\t    (t_avail_in > t_avail_out)?t_avail_out:t_avail_in;\n\n\t\tmemcpy(t_next_out, t_next_in, bytes);\n\t\tt_avail_in -= bytes;\n\t\tt_avail_out -= bytes;\n\t\tif (o_avail_in == 0)\n\t\t\tret = ARCHIVE_EOF;\n\t\tbreak;\n\t}\n#ifdef HAVE_LZMA_H\n\tcase _7Z_LZMA: case _7Z_LZMA2:\n\t\tzip->lzstream.next_in = t_next_in;\n\t\tzip->lzstream.avail_in = t_avail_in;\n\t\tzip->lzstream.next_out = t_next_out;\n\t\tzip->lzstream.avail_out = t_avail_out;\n\n\t\tr = lzma_code(&(zip->lzstream), LZMA_RUN);\n\t\tswitch (r) {\n\t\tcase LZMA_STREAM_END: /* Found end of stream. */\n\t\t\tlzma_end(&(zip->lzstream));\n\t\t\tzip->lzstream_valid = 0;\n\t\t\tret = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\tcase LZMA_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\"Decompression failed(%d)\",\n\t\t\t    r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tt_avail_in = zip->lzstream.avail_in;\n\t\tt_avail_out = zip->lzstream.avail_out;\n\t\tbreak;\n#endif\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tcase _7Z_BZ2:\n\t\tzip->bzstream.next_in = (char *)(uintptr_t)t_next_in;\n\t\tzip->bzstream.avail_in = t_avail_in;\n\t\tzip->bzstream.next_out = (char *)(uintptr_t)t_next_out;\n\t\tzip->bzstream.avail_out = t_avail_out;\n\t\tr = BZ2_bzDecompress(&(zip->bzstream));\n\t\tswitch (r) {\n\t\tcase BZ_STREAM_END: /* Found end of stream. */\n\t\t\tswitch (BZ2_bzDecompressEnd(&(zip->bzstream))) {\n\t\t\tcase BZ_OK:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to clean up decompressor\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->bzstream_valid = 0;\n\t\t\tret = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\tcase BZ_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"bzip decompression failed\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tt_avail_in = zip->bzstream.avail_in;\n\t\tt_avail_out = zip->bzstream.avail_out;\n\t\tbreak;\n#endif\n#ifdef HAVE_ZLIB_H\n\tcase _7Z_DEFLATE:\n\t\tzip->stream.next_in = (Bytef *)(uintptr_t)t_next_in;\n\t\tzip->stream.avail_in = (uInt)t_avail_in;\n\t\tzip->stream.next_out = t_next_out;\n\t\tzip->stream.avail_out = (uInt)t_avail_out;\n\t\tr = inflate(&(zip->stream), 0);\n\t\tswitch (r) {\n\t\tcase Z_STREAM_END: /* Found end of stream. */\n\t\t\tret = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\tcase Z_OK: /* Decompressor made some progress.*/\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"File decompression failed (%d)\", r);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tt_avail_in = zip->stream.avail_in;\n\t\tt_avail_out = zip->stream.avail_out;\n\t\tbreak;\n#endif\n\tcase _7Z_PPMD:\n\t{\n\t\tuint64_t flush_bytes;\n\n\t\tif (!zip->ppmd7_valid || zip->ppmd7_stat < 0 ||\n\t\t    t_avail_out <= 0) {\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decompression internal error\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->ppstream.next_in = t_next_in;\n\t\tzip->ppstream.avail_in = t_avail_in;\n\t\tzip->ppstream.next_out = t_next_out;\n\t\tzip->ppstream.avail_out = t_avail_out;\n\t\tif (zip->ppmd7_stat == 0) {\n\t\t\tzip->bytein.a = a;\n\t\t\tzip->bytein.Read = &ppmd_read;\n\t\t\tzip->range_dec.Stream = &zip->bytein;\n\t\t\tr = __archive_ppmd7_functions.Ppmd7z_RangeDec_Init(\n\t\t\t\t&(zip->range_dec));\n\t\t\tif (r == 0) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to initialize PPMd range decorder\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tif (zip->ppstream.overconsumed) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tzip->ppmd7_stat = 1;\n\t\t}\n\n\t\tif (t_avail_in == 0)\n\t\t\t/* XXX Flush out remaining decoded data XXX */\n\t\t\tflush_bytes = zip->folder_outbytes_remaining;\n\t\telse\n\t\t\tflush_bytes = 0;\n\n\t\tdo {\n\t\t\tint sym;\n\n\t\t\tsym = __archive_ppmd7_functions.Ppmd7_DecodeSymbol(\n\t\t\t\t&(zip->ppmd7_context), &(zip->range_dec.p));\n\t\t\tif (sym < 0) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Failed to decode PPMd\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\tif (zip->ppstream.overconsumed) {\n\t\t\t\tzip->ppmd7_stat = -1;\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\t*zip->ppstream.next_out++ = (unsigned char)sym;\n\t\t\tzip->ppstream.avail_out--;\n\t\t\tzip->ppstream.total_out++;\n\t\t\tif (flush_bytes)\n\t\t\t\tflush_bytes--;\n\t\t} while (zip->ppstream.avail_out &&\n\t\t\t(zip->ppstream.avail_in || flush_bytes));\n\n\t\tt_avail_in = (size_t)zip->ppstream.avail_in;\n\t\tt_avail_out = (size_t)zip->ppstream.avail_out;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"Decompression internal error\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tif (ret != ARCHIVE_OK && ret != ARCHIVE_EOF)\n\t\treturn (ret);\n\n\t*used = o_avail_in - t_avail_in;\n\t*outbytes = o_avail_out - t_avail_out;\n\n\t/*\n\t * Decord BCJ.\n\t */\n\tif (zip->codec != _7Z_LZMA2 && zip->codec2 == _7Z_X86) {\n\t\tsize_t l = x86_Convert(zip, buff, *outbytes);\n\t\tzip->odd_bcj_size = *outbytes - l;\n\t\tif (zip->odd_bcj_size > 0 && zip->odd_bcj_size <= 4 &&\n\t\t    o_avail_in && ret != ARCHIVE_EOF) {\n\t\t\tmemcpy(zip->odd_bcj, ((unsigned char *)buff) + l,\n\t\t\t    zip->odd_bcj_size);\n\t\t\t*outbytes = l;\n\t\t} else\n\t\t\tzip->odd_bcj_size = 0;\n\t}\n\n\t/*\n\t * Decord BCJ2 with a decompressed main stream.\n\t */\n\tif (zip->codec2 == _7Z_X86_BCJ2) {\n\t\tssize_t bytes;\n\n\t\tzip->tmp_stream_bytes_avail =\n\t\t    zip->tmp_stream_buff_size - t_avail_out;\n\t\tif (zip->tmp_stream_bytes_avail >\n\t\t      zip->main_stream_bytes_remaining)\n\t\t\tzip->tmp_stream_bytes_avail =\n\t\t\t    zip->main_stream_bytes_remaining;\n\t\tzip->tmp_stream_bytes_remaining = zip->tmp_stream_bytes_avail;\n\t\tbytes = Bcj2_Decode(zip, bcj2_next_out, bcj2_avail_out);\n\t\tif (bytes < 0) {\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC, \"BCJ2 conversion Failed\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tzip->main_stream_bytes_remaining -=\n\t\t    zip->tmp_stream_bytes_avail\n\t\t      - zip->tmp_stream_bytes_remaining;\n\t\tbcj2_avail_out -= bytes;\n\t\t*outbytes = o_avail_out - bcj2_avail_out;\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nfree_decompression(struct archive_read *a, struct _7zip *zip)\n{\n\tint r = ARCHIVE_OK;\n\n#if !defined(HAVE_ZLIB_H) &&\\\n\t!(defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR))\n\t(void)a;/* UNUSED */\n#endif\n#ifdef HAVE_LZMA_H\n\tif (zip->lzstream_valid)\n\t\tlzma_end(&(zip->lzstream));\n#endif\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tif (zip->bzstream_valid) {\n\t\tif (BZ2_bzDecompressEnd(&(zip->bzstream)) != BZ_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up bzip2 decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t\tzip->bzstream_valid = 0;\n\t}\n#endif\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid) {\n\t\tif (inflateEnd(&(zip->stream)) != Z_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up zlib decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t\tzip->stream_valid = 0;\n\t}\n#endif\n\tif (zip->ppmd7_valid) {\n\t\t__archive_ppmd7_functions.Ppmd7_Free(\n\t\t\t&zip->ppmd7_context, &g_szalloc);\n\t\tzip->ppmd7_valid = 0;\n\t}\n\treturn (r);\n}\n\nstatic int\nparse_7zip_uint64(struct archive_read *a, uint64_t *val)\n{\n\tconst unsigned char *p;\n\tunsigned char avail, mask;\n\tint i;\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tavail = *p;\n\tmask = 0x80;\n\t*val = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (avail & mask) {\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\t*val |= ((uint64_t)*p) << (8 * i);\n\t\t\tmask >>= 1;\n\t\t\tcontinue;\n\t\t}\n\t\t*val += ((uint64_t)(avail & (mask -1))) << (8 * i);\n\t\tbreak;\n\t}\n\treturn (0);\n}\n\nstatic int\nread_Bools(struct archive_read *a, unsigned char *data, size_t num)\n{\n\tconst unsigned char *p;\n\tunsigned i, mask = 0, avail = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (mask == 0) {\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tavail = *p;\n\t\t\tmask = 0x80;\n\t\t}\n\t\tdata[i] = (avail & mask)?1:0;\n\t\tmask >>= 1;\n\t}\n\treturn (0);\n}\n\nstatic void\nfree_Digest(struct _7z_digests *d)\n{\n\tfree(d->defineds);\n\tfree(d->digests);\n}\n\nstatic int\nread_Digests(struct archive_read *a, struct _7z_digests *d, size_t num)\n{\n\tconst unsigned char *p;\n\tunsigned i;\n\n\tif (num == 0)\n\t\treturn (-1);\n\tmemset(d, 0, sizeof(*d));\n\n\td->defineds = malloc(num);\n\tif (d->defineds == NULL)\n\t\treturn (-1);\n\t/*\n\t * Read Bools.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == 0) {\n\t\tif (read_Bools(a, d->defineds, num) < 0)\n\t\t\treturn (-1);\n\t} else\n\t\t/* All are defined */\n\t\tmemset(d->defineds, 1, num);\n\n\td->digests = calloc(num, sizeof(*d->digests));\n\tif (d->digests == NULL)\n\t\treturn (-1);\n\tfor (i = 0; i < num; i++) {\n\t\tif (d->defineds[i]) {\n\t\t\tif ((p = header_bytes(a, 4)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\td->digests[i] = archive_le32dec(p);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic void\nfree_PackInfo(struct _7z_pack_info *pi)\n{\n\tfree(pi->sizes);\n\tfree(pi->positions);\n\tfree_Digest(&(pi->digest));\n}\n\nstatic int\nread_PackInfo(struct archive_read *a, struct _7z_pack_info *pi)\n{\n\tconst unsigned char *p;\n\tunsigned i;\n\n\tmemset(pi, 0, sizeof(*pi));\n\n\t/*\n\t * Read PackPos.\n\t */\n\tif (parse_7zip_uint64(a, &(pi->pos)) < 0)\n\t\treturn (-1);\n\n\t/*\n\t * Read NumPackStreams.\n\t */\n\tif (parse_7zip_uint64(a, &(pi->numPackStreams)) < 0)\n\t\treturn (-1);\n\tif (pi->numPackStreams == 0)\n\t\treturn (-1);\n\tif (UMAX_ENTRY < pi->numPackStreams)\n\t\treturn (-1);\n\n\t/*\n\t * Read PackSizes[num]\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kEnd)\n\t\t/* PackSizes[num] are not present. */\n\t\treturn (0);\n\tif (*p != kSize)\n\t\treturn (-1);\n\tpi->sizes = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));\n\tpi->positions = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));\n\tif (pi->sizes == NULL || pi->positions == NULL)\n\t\treturn (-1);\n\n\tfor (i = 0; i < pi->numPackStreams; i++) {\n\t\tif (parse_7zip_uint64(a, &(pi->sizes[i])) < 0)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read PackStreamDigests[num]\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kEnd) {\n\t\t/* PackStreamDigests[num] are not present. */\n\t\tpi->digest.defineds =\n\t\t    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.defineds));\n\t\tpi->digest.digests =\n\t\t    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.digests));\n\t\tif (pi->digest.defineds == NULL || pi->digest.digests == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\tif (*p != kSize)\n\t\treturn (-1);\n\n\tif (read_Digests(a, &(pi->digest), (size_t)pi->numPackStreams) < 0)\n\t\treturn (-1);\n\n\t/*\n\t *  Must be marked by kEnd.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}\n\nstatic void\nfree_Folder(struct _7z_folder *f)\n{\n\tunsigned i;\n\n\tif (f->coders) {\n\t\tfor (i = 0; i< f->numCoders; i++) {\n\t\t\tfree(f->coders[i].properties);\n\t\t}\n\t\tfree(f->coders);\n\t}\n\tfree(f->bindPairs);\n\tfree(f->packedStreams);\n\tfree(f->unPackSize);\n}\n\nstatic int\nread_Folder(struct archive_read *a, struct _7z_folder *f)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tuint64_t numInStreamsTotal = 0;\n\tuint64_t numOutStreamsTotal = 0;\n\tunsigned i;\n\n\tmemset(f, 0, sizeof(*f));\n\n\t/*\n\t * Read NumCoders.\n\t */\n\tif (parse_7zip_uint64(a, &(f->numCoders)) < 0)\n\t\treturn (-1);\n\tif (f->numCoders > 4)\n\t\t/* Too many coders. */\n\t\treturn (-1);\n\n\tf->coders = calloc((size_t)f->numCoders, sizeof(*f->coders));\n\tif (f->coders == NULL)\n\t\treturn (-1);\n\tfor (i = 0; i< f->numCoders; i++) {\n\t\tsize_t codec_size;\n\t\tint simple, attr;\n\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\t/*\n\t\t * 0:3 CodecIdSize\n\t\t * 4:  0 - IsSimple\n\t\t *     1 - Is not Simple\n\t\t * 5:  0 - No Attributes\n\t\t *     1 - There are Attributes;\n\t\t * 7:  Must be zero.\n\t\t */\n\t\tcodec_size = *p & 0xf;\n\t\tsimple = (*p & 0x10)?0:1;\n\t\tattr = *p & 0x20;\n\t\tif (*p & 0x80)\n\t\t\treturn (-1);/* Not supported. */\n\n\t\t/*\n\t\t * Read Decompression Method IDs.\n\t\t */\n\t\tif ((p = header_bytes(a, codec_size)) == NULL)\n\t\t\treturn (-1);\n\n\t\tf->coders[i].codec = decode_codec_id(p, codec_size);\n\n\t\tif (simple) {\n\t\t\tf->coders[i].numInStreams = 1;\n\t\t\tf->coders[i].numOutStreams = 1;\n\t\t} else {\n\t\t\tif (parse_7zip_uint64(\n\t\t\t    a, &(f->coders[i].numInStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f->coders[i].numInStreams)\n\t\t\t\treturn (-1);\n\t\t\tif (parse_7zip_uint64(\n\t\t\t    a, &(f->coders[i].numOutStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f->coders[i].numOutStreams)\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\tif (attr) {\n\t\t\tif (parse_7zip_uint64(\n\t\t\t    a, &(f->coders[i].propertiesSize)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif ((p = header_bytes(\n\t\t\t    a, (size_t)f->coders[i].propertiesSize)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tf->coders[i].properties =\n\t\t\t    malloc((size_t)f->coders[i].propertiesSize);\n\t\t\tif (f->coders[i].properties == NULL)\n\t\t\t\treturn (-1);\n\t\t\tmemcpy(f->coders[i].properties, p,\n\t\t\t    (size_t)f->coders[i].propertiesSize);\n\t\t}\n\n\t\tnumInStreamsTotal += f->coders[i].numInStreams;\n\t\tnumOutStreamsTotal += f->coders[i].numOutStreams;\n\t}\n\n\tif (numOutStreamsTotal == 0 ||\n\t    numInStreamsTotal < numOutStreamsTotal-1)\n\t\treturn (-1);\n\n\tf->numBindPairs = numOutStreamsTotal - 1;\n\tif (zip->header_bytes_remaining < f->numBindPairs)\n\t\t\treturn (-1);\n\tif (f->numBindPairs > 0) {\n\t\tf->bindPairs =\n\t\t\tcalloc((size_t)f->numBindPairs, sizeof(*f->bindPairs));\n\t\tif (f->bindPairs == NULL)\n\t\t\treturn (-1);\n\t} else\n\t\tf->bindPairs = NULL;\n\tfor (i = 0; i < f->numBindPairs; i++) {\n\t\tif (parse_7zip_uint64(a, &(f->bindPairs[i].inIndex)) < 0)\n\t\t\treturn (-1);\n\t\tif (UMAX_ENTRY < f->bindPairs[i].inIndex)\n\t\t\treturn (-1);\n\t\tif (parse_7zip_uint64(a, &(f->bindPairs[i].outIndex)) < 0)\n\t\t\treturn (-1);\n\t\tif (UMAX_ENTRY < f->bindPairs[i].outIndex)\n\t\t\treturn (-1);\n\t}\n\n\tf->numPackedStreams = numInStreamsTotal - f->numBindPairs;\n\tf->packedStreams =\n\t    calloc((size_t)f->numPackedStreams, sizeof(*f->packedStreams));\n\tif (f->packedStreams == NULL)\n\t\treturn (-1);\n\tif (f->numPackedStreams == 1) {\n\t\tfor (i = 0; i < numInStreamsTotal; i++) {\n\t\t\tunsigned j;\n\t\t\tfor (j = 0; j < f->numBindPairs; j++) {\n\t\t\t\tif (f->bindPairs[j].inIndex == i)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == f->numBindPairs)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == numInStreamsTotal)\n\t\t\treturn (-1);\n\t\tf->packedStreams[0] = i;\n\t} else {\n\t\tfor (i = 0; i < f->numPackedStreams; i++) {\n\t\t\tif (parse_7zip_uint64(a, &(f->packedStreams[i])) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f->packedStreams[i])\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\tf->numInStreams = numInStreamsTotal;\n\tf->numOutStreams = numOutStreamsTotal;\n\n\treturn (0);\n}\n\nstatic void\nfree_CodersInfo(struct _7z_coders_info *ci)\n{\n\tunsigned i;\n\n\tif (ci->folders) {\n\t\tfor (i = 0; i < ci->numFolders; i++)\n\t\t\tfree_Folder(&(ci->folders[i]));\n\t\tfree(ci->folders);\n\t}\n}\n\nstatic int\nread_CodersInfo(struct archive_read *a, struct _7z_coders_info *ci)\n{\n\tconst unsigned char *p;\n\tstruct _7z_digests digest;\n\tunsigned i;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(&digest, 0, sizeof(digest));\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p != kFolder)\n\t\tgoto failed;\n\n\t/*\n\t * Read NumFolders.\n\t */\n\tif (parse_7zip_uint64(a, &(ci->numFolders)) < 0)\n\t\tgoto failed;\n\tif (UMAX_ENTRY < ci->numFolders)\n\t\treturn (-1);\n\n\t/*\n\t * Read External.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tswitch (*p) {\n\tcase 0:\n\t\tci->folders =\n\t\t\tcalloc((size_t)ci->numFolders, sizeof(*ci->folders));\n\t\tif (ci->folders == NULL)\n\t\t\treturn (-1);\n\t\tfor (i = 0; i < ci->numFolders; i++) {\n\t\t\tif (read_Folder(a, &(ci->folders[i])) < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tif (parse_7zip_uint64(a, &(ci->dataStreamIndex)) < 0)\n\t\t\treturn (-1);\n\t\tif (UMAX_ENTRY < ci->dataStreamIndex)\n\t\t\treturn (-1);\n\t\tif (ci->numFolders > 0) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\t\tgoto failed;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, -1,\n\t\t    \"Malformed 7-Zip archive\");\n\t\tgoto failed;\n\t}\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p != kCodersUnPackSize)\n\t\tgoto failed;\n\n\tfor (i = 0; i < ci->numFolders; i++) {\n\t\tstruct _7z_folder *folder = &(ci->folders[i]);\n\t\tunsigned j;\n\n\t\tfolder->unPackSize =\n\t\t    calloc((size_t)folder->numOutStreams, sizeof(*folder->unPackSize));\n\t\tif (folder->unPackSize == NULL)\n\t\t\tgoto failed;\n\t\tfor (j = 0; j < folder->numOutStreams; j++) {\n\t\t\tif (parse_7zip_uint64(a, &(folder->unPackSize[j])) < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\t}\n\n\t/*\n\t * Read CRCs.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p == kEnd)\n\t\treturn (0);\n\tif (*p != kCRC)\n\t\tgoto failed;\n\tif (read_Digests(a, &digest, (size_t)ci->numFolders) < 0)\n\t\tgoto failed;\n\tfor (i = 0; i < ci->numFolders; i++) {\n\t\tci->folders[i].digest_defined = digest.defineds[i];\n\t\tci->folders[i].digest = digest.digests[i];\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p != kEnd)\n\t\tgoto failed;\n\tfree_Digest(&digest);\n\treturn (0);\nfailed:\n\tfree_Digest(&digest);\n\treturn (-1);\n}\n\nstatic uint64_t\nfolder_uncompressed_size(struct _7z_folder *f)\n{\n\tint n = (int)f->numOutStreams;\n\tunsigned pairs = (unsigned)f->numBindPairs;\n\n\twhile (--n >= 0) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < pairs; i++) {\n\t\t\tif (f->bindPairs[i].outIndex == (uint64_t)n)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= pairs)\n\t\t\treturn (f->unPackSize[n]);\n\t}\n\treturn (0);\n}\n\nstatic void\nfree_SubStreamsInfo(struct _7z_substream_info *ss)\n{\n\tfree(ss->unpackSizes);\n\tfree(ss->digestsDefined);\n\tfree(ss->digests);\n}\n\nstatic int\nread_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,\n    struct _7z_folder *f, size_t numFolders)\n{\n\tconst unsigned char *p;\n\tuint64_t *usizes;\n\tsize_t unpack_streams;\n\tint type;\n\tunsigned i;\n\tuint32_t numDigests;\n\n\tmemset(ss, 0, sizeof(*ss));\n\n\tfor (i = 0; i < numFolders; i++)\n\t\tf[i].numUnpackStreams = 1;\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\ttype = *p;\n\n\tif (type == kNumUnPackStream) {\n\t\tunpack_streams = 0;\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (parse_7zip_uint64(a, &(f[i].numUnpackStreams)) < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (UMAX_ENTRY < f[i].numUnpackStreams)\n\t\t\t\treturn (-1);\n\t\t\tif (unpack_streams > SIZE_MAX - UMAX_ENTRY) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tunpack_streams += (size_t)f[i].numUnpackStreams;\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t} else\n\t\tunpack_streams = numFolders;\n\n\tss->unpack_streams = unpack_streams;\n\tif (unpack_streams) {\n\t\tss->unpackSizes = calloc(unpack_streams,\n\t\t    sizeof(*ss->unpackSizes));\n\t\tss->digestsDefined = calloc(unpack_streams,\n\t\t    sizeof(*ss->digestsDefined));\n\t\tss->digests = calloc(unpack_streams,\n\t\t    sizeof(*ss->digests));\n\t\tif (ss->unpackSizes == NULL || ss->digestsDefined == NULL ||\n\t\t    ss->digests == NULL)\n\t\t\treturn (-1);\n\t}\n\n\tusizes = ss->unpackSizes;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tunsigned pack;\n\t\tuint64_t sum;\n\n\t\tif (f[i].numUnpackStreams == 0)\n\t\t\tcontinue;\n\n\t\tsum = 0;\n\t\tif (type == kSize) {\n\t\t\tfor (pack = 1; pack < f[i].numUnpackStreams; pack++) {\n\t\t\t\tif (parse_7zip_uint64(a, usizes) < 0)\n\t\t\t\t\treturn (-1);\n\t\t\t\tsum += *usizes++;\n\t\t\t}\n\t\t}\n\t\t*usizes++ = folder_uncompressed_size(&f[i]) - sum;\n\t}\n\n\tif (type == kSize) {\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\tfor (i = 0; i < unpack_streams; i++) {\n\t\tss->digestsDefined[i] = 0;\n\t\tss->digests[i] = 0;\n\t}\n\n\tnumDigests = 0;\n\tfor (i = 0; i < numFolders; i++) {\n\t\tif (f[i].numUnpackStreams != 1 || !f[i].digest_defined)\n\t\t\tnumDigests += (uint32_t)f[i].numUnpackStreams;\n\t}\n\n\tif (type == kCRC) {\n\t\tstruct _7z_digests tmpDigests;\n\t\tunsigned char *digestsDefined = ss->digestsDefined;\n\t\tuint32_t * digests = ss->digests;\n\t\tint di = 0;\n\n\t\tmemset(&tmpDigests, 0, sizeof(tmpDigests));\n\t\tif (read_Digests(a, &(tmpDigests), numDigests) < 0) {\n\t\t\tfree_Digest(&tmpDigests);\n\t\t\treturn (-1);\n\t\t}\n\t\tfor (i = 0; i < numFolders; i++) {\n\t\t\tif (f[i].numUnpackStreams == 1 && f[i].digest_defined) {\n\t\t\t\t*digestsDefined++ = 1;\n\t\t\t\t*digests++ = f[i].digest;\n\t\t\t} else {\n\t\t\t\tunsigned j;\n\n\t\t\t\tfor (j = 0; j < f[i].numUnpackStreams;\n\t\t\t\t    j++, di++) {\n\t\t\t\t\t*digestsDefined++ =\n\t\t\t\t\t    tmpDigests.defineds[di];\n\t\t\t\t\t*digests++ =\n\t\t\t\t\t    tmpDigests.digests[di];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree_Digest(&tmpDigests);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif (type != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}\n\nstatic void\nfree_StreamsInfo(struct _7z_stream_info *si)\n{\n\tfree_PackInfo(&(si->pi));\n\tfree_CodersInfo(&(si->ci));\n\tfree_SubStreamsInfo(&(si->ss));\n}\n\nstatic int\nread_StreamsInfo(struct archive_read *a, struct _7z_stream_info *si)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tunsigned i;\n\n\tmemset(si, 0, sizeof(*si));\n\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kPackInfo) {\n\t\tuint64_t packPos;\n\n\t\tif (read_PackInfo(a, &(si->pi)) < 0)\n\t\t\treturn (-1);\n\n\t\tif (si->pi.positions == NULL || si->pi.sizes == NULL)\n\t\t\treturn (-1);\n\t\t/*\n\t\t * Calculate packed stream positions.\n\t\t */\n\t\tpackPos = si->pi.pos;\n\t\tfor (i = 0; i < si->pi.numPackStreams; i++) {\n\t\t\tsi->pi.positions[i] = packPos;\n\t\t\tpackPos += si->pi.sizes[i];\n\t\t\tif (packPos > zip->header_offset)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p == kUnPackInfo) {\n\t\tuint32_t packIndex;\n\t\tstruct _7z_folder *f;\n\n\t\tif (read_CodersInfo(a, &(si->ci)) < 0)\n\t\t\treturn (-1);\n\n\t\t/*\n\t\t * Calculate packed stream indexes.\n\t\t */\n\t\tpackIndex = 0;\n\t\tf = si->ci.folders;\n\t\tfor (i = 0; i < si->ci.numFolders; i++) {\n\t\t\tf[i].packIndex = packIndex;\n\t\t\tpackIndex += (uint32_t)f[i].numPackedStreams;\n\t\t\tif (packIndex > si->pi.numPackStreams)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\n\tif (*p == kSubStreamsInfo) {\n\t\tif (read_SubStreamsInfo(a, &(si->ss),\n\t\t    si->ci.folders, (size_t)si->ci.numFolders) < 0)\n\t\t\treturn (-1);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t *  Must be kEnd.\n\t */\n\tif (*p != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}\n\nstatic void\nfree_Header(struct _7z_header_info *h)\n{\n\tfree(h->emptyStreamBools);\n\tfree(h->emptyFileBools);\n\tfree(h->antiBools);\n\tfree(h->attrBools);\n}\n\nstatic int\nread_Header(struct archive_read *a, struct _7z_header_info *h,\n    int check_header_id)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tstruct _7z_folder *folders;\n\tstruct _7z_stream_info *si = &(zip->si);\n\tstruct _7zip_entry *entries;\n\tuint32_t folderIndex, indexInFolder;\n\tunsigned i;\n\tint eindex, empty_streams, sindex;\n\n\tif (check_header_id) {\n\t\t/*\n\t\t * Read Header.\n\t\t */\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\tif (*p != kHeader)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read ArchiveProperties.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kArchiveProperties) {\n\t\tfor (;;) {\n\t\t\tuint64_t size;\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (*p == 0)\n\t\t\t\tbreak;\n\t\t\tif (parse_7zip_uint64(a, &size) < 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read MainStreamsInfo.\n\t */\n\tif (*p == kMainStreamsInfo) {\n\t\tif (read_StreamsInfo(a, &(zip->si)) < 0)\n\t\t\treturn (-1);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p == kEnd)\n\t\treturn (0);\n\n\t/*\n\t * Read FilesInfo.\n\t */\n\tif (*p != kFilesInfo)\n\t\treturn (-1);\n\n\tif (parse_7zip_uint64(a, &(zip->numFiles)) < 0)\n\t\treturn (-1);\n\tif (UMAX_ENTRY < zip->numFiles)\n\t\treturn (-1);\n\n\tzip->entries = calloc((size_t)zip->numFiles, sizeof(*zip->entries));\n\tif (zip->entries == NULL)\n\t\treturn (-1);\n\tentries = zip->entries;\n\n\tempty_streams = 0;\n\tfor (;;) {\n\t\tint type;\n\t\tuint64_t size;\n\t\tsize_t ll;\n\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t\tif (type == kEnd)\n\t\t\tbreak;\n\n\t\tif (parse_7zip_uint64(a, &size) < 0)\n\t\t\treturn (-1);\n\t\tif (zip->header_bytes_remaining < size)\n\t\t\treturn (-1);\n\t\tll = (size_t)size;\n\n\t\tswitch (type) {\n\t\tcase kEmptyStream:\n\t\t\th->emptyStreamBools = calloc((size_t)zip->numFiles,\n\t\t\t    sizeof(*h->emptyStreamBools));\n\t\t\tif (h->emptyStreamBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(\n\t\t\t    a, h->emptyStreamBools, (size_t)zip->numFiles) < 0)\n\t\t\t\treturn (-1);\n\t\t\tempty_streams = 0;\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tif (h->emptyStreamBools[i])\n\t\t\t\t\tempty_streams++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase kEmptyFile:\n\t\t\tif (empty_streams <= 0) {\n\t\t\t\t/* Unexcepted sequence. Skip this. */\n\t\t\t\tif (header_bytes(a, ll) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th->emptyFileBools = calloc(empty_streams,\n\t\t\t    sizeof(*h->emptyFileBools));\n\t\t\tif (h->emptyFileBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(a, h->emptyFileBools, empty_streams) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kAnti:\n\t\t\tif (empty_streams <= 0) {\n\t\t\t\t/* Unexcepted sequence. Skip this. */\n\t\t\t\tif (header_bytes(a, ll) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th->antiBools = calloc(empty_streams,\n\t\t\t    sizeof(*h->antiBools));\n\t\t\tif (h->antiBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(a, h->antiBools, empty_streams) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kCTime:\n\t\tcase kATime:\n\t\tcase kMTime:\n\t\t\tif (read_Times(a, h, type) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kName:\n\t\t{\n\t\t\tunsigned char *np;\n\t\t\tsize_t nl, nb;\n\n\t\t\t/* Skip one byte. */\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tll--;\n\n\t\t\tif ((ll & 1) || ll < zip->numFiles * 4)\n\t\t\t\treturn (-1);\n\n\t\t\tzip->entry_names = malloc(ll);\n\t\t\tif (zip->entry_names == NULL)\n\t\t\t\treturn (-1);\n\t\t\tnp = zip->entry_names;\n\t\t\tnb = ll;\n\t\t\t/*\n\t\t\t * Copy whole file names.\n\t\t\t * NOTE: This loop prevents from expanding\n\t\t\t * the uncompressed buffer in order not to\n\t\t\t * use extra memory resource.\n\t\t\t */\n\t\t\twhile (nb) {\n\t\t\t\tsize_t b;\n\t\t\t\tif (nb > UBUFF_SIZE)\n\t\t\t\t\tb = UBUFF_SIZE;\n\t\t\t\telse\n\t\t\t\t\tb = nb;\n\t\t\t\tif ((p = header_bytes(a, b)) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tmemcpy(np, p, b);\n\t\t\t\tnp += b;\n\t\t\t\tnb -= b;\n\t\t\t}\n\t\t\tnp = zip->entry_names;\n\t\t\tnl = ll;\n\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tentries[i].utf16name = np;\n#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)\n\t\t\t\tentries[i].wname = (wchar_t *)np;\n#endif\n\n\t\t\t\t/* Find a terminator. */\n\t\t\t\twhile (nl >= 2 && (np[0] || np[1])) {\n\t\t\t\t\tnp += 2;\n\t\t\t\t\tnl -= 2;\n\t\t\t\t}\n\t\t\t\tif (nl < 2)\n\t\t\t\t\treturn (-1);/* Terminator not found */\n\t\t\t\tentries[i].name_len = np - entries[i].utf16name;\n\t\t\t\tnp += 2;\n\t\t\t\tnl -= 2;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase kAttributes:\n\t\t{\n\t\t\tint allAreDefined;\n\n\t\t\tif ((p = header_bytes(a, 2)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tallAreDefined = *p;\n\t\t\th->attrBools = calloc((size_t)zip->numFiles,\n\t\t\t    sizeof(*h->attrBools));\n\t\t\tif (h->attrBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (allAreDefined)\n\t\t\t\tmemset(h->attrBools, 1, (size_t)zip->numFiles);\n\t\t\telse {\n\t\t\t\tif (read_Bools(a, h->attrBools,\n\t\t\t\t      (size_t)zip->numFiles) < 0)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tif (h->attrBools[i]) {\n\t\t\t\t\tif ((p = header_bytes(a, 4)) == NULL)\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\tentries[i].attr = archive_le32dec(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase kDummy:\n\t\t\tif (ll == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (header_bytes(a, ll) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Set up entry's attributes.\n\t */\n\tfolders = si->ci.folders;\n\teindex = sindex = 0;\n\tfolderIndex = indexInFolder = 0;\n\tfor (i = 0; i < zip->numFiles; i++) {\n\t\tif (h->emptyStreamBools == NULL || h->emptyStreamBools[i] == 0)\n\t\t\tentries[i].flg |= HAS_STREAM;\n\t\t/* The high 16 bits of attributes is a posix file mode. */\n\t\tentries[i].mode = entries[i].attr >> 16;\n\t\tif (entries[i].flg & HAS_STREAM) {\n\t\t\tif ((size_t)sindex >= si->ss.unpack_streams)\n\t\t\t\treturn (-1);\n\t\t\tif (entries[i].mode == 0)\n\t\t\t\tentries[i].mode = AE_IFREG | 0666;\n\t\t\tif (si->ss.digestsDefined[sindex])\n\t\t\t\tentries[i].flg |= CRC32_IS_SET;\n\t\t\tentries[i].ssIndex = sindex;\n\t\t\tsindex++;\n\t\t} else {\n\t\t\tint dir;\n\t\t\tif (h->emptyFileBools == NULL)\n\t\t\t\tdir = 1;\n\t\t\telse {\n\t\t\t\tif (h->emptyFileBools[eindex])\n\t\t\t\t\tdir = 0;\n\t\t\t\telse\n\t\t\t\t\tdir = 1;\n\t\t\t\teindex++;\n\t\t\t}\n\t\t\tif (entries[i].mode == 0) {\n\t\t\t\tif (dir)\n\t\t\t\t\tentries[i].mode = AE_IFDIR | 0777;\n\t\t\t\telse\n\t\t\t\t\tentries[i].mode = AE_IFREG | 0666;\n\t\t\t} else if (dir &&\n\t\t\t    (entries[i].mode & AE_IFMT) != AE_IFDIR) {\n\t\t\t\tentries[i].mode &= ~AE_IFMT;\n\t\t\t\tentries[i].mode |= AE_IFDIR;\n\t\t\t}\n\t\t\tif ((entries[i].mode & AE_IFMT) == AE_IFDIR &&\n\t\t\t    entries[i].name_len >= 2 &&\n\t\t\t    (entries[i].utf16name[entries[i].name_len-2] != '/' ||\n\t\t\t     entries[i].utf16name[entries[i].name_len-1] != 0)) {\n\t\t\t\tentries[i].utf16name[entries[i].name_len] = '/';\n\t\t\t\tentries[i].utf16name[entries[i].name_len+1] = 0;\n\t\t\t\tentries[i].name_len += 2;\n\t\t\t}\n\t\t\tentries[i].ssIndex = -1;\n\t\t}\n\t\tif (entries[i].attr & 0x01)\n\t\t\tentries[i].mode &= ~0222;/* Read only. */\n\n\t\tif ((entries[i].flg & HAS_STREAM) == 0 && indexInFolder == 0) {\n\t\t\t/*\n\t\t\t * The entry is an empty file or a directory file,\n\t\t\t * those both have no contents.\n\t\t\t */\n\t\t\tentries[i].folderIndex = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (indexInFolder == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tif (folderIndex >= si->ci.numFolders)\n\t\t\t\t\treturn (-1);\n\t\t\t\tif (folders[folderIndex].numUnpackStreams)\n\t\t\t\t\tbreak;\n\t\t\t\tfolderIndex++;\n\t\t\t}\n\t\t}\n\t\tentries[i].folderIndex = folderIndex;\n\t\tif ((entries[i].flg & HAS_STREAM) == 0)\n\t\t\tcontinue;\n\t\tindexInFolder++;\n\t\tif (indexInFolder >= folders[folderIndex].numUnpackStreams) {\n\t\t\tfolderIndex++;\n\t\t\tindexInFolder = 0;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n#define EPOC_TIME ARCHIVE_LITERAL_ULL(116444736000000000)\nstatic void\nfileTimeToUtc(uint64_t fileTime, time_t *timep, long *ns)\n{\n\n\tif (fileTime >= EPOC_TIME) {\n\t\tfileTime -= EPOC_TIME;\n\t\t/* milli seconds base */\n\t\t*timep = (time_t)(fileTime / 10000000);\n\t\t/* nano seconds base */\n\t\t*ns = (long)(fileTime % 10000000) * 100;\n\t} else {\n\t\t*timep = 0;\n\t\t*ns = 0;\n\t}\n}\n\nstatic int\nread_Times(struct archive_read *a, struct _7z_header_info *h, int type)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tstruct _7zip_entry *entries = zip->entries;\n\tunsigned char *timeBools;\n\tint allAreDefined;\n\tunsigned i;\n\n\ttimeBools = calloc((size_t)zip->numFiles, sizeof(*timeBools));\n\tif (timeBools == NULL)\n\t\treturn (-1);\n\n\t/* Read allAreDefined. */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tallAreDefined = *p;\n\tif (allAreDefined)\n\t\tmemset(timeBools, 1, (size_t)zip->numFiles);\n\telse {\n\t\tif (read_Bools(a, timeBools, (size_t)zip->numFiles) < 0)\n\t\t\tgoto failed;\n\t}\n\n\t/* Read external. */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\tgoto failed;\n\tif (*p) {\n\t\tif (parse_7zip_uint64(a, &(h->dataIndex)) < 0)\n\t\t\tgoto failed;\n\t\tif (UMAX_ENTRY < h->dataIndex)\n\t\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < zip->numFiles; i++) {\n\t\tif (!timeBools[i])\n\t\t\tcontinue;\n\t\tif ((p = header_bytes(a, 8)) == NULL)\n\t\t\tgoto failed;\n\t\tswitch (type) {\n\t\tcase kCTime:\n\t\t\tfileTimeToUtc(archive_le64dec(p),\n\t\t\t    &(entries[i].ctime),\n\t\t\t    &(entries[i].ctime_ns));\n\t\t\tentries[i].flg |= CTIME_IS_SET;\n\t\t\tbreak;\n\t\tcase kATime:\n\t\t\tfileTimeToUtc(archive_le64dec(p),\n\t\t\t    &(entries[i].atime),\n\t\t\t    &(entries[i].atime_ns));\n\t\t\tentries[i].flg |= ATIME_IS_SET;\n\t\t\tbreak;\n\t\tcase kMTime:\n\t\t\tfileTimeToUtc(archive_le64dec(p),\n\t\t\t    &(entries[i].mtime),\n\t\t\t    &(entries[i].mtime_ns));\n\t\t\tentries[i].flg |= MTIME_IS_SET;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(timeBools);\n\treturn (0);\nfailed:\n\tfree(timeBools);\n\treturn (-1);\n}\n\nstatic int\ndecode_encoded_header_info(struct archive_read *a, struct _7z_stream_info *si)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\n\terrno = 0;\n\tif (read_StreamsInfo(a, si) < 0) {\n\t\tif (errno == ENOMEM)\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Couldn't allocate memory\");\n\t\telse\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (si->pi.numPackStreams == 0 || si->ci.numFolders == 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Malformed 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (zip->header_offset < si->pi.pos + si->pi.sizes[0] ||\n\t    (int64_t)(si->pi.pos + si->pi.sizes[0]) < 0 ||\n\t    si->pi.sizes[0] == 0 || (int64_t)si->pi.pos < 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Malformed Header offset\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic const unsigned char *\nheader_bytes(struct archive_read *a, size_t rbytes)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\n\tif (zip->header_bytes_remaining < rbytes)\n\t\treturn (NULL);\n\tif (zip->pack_stream_bytes_unconsumed)\n\t\tread_consume(a);\n\n\tif (zip->header_is_encoded == 0) {\n\t\tp = __archive_read_ahead(a, rbytes, NULL);\n\t\tif (p == NULL)\n\t\t\treturn (NULL);\n\t\tzip->header_bytes_remaining -= rbytes;\n\t\tzip->pack_stream_bytes_unconsumed = rbytes;\n\t} else {\n\t\tconst void *buff;\n\t\tssize_t bytes;\n\n\t\tbytes = read_stream(a, &buff, rbytes, rbytes);\n\t\tif (bytes <= 0)\n\t\t\treturn (NULL);\n\t\tzip->header_bytes_remaining -= bytes;\n\t\tp = buff;\n\t}\n\n\t/* Update checksum */\n\tzip->header_crc32 = crc32(zip->header_crc32, p, (unsigned)rbytes);\n\treturn (p);\n}\n\nstatic int\nslurp_central_directory(struct archive_read *a, struct _7zip *zip,\n    struct _7z_header_info *header)\n{\n\tconst unsigned char *p;\n\tuint64_t next_header_offset;\n\tuint64_t next_header_size;\n\tuint32_t next_header_crc;\n\tssize_t bytes_avail;\n\tint check_header_crc, r;\n\n\tif ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\n\tif ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, \"\\x7F\\x45LF\", 4) == 0) {\n\t\t/* This is an executable ? Must be self-extracting... */\n\t\tr = skip_sfx(a, bytes_avail);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->seek_base += 32;\n\n\tif (memcmp(p, _7ZIP_SIGNATURE, 6) != 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Not 7-Zip archive file\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* CRC check. */\n\tif (crc32(0, (const unsigned char *)p + 12, 20)\n\t    != archive_le32dec(p + 8)) {\n\t\tarchive_set_error(&a->archive, -1, \"Header CRC error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tnext_header_offset = archive_le64dec(p + 12);\n\tnext_header_size = archive_le64dec(p + 20);\n\tnext_header_crc = archive_le32dec(p + 28);\n\n\tif (next_header_size == 0)\n\t\t/* There is no entry in an archive file. */\n\t\treturn (ARCHIVE_EOF);\n\n\tif (((int64_t)next_header_offset) < 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Malformed 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\t__archive_read_consume(a, 32);\n\tif (next_header_offset != 0) {\n\t\tif (bytes_avail >= (ssize_t)next_header_offset)\n\t\t\t__archive_read_consume(a, next_header_offset);\n\t\telse if (__archive_read_seek(a,\n\t\t    next_header_offset + zip->seek_base, SEEK_SET) < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->stream_offset = next_header_offset;\n\tzip->header_offset = next_header_offset;\n\tzip->header_bytes_remaining = next_header_size;\n\tzip->header_crc32 = 0;\n\tzip->header_is_encoded = 0;\n\tzip->header_is_being_read = 1;\n\tzip->has_encrypted_entries = 0;\n\tcheck_header_crc = 1;\n\n\tif ((p = header_bytes(a, 1)) == NULL) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated 7-Zip file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\t/* Parse ArchiveProperties. */\n\tswitch (p[0]) {\n\tcase kEncodedHeader:\n\t\t/*\n\t\t * The archive has an encoded header and we have to decode it\n\t\t * in order to parse the header correctly.\n\t\t */\n\t\tr = decode_encoded_header_info(a, &(zip->si));\n\n\t\t/* Check the EncodedHeader CRC.*/\n\t\tif (r == 0 && zip->header_crc32 != next_header_crc) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Damaged 7-Zip archive\");\n\t\t\tr = -1;\n\t\t}\n\t\tif (r == 0) {\n\t\t\tif (zip->si.ci.folders[0].digest_defined)\n\t\t\t\tnext_header_crc = zip->si.ci.folders[0].digest;\n\t\t\telse\n\t\t\t\tcheck_header_crc = 0;\n\t\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\t\tread_consume(a);\n\t\t\tr = setup_decode_folder(a, zip->si.ci.folders, 1);\n\t\t\tif (r == 0) {\n\t\t\t\tzip->header_bytes_remaining =\n\t\t\t\t\tzip->folder_outbytes_remaining;\n\t\t\t\tr = seek_pack(a);\n\t\t\t}\n\t\t}\n\t\t/* Clean up StreamsInfo. */\n\t\tfree_StreamsInfo(&(zip->si));\n\t\tmemset(&(zip->si), 0, sizeof(zip->si));\n\t\tif (r < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tzip->header_is_encoded = 1;\n\t\tzip->header_crc32 = 0;\n\t\t/* FALL THROUGH */\n\tcase kHeader:\n\t\t/*\n\t\t * Parse the header.\n\t\t */\n\t\terrno = 0;\n\t\tr = read_Header(a, header, zip->header_is_encoded);\n\t\tif (r < 0) {\n\t\t\tif (errno == ENOMEM)\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Couldn't allocate memory\");\n\t\t\telse\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Damaged 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/*\n\t\t *  Must be kEnd.\n\t\t */\n\t\tif ((p = header_bytes(a, 1)) == NULL ||*p != kEnd) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/* Check the Header CRC.*/\n\t\tif (check_header_crc && zip->header_crc32 != next_header_crc) {\n\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t    \"Malformed 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, -1,\n\t\t    \"Unexpected Property ID = %X\", p[0]);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* Clean up variables be used for decoding the archive header */\n\tzip->pack_stream_remaining = 0;\n\tzip->pack_stream_index = 0;\n\tzip->folder_outbytes_remaining = 0;\n\tzip->uncompressed_buffer_bytes_remaining = 0;\n\tzip->pack_stream_bytes_unconsumed = 0;\n\tzip->header_is_being_read = 0;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nget_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t/* Copy mode. */\n\n\t\t/*\n\t\t * Note: '1' here is a performance optimization.\n\t\t * Recall that the decompression layer returns a count of\n\t\t * available bytes; asking for more than that forces the\n\t\t * decompressor to combine reads by copying data.\n\t\t */\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\t/* Decompression has failed. */\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\t/* Packed mode. */\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\t/*\n\t\t\t * If remaining uncompressed data size is less than\n\t\t\t * the minimum size, fill the buffer up to the\n\t\t\t * minimum size.\n\t\t\t */\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}\n\nstatic ssize_t\nextract_pack_stream(struct archive_read *a, size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\tint r;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\tif (minimum == 0)\n\t\t\tminimum = 1;\n\t\tif (__archive_read_ahead(a, minimum, &bytes_avail) == NULL\n\t\t    || bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (bytes_avail > (ssize_t)zip->pack_stream_inbytes_remaining)\n\t\t\tbytes_avail = (ssize_t)zip->pack_stream_inbytes_remaining;\n\t\tzip->pack_stream_inbytes_remaining -= bytes_avail;\n\t\tif (bytes_avail > (ssize_t)zip->folder_outbytes_remaining)\n\t\t\tbytes_avail = (ssize_t)zip->folder_outbytes_remaining;\n\t\tzip->folder_outbytes_remaining -= bytes_avail;\n\t\tzip->uncompressed_buffer_bytes_remaining = bytes_avail;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* If the buffer hasn't been allocated, allocate it now. */\n\tif (zip->uncompressed_buffer == NULL) {\n\t\tzip->uncompressed_buffer_size = UBUFF_SIZE;\n\t\tif (zip->uncompressed_buffer_size < minimum) {\n\t\t\tzip->uncompressed_buffer_size = minimum + 1023;\n\t\t\tzip->uncompressed_buffer_size &= ~0x3ff;\n\t\t}\n\t\tzip->uncompressed_buffer =\n\t\t    malloc(zip->uncompressed_buffer_size);\n\t\tif (zip->uncompressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tzip->uncompressed_buffer_bytes_remaining = 0;\n\t} else if (zip->uncompressed_buffer_size < minimum ||\n\t    zip->uncompressed_buffer_bytes_remaining < minimum) {\n\t\t/*\n\t\t * Make sure the uncompressed buffer can have bytes\n\t\t * at least `minimum' bytes.\n\t\t * NOTE: This case happen when reading the header.\n\t\t */\n\t\tsize_t used;\n\t\tif (zip->uncompressed_buffer_pointer != 0)\n\t\t\tused = zip->uncompressed_buffer_pointer -\n\t\t\t\tzip->uncompressed_buffer;\n\t\telse\n\t\t\tused = 0;\n\t\tif (zip->uncompressed_buffer_size < minimum) {\n\t\t\t/*\n\t\t\t * Expand the uncompressed buffer up to\n\t\t\t * the minimum size.\n\t\t\t */\n\t\t\tvoid *p;\n\t\t\tsize_t new_size;\n\n\t\t\tnew_size = minimum + 1023;\n\t\t\tnew_size &= ~0x3ff;\n\t\t\tp = realloc(zip->uncompressed_buffer, new_size);\n\t\t\tif (p == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tzip->uncompressed_buffer = (unsigned char *)p;\n\t\t\tzip->uncompressed_buffer_size = new_size;\n\t\t}\n\t\t/*\n\t\t * Move unconsumed bytes to the head.\n\t\t */\n\t\tif (used) {\n\t\t\tmemmove(zip->uncompressed_buffer,\n\t\t\t\tzip->uncompressed_buffer + used,\n\t\t\t\tzip->uncompressed_buffer_bytes_remaining);\n\t\t}\n\t} else\n\t\tzip->uncompressed_buffer_bytes_remaining = 0;\n\tzip->uncompressed_buffer_pointer = NULL;\n\tfor (;;) {\n\t\tsize_t bytes_in, bytes_out;\n\t\tconst void *buff_in;\n\t\tunsigned char *buff_out;\n\t\tint end_of_data;\n\n\t\t/*\n\t\t * Note: '1' here is a performance optimization.\n\t\t * Recall that the decompression layer returns a count of\n\t\t * available bytes; asking for more than that forces the\n\t\t * decompressor to combine reads by copying data.\n\t\t */\n\t\tbuff_in = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tbuff_out = zip->uncompressed_buffer\n\t\t\t+ zip->uncompressed_buffer_bytes_remaining;\n\t\tbytes_out = zip->uncompressed_buffer_size\n\t\t\t- zip->uncompressed_buffer_bytes_remaining;\n\t\tbytes_in = bytes_avail;\n\t\tif (bytes_in > zip->pack_stream_inbytes_remaining)\n\t\t\tbytes_in = (size_t)zip->pack_stream_inbytes_remaining;\n\t\t/* Drive decompression. */\n\t\tr = decompress(a, zip, buff_out, &bytes_out,\n\t\t\tbuff_in, &bytes_in);\n\t\tswitch (r) {\n\t\tcase ARCHIVE_OK:\n\t\t\tend_of_data = 0;\n\t\t\tbreak;\n\t\tcase ARCHIVE_EOF:\n\t\t\tend_of_data = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tzip->pack_stream_inbytes_remaining -= bytes_in;\n\t\tif (bytes_out > zip->folder_outbytes_remaining)\n\t\t\tbytes_out = (size_t)zip->folder_outbytes_remaining;\n\t\tzip->folder_outbytes_remaining -= bytes_out;\n\t\tzip->uncompressed_buffer_bytes_remaining += bytes_out;\n\t\tzip->pack_stream_bytes_unconsumed = bytes_in;\n\n\t\t/*\n\t\t * Continue decompression until uncompressed_buffer is full.\n\t\t */\n\t\tif (zip->uncompressed_buffer_bytes_remaining ==\n\t\t    zip->uncompressed_buffer_size)\n\t\t\tbreak;\n\t\tif (zip->codec2 == _7Z_X86 && zip->odd_bcj_size &&\n\t\t    zip->uncompressed_buffer_bytes_remaining + 5 >\n\t\t    zip->uncompressed_buffer_size)\n\t\t\tbreak;\n\t\tif (zip->pack_stream_inbytes_remaining == 0 &&\n\t\t    zip->folder_outbytes_remaining == 0)\n\t\t\tbreak;\n\t\tif (end_of_data || (bytes_in == 0 && bytes_out == 0)) {\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tread_consume(a);\n\t}\n\tif (zip->uncompressed_buffer_bytes_remaining < minimum) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->uncompressed_buffer_pointer = zip->uncompressed_buffer;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nseek_pack(struct archive_read *a)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tint64_t pack_offset;\n\n\tif (zip->pack_stream_remaining <= 0) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->pack_stream_inbytes_remaining =\n\t    zip->si.pi.sizes[zip->pack_stream_index];\n\tpack_offset = zip->si.pi.positions[zip->pack_stream_index];\n\tif (zip->stream_offset != pack_offset) {\n\t\tif (0 > __archive_read_seek(a, pack_offset + zip->seek_base,\n\t\t    SEEK_SET))\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tzip->stream_offset = pack_offset;\n\t}\n\tzip->pack_stream_index++;\n\tzip->pack_stream_remaining--;\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nread_stream(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tuint64_t skip_bytes = 0;\n\tssize_t r;\n\n\tif (zip->uncompressed_buffer_bytes_remaining == 0) {\n\t\tif (zip->pack_stream_inbytes_remaining > 0) {\n\t\t\tr = extract_pack_stream(a, 0);\n\t\t\tif (r < 0)\n\t\t\t\treturn (r);\n\t\t\treturn (get_uncompressed_data(a, buff, size, minimum));\n\t\t} else if (zip->folder_outbytes_remaining > 0) {\n\t\t\t/* Extract a remaining pack stream. */\n\t\t\tr = extract_pack_stream(a, 0);\n\t\t\tif (r < 0)\n\t\t\t\treturn (r);\n\t\t\treturn (get_uncompressed_data(a, buff, size, minimum));\n\t\t}\n\t} else\n\t\treturn (get_uncompressed_data(a, buff, size, minimum));\n\n\t/*\n\t * Current pack stream has been consumed.\n\t */\n\tif (zip->pack_stream_remaining == 0) {\n\t\tif (zip->header_is_being_read) {\n\t\t\t/* Invalid sequence. This might happen when\n\t\t\t * reading a malformed archive. */\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC, \"Malformed 7-Zip archive\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/*\n\t\t * All current folder's pack streams have been\n\t\t * consumed. Switch to next folder.\n\t\t */\n\t\tif (zip->folder_index == 0 &&\n\t\t    (zip->si.ci.folders[zip->entry->folderIndex].skipped_bytes\n\t\t     || zip->folder_index != zip->entry->folderIndex)) {\n\t\t\tzip->folder_index = zip->entry->folderIndex;\n\t\t\tskip_bytes =\n\t\t\t    zip->si.ci.folders[zip->folder_index].skipped_bytes;\n\t\t}\n\n\t\tif (zip->folder_index >= zip->si.ci.numFolders) {\n\t\t\t/*\n\t\t\t * We have consumed all folders and its pack streams.\n\t\t\t */\n\t\t\t*buff = NULL;\n\t\t\treturn (0);\n\t\t}\n\t\tr = setup_decode_folder(a,\n\t\t\t&(zip->si.ci.folders[zip->folder_index]), 0);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\n\t\tzip->folder_index++;\n\t}\n\n\t/*\n\t * Switch to next pack stream.\n\t */\n\tr = seek_pack(a);\n\tif (r < 0)\n\t\treturn (r);\n\n\t/* Extract a new pack stream. */\n\tr = extract_pack_stream(a, 0);\n\tif (r < 0)\n\t\treturn (r);\n\n\t/*\n\t * Skip the bytes we alrady has skipped in skip_stream().\n\t */\n\twhile (skip_bytes) {\n\t\tssize_t skipped;\n\n\t\tif (zip->uncompressed_buffer_bytes_remaining == 0) {\n\t\t\tif (zip->pack_stream_inbytes_remaining > 0) {\n\t\t\t\tr = extract_pack_stream(a, 0);\n\t\t\t\tif (r < 0)\n\t\t\t\t\treturn (r);\n\t\t\t} else if (zip->folder_outbytes_remaining > 0) {\n\t\t\t\t/* Extract a remaining pack stream. */\n\t\t\t\tr = extract_pack_stream(a, 0);\n\t\t\t\tif (r < 0)\n\t\t\t\t\treturn (r);\n\t\t\t} else {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tskipped = get_uncompressed_data(\n\t\t\ta, buff, (size_t)skip_bytes, 0);\n\t\tif (skipped < 0)\n\t\t\treturn (skipped);\n\t\tskip_bytes -= skipped;\n\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\tread_consume(a);\n\t}\n\n\treturn (get_uncompressed_data(a, buff, size, minimum));\n}\n\nstatic int\nsetup_decode_folder(struct archive_read *a, struct _7z_folder *folder,\n    int header)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst struct _7z_coder *coder1, *coder2;\n\tconst char *cname = (header)?\"archive header\":\"file content\";\n\tunsigned i;\n\tint r, found_bcj2 = 0;\n\n\t/*\n\t * Release the memory which the previous folder used for BCJ2.\n\t */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (zip->sub_stream_buff[i] != NULL)\n\t\t\tfree(zip->sub_stream_buff[i]);\n\t\tzip->sub_stream_buff[i] = NULL;\n\t}\n\n\t/*\n\t * Initialize a stream reader.\n\t */\n\tzip->pack_stream_remaining = (unsigned)folder->numPackedStreams;\n\tzip->pack_stream_index = (unsigned)folder->packIndex;\n\tzip->folder_outbytes_remaining = folder_uncompressed_size(folder);\n\tzip->uncompressed_buffer_bytes_remaining = 0;\n\n\t/*\n\t * Check coder types.\n\t */\n\tfor (i = 0; i < folder->numCoders; i++) {\n\t\tswitch(folder->coders[i].codec) {\n\t\t\tcase _7Z_CRYPTO_MAIN_ZIP:\n\t\t\tcase _7Z_CRYPTO_RAR_29:\n\t\t\tcase _7Z_CRYPTO_AES_256_SHA_256: {\n\t\t\t\t/* For entry that is associated with this folder, mark\n\t\t\t\t   it as encrypted (data+metadata). */\n\t\t\t\tzip->has_encrypted_entries = 1;\n\t\t\t\tif (a->entry) {\n\t\t\t\t\tarchive_entry_set_is_data_encrypted(a->entry, 1);\n\t\t\t\t\tarchive_entry_set_is_metadata_encrypted(a->entry, 1);\n\t\t\t\t}\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t\tARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\"The %s is encrypted, \"\n\t\t\t\t\t\"but currently not supported\", cname);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tcase _7Z_X86_BCJ2: {\n\t\t\t\tfound_bcj2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* Now that we've checked for encryption, if there were still no\n\t * encrypted entries found we can say for sure that there are none.\n\t */\n\tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t\tzip->has_encrypted_entries = 0;\n\t}\n\n\tif ((folder->numCoders > 2 && !found_bcj2) || found_bcj2 > 1) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC,\n\t\t    \"The %s is encoded with many filters, \"\n\t\t    \"but currently not supported\", cname);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tcoder1 = &(folder->coders[0]);\n\tif (folder->numCoders == 2)\n\t\tcoder2 = &(folder->coders[1]);\n\telse\n\t\tcoder2 = NULL;\n\n\tif (found_bcj2) {\n\t\t/*\n\t\t * Preparation to decode BCJ2.\n\t\t * Decoding BCJ2 requires four sources. Those are at least,\n\t\t * as far as I know, two types of the storage form.\n\t\t */\n\t\tconst struct _7z_coder *fc = folder->coders;\n\t\tstatic const struct _7z_coder coder_copy = {0, 1, 1, 0, NULL};\n\t\tconst struct _7z_coder *scoder[3] =\n\t\t\t{&coder_copy, &coder_copy, &coder_copy};\n\t\tconst void *buff;\n\t\tssize_t bytes;\n\t\tunsigned char *b[3] = {NULL, NULL, NULL};\n\t\tuint64_t sunpack[3] ={-1, -1, -1};\n\t\tsize_t s[3] = {0, 0, 0};\n\t\tint idx[3] = {0, 1, 2};\n\n\t\tif (folder->numCoders == 4 && fc[3].codec == _7Z_X86_BCJ2 &&\n\t\t    folder->numInStreams == 7 && folder->numOutStreams == 4 &&\n\t\t    zip->pack_stream_remaining == 4) {\n\t\t\t/* Source type 1 made by 7zr or 7z with -m options. */\n\t\t\tif (folder->bindPairs[0].inIndex == 5) {\n\t\t\t\t/* The form made by 7zr */\n\t\t\t\tidx[0] = 1; idx[1] = 2; idx[2] = 0;\n\t\t\t\tscoder[1] = &(fc[1]);\n\t\t\t\tscoder[2] = &(fc[0]);\n\t\t\t\tsunpack[1] = folder->unPackSize[1];\n\t\t\t\tsunpack[2] = folder->unPackSize[0];\n\t\t\t\tcoder1 = &(fc[2]);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * NOTE: Some patterns do not work.\n\t\t\t\t * work:\n\t\t\t\t *  7z a -m0=BCJ2 -m1=COPY -m2=COPY\n\t\t\t\t *       -m3=(any)\n\t\t\t\t *  7z a -m0=BCJ2 -m1=COPY -m2=(any)\n\t\t\t\t *       -m3=COPY\n\t\t\t\t *  7z a -m0=BCJ2 -m1=(any) -m2=COPY\n\t\t\t\t *       -m3=COPY\n\t\t\t\t * not work:\n\t\t\t\t *  other patterns.\n\t\t\t\t *\n\t\t\t\t * We have to handle this like `pipe' or\n\t\t\t\t * our libarchive7s filter frame work,\n\t\t\t\t * decoding the BCJ2 main stream sequentially,\n\t\t\t\t * m3 -> m2 -> m1 -> BCJ2.\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (fc[0].codec == _7Z_COPY &&\n\t\t\t\t    fc[1].codec == _7Z_COPY)\n\t\t\t\t\tcoder1 = &(folder->coders[2]);\n\t\t\t\telse if (fc[0].codec == _7Z_COPY &&\n\t\t\t\t    fc[2].codec == _7Z_COPY)\n\t\t\t\t\tcoder1 = &(folder->coders[1]);\n\t\t\t\telse if (fc[1].codec == _7Z_COPY &&\n\t\t\t\t    fc[2].codec == _7Z_COPY)\n\t\t\t\t\tcoder1 = &(folder->coders[0]);\n\t\t\t\telse {\n\t\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t    \"Unsupported form of \"\n\t\t\t\t\t    \"BCJ2 streams\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcoder2 = &(fc[3]);\n\t\t\tzip->main_stream_bytes_remaining =\n\t\t\t\t(size_t)folder->unPackSize[2];\n\t\t} else if (coder2 != NULL && coder2->codec == _7Z_X86_BCJ2 &&\n\t\t    zip->pack_stream_remaining == 4 &&\n\t\t    folder->numInStreams == 5 && folder->numOutStreams == 2) {\n\t\t\t/* Source type 0 made by 7z */\n\t\t\tzip->main_stream_bytes_remaining =\n\t\t\t\t(size_t)folder->unPackSize[0];\n\t\t} else {\n\t\t\t/* We got an unexpected form. */\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported form of BCJ2 streams\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/* Skip the main stream at this time. */\n\t\tif ((r = seek_pack(a)) < 0)\n\t\t\treturn (r);\n\t\tzip->pack_stream_bytes_unconsumed =\n\t\t    (size_t)zip->pack_stream_inbytes_remaining;\n\t\tread_consume(a);\n\n\t\t/* Read following three sub streams. */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tconst struct _7z_coder *coder = scoder[i];\n\n\t\t\tif ((r = seek_pack(a)) < 0) {\n\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\treturn (r);\n\t\t\t}\n\n\t\t\tif (sunpack[i] == (uint64_t)-1)\n\t\t\t\tzip->folder_outbytes_remaining =\n\t\t\t\t    zip->pack_stream_inbytes_remaining;\n\t\t\telse\n\t\t\t\tzip->folder_outbytes_remaining = sunpack[i];\n\n\t\t\tr = init_decompression(a, zip, coder, NULL);\n\t\t\tif (r != ARCHIVE_OK) {\n\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\n\t\t\t/* Allocate memory for the decorded data of a sub\n\t\t\t * stream. */\n\t\t\tb[i] = malloc((size_t)zip->folder_outbytes_remaining);\n\t\t\tif (b[i] == NULL) {\n\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\n\t\t\t/* Extract a sub stream. */\n\t\t\twhile (zip->pack_stream_inbytes_remaining > 0) {\n\t\t\t\tr = (int)extract_pack_stream(a, 0);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\t\treturn (r);\n\t\t\t\t}\n\t\t\t\tbytes = get_uncompressed_data(a, &buff,\n\t\t\t\t    zip->uncompressed_buffer_bytes_remaining,\n\t\t\t\t    0);\n\t\t\t\tif (bytes < 0) {\n\t\t\t\t\tfree(b[0]); free(b[1]); free(b[2]);\n\t\t\t\t\treturn ((int)bytes);\n\t\t\t\t}\n\t\t\t\tmemcpy(b[i]+s[i], buff, bytes);\n\t\t\t\ts[i] += bytes;\n\t\t\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\t\t\tread_consume(a);\n\t\t\t}\n\t\t}\n\n\t\t/* Set the sub streams to the right place. */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tzip->sub_stream_buff[i] = b[idx[i]];\n\t\t\tzip->sub_stream_size[i] = s[idx[i]];\n\t\t\tzip->sub_stream_bytes_remaining[i] = s[idx[i]];\n\t\t}\n\n\t\t/* Allocate memory used for decoded main stream bytes. */\n\t\tif (zip->tmp_stream_buff == NULL) {\n\t\t\tzip->tmp_stream_buff_size = 32 * 1024;\n\t\t\tzip->tmp_stream_buff =\n\t\t\t    malloc(zip->tmp_stream_buff_size);\n\t\t\tif (zip->tmp_stream_buff == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for 7-Zip decompression\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tzip->tmp_stream_bytes_avail = 0;\n\t\tzip->tmp_stream_bytes_remaining = 0;\n\t\tzip->odd_bcj_size = 0;\n\t\tzip->bcj2_outPos = 0;\n\n\t\t/*\n\t\t * Reset a stream reader in order to read the main stream\n\t\t * of BCJ2.\n\t\t */\n\t\tzip->pack_stream_remaining = 1;\n\t\tzip->pack_stream_index = (unsigned)folder->packIndex;\n\t\tzip->folder_outbytes_remaining =\n\t\t    folder_uncompressed_size(folder);\n\t\tzip->uncompressed_buffer_bytes_remaining = 0;\n\t}\n\n\t/*\n\t * Initialize the decompressor for the new folder's pack streams.\n\t */\n\tr = init_decompression(a, zip, coder1, coder2);\n\tif (r != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int64_t\nskip_stream(struct archive_read *a, size_t skip_bytes)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst void *p;\n\tint64_t skipped_bytes;\n\tsize_t bytes = skip_bytes;\n\n\tif (zip->folder_index == 0) {\n\t\t/*\n\t\t * Optimization for a list mode.\n\t\t * Avoid unncecessary decoding operations.\n\t\t */\n\t\tzip->si.ci.folders[zip->entry->folderIndex].skipped_bytes\n\t\t    += skip_bytes;\n\t\treturn (skip_bytes);\n\t}\n\n\twhile (bytes) {\n\t\tskipped_bytes = read_stream(a, &p, bytes, 0);\n\t\tif (skipped_bytes < 0)\n\t\t\treturn (skipped_bytes);\n\t\tif (skipped_bytes == 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file body\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tbytes -= (size_t)skipped_bytes;\n\t\tif (zip->pack_stream_bytes_unconsumed)\n\t\t\tread_consume(a);\n\t}\n\treturn (skip_bytes);\n}\n\n/*\n * Brought from LZMA SDK.\n *\n * Bra86.c -- Converter for x86 code (BCJ)\n * 2008-10-04 : Igor Pavlov : Public domain\n *\n */\n\n#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)\n\nstatic void\nx86_Init(struct _7zip *zip)\n{\n\tzip->bcj_state = 0;\n\tzip->bcj_prevPosT = (size_t)0 - 1;\n\tzip->bcj_prevMask = 0;\n\tzip->bcj_ip = 5;\n}\n\nstatic size_t\nx86_Convert(struct _7zip *zip, uint8_t *data, size_t size)\n{\n\tstatic const uint8_t kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};\n\tstatic const uint8_t kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};\n\tsize_t bufferPos, prevPosT;\n\tuint32_t ip, prevMask;\n\n\tif (size < 5)\n\t\treturn 0;\n\n\tbufferPos = 0;\n\tprevPosT = zip->bcj_prevPosT;\n\tprevMask = zip->bcj_prevMask;\n\tip = zip->bcj_ip;\n\n\tfor (;;) {\n\t\tuint8_t *p = data + bufferPos;\n\t\tuint8_t *limit = data + size - 4;\n\n\t\tfor (; p < limit; p++)\n\t\t\tif ((*p & 0xFE) == 0xE8)\n\t\t\t\tbreak;\n\t\tbufferPos = (size_t)(p - data);\n\t\tif (p >= limit)\n\t\t\tbreak;\n\t\tprevPosT = bufferPos - prevPosT;\n\t\tif (prevPosT > 3)\n\t\t\tprevMask = 0;\n\t\telse {\n\t\t\tprevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;\n\t\t\tif (prevMask != 0) {\n\t\t\t\tunsigned char b =\n\t\t\t\t\tp[4 - kMaskToBitNumber[prevMask]];\n\t\t\t\tif (!kMaskToAllowedStatus[prevMask] ||\n\t\t\t\t    Test86MSByte(b)) {\n\t\t\t\t\tprevPosT = bufferPos;\n\t\t\t\t\tprevMask = ((prevMask << 1) & 0x7) | 1;\n\t\t\t\t\tbufferPos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprevPosT = bufferPos;\n\n\t\tif (Test86MSByte(p[4])) {\n\t\t\tuint32_t src = ((uint32_t)p[4] << 24) |\n\t\t\t\t((uint32_t)p[3] << 16) | ((uint32_t)p[2] << 8) |\n\t\t\t\t((uint32_t)p[1]);\n\t\t\tuint32_t dest;\n\t\t\tfor (;;) {\n\t\t\t\tuint8_t b;\n\t\t\t\tint b_index;\n\n\t\t\t\tdest = src - (ip + (uint32_t)bufferPos);\n\t\t\t\tif (prevMask == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb_index = kMaskToBitNumber[prevMask] * 8;\n\t\t\t\tb = (uint8_t)(dest >> (24 - b_index));\n\t\t\t\tif (!Test86MSByte(b))\n\t\t\t\t\tbreak;\n\t\t\t\tsrc = dest ^ ((1 << (32 - b_index)) - 1);\n\t\t\t}\n\t\t\tp[4] = (uint8_t)(~(((dest >> 24) & 1) - 1));\n\t\t\tp[3] = (uint8_t)(dest >> 16);\n\t\t\tp[2] = (uint8_t)(dest >> 8);\n\t\t\tp[1] = (uint8_t)dest;\n\t\t\tbufferPos += 5;\n\t\t} else {\n\t\t\tprevMask = ((prevMask << 1) & 0x7) | 1;\n\t\t\tbufferPos++;\n\t\t}\n\t}\n\tzip->bcj_prevPosT = prevPosT;\n\tzip->bcj_prevMask = prevMask;\n\tzip->bcj_ip += (uint32_t)bufferPos;\n\treturn (bufferPos);\n}\n\n/*\n * Brought from LZMA SDK.\n *\n * Bcj2.c -- Converter for x86 code (BCJ2)\n * 2008-10-04 : Igor Pavlov : Public domain\n *\n */\n\n#define SZ_ERROR_DATA\t ARCHIVE_FAILED\n\n#define IsJcc(b0, b1) ((b0) == 0x0F && ((b1) & 0xF0) == 0x80)\n#define IsJ(b0, b1) ((b1 & 0xFE) == 0xE8 || IsJcc(b0, b1))\n\n#define kNumTopBits 24\n#define kTopValue ((uint32_t)1 << kNumTopBits)\n\n#define kNumBitModelTotalBits 11\n#define kBitModelTotal (1 << kNumBitModelTotalBits)\n#define kNumMoveBits 5\n\n#define RC_READ_BYTE (*buffer++)\n#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }\n#define RC_INIT2 zip->bcj2_code = 0; zip->bcj2_range = 0xFFFFFFFF; \\\n  { int ii; for (ii = 0; ii < 5; ii++) { RC_TEST; zip->bcj2_code = (zip->bcj2_code << 8) | RC_READ_BYTE; }}\n\n#define NORMALIZE if (zip->bcj2_range < kTopValue) { RC_TEST; zip->bcj2_range <<= 8; zip->bcj2_code = (zip->bcj2_code << 8) | RC_READ_BYTE; }\n\n#define IF_BIT_0(p) ttt = *(p); bound = (zip->bcj2_range >> kNumBitModelTotalBits) * ttt; if (zip->bcj2_code < bound)\n#define UPDATE_0(p) zip->bcj2_range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits)); NORMALIZE;\n#define UPDATE_1(p) zip->bcj2_range -= bound; zip->bcj2_code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;\n\nstatic ssize_t\nBcj2_Decode(struct _7zip *zip, uint8_t *outBuf, size_t outSize)\n{\n\tsize_t inPos = 0, outPos = 0;\n\tconst uint8_t *buf0, *buf1, *buf2, *buf3;\n\tsize_t size0, size1, size2, size3;\n\tconst uint8_t *buffer, *bufferLim;\n\tunsigned int i, j;\n\n\tsize0 = zip->tmp_stream_bytes_remaining;\n\tbuf0 = zip->tmp_stream_buff + zip->tmp_stream_bytes_avail - size0;\n\tsize1 = zip->sub_stream_bytes_remaining[0];\n\tbuf1 = zip->sub_stream_buff[0] + zip->sub_stream_size[0] - size1;\n\tsize2 = zip->sub_stream_bytes_remaining[1];\n\tbuf2 = zip->sub_stream_buff[1] + zip->sub_stream_size[1] - size2;\n\tsize3 = zip->sub_stream_bytes_remaining[2];\n\tbuf3 = zip->sub_stream_buff[2] + zip->sub_stream_size[2] - size3;\n\n\tbuffer = buf3;\n\tbufferLim = buffer + size3;\n\n\tif (zip->bcj_state == 0) {\n\t\t/*\n\t\t * Initialize.\n\t\t */\n\t\tzip->bcj2_prevByte = 0;\n\t\tfor (i = 0;\n\t\t    i < sizeof(zip->bcj2_p) / sizeof(zip->bcj2_p[0]); i++)\n\t\t\tzip->bcj2_p[i] = kBitModelTotal >> 1;\n\t\tRC_INIT2;\n\t\tzip->bcj_state = 1;\n\t}\n\n\t/*\n\t * Gather the odd bytes of a previous call.\n\t */\n\tfor (i = 0; zip->odd_bcj_size > 0 && outPos < outSize; i++) {\n\t\toutBuf[outPos++] = zip->odd_bcj[i];\n\t\tzip->odd_bcj_size--;\n\t}\n\n\tif (outSize == 0) {\n\t\tzip->bcj2_outPos += outPos;\n\t\treturn (outPos);\n\t}\n\n\tfor (;;) {\n\t\tuint8_t b;\n\t\tCProb *prob;\n\t\tuint32_t bound;\n\t\tuint32_t ttt;\n\n\t\tsize_t limit = size0 - inPos;\n\t\tif (outSize - outPos < limit)\n\t\t\tlimit = outSize - outPos;\n\n\t\tif (zip->bcj_state == 1) {\n\t\t\twhile (limit != 0) {\n\t\t\t\tuint8_t bb = buf0[inPos];\n\t\t\t\toutBuf[outPos++] = bb;\n\t\t\t\tif (IsJ(zip->bcj2_prevByte, bb)) {\n\t\t\t\t\tzip->bcj_state = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinPos++;\n\t\t\t\tzip->bcj2_prevByte = bb;\n\t\t\t\tlimit--;\n\t\t\t}\n\t\t}\n\n\t\tif (limit == 0 || outPos == outSize)\n\t\t\tbreak;\n\t\tzip->bcj_state = 1;\n\n\t\tb = buf0[inPos++];\n\n\t\tif (b == 0xE8)\n\t\t\tprob = zip->bcj2_p + zip->bcj2_prevByte;\n\t\telse if (b == 0xE9)\n\t\t\tprob = zip->bcj2_p + 256;\n\t\telse\n\t\t\tprob = zip->bcj2_p + 257;\n\n\t\tIF_BIT_0(prob) {\n\t\t\tUPDATE_0(prob)\n\t\t\tzip->bcj2_prevByte = b;\n\t\t} else {\n\t\t\tuint32_t dest;\n\t\t\tconst uint8_t *v;\n\t\t\tuint8_t out[4];\n\n\t\t\tUPDATE_1(prob)\n\t\t\tif (b == 0xE8) {\n\t\t\t\tv = buf1;\n\t\t\t\tif (size1 < 4)\n\t\t\t\t\treturn SZ_ERROR_DATA;\n\t\t\t\tbuf1 += 4;\n\t\t\t\tsize1 -= 4;\n\t\t\t} else {\n\t\t\t\tv = buf2;\n\t\t\t\tif (size2 < 4)\n\t\t\t\t\treturn SZ_ERROR_DATA;\n\t\t\t\tbuf2 += 4;\n\t\t\t\tsize2 -= 4;\n\t\t\t}\n\t\t\tdest = (((uint32_t)v[0] << 24) |\n\t\t\t    ((uint32_t)v[1] << 16) |\n\t\t\t    ((uint32_t)v[2] << 8) |\n\t\t\t    ((uint32_t)v[3])) -\n\t\t\t    ((uint32_t)zip->bcj2_outPos + (uint32_t)outPos + 4);\n\t\t\tout[0] = (uint8_t)dest;\n\t\t\tout[1] = (uint8_t)(dest >> 8);\n\t\t\tout[2] = (uint8_t)(dest >> 16);\n\t\t\tout[3] = zip->bcj2_prevByte = (uint8_t)(dest >> 24);\n\n\t\t\tfor (i = 0; i < 4 && outPos < outSize; i++)\n\t\t\t\toutBuf[outPos++] = out[i];\n\t\t\tif (i < 4) {\n\t\t\t\t/*\n\t\t\t\t * Save odd bytes which we could not add into\n\t\t\t\t * the output buffer because of out of space.\n\t\t\t\t */\n\t\t\t\tzip->odd_bcj_size = 4 -i;\n\t\t\t\tfor (; i < 4; i++) {\n\t\t\t\t\tj = i - 4 + (unsigned)zip->odd_bcj_size;\n\t\t\t\t\tzip->odd_bcj[j] = out[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tzip->tmp_stream_bytes_remaining -= inPos;\n\tzip->sub_stream_bytes_remaining[0] = size1;\n\tzip->sub_stream_bytes_remaining[1] = size2;\n\tzip->sub_stream_bytes_remaining[2] = bufferLim - buffer;\n\tzip->bcj2_outPos += outPos;\n\n\treturn ((ssize_t)outPos);\n}\n\n"], "filenames": ["libarchive/archive_read_support_format_7zip.c"], "buggy_code_start_loc": [2155], "buggy_code_end_loc": [2155], "fixing_code_start_loc": [2156], "fixing_code_end_loc": [2159], "type": "CWE-190", "message": "Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2016-4300", "sourceIdentifier": "cret@cert.org", "published": "2016-09-21T14:25:01.940", "lastModified": "2017-11-04T01:29:19.677", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n read_SubStreamsInfo en archive_read_support_format_7zip.c en libarchive en versiones anteriores a 3.2.1 permite a atacantes remotos ejecutar c\u00f3digo arbitrario a trav\u00e9s de un archivo 7zip con un gran n\u00famero de subcorrientes, lo que desencadena un desbordamiento de b\u00fafer basado en memoria din\u00e1mica."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.0", "matchCriteriaId": "6A6EFED3-4FD3-413D-85C2-73F746F346E8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "39A901D6-0874-46A4-92A8-5F72C7A89E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D871B-AEA1-4407-AEE3-47EC782250FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://blog.talosintel.com/2016/06/the-poisoned-archives.html", "source": "cret@cert.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1844.html", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3657", "source": "cret@cert.org"}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjul2016-3090568.html", "source": "cret@cert.org"}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "cret@cert.org"}, {"url": "http://www.securityfocus.com/bid/91326", "source": "cret@cert.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.talosintel.com/reports/TALOS-2016-0152/", "source": "cret@cert.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1348439", "source": "cret@cert.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573", "source": "cret@cert.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/issues/718", "source": "cret@cert.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00062&languageid=en-fr", "source": "cret@cert.org"}, {"url": "https://security.gentoo.org/glsa/201701-03", "source": "cret@cert.org"}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573"}}