{"buggy_code": ["package dtls\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pion/logging\"\n)\n\nconst (\n\tinitialTickerInterval = time.Second\n\tcookieLength          = 20\n\tdefaultNamedCurve     = namedCurveX25519\n\tinboundBufferSize     = 8192\n)\n\nvar invalidKeyingLabels = map[string]bool{\n\t\"client finished\": true,\n\t\"server finished\": true,\n\t\"master secret\":   true,\n\t\"key expansion\":   true,\n}\n\ntype handshakeMessageHandler func(*Conn) (*alert, error)\ntype flightHandler func(*Conn) (bool, *alert, error)\n\n// Conn represents a DTLS connection\ntype Conn struct {\n\tlock           sync.RWMutex    // Internal lock (must not be public)\n\tnextConn       net.Conn        // Embedded Conn, typically a udpconn we read/write from\n\tfragmentBuffer *fragmentBuffer // out-of-order and missing fragment handling\n\thandshakeCache *handshakeCache // caching of handshake messages for verifyData generation\n\tdecrypted      chan []byte     // Decrypted Application Data, pull by calling `Read`\n\tworkerTicker   *time.Ticker\n\n\tstate State // Internal state\n\n\tconnectTimeout time.Duration\n\n\tmaximumTransmissionUnit int\n\n\tremoteRequestedCertificate bool // Did we get a CertificateRequest\n\n\tlocalSRTPProtectionProfiles []SRTPProtectionProfile // Available SRTPProtectionProfiles, if empty no SRTP support\n\tlocalCipherSuites           []cipherSuite           // Available CipherSuites, if empty use default list\n\n\tclientAuth           ClientAuthType           // If we are a client should we request a client certificate\n\textendedMasterSecret ExtendedMasterSecretType // Policy for the Extended Master Support extension\n\n\tcurrFlight       *flight\n\tnamedCurve       namedCurve\n\tlocalCertificate *x509.Certificate\n\tlocalPrivateKey  crypto.PrivateKey\n\tlocalKeypair     *namedCurveKeypair\n\tcookie           []byte\n\n\tlocalPSKCallback     PSKCallback\n\tlocalPSKIdentityHint []byte\n\n\tlocalCertificateVerify    []byte // cache CertificateVerify\n\tlocalVerifyData           []byte // cached VerifyData\n\tlocalKeySignature         []byte // cached keySignature\n\tremoteCertificateVerified bool\n\n\tinsecureSkipVerify    bool\n\tverifyPeerCertificate func(cer *x509.Certificate, verified bool) error\n\trootCAs               *x509.CertPool\n\tserverName            string\n\n\thandshakeMessageSequence       int\n\thandshakeMessageHandler        handshakeMessageHandler\n\tflightHandler                  flightHandler\n\thandshakeDoneSignal            *Closer\n\thandshakeCompletedSuccessfully atomic.Value\n\n\tconnErr atomic.Value\n\tlog     logging.LeveledLogger\n}\n\nfunc createConn(nextConn net.Conn, flightHandler flightHandler, handshakeMessageHandler handshakeMessageHandler, config *Config, isClient bool) (*Conn, error) {\n\tswitch {\n\tcase config == nil:\n\t\treturn nil, errNoConfigProvided\n\tcase nextConn == nil:\n\t\treturn nil, errNilNextConn\n\tcase config.Certificate != nil && config.PSK != nil:\n\t\treturn nil, errPSKAndCertificate\n\tcase config.PSKIdentityHint != nil && config.PSK == nil:\n\t\treturn nil, errIdentityNoPSK\n\t}\n\n\tif config.PrivateKey != nil {\n\t\tif _, ok := config.PrivateKey.(*ecdsa.PrivateKey); !ok {\n\t\t\treturn nil, errInvalidPrivateKey\n\t\t}\n\t}\n\n\tcipherSuites, err := parseCipherSuites(config.CipherSuites, config.PSK == nil, config.PSK != nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tworkerInterval := initialTickerInterval\n\tif config.FlightInterval != 0 {\n\t\tworkerInterval = config.FlightInterval\n\t}\n\n\tloggerFactory := config.LoggerFactory\n\tif loggerFactory == nil {\n\t\tloggerFactory = logging.NewDefaultLoggerFactory()\n\t}\n\n\tlogger := loggerFactory.NewLogger(\"dtls\")\n\n\tconnectTimeout := defaultConnectTimeout\n\tif config.ConnectTimeout != nil {\n\t\tconnectTimeout = *config.ConnectTimeout\n\t}\n\n\tif connectTimeout <= 0 {\n\t\tconnectTimeout = math.MaxInt64 * time.Nanosecond\n\t}\n\n\tmtu := config.MTU\n\tif mtu <= 0 {\n\t\tmtu = defaultMTU\n\t}\n\n\thandshakeDoneSignal := NewCloser()\n\n\tc := &Conn{\n\t\tnextConn:                    nextConn,\n\t\tcurrFlight:                  newFlight(isClient, logger),\n\t\tfragmentBuffer:              newFragmentBuffer(),\n\t\thandshakeCache:              newHandshakeCache(),\n\t\thandshakeMessageHandler:     handshakeMessageHandler,\n\t\tflightHandler:               flightHandler,\n\t\tconnectTimeout:              connectTimeout,\n\t\tmaximumTransmissionUnit:     mtu,\n\t\tlocalCertificate:            config.Certificate,\n\t\tlocalPrivateKey:             config.PrivateKey,\n\t\tclientAuth:                  config.ClientAuth,\n\t\textendedMasterSecret:        config.ExtendedMasterSecret,\n\t\tinsecureSkipVerify:          config.InsecureSkipVerify,\n\t\tverifyPeerCertificate:       config.VerifyPeerCertificate,\n\t\trootCAs:                     config.RootCAs,\n\t\tserverName:                  config.ServerName,\n\t\tlocalSRTPProtectionProfiles: config.SRTPProtectionProfiles,\n\t\tlocalCipherSuites:           cipherSuites,\n\t\tnamedCurve:                  defaultNamedCurve,\n\n\t\tlocalPSKCallback:     config.PSK,\n\t\tlocalPSKIdentityHint: config.PSKIdentityHint,\n\n\t\tdecrypted:           make(chan []byte),\n\t\tworkerTicker:        time.NewTicker(workerInterval),\n\t\thandshakeDoneSignal: handshakeDoneSignal,\n\t\tlog:                 logger,\n\t}\n\n\t// Use host from conn address when serverName is not provided\n\tif isClient && c.serverName == \"\" && nextConn.RemoteAddr() != nil {\n\t\tremoteAddr := nextConn.RemoteAddr().String()\n\t\tvar host string\n\t\thost, _, err = net.SplitHostPort(remoteAddr)\n\t\tif err != nil {\n\t\t\tc.serverName = remoteAddr\n\t\t}\n\t\tc.serverName = host\n\t}\n\n\tvar zeroEpoch uint16\n\tc.state.localEpoch.Store(zeroEpoch)\n\tc.state.remoteEpoch.Store(zeroEpoch)\n\tc.state.isClient = isClient\n\n\tif err = c.state.localRandom.populate(); err != nil {\n\t\treturn nil, err\n\t}\n\tif !isClient {\n\t\tc.cookie = make([]byte, cookieLength)\n\t\tif _, err = rand.Read(c.cookie); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Trigger outbound\n\tc.startHandshakeOutbound()\n\n\t// Handle inbound\n\tgo c.inboundLoop()\n\n\tselect {\n\tcase <-c.handshakeDoneSignal.Done():\n\t\terr = c.getConnErr()\n\tcase <-time.After(c.connectTimeout):\n\t\terr = errConnectTimeout\n\t\tc.handshakeDoneSignal.Close()\n\t}\n\n\tif err == nil {\n\t\tc.setHandshakeCompletedSuccessfully()\n\t}\n\n\tc.log.Trace(fmt.Sprintf(\"Handshake Completed (Error: %v)\", err))\n\n\treturn c, err\n}\n\n// Dial connects to the given network address and establishes a DTLS connection on top\nfunc Dial(network string, raddr *net.UDPAddr, config *Config) (*Conn, error) {\n\tpConn, err := net.DialUDP(network, nil, raddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn Client(pConn, config)\n}\n\n// Client establishes a DTLS connection over an existing conn\nfunc Client(conn net.Conn, config *Config) (*Conn, error) {\n\tswitch {\n\tcase config == nil:\n\t\treturn nil, errNoConfigProvided\n\tcase config.PSK != nil && config.PSKIdentityHint == nil:\n\t\treturn nil, errPSKAndIdentityMustBeSetForClient\n\t}\n\n\treturn createConn(conn, clientFlightHandler, clientHandshakeHandler, config, true)\n}\n\n// Server listens for incoming DTLS connections\nfunc Server(conn net.Conn, config *Config) (*Conn, error) {\n\tswitch {\n\tcase config == nil:\n\t\treturn nil, errNoConfigProvided\n\tcase config.PSK == nil && config.Certificate == nil:\n\t\treturn nil, errServerMustHaveCertificate\n\t}\n\n\treturn createConn(conn, serverFlightHandler, serverHandshakeHandler, config, false)\n}\n\n// Read reads data from the connection.\nfunc (c *Conn) Read(p []byte) (n int, err error) {\n\tout, ok := <-c.decrypted\n\tif !ok {\n\t\treturn 0, c.getConnErr()\n\t}\n\tif len(p) < len(out) {\n\t\treturn 0, errBufferTooSmall\n\t}\n\n\tcopy(p, out)\n\treturn len(out), nil\n}\n\n// Write writes len(p) bytes from p to the DTLS connection\nfunc (c *Conn) Write(p []byte) (int, error) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif c.getLocalEpoch() == 0 {\n\t\treturn 0, errHandshakeInProgress\n\t} else if c.getConnErr() != nil {\n\t\treturn 0, c.getConnErr()\n\t}\n\n\tc.internalSend(&recordLayer{\n\t\trecordLayerHeader: recordLayerHeader{\n\t\t\tepoch:           c.getLocalEpoch(),\n\t\t\tprotocolVersion: protocolVersion1_2,\n\t\t},\n\t\tcontent: &applicationData{\n\t\t\tdata: p,\n\t\t},\n\t}, true)\n\n\treturn len(p), nil\n}\n\n// Close closes the connection.\nfunc (c *Conn) Close() error {\n\tc.notify(alertLevelFatal, alertCloseNotify)\n\tc.stopWithError(ErrConnClosed)\n\tif err := c.getConnErr(); err != ErrConnClosed {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// RemoteCertificate exposes the remote certificate\nfunc (c *Conn) RemoteCertificate() *x509.Certificate {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\treturn c.state.remoteCertificate\n}\n\n// SelectedSRTPProtectionProfile returns the selected SRTPProtectionProfile\nfunc (c *Conn) SelectedSRTPProtectionProfile() (SRTPProtectionProfile, bool) {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\n\tif c.state.srtpProtectionProfile == 0 {\n\t\treturn 0, false\n\t}\n\n\treturn c.state.srtpProtectionProfile, true\n}\n\n// ExportKeyingMaterial from https://tools.ietf.org/html/rfc5705\n// This allows protocols to use DTLS for key establishment, but\n// then use some of the keying material for their own purposes\nfunc (c *Conn) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif c.getLocalEpoch() == 0 {\n\t\treturn nil, errHandshakeInProgress\n\t} else if len(context) != 0 {\n\t\treturn nil, errContextUnsupported\n\t} else if _, ok := invalidKeyingLabels[label]; ok {\n\t\treturn nil, errReservedExportKeyingMaterial\n\t}\n\n\tlocalRandom, err := c.state.localRandom.Marshal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tremoteRandom, err := c.state.remoteRandom.Marshal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tseed := []byte(label)\n\tif c.state.isClient {\n\t\tseed = append(append(seed, localRandom...), remoteRandom...)\n\t} else {\n\t\tseed = append(append(seed, remoteRandom...), localRandom...)\n\t}\n\treturn prfPHash(c.state.masterSecret, seed, length, c.state.cipherSuite.hashFunc())\n}\n\nfunc (c *Conn) internalSend(record *recordLayer, shouldEncrypt bool) {\n\tvar packets [][]byte\n\n\tif h, ok := record.content.(*handshake); ok {\n\t\thandshakeRaw, err := record.Marshal()\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tc.log.Tracef(\"[handshake] -> %s\", h.handshakeHeader.handshakeType.String())\n\t\tc.handshakeCache.push(handshakeRaw[recordLayerHeaderSize:], h.handshakeHeader.messageSequence, h.handshakeHeader.handshakeType, c.state.isClient)\n\n\t\thandshakeFragments, err := c.fragmentHandshake(h)\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tfor _, handshakeFragment := range handshakeFragments {\n\t\t\trecordLayerHeader := &recordLayerHeader{\n\t\t\t\tcontentType:     record.recordLayerHeader.contentType,\n\t\t\t\tcontentLen:      uint16(len(handshakeFragment)),\n\t\t\t\tprotocolVersion: record.recordLayerHeader.protocolVersion,\n\t\t\t\tepoch:           record.recordLayerHeader.epoch,\n\t\t\t\tsequenceNumber:  atomic.LoadUint64(&c.state.localSequenceNumber),\n\t\t\t}\n\n\t\t\tatomic.AddUint64(&c.state.localSequenceNumber, 1)\n\n\t\t\trecordLayerHeaderBytes, err := recordLayerHeader.Marshal()\n\t\t\tif err != nil {\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpacket := append(recordLayerHeaderBytes, handshakeFragment...)\n\t\t\tpackets = append(packets, packet)\n\t\t}\n\t} else {\n\t\trecord.recordLayerHeader.sequenceNumber = atomic.LoadUint64(&c.state.localSequenceNumber)\n\t\tatomic.AddUint64(&c.state.localSequenceNumber, 1)\n\n\t\tpacket, err := record.Marshal()\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tpackets = [][]byte{packet}\n\t}\n\n\tfor _, packet := range packets {\n\t\tif shouldEncrypt {\n\t\t\tvar err error\n\t\t\tpacket, err = c.state.cipherSuite.encrypt(record, packet)\n\t\t\tif err != nil {\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif _, err := c.nextConn.Write(packet); err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (c *Conn) fragmentHandshake(h *handshake) ([][]byte, error) {\n\tcontent, err := h.handshakeMessage.Marshal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfragmentedHandshakes := make([][]byte, 0)\n\n\tcontentFragments := splitBytes(content, c.maximumTransmissionUnit)\n\tif len(contentFragments) == 0 {\n\t\tcontentFragments = [][]byte{\n\t\t\t{},\n\t\t}\n\t}\n\n\toffset := 0\n\tfor _, contentFragment := range contentFragments {\n\t\tcontentFragmentLen := len(contentFragment)\n\n\t\thandshakeHeaderFragment := &handshakeHeader{\n\t\t\thandshakeType:   h.handshakeHeader.handshakeType,\n\t\t\tlength:          h.handshakeHeader.length,\n\t\t\tmessageSequence: h.handshakeHeader.messageSequence,\n\t\t\tfragmentOffset:  uint32(offset),\n\t\t\tfragmentLength:  uint32(contentFragmentLen),\n\t\t}\n\n\t\toffset += contentFragmentLen\n\n\t\thandshakeHeaderFragmentRaw, err := handshakeHeaderFragment.Marshal()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfragmentedHandshake := append(handshakeHeaderFragmentRaw, contentFragment...)\n\t\tfragmentedHandshakes = append(fragmentedHandshakes, fragmentedHandshake)\n\t}\n\n\treturn fragmentedHandshakes, nil\n}\n\nfunc (c *Conn) inboundLoop() {\n\tdefer func() {\n\t\tclose(c.decrypted)\n\t}()\n\n\tb := make([]byte, inboundBufferSize)\n\tfor {\n\t\ti, err := c.nextConn.Read(b)\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t} else if c.getConnErr() != nil {\n\t\t\treturn\n\t\t}\n\n\t\tpkts, err := unpackDatagram(b[:i])\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tfor _, p := range pkts {\n\t\t\talert, err := c.handleIncomingPacket(p)\n\t\t\tif alert != nil {\n\t\t\t\tc.notify(alert.alertLevel, alert.alertDescription)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Conn) handleIncomingPacket(buf []byte) (*alert, error) {\n\t// TODO: avoid separate unmarshal\n\th := &recordLayerHeader{}\n\tif err := h.Unmarshal(buf); err != nil {\n\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t}\n\n\tif h.epoch < c.getRemoteEpoch() {\n\t\tif _, alertPtr, err := c.flightHandler(c); err != nil {\n\t\t\treturn alertPtr, err\n\t\t}\n\t}\n\n\tif h.epoch != 0 {\n\t\tif c.state.cipherSuite == nil || !c.state.cipherSuite.isInitialized() {\n\t\t\tc.log.Debug(\"handleIncoming: Handshake not finished, dropping packet\")\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tvar err error\n\t\tbuf, err = c.state.cipherSuite.decrypt(buf)\n\t\tif err != nil {\n\t\t\tc.log.Debugf(\"decrypt failed: %s\", err)\n\t\t\treturn nil, nil\n\t\t}\n\t}\n\n\tisHandshake, err := c.fragmentBuffer.push(append([]byte{}, buf...))\n\tif err != nil {\n\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t} else if isHandshake {\n\t\tnewHandshakeMessage := false\n\t\tfor out := c.fragmentBuffer.pop(); out != nil; out = c.fragmentBuffer.pop() {\n\t\t\trawHandshake := &handshake{}\n\t\t\tif err := rawHandshake.Unmarshal(out); err != nil {\n\t\t\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t\t\t}\n\n\t\t\tif c.handshakeCache.push(out, rawHandshake.handshakeHeader.messageSequence, rawHandshake.handshakeHeader.handshakeType, !c.state.isClient) {\n\t\t\t\tnewHandshakeMessage = true\n\t\t\t}\n\t\t}\n\t\tif !newHandshakeMessage {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tc.lock.Lock()\n\t\tdefer c.lock.Unlock()\n\t\treturn c.handshakeMessageHandler(c)\n\t}\n\n\tr := &recordLayer{}\n\tif err := r.Unmarshal(buf); err != nil {\n\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t}\n\n\tswitch content := r.content.(type) {\n\tcase *alert:\n\t\tc.log.Tracef(\"<- %s\", content.String())\n\t\tif content.alertDescription == alertCloseNotify {\n\t\t\treturn nil, c.Close()\n\t\t}\n\t\treturn nil, fmt.Errorf(\"alert: %v\", content)\n\tcase *changeCipherSpec:\n\t\tc.log.Trace(\"<- ChangeCipherSpec\")\n\t\tc.setRemoteEpoch(c.getRemoteEpoch() + 1)\n\tcase *applicationData:\n\t\tc.decrypted <- content.data\n\tdefault:\n\t\treturn &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf(\"unhandled contentType %d\", content.contentType())\n\t}\n\treturn nil, nil\n}\n\nfunc (c *Conn) notify(level alertLevel, desc alertDescription) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.internalSend(&recordLayer{\n\t\trecordLayerHeader: recordLayerHeader{\n\t\t\tepoch:           c.getLocalEpoch(),\n\t\t\tprotocolVersion: protocolVersion1_2,\n\t\t},\n\t\tcontent: &alert{\n\t\t\talertLevel:       level,\n\t\t\talertDescription: desc,\n\t\t},\n\t}, c.isHandshakeCompletedSuccessfully())\n}\n\nfunc (c *Conn) setHandshakeCompletedSuccessfully() {\n\tc.handshakeCompletedSuccessfully.Store(struct{ bool }{true})\n}\n\nfunc (c *Conn) isHandshakeCompletedSuccessfully() bool {\n\tboolean, _ := c.handshakeCompletedSuccessfully.Load().(struct{ bool })\n\treturn boolean.bool\n}\n\nfunc (c *Conn) startHandshakeOutbound() {\n\tgo func() {\n\t\tfor {\n\t\t\tvar (\n\t\t\t\tisFinished bool\n\t\t\t\talertPtr   *alert\n\t\t\t\terr        error\n\t\t\t)\n\t\t\tselect {\n\t\t\tcase <-c.handshakeDoneSignal.Done():\n\t\t\t\treturn\n\t\t\tcase <-c.workerTicker.C:\n\t\t\t\tisFinished, alertPtr, err = c.flightHandler(c)\n\t\t\tcase <-c.currFlight.workerTrigger:\n\t\t\t\tisFinished, alertPtr, err = c.flightHandler(c)\n\t\t\t}\n\n\t\t\tif alertPtr != nil {\n\t\t\t\tc.notify(alertPtr.alertLevel, alertPtr.alertDescription)\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase err != nil:\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\tcase c.getConnErr() != nil:\n\t\t\t\treturn\n\t\t\tcase isFinished:\n\t\t\t\treturn // Handshake is complete\n\t\t\t}\n\t\t}\n\t}()\n\tc.currFlight.workerTrigger <- struct{}{}\n}\n\nfunc (c *Conn) stopWithError(err error) {\n\tif connErr := c.nextConn.Close(); connErr != nil {\n\t\tif err != ErrConnClosed {\n\t\t\tconnErr = fmt.Errorf(\"%v\\n%v\", err, connErr)\n\t\t}\n\t\terr = connErr\n\t}\n\n\tc.connErr.Store(struct{ error }{err})\n\n\tc.workerTicker.Stop()\n\n\tc.handshakeDoneSignal.Close()\n}\n\nfunc (c *Conn) getConnErr() error {\n\terr, _ := c.connErr.Load().(struct{ error })\n\treturn err.error\n}\n\nfunc (c *Conn) setLocalEpoch(epoch uint16) {\n\tc.state.localEpoch.Store(epoch)\n}\n\nfunc (c *Conn) getLocalEpoch() uint16 {\n\treturn c.state.localEpoch.Load().(uint16)\n}\n\nfunc (c *Conn) setRemoteEpoch(epoch uint16) {\n\tc.state.remoteEpoch.Store(epoch)\n}\n\nfunc (c *Conn) getRemoteEpoch() uint16 {\n\treturn c.state.remoteEpoch.Load().(uint16)\n}\n\n// LocalAddr is a stub\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.nextConn.LocalAddr()\n}\n\n// RemoteAddr is a stub\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.nextConn.RemoteAddr()\n}\n\n// SetDeadline is a stub\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\treturn c.nextConn.SetDeadline(t)\n}\n\n// SetReadDeadline is a stub\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.nextConn.SetReadDeadline(t)\n}\n\n// SetWriteDeadline is a stub\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.nextConn.SetWriteDeadline(t)\n}\n"], "fixing_code": ["package dtls\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pion/logging\"\n)\n\nconst (\n\tinitialTickerInterval = time.Second\n\tcookieLength          = 20\n\tdefaultNamedCurve     = namedCurveX25519\n\tinboundBufferSize     = 8192\n)\n\nvar invalidKeyingLabels = map[string]bool{\n\t\"client finished\": true,\n\t\"server finished\": true,\n\t\"master secret\":   true,\n\t\"key expansion\":   true,\n}\n\ntype handshakeMessageHandler func(*Conn) (*alert, error)\ntype flightHandler func(*Conn) (bool, *alert, error)\n\n// Conn represents a DTLS connection\ntype Conn struct {\n\tlock           sync.RWMutex    // Internal lock (must not be public)\n\tnextConn       net.Conn        // Embedded Conn, typically a udpconn we read/write from\n\tfragmentBuffer *fragmentBuffer // out-of-order and missing fragment handling\n\thandshakeCache *handshakeCache // caching of handshake messages for verifyData generation\n\tdecrypted      chan []byte     // Decrypted Application Data, pull by calling `Read`\n\tworkerTicker   *time.Ticker\n\n\tstate State // Internal state\n\n\tconnectTimeout time.Duration\n\n\tmaximumTransmissionUnit int\n\n\tremoteRequestedCertificate bool // Did we get a CertificateRequest\n\n\tlocalSRTPProtectionProfiles []SRTPProtectionProfile // Available SRTPProtectionProfiles, if empty no SRTP support\n\tlocalCipherSuites           []cipherSuite           // Available CipherSuites, if empty use default list\n\n\tclientAuth           ClientAuthType           // If we are a client should we request a client certificate\n\textendedMasterSecret ExtendedMasterSecretType // Policy for the Extended Master Support extension\n\n\tcurrFlight       *flight\n\tnamedCurve       namedCurve\n\tlocalCertificate *x509.Certificate\n\tlocalPrivateKey  crypto.PrivateKey\n\tlocalKeypair     *namedCurveKeypair\n\tcookie           []byte\n\n\tlocalPSKCallback     PSKCallback\n\tlocalPSKIdentityHint []byte\n\n\tlocalCertificateVerify    []byte // cache CertificateVerify\n\tlocalVerifyData           []byte // cached VerifyData\n\tlocalKeySignature         []byte // cached keySignature\n\tremoteCertificateVerified bool\n\n\tinsecureSkipVerify    bool\n\tverifyPeerCertificate func(cer *x509.Certificate, verified bool) error\n\trootCAs               *x509.CertPool\n\tserverName            string\n\n\thandshakeMessageSequence       int\n\thandshakeMessageHandler        handshakeMessageHandler\n\tflightHandler                  flightHandler\n\thandshakeDoneSignal            *Closer\n\thandshakeCompletedSuccessfully atomic.Value\n\n\tconnErr atomic.Value\n\tlog     logging.LeveledLogger\n}\n\nfunc createConn(nextConn net.Conn, flightHandler flightHandler, handshakeMessageHandler handshakeMessageHandler, config *Config, isClient bool) (*Conn, error) {\n\tswitch {\n\tcase config == nil:\n\t\treturn nil, errNoConfigProvided\n\tcase nextConn == nil:\n\t\treturn nil, errNilNextConn\n\tcase config.Certificate != nil && config.PSK != nil:\n\t\treturn nil, errPSKAndCertificate\n\tcase config.PSKIdentityHint != nil && config.PSK == nil:\n\t\treturn nil, errIdentityNoPSK\n\t}\n\n\tif config.PrivateKey != nil {\n\t\tif _, ok := config.PrivateKey.(*ecdsa.PrivateKey); !ok {\n\t\t\treturn nil, errInvalidPrivateKey\n\t\t}\n\t}\n\n\tcipherSuites, err := parseCipherSuites(config.CipherSuites, config.PSK == nil, config.PSK != nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tworkerInterval := initialTickerInterval\n\tif config.FlightInterval != 0 {\n\t\tworkerInterval = config.FlightInterval\n\t}\n\n\tloggerFactory := config.LoggerFactory\n\tif loggerFactory == nil {\n\t\tloggerFactory = logging.NewDefaultLoggerFactory()\n\t}\n\n\tlogger := loggerFactory.NewLogger(\"dtls\")\n\n\tconnectTimeout := defaultConnectTimeout\n\tif config.ConnectTimeout != nil {\n\t\tconnectTimeout = *config.ConnectTimeout\n\t}\n\n\tif connectTimeout <= 0 {\n\t\tconnectTimeout = math.MaxInt64 * time.Nanosecond\n\t}\n\n\tmtu := config.MTU\n\tif mtu <= 0 {\n\t\tmtu = defaultMTU\n\t}\n\n\thandshakeDoneSignal := NewCloser()\n\n\tc := &Conn{\n\t\tnextConn:                    nextConn,\n\t\tcurrFlight:                  newFlight(isClient, logger),\n\t\tfragmentBuffer:              newFragmentBuffer(),\n\t\thandshakeCache:              newHandshakeCache(),\n\t\thandshakeMessageHandler:     handshakeMessageHandler,\n\t\tflightHandler:               flightHandler,\n\t\tconnectTimeout:              connectTimeout,\n\t\tmaximumTransmissionUnit:     mtu,\n\t\tlocalCertificate:            config.Certificate,\n\t\tlocalPrivateKey:             config.PrivateKey,\n\t\tclientAuth:                  config.ClientAuth,\n\t\textendedMasterSecret:        config.ExtendedMasterSecret,\n\t\tinsecureSkipVerify:          config.InsecureSkipVerify,\n\t\tverifyPeerCertificate:       config.VerifyPeerCertificate,\n\t\trootCAs:                     config.RootCAs,\n\t\tserverName:                  config.ServerName,\n\t\tlocalSRTPProtectionProfiles: config.SRTPProtectionProfiles,\n\t\tlocalCipherSuites:           cipherSuites,\n\t\tnamedCurve:                  defaultNamedCurve,\n\n\t\tlocalPSKCallback:     config.PSK,\n\t\tlocalPSKIdentityHint: config.PSKIdentityHint,\n\n\t\tdecrypted:           make(chan []byte),\n\t\tworkerTicker:        time.NewTicker(workerInterval),\n\t\thandshakeDoneSignal: handshakeDoneSignal,\n\t\tlog:                 logger,\n\t}\n\n\t// Use host from conn address when serverName is not provided\n\tif isClient && c.serverName == \"\" && nextConn.RemoteAddr() != nil {\n\t\tremoteAddr := nextConn.RemoteAddr().String()\n\t\tvar host string\n\t\thost, _, err = net.SplitHostPort(remoteAddr)\n\t\tif err != nil {\n\t\t\tc.serverName = remoteAddr\n\t\t}\n\t\tc.serverName = host\n\t}\n\n\tvar zeroEpoch uint16\n\tc.state.localEpoch.Store(zeroEpoch)\n\tc.state.remoteEpoch.Store(zeroEpoch)\n\tc.state.isClient = isClient\n\n\tif err = c.state.localRandom.populate(); err != nil {\n\t\treturn nil, err\n\t}\n\tif !isClient {\n\t\tc.cookie = make([]byte, cookieLength)\n\t\tif _, err = rand.Read(c.cookie); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Trigger outbound\n\tc.startHandshakeOutbound()\n\n\t// Handle inbound\n\tgo c.inboundLoop()\n\n\tselect {\n\tcase <-c.handshakeDoneSignal.Done():\n\t\terr = c.getConnErr()\n\tcase <-time.After(c.connectTimeout):\n\t\terr = errConnectTimeout\n\t\tc.handshakeDoneSignal.Close()\n\t}\n\n\tif err == nil {\n\t\tc.setHandshakeCompletedSuccessfully()\n\t}\n\n\tc.log.Trace(fmt.Sprintf(\"Handshake Completed (Error: %v)\", err))\n\n\treturn c, err\n}\n\n// Dial connects to the given network address and establishes a DTLS connection on top\nfunc Dial(network string, raddr *net.UDPAddr, config *Config) (*Conn, error) {\n\tpConn, err := net.DialUDP(network, nil, raddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn Client(pConn, config)\n}\n\n// Client establishes a DTLS connection over an existing conn\nfunc Client(conn net.Conn, config *Config) (*Conn, error) {\n\tswitch {\n\tcase config == nil:\n\t\treturn nil, errNoConfigProvided\n\tcase config.PSK != nil && config.PSKIdentityHint == nil:\n\t\treturn nil, errPSKAndIdentityMustBeSetForClient\n\t}\n\n\treturn createConn(conn, clientFlightHandler, clientHandshakeHandler, config, true)\n}\n\n// Server listens for incoming DTLS connections\nfunc Server(conn net.Conn, config *Config) (*Conn, error) {\n\tswitch {\n\tcase config == nil:\n\t\treturn nil, errNoConfigProvided\n\tcase config.PSK == nil && config.Certificate == nil:\n\t\treturn nil, errServerMustHaveCertificate\n\t}\n\n\treturn createConn(conn, serverFlightHandler, serverHandshakeHandler, config, false)\n}\n\n// Read reads data from the connection.\nfunc (c *Conn) Read(p []byte) (n int, err error) {\n\tout, ok := <-c.decrypted\n\tif !ok {\n\t\treturn 0, c.getConnErr()\n\t}\n\tif len(p) < len(out) {\n\t\treturn 0, errBufferTooSmall\n\t}\n\n\tcopy(p, out)\n\treturn len(out), nil\n}\n\n// Write writes len(p) bytes from p to the DTLS connection\nfunc (c *Conn) Write(p []byte) (int, error) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif c.getLocalEpoch() == 0 {\n\t\treturn 0, errHandshakeInProgress\n\t} else if c.getConnErr() != nil {\n\t\treturn 0, c.getConnErr()\n\t}\n\n\tc.internalSend(&recordLayer{\n\t\trecordLayerHeader: recordLayerHeader{\n\t\t\tepoch:           c.getLocalEpoch(),\n\t\t\tprotocolVersion: protocolVersion1_2,\n\t\t},\n\t\tcontent: &applicationData{\n\t\t\tdata: p,\n\t\t},\n\t}, true)\n\n\treturn len(p), nil\n}\n\n// Close closes the connection.\nfunc (c *Conn) Close() error {\n\tc.notify(alertLevelFatal, alertCloseNotify)\n\tc.stopWithError(ErrConnClosed)\n\tif err := c.getConnErr(); err != ErrConnClosed {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// RemoteCertificate exposes the remote certificate\nfunc (c *Conn) RemoteCertificate() *x509.Certificate {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\treturn c.state.remoteCertificate\n}\n\n// SelectedSRTPProtectionProfile returns the selected SRTPProtectionProfile\nfunc (c *Conn) SelectedSRTPProtectionProfile() (SRTPProtectionProfile, bool) {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\n\tif c.state.srtpProtectionProfile == 0 {\n\t\treturn 0, false\n\t}\n\n\treturn c.state.srtpProtectionProfile, true\n}\n\n// ExportKeyingMaterial from https://tools.ietf.org/html/rfc5705\n// This allows protocols to use DTLS for key establishment, but\n// then use some of the keying material for their own purposes\nfunc (c *Conn) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif c.getLocalEpoch() == 0 {\n\t\treturn nil, errHandshakeInProgress\n\t} else if len(context) != 0 {\n\t\treturn nil, errContextUnsupported\n\t} else if _, ok := invalidKeyingLabels[label]; ok {\n\t\treturn nil, errReservedExportKeyingMaterial\n\t}\n\n\tlocalRandom, err := c.state.localRandom.Marshal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tremoteRandom, err := c.state.remoteRandom.Marshal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tseed := []byte(label)\n\tif c.state.isClient {\n\t\tseed = append(append(seed, localRandom...), remoteRandom...)\n\t} else {\n\t\tseed = append(append(seed, remoteRandom...), localRandom...)\n\t}\n\treturn prfPHash(c.state.masterSecret, seed, length, c.state.cipherSuite.hashFunc())\n}\n\nfunc (c *Conn) internalSend(record *recordLayer, shouldEncrypt bool) {\n\tvar packets [][]byte\n\n\tif h, ok := record.content.(*handshake); ok {\n\t\thandshakeRaw, err := record.Marshal()\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tc.log.Tracef(\"[handshake] -> %s\", h.handshakeHeader.handshakeType.String())\n\t\tc.handshakeCache.push(handshakeRaw[recordLayerHeaderSize:], h.handshakeHeader.messageSequence, h.handshakeHeader.handshakeType, c.state.isClient)\n\n\t\thandshakeFragments, err := c.fragmentHandshake(h)\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tfor _, handshakeFragment := range handshakeFragments {\n\t\t\trecordLayerHeader := &recordLayerHeader{\n\t\t\t\tcontentType:     record.recordLayerHeader.contentType,\n\t\t\t\tcontentLen:      uint16(len(handshakeFragment)),\n\t\t\t\tprotocolVersion: record.recordLayerHeader.protocolVersion,\n\t\t\t\tepoch:           record.recordLayerHeader.epoch,\n\t\t\t\tsequenceNumber:  atomic.LoadUint64(&c.state.localSequenceNumber),\n\t\t\t}\n\n\t\t\tatomic.AddUint64(&c.state.localSequenceNumber, 1)\n\n\t\t\trecordLayerHeaderBytes, err := recordLayerHeader.Marshal()\n\t\t\tif err != nil {\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpacket := append(recordLayerHeaderBytes, handshakeFragment...)\n\t\t\tpackets = append(packets, packet)\n\t\t}\n\t} else {\n\t\trecord.recordLayerHeader.sequenceNumber = atomic.LoadUint64(&c.state.localSequenceNumber)\n\t\tatomic.AddUint64(&c.state.localSequenceNumber, 1)\n\n\t\tpacket, err := record.Marshal()\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tpackets = [][]byte{packet}\n\t}\n\n\tfor _, packet := range packets {\n\t\tif shouldEncrypt {\n\t\t\tvar err error\n\t\t\tpacket, err = c.state.cipherSuite.encrypt(record, packet)\n\t\t\tif err != nil {\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif _, err := c.nextConn.Write(packet); err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (c *Conn) fragmentHandshake(h *handshake) ([][]byte, error) {\n\tcontent, err := h.handshakeMessage.Marshal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfragmentedHandshakes := make([][]byte, 0)\n\n\tcontentFragments := splitBytes(content, c.maximumTransmissionUnit)\n\tif len(contentFragments) == 0 {\n\t\tcontentFragments = [][]byte{\n\t\t\t{},\n\t\t}\n\t}\n\n\toffset := 0\n\tfor _, contentFragment := range contentFragments {\n\t\tcontentFragmentLen := len(contentFragment)\n\n\t\thandshakeHeaderFragment := &handshakeHeader{\n\t\t\thandshakeType:   h.handshakeHeader.handshakeType,\n\t\t\tlength:          h.handshakeHeader.length,\n\t\t\tmessageSequence: h.handshakeHeader.messageSequence,\n\t\t\tfragmentOffset:  uint32(offset),\n\t\t\tfragmentLength:  uint32(contentFragmentLen),\n\t\t}\n\n\t\toffset += contentFragmentLen\n\n\t\thandshakeHeaderFragmentRaw, err := handshakeHeaderFragment.Marshal()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfragmentedHandshake := append(handshakeHeaderFragmentRaw, contentFragment...)\n\t\tfragmentedHandshakes = append(fragmentedHandshakes, fragmentedHandshake)\n\t}\n\n\treturn fragmentedHandshakes, nil\n}\n\nfunc (c *Conn) inboundLoop() {\n\tdefer func() {\n\t\tclose(c.decrypted)\n\t}()\n\n\tb := make([]byte, inboundBufferSize)\n\tfor {\n\t\ti, err := c.nextConn.Read(b)\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t} else if c.getConnErr() != nil {\n\t\t\treturn\n\t\t}\n\n\t\tpkts, err := unpackDatagram(b[:i])\n\t\tif err != nil {\n\t\t\tc.stopWithError(err)\n\t\t\treturn\n\t\t}\n\n\t\tfor _, p := range pkts {\n\t\t\talert, err := c.handleIncomingPacket(p)\n\t\t\tif alert != nil {\n\t\t\t\tc.notify(alert.alertLevel, alert.alertDescription)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Conn) handleIncomingPacket(buf []byte) (*alert, error) {\n\t// TODO: avoid separate unmarshal\n\th := &recordLayerHeader{}\n\tif err := h.Unmarshal(buf); err != nil {\n\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t}\n\n\tif h.epoch < c.getRemoteEpoch() {\n\t\tif _, alertPtr, err := c.flightHandler(c); err != nil {\n\t\t\treturn alertPtr, err\n\t\t}\n\t}\n\n\tif h.epoch != 0 {\n\t\tif c.state.cipherSuite == nil || !c.state.cipherSuite.isInitialized() {\n\t\t\tc.log.Debug(\"handleIncoming: Handshake not finished, dropping packet\")\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tvar err error\n\t\tbuf, err = c.state.cipherSuite.decrypt(buf)\n\t\tif err != nil {\n\t\t\tc.log.Debugf(\"decrypt failed: %s\", err)\n\t\t\treturn nil, nil\n\t\t}\n\t}\n\n\tisHandshake, err := c.fragmentBuffer.push(append([]byte{}, buf...))\n\tif err != nil {\n\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t} else if isHandshake {\n\t\tnewHandshakeMessage := false\n\t\tfor out := c.fragmentBuffer.pop(); out != nil; out = c.fragmentBuffer.pop() {\n\t\t\trawHandshake := &handshake{}\n\t\t\tif err := rawHandshake.Unmarshal(out); err != nil {\n\t\t\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t\t\t}\n\n\t\t\tif c.handshakeCache.push(out, rawHandshake.handshakeHeader.messageSequence, rawHandshake.handshakeHeader.handshakeType, !c.state.isClient) {\n\t\t\t\tnewHandshakeMessage = true\n\t\t\t}\n\t\t}\n\t\tif !newHandshakeMessage {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tc.lock.Lock()\n\t\tdefer c.lock.Unlock()\n\t\treturn c.handshakeMessageHandler(c)\n\t}\n\n\tr := &recordLayer{}\n\tif err := r.Unmarshal(buf); err != nil {\n\t\treturn &alert{alertLevelFatal, alertDecodeError}, err\n\t}\n\n\tswitch content := r.content.(type) {\n\tcase *alert:\n\t\tc.log.Tracef(\"<- %s\", content.String())\n\t\tif content.alertDescription == alertCloseNotify {\n\t\t\treturn nil, c.Close()\n\t\t}\n\t\treturn nil, fmt.Errorf(\"alert: %v\", content)\n\tcase *changeCipherSpec:\n\t\tc.log.Trace(\"<- ChangeCipherSpec\")\n\t\tc.setRemoteEpoch(c.getRemoteEpoch() + 1)\n\tcase *applicationData:\n\t\tif h.epoch == 0 {\n\t\t\treturn &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf(\"ApplicationData with epoch of 0\")\n\t\t}\n\n\t\tc.decrypted <- content.data\n\tdefault:\n\t\treturn &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf(\"unhandled contentType %d\", content.contentType())\n\t}\n\treturn nil, nil\n}\n\nfunc (c *Conn) notify(level alertLevel, desc alertDescription) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.internalSend(&recordLayer{\n\t\trecordLayerHeader: recordLayerHeader{\n\t\t\tepoch:           c.getLocalEpoch(),\n\t\t\tprotocolVersion: protocolVersion1_2,\n\t\t},\n\t\tcontent: &alert{\n\t\t\talertLevel:       level,\n\t\t\talertDescription: desc,\n\t\t},\n\t}, c.isHandshakeCompletedSuccessfully())\n}\n\nfunc (c *Conn) setHandshakeCompletedSuccessfully() {\n\tc.handshakeCompletedSuccessfully.Store(struct{ bool }{true})\n}\n\nfunc (c *Conn) isHandshakeCompletedSuccessfully() bool {\n\tboolean, _ := c.handshakeCompletedSuccessfully.Load().(struct{ bool })\n\treturn boolean.bool\n}\n\nfunc (c *Conn) startHandshakeOutbound() {\n\tgo func() {\n\t\tfor {\n\t\t\tvar (\n\t\t\t\tisFinished bool\n\t\t\t\talertPtr   *alert\n\t\t\t\terr        error\n\t\t\t)\n\t\t\tselect {\n\t\t\tcase <-c.handshakeDoneSignal.Done():\n\t\t\t\treturn\n\t\t\tcase <-c.workerTicker.C:\n\t\t\t\tisFinished, alertPtr, err = c.flightHandler(c)\n\t\t\tcase <-c.currFlight.workerTrigger:\n\t\t\t\tisFinished, alertPtr, err = c.flightHandler(c)\n\t\t\t}\n\n\t\t\tif alertPtr != nil {\n\t\t\t\tc.notify(alertPtr.alertLevel, alertPtr.alertDescription)\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase err != nil:\n\t\t\t\tc.stopWithError(err)\n\t\t\t\treturn\n\t\t\tcase c.getConnErr() != nil:\n\t\t\t\treturn\n\t\t\tcase isFinished:\n\t\t\t\treturn // Handshake is complete\n\t\t\t}\n\t\t}\n\t}()\n\tc.currFlight.workerTrigger <- struct{}{}\n}\n\nfunc (c *Conn) stopWithError(err error) {\n\tif connErr := c.nextConn.Close(); connErr != nil {\n\t\tif err != ErrConnClosed {\n\t\t\tconnErr = fmt.Errorf(\"%v\\n%v\", err, connErr)\n\t\t}\n\t\terr = connErr\n\t}\n\n\tc.connErr.Store(struct{ error }{err})\n\n\tc.workerTicker.Stop()\n\n\tc.handshakeDoneSignal.Close()\n}\n\nfunc (c *Conn) getConnErr() error {\n\terr, _ := c.connErr.Load().(struct{ error })\n\treturn err.error\n}\n\nfunc (c *Conn) setLocalEpoch(epoch uint16) {\n\tc.state.localEpoch.Store(epoch)\n}\n\nfunc (c *Conn) getLocalEpoch() uint16 {\n\treturn c.state.localEpoch.Load().(uint16)\n}\n\nfunc (c *Conn) setRemoteEpoch(epoch uint16) {\n\tc.state.remoteEpoch.Store(epoch)\n}\n\nfunc (c *Conn) getRemoteEpoch() uint16 {\n\treturn c.state.remoteEpoch.Load().(uint16)\n}\n\n// LocalAddr is a stub\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.nextConn.LocalAddr()\n}\n\n// RemoteAddr is a stub\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.nextConn.RemoteAddr()\n}\n\n// SetDeadline is a stub\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\treturn c.nextConn.SetDeadline(t)\n}\n\n// SetReadDeadline is a stub\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.nextConn.SetReadDeadline(t)\n}\n\n// SetWriteDeadline is a stub\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.nextConn.SetWriteDeadline(t)\n}\n"], "filenames": ["conn.go"], "buggy_code_start_loc": [561], "buggy_code_end_loc": [561], "fixing_code_start_loc": [562], "fixing_code_end_loc": [566], "type": "CWE-287", "message": "handleIncomingPacket in conn.go in Pion DTLS before 1.5.2 lacks a check for application data with epoch 0, which allows remote attackers to inject arbitrary unencrypted data after handshake completion.", "other": {"cve": {"id": "CVE-2019-20786", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-19T20:15:11.587", "lastModified": "2020-04-23T14:47:01.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "handleIncomingPacket in conn.go in Pion DTLS before 1.5.2 lacks a check for application data with epoch 0, which allows remote attackers to inject arbitrary unencrypted data after handshake completion."}, {"lang": "es", "value": "La funci\u00f3n handleIncomingPacket en el archivo conn.go en Pion DTLS versiones anteriores a la versi\u00f3n  1.5.2, carece de una comprobaci\u00f3n de los datos de aplicaci\u00f3n con epoch 0, que permite a atacantes remotos inyectar datos arbitrarios no cifrados despu\u00e9s de completar el protocolo de enlace."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pion:dtls:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.2", "matchCriteriaId": "80BBC077-8B85-4464-B76C-111F08F28338"}]}]}], "references": [{"url": "https://github.com/pion/dtls/commit/fd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pion/dtls/compare/v1.5.1...v1.5.2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.usenix.org/conference/usenixsecurity20/presentation/fiterau-brostean", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.usenix.org/system/files/sec20fall_fiterau-brostean_prepub.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pion/dtls/commit/fd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0"}}