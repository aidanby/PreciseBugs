{"buggy_code": ["#================\n# FILE          : KIWIRoot.pm\n#----------------\n# PROJECT       : OpenSUSE Build-Service\n# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany\n#               :\n# AUTHOR        : Marcus Schaefer <ms@suse.de>\n#               :\n# BELONGS TO    : Operating System images\n#               :\n# DESCRIPTION   : This module is used to initialize and install\n#               : the chroot system of the image\n#               : \n#               :\n# STATUS        : Development\n#----------------\npackage KIWIRoot;\n#==========================================\n# Modules\n#------------------------------------------\nuse strict;\nuse Carp qw (cluck);\nuse File::Glob ':glob';\nuse File::Find;\nuse FileHandle;\nuse KIWIConfigure;\nuse KIWILocator;\nuse KIWILog;\nuse KIWIManager;\nuse KIWIOverlay;\nuse KIWIQX;\nuse KIWIURL;\n\n#==========================================\n# Constructor\n#------------------------------------------\nsub new {\n\t# ...\n\t# Create a new KIWIRoot object which is used for\n\t# setting up a physical extend. In principal the root\n\t# object creates a chroot environment including all\n\t# packages which makes the image\n\t# ---\n\t#==========================================\n\t# Object setup\n\t#------------------------------------------\n\tmy $this  = {};\n\tmy $class = shift;\n\tbless $this,$class;\n\t#==========================================\n\t# Module Parameters\n\t#------------------------------------------\n\tmy $kiwi = shift;\n\tmy $xml  = shift;\n\tmy $imageDesc    = shift;\n\tmy $selfRoot     = shift;\n\tmy $baseSystem   = shift;\n\tmy $useRoot      = shift;\n\tmy $addPacks     = shift;\n\tmy $delPacks     = shift;\n\tmy $cacheRoot    = shift;\n\tmy $targetArch   = shift;\n\tmy $cmdL         = shift;\n\t#==========================================\n\t# Constructor setup\n\t#------------------------------------------\n\tmy $code;\n\tif (! defined $kiwi) {\n\t\t$kiwi = new KIWILog(\"tiny\");\n\t}\n\tif (($imageDesc !~ /^\\//) && (! -d $imageDesc)) {\n\t\t$imageDesc = $this->{gdata}->{System}.\"/\".$imageDesc;\n\t}\n\tif (! defined $baseSystem) {\n\t\t$kiwi -> error (\"No base system path specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $xml) {\n\t\t$kiwi -> error (\"No XML tree specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $imageDesc) {\n\t\t$kiwi -> error (\"No image path specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy %repository = $xml -> getRepository();\n\tif (! %repository) {\n\t\t$kiwi -> error (\"No repository specified in XML tree\");\n\t\t$kiwi -> failed ();\n\t\treturn undef; \n\t}\n\tif (! $main::global) {\n\t\t$kiwi -> error  (\"Globals object not found\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $count = 1;\n\tmy %sourceChannel = ();\n\t#==========================================\n\t# Create sourceChannel hash\n\t#------------------------------------------\n\tforeach my $source (keys %repository) {\n\t\tmy $type = $repository{$source}[0];\n\t\tmy $alias= $repository{$source}[1];\n\t\tmy $prio = $repository{$source}[2];\n\t\tmy $user = $repository{$source}[3];\n\t\tmy $pwd  = $repository{$source}[4];\n\t\tmy $plic = $repository{$source}[5];\n\t\tmy $imgincl = $repository{$source}[6];\n\t\tmy $urlHandler  = new KIWIURL ($kiwi,$cmdL,$this,$user,$pwd);\n\t\tmy $publics_url = $urlHandler -> normalizePath ($source);\n\t\tif ($publics_url =~ /^\\//) {\n\t\t\tmy ( $publics_url_test ) = bsd_glob ( $publics_url );\n\t\t\tif (! -d $publics_url_test) {\n\t\t\t\t$kiwi ->warning (\"local URL path not found: $publics_url_test\");\n\t\t\t\t$kiwi ->skipped ();\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\t\tmy $private_url = $publics_url;\n\t\tif ($private_url =~ /^\\//) {\n\t\t\t$private_url = $baseSystem.\"/\".$private_url;\n\t\t}\n\t\tmy $publics_type = $urlHandler -> getRepoType();\n\t\tif (($publics_type ne \"unknown\") && ($publics_type ne $type)) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"$private_url: overwrite repo type $type with: $publics_type\"\n\t\t\t);\n\t\t\t$kiwi -> done();\n\t\t\t$type = $publics_type;\n\t\t}\n\t\t#==========================================\n\t\t# build channel name/alias...\n\t\t#------------------------------------------\n\t\tmy $channel = $alias;\n\t\tif (! $channel) {\n\t\t\t$channel = $publics_url;\n\t\t\t$channel =~ s/\\//_/g;\n\t\t\t$channel =~ s/^_//;\n\t\t\t$channel =~ s/_$//;\n\t\t}\n\t\t#==========================================\n\t\t# build source key...\n\t\t#------------------------------------------\n\t\tmy $srckey  = \"baseurl\";\n\t\tmy $srcopt;\n\t\tif (($type eq \"rpm-dir\") || ($type eq \"deb-dir\")) {\n\t\t\t$srckey = \"path\";\n\t\t\t$srcopt = \"recursive=True\";\n\t\t}\n\t\t$private_url = \"'\".$private_url.\"'\";\n\t\t$publics_url = \"'\".$publics_url.\"'\";\n\t\tmy @private_options = (\"type=$type\",\"name=$channel\",\n\t\t\t\"$srckey=$private_url\",$srcopt\n\t\t);\n\t\tmy @public_options  = (\"type=$type\",\"name=$channel\",\n\t\t\t\"$srckey=$publics_url\",$srcopt\n\t\t);\n\t\tif (($prio) && ($prio != 0)) {\n\t\t\tpush (@private_options,\"priority=$prio\");\n\t\t\tpush (@public_options ,\"priority=$prio\");\n\t\t}\n\t\tpush (@private_options,\"-y\");\n\t\tpush (@public_options ,\"-y\");\n\t\t$sourceChannel{private}{$channel} = \\@private_options;\n\t\t$sourceChannel{public}{$channel}  = \\@public_options;\n\t\t$sourceChannel{$channel}{license} = 0;\n\t\t$sourceChannel{$channel}{imgincl} = 0;\n\t\tif (($plic) && (\"$plic\" eq \"true\")) {\n\t\t\t$sourceChannel{$channel}{license} = 1;\n\t\t}\n\t\tif (($imgincl) && (\"$imgincl\" eq \"true\")) {\n\t\t\t$kiwi -> info (\"Retain $channel\\n\");\n\t\t\t$sourceChannel{$channel}{imgincl} = 1;\n\t\t}\n\t\t$count++;\n\t}\n\t#==========================================\n\t# Store object data\n\t#------------------------------------------\n\t$this->{kiwi}          = $kiwi;\n\t$this->{sourceChannel} = \\%sourceChannel;\n\t$this->{xml}           = $xml;\n\t$this->{imageDesc}     = $imageDesc;\n\t$this->{selfRoot}      = $selfRoot;\n\t$this->{baseSystem}    = $baseSystem;\n\t$this->{useRoot}       = $useRoot;\n\t$this->{addPacks}      = $addPacks;\n\t$this->{delPacks}      = $delPacks;\n\t$this->{cacheRoot}     = $cacheRoot;\n\t$this->{gdata}         = $main::global -> getGlobals();\n\t#==========================================\n\t# check channel count\n\t#------------------------------------------\n\tif ($count == 1) {\n\t\t$kiwi -> error  (\"No Channels left\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create root directory\n\t#------------------------------------------\n\tmy $locator = new KIWILocator ($this -> {kiwi});\n\tmy $root = $locator -> createTmpDirectory (\n\t\t$useRoot,$selfRoot,$cmdL\n\t);\n\tif ( ! defined $root ) {\n\t\t$kiwi -> error (\"Couldn't create root directory: $!\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for overlay structure\n\t#------------------------------------------\n\t$this->{origtree}= $root;\n\t$this->{overlay} = new KIWIOverlay ($kiwi,$root,$cacheRoot);\n\tif (! $this->{overlay}) {\n\t\treturn undef;\n\t}\n\t$root = $this->{overlay} -> mountOverlay();\n\tif (! -d $root) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Mark new root directory as broken\n\t#------------------------------------------\n\tqxx (\"touch $root/.broken 2>&1\");\n\t#==========================================\n\t# Set root log file\n\t#------------------------------------------\n\tif (! $cmdL -> getLogFile()) {\n\t\tif (-e $this->{origtree}) {\n\t\t\t$kiwi -> setRootLog ($this->{origtree}.\".\".\"$$\".\".screenrc.log\");\n\t\t} else {\n\t\t\t$kiwi -> setRootLog ($root.\".\".\"$$\".\".screenrc.log\");\n\t\t}\n\t}\n\t#==========================================\n\t# Get configured name of package manager\n\t#------------------------------------------\n\t$kiwi -> info (\"Setting up package manager: \");\n\tmy $pmgr = $xml -> getPackageManager();\n\tif (! defined $pmgr) {\n\t\t$kiwi -> failed();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t$kiwi -> note ($pmgr);\n\t$kiwi -> done ();\n\t#==========================================\n\t# Create package manager object\n\t#------------------------------------------\n\tmy $manager = new KIWIManager (\n\t\t$kiwi,$xml,\\%sourceChannel,$root,$pmgr,$targetArch\n\t);\n\tif (! defined $manager) {\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Store object data\n\t#------------------------------------------\n\t$this->{root}    = $root;\n\t$this->{manager} = $manager;\n\t$this->{cmdL}    = $cmdL;\n\treturn $this;\n}\n\n#==========================================\n# getRootPath\n#------------------------------------------\nsub getRootPath {\n\t# ...\n\t# Return chroot path for this image\n\t# ---\n\tmy $this = shift;\n\treturn $this->{root};\n}\n\n#==========================================\n# cleanBroken\n#------------------------------------------\nsub cleanBroken {\n\t# ...\n\t# Remove the .broken indicator to allow\n\t# use of this root path for image creation\n\t# ---\n\tmy $this = shift;\n\tmy $root = $this->{root};\n\tunlink $root.\"/.broken\";\n\treturn $this;\n}\n\n#==========================================\n# copyBroken\n#------------------------------------------\nsub copyBroken {\n\t# ...\n\t# copy the current logfile contents into\n\t# the .broken file below the root tree which\n\t# is indicated to be broken for some reason\n\t# mentioned in the log file\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $log  = $kiwi->getRootLog();\t\n\tif (-f $log) {\n\t\tqxx (\"cp $log $root/.broken 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# init\n#------------------------------------------\nsub init {\n\t# ...\n\t# Initialize root system. The method will create a secured\n\t# tmp directory and extract all the given base files.\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $root = $this->{root};\n\tmy $cmdL = $this->{cmdL};\n\tmy $manager    = $this->{manager};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $FD;\n\t#==================================\n\t# Create /etc/ImageVersion file\n\t#----------------------------------\n\tmy $imageVersionFile = \"$root/etc/ImageVersion\";\n\tmy $imageVersion = $xml -> getImageVersion();\n\tmy $imageName    = $xml -> getImageName();\n\tqxx (\"mkdir -p $root/etc\");\n\tif ( ! open ($FD, \">$imageVersionFile\")) {\n\t\t$kiwi -> error (\"Failed to create version file: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tprint $FD $imageName.\"-\".$imageVersion;\n\tclose $FD;\n\t#==================================\n\t# Copy helper scripts to new root\n\t#----------------------------------\n\tqxx (\"cp $this->{gdata}->{KConfig} $root/.kconfig 2>&1\");\n\t#==================================\n\t# Return early if existing root\n\t#----------------------------------\n\tif ($cmdL -> getRecycleRootDir()) {\n\t\treturn $this;\n\t}\n\t#==================================\n\t# Return early if cache is used\n\t#----------------------------------\n\tif (($cmdL-> getCacheDir()) && (! $cmdL->getOperationMode(\"initCache\"))) {\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# Get base Package list\n\t#------------------------------------------\n\tmy @initPacs = $xml -> getBaseList();\n\tif (! @initPacs) {\n\t\t$kiwi -> error (\"Couldn't create base package list\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Setup preperation checks\n\t#------------------------------------------\n\t$manager -> switchToLocal();\n\tif (! $manager -> setupSignatureCheck()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupExcludeDocs()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==================================\n\t# Copy/touch some defaults files\n\t#----------------------------------\n\t$kiwi -> info (\"Creating default template files for new root system\");\n\tif (! defined $this->{cacheRoot}) {\n\t\tqxx (\"mkdir -p $root/dev\");\n\t\tqxx (\"mkdir -m 755 -p $root/dev/pts\");\n\t\tqxx (\"mknod -m 666 $root/dev/null c 1 3\");\n\t\tqxx (\"mknod -m 666 $root/dev/zero c 1 5\");\n\t\tqxx (\"mknod -m 622 $root/dev/full c 1 7\");\n\t\tqxx (\"mknod -m 666 $root/dev/random c 1 8\");\n\t\tqxx (\"mknod -m 644 $root/dev/urandom c 1 9\");\n\t\tqxx (\"mknod -m 666 $root/dev/tty c 5 0\");\n\t\tqxx (\"mknod -m 666 $root/dev/ptmx c 5 2\");\n\t\tqxx (\"ln -s /proc/self/fd $root/dev/fd\");\n\t\tqxx (\"ln -s fd/2 $root/dev/stderr\");\n\t\tqxx (\"ln -s fd/0 $root/dev/stdin\");\n\t\tqxx (\"ln -s fd/1 $root/dev/stdout\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop0 b 7 0\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop1 b 7 1\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop2 b 7 2\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop3 b 7 3\");\n\t\tqxx (\"mkdir -p $root/etc/sysconfig\");\n\t\tqxx (\"mkdir -p $root/var/log/YaST2\");\n\t\t# for smart we need the dpkg default file\n\t\tqxx (\"mkdir -p $root/var/lib/dpkg\");\n\t\tqxx (\"touch $root/var/lib/dpkg/status\");\n\t\tqxx (\"mkdir -p $root/var/lib/dpkg/updates\");\n\t\tqxx (\"touch $root/var/lib/dpkg/available\");\n\t\t# for building in suse autobuild we need the following file\n\t\tif (-f '/.buildenv') {\n\t\t\tqxx (\"touch $root/.buildenv\");\n\t\t}\n\t\t# need mtab link for mount calls\n\t\tqxx (\"ln -s /proc/self/mounts $root/etc/mtab\");\n\t\t# need sysconfig/bootloader to make post scripts happy\n\t\tqxx (\"touch $root/etc/sysconfig/bootloader\");\n\t}\n\t# need user/group files as template\n\tmy $groupTemplate = \"/etc/group\"; \n\tmy $paswdTemplate = \"/etc/passwd\";\n\t# search for template files, add paths for different distros here\n\tmy @searchPWD = (\n\t\t\"/var/adm/fillup-templates/passwd.aaa_base\"\n\t);\n\tmy @searchGRP = (\n\t\t\"/var/adm/fillup-templates/group.aaa_base\"\n\t);\n\tforeach my $group (@searchGRP) {\n\t\tif ( -f $group ) {\n\t\t\t$groupTemplate = $group; last;\n\t\t}\n\t}\n\tforeach my $paswd (@searchPWD) {\n\t\tif ( -f $paswd ) {\n\t\t\t$paswdTemplate = $paswd; last;\n\t\t}\n\t}\n\tqxx (\" cp $groupTemplate $root/etc/group  2>&1 \");\n\tqxx (\" cp $paswdTemplate $root/etc/passwd 2>&1 \");\n\t# need resolv.conf/hosts for internal chroot name resolution\n\tqxx (\" cp /etc/resolv.conf $root/etc 2>&1 \");\n\tqxx (\" cp /etc/hosts $root/etc 2>&1 \");\n\t$kiwi -> done();\n\t#==========================================\n\t# Create package keys\n\t#------------------------------------------\n\tif (! defined $this->{cacheRoot}) {\n\t\t$manager -> setupPackageKeys();\n\t}\n\t#==========================================\n\t# Setup shared cache directory\n\t#------------------------------------------\n\t$this -> setupCacheMount();\n\t#==========================================\n\t# Add source, install and clean source\n\t#------------------------------------------\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$this -> cleanMount();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupRootSystem(@initPacs)) {\n\t\t$manager -> resetInstallationSource();\n\t\t$this -> cleanMount();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# reset installation source\n\t#------------------------------------------\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$this -> cleanMount();\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t#==========================================\n\t# Reset preperation checks\n\t#------------------------------------------\n\tif (! $manager -> resetSignatureCheck()) {\n\t\t$this -> cleanMount();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t$this -> cleanMount('(cache\\/(kiwi|zypp)$)|(dev$)');\n\t$manager -> freeLock();\n\t#==================================\n\t# Create default fstab file\n\t#----------------------------------\n\tif ( ! open (FD,\">$root/etc/fstab\")) {\n\t\t$kiwi -> error (\"Failed to create fstab file: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tprint FD \"devpts /dev/pts devpts mode=0620,gid=5 0 0\\n\";\n\tprint FD \"proc   /proc    proc   defaults        0 0\\n\";\n\tclose FD;\n\t#==================================\n\t# Return object reference\n\t#----------------------------------\n\treturn $this;\n}\n\n#==========================================\n# upgrade\n#------------------------------------------\nsub upgrade {\n\t# ...\n\t# Upgrade a previosly prepared image root tree\n\t# with respect to changes of the installation source(s)\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $manager  = $this->{manager};\n\tmy $addPacks = $this->{addPacks};\n\tmy $delPacks = $this->{delPacks};\n\t#==========================================\n\t# Mount local and NFS directories\n\t#------------------------------------------\n\t$manager -> switchToChroot();\n\tif (! $this -> setupMount ()) {\n\t\t$kiwi -> error (\"Couldn't mount base system\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# make sure name resolution works\n\t#------------------------------------------\n\t$this->{needResolvConf} = 0;\n\t$this->{needHosts} = 0;\n\tif (! -f \"$root/etc/resolv.conf\") {\n\t\tqxx (\"cp /etc/resolv.conf $root/etc 2>&1\");\n\t\t$this->{needResolvConf} = 1;\n\t}\n\tif (! -f \"$root/etc/hosts\") {\n\t\tqxx (\"cp /etc/hosts $root/etc 2>&1\");\n\t\t$this->{needHosts} = 1;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Upgrade system\n\t#------------------------------------------\n\tif (! $manager -> setupSignatureCheck()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$this -> cleanupResolvConf();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupUpgrade ($addPacks,$delPacks)) {\n\t\t$this -> cleanupResolvConf();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$this -> cleanupResolvConf();\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t$this -> cleanupResolvConf();\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n#==========================================\n# prepareTestingEnvironment\n#------------------------------------------\nsub prepareTestingEnvironment {\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $manager  = $this->{manager};\n\t#==========================================\n\t# Mount local and NFS directories\n\t#------------------------------------------\n\t$manager -> switchToChroot();\n\tif (! $this -> setupMount ()) {\n\t\t$kiwi -> error (\"Couldn't mount base system\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# make sure name resolution works\n\t#------------------------------------------\n\t$this->{needResolvConf} = 0;\n\t$this->{needHosts} = 0;\n\tif (! -f \"$root/etc/resolv.conf\") {\n\t\tqxx (\"cp /etc/resolv.conf $root/etc 2>&1\");\n\t\t$this->{needResolvConf} = 1;\n\t}\n\tif (! -f \"$root/etc/hosts\") {\n\t\tqxx (\"cp /etc/hosts $root/etc 2>&1\");\n\t\t$this->{needHosts} = 1;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Setup sources\n\t#------------------------------------------\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$this -> cleanupResolvConf();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t$this -> cleanupResolvConf();\n\treturn $this;\n}\n\n#==========================================\n# cleanupTestingEnvironment\n#------------------------------------------\nsub cleanupTestingEnvironment {\n\tmy $this = shift;\n\tmy $root = $this->{root};\n\tmy $manager = $this->{manager};\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$this -> cleanupResolvConf();\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t$this -> cleanupResolvConf();\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n#==========================================\n# cleanupResolvConf\n#------------------------------------------\nsub cleanupResolvConf {\n\tmy $this = shift;\n\tmy $root = $this->{root};\n\tmy $needResolvConf = $this->{needResolvConf};\n\tmy $needHosts = $this->{needHosts};\n\tif ($needResolvConf) {\n\t\tqxx (\"rm -f $root/etc/resolv.conf\");\n\t\tundef $this->{needResolvConf};\n\t}\n\tif ($needHosts) {\n\t\tqxx (\"rm -f $root/etc/hosts\");\n\t\tundef $this->{needHosts};\n\t}\n}\n\n#==========================================\n# installTestingPackages\n#------------------------------------------\nsub installTestingPackages {\n\tmy $this = shift;\n\tmy $pack = shift;\n\tmy $manager  = $this->{manager};\n\tif (! $manager -> installPackages ($pack)) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# uninstallTestingPackages\n#------------------------------------------\nsub uninstallTestingPackages {\n\tmy $this = shift;\n\tmy $pack = shift;\n\tmy $manager  = $this->{manager};\n\tif (! $manager -> removePackages ($pack)) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# install\n#------------------------------------------\nsub install {\n\t# ...\n\t# Install the given package set into the root\n\t# directory of the image system\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $manager = $this->{manager};\n\tmy %type;\n\t#==========================================\n\t# Get image package list\n\t#------------------------------------------\n\tmy @packList = $manager -> setupInstallPackages;\n\t#==========================================\n\t# proceed if packlist is not empty\n\t#------------------------------------------\n\tif (! @packList) {\n\t\t$kiwi -> loginfo (\"Packlist is empty, skipping install\\n\");\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# Mount local and NFS directories\n\t#------------------------------------------\n\tif (! setupMount ($this)) {\n\t\t$kiwi -> error (\"Couldn't mount base system\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Setup signature check\n\t#------------------------------------------\n\t$manager -> switchToChroot();\n\tif (! $manager -> setupSignatureCheck()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupExcludeDocs()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Add source(s) and install\n\t#------------------------------------------\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupRootSystem (@packList)) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# reset installation source\n\t#------------------------------------------\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n#==========================================\n# installArchives\n#------------------------------------------\nsub installArchives {\n\t# ...\n\t# Install the given raw archives into the root\n\t# directory of the image system\n\t# ---\n\tmy $this = shift;\n\tmy $idesc= shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $root = $this->{root};\n\tmy $manager = $this->{manager};\n\tif (! defined $idesc) {\n\t\t$idesc = $this->{imageDesc};\n\t}\n\t#==========================================\n\t# get image archive list\n\t#------------------------------------------\n\tmy @archives = $xml -> getArchiveList();\n\t#==========================================\n\t# Install raw data archives\n\t#------------------------------------------\n\t$manager -> switchToLocal();\n\tif (! $manager -> setupArchives($idesc,@archives)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check ownership of archive files\n\t#------------------------------------------\n\tif (-f \"$root/bootincluded_archives.filelist\") {\n\t\t$this -> fixupOverlayFilesOwnership (\"bootincluded_archives.filelist\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# fixupOverlayFilesOwnership\n#------------------------------------------\nsub fixupOverlayFilesOwnership {\n\t# ...\n\t# search for files and directories in the given path or\n\t# table of contents (toc) file and make sure those files\n\t# get the right ownership assigned\n\t# ---\n\tmy $this  = shift;\n\tmy $path  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $root  = $this->{root};\n\tmy $item  = $root.\"/\".$path;\n\tmy $prefix= \"FixupOwner\";\n\tmy @files = ();\n\tmy %except= ();\n\tif (-d $item) {\n\t\t#==========================================\n\t\t# got dir, search files there\n\t\t#------------------------------------------\n\t\tsub generateWanted {\n\t\t\tmy $result = shift;\n\t\t\tmy $base   = shift;\n\t\t\treturn sub {\n\t\t\t\tmy @names = ($File::Find::name,$File::Find::dir);\n\t\t\t\tforeach my $name (@names) {\n\t\t\t\t\t$name =~ s/^$base//; $name =~ s/^\\///;\n\t\t\t\t\tpush @{$result},$name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmy $wref = generateWanted (\\@files,$root);\n\t\tfind ({ wanted => $wref, follow => 0 }, $item);\n\t} elsif (-f $item) {\n\t\t#==========================================\n\t\t# got archive, use archive toc file\n\t\t#------------------------------------------\n\t\tmy $fd = new FileHandle;\n\t\tif ($fd -> open ($item)) {\n\t\t\twhile (my $line = <$fd>) {\n\t\t\t\tchomp $line; $line =~ s/^\\///;\n\t\t\t\tpush (@files,$line);\n\t\t\t}\n\t\t\t$fd -> close();\n\t\t} else {\n\t\t\t$kiwi -> warning (\"$prefix: Failed to open $item: $!\");\n\t\t\t$kiwi -> skipped ();\n\t\t\treturn undef;\n\t\t}\n\t} else {\n\t\t$kiwi -> warning (\"$prefix: No such file or directory: $item\");\n\t\t$kiwi -> skipped ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check file list\n\t#------------------------------------------\n\tif (! @files) {\n\t\t$kiwi -> warning (\"$prefix: No files found in: $item\");\n\t\t$kiwi -> skipped ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# create passwd exception directories\n\t#------------------------------------------\n\tmy $fd = new FileHandle;\n\tif (! $fd -> open ($root.\"/etc/passwd\")) {\n\t\t$kiwi -> warning (\"$prefix: No passwd file found in: $root\");\n\t\t$kiwi -> skipped ();\n\t\treturn undef;\n\t}\n\twhile (my $line = <$fd>) {\n\t\tchomp $line;\n\t\tmy $name = (split (/:/,$line))[5];\n\t\t$name =~ s/\\///;\n\t\tif ($name =~ /^(bin|sbin|root)/) {\n\t\t\tnext;\n\t\t}\n\t\t$except{$name} = 1;\n\t}\n\t$fd -> close();\n\t#==========================================\n\t# walk through all files\n\t#------------------------------------------\n\tforeach my $file (@files) {\n\t\tmy $ok = 1;\n\t\t$file =~ s/^ +//;\n\t\tforeach my $exception (keys %except) {\n\t\t\tif ($file =~ /$exception/) {\n\t\t\t\t$kiwi -> loginfo (\n\t\t\t\t\t\"$prefix: $file belongs to passwd, leaving it untouched\"\n\t\t\t\t);\n\t\t\t\t$ok = 0; last;\n\t\t\t}\n\t\t}\n\t\tnext if ! $ok;\n\t\tmy $data = qxx (\"chroot $root chown -c root:root \\\"$file\\\" 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"$prefix: Failed to fixup ownership of $root/$file: $data\"\n\t\t\t);\n\t\t\t$kiwi -> skipped ();\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# setup\n#------------------------------------------\nsub setup {\n\t# ...\n\t# Setup the installed system. This method will:\n\t# 1) copy the user defined files to the root tree and\n\t#    creates the .profile environment file.\n\t# 2) create .profile image environment source file\n\t# 3) import linuxrc file if required\n\t# 4) call package setup scripts from config directory\n\t# 5) calls the config.sh and package scripts within the\n\t#    chroot of the physical extend.\n\t# 6) copy the complete image description tree to\n\t#    /image which contains information to create a logical\n\t#    extend from the chroot.\n\t# 7) configure the system with methods from KIWIConfigure\n\t# 8) cleanup temporary files\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $xml  = $this->{xml};\n\tmy $configFile= $xml -> getConfigName();\n\tmy $imageDesc = $this->{imageDesc};\n\tmy $manager   = $this->{manager};\n\tmy $data;\n\tmy $status;\n\t#======================================== \n\t# Consistency check\n\t#----------------------------------------\n\tif (! -d \"$root/tmp\") {\n\t\t$kiwi -> error (\"Image system seems to be broken\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#========================================\n\t# copy license files if they exist\n\t#----------------------------------------\n\tif (-f \"$root/license.tar.gz\") {\n\t\tqxx (\"mkdir -p $root/etc/YaST2/licenses/base\");\n\t\tqxx (\"tar -C $root/etc/YaST2/licenses/base -xf $root/license.tar.gz\");\n\t\tqxx (\"rm -f $root/license.tar.gz\");\n\t}\n\t#========================================\n\t# copy user defined files to image tree\n\t#----------------------------------------\n\tif ((-d \"$imageDesc/root\") && (bsd_glob($imageDesc.'/root/*'))) {\n\t\t$kiwi -> info (\"Copying user defined files to image tree\");\n\t\t#========================================\n\t\t# copy user defined files to tmproot\n\t\t#----------------------------------------\n\t\tmkdir $root.\"/tmproot\";\n\t\tif ((-l \"$imageDesc/root/linuxrc\") || (-l \"$imageDesc/root/include\")) {\n\t\t\t$data = qxx (\n\t\t\t\t\"cp -LR --force $imageDesc/root/* $root/tmproot 2>&1\"\n\t\t\t);\n\t\t} else {\n\t\t\t$data = qxx (\n\t\t\t\t\"tar -cf - -C $imageDesc/root . | tar -x -C $root/tmproot 2>&1\"\n\t\t\t);\n\t\t}\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t#========================================\n\t\t# check tmproot ownership\n\t\t#----------------------------------------\n\t\t$this -> fixupOverlayFilesOwnership (\"tmproot\");\n\t\t#========================================\n\t\t# copy tmproot to real root (tar)\n\t\t#----------------------------------------\n\t\t$data = qxx (\"tar -cf - -C $root/tmproot . | tar -x -C $root 2>&1\");\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t#========================================\n\t\t# cleanup tmproot\n\t\t#----------------------------------------\n\t\tqxx (\"rm -rf $root/tmproot\");\n\t\t$kiwi -> done();\n\t}\n\t#========================================\n\t# create .profile from <image> tags\n\t#----------------------------------------\n\t$kiwi -> info (\"Create .profile for package scripts\");\n\tif (! open (FD,\">$root/.profile\")) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create .profile: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\tmy %config = $xml -> getImageConfig();\n\tforeach my $key (keys %config) {\n\t\t$kiwi -> loginfo (\"[PROFILE]: $key=\\\"$config{$key}\\\"\\n\");\n\t\tprint FD \"$key=\\\"$config{$key}\\\"\\n\";\n\t}\n\tclose FD;\n\t#========================================\n\t# check for linuxrc\n\t#----------------------------------------\n\tif (-f \"$root/linuxrc\") {\n\t\t$kiwi -> info (\"Setting up linuxrc...\");\n\t\tmy $data = qxx (\"ln $root/linuxrc $root/init 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t}\n\t\tqxx (\"chmod u+x $root/linuxrc $root/init 2>&1\");\n\t\t$kiwi -> done ();\n\t}\n\t#========================================\n\t# call setup scripts\n\t#----------------------------------------\n\tif (-d \"$imageDesc/config\") {\n\t\t$kiwi -> info (\"Preparing package setup scripts\");\n\t\tqxx (\" mkdir -p $root/image/config \");\n\t\tqxx (\" cp $imageDesc/config/* $root/image/config 2>&1 \");\n\t\tif (! opendir (FD,\"$root/image/config\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't open script directory: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\tmy @scriptList = readdir FD;\n\t\tforeach my $script (@scriptList) {\n\t\t\tif (-f \"$root/image/config/$script\") {\n\t\t\t\tif ($manager -> setupPackageInfo ( $script )) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$kiwi -> info (\"Calling package setup script: $script\");\n\t\t\t\tqxx (\" chmod u+x $root/image/config/$script\");\n\t\t\t\tmy $data = qxx (\" chroot $root /image/config/$script 2>&1 \");\n\t\t\t\tmy $code = $? >> 8;\n\t\t\t\tif ($code != 0) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$kiwi -> info   ($data);\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t} else {\n\t\t\t\t\t$kiwi -> loginfo (\"$script: $data\");\n\t\t\t\t}\n\t\t\t\tqxx (\"rm -f $root/image/config/$script\");\n\t\t\t\t$kiwi -> done ();\n\t\t\t}\n\t\t}\n\t\trmdir (\"$root/image/config\");\n\t\tclosedir FD;\n\t}\n\t#========================================\n\t# copy image description to image tree\n\t#----------------------------------------\n\tqxx (\" mkdir -p $root/image \");\n\tqxx (\" cp $configFile $root/image 2>&1 \");\n\tqxx (\" cp $imageDesc/images.sh $root/image 2>&1 \");\n\tqxx (\" cp $imageDesc/config-cdroot.tgz $root/image 2>&1 \");\n\tqxx (\" cp $imageDesc/config-cdroot.sh  $root/image 2>&1 \");\n\tqxx (\" cp $root/.profile $root/image 2>&1 \");\n\tqxx (\" chmod u+x $root/image/images.sh 2>&1\");\n\tqxx (\" chmod u+x $root/image/config-cdroot.sh 2>&1\");\n\tif (open (FD,\">$root/image/main::Prepare\")) {\n\t\tif ($imageDesc !~ /^\\//) {\n\t\t\tmy $pwd = qxx (\" pwd \"); chomp $pwd;\n\t\t\tprint FD $pwd.\"/\".$imageDesc; close FD;\n\t\t} else {\n\t\t\tprint FD $imageDesc; close FD;\n\t\t}\n\t}\n\t#========================================\n\t# configure the system\n\t#----------------------------------------\n\tmy $configure = new KIWIConfigure ( $kiwi,$xml,$root,$imageDesc );\n\tif (! defined $configure) {\n\t\treturn undef;\n\t}\n\t#========================================\n\t# setup users/groups\n\t#----------------------------------------\n\tif (! $configure -> setupUsersGroups()) {\n\t\treturn undef;\n\t}\n\t#========================================\n\t# check for yast firstboot setup file\n\t#----------------------------------------\n\t$status = $configure -> setupFirstBootYaST();\n\tif ($status eq \"failed\") {\n\t\treturn undef;\n\t}\n\t$status = $configure -> setupAutoYaST();\n\tif ($status eq \"failed\") {\n\t\treturn undef;\n\t}\n\t$status = $configure -> setupFirstBootAnaconda();\n\tif ($status eq \"failed\") {\n\t\treturn undef;\n\t}\n\t#========================================\n\t# call config.sh image script\n\t#----------------------------------------\n\tif (-e \"$imageDesc/config.sh\") {\n\t\t$kiwi -> info (\"Calling image script: config.sh\");\n\t\tqxx (\" cp $imageDesc/config.sh $root/tmp \");\n\t\t\t\tqxx (\" chmod u+x $root/tmp/config.sh \");\n\t\tmy $data = qxx (\" chroot $root /tmp/config.sh 2>&1 \");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config.sh: $data\");\n\t\t}\n\t\tqxx (\" rm -f $root/tmp/config.sh \");\n\t\t$kiwi -> done ();\n\t}\n\t#========================================\n\t# create /etc/ImageID file\n\t#----------------------------------------\n\tmy $id = $xml -> getImageID();\n\tif ($id) {\n\t\t$kiwi -> info (\"Creating image ID file: $id\");\n\t\tif ( ! open (FD,\">$root/etc/ImageID\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to create ID file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$id\\n\"; close FD;\n\t\t$kiwi -> done();\n\t}\n\t#========================================\n\t# cleanup temporary copy of resolv.conf\n\t#----------------------------------------\n\tif (! -e \"$imageDesc/root/etc/resolv.conf\") {\n\t\t# restore only if overlay tree doesn't contain a resolv.conf\n\t\tif ((-f \"$root/etc/resolv.conf\") && (-f \"/etc/resolv.conf\")) {\n\t\t\tmy $data = qxx (\"diff -q /etc/resolv.conf $root/etc/resolv.conf\");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code == 0) {\n\t\t\t\t$kiwi -> info (\"Cleanup temporary copy of resolv.conf\");\n\t\t\t\tqxx (\"rm -f $root/etc/resolv.conf\");\n\t\t\t\t$kiwi -> done ();\n\t\t\t}\n\t\t}\n\t}\n\t#========================================\n\t# cleanup temporary copy of hosts\n\t#----------------------------------------\n\tif (! -e \"$imageDesc/root/etc/hosts\") {\n\t\t# restore only if overlay tree doesn't contain a hosts\n\t\tif (-f \"$root/etc/hosts.rpmnew\") {\n\t\t\t$kiwi -> info (\"Cleanup temporary copy of hosts\");\n\t\t\tqxx (\"mv $root/etc/hosts.rpmnew $root/etc/hosts\");\n\t\t\t$kiwi -> done ();\n\t\t}\n\t}\n\t#========================================\n\t# cleanup temporary .buildenv\n\t#----------------------------------------\n\tif (-f \"$root/.buildenv\") {\n\t\tqxx (\"rm -f $root/.buildenv\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# addToMountList\n#------------------------------------------\nsub addToMountList {\n\t# ...\n\t# add mount path to mount list\n\t# ---\n\tmy $this = shift;\n\tmy $path = shift;\n\tmy @mountList;\n\tif (defined $this->{mountList}) {\n\t\t@mountList = @{$this->{mountList}};\n\t} else {\n\t\t@mountList = ();\n\t}\n\tpush (@mountList,$path);\n\t$this->{mountList} = \\@mountList;\n\treturn $this;\n}\n\n#==========================================\n# setupCacheMount\n#------------------------------------------\nsub setupCacheMount {\n\t# ...\n\t# bind mount the specified cache directory into\n\t# the chroot system. This is used to establish\n\t# a shared cache over multiple prepare processes\n\t# ---\n\tmy $this  = shift;\n\tmy $root  = $this->{root};\n\tmy @cache = (\"/var/cache/zypp\",\"/var/cache/kiwi\");\n\tmy @mountList;\n\tif (defined $this->{mountList}) {\n\t\t@mountList = @{$this->{mountList}};\n\t} else {\n\t\t@mountList = ();\n\t}\n\tif (! -f \"$root/dev/console\") {\n\t\tqxx (\"mkdir -p $root/dev\");\n\t\tqxx (\"mount --bind /dev $root/dev\");\n\t\tpush (@mountList,\"$root/dev\");\n\t}\n\tforeach my $cache (@cache) {\n\t\tif (! -d $cache) {\n\t\t\tqxx (\"mkdir -p $cache\");\n\t\t}\n\t\tif (! -d \"$root/$cache\") {\n\t\t\tqxx (\"mkdir -p $root/$cache 2>&1\");\n\t\t}\n\t\tqxx (\"mount --bind $cache $root/$cache 2>&1\");\n\t\tpush (@mountList,\"$root/$cache\");\n\t}\n\tif (! -f \"$root/proc/mounts\") {\n\t\tqxx (\"mkdir -p $root/proc\");\n\t\tqxx (\"mount -t proc proc $root/proc\");\n\t\tpush (@mountList,\"$root/proc\");\n\t}\n\t$this->{mountList} = \\@mountList;\n\treturn @mountList;\n}\n\n#==========================================\n# setupMount\n#------------------------------------------\nsub setupMount {\n\t# ...\n\t# mount all reachable local and nfs directories\n\t# and register them in the mountList\n\t# ---\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $root   = $this->{root};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $prefix = $root.\"/\".$baseSystem;\n\tmy $cache  = \"/var/cache\";\n\tmy @mountList;\n\tif (defined $this->{mountList}) {\n\t\t@mountList = @{$this->{mountList}};\n\t} else {\n\t\t@mountList = ();\n\t}\n\t$kiwi -> info (\"Mounting required file systems\");\n\tif (! -d $prefix) {\n\tif (! mkdir $prefix) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Couldn't create directory: $prefix\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t} else {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Entity $prefix already exist\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! -f \"$root/proc/mounts\") {\n\t\tqxx (\"mkdir -p $root/proc\");\n\t\tqxx (\"mount -t proc proc $root/proc\");\n\t\tpush (@mountList,\"$root/proc\");\n\t}\n\tif (! -f \"$root/dev/console\") {\n\t\tqxx (\"mount --bind /dev $root/dev\");\n\t\tpush (@mountList,\"$root/dev\");\n\t}\n\tif (! -f \"$root/var/run/dbus/pid\") {\n\t\tqxx (\"mkdir -p $root/var/run/dbus\");\n\t\tqxx (\"mount --bind /var/run/dbus $root/var/run/dbus\");\n\t\tpush (@mountList,\"$root/var/run/dbus\");\n\t}\n\tif (! -d \"$root/sys/block\") {\n\t\tqxx (\"mkdir -p $root/sys\");\n\t\tqxx (\"mount -t sysfs sysfs $root/sys\");\n\t\tqxx (\"mkdir -p $root/dev/pts\");\n\t\tqxx (\"mount -t devpts devpts $root/dev/pts\");\n\t\tpush (@mountList,\"$root/sys\");\n\t\tpush (@mountList,\"$root/dev/pts\");\n\t}\n\t$this->{mountList} = \\@mountList;\n\t@mountList = $this -> setupCacheMount();\n\t$kiwi -> done();\n\tforeach my $chl (keys %{$this->{sourceChannel}{private}}) {\n\t\tmy @opts = @{$this->{sourceChannel}{private}{$chl}};\n\t\tmy $path = $opts[2];\n\t\tif ($path =~ /='$baseSystem\\/(.*)'$/) {\n\t\t\t$path = $1;\n\t\t} else {\n\t\t\tnext;\n\t\t}\n\t\t$kiwi -> info (\"Mounting local channel: $chl\");\n\t\tmy $roopt = \"dirs=$cache=rw:$path=ro,ro\";\n\t\tmy $auopt = \"dirs=$path=ro\";\n\t\tmy $mount = $prefix.$path;\n\t\tpush (@mountList,$mount);\n\t\tqxx (\"mkdir -p \\\"$mount\\\"\");\n\t\tmy $data = qxx (\"touch $path/bob 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code == 0) {\n\t\t\t#==========================================\n\t\t\t# $path is writable try overlay ro mount\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> skipped ();\n\t\t\t$kiwi -> warning (\"Path $path is writable, trying read-only mount\");\n\t\t\tqxx (\" rm -f $path/bob 2>&1 \");\n\t\t\t$data = qxx (\"mount -t aufs -o $auopt aufs $mount 2>&1\");\n\t\t\t$code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$data = qxx (\"mount -t unionfs -o $roopt unionfs $mount 2>&1\");\n\t\t\t\t$code = $? >> 8;\n\t\t\t}\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> skipped ();\n\t\t\t\t$kiwi -> warning (\"Couldn't mount read-only, using bind mount\");\n\t\t\t}\n\t\t}\n\t\tif ($code != 0) {\n\t\t\tmy $data = qxx (\" mount -o bind \\\"$path\\\" \\\"$mount\\\" 2>&1 \");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed();\n\t\t\t\t$this->{mountList} = \\@mountList;\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> done();\n\t\t}\n\t}\n\t$this->{mountList} = \\@mountList;\n\treturn $this;\n}\n\n#==========================================\n# cleanMount\n#------------------------------------------\nsub cleanMount {\n\t# ...\n\t# umount all mountList registered devices\n\t# ---\n\tmy $this = shift;\n\tmy $expr = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $xml  = $this->{xml};\n\tif (! defined $this->{mountList}) {\n\t\treturn $this;\n\t}\n\tmy @mountList  = @{$this->{mountList}};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $prefix = $root.\"/\".$baseSystem;\n\tmy @newList= ();\n\tforeach my $item (reverse @mountList) {\n\t\tif (defined $expr) {\n\t\t\tif ($item !~ /$expr/) {\n\t\t\t\tpush (@newList,$item);\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\t\t$kiwi -> loginfo (\"Umounting path: $item\\n\");\n\t\tmy $data = qxx (\"umount \\\"$item\\\" 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif (($code != 0) && ($data !~ \"not mounted\")) {\n\t\t\t$kiwi -> loginfo (\"Umount failed: $data\");\n\t\t\t$kiwi -> warning (\"Umount failed: calling lazy umount\");\n\t\t\tmy $data = qxx (\"umount -l \\\"$item\\\" 2>&1\");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed();\n\t\t\t} else {\n\t\t\t\t$kiwi -> done();\n\t\t\t}\n\t\t}\n\t\tif ($item =~ /^$prefix/) {\n\t\t\tqxx (\"rmdir -p \\\"$item\\\" 2>&1\");\n\t\t}\n\t\tif ($item =~ /^\\/tmp\\/kiwimount/) {\n\t\t\tqxx (\"rmdir -p \\\"$item\\\" 2>&1\");\n\t\t}\n\t\t\n\t}\n\tif (-d $prefix) {\n\t\trmdir $prefix;\n\t}\n\tif (defined $this->{overlay}) {\n\t\tundef $this->{overlay};\n\t}\n\t$this->{mountList} = \\@newList;\n\treturn $this;\n}\n\n#==========================================\n# cleanSource\n#------------------------------------------\nsub cleanSource {\n\t# ...\n\t# remove all source locations created by kiwi\n\t# ---\n\tmy $this = shift;\n\tmy $manager = $this->{manager};\n\t$manager -> resetSource();\n\treturn $this;\n}\n\n#==========================================\n# cleanManager\n#------------------------------------------\nsub cleanManager {\n\t# ...\n\t# remove data and cache dir(s) of the packagemanager\n\t# created for building the new root system\n\t# ---\n\tmy $this = shift;\n\tmy $manager = $this->{manager};\n\t$manager -> cleanChild();\n\treturn $this;\n}\n\n#==========================================\n# cleanLock\n#------------------------------------------\nsub cleanLock {\n\t# ...\n\t# remove stale lock files\n\t# ---\n\tmy $this = shift;\n\tmy $manager = $this->{manager};\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n1;\n"], "fixing_code": ["#================\n# FILE          : KIWIRoot.pm\n#----------------\n# PROJECT       : OpenSUSE Build-Service\n# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany\n#               :\n# AUTHOR        : Marcus Schaefer <ms@suse.de>\n#               :\n# BELONGS TO    : Operating System images\n#               :\n# DESCRIPTION   : This module is used to initialize and install\n#               : the chroot system of the image\n#               : \n#               :\n# STATUS        : Development\n#----------------\npackage KIWIRoot;\n#==========================================\n# Modules\n#------------------------------------------\nuse strict;\nuse Carp qw (cluck);\nuse File::Glob ':glob';\nuse File::Find;\nuse FileHandle;\nuse KIWIConfigure;\nuse KIWILocator;\nuse KIWILog;\nuse KIWIManager;\nuse KIWIOverlay;\nuse KIWIQX;\nuse KIWIURL;\n\n#==========================================\n# Constructor\n#------------------------------------------\nsub new {\n\t# ...\n\t# Create a new KIWIRoot object which is used for\n\t# setting up a physical extend. In principal the root\n\t# object creates a chroot environment including all\n\t# packages which makes the image\n\t# ---\n\t#==========================================\n\t# Object setup\n\t#------------------------------------------\n\tmy $this  = {};\n\tmy $class = shift;\n\tbless $this,$class;\n\t#==========================================\n\t# Module Parameters\n\t#------------------------------------------\n\tmy $kiwi = shift;\n\tmy $xml  = shift;\n\tmy $imageDesc    = shift;\n\tmy $selfRoot     = shift;\n\tmy $baseSystem   = shift;\n\tmy $useRoot      = shift;\n\tmy $addPacks     = shift;\n\tmy $delPacks     = shift;\n\tmy $cacheRoot    = shift;\n\tmy $targetArch   = shift;\n\tmy $cmdL         = shift;\n\t#==========================================\n\t# Constructor setup\n\t#------------------------------------------\n\tmy $code;\n\tif (! defined $kiwi) {\n\t\t$kiwi = new KIWILog(\"tiny\");\n\t}\n\tif (($imageDesc !~ /^\\//) && (! -d $imageDesc)) {\n\t\t$imageDesc = $this->{gdata}->{System}.\"/\".$imageDesc;\n\t}\n\tif (! defined $baseSystem) {\n\t\t$kiwi -> error (\"No base system path specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $xml) {\n\t\t$kiwi -> error (\"No XML tree specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! defined $imageDesc) {\n\t\t$kiwi -> error (\"No image path specified\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy %repository = $xml -> getRepository();\n\tif (! %repository) {\n\t\t$kiwi -> error (\"No repository specified in XML tree\");\n\t\t$kiwi -> failed ();\n\t\treturn undef; \n\t}\n\tif (! $main::global) {\n\t\t$kiwi -> error  (\"Globals object not found\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tmy $count = 1;\n\tmy %sourceChannel = ();\n\t#==========================================\n\t# Create sourceChannel hash\n\t#------------------------------------------\n\tforeach my $source (keys %repository) {\n\t\tmy $type = $repository{$source}[0];\n\t\tmy $alias= $repository{$source}[1];\n\t\tmy $prio = $repository{$source}[2];\n\t\tmy $user = $repository{$source}[3];\n\t\tmy $pwd  = $repository{$source}[4];\n\t\tmy $plic = $repository{$source}[5];\n\t\tmy $imgincl = $repository{$source}[6];\n\t\tmy $urlHandler  = new KIWIURL ($kiwi,$cmdL,$this,$user,$pwd);\n\t\tmy $publics_url = $urlHandler -> normalizePath ($source);\n\t\tif ($publics_url =~ /^\\//) {\n\t\t\tmy ( $publics_url_test ) = bsd_glob ( $publics_url );\n\t\t\tif (! -d $publics_url_test) {\n\t\t\t\t$kiwi ->warning (\"local URL path not found: $publics_url_test\");\n\t\t\t\t$kiwi ->skipped ();\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\t\tmy $private_url = $publics_url;\n\t\tif ($private_url =~ /^\\//) {\n\t\t\t$private_url = $baseSystem.\"/\".$private_url;\n\t\t}\n\t\tmy $publics_type = $urlHandler -> getRepoType();\n\t\tif (($publics_type ne \"unknown\") && ($publics_type ne $type)) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"$private_url: overwrite repo type $type with: $publics_type\"\n\t\t\t);\n\t\t\t$kiwi -> done();\n\t\t\t$type = $publics_type;\n\t\t}\n\t\t#==========================================\n\t\t# build channel name/alias...\n\t\t#------------------------------------------\n\t\tmy $channel = $alias;\n\t\tif (! $channel) {\n\t\t\t$channel = $publics_url;\n\t\t\t$channel =~ s/\\//_/g;\n\t\t\t$channel =~ s/^_//;\n\t\t\t$channel =~ s/_$//;\n\t\t}\n\t\t#==========================================\n\t\t# build source key...\n\t\t#------------------------------------------\n\t\tmy $srckey  = \"baseurl\";\n\t\tmy $srcopt;\n\t\tif (($type eq \"rpm-dir\") || ($type eq \"deb-dir\")) {\n\t\t\t$srckey = \"path\";\n\t\t\t$srcopt = \"recursive=True\";\n\t\t}\n\t\t$private_url = \"'\".$private_url.\"'\";\n\t\t$publics_url = \"'\".$publics_url.\"'\";\n\t\tmy @private_options = (\"type=$type\",\"name=$channel\",\n\t\t\t\"$srckey=$private_url\",$srcopt\n\t\t);\n\t\tmy @public_options  = (\"type=$type\",\"name=$channel\",\n\t\t\t\"$srckey=$publics_url\",$srcopt\n\t\t);\n\t\tif (($prio) && ($prio != 0)) {\n\t\t\tpush (@private_options,\"priority=$prio\");\n\t\t\tpush (@public_options ,\"priority=$prio\");\n\t\t}\n\t\tpush (@private_options,\"-y\");\n\t\tpush (@public_options ,\"-y\");\n\t\t$sourceChannel{private}{$channel} = \\@private_options;\n\t\t$sourceChannel{public}{$channel}  = \\@public_options;\n\t\t$sourceChannel{$channel}{license} = 0;\n\t\t$sourceChannel{$channel}{imgincl} = 0;\n\t\tif (($plic) && (\"$plic\" eq \"true\")) {\n\t\t\t$sourceChannel{$channel}{license} = 1;\n\t\t}\n\t\tif (($imgincl) && (\"$imgincl\" eq \"true\")) {\n\t\t\t$kiwi -> info (\"Retain $channel\\n\");\n\t\t\t$sourceChannel{$channel}{imgincl} = 1;\n\t\t}\n\t\t$count++;\n\t}\n\t#==========================================\n\t# Store object data\n\t#------------------------------------------\n\t$this->{kiwi}          = $kiwi;\n\t$this->{sourceChannel} = \\%sourceChannel;\n\t$this->{xml}           = $xml;\n\t$this->{imageDesc}     = $imageDesc;\n\t$this->{selfRoot}      = $selfRoot;\n\t$this->{baseSystem}    = $baseSystem;\n\t$this->{useRoot}       = $useRoot;\n\t$this->{addPacks}      = $addPacks;\n\t$this->{delPacks}      = $delPacks;\n\t$this->{cacheRoot}     = $cacheRoot;\n\t$this->{gdata}         = $main::global -> getGlobals();\n\t#==========================================\n\t# check channel count\n\t#------------------------------------------\n\tif ($count == 1) {\n\t\t$kiwi -> error  (\"No Channels left\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Create root directory\n\t#------------------------------------------\n\tmy $locator = new KIWILocator ($this -> {kiwi});\n\tmy $root = $locator -> createTmpDirectory (\n\t\t$useRoot,$selfRoot,$cmdL\n\t);\n\tif ( ! defined $root ) {\n\t\t$kiwi -> error (\"Couldn't create root directory: $!\");\n\t\t$kiwi -> failed ();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check for overlay structure\n\t#------------------------------------------\n\t$this->{origtree}= $root;\n\t$this->{overlay} = new KIWIOverlay ($kiwi,$root,$cacheRoot);\n\tif (! $this->{overlay}) {\n\t\treturn undef;\n\t}\n\t$root = $this->{overlay} -> mountOverlay();\n\tif (! -d $root) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Mark new root directory as broken\n\t#------------------------------------------\n\tqxx (\"touch $root/.broken 2>&1\");\n\t#==========================================\n\t# Set root log file\n\t#------------------------------------------\n\tif (! $cmdL -> getLogFile()) {\n\t\tif (-e $this->{origtree}) {\n\t\t\t$kiwi -> setRootLog ($this->{origtree}.\".\".\"$$\".\".screenrc.log\");\n\t\t} else {\n\t\t\t$kiwi -> setRootLog ($root.\".\".\"$$\".\".screenrc.log\");\n\t\t}\n\t}\n\t#==========================================\n\t# Get configured name of package manager\n\t#------------------------------------------\n\t$kiwi -> info (\"Setting up package manager: \");\n\tmy $pmgr = $xml -> getPackageManager();\n\tif (! defined $pmgr) {\n\t\t$kiwi -> failed();\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t$kiwi -> note ($pmgr);\n\t$kiwi -> done ();\n\t#==========================================\n\t# Create package manager object\n\t#------------------------------------------\n\tmy $manager = new KIWIManager (\n\t\t$kiwi,$xml,\\%sourceChannel,$root,$pmgr,$targetArch\n\t);\n\tif (! defined $manager) {\n\t\t$this -> cleanMount();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Store object data\n\t#------------------------------------------\n\t$this->{root}    = $root;\n\t$this->{manager} = $manager;\n\t$this->{cmdL}    = $cmdL;\n\treturn $this;\n}\n\n#==========================================\n# getRootPath\n#------------------------------------------\nsub getRootPath {\n\t# ...\n\t# Return chroot path for this image\n\t# ---\n\tmy $this = shift;\n\treturn $this->{root};\n}\n\n#==========================================\n# cleanBroken\n#------------------------------------------\nsub cleanBroken {\n\t# ...\n\t# Remove the .broken indicator to allow\n\t# use of this root path for image creation\n\t# ---\n\tmy $this = shift;\n\tmy $root = $this->{root};\n\tunlink $root.\"/.broken\";\n\treturn $this;\n}\n\n#==========================================\n# copyBroken\n#------------------------------------------\nsub copyBroken {\n\t# ...\n\t# copy the current logfile contents into\n\t# the .broken file below the root tree which\n\t# is indicated to be broken for some reason\n\t# mentioned in the log file\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $log  = $kiwi->getRootLog();\t\n\tif (-f $log) {\n\t\tqxx (\"cp $log $root/.broken 2>&1\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# init\n#------------------------------------------\nsub init {\n\t# ...\n\t# Initialize root system. The method will create a secured\n\t# tmp directory and extract all the given base files.\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $root = $this->{root};\n\tmy $cmdL = $this->{cmdL};\n\tmy $manager    = $this->{manager};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $FD;\n\t#==================================\n\t# Create /etc/ImageVersion file\n\t#----------------------------------\n\tmy $imageVersionFile = \"$root/etc/ImageVersion\";\n\tmy $imageVersion = $xml -> getImageVersion();\n\tmy $imageName    = $xml -> getImageName();\n\tqxx (\"mkdir -p $root/etc\");\n\tif ( ! open ($FD, \">$imageVersionFile\")) {\n\t\t$kiwi -> error (\"Failed to create version file: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tprint $FD $imageName.\"-\".$imageVersion;\n\tclose $FD;\n\t#==================================\n\t# Copy helper scripts to new root\n\t#----------------------------------\n\tqxx (\"cp $this->{gdata}->{KConfig} $root/.kconfig 2>&1\");\n\t#==================================\n\t# Return early if existing root\n\t#----------------------------------\n\tif ($cmdL -> getRecycleRootDir()) {\n\t\treturn $this;\n\t}\n\t#==================================\n\t# Return early if cache is used\n\t#----------------------------------\n\tif (($cmdL-> getCacheDir()) && (! $cmdL->getOperationMode(\"initCache\"))) {\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# Get base Package list\n\t#------------------------------------------\n\tmy @initPacs = $xml -> getBaseList();\n\tif (! @initPacs) {\n\t\t$kiwi -> error (\"Couldn't create base package list\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Setup preperation checks\n\t#------------------------------------------\n\t$manager -> switchToLocal();\n\tif (! $manager -> setupSignatureCheck()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupExcludeDocs()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==================================\n\t# Copy/touch some defaults files\n\t#----------------------------------\n\t$kiwi -> info (\"Creating default template files for new root system\");\n\tif (! defined $this->{cacheRoot}) {\n\t\tqxx (\"mkdir -p $root/dev\");\n\t\tqxx (\"mkdir -m 755 -p $root/dev/pts\");\n\t\tqxx (\"mknod -m 666 $root/dev/null c 1 3\");\n\t\tqxx (\"mknod -m 666 $root/dev/zero c 1 5\");\n\t\tqxx (\"mknod -m 622 $root/dev/full c 1 7\");\n\t\tqxx (\"mknod -m 666 $root/dev/random c 1 8\");\n\t\tqxx (\"mknod -m 644 $root/dev/urandom c 1 9\");\n\t\tqxx (\"mknod -m 666 $root/dev/tty c 5 0\");\n\t\tqxx (\"mknod -m 666 $root/dev/ptmx c 5 2\");\n\t\tqxx (\"ln -s /proc/self/fd $root/dev/fd\");\n\t\tqxx (\"ln -s fd/2 $root/dev/stderr\");\n\t\tqxx (\"ln -s fd/0 $root/dev/stdin\");\n\t\tqxx (\"ln -s fd/1 $root/dev/stdout\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop0 b 7 0\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop1 b 7 1\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop2 b 7 2\");\n\t\tqxx (\"mknod -m 640 $root/dev/loop3 b 7 3\");\n\t\tqxx (\"mkdir -p $root/etc/sysconfig\");\n\t\tqxx (\"mkdir -p $root/var/log/YaST2\");\n\t\t# for smart we need the dpkg default file\n\t\tqxx (\"mkdir -p $root/var/lib/dpkg\");\n\t\tqxx (\"touch $root/var/lib/dpkg/status\");\n\t\tqxx (\"mkdir -p $root/var/lib/dpkg/updates\");\n\t\tqxx (\"touch $root/var/lib/dpkg/available\");\n\t\t# for building in suse autobuild we need the following file\n\t\tif (-f '/.buildenv') {\n\t\t\tqxx (\"touch $root/.buildenv\");\n\t\t}\n\t\t# need mtab link for mount calls\n\t\tqxx (\"ln -s /proc/self/mounts $root/etc/mtab\");\n\t\t# need sysconfig/bootloader to make post scripts happy\n\t\tqxx (\"touch $root/etc/sysconfig/bootloader\");\n\t}\n\t# need user/group files as template\n\tmy $groupTemplate = \"/etc/group\"; \n\tmy $paswdTemplate = \"/etc/passwd\";\n\t# search for template files, add paths for different distros here\n\tmy @searchPWD = (\n\t\t\"/var/adm/fillup-templates/passwd.aaa_base\"\n\t);\n\tmy @searchGRP = (\n\t\t\"/var/adm/fillup-templates/group.aaa_base\"\n\t);\n\tforeach my $group (@searchGRP) {\n\t\tif ( -f $group ) {\n\t\t\t$groupTemplate = $group; last;\n\t\t}\n\t}\n\tforeach my $paswd (@searchPWD) {\n\t\tif ( -f $paswd ) {\n\t\t\t$paswdTemplate = $paswd; last;\n\t\t}\n\t}\n\tqxx (\" cp $groupTemplate $root/etc/group  2>&1 \");\n\tqxx (\" cp $paswdTemplate $root/etc/passwd 2>&1 \");\n\t# need resolv.conf/hosts for internal chroot name resolution\n\tqxx (\" cp /etc/resolv.conf $root/etc 2>&1 \");\n\tqxx (\" cp /etc/hosts $root/etc 2>&1 \");\n\t$kiwi -> done();\n\t#==========================================\n\t# Create package keys\n\t#------------------------------------------\n\tif (! defined $this->{cacheRoot}) {\n\t\t$manager -> setupPackageKeys();\n\t}\n\t#==========================================\n\t# Setup shared cache directory\n\t#------------------------------------------\n\t$this -> setupCacheMount();\n\t#==========================================\n\t# Add source, install and clean source\n\t#------------------------------------------\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$this -> cleanMount();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupRootSystem(@initPacs)) {\n\t\t$manager -> resetInstallationSource();\n\t\t$this -> cleanMount();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# reset installation source\n\t#------------------------------------------\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$this -> cleanMount();\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t#==========================================\n\t# Reset preperation checks\n\t#------------------------------------------\n\tif (! $manager -> resetSignatureCheck()) {\n\t\t$this -> cleanMount();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t$this -> cleanMount('(cache\\/(kiwi|zypp)$)|(dev$)');\n\t$manager -> freeLock();\n\t#==================================\n\t# Create default fstab file\n\t#----------------------------------\n\tif ( ! open (FD,\">$root/etc/fstab\")) {\n\t\t$kiwi -> error (\"Failed to create fstab file: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tprint FD \"devpts /dev/pts devpts mode=0620,gid=5 0 0\\n\";\n\tprint FD \"proc   /proc    proc   defaults        0 0\\n\";\n\tclose FD;\n\t#==================================\n\t# Return object reference\n\t#----------------------------------\n\treturn $this;\n}\n\n#==========================================\n# upgrade\n#------------------------------------------\nsub upgrade {\n\t# ...\n\t# Upgrade a previosly prepared image root tree\n\t# with respect to changes of the installation source(s)\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $manager  = $this->{manager};\n\tmy $addPacks = $this->{addPacks};\n\tmy $delPacks = $this->{delPacks};\n\t#==========================================\n\t# Mount local and NFS directories\n\t#------------------------------------------\n\t$manager -> switchToChroot();\n\tif (! $this -> setupMount ()) {\n\t\t$kiwi -> error (\"Couldn't mount base system\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# make sure name resolution works\n\t#------------------------------------------\n\t$this->{needResolvConf} = 0;\n\t$this->{needHosts} = 0;\n\tif (! -f \"$root/etc/resolv.conf\") {\n\t\tqxx (\"cp /etc/resolv.conf $root/etc 2>&1\");\n\t\t$this->{needResolvConf} = 1;\n\t}\n\tif (! -f \"$root/etc/hosts\") {\n\t\tqxx (\"cp /etc/hosts $root/etc 2>&1\");\n\t\t$this->{needHosts} = 1;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Upgrade system\n\t#------------------------------------------\n\tif (! $manager -> setupSignatureCheck()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$this -> cleanupResolvConf();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupUpgrade ($addPacks,$delPacks)) {\n\t\t$this -> cleanupResolvConf();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$this -> cleanupResolvConf();\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t$this -> cleanupResolvConf();\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n#==========================================\n# prepareTestingEnvironment\n#------------------------------------------\nsub prepareTestingEnvironment {\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $manager  = $this->{manager};\n\t#==========================================\n\t# Mount local and NFS directories\n\t#------------------------------------------\n\t$manager -> switchToChroot();\n\tif (! $this -> setupMount ()) {\n\t\t$kiwi -> error (\"Couldn't mount base system\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# make sure name resolution works\n\t#------------------------------------------\n\t$this->{needResolvConf} = 0;\n\t$this->{needHosts} = 0;\n\tif (! -f \"$root/etc/resolv.conf\") {\n\t\tqxx (\"cp /etc/resolv.conf $root/etc 2>&1\");\n\t\t$this->{needResolvConf} = 1;\n\t}\n\tif (! -f \"$root/etc/hosts\") {\n\t\tqxx (\"cp /etc/hosts $root/etc 2>&1\");\n\t\t$this->{needHosts} = 1;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Setup sources\n\t#------------------------------------------\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$this -> cleanupResolvConf();\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t$this -> cleanupResolvConf();\n\treturn $this;\n}\n\n#==========================================\n# cleanupTestingEnvironment\n#------------------------------------------\nsub cleanupTestingEnvironment {\n\tmy $this = shift;\n\tmy $root = $this->{root};\n\tmy $manager = $this->{manager};\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$this -> cleanupResolvConf();\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t$this -> cleanupResolvConf();\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n#==========================================\n# cleanupResolvConf\n#------------------------------------------\nsub cleanupResolvConf {\n\tmy $this = shift;\n\tmy $root = $this->{root};\n\tmy $needResolvConf = $this->{needResolvConf};\n\tmy $needHosts = $this->{needHosts};\n\tif ($needResolvConf) {\n\t\tqxx (\"rm -f $root/etc/resolv.conf\");\n\t\tundef $this->{needResolvConf};\n\t}\n\tif ($needHosts) {\n\t\tqxx (\"rm -f $root/etc/hosts\");\n\t\tundef $this->{needHosts};\n\t}\n}\n\n#==========================================\n# installTestingPackages\n#------------------------------------------\nsub installTestingPackages {\n\tmy $this = shift;\n\tmy $pack = shift;\n\tmy $manager  = $this->{manager};\n\tif (! $manager -> installPackages ($pack)) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# uninstallTestingPackages\n#------------------------------------------\nsub uninstallTestingPackages {\n\tmy $this = shift;\n\tmy $pack = shift;\n\tmy $manager  = $this->{manager};\n\tif (! $manager -> removePackages ($pack)) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\treturn $this;\n}\n\n#==========================================\n# install\n#------------------------------------------\nsub install {\n\t# ...\n\t# Install the given package set into the root\n\t# directory of the image system\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $manager = $this->{manager};\n\tmy %type;\n\t#==========================================\n\t# Get image package list\n\t#------------------------------------------\n\tmy @packList = $manager -> setupInstallPackages;\n\t#==========================================\n\t# proceed if packlist is not empty\n\t#------------------------------------------\n\tif (! @packList) {\n\t\t$kiwi -> loginfo (\"Packlist is empty, skipping install\\n\");\n\t\treturn $this;\n\t}\n\t#==========================================\n\t# Mount local and NFS directories\n\t#------------------------------------------\n\tif (! setupMount ($this)) {\n\t\t$kiwi -> error (\"Couldn't mount base system\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check and set lock\n\t#------------------------------------------\n\t$manager -> checkExclusiveLock();\n\t$manager -> setLock();\n\t#==========================================\n\t# Setup signature check\n\t#------------------------------------------\n\t$manager -> switchToChroot();\n\tif (! $manager -> setupSignatureCheck()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupExcludeDocs()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Add source(s) and install\n\t#------------------------------------------\n\tif (! $manager -> setupInstallationSource()) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\tif (! $manager -> setupRootSystem (@packList)) {\n\t\t$manager -> freeLock();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# reset installation source\n\t#------------------------------------------\n\t# /.../\n\t# In order to re-use an already downloaded metadata cache\n\t# we prevent kiwi from removing the package manager cache.\n\t# kiwi point the package manger to an alternative cache\n\t# directory in /var/cache/kiwi/$manager. My hope is that\n\t# there will be no conflicts if different package manager\n\t# versions uses the cache. If you find problems activate\n\t# the following code:\n\t# ----\n\t# if (! $manager -> resetInstallationSource()) {\n\t#\t$manager -> freeLock();\n\t#\treturn undef;\n\t# }\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n#==========================================\n# installArchives\n#------------------------------------------\nsub installArchives {\n\t# ...\n\t# Install the given raw archives into the root\n\t# directory of the image system\n\t# ---\n\tmy $this = shift;\n\tmy $idesc= shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $xml  = $this->{xml};\n\tmy $root = $this->{root};\n\tmy $manager = $this->{manager};\n\tif (! defined $idesc) {\n\t\t$idesc = $this->{imageDesc};\n\t}\n\t#==========================================\n\t# get image archive list\n\t#------------------------------------------\n\tmy @archives = $xml -> getArchiveList();\n\t#==========================================\n\t# Install raw data archives\n\t#------------------------------------------\n\t$manager -> switchToLocal();\n\tif (! $manager -> setupArchives($idesc,@archives)) {\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# Check ownership of archive files\n\t#------------------------------------------\n\tif (-f \"$root/bootincluded_archives.filelist\") {\n\t\t$this -> fixupOverlayFilesOwnership (\"bootincluded_archives.filelist\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# fixupOverlayFilesOwnership\n#------------------------------------------\nsub fixupOverlayFilesOwnership {\n\t# ...\n\t# search for files and directories in the given path or\n\t# table of contents (toc) file and make sure those files\n\t# get the right ownership assigned\n\t# ---\n\tmy $this  = shift;\n\tmy $path  = shift;\n\tmy $kiwi  = $this->{kiwi};\n\tmy $root  = $this->{root};\n\tmy $item  = $root.\"/\".$path;\n\tmy $prefix= \"FixupOwner\";\n\tmy @files = ();\n\tmy %except= ();\n\tif (-d $item) {\n\t\t#==========================================\n\t\t# got dir, search files there\n\t\t#------------------------------------------\n\t\tsub generateWanted {\n\t\t\tmy $result = shift;\n\t\t\tmy $base   = shift;\n\t\t\treturn sub {\n\t\t\t\tmy @names = ($File::Find::name,$File::Find::dir);\n\t\t\t\tforeach my $name (@names) {\n\t\t\t\t\t$name =~ s/^$base//; $name =~ s/^\\///;\n\t\t\t\t\tpush @{$result},$name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmy $wref = generateWanted (\\@files,$root);\n\t\tfind ({ wanted => $wref, follow => 0 }, $item);\n\t} elsif (-f $item) {\n\t\t#==========================================\n\t\t# got archive, use archive toc file\n\t\t#------------------------------------------\n\t\tmy $fd = new FileHandle;\n\t\tif ($fd -> open ($item)) {\n\t\t\twhile (my $line = <$fd>) {\n\t\t\t\tchomp $line; $line =~ s/^\\///;\n\t\t\t\tpush (@files,$line);\n\t\t\t}\n\t\t\t$fd -> close();\n\t\t} else {\n\t\t\t$kiwi -> warning (\"$prefix: Failed to open $item: $!\");\n\t\t\t$kiwi -> skipped ();\n\t\t\treturn undef;\n\t\t}\n\t} else {\n\t\t$kiwi -> warning (\"$prefix: No such file or directory: $item\");\n\t\t$kiwi -> skipped ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# check file list\n\t#------------------------------------------\n\tif (! @files) {\n\t\t$kiwi -> warning (\"$prefix: No files found in: $item\");\n\t\t$kiwi -> skipped ();\n\t\treturn undef;\n\t}\n\t#==========================================\n\t# create passwd exception directories\n\t#------------------------------------------\n\tmy $fd = new FileHandle;\n\tif (! $fd -> open ($root.\"/etc/passwd\")) {\n\t\t$kiwi -> warning (\"$prefix: No passwd file found in: $root\");\n\t\t$kiwi -> skipped ();\n\t\treturn undef;\n\t}\n\twhile (my $line = <$fd>) {\n\t\tchomp $line;\n\t\tmy $name = (split (/:/,$line))[5];\n\t\t$name =~ s/\\///;\n\t\tif ($name =~ /^(bin|sbin|root)/) {\n\t\t\tnext;\n\t\t}\n\t\t$except{$name} = 1;\n\t}\n\t$fd -> close();\n\t#==========================================\n\t# walk through all files\n\t#------------------------------------------\n\tforeach my $file (@files) {\n\t\tmy $ok = 1;\n\t\t$file =~ s/^ +//;\n\t\tforeach my $exception (keys %except) {\n\t\t\tif ($file =~ /$exception/) {\n\t\t\t\t$kiwi -> loginfo (\n\t\t\t\t\t\"$prefix: $file belongs to passwd, leaving it untouched\"\n\t\t\t\t);\n\t\t\t\t$ok = 0; last;\n\t\t\t}\n\t\t}\n\t\tnext if ! $ok;\n\t\tmy $data = qxx (\"chroot $root chown -c root:root '\".$file.\"' 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> warning (\n\t\t\t\t\"$prefix: Failed to fixup ownership of $root/$file: $data\"\n\t\t\t);\n\t\t\t$kiwi -> skipped ();\n\t\t}\n\t}\n\treturn $this;\n}\n\n#==========================================\n# setup\n#------------------------------------------\nsub setup {\n\t# ...\n\t# Setup the installed system. This method will:\n\t# 1) copy the user defined files to the root tree and\n\t#    creates the .profile environment file.\n\t# 2) create .profile image environment source file\n\t# 3) import linuxrc file if required\n\t# 4) call package setup scripts from config directory\n\t# 5) calls the config.sh and package scripts within the\n\t#    chroot of the physical extend.\n\t# 6) copy the complete image description tree to\n\t#    /image which contains information to create a logical\n\t#    extend from the chroot.\n\t# 7) configure the system with methods from KIWIConfigure\n\t# 8) cleanup temporary files\n\t# ---\n\tmy $this = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $xml  = $this->{xml};\n\tmy $configFile= $xml -> getConfigName();\n\tmy $imageDesc = $this->{imageDesc};\n\tmy $manager   = $this->{manager};\n\tmy $data;\n\tmy $status;\n\t#======================================== \n\t# Consistency check\n\t#----------------------------------------\n\tif (! -d \"$root/tmp\") {\n\t\t$kiwi -> error (\"Image system seems to be broken\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t#========================================\n\t# copy license files if they exist\n\t#----------------------------------------\n\tif (-f \"$root/license.tar.gz\") {\n\t\tqxx (\"mkdir -p $root/etc/YaST2/licenses/base\");\n\t\tqxx (\"tar -C $root/etc/YaST2/licenses/base -xf $root/license.tar.gz\");\n\t\tqxx (\"rm -f $root/license.tar.gz\");\n\t}\n\t#========================================\n\t# copy user defined files to image tree\n\t#----------------------------------------\n\tif ((-d \"$imageDesc/root\") && (bsd_glob($imageDesc.'/root/*'))) {\n\t\t$kiwi -> info (\"Copying user defined files to image tree\");\n\t\t#========================================\n\t\t# copy user defined files to tmproot\n\t\t#----------------------------------------\n\t\tmkdir $root.\"/tmproot\";\n\t\tif ((-l \"$imageDesc/root/linuxrc\") || (-l \"$imageDesc/root/include\")) {\n\t\t\t$data = qxx (\n\t\t\t\t\"cp -LR --force $imageDesc/root/* $root/tmproot 2>&1\"\n\t\t\t);\n\t\t} else {\n\t\t\t$data = qxx (\n\t\t\t\t\"tar -cf - -C $imageDesc/root . | tar -x -C $root/tmproot 2>&1\"\n\t\t\t);\n\t\t}\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t#========================================\n\t\t# check tmproot ownership\n\t\t#----------------------------------------\n\t\t$this -> fixupOverlayFilesOwnership (\"tmproot\");\n\t\t#========================================\n\t\t# copy tmproot to real root (tar)\n\t\t#----------------------------------------\n\t\t$data = qxx (\"tar -cf - -C $root/tmproot . | tar -x -C $root 2>&1\");\n\t\t$code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t}\n\t\t#========================================\n\t\t# cleanup tmproot\n\t\t#----------------------------------------\n\t\tqxx (\"rm -rf $root/tmproot\");\n\t\t$kiwi -> done();\n\t}\n\t#========================================\n\t# create .profile from <image> tags\n\t#----------------------------------------\n\t$kiwi -> info (\"Create .profile for package scripts\");\n\tif (! open (FD,\">$root/.profile\")) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error  (\"Couldn't create .profile: $!\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t$kiwi -> done();\n\tmy %config = $xml -> getImageConfig();\n\tforeach my $key (keys %config) {\n\t\t$kiwi -> loginfo (\"[PROFILE]: $key=\\\"$config{$key}\\\"\\n\");\n\t\tprint FD \"$key=\\\"$config{$key}\\\"\\n\";\n\t}\n\tclose FD;\n\t#========================================\n\t# check for linuxrc\n\t#----------------------------------------\n\tif (-f \"$root/linuxrc\") {\n\t\t$kiwi -> info (\"Setting up linuxrc...\");\n\t\tmy $data = qxx (\"ln $root/linuxrc $root/init 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t}\n\t\tqxx (\"chmod u+x $root/linuxrc $root/init 2>&1\");\n\t\t$kiwi -> done ();\n\t}\n\t#========================================\n\t# call setup scripts\n\t#----------------------------------------\n\tif (-d \"$imageDesc/config\") {\n\t\t$kiwi -> info (\"Preparing package setup scripts\");\n\t\tqxx (\" mkdir -p $root/image/config \");\n\t\tqxx (\" cp $imageDesc/config/* $root/image/config 2>&1 \");\n\t\tif (! opendir (FD,\"$root/image/config\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error  (\"Couldn't open script directory: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\t$kiwi -> done();\n\t\tmy @scriptList = readdir FD;\n\t\tforeach my $script (@scriptList) {\n\t\t\tif (-f \"$root/image/config/$script\") {\n\t\t\t\tif ($manager -> setupPackageInfo ( $script )) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$kiwi -> info (\"Calling package setup script: $script\");\n\t\t\t\tqxx (\" chmod u+x $root/image/config/$script\");\n\t\t\t\tmy $data = qxx (\" chroot $root /image/config/$script 2>&1 \");\n\t\t\t\tmy $code = $? >> 8;\n\t\t\t\tif ($code != 0) {\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\t$kiwi -> info   ($data);\n\t\t\t\t\t$kiwi -> failed ();\n\t\t\t\t\treturn undef;\n\t\t\t\t} else {\n\t\t\t\t\t$kiwi -> loginfo (\"$script: $data\");\n\t\t\t\t}\n\t\t\t\tqxx (\"rm -f $root/image/config/$script\");\n\t\t\t\t$kiwi -> done ();\n\t\t\t}\n\t\t}\n\t\trmdir (\"$root/image/config\");\n\t\tclosedir FD;\n\t}\n\t#========================================\n\t# copy image description to image tree\n\t#----------------------------------------\n\tqxx (\" mkdir -p $root/image \");\n\tqxx (\" cp $configFile $root/image 2>&1 \");\n\tqxx (\" cp $imageDesc/images.sh $root/image 2>&1 \");\n\tqxx (\" cp $imageDesc/config-cdroot.tgz $root/image 2>&1 \");\n\tqxx (\" cp $imageDesc/config-cdroot.sh  $root/image 2>&1 \");\n\tqxx (\" cp $root/.profile $root/image 2>&1 \");\n\tqxx (\" chmod u+x $root/image/images.sh 2>&1\");\n\tqxx (\" chmod u+x $root/image/config-cdroot.sh 2>&1\");\n\tif (open (FD,\">$root/image/main::Prepare\")) {\n\t\tif ($imageDesc !~ /^\\//) {\n\t\t\tmy $pwd = qxx (\" pwd \"); chomp $pwd;\n\t\t\tprint FD $pwd.\"/\".$imageDesc; close FD;\n\t\t} else {\n\t\t\tprint FD $imageDesc; close FD;\n\t\t}\n\t}\n\t#========================================\n\t# configure the system\n\t#----------------------------------------\n\tmy $configure = new KIWIConfigure ( $kiwi,$xml,$root,$imageDesc );\n\tif (! defined $configure) {\n\t\treturn undef;\n\t}\n\t#========================================\n\t# setup users/groups\n\t#----------------------------------------\n\tif (! $configure -> setupUsersGroups()) {\n\t\treturn undef;\n\t}\n\t#========================================\n\t# check for yast firstboot setup file\n\t#----------------------------------------\n\t$status = $configure -> setupFirstBootYaST();\n\tif ($status eq \"failed\") {\n\t\treturn undef;\n\t}\n\t$status = $configure -> setupAutoYaST();\n\tif ($status eq \"failed\") {\n\t\treturn undef;\n\t}\n\t$status = $configure -> setupFirstBootAnaconda();\n\tif ($status eq \"failed\") {\n\t\treturn undef;\n\t}\n\t#========================================\n\t# call config.sh image script\n\t#----------------------------------------\n\tif (-e \"$imageDesc/config.sh\") {\n\t\t$kiwi -> info (\"Calling image script: config.sh\");\n\t\tqxx (\" cp $imageDesc/config.sh $root/tmp \");\n\t\t\t\tqxx (\" chmod u+x $root/tmp/config.sh \");\n\t\tmy $data = qxx (\" chroot $root /tmp/config.sh 2>&1 \");\n\t\tmy $code = $? >> 8;\n\t\tif ($code != 0) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> info   ($data);\n\t\t\treturn undef;\n\t\t} else {\n\t\t\t$kiwi -> loginfo (\"config.sh: $data\");\n\t\t}\n\t\tqxx (\" rm -f $root/tmp/config.sh \");\n\t\t$kiwi -> done ();\n\t}\n\t#========================================\n\t# create /etc/ImageID file\n\t#----------------------------------------\n\tmy $id = $xml -> getImageID();\n\tif ($id) {\n\t\t$kiwi -> info (\"Creating image ID file: $id\");\n\t\tif ( ! open (FD,\">$root/etc/ImageID\")) {\n\t\t\t$kiwi -> failed ();\n\t\t\t$kiwi -> error (\"Failed to create ID file: $!\");\n\t\t\t$kiwi -> failed ();\n\t\t\treturn undef;\n\t\t}\n\t\tprint FD \"$id\\n\"; close FD;\n\t\t$kiwi -> done();\n\t}\n\t#========================================\n\t# cleanup temporary copy of resolv.conf\n\t#----------------------------------------\n\tif (! -e \"$imageDesc/root/etc/resolv.conf\") {\n\t\t# restore only if overlay tree doesn't contain a resolv.conf\n\t\tif ((-f \"$root/etc/resolv.conf\") && (-f \"/etc/resolv.conf\")) {\n\t\t\tmy $data = qxx (\"diff -q /etc/resolv.conf $root/etc/resolv.conf\");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code == 0) {\n\t\t\t\t$kiwi -> info (\"Cleanup temporary copy of resolv.conf\");\n\t\t\t\tqxx (\"rm -f $root/etc/resolv.conf\");\n\t\t\t\t$kiwi -> done ();\n\t\t\t}\n\t\t}\n\t}\n\t#========================================\n\t# cleanup temporary copy of hosts\n\t#----------------------------------------\n\tif (! -e \"$imageDesc/root/etc/hosts\") {\n\t\t# restore only if overlay tree doesn't contain a hosts\n\t\tif (-f \"$root/etc/hosts.rpmnew\") {\n\t\t\t$kiwi -> info (\"Cleanup temporary copy of hosts\");\n\t\t\tqxx (\"mv $root/etc/hosts.rpmnew $root/etc/hosts\");\n\t\t\t$kiwi -> done ();\n\t\t}\n\t}\n\t#========================================\n\t# cleanup temporary .buildenv\n\t#----------------------------------------\n\tif (-f \"$root/.buildenv\") {\n\t\tqxx (\"rm -f $root/.buildenv\");\n\t}\n\treturn $this;\n}\n\n#==========================================\n# addToMountList\n#------------------------------------------\nsub addToMountList {\n\t# ...\n\t# add mount path to mount list\n\t# ---\n\tmy $this = shift;\n\tmy $path = shift;\n\tmy @mountList;\n\tif (defined $this->{mountList}) {\n\t\t@mountList = @{$this->{mountList}};\n\t} else {\n\t\t@mountList = ();\n\t}\n\tpush (@mountList,$path);\n\t$this->{mountList} = \\@mountList;\n\treturn $this;\n}\n\n#==========================================\n# setupCacheMount\n#------------------------------------------\nsub setupCacheMount {\n\t# ...\n\t# bind mount the specified cache directory into\n\t# the chroot system. This is used to establish\n\t# a shared cache over multiple prepare processes\n\t# ---\n\tmy $this  = shift;\n\tmy $root  = $this->{root};\n\tmy @cache = (\"/var/cache/zypp\",\"/var/cache/kiwi\");\n\tmy @mountList;\n\tif (defined $this->{mountList}) {\n\t\t@mountList = @{$this->{mountList}};\n\t} else {\n\t\t@mountList = ();\n\t}\n\tif (! -f \"$root/dev/console\") {\n\t\tqxx (\"mkdir -p $root/dev\");\n\t\tqxx (\"mount --bind /dev $root/dev\");\n\t\tpush (@mountList,\"$root/dev\");\n\t}\n\tforeach my $cache (@cache) {\n\t\tif (! -d $cache) {\n\t\t\tqxx (\"mkdir -p $cache\");\n\t\t}\n\t\tif (! -d \"$root/$cache\") {\n\t\t\tqxx (\"mkdir -p $root/$cache 2>&1\");\n\t\t}\n\t\tqxx (\"mount --bind $cache $root/$cache 2>&1\");\n\t\tpush (@mountList,\"$root/$cache\");\n\t}\n\tif (! -f \"$root/proc/mounts\") {\n\t\tqxx (\"mkdir -p $root/proc\");\n\t\tqxx (\"mount -t proc proc $root/proc\");\n\t\tpush (@mountList,\"$root/proc\");\n\t}\n\t$this->{mountList} = \\@mountList;\n\treturn @mountList;\n}\n\n#==========================================\n# setupMount\n#------------------------------------------\nsub setupMount {\n\t# ...\n\t# mount all reachable local and nfs directories\n\t# and register them in the mountList\n\t# ---\n\tmy $this   = shift;\n\tmy $kiwi   = $this->{kiwi};\n\tmy $root   = $this->{root};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $prefix = $root.\"/\".$baseSystem;\n\tmy $cache  = \"/var/cache\";\n\tmy @mountList;\n\tif (defined $this->{mountList}) {\n\t\t@mountList = @{$this->{mountList}};\n\t} else {\n\t\t@mountList = ();\n\t}\n\t$kiwi -> info (\"Mounting required file systems\");\n\tif (! -d $prefix) {\n\tif (! mkdir $prefix) {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Couldn't create directory: $prefix\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\t} else {\n\t\t$kiwi -> failed ();\n\t\t$kiwi -> error (\"Entity $prefix already exist\");\n\t\t$kiwi -> failed ();\n\t\treturn undef;\n\t}\n\tif (! -f \"$root/proc/mounts\") {\n\t\tqxx (\"mkdir -p $root/proc\");\n\t\tqxx (\"mount -t proc proc $root/proc\");\n\t\tpush (@mountList,\"$root/proc\");\n\t}\n\tif (! -f \"$root/dev/console\") {\n\t\tqxx (\"mount --bind /dev $root/dev\");\n\t\tpush (@mountList,\"$root/dev\");\n\t}\n\tif (! -f \"$root/var/run/dbus/pid\") {\n\t\tqxx (\"mkdir -p $root/var/run/dbus\");\n\t\tqxx (\"mount --bind /var/run/dbus $root/var/run/dbus\");\n\t\tpush (@mountList,\"$root/var/run/dbus\");\n\t}\n\tif (! -d \"$root/sys/block\") {\n\t\tqxx (\"mkdir -p $root/sys\");\n\t\tqxx (\"mount -t sysfs sysfs $root/sys\");\n\t\tqxx (\"mkdir -p $root/dev/pts\");\n\t\tqxx (\"mount -t devpts devpts $root/dev/pts\");\n\t\tpush (@mountList,\"$root/sys\");\n\t\tpush (@mountList,\"$root/dev/pts\");\n\t}\n\t$this->{mountList} = \\@mountList;\n\t@mountList = $this -> setupCacheMount();\n\t$kiwi -> done();\n\tforeach my $chl (keys %{$this->{sourceChannel}{private}}) {\n\t\tmy @opts = @{$this->{sourceChannel}{private}{$chl}};\n\t\tmy $path = $opts[2];\n\t\tif ($path =~ /='$baseSystem\\/(.*)'$/) {\n\t\t\t$path = $1;\n\t\t} else {\n\t\t\tnext;\n\t\t}\n\t\t$kiwi -> info (\"Mounting local channel: $chl\");\n\t\tmy $roopt = \"dirs=$cache=rw:$path=ro,ro\";\n\t\tmy $auopt = \"dirs=$path=ro\";\n\t\tmy $mount = $prefix.$path;\n\t\tpush (@mountList,$mount);\n\t\tqxx (\"mkdir -p \\\"$mount\\\"\");\n\t\tmy $data = qxx (\"touch $path/bob 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif ($code == 0) {\n\t\t\t#==========================================\n\t\t\t# $path is writable try overlay ro mount\n\t\t\t#------------------------------------------\n\t\t\t$kiwi -> skipped ();\n\t\t\t$kiwi -> warning (\"Path $path is writable, trying read-only mount\");\n\t\t\tqxx (\" rm -f $path/bob 2>&1 \");\n\t\t\t$data = qxx (\"mount -t aufs -o $auopt aufs $mount 2>&1\");\n\t\t\t$code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$data = qxx (\"mount -t unionfs -o $roopt unionfs $mount 2>&1\");\n\t\t\t\t$code = $? >> 8;\n\t\t\t}\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> skipped ();\n\t\t\t\t$kiwi -> warning (\"Couldn't mount read-only, using bind mount\");\n\t\t\t}\n\t\t}\n\t\tif ($code != 0) {\n\t\t\tmy $data = qxx (\" mount -o bind \\\"$path\\\" \\\"$mount\\\" 2>&1 \");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed();\n\t\t\t\t$this->{mountList} = \\@mountList;\n\t\t\t\treturn undef;\n\t\t\t}\n\t\t\t$kiwi -> done();\n\t\t} else {\n\t\t\t$kiwi -> done();\n\t\t}\n\t}\n\t$this->{mountList} = \\@mountList;\n\treturn $this;\n}\n\n#==========================================\n# cleanMount\n#------------------------------------------\nsub cleanMount {\n\t# ...\n\t# umount all mountList registered devices\n\t# ---\n\tmy $this = shift;\n\tmy $expr = shift;\n\tmy $kiwi = $this->{kiwi};\n\tmy $root = $this->{root};\n\tmy $xml  = $this->{xml};\n\tif (! defined $this->{mountList}) {\n\t\treturn $this;\n\t}\n\tmy @mountList  = @{$this->{mountList}};\n\tmy $baseSystem = $this->{baseSystem};\n\tmy $prefix = $root.\"/\".$baseSystem;\n\tmy @newList= ();\n\tforeach my $item (reverse @mountList) {\n\t\tif (defined $expr) {\n\t\t\tif ($item !~ /$expr/) {\n\t\t\t\tpush (@newList,$item);\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\t\t$kiwi -> loginfo (\"Umounting path: $item\\n\");\n\t\tmy $data = qxx (\"umount \\\"$item\\\" 2>&1\");\n\t\tmy $code = $? >> 8;\n\t\tif (($code != 0) && ($data !~ \"not mounted\")) {\n\t\t\t$kiwi -> loginfo (\"Umount failed: $data\");\n\t\t\t$kiwi -> warning (\"Umount failed: calling lazy umount\");\n\t\t\tmy $data = qxx (\"umount -l \\\"$item\\\" 2>&1\");\n\t\t\tmy $code = $? >> 8;\n\t\t\tif ($code != 0) {\n\t\t\t\t$kiwi -> failed();\n\t\t\t} else {\n\t\t\t\t$kiwi -> done();\n\t\t\t}\n\t\t}\n\t\tif ($item =~ /^$prefix/) {\n\t\t\tqxx (\"rmdir -p \\\"$item\\\" 2>&1\");\n\t\t}\n\t\tif ($item =~ /^\\/tmp\\/kiwimount/) {\n\t\t\tqxx (\"rmdir -p \\\"$item\\\" 2>&1\");\n\t\t}\n\t\t\n\t}\n\tif (-d $prefix) {\n\t\trmdir $prefix;\n\t}\n\tif (defined $this->{overlay}) {\n\t\tundef $this->{overlay};\n\t}\n\t$this->{mountList} = \\@newList;\n\treturn $this;\n}\n\n#==========================================\n# cleanSource\n#------------------------------------------\nsub cleanSource {\n\t# ...\n\t# remove all source locations created by kiwi\n\t# ---\n\tmy $this = shift;\n\tmy $manager = $this->{manager};\n\t$manager -> resetSource();\n\treturn $this;\n}\n\n#==========================================\n# cleanManager\n#------------------------------------------\nsub cleanManager {\n\t# ...\n\t# remove data and cache dir(s) of the packagemanager\n\t# created for building the new root system\n\t# ---\n\tmy $this = shift;\n\tmy $manager = $this->{manager};\n\t$manager -> cleanChild();\n\treturn $this;\n}\n\n#==========================================\n# cleanLock\n#------------------------------------------\nsub cleanLock {\n\t# ...\n\t# remove stale lock files\n\t# ---\n\tmy $this = shift;\n\tmy $manager = $this->{manager};\n\t$manager -> freeLock();\n\treturn $this;\n}\n\n1;\n"], "filenames": ["modules/KIWIRoot.pm"], "buggy_code_start_loc": [933], "buggy_code_end_loc": [934], "fixing_code_start_loc": [933], "fixing_code_end_loc": [934], "type": "NVD-CWE-Other", "message": "kiwi before 4.98.08, as used in SUSE Studio Onsite 1.2 before 1.2.1 and SUSE Studio Extension for System z 1.2 before 1.2.1, allows attackers to execute arbitrary commands via shell metacharacters in the path of an overlay file, related to chown.", "other": {"cve": {"id": "CVE-2011-3180", "sourceIdentifier": "cve@mitre.org", "published": "2014-04-16T18:37:09.397", "lastModified": "2014-04-17T13:36:38.733", "vulnStatus": "Analyzed", "evaluatorComment": "Per: https://cwe.mitre.org/data/definitions/77.html\n\n\"CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\"", "descriptions": [{"lang": "en", "value": "kiwi before 4.98.08, as used in SUSE Studio Onsite 1.2 before 1.2.1 and SUSE Studio Extension for System z 1.2 before 1.2.1, allows attackers to execute arbitrary commands via shell metacharacters in the path of an overlay file, related to chown."}, {"lang": "es", "value": "kiwi anterior a 4.98.08, utilizado en SUSE Studio Onsite 1.2 anterior a 1.2.1 y SUSE Studio Extension para System z 1.2 anterior a 1.2.1, permite a atacantes ejecutar comandos arbitrarios a trav\u00e9s de metacaracteres de shell en la ruta de un archivo superpuesto, relacionado con chown."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:suse:kiwi:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.98.07", "matchCriteriaId": "8137440C-2C23-47E1-B0A3-6E4EA121F323"}, {"vulnerable": true, "criteria": "cpe:2.3:a:suse:studio_extension_for_system_z:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "FA8D3852-BBD8-4E26-BA67-181C29A4E97B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:suse:studio_onsite:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "E523A94D-9ECA-43C2-B96F-0D2C77D3F952"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2011-12/msg00015.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/11/02/4", "source": "cve@mitre.org"}, {"url": "https://github.com/openSUSE/kiwi/commit/f0f74b3f6ac6d47f7919aa9db380c0ad41ffe55f#", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/openSUSE/kiwi/commit/f0f74b3f6ac6d47f7919aa9db380c0ad41ffe55f#"}}