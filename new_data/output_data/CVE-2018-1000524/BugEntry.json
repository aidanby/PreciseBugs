{"buggy_code": ["/**\n *  miniSphere JavaScript game engine\n *  Copyright (c) 2015-2018, Fat Cerberus\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of miniSphere nor the names of its contributors may be\n *    used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n**/\n\n#include \"minisphere.h\"\n#include \"map_engine.h\"\n\n#include \"api.h\"\n#include \"audio.h\"\n#include \"color.h\"\n#include \"dispatch.h\"\n#include \"geometry.h\"\n#include \"image.h\"\n#include \"input.h\"\n#include \"jsal.h\"\n#include \"obstruction.h\"\n#include \"script.h\"\n#include \"spriteset.h\"\n#include \"tileset.h\"\n#include \"vanilla.h\"\n#include \"vector.h\"\n\nstatic const person_t*     s_acting_person;\nstatic mixer_t*            s_bgm_mixer = NULL;\nstatic person_t*           s_camera_person = NULL;\nstatic int                 s_camera_x = 0;\nstatic int                 s_camera_y = 0;\nstatic color_t             s_color_mask;\nstatic const person_t*     s_current_person = NULL;\nstatic int                 s_current_trigger = -1;\nstatic int                 s_current_zone = -1;\nstatic script_t*           s_def_map_scripts[MAP_SCRIPT_MAX];\nstatic script_t*           s_def_person_scripts[PERSON_SCRIPT_MAX];\nstatic bool                s_exiting = false;\nstatic color_t             s_fade_color_from;\nstatic color_t             s_fade_color_to;\nstatic int                 s_fade_frames;\nstatic int                 s_fade_progress;\nstatic int                 s_frame_rate = 0;\nstatic unsigned int        s_frames = 0;\nstatic bool                s_is_map_running = false;\nstatic lstring_t*          s_last_bgm_file = NULL;\nstatic struct map*         s_map = NULL;\nstatic sound_t*            s_map_bgm_stream = NULL;\nstatic char*               s_map_filename = NULL;\nstatic int                 s_max_deferreds = 0;\nstatic int                 s_max_persons = 0;\nstatic unsigned int        s_next_person_id = 0;\nstatic int                 s_num_deferreds = 0;\nstatic int                 s_num_persons = 0;\nstatic struct map_trigger* s_on_trigger = NULL;\nstatic unsigned int        s_queued_id = 0;\nstatic vector_t*           s_person_list = NULL;\nstatic struct player*      s_players;\nstatic script_t*           s_render_script = NULL;\nstatic int                 s_talk_button = 0;\nstatic int                 s_talk_distance = 8;\nstatic script_t*           s_update_script = NULL;\nstatic struct deferred     *s_deferreds = NULL;\nstatic person_t*           *s_persons = NULL;\n\nstruct deferred\n{\n\tscript_t* script;\n\tint       frames_left;\n};\n\nstruct map\n{\n\tint                width, height;\n\tbool               is_repeating;\n\tpoint3_t           origin;\n\tlstring_t*         bgm_file;\n\tscript_t*          scripts[MAP_SCRIPT_MAX];\n\ttileset_t*         tileset;\n\tvector_t*          triggers;\n\tvector_t*          zones;\n\tint                num_layers;\n\tint                num_persons;\n\tstruct map_layer   *layers;\n\tstruct map_person  *persons;\n};\n\nstruct map_layer\n{\n\tlstring_t*       name;\n\tbool             is_parallax;\n\tbool             is_reflective;\n\tbool             is_visible;\n\tfloat            autoscroll_x;\n\tfloat            autoscroll_y;\n\tcolor_t          color_mask;\n\tint              height;\n\tobsmap_t*        obsmap;\n\tfloat            parallax_x;\n\tfloat            parallax_y;\n\tscript_t*        render_script;\n\tstruct map_tile* tilemap;\n\tint              width;\n};\n\nstruct map_person\n{\n\tlstring_t* name;\n\tlstring_t* spriteset;\n\tint        x, y, z;\n\tlstring_t* create_script;\n\tlstring_t* destroy_script;\n\tlstring_t* command_script;\n\tlstring_t* talk_script;\n\tlstring_t* touch_script;\n};\n\nstruct map_tile\n{\n\tint tile_index;\n\tint frames_left;\n};\n\nstruct map_trigger\n{\n\tscript_t* script;\n\tint       x, y, z;\n};\n\nstruct map_zone\n{\n\tbool      is_active;\n\trect_t    bounds;\n\tint       interval;\n\tint       steps_left;\n\tint       layer;\n\tscript_t* script;\n};\n\nstruct person\n{\n\tunsigned int    id;\n\tchar*           name;\n\tint             anim_frames;\n\tchar*           direction;\n\tint             follow_distance;\n\tint             frame;\n\tbool            ignore_all_persons;\n\tbool            ignore_all_tiles;\n\tvector_t*       ignore_list;\n\tbool            is_persistent;\n\tbool            is_visible;\n\tint             layer;\n\tperson_t*       leader;\n\tcolor_t         mask;\n\tint             mv_x, mv_y;\n\tint             revert_delay;\n\tint             revert_frames;\n\tdouble          scale_x;\n\tdouble          scale_y;\n\tscript_t*       scripts[PERSON_SCRIPT_MAX];\n\tdouble          speed_x, speed_y;\n\tspriteset_t*    sprite;\n\tdouble          theta;\n\tdouble          x, y;\n\tint             x_offset, y_offset;\n\tint             max_commands;\n\tint             max_history;\n\tint             num_commands;\n\tint             num_ignores;\n\tstruct command  *commands;\n\tchar*           *ignores;\n\tstruct step     *steps;\n};\n\nstruct step\n{\n\tdouble x, y;\n};\n\nstruct command\n{\n\tint       type;\n\tbool      is_immediate;\n\tscript_t* script;\n};\n\nstruct player\n{\n\tbool      is_talk_allowed;\n\tperson_t* person;\n\tint       talk_key;\n};\n\n#pragma pack(push, 1)\nstruct rmp_header\n{\n\tchar    signature[4];\n\tint16_t version;\n\tuint8_t type;\n\tint8_t  num_layers;\n\tuint8_t reserved_1;\n\tint16_t num_entities;\n\tint16_t start_x;\n\tint16_t start_y;\n\tint8_t  start_layer;\n\tint8_t  start_direction;\n\tint16_t num_strings;\n\tint16_t num_zones;\n\tuint8_t repeat_map;\n\tuint8_t reserved[234];\n};\n\nstruct rmp_entity_header\n{\n\tuint16_t x;\n\tuint16_t y;\n\tuint16_t z;\n\tuint16_t type;\n\tuint8_t  reserved[8];\n};\n\nstruct rmp_layer_header\n{\n\tint16_t  width;\n\tint16_t  height;\n\tuint16_t flags;\n\tfloat    parallax_x;\n\tfloat    parallax_y;\n\tfloat    scrolling_x;\n\tfloat    scrolling_y;\n\tint32_t  num_segments;\n\tuint8_t  is_reflective;\n\tuint8_t  reserved[3];\n};\n\nstruct rmp_zone_header\n{\n\tuint16_t x1;\n\tuint16_t y1;\n\tuint16_t x2;\n\tuint16_t y2;\n\tuint16_t layer;\n\tuint16_t interval;\n\tuint8_t  reserved[4];\n};\n#pragma pack(pop)\n\nstatic bool                change_map           (const char* filename, bool preserve_persons);\nstatic void                command_person       (person_t* person, int command);\nstatic int                 compare_persons      (const void* a, const void* b);\nstatic void                detach_person        (const person_t* person);\nstatic bool                does_person_exist    (const person_t* person);\nstatic void                draw_persons         (int layer, bool is_flipped, int cam_x, int cam_y);\nstatic bool                enlarge_step_history (person_t* person, int new_size);\nstatic void                free_map             (struct map* map);\nstatic void                free_person          (person_t* person);\nstatic struct map_trigger* get_trigger_at       (int x, int y, int layer, int* out_index);\nstatic struct map_zone*    get_zone_at          (int x, int y, int layer, int which, int* out_index);\nstatic struct map*         load_map             (const char* path);\nstatic void                map_screen_to_layer  (int layer, int camera_x, int camera_y, int* inout_x, int* inout_y);\nstatic void                map_screen_to_map    (int camera_x, int camera_y, int* inout_x, int* inout_y);\nstatic void                process_map_input    (void);\nstatic void                record_step          (person_t* person);\nstatic void                reset_persons        (bool keep_existing);\nstatic void                set_person_name      (person_t* person, const char* name);\nstatic void                sort_persons         (void);\nstatic void                update_map_engine    (bool is_main_loop);\nstatic void                update_person        (person_t* person, bool* out_has_moved);\n\nvoid\nmap_engine_init(void)\n{\n\tint i;\n\n\tconsole_log(1, \"initializing map engine subsystem\");\n\n\taudio_init();\n\ts_bgm_mixer = mixer_new(44100, 16, 2);\n\n\tmemset(s_def_map_scripts, 0, MAP_SCRIPT_MAX * sizeof(int));\n\tmemset(s_def_person_scripts, 0, PERSON_SCRIPT_MAX * sizeof(int));\n\ts_map = NULL; s_map_filename = NULL;\n\ts_camera_person = NULL;\n\ts_players = calloc(PLAYER_MAX, sizeof(struct player));\n\tfor (i = 0; i < PLAYER_MAX; ++i)\n\t\ts_players[i].is_talk_allowed = true;\n\ts_current_trigger = -1;\n\ts_current_zone = -1;\n\ts_render_script = NULL;\n\ts_update_script = NULL;\n\ts_num_deferreds = s_max_deferreds = 0;\n\ts_deferreds = NULL;\n\ts_talk_button = 0;\n\ts_is_map_running = false;\n\ts_color_mask = mk_color(0, 0, 0, 0);\n\ts_on_trigger = NULL;\n\n\ts_num_persons = s_max_persons = 0;\n\ts_persons = NULL;\n\ts_talk_distance = 8;\n\ts_acting_person = NULL;\n\ts_current_person = NULL;\n}\n\nvoid\nmap_engine_uninit(void)\n{\n\tint i;\n\n\tconsole_log(1, \"shutting down map engine subsystem\");\n\n\tvector_free(s_person_list);\n\n\tfor (i = 0; i < s_num_deferreds; ++i)\n\t\tscript_unref(s_deferreds[i].script);\n\tfree(s_deferreds);\n\tfor (i = 0; i < MAP_SCRIPT_MAX; ++i)\n\t\tscript_unref(s_def_map_scripts[i]);\n\tscript_unref(s_update_script);\n\tscript_unref(s_render_script);\n\tfree_map(s_map);\n\tfree(s_players);\n\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tfree_person(s_persons[i]);\n\tfor (i = 0; i < PERSON_SCRIPT_MAX; ++i)\n\t\tscript_unref(s_def_person_scripts[i]);\n\tfree(s_persons);\n\n\tmixer_unref(s_bgm_mixer);\n\n\taudio_uninit();\n}\n\nvoid\nmap_engine_on_map_event(map_op_t op, script_t* script)\n{\n\tscript_t* old_script;\n\n\told_script = s_def_map_scripts[op];\n\ts_def_map_scripts[op] = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\nmap_engine_on_person_event(person_op_t op, script_t* script)\n{\n\tscript_t* old_script;\n\n\told_script = s_def_person_scripts[op];\n\ts_def_person_scripts[op] = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\nmap_engine_on_render(script_t* script)\n{\n\tscript_unref(s_render_script);\n\ts_render_script = script_ref(script);\n}\n\nvoid\nmap_engine_on_update(script_t* script)\n{\n\tscript_unref(s_update_script);\n\ts_update_script = script_ref(script);\n}\n\nconst person_t*\nmap_engine_acting_person(void)\n{\n\treturn s_acting_person;\n}\n\nconst person_t*\nmap_engine_active_person(void)\n{\n\treturn s_current_person;\n}\n\nint\nmap_engine_active_trigger(void)\n{\n\treturn s_current_trigger;\n}\n\nint\nmap_engine_active_zone(void)\n{\n\treturn s_current_zone;\n}\n\nvector_t*\nmap_engine_persons(void)\n{\n\tint i;\n\n\tif (s_person_list == NULL)\n\t\ts_person_list = vector_new(sizeof(person_t*));\n\tvector_clear(s_person_list);\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tvector_push(s_person_list, &s_persons[i]);\n\treturn s_person_list;\n}\n\nbool\nmap_engine_running(void)\n{\n\treturn s_is_map_running;\n}\n\nint\nmap_engine_get_framerate(void)\n{\n\treturn s_frame_rate;\n}\n\nperson_t*\nmap_engine_get_player(player_id_t player_id)\n{\n\treturn s_players[player_id].person;\n}\n\nperson_t*\nmap_engine_get_subject(void)\n{\n\treturn s_camera_person;\n}\n\nint\nmap_engine_get_talk_button(void)\n{\n\treturn s_talk_button;\n}\n\nint\nmap_engine_get_talk_distance(void)\n{\n\treturn s_talk_distance;\n}\n\nint\nmap_engine_get_talk_key(player_id_t player_id)\n{\n\treturn s_players[player_id].talk_key;\n}\n\nvoid\nmap_engine_set_framerate(int framerate)\n{\n\ts_frame_rate = framerate;\n}\n\nvoid\nmap_engine_set_player(player_id_t player_id, person_t* person)\n{\n\tint i;\n\n\t// detach person from any other players\n\tfor (i = 0; i < PLAYER_MAX; ++i) {\n\t\tif (s_players[i].person == person)\n\t\t\ts_players[i].person = NULL;\n\t}\n\n\ts_players[player_id].person = person;\n}\n\nvoid\nmap_engine_set_subject(person_t* person)\n{\n\ts_camera_person = person;\n}\n\nvoid\nmap_engine_set_talk_button(int button_id)\n{\n\ts_talk_button = button_id;\n}\n\nvoid\nmap_engine_set_talk_distance(int distance)\n{\n\ts_talk_distance = distance;\n}\n\nvoid\nmap_engine_set_talk_key(player_id_t player_id, int key)\n{\n\ts_players[player_id].talk_key = key;\n}\n\nbool\nmap_engine_change_map(const char* filename)\n{\n\treturn change_map(filename, false);\n}\n\nvoid\nmap_engine_defer(script_t* script, int num_frames)\n{\n\tstruct deferred* deferred;\n\n\tif (++s_num_deferreds > s_max_deferreds) {\n\t\ts_max_deferreds = s_num_deferreds * 2;\n\t\ts_deferreds = realloc(s_deferreds, s_max_deferreds * sizeof(struct deferred));\n\t}\n\tdeferred = &s_deferreds[s_num_deferreds - 1];\n\tdeferred->script = script;\n\tdeferred->frames_left = num_frames;\n}\n\nvoid\nmap_engine_draw_map(void)\n{\n\tbool              is_repeating;\n\tint               cell_x;\n\tint               cell_y;\n\tint               first_cell_x;\n\tint               first_cell_y;\n\tstruct map_layer* layer;\n\tint               layer_height;\n\tint               layer_width;\n\tsize2_t           resolution;\n\tint               tile_height;\n\tint               tile_index;\n\tint               tile_width;\n\tint               off_x;\n\tint               off_y;\n\n\tint x, y, z;\n\n\tif (screen_skipping_frame(g_screen))\n\t\treturn;\n\n\tresolution = screen_size(g_screen);\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\n\t// render map layers from bottom to top (+Z = up)\n\tfor (z = 0; z < s_map->num_layers; ++z) {\n\t\tlayer = &s_map->layers[z];\n\t\tis_repeating = s_map->is_repeating || layer->is_parallax;\n\t\tlayer_width = layer->width * tile_width;\n\t\tlayer_height = layer->height * tile_height;\n\t\toff_x = 0;\n\t\toff_y = 0;\n\t\tmap_screen_to_layer(z, s_camera_x, s_camera_y, &off_x, &off_y);\n\n\t\t// render person reflections if layer is reflective\n\t\tal_hold_bitmap_drawing(true);\n\t\tif (layer->is_reflective) {\n\t\t\tif (is_repeating) {  // for small repeating maps, persons need to be repeated as well\n\t\t\t\tfor (y = 0; y < resolution.height / layer_height + 2; ++y) for (x = 0; x < resolution.width / layer_width + 2; ++x)\n\t\t\t\t\tdraw_persons(z, true, off_x - x * layer_width, off_y - y * layer_height);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdraw_persons(z, true, off_x, off_y);\n\t\t\t}\n\t\t}\n\n\t\t// render tiles, but only if the layer is visible\n\t\tif (layer->is_visible) {\n\t\t\tfirst_cell_x = off_x / tile_width;\n\t\t\tfirst_cell_y = off_y / tile_height;\n\t\t\tfor (y = 0; y < resolution.height / tile_height + 2; ++y) for (x = 0; x < resolution.width / tile_width + 2; ++x) {\n\t\t\t\tcell_x = is_repeating ? (x + first_cell_x) % layer->width : x + first_cell_x;\n\t\t\t\tcell_y = is_repeating ? (y + first_cell_y) % layer->height : y + first_cell_y;\n\t\t\t\tif (cell_x < 0 || cell_x >= layer->width || cell_y < 0 || cell_y >= layer->height)\n\t\t\t\t\tcontinue;\n\t\t\t\ttile_index = layer->tilemap[cell_x + cell_y * layer->width].tile_index;\n\t\t\t\ttileset_draw(s_map->tileset, layer->color_mask, x * tile_width - off_x % tile_width, y * tile_height - off_y % tile_height, tile_index);\n\t\t\t}\n\t\t}\n\n\t\t// render persons\n\t\tif (is_repeating) {  // for small repeating maps, persons need to be repeated as well\n\t\t\tfor (y = 0; y < resolution.height / layer_height + 2; ++y) for (x = 0; x < resolution.width / layer_width + 2; ++x)\n\t\t\t\tdraw_persons(z, false, off_x - x * layer_width, off_y - y * layer_height);\n\t\t}\n\t\telse {\n\t\t\tdraw_persons(z, false, off_x, off_y);\n\t\t}\n\t\tal_hold_bitmap_drawing(false);\n\n\t\tscript_run(layer->render_script, false);\n\t}\n\n\tal_draw_filled_rectangle(0, 0, resolution.width, resolution.height, nativecolor(s_color_mask));\n\tscript_run(s_render_script, false);\n}\n\nvoid\nmap_engine_exit(void)\n{\n\ts_exiting = true;\n}\n\nvoid\nmap_engine_fade_to(color_t color_mask, int num_frames)\n{\n\tif (num_frames > 0) {\n\t\ts_fade_color_to = color_mask;\n\t\ts_fade_color_from = s_color_mask;\n\t\ts_fade_frames = num_frames;\n\t\ts_fade_progress = 0;\n\t}\n\telse {\n\t\ts_color_mask = color_mask;\n\t\ts_fade_color_to = s_fade_color_from = color_mask;\n\t\ts_fade_progress = s_fade_frames = 0;\n\t}\n}\n\nbool\nmap_engine_start(const char* filename, int framerate)\n{\n\ts_is_map_running = true;\n\ts_exiting = false;\n\ts_color_mask = mk_color(0, 0, 0, 0);\n\ts_fade_color_to = s_fade_color_from = s_color_mask;\n\ts_fade_progress = s_fade_frames = 0;\n\tal_clear_to_color(al_map_rgba(0, 0, 0, 255));\n\ts_frame_rate = framerate;\n\tif (!change_map(filename, true))\n\t\tgoto on_error;\n\twhile (!s_exiting && jsal_vm_enabled()) {\n\t\tsphere_heartbeat(true, 1);\n\n\t\t// order of operations matches Sphere 1.x.  not sure why, but Sphere 1.x\n\t\t// checks for input AFTER an update for some reason...\n\t\tupdate_map_engine(true);\n\t\tprocess_map_input();\n\t\tmap_engine_draw_map();\n\n\t\t// don't clear the backbuffer.  the Sphere 1.x map engine has a bug where it doesn't\n\t\t// clear the backbuffer between frames; as it turns out, a good deal of of v1 code relies\n\t\t// on that behavior.\n\t\tsphere_tick(1, false, s_frame_rate);\n\t}\n\treset_persons(false);\n\ts_is_map_running = false;\n\treturn true;\n\non_error:\n\ts_is_map_running = false;\n\treturn false;\n}\n\nvoid\nmap_engine_update(void)\n{\n\tupdate_map_engine(false);\n}\n\nrect_t\nmap_bounds(void)\n{\n\trect_t bounds;\n\tint    tile_w, tile_h;\n\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tbounds.x1 = 0; bounds.y1 = 0;\n\tbounds.x2 = s_map->width * tile_w;\n\tbounds.y2 = s_map->height * tile_h;\n\treturn bounds;\n}\n\nint\nmap_layer_by_name(const char* name)\n{\n\tint i;\n\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (strcmp(name, lstr_cstr(s_map->layers[0].name)) == 0)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nint\nmap_num_layers(void)\n{\n\treturn s_map->num_layers;\n}\n\nint\nmap_num_persons(void)\n{\n\treturn s_num_persons;\n}\n\nint\nmap_num_triggers(void)\n{\n\treturn vector_len(s_map->triggers);\n}\n\nint\nmap_num_zones(void)\n{\n\treturn vector_len(s_map->zones);\n}\n\npoint3_t\nmap_origin(void)\n{\n\treturn s_map != NULL ? s_map->origin\n\t\t: mk_point3(0, 0, 0);\n}\n\nconst char*\nmap_pathname(void)\n{\n\treturn s_map ? s_map_filename : NULL;\n}\n\nperson_t*\nmap_person_by_name(const char* name)\n{\n\tint i;\n\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (strcmp(name, s_persons[i]->name) == 0)\n\t\t\treturn s_persons[i];\n\t}\n\treturn NULL;\n}\n\nint\nmap_tile_at(int x, int y, int layer)\n{\n\tint layer_h;\n\tint layer_w;\n\n\tlayer_w = s_map->layers[layer].width;\n\tlayer_h = s_map->layers[layer].height;\n\n\tif (s_map->is_repeating || s_map->layers[layer].is_parallax) {\n\t\tx = (x % layer_w + layer_w) % layer_w;\n\t\ty = (y % layer_h + layer_h) % layer_h;\n\t}\n\tif (x < 0 || y < 0 || x >= layer_w || y >= layer_h)\n\t\treturn -1;\n\treturn layer_get_tile(layer, x, y);\n}\n\ntileset_t*\nmap_tileset(void)\n{\n\treturn s_map->tileset;\n}\n\nint\nmap_trigger_at(int x, int y, int layer)\n{\n\trect_t              bounds;\n\tint                 tile_w, tile_h;\n\tstruct map_trigger* trigger;\n\n\titer_t iter;\n\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\titer = vector_enum(s_map->triggers);\n\twhile ((trigger = iter_next(&iter))) {\n\t\tif (trigger->z != layer && false)  // layer ignored for compatibility\n\t\t\tcontinue;\n\t\tbounds.x1 = trigger->x - tile_w / 2;\n\t\tbounds.y1 = trigger->y - tile_h / 2;\n\t\tbounds.x2 = bounds.x1 + tile_w;\n\t\tbounds.y2 = bounds.y1 + tile_h;\n\t\tif (is_point_in_rect(x, y, bounds))\n\t\t\treturn iter.index;\n\t}\n\treturn -1;\n}\n\npoint2_t\nmap_xy_from_screen(point2_t screen_xy)\n{\n\tint x;\n\tint y;\n\n\tx = screen_xy.x;\n\ty = screen_xy.y;\n\tmap_screen_to_map(s_camera_x, s_camera_y, &x, &y);\n\treturn mk_point2(x, y);\n}\n\nint\nmap_zone_at(int x, int y, int layer, int which)\n{\n\tstruct map_zone* zone;\n\n\titer_t iter;\n\n\titer = vector_enum(s_map->zones);\n\twhile ((zone = iter_next(&iter))) {\n\t\tif (zone->layer != layer && false)  // layer ignored for compatibility\n\t\t\tcontinue;\n\t\tif (is_point_in_rect(x, y, zone->bounds) && --which < 0)\n\t\t\treturn iter.index;\n\t}\n\treturn -1;\n}\n\npoint2_t\nmap_get_camera_xy(void)\n{\n\treturn mk_point2(s_camera_x, s_camera_y);\n}\n\nvoid\nmap_set_camera_xy(point2_t where)\n{\n\ts_camera_x = where.x;\n\ts_camera_y = where.y;\n}\n\nvoid\nmap_activate(map_op_t op, bool use_default)\n{\n\tif (use_default)\n\t\tscript_run(s_def_map_scripts[op], false);\n\tscript_run(s_map->scripts[op], false);\n}\n\nbool\nmap_add_trigger(int x, int y, int layer, script_t* script)\n{\n\tstruct map_trigger trigger;\n\n\tconsole_log(2, \"creating trigger #%d on map '%s'\", vector_len(s_map->triggers), s_map_filename);\n\tconsole_log(3, \"    location: '%s' @ (%d,%d)\", lstr_cstr(s_map->layers[layer].name), x, y);\n\n\ttrigger.x = x; trigger.y = y;\n\ttrigger.z = layer;\n\ttrigger.script = script_ref(script);\n\tif (!vector_push(s_map->triggers, &trigger))\n\t\treturn false;\n\treturn true;\n}\n\nbool\nmap_add_zone(rect_t bounds, int layer, script_t* script, int steps)\n{\n\tstruct map_zone zone;\n\n\tconsole_log(2, \"creating %u-step zone #%d on map '%s'\", steps, vector_len(s_map->zones), s_map_filename);\n\tconsole_log(3, \"    bounds: (%d,%d)-(%d,%d)\", bounds.x1, bounds.y1, bounds.x2, bounds.y2);\n\n\tmemset(&zone, 0, sizeof(struct map_zone));\n\tzone.bounds = bounds;\n\tzone.layer = layer;\n\tzone.script = script_ref(script);\n\tzone.interval = steps;\n\tzone.steps_left = 0;\n\tif (!vector_push(s_map->zones, &zone))\n\t\treturn false;\n\treturn true;\n}\n\nvoid\nmap_call_default(map_op_t op)\n{\n\tscript_run(s_def_map_scripts[op], false);\n}\n\nvoid\nmap_normalize_xy(double* inout_x, double* inout_y, int layer)\n{\n\tint tile_w, tile_h;\n\tint layer_w, layer_h;\n\n\tif (s_map == NULL)\n\t\treturn;  // can't normalize if no map loaded\n\tif (!s_map->is_repeating && !s_map->layers[layer].is_parallax)\n\t\treturn;\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tlayer_w = s_map->layers[layer].width * tile_w;\n\tlayer_h = s_map->layers[layer].height * tile_h;\n\tif (inout_x)\n\t\t*inout_x = fmod(fmod(*inout_x, layer_w) + layer_w, layer_w);\n\tif (inout_y)\n\t\t*inout_y = fmod(fmod(*inout_y, layer_h) + layer_h, layer_h);\n}\n\nvoid\nmap_remove_trigger(int trigger_index)\n{\n\tvector_remove(s_map->triggers, trigger_index);\n}\n\nvoid\nmap_remove_zone(int zone_index)\n{\n\tvector_remove(s_map->zones, zone_index);\n}\n\nvoid\nlayer_on_render(int layer, script_t* script)\n{\n\tscript_unref(s_map->layers[layer].render_script);\n\ts_map->layers[layer].render_script = script_ref(script);\n}\n\nconst char*\nlayer_name(int layer)\n{\n\treturn lstr_cstr(s_map->layers[layer].name);\n}\n\nconst obsmap_t*\nlayer_obsmap(int layer)\n{\n\treturn s_map->layers[layer].obsmap;\n}\n\nsize2_t\nlayer_size(int layer)\n{\n\tstruct map_layer* layer_data;\n\n\tlayer_data = &s_map->layers[layer];\n\treturn mk_size2(layer_data->width, layer_data->height);\n}\n\ncolor_t\nlayer_get_color_mask(int layer)\n{\n\treturn s_map->layers[layer].color_mask;\n}\n\nbool\nlayer_get_reflective(int layer)\n{\n\treturn s_map->layers[layer].is_reflective;\n}\n\nint\nlayer_get_tile(int layer, int x, int y)\n{\n\tstruct map_tile* tile;\n\tint              width;\n\n\twidth = s_map->layers[layer].width;\n\ttile = &s_map->layers[layer].tilemap[x + y * width];\n\treturn tile->tile_index;\n}\n\nbool\nlayer_get_visible(int layer)\n{\n\treturn s_map->layers[layer].is_visible;\n}\n\nvoid\nlayer_set_color_mask(int layer, color_t color)\n{\n\ts_map->layers[layer].color_mask = color;\n}\n\nvoid\nlayer_set_reflective(int layer, bool reflective)\n{\n\ts_map->layers[layer].is_reflective = reflective;\n}\n\nvoid\nlayer_set_tile(int layer, int x, int y, int tile_index)\n{\n\tstruct map_tile* tile;\n\tint              width;\n\n\twidth = s_map->layers[layer].width;\n\ttile = &s_map->layers[layer].tilemap[x + y * width];\n\ttile->tile_index = tile_index;\n\ttile->frames_left = tileset_get_delay(s_map->tileset, tile_index);\n}\n\nvoid\nlayer_set_visible(int layer, bool visible)\n{\n\ts_map->layers[layer].is_visible = visible;\n}\n\nvoid\nlayer_replace_tiles(int layer, int old_index, int new_index)\n{\n\tint              layer_h;\n\tint              layer_w;\n\tstruct map_tile* tile;\n\n\tint i_x, i_y;\n\n\tlayer_w = s_map->layers[layer].width;\n\tlayer_h = s_map->layers[layer].height;\n\tfor (i_x = 0; i_x < layer_w; ++i_x) for (i_y = 0; i_y < layer_h; ++i_y) {\n\t\ttile = &s_map->layers[layer].tilemap[i_x + i_y * layer_w];\n\t\tif (tile->tile_index == old_index)\n\t\t\ttile->tile_index = new_index;\n\t}\n}\n\nbool\nlayer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n\tstruct map_tile*    tilemap;\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\n\tint x, y, i;\n\n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n\n\t// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc\n\t// because the tilemap is a 2D array.\n\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))\n\t\treturn false;\n\tfor (x = 0; x < x_size; ++x) {\n\t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the old tilemap and substitute the new one\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\t// if we resize the largest layer, the overall map size will change.\n\t// recalcuate it.\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\t// ensure zones and triggers remain in-bounds.  if any are completely\n\t// out-of-bounds, delete them.\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}\n\nperson_t*\nperson_new(const char* name, spriteset_t* spriteset, bool is_persistent, script_t* create_script)\n{\n\tpoint3_t  origin = map_origin();\n\tperson_t* person;\n\n\tif (++s_num_persons > s_max_persons) {\n\t\ts_max_persons = s_num_persons * 2;\n\t\ts_persons = realloc(s_persons, s_max_persons * sizeof(person_t*));\n\t}\n\tperson = s_persons[s_num_persons - 1] = calloc(1, sizeof(person_t));\n\tperson->id = s_next_person_id++;\n\tperson->sprite = spriteset_ref(spriteset);\n\tset_person_name(person, name);\n\tperson_set_pose(person, spriteset_pose_name(spriteset, 0));\n\tperson->is_persistent = is_persistent;\n\tperson->is_visible = true;\n\tperson->x = origin.x;\n\tperson->y = origin.y;\n\tperson->layer = origin.z;\n\tperson->speed_x = 1.0;\n\tperson->speed_y = 1.0;\n\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, 0);\n\tperson->mask = mk_color(255, 255, 255, 255);\n\tperson->scale_x = person->scale_y = 1.0;\n\tperson->scripts[PERSON_SCRIPT_ON_CREATE] = create_script;\n\tperson_activate(person, PERSON_SCRIPT_ON_CREATE, NULL, true);\n\tsort_persons();\n\treturn person;\n}\n\nvoid\nperson_free(person_t* person)\n{\n\tint i, j;\n\n\t// call the person's destroy script *before* renouncing leadership.\n\t// the destroy script may want to reassign followers (they will be orphaned otherwise), so\n\t// we want to give it a chance to do so.\n\tperson_activate(person, PERSON_SCRIPT_ON_DESTROY, NULL, true);\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i]->leader == person)\n\t\t\ts_persons[i]->leader = NULL;\n\t}\n\n\t// remove the person from the engine\n\tdetach_person(person);\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i] == person) {\n\t\t\tfor (j = i; j < s_num_persons - 1; ++j)\n\t\t\t\ts_persons[j] = s_persons[j + 1];\n\t\t\t--s_num_persons;\n\t\t\t--i;\n\t\t}\n\t}\n\n\tvector_free(person->ignore_list);\n\n\tfree_person(person);\n\tsort_persons();\n}\n\nrect_t\nperson_base(const person_t* person)\n{\n\trect_t base_rect;\n\tint    base_x;\n\tint    base_y;\n\tdouble x;\n\tdouble y;\n\n\tbase_rect = rect_zoom(spriteset_get_base(person->sprite), person->scale_x, person->scale_y);\n\tperson_get_xy(person, &x, &y, true);\n\tbase_x = x - (base_rect.x1 + (base_rect.x2 - base_rect.x1) / 2);\n\tbase_y = y - (base_rect.y1 + (base_rect.y2 - base_rect.y1) / 2);\n\tbase_rect.x1 += base_x; base_rect.x2 += base_x;\n\tbase_rect.y1 += base_y; base_rect.y2 += base_y;\n\treturn base_rect;\n}\n\nbool\nperson_following(const person_t* person, const person_t* leader)\n{\n\tconst person_t* node;\n\n\tnode = person;\n\twhile ((node = node->leader))\n\t\tif (node == leader) return true;\n\treturn false;\n}\n\nbool\nperson_has_moved(const person_t* person)\n{\n\treturn person->mv_x != 0 || person->mv_y != 0;\n}\n\nvector_t*\nperson_ignore_list(person_t* person)\n{\n\t// note: the returned vector is an array of C strings.  these should be treated\n\t//       as const char*; in other words, don't free them!\n\n\tint i;\n\n\tif (person->ignore_list == NULL)\n\t\tperson->ignore_list = vector_new(sizeof(const char*));\n\tvector_clear(person->ignore_list);\n\tfor (i = 0; i < person->num_ignores; ++i)\n\t\tvector_push(person->ignore_list, &person->ignores[i]);\n\treturn person->ignore_list;\n}\n\nbool\nperson_ignored_by(const person_t* person, const person_t* other)\n{\n\t// note: commutative; if either person ignores the other, the function will return true\n\n\tint i;\n\n\tif (other->ignore_all_persons || person->ignore_all_persons)\n\t\treturn true;\n\tfor (i = 0; i < other->num_ignores; ++i)\n\t\tif (strcmp(other->ignores[i], person->name) == 0) return true;\n\tfor (i = 0; i < person->num_ignores; ++i)\n\t\tif (strcmp(person->ignores[i], other->name) == 0) return true;\n\treturn false;\n}\n\nbool\nperson_moving(const person_t* person)\n{\n\treturn person->num_commands > 0;\n}\n\nconst char*\nperson_name(const person_t* person)\n{\n\treturn person != NULL ? person->name : \"\";\n}\n\nbool\nperson_obstructed_at(const person_t* person, double x, double y, person_t** out_obstructing_person, int* out_tile_index)\n{\n\trect_t           area;\n\trect_t           base, my_base;\n\tdouble           cur_x, cur_y;\n\tbool             is_obstructed = false;\n\tint              layer;\n\tconst obsmap_t*  obsmap;\n\tint              tile_w, tile_h;\n\tconst tileset_t* tileset;\n\n\tint i, i_x, i_y;\n\n\tmap_normalize_xy(&x, &y, person->layer);\n\tperson_get_xyz(person, &cur_x, &cur_y, &layer, true);\n\tmy_base = rect_translate(person_base(person), x - cur_x, y - cur_y);\n\tif (out_obstructing_person != NULL)\n\t\t*out_obstructing_person = NULL;\n\tif (out_tile_index != NULL)\n\t\t*out_tile_index = -1;\n\n\t// check for obstructing persons\n\tif (!person->ignore_all_persons) {\n\t\tfor (i = 0; i < s_num_persons; ++i) {\n\t\t\tif (s_persons[i] == person)  // these persons aren't going to obstruct themselves!\n\t\t\t\tcontinue;\n\t\t\tif (s_persons[i]->layer != layer)\n\t\t\t\tcontinue;  // ignore persons not on the same layer\n\t\t\tif (person_following(s_persons[i], person))\n\t\t\t\tcontinue;  // ignore own followers\n\t\t\tbase = person_base(s_persons[i]);\n\t\t\tif (do_rects_overlap(my_base, base) && !person_ignored_by(person, s_persons[i])) {\n\t\t\t\tis_obstructed = true;\n\t\t\t\tif (out_obstructing_person)\n\t\t\t\t\t*out_obstructing_person = s_persons[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// no obstructing person, check map-defined obstructions\n\tobsmap = layer_obsmap(layer);\n\tif (obsmap_test_rect(obsmap, my_base))\n\t\tis_obstructed = true;\n\n\t// check for obstructing tiles\n\t// for performance reasons, the search is constrained to the immediate vicinity\n\t// of the person's sprite base.\n\tif (!person->ignore_all_tiles) {\n\t\ttileset = map_tileset();\n\t\ttileset_get_size(tileset, &tile_w, &tile_h);\n\t\tarea.x1 = my_base.x1 / tile_w;\n\t\tarea.y1 = my_base.y1 / tile_h;\n\t\tarea.x2 = area.x1 + (my_base.x2 - my_base.x1) / tile_w + 2;\n\t\tarea.y2 = area.y1 + (my_base.y2 - my_base.y1) / tile_h + 2;\n\t\tfor (i_x = area.x1; i_x < area.x2; ++i_x) for (i_y = area.y1; i_y < area.y2; ++i_y) {\n\t\t\tbase = rect_translate(my_base, -(i_x * tile_w), -(i_y * tile_h));\n\t\t\tobsmap = tileset_obsmap(tileset, map_tile_at(i_x, i_y, layer));\n\t\t\tif (obsmap != NULL && obsmap_test_rect(obsmap, base)) {\n\t\t\t\tis_obstructed = true;\n\t\t\t\tif (out_tile_index)\n\t\t\t\t\t*out_tile_index = map_tile_at(i_x, i_y, layer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn is_obstructed;\n}\n\ndouble\nperson_get_angle(const person_t* person)\n{\n\treturn person->theta;\n}\n\ncolor_t\nperson_get_color(const person_t* person)\n{\n\treturn person->mask;\n}\n\nint\nperson_get_frame(const person_t* person)\n{\n\tint num_frames;\n\n\tnum_frames = spriteset_num_frames(person->sprite, person->direction);\n\treturn person->frame % num_frames;\n}\n\nint\nperson_get_frame_delay(const person_t* person)\n{\n\treturn person->anim_frames;\n}\n\nbool\nperson_get_ignore_persons(const person_t* person)\n{\n\treturn person->ignore_all_persons;\n}\n\nbool\nperson_get_ignore_tiles(const person_t* person)\n{\n\treturn person->ignore_all_tiles;\n}\n\nint\nperson_get_layer(const person_t* person)\n{\n\treturn person->layer;\n}\n\nperson_t*\nperson_get_leader(const person_t* person)\n{\n\treturn person->leader;\n}\n\npoint2_t\nperson_get_offset(const person_t* person)\n{\n\treturn mk_point2(person->x_offset, person->y_offset);\n}\n\nconst char*\nperson_get_pose(const person_t* person)\n{\n\treturn person->direction;\n}\n\nint\nperson_get_revert_delay(const person_t* person)\n{\n\treturn person->revert_delay;\n}\n\nvoid\nperson_get_scale(const person_t* person, double* out_scale_x, double* out_scale_y)\n{\n\t*out_scale_x = person->scale_x;\n\t*out_scale_y = person->scale_y;\n}\n\nvoid\nperson_get_speed(const person_t* person, double* out_x_speed, double* out_y_speed)\n{\n\tif (out_x_speed) *out_x_speed = person->speed_x;\n\tif (out_y_speed) *out_y_speed = person->speed_y;\n}\n\nspriteset_t*\nperson_get_spriteset(const person_t* person)\n{\n\treturn person->sprite;\n}\n\nint\nperson_get_trailing(const person_t* person)\n{\n\treturn person->follow_distance;\n}\n\nbool\nperson_get_visible(const person_t* person)\n{\n\treturn person->is_visible;\n}\n\nvoid\nperson_get_xy(const person_t* person, double* out_x, double* out_y, bool normalize)\n{\n\t*out_x = person->x;\n\t*out_y = person->y;\n\tif (normalize)\n\t\tmap_normalize_xy(out_x, out_y, person->layer);\n}\n\nvoid\nperson_get_xyz(const person_t* person, double* out_x, double* out_y, int* out_layer, bool normalize)\n{\n\t*out_x = person->x;\n\t*out_y = person->y;\n\t*out_layer = person->layer;\n\tif (normalize)\n\t\tmap_normalize_xy(out_x, out_y, *out_layer);\n}\n\nvoid\nperson_set_angle(person_t* person, double theta)\n{\n\tperson->theta = theta;\n}\n\nvoid\nperson_set_color(person_t* person, color_t mask)\n{\n\tperson->mask = mask;\n}\n\nvoid\nperson_set_frame(person_t* person, int frame_index)\n{\n\tint num_frames;\n\n\tnum_frames = spriteset_num_frames(person->sprite, person->direction);\n\tperson->frame = (frame_index % num_frames + num_frames) % num_frames;\n\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, person->frame);\n\tperson->revert_frames = person->revert_delay;\n}\n\nvoid\nperson_set_frame_delay(person_t* person, int num_frames)\n{\n\tperson->anim_frames = num_frames;\n\tperson->revert_frames = person->revert_delay;\n}\n\nvoid\nperson_set_ignore_persons(person_t* person, bool ignoring)\n{\n\tperson->ignore_all_persons = ignoring;\n}\n\nvoid\nperson_set_ignore_tiles (person_t* person, bool ignoring)\n{\n\tperson->ignore_all_tiles = ignoring;\n}\n\nvoid\nperson_set_layer(person_t* person, int layer)\n{\n\tperson->layer = layer;\n}\n\nbool\nperson_set_leader(person_t* person, person_t* leader, int distance)\n{\n\tconst person_t* node;\n\n\t// prevent circular follower chains from forming\n\tif (leader != NULL) {\n\t\tnode = leader;\n\t\tdo {\n\t\t\tif (node == person)\n\t\t\t\treturn false;\n\t\t} while ((node = node->leader));\n\t}\n\n\t// add the person as a follower (or sever existing link if leader==NULL)\n\tif (leader != NULL) {\n\t\tif (!enlarge_step_history(leader, distance))\n\t\t\treturn false;\n\t\tperson->leader = leader;\n\t\tperson->follow_distance = distance;\n\t}\n\tperson->leader = leader;\n\treturn true;\n}\n\nvoid\nperson_set_offset(person_t* person, point2_t offset)\n{\n\tperson->x_offset = offset.x;\n\tperson->y_offset = offset.y;\n}\n\nvoid\nperson_set_pose(person_t* person, const char* pose_name)\n{\n\tperson->direction = realloc(person->direction, (strlen(pose_name) + 1) * sizeof(char));\n\tstrcpy(person->direction, pose_name);\n}\n\nvoid\nperson_set_revert_delay(person_t* person, int num_frames)\n{\n\tperson->revert_delay = num_frames;\n\tperson->revert_frames = num_frames;\n}\n\nvoid\nperson_set_scale(person_t* person, double scale_x, double scale_y)\n{\n\tperson->scale_x = scale_x;\n\tperson->scale_y = scale_y;\n}\n\nvoid\nperson_set_speed(person_t* person, double x_speed, double y_speed)\n{\n\tperson->speed_x = x_speed;\n\tperson->speed_y = y_speed;\n}\n\nvoid\nperson_set_spriteset(person_t* person, spriteset_t* spriteset)\n{\n\tspriteset_t* old_spriteset;\n\n\told_spriteset = person->sprite;\n\tperson->sprite = spriteset_ref(spriteset);\n\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, 0);\n\tperson->frame = 0;\n\tspriteset_unref(old_spriteset);\n}\n\nvoid\nperson_set_trailing(person_t* person, int distance)\n{\n\tenlarge_step_history(person->leader, distance);\n\tperson->follow_distance = distance;\n}\n\nvoid\nperson_set_visible(person_t* person, bool visible)\n{\n\tperson->is_visible = visible;\n}\n\nvoid\nperson_set_xyz(person_t* person, double x, double y, int layer)\n{\n\tperson->x = x;\n\tperson->y = y;\n\tperson->layer = layer;\n\tsort_persons();\n}\n\nvoid\nperson_on_event(person_t* person, int type, script_t* script)\n{\n\tscript_unref(person->scripts[type]);\n\tperson->scripts[type] = script;\n}\n\nvoid\nperson_activate(const person_t* person, person_op_t op, const person_t* acting_person, bool use_default)\n{\n\tconst person_t* last_acting;\n\tconst person_t* last_current;\n\n\tlast_acting = s_acting_person;\n\tlast_current = s_current_person;\n\ts_acting_person = acting_person;\n\ts_current_person = person;\n\tif (use_default)\n\t\tscript_run(s_def_person_scripts[op], false);\n\tif (does_person_exist(person))\n\t\tscript_run(person->scripts[op], false);\n\ts_acting_person = last_acting;\n\ts_current_person = last_current;\n}\n\nvoid\nperson_call_default(const person_t* person, person_op_t op, const person_t* acting_person)\n{\n\tconst person_t* last_acting;\n\tconst person_t* last_current;\n\n\tlast_acting = s_acting_person;\n\tlast_current = s_current_person;\n\ts_acting_person = acting_person;\n\ts_current_person = person;\n\tscript_run(s_def_person_scripts[op], false);\n\ts_acting_person = last_acting;\n\ts_current_person = last_current;\n}\n\nvoid\nperson_clear_ignores(person_t* person)\n{\n\tint i;\n\n\tfor (i = 0; i < person->num_ignores; ++i)\n\t\tfree(person->ignores[i]);\n\tperson->num_ignores = 0;\n}\n\nvoid\nperson_clear_queue(person_t* person)\n{\n\tperson->num_commands = 0;\n}\n\nbool\nperson_compile_script(person_t* person, int type, const lstring_t* codestring)\n{\n\tscript_t*   script;\n\tconst char* script_name;\n\n\tscript_name = type == PERSON_SCRIPT_ON_CREATE ? \"onCreate\"\n\t\t: type == PERSON_SCRIPT_ON_DESTROY ? \"onDestroy\"\n\t\t: type == PERSON_SCRIPT_ON_TOUCH ? \"onTouch\"\n\t\t: type == PERSON_SCRIPT_ON_TALK ? \"onTalk\"\n\t\t: type == PERSON_SCRIPT_GENERATOR ? \"genCommands\"\n\t\t: NULL;\n\tif (script_name == NULL)\n\t\treturn false;\n\tscript = script_new(codestring, \"%s/%s/%s.js\", map_pathname(), person->name, script_name);\n\tperson_on_event(person, type, script);\n\treturn true;\n}\n\nvoid\nperson_ignore_name(person_t* person, const char* name)\n{\n\tint index;\n\n\tindex = person->num_ignores++;\n\tperson->ignores = realloc(person->ignores, person->num_ignores * sizeof(char*));\n\tperson->ignores[index] = strdup(name);\n\n\t// ignore list changed, delete cache\n\tvector_free(person->ignore_list);\n\tperson->ignore_list = NULL;\n}\n\nbool\nperson_queue_command(person_t* person, int command, bool is_immediate)\n{\n\tstruct command* commands;\n\tbool            is_aok = true;\n\n\tswitch (command) {\n\tcase COMMAND_MOVE_NORTHEAST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_NORTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_EAST, is_immediate);\n\t\treturn is_aok;\n\tcase COMMAND_MOVE_SOUTHEAST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_SOUTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_EAST, is_immediate);\n\t\treturn is_aok;\n\tcase COMMAND_MOVE_SOUTHWEST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_SOUTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_WEST, is_immediate);\n\t\treturn is_aok;\n\tcase COMMAND_MOVE_NORTHWEST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_NORTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_WEST, is_immediate);\n\t\treturn is_aok;\n\tdefault:\n\t\t++person->num_commands;\n\t\tif (person->num_commands > person->max_commands) {\n\t\t\tif (!(commands = realloc(person->commands, person->num_commands * 2 * sizeof(struct command))))\n\t\t\t\treturn false;\n\t\t\tperson->max_commands = person->num_commands * 2;\n\t\t\tperson->commands = commands;\n\t\t}\n\t\tperson->commands[person->num_commands - 1].type = command;\n\t\tperson->commands[person->num_commands - 1].is_immediate = is_immediate;\n\t\tperson->commands[person->num_commands - 1].script = NULL;\n\t\treturn true;\n\t}\n}\n\nbool\nperson_queue_script(person_t* person, script_t* script, bool is_immediate)\n{\n\t++person->num_commands;\n\tif (person->num_commands > person->max_commands) {\n\t\tperson->max_commands = person->num_commands * 2;\n\t\tif (!(person->commands = realloc(person->commands, person->max_commands * sizeof(struct command))))\n\t\t\treturn false;\n\t}\n\tperson->commands[person->num_commands - 1].type = COMMAND_RUN_SCRIPT;\n\tperson->commands[person->num_commands - 1].is_immediate = is_immediate;\n\tperson->commands[person->num_commands - 1].script = script;\n\treturn true;\n}\n\nvoid\nperson_talk(const person_t* person)\n{\n\trect_t          map_rect;\n\tperson_t*       target_person;\n\tdouble          talk_x, talk_y;\n\n\tmap_rect = map_bounds();\n\n\t// check if anyone else is within earshot\n\tperson_get_xy(person, &talk_x, &talk_y, true);\n\tif (strstr(person->direction, \"north\"))\n\t\ttalk_y -= s_talk_distance;\n\tif (strstr(person->direction, \"east\"))\n\t\ttalk_x += s_talk_distance;\n\tif (strstr(person->direction, \"south\"))\n\t\ttalk_y += s_talk_distance;\n\tif (strstr(person->direction, \"west\"))\n\t\ttalk_x -= s_talk_distance;\n\tperson_obstructed_at(person, talk_x, talk_y, &target_person, NULL);\n\n\t// if so, call their talk script\n\tif (target_person != NULL)\n\t\tperson_activate(target_person, PERSON_SCRIPT_ON_TALK, person, true);\n}\n\nvoid\ntrigger_get_xyz(int trigger_index, int* out_x, int* out_y, int* out_layer)\n{\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\tif (out_x != NULL)\n\t\t*out_x = trigger->x;\n\tif (out_y != NULL)\n\t\t*out_y = trigger->y;\n\tif (out_layer) *out_layer = trigger->z;\n}\n\nvoid\ntrigger_set_layer(int trigger_index, int layer)\n{\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\ttrigger->z = layer;\n}\n\nvoid\ntrigger_set_script(int trigger_index, script_t* script)\n{\n\tscript_t*           old_script;\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\told_script = trigger->script;\n\ttrigger->script = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\ntrigger_set_xy(int trigger_index, int x, int y)\n{\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\ttrigger->x = x;\n\ttrigger->y = y;\n}\n\nvoid\ntrigger_activate(int trigger_index)\n{\n\tint                 last_trigger;\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\tlast_trigger = s_current_trigger;\n\ts_current_trigger = trigger_index;\n\tscript_run(trigger->script, true);\n\ts_current_trigger = last_trigger;\n}\n\nrect_t\nzone_get_bounds(int zone_index)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\treturn zone->bounds;\n}\n\nint\nzone_get_layer(int zone_index)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\treturn zone->layer;\n}\n\nint\nzone_get_steps(int zone_index)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\treturn zone->interval;\n}\n\nvoid\nzone_set_bounds(int zone_index, rect_t bounds)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\trect_normalize(&bounds);\n\tzone->bounds = bounds;\n}\n\nvoid\nzone_set_layer(int zone_index, int layer)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\tzone->layer = layer;\n}\n\nvoid\nzone_set_script(int zone_index, script_t* script)\n{\n\tscript_t*        old_script;\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\told_script = zone->script;\n\tzone->script = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\nzone_set_steps(int zone_index, int interval)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\tzone->interval = interval;\n\tzone->steps_left = 0;\n}\n\nvoid\nzone_activate(int zone_index)\n{\n\tint              last_zone;\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\tlast_zone = s_current_zone;\n\ts_current_zone = zone_index;\n\tscript_run(zone->script, true);\n\ts_current_zone = last_zone;\n}\n\nstatic bool\nchange_map(const char* filename, bool preserve_persons)\n{\n\t// note: if an error is detected during a map change, change_map() will return false, but\n\t//       the map engine may be left in an inconsistent state. it is therefore probably wise\n\t//       to consider such a situation unrecoverable.\n\n\tstruct map*        map;\n\tperson_t*          person;\n\tstruct map_person* person_info;\n\tpath_t*            path;\n\tspriteset_t*       spriteset = NULL;\n\n\tint i;\n\n\tconsole_log(2, \"changing current map to '%s'\", filename);\n\n\tmap = load_map(filename);\n\tif (map == NULL) return false;\n\tif (s_map != NULL) {\n\t\t// run map exit scripts first, before loading new map\n\t\tmap_activate(MAP_SCRIPT_ON_LEAVE, true);\n\t}\n\n\t// close out old map and prep for new one\n\tfree_map(s_map); free(s_map_filename);\n\tfor (i = 0; i < s_num_deferreds; ++i)\n\t\tscript_unref(s_deferreds[i].script);\n\ts_num_deferreds = 0;\n\ts_map = map; s_map_filename = strdup(filename);\n\treset_persons(preserve_persons);\n\n\t// populate persons\n\tfor (i = 0; i < s_map->num_persons; ++i) {\n\t\tperson_info = &s_map->persons[i];\n\t\tpath = game_full_path(g_game, lstr_cstr(person_info->spriteset), \"spritesets\", true);\n\t\tspriteset = spriteset_load(path_cstr(path));\n\t\tpath_free(path);\n\t\tif (spriteset == NULL)\n\t\t\tgoto on_error;\n\t\tif (!(person = person_new(lstr_cstr(person_info->name), spriteset, false, NULL)))\n\t\t\tgoto on_error;\n\t\tspriteset_unref(spriteset);\n\t\tperson_set_xyz(person, person_info->x, person_info->y, person_info->z);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_CREATE, person_info->create_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_DESTROY, person_info->destroy_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_TOUCH, person_info->touch_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_TALK, person_info->talk_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_GENERATOR, person_info->command_script);\n\n\t\t// normally this is handled by person_new(), but since in this case the\n\t\t// person-specific create script isn't compiled until after the person is created,\n\t\t// the map engine gets the responsibility.\n\t\tperson_activate(person, PERSON_SCRIPT_ON_CREATE, NULL, false);\n\t}\n\n\t// set camera over starting position\n\ts_camera_x = s_map->origin.x;\n\ts_camera_y = s_map->origin.y;\n\n\t// start up map BGM (if same as previous, leave alone)\n\tif (s_map->bgm_file == NULL && s_map_bgm_stream != NULL) {\n\t\tsound_unref(s_map_bgm_stream);\n\t\tlstr_free(s_last_bgm_file);\n\t\ts_map_bgm_stream = NULL;\n\t\ts_last_bgm_file = NULL;\n\t}\n\telse if (s_map->bgm_file != NULL\n\t\t&& (s_last_bgm_file == NULL || lstr_cmp(s_map->bgm_file, s_last_bgm_file) != 0))\n\t{\n\t\tsound_unref(s_map_bgm_stream);\n\t\tlstr_free(s_last_bgm_file);\n\t\ts_last_bgm_file = lstr_dup(s_map->bgm_file);\n\t\tpath = game_full_path(g_game, lstr_cstr(s_map->bgm_file), \"sounds\", true);\n\t\tif ((s_map_bgm_stream = sound_new(path_cstr(path)))) {\n\t\t\tsound_set_repeat(s_map_bgm_stream, true);\n\t\t\tsound_play(s_map_bgm_stream, s_bgm_mixer);\n\t\t}\n\t\tpath_free(path);\n\t}\n\n\t// run map entry scripts\n\tmap_activate(MAP_SCRIPT_ON_ENTER, true);\n\n\ts_frames = 0;\n\treturn true;\n\non_error:\n\tspriteset_unref(spriteset);\n\tfree_map(s_map);\n\treturn false;\n}\n\nstatic void\ncommand_person(person_t* person, int command)\n{\n\tdouble    new_x;\n\tdouble    new_y;\n\tperson_t* person_to_touch;\n\n\tnew_x = person->x;\n\tnew_y = person->y;\n\tswitch (command) {\n\tcase COMMAND_ANIMATE:\n\t\tperson->revert_frames = person->revert_delay;\n\t\tif (person->anim_frames > 0 && --person->anim_frames == 0) {\n\t\t\t++person->frame;\n\t\t\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, person->frame);\n\t\t}\n\t\tbreak;\n\tcase COMMAND_FACE_NORTH:\n\t\tperson_set_pose(person, \"north\");\n\t\tbreak;\n\tcase COMMAND_FACE_NORTHEAST:\n\t\tperson_set_pose(person, \"northeast\");\n\t\tbreak;\n\tcase COMMAND_FACE_EAST:\n\t\tperson_set_pose(person, \"east\");\n\t\tbreak;\n\tcase COMMAND_FACE_SOUTHEAST:\n\t\tperson_set_pose(person, \"southeast\");\n\t\tbreak;\n\tcase COMMAND_FACE_SOUTH:\n\t\tperson_set_pose(person, \"south\");\n\t\tbreak;\n\tcase COMMAND_FACE_SOUTHWEST:\n\t\tperson_set_pose(person, \"southwest\");\n\t\tbreak;\n\tcase COMMAND_FACE_WEST:\n\t\tperson_set_pose(person, \"west\");\n\t\tbreak;\n\tcase COMMAND_FACE_NORTHWEST:\n\t\tperson_set_pose(person, \"northwest\");\n\t\tbreak;\n\tcase COMMAND_MOVE_NORTH:\n\t\tnew_y = person->y - person->speed_y;\n\t\tbreak;\n\tcase COMMAND_MOVE_EAST:\n\t\tnew_x = person->x + person->speed_x;\n\t\tbreak;\n\tcase COMMAND_MOVE_SOUTH:\n\t\tnew_y = person->y + person->speed_y;\n\t\tbreak;\n\tcase COMMAND_MOVE_WEST:\n\t\tnew_x = person->x - person->speed_x;\n\t\tbreak;\n\t}\n\tif (new_x != person->x || new_y != person->y) {\n\t\t// person is trying to move, make sure the path is clear of obstructions\n\t\tif (!person_obstructed_at(person, new_x, new_y, &person_to_touch, NULL)) {\n\t\t\tif (new_x != person->x)\n\t\t\t\tperson->mv_x = new_x > person->x ? 1 : -1;\n\t\t\tif (new_y != person->y)\n\t\t\t\tperson->mv_y = new_y > person->y ? 1 : -1;\n\t\t\tperson->x = new_x;\n\t\t\tperson->y = new_y;\n\t\t}\n\t\telse {\n\t\t\t// if not, and we collided with a person, call that person's touch script\n\t\t\tif (person_to_touch != NULL)\n\t\t\t\tperson_activate(person_to_touch, PERSON_SCRIPT_ON_TOUCH, person, true);\n\t\t}\n\t}\n}\n\nstatic int\ncompare_persons(const void* a, const void* b)\n{\n\tperson_t* p1 = *(person_t**)a;\n\tperson_t* p2 = *(person_t**)b;\n\n\tdouble x, y_p1, y_p2;\n\tint    y_delta;\n\n\tperson_get_xy(p1, &x, &y_p1, true);\n\tperson_get_xy(p2, &x, &y_p2, true);\n\ty_delta = y_p1 - y_p2;\n\tif (y_delta != 0)\n\t\treturn y_delta;\n\telse if (person_following(p1, p2))\n\t\treturn -1;\n\telse if (person_following(p2, p1))\n\t\treturn 1;\n\telse\n\t\treturn p1->id - p2->id;\n}\n\nstatic void\ndetach_person(const person_t* person)\n{\n\tint i;\n\n\tif (s_camera_person == person)\n\t\ts_camera_person = NULL;\n\tfor (i = 0; i < PLAYER_MAX; ++i) {\n\t\tif (s_players[i].person == person)\n\t\t\ts_players[i].person = NULL;\n\t}\n}\n\nstatic bool\ndoes_person_exist(const person_t* person)\n{\n\tint i;\n\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tif (person == s_persons[i]) return true;\n\treturn false;\n}\n\nvoid\ndraw_persons(int layer, bool is_flipped, int cam_x, int cam_y)\n{\n\tperson_t*    person;\n\tspriteset_t* sprite;\n\tint          w, h;\n\tdouble       x, y;\n\tint          i;\n\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tperson = s_persons[i];\n\t\tif (!person->is_visible || person->layer != layer)\n\t\t\tcontinue;\n\t\tsprite = person->sprite;\n\t\tw = spriteset_width(sprite);\n\t\th = spriteset_height(sprite);\n\t\tperson_get_xy(person, &x, &y, true);\n\t\tx -= cam_x - person->x_offset;\n\t\ty -= cam_y - person->y_offset;\n\t\tspriteset_draw(sprite, person->mask, is_flipped, person->theta, person->scale_x, person->scale_y,\n\t\t\tperson->direction, trunc(x), trunc(y), person->frame);\n\t}\n}\n\nstatic bool\nenlarge_step_history(person_t* person, int new_size)\n{\n\tstruct step *new_steps;\n\tsize_t      pastmost;\n\tdouble      last_x;\n\tdouble      last_y;\n\n\tint i;\n\n\tif (new_size > person->max_history) {\n\t\tif (!(new_steps = realloc(person->steps, new_size * sizeof(struct step))))\n\t\t\treturn false;\n\n\t\t// when enlarging the history buffer, fill new slots with pastmost values\n\t\t// (kind of like sign extension)\n\t\tpastmost = person->max_history - 1;\n\t\tlast_x = person->steps != NULL ? person->steps[pastmost].x : person->x;\n\t\tlast_y = person->steps != NULL ? person->steps[pastmost].y : person->y;\n\t\tfor (i = person->max_history; i < new_size; ++i) {\n\t\t\tnew_steps[i].x = last_x;\n\t\t\tnew_steps[i].y = last_y;\n\t\t}\n\t\tperson->steps = new_steps;\n\t\tperson->max_history = new_size;\n\t}\n\n\treturn true;\n}\n\nstatic void\nfree_map(struct map* map)\n{\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\n\titer_t iter;\n\tint    i;\n\n\tif (map == NULL)\n\t\treturn;\n\tfor (i = 0; i < MAP_SCRIPT_MAX; ++i)\n\t\tscript_unref(map->scripts[i]);\n\tfor (i = 0; i < map->num_layers; ++i) {\n\t\tscript_unref(map->layers[i].render_script);\n\t\tlstr_free(map->layers[i].name);\n\t\tfree(map->layers[i].tilemap);\n\t\tobsmap_free(map->layers[i].obsmap);\n\t}\n\tfor (i = 0; i < map->num_persons; ++i) {\n\t\tlstr_free(map->persons[i].name);\n\t\tlstr_free(map->persons[i].spriteset);\n\t\tlstr_free(map->persons[i].create_script);\n\t\tlstr_free(map->persons[i].destroy_script);\n\t\tlstr_free(map->persons[i].command_script);\n\t\tlstr_free(map->persons[i].talk_script);\n\t\tlstr_free(map->persons[i].touch_script);\n\t}\n\titer = vector_enum(s_map->triggers);\n\twhile ((trigger = iter_next(&iter)))\n\t\tscript_unref(trigger->script);\n\titer = vector_enum(s_map->zones);\n\twhile ((zone = iter_next(&iter)))\n\t\tscript_unref(zone->script);\n\tlstr_free(s_map->bgm_file);\n\ttileset_free(map->tileset);\n\tfree(map->layers);\n\tfree(map->persons);\n\tvector_free(map->triggers);\n\tvector_free(map->zones);\n\tfree(map);\n}\n\nstatic void\nfree_person(person_t* person)\n{\n\tint i;\n\n\tfree(person->steps);\n\tfor (i = 0; i < PERSON_SCRIPT_MAX; ++i)\n\t\tscript_unref(person->scripts[i]);\n\tspriteset_unref(person->sprite);\n\tfree(person->commands);\n\tfree(person->name);\n\tfree(person->direction);\n\tfree(person);\n}\n\nstatic struct map_trigger*\nget_trigger_at(int x, int y, int layer, int* out_index)\n{\n\trect_t              bounds;\n\tstruct map_trigger* found_item = NULL;\n\tint                 tile_w, tile_h;\n\tstruct map_trigger* trigger;\n\n\titer_t iter;\n\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\titer = vector_enum(s_map->triggers);\n\twhile ((trigger = iter_next(&iter))) {\n\t\tif (trigger->z != layer && false)  // layer ignored for compatibility reasons\n\t\t\tcontinue;\n\t\tbounds.x1 = trigger->x - tile_w / 2;\n\t\tbounds.y1 = trigger->y - tile_h / 2;\n\t\tbounds.x2 = bounds.x1 + tile_w;\n\t\tbounds.y2 = bounds.y1 + tile_h;\n\t\tif (is_point_in_rect(x, y, bounds)) {\n\t\t\tfound_item = trigger;\n\t\t\tif (out_index != NULL)\n\t\t\t\t*out_index = (int)iter.index;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found_item;\n}\n\nstatic struct map_zone*\nget_zone_at(int x, int y, int layer, int which, int* out_index)\n{\n\tstruct map_zone* found_item = NULL;\n\tstruct map_zone* zone;\n\n\titer_t iter;\n\tint    i;\n\n\titer = vector_enum(s_map->zones); i = -1;\n\twhile ((zone = iter_next(&iter))) {\n\t\tif (zone->layer != layer && false)  // layer ignored for compatibility\n\t\t\tcontinue;\n\t\tif (is_point_in_rect(x, y, zone->bounds) && which-- == 0) {\n\t\t\tfound_item = zone;\n\t\t\tif (out_index) *out_index = (int)iter.index;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found_item;\n}\n\nstatic struct map*\nload_map(const char* filename)\n{\n\t// strings: 0 - tileset filename\n\t//          1 - music filename\n\t//          2 - script filename (obsolete, not used)\n\t//          3 - entry script\n\t//          4 - exit script\n\t//          5 - exit north script\n\t//          6 - exit east script\n\t//          7 - exit south script\n\t//          8 - exit west script\n\n\tuint16_t                 count;\n\tstruct rmp_entity_header entity_hdr;\n\tfile_t*                  file = NULL;\n\tbool                     has_failed;\n\tstruct map_layer*        layer;\n\tstruct rmp_layer_header  layer_hdr;\n\tstruct map*              map = NULL;\n\tint                      num_tiles;\n\tstruct map_person*       person;\n\tstruct rmp_header        rmp;\n\tlstring_t*               script;\n\trect_t                   segment;\n\tint16_t*                 tile_data = NULL;\n\tpath_t*                  tileset_path;\n\ttileset_t*               tileset;\n\tstruct map_trigger       trigger;\n\tstruct map_zone          zone;\n\tstruct rmp_zone_header   zone_hdr;\n\tlstring_t*               *strings = NULL;\n\n\tint i, j, x, y, z;\n\n\tconsole_log(2, \"constructing new map from '%s'\", filename);\n\n\tmemset(&rmp, 0, sizeof(struct rmp_header));\n\n\tif (!(file = file_open(g_game, filename, \"rb\")))\n\t\tgoto on_error;\n\tmap = calloc(1, sizeof(struct map));\n\tif (file_read(file, &rmp, 1, sizeof(struct rmp_header)) != 1)\n\t\tgoto on_error;\n\tif (memcmp(rmp.signature, \".rmp\", 4) != 0) goto on_error;\n\tif (rmp.num_strings != 3 && rmp.num_strings != 5 && rmp.num_strings < 9)\n\t\tgoto on_error;\n\tif (rmp.start_layer < 0 || rmp.start_layer >= rmp.num_layers)\n\t\trmp.start_layer = 0;  // being nice here, this really should fail outright\n\tswitch (rmp.version) {\n\tcase 1:\n\t\t// load strings (resource filenames, scripts, etc.)\n\t\tstrings = calloc(rmp.num_strings, sizeof(lstring_t*));\n\t\thas_failed = false;\n\t\tfor (i = 0; i < rmp.num_strings; ++i)\n\t\t\thas_failed = has_failed || ((strings[i] = read_lstring(file, true)) == NULL);\n\t\tif (has_failed) goto on_error;\n\n\t\t// pre-allocate map structures\n\t\tmap->layers = calloc(rmp.num_layers, sizeof(struct map_layer));\n\t\tmap->persons = calloc(rmp.num_entities, sizeof(struct map_person));\n\t\tmap->triggers = vector_new(sizeof(struct map_trigger));\n\t\tmap->zones = vector_new(sizeof(struct map_zone));\n\n\t\t// load layers\n\t\tfor (i = 0; i < rmp.num_layers; ++i) {\n\t\t\tif (file_read(file, &layer_hdr, 1, sizeof(struct rmp_layer_header)) != 1)\n\t\t\t\tgoto on_error;\n\t\t\tlayer = &map->layers[i];\n\t\t\tlayer->is_parallax = (layer_hdr.flags & 2) != 0x0;\n\t\t\tlayer->is_reflective = layer_hdr.is_reflective;\n\t\t\tlayer->is_visible = (layer_hdr.flags & 1) == 0x0;\n\t\t\tlayer->color_mask = mk_color(255, 255, 255, 255);\n\t\t\tlayer->width = layer_hdr.width;\n\t\t\tlayer->height = layer_hdr.height;\n\t\t\tlayer->autoscroll_x = layer->is_parallax ? layer_hdr.scrolling_x : 0.0;\n\t\t\tlayer->autoscroll_y = layer->is_parallax ? layer_hdr.scrolling_y : 0.0;\n\t\t\tlayer->parallax_x = layer->is_parallax ? layer_hdr.parallax_x : 1.0;\n\t\t\tlayer->parallax_y = layer->is_parallax ? layer_hdr.parallax_y : 1.0;\n\t\t\tif (!layer->is_parallax) {\n\t\t\t\tmap->width = fmax(map->width, layer->width);\n\t\t\t\tmap->height = fmax(map->height, layer->height);\n\t\t\t}\n\t\t\tif (!(layer->tilemap = malloc(layer_hdr.width * layer_hdr.height * sizeof(struct map_tile))))\n\t\t\t\tgoto on_error;\n\t\t\tlayer->name = read_lstring(file, true);\n\t\t\tlayer->obsmap = obsmap_new();\n\t\t\tnum_tiles = layer_hdr.width * layer_hdr.height;\n\t\t\tif ((tile_data = malloc(num_tiles * 2)) == NULL)\n\t\t\t\tgoto on_error;\n\t\t\tif (file_read(file, tile_data, num_tiles, 2) != num_tiles)\n\t\t\t\tgoto on_error;\n\t\t\tfor (j = 0; j < num_tiles; ++j)\n\t\t\t\tlayer->tilemap[j].tile_index = tile_data[j];\n\t\t\tfor (j = 0; j < layer_hdr.num_segments; ++j) {\n\t\t\t\tif (!fread_rect32(file, &segment)) goto on_error;\n\t\t\t\tobsmap_add_line(layer->obsmap, segment);\n\t\t\t}\n\t\t\tfree(tile_data);\n\t\t\ttile_data = NULL;\n\t\t}\n\n\t\t// if either dimension is zero, the map has no non-parallax layers and is thus malformed\n\t\tif (map->width == 0 || map->height == 0)\n\t\t\tgoto on_error;\n\n\t\t// load entities\n\t\tmap->num_persons = 0;\n\t\tfor (i = 0; i < rmp.num_entities; ++i) {\n\t\t\tif (file_read(file, &entity_hdr, 1, sizeof(struct rmp_entity_header)) != 1)\n\t\t\t\tgoto on_error;\n\t\t\tif (entity_hdr.z < 0 || entity_hdr.z >= rmp.num_layers)\n\t\t\t\tentity_hdr.z = 0;\n\t\t\tswitch (entity_hdr.type) {\n\t\t\tcase 1:  // person\n\t\t\t\t++map->num_persons;\n\t\t\t\tperson = &map->persons[map->num_persons - 1];\n\t\t\t\tmemset(person, 0, sizeof(struct map_person));\n\t\t\t\tif (!(person->name = read_lstring(file, true)))\n\t\t\t\t\tgoto on_error;\n\t\t\t\tif (!(person->spriteset = read_lstring(file, true)))\n\t\t\t\t\tgoto on_error;\n\t\t\t\tperson->x = entity_hdr.x; person->y = entity_hdr.y; person->z = entity_hdr.z;\n\t\t\t\tif (file_read(file, &count, 1, 2) != 1 || count < 5)\n\t\t\t\t\tgoto on_error;\n\t\t\t\tperson->create_script = read_lstring(file, false);\n\t\t\t\tperson->destroy_script = read_lstring(file, false);\n\t\t\t\tperson->touch_script = read_lstring(file, false);\n\t\t\t\tperson->talk_script = read_lstring(file, false);\n\t\t\t\tperson->command_script = read_lstring(file, false);\n\t\t\t\tfor (j = 5; j < count; ++j)\n\t\t\t\t\tlstr_free(read_lstring(file, true));\n\t\t\t\tfile_seek(file, 16, WHENCE_CUR);\n\t\t\t\tbreak;\n\t\t\tcase 2:  // trigger\n\t\t\t\tif ((script = read_lstring(file, false)) == NULL) goto on_error;\n\t\t\t\tmemset(&trigger, 0, sizeof(struct map_trigger));\n\t\t\t\ttrigger.x = entity_hdr.x;\n\t\t\t\ttrigger.y = entity_hdr.y;\n\t\t\t\ttrigger.z = entity_hdr.z;\n\t\t\t\ttrigger.script = script_new(script, \"%s/trig%d\", filename, vector_len(map->triggers));\n\t\t\t\tif (!vector_push(map->triggers, &trigger))\n\t\t\t\t\treturn false;\n\t\t\t\tlstr_free(script);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\t// load zones\n\t\tfor (i = 0; i < rmp.num_zones; ++i) {\n\t\t\tif (file_read(file, &zone_hdr, 1, sizeof(struct rmp_zone_header)) != 1)\n\t\t\t\tgoto on_error;\n\t\t\tif ((script = read_lstring(file, false)) == NULL) goto on_error;\n\t\t\tif (zone_hdr.layer < 0 || zone_hdr.layer >= rmp.num_layers)\n\t\t\t\tzone_hdr.layer = 0;\n\t\t\tzone.layer = zone_hdr.layer;\n\t\t\tzone.bounds = mk_rect(zone_hdr.x1, zone_hdr.y1, zone_hdr.x2, zone_hdr.y2);\n\t\t\tzone.interval = zone_hdr.interval;\n\t\t\tzone.steps_left = 0;\n\t\t\tzone.script = script_new(script, \"%s/zone%d\", filename, vector_len(map->zones));\n\t\t\trect_normalize(&zone.bounds);\n\t\t\tif (!vector_push(map->zones, &zone))\n\t\t\t\treturn false;\n\t\t\tlstr_free(script);\n\t\t}\n\n\t\t// load tileset\n\t\tif (strcmp(lstr_cstr(strings[0]), \"\") != 0) {\n\t\t\ttileset_path = path_strip(path_new(filename));\n\t\t\tpath_append(tileset_path, lstr_cstr(strings[0]));\n\t\t\ttileset = tileset_new(path_cstr(tileset_path));\n\t\t\tpath_free(tileset_path);\n\t\t}\n\t\telse {\n\t\t\ttileset = tileset_read(file);\n\t\t}\n\t\tif (tileset == NULL) goto on_error;\n\n\t\t// initialize tile animation\n\t\tfor (z = 0; z < rmp.num_layers; ++z) {\n\t\t\tlayer = &map->layers[z];\n\t\t\tfor (x = 0; x < layer->width; ++x) for (y = 0; y < layer->height; ++y) {\n\t\t\t\ti = x + y * layer->width;\n\t\t\t\tmap->layers[z].tilemap[i].frames_left =\n\t\t\t\t\ttileset_get_delay(tileset, map->layers[z].tilemap[i].tile_index);\n\t\t\t}\n\t\t}\n\n\t\t// wrap things up\n\t\tmap->bgm_file = strcmp(lstr_cstr(strings[1]), \"\") != 0\n\t\t\t? lstr_dup(strings[1]) : NULL;\n\t\tmap->num_layers = rmp.num_layers;\n\t\tmap->is_repeating = rmp.repeat_map;\n\t\tmap->origin.x = rmp.start_x;\n\t\tmap->origin.y = rmp.start_y;\n\t\tmap->origin.z = rmp.start_layer;\n\t\tmap->tileset = tileset;\n\t\tif (rmp.num_strings >= 5) {\n\t\t\tmap->scripts[MAP_SCRIPT_ON_ENTER] = script_new(strings[3], \"%s/onEnter\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE] = script_new(strings[4], \"%s/onLeave\", filename);\n\t\t}\n\t\tif (rmp.num_strings >= 9) {\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_NORTH] = script_new(strings[5], \"%s/onLeave\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_EAST] = script_new(strings[6], \"%s/onLeaveEast\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_SOUTH] = script_new(strings[7], \"%s/onLeaveSouth\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_WEST] = script_new(strings[8], \"%s/onLeaveWest\", filename);\n\t\t}\n\t\tfor (i = 0; i < rmp.num_strings; ++i)\n\t\t\tlstr_free(strings[i]);\n\t\tfree(strings);\n\t\tbreak;\n\tdefault:\n\t\tgoto on_error;\n\t}\n\tfile_close(file);\n\treturn map;\n\non_error:\n\tif (file != NULL) file_close(file);\n\tfree(tile_data);\n\tif (strings != NULL) {\n\t\tfor (i = 0; i < rmp.num_strings; ++i) lstr_free(strings[i]);\n\t\tfree(strings);\n\t}\n\tif (map != NULL) {\n\t\tif (map->layers != NULL) {\n\t\t\tfor (i = 0; i < rmp.num_layers; ++i) {\n\t\t\t\tlstr_free(map->layers[i].name);\n\t\t\t\tfree(map->layers[i].tilemap);\n\t\t\t\tobsmap_free(map->layers[i].obsmap);\n\t\t\t}\n\t\t\tfree(map->layers);\n\t\t}\n\t\tif (map->persons != NULL) {\n\t\t\tfor (i = 0; i < map->num_persons; ++i) {\n\t\t\t\tlstr_free(map->persons[i].name);\n\t\t\t\tlstr_free(map->persons[i].spriteset);\n\t\t\t\tlstr_free(map->persons[i].create_script);\n\t\t\t\tlstr_free(map->persons[i].destroy_script);\n\t\t\t\tlstr_free(map->persons[i].command_script);\n\t\t\t\tlstr_free(map->persons[i].talk_script);\n\t\t\t\tlstr_free(map->persons[i].touch_script);\n\t\t\t}\n\t\t\tfree(map->persons);\n\t\t}\n\t\tvector_free(map->triggers);\n\t\tvector_free(map->zones);\n\t\tfree(map);\n\t}\n\treturn NULL;\n}\n\nvoid\nmap_screen_to_layer(int layer, int camera_x, int camera_y, int* inout_x, int* inout_y)\n{\n\trect_t  bounds;\n\tint     center_x;\n\tint     center_y;\n\tint     layer_h;\n\tint     layer_w;\n\tfloat   plx_offset_x = 0.0;\n\tint     plx_offset_y = 0.0;\n\tsize2_t resolution;\n\tint     tile_w;\n\tint     tile_h;\n\tint     x_offset;\n\tint     y_offset;\n\n\t// get layer and screen metrics\n\tresolution = screen_size(g_screen);\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tlayer_w = s_map->layers[layer].width * tile_w;\n\tlayer_h = s_map->layers[layer].height * tile_h;\n\tcenter_x = resolution.width / 2;\n\tcenter_y = resolution.height / 2;\n\n\t// initial camera correction\n\tif (!s_map->is_repeating) {\n\t\tbounds = map_bounds();\n\t\tcamera_x = fmin(fmax(camera_x, bounds.x1 + center_x), bounds.x2 - center_x);\n\t\tcamera_y = fmin(fmax(camera_y, bounds.y1 + center_y), bounds.y2 - center_y);\n\t}\n\n\t// remap screen coordinates to layer coordinates\n\tplx_offset_x = s_frames * s_map->layers[layer].autoscroll_x\n\t\t- camera_x * (s_map->layers[layer].parallax_x - 1.0);\n\tplx_offset_y = s_frames * s_map->layers[layer].autoscroll_y\n\t\t- camera_y * (s_map->layers[layer].parallax_y - 1.0);\n\tx_offset = camera_x - center_x - plx_offset_x;\n\ty_offset = camera_y - center_y - plx_offset_y;\n\tif (!s_map->is_repeating && !s_map->layers[layer].is_parallax) {\n\t\t// if the map is smaller than the screen, align to top left.  centering\n\t\t// would be better aesthetically, but there are a couple Sphere 1.x games\n\t\t// that depend on top-left justification.\n\t\tif (layer_w < resolution.width)\n\t\t\tx_offset = 0;\n\t\tif (layer_h < resolution.height)\n\t\t\ty_offset = 0;\n\t}\n\tif (inout_x != NULL)\n\t\t*inout_x += x_offset;\n\tif (inout_y != NULL)\n\t\t*inout_y += y_offset;\n\n\t// normalize coordinates. this simplifies rendering calculations.\n\tif (s_map->is_repeating || s_map->layers[layer].is_parallax) {\n\t\tif (inout_x) *inout_x = (*inout_x % layer_w + layer_w) % layer_w;\n\t\tif (inout_y) *inout_y = (*inout_y % layer_h + layer_h) % layer_h;\n\t}\n}\n\nstatic void\nmap_screen_to_map(int camera_x, int camera_y, int* inout_x, int* inout_y)\n{\n\trect_t  bounds;\n\tint     center_x;\n\tint     center_y;\n\tint     map_h;\n\tint     map_w;\n\tsize2_t resolution;\n\tint     tile_h;\n\tint     tile_w;\n\tint     x_offset;\n\tint     y_offset;\n\n\t// get layer and screen metrics\n\tresolution = screen_size(g_screen);\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tmap_w = s_map->width * tile_w;\n\tmap_h = s_map->height * tile_h;\n\tcenter_x = resolution.width / 2;\n\tcenter_y = resolution.height / 2;\n\n\t// initial camera correction\n\tif (!s_map->is_repeating) {\n\t\tbounds = map_bounds();\n\t\tcamera_x = fmin(fmax(camera_x, bounds.x1 + center_x), bounds.x2 - center_x);\n\t\tcamera_y = fmin(fmax(camera_y, bounds.y1 + center_y), bounds.y2 - center_y);\n\t}\n\n\t// remap screen coordinates to map coordinates\n\tx_offset = camera_x - center_x;\n\ty_offset = camera_y - center_y;\n\tif (!s_map->is_repeating) {\n\t\t// if the map is smaller than the screen, align to top left.  centering\n\t\t// would be better aesthetically, but there are a couple Sphere 1.x games\n\t\t// that depend on top-left justification.\n\t\tif (map_w < resolution.width)\n\t\t\tx_offset = 0;\n\t\tif (map_h < resolution.height)\n\t\t\ty_offset = 0;\n\t}\n\tif (inout_x != NULL)\n\t\t*inout_x += x_offset;\n\tif (inout_y != NULL)\n\t\t*inout_y += y_offset;\n\n\t// normalize coordinates\n\tif (s_map->is_repeating) {\n\t\tif (inout_x) *inout_x = (*inout_x % map_w + map_w) % map_w;\n\t\tif (inout_y) *inout_y = (*inout_y % map_h + map_h) % map_h;\n\t}\n}\n\nstatic void\nprocess_map_input(void)\n{\n\tint       mv_x, mv_y;\n\tperson_t* person;\n\n\tint i;\n\n\t// clear out excess keys from key queue\n\tkb_clear_queue();\n\n\t// check for player control of input persons, if there are any\n\tfor (i = 0; i < PLAYER_MAX; ++i) {\n\t\tperson = s_players[i].person;\n\t\tif (person != NULL) {\n\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_A))\n\t\t\t\t|| kb_is_key_down(s_players[i].talk_key)\n\t\t\t\t|| joy_is_button_down(i, s_talk_button))\n\t\t\t{\n\t\t\t\tif (s_players[i].is_talk_allowed)\n\t\t\t\t\tperson_talk(person);\n\t\t\t\ts_players[i].is_talk_allowed = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// allow talking again only after key is released\n\t\t\t\ts_players[i].is_talk_allowed = true;\n\t\t\t}\n\t\t\tmv_x = 0; mv_y = 0;\n\t\t\tif (person->num_commands == 0 && person->leader == NULL) {\n\t\t\t\t// allow player control only if the input person is idle and not being led around\n\t\t\t\t// by someone else.\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_UP)) || joy_position(i, 1) <= -0.5)\n\t\t\t\t\tmv_y = -1;\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_RIGHT)) || joy_position(i, 0) >= 0.5)\n\t\t\t\t\tmv_x = 1;\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_DOWN)) || joy_position(i, 1) >= 0.5)\n\t\t\t\t\tmv_y = 1;\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_LEFT)) || joy_position(i, 0) <= -0.5)\n\t\t\t\t\tmv_x = -1;\n\t\t\t}\n\t\t\tswitch (mv_x + mv_y * 3) {\n\t\t\tcase -3: // north\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_NORTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_NORTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase -2: // northeast\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_NORTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_NORTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 1: // east\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_EAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_EAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 4: // southeast\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_SOUTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_SOUTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 3: // south\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_SOUTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_SOUTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 2: // southwest\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_SOUTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_SOUTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase -1: // west\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_WEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_WEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase -4: // northwest\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_NORTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_NORTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate_bound_keys(true);\n}\n\nstatic void\nrecord_step(person_t* person)\n{\n\tstruct step* p_step;\n\n\tif (person->max_history <= 0)\n\t\treturn;\n\tmemmove(&person->steps[1], &person->steps[0], (person->max_history - 1) * sizeof(struct step));\n\tp_step = &person->steps[0];\n\tp_step->x = person->x;\n\tp_step->y = person->y;\n}\n\nvoid\nreset_persons(bool keep_existing)\n{\n\tunsigned int id;\n\tpoint3_t     origin;\n\tperson_t*    person;\n\n\tint i, j;\n\n\torigin = map_origin();\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tperson = s_persons[i];\n\t\tid = person->id;\n\t\tif (!keep_existing)\n\t\t\tperson->num_commands = 0;\n\t\tif (person->is_persistent || keep_existing) {\n\t\t\tperson->x = origin.x;\n\t\t\tperson->y = origin.y;\n\t\t\tperson->layer = origin.z;\n\t\t}\n\t\telse {\n\t\t\tperson_activate(person, PERSON_SCRIPT_ON_DESTROY, NULL, true);\n\t\t\tfree_person(person);\n\t\t\t--s_num_persons;\n\t\t\tfor (j = i; j < s_num_persons; ++j)\n\t\t\t\ts_persons[j] = s_persons[j + 1];\n\t\t\t--i;\n\t\t}\n\t}\n\tsort_persons();\n}\n\nstatic void\nset_person_name(person_t* person, const char* name)\n{\n\tperson->name = realloc(person->name, (strlen(name) + 1) * sizeof(char));\n\tstrcpy(person->name, name);\n}\n\nstatic void\nsort_persons(void)\n{\n\tqsort(s_persons, s_num_persons, sizeof(person_t*), compare_persons);\n}\n\nstatic void\nupdate_map_engine(bool in_main_loop)\n{\n\tbool                has_moved;\n\tint                 index;\n\tbool                is_sort_needed = false;\n\tint                 last_trigger;\n\tint                 last_zone;\n\tint                 layer;\n\tint                 map_w, map_h;\n\tint                 num_zone_steps;\n\tscript_t*           script_to_run;\n\tint                 script_type;\n\tdouble              start_x[PLAYER_MAX];\n\tdouble              start_y[PLAYER_MAX];\n\tint                 tile_w, tile_h;\n\tstruct map_trigger* trigger;\n\tdouble              x, y, px, py;\n\tstruct map_zone*    zone;\n\n\tint i, j, k;\n\n\t++s_frames;\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tmap_w = s_map->width * tile_w;\n\tmap_h = s_map->height * tile_h;\n\n\ttileset_update(s_map->tileset);\n\n\tfor (i = 0; i < PLAYER_MAX; ++i) if (s_players[i].person != NULL)\n\t\tperson_get_xy(s_players[i].person, &start_x[i], &start_y[i], false);\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i]->leader != NULL)\n\t\t\tcontinue;  // skip followers for now\n\t\tupdate_person(s_persons[i], &has_moved);\n\t\tis_sort_needed |= has_moved;\n\t}\n\tif (is_sort_needed)\n\t\tsort_persons();\n\n\t// update color mask fade level\n\tif (s_fade_progress < s_fade_frames) {\n\t\t++s_fade_progress;\n\t\ts_color_mask = color_mix(s_fade_color_to, s_fade_color_from,\n\t\t\ts_fade_progress, s_fade_frames - s_fade_progress);\n\t}\n\n\t// update camera\n\tif (s_camera_person != NULL) {\n\t\tperson_get_xy(s_camera_person, &x, &y, true);\n\t\ts_camera_x = x; s_camera_y = y;\n\t}\n\n\t// run edge script if the camera has moved past the edge of the map\n\t// note: only applies for non-repeating maps\n\tif (in_main_loop && !s_map->is_repeating) {\n\t\tscript_type = s_camera_y < 0 ? MAP_SCRIPT_ON_LEAVE_NORTH\n\t\t\t: s_camera_x >= map_w ? MAP_SCRIPT_ON_LEAVE_EAST\n\t\t\t: s_camera_y >= map_h ? MAP_SCRIPT_ON_LEAVE_SOUTH\n\t\t\t: s_camera_x < 0 ? MAP_SCRIPT_ON_LEAVE_WEST\n\t\t\t: MAP_SCRIPT_MAX;\n\t\tif (script_type < MAP_SCRIPT_MAX)\n\t\t\tmap_activate(script_type, true);\n\t}\n\n\t// if there are any input persons, check for trigger activation\n\tfor (i = 0; i < PLAYER_MAX; ++i) if (s_players[i].person != NULL) {\n\t\t// did we step on a trigger or move to a new one?\n\t\tperson_get_xyz(s_players[i].person, &x, &y, &layer, true);\n\t\ttrigger = get_trigger_at(x, y, layer, &index);\n\t\tif (trigger != s_on_trigger) {\n\t\t\tlast_trigger = s_current_trigger;\n\t\t\ts_current_trigger = index;\n\t\t\ts_on_trigger = trigger;\n\t\t\tif (trigger != NULL)\n\t\t\t\tscript_run(trigger->script, false);\n\t\t\ts_current_trigger = last_trigger;\n\t\t}\n\t}\n\n\t// update any zones occupied by the input person\n\t// note: a zone's step count is in reality a pixel count, so a zone\n\t//       may be updated multiple times in a single frame.\n\tfor (k = 0; k < PLAYER_MAX; ++k) if (s_players[k].person != NULL) {\n\t\tperson_get_xy(s_players[k].person, &x, &y, false);\n\t\tpx = fabs(x - start_x[k]);\n\t\tpy = fabs(y - start_y[k]);\n\t\tnum_zone_steps = px > py ? px : py;\n\t\tfor (i = 0; i < num_zone_steps; ++i) {\n\t\t\tj = 0;\n\t\t\twhile ((zone = get_zone_at(x, y, layer, j++, &index))) {\n\t\t\t\tif (zone->steps_left-- <= 0) {\n\t\t\t\t\tlast_zone = s_current_zone;\n\t\t\t\t\ts_current_zone = index;\n\t\t\t\t\tzone->steps_left = zone->interval;\n\t\t\t\t\tscript_run(zone->script, true);\n\t\t\t\t\ts_current_zone = last_zone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// check if there are any deferred scripts due to run this frame\n\t// and run the ones that are\n\tfor (i = 0; i < s_num_deferreds; ++i) {\n\t\tif (s_deferreds[i].frames_left-- <= 0) {\n\t\t\tscript_to_run = s_deferreds[i].script;\n\t\t\tfor (j = i; j < s_num_deferreds - 1; ++j)\n\t\t\t\ts_deferreds[j] = s_deferreds[j + 1];\n\t\t\t--s_num_deferreds;\n\t\t\tscript_run(script_to_run, false);\n\t\t\tscript_unref(script_to_run);\n\t\t\t--i;\n\t\t}\n\t}\n\n\t// now that everything else is in order, we can run the\n\t// update script!\n\tscript_run(s_update_script, false);\n}\n\nstatic void\nupdate_person(person_t* person, bool* out_has_moved)\n{\n\tstruct command  command;\n\tdouble          delta_x, delta_y;\n\tint             facing;\n\tbool            has_moved;\n\tbool            is_finished;\n\tconst person_t* last_person;\n\tstruct step     step;\n\tint             vector;\n\n\tint i;\n\n\tperson->mv_x = 0; person->mv_y = 0;\n\tif (person->revert_frames > 0 && --person->revert_frames <= 0)\n\t\tperson->frame = 0;\n\tif (person->leader == NULL) {  // no leader; use command queue\n\t\t// call the command generator if the queue is empty\n\t\tif (person->num_commands == 0)\n\t\t\tperson_activate(person, PERSON_SCRIPT_GENERATOR, NULL, true);\n\n\t\t// run through the queue, stopping after the first non-immediate command\n\t\tis_finished = !does_person_exist(person) || person->num_commands == 0;\n\t\twhile (!is_finished) {\n\t\t\tcommand = person->commands[0];\n\t\t\t--person->num_commands;\n\t\t\tfor (i = 0; i < person->num_commands; ++i)\n\t\t\t\tperson->commands[i] = person->commands[i + 1];\n\t\t\tlast_person = s_current_person;\n\t\t\ts_current_person = person;\n\t\t\tif (command.type != COMMAND_RUN_SCRIPT)\n\t\t\t\tcommand_person(person, command.type);\n\t\t\telse\n\t\t\t\tscript_run(command.script, false);\n\t\t\ts_current_person = last_person;\n\t\t\tscript_unref(command.script);\n\t\t\tis_finished = !does_person_exist(person)  // stop if person was destroyed\n\t\t\t\t|| !command.is_immediate || person->num_commands == 0;\n\t\t}\n\t}\n\telse {  // leader set; follow the leader!\n\t\tstep = person->leader->steps[person->follow_distance - 1];\n\t\tdelta_x = step.x - person->x;\n\t\tdelta_y = step.y - person->y;\n\t\tif (fabs(delta_x) > person->speed_x)\n\t\t\tcommand_person(person, delta_x > 0 ? COMMAND_MOVE_EAST : COMMAND_MOVE_WEST);\n\t\tif (!does_person_exist(person)) return;\n\t\tif (fabs(delta_y) > person->speed_y)\n\t\t\tcommand_person(person, delta_y > 0 ? COMMAND_MOVE_SOUTH : COMMAND_MOVE_NORTH);\n\t\tif (!does_person_exist(person)) return;\n\t\tvector = person->mv_x + person->mv_y * 3;\n\t\tfacing = vector == -3 ? COMMAND_FACE_NORTH\n\t\t\t: vector == -2 ? COMMAND_FACE_NORTHEAST\n\t\t\t: vector == 1 ? COMMAND_FACE_EAST\n\t\t\t: vector == 4 ? COMMAND_FACE_SOUTHEAST\n\t\t\t: vector == 3 ? COMMAND_FACE_SOUTH\n\t\t\t: vector == 2 ? COMMAND_FACE_SOUTHWEST\n\t\t\t: vector == -1 ? COMMAND_FACE_WEST\n\t\t\t: vector == -4 ? COMMAND_FACE_NORTHWEST\n\t\t\t: COMMAND_WAIT;\n\t\tif (facing != COMMAND_WAIT)\n\t\t\tcommand_person(person, COMMAND_ANIMATE);\n\t\tif (!does_person_exist(person)) return;\n\t\tcommand_person(person, facing);\n\t}\n\n\t// check that the person didn't mysteriously disappear...\n\tif (!does_person_exist(person))\n\t\treturn;  // they probably got eaten by a pig.\n\n\t// if the person's position changed, record it in their step history\n\t*out_has_moved = person_has_moved(person);\n\tif (*out_has_moved)\n\t\trecord_step(person);\n\n\t// recursively update the follower chain\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i]->leader != person)\n\t\t\tcontinue;\n\t\tupdate_person(s_persons[i], &has_moved);\n\t\t*out_has_moved |= has_moved;\n\t}\n}\n"], "fixing_code": ["/**\n *  miniSphere JavaScript game engine\n *  Copyright (c) 2015-2018, Fat Cerberus\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of miniSphere nor the names of its contributors may be\n *    used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n**/\n\n#include \"minisphere.h\"\n#include \"map_engine.h\"\n\n#include \"api.h\"\n#include \"audio.h\"\n#include \"color.h\"\n#include \"dispatch.h\"\n#include \"geometry.h\"\n#include \"image.h\"\n#include \"input.h\"\n#include \"jsal.h\"\n#include \"obstruction.h\"\n#include \"script.h\"\n#include \"spriteset.h\"\n#include \"tileset.h\"\n#include \"vanilla.h\"\n#include \"vector.h\"\n\nstatic const person_t*     s_acting_person;\nstatic mixer_t*            s_bgm_mixer = NULL;\nstatic person_t*           s_camera_person = NULL;\nstatic int                 s_camera_x = 0;\nstatic int                 s_camera_y = 0;\nstatic color_t             s_color_mask;\nstatic const person_t*     s_current_person = NULL;\nstatic int                 s_current_trigger = -1;\nstatic int                 s_current_zone = -1;\nstatic script_t*           s_def_map_scripts[MAP_SCRIPT_MAX];\nstatic script_t*           s_def_person_scripts[PERSON_SCRIPT_MAX];\nstatic bool                s_exiting = false;\nstatic color_t             s_fade_color_from;\nstatic color_t             s_fade_color_to;\nstatic int                 s_fade_frames;\nstatic int                 s_fade_progress;\nstatic int                 s_frame_rate = 0;\nstatic unsigned int        s_frames = 0;\nstatic bool                s_is_map_running = false;\nstatic lstring_t*          s_last_bgm_file = NULL;\nstatic struct map*         s_map = NULL;\nstatic sound_t*            s_map_bgm_stream = NULL;\nstatic char*               s_map_filename = NULL;\nstatic int                 s_max_deferreds = 0;\nstatic int                 s_max_persons = 0;\nstatic unsigned int        s_next_person_id = 0;\nstatic int                 s_num_deferreds = 0;\nstatic int                 s_num_persons = 0;\nstatic struct map_trigger* s_on_trigger = NULL;\nstatic unsigned int        s_queued_id = 0;\nstatic vector_t*           s_person_list = NULL;\nstatic struct player*      s_players;\nstatic script_t*           s_render_script = NULL;\nstatic int                 s_talk_button = 0;\nstatic int                 s_talk_distance = 8;\nstatic script_t*           s_update_script = NULL;\nstatic struct deferred     *s_deferreds = NULL;\nstatic person_t*           *s_persons = NULL;\n\nstruct deferred\n{\n\tscript_t* script;\n\tint       frames_left;\n};\n\nstruct map\n{\n\tint                width, height;\n\tbool               is_repeating;\n\tpoint3_t           origin;\n\tlstring_t*         bgm_file;\n\tscript_t*          scripts[MAP_SCRIPT_MAX];\n\ttileset_t*         tileset;\n\tvector_t*          triggers;\n\tvector_t*          zones;\n\tint                num_layers;\n\tint                num_persons;\n\tstruct map_layer   *layers;\n\tstruct map_person  *persons;\n};\n\nstruct map_layer\n{\n\tlstring_t*       name;\n\tbool             is_parallax;\n\tbool             is_reflective;\n\tbool             is_visible;\n\tfloat            autoscroll_x;\n\tfloat            autoscroll_y;\n\tcolor_t          color_mask;\n\tint              height;\n\tobsmap_t*        obsmap;\n\tfloat            parallax_x;\n\tfloat            parallax_y;\n\tscript_t*        render_script;\n\tstruct map_tile* tilemap;\n\tint              width;\n};\n\nstruct map_person\n{\n\tlstring_t* name;\n\tlstring_t* spriteset;\n\tint        x, y, z;\n\tlstring_t* create_script;\n\tlstring_t* destroy_script;\n\tlstring_t* command_script;\n\tlstring_t* talk_script;\n\tlstring_t* touch_script;\n};\n\nstruct map_tile\n{\n\tint tile_index;\n\tint frames_left;\n};\n\nstruct map_trigger\n{\n\tscript_t* script;\n\tint       x, y, z;\n};\n\nstruct map_zone\n{\n\tbool      is_active;\n\trect_t    bounds;\n\tint       interval;\n\tint       steps_left;\n\tint       layer;\n\tscript_t* script;\n};\n\nstruct person\n{\n\tunsigned int    id;\n\tchar*           name;\n\tint             anim_frames;\n\tchar*           direction;\n\tint             follow_distance;\n\tint             frame;\n\tbool            ignore_all_persons;\n\tbool            ignore_all_tiles;\n\tvector_t*       ignore_list;\n\tbool            is_persistent;\n\tbool            is_visible;\n\tint             layer;\n\tperson_t*       leader;\n\tcolor_t         mask;\n\tint             mv_x, mv_y;\n\tint             revert_delay;\n\tint             revert_frames;\n\tdouble          scale_x;\n\tdouble          scale_y;\n\tscript_t*       scripts[PERSON_SCRIPT_MAX];\n\tdouble          speed_x, speed_y;\n\tspriteset_t*    sprite;\n\tdouble          theta;\n\tdouble          x, y;\n\tint             x_offset, y_offset;\n\tint             max_commands;\n\tint             max_history;\n\tint             num_commands;\n\tint             num_ignores;\n\tstruct command  *commands;\n\tchar*           *ignores;\n\tstruct step     *steps;\n};\n\nstruct step\n{\n\tdouble x, y;\n};\n\nstruct command\n{\n\tint       type;\n\tbool      is_immediate;\n\tscript_t* script;\n};\n\nstruct player\n{\n\tbool      is_talk_allowed;\n\tperson_t* person;\n\tint       talk_key;\n};\n\n#pragma pack(push, 1)\nstruct rmp_header\n{\n\tchar    signature[4];\n\tint16_t version;\n\tuint8_t type;\n\tint8_t  num_layers;\n\tuint8_t reserved_1;\n\tint16_t num_entities;\n\tint16_t start_x;\n\tint16_t start_y;\n\tint8_t  start_layer;\n\tint8_t  start_direction;\n\tint16_t num_strings;\n\tint16_t num_zones;\n\tuint8_t repeat_map;\n\tuint8_t reserved[234];\n};\n\nstruct rmp_entity_header\n{\n\tuint16_t x;\n\tuint16_t y;\n\tuint16_t z;\n\tuint16_t type;\n\tuint8_t  reserved[8];\n};\n\nstruct rmp_layer_header\n{\n\tint16_t  width;\n\tint16_t  height;\n\tuint16_t flags;\n\tfloat    parallax_x;\n\tfloat    parallax_y;\n\tfloat    scrolling_x;\n\tfloat    scrolling_y;\n\tint32_t  num_segments;\n\tuint8_t  is_reflective;\n\tuint8_t  reserved[3];\n};\n\nstruct rmp_zone_header\n{\n\tuint16_t x1;\n\tuint16_t y1;\n\tuint16_t x2;\n\tuint16_t y2;\n\tuint16_t layer;\n\tuint16_t interval;\n\tuint8_t  reserved[4];\n};\n#pragma pack(pop)\n\nstatic bool                change_map           (const char* filename, bool preserve_persons);\nstatic void                command_person       (person_t* person, int command);\nstatic int                 compare_persons      (const void* a, const void* b);\nstatic void                detach_person        (const person_t* person);\nstatic bool                does_person_exist    (const person_t* person);\nstatic void                draw_persons         (int layer, bool is_flipped, int cam_x, int cam_y);\nstatic bool                enlarge_step_history (person_t* person, int new_size);\nstatic void                free_map             (struct map* map);\nstatic void                free_person          (person_t* person);\nstatic struct map_trigger* get_trigger_at       (int x, int y, int layer, int* out_index);\nstatic struct map_zone*    get_zone_at          (int x, int y, int layer, int which, int* out_index);\nstatic struct map*         load_map             (const char* path);\nstatic void                map_screen_to_layer  (int layer, int camera_x, int camera_y, int* inout_x, int* inout_y);\nstatic void                map_screen_to_map    (int camera_x, int camera_y, int* inout_x, int* inout_y);\nstatic void                process_map_input    (void);\nstatic void                record_step          (person_t* person);\nstatic void                reset_persons        (bool keep_existing);\nstatic void                set_person_name      (person_t* person, const char* name);\nstatic void                sort_persons         (void);\nstatic void                update_map_engine    (bool is_main_loop);\nstatic void                update_person        (person_t* person, bool* out_has_moved);\n\nvoid\nmap_engine_init(void)\n{\n\tint i;\n\n\tconsole_log(1, \"initializing map engine subsystem\");\n\n\taudio_init();\n\ts_bgm_mixer = mixer_new(44100, 16, 2);\n\n\tmemset(s_def_map_scripts, 0, MAP_SCRIPT_MAX * sizeof(int));\n\tmemset(s_def_person_scripts, 0, PERSON_SCRIPT_MAX * sizeof(int));\n\ts_map = NULL; s_map_filename = NULL;\n\ts_camera_person = NULL;\n\ts_players = calloc(PLAYER_MAX, sizeof(struct player));\n\tfor (i = 0; i < PLAYER_MAX; ++i)\n\t\ts_players[i].is_talk_allowed = true;\n\ts_current_trigger = -1;\n\ts_current_zone = -1;\n\ts_render_script = NULL;\n\ts_update_script = NULL;\n\ts_num_deferreds = s_max_deferreds = 0;\n\ts_deferreds = NULL;\n\ts_talk_button = 0;\n\ts_is_map_running = false;\n\ts_color_mask = mk_color(0, 0, 0, 0);\n\ts_on_trigger = NULL;\n\n\ts_num_persons = s_max_persons = 0;\n\ts_persons = NULL;\n\ts_talk_distance = 8;\n\ts_acting_person = NULL;\n\ts_current_person = NULL;\n}\n\nvoid\nmap_engine_uninit(void)\n{\n\tint i;\n\n\tconsole_log(1, \"shutting down map engine subsystem\");\n\n\tvector_free(s_person_list);\n\n\tfor (i = 0; i < s_num_deferreds; ++i)\n\t\tscript_unref(s_deferreds[i].script);\n\tfree(s_deferreds);\n\tfor (i = 0; i < MAP_SCRIPT_MAX; ++i)\n\t\tscript_unref(s_def_map_scripts[i]);\n\tscript_unref(s_update_script);\n\tscript_unref(s_render_script);\n\tfree_map(s_map);\n\tfree(s_players);\n\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tfree_person(s_persons[i]);\n\tfor (i = 0; i < PERSON_SCRIPT_MAX; ++i)\n\t\tscript_unref(s_def_person_scripts[i]);\n\tfree(s_persons);\n\n\tmixer_unref(s_bgm_mixer);\n\n\taudio_uninit();\n}\n\nvoid\nmap_engine_on_map_event(map_op_t op, script_t* script)\n{\n\tscript_t* old_script;\n\n\told_script = s_def_map_scripts[op];\n\ts_def_map_scripts[op] = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\nmap_engine_on_person_event(person_op_t op, script_t* script)\n{\n\tscript_t* old_script;\n\n\told_script = s_def_person_scripts[op];\n\ts_def_person_scripts[op] = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\nmap_engine_on_render(script_t* script)\n{\n\tscript_unref(s_render_script);\n\ts_render_script = script_ref(script);\n}\n\nvoid\nmap_engine_on_update(script_t* script)\n{\n\tscript_unref(s_update_script);\n\ts_update_script = script_ref(script);\n}\n\nconst person_t*\nmap_engine_acting_person(void)\n{\n\treturn s_acting_person;\n}\n\nconst person_t*\nmap_engine_active_person(void)\n{\n\treturn s_current_person;\n}\n\nint\nmap_engine_active_trigger(void)\n{\n\treturn s_current_trigger;\n}\n\nint\nmap_engine_active_zone(void)\n{\n\treturn s_current_zone;\n}\n\nvector_t*\nmap_engine_persons(void)\n{\n\tint i;\n\n\tif (s_person_list == NULL)\n\t\ts_person_list = vector_new(sizeof(person_t*));\n\tvector_clear(s_person_list);\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tvector_push(s_person_list, &s_persons[i]);\n\treturn s_person_list;\n}\n\nbool\nmap_engine_running(void)\n{\n\treturn s_is_map_running;\n}\n\nint\nmap_engine_get_framerate(void)\n{\n\treturn s_frame_rate;\n}\n\nperson_t*\nmap_engine_get_player(player_id_t player_id)\n{\n\treturn s_players[player_id].person;\n}\n\nperson_t*\nmap_engine_get_subject(void)\n{\n\treturn s_camera_person;\n}\n\nint\nmap_engine_get_talk_button(void)\n{\n\treturn s_talk_button;\n}\n\nint\nmap_engine_get_talk_distance(void)\n{\n\treturn s_talk_distance;\n}\n\nint\nmap_engine_get_talk_key(player_id_t player_id)\n{\n\treturn s_players[player_id].talk_key;\n}\n\nvoid\nmap_engine_set_framerate(int framerate)\n{\n\ts_frame_rate = framerate;\n}\n\nvoid\nmap_engine_set_player(player_id_t player_id, person_t* person)\n{\n\tint i;\n\n\t// detach person from any other players\n\tfor (i = 0; i < PLAYER_MAX; ++i) {\n\t\tif (s_players[i].person == person)\n\t\t\ts_players[i].person = NULL;\n\t}\n\n\ts_players[player_id].person = person;\n}\n\nvoid\nmap_engine_set_subject(person_t* person)\n{\n\ts_camera_person = person;\n}\n\nvoid\nmap_engine_set_talk_button(int button_id)\n{\n\ts_talk_button = button_id;\n}\n\nvoid\nmap_engine_set_talk_distance(int distance)\n{\n\ts_talk_distance = distance;\n}\n\nvoid\nmap_engine_set_talk_key(player_id_t player_id, int key)\n{\n\ts_players[player_id].talk_key = key;\n}\n\nbool\nmap_engine_change_map(const char* filename)\n{\n\treturn change_map(filename, false);\n}\n\nvoid\nmap_engine_defer(script_t* script, int num_frames)\n{\n\tstruct deferred* deferred;\n\n\tif (++s_num_deferreds > s_max_deferreds) {\n\t\ts_max_deferreds = s_num_deferreds * 2;\n\t\ts_deferreds = realloc(s_deferreds, s_max_deferreds * sizeof(struct deferred));\n\t}\n\tdeferred = &s_deferreds[s_num_deferreds - 1];\n\tdeferred->script = script;\n\tdeferred->frames_left = num_frames;\n}\n\nvoid\nmap_engine_draw_map(void)\n{\n\tbool              is_repeating;\n\tint               cell_x;\n\tint               cell_y;\n\tint               first_cell_x;\n\tint               first_cell_y;\n\tstruct map_layer* layer;\n\tint               layer_height;\n\tint               layer_width;\n\tsize2_t           resolution;\n\tint               tile_height;\n\tint               tile_index;\n\tint               tile_width;\n\tint               off_x;\n\tint               off_y;\n\n\tint x, y, z;\n\n\tif (screen_skipping_frame(g_screen))\n\t\treturn;\n\n\tresolution = screen_size(g_screen);\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\n\t// render map layers from bottom to top (+Z = up)\n\tfor (z = 0; z < s_map->num_layers; ++z) {\n\t\tlayer = &s_map->layers[z];\n\t\tis_repeating = s_map->is_repeating || layer->is_parallax;\n\t\tlayer_width = layer->width * tile_width;\n\t\tlayer_height = layer->height * tile_height;\n\t\toff_x = 0;\n\t\toff_y = 0;\n\t\tmap_screen_to_layer(z, s_camera_x, s_camera_y, &off_x, &off_y);\n\n\t\t// render person reflections if layer is reflective\n\t\tal_hold_bitmap_drawing(true);\n\t\tif (layer->is_reflective) {\n\t\t\tif (is_repeating) {  // for small repeating maps, persons need to be repeated as well\n\t\t\t\tfor (y = 0; y < resolution.height / layer_height + 2; ++y) for (x = 0; x < resolution.width / layer_width + 2; ++x)\n\t\t\t\t\tdraw_persons(z, true, off_x - x * layer_width, off_y - y * layer_height);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdraw_persons(z, true, off_x, off_y);\n\t\t\t}\n\t\t}\n\n\t\t// render tiles, but only if the layer is visible\n\t\tif (layer->is_visible) {\n\t\t\tfirst_cell_x = off_x / tile_width;\n\t\t\tfirst_cell_y = off_y / tile_height;\n\t\t\tfor (y = 0; y < resolution.height / tile_height + 2; ++y) for (x = 0; x < resolution.width / tile_width + 2; ++x) {\n\t\t\t\tcell_x = is_repeating ? (x + first_cell_x) % layer->width : x + first_cell_x;\n\t\t\t\tcell_y = is_repeating ? (y + first_cell_y) % layer->height : y + first_cell_y;\n\t\t\t\tif (cell_x < 0 || cell_x >= layer->width || cell_y < 0 || cell_y >= layer->height)\n\t\t\t\t\tcontinue;\n\t\t\t\ttile_index = layer->tilemap[cell_x + cell_y * layer->width].tile_index;\n\t\t\t\ttileset_draw(s_map->tileset, layer->color_mask, x * tile_width - off_x % tile_width, y * tile_height - off_y % tile_height, tile_index);\n\t\t\t}\n\t\t}\n\n\t\t// render persons\n\t\tif (is_repeating) {  // for small repeating maps, persons need to be repeated as well\n\t\t\tfor (y = 0; y < resolution.height / layer_height + 2; ++y) for (x = 0; x < resolution.width / layer_width + 2; ++x)\n\t\t\t\tdraw_persons(z, false, off_x - x * layer_width, off_y - y * layer_height);\n\t\t}\n\t\telse {\n\t\t\tdraw_persons(z, false, off_x, off_y);\n\t\t}\n\t\tal_hold_bitmap_drawing(false);\n\n\t\tscript_run(layer->render_script, false);\n\t}\n\n\tal_draw_filled_rectangle(0, 0, resolution.width, resolution.height, nativecolor(s_color_mask));\n\tscript_run(s_render_script, false);\n}\n\nvoid\nmap_engine_exit(void)\n{\n\ts_exiting = true;\n}\n\nvoid\nmap_engine_fade_to(color_t color_mask, int num_frames)\n{\n\tif (num_frames > 0) {\n\t\ts_fade_color_to = color_mask;\n\t\ts_fade_color_from = s_color_mask;\n\t\ts_fade_frames = num_frames;\n\t\ts_fade_progress = 0;\n\t}\n\telse {\n\t\ts_color_mask = color_mask;\n\t\ts_fade_color_to = s_fade_color_from = color_mask;\n\t\ts_fade_progress = s_fade_frames = 0;\n\t}\n}\n\nbool\nmap_engine_start(const char* filename, int framerate)\n{\n\ts_is_map_running = true;\n\ts_exiting = false;\n\ts_color_mask = mk_color(0, 0, 0, 0);\n\ts_fade_color_to = s_fade_color_from = s_color_mask;\n\ts_fade_progress = s_fade_frames = 0;\n\tal_clear_to_color(al_map_rgba(0, 0, 0, 255));\n\ts_frame_rate = framerate;\n\tif (!change_map(filename, true))\n\t\tgoto on_error;\n\twhile (!s_exiting && jsal_vm_enabled()) {\n\t\tsphere_heartbeat(true, 1);\n\n\t\t// order of operations matches Sphere 1.x.  not sure why, but Sphere 1.x\n\t\t// checks for input AFTER an update for some reason...\n\t\tupdate_map_engine(true);\n\t\tprocess_map_input();\n\t\tmap_engine_draw_map();\n\n\t\t// don't clear the backbuffer.  the Sphere 1.x map engine has a bug where it doesn't\n\t\t// clear the backbuffer between frames; as it turns out, a good deal of of v1 code relies\n\t\t// on that behavior.\n\t\tsphere_tick(1, false, s_frame_rate);\n\t}\n\treset_persons(false);\n\ts_is_map_running = false;\n\treturn true;\n\non_error:\n\ts_is_map_running = false;\n\treturn false;\n}\n\nvoid\nmap_engine_update(void)\n{\n\tupdate_map_engine(false);\n}\n\nrect_t\nmap_bounds(void)\n{\n\trect_t bounds;\n\tint    tile_w, tile_h;\n\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tbounds.x1 = 0; bounds.y1 = 0;\n\tbounds.x2 = s_map->width * tile_w;\n\tbounds.y2 = s_map->height * tile_h;\n\treturn bounds;\n}\n\nint\nmap_layer_by_name(const char* name)\n{\n\tint i;\n\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (strcmp(name, lstr_cstr(s_map->layers[0].name)) == 0)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nint\nmap_num_layers(void)\n{\n\treturn s_map->num_layers;\n}\n\nint\nmap_num_persons(void)\n{\n\treturn s_num_persons;\n}\n\nint\nmap_num_triggers(void)\n{\n\treturn vector_len(s_map->triggers);\n}\n\nint\nmap_num_zones(void)\n{\n\treturn vector_len(s_map->zones);\n}\n\npoint3_t\nmap_origin(void)\n{\n\treturn s_map != NULL ? s_map->origin\n\t\t: mk_point3(0, 0, 0);\n}\n\nconst char*\nmap_pathname(void)\n{\n\treturn s_map ? s_map_filename : NULL;\n}\n\nperson_t*\nmap_person_by_name(const char* name)\n{\n\tint i;\n\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (strcmp(name, s_persons[i]->name) == 0)\n\t\t\treturn s_persons[i];\n\t}\n\treturn NULL;\n}\n\nint\nmap_tile_at(int x, int y, int layer)\n{\n\tint layer_h;\n\tint layer_w;\n\n\tlayer_w = s_map->layers[layer].width;\n\tlayer_h = s_map->layers[layer].height;\n\n\tif (s_map->is_repeating || s_map->layers[layer].is_parallax) {\n\t\tx = (x % layer_w + layer_w) % layer_w;\n\t\ty = (y % layer_h + layer_h) % layer_h;\n\t}\n\tif (x < 0 || y < 0 || x >= layer_w || y >= layer_h)\n\t\treturn -1;\n\treturn layer_get_tile(layer, x, y);\n}\n\ntileset_t*\nmap_tileset(void)\n{\n\treturn s_map->tileset;\n}\n\nint\nmap_trigger_at(int x, int y, int layer)\n{\n\trect_t              bounds;\n\tint                 tile_w, tile_h;\n\tstruct map_trigger* trigger;\n\n\titer_t iter;\n\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\titer = vector_enum(s_map->triggers);\n\twhile ((trigger = iter_next(&iter))) {\n\t\tif (trigger->z != layer && false)  // layer ignored for compatibility\n\t\t\tcontinue;\n\t\tbounds.x1 = trigger->x - tile_w / 2;\n\t\tbounds.y1 = trigger->y - tile_h / 2;\n\t\tbounds.x2 = bounds.x1 + tile_w;\n\t\tbounds.y2 = bounds.y1 + tile_h;\n\t\tif (is_point_in_rect(x, y, bounds))\n\t\t\treturn iter.index;\n\t}\n\treturn -1;\n}\n\npoint2_t\nmap_xy_from_screen(point2_t screen_xy)\n{\n\tint x;\n\tint y;\n\n\tx = screen_xy.x;\n\ty = screen_xy.y;\n\tmap_screen_to_map(s_camera_x, s_camera_y, &x, &y);\n\treturn mk_point2(x, y);\n}\n\nint\nmap_zone_at(int x, int y, int layer, int which)\n{\n\tstruct map_zone* zone;\n\n\titer_t iter;\n\n\titer = vector_enum(s_map->zones);\n\twhile ((zone = iter_next(&iter))) {\n\t\tif (zone->layer != layer && false)  // layer ignored for compatibility\n\t\t\tcontinue;\n\t\tif (is_point_in_rect(x, y, zone->bounds) && --which < 0)\n\t\t\treturn iter.index;\n\t}\n\treturn -1;\n}\n\npoint2_t\nmap_get_camera_xy(void)\n{\n\treturn mk_point2(s_camera_x, s_camera_y);\n}\n\nvoid\nmap_set_camera_xy(point2_t where)\n{\n\ts_camera_x = where.x;\n\ts_camera_y = where.y;\n}\n\nvoid\nmap_activate(map_op_t op, bool use_default)\n{\n\tif (use_default)\n\t\tscript_run(s_def_map_scripts[op], false);\n\tscript_run(s_map->scripts[op], false);\n}\n\nbool\nmap_add_trigger(int x, int y, int layer, script_t* script)\n{\n\tstruct map_trigger trigger;\n\n\tconsole_log(2, \"creating trigger #%d on map '%s'\", vector_len(s_map->triggers), s_map_filename);\n\tconsole_log(3, \"    location: '%s' @ (%d,%d)\", lstr_cstr(s_map->layers[layer].name), x, y);\n\n\ttrigger.x = x; trigger.y = y;\n\ttrigger.z = layer;\n\ttrigger.script = script_ref(script);\n\tif (!vector_push(s_map->triggers, &trigger))\n\t\treturn false;\n\treturn true;\n}\n\nbool\nmap_add_zone(rect_t bounds, int layer, script_t* script, int steps)\n{\n\tstruct map_zone zone;\n\n\tconsole_log(2, \"creating %u-step zone #%d on map '%s'\", steps, vector_len(s_map->zones), s_map_filename);\n\tconsole_log(3, \"    bounds: (%d,%d)-(%d,%d)\", bounds.x1, bounds.y1, bounds.x2, bounds.y2);\n\n\tmemset(&zone, 0, sizeof(struct map_zone));\n\tzone.bounds = bounds;\n\tzone.layer = layer;\n\tzone.script = script_ref(script);\n\tzone.interval = steps;\n\tzone.steps_left = 0;\n\tif (!vector_push(s_map->zones, &zone))\n\t\treturn false;\n\treturn true;\n}\n\nvoid\nmap_call_default(map_op_t op)\n{\n\tscript_run(s_def_map_scripts[op], false);\n}\n\nvoid\nmap_normalize_xy(double* inout_x, double* inout_y, int layer)\n{\n\tint tile_w, tile_h;\n\tint layer_w, layer_h;\n\n\tif (s_map == NULL)\n\t\treturn;  // can't normalize if no map loaded\n\tif (!s_map->is_repeating && !s_map->layers[layer].is_parallax)\n\t\treturn;\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tlayer_w = s_map->layers[layer].width * tile_w;\n\tlayer_h = s_map->layers[layer].height * tile_h;\n\tif (inout_x)\n\t\t*inout_x = fmod(fmod(*inout_x, layer_w) + layer_w, layer_w);\n\tif (inout_y)\n\t\t*inout_y = fmod(fmod(*inout_y, layer_h) + layer_h, layer_h);\n}\n\nvoid\nmap_remove_trigger(int trigger_index)\n{\n\tvector_remove(s_map->triggers, trigger_index);\n}\n\nvoid\nmap_remove_zone(int zone_index)\n{\n\tvector_remove(s_map->zones, zone_index);\n}\n\nvoid\nlayer_on_render(int layer, script_t* script)\n{\n\tscript_unref(s_map->layers[layer].render_script);\n\ts_map->layers[layer].render_script = script_ref(script);\n}\n\nconst char*\nlayer_name(int layer)\n{\n\treturn lstr_cstr(s_map->layers[layer].name);\n}\n\nconst obsmap_t*\nlayer_obsmap(int layer)\n{\n\treturn s_map->layers[layer].obsmap;\n}\n\nsize2_t\nlayer_size(int layer)\n{\n\tstruct map_layer* layer_data;\n\n\tlayer_data = &s_map->layers[layer];\n\treturn mk_size2(layer_data->width, layer_data->height);\n}\n\ncolor_t\nlayer_get_color_mask(int layer)\n{\n\treturn s_map->layers[layer].color_mask;\n}\n\nbool\nlayer_get_reflective(int layer)\n{\n\treturn s_map->layers[layer].is_reflective;\n}\n\nint\nlayer_get_tile(int layer, int x, int y)\n{\n\tstruct map_tile* tile;\n\tint              width;\n\n\twidth = s_map->layers[layer].width;\n\ttile = &s_map->layers[layer].tilemap[x + y * width];\n\treturn tile->tile_index;\n}\n\nbool\nlayer_get_visible(int layer)\n{\n\treturn s_map->layers[layer].is_visible;\n}\n\nvoid\nlayer_set_color_mask(int layer, color_t color)\n{\n\ts_map->layers[layer].color_mask = color;\n}\n\nvoid\nlayer_set_reflective(int layer, bool reflective)\n{\n\ts_map->layers[layer].is_reflective = reflective;\n}\n\nvoid\nlayer_set_tile(int layer, int x, int y, int tile_index)\n{\n\tstruct map_tile* tile;\n\tint              width;\n\n\twidth = s_map->layers[layer].width;\n\ttile = &s_map->layers[layer].tilemap[x + y * width];\n\ttile->tile_index = tile_index;\n\ttile->frames_left = tileset_get_delay(s_map->tileset, tile_index);\n}\n\nvoid\nlayer_set_visible(int layer, bool visible)\n{\n\ts_map->layers[layer].is_visible = visible;\n}\n\nvoid\nlayer_replace_tiles(int layer, int old_index, int new_index)\n{\n\tint              layer_h;\n\tint              layer_w;\n\tstruct map_tile* tile;\n\n\tint i_x, i_y;\n\n\tlayer_w = s_map->layers[layer].width;\n\tlayer_h = s_map->layers[layer].height;\n\tfor (i_x = 0; i_x < layer_w; ++i_x) for (i_y = 0; i_y < layer_h; ++i_y) {\n\t\ttile = &s_map->layers[layer].tilemap[i_x + i_y * layer_w];\n\t\tif (tile->tile_index == old_index)\n\t\t\ttile->tile_index = new_index;\n\t}\n}\n\nbool\nlayer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n\tstruct map_tile*    tilemap;\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\tsize_t              tilemap_size;\n\n\tint x, y, i;\n\n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n\n\t// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc\n\t// because the tilemap is a 2D array.\n\ttilemap_size = x_size * y_size * sizeof(struct map_tile);\n\tif (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size\n\t\t|| !(tilemap = malloc(tilemap_size)))\n\t\treturn false;\n\tfor (x = 0; x < x_size; ++x) {\n\t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the old tilemap and substitute the new one\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\t// if we resize the largest layer, the overall map size will change.\n\t// recalcuate it.\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\t// ensure zones and triggers remain in-bounds.  if any are completely\n\t// out-of-bounds, delete them.\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}\n\nperson_t*\nperson_new(const char* name, spriteset_t* spriteset, bool is_persistent, script_t* create_script)\n{\n\tpoint3_t  origin = map_origin();\n\tperson_t* person;\n\n\tif (++s_num_persons > s_max_persons) {\n\t\ts_max_persons = s_num_persons * 2;\n\t\ts_persons = realloc(s_persons, s_max_persons * sizeof(person_t*));\n\t}\n\tperson = s_persons[s_num_persons - 1] = calloc(1, sizeof(person_t));\n\tperson->id = s_next_person_id++;\n\tperson->sprite = spriteset_ref(spriteset);\n\tset_person_name(person, name);\n\tperson_set_pose(person, spriteset_pose_name(spriteset, 0));\n\tperson->is_persistent = is_persistent;\n\tperson->is_visible = true;\n\tperson->x = origin.x;\n\tperson->y = origin.y;\n\tperson->layer = origin.z;\n\tperson->speed_x = 1.0;\n\tperson->speed_y = 1.0;\n\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, 0);\n\tperson->mask = mk_color(255, 255, 255, 255);\n\tperson->scale_x = person->scale_y = 1.0;\n\tperson->scripts[PERSON_SCRIPT_ON_CREATE] = create_script;\n\tperson_activate(person, PERSON_SCRIPT_ON_CREATE, NULL, true);\n\tsort_persons();\n\treturn person;\n}\n\nvoid\nperson_free(person_t* person)\n{\n\tint i, j;\n\n\t// call the person's destroy script *before* renouncing leadership.\n\t// the destroy script may want to reassign followers (they will be orphaned otherwise), so\n\t// we want to give it a chance to do so.\n\tperson_activate(person, PERSON_SCRIPT_ON_DESTROY, NULL, true);\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i]->leader == person)\n\t\t\ts_persons[i]->leader = NULL;\n\t}\n\n\t// remove the person from the engine\n\tdetach_person(person);\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i] == person) {\n\t\t\tfor (j = i; j < s_num_persons - 1; ++j)\n\t\t\t\ts_persons[j] = s_persons[j + 1];\n\t\t\t--s_num_persons;\n\t\t\t--i;\n\t\t}\n\t}\n\n\tvector_free(person->ignore_list);\n\n\tfree_person(person);\n\tsort_persons();\n}\n\nrect_t\nperson_base(const person_t* person)\n{\n\trect_t base_rect;\n\tint    base_x;\n\tint    base_y;\n\tdouble x;\n\tdouble y;\n\n\tbase_rect = rect_zoom(spriteset_get_base(person->sprite), person->scale_x, person->scale_y);\n\tperson_get_xy(person, &x, &y, true);\n\tbase_x = x - (base_rect.x1 + (base_rect.x2 - base_rect.x1) / 2);\n\tbase_y = y - (base_rect.y1 + (base_rect.y2 - base_rect.y1) / 2);\n\tbase_rect.x1 += base_x; base_rect.x2 += base_x;\n\tbase_rect.y1 += base_y; base_rect.y2 += base_y;\n\treturn base_rect;\n}\n\nbool\nperson_following(const person_t* person, const person_t* leader)\n{\n\tconst person_t* node;\n\n\tnode = person;\n\twhile ((node = node->leader))\n\t\tif (node == leader) return true;\n\treturn false;\n}\n\nbool\nperson_has_moved(const person_t* person)\n{\n\treturn person->mv_x != 0 || person->mv_y != 0;\n}\n\nvector_t*\nperson_ignore_list(person_t* person)\n{\n\t// note: the returned vector is an array of C strings.  these should be treated\n\t//       as const char*; in other words, don't free them!\n\n\tint i;\n\n\tif (person->ignore_list == NULL)\n\t\tperson->ignore_list = vector_new(sizeof(const char*));\n\tvector_clear(person->ignore_list);\n\tfor (i = 0; i < person->num_ignores; ++i)\n\t\tvector_push(person->ignore_list, &person->ignores[i]);\n\treturn person->ignore_list;\n}\n\nbool\nperson_ignored_by(const person_t* person, const person_t* other)\n{\n\t// note: commutative; if either person ignores the other, the function will return true\n\n\tint i;\n\n\tif (other->ignore_all_persons || person->ignore_all_persons)\n\t\treturn true;\n\tfor (i = 0; i < other->num_ignores; ++i)\n\t\tif (strcmp(other->ignores[i], person->name) == 0) return true;\n\tfor (i = 0; i < person->num_ignores; ++i)\n\t\tif (strcmp(person->ignores[i], other->name) == 0) return true;\n\treturn false;\n}\n\nbool\nperson_moving(const person_t* person)\n{\n\treturn person->num_commands > 0;\n}\n\nconst char*\nperson_name(const person_t* person)\n{\n\treturn person != NULL ? person->name : \"\";\n}\n\nbool\nperson_obstructed_at(const person_t* person, double x, double y, person_t** out_obstructing_person, int* out_tile_index)\n{\n\trect_t           area;\n\trect_t           base, my_base;\n\tdouble           cur_x, cur_y;\n\tbool             is_obstructed = false;\n\tint              layer;\n\tconst obsmap_t*  obsmap;\n\tint              tile_w, tile_h;\n\tconst tileset_t* tileset;\n\n\tint i, i_x, i_y;\n\n\tmap_normalize_xy(&x, &y, person->layer);\n\tperson_get_xyz(person, &cur_x, &cur_y, &layer, true);\n\tmy_base = rect_translate(person_base(person), x - cur_x, y - cur_y);\n\tif (out_obstructing_person != NULL)\n\t\t*out_obstructing_person = NULL;\n\tif (out_tile_index != NULL)\n\t\t*out_tile_index = -1;\n\n\t// check for obstructing persons\n\tif (!person->ignore_all_persons) {\n\t\tfor (i = 0; i < s_num_persons; ++i) {\n\t\t\tif (s_persons[i] == person)  // these persons aren't going to obstruct themselves!\n\t\t\t\tcontinue;\n\t\t\tif (s_persons[i]->layer != layer)\n\t\t\t\tcontinue;  // ignore persons not on the same layer\n\t\t\tif (person_following(s_persons[i], person))\n\t\t\t\tcontinue;  // ignore own followers\n\t\t\tbase = person_base(s_persons[i]);\n\t\t\tif (do_rects_overlap(my_base, base) && !person_ignored_by(person, s_persons[i])) {\n\t\t\t\tis_obstructed = true;\n\t\t\t\tif (out_obstructing_person)\n\t\t\t\t\t*out_obstructing_person = s_persons[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// no obstructing person, check map-defined obstructions\n\tobsmap = layer_obsmap(layer);\n\tif (obsmap_test_rect(obsmap, my_base))\n\t\tis_obstructed = true;\n\n\t// check for obstructing tiles\n\t// for performance reasons, the search is constrained to the immediate vicinity\n\t// of the person's sprite base.\n\tif (!person->ignore_all_tiles) {\n\t\ttileset = map_tileset();\n\t\ttileset_get_size(tileset, &tile_w, &tile_h);\n\t\tarea.x1 = my_base.x1 / tile_w;\n\t\tarea.y1 = my_base.y1 / tile_h;\n\t\tarea.x2 = area.x1 + (my_base.x2 - my_base.x1) / tile_w + 2;\n\t\tarea.y2 = area.y1 + (my_base.y2 - my_base.y1) / tile_h + 2;\n\t\tfor (i_x = area.x1; i_x < area.x2; ++i_x) for (i_y = area.y1; i_y < area.y2; ++i_y) {\n\t\t\tbase = rect_translate(my_base, -(i_x * tile_w), -(i_y * tile_h));\n\t\t\tobsmap = tileset_obsmap(tileset, map_tile_at(i_x, i_y, layer));\n\t\t\tif (obsmap != NULL && obsmap_test_rect(obsmap, base)) {\n\t\t\t\tis_obstructed = true;\n\t\t\t\tif (out_tile_index)\n\t\t\t\t\t*out_tile_index = map_tile_at(i_x, i_y, layer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn is_obstructed;\n}\n\ndouble\nperson_get_angle(const person_t* person)\n{\n\treturn person->theta;\n}\n\ncolor_t\nperson_get_color(const person_t* person)\n{\n\treturn person->mask;\n}\n\nint\nperson_get_frame(const person_t* person)\n{\n\tint num_frames;\n\n\tnum_frames = spriteset_num_frames(person->sprite, person->direction);\n\treturn person->frame % num_frames;\n}\n\nint\nperson_get_frame_delay(const person_t* person)\n{\n\treturn person->anim_frames;\n}\n\nbool\nperson_get_ignore_persons(const person_t* person)\n{\n\treturn person->ignore_all_persons;\n}\n\nbool\nperson_get_ignore_tiles(const person_t* person)\n{\n\treturn person->ignore_all_tiles;\n}\n\nint\nperson_get_layer(const person_t* person)\n{\n\treturn person->layer;\n}\n\nperson_t*\nperson_get_leader(const person_t* person)\n{\n\treturn person->leader;\n}\n\npoint2_t\nperson_get_offset(const person_t* person)\n{\n\treturn mk_point2(person->x_offset, person->y_offset);\n}\n\nconst char*\nperson_get_pose(const person_t* person)\n{\n\treturn person->direction;\n}\n\nint\nperson_get_revert_delay(const person_t* person)\n{\n\treturn person->revert_delay;\n}\n\nvoid\nperson_get_scale(const person_t* person, double* out_scale_x, double* out_scale_y)\n{\n\t*out_scale_x = person->scale_x;\n\t*out_scale_y = person->scale_y;\n}\n\nvoid\nperson_get_speed(const person_t* person, double* out_x_speed, double* out_y_speed)\n{\n\tif (out_x_speed) *out_x_speed = person->speed_x;\n\tif (out_y_speed) *out_y_speed = person->speed_y;\n}\n\nspriteset_t*\nperson_get_spriteset(const person_t* person)\n{\n\treturn person->sprite;\n}\n\nint\nperson_get_trailing(const person_t* person)\n{\n\treturn person->follow_distance;\n}\n\nbool\nperson_get_visible(const person_t* person)\n{\n\treturn person->is_visible;\n}\n\nvoid\nperson_get_xy(const person_t* person, double* out_x, double* out_y, bool normalize)\n{\n\t*out_x = person->x;\n\t*out_y = person->y;\n\tif (normalize)\n\t\tmap_normalize_xy(out_x, out_y, person->layer);\n}\n\nvoid\nperson_get_xyz(const person_t* person, double* out_x, double* out_y, int* out_layer, bool normalize)\n{\n\t*out_x = person->x;\n\t*out_y = person->y;\n\t*out_layer = person->layer;\n\tif (normalize)\n\t\tmap_normalize_xy(out_x, out_y, *out_layer);\n}\n\nvoid\nperson_set_angle(person_t* person, double theta)\n{\n\tperson->theta = theta;\n}\n\nvoid\nperson_set_color(person_t* person, color_t mask)\n{\n\tperson->mask = mask;\n}\n\nvoid\nperson_set_frame(person_t* person, int frame_index)\n{\n\tint num_frames;\n\n\tnum_frames = spriteset_num_frames(person->sprite, person->direction);\n\tperson->frame = (frame_index % num_frames + num_frames) % num_frames;\n\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, person->frame);\n\tperson->revert_frames = person->revert_delay;\n}\n\nvoid\nperson_set_frame_delay(person_t* person, int num_frames)\n{\n\tperson->anim_frames = num_frames;\n\tperson->revert_frames = person->revert_delay;\n}\n\nvoid\nperson_set_ignore_persons(person_t* person, bool ignoring)\n{\n\tperson->ignore_all_persons = ignoring;\n}\n\nvoid\nperson_set_ignore_tiles (person_t* person, bool ignoring)\n{\n\tperson->ignore_all_tiles = ignoring;\n}\n\nvoid\nperson_set_layer(person_t* person, int layer)\n{\n\tperson->layer = layer;\n}\n\nbool\nperson_set_leader(person_t* person, person_t* leader, int distance)\n{\n\tconst person_t* node;\n\n\t// prevent circular follower chains from forming\n\tif (leader != NULL) {\n\t\tnode = leader;\n\t\tdo {\n\t\t\tif (node == person)\n\t\t\t\treturn false;\n\t\t} while ((node = node->leader));\n\t}\n\n\t// add the person as a follower (or sever existing link if leader==NULL)\n\tif (leader != NULL) {\n\t\tif (!enlarge_step_history(leader, distance))\n\t\t\treturn false;\n\t\tperson->leader = leader;\n\t\tperson->follow_distance = distance;\n\t}\n\tperson->leader = leader;\n\treturn true;\n}\n\nvoid\nperson_set_offset(person_t* person, point2_t offset)\n{\n\tperson->x_offset = offset.x;\n\tperson->y_offset = offset.y;\n}\n\nvoid\nperson_set_pose(person_t* person, const char* pose_name)\n{\n\tperson->direction = realloc(person->direction, (strlen(pose_name) + 1) * sizeof(char));\n\tstrcpy(person->direction, pose_name);\n}\n\nvoid\nperson_set_revert_delay(person_t* person, int num_frames)\n{\n\tperson->revert_delay = num_frames;\n\tperson->revert_frames = num_frames;\n}\n\nvoid\nperson_set_scale(person_t* person, double scale_x, double scale_y)\n{\n\tperson->scale_x = scale_x;\n\tperson->scale_y = scale_y;\n}\n\nvoid\nperson_set_speed(person_t* person, double x_speed, double y_speed)\n{\n\tperson->speed_x = x_speed;\n\tperson->speed_y = y_speed;\n}\n\nvoid\nperson_set_spriteset(person_t* person, spriteset_t* spriteset)\n{\n\tspriteset_t* old_spriteset;\n\n\told_spriteset = person->sprite;\n\tperson->sprite = spriteset_ref(spriteset);\n\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, 0);\n\tperson->frame = 0;\n\tspriteset_unref(old_spriteset);\n}\n\nvoid\nperson_set_trailing(person_t* person, int distance)\n{\n\tenlarge_step_history(person->leader, distance);\n\tperson->follow_distance = distance;\n}\n\nvoid\nperson_set_visible(person_t* person, bool visible)\n{\n\tperson->is_visible = visible;\n}\n\nvoid\nperson_set_xyz(person_t* person, double x, double y, int layer)\n{\n\tperson->x = x;\n\tperson->y = y;\n\tperson->layer = layer;\n\tsort_persons();\n}\n\nvoid\nperson_on_event(person_t* person, int type, script_t* script)\n{\n\tscript_unref(person->scripts[type]);\n\tperson->scripts[type] = script;\n}\n\nvoid\nperson_activate(const person_t* person, person_op_t op, const person_t* acting_person, bool use_default)\n{\n\tconst person_t* last_acting;\n\tconst person_t* last_current;\n\n\tlast_acting = s_acting_person;\n\tlast_current = s_current_person;\n\ts_acting_person = acting_person;\n\ts_current_person = person;\n\tif (use_default)\n\t\tscript_run(s_def_person_scripts[op], false);\n\tif (does_person_exist(person))\n\t\tscript_run(person->scripts[op], false);\n\ts_acting_person = last_acting;\n\ts_current_person = last_current;\n}\n\nvoid\nperson_call_default(const person_t* person, person_op_t op, const person_t* acting_person)\n{\n\tconst person_t* last_acting;\n\tconst person_t* last_current;\n\n\tlast_acting = s_acting_person;\n\tlast_current = s_current_person;\n\ts_acting_person = acting_person;\n\ts_current_person = person;\n\tscript_run(s_def_person_scripts[op], false);\n\ts_acting_person = last_acting;\n\ts_current_person = last_current;\n}\n\nvoid\nperson_clear_ignores(person_t* person)\n{\n\tint i;\n\n\tfor (i = 0; i < person->num_ignores; ++i)\n\t\tfree(person->ignores[i]);\n\tperson->num_ignores = 0;\n}\n\nvoid\nperson_clear_queue(person_t* person)\n{\n\tperson->num_commands = 0;\n}\n\nbool\nperson_compile_script(person_t* person, int type, const lstring_t* codestring)\n{\n\tscript_t*   script;\n\tconst char* script_name;\n\n\tscript_name = type == PERSON_SCRIPT_ON_CREATE ? \"onCreate\"\n\t\t: type == PERSON_SCRIPT_ON_DESTROY ? \"onDestroy\"\n\t\t: type == PERSON_SCRIPT_ON_TOUCH ? \"onTouch\"\n\t\t: type == PERSON_SCRIPT_ON_TALK ? \"onTalk\"\n\t\t: type == PERSON_SCRIPT_GENERATOR ? \"genCommands\"\n\t\t: NULL;\n\tif (script_name == NULL)\n\t\treturn false;\n\tscript = script_new(codestring, \"%s/%s/%s.js\", map_pathname(), person->name, script_name);\n\tperson_on_event(person, type, script);\n\treturn true;\n}\n\nvoid\nperson_ignore_name(person_t* person, const char* name)\n{\n\tint index;\n\n\tindex = person->num_ignores++;\n\tperson->ignores = realloc(person->ignores, person->num_ignores * sizeof(char*));\n\tperson->ignores[index] = strdup(name);\n\n\t// ignore list changed, delete cache\n\tvector_free(person->ignore_list);\n\tperson->ignore_list = NULL;\n}\n\nbool\nperson_queue_command(person_t* person, int command, bool is_immediate)\n{\n\tstruct command* commands;\n\tbool            is_aok = true;\n\n\tswitch (command) {\n\tcase COMMAND_MOVE_NORTHEAST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_NORTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_EAST, is_immediate);\n\t\treturn is_aok;\n\tcase COMMAND_MOVE_SOUTHEAST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_SOUTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_EAST, is_immediate);\n\t\treturn is_aok;\n\tcase COMMAND_MOVE_SOUTHWEST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_SOUTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_WEST, is_immediate);\n\t\treturn is_aok;\n\tcase COMMAND_MOVE_NORTHWEST:\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_NORTH, true);\n\t\tis_aok &= person_queue_command(person, COMMAND_MOVE_WEST, is_immediate);\n\t\treturn is_aok;\n\tdefault:\n\t\t++person->num_commands;\n\t\tif (person->num_commands > person->max_commands) {\n\t\t\tif (!(commands = realloc(person->commands, person->num_commands * 2 * sizeof(struct command))))\n\t\t\t\treturn false;\n\t\t\tperson->max_commands = person->num_commands * 2;\n\t\t\tperson->commands = commands;\n\t\t}\n\t\tperson->commands[person->num_commands - 1].type = command;\n\t\tperson->commands[person->num_commands - 1].is_immediate = is_immediate;\n\t\tperson->commands[person->num_commands - 1].script = NULL;\n\t\treturn true;\n\t}\n}\n\nbool\nperson_queue_script(person_t* person, script_t* script, bool is_immediate)\n{\n\t++person->num_commands;\n\tif (person->num_commands > person->max_commands) {\n\t\tperson->max_commands = person->num_commands * 2;\n\t\tif (!(person->commands = realloc(person->commands, person->max_commands * sizeof(struct command))))\n\t\t\treturn false;\n\t}\n\tperson->commands[person->num_commands - 1].type = COMMAND_RUN_SCRIPT;\n\tperson->commands[person->num_commands - 1].is_immediate = is_immediate;\n\tperson->commands[person->num_commands - 1].script = script;\n\treturn true;\n}\n\nvoid\nperson_talk(const person_t* person)\n{\n\trect_t          map_rect;\n\tperson_t*       target_person;\n\tdouble          talk_x, talk_y;\n\n\tmap_rect = map_bounds();\n\n\t// check if anyone else is within earshot\n\tperson_get_xy(person, &talk_x, &talk_y, true);\n\tif (strstr(person->direction, \"north\"))\n\t\ttalk_y -= s_talk_distance;\n\tif (strstr(person->direction, \"east\"))\n\t\ttalk_x += s_talk_distance;\n\tif (strstr(person->direction, \"south\"))\n\t\ttalk_y += s_talk_distance;\n\tif (strstr(person->direction, \"west\"))\n\t\ttalk_x -= s_talk_distance;\n\tperson_obstructed_at(person, talk_x, talk_y, &target_person, NULL);\n\n\t// if so, call their talk script\n\tif (target_person != NULL)\n\t\tperson_activate(target_person, PERSON_SCRIPT_ON_TALK, person, true);\n}\n\nvoid\ntrigger_get_xyz(int trigger_index, int* out_x, int* out_y, int* out_layer)\n{\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\tif (out_x != NULL)\n\t\t*out_x = trigger->x;\n\tif (out_y != NULL)\n\t\t*out_y = trigger->y;\n\tif (out_layer) *out_layer = trigger->z;\n}\n\nvoid\ntrigger_set_layer(int trigger_index, int layer)\n{\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\ttrigger->z = layer;\n}\n\nvoid\ntrigger_set_script(int trigger_index, script_t* script)\n{\n\tscript_t*           old_script;\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\told_script = trigger->script;\n\ttrigger->script = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\ntrigger_set_xy(int trigger_index, int x, int y)\n{\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\ttrigger->x = x;\n\ttrigger->y = y;\n}\n\nvoid\ntrigger_activate(int trigger_index)\n{\n\tint                 last_trigger;\n\tstruct map_trigger* trigger;\n\n\ttrigger = vector_get(s_map->triggers, trigger_index);\n\tlast_trigger = s_current_trigger;\n\ts_current_trigger = trigger_index;\n\tscript_run(trigger->script, true);\n\ts_current_trigger = last_trigger;\n}\n\nrect_t\nzone_get_bounds(int zone_index)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\treturn zone->bounds;\n}\n\nint\nzone_get_layer(int zone_index)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\treturn zone->layer;\n}\n\nint\nzone_get_steps(int zone_index)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\treturn zone->interval;\n}\n\nvoid\nzone_set_bounds(int zone_index, rect_t bounds)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\trect_normalize(&bounds);\n\tzone->bounds = bounds;\n}\n\nvoid\nzone_set_layer(int zone_index, int layer)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\tzone->layer = layer;\n}\n\nvoid\nzone_set_script(int zone_index, script_t* script)\n{\n\tscript_t*        old_script;\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\told_script = zone->script;\n\tzone->script = script_ref(script);\n\tscript_unref(old_script);\n}\n\nvoid\nzone_set_steps(int zone_index, int interval)\n{\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\tzone->interval = interval;\n\tzone->steps_left = 0;\n}\n\nvoid\nzone_activate(int zone_index)\n{\n\tint              last_zone;\n\tstruct map_zone* zone;\n\n\tzone = vector_get(s_map->zones, zone_index);\n\tlast_zone = s_current_zone;\n\ts_current_zone = zone_index;\n\tscript_run(zone->script, true);\n\ts_current_zone = last_zone;\n}\n\nstatic bool\nchange_map(const char* filename, bool preserve_persons)\n{\n\t// note: if an error is detected during a map change, change_map() will return false, but\n\t//       the map engine may be left in an inconsistent state. it is therefore probably wise\n\t//       to consider such a situation unrecoverable.\n\n\tstruct map*        map;\n\tperson_t*          person;\n\tstruct map_person* person_info;\n\tpath_t*            path;\n\tspriteset_t*       spriteset = NULL;\n\n\tint i;\n\n\tconsole_log(2, \"changing current map to '%s'\", filename);\n\n\tmap = load_map(filename);\n\tif (map == NULL) return false;\n\tif (s_map != NULL) {\n\t\t// run map exit scripts first, before loading new map\n\t\tmap_activate(MAP_SCRIPT_ON_LEAVE, true);\n\t}\n\n\t// close out old map and prep for new one\n\tfree_map(s_map); free(s_map_filename);\n\tfor (i = 0; i < s_num_deferreds; ++i)\n\t\tscript_unref(s_deferreds[i].script);\n\ts_num_deferreds = 0;\n\ts_map = map; s_map_filename = strdup(filename);\n\treset_persons(preserve_persons);\n\n\t// populate persons\n\tfor (i = 0; i < s_map->num_persons; ++i) {\n\t\tperson_info = &s_map->persons[i];\n\t\tpath = game_full_path(g_game, lstr_cstr(person_info->spriteset), \"spritesets\", true);\n\t\tspriteset = spriteset_load(path_cstr(path));\n\t\tpath_free(path);\n\t\tif (spriteset == NULL)\n\t\t\tgoto on_error;\n\t\tif (!(person = person_new(lstr_cstr(person_info->name), spriteset, false, NULL)))\n\t\t\tgoto on_error;\n\t\tspriteset_unref(spriteset);\n\t\tperson_set_xyz(person, person_info->x, person_info->y, person_info->z);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_CREATE, person_info->create_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_DESTROY, person_info->destroy_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_TOUCH, person_info->touch_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_ON_TALK, person_info->talk_script);\n\t\tperson_compile_script(person, PERSON_SCRIPT_GENERATOR, person_info->command_script);\n\n\t\t// normally this is handled by person_new(), but since in this case the\n\t\t// person-specific create script isn't compiled until after the person is created,\n\t\t// the map engine gets the responsibility.\n\t\tperson_activate(person, PERSON_SCRIPT_ON_CREATE, NULL, false);\n\t}\n\n\t// set camera over starting position\n\ts_camera_x = s_map->origin.x;\n\ts_camera_y = s_map->origin.y;\n\n\t// start up map BGM (if same as previous, leave alone)\n\tif (s_map->bgm_file == NULL && s_map_bgm_stream != NULL) {\n\t\tsound_unref(s_map_bgm_stream);\n\t\tlstr_free(s_last_bgm_file);\n\t\ts_map_bgm_stream = NULL;\n\t\ts_last_bgm_file = NULL;\n\t}\n\telse if (s_map->bgm_file != NULL\n\t\t&& (s_last_bgm_file == NULL || lstr_cmp(s_map->bgm_file, s_last_bgm_file) != 0))\n\t{\n\t\tsound_unref(s_map_bgm_stream);\n\t\tlstr_free(s_last_bgm_file);\n\t\ts_last_bgm_file = lstr_dup(s_map->bgm_file);\n\t\tpath = game_full_path(g_game, lstr_cstr(s_map->bgm_file), \"sounds\", true);\n\t\tif ((s_map_bgm_stream = sound_new(path_cstr(path)))) {\n\t\t\tsound_set_repeat(s_map_bgm_stream, true);\n\t\t\tsound_play(s_map_bgm_stream, s_bgm_mixer);\n\t\t}\n\t\tpath_free(path);\n\t}\n\n\t// run map entry scripts\n\tmap_activate(MAP_SCRIPT_ON_ENTER, true);\n\n\ts_frames = 0;\n\treturn true;\n\non_error:\n\tspriteset_unref(spriteset);\n\tfree_map(s_map);\n\treturn false;\n}\n\nstatic void\ncommand_person(person_t* person, int command)\n{\n\tdouble    new_x;\n\tdouble    new_y;\n\tperson_t* person_to_touch;\n\n\tnew_x = person->x;\n\tnew_y = person->y;\n\tswitch (command) {\n\tcase COMMAND_ANIMATE:\n\t\tperson->revert_frames = person->revert_delay;\n\t\tif (person->anim_frames > 0 && --person->anim_frames == 0) {\n\t\t\t++person->frame;\n\t\t\tperson->anim_frames = spriteset_frame_delay(person->sprite, person->direction, person->frame);\n\t\t}\n\t\tbreak;\n\tcase COMMAND_FACE_NORTH:\n\t\tperson_set_pose(person, \"north\");\n\t\tbreak;\n\tcase COMMAND_FACE_NORTHEAST:\n\t\tperson_set_pose(person, \"northeast\");\n\t\tbreak;\n\tcase COMMAND_FACE_EAST:\n\t\tperson_set_pose(person, \"east\");\n\t\tbreak;\n\tcase COMMAND_FACE_SOUTHEAST:\n\t\tperson_set_pose(person, \"southeast\");\n\t\tbreak;\n\tcase COMMAND_FACE_SOUTH:\n\t\tperson_set_pose(person, \"south\");\n\t\tbreak;\n\tcase COMMAND_FACE_SOUTHWEST:\n\t\tperson_set_pose(person, \"southwest\");\n\t\tbreak;\n\tcase COMMAND_FACE_WEST:\n\t\tperson_set_pose(person, \"west\");\n\t\tbreak;\n\tcase COMMAND_FACE_NORTHWEST:\n\t\tperson_set_pose(person, \"northwest\");\n\t\tbreak;\n\tcase COMMAND_MOVE_NORTH:\n\t\tnew_y = person->y - person->speed_y;\n\t\tbreak;\n\tcase COMMAND_MOVE_EAST:\n\t\tnew_x = person->x + person->speed_x;\n\t\tbreak;\n\tcase COMMAND_MOVE_SOUTH:\n\t\tnew_y = person->y + person->speed_y;\n\t\tbreak;\n\tcase COMMAND_MOVE_WEST:\n\t\tnew_x = person->x - person->speed_x;\n\t\tbreak;\n\t}\n\tif (new_x != person->x || new_y != person->y) {\n\t\t// person is trying to move, make sure the path is clear of obstructions\n\t\tif (!person_obstructed_at(person, new_x, new_y, &person_to_touch, NULL)) {\n\t\t\tif (new_x != person->x)\n\t\t\t\tperson->mv_x = new_x > person->x ? 1 : -1;\n\t\t\tif (new_y != person->y)\n\t\t\t\tperson->mv_y = new_y > person->y ? 1 : -1;\n\t\t\tperson->x = new_x;\n\t\t\tperson->y = new_y;\n\t\t}\n\t\telse {\n\t\t\t// if not, and we collided with a person, call that person's touch script\n\t\t\tif (person_to_touch != NULL)\n\t\t\t\tperson_activate(person_to_touch, PERSON_SCRIPT_ON_TOUCH, person, true);\n\t\t}\n\t}\n}\n\nstatic int\ncompare_persons(const void* a, const void* b)\n{\n\tperson_t* p1 = *(person_t**)a;\n\tperson_t* p2 = *(person_t**)b;\n\n\tdouble x, y_p1, y_p2;\n\tint    y_delta;\n\n\tperson_get_xy(p1, &x, &y_p1, true);\n\tperson_get_xy(p2, &x, &y_p2, true);\n\ty_delta = y_p1 - y_p2;\n\tif (y_delta != 0)\n\t\treturn y_delta;\n\telse if (person_following(p1, p2))\n\t\treturn -1;\n\telse if (person_following(p2, p1))\n\t\treturn 1;\n\telse\n\t\treturn p1->id - p2->id;\n}\n\nstatic void\ndetach_person(const person_t* person)\n{\n\tint i;\n\n\tif (s_camera_person == person)\n\t\ts_camera_person = NULL;\n\tfor (i = 0; i < PLAYER_MAX; ++i) {\n\t\tif (s_players[i].person == person)\n\t\t\ts_players[i].person = NULL;\n\t}\n}\n\nstatic bool\ndoes_person_exist(const person_t* person)\n{\n\tint i;\n\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tif (person == s_persons[i]) return true;\n\treturn false;\n}\n\nvoid\ndraw_persons(int layer, bool is_flipped, int cam_x, int cam_y)\n{\n\tperson_t*    person;\n\tspriteset_t* sprite;\n\tint          w, h;\n\tdouble       x, y;\n\tint          i;\n\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tperson = s_persons[i];\n\t\tif (!person->is_visible || person->layer != layer)\n\t\t\tcontinue;\n\t\tsprite = person->sprite;\n\t\tw = spriteset_width(sprite);\n\t\th = spriteset_height(sprite);\n\t\tperson_get_xy(person, &x, &y, true);\n\t\tx -= cam_x - person->x_offset;\n\t\ty -= cam_y - person->y_offset;\n\t\tspriteset_draw(sprite, person->mask, is_flipped, person->theta, person->scale_x, person->scale_y,\n\t\t\tperson->direction, trunc(x), trunc(y), person->frame);\n\t}\n}\n\nstatic bool\nenlarge_step_history(person_t* person, int new_size)\n{\n\tstruct step *new_steps;\n\tsize_t      pastmost;\n\tdouble      last_x;\n\tdouble      last_y;\n\n\tint i;\n\n\tif (new_size > person->max_history) {\n\t\tif (!(new_steps = realloc(person->steps, new_size * sizeof(struct step))))\n\t\t\treturn false;\n\n\t\t// when enlarging the history buffer, fill new slots with pastmost values\n\t\t// (kind of like sign extension)\n\t\tpastmost = person->max_history - 1;\n\t\tlast_x = person->steps != NULL ? person->steps[pastmost].x : person->x;\n\t\tlast_y = person->steps != NULL ? person->steps[pastmost].y : person->y;\n\t\tfor (i = person->max_history; i < new_size; ++i) {\n\t\t\tnew_steps[i].x = last_x;\n\t\t\tnew_steps[i].y = last_y;\n\t\t}\n\t\tperson->steps = new_steps;\n\t\tperson->max_history = new_size;\n\t}\n\n\treturn true;\n}\n\nstatic void\nfree_map(struct map* map)\n{\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\n\titer_t iter;\n\tint    i;\n\n\tif (map == NULL)\n\t\treturn;\n\tfor (i = 0; i < MAP_SCRIPT_MAX; ++i)\n\t\tscript_unref(map->scripts[i]);\n\tfor (i = 0; i < map->num_layers; ++i) {\n\t\tscript_unref(map->layers[i].render_script);\n\t\tlstr_free(map->layers[i].name);\n\t\tfree(map->layers[i].tilemap);\n\t\tobsmap_free(map->layers[i].obsmap);\n\t}\n\tfor (i = 0; i < map->num_persons; ++i) {\n\t\tlstr_free(map->persons[i].name);\n\t\tlstr_free(map->persons[i].spriteset);\n\t\tlstr_free(map->persons[i].create_script);\n\t\tlstr_free(map->persons[i].destroy_script);\n\t\tlstr_free(map->persons[i].command_script);\n\t\tlstr_free(map->persons[i].talk_script);\n\t\tlstr_free(map->persons[i].touch_script);\n\t}\n\titer = vector_enum(s_map->triggers);\n\twhile ((trigger = iter_next(&iter)))\n\t\tscript_unref(trigger->script);\n\titer = vector_enum(s_map->zones);\n\twhile ((zone = iter_next(&iter)))\n\t\tscript_unref(zone->script);\n\tlstr_free(s_map->bgm_file);\n\ttileset_free(map->tileset);\n\tfree(map->layers);\n\tfree(map->persons);\n\tvector_free(map->triggers);\n\tvector_free(map->zones);\n\tfree(map);\n}\n\nstatic void\nfree_person(person_t* person)\n{\n\tint i;\n\n\tfree(person->steps);\n\tfor (i = 0; i < PERSON_SCRIPT_MAX; ++i)\n\t\tscript_unref(person->scripts[i]);\n\tspriteset_unref(person->sprite);\n\tfree(person->commands);\n\tfree(person->name);\n\tfree(person->direction);\n\tfree(person);\n}\n\nstatic struct map_trigger*\nget_trigger_at(int x, int y, int layer, int* out_index)\n{\n\trect_t              bounds;\n\tstruct map_trigger* found_item = NULL;\n\tint                 tile_w, tile_h;\n\tstruct map_trigger* trigger;\n\n\titer_t iter;\n\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\titer = vector_enum(s_map->triggers);\n\twhile ((trigger = iter_next(&iter))) {\n\t\tif (trigger->z != layer && false)  // layer ignored for compatibility reasons\n\t\t\tcontinue;\n\t\tbounds.x1 = trigger->x - tile_w / 2;\n\t\tbounds.y1 = trigger->y - tile_h / 2;\n\t\tbounds.x2 = bounds.x1 + tile_w;\n\t\tbounds.y2 = bounds.y1 + tile_h;\n\t\tif (is_point_in_rect(x, y, bounds)) {\n\t\t\tfound_item = trigger;\n\t\t\tif (out_index != NULL)\n\t\t\t\t*out_index = (int)iter.index;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found_item;\n}\n\nstatic struct map_zone*\nget_zone_at(int x, int y, int layer, int which, int* out_index)\n{\n\tstruct map_zone* found_item = NULL;\n\tstruct map_zone* zone;\n\n\titer_t iter;\n\tint    i;\n\n\titer = vector_enum(s_map->zones); i = -1;\n\twhile ((zone = iter_next(&iter))) {\n\t\tif (zone->layer != layer && false)  // layer ignored for compatibility\n\t\t\tcontinue;\n\t\tif (is_point_in_rect(x, y, zone->bounds) && which-- == 0) {\n\t\t\tfound_item = zone;\n\t\t\tif (out_index) *out_index = (int)iter.index;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found_item;\n}\n\nstatic struct map*\nload_map(const char* filename)\n{\n\t// strings: 0 - tileset filename\n\t//          1 - music filename\n\t//          2 - script filename (obsolete, not used)\n\t//          3 - entry script\n\t//          4 - exit script\n\t//          5 - exit north script\n\t//          6 - exit east script\n\t//          7 - exit south script\n\t//          8 - exit west script\n\n\tuint16_t                 count;\n\tstruct rmp_entity_header entity_hdr;\n\tfile_t*                  file = NULL;\n\tbool                     has_failed;\n\tstruct map_layer*        layer;\n\tstruct rmp_layer_header  layer_hdr;\n\tstruct map*              map = NULL;\n\tint                      num_tiles;\n\tstruct map_person*       person;\n\tstruct rmp_header        rmp;\n\tlstring_t*               script;\n\trect_t                   segment;\n\tint16_t*                 tile_data = NULL;\n\tpath_t*                  tileset_path;\n\ttileset_t*               tileset;\n\tstruct map_trigger       trigger;\n\tstruct map_zone          zone;\n\tstruct rmp_zone_header   zone_hdr;\n\tlstring_t*               *strings = NULL;\n\n\tint i, j, x, y, z;\n\n\tconsole_log(2, \"constructing new map from '%s'\", filename);\n\n\tmemset(&rmp, 0, sizeof(struct rmp_header));\n\n\tif (!(file = file_open(g_game, filename, \"rb\")))\n\t\tgoto on_error;\n\tmap = calloc(1, sizeof(struct map));\n\tif (file_read(file, &rmp, 1, sizeof(struct rmp_header)) != 1)\n\t\tgoto on_error;\n\tif (memcmp(rmp.signature, \".rmp\", 4) != 0) goto on_error;\n\tif (rmp.num_strings != 3 && rmp.num_strings != 5 && rmp.num_strings < 9)\n\t\tgoto on_error;\n\tif (rmp.start_layer < 0 || rmp.start_layer >= rmp.num_layers)\n\t\trmp.start_layer = 0;  // being nice here, this really should fail outright\n\tswitch (rmp.version) {\n\tcase 1:\n\t\t// load strings (resource filenames, scripts, etc.)\n\t\tstrings = calloc(rmp.num_strings, sizeof(lstring_t*));\n\t\thas_failed = false;\n\t\tfor (i = 0; i < rmp.num_strings; ++i)\n\t\t\thas_failed = has_failed || ((strings[i] = read_lstring(file, true)) == NULL);\n\t\tif (has_failed) goto on_error;\n\n\t\t// pre-allocate map structures\n\t\tmap->layers = calloc(rmp.num_layers, sizeof(struct map_layer));\n\t\tmap->persons = calloc(rmp.num_entities, sizeof(struct map_person));\n\t\tmap->triggers = vector_new(sizeof(struct map_trigger));\n\t\tmap->zones = vector_new(sizeof(struct map_zone));\n\n\t\t// load layers\n\t\tfor (i = 0; i < rmp.num_layers; ++i) {\n\t\t\tif (file_read(file, &layer_hdr, 1, sizeof(struct rmp_layer_header)) != 1)\n\t\t\t\tgoto on_error;\n\t\t\tlayer = &map->layers[i];\n\t\t\tlayer->is_parallax = (layer_hdr.flags & 2) != 0x0;\n\t\t\tlayer->is_reflective = layer_hdr.is_reflective;\n\t\t\tlayer->is_visible = (layer_hdr.flags & 1) == 0x0;\n\t\t\tlayer->color_mask = mk_color(255, 255, 255, 255);\n\t\t\tlayer->width = layer_hdr.width;\n\t\t\tlayer->height = layer_hdr.height;\n\t\t\tlayer->autoscroll_x = layer->is_parallax ? layer_hdr.scrolling_x : 0.0;\n\t\t\tlayer->autoscroll_y = layer->is_parallax ? layer_hdr.scrolling_y : 0.0;\n\t\t\tlayer->parallax_x = layer->is_parallax ? layer_hdr.parallax_x : 1.0;\n\t\t\tlayer->parallax_y = layer->is_parallax ? layer_hdr.parallax_y : 1.0;\n\t\t\tif (!layer->is_parallax) {\n\t\t\t\tmap->width = fmax(map->width, layer->width);\n\t\t\t\tmap->height = fmax(map->height, layer->height);\n\t\t\t}\n\t\t\tif (!(layer->tilemap = malloc(layer_hdr.width * layer_hdr.height * sizeof(struct map_tile))))\n\t\t\t\tgoto on_error;\n\t\t\tlayer->name = read_lstring(file, true);\n\t\t\tlayer->obsmap = obsmap_new();\n\t\t\tnum_tiles = layer_hdr.width * layer_hdr.height;\n\t\t\tif ((tile_data = malloc(num_tiles * 2)) == NULL)\n\t\t\t\tgoto on_error;\n\t\t\tif (file_read(file, tile_data, num_tiles, 2) != num_tiles)\n\t\t\t\tgoto on_error;\n\t\t\tfor (j = 0; j < num_tiles; ++j)\n\t\t\t\tlayer->tilemap[j].tile_index = tile_data[j];\n\t\t\tfor (j = 0; j < layer_hdr.num_segments; ++j) {\n\t\t\t\tif (!fread_rect32(file, &segment)) goto on_error;\n\t\t\t\tobsmap_add_line(layer->obsmap, segment);\n\t\t\t}\n\t\t\tfree(tile_data);\n\t\t\ttile_data = NULL;\n\t\t}\n\n\t\t// if either dimension is zero, the map has no non-parallax layers and is thus malformed\n\t\tif (map->width == 0 || map->height == 0)\n\t\t\tgoto on_error;\n\n\t\t// load entities\n\t\tmap->num_persons = 0;\n\t\tfor (i = 0; i < rmp.num_entities; ++i) {\n\t\t\tif (file_read(file, &entity_hdr, 1, sizeof(struct rmp_entity_header)) != 1)\n\t\t\t\tgoto on_error;\n\t\t\tif (entity_hdr.z < 0 || entity_hdr.z >= rmp.num_layers)\n\t\t\t\tentity_hdr.z = 0;\n\t\t\tswitch (entity_hdr.type) {\n\t\t\tcase 1:  // person\n\t\t\t\t++map->num_persons;\n\t\t\t\tperson = &map->persons[map->num_persons - 1];\n\t\t\t\tmemset(person, 0, sizeof(struct map_person));\n\t\t\t\tif (!(person->name = read_lstring(file, true)))\n\t\t\t\t\tgoto on_error;\n\t\t\t\tif (!(person->spriteset = read_lstring(file, true)))\n\t\t\t\t\tgoto on_error;\n\t\t\t\tperson->x = entity_hdr.x; person->y = entity_hdr.y; person->z = entity_hdr.z;\n\t\t\t\tif (file_read(file, &count, 1, 2) != 1 || count < 5)\n\t\t\t\t\tgoto on_error;\n\t\t\t\tperson->create_script = read_lstring(file, false);\n\t\t\t\tperson->destroy_script = read_lstring(file, false);\n\t\t\t\tperson->touch_script = read_lstring(file, false);\n\t\t\t\tperson->talk_script = read_lstring(file, false);\n\t\t\t\tperson->command_script = read_lstring(file, false);\n\t\t\t\tfor (j = 5; j < count; ++j)\n\t\t\t\t\tlstr_free(read_lstring(file, true));\n\t\t\t\tfile_seek(file, 16, WHENCE_CUR);\n\t\t\t\tbreak;\n\t\t\tcase 2:  // trigger\n\t\t\t\tif ((script = read_lstring(file, false)) == NULL) goto on_error;\n\t\t\t\tmemset(&trigger, 0, sizeof(struct map_trigger));\n\t\t\t\ttrigger.x = entity_hdr.x;\n\t\t\t\ttrigger.y = entity_hdr.y;\n\t\t\t\ttrigger.z = entity_hdr.z;\n\t\t\t\ttrigger.script = script_new(script, \"%s/trig%d\", filename, vector_len(map->triggers));\n\t\t\t\tif (!vector_push(map->triggers, &trigger))\n\t\t\t\t\treturn false;\n\t\t\t\tlstr_free(script);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\t// load zones\n\t\tfor (i = 0; i < rmp.num_zones; ++i) {\n\t\t\tif (file_read(file, &zone_hdr, 1, sizeof(struct rmp_zone_header)) != 1)\n\t\t\t\tgoto on_error;\n\t\t\tif ((script = read_lstring(file, false)) == NULL) goto on_error;\n\t\t\tif (zone_hdr.layer < 0 || zone_hdr.layer >= rmp.num_layers)\n\t\t\t\tzone_hdr.layer = 0;\n\t\t\tzone.layer = zone_hdr.layer;\n\t\t\tzone.bounds = mk_rect(zone_hdr.x1, zone_hdr.y1, zone_hdr.x2, zone_hdr.y2);\n\t\t\tzone.interval = zone_hdr.interval;\n\t\t\tzone.steps_left = 0;\n\t\t\tzone.script = script_new(script, \"%s/zone%d\", filename, vector_len(map->zones));\n\t\t\trect_normalize(&zone.bounds);\n\t\t\tif (!vector_push(map->zones, &zone))\n\t\t\t\treturn false;\n\t\t\tlstr_free(script);\n\t\t}\n\n\t\t// load tileset\n\t\tif (strcmp(lstr_cstr(strings[0]), \"\") != 0) {\n\t\t\ttileset_path = path_strip(path_new(filename));\n\t\t\tpath_append(tileset_path, lstr_cstr(strings[0]));\n\t\t\ttileset = tileset_new(path_cstr(tileset_path));\n\t\t\tpath_free(tileset_path);\n\t\t}\n\t\telse {\n\t\t\ttileset = tileset_read(file);\n\t\t}\n\t\tif (tileset == NULL) goto on_error;\n\n\t\t// initialize tile animation\n\t\tfor (z = 0; z < rmp.num_layers; ++z) {\n\t\t\tlayer = &map->layers[z];\n\t\t\tfor (x = 0; x < layer->width; ++x) for (y = 0; y < layer->height; ++y) {\n\t\t\t\ti = x + y * layer->width;\n\t\t\t\tmap->layers[z].tilemap[i].frames_left =\n\t\t\t\t\ttileset_get_delay(tileset, map->layers[z].tilemap[i].tile_index);\n\t\t\t}\n\t\t}\n\n\t\t// wrap things up\n\t\tmap->bgm_file = strcmp(lstr_cstr(strings[1]), \"\") != 0\n\t\t\t? lstr_dup(strings[1]) : NULL;\n\t\tmap->num_layers = rmp.num_layers;\n\t\tmap->is_repeating = rmp.repeat_map;\n\t\tmap->origin.x = rmp.start_x;\n\t\tmap->origin.y = rmp.start_y;\n\t\tmap->origin.z = rmp.start_layer;\n\t\tmap->tileset = tileset;\n\t\tif (rmp.num_strings >= 5) {\n\t\t\tmap->scripts[MAP_SCRIPT_ON_ENTER] = script_new(strings[3], \"%s/onEnter\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE] = script_new(strings[4], \"%s/onLeave\", filename);\n\t\t}\n\t\tif (rmp.num_strings >= 9) {\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_NORTH] = script_new(strings[5], \"%s/onLeave\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_EAST] = script_new(strings[6], \"%s/onLeaveEast\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_SOUTH] = script_new(strings[7], \"%s/onLeaveSouth\", filename);\n\t\t\tmap->scripts[MAP_SCRIPT_ON_LEAVE_WEST] = script_new(strings[8], \"%s/onLeaveWest\", filename);\n\t\t}\n\t\tfor (i = 0; i < rmp.num_strings; ++i)\n\t\t\tlstr_free(strings[i]);\n\t\tfree(strings);\n\t\tbreak;\n\tdefault:\n\t\tgoto on_error;\n\t}\n\tfile_close(file);\n\treturn map;\n\non_error:\n\tif (file != NULL) file_close(file);\n\tfree(tile_data);\n\tif (strings != NULL) {\n\t\tfor (i = 0; i < rmp.num_strings; ++i) lstr_free(strings[i]);\n\t\tfree(strings);\n\t}\n\tif (map != NULL) {\n\t\tif (map->layers != NULL) {\n\t\t\tfor (i = 0; i < rmp.num_layers; ++i) {\n\t\t\t\tlstr_free(map->layers[i].name);\n\t\t\t\tfree(map->layers[i].tilemap);\n\t\t\t\tobsmap_free(map->layers[i].obsmap);\n\t\t\t}\n\t\t\tfree(map->layers);\n\t\t}\n\t\tif (map->persons != NULL) {\n\t\t\tfor (i = 0; i < map->num_persons; ++i) {\n\t\t\t\tlstr_free(map->persons[i].name);\n\t\t\t\tlstr_free(map->persons[i].spriteset);\n\t\t\t\tlstr_free(map->persons[i].create_script);\n\t\t\t\tlstr_free(map->persons[i].destroy_script);\n\t\t\t\tlstr_free(map->persons[i].command_script);\n\t\t\t\tlstr_free(map->persons[i].talk_script);\n\t\t\t\tlstr_free(map->persons[i].touch_script);\n\t\t\t}\n\t\t\tfree(map->persons);\n\t\t}\n\t\tvector_free(map->triggers);\n\t\tvector_free(map->zones);\n\t\tfree(map);\n\t}\n\treturn NULL;\n}\n\nvoid\nmap_screen_to_layer(int layer, int camera_x, int camera_y, int* inout_x, int* inout_y)\n{\n\trect_t  bounds;\n\tint     center_x;\n\tint     center_y;\n\tint     layer_h;\n\tint     layer_w;\n\tfloat   plx_offset_x = 0.0;\n\tint     plx_offset_y = 0.0;\n\tsize2_t resolution;\n\tint     tile_w;\n\tint     tile_h;\n\tint     x_offset;\n\tint     y_offset;\n\n\t// get layer and screen metrics\n\tresolution = screen_size(g_screen);\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tlayer_w = s_map->layers[layer].width * tile_w;\n\tlayer_h = s_map->layers[layer].height * tile_h;\n\tcenter_x = resolution.width / 2;\n\tcenter_y = resolution.height / 2;\n\n\t// initial camera correction\n\tif (!s_map->is_repeating) {\n\t\tbounds = map_bounds();\n\t\tcamera_x = fmin(fmax(camera_x, bounds.x1 + center_x), bounds.x2 - center_x);\n\t\tcamera_y = fmin(fmax(camera_y, bounds.y1 + center_y), bounds.y2 - center_y);\n\t}\n\n\t// remap screen coordinates to layer coordinates\n\tplx_offset_x = s_frames * s_map->layers[layer].autoscroll_x\n\t\t- camera_x * (s_map->layers[layer].parallax_x - 1.0);\n\tplx_offset_y = s_frames * s_map->layers[layer].autoscroll_y\n\t\t- camera_y * (s_map->layers[layer].parallax_y - 1.0);\n\tx_offset = camera_x - center_x - plx_offset_x;\n\ty_offset = camera_y - center_y - plx_offset_y;\n\tif (!s_map->is_repeating && !s_map->layers[layer].is_parallax) {\n\t\t// if the map is smaller than the screen, align to top left.  centering\n\t\t// would be better aesthetically, but there are a couple Sphere 1.x games\n\t\t// that depend on top-left justification.\n\t\tif (layer_w < resolution.width)\n\t\t\tx_offset = 0;\n\t\tif (layer_h < resolution.height)\n\t\t\ty_offset = 0;\n\t}\n\tif (inout_x != NULL)\n\t\t*inout_x += x_offset;\n\tif (inout_y != NULL)\n\t\t*inout_y += y_offset;\n\n\t// normalize coordinates. this simplifies rendering calculations.\n\tif (s_map->is_repeating || s_map->layers[layer].is_parallax) {\n\t\tif (inout_x) *inout_x = (*inout_x % layer_w + layer_w) % layer_w;\n\t\tif (inout_y) *inout_y = (*inout_y % layer_h + layer_h) % layer_h;\n\t}\n}\n\nstatic void\nmap_screen_to_map(int camera_x, int camera_y, int* inout_x, int* inout_y)\n{\n\trect_t  bounds;\n\tint     center_x;\n\tint     center_y;\n\tint     map_h;\n\tint     map_w;\n\tsize2_t resolution;\n\tint     tile_h;\n\tint     tile_w;\n\tint     x_offset;\n\tint     y_offset;\n\n\t// get layer and screen metrics\n\tresolution = screen_size(g_screen);\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tmap_w = s_map->width * tile_w;\n\tmap_h = s_map->height * tile_h;\n\tcenter_x = resolution.width / 2;\n\tcenter_y = resolution.height / 2;\n\n\t// initial camera correction\n\tif (!s_map->is_repeating) {\n\t\tbounds = map_bounds();\n\t\tcamera_x = fmin(fmax(camera_x, bounds.x1 + center_x), bounds.x2 - center_x);\n\t\tcamera_y = fmin(fmax(camera_y, bounds.y1 + center_y), bounds.y2 - center_y);\n\t}\n\n\t// remap screen coordinates to map coordinates\n\tx_offset = camera_x - center_x;\n\ty_offset = camera_y - center_y;\n\tif (!s_map->is_repeating) {\n\t\t// if the map is smaller than the screen, align to top left.  centering\n\t\t// would be better aesthetically, but there are a couple Sphere 1.x games\n\t\t// that depend on top-left justification.\n\t\tif (map_w < resolution.width)\n\t\t\tx_offset = 0;\n\t\tif (map_h < resolution.height)\n\t\t\ty_offset = 0;\n\t}\n\tif (inout_x != NULL)\n\t\t*inout_x += x_offset;\n\tif (inout_y != NULL)\n\t\t*inout_y += y_offset;\n\n\t// normalize coordinates\n\tif (s_map->is_repeating) {\n\t\tif (inout_x) *inout_x = (*inout_x % map_w + map_w) % map_w;\n\t\tif (inout_y) *inout_y = (*inout_y % map_h + map_h) % map_h;\n\t}\n}\n\nstatic void\nprocess_map_input(void)\n{\n\tint       mv_x, mv_y;\n\tperson_t* person;\n\n\tint i;\n\n\t// clear out excess keys from key queue\n\tkb_clear_queue();\n\n\t// check for player control of input persons, if there are any\n\tfor (i = 0; i < PLAYER_MAX; ++i) {\n\t\tperson = s_players[i].person;\n\t\tif (person != NULL) {\n\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_A))\n\t\t\t\t|| kb_is_key_down(s_players[i].talk_key)\n\t\t\t\t|| joy_is_button_down(i, s_talk_button))\n\t\t\t{\n\t\t\t\tif (s_players[i].is_talk_allowed)\n\t\t\t\t\tperson_talk(person);\n\t\t\t\ts_players[i].is_talk_allowed = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// allow talking again only after key is released\n\t\t\t\ts_players[i].is_talk_allowed = true;\n\t\t\t}\n\t\t\tmv_x = 0; mv_y = 0;\n\t\t\tif (person->num_commands == 0 && person->leader == NULL) {\n\t\t\t\t// allow player control only if the input person is idle and not being led around\n\t\t\t\t// by someone else.\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_UP)) || joy_position(i, 1) <= -0.5)\n\t\t\t\t\tmv_y = -1;\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_RIGHT)) || joy_position(i, 0) >= 0.5)\n\t\t\t\t\tmv_x = 1;\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_DOWN)) || joy_position(i, 1) >= 0.5)\n\t\t\t\t\tmv_y = 1;\n\t\t\t\tif (kb_is_key_down(get_player_key(i, PLAYER_KEY_LEFT)) || joy_position(i, 0) <= -0.5)\n\t\t\t\t\tmv_x = -1;\n\t\t\t}\n\t\t\tswitch (mv_x + mv_y * 3) {\n\t\t\tcase -3: // north\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_NORTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_NORTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase -2: // northeast\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_NORTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_NORTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 1: // east\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_EAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_EAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 4: // southeast\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_SOUTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_SOUTHEAST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 3: // south\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_SOUTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_SOUTH, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase 2: // southwest\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_SOUTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_SOUTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase -1: // west\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_WEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_WEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\tcase -4: // northwest\n\t\t\t\tperson_queue_command(person, COMMAND_MOVE_NORTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_FACE_NORTHWEST, true);\n\t\t\t\tperson_queue_command(person, COMMAND_ANIMATE, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate_bound_keys(true);\n}\n\nstatic void\nrecord_step(person_t* person)\n{\n\tstruct step* p_step;\n\n\tif (person->max_history <= 0)\n\t\treturn;\n\tmemmove(&person->steps[1], &person->steps[0], (person->max_history - 1) * sizeof(struct step));\n\tp_step = &person->steps[0];\n\tp_step->x = person->x;\n\tp_step->y = person->y;\n}\n\nvoid\nreset_persons(bool keep_existing)\n{\n\tunsigned int id;\n\tpoint3_t     origin;\n\tperson_t*    person;\n\n\tint i, j;\n\n\torigin = map_origin();\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tperson = s_persons[i];\n\t\tid = person->id;\n\t\tif (!keep_existing)\n\t\t\tperson->num_commands = 0;\n\t\tif (person->is_persistent || keep_existing) {\n\t\t\tperson->x = origin.x;\n\t\t\tperson->y = origin.y;\n\t\t\tperson->layer = origin.z;\n\t\t}\n\t\telse {\n\t\t\tperson_activate(person, PERSON_SCRIPT_ON_DESTROY, NULL, true);\n\t\t\tfree_person(person);\n\t\t\t--s_num_persons;\n\t\t\tfor (j = i; j < s_num_persons; ++j)\n\t\t\t\ts_persons[j] = s_persons[j + 1];\n\t\t\t--i;\n\t\t}\n\t}\n\tsort_persons();\n}\n\nstatic void\nset_person_name(person_t* person, const char* name)\n{\n\tperson->name = realloc(person->name, (strlen(name) + 1) * sizeof(char));\n\tstrcpy(person->name, name);\n}\n\nstatic void\nsort_persons(void)\n{\n\tqsort(s_persons, s_num_persons, sizeof(person_t*), compare_persons);\n}\n\nstatic void\nupdate_map_engine(bool in_main_loop)\n{\n\tbool                has_moved;\n\tint                 index;\n\tbool                is_sort_needed = false;\n\tint                 last_trigger;\n\tint                 last_zone;\n\tint                 layer;\n\tint                 map_w, map_h;\n\tint                 num_zone_steps;\n\tscript_t*           script_to_run;\n\tint                 script_type;\n\tdouble              start_x[PLAYER_MAX];\n\tdouble              start_y[PLAYER_MAX];\n\tint                 tile_w, tile_h;\n\tstruct map_trigger* trigger;\n\tdouble              x, y, px, py;\n\tstruct map_zone*    zone;\n\n\tint i, j, k;\n\n\t++s_frames;\n\ttileset_get_size(s_map->tileset, &tile_w, &tile_h);\n\tmap_w = s_map->width * tile_w;\n\tmap_h = s_map->height * tile_h;\n\n\ttileset_update(s_map->tileset);\n\n\tfor (i = 0; i < PLAYER_MAX; ++i) if (s_players[i].person != NULL)\n\t\tperson_get_xy(s_players[i].person, &start_x[i], &start_y[i], false);\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i]->leader != NULL)\n\t\t\tcontinue;  // skip followers for now\n\t\tupdate_person(s_persons[i], &has_moved);\n\t\tis_sort_needed |= has_moved;\n\t}\n\tif (is_sort_needed)\n\t\tsort_persons();\n\n\t// update color mask fade level\n\tif (s_fade_progress < s_fade_frames) {\n\t\t++s_fade_progress;\n\t\ts_color_mask = color_mix(s_fade_color_to, s_fade_color_from,\n\t\t\ts_fade_progress, s_fade_frames - s_fade_progress);\n\t}\n\n\t// update camera\n\tif (s_camera_person != NULL) {\n\t\tperson_get_xy(s_camera_person, &x, &y, true);\n\t\ts_camera_x = x; s_camera_y = y;\n\t}\n\n\t// run edge script if the camera has moved past the edge of the map\n\t// note: only applies for non-repeating maps\n\tif (in_main_loop && !s_map->is_repeating) {\n\t\tscript_type = s_camera_y < 0 ? MAP_SCRIPT_ON_LEAVE_NORTH\n\t\t\t: s_camera_x >= map_w ? MAP_SCRIPT_ON_LEAVE_EAST\n\t\t\t: s_camera_y >= map_h ? MAP_SCRIPT_ON_LEAVE_SOUTH\n\t\t\t: s_camera_x < 0 ? MAP_SCRIPT_ON_LEAVE_WEST\n\t\t\t: MAP_SCRIPT_MAX;\n\t\tif (script_type < MAP_SCRIPT_MAX)\n\t\t\tmap_activate(script_type, true);\n\t}\n\n\t// if there are any input persons, check for trigger activation\n\tfor (i = 0; i < PLAYER_MAX; ++i) if (s_players[i].person != NULL) {\n\t\t// did we step on a trigger or move to a new one?\n\t\tperson_get_xyz(s_players[i].person, &x, &y, &layer, true);\n\t\ttrigger = get_trigger_at(x, y, layer, &index);\n\t\tif (trigger != s_on_trigger) {\n\t\t\tlast_trigger = s_current_trigger;\n\t\t\ts_current_trigger = index;\n\t\t\ts_on_trigger = trigger;\n\t\t\tif (trigger != NULL)\n\t\t\t\tscript_run(trigger->script, false);\n\t\t\ts_current_trigger = last_trigger;\n\t\t}\n\t}\n\n\t// update any zones occupied by the input person\n\t// note: a zone's step count is in reality a pixel count, so a zone\n\t//       may be updated multiple times in a single frame.\n\tfor (k = 0; k < PLAYER_MAX; ++k) if (s_players[k].person != NULL) {\n\t\tperson_get_xy(s_players[k].person, &x, &y, false);\n\t\tpx = fabs(x - start_x[k]);\n\t\tpy = fabs(y - start_y[k]);\n\t\tnum_zone_steps = px > py ? px : py;\n\t\tfor (i = 0; i < num_zone_steps; ++i) {\n\t\t\tj = 0;\n\t\t\twhile ((zone = get_zone_at(x, y, layer, j++, &index))) {\n\t\t\t\tif (zone->steps_left-- <= 0) {\n\t\t\t\t\tlast_zone = s_current_zone;\n\t\t\t\t\ts_current_zone = index;\n\t\t\t\t\tzone->steps_left = zone->interval;\n\t\t\t\t\tscript_run(zone->script, true);\n\t\t\t\t\ts_current_zone = last_zone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// check if there are any deferred scripts due to run this frame\n\t// and run the ones that are\n\tfor (i = 0; i < s_num_deferreds; ++i) {\n\t\tif (s_deferreds[i].frames_left-- <= 0) {\n\t\t\tscript_to_run = s_deferreds[i].script;\n\t\t\tfor (j = i; j < s_num_deferreds - 1; ++j)\n\t\t\t\ts_deferreds[j] = s_deferreds[j + 1];\n\t\t\t--s_num_deferreds;\n\t\t\tscript_run(script_to_run, false);\n\t\t\tscript_unref(script_to_run);\n\t\t\t--i;\n\t\t}\n\t}\n\n\t// now that everything else is in order, we can run the\n\t// update script!\n\tscript_run(s_update_script, false);\n}\n\nstatic void\nupdate_person(person_t* person, bool* out_has_moved)\n{\n\tstruct command  command;\n\tdouble          delta_x, delta_y;\n\tint             facing;\n\tbool            has_moved;\n\tbool            is_finished;\n\tconst person_t* last_person;\n\tstruct step     step;\n\tint             vector;\n\n\tint i;\n\n\tperson->mv_x = 0; person->mv_y = 0;\n\tif (person->revert_frames > 0 && --person->revert_frames <= 0)\n\t\tperson->frame = 0;\n\tif (person->leader == NULL) {  // no leader; use command queue\n\t\t// call the command generator if the queue is empty\n\t\tif (person->num_commands == 0)\n\t\t\tperson_activate(person, PERSON_SCRIPT_GENERATOR, NULL, true);\n\n\t\t// run through the queue, stopping after the first non-immediate command\n\t\tis_finished = !does_person_exist(person) || person->num_commands == 0;\n\t\twhile (!is_finished) {\n\t\t\tcommand = person->commands[0];\n\t\t\t--person->num_commands;\n\t\t\tfor (i = 0; i < person->num_commands; ++i)\n\t\t\t\tperson->commands[i] = person->commands[i + 1];\n\t\t\tlast_person = s_current_person;\n\t\t\ts_current_person = person;\n\t\t\tif (command.type != COMMAND_RUN_SCRIPT)\n\t\t\t\tcommand_person(person, command.type);\n\t\t\telse\n\t\t\t\tscript_run(command.script, false);\n\t\t\ts_current_person = last_person;\n\t\t\tscript_unref(command.script);\n\t\t\tis_finished = !does_person_exist(person)  // stop if person was destroyed\n\t\t\t\t|| !command.is_immediate || person->num_commands == 0;\n\t\t}\n\t}\n\telse {  // leader set; follow the leader!\n\t\tstep = person->leader->steps[person->follow_distance - 1];\n\t\tdelta_x = step.x - person->x;\n\t\tdelta_y = step.y - person->y;\n\t\tif (fabs(delta_x) > person->speed_x)\n\t\t\tcommand_person(person, delta_x > 0 ? COMMAND_MOVE_EAST : COMMAND_MOVE_WEST);\n\t\tif (!does_person_exist(person)) return;\n\t\tif (fabs(delta_y) > person->speed_y)\n\t\t\tcommand_person(person, delta_y > 0 ? COMMAND_MOVE_SOUTH : COMMAND_MOVE_NORTH);\n\t\tif (!does_person_exist(person)) return;\n\t\tvector = person->mv_x + person->mv_y * 3;\n\t\tfacing = vector == -3 ? COMMAND_FACE_NORTH\n\t\t\t: vector == -2 ? COMMAND_FACE_NORTHEAST\n\t\t\t: vector == 1 ? COMMAND_FACE_EAST\n\t\t\t: vector == 4 ? COMMAND_FACE_SOUTHEAST\n\t\t\t: vector == 3 ? COMMAND_FACE_SOUTH\n\t\t\t: vector == 2 ? COMMAND_FACE_SOUTHWEST\n\t\t\t: vector == -1 ? COMMAND_FACE_WEST\n\t\t\t: vector == -4 ? COMMAND_FACE_NORTHWEST\n\t\t\t: COMMAND_WAIT;\n\t\tif (facing != COMMAND_WAIT)\n\t\t\tcommand_person(person, COMMAND_ANIMATE);\n\t\tif (!does_person_exist(person)) return;\n\t\tcommand_person(person, facing);\n\t}\n\n\t// check that the person didn't mysteriously disappear...\n\tif (!does_person_exist(person))\n\t\treturn;  // they probably got eaten by a pig.\n\n\t// if the person's position changed, record it in their step history\n\t*out_has_moved = person_has_moved(person);\n\tif (*out_has_moved)\n\t\trecord_step(person);\n\n\t// recursively update the follower chain\n\tfor (i = 0; i < s_num_persons; ++i) {\n\t\tif (s_persons[i]->leader != person)\n\t\t\tcontinue;\n\t\tupdate_person(s_persons[i], &has_moved);\n\t\t*out_has_moved |= has_moved;\n\t}\n}\n"], "filenames": ["src/minisphere/map_engine.c"], "buggy_code_start_loc": [1038], "buggy_code_end_loc": [1048], "fixing_code_start_loc": [1039], "fixing_code_end_loc": [1051], "type": "CWE-190", "message": "miniSphere version 5.2.9 and earlier contains a Integer Overflow vulnerability in layer_resize() function in map_engine.c that can result in remote denial of service. This attack appear to be exploitable via the victim must load a specially-crafted map which calls SetLayerSize in its entry script. This vulnerability appears to have been fixed in 5.0.3, 5.1.5, 5.2.10 and later.", "other": {"cve": {"id": "CVE-2018-1000524", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-26T16:29:01.507", "lastModified": "2018-08-28T17:02:10.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "miniSphere version 5.2.9 and earlier contains a Integer Overflow vulnerability in layer_resize() function in map_engine.c that can result in remote denial of service. This attack appear to be exploitable via the victim must load a specially-crafted map which calls SetLayerSize in its entry script. This vulnerability appears to have been fixed in 5.0.3, 5.1.5, 5.2.10 and later."}, {"lang": "es", "value": "miniSphere en versiones 5.2.9 y anteriores contiene una vulnerabilidad de desbordamiento de enteros en la funci\u00f3n layer_resize() en map_engine.c que puede resultar en una denegaci\u00f3n de servicio (DoS) remota. El ataque parece ser explotable mediante una v\u00edctima que cargue un mapa especialmente manipulado que llame a SetLayerSize en su script de entrada. La vulnerabilidad parece haber sido solucionada en las versiones 5.0.3, 5.1.5, 5.2.10 y siguientes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:spheredev:minisphere:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.2.9", "matchCriteriaId": "C5D2A28F-B256-4E33-80E7-2C9365021BBE"}]}]}], "references": [{"url": "https://github.com/fatcerberus/minisphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/fatcerberus/minisphere/pull/268", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fatcerberus/minisphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996"}}