{"buggy_code": ["\"use strict\";\n\n// Dependencies\nconst Repo = require(\"../lib\")\n    , fs = require(\"fs\")\n    , oneByOne = require(\"one-by-one\")\n    ;\n\n// Create the repository\nvar myRepo = new Repo(\"./foo\");\noneByOne([\n    myRepo.create.bind(myRepo)\n  , cb => {\n        console.log(\"> Created the repository.\");\n        fs.writeFile(\"./foo/README\", \"Hello World!\", cb);\n    }\n  , cb => {\n        console.log(\"> Created README.md\");\n        myRepo.exec(\"add .\", cb);\n    }\n  , cb => {\n        console.log(\"> Added the files.\");\n        myRepo.commit(\"Initial commit.\", cb);\n    }\n  , cb => {\n        console.log(\"> Created the initial commit.\");\n        cb();\n    }\n], function (err) {\n    console.log(err ? \"An error appeared: \" + err.stack : \"Successfully done.\");\n});\n", "\"use strict\";\n\nconst fs = require(\"fs\")\n    , abs = require(\"abs\")\n    , ExecLimiter = require(\"exec-limiter\")\n    , ul = require(\"ul\")\n    ;\n\n// Create a global exec limiter\nconst el = new ExecLimiter();\n\nclass Gry {\n    /**\n     * Gry\n     * Creates a new `Gry` instance.\n     *\n     * @name Gry\n     * @function\n     * @param {Object} options An object containing the following fields:\n     *\n     *  - `path` (String): The path to the git repository.\n     *  - `limit` (Number): The limit of commands to run same time.\n     *\n     * @return {Gry} The `Gry` instance.\n     */\n    constructor (options) {\n        if (typeof options === \"string\") {\n            options = {\n                path: options\n            };\n        }\n\n        options = ul.merge(options, {\n            limit: 30\n        });\n\n        options.path = abs(options.path);\n\n        this.options = options;\n        this.cwd = options.path;\n    }\n\n    /**\n     * exec\n     * Executes a git command in the repository directory.\n     *\n     * @name exec\n     * @function\n     * @param {String} command The git command that should be executed in the repository directory.\n     * @param {Array} args An array of options passed to the spawned process. This is optional (if not provided, `exec` will be used instead).\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    exec (command, args, callback) {\n\n        var eargs = [];\n        if (typeof args === \"function\") {\n            callback = args;\n            args = null;\n        }\n\n        // Handle spawn\n        if (Array.isArray(args)) {\n            eargs.push(\"git\", [command].concat(args));\n        } else {\n            eargs.push(\"git \" + command.trim());\n        }\n\n        eargs.push({ cwd: this.cwd });\n\n        // Add the callback function\n        eargs.push((err, stdout) => {\n            if (err) { return callback(err); }\n            callback(null, stdout.trimRight());\n        });\n\n        el.add.apply(el, eargs);\n        return this;\n    }\n\n    /**\n     * init\n     * Inits the git repository.\n     *\n     * @name init\n     * @function\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    init (callback) {\n        return this.exec(\"init\", callback);\n    }\n\n    /**\n     * create\n     * Creates a git repository.\n     *\n     * @name create\n     * @function\n     * @param {String} path The path of the repository.\n     * @param {Function} callback The callback function\n     * @return {Gry} The `Gry` instance.\n     */\n    create (callback) {\n        fs.mkdir(this.cwd, err => {\n            if (err) {\n                return callback(err);\n            }\n            this.init(callback);\n        });\n        return this;\n    }\n\n    /**\n     * commit\n     * Creates a commit, providing the `message`.\n     *\n     * @name commit\n     * @function\n     * @param {String} message The commit message\n     * @param {String} options Additional options passed to the commit command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    commit (message, options, callback) {\n        message = message.replace(/\\\"/g, \"\\\\\");\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(\"commit -m \\\"\" + message + \"\\\" \" + options, callback)\n    }\n\n    /**\n     * pull\n     * Runs `git pull`.\n     *\n     * @name pull\n     * @function\n     * @param {String} options Additional options passed to the `pull` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    pull (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(\"pull \" + options, callback);\n    }\n\n    /**\n     * add\n     * Runs `git add`.\n     *\n     * @name add\n     * @function\n     * @param {String} options Additional options passed to the `add` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    add (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \".\";\n        }\n        return this.exec(\"add \" + options, callback);\n    }\n\n    /**\n     * branch\n     * Runs `git branch`.\n     *\n     * @name branch\n     * @function\n     * @param {String} options Additional options passed to the `branch` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    branch (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(\"branch \" + options, callback);\n    }\n\n    /**\n     * checkout\n     * Runs `git checkout`.\n     *\n     * @name checkout\n     * @function\n     * @param {String} options Additional options passed to the `checkout` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    checkout (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(\"checkout \" + options, callback);\n    }\n\n    /**\n     * clone\n     * Runs `git clone`.\n     *\n     * @name clone\n     * @function\n     * @param {String} gitUrl The git url of the repository that should be cloned.\n     * @param {String} options Additional options passed to the `checkout` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    clone (gitUrl, options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(\"clone \" + gitUrl + \" \" + options, callback);\n    }\n}\n\nGry.limiter = el;\n\nmodule.exports = Gry;\n"], "fixing_code": ["\"use strict\";\n\n// Dependencies\nconst Repo = require(\"../lib\")\n    , fs = require(\"fs\")\n    , oneByOne = require(\"one-by-one\")\n    ;\n\n// Create the repository\nvar myRepo = new Repo(\"./foo\");\noneByOne([\n    myRepo.create.bind(myRepo)\n  , cb => {\n        console.log(\"> Created the repository.\");\n        fs.writeFile(\"./foo/README\", \"Hello World!\", cb);\n    }\n  , cb => {\n        console.log(\"> Created README.md\");\n        myRepo.exec(['add', '.'], cb);\n    }\n  , cb => {\n        console.log(\"> Added the files.\");\n        myRepo.commit(\"Initial commit.\", cb);\n    }\n  , cb => {\n        console.log(\"> Created the initial commit.\");\n        cb();\n    }\n], function (err) {\n    console.log(err ? \"An error appeared: \" + err.stack : \"Successfully done.\");\n});\n", "\"use strict\";\n\nconst fs = require(\"fs\")\n    , abs = require(\"abs\")\n    , ExecLimiter = require(\"exec-limiter\")\n    , ul = require(\"ul\")\n    ;\n\n// Create a global exec limiter\nconst el = new ExecLimiter();\n\nclass Gry {\n    /**\n     * Gry\n     * Creates a new `Gry` instance.\n     *\n     * @name Gry\n     * @function\n     * @param {Object} options An object containing the following fields:\n     *\n     *  - `path` (String): The path to the git repository.\n     *  - `limit` (Number): The limit of commands to run same time.\n     *\n     * @return {Gry} The `Gry` instance.\n     */\n    constructor (options) {\n        if (typeof options === \"string\") {\n            options = {\n                path: options\n            };\n        }\n\n        options = ul.merge(options, {\n            limit: 30\n        });\n\n        options.path = abs(options.path);\n\n        this.options = options;\n        this.cwd = options.path;\n    }\n\n    /**\n     * exec\n     * Executes a git command in the repository directory.\n     *\n     * @name exec\n     * @function\n     * @param {String} command The git command that should be executed in the repository directory.\n     * @param {Array} args An array of options passed to the spawned process. This is optional (if not provided, `exec` will be used instead).\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    exec (command, args, callback) {\n        var eargs = [];\n        if (typeof args === \"function\") {\n            callback = args;\n            args = null;\n        }\n\n        eargs.push({ cwd: this.cwd });\n\n        // Add the callback function\n        eargs.push((err, stdout) => {\n            if (err) { return callback(err); }\n            callback(null, stdout.trimRight());\n        });\n        console.log({command, eargs, callback})\n\n        el.add('git', command, eargs[0], eargs[1]);\n        return this;\n    }\n\n    /**\n     * init\n     * Inits the git repository.\n     *\n     * @name init\n     * @function\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    init (callback) {\n        return this.exec(['init'], callback);\n    }\n\n    /**\n     * create\n     * Creates a git repository.\n     *\n     * @name create\n     * @function\n     * @param {String} path The path of the repository.\n     * @param {Function} callback The callback function\n     * @return {Gry} The `Gry` instance.\n     */\n    create (callback) {\n        fs.mkdir(this.cwd, err => {\n            if (err) {\n                return callback(err);\n            }\n            this.init(callback);\n        });\n        return this;\n    }\n\n    /**\n     * commit\n     * Creates a commit, providing the `message`.\n     *\n     * @name commit\n     * @function\n     * @param {String} message The commit message\n     * @param {String} options Additional options passed to the commit command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    commit (message, options, callback) {\n        message = message.replace(/\\\"/g, \"\\\\\");\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(['commit', '-m', message, ...options.split(' ').filter(a => a)], callback)\n    }\n\n    /**\n     * pull\n     * Runs `git pull`.\n     *\n     * @name pull\n     * @function\n     * @param {String} options Additional options passed to the `pull` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    pull (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(['pull', ...options.split(' ')], callback);\n    }\n\n    /**\n     * add\n     * Runs `git add`.\n     *\n     * @name add\n     * @function\n     * @param {String} options Additional options passed to the `add` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    add (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \".\";\n        }\n        return this.exec(['add', ...options.split(' ')], callback);\n    }\n\n    /**\n     * branch\n     * Runs `git branch`.\n     *\n     * @name branch\n     * @function\n     * @param {String} options Additional options passed to the `branch` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    branch (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(['branch', ...options.split(' ')], callback);\n    }\n\n    /**\n     * checkout\n     * Runs `git checkout`.\n     *\n     * @name checkout\n     * @function\n     * @param {String} options Additional options passed to the `checkout` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    checkout (options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(['checkout', ...options.split(' ')], callback);\n    }\n\n    /**\n     * clone\n     * Runs `git clone`.\n     *\n     * @name clone\n     * @function\n     * @param {String} gitUrl The git url of the repository that should be cloned.\n     * @param {String} options Additional options passed to the `checkout` command.\n     * @param {Function} callback The callback function.\n     * @return {Gry} The `Gry` instance.\n     */\n    clone (gitUrl, options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = \"\";\n        }\n        return this.exec(['clone', gitUrl, ...options.split(' ')], callback);\n    }\n}\n\nGry.limiter = el;\n\nmodule.exports = Gry;\n"], "filenames": ["example/index.js", "lib/index.js"], "buggy_code_start_loc": [19, 55], "buggy_code_end_loc": [20, 223], "fixing_code_start_loc": [19, 54], "fixing_code_end_loc": [20, 216], "type": "CWE-77", "message": "A vulnerability, which was classified as critical, was found in IonicaBizau node-gry up to 5.x. This affects an unknown part. The manipulation leads to command injection. Upgrading to version 6.0.0 is able to address this issue. The name of the patch is 5108446c1e23960d65e8b973f1d9486f9f9dbd6c. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-218019.", "other": {"cve": {"id": "CVE-2020-36650", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-11T18:15:09.003", "lastModified": "2023-01-18T19:20:51.067", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in IonicaBizau node-gry up to 5.x. This affects an unknown part. The manipulation leads to command injection. Upgrading to version 6.0.0 is able to address this issue. The name of the patch is 5108446c1e23960d65e8b973f1d9486f9f9dbd6c. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-218019."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gry_project:gry:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "6.0.0", "matchCriteriaId": "AA2E0A9F-5712-415F-BA68-F7033E3CEF7A"}]}]}], "references": [{"url": "https://github.com/IonicaBizau/node-gry/commit/5108446c1e23960d65e8b973f1d9486f9f9dbd6c", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/IonicaBizau/node-gry/pull/22", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/IonicaBizau/node-gry/releases/tag/6.0.0", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218019", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218019", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/IonicaBizau/node-gry/commit/5108446c1e23960d65e8b973f1d9486f9f9dbd6c"}}