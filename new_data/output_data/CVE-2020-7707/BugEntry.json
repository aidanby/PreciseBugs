{"buggy_code": ["var { Cache, normalizePath, split, forEach } = require('./')\n\nvar setCache = new Cache(512),\n  getCache = new Cache(512)\n\nfunction makeSafe(path, param) {\n  var result = param,\n    parts = split(path),\n    isLast\n\n  forEach(parts, function(part, isBracket, isArray, idx, parts) {\n    isLast = idx === parts.length - 1\n\n    part = isBracket || isArray ? '[' + part + ']' : '.' + part\n\n    result += part + (!isLast ? ' || {})' : ')')\n  })\n\n  return new Array(parts.length + 1).join('(') + result\n}\n\nfunction expr(expression, safe, param) {\n  expression = expression || ''\n\n  if (typeof safe === 'string') {\n    param = safe\n    safe = false\n  }\n\n  param = param || 'data'\n\n  if (expression && expression.charAt(0) !== '[') expression = '.' + expression\n\n  return safe ? makeSafe(expression, param) : param + expression\n}\n\nmodule.exports = {\n  expr,\n  setter: function(path) {\n    return (\n      setCache.get(path) ||\n      setCache.set(\n        path,\n        new Function('data, value', expr(path, 'data') + ' = value')\n      )\n    )\n  },\n\n  getter: function(path, safe) {\n    var key = path + '_' + safe\n    return (\n      getCache.get(key) ||\n      getCache.set(\n        key,\n        new Function('data', 'return ' + expr(path, safe, 'data'))\n      )\n    )\n  }\n}\n", "/**\n * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>\n */\n'use strict'\n\nfunction Cache(maxSize) {\n  this._maxSize = maxSize\n  this.clear()\n}\nCache.prototype.clear = function() {\n  this._size = 0\n  this._values = Object.create(null)\n}\nCache.prototype.get = function(key) {\n  return this._values[key]\n}\nCache.prototype.set = function(key, value) {\n  this._size >= this._maxSize && this.clear()\n  if (!(key in this._values)) this._size++\n\n  return (this._values[key] = value)\n}\n\nvar SPLIT_REGEX = /[^.^\\]^[]+|(?=\\[\\]|\\.\\.)/g,\n  DIGIT_REGEX = /^\\d+$/,\n  LEAD_DIGIT_REGEX = /^\\d/,\n  SPEC_CHAR_REGEX = /[~`!#$%\\^&*+=\\-\\[\\]\\\\';,/{}|\\\\\":<>\\?]/g,\n  CLEAN_QUOTES_REGEX = /^\\s*(['\"]?)(.*?)(\\1)\\s*$/,\n  MAX_CACHE_SIZE = 512\n\nvar pathCache = new Cache(MAX_CACHE_SIZE),\n  setCache = new Cache(MAX_CACHE_SIZE),\n  getCache = new Cache(MAX_CACHE_SIZE)\n\nvar config\n\nmodule.exports = {\n  Cache: Cache,\n\n  split: split,\n\n  normalizePath: normalizePath,\n\n  setter: function(path) {\n    var parts = normalizePath(path)\n\n    return (\n      setCache.get(path) ||\n      setCache.set(path, function setter(data, value) {\n        var index = 0,\n          len = parts.length\n        while (index < len - 1) {\n          data = data[parts[index++]]\n        }\n        data[parts[index]] = value\n      })\n    )\n  },\n\n  getter: function(path, safe) {\n    var parts = normalizePath(path)\n    return (\n      getCache.get(path) ||\n      getCache.set(path, function getter(data) {\n        var index = 0,\n          len = parts.length\n        while (index < len) {\n          if (data != null || !safe) data = data[parts[index++]]\n          else return\n        }\n        return data\n      })\n    )\n  },\n\n  join: function(segments) {\n    return segments.reduce(function(path, part) {\n      return (\n        path +\n        (isQuoted(part) || DIGIT_REGEX.test(part)\n          ? '[' + part + ']'\n          : (path ? '.' : '') + part)\n      )\n    }, '')\n  },\n\n  forEach: function(path, cb, thisArg) {\n    forEach(Array.isArray(path) ? path : split(path), cb, thisArg)\n  }\n}\n\nfunction normalizePath(path) {\n  return (\n    pathCache.get(path) ||\n    pathCache.set(\n      path,\n      split(path).map(function(part) {\n        return part.replace(CLEAN_QUOTES_REGEX, '$2')\n      })\n    )\n  )\n}\n\nfunction split(path) {\n  return path.match(SPLIT_REGEX)\n}\n\nfunction forEach(parts, iter, thisArg) {\n  var len = parts.length,\n    part,\n    idx,\n    isArray,\n    isBracket\n\n  for (idx = 0; idx < len; idx++) {\n    part = parts[idx]\n\n    if (part) {\n      if (shouldBeQuoted(part)) {\n        part = '\"' + part + '\"'\n      }\n\n      isBracket = isQuoted(part)\n      isArray = !isBracket && /^\\d+$/.test(part)\n\n      iter.call(thisArg, part, isBracket, isArray, idx, parts)\n    }\n  }\n}\n\nfunction isQuoted(str) {\n  return (\n    typeof str === 'string' && str && [\"'\", '\"'].indexOf(str.charAt(0)) !== -1\n  )\n}\n\nfunction hasLeadingNumber(part) {\n  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)\n}\n\nfunction hasSpecialChars(part) {\n  return SPEC_CHAR_REGEX.test(part)\n}\n\nfunction shouldBeQuoted(part) {\n  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))\n}\n", "const a = require('assert')\nconst expr = require('./index')\nconst compiler = require('./compiler')\n\nfunction runSetterGetterTests({ setter, getter }) {\n  let obj = {\n    foo: {\n      bar: ['baz', 'bux'],\n      fux: 5,\n      '00N40000002S5U0': 1,\n      N40000002S5U0: 2,\n      'FE43-D880-21AE': 3\n    }\n  }\n\n  // -- Getters --\n  a.strictEqual(getter('foo.fux')(obj), 5)\n  a.deepEqual(getter('foo.bar')(obj), ['baz', 'bux'])\n\n  a.strictEqual(getter('foo.bar[1]')(obj), 'bux')\n  a.strictEqual(getter('[\"foo\"][\"bar\"][1]')(obj), 'bux')\n  a.strictEqual(getter('[1]')([1, 'bux']), 'bux')\n\n  // safe access\n  a.strictEqual(getter('foo.fux', true)(obj), 5)\n  a.deepEqual(getter('foo.bar', true)(obj), ['baz', 'bux'])\n\n  a.strictEqual(getter('foo.bar[1]', true)(obj), 'bux')\n  a.strictEqual(getter('[\"foo\"][\"bar\"][1]', true)(obj), 'bux')\n  a.strictEqual(getter('[1]', true)([1, 'bux']), 'bux')\n\n  a.strictEqual(getter('foo.gih.df[0]', true)(obj), undefined)\n  a.strictEqual(getter('[\"fr\"][\"bzr\"][1]', true)(obj), undefined)\n\n  a.strictEqual(getter('foo[\"00N40000002S5U0\"]', true)(obj), 1)\n  a.strictEqual(getter('foo.00N40000002S5U0', true)(obj), 1)\n  a.strictEqual(getter('foo[\"N40000002S5U0\"]', true)(obj), 2)\n  a.strictEqual(getter('foo.N40000002S5U0', true)(obj), 2)\n  a.strictEqual(getter('foo[\"FE43-D880-21AE\"]', true)(obj), 3)\n  a.strictEqual(getter('foo.FE43-D880-21AE', true)(obj), 3)\n\n  // -- Setters --\n  setter('foo.fux')(obj, 10)\n  a.strictEqual(obj.foo.fux, 10)\n\n  setter('foo.bar[1]')(obj, 'bot')\n  a.strictEqual(obj.foo.bar[1], 'bot')\n\n  setter('[\\'foo\\'][\"bar\"][1]')(obj, 'baz')\n  a.strictEqual(obj.foo.bar[1], 'baz')\n}\n\nconsole.log('--- Test Start ---')\n\n// -- Cache --\nconst cache = new expr.Cache(3)\na.strictEqual(cache._size, 0)\na.strictEqual(cache.set('a', a), a)\na.strictEqual(cache.get('a'), a)\na.strictEqual(cache._size, 1)\na.strictEqual(cache.set('b', 123), 123)\na.strictEqual(cache.get('b'), 123)\na.strictEqual(cache.set('b', 321), 321)\na.strictEqual(cache.get('b'), 321)\na.strictEqual(cache.set('c', null), null)\na.strictEqual(cache.get('c'), null)\na.strictEqual(cache._size, 3)\na.strictEqual(cache.set('d', 444), 444)\na.strictEqual(cache._size, 1)\ncache.clear()\na.strictEqual(cache._size, 0)\na.strictEqual(cache.get('a'), undefined)\n\n// -- split --\n\nlet parts = expr.split('foo.baz[\"bar\"][1]')\n\na.strictEqual(parts.length, 4)\n\n// -- join --\n\nparts = expr.split('foo.baz[\"bar\"][1]')\n\na.strictEqual(expr.join(['0', 'baz', '\"bar\"', 1]), '[0].baz[\"bar\"][1]')\n\na.strictEqual(expr.join(parts), 'foo.baz[\"bar\"][1]')\n\n// -- forEach --\n\nlet count = 0\n\nexpr.forEach('foo.baz[\"bar\"][1]', function(part, isBracket, isArray, idx) {\n  count = idx\n\n  switch (idx) {\n    case 0:\n      a.strictEqual(part, 'foo')\n      a.strictEqual(isBracket, false)\n      a.strictEqual(isArray, false)\n      break\n    case 1:\n      a.strictEqual(part, 'baz')\n      a.strictEqual(isBracket, false)\n      a.strictEqual(isArray, false)\n      break\n    case 2:\n      a.strictEqual(part, '\"bar\"')\n      a.strictEqual(isBracket, true)\n      a.strictEqual(isArray, false)\n      break\n    case 3:\n      a.strictEqual(part, '1')\n      a.strictEqual(isBracket, false)\n      a.strictEqual(isArray, true)\n      break\n  }\n})\n\na.strictEqual(count, 3)\n\n// -- normalizePath --\n\na.deepEqual(\n  expr.normalizePath('foo[ \" bux\\'s \" ].bar[\"baz\"][ 9 ][ \\' s \\' ]'),\n  ['foo', \" bux's \", 'bar', 'baz', '9', ' s ']\n)\n\nrunSetterGetterTests(expr)\nrunSetterGetterTests(compiler)\n\nconsole.log('--- Tests Passed ---')\n"], "fixing_code": ["var { Cache, normalizePath, split, forEach } = require('./')\n\nvar setCache = new Cache(512),\n  getCache = new Cache(512)\n\nfunction makeSafe(path, param) {\n  var result = param,\n    parts = split(path),\n    isLast\n\n  forEach(parts, function (part, isBracket, isArray, idx, parts) {\n    isLast = idx === parts.length - 1\n\n    part = isBracket || isArray ? '[' + part + ']' : '.' + part\n\n    result += part + (!isLast ? ' || {})' : ')')\n  })\n\n  return new Array(parts.length + 1).join('(') + result\n}\n\nfunction expr(expression, safe, param) {\n  expression = expression || ''\n\n  if (typeof safe === 'string') {\n    param = safe\n    safe = false\n  }\n\n  param = param || 'data'\n\n  if (expression && expression.charAt(0) !== '[') expression = '.' + expression\n\n  return safe ? makeSafe(expression, param) : param + expression\n}\n\nmodule.exports = {\n  expr,\n  setter: function (path) {\n    if (\n      path.indexOf('__proto__') !== -1 ||\n      path.indexOf('constructor') !== -1 ||\n      path.indexOf('prototype') !== -1\n    ) {\n      return (obj) => obj\n    }\n\n    return (\n      setCache.get(path) ||\n      setCache.set(\n        path,\n        new Function('data, value', expr(path, 'data') + ' = value')\n      )\n    )\n  },\n\n  getter: function (path, safe) {\n    var key = path + '_' + safe\n    return (\n      getCache.get(key) ||\n      getCache.set(\n        key,\n        new Function('data', 'return ' + expr(path, safe, 'data'))\n      )\n    )\n  },\n}\n", "/**\n * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>\n */\n'use strict'\n\nfunction Cache(maxSize) {\n  this._maxSize = maxSize\n  this.clear()\n}\nCache.prototype.clear = function () {\n  this._size = 0\n  this._values = Object.create(null)\n}\nCache.prototype.get = function (key) {\n  return this._values[key]\n}\nCache.prototype.set = function (key, value) {\n  this._size >= this._maxSize && this.clear()\n  if (!(key in this._values)) this._size++\n\n  return (this._values[key] = value)\n}\n\nvar SPLIT_REGEX = /[^.^\\]^[]+|(?=\\[\\]|\\.\\.)/g,\n  DIGIT_REGEX = /^\\d+$/,\n  LEAD_DIGIT_REGEX = /^\\d/,\n  SPEC_CHAR_REGEX = /[~`!#$%\\^&*+=\\-\\[\\]\\\\';,/{}|\\\\\":<>\\?]/g,\n  CLEAN_QUOTES_REGEX = /^\\s*(['\"]?)(.*?)(\\1)\\s*$/,\n  MAX_CACHE_SIZE = 512\n\nvar pathCache = new Cache(MAX_CACHE_SIZE),\n  setCache = new Cache(MAX_CACHE_SIZE),\n  getCache = new Cache(MAX_CACHE_SIZE)\n\nvar config\n\nmodule.exports = {\n  Cache: Cache,\n\n  split: split,\n\n  normalizePath: normalizePath,\n\n  setter: function (path) {\n    var parts = normalizePath(path)\n\n    return (\n      setCache.get(path) ||\n      setCache.set(path, function setter(obj, value) {\n        var index = 0\n        var len = parts.length\n        var data = obj\n\n        while (index < len - 1) {\n          let part = parts[index]\n          if (\n            part === '__proto__' ||\n            part === 'constructor' ||\n            part === 'prototype'\n          ) {\n            return obj\n          }\n\n          data = data[parts[index++]]\n        }\n        data[parts[index]] = value\n      })\n    )\n  },\n\n  getter: function (path, safe) {\n    var parts = normalizePath(path)\n    return (\n      getCache.get(path) ||\n      getCache.set(path, function getter(data) {\n        var index = 0,\n          len = parts.length\n        while (index < len) {\n          if (data != null || !safe) data = data[parts[index++]]\n          else return\n        }\n        return data\n      })\n    )\n  },\n\n  join: function (segments) {\n    return segments.reduce(function (path, part) {\n      return (\n        path +\n        (isQuoted(part) || DIGIT_REGEX.test(part)\n          ? '[' + part + ']'\n          : (path ? '.' : '') + part)\n      )\n    }, '')\n  },\n\n  forEach: function (path, cb, thisArg) {\n    forEach(Array.isArray(path) ? path : split(path), cb, thisArg)\n  },\n}\n\nfunction normalizePath(path) {\n  return (\n    pathCache.get(path) ||\n    pathCache.set(\n      path,\n      split(path).map(function (part) {\n        return part.replace(CLEAN_QUOTES_REGEX, '$2')\n      })\n    )\n  )\n}\n\nfunction split(path) {\n  return path.match(SPLIT_REGEX)\n}\n\nfunction forEach(parts, iter, thisArg) {\n  var len = parts.length,\n    part,\n    idx,\n    isArray,\n    isBracket\n\n  for (idx = 0; idx < len; idx++) {\n    part = parts[idx]\n\n    if (part) {\n      if (shouldBeQuoted(part)) {\n        part = '\"' + part + '\"'\n      }\n\n      isBracket = isQuoted(part)\n      isArray = !isBracket && /^\\d+$/.test(part)\n\n      iter.call(thisArg, part, isBracket, isArray, idx, parts)\n    }\n  }\n}\n\nfunction isQuoted(str) {\n  return (\n    typeof str === 'string' && str && [\"'\", '\"'].indexOf(str.charAt(0)) !== -1\n  )\n}\n\nfunction hasLeadingNumber(part) {\n  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)\n}\n\nfunction hasSpecialChars(part) {\n  return SPEC_CHAR_REGEX.test(part)\n}\n\nfunction shouldBeQuoted(part) {\n  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))\n}\n", "const a = require('assert')\nconst expr = require('./index')\nconst compiler = require('./compiler')\n\nconst root = (typeof global == 'object' && global) || this\n\nfunction runSetterGetterTests({ setter, getter }) {\n  let obj = {\n    foo: {\n      bar: ['baz', 'bux'],\n      fux: 5,\n      '00N40000002S5U0': 1,\n      N40000002S5U0: 2,\n      'FE43-D880-21AE': 3,\n    },\n  }\n\n  // -- Getters --\n  a.strictEqual(getter('foo.fux')(obj), 5)\n  a.deepEqual(getter('foo.bar')(obj), ['baz', 'bux'])\n\n  a.strictEqual(getter('foo.bar[1]')(obj), 'bux')\n  a.strictEqual(getter('[\"foo\"][\"bar\"][1]')(obj), 'bux')\n  a.strictEqual(getter('[1]')([1, 'bux']), 'bux')\n\n  // safe access\n  a.strictEqual(getter('foo.fux', true)(obj), 5)\n  a.deepEqual(getter('foo.bar', true)(obj), ['baz', 'bux'])\n\n  a.strictEqual(getter('foo.bar[1]', true)(obj), 'bux')\n  a.strictEqual(getter('[\"foo\"][\"bar\"][1]', true)(obj), 'bux')\n  a.strictEqual(getter('[1]', true)([1, 'bux']), 'bux')\n\n  a.strictEqual(getter('foo.gih.df[0]', true)(obj), undefined)\n  a.strictEqual(getter('[\"fr\"][\"bzr\"][1]', true)(obj), undefined)\n\n  a.strictEqual(getter('foo[\"00N40000002S5U0\"]', true)(obj), 1)\n  a.strictEqual(getter('foo.00N40000002S5U0', true)(obj), 1)\n  a.strictEqual(getter('foo[\"N40000002S5U0\"]', true)(obj), 2)\n  a.strictEqual(getter('foo.N40000002S5U0', true)(obj), 2)\n  a.strictEqual(getter('foo[\"FE43-D880-21AE\"]', true)(obj), 3)\n  a.strictEqual(getter('foo.FE43-D880-21AE', true)(obj), 3)\n\n  // -- Setters --\n  setter('foo.fux')(obj, 10)\n  a.strictEqual(obj.foo.fux, 10)\n\n  setter('foo.bar[1]')(obj, 'bot')\n  a.strictEqual(obj.foo.bar[1], 'bot')\n\n  setter('[\\'foo\\'][\"bar\"][1]')(obj, 'baz')\n\n  a.strictEqual(obj.foo.bar[1], 'baz')\n  //\n  ;['__proto__', 'constructor', 'prototype'].forEach((keyToTest) => {\n    setter(`${keyToTest}.a`)({}, 'newValue')\n\n    a.notEqual(root['a'], 'newValue')\n\n    const b = 'oldValue'\n\n    a.equal(b, 'oldValue')\n    a.notEqual(root['b'], 'newValue')\n\n    setter(`${keyToTest}.b`)({}, 'newValue')\n    a.equal(b, 'oldValue')\n    a.notEqual(root['b'], 'newValue')\n    a.equal(root['b'], undefined)\n  })\n}\n\nconsole.log('--- Test Start ---')\n\n// -- Cache --\nconst cache = new expr.Cache(3)\na.strictEqual(cache._size, 0)\na.strictEqual(cache.set('a', a), a)\na.strictEqual(cache.get('a'), a)\na.strictEqual(cache._size, 1)\na.strictEqual(cache.set('b', 123), 123)\na.strictEqual(cache.get('b'), 123)\na.strictEqual(cache.set('b', 321), 321)\na.strictEqual(cache.get('b'), 321)\na.strictEqual(cache.set('c', null), null)\na.strictEqual(cache.get('c'), null)\na.strictEqual(cache._size, 3)\na.strictEqual(cache.set('d', 444), 444)\na.strictEqual(cache._size, 1)\ncache.clear()\na.strictEqual(cache._size, 0)\na.strictEqual(cache.get('a'), undefined)\n\n// -- split --\n\nlet parts = expr.split('foo.baz[\"bar\"][1]')\n\na.strictEqual(parts.length, 4)\n\n// -- join --\n\nparts = expr.split('foo.baz[\"bar\"][1]')\n\na.strictEqual(expr.join(['0', 'baz', '\"bar\"', 1]), '[0].baz[\"bar\"][1]')\n\na.strictEqual(expr.join(parts), 'foo.baz[\"bar\"][1]')\n\n// -- forEach --\n\nlet count = 0\n\nexpr.forEach('foo.baz[\"bar\"][1]', function (part, isBracket, isArray, idx) {\n  count = idx\n\n  switch (idx) {\n    case 0:\n      a.strictEqual(part, 'foo')\n      a.strictEqual(isBracket, false)\n      a.strictEqual(isArray, false)\n      break\n    case 1:\n      a.strictEqual(part, 'baz')\n      a.strictEqual(isBracket, false)\n      a.strictEqual(isArray, false)\n      break\n    case 2:\n      a.strictEqual(part, '\"bar\"')\n      a.strictEqual(isBracket, true)\n      a.strictEqual(isArray, false)\n      break\n    case 3:\n      a.strictEqual(part, '1')\n      a.strictEqual(isBracket, false)\n      a.strictEqual(isArray, true)\n      break\n  }\n})\n\na.strictEqual(count, 3)\n\n// -- normalizePath --\n\na.deepEqual(\n  expr.normalizePath('foo[ \" bux\\'s \" ].bar[\"baz\"][ 9 ][ \\' s \\' ]'),\n  ['foo', \" bux's \", 'bar', 'baz', '9', ' s ']\n)\n\nrunSetterGetterTests(expr)\nrunSetterGetterTests(compiler)\n\nconsole.log('--- Tests Passed ---')\n"], "filenames": ["compiler.js", "index.js", "test.js"], "buggy_code_start_loc": [11, 10, 3], "buggy_code_end_loc": [59, 98, 93], "fixing_code_start_loc": [11, 10, 4], "fixing_code_end_loc": [67, 109, 112], "type": "CWE-1321", "message": "The package property-expr before 2.0.3 are vulnerable to Prototype Pollution via the setter function.", "other": {"cve": {"id": "CVE-2020-7707", "sourceIdentifier": "report@snyk.io", "published": "2020-08-18T14:15:13.793", "lastModified": "2022-12-02T19:55:55.097", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package property-expr before 2.0.3 are vulnerable to Prototype Pollution via the setter function."}, {"lang": "es", "value": "El paquete property-expr versiones anteriores a 2.0.3, es vulnerable a la Contaminaci\u00f3n de Prototipo por medio de la funci\u00f3n setter."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:property-expr_project:property-expr:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.3", "matchCriteriaId": "679DD9FB-37A9-4BD4-B36F-43D8F001CE9B"}]}]}], "references": [{"url": "https://github.com/jquense/expr/commit/df846910915d59f711ce63c1f817815bceab5ff7", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-598857", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-PROPERTYEXPR-598800", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jquense/expr/commit/df846910915d59f711ce63c1f817815bceab5ff7"}}