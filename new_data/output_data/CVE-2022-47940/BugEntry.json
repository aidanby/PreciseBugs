{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n#include <linux/syscalls.h>\n#include <linux/namei.h>\n#include <linux/statfs.h>\n#include <linux/ethtool.h>\n#include <linux/falloc.h>\n#include <linux/mount.h>\n\n#include \"glob.h\"\n#include \"smbfsctl.h\"\n#include \"oplock.h\"\n#include \"smbacl.h\"\n\n#include \"auth.h\"\n#include \"asn1.h\"\n#include \"connection.h\"\n#include \"transport_ipc.h\"\n#include \"transport_rdma.h\"\n#include \"vfs.h\"\n#include \"vfs_cache.h\"\n#include \"misc.h\"\n\n#include \"server.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"ksmbd_work.h\"\n#include \"mgmt/user_config.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/ksmbd_ida.h\"\n#include \"ndr.h\"\n\nstatic void __wbuf(struct ksmbd_work *work, void **req, void **rsp)\n{\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\t*req = ksmbd_req_buf_next(work);\n\t\t*rsp = ksmbd_resp_buf_next(work);\n\t} else {\n\t\t*req = smb2_get_msg(work->request_buf);\n\t\t*rsp = smb2_get_msg(work->response_buf);\n\t}\n}\n\n#define WORK_BUFFERS(w, rq, rs)\t__wbuf((w), (void **)&(rq), (void **)&(rs))\n\n/**\n * check_session_id() - check for valid session id in smb header\n * @conn:\tconnection instance\n * @id:\t\tsession id from smb header\n *\n * Return:      1 if valid session id, otherwise 0\n */\nstatic inline bool check_session_id(struct ksmbd_conn *conn, u64 id)\n{\n\tstruct ksmbd_session *sess;\n\n\tif (id == 0 || id == -1)\n\t\treturn false;\n\n\tsess = ksmbd_session_lookup_all(conn, id);\n\tif (sess)\n\t\treturn true;\n\tpr_err(\"Invalid user session id: %llu\\n\", id);\n\treturn false;\n}\n\nstruct channel *lookup_chann_list(struct ksmbd_session *sess, struct ksmbd_conn *conn)\n{\n\tstruct channel *chann;\n\n\tlist_for_each_entry(chann, &sess->ksmbd_chann_list, chann_list) {\n\t\tif (chann->conn == conn)\n\t\t\treturn chann;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * smb2_get_ksmbd_tcon() - get tree connection information using a tree id.\n * @work:\tsmb work\n *\n * Return:\t0 if there is a tree connection matched or these are\n *\t\tskipable commands, otherwise error\n */\nint smb2_get_ksmbd_tcon(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tunsigned int cmd = le16_to_cpu(req_hdr->Command);\n\tint tree_id;\n\n\twork->tcon = NULL;\n\tif (cmd == SMB2_TREE_CONNECT_HE ||\n\t    cmd ==  SMB2_CANCEL_HE ||\n\t    cmd ==  SMB2_LOGOFF_HE) {\n\t\tksmbd_debug(SMB, \"skip to check tree connect request\\n\");\n\t\treturn 0;\n\t}\n\n\tif (xa_empty(&work->sess->tree_conns)) {\n\t\tksmbd_debug(SMB, \"NO tree connected\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\ttree_id = le32_to_cpu(req_hdr->Id.SyncId.TreeId);\n\twork->tcon = ksmbd_tree_conn_lookup(work->sess, tree_id);\n\tif (!work->tcon) {\n\t\tpr_err(\"Invalid tid %d\\n\", tree_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_err_rsp() - set error response code on smb response\n * @work:\tsmb work containing response buffer\n */\nvoid smb2_set_err_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_err_rsp *err_rsp;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\terr_rsp = ksmbd_resp_buf_next(work);\n\telse\n\t\terr_rsp = smb2_get_msg(work->response_buf);\n\n\tif (err_rsp->hdr.Status != STATUS_STOPPED_ON_SYMLINK) {\n\t\terr_rsp->StructureSize = SMB2_ERROR_STRUCTURE_SIZE2_LE;\n\t\terr_rsp->ErrorContextCount = 0;\n\t\terr_rsp->Reserved = 0;\n\t\terr_rsp->ByteCount = 0;\n\t\terr_rsp->ErrorData[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, SMB2_ERROR_STRUCTURE_SIZE2);\n\t}\n}\n\n/**\n * is_smb2_neg_cmd() - is it smb2 negotiation command\n * @work:\tsmb work containing smb header\n *\n * Return:      true if smb2 negotiation command, otherwise false\n */\nbool is_smb2_neg_cmd(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is request not response message */\n\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\treturn false;\n\n\tif (hdr->Command != SMB2_NEGOTIATE)\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * is_smb2_rsp() - is it smb2 response\n * @work:\tsmb work containing smb response buffer\n *\n * Return:      true if smb2 response, otherwise false\n */\nbool is_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->response_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is response not request message */\n\tif (!(hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * get_smb2_cmd_val() - get smb command code from smb header\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      smb2 request command value\n */\nu16 get_smb2_cmd_val(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rcv_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trcv_hdr = ksmbd_req_buf_next(work);\n\telse\n\t\trcv_hdr = smb2_get_msg(work->request_buf);\n\treturn le16_to_cpu(rcv_hdr->Command);\n}\n\n/**\n * set_smb2_rsp_status() - set error response code on smb2 header\n * @work:\tsmb work containing response buffer\n * @err:\terror response code\n */\nvoid set_smb2_rsp_status(struct ksmbd_work *work, __le32 err)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp_hdr = ksmbd_resp_buf_next(work);\n\telse\n\t\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Status = err;\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * init_smb2_neg_rsp() - initialize smb2 response for negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * smb2 negotiate response is sent in reply of smb1 negotiate command for\n * dialect auto-negotiation.\n */\nint init_smb2_neg_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tif (conn->need_neg == false)\n\t\treturn -EINVAL;\n\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(2);\n\trsp_hdr->Command = SMB2_NEGOTIATE;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = 0;\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\n\tWARN_ON(ksmbd_conn_good(work));\n\n\trsp->StructureSize = cpu_to_le16(65);\n\tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying connection\n\t */\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\t/* Default Max Message Size till SMB2.0, 64K*/\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\tAUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tif (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\tconn->use_spnego = true;\n\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * smb2_set_rsp_credits() - set number of credits in response buffer\n * @work:\tsmb work containing smb response buffer\n */\nint smb2_set_rsp_credits(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *hdr = ksmbd_resp_buf_next(work);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned short credits_requested, aux_max;\n\tunsigned short credit_charge, credits_granted = 0;\n\n\tif (work->send_no_response)\n\t\treturn 0;\n\n\thdr->CreditCharge = req_hdr->CreditCharge;\n\n\tif (conn->total_credits > conn->vals->max_credits) {\n\t\thdr->CreditRequest = 0;\n\t\tpr_err(\"Total credits overflow: %d\\n\", conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tcredit_charge = max_t(unsigned short,\n\t\t\t      le16_to_cpu(req_hdr->CreditCharge), 1);\n\tif (credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Insufficient credits granted, given: %u, granted: %u\\n\",\n\t\t\t    credit_charge, conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tconn->total_credits -= credit_charge;\n\tconn->outstanding_credits -= credit_charge;\n\tcredits_requested = max_t(unsigned short,\n\t\t\t\t  le16_to_cpu(req_hdr->CreditRequest), 1);\n\n\t/* according to smb2.credits smbtorture, Windows server\n\t * 2016 or later grant up to 8192 credits at once.\n\t *\n\t * TODO: Need to adjuct CreditRequest value according to\n\t * current cpu load\n\t */\n\tif (hdr->Command == SMB2_NEGOTIATE)\n\t\taux_max = 1;\n\telse\n\t\taux_max = conn->vals->max_credits - credit_charge;\n\tcredits_granted = min_t(unsigned short, credits_requested, aux_max);\n\n\tif (conn->vals->max_credits - conn->total_credits < credits_granted)\n\t\tcredits_granted = conn->vals->max_credits -\n\t\t\tconn->total_credits;\n\n\tconn->total_credits += credits_granted;\n\twork->credits_granted += credits_granted;\n\n\tif (!req_hdr->NextCommand) {\n\t\t/* Update CreditRequest in last request */\n\t\thdr->CreditRequest = cpu_to_le16(work->credits_granted);\n\t}\n\tksmbd_debug(SMB,\n\t\t    \"credits: requested[%d] granted[%d] total_granted[%d]\\n\",\n\t\t    credits_requested, credits_granted,\n\t\t    conn->total_credits);\n\treturn 0;\n}\n\n/**\n * init_chained_smb2_rsp() - initialize smb2 chained response\n * @work:\tsmb work containing smb response buffer\n */\nstatic void init_chained_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *rsp = ksmbd_resp_buf_next(work);\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_hdr *rcv_hdr;\n\tint next_hdr_offset = 0;\n\tint len, new_len;\n\n\t/* Len of this response = updated RFC len - offset of previous cmd\n\t * in the compound rsp\n\t */\n\n\t/* Storing the current local FID which may be needed by subsequent\n\t * command in the compound request\n\t */\n\tif (req->Command == SMB2_CREATE && rsp->Status == STATUS_SUCCESS) {\n\t\twork->compound_fid = ((struct smb2_create_rsp *)rsp)->VolatileFileId;\n\t\twork->compound_pfid = ((struct smb2_create_rsp *)rsp)->PersistentFileId;\n\t\twork->compound_sid = le64_to_cpu(rsp->SessionId);\n\t}\n\n\tlen = get_rfc1002_len(work->response_buf) - work->next_smb2_rsp_hdr_off;\n\tnext_hdr_offset = le32_to_cpu(req->NextCommand);\n\n\tnew_len = ALIGN(len, 8);\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_hdr) + new_len - len);\n\trsp->NextCommand = cpu_to_le32(new_len);\n\n\twork->next_smb2_rcv_hdr_off += next_hdr_offset;\n\twork->next_smb2_rsp_hdr_off += new_len;\n\tksmbd_debug(SMB,\n\t\t    \"Compound req new_len = %d rcv off = %d rsp off = %d\\n\",\n\t\t    new_len, work->next_smb2_rcv_hdr_off,\n\t\t    work->next_smb2_rsp_hdr_off);\n\n\trsp_hdr = ksmbd_resp_buf_next(work);\n\trcv_hdr = ksmbd_req_buf_next(work);\n\n\tif (!(rcv_hdr->Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"related flag should be set\\n\");\n\t\twork->compound_fid = KSMBD_NO_FID;\n\t\twork->compound_pfid = KSMBD_NO_FID;\n\t}\n\tmemset((char *)rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR |\n\t\t\t\tSMB2_FLAGS_RELATED_OPERATIONS);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n}\n\n/**\n * is_chained_smb2_message() - check for chained command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      true if chained request, otherwise false\n */\nbool is_chained_smb2_message(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tunsigned int len, next_cmd;\n\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\thdr = ksmbd_req_buf_next(work);\n\tnext_cmd = le32_to_cpu(hdr->NextCommand);\n\tif (next_cmd > 0) {\n\t\tif ((u64)work->next_smb2_rcv_hdr_off + next_cmd +\n\t\t\t__SMB2_HEADER_STRUCTURE_SIZE >\n\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\tpr_err(\"next command(%u) offset exceeds smb msg size\\n\",\n\t\t\t       next_cmd);\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((u64)get_rfc1002_len(work->response_buf) + MAX_CIFS_SMALL_BUFFER_SIZE >\n\t\t    work->response_sz) {\n\t\t\tpr_err(\"next response offset exceeds response buffer size\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"got SMB2 chained command\\n\");\n\t\tinit_chained_smb2_rsp(work);\n\t\treturn true;\n\t} else if (work->next_smb2_rcv_hdr_off) {\n\t\t/*\n\t\t * This is last request in chained command,\n\t\t * align response to 8 byte\n\t\t */\n\t\tlen = ALIGN(get_rfc1002_len(work->response_buf), 8);\n\t\tlen = len - get_rfc1002_len(work->response_buf);\n\t\tif (len) {\n\t\t\tksmbd_debug(SMB, \"padding len %u\\n\", len);\n\t\t\tinc_rfc1001_len(work->response_buf, len);\n\t\t\tif (work->aux_payload_sz)\n\t\t\t\twork->aux_payload_sz += len;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * init_smb2_rsp_hdr() - initialize smb2 response\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint init_smb2_rsp_hdr(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr = smb2_get_msg(work->response_buf);\n\tstruct smb2_hdr *rcv_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\trsp_hdr->ProtocolId = rcv_hdr->ProtocolId;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n\n\twork->syncronous = true;\n\tif (work->async_id) {\n\t\tksmbd_release_id(&conn->async_ida, work->async_id);\n\t\twork->async_id = 0;\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_allocate_rsp_buf() - allocate smb2 response buffer\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise -ENOMEM\n */\nint smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\n\t/* allocate large response buf for chained commands */\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\n\twork->response_sz = sz;\n\treturn 0;\n}\n\n/**\n * smb2_check_user_session() - check for valid session for a user\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_check_user_session(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned int cmd = conn->ops->get_cmd_val(work);\n\tunsigned long long sess_id;\n\n\twork->sess = NULL;\n\t/*\n\t * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not\n\t * require a session id, so no need to validate user session's for\n\t * these commands.\n\t */\n\tif (cmd == SMB2_ECHO_HE || cmd == SMB2_NEGOTIATE_HE ||\n\t    cmd == SMB2_SESSION_SETUP_HE)\n\t\treturn 0;\n\n\tif (!ksmbd_conn_good(work))\n\t\treturn -EINVAL;\n\n\tsess_id = le64_to_cpu(req_hdr->SessionId);\n\t/* Check for validity of user session */\n\twork->sess = ksmbd_session_lookup_all(conn, sess_id);\n\tif (work->sess)\n\t\treturn 1;\n\tksmbd_debug(SMB, \"Invalid user session, Uid %llu\\n\", sess_id);\n\treturn -EINVAL;\n}\n\nstatic void destroy_previous_session(struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz)) {\n\t\tput_session(prev_sess);\n\t\treturn;\n\t}\n\n\tput_session(prev_sess);\n\tksmbd_session_destroy(prev_sess);\n}\n\n/**\n * smb2_get_name() - get filename string from on the wire smb format\n * @src:\tsource buffer\n * @maxlen:\tmaxlen of source string\n * @local_nls:\tnls_table pointer\n *\n * Return:      matching converted filename on success, otherwise error ptr\n */\nstatic char *\nsmb2_get_name(const char *src, const int maxlen, struct nls_table *local_nls)\n{\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(src, maxlen, 1, local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"failed to get name %ld\\n\", PTR_ERR(name));\n\t\treturn name;\n\t}\n\n\tksmbd_conv_path_to_unix(name);\n\tksmbd_strip_last_slash(name);\n\treturn name;\n}\n\nint setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint id;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Flags |= SMB2_FLAGS_ASYNC_COMMAND;\n\n\tid = ksmbd_acquire_async_msg_id(&conn->async_ida);\n\tif (id < 0) {\n\t\tpr_err(\"Failed to alloc async message id\\n\");\n\t\treturn id;\n\t}\n\twork->syncronous = false;\n\twork->async_id = id;\n\trsp_hdr->Id.AsyncId = cpu_to_le64(id);\n\n\tksmbd_debug(SMB,\n\t\t    \"Send interim Response to inform async request id : %d\\n\",\n\t\t    work->async_id);\n\n\twork->cancel_fn = fn;\n\twork->cancel_argv = arg;\n\n\tif (list_empty(&work->async_request_entry)) {\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_add_tail(&work->async_request_entry, &conn->async_requests);\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\treturn 0;\n}\n\nvoid smb2_send_interim_resp(struct ksmbd_work *work, __le32 status)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tsmb2_set_err_rsp(work);\n\trsp_hdr->Status = status;\n\n\twork->multiRsp = 1;\n\tksmbd_conn_write(work);\n\trsp_hdr->Status = 0;\n\twork->multiRsp = 0;\n}\n\nstatic __le32 smb2_get_reparse_tag_special_file(umode_t mode)\n{\n\tif (S_ISDIR(mode) || S_ISREG(mode))\n\t\treturn 0;\n\n\tif (S_ISLNK(mode))\n\t\treturn IO_REPARSE_TAG_LX_SYMLINK_LE;\n\telse if (S_ISFIFO(mode))\n\t\treturn IO_REPARSE_TAG_LX_FIFO_LE;\n\telse if (S_ISSOCK(mode))\n\t\treturn IO_REPARSE_TAG_AF_UNIX_LE;\n\telse if (S_ISCHR(mode))\n\t\treturn IO_REPARSE_TAG_LX_CHR_LE;\n\telse if (S_ISBLK(mode))\n\t\treturn IO_REPARSE_TAG_LX_BLK_LE;\n\n\treturn 0;\n}\n\n/**\n * smb2_get_dos_mode() - get file mode in dos format from unix mode\n * @stat:\tkstat containing file mode\n * @attribute:\tattribute flags\n *\n * Return:      converted dos mode\n */\nstatic int smb2_get_dos_mode(struct kstat *stat, int attribute)\n{\n\tint attr = 0;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\tattr = FILE_ATTRIBUTE_DIRECTORY |\n\t\t\t(attribute & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));\n\t} else {\n\t\tattr = (attribute & 0x00005137) | FILE_ATTRIBUTE_ARCHIVE;\n\t\tattr &= ~(FILE_ATTRIBUTE_DIRECTORY);\n\t\tif (S_ISREG(stat->mode) && (server_conf.share_fake_fscaps &\n\t\t\t\tFILE_SUPPORTS_SPARSE_FILES))\n\t\t\tattr |= FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (smb2_get_reparse_tag_special_file(stat->mode))\n\t\t\tattr |= FILE_ATTRIBUTE_REPARSE_POINT;\n\t}\n\n\treturn attr;\n}\n\nstatic void build_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt,\n\t\t\t       __le16 hash_id)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = hash_id;\n}\n\nstatic void build_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t       __le16 cipher_type)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(4);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CipherCount = cpu_to_le16(1);\n\tpneg_ctxt->Ciphers[0] = cipher_type;\n}\n\nstatic void build_compression_ctxt(struct smb2_compression_capabilities_context *pneg_ctxt,\n\t\t\t\t   __le16 comp_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16(sizeof(struct smb2_compression_capabilities_context)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Flags = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithms[0] = comp_algo;\n}\n\nstatic void build_sign_cap_ctxt(struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t__le16 sign_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_SIGNING_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16((sizeof(struct smb2_signing_capabilities) + 2)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SigningAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SigningAlgorithms[0] = sign_algo;\n}\n\nstatic void build_posix_ctxt(struct smb2_posix_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_POSIX_EXTENSIONS_AVAILABLE;\n\tpneg_ctxt->DataLength = cpu_to_le16(POSIX_CTXT_DATA_LEN);\n\t/* SMB2_CREATE_TAG_POSIX is \"0x93AD25509CB411E7B42383DE968BCD7C\" */\n\tpneg_ctxt->Name[0] = 0x93;\n\tpneg_ctxt->Name[1] = 0xAD;\n\tpneg_ctxt->Name[2] = 0x25;\n\tpneg_ctxt->Name[3] = 0x50;\n\tpneg_ctxt->Name[4] = 0x9C;\n\tpneg_ctxt->Name[5] = 0xB4;\n\tpneg_ctxt->Name[6] = 0x11;\n\tpneg_ctxt->Name[7] = 0xE7;\n\tpneg_ctxt->Name[8] = 0xB4;\n\tpneg_ctxt->Name[9] = 0x23;\n\tpneg_ctxt->Name[10] = 0x83;\n\tpneg_ctxt->Name[11] = 0xDE;\n\tpneg_ctxt->Name[12] = 0x96;\n\tpneg_ctxt->Name[13] = 0x8B;\n\tpneg_ctxt->Name[14] = 0xCD;\n\tpneg_ctxt->Name[15] = 0x7C;\n}\n\nstatic void assemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_negotiate_rsp *rsp,\n\t\t\t\t  void *smb2_buf_len)\n{\n\tchar *pneg_ctxt = (char *)rsp +\n\t\t\tle32_to_cpu(rsp->NegotiateContextOffset);\n\tint neg_ctxt_cnt = 1;\n\tint ctxt_size;\n\n\tksmbd_debug(SMB,\n\t\t    \"assemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt,\n\t\t\t   conn->preauth_info->Preauth_HashId);\n\trsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);\n\tinc_rfc1001_len(smb2_buf_len, AUTH_GSS_PADDING);\n\tctxt_size = sizeof(struct smb2_preauth_neg_context);\n\t/* Round to 8 byte boundary */\n\tpneg_ctxt += round_up(sizeof(struct smb2_preauth_neg_context), 8);\n\n\tif (conn->cipher_type) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt,\n\t\t\t\t   conn->cipher_type);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_encryption_neg_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt +=\n\t\t\tround_up(sizeof(struct smb2_encryption_neg_context) + 2,\n\t\t\t\t 8);\n\t}\n\n\tif (conn->compress_algorithm) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t/* Temporarily set to SMB3_COMPRESS_NONE */\n\t\tbuild_compression_ctxt((struct smb2_compression_capabilities_context *)pneg_ctxt,\n\t\t\t\t       conn->compress_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_compression_capabilities_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_compression_capabilities_context) + 2,\n\t\t\t\t      8);\n\t}\n\n\tif (conn->posix_ext_supported) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\tbuild_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_posix_neg_context);\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_posix_neg_context), 8);\n\t}\n\n\tif (conn->signing_negotiated) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\tbuild_sign_cap_ctxt((struct smb2_signing_capabilities *)pneg_ctxt,\n\t\t\t\t    conn->signing_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_signing_capabilities) + 2;\n\t}\n\n\tinc_rfc1001_len(smb2_buf_len, ctxt_size);\n}\n\nstatic __le32 decode_preauth_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\t__le32 err = STATUS_NO_PREAUTH_INTEGRITY_HASH_OVERLAP;\n\n\tif (pneg_ctxt->HashAlgorithms == SMB2_PREAUTH_INTEGRITY_SHA512) {\n\t\tconn->preauth_info->Preauth_HashId =\n\t\t\tSMB2_PREAUTH_INTEGRITY_SHA512;\n\t\terr = STATUS_SUCCESS;\n\t}\n\n\treturn err;\n}\n\nstatic void decode_encrypt_ctxt(struct ksmbd_conn *conn,\n\t\t\t\tstruct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t\tint len_of_ctxts)\n{\n\tint cph_cnt = le16_to_cpu(pneg_ctxt->CipherCount);\n\tint i, cphs_size = cph_cnt * sizeof(__le16);\n\n\tconn->cipher_type = 0;\n\n\tif (sizeof(struct smb2_encryption_neg_context) + cphs_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid cipher count(%d)\\n\", cph_cnt);\n\t\treturn;\n\t}\n\n\tif (!(server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION))\n\t\treturn;\n\n\tfor (i = 0; i < cph_cnt; i++) {\n\t\tif (pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_GCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_GCM) {\n\t\t\tksmbd_debug(SMB, \"Cipher ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->Ciphers[i]);\n\t\t\tconn->cipher_type = pneg_ctxt->Ciphers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * smb3_encryption_negotiated() - checks if server and client agreed on enabling encryption\n * @conn:\tsmb connection\n *\n * Return:\ttrue if connection should be encrypted, else false\n */\nstatic bool smb3_encryption_negotiated(struct ksmbd_conn *conn)\n{\n\tif (!conn->ops->generate_encryptionkey)\n\t\treturn false;\n\n\t/*\n\t * SMB 3.0 and 3.0.2 dialects use the SMB2_GLOBAL_CAP_ENCRYPTION flag.\n\t * SMB 3.1.1 uses the cipher_type field.\n\t */\n\treturn (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) ||\n\t    conn->cipher_type;\n}\n\nstatic void decode_compress_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_compression_capabilities_context *pneg_ctxt)\n{\n\tconn->compress_algorithm = SMB3_COMPRESS_NONE;\n}\n\nstatic void decode_sign_cap_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t int len_of_ctxts)\n{\n\tint sign_algo_cnt = le16_to_cpu(pneg_ctxt->SigningAlgorithmCount);\n\tint i, sign_alos_size = sign_algo_cnt * sizeof(__le16);\n\n\tconn->signing_negotiated = false;\n\n\tif (sizeof(struct smb2_signing_capabilities) + sign_alos_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid signing algorithm count(%d)\\n\", sign_algo_cnt);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < sign_algo_cnt; i++) {\n\t\tif (pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_HMAC_SHA256_LE ||\n\t\t    pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_AES_CMAC_LE) {\n\t\t\tksmbd_debug(SMB, \"Signing Algorithm ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->SigningAlgorithms[i]);\n\t\t\tconn->signing_negotiated = true;\n\t\t\tconn->signing_algorithm =\n\t\t\t\tpneg_ctxt->SigningAlgorithms[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen;\n\n\t\t/* check that offset is not beyond end of SMB */\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen + sizeof(struct smb2_neg_context) > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    len_of_ctxts);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     len_of_ctxts);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset = clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n\t}\n\treturn status;\n}\n\n/**\n * smb2_handle_negotiate() - handler for smb2 negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint smb2_handle_negotiate(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);\n\tint rc = 0;\n\tunsigned int smb2_buf_len, smb2_neg_size;\n\t__le32 status;\n\n\tksmbd_debug(SMB, \"Received negotiate request\\n\");\n\tconn->need_neg = false;\n\tif (ksmbd_conn_good(work)) {\n\t\tpr_err(\"conn->tcp_status is already in CifsGood State\\n\");\n\t\twork->send_no_response = 1;\n\t\treturn rc;\n\t}\n\n\tif (req->DialectCount == 0) {\n\t\tpr_err(\"malformed packet\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tsmb2_buf_len = get_rfc1002_len(work->request_buf);\n\tsmb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);\n\tif (smb2_neg_size > smb2_buf_len) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (conn->dialect == SMB311_PROT_ID) {\n\t\tunsigned int nego_ctxt_off = le32_to_cpu(req->NegotiateContextOffset);\n\n\t\tif (smb2_buf_len < nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size > nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    smb2_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tconn->cli_cap = le32_to_cpu(req->Capabilities);\n\tswitch (conn->dialect) {\n\tcase SMB311_PROT_ID:\n\t\tconn->preauth_info =\n\t\t\tkzalloc(sizeof(struct preauth_integrity_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!conn->preauth_info) {\n\t\t\trc = -ENOMEM;\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tstatus = deassemble_neg_contexts(conn, req,\n\t\t\t\t\t\t get_rfc1002_len(work->request_buf));\n\t\tif (status != STATUS_SUCCESS) {\n\t\t\tpr_err(\"deassemble_neg_contexts error(0x%x)\\n\",\n\t\t\t       status);\n\t\t\trsp->hdr.Status = status;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\trc = init_smb3_11_server(conn);\n\t\tif (rc < 0) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tksmbd_gen_preauth_integrity_hash(conn,\n\t\t\t\t\t\t work->request_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\t\trsp->NegotiateContextOffset =\n\t\t\t\tcpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\t\tassemble_neg_contexts(conn, rsp, work->response_buf);\n\t\tbreak;\n\tcase SMB302_PROT_ID:\n\t\tinit_smb3_02_server(conn);\n\t\tbreak;\n\tcase SMB30_PROT_ID:\n\t\tinit_smb3_0_server(conn);\n\t\tbreak;\n\tcase SMB21_PROT_ID:\n\t\tinit_smb2_1_server(conn);\n\t\tbreak;\n\tcase SMB2X_PROT_ID:\n\tcase BAD_PROT_ID:\n\tdefault:\n\t\tksmbd_debug(SMB, \"Server dialect :0x%x not supported\\n\",\n\t\t\t    conn->dialect);\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\n\t/* For stats */\n\tconn->connection_type = conn->dialect;\n\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\tmemcpy(conn->ClientGUID, req->ClientGUID,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\tconn->cli_sec_mode = le16_to_cpu(req->SecurityMode);\n\n\trsp->StructureSize = cpu_to_le16(65);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying server\n\t */\n\tmemset(rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\tksmbd_debug(SMB, \"negotiate context offset %d, count %d\\n\",\n\t\t    le32_to_cpu(rsp->NegotiateContextOffset),\n\t\t    le16_to_cpu(rsp->NegotiateContextCount));\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\t\t\t  le16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\t AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tconn->use_spnego = true;\n\n\tif ((server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||\n\t     server_conf.signing == KSMBD_CONFIG_OPT_DISABLED) &&\n\t    req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED_LE)\n\t\tconn->sign = true;\n\telse if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {\n\t\tserver_conf.enforced_signing = true;\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\t\tconn->sign = true;\n\t}\n\n\tconn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tksmbd_conn_set_need_negotiate(work);\n\nerr_out:\n\tif (rc < 0)\n\t\tsmb2_set_err_rsp(work);\n\n\treturn rc;\n}\n\nstatic int alloc_preauth_hash(struct ksmbd_session *sess,\n\t\t\t      struct ksmbd_conn *conn)\n{\n\tif (sess->Preauth_HashValue)\n\t\treturn 0;\n\n\tsess->Preauth_HashValue = kmemdup(conn->preauth_info->Preauth_HashValue,\n\t\t\t\t\t  PREAUTH_HASHVALUE_SIZE, GFP_KERNEL);\n\tif (!sess->Preauth_HashValue)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int generate_preauth_hash(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tu8 *preauth_hash;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn 0;\n\n\tif (conn->binding) {\n\t\tstruct preauth_session *preauth_sess;\n\n\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\tif (!preauth_sess) {\n\t\t\tpreauth_sess = ksmbd_preauth_session_alloc(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpreauth_hash = preauth_sess->Preauth_HashValue;\n\t} else {\n\t\tif (!sess->Preauth_HashValue)\n\t\t\tif (alloc_preauth_hash(sess, conn))\n\t\t\t\treturn -ENOMEM;\n\t\tpreauth_hash = sess->Preauth_HashValue;\n\t}\n\n\tksmbd_gen_preauth_integrity_hash(conn, work->request_buf, preauth_hash);\n\treturn 0;\n}\n\nstatic int decode_negotiation_token(struct ksmbd_conn *conn,\n\t\t\t\t    struct negotiate_message *negblob,\n\t\t\t\t    size_t sz)\n{\n\tif (!conn->use_spnego)\n\t\treturn -EINVAL;\n\n\tif (ksmbd_decode_negTokenInit((char *)negblob, sz, conn)) {\n\t\tif (ksmbd_decode_negTokenTarg((char *)negblob, sz, conn)) {\n\t\t\tconn->auth_mechs |= KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->preferred_auth_mech = KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->use_spnego = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ntlm_negotiate(struct ksmbd_work *work,\n\t\t\t  struct negotiate_message *negblob,\n\t\t\t  size_t negblob_len)\n{\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct challenge_message *chgblob;\n\tunsigned char *spnego_blob = NULL;\n\tu16 spnego_blob_len;\n\tchar *neg_blob;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"negotiate phase\\n\");\n\trc = ksmbd_decode_ntlmssp_neg_blob(negblob, negblob_len, work->conn);\n\tif (rc)\n\t\treturn rc;\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tchgblob =\n\t\t(struct challenge_message *)((char *)&rsp->hdr.ProtocolId + sz);\n\tmemset(chgblob, 0, sizeof(struct challenge_message));\n\n\tif (!work->conn->use_spnego) {\n\t\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\t\tif (sz < 0)\n\t\t\treturn -ENOMEM;\n\n\t\trsp->SecurityBufferLength = cpu_to_le16(sz);\n\t\treturn 0;\n\t}\n\n\tsz = sizeof(struct challenge_message);\n\tsz += (strlen(ksmbd_netbios_name()) * 2 + 1 + 4) * 6;\n\n\tneg_blob = kzalloc(sz, GFP_KERNEL);\n\tif (!neg_blob)\n\t\treturn -ENOMEM;\n\n\tchgblob = (struct challenge_message *)neg_blob;\n\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\tif (sz < 0) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = build_spnego_ntlmssp_neg_blob(&spnego_blob, &spnego_blob_len,\n\t\t\t\t\t   neg_blob, sz);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\nout:\n\tkfree(spnego_blob);\n\tkfree(neg_blob);\n\treturn rc;\n}\n\nstatic struct authenticate_message *user_authblob(struct ksmbd_conn *conn,\n\t\t\t\t\t\t  struct smb2_sess_setup_req *req)\n{\n\tint sz;\n\n\tif (conn->use_spnego && conn->mechToken)\n\t\treturn (struct authenticate_message *)conn->mechToken;\n\n\tsz = le16_to_cpu(req->SecurityBufferOffset);\n\treturn (struct authenticate_message *)((char *)&req->hdr.ProtocolId\n\t\t\t\t\t       + sz);\n}\n\nstatic struct ksmbd_user *session_user(struct ksmbd_conn *conn,\n\t\t\t\t       struct smb2_sess_setup_req *req)\n{\n\tstruct authenticate_message *authblob;\n\tstruct ksmbd_user *user;\n\tchar *name;\n\tunsigned int auth_msg_len, name_off, name_len, secbuf_len;\n\n\tsecbuf_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (secbuf_len < sizeof(struct authenticate_message)) {\n\t\tksmbd_debug(SMB, \"blob len %d too small\\n\", secbuf_len);\n\t\treturn NULL;\n\t}\n\tauthblob = user_authblob(conn, req);\n\tname_off = le32_to_cpu(authblob->UserName.BufferOffset);\n\tname_len = le16_to_cpu(authblob->UserName.Length);\n\tauth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;\n\n\tif (auth_msg_len < (u64)name_off + name_len)\n\t\treturn NULL;\n\n\tname = smb_strndup_from_utf16((const char *)authblob + name_off,\n\t\t\t\t      name_len,\n\t\t\t\t      true,\n\t\t\t\t      conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"cannot allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tksmbd_debug(SMB, \"session setup request for user %s\\n\", name);\n\tuser = ksmbd_login_user(name);\n\tkfree(name);\n\treturn user;\n}\n\nstatic int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(work->response_buf, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t/*\n\t * If session state is SMB2_SESSION_VALID, We can assume\n\t * that it is reauthentication. And the user/password\n\t * has been verified, so return it here.\n\t */\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\tif (conn->binding)\n\t\t\tgoto binding_session;\n\t\treturn 0;\n\t}\n\n\tif ((rsp->SessionFlags != SMB2_SESSION_FLAG_IS_GUEST_LE &&\n\t     (conn->sign || server_conf.enforced_signing)) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn) &&\n\t\t\t!(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\trc = conn->ops->generate_encryptionkey(sess);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t/*\n\t\t * signing is disable if encryption is enable\n\t\t * on this session\n\t\t */\n\t\tsess->sign = false;\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SMB_SERVER_KERBEROS5\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *in_blob, *out_blob;\n\tstruct channel *chann = NULL;\n\tu64 prev_sess_id;\n\tint in_len, out_len;\n\tint retval;\n\n\tin_blob = (char *)&req->hdr.ProtocolId +\n\t\tle16_to_cpu(req->SecurityBufferOffset);\n\tin_len = le16_to_cpu(req->SecurityBufferLength);\n\tout_blob = (char *)&rsp->hdr.ProtocolId +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\tout_len = work->response_sz -\n\t\t(le16_to_cpu(rsp->SecurityBufferOffset) + 4);\n\n\t/* Check previous session */\n\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_sess_id && prev_sess_id != sess->id)\n\t\tdestroy_previous_session(sess->user, prev_sess_id);\n\n\tif (sess->state == SMB2_SESSION_VALID)\n\t\tksmbd_free_user(sess->user);\n\n\tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n\t\t\t\t\t out_blob, &out_len);\n\tif (retval) {\n\t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\trsp->SecurityBufferLength = cpu_to_le16(out_len);\n\tinc_rfc1001_len(work->response_buf, out_len - 1);\n\n\tif ((conn->sign || server_conf.enforced_signing) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn)) {\n\t\tretval = conn->ops->generate_encryptionkey(sess);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\tsess->sign = false;\n\t}\n\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\tretval = conn->ops->generate_signingkey(sess, conn);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n#else\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nint smb2_sess_setup(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess;\n\tstruct negotiate_message *negblob;\n\tunsigned int negblob_len, negblob_off;\n\tint rc = 0;\n\n\tksmbd_debug(SMB, \"Received request for session setup\\n\");\n\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->SessionFlags = 0;\n\trsp->SecurityBufferOffset = cpu_to_le16(72);\n\trsp->SecurityBufferLength = 0;\n\tinc_rfc1001_len(work->response_buf, 9);\n\n\tif (!req->hdr.SessionId) {\n\t\tsess = ksmbd_smb2_session_create();\n\t\tif (!sess) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\trsp->hdr.SessionId = cpu_to_le64(sess->id);\n\t\tksmbd_session_register(conn, sess);\n\t} else if (conn->dialect >= SMB30_PROT_ID &&\n\t\t   (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   req->Flags & SMB2_SESSION_REQ_FLAG_BINDING) {\n\t\tu64 sess_id = le64_to_cpu(req->hdr.SessionId);\n\n\t\tsess = ksmbd_session_lookup_slowpath(sess_id);\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (conn->dialect != sess->conn->dialect) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!(req->hdr.Flags & SMB2_FLAGS_SIGNED)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (strncmp(conn->ClientGUID, sess->conn->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE)) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_IN_PROGRESS) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_EXPIRED) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (ksmbd_session_lookup(conn, sess_id)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tconn->binding = true;\n\t} else if ((conn->dialect < SMB30_PROT_ID ||\n\t\t    server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   (req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\tsess = NULL;\n\t\trc = -EACCES;\n\t\tgoto out_err;\n\t} else {\n\t\tsess = ksmbd_session_lookup(conn,\n\t\t\t\t\t    le64_to_cpu(req->hdr.SessionId));\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\twork->sess = sess;\n\n\tif (sess->state == SMB2_SESSION_EXPIRED)\n\t\tsess->state = SMB2_SESSION_IN_PROGRESS;\n\n\tnegblob_off = le16_to_cpu(req->SecurityBufferOffset);\n\tnegblob_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (negblob_off < offsetof(struct smb2_sess_setup_req, Buffer) ||\n\t    negblob_len < offsetof(struct negotiate_message, NegotiateFlags)) {\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tnegblob = (struct negotiate_message *)((char *)&req->hdr.ProtocolId +\n\t\t\tnegblob_off);\n\n\tif (decode_negotiation_token(conn, negblob, negblob_len) == 0) {\n\t\tif (conn->mechToken)\n\t\t\tnegblob = (struct negotiate_message *)conn->mechToken;\n\t}\n\n\tif (server_conf.auth_mechs & conn->auth_mechs) {\n\t\trc = generate_preauth_hash(work);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\n\t\tif (conn->preferred_auth_mech &\n\t\t\t\t(KSMBD_AUTH_KRB5 | KSMBD_AUTH_MSKRB5)) {\n\t\t\trc = krb5_authenticate(work);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tksmbd_conn_set_good(work);\n\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\tsess->Preauth_HashValue = NULL;\n\t\t} else if (conn->preferred_auth_mech == KSMBD_AUTH_NTLMSSP) {\n\t\t\tif (negblob->MessageType == NtLmNegotiate) {\n\t\t\t\trc = ntlm_negotiate(work, negblob, negblob_len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\t\t\t\trsp->hdr.Status =\n\t\t\t\t\tSTATUS_MORE_PROCESSING_REQUIRED;\n\t\t\t\t/*\n\t\t\t\t * Note: here total size -1 is done as an\n\t\t\t\t * adjustment for 0 size blob\n\t\t\t\t */\n\t\t\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\t\t\tle16_to_cpu(rsp->SecurityBufferLength) - 1);\n\n\t\t\t} else if (negblob->MessageType == NtLmAuthenticate) {\n\t\t\t\trc = ntlm_authenticate(work);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\tksmbd_conn_set_good(work);\n\t\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\t\tif (conn->binding) {\n\t\t\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\t\t\tpreauth_sess =\n\t\t\t\t\t\tksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\t\t\tif (preauth_sess) {\n\t\t\t\t\t\tlist_del(&preauth_sess->preauth_entry);\n\t\t\t\t\t\tkfree(preauth_sess);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\t\tsess->Preauth_HashValue = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: need one more negotiation */\n\t\t\tpr_err(\"Not support the preferred authentication\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"Not support authentication\\n\");\n\t\trc = -EINVAL;\n\t}\n\nout_err:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_NETWORK_SESSION_EXPIRED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\telse if (rc)\n\t\trsp->hdr.Status = STATUS_LOGON_FAILURE;\n\n\tif (conn->use_spnego && conn->mechToken) {\n\t\tkfree(conn->mechToken);\n\t\tconn->mechToken = NULL;\n\t}\n\n\tif (rc < 0) {\n\t\t/*\n\t\t * SecurityBufferOffset should be set to zero\n\t\t * in session setup error response.\n\t\t */\n\t\trsp->SecurityBufferOffset = 0;\n\n\t\tif (sess) {\n\t\t\tbool try_delay = false;\n\n\t\t\t/*\n\t\t\t * To avoid dictionary attacks (repeated session setups rapidly sent) to\n\t\t\t * connect to server, ksmbd make a delay of a 5 seconds on session setup\n\t\t\t * failure to make it harder to send enough random connection requests\n\t\t\t * to break into a server.\n\t\t\t */\n\t\t\tif (sess->user && sess->user->flags & KSMBD_USER_FLAG_DELAY_SESSION)\n\t\t\t\ttry_delay = true;\n\n\t\t\tksmbd_session_destroy(sess);\n\t\t\twork->sess = NULL;\n\t\t\tif (try_delay)\n\t\t\t\tssleep(5);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_tree_connect() - handler for smb2 tree connect command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_tree_connect(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_tree_connect_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_tree_connect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *treename = NULL, *name = NULL;\n\tstruct ksmbd_tree_conn_status status;\n\tstruct ksmbd_share_config *share;\n\tint rc = -EINVAL;\n\n\ttreename = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->PathLength), true,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(treename)) {\n\t\tpr_err(\"treename is NULL\\n\");\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tname = ksmbd_extract_sharename(treename);\n\tif (IS_ERR(name)) {\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tksmbd_debug(SMB, \"tree connect request for tree %s treename %s\\n\",\n\t\t    name, treename);\n\n\tstatus = ksmbd_tree_conn_connect(sess, name);\n\tif (status.ret == KSMBD_TREE_CONN_STATUS_OK)\n\t\trsp->hdr.Id.SyncId.TreeId = cpu_to_le32(status.tree_conn->id);\n\telse\n\t\tgoto out_err1;\n\n\tshare = status.tree_conn->share_conf;\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC share path request\\n\");\n\t\trsp->ShareType = SMB2_SHARE_TYPE_PIPE;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_DELETE_LE | FILE_READ_CONTROL_LE |\n\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\tFILE_SYNCHRONIZE_LE;\n\t} else {\n\t\trsp->ShareType = SMB2_SHARE_TYPE_DISK;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE;\n\t\tif (test_tree_conn_flag(status.tree_conn,\n\t\t\t\t\tKSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\trsp->MaximalAccess |= FILE_WRITE_DATA_LE |\n\t\t\t\tFILE_APPEND_DATA_LE | FILE_WRITE_EA_LE |\n\t\t\t\tFILE_DELETE_LE | FILE_WRITE_ATTRIBUTES_LE |\n\t\t\t\tFILE_DELETE_CHILD_LE | FILE_READ_CONTROL_LE |\n\t\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\t\tFILE_SYNCHRONIZE_LE;\n\t\t}\n\t}\n\n\tstatus.tree_conn->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\tif (conn->posix_ext_supported)\n\t\tstatus.tree_conn->posix_extensions = true;\n\nout_err1:\n\trsp->StructureSize = cpu_to_le16(16);\n\trsp->Capabilities = 0;\n\trsp->Reserved = 0;\n\t/* default manual caching */\n\trsp->ShareFlags = SMB2_SHAREFLAG_MANUAL_CACHING;\n\tinc_rfc1001_len(work->response_buf, 16);\n\n\tif (!IS_ERR(treename))\n\t\tkfree(treename);\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tswitch (status.ret) {\n\tcase KSMBD_TREE_CONN_STATUS_OK:\n\t\trsp->hdr.Status = STATUS_SUCCESS;\n\t\trc = 0;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_NO_SHARE:\n\t\trsp->hdr.Status = STATUS_BAD_NETWORK_PATH;\n\t\tbreak;\n\tcase -ENOMEM:\n\tcase KSMBD_TREE_CONN_STATUS_NOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_ERROR:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_CONNS:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_SESSIONS:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tbreak;\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tdefault:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_create_open_flags() - convert smb open flags to unix open flags\n * @file_present:\tis file already present\n * @access:\t\tfile access flags\n * @disposition:\tfile disposition flags\n * @may_flags:\t\tset with MAY_ flags\n *\n * Return:      file open flags\n */\nstatic int smb2_create_open_flags(bool file_present, __le32 access,\n\t\t\t\t  __le32 disposition,\n\t\t\t\t  int *may_flags)\n{\n\tint oflags = O_NONBLOCK | O_LARGEFILE;\n\n\tif (access & FILE_READ_DESIRED_ACCESS_LE &&\n\t    access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_RDWR;\n\t\t*may_flags = MAY_OPEN | MAY_READ | MAY_WRITE;\n\t} else if (access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_WRONLY;\n\t\t*may_flags = MAY_OPEN | MAY_WRITE;\n\t} else {\n\t\toflags |= O_RDONLY;\n\t\t*may_flags = MAY_OPEN | MAY_READ;\n\t}\n\n\tif (access == FILE_READ_ATTRIBUTES_LE)\n\t\toflags |= O_PATH;\n\n\tif (file_present) {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_CREATE_LE:\n\t\t\tbreak;\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_TRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_CREATE_LE:\n\t\tcase FILE_OPEN_IF_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_CREAT;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\t\toflags &= ~O_CREAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn oflags;\n}\n\n/**\n * smb2_tree_disconnect() - handler for smb tree connect request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\treturn 0;\n}\n\n/**\n * smb2_session_logoff() - handler for session log off request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_session_logoff(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_logoff_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\t/* setting CifsExiting here may race with start_tcp_sess */\n\tksmbd_conn_set_need_reconnect(work);\n\tksmbd_close_session_fds(work);\n\tksmbd_conn_wait_idle(conn);\n\n\tif (ksmbd_tree_conn_session_logoff(sess)) {\n\t\tstruct smb2_logoff_req *req = smb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_destroy_file_table(&sess->file_table);\n\tsess->state = SMB2_SESSION_EXPIRED;\n\n\tksmbd_free_user(sess->user);\n\tsess->user = NULL;\n\n\t/* let start_tcp_sess free connection info now */\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * create_smb2_pipe() - create IPC pipe\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nstatic noinline int create_smb2_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_create_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_create_req *req = smb2_get_msg(work->request_buf);\n\tint id;\n\tint err;\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(req->Buffer, le16_to_cpu(req->NameLength),\n\t\t\t\t      1, work->conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\terr = PTR_ERR(name);\n\t\tgoto out;\n\t}\n\n\tid = ksmbd_session_rpc_open(work->sess, name);\n\tif (id < 0) {\n\t\tpr_err(\"Unable to open RPC pipe: %d\\n\", id);\n\t\terr = id;\n\t\tgoto out;\n\t}\n\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->StructureSize = cpu_to_le16(89);\n\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_NONE;\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(FILE_OPENED);\n\n\trsp->CreationTime = cpu_to_le64(0);\n\trsp->LastAccessTime = cpu_to_le64(0);\n\trsp->ChangeTime = cpu_to_le64(0);\n\trsp->AllocationSize = cpu_to_le64(0);\n\trsp->EndofFile = cpu_to_le64(0);\n\trsp->FileAttributes = FILE_ATTRIBUTE_NORMAL_LE;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFileId = id;\n\trsp->PersistentFileId = 0;\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\tkfree(name);\n\treturn 0;\n\nout:\n\tswitch (err) {\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tcase -ENOSPC:\n\tcase -ENOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\t}\n\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tsmb2_set_err_rsp(work);\n\treturn err;\n}\n\n/**\n * smb2_set_ea() - handler for setting extended attributes using set\n *\t\tinfo command\n * @eabuf:\tset info command buffer\n * @buf_len:\tset info command buffer length\n * @path:\tdentry path for get ea\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,\n\t\t       struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *attr_name = NULL, *value;\n\tint rc = 0;\n\tunsigned int next = 0;\n\n\tif (buf_len < sizeof(struct smb2_ea_info) + eabuf->EaNameLength +\n\t\t\tle16_to_cpu(eabuf->EaValueLength))\n\t\treturn -EINVAL;\n\n\tattr_name = kmalloc(XATTR_NAME_MAX + 1, GFP_KERNEL);\n\tif (!attr_name)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tif (!eabuf->EaNameLength)\n\t\t\tgoto next;\n\n\t\tksmbd_debug(SMB,\n\t\t\t    \"name : <%s>, name_len : %u, value_len : %u, next : %u\\n\",\n\t\t\t    eabuf->name, eabuf->EaNameLength,\n\t\t\t    le16_to_cpu(eabuf->EaValueLength),\n\t\t\t    le32_to_cpu(eabuf->NextEntryOffset));\n\n\t\tif (eabuf->EaNameLength >\n\t\t    (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN)) {\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(attr_name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\t\tmemcpy(&attr_name[XATTR_USER_PREFIX_LEN], eabuf->name,\n\t\t       eabuf->EaNameLength);\n\t\tattr_name[XATTR_USER_PREFIX_LEN + eabuf->EaNameLength] = '\\0';\n\t\tvalue = (char *)&eabuf->name + eabuf->EaNameLength + 1;\n\n\t\tif (!eabuf->EaValueLength) {\n\t\t\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t\t\t     path->dentry,\n\t\t\t\t\t\t     attr_name,\n\t\t\t\t\t\t     XATTR_USER_PREFIX_LEN +\n\t\t\t\t\t\t     eabuf->EaNameLength);\n\n\t\t\t/* delete the EA only when it exits */\n\t\t\tif (rc > 0) {\n\t\t\t\trc = ksmbd_vfs_remove_xattr(user_ns,\n\t\t\t\t\t\t\t    path->dentry,\n\t\t\t\t\t\t\t    attr_name);\n\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\t    \"remove xattr failed(%d)\\n\",\n\t\t\t\t\t\t    rc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* if the EA doesn't exist, just do nothing. */\n\t\t\trc = 0;\n\t\t} else {\n\t\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\t\tpath->dentry, attr_name, value,\n\t\t\t\t\t\tle16_to_cpu(eabuf->EaValueLength), 0);\n\t\t\tif (rc < 0) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"ksmbd_vfs_setxattr is failed(%d)\\n\",\n\t\t\t\t\t    rc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tnext = le32_to_cpu(eabuf->NextEntryOffset);\n\t\tif (next == 0 || buf_len < next)\n\t\t\tbreak;\n\t\tbuf_len -= next;\n\t\teabuf = (struct smb2_ea_info *)((char *)eabuf + next);\n\t\tif (next < (u32)eabuf->EaNameLength + le16_to_cpu(eabuf->EaValueLength))\n\t\t\tbreak;\n\n\t} while (next != 0);\n\n\tkfree(attr_name);\n\treturn rc;\n}\n\nstatic noinline int smb2_set_stream_name_xattr(struct path *path,\n\t\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t\t       char *stream_name, int s_type)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tsize_t xattr_stream_size;\n\tchar *xattr_stream_name;\n\tint rc;\n\n\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t s_type);\n\tif (rc)\n\t\treturn rc;\n\n\tfp->stream.name = xattr_stream_name;\n\tfp->stream.size = xattr_stream_size;\n\n\t/* Check if there is stream prefix in xattr space */\n\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t     path->dentry,\n\t\t\t\t     xattr_stream_name,\n\t\t\t\t     xattr_stream_size);\n\tif (rc >= 0)\n\t\treturn 0;\n\n\tif (fp->cdoption == FILE_OPEN_LE) {\n\t\tksmbd_debug(SMB, \"XATTR stream name lookup failed: %d\\n\", rc);\n\t\treturn -EBADF;\n\t}\n\n\trc = ksmbd_vfs_setxattr(user_ns, path->dentry,\n\t\t\t\txattr_stream_name, NULL, 0, 0);\n\tif (rc < 0)\n\t\tpr_err(\"Failed to store XATTR stream name :%d\\n\", rc);\n\treturn 0;\n}\n\nstatic int smb2_remove_smb_xattrs(struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], DOS_ATTRIBUTE_PREFIX,\n\t\t\t    DOS_ATTRIBUTE_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\terr = ksmbd_vfs_remove_xattr(user_ns, path->dentry, name);\n\t\tif (err)\n\t\t\tksmbd_debug(SMB, \"remove xattr failed : %s\\n\", name);\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nstatic int smb2_create_truncate(struct path *path)\n{\n\tint rc = vfs_truncate(path, 0);\n\n\tif (rc) {\n\t\tpr_err(\"vfs_truncate failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = smb2_remove_smb_xattrs(path);\n\tif (rc == -EOPNOTSUPP)\n\t\trc = 0;\n\tif (rc)\n\t\tksmbd_debug(SMB,\n\t\t\t    \"ksmbd_truncate_stream_name_xattr failed, rc %d\\n\",\n\t\t\t    rc);\n\treturn rc;\n}\n\nstatic void smb2_new_xattrs(struct ksmbd_tree_connect *tcon, struct path *path,\n\t\t\t    struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da = {0};\n\tint rc;\n\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\tda.version = 4;\n\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\tda.itime = da.create_time = fp->create_time;\n\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\tXATTR_DOSINFO_ITIME;\n\n\trc = ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc)\n\t\tksmbd_debug(SMB, \"failed to store file attribute into xattr\\n\");\n}\n\nstatic void smb2_update_xattrs(struct ksmbd_tree_connect *tcon,\n\t\t\t       struct path *path, struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da;\n\tint rc;\n\n\tfp->f_ci->m_fattr &= ~(FILE_ATTRIBUTE_HIDDEN_LE | FILE_ATTRIBUTE_SYSTEM_LE);\n\n\t/* get FileAttributes from XATTR_NAME_DOS_ATTRIBUTE */\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\trc = ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc > 0) {\n\t\tfp->f_ci->m_fattr = cpu_to_le32(da.attr);\n\t\tfp->create_time = da.create_time;\n\t\tfp->itime = da.itime;\n\t}\n}\n\nstatic int smb2_creat(struct ksmbd_work *work, struct path *path, char *name,\n\t\t      int open_flags, umode_t posix_mode, bool is_dir)\n{\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tumode_t mode;\n\tint rc;\n\n\tif (!(open_flags & O_CREAT))\n\t\treturn -EBADF;\n\n\tksmbd_debug(SMB, \"file does not exist, so creating\\n\");\n\tif (is_dir == true) {\n\t\tksmbd_debug(SMB, \"creating directory\\n\");\n\n\t\tmode = share_config_directory_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_mkdir(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tksmbd_debug(SMB, \"creating regular file\\n\");\n\n\t\tmode = share_config_create_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_create(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, 0, path, 0);\n\tif (rc) {\n\t\tpr_err(\"cannot get linux path (%s), err = %d\\n\",\n\t\t       name, rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int smb2_create_sd_buffer(struct ksmbd_work *work,\n\t\t\t\t struct smb2_create_req *req,\n\t\t\t\t struct path *path)\n{\n\tstruct create_context *context;\n\tstruct create_sd_buf_req *sd_buf;\n\n\tif (!req->CreateContextsOffset)\n\t\treturn -ENOENT;\n\n\t/* Parse SD BUFFER create contexts */\n\tcontext = smb2_find_context_vals(req, SMB2_CREATE_SD_BUFFER);\n\tif (!context)\n\t\treturn -ENOENT;\n\telse if (IS_ERR(context))\n\t\treturn PTR_ERR(context);\n\n\tksmbd_debug(SMB,\n\t\t    \"Set ACLs using SMB2_CREATE_SD_BUFFER context\\n\");\n\tsd_buf = (struct create_sd_buf_req *)context;\n\tif (le16_to_cpu(context->DataOffset) +\n\t    le32_to_cpu(context->DataLength) <\n\t    sizeof(struct create_sd_buf_req))\n\t\treturn -EINVAL;\n\treturn set_info_sec(work->conn, work->tcon, path, &sd_buf->ntsd,\n\t\t\t    le32_to_cpu(sd_buf->ccontext.DataLength), true);\n}\n\nstatic void ksmbd_acls_fattr(struct smb_fattr *fattr,\n\t\t\t     struct user_namespace *mnt_userns,\n\t\t\t     struct inode *inode)\n{\n\tfattr->cf_uid = i_uid_into_mnt(mnt_userns, inode);\n\tfattr->cf_gid = i_gid_into_mnt(mnt_userns, inode);\n\tfattr->cf_mode = inode->i_mode;\n\tfattr->cf_acls = NULL;\n\tfattr->cf_dacls = NULL;\n\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\tfattr->cf_acls = get_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tfattr->cf_dacls = get_acl(inode, ACL_TYPE_DEFAULT);\n\t}\n}\n\n/**\n * smb2_open() - handler for smb file open request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_open(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct path path;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file *filp = NULL;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct kstat stat;\n\tstruct create_context *context;\n\tstruct lease_ctx_info *lc = NULL;\n\tstruct create_ea_buf_req *ea_buf = NULL;\n\tstruct oplock_info *opinfo;\n\t__le32 *next_ptr = NULL;\n\tint req_op_level = 0, open_flags = 0, may_flags = 0, file_info = 0;\n\tint rc = 0;\n\tint contxt_cnt = 0, query_disk_id = 0;\n\tint maximal_access_ctxt = 0, posix_ctxt = 0;\n\tint s_type = 0;\n\tint next_off = 0;\n\tchar *name = NULL;\n\tchar *stream_name = NULL;\n\tbool file_present = false, created = false, already_permitted = false;\n\tint share_ret, need_truncate = 0;\n\tu64 time;\n\tumode_t posix_mode = 0;\n\t__le32 daccess, maximal_access = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (req->hdr.NextCommand && !work->next_smb2_rcv_hdr_off &&\n\t    (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"invalid flag in chained command\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe create request\\n\");\n\t\treturn create_smb2_pipe(work);\n\t}\n\n\tif (req->NameLength) {\n\t\tif ((req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t\t    *(char *)req->Buffer == '\\\\') {\n\t\t\tpr_err(\"not allow directory name included leading slash\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tname = smb2_get_name(req->Buffer,\n\t\t\t\t     le16_to_cpu(req->NameLength),\n\t\t\t\t     work->conn->local_nls);\n\t\tif (IS_ERR(name)) {\n\t\t\trc = PTR_ERR(name);\n\t\t\tif (rc != -ENOMEM)\n\t\t\t\trc = -ENOENT;\n\t\t\tname = NULL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"converted name = %s\\n\", name);\n\t\tif (strchr(name, ':')) {\n\t\t\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t    KSMBD_SHARE_FLAG_STREAMS)) {\n\t\t\t\trc = -EBADF;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\trc = parse_stream_name(name, &stream_name, &s_type);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_out1;\n\t\t}\n\n\t\trc = ksmbd_validate_filename(name);\n\t\tif (rc < 0)\n\t\t\tgoto err_out1;\n\n\t\tif (ksmbd_share_veto_filename(share, name)) {\n\t\t\trc = -ENOENT;\n\t\t\tksmbd_debug(SMB, \"Reject open(), vetoed file: %s\\n\",\n\t\t\t\t    name);\n\t\t\tgoto err_out1;\n\t\t}\n\t} else {\n\t\tname = kstrdup(\"\", GFP_KERNEL);\n\t\tif (!name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out1;\n\t\t}\n\t}\n\n\treq_op_level = req->RequestedOplockLevel;\n\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)\n\t\tlc = parse_lease_state(req);\n\n\tif (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE)) {\n\t\tpr_err(\"Invalid impersonationlevel : 0x%x\\n\",\n\t\t       le32_to_cpu(req->ImpersonationLevel));\n\t\trc = -EIO;\n\t\trsp->hdr.Status = STATUS_BAD_IMPERSONATION_LEVEL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK_LE)) {\n\t\tpr_err(\"Invalid create options : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateOptions));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t} else {\n\t\tif (req->CreateOptions & FILE_SEQUENTIAL_ONLY_LE &&\n\t\t    req->CreateOptions & FILE_RANDOM_ACCESS_LE)\n\t\t\treq->CreateOptions = ~(FILE_SEQUENTIAL_ONLY_LE);\n\n\t\tif (req->CreateOptions &\n\t\t    (FILE_OPEN_BY_FILE_ID_LE | CREATE_TREE_CONNECTION |\n\t\t     FILE_RESERVE_OPFILTER_LE)) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (req->CreateOptions & FILE_NO_COMPRESSION_LE) {\n\t\t\t\treq->CreateOptions = ~(FILE_NO_COMPRESSION_LE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (le32_to_cpu(req->CreateDisposition) >\n\t    le32_to_cpu(FILE_OVERWRITE_IF_LE)) {\n\t\tpr_err(\"Invalid create disposition : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateDisposition));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (!(req->DesiredAccess & DESIRED_ACCESS_MASK)) {\n\t\tpr_err(\"Invalid desired access : 0x%x\\n\",\n\t\t       le32_to_cpu(req->DesiredAccess));\n\t\trc = -EACCES;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->FileAttributes && !(req->FileAttributes & FILE_ATTRIBUTE_MASK_LE)) {\n\t\tpr_err(\"Invalid file attribute : 0x%x\\n\",\n\t\t       le32_to_cpu(req->FileAttributes));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\t/* Parse non-durable handle create contexts */\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_EA_BUFFER);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tea_buf = (struct create_ea_buf_req *)context;\n\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t    sizeof(struct create_ea_buf_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\tif (req->CreateOptions & FILE_NO_EA_KNOWLEDGE_LE) {\n\t\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\t\t\trc = -EACCES;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"get query maximal access context\\n\");\n\t\t\tmaximal_access_ctxt = 1;\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_TIMEWARP_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get timewarp context\\n\");\n\t\t\trc = -EBADF;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (tcon->posix_extensions) {\n\t\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t\t SMB2_CREATE_TAG_POSIX);\n\t\t\tif (IS_ERR(context)) {\n\t\t\t\trc = PTR_ERR(context);\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (context) {\n\t\t\t\tstruct create_posix *posix =\n\t\t\t\t\t(struct create_posix *)context;\n\t\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t\t    sizeof(struct create_posix) - 4) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto err_out1;\n\t\t\t\t}\n\t\t\t\tksmbd_debug(SMB, \"get posix context\\n\");\n\n\t\t\t\tposix_mode = le32_to_cpu(posix->Mode);\n\t\t\t\tposix_ctxt = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out1;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (!rc) {\n\t\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE) {\n\t\t\t/*\n\t\t\t * If file exists with under flags, return access\n\t\t\t * denied error.\n\t\t\t */\n\t\t\tif (req->CreateDisposition == FILE_OVERWRITE_IF_LE ||\n\t\t\t    req->CreateDisposition == FILE_OPEN_IF_LE) {\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else if (d_is_symlink(path.dentry)) {\n\t\t\trc = -EACCES;\n\t\t\tpath_put(&path);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto err_out;\n\t\tksmbd_debug(SMB, \"can not get linux path for %s, rc = %d\\n\",\n\t\t\t    name, rc);\n\t\trc = 0;\n\t} else {\n\t\tfile_present = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t}\n\tif (stream_name) {\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\t}\n\t\t} else {\n\t\t\tif (S_ISDIR(stat.mode) && s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\t\t}\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE &&\n\t\t    req->FileAttributes & FILE_ATTRIBUTE_NORMAL_LE) {\n\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\trc = -EIO;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (file_present && req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE &&\n\t    S_ISDIR(stat.mode) && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\tksmbd_debug(SMB, \"open() argument is a directory: %s, %x\\n\",\n\t\t\t    name, req->CreateOptions);\n\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (file_present && (req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t    !(req->CreateDisposition == FILE_CREATE_LE) &&\n\t    !S_ISDIR(stat.mode)) {\n\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (!stream_name && file_present &&\n\t    req->CreateDisposition == FILE_CREATE_LE) {\n\t\trc = -EEXIST;\n\t\tgoto err_out;\n\t}\n\n\tdaccess = smb_map_generic_desired_access(req->DesiredAccess);\n\n\tif (file_present && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\trc = smb_check_perm_dacl(conn, &path, &daccess,\n\t\t\t\t\t sess->user->uid);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (daccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tif (!file_present) {\n\t\t\tdaccess = cpu_to_le32(GENERIC_ALL_FLAGS);\n\t\t} else {\n\t\t\trc = ksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t    &daccess);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t\talready_permitted = true;\n\t\t}\n\t\tmaximal_access = daccess;\n\t}\n\n\topen_flags = smb2_create_open_flags(file_present, daccess,\n\t\t\t\t\t    req->CreateDisposition,\n\t\t\t\t\t    &may_flags);\n\n\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tif (open_flags & O_CREAT) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t/*create file if not present */\n\tif (!file_present) {\n\t\trc = smb2_creat(work, &path, name, open_flags, posix_mode,\n\t\t\t\treq->CreateOptions & FILE_DIRECTORY_FILE_LE);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOENT) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t}\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tcreated = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tif (ea_buf) {\n\t\t\tif (le32_to_cpu(ea_buf->ccontext.DataLength) <\n\t\t\t    sizeof(struct smb2_ea_info)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\trc = smb2_set_ea(&ea_buf->ea,\n\t\t\t\t\t le32_to_cpu(ea_buf->ccontext.DataLength),\n\t\t\t\t\t &path);\n\t\t\tif (rc == -EOPNOTSUPP)\n\t\t\t\trc = 0;\n\t\t\telse if (rc)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (!already_permitted) {\n\t\t/* FILE_READ_ATTRIBUTE is allowed without inode_permission,\n\t\t * because execute(search) permission on a parent directory,\n\t\t * is already granted.\n\t\t */\n\t\tif (daccess & ~(FILE_READ_ATTRIBUTES_LE | FILE_READ_CONTROL_LE)) {\n\t\t\trc = inode_permission(user_ns,\n\t\t\t\t\t      d_inode(path.dentry),\n\t\t\t\t\t      may_flags);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\n\t\t\tif ((daccess & FILE_DELETE_LE) ||\n\t\t\t    (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\t\t\trc = ksmbd_vfs_may_delete(user_ns,\n\t\t\t\t\t\t\t  path.dentry);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = ksmbd_query_inode_status(d_inode(path.dentry->d_parent));\n\tif (rc == KSMBD_INODE_STATUS_PENDING_DELETE) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\trc = 0;\n\tfilp = dentry_open(&path, open_flags, current_cred());\n\tif (IS_ERR(filp)) {\n\t\trc = PTR_ERR(filp);\n\t\tpr_err(\"dentry open for dir failed, rc %d\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\tif (file_present) {\n\t\tif (!(open_flags & O_TRUNC))\n\t\t\tfile_info = FILE_OPENED;\n\t\telse\n\t\t\tfile_info = FILE_OVERWRITTEN;\n\n\t\tif ((req->CreateDisposition & FILE_CREATE_MASK_LE) ==\n\t\t    FILE_SUPERSEDE_LE)\n\t\t\tfile_info = FILE_SUPERSEDED;\n\t} else if (open_flags & O_CREAT) {\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tksmbd_vfs_set_fadvise(filp, req->CreateOptions);\n\n\t/* Obtain Volatile-ID */\n\tfp = ksmbd_open_fd(work, filp);\n\tif (IS_ERR(fp)) {\n\t\tfput(filp);\n\t\trc = PTR_ERR(fp);\n\t\tfp = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/* Get Persistent-ID */\n\tksmbd_open_durable_fd(fp);\n\tif (!has_file_id(fp->persistent_id)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tfp->cdoption = req->CreateDisposition;\n\tfp->daccess = daccess;\n\tfp->saccess = req->ShareAccess;\n\tfp->coption = req->CreateOptions;\n\n\t/* Set default windows and posix acls if creating new file */\n\tif (created) {\n\t\tint posix_acl_rc;\n\t\tstruct inode *inode = d_inode(path.dentry);\n\n\t\tposix_acl_rc = ksmbd_vfs_inherit_posix_acl(user_ns,\n\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t   d_inode(path.dentry->d_parent));\n\t\tif (posix_acl_rc)\n\t\t\tksmbd_debug(SMB, \"inherit posix acl failed : %d\\n\", posix_acl_rc);\n\n\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\trc = smb_inherit_dacl(conn, &path, sess->user->uid,\n\t\t\t\t\t      sess->user->gid);\n\t\t}\n\n\t\tif (rc) {\n\t\t\trc = smb2_create_sd_buffer(work, req, &path);\n\t\t\tif (rc) {\n\t\t\t\tif (posix_acl_rc)\n\t\t\t\t\tksmbd_vfs_set_init_posix_acl(user_ns,\n\t\t\t\t\t\t\t\t     inode);\n\n\t\t\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\t\t\tstruct smb_fattr fattr;\n\t\t\t\t\tstruct smb_ntsd *pntsd;\n\t\t\t\t\tint pntsd_size, ace_num = 0;\n\n\t\t\t\t\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\t\t\t\t\tif (fattr.cf_acls)\n\t\t\t\t\t\tace_num = fattr.cf_acls->a_count;\n\t\t\t\t\tif (fattr.cf_dacls)\n\t\t\t\t\t\tace_num += fattr.cf_dacls->a_count;\n\n\t\t\t\t\tpntsd = kmalloc(sizeof(struct smb_ntsd) +\n\t\t\t\t\t\t\tsizeof(struct smb_sid) * 3 +\n\t\t\t\t\t\t\tsizeof(struct smb_acl) +\n\t\t\t\t\t\t\tsizeof(struct smb_ace) * ace_num * 2,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!pntsd)\n\t\t\t\t\t\tgoto err_out;\n\n\t\t\t\t\trc = build_sec_desc(user_ns,\n\t\t\t\t\t\t\t    pntsd, NULL,\n\t\t\t\t\t\t\t    OWNER_SECINFO |\n\t\t\t\t\t\t\t    GROUP_SECINFO |\n\t\t\t\t\t\t\t    DACL_SECINFO,\n\t\t\t\t\t\t\t    &pntsd_size, &fattr);\n\t\t\t\t\tposix_acl_release(fattr.cf_acls);\n\t\t\t\t\tposix_acl_release(fattr.cf_dacls);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\n\t\t\t\t\trc = ksmbd_vfs_set_sd_xattr(conn,\n\t\t\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t\t    pntsd,\n\t\t\t\t\t\t\t\t    pntsd_size);\n\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tpr_err(\"failed to store ntacl in xattr : %d\\n\",\n\t\t\t\t\t\t       rc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trc = 0;\n\t}\n\n\tif (stream_name) {\n\t\trc = smb2_set_stream_name_xattr(&path,\n\t\t\t\t\t\tfp,\n\t\t\t\t\t\tstream_name,\n\t\t\t\t\t\ts_type);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tfp->attrib_only = !(req->DesiredAccess & ~(FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_WRITE_ATTRIBUTES_LE | FILE_SYNCHRONIZE_LE));\n\tif (!S_ISDIR(file_inode(filp)->i_mode) && open_flags & O_TRUNC &&\n\t    !fp->attrib_only && !stream_name) {\n\t\tsmb_break_all_oplock(work, fp);\n\t\tneed_truncate = 1;\n\t}\n\n\t/* fp should be searchable through ksmbd_inode.m_fp_list\n\t * after daccess, saccess, attrib_only, and stream are\n\t * initialized.\n\t */\n\twrite_lock(&fp->f_ci->m_lock);\n\tlist_add(&fp->node, &fp->f_ci->m_fp_list);\n\twrite_unlock(&fp->f_ci->m_lock);\n\n\trc = ksmbd_vfs_getattr(&path, &stat);\n\tif (rc) {\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t\trc = 0;\n\t}\n\n\t/* Check delete pending among previous fp before oplock break */\n\tif (ksmbd_inode_pending_delete(fp)) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tshare_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);\n\tif (!test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_OPLOCKS) ||\n\t    (req_op_level == SMB2_OPLOCK_LEVEL_LEASE &&\n\t     !(conn->vals->capabilities & SMB2_GLOBAL_CAP_LEASING))) {\n\t\tif (share_ret < 0 && !S_ISDIR(file_inode(fp->filp)->i_mode)) {\n\t\t\trc = share_ret;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE) {\n\t\t\treq_op_level = smb2_map_lease_to_oplock(lc->req_state);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"lease req for(%s) req oplock state 0x%x, lease state 0x%x\\n\",\n\t\t\t\t    name, req_op_level, lc->req_state);\n\t\t\trc = find_same_lease_key(sess, fp->f_ci, lc);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t} else if (open_flags == O_RDONLY &&\n\t\t\t   (req_op_level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t\t\t    req_op_level == SMB2_OPLOCK_LEVEL_EXCLUSIVE))\n\t\t\treq_op_level = SMB2_OPLOCK_LEVEL_II;\n\n\t\trc = smb_grant_oplock(work, req_op_level,\n\t\t\t\t      fp->persistent_id, fp,\n\t\t\t\t      le32_to_cpu(req->hdr.Id.SyncId.TreeId),\n\t\t\t\t      lc, share_ret);\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)\n\t\tksmbd_fd_set_delete_on_close(fp, file_info);\n\n\tif (need_truncate) {\n\t\trc = smb2_create_truncate(&path);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\tstruct create_alloc_size_req *az_req;\n\n\t\taz_req = (struct create_alloc_size_req *)smb2_find_context_vals(req,\n\t\t\t\t\tSMB2_CREATE_ALLOCATION_SIZE);\n\t\tif (IS_ERR(az_req)) {\n\t\t\trc = PTR_ERR(az_req);\n\t\t\tgoto err_out;\n\t\t} else if (az_req) {\n\t\t\tloff_t alloc_size;\n\t\t\tint err;\n\n\t\t\tif (le16_to_cpu(az_req->ccontext.DataOffset) +\n\t\t\t    le32_to_cpu(az_req->ccontext.DataLength) <\n\t\t\t    sizeof(struct create_alloc_size_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\talloc_size = le64_to_cpu(az_req->AllocationSize);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"request smb2 create allocate size : %llu\\n\",\n\t\t\t\t    alloc_size);\n\t\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\t\terr = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t\t    alloc_size);\n\t\t\tif (err < 0)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"vfs_fallocate is failed : %d\\n\",\n\t\t\t\t\t    err);\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_QUERY_ON_DISK_ID);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get query on disk id context\\n\");\n\t\t\tquery_disk_id = 1;\n\t\t}\n\t}\n\n\tif (stat.result_mask & STATX_BTIME)\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.btime);\n\telse\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.ctime);\n\tif (req->FileAttributes || fp->f_ci->m_fattr == 0)\n\t\tfp->f_ci->m_fattr =\n\t\t\tcpu_to_le32(smb2_get_dos_mode(&stat, le32_to_cpu(req->FileAttributes)));\n\n\tif (!created)\n\t\tsmb2_update_xattrs(tcon, &path, fp);\n\telse\n\t\tsmb2_new_xattrs(tcon, &path, fp);\n\n\tmemcpy(fp->client_guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE);\n\n\tgeneric_fillattr(user_ns, file_inode(fp->filp),\n\t\t\t &stat);\n\n\trsp->StructureSize = cpu_to_le16(89);\n\trcu_read_lock();\n\topinfo = rcu_dereference(fp->f_opinfo);\n\trsp->OplockLevel = opinfo != NULL ? opinfo->level : 0;\n\trcu_read_unlock();\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(file_info);\n\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\trsp->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\trsp->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\trsp->ChangeTime = cpu_to_le64(time);\n\trsp->AllocationSize = S_ISDIR(stat.mode) ? 0 :\n\t\tcpu_to_le64(stat.blocks << 9);\n\trsp->EndofFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\trsp->FileAttributes = fp->f_ci->m_fattr;\n\n\trsp->Reserved2 = 0;\n\n\trsp->PersistentFileId = fp->persistent_id;\n\trsp->VolatileFileId = fp->volatile_id;\n\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\n\t/* If lease is request send lease context response */\n\tif (opinfo && opinfo->is_lease) {\n\t\tstruct create_context *lease_ccontext;\n\n\t\tksmbd_debug(SMB, \"lease granted on(%s) lease state 0x%x\\n\",\n\t\t\t    name, opinfo->o_lease->state);\n\t\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\n\t\tlease_ccontext = (struct create_context *)rsp->Buffer;\n\t\tcontxt_cnt++;\n\t\tcreate_lease_buf(rsp->Buffer, opinfo->o_lease);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_lease_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_lease_size);\n\t\tnext_ptr = &lease_ccontext->Next;\n\t\tnext_off = conn->vals->create_lease_size;\n\t}\n\n\tif (maximal_access_ctxt) {\n\t\tstruct create_context *mxac_ccontext;\n\n\t\tif (maximal_access == 0)\n\t\t\tksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t       path.dentry,\n\t\t\t\t\t\t       &maximal_access);\n\t\tmxac_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_mxac_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tle32_to_cpu(maximal_access));\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_mxac_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_mxac_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &mxac_ccontext->Next;\n\t\tnext_off = conn->vals->create_mxac_size;\n\t}\n\n\tif (query_disk_id) {\n\t\tstruct create_context *disk_id_ccontext;\n\n\t\tdisk_id_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_disk_id_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tstat.ino, tcon->id);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_disk_id_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_disk_id_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &disk_id_ccontext->Next;\n\t\tnext_off = conn->vals->create_disk_id_size;\n\t}\n\n\tif (posix_ctxt) {\n\t\tcontxt_cnt++;\n\t\tcreate_posix_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tfp);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_posix_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_posix_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t}\n\n\tif (contxt_cnt > 0) {\n\t\trsp->CreateContextsOffset =\n\t\t\tcpu_to_le32(offsetof(struct smb2_create_rsp, Buffer));\n\t}\n\nerr_out:\n\tif (file_present || created)\n\t\tpath_put(&path);\n\tksmbd_revert_fsids(work);\nerr_out1:\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (rc == -EOPNOTSUPP)\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\telse if (rc == -EACCES || rc == -ESTALE || rc == -EXDEV)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\t\telse if (rc == -EPERM)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (rc == -EBUSY)\n\t\t\trsp->hdr.Status = STATUS_DELETE_PENDING;\n\t\telse if (rc == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\telse if (rc == -ENOEXEC)\n\t\t\trsp->hdr.Status = STATUS_DUPLICATE_OBJECTID;\n\t\telse if (rc == -ENXIO)\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_DEVICE;\n\t\telse if (rc == -EEXIST)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\t\telse if (rc == -EMFILE)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\tif (!rsp->hdr.Status)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\t\tif (fp)\n\t\t\tksmbd_fd_put(work, fp);\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_debug(SMB, \"Error response: %x\\n\", rsp->hdr.Status);\n\t}\n\n\tkfree(name);\n\tkfree(lc);\n\n\treturn 0;\n}\n\nstatic int readdir_info_level_struct_sz(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_full_directory_info);\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_both_directory_info);\n\tcase FILE_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_directory_info);\n\tcase FILE_NAMES_INFORMATION:\n\t\treturn sizeof(struct file_names_info);\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_full_dir_info);\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_both_directory_info);\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\treturn sizeof(struct smb2_posix_info);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dentry_name(struct ksmbd_dir_info *d_info, int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(ffdinfo->NextEntryOffset);\n\t\td_info->name = ffdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(ffdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fbdinfo->NextEntryOffset);\n\t\td_info->name = fbdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fbdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fdinfo->NextEntryOffset);\n\t\td_info->name = fdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fninfo->NextEntryOffset);\n\t\td_info->name = fninfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fninfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(dinfo->NextEntryOffset);\n\t\td_info->name = dinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(dinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fibdinfo->NextEntryOffset);\n\t\td_info->name = fibdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fibdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(posix_info->NextEntryOffset);\n\t\td_info->name = posix_info->name;\n\t\td_info->name_len = le32_to_cpu(posix_info->name_len);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * smb2_populate_readdir_entry() - encode directory entry in smb2 response\n * buffer\n * @conn:\tconnection instance\n * @info_level:\tsmb information level\n * @d_info:\tstructure included variables for query dir\n * @ksmbd_kstat:\tksmbd wrapper of dirent stat information\n *\n * if directory has many entries, find first can't read it fully.\n * find next might be called multiple times to read remaining dir entries\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,\n\t\t\t\t       struct ksmbd_dir_info *d_info,\n\t\t\t\t       struct ksmbd_kstat *ksmbd_kstat)\n{\n\tint next_entry_offset = 0;\n\tchar *conv_name;\n\tint conv_len;\n\tvoid *kstat;\n\tint struct_sz, rc = 0;\n\n\tconv_name = ksmbd_convert_dir_info_name(d_info,\n\t\t\t\t\t\tconn->local_nls,\n\t\t\t\t\t\t&conv_len);\n\tif (!conv_name)\n\t\treturn -ENOMEM;\n\n\t/* Somehow the name has only terminating NULL bytes */\n\tif (conv_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto free_conv_name;\n\t}\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level) - 1 + conv_len;\n\tnext_entry_offset = ALIGN(struct_sz, KSMBD_DIR_INFO_ALIGNMENT);\n\td_info->last_entry_off_align = next_entry_offset - struct_sz;\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\trc = -ENOSPC;\n\t\tgoto free_conv_name;\n\t}\n\n\tkstat = d_info->wptr;\n\tif (info_level != FILE_NAMES_INFORMATION)\n\t\tkstat = ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)kstat;\n\t\tffdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tffdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (ffdinfo->EaSize)\n\t\t\tffdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tffdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(ffdinfo->FileName, conv_name, conv_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)kstat;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfbdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fbdinfo->EaSize)\n\t\t\tfbdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfbdinfo->ShortNameLength = 0;\n\t\tfbdinfo->Reserved = 0;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfbdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fbdinfo->FileName, conv_name, conv_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)kstat;\n\t\tfdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fdinfo->FileName, conv_name, conv_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)kstat;\n\t\tfninfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tmemcpy(fninfo->FileName, conv_name, conv_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)kstat;\n\t\tdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (dinfo->EaSize)\n\t\t\tdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tdinfo->Reserved = 0;\n\t\tdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(dinfo->FileName, conv_name, conv_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)kstat;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfibdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fibdinfo->EaSize)\n\t\t\tfibdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfibdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tfibdinfo->ShortNameLength = 0;\n\t\tfibdinfo->Reserved = 0;\n\t\tfibdinfo->Reserved2 = cpu_to_le16(0);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfibdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fibdinfo->FileName, conv_name, conv_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\t\tu64 time;\n\n\t\tposix_info = (struct smb2_posix_info *)kstat;\n\t\tposix_info->Ignored = 0;\n\t\tposix_info->CreationTime = cpu_to_le64(ksmbd_kstat->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);\n\t\tposix_info->ChangeTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->atime);\n\t\tposix_info->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->mtime);\n\t\tposix_info->LastWriteTime = cpu_to_le64(time);\n\t\tposix_info->EndOfFile = cpu_to_le64(ksmbd_kstat->kstat->size);\n\t\tposix_info->AllocationSize = cpu_to_le64(ksmbd_kstat->kstat->blocks << 9);\n\t\tposix_info->DeviceId = cpu_to_le32(ksmbd_kstat->kstat->rdev);\n\t\tposix_info->HardLinks = cpu_to_le32(ksmbd_kstat->kstat->nlink);\n\t\tposix_info->Mode = cpu_to_le32(ksmbd_kstat->kstat->mode);\n\t\tposix_info->Inode = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tposix_info->DosAttributes =\n\t\t\tS_ISDIR(ksmbd_kstat->kstat->mode) ?\n\t\t\t\tFILE_ATTRIBUTE_DIRECTORY_LE : FILE_ATTRIBUTE_ARCHIVE_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tposix_info->DosAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tid_to_sid(from_kuid_munged(&init_user_ns, ksmbd_kstat->kstat->uid),\n\t\t\t  SIDNFS_USER, (struct smb_sid *)&posix_info->SidBuffer[0]);\n\t\tid_to_sid(from_kgid_munged(&init_user_ns, ksmbd_kstat->kstat->gid),\n\t\t\t  SIDNFS_GROUP, (struct smb_sid *)&posix_info->SidBuffer[20]);\n\t\tmemcpy(posix_info->name, conv_name, conv_len);\n\t\tposix_info->name_len = cpu_to_le32(conv_len);\n\t\tposix_info->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\n\t} /* switch (info_level) */\n\n\td_info->last_entry_offset = d_info->data_count;\n\td_info->data_count += next_entry_offset;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\n\tksmbd_debug(SMB,\n\t\t    \"info_level : %d, buf_len :%d, next_offset : %d, data_count : %d\\n\",\n\t\t    info_level, d_info->out_buf_len,\n\t\t    next_entry_offset, d_info->data_count);\n\nfree_conv_name:\n\tkfree(conv_name);\n\treturn rc;\n}\n\nstruct smb2_query_dir_private {\n\tstruct ksmbd_work\t*work;\n\tchar\t\t\t*search_pattern;\n\tstruct ksmbd_file\t*dir_fp;\n\n\tstruct ksmbd_dir_info\t*d_info;\n\tint\t\t\tinfo_level;\n};\n\nstatic void lock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n}\n\nstatic void unlock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_unlock(d_inode(dir));\n}\n\nstatic int process_query_dir_entries(struct smb2_query_dir_private *priv)\n{\n\tstruct user_namespace\t*user_ns = file_mnt_user_ns(priv->dir_fp->filp);\n\tstruct kstat\t\tkstat;\n\tstruct ksmbd_kstat\tksmbd_kstat;\n\tint\t\t\trc;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < priv->d_info->num_entry; i++) {\n\t\tstruct dentry *dent;\n\n\t\tif (dentry_name(priv->d_info, priv->info_level))\n\t\t\treturn -EINVAL;\n\n\t\tlock_dir(priv->dir_fp);\n\t\tdent = lookup_one(user_ns, priv->d_info->name,\n\t\t\t\t  priv->dir_fp->filp->f_path.dentry,\n\t\t\t\t  priv->d_info->name_len);\n\t\tunlock_dir(priv->dir_fp);\n\n\t\tif (IS_ERR(dent)) {\n\t\t\tksmbd_debug(SMB, \"Cannot lookup `%s' [%ld]\\n\",\n\t\t\t\t    priv->d_info->name,\n\t\t\t\t    PTR_ERR(dent));\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(d_is_negative(dent))) {\n\t\t\tdput(dent);\n\t\t\tksmbd_debug(SMB, \"Negative dentry `%s'\\n\",\n\t\t\t\t    priv->d_info->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tksmbd_kstat.kstat = &kstat;\n\t\tif (priv->info_level != FILE_NAMES_INFORMATION)\n\t\t\tksmbd_vfs_fill_dentry_attrs(priv->work,\n\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t    dent,\n\t\t\t\t\t\t    &ksmbd_kstat);\n\n\t\trc = smb2_populate_readdir_entry(priv->work->conn,\n\t\t\t\t\t\t priv->info_level,\n\t\t\t\t\t\t priv->d_info,\n\t\t\t\t\t\t &ksmbd_kstat);\n\t\tdput(dent);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int reserve_populate_dentry(struct ksmbd_dir_info *d_info,\n\t\t\t\t   int info_level)\n{\n\tint struct_sz;\n\tint conv_len;\n\tint next_entry_offset;\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level);\n\tif (struct_sz == -EOPNOTSUPP)\n\t\treturn -EOPNOTSUPP;\n\n\tconv_len = (d_info->name_len + 1) * 2;\n\tnext_entry_offset = ALIGN(struct_sz - 1 + conv_len,\n\t\t\t\t  KSMBD_DIR_INFO_ALIGNMENT);\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\treturn -ENOSPC;\n\t}\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->wptr;\n\t\tmemcpy(ffdinfo->FileName, d_info->name, d_info->name_len);\n\t\tffdinfo->FileName[d_info->name_len] = 0x00;\n\t\tffdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fbdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfbdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->wptr;\n\t\tmemcpy(fdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->wptr;\n\t\tmemcpy(fninfo->FileName, d_info->name, d_info->name_len);\n\t\tfninfo->FileName[d_info->name_len] = 0x00;\n\t\tfninfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->wptr;\n\t\tmemcpy(dinfo->FileName, d_info->name, d_info->name_len);\n\t\tdinfo->FileName[d_info->name_len] = 0x00;\n\t\tdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fibdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfibdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->wptr;\n\t\tmemcpy(posix_info->name, d_info->name, d_info->name_len);\n\t\tposix_info->name[d_info->name_len] = 0x00;\n\t\tposix_info->name_len = cpu_to_le32(d_info->name_len);\n\t\tposix_info->NextEntryOffset =\n\t\t\tcpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\t} /* switch (info_level) */\n\n\td_info->num_entry++;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\treturn 0;\n}\n\nstatic int __query_dir(struct dir_context *ctx, const char *name, int namlen,\n\t\t       loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data\t*buf;\n\tstruct smb2_query_dir_private\t*priv;\n\tstruct ksmbd_dir_info\t\t*d_info;\n\tint\t\t\t\trc;\n\n\tbuf\t= container_of(ctx, struct ksmbd_readdir_data, ctx);\n\tpriv\t= buf->private;\n\td_info\t= priv->d_info;\n\n\t/* dot and dotdot entries are already reserved */\n\tif (!strcmp(\".\", name) || !strcmp(\"..\", name))\n\t\treturn 0;\n\tif (ksmbd_share_veto_filename(priv->work->tcon->share_conf, name))\n\t\treturn 0;\n\tif (!match_pattern(name, namlen, priv->search_pattern))\n\t\treturn 0;\n\n\td_info->name\t\t= name;\n\td_info->name_len\t= namlen;\n\trc = reserve_populate_dentry(d_info, priv->info_level);\n\tif (rc)\n\t\treturn rc;\n\tif (d_info->flags & SMB2_RETURN_SINGLE_ENTRY) {\n\t\td_info->out_buf_len = 0;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void restart_ctx(struct dir_context *ctx)\n{\n\tctx->pos = 0;\n}\n\nstatic int verify_info_level(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\tcase FILE_DIRECTORY_INFORMATION:\n\tcase FILE_NAMES_INFORMATION:\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\n\treturn min_t(int, out_buf_len, free_len);\n}\n\nint smb2_query_dir(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tstruct ksmbd_file *dir_fp = NULL;\n\tstruct ksmbd_dir_info d_info;\n\tint rc = 0;\n\tchar *srch_ptr = NULL;\n\tunsigned char srch_flag;\n\tint buffer_sz;\n\tstruct smb2_query_dir_private query_dir_private = {NULL, };\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = verify_info_level(req->FileInformationClass);\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto err_out2;\n\t}\n\n\tdir_fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!dir_fp) {\n\t\trc = -EBADF;\n\t\tgoto err_out2;\n\t}\n\n\tif (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||\n\t    inode_permission(file_mnt_user_ns(dir_fp->filp),\n\t\t\t     file_inode(dir_fp->filp),\n\t\t\t     MAY_READ | MAY_EXEC)) {\n\t\tpr_err(\"no right to enumerate directory (%pd)\\n\",\n\t\t       dir_fp->filp->f_path.dentry);\n\t\trc = -EACCES;\n\t\tgoto err_out2;\n\t}\n\n\tif (!S_ISDIR(file_inode(dir_fp->filp)->i_mode)) {\n\t\tpr_err(\"can't do query dir for a file\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t}\n\n\tsrch_flag = req->Flags;\n\tsrch_ptr = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->FileNameLength), 1,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(srch_ptr)) {\n\t\tksmbd_debug(SMB, \"Search Pattern not found\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t} else {\n\t\tksmbd_debug(SMB, \"Search pattern is %s\\n\", srch_ptr);\n\t}\n\n\tif (srch_flag & SMB2_REOPEN || srch_flag & SMB2_RESTART_SCANS) {\n\t\tksmbd_debug(SMB, \"Restart directory scan\\n\");\n\t\tgeneric_file_llseek(dir_fp->filp, 0, SEEK_SET);\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\t}\n\n\tmemset(&d_info, 0, sizeof(struct ksmbd_dir_info));\n\td_info.wptr = (char *)rsp->Buffer;\n\td_info.rptr = (char *)rsp->Buffer;\n\td_info.out_buf_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (d_info.out_buf_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\td_info.flags = srch_flag;\n\n\t/*\n\t * reserve dot and dotdot entries in head of buffer\n\t * in first response\n\t */\n\trc = ksmbd_populate_dot_dotdot_entries(work, req->FileInformationClass,\n\t\t\t\t\t       dir_fp, &d_info, srch_ptr,\n\t\t\t\t\t       smb2_populate_readdir_entry);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\telse if (rc)\n\t\tgoto err_out;\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_HIDE_DOT_FILES))\n\t\td_info.hide_dot_file = true;\n\n\tbuffer_sz\t\t\t\t= d_info.out_buf_len;\n\td_info.rptr\t\t\t\t= d_info.wptr;\n\tquery_dir_private.work\t\t\t= work;\n\tquery_dir_private.search_pattern\t= srch_ptr;\n\tquery_dir_private.dir_fp\t\t= dir_fp;\n\tquery_dir_private.d_info\t\t= &d_info;\n\tquery_dir_private.info_level\t\t= req->FileInformationClass;\n\tdir_fp->readdir_data.private\t\t= &query_dir_private;\n\tset_ctx_actor(&dir_fp->readdir_data.ctx, __query_dir);\n\n\trc = iterate_dir(dir_fp->filp, &dir_fp->readdir_data.ctx);\n\tif (rc == 0)\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\tif (rc)\n\t\tgoto err_out;\n\n\td_info.wptr = d_info.rptr;\n\td_info.out_buf_len = buffer_sz;\n\trc = process_query_dir_entries(&query_dir_private);\n\tif (rc)\n\t\tgoto err_out;\n\n\tif (!d_info.data_count && d_info.out_buf_len >= 0) {\n\t\tif (srch_flag & SMB2_RETURN_SINGLE_ENTRY && !is_asterisk(srch_ptr)) {\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\t\t} else {\n\t\t\tdir_fp->dot_dotdot[0] = dir_fp->dot_dotdot[1] = 0;\n\t\t\trsp->hdr.Status = STATUS_NO_MORE_FILES;\n\t\t}\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(0);\n\t\trsp->OutputBufferLength = cpu_to_le32(0);\n\t\trsp->Buffer[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, 9);\n\t} else {\n\t\t((struct file_directory_info *)\n\t\t((char *)rsp->Buffer + d_info.last_entry_offset))\n\t\t->NextEntryOffset = 0;\n\t\td_info.data_count -= d_info.last_entry_off_align;\n\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(72);\n\t\trsp->OutputBufferLength = cpu_to_le32(d_info.data_count);\n\t\tinc_rfc1001_len(work->response_buf, 8 + d_info.data_count);\n\t}\n\n\tkfree(srch_ptr);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n\nerr_out:\n\tpr_err(\"error while processing smb2 query dir rc = %d\\n\", rc);\n\tkfree(srch_ptr);\n\nerr_out2:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\telse if (rc == -EBADF)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tif (!rsp->hdr.Status)\n\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n}\n\n/**\n * buffer_check_err() - helper function to check buffer errors\n * @reqOutputBufferLength:\tmax buffer length expected in command response\n * @rsp:\t\tquery info response buffer contains output buffer length\n * @rsp_org:\t\tbase response buffer pointer in case of chained response\n * @infoclass_size:\tquery info class response buffer size\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int buffer_check_err(int reqOutputBufferLength,\n\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t    void *rsp_org, int infoclass_size)\n{\n\tif (reqOutputBufferLength < le32_to_cpu(rsp->OutputBufferLength)) {\n\t\tif (reqOutputBufferLength < infoclass_size) {\n\t\t\tpr_err(\"Invalid Buffer Size Requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INFO_LENGTH_MISMATCH;\n\t\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"Buffer Overflow\\n\");\n\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr) +\n\t\t\t\treqOutputBufferLength);\n\t\trsp->OutputBufferLength = cpu_to_le32(reqOutputBufferLength);\n\t}\n\treturn 0;\n}\n\nstatic void get_standard_info_pipe(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\n\tsinfo->AllocationSize = cpu_to_le64(4096);\n\tsinfo->EndOfFile = cpu_to_le64(0);\n\tsinfo->NumberOfLinks = cpu_to_le32(1);\n\tsinfo->DeletePending = 1;\n\tsinfo->Directory = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_internal_info_pipe(struct smb2_query_info_rsp *rsp, u64 num,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\n\t/* any unique number */\n\tfile_info->IndexNumber = cpu_to_le64(num | (1ULL << 63));\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int smb2_get_info_file_pipe(struct ksmbd_session *sess,\n\t\t\t\t   struct smb2_query_info_req *req,\n\t\t\t\t   struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tu64 id;\n\tint rc;\n\n\t/*\n\t * Windows can sometime send query file info request on\n\t * pipe without opening it, checking error condition here\n\t */\n\tid = req->VolatileFileId;\n\tif (!ksmbd_session_rpc_method(sess, id))\n\t\treturn -ENOENT;\n\n\tksmbd_debug(SMB, \"FileInfoClass %u, FileId 0x%llx\\n\",\n\t\t    req->FileInfoClass, req->VolatileFileId);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_standard_info_pipe(rsp, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_STANDARD_INFORMATION_SIZE);\n\t\tbreak;\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_internal_info_pipe(rsp, id, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_INTERNAL_INFORMATION_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"smb2_info_file_pipe for %u not supported\\n\",\n\t\t\t    req->FileInfoClass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\n\n/**\n * smb2_get_ea() - handler for smb2 get extended attribute command\n * @work:\tsmb work containing query info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\tget extended attribute request\n * @rsp:\tresponse buffer pointer\n * @rsp_org:\tbase response buffer pointer in case of chained response\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t       struct smb2_query_info_req *req,\n\t\t       struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_ea_info *eainfo, *prev_eainfo;\n\tchar *name, *ptr, *xattr_list = NULL, *buf;\n\tint rc, name_len, value_len, xattr_list_len, idx;\n\tssize_t buf_free_len, alignment_bytes, next_offset, rsp_data_cnt = 0;\n\tstruct smb2_ea_info_req *ea_req = NULL;\n\tstruct path *path;\n\tstruct user_namespace *user_ns = file_mnt_user_ns(fp->filp);\n\n\tif (!(fp->daccess & FILE_READ_EA_LE)) {\n\t\tpr_err(\"Not permitted to read ext attr : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tpath = &fp->filp->f_path;\n\t/* single EA entry is requested with given user.* name */\n\tif (req->InputBufferLength) {\n\t\tif (le32_to_cpu(req->InputBufferLength) <\n\t\t    sizeof(struct smb2_ea_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tea_req = (struct smb2_ea_info_req *)req->Buffer;\n\t} else {\n\t\t/* need to send all EAs, if no specific EA is requested*/\n\t\tif (le32_to_cpu(req->Flags) & SL_RETURN_SINGLE_ENTRY)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"All EAs are requested but need to send single EA entry in rsp flags 0x%x\\n\",\n\t\t\t\t    le32_to_cpu(req->Flags));\n\t}\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\treturn -EINVAL;\n\n\trc = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (rc < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tgoto out;\n\t} else if (!rc) { /* there is no EA in the file */\n\t\tksmbd_debug(SMB, \"no ea data in the file\\n\");\n\t\tgoto done;\n\t}\n\txattr_list_len = rc;\n\n\tptr = (char *)rsp->Buffer;\n\teainfo = (struct smb2_ea_info *)ptr;\n\tprev_eainfo = eainfo;\n\tidx = 0;\n\n\twhile (idx < xattr_list_len) {\n\t\tname = xattr_list + idx;\n\t\tname_len = strlen(name);\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", name, name_len);\n\t\tidx += name_len + 1;\n\n\t\t/*\n\t\t * CIFS does not support EA other than user.* namespace,\n\t\t * still keep the framework generic, to list other attrs\n\t\t * in future.\n\t\t */\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX,\n\t\t\t     STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (req->InputBufferLength &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], ea_req->name,\n\t\t\t    ea_req->EaNameLength))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN],\n\t\t\t     DOS_ATTRIBUTE_PREFIX, DOS_ATTRIBUTE_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tname_len -= XATTR_USER_PREFIX_LEN;\n\n\t\tptr = (char *)(&eainfo->name + name_len + 1);\n\t\tbuf_free_len -= (offsetof(struct smb2_ea_info, name) +\n\t\t\t\tname_len + 1);\n\t\t/* bailout if xattr can't fit in buf_free_len */\n\t\tvalue_len = ksmbd_vfs_getxattr(user_ns, path->dentry,\n\t\t\t\t\t       name, &buf);\n\t\tif (value_len <= 0) {\n\t\t\trc = -ENOENT;\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf_free_len -= value_len;\n\t\tif (buf_free_len < 0) {\n\t\t\tkfree(buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(ptr, buf, value_len);\n\t\tkfree(buf);\n\n\t\tptr += value_len;\n\t\teainfo->Flags = 0;\n\t\teainfo->EaNameLength = name_len;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tmemcpy(eainfo->name, &name[XATTR_USER_PREFIX_LEN],\n\t\t\t       name_len);\n\t\telse\n\t\t\tmemcpy(eainfo->name, name, name_len);\n\n\t\teainfo->name[name_len] = '\\0';\n\t\teainfo->EaValueLength = cpu_to_le16(value_len);\n\t\tnext_offset = offsetof(struct smb2_ea_info, name) +\n\t\t\tname_len + 1 + value_len;\n\n\t\t/* align next xattr entry at 4 byte bundary */\n\t\talignment_bytes = ((next_offset + 3) & ~3) - next_offset;\n\t\tif (alignment_bytes) {\n\t\t\tmemset(ptr, '\\0', alignment_bytes);\n\t\t\tptr += alignment_bytes;\n\t\t\tnext_offset += alignment_bytes;\n\t\t\tbuf_free_len -= alignment_bytes;\n\t\t}\n\t\teainfo->NextEntryOffset = cpu_to_le32(next_offset);\n\t\tprev_eainfo = eainfo;\n\t\teainfo = (struct smb2_ea_info *)ptr;\n\t\trsp_data_cnt += next_offset;\n\n\t\tif (req->InputBufferLength) {\n\t\t\tksmbd_debug(SMB, \"single entry requested\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no more ea entries */\n\tprev_eainfo->NextEntryOffset = 0;\ndone:\n\trc = 0;\n\tif (rsp_data_cnt == 0)\n\t\trsp->hdr.Status = STATUS_NO_EAS_ON_FILE;\n\trsp->OutputBufferLength = cpu_to_le32(rsp_data_cnt);\n\tinc_rfc1001_len(rsp_org, rsp_data_cnt);\nout:\n\tkvfree(xattr_list);\n\treturn rc;\n}\n\nstatic void get_file_access_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_access_info *file_info;\n\n\tfile_info = (struct smb2_file_access_info *)rsp->Buffer;\n\tfile_info->AccessFlags = fp->daccess;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_access_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_access_info));\n}\n\nstatic int get_file_basic_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_basic_info *basic_info;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tbasic_info = (struct smb2_file_basic_info *)rsp->Buffer;\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tbasic_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tbasic_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tbasic_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tbasic_info->ChangeTime = cpu_to_le64(time);\n\tbasic_info->Attributes = fp->f_ci->m_fattr;\n\tbasic_info->Pad1 = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_basic_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_basic_info));\n\treturn 0;\n}\n\nstatic unsigned long long get_allocation_size(struct inode *inode,\n\t\t\t\t\t      struct kstat *stat)\n{\n\tunsigned long long alloc_size = 0;\n\n\tif (!S_ISDIR(stat->mode)) {\n\t\tif ((inode->i_blocks << 9) <= stat->size)\n\t\t\talloc_size = stat->size;\n\t\telse\n\t\t\talloc_size = inode->i_blocks << 9;\n\t}\n\n\treturn alloc_size;\n}\n\nstatic void get_file_standard_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\n\tsinfo->AllocationSize = cpu_to_le64(get_allocation_size(inode, &stat));\n\tsinfo->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tsinfo->NumberOfLinks = cpu_to_le32(get_nlink(&stat) - delete_pending);\n\tsinfo->DeletePending = delete_pending;\n\tsinfo->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_file_alignment_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct smb2_file_alignment_info *file_info;\n\n\tfile_info = (struct smb2_file_alignment_info *)rsp->Buffer;\n\tfile_info->AlignmentRequirement = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alignment_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_alignment_info));\n}\n\nstatic int get_file_all_info(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_rsp *rsp,\n\t\t\t     struct ksmbd_file *fp,\n\t\t\t     void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_all_info *file_info;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tint conv_len;\n\tchar *filename;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tksmbd_debug(SMB, \"no right to read the attributes : 0x%x\\n\",\n\t\t\t    fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfilename = convert_to_nt_pathname(work->tcon->share_conf, &fp->filp->f_path);\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tksmbd_debug(SMB, \"filename = %s\\n\", filename);\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\tfile_info = (struct smb2_file_all_info *)rsp->Buffer;\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->Pad1 = 0;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->NumberOfLinks =\n\t\t\tcpu_to_le32(get_nlink(&stat) - delete_pending);\n\tfile_info->DeletePending = delete_pending;\n\tfile_info->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\tfile_info->Pad2 = 0;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\tfile_info->EASize = 0;\n\tfile_info->AccessFlags = fp->daccess;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\tfile_info->Mode = fp->coption;\n\tfile_info->AlignmentRequirement = 0;\n\tconv_len = smbConvertToUTF16((__le16 *)file_info->FileName, filename,\n\t\t\t\t     PATH_MAX, conn->local_nls, 0);\n\tconv_len *= 2;\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_all_info) + conv_len - 1);\n\tkfree(filename);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n\treturn 0;\n}\n\nstatic void get_file_alternate_info(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_alt_name_info *file_info;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint conv_len;\n\n\tspin_lock(&dentry->d_lock);\n\tfile_info = (struct smb2_file_alt_name_info *)rsp->Buffer;\n\tconv_len = ksmbd_extract_shortname(conn,\n\t\t\t\t\t   dentry->d_name.name,\n\t\t\t\t\t   file_info->FileName);\n\tspin_unlock(&dentry->d_lock);\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alt_name_info) + conv_len);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n}\n\nstatic void get_file_stream_info(struct ksmbd_work *work,\n\t\t\t\t struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp,\n\t\t\t\t void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_stream_info *file_info;\n\tchar *stream_name, *xattr_list = NULL, *stream_buf;\n\tstruct kstat stat;\n\tstruct path *path = &fp->filp->f_path;\n\tssize_t xattr_list_len;\n\tint nbytes = 0, streamlen, stream_name_len, next, idx = 0;\n\tint buf_free_len;\n\tstruct smb2_query_info_req *req = ksmbd_req_buf_next(work);\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_stream_info *)rsp->Buffer;\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\tgoto out;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (idx < xattr_list_len) {\n\t\tstream_name = xattr_list + idx;\n\t\tstreamlen = strlen(stream_name);\n\t\tidx += streamlen + 1;\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", stream_name, streamlen);\n\n\t\tif (strncmp(&stream_name[XATTR_USER_PREFIX_LEN],\n\t\t\t    STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tstream_name_len = streamlen - (XATTR_USER_PREFIX_LEN +\n\t\t\t\tSTREAM_PREFIX_LEN);\n\t\tstreamlen = stream_name_len;\n\n\t\t/* plus : size */\n\t\tstreamlen += 1;\n\t\tstream_buf = kmalloc(streamlen + 1, GFP_KERNEL);\n\t\tif (!stream_buf)\n\t\t\tbreak;\n\n\t\tstreamlen = snprintf(stream_buf, streamlen + 1,\n\t\t\t\t     \":%s\", &stream_name[XATTR_NAME_STREAM_LEN]);\n\n\t\tnext = sizeof(struct smb2_file_stream_info) + streamlen * 2;\n\t\tif (next > buf_free_len) {\n\t\t\tkfree(stream_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tfile_info = (struct smb2_file_stream_info *)&rsp->Buffer[nbytes];\n\t\tstreamlen  = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t       stream_buf, streamlen,\n\t\t\t\t\t       conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tkfree(stream_buf);\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stream_name_len);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stream_name_len);\n\n\t\tnbytes += next;\n\t\tbuf_free_len -= next;\n\t\tfile_info->NextEntryOffset = cpu_to_le32(next);\n\t}\n\nout:\n\tif (!S_ISDIR(stat.mode) &&\n\t    buf_free_len >= sizeof(struct smb2_file_stream_info) + 7 * 2) {\n\t\tfile_info = (struct smb2_file_stream_info *)\n\t\t\t&rsp->Buffer[nbytes];\n\t\tstreamlen = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t      \"::$DATA\", 7, conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stat.size);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stat.blocks << 9);\n\t\tnbytes += sizeof(struct smb2_file_stream_info) + streamlen;\n\t}\n\n\t/* last entry offset should be 0 */\n\tfile_info->NextEntryOffset = 0;\n\tkvfree(xattr_list);\n\n\trsp->OutputBufferLength = cpu_to_le32(nbytes);\n\tinc_rfc1001_len(rsp_org, nbytes);\n}\n\nstatic void get_file_internal_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int get_file_network_open_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_ntwrk_info *file_info;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_ntwrk_info *)rsp->Buffer;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->Reserved = cpu_to_le32(0);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ntwrk_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ntwrk_info));\n\treturn 0;\n}\n\nstatic void get_file_ea_info(struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_file_ea_info *file_info;\n\n\tfile_info = (struct smb2_file_ea_info *)rsp->Buffer;\n\tfile_info->EASize = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ea_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ea_info));\n}\n\nstatic void get_file_position_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_pos_info *file_info;\n\n\tfile_info = (struct smb2_file_pos_info *)rsp->Buffer;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_pos_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_pos_info));\n}\n\nstatic void get_file_mode_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_mode_info *file_info;\n\n\tfile_info = (struct smb2_file_mode_info *)rsp->Buffer;\n\tfile_info->Mode = fp->coption & FILE_MODE_INFO_MASK;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_mode_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_mode_info));\n}\n\nstatic void get_file_compression_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_comp_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\n\tfile_info = (struct smb2_file_comp_info *)rsp->Buffer;\n\tfile_info->CompressedFileSize = cpu_to_le64(stat.blocks << 9);\n\tfile_info->CompressionFormat = COMPRESSION_FORMAT_NONE;\n\tfile_info->CompressionUnitShift = 0;\n\tfile_info->ChunkShift = 0;\n\tfile_info->ClusterShift = 0;\n\tmemset(&file_info->Reserved[0], 0, 3);\n\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_comp_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_comp_info));\n}\n\nstatic int get_file_attribute_tag_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_attr_tag_info *file_info;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_attr_tag_info *)rsp->Buffer;\n\tfile_info->FileAttributes = fp->f_ci->m_fattr;\n\tfile_info->ReparseTag = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_attr_tag_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_attr_tag_info));\n\treturn 0;\n}\n\nstatic int find_file_posix_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\tstruct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb311_posix_qinfo *file_info;\n\tstruct inode *inode = file_inode(fp->filp);\n\tu64 time;\n\n\tfile_info = (struct smb311_posix_qinfo *)rsp->Buffer;\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->DosAttributes = fp->f_ci->m_fattr;\n\tfile_info->Inode = cpu_to_le64(inode->i_ino);\n\tfile_info->EndOfFile = cpu_to_le64(inode->i_size);\n\tfile_info->AllocationSize = cpu_to_le64(inode->i_blocks << 9);\n\tfile_info->HardLinks = cpu_to_le32(inode->i_nlink);\n\tfile_info->Mode = cpu_to_le32(inode->i_mode);\n\tfile_info->DeviceId = cpu_to_le32(inode->i_rdev);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb311_posix_qinfo));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb311_posix_qinfo));\n\treturn 0;\n}\n\nstatic int smb2_get_info_file(struct ksmbd_work *work,\n\t\t\t      struct smb2_query_info_req *req,\n\t\t\t      struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tint fileinfoclass = 0;\n\tint rc = 0;\n\tint file_infoclass_size;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\t/* smb2 info file called for pipe */\n\t\treturn smb2_get_info_file_pipe(work->sess, req, rsp,\n\t\t\t\t\t       work->response_buf);\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tfileinfoclass = req->FileInfoClass;\n\n\tswitch (fileinfoclass) {\n\tcase FILE_ACCESS_INFORMATION:\n\t\tget_file_access_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ACCESS_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_BASIC_INFORMATION:\n\t\trc = get_file_basic_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_BASIC_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_file_standard_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STANDARD_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALIGNMENT_INFORMATION:\n\t\tget_file_alignment_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALIGNMENT_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALL_INFORMATION:\n\t\trc = get_file_all_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALTERNATE_NAME_INFORMATION:\n\t\tget_file_alternate_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALTERNATE_NAME_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STREAM_INFORMATION:\n\t\tget_file_stream_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STREAM_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_file_internal_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_INTERNAL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_NETWORK_OPEN_INFORMATION:\n\t\trc = get_file_network_open_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_NETWORK_OPEN_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_EA_INFORMATION:\n\t\tget_file_ea_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_FULL_EA_INFORMATION:\n\t\trc = smb2_get_ea(work, fp, req, rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_FULL_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_POSITION_INFORMATION:\n\t\tget_file_position_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_POSITION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_MODE_INFORMATION:\n\t\tget_file_mode_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_MODE_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_COMPRESSION_INFORMATION:\n\t\tget_file_compression_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_COMPRESSION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ATTRIBUTE_TAG_INFORMATION:\n\t\trc = get_file_attribute_tag_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ATTRIBUTE_TAG_INFORMATION_SIZE;\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\trc = find_file_posix_info(rsp, fp, work->response_buf);\n\t\t\tfile_infoclass_size = sizeof(struct smb311_posix_qinfo);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"fileinfoclass %d not supported yet\\n\",\n\t\t\t    fileinfoclass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\tif (!rc)\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, work->response_buf,\n\t\t\t\t      file_infoclass_size);\n\tksmbd_fd_put(work, fp);\n\treturn rc;\n}\n\nstatic int smb2_get_info_filesystem(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_req *req,\n\t\t\t\t    struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_conn *conn = sess->conn;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tint fsinfoclass = 0;\n\tstruct kstatfs stfs;\n\tstruct path path;\n\tint rc = 0, len;\n\tint fs_infoclass_size = 0;\n\n\trc = kern_path(share->path, LOOKUP_NO_SYMLINKS, &path);\n\tif (rc) {\n\t\tpr_err(\"cannot create vfs path\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = vfs_statfs(&path, &stfs);\n\tif (rc) {\n\t\tpr_err(\"cannot do stat of path %s\\n\", share->path);\n\t\tpath_put(&path);\n\t\treturn -EIO;\n\t}\n\n\tfsinfoclass = req->FileInfoClass;\n\n\tswitch (fsinfoclass) {\n\tcase FS_DEVICE_INFORMATION:\n\t{\n\t\tstruct filesystem_device_info *info;\n\n\t\tinfo = (struct filesystem_device_info *)rsp->Buffer;\n\n\t\tinfo->DeviceType = cpu_to_le32(stfs.f_type);\n\t\tinfo->DeviceCharacteristics = cpu_to_le32(0x00000020);\n\t\trsp->OutputBufferLength = cpu_to_le32(8);\n\t\tinc_rfc1001_len(work->response_buf, 8);\n\t\tfs_infoclass_size = FS_DEVICE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_ATTRIBUTE_INFORMATION:\n\t{\n\t\tstruct filesystem_attribute_info *info;\n\t\tsize_t sz;\n\n\t\tinfo = (struct filesystem_attribute_info *)rsp->Buffer;\n\t\tinfo->Attributes = cpu_to_le32(FILE_SUPPORTS_OBJECT_IDS |\n\t\t\t\t\t       FILE_PERSISTENT_ACLS |\n\t\t\t\t\t       FILE_UNICODE_ON_DISK |\n\t\t\t\t\t       FILE_CASE_PRESERVED_NAMES |\n\t\t\t\t\t       FILE_CASE_SENSITIVE_SEARCH |\n\t\t\t\t\t       FILE_SUPPORTS_BLOCK_REFCOUNTING);\n\n\t\tinfo->Attributes |= cpu_to_le32(server_conf.share_fake_fscaps);\n\n\t\tinfo->MaxPathNameComponentLength = cpu_to_le32(stfs.f_namelen);\n\t\tlen = smbConvertToUTF16((__le16 *)info->FileSystemName,\n\t\t\t\t\t\"NTFS\", PATH_MAX, conn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->FileSystemNameLen = cpu_to_le32(len);\n\t\tsz = sizeof(struct filesystem_attribute_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_ATTRIBUTE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_VOLUME_INFORMATION:\n\t{\n\t\tstruct filesystem_vol_info *info;\n\t\tsize_t sz;\n\t\tunsigned int serial_crc = 0;\n\n\t\tinfo = (struct filesystem_vol_info *)(rsp->Buffer);\n\t\tinfo->VolumeCreationTime = 0;\n\t\tserial_crc = crc32_le(serial_crc, share->name,\n\t\t\t\t      strlen(share->name));\n\t\tserial_crc = crc32_le(serial_crc, share->path,\n\t\t\t\t      strlen(share->path));\n\t\tserial_crc = crc32_le(serial_crc, ksmbd_netbios_name(),\n\t\t\t\t      strlen(ksmbd_netbios_name()));\n\t\t/* Taking dummy value of serial number*/\n\t\tinfo->SerialNumber = cpu_to_le32(serial_crc);\n\t\tlen = smbConvertToUTF16((__le16 *)info->VolumeLabel,\n\t\t\t\t\tshare->name, PATH_MAX,\n\t\t\t\t\tconn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->VolumeLabelSize = cpu_to_le32(len);\n\t\tinfo->Reserved = 0;\n\t\tsz = sizeof(struct filesystem_vol_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_VOLUME_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SIZE_INFORMATION:\n\t{\n\t\tstruct filesystem_info *info;\n\n\t\tinfo = (struct filesystem_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->FreeAllocationUnits = cpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(24);\n\t\tinc_rfc1001_len(work->response_buf, 24);\n\t\tfs_infoclass_size = FS_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_FULL_SIZE_INFORMATION:\n\t{\n\t\tstruct smb2_fs_full_size_info *info;\n\n\t\tinfo = (struct smb2_fs_full_size_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->CallerAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bavail);\n\t\tinfo->ActualAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(32);\n\t\tinc_rfc1001_len(work->response_buf, 32);\n\t\tfs_infoclass_size = FS_FULL_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_OBJECT_ID_INFORMATION:\n\t{\n\t\tstruct object_id_info *info;\n\n\t\tinfo = (struct object_id_info *)(rsp->Buffer);\n\n\t\tif (!user_guest(sess->user))\n\t\t\tmemcpy(info->objid, user_passkey(sess->user), 16);\n\t\telse\n\t\t\tmemset(info->objid, 0, 16);\n\n\t\tinfo->extended_info.magic = cpu_to_le32(EXTENDED_INFO_MAGIC);\n\t\tinfo->extended_info.version = cpu_to_le32(1);\n\t\tinfo->extended_info.release = cpu_to_le32(1);\n\t\tinfo->extended_info.rel_date = 0;\n\t\tmemcpy(info->extended_info.version_string, \"1.1.0\", strlen(\"1.1.0\"));\n\t\trsp->OutputBufferLength = cpu_to_le32(64);\n\t\tinc_rfc1001_len(work->response_buf, 64);\n\t\tfs_infoclass_size = FS_OBJECT_ID_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SECTOR_SIZE_INFORMATION:\n\t{\n\t\tstruct smb3_fs_ss_info *info;\n\t\tunsigned int sector_size =\n\t\t\tmin_t(unsigned int, path.mnt->mnt_sb->s_blocksize, 4096);\n\n\t\tinfo = (struct smb3_fs_ss_info *)(rsp->Buffer);\n\n\t\tinfo->LogicalBytesPerSector = cpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForPerf = cpu_to_le32(sector_size);\n\t\tinfo->FSEffPhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->Flags = cpu_to_le32(SSINFO_FLAGS_ALIGNED_DEVICE |\n\t\t\t\t    SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE);\n\t\tinfo->ByteOffsetForSectorAlignment = 0;\n\t\tinfo->ByteOffsetForPartitionAlignment = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(28);\n\t\tinc_rfc1001_len(work->response_buf, 28);\n\t\tfs_infoclass_size = FS_SECTOR_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_CONTROL_INFORMATION:\n\t{\n\t\t/*\n\t\t * TODO : The current implementation is based on\n\t\t * test result with win7(NTFS) server. It's need to\n\t\t * modify this to get valid Quota values\n\t\t * from Linux kernel\n\t\t */\n\t\tstruct smb2_fs_control_info *info;\n\n\t\tinfo = (struct smb2_fs_control_info *)(rsp->Buffer);\n\t\tinfo->FreeSpaceStartFiltering = 0;\n\t\tinfo->FreeSpaceThreshold = 0;\n\t\tinfo->FreeSpaceStopFiltering = 0;\n\t\tinfo->DefaultQuotaThreshold = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->DefaultQuotaLimit = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->Padding = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(48);\n\t\tinc_rfc1001_len(work->response_buf, 48);\n\t\tfs_infoclass_size = FS_CONTROL_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_POSIX_INFORMATION:\n\t{\n\t\tstruct filesystem_posix_info *info;\n\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\tinfo = (struct filesystem_posix_info *)(rsp->Buffer);\n\t\t\tinfo->OptimalTransferSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->BlockSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->TotalBlocks = cpu_to_le64(stfs.f_blocks);\n\t\t\tinfo->BlocksAvail = cpu_to_le64(stfs.f_bfree);\n\t\t\tinfo->UserBlocksAvail = cpu_to_le64(stfs.f_bavail);\n\t\t\tinfo->TotalFileNodes = cpu_to_le64(stfs.f_files);\n\t\t\tinfo->FreeFileNodes = cpu_to_le64(stfs.f_ffree);\n\t\t\trsp->OutputBufferLength = cpu_to_le32(56);\n\t\t\tinc_rfc1001_len(work->response_buf, 56);\n\t\t\tfs_infoclass_size = FS_POSIX_INFORMATION_SIZE;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpath_put(&path);\n\t\treturn -EOPNOTSUPP;\n\t}\n\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t      rsp, work->response_buf,\n\t\t\t      fs_infoclass_size);\n\tpath_put(&path);\n\treturn rc;\n}\n\nstatic int smb2_get_info_sec(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_req *req,\n\t\t\t     struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;\n\tstruct smb_fattr fattr = {{0}};\n\tstruct inode *inode;\n\t__u32 secdesclen;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\tint addition_info = le32_to_cpu(req->AdditionalInformation);\n\tint rc;\n\n\tif (addition_info & ~(OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO |\n\t\t\t      PROTECTED_DACL_SECINFO |\n\t\t\t      UNPROTECTED_DACL_SECINFO)) {\n\t\tksmbd_debug(SMB, \"Unsupported addition info: 0x%x)\\n\",\n\t\t       addition_info);\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PROTECTED);\n\t\tpntsd->osidoffset = 0;\n\t\tpntsd->gsidoffset = 0;\n\t\tpntsd->sacloffset = 0;\n\t\tpntsd->dacloffset = 0;\n\n\t\tsecdesclen = sizeof(struct smb_ntsd);\n\t\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\t\tinc_rfc1001_len(work->response_buf, secdesclen);\n\n\t\treturn 0;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tinode = file_inode(fp->filp);\n\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR))\n\t\tksmbd_vfs_get_sd_xattr(work->conn, user_ns,\n\t\t\t\t       fp->filp->f_path.dentry, &ppntsd);\n\n\trc = build_sec_desc(user_ns, pntsd, ppntsd, addition_info,\n\t\t\t    &secdesclen, &fattr);\n\tposix_acl_release(fattr.cf_acls);\n\tposix_acl_release(fattr.cf_dacls);\n\tkfree(ppntsd);\n\tksmbd_fd_put(work, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\tinc_rfc1001_len(work->response_buf, secdesclen);\n\treturn 0;\n}\n\n/**\n * smb2_query_info() - handler for smb2 query info command\n * @work:\tsmb work containing query info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_query_info(struct ksmbd_work *work)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp;\n\tint rc = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"GOT query info request\\n\");\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_get_info_file(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_FILESYSTEM:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILESYSTEM\\n\");\n\t\trc = smb2_get_info_filesystem(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\trc = smb2_get_info_sec(work, req, rsp);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"InfoType %d not supported yet\\n\",\n\t\t\t    req->InfoType);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0) {\n\t\tif (rc == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (rc == -EIO)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t\telse if (rc == -EOPNOTSUPP || rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\t\tsmb2_set_err_rsp(work);\n\n\t\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\",\n\t\t\t    rc);\n\t\treturn rc;\n\t}\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->OutputBufferOffset = cpu_to_le16(72);\n\tinc_rfc1001_len(work->response_buf, 8);\n\treturn 0;\n}\n\n/**\n * smb2_close_pipe() - handler for closing IPC pipe\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nstatic noinline int smb2_close_pipe(struct ksmbd_work *work)\n{\n\tu64 id;\n\tstruct smb2_close_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_close_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\tksmbd_session_rpc_close(work->sess, id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Flags = 0;\n\trsp->Reserved = 0;\n\trsp->CreationTime = 0;\n\trsp->LastAccessTime = 0;\n\trsp->LastWriteTime = 0;\n\trsp->ChangeTime = 0;\n\trsp->AllocationSize = 0;\n\trsp->EndOfFile = 0;\n\trsp->Attributes = 0;\n\tinc_rfc1001_len(work->response_buf, 60);\n\treturn 0;\n}\n\n/**\n * smb2_close() - handler for smb2 close file command\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nint smb2_close(struct ksmbd_work *work)\n{\n\tu64 volatile_id = KSMBD_NO_FID;\n\tu64 sess_id;\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_file *fp;\n\tstruct inode *inode;\n\tu64 time;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe close request\\n\");\n\t\treturn smb2_close_pipe(work);\n\t}\n\n\tsess_id = le64_to_cpu(req->hdr.SessionId);\n\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\tsess_id = work->compound_sid;\n\n\twork->compound_sid = 0;\n\tif (check_session_id(conn, sess_id)) {\n\t\twork->compound_sid = sess_id;\n\t} else {\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\t\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\terr = -EBADF;\n\t\tgoto out;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off &&\n\t    !has_file_id(req->VolatileFileId)) {\n\t\tif (!has_file_id(work->compound_fid)) {\n\t\t\t/* file already closed, return FILE_CLOSED */\n\t\t\tksmbd_debug(SMB, \"file already closed\\n\");\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Compound request set FID = %llu:%llu\\n\",\n\t\t\t\t    work->compound_fid,\n\t\t\t\t    work->compound_pfid);\n\t\t\tvolatile_id = work->compound_fid;\n\n\t\t\t/* file closed, stored id is not valid anymore */\n\t\t\twork->compound_fid = KSMBD_NO_FID;\n\t\t\twork->compound_pfid = KSMBD_NO_FID;\n\t\t}\n\t} else {\n\t\tvolatile_id = req->VolatileFileId;\n\t}\n\tksmbd_debug(SMB, \"volatile_id = %llu\\n\", volatile_id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Reserved = 0;\n\n\tif (req->Flags == SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB) {\n\t\tfp = ksmbd_lookup_fd_fast(work, volatile_id);\n\t\tif (!fp) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode = file_inode(fp->filp);\n\t\trsp->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;\n\t\trsp->AllocationSize = S_ISDIR(inode->i_mode) ? 0 :\n\t\t\tcpu_to_le64(inode->i_blocks << 9);\n\t\trsp->EndOfFile = cpu_to_le64(inode->i_size);\n\t\trsp->Attributes = fp->f_ci->m_fattr;\n\t\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\t\trsp->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\t\trsp->LastWriteTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\t\trsp->ChangeTime = cpu_to_le64(time);\n\t\tksmbd_fd_put(work, fp);\n\t} else {\n\t\trsp->Flags = 0;\n\t\trsp->AllocationSize = 0;\n\t\trsp->EndOfFile = 0;\n\t\trsp->Attributes = 0;\n\t\trsp->CreationTime = 0;\n\t\trsp->LastAccessTime = 0;\n\t\trsp->LastWriteTime = 0;\n\t\trsp->ChangeTime = 0;\n\t}\n\n\terr = ksmbd_close_fd(work, volatile_id);\nout:\n\tif (err) {\n\t\tif (rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t} else {\n\t\tinc_rfc1001_len(work->response_buf, 60);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_echo() - handler for smb2 echo(ping) command\n * @work:\tsmb work containing echo request buffer\n *\n * Return:\t0\n */\nint smb2_echo(struct ksmbd_work *work)\n{\n\tstruct smb2_echo_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n}\n\nstatic int smb2_rename(struct ksmbd_work *work,\n\t\t       struct ksmbd_file *fp,\n\t\t       struct user_namespace *user_ns,\n\t\t       struct smb2_file_rename_info *file_info,\n\t\t       struct nls_table *local_nls)\n{\n\tstruct ksmbd_share_config *share = fp->tcon->share_conf;\n\tchar *new_name = NULL, *abs_oldname = NULL, *old_name = NULL;\n\tchar *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tksmbd_debug(SMB, \"setting FILE_RENAME_INFO\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tabs_oldname = d_path(&fp->filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(abs_oldname)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\told_name = strrchr(abs_oldname, '/');\n\tif (old_name && old_name[1] != '\\0') {\n\t\told_name++;\n\t} else {\n\t\tksmbd_debug(SMB, \"can't get last component in path %s\\n\",\n\t\t\t    abs_oldname);\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tnew_name = smb2_get_name(file_info->FileName,\n\t\t\t\t le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t local_nls);\n\tif (IS_ERR(new_name)) {\n\t\trc = PTR_ERR(new_name);\n\t\tgoto out;\n\t}\n\n\tif (strchr(new_name, ':')) {\n\t\tint s_type;\n\t\tchar *xattr_stream_name, *stream_name = NULL;\n\t\tsize_t xattr_stream_size;\n\t\tint len;\n\n\t\trc = parse_stream_name(new_name, &stream_name, &s_type);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tlen = strlen(new_name);\n\t\tif (len > 0 && new_name[len - 1] != '/') {\n\t\t\tpr_err(\"not allow base filename in rename\\n\");\n\t\t\trc = -ESHARE;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t\t s_type);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\tfp->filp->f_path.dentry,\n\t\t\t\t\txattr_stream_name,\n\t\t\t\t\tNULL, 0, 0);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"failed to store stream name in xattr: %d\\n\",\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"new name %s\\n\", new_name);\n\trc = ksmbd_vfs_kern_path(work, new_name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (ksmbd_share_veto_filename(share, new_name)) {\n\t\trc = -ENOENT;\n\t\tksmbd_debug(SMB, \"Can't rename vetoed file: %s\\n\", new_name);\n\t\tgoto out;\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, new_name);\n\t\t\tif (rc) {\n\t\t\t\tif (rc != -ENOTEMPTY)\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s, rc %d\\n\",\n\t\t\t\t\t    new_name, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present &&\n\t\t    strncmp(old_name, path.dentry->d_name.name, strlen(old_name))) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"cannot rename already existing file\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_fp_rename(work, fp, new_name);\nout:\n\tkfree(pathname);\n\tif (!IS_ERR(new_name))\n\t\tkfree(new_name);\n\treturn rc;\n}\n\nstatic int smb2_create_link(struct ksmbd_work *work,\n\t\t\t    struct ksmbd_share_config *share,\n\t\t\t    struct smb2_file_link_info *file_info,\n\t\t\t    unsigned int buf_len, struct file *filp,\n\t\t\t    struct nls_table *local_nls)\n{\n\tchar *link_name = NULL, *target_name = NULL, *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_link_info) +\n\t\t\tle32_to_cpu(file_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tksmbd_debug(SMB, \"setting FILE_LINK_INFORMATION\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tlink_name = smb2_get_name(file_info->FileName,\n\t\t\t\t  le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t  local_nls);\n\tif (IS_ERR(link_name) || S_ISDIR(file_inode(filp)->i_mode)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"link name is %s\\n\", link_name);\n\ttarget_name = d_path(&filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(target_name)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"target name is %s\\n\", target_name);\n\trc = ksmbd_vfs_kern_path(work, link_name, LOOKUP_NO_SYMLINKS, &path, 0);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, link_name);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s\\n\",\n\t\t\t\t\t    link_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB, \"link already exists\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_link(work, target_name, link_name);\n\tif (rc)\n\t\trc = -EINVAL;\nout:\n\tif (!IS_ERR(link_name))\n\t\tkfree(link_name);\n\tkfree(pathname);\n\treturn rc;\n}\n\nstatic int set_file_basic_info(struct ksmbd_file *fp,\n\t\t\t       struct smb2_file_basic_info *file_info,\n\t\t\t       struct ksmbd_share_config *share)\n{\n\tstruct iattr attrs;\n\tstruct file *filp;\n\tstruct inode *inode;\n\tstruct user_namespace *user_ns;\n\tint rc = 0;\n\n\tif (!(fp->daccess & FILE_WRITE_ATTRIBUTES_LE))\n\t\treturn -EACCES;\n\n\tattrs.ia_valid = 0;\n\tfilp = fp->filp;\n\tinode = file_inode(filp);\n\tuser_ns = file_mnt_user_ns(filp);\n\n\tif (file_info->CreationTime)\n\t\tfp->create_time = le64_to_cpu(file_info->CreationTime);\n\n\tif (file_info->LastAccessTime) {\n\t\tattrs.ia_atime = ksmbd_NTtimeToUnix(file_info->LastAccessTime);\n\t\tattrs.ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t}\n\n\tattrs.ia_valid |= ATTR_CTIME;\n\tif (file_info->ChangeTime)\n\t\tattrs.ia_ctime = ksmbd_NTtimeToUnix(file_info->ChangeTime);\n\telse\n\t\tattrs.ia_ctime = inode->i_ctime;\n\n\tif (file_info->LastWriteTime) {\n\t\tattrs.ia_mtime = ksmbd_NTtimeToUnix(file_info->LastWriteTime);\n\t\tattrs.ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t}\n\n\tif (file_info->Attributes) {\n\t\tif (!S_ISDIR(inode->i_mode) &&\n\t\t    file_info->Attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {\n\t\t\tpr_err(\"can't change a file to a directory\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(S_ISDIR(inode->i_mode) && file_info->Attributes == FILE_ATTRIBUTE_NORMAL_LE))\n\t\t\tfp->f_ci->m_fattr = file_info->Attributes |\n\t\t\t\t(fp->f_ci->m_fattr & FILE_ATTRIBUTE_DIRECTORY_LE);\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_STORE_DOS_ATTRS) &&\n\t    (file_info->CreationTime || file_info->Attributes)) {\n\t\tstruct xattr_dos_attrib da = {0};\n\n\t\tda.version = 4;\n\t\tda.itime = fp->itime;\n\t\tda.create_time = fp->create_time;\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\t\tXATTR_DOSINFO_ITIME;\n\n\t\trc = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t    filp->f_path.dentry, &da);\n\t\tif (rc)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"failed to restore file attribute in EA\\n\");\n\t\trc = 0;\n\t}\n\n\tif (attrs.ia_valid) {\n\t\tstruct dentry *dentry = filp->f_path.dentry;\n\t\tstruct inode *inode = d_inode(dentry);\n\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EACCES;\n\n\t\tinode_lock(inode);\n\t\tinode->i_ctime = attrs.ia_ctime;\n\t\tattrs.ia_valid &= ~ATTR_CTIME;\n\t\trc = notify_change(user_ns, dentry, &attrs, NULL);\n\t\tinode_unlock(inode);\n\t}\n\treturn rc;\n}\n\nstatic int set_file_allocation_info(struct ksmbd_work *work,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    struct smb2_file_alloc_info *file_alloc_info)\n{\n\t/*\n\t * TODO : It's working fine only when store dos attributes\n\t * is not yes. need to implement a logic which works\n\t * properly with any smb.conf option\n\t */\n\n\tloff_t alloc_blks;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\talloc_blks = (le64_to_cpu(file_alloc_info->AllocationSize) + 511) >> 9;\n\tinode = file_inode(fp->filp);\n\n\tif (alloc_blks > inode->i_blocks) {\n\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\trc = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t   alloc_blks * 512);\n\t\tif (rc && rc != -EOPNOTSUPP) {\n\t\t\tpr_err(\"vfs_fallocate is failed : %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t} else if (alloc_blks < inode->i_blocks) {\n\t\tloff_t size;\n\n\t\t/*\n\t\t * Allocation size could be smaller than original one\n\t\t * which means allocated blocks in file should be\n\t\t * deallocated. use truncate to cut out it, but inode\n\t\t * size is also updated with truncate offset.\n\t\t * inode size is retained by backup inode size.\n\t\t */\n\t\tsize = i_size_read(inode);\n\t\trc = ksmbd_vfs_truncate(work, fp, alloc_blks * 512);\n\t\tif (rc) {\n\t\t\tpr_err(\"truncate failed!, err %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tif (size < alloc_blks * 512)\n\t\t\ti_size_write(inode, size);\n\t}\n\treturn 0;\n}\n\nstatic int set_end_of_file_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t\tstruct smb2_file_eof_info *file_eof_info)\n{\n\tloff_t newsize;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\tnewsize = le64_to_cpu(file_eof_info->EndOfFile);\n\tinode = file_inode(fp->filp);\n\n\t/*\n\t * If FILE_END_OF_FILE_INFORMATION of set_info_file is called\n\t * on FAT32 shared device, truncate execution time is too long\n\t * and network error could cause from windows client. because\n\t * truncate of some filesystem like FAT32 fill zero data in\n\t * truncated range.\n\t */\n\tif (inode->i_sb->s_magic != MSDOS_SUPER_MAGIC) {\n\t\tksmbd_debug(SMB, \"truncated to newsize %lld\\n\", newsize);\n\t\trc = ksmbd_vfs_truncate(work, fp, newsize);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"truncate failed!, err %d\\n\", rc);\n\t\t\tif (rc != -EAGAIN)\n\t\t\t\trc = -EBADF;\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t   struct smb2_file_rename_info *rename_info,\n\t\t\t   unsigned int buf_len)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ksmbd_file *parent_fp;\n\tstruct dentry *parent;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint ret;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_rename_info) +\n\t\t\tle32_to_cpu(rename_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tif (ksmbd_stream_fd(fp))\n\t\tgoto next;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tparent_fp = ksmbd_lookup_fd_inode(d_inode(parent));\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\n\tif (parent_fp) {\n\t\tif (parent_fp->daccess & FILE_DELETE_LE) {\n\t\t\tpr_err(\"parent dir is opened with delete access\\n\");\n\t\t\tksmbd_fd_put(work, parent_fp);\n\t\t\treturn -ESHARE;\n\t\t}\n\t\tksmbd_fd_put(work, parent_fp);\n\t}\nnext:\n\treturn smb2_rename(work, fp, user_ns, rename_info,\n\t\t\t   work->sess->conn->local_nls);\n}\n\nstatic int set_file_disposition_info(struct ksmbd_file *fp,\n\t\t\t\t     struct smb2_file_disposition_info *file_info)\n{\n\tstruct inode *inode;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tinode = file_inode(fp->filp);\n\tif (file_info->DeletePending) {\n\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t    ksmbd_vfs_empty_dir(fp) == -ENOTEMPTY)\n\t\t\treturn -EBUSY;\n\t\tksmbd_set_inode_pending_delete(fp);\n\t} else {\n\t\tksmbd_clear_inode_pending_delete(fp);\n\t}\n\treturn 0;\n}\n\nstatic int set_file_position_info(struct ksmbd_file *fp,\n\t\t\t\t  struct smb2_file_pos_info *file_info)\n{\n\tloff_t current_byte_offset;\n\tunsigned long sector_size;\n\tstruct inode *inode;\n\n\tinode = file_inode(fp->filp);\n\tcurrent_byte_offset = le64_to_cpu(file_info->CurrentByteOffset);\n\tsector_size = inode->i_sb->s_blocksize;\n\n\tif (current_byte_offset < 0 ||\n\t    (fp->coption == FILE_NO_INTERMEDIATE_BUFFERING_LE &&\n\t     current_byte_offset & (sector_size - 1))) {\n\t\tpr_err(\"CurrentByteOffset is not valid : %llu\\n\",\n\t\t       current_byte_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tfp->filp->f_pos = current_byte_offset;\n\treturn 0;\n}\n\nstatic int set_file_mode_info(struct ksmbd_file *fp,\n\t\t\t      struct smb2_file_mode_info *file_info)\n{\n\t__le32 mode;\n\n\tmode = file_info->Mode;\n\n\tif ((mode & ~FILE_MODE_INFO_MASK)) {\n\t\tpr_err(\"Mode is not valid : 0x%x\\n\", le32_to_cpu(mode));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * TODO : need to implement consideration for\n\t * FILE_SYNCHRONOUS_IO_ALERT and FILE_SYNCHRONOUS_IO_NONALERT\n\t */\n\tksmbd_vfs_set_fadvise(fp->filp, mode);\n\tfp->coption = mode;\n\treturn 0;\n}\n\n/**\n * smb2_set_info_file() - handler for smb2 set info command\n * @work:\tsmb work containing set info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\trequest buffer pointer\n * @share:\tksmbd_share_config pointer\n *\n * Return:\t0 on success, otherwise error\n * TODO: need to implement an error handling for STATUS_INFO_LENGTH_MISMATCH\n */\nstatic int smb2_set_info_file(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t      struct smb2_set_info_req *req,\n\t\t\t      struct ksmbd_share_config *share)\n{\n\tunsigned int buf_len = le32_to_cpu(req->BufferLength);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_BASIC_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_basic_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_basic_info(fp, (struct smb2_file_basic_info *)req->Buffer, share);\n\t}\n\tcase FILE_ALLOCATION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_alloc_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_allocation_info(work, fp,\n\t\t\t\t\t\t(struct smb2_file_alloc_info *)req->Buffer);\n\t}\n\tcase FILE_END_OF_FILE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_eof_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_end_of_file_info(work, fp,\n\t\t\t\t\t    (struct smb2_file_eof_info *)req->Buffer);\n\t}\n\tcase FILE_RENAME_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_rename_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_rename_info(work, fp,\n\t\t\t\t       (struct smb2_file_rename_info *)req->Buffer,\n\t\t\t\t       buf_len);\n\t}\n\tcase FILE_LINK_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_link_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_create_link(work, work->tcon->share_conf,\n\t\t\t\t\t(struct smb2_file_link_info *)req->Buffer,\n\t\t\t\t\tbuf_len, fp->filp,\n\t\t\t\t\twork->sess->conn->local_nls);\n\t}\n\tcase FILE_DISPOSITION_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_disposition_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_disposition_info(fp,\n\t\t\t\t\t\t (struct smb2_file_disposition_info *)req->Buffer);\n\t}\n\tcase FILE_FULL_EA_INFORMATION:\n\t{\n\t\tif (!(fp->daccess & FILE_WRITE_EA_LE)) {\n\t\t\tpr_err(\"Not permitted to write ext  attr: 0x%x\\n\",\n\t\t\t       fp->daccess);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_ea_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_set_ea((struct smb2_ea_info *)req->Buffer,\n\t\t\t\t   buf_len, &fp->filp->f_path);\n\t}\n\tcase FILE_POSITION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_pos_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_position_info(fp, (struct smb2_file_pos_info *)req->Buffer);\n\t}\n\tcase FILE_MODE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_mode_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_mode_info(fp, (struct smb2_file_mode_info *)req->Buffer);\n\t}\n\t}\n\n\tpr_err(\"Unimplemented Fileinfoclass :%d\\n\", req->FileInfoClass);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int smb2_set_info_sec(struct ksmbd_file *fp, int addition_info,\n\t\t\t     char *buffer, int buf_len)\n{\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)buffer;\n\n\tfp->saccess |= FILE_SHARE_DELETE_LE;\n\n\treturn set_info_sec(fp->conn, fp->tcon, &fp->filp->f_path, pntsd,\n\t\t\tbuf_len, false);\n}\n\n/**\n * smb2_set_info() - handler for smb2 set info command handler\n * @work:\tsmb work containing set info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_set_info(struct ksmbd_work *work)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp;\n\tstruct ksmbd_file *fp;\n\tint rc = 0;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tksmbd_debug(SMB, \"Received set info request\\n\");\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid id for close: %u\\n\", id);\n\t\trc = -ENOENT;\n\t\tgoto err_out;\n\t}\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_set_info_file(work, fp, req, work->tcon->share_conf);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\tif (ksmbd_override_fsids(work)) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\trc = smb2_set_info_sec(fp,\n\t\t\t\t       le32_to_cpu(req->AdditionalInformation),\n\t\t\t\t       req->Buffer,\n\t\t\t\t       le32_to_cpu(req->BufferLength));\n\t\tksmbd_revert_fsids(work);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0)\n\t\tgoto err_out;\n\n\trsp->StructureSize = cpu_to_le16(2);\n\tinc_rfc1001_len(work->response_buf, 2);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nerr_out:\n\tif (rc == -EACCES || rc == -EPERM || rc == -EXDEV)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\telse if (rc == -EBUSY || rc == -ENOTEMPTY)\n\t\trsp->hdr.Status = STATUS_DIRECTORY_NOT_EMPTY;\n\telse if (rc == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (rc == -EBADF || rc == -ESTALE)\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\telse if (rc == -EEXIST)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\telse if (rsp->hdr.Status == 0 || rc == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\", rc);\n\treturn rc;\n}\n\n/**\n * smb2_read_pipe() - handler for smb2 read from IPC pipe\n * @work:\tsmb work containing read IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_read_pipe(struct ksmbd_work *work)\n{\n\tint nbytes = 0, err;\n\tu64 id;\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tstruct smb2_read_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_read_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\n\tinc_rfc1001_len(work->response_buf, 16);\n\trpc_resp = ksmbd_rpc_read(work->sess, id);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\twork->aux_payload_buf =\n\t\t\tkvmalloc(rpc_resp->payload_sz, GFP_KERNEL | __GFP_ZERO);\n\t\tif (!work->aux_payload_buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(work->aux_payload_buf, rpc_resp->payload,\n\t\t       rpc_resp->payload_sz);\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\t\twork->aux_payload_sz = nbytes;\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\treturn 0;\n\nout:\n\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\tsmb2_set_err_rsp(work);\n\tkvfree(rpc_resp);\n\treturn err;\n}\n\nstatic int smb2_set_remote_key_for_rdma(struct ksmbd_work *work,\n\t\t\t\t\tstruct smb2_buffer_desc_v1 *desc,\n\t\t\t\t\t__le32 Channel,\n\t\t\t\t\t__le16 ChannelInfoOffset,\n\t\t\t\t\t__le16 ChannelInfoLength)\n{\n\tunsigned int i, ch_count;\n\n\tif (work->conn->dialect == SMB30_PROT_ID &&\n\t    Channel != SMB2_CHANNEL_RDMA_V1)\n\t\treturn -EINVAL;\n\n\tch_count = le16_to_cpu(ChannelInfoLength) / sizeof(*desc);\n\tif (ksmbd_debug_types & KSMBD_DEBUG_RDMA) {\n\t\tfor (i = 0; i < ch_count; i++) {\n\t\t\tpr_info(\"RDMA r/w request %#x: token %#x, length %#x\\n\",\n\t\t\t\ti,\n\t\t\t\tle32_to_cpu(desc[i].token),\n\t\t\t\tle32_to_cpu(desc[i].length));\n\t\t}\n\t}\n\tif (ch_count != 1) {\n\t\tksmbd_debug(RDMA, \"RDMA multiple buffer descriptors %d are not supported yet\\n\",\n\t\t\t    ch_count);\n\t\treturn -EINVAL;\n\t}\n\n\twork->need_invalidate_rkey =\n\t\t(Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE);\n\twork->remote_key = le32_to_cpu(desc->token);\n\treturn 0;\n}\n\nstatic ssize_t smb2_read_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t      struct smb2_read_req *req, void *data_buf,\n\t\t\t\t      size_t length)\n{\n\tstruct smb2_buffer_desc_v1 *desc =\n\t\t(struct smb2_buffer_desc_v1 *)&req->Buffer[0];\n\tint err;\n\n\terr = ksmbd_conn_rdma_write(work->conn, data_buf, length,\n\t\t\t\t    le32_to_cpu(desc->token),\n\t\t\t\t    le64_to_cpu(desc->offset),\n\t\t\t\t    le32_to_cpu(desc->length));\n\tif (err)\n\t\treturn err;\n\n\treturn length;\n}\n\n/**\n * smb2_read() - handler for smb2 read from file\n * @work:\tsmb work containing read command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_read(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_read_req *req;\n\tstruct smb2_read_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length, mincount;\n\tssize_t nbytes = 0, remain_bytes = 0;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe read request\\n\");\n\t\treturn smb2_read_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->ReadChannelInfoOffset);\n\n\t\tif (ch_offset < offsetof(struct smb2_read_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->ReadChannelInfoOffset,\n\t\t\t\t\t\t   req->ReadChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to read : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\tmincount = le32_to_cpu(req->MinimumCount);\n\n\tif (length > conn->vals->max_read_size) {\n\t\tksmbd_debug(SMB, \"limiting read size to max size(%u)\\n\",\n\t\t\t    conn->vals->max_read_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t    fp->filp->f_path.dentry, offset, length);\n\n\twork->aux_payload_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->aux_payload_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnbytes = ksmbd_vfs_read(work, fp, length, &offset);\n\tif (nbytes < 0) {\n\t\terr = nbytes;\n\t\tgoto out;\n\t}\n\n\tif ((nbytes == 0 && length != 0) || nbytes < mincount) {\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\t\trsp->hdr.Status = STATUS_END_OF_FILE;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn 0;\n\t}\n\n\tksmbd_debug(SMB, \"nbytes %zu, offset %lld mincount %zu\\n\",\n\t\t    nbytes, offset, mincount);\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1) {\n\t\t/* write data to the client using rdma channel */\n\t\tremain_bytes = smb2_read_rdma_channel(work, req,\n\t\t\t\t\t\t      work->aux_payload_buf,\n\t\t\t\t\t\t      nbytes);\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\n\t\tnbytes = 0;\n\t\tif (remain_bytes < 0) {\n\t\t\terr = (int)remain_bytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = cpu_to_le32(remain_bytes);\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\twork->aux_payload_sz = nbytes;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\tif (err == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\telse if (err == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (err == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (err == -ESHARE)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\t\tsmb2_set_err_rsp(work);\n\t}\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_write_pipe() - handler for smb2 write on IPC pipe\n * @work:\tsmb work containing write IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_write_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_write_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tu64 id = 0;\n\tint err = 0, ret = 0;\n\tchar *data_buf;\n\tsize_t length;\n\n\tlength = le32_to_cpu(req->Length);\n\tid = req->VolatileFileId;\n\n\tif (le16_to_cpu(req->DataOffset) ==\n\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\tdata_buf = (char *)&req->Buffer[0];\n\t} else {\n\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t\t       le16_to_cpu(req->DataOffset),\n\t\t\t       get_rfc1002_len(work->request_buf));\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\tle16_to_cpu(req->DataOffset));\n\t}\n\n\trpc_resp = ksmbd_rpc_write(work->sess, id, data_buf, length);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tkvfree(rpc_resp);\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\tkvfree(rpc_resp);\n\t\t\treturn ret;\n\t\t}\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(length);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\treturn 0;\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t smb2_write_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t       struct smb2_write_req *req,\n\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t       loff_t offset, size_t length, bool sync)\n{\n\tstruct smb2_buffer_desc_v1 *desc;\n\tchar *data_buf;\n\tint ret;\n\tssize_t nbytes;\n\n\tdesc = (struct smb2_buffer_desc_v1 *)&req->Buffer[0];\n\n\tdata_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\tret = ksmbd_conn_rdma_read(work->conn, data_buf, length,\n\t\t\t\t   le32_to_cpu(desc->token),\n\t\t\t\t   le64_to_cpu(desc->offset),\n\t\t\t\t   le32_to_cpu(desc->length));\n\tif (ret < 0) {\n\t\tkvfree(data_buf);\n\t\treturn ret;\n\t}\n\n\tret = ksmbd_vfs_write(work, fp, data_buf, length, &offset, sync, &nbytes);\n\tkvfree(data_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn nbytes;\n}\n\n/**\n * smb2_write() - handler for smb2 write from file\n * @work:\tsmb work containing write command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoOffset,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (length > work->conn->vals->max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    work->conn->vals->max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (req->Channel != SMB2_CHANNEL_RDMA_V1 &&\n\t    req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tif (le16_to_cpu(req->DataOffset) ==\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\tdata_buf = (char *)&req->Buffer[0];\n\t\t} else {\n\t\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t\t\t       le16_to_cpu(req->DataOffset),\n\t\t\t\t       get_rfc1002_len(work->request_buf));\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t\tle16_to_cpu(req->DataOffset));\n\t\t}\n\n\t\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\t\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\t\twritethrough = true;\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset,\n\t\t\t\t\t\t le32_to_cpu(req->RemainingBytes),\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_flush() - handler for smb2 flush file - fsync\n * @work:\tsmb work containing flush command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_flush(struct ksmbd_work *work)\n{\n\tstruct smb2_flush_req *req;\n\tstruct smb2_flush_rsp *rsp;\n\tint err;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"SMB2_FLUSH called for fid %llu\\n\", req->VolatileFileId);\n\n\terr = ksmbd_vfs_fsync(work, req->VolatileFileId, req->PersistentFileId);\n\tif (err)\n\t\tgoto out;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\n/**\n * smb2_cancel() - handler for smb2 cancel command\n * @work:\tsmb work containing cancel command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_cancel(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tstruct smb2_hdr *chdr;\n\tstruct ksmbd_work *cancel_work = NULL, *iter;\n\tstruct list_head *command_list;\n\n\tksmbd_debug(SMB, \"smb2 cancel called on mid %llu, async flags 0x%x\\n\",\n\t\t    hdr->MessageId, hdr->Flags);\n\n\tif (hdr->Flags & SMB2_FLAGS_ASYNC_COMMAND) {\n\t\tcommand_list = &conn->async_requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list,\n\t\t\t\t    async_request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (iter->async_id !=\n\t\t\t    le64_to_cpu(hdr->Id.AsyncId))\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with AsyncId %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->Id.AsyncId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t} else {\n\t\tcommand_list = &conn->requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list, request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (chdr->MessageId != hdr->MessageId ||\n\t\t\t    iter == work)\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with mid %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->MessageId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\tif (cancel_work) {\n\t\tcancel_work->state = KSMBD_WORK_CANCELLED;\n\t\tif (cancel_work->cancel_fn)\n\t\t\tcancel_work->cancel_fn(cancel_work->cancel_argv);\n\t}\n\n\t/* For SMB2_CANCEL command itself send no response*/\n\twork->send_no_response = 1;\n\treturn 0;\n}\n\nstruct file_lock *smb_flock_init(struct file *f)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\tgoto out;\n\n\tlocks_init_lock(fl);\n\n\tfl->fl_owner = f;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = f;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\nout:\n\treturn fl;\n}\n\nstatic int smb2_set_flock_flags(struct file_lock *flock, int flags)\n{\n\tint cmd = -EINVAL;\n\n\t/* Checking for wrong flag combination during lock request*/\n\tswitch (flags) {\n\tcase SMB2_LOCKFLAG_SHARED:\n\t\tksmbd_debug(SMB, \"received shared request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_RDLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE:\n\t\tksmbd_debug(SMB, \"received exclusive request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_WRLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_SHARED | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received shared & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received exclusive & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_UNLOCK:\n\t\tksmbd_debug(SMB, \"received unlock request\\n\");\n\t\tflock->fl_type = F_UNLCK;\n\t\tcmd = 0;\n\t\tbreak;\n\t}\n\n\treturn cmd;\n}\n\nstatic struct ksmbd_lock *smb2_lock_init(struct file_lock *flock,\n\t\t\t\t\t unsigned int cmd, int flags,\n\t\t\t\t\t struct list_head *lock_list)\n{\n\tstruct ksmbd_lock *lock;\n\n\tlock = kzalloc(sizeof(struct ksmbd_lock), GFP_KERNEL);\n\tif (!lock)\n\t\treturn NULL;\n\n\tlock->cmd = cmd;\n\tlock->fl = flock;\n\tlock->start = flock->fl_start;\n\tlock->end = flock->fl_end;\n\tlock->flags = flags;\n\tif (lock->start == lock->end)\n\t\tlock->zero_len = 1;\n\tINIT_LIST_HEAD(&lock->clist);\n\tINIT_LIST_HEAD(&lock->flist);\n\tINIT_LIST_HEAD(&lock->llist);\n\tlist_add_tail(&lock->llist, lock_list);\n\n\treturn lock;\n}\n\nstatic void smb2_remove_blocked_lock(void **argv)\n{\n\tstruct file_lock *flock = (struct file_lock *)argv[0];\n\n\tksmbd_vfs_posix_lock_unblock(flock);\n\twake_up(&flock->fl_wait);\n}\n\nstatic inline bool lock_defer_pending(struct file_lock *fl)\n{\n\t/* check pending lock waiters */\n\treturn waitqueue_active(&fl->fl_wait);\n}\n\n/**\n * smb2_lock() - handler for smb2 file lock command\n * @work:\tsmb work containing lock command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_lock(struct ksmbd_work *work)\n{\n\tstruct smb2_lock_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lock_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_lock_element *lock_ele;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file_lock *flock = NULL;\n\tstruct file *filp = NULL;\n\tint lock_count;\n\tint flags = 0;\n\tint cmd = 0;\n\tint err = -EIO, i, rc = 0;\n\tu64 lock_start, lock_length;\n\tstruct ksmbd_lock *smb_lock = NULL, *cmp_lock, *tmp, *tmp2;\n\tstruct ksmbd_conn *conn;\n\tint nolock = 0;\n\tLIST_HEAD(lock_list);\n\tLIST_HEAD(rollback_list);\n\tint prior_lock = 0;\n\n\tksmbd_debug(SMB, \"Received lock request\\n\");\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid file id for lock : %llu\\n\", req->VolatileFileId);\n\t\terr = -ENOENT;\n\t\tgoto out2;\n\t}\n\n\tfilp = fp->filp;\n\tlock_count = le16_to_cpu(req->LockCount);\n\tlock_ele = req->locks;\n\n\tksmbd_debug(SMB, \"lock count is %d\\n\", lock_count);\n\tif (!lock_count) {\n\t\terr = -EINVAL;\n\t\tgoto out2;\n\t}\n\n\tfor (i = 0; i < lock_count; i++) {\n\t\tflags = le32_to_cpu(lock_ele[i].Flags);\n\n\t\tflock = smb_flock_init(filp);\n\t\tif (!flock)\n\t\t\tgoto out;\n\n\t\tcmd = smb2_set_flock_flags(flock, flags);\n\n\t\tlock_start = le64_to_cpu(lock_ele[i].Offset);\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_start > U64_MAX - lock_length) {\n\t\t\tpr_err(\"Invalid lock range requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lock_start > OFFSET_MAX)\n\t\t\tflock->fl_start = OFFSET_MAX;\n\t\telse\n\t\t\tflock->fl_start = lock_start;\n\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_length > OFFSET_MAX - flock->fl_start)\n\t\t\tlock_length = OFFSET_MAX - flock->fl_start;\n\n\t\tflock->fl_end = flock->fl_start + lock_length;\n\n\t\tif (flock->fl_end < flock->fl_start) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"the end offset(%llx) is smaller than the start offset(%llx)\\n\",\n\t\t\t\t    flock->fl_end, flock->fl_start);\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check conflict locks in one request */\n\t\tlist_for_each_entry(cmp_lock, &lock_list, llist) {\n\t\t\tif (cmp_lock->fl->fl_start <= flock->fl_start &&\n\t\t\t    cmp_lock->fl->fl_end >= flock->fl_end) {\n\t\t\t\tif (cmp_lock->fl->fl_type != F_UNLCK &&\n\t\t\t\t    flock->fl_type != F_UNLCK) {\n\t\t\t\t\tpr_err(\"conflict two locks in one request\\n\");\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsmb_lock = smb2_lock_init(flock, cmd, flags, &lock_list);\n\t\tif (!smb_lock) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tif (smb_lock->cmd < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_MASK)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((prior_lock & (SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_SHARED) &&\n\t\t     smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) ||\n\t\t    (prior_lock == SMB2_LOCKFLAG_UNLOCK &&\n\t\t     !(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprior_lock = smb_lock->flags;\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) &&\n\t\t    !(smb_lock->flags & SMB2_LOCKFLAG_FAIL_IMMEDIATELY))\n\t\t\tgoto no_check_cl;\n\n\t\tnolock = 1;\n\t\t/* check locks in connection list */\n\t\tread_lock(&conn_list_lock);\n\t\tlist_for_each_entry(conn, &conn_list, conns_list) {\n\t\t\tspin_lock(&conn->llist_lock);\n\t\t\tlist_for_each_entry_safe(cmp_lock, tmp2, &conn->lock_list, clist) {\n\t\t\t\tif (file_inode(cmp_lock->fl->fl_file) !=\n\t\t\t\t    file_inode(smb_lock->fl->fl_file))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (smb_lock->fl->fl_type == F_UNLCK) {\n\t\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file &&\n\t\t\t\t\t    cmp_lock->start == smb_lock->start &&\n\t\t\t\t\t    cmp_lock->end == smb_lock->end &&\n\t\t\t\t\t    !lock_defer_pending(cmp_lock->fl)) {\n\t\t\t\t\t\tnolock = 0;\n\t\t\t\t\t\tlist_del(&cmp_lock->flist);\n\t\t\t\t\t\tlist_del(&cmp_lock->clist);\n\t\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\t\tread_unlock(&conn_list_lock);\n\n\t\t\t\t\t\tlocks_free_lock(cmp_lock->fl);\n\t\t\t\t\t\tkfree(cmp_lock);\n\t\t\t\t\t\tgoto out_check_cl;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file) {\n\t\t\t\t\tif (smb_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tif (cmp_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* check zero byte lock range */\n\t\t\t\tif (cmp_lock->zero_len && !smb_lock->zero_len &&\n\t\t\t\t    cmp_lock->start > smb_lock->start &&\n\t\t\t\t    cmp_lock->start < smb_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"previous lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (smb_lock->zero_len && !cmp_lock->zero_len &&\n\t\t\t\t    smb_lock->start > cmp_lock->start &&\n\t\t\t\t    smb_lock->start < cmp_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"current lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (((cmp_lock->start <= smb_lock->start &&\n\t\t\t\t      cmp_lock->end > smb_lock->start) ||\n\t\t\t\t     (cmp_lock->start < smb_lock->end &&\n\t\t\t\t      cmp_lock->end >= smb_lock->end)) &&\n\t\t\t\t    !cmp_lock->zero_len && !smb_lock->zero_len) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"Not allow lock operation on exclusive lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&conn->llist_lock);\n\t\t}\n\t\tread_unlock(&conn_list_lock);\nout_check_cl:\n\t\tif (smb_lock->fl->fl_type == F_UNLCK && nolock) {\n\t\t\tpr_err(\"Try to unlock nolocked range\\n\");\n\t\t\trsp->hdr.Status = STATUS_RANGE_NOT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\nno_check_cl:\n\t\tif (smb_lock->zero_len) {\n\t\t\terr = 0;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tflock = smb_lock->fl;\n\t\tlist_del(&smb_lock->llist);\nretry:\n\t\trc = vfs_lock_file(filp, smb_lock->cmd, flock, NULL);\nskip:\n\t\tif (flags & SMB2_LOCKFLAG_UNLOCK) {\n\t\t\tif (!rc) {\n\t\t\t\tksmbd_debug(SMB, \"File unlocked\\n\");\n\t\t\t} else if (rc == -ENOENT) {\n\t\t\t\trsp->hdr.Status = STATUS_NOT_LOCKED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlocks_free_lock(flock);\n\t\t\tkfree(smb_lock);\n\t\t} else {\n\t\t\tif (rc == FILE_LOCK_DEFERRED) {\n\t\t\t\tvoid **argv;\n\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"would have to wait for getting lock\\n\");\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\n\t\t\t\targv = kmalloc(sizeof(void *), GFP_KERNEL);\n\t\t\t\tif (!argv) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\targv[0] = flock;\n\n\t\t\t\trc = setup_async_work(work,\n\t\t\t\t\t\t      smb2_remove_blocked_lock,\n\t\t\t\t\t\t      argv);\n\t\t\t\tif (rc) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_add(&work->fp_entry, &fp->blocked_works);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\n\t\t\t\tsmb2_send_interim_resp(work, STATUS_PENDING);\n\n\t\t\t\tksmbd_vfs_posix_lock_wait(flock);\n\n\t\t\t\tif (work->state != KSMBD_WORK_ACTIVE) {\n\t\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\t\tlocks_free_lock(flock);\n\n\t\t\t\t\tif (work->state == KSMBD_WORK_CANCELLED) {\n\t\t\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\t\tSTATUS_CANCELLED;\n\t\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\t\tsmb2_send_interim_resp(work,\n\t\t\t\t\t\t\t\t       STATUS_CANCELLED);\n\t\t\t\t\t\twork->send_no_response = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tinit_smb2_rsp_hdr(work);\n\t\t\t\t\tsmb2_set_err_rsp(work);\n\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\tSTATUS_RANGE_NOT_LOCKED;\n\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\tgoto out2;\n\t\t\t\t}\n\n\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\tgoto retry;\n\t\t\t} else if (!rc) {\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tlist_add_tail(&smb_lock->flist,\n\t\t\t\t\t      &fp->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\t\t\t\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (atomic_read(&fp->f_ci->op_count) > 1)\n\t\tsmb_break_all_oplock(work, fp);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlist_del(&smb_lock->llist);\n\t\tkfree(smb_lock);\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &rollback_list, llist) {\n\t\tstruct file_lock *rlock = NULL;\n\n\t\trlock = smb_flock_init(filp);\n\t\trlock->fl_type = F_UNLCK;\n\t\trlock->fl_start = smb_lock->start;\n\t\trlock->fl_end = smb_lock->end;\n\n\t\trc = vfs_lock_file(filp, 0, rlock, NULL);\n\t\tif (rc)\n\t\t\tpr_err(\"rollback unlock fail : %d\\n\", rc);\n\n\t\tlist_del(&smb_lock->llist);\n\t\tspin_lock(&work->conn->llist_lock);\n\t\tif (!list_empty(&smb_lock->flist))\n\t\t\tlist_del(&smb_lock->flist);\n\t\tlist_del(&smb_lock->clist);\n\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlocks_free_lock(rlock);\n\t\tkfree(smb_lock);\n\t}\nout2:\n\tksmbd_debug(SMB, \"failed in taking lock(flags : %x), err : %d\\n\", flags, err);\n\n\tif (!rsp->hdr.Status) {\n\t\tif (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (err == -ENOMEM)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_LOCK_NOT_GRANTED;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\nstatic int fsctl_copychunk(struct ksmbd_work *work,\n\t\t\t   struct copychunk_ioctl_req *ci_req,\n\t\t\t   unsigned int cnt_code,\n\t\t\t   unsigned int input_count,\n\t\t\t   unsigned long long volatile_id,\n\t\t\t   unsigned long long persistent_id,\n\t\t\t   struct smb2_ioctl_rsp *rsp)\n{\n\tstruct copychunk_ioctl_rsp *ci_rsp;\n\tstruct ksmbd_file *src_fp = NULL, *dst_fp = NULL;\n\tstruct srv_copychunk *chunks;\n\tunsigned int i, chunk_count, chunk_count_written = 0;\n\tunsigned int chunk_size_written = 0;\n\tloff_t total_size_written = 0;\n\tint ret = 0;\n\n\tci_rsp = (struct copychunk_ioctl_rsp *)&rsp->Buffer[0];\n\n\trsp->VolatileFileId = volatile_id;\n\trsp->PersistentFileId = persistent_id;\n\tci_rsp->ChunksWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_count());\n\tci_rsp->ChunkBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_size());\n\tci_rsp->TotalBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_total_size());\n\n\tchunks = (struct srv_copychunk *)&ci_req->Chunks[0];\n\tchunk_count = le32_to_cpu(ci_req->ChunkCount);\n\tif (chunk_count == 0)\n\t\tgoto out;\n\ttotal_size_written = 0;\n\n\t/* verify the SRV_COPYCHUNK_COPY packet */\n\tif (chunk_count > ksmbd_server_side_copy_max_chunk_count() ||\n\t    input_count < offsetof(struct copychunk_ioctl_req, Chunks) +\n\t     chunk_count * sizeof(struct srv_copychunk)) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tif (le32_to_cpu(chunks[i].Length) == 0 ||\n\t\t    le32_to_cpu(chunks[i].Length) > ksmbd_server_side_copy_max_chunk_size())\n\t\t\tbreak;\n\t\ttotal_size_written += le32_to_cpu(chunks[i].Length);\n\t}\n\n\tif (i < chunk_count ||\n\t    total_size_written > ksmbd_server_side_copy_max_total_size()) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tsrc_fp = ksmbd_lookup_foreign_fd(work,\n\t\t\t\t\t le64_to_cpu(ci_req->ResumeKey[0]));\n\tdst_fp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tret = -EINVAL;\n\tif (!src_fp ||\n\t    src_fp->persistent_id != le64_to_cpu(ci_req->ResumeKey[1])) {\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\tgoto out;\n\t}\n\n\tif (!dst_fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FILE_READ_DATA should only be included in\n\t * the FSCTL_COPYCHUNK case\n\t */\n\tif (cnt_code == FSCTL_COPYCHUNK &&\n\t    !(dst_fp->daccess & (FILE_READ_DATA_LE | FILE_GENERIC_READ_LE))) {\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tgoto out;\n\t}\n\n\tret = ksmbd_vfs_copy_file_ranges(work, src_fp, dst_fp,\n\t\t\t\t\t chunks, chunk_count,\n\t\t\t\t\t &chunk_count_written,\n\t\t\t\t\t &chunk_size_written,\n\t\t\t\t\t &total_size_written);\n\tif (ret < 0) {\n\t\tif (ret == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tif (ret == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (ret == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\telse if (ret == -EFBIG || ret == -ENOSPC)\n\t\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\t\telse if (ret == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (ret == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\telse if (ret == -E2BIG)\n\t\t\trsp->hdr.Status = STATUS_INVALID_VIEW_SIZE;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t}\n\n\tci_rsp->ChunksWritten = cpu_to_le32(chunk_count_written);\n\tci_rsp->ChunkBytesWritten = cpu_to_le32(chunk_size_written);\n\tci_rsp->TotalBytesWritten = cpu_to_le32(total_size_written);\nout:\n\tksmbd_fd_put(work, src_fp);\n\tksmbd_fd_put(work, dst_fp);\n\treturn ret;\n}\n\nstatic __be32 idev_ipv4_address(struct in_device *idev)\n{\n\t__be32 addr = 0;\n\n\tstruct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\tin_dev_for_each_ifa_rcu(ifa, idev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\n\t\taddr = ifa->ifa_address;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn addr;\n}\n\nstatic int fsctl_query_iface_info_ioctl(struct ksmbd_conn *conn,\n\t\t\t\t\tstruct smb2_ioctl_rsp *rsp,\n\t\t\t\t\tunsigned int out_buf_len)\n{\n\tstruct network_interface_info_ioctl_rsp *nii_rsp = NULL;\n\tint nbytes = 0;\n\tstruct net_device *netdev;\n\tstruct sockaddr_storage_rsp *sockaddr_storage;\n\tunsigned int flags;\n\tunsigned long long speed;\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, netdev) {\n\t\tbool ipv4_set = false;\n\n\t\tif (netdev->type == ARPHRD_LOOPBACK)\n\t\t\tcontinue;\n\n\t\tflags = dev_get_flags(netdev);\n\t\tif (!(flags & IFF_RUNNING))\n\t\t\tcontinue;\nipv6_retry:\n\t\tif (out_buf_len <\n\t\t    nbytes + sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tnii_rsp = (struct network_interface_info_ioctl_rsp *)\n\t\t\t\t&rsp->Buffer[nbytes];\n\t\tnii_rsp->IfIndex = cpu_to_le32(netdev->ifindex);\n\n\t\tnii_rsp->Capability = 0;\n\t\tif (netdev->real_num_tx_queues > 1)\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RSS_CAPABLE);\n\t\tif (ksmbd_rdma_capable_netdev(netdev))\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RDMA_CAPABLE);\n\n\t\tnii_rsp->Next = cpu_to_le32(152);\n\t\tnii_rsp->Reserved = 0;\n\n\t\tif (netdev->ethtool_ops->get_link_ksettings) {\n\t\t\tstruct ethtool_link_ksettings cmd;\n\n\t\t\tnetdev->ethtool_ops->get_link_ksettings(netdev, &cmd);\n\t\t\tspeed = cmd.base.speed;\n\t\t} else {\n\t\t\tksmbd_debug(SMB, \"%s %s\\n\", netdev->name,\n\t\t\t\t    \"speed is unknown, defaulting to 1Gb/sec\");\n\t\t\tspeed = SPEED_1000;\n\t\t}\n\n\t\tspeed *= 1000000;\n\t\tnii_rsp->LinkSpeed = cpu_to_le64(speed);\n\n\t\tsockaddr_storage = (struct sockaddr_storage_rsp *)\n\t\t\t\t\tnii_rsp->SockAddr_Storage;\n\t\tmemset(sockaddr_storage, 0, 128);\n\n\t\tif (!ipv4_set) {\n\t\t\tstruct in_device *idev;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORK);\n\t\t\tsockaddr_storage->addr4.Port = 0;\n\n\t\t\tidev = __in_dev_get_rtnl(netdev);\n\t\t\tif (!idev)\n\t\t\t\tcontinue;\n\t\t\tsockaddr_storage->addr4.IPv4address =\n\t\t\t\t\t\tidev_ipv4_address(idev);\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t\tipv4_set = true;\n\t\t\tgoto ipv6_retry;\n\t\t} else {\n\t\t\tstruct inet6_dev *idev6;\n\t\t\tstruct inet6_ifaddr *ifa;\n\t\t\t__u8 *ipv6_addr = sockaddr_storage->addr6.IPv6address;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORKV6);\n\t\t\tsockaddr_storage->addr6.Port = 0;\n\t\t\tsockaddr_storage->addr6.FlowInfo = 0;\n\n\t\t\tidev6 = __in6_dev_get(netdev);\n\t\t\tif (!idev6)\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry(ifa, &idev6->addr_list, if_list) {\n\t\t\t\tif (ifa->flags & (IFA_F_TENTATIVE |\n\t\t\t\t\t\t\tIFA_F_DEPRECATED))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(ipv6_addr, ifa->addr.s6_addr, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsockaddr_storage->addr6.ScopeId = 0;\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t}\n\t}\n\trtnl_unlock();\n\n\t/* zero if this is last one */\n\tif (nii_rsp)\n\t\tnii_rsp->Next = 0;\n\n\trsp->PersistentFileId = SMB2_NO_FID;\n\trsp->VolatileFileId = SMB2_NO_FID;\n\treturn nbytes;\n}\n\nstatic int fsctl_validate_negotiate_info(struct ksmbd_conn *conn,\n\t\t\t\t\t struct validate_negotiate_info_req *neg_req,\n\t\t\t\t\t struct validate_negotiate_info_rsp *neg_rsp,\n\t\t\t\t\t unsigned int in_buf_len)\n{\n\tint ret = 0;\n\tint dialect;\n\n\tif (in_buf_len < offsetof(struct validate_negotiate_info_req, Dialects) +\n\t\t\tle16_to_cpu(neg_req->DialectCount) * sizeof(__le16))\n\t\treturn -EINVAL;\n\n\tdialect = ksmbd_lookup_dialect_by_id(neg_req->Dialects,\n\t\t\t\t\t     neg_req->DialectCount);\n\tif (dialect == BAD_PROT_ID || dialect != conn->dialect) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (strncmp(neg_req->Guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le16_to_cpu(neg_req->SecurityMode) != conn->cli_sec_mode) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le32_to_cpu(neg_req->Capabilities) != conn->cli_cap) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tneg_rsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\tmemset(neg_rsp->Guid, 0, SMB2_CLIENT_GUID_SIZE);\n\tneg_rsp->SecurityMode = cpu_to_le16(conn->srv_sec_mode);\n\tneg_rsp->Dialect = cpu_to_le16(conn->dialect);\nerr_out:\n\treturn ret;\n}\n\nstatic int fsctl_query_allocated_ranges(struct ksmbd_work *work, u64 id,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_req,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_rsp,\n\t\t\t\t\tunsigned int in_count, unsigned int *out_count)\n{\n\tstruct ksmbd_file *fp;\n\tloff_t start, length;\n\tint ret = 0;\n\n\t*out_count = 0;\n\tif (in_count == 0)\n\t\treturn -EINVAL;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tstart = le64_to_cpu(qar_req->file_offset);\n\tlength = le64_to_cpu(qar_req->length);\n\n\tret = ksmbd_vfs_fqar_lseek(fp, start, length,\n\t\t\t\t   qar_rsp, in_count, out_count);\n\tif (ret && ret != -E2BIG)\n\t\t*out_count = 0;\n\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_pipe_transceive(struct ksmbd_work *work, u64 id,\n\t\t\t\t unsigned int out_buf_len,\n\t\t\t\t struct smb2_ioctl_req *req,\n\t\t\t\t struct smb2_ioctl_rsp *rsp)\n{\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tchar *data_buf = (char *)&req->Buffer[0];\n\tint nbytes = 0;\n\n\trpc_resp = ksmbd_rpc_ioctl(work->sess, id, data_buf,\n\t\t\t\t   le32_to_cpu(req->InputCount));\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_SOME_NOT_MAPPED) {\n\t\t\t/*\n\t\t\t * set STATUS_SOME_NOT_MAPPED response\n\t\t\t * for unknown domain sid.\n\t\t\t */\n\t\t\trsp->hdr.Status = STATUS_SOME_NOT_MAPPED;\n\t\t} else if (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t} else if (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\tif (rpc_resp->payload_sz > out_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\tnbytes = out_buf_len;\n\t\t}\n\n\t\tif (!rpc_resp->payload_sz) {\n\t\t\trsp->hdr.Status =\n\t\t\t\tSTATUS_UNEXPECTED_IO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy((char *)rsp->Buffer, rpc_resp->payload, nbytes);\n\t}\nout:\n\tkvfree(rpc_resp);\n\treturn nbytes;\n}\n\nstatic inline int fsctl_set_sparse(struct ksmbd_work *work, u64 id,\n\t\t\t\t   struct file_sparse *sparse)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tint ret = 0;\n\t__le32 old_fattr;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\n\told_fattr = fp->f_ci->m_fattr;\n\tif (sparse->SetSparse)\n\t\tfp->f_ci->m_fattr |= FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\telse\n\t\tfp->f_ci->m_fattr &= ~FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\n\tif (fp->f_ci->m_fattr != old_fattr &&\n\t    test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {\n\t\tstruct xattr_dos_attrib da;\n\n\t\tret = ksmbd_vfs_get_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tret = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret)\n\t\t\tfp->f_ci->m_fattr = old_fattr;\n\t}\n\nout:\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_request_resume_key(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_ioctl_req *req,\n\t\t\t\t    struct resume_key_ioctl_rsp *key_rsp)\n{\n\tstruct ksmbd_file *fp;\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tmemset(key_rsp, 0, sizeof(*key_rsp));\n\tkey_rsp->ResumeKey[0] = req->VolatileFileId;\n\tkey_rsp->ResumeKey[1] = req->PersistentFileId;\n\tksmbd_fd_put(work, fp);\n\n\treturn 0;\n}\n\n/**\n * smb2_ioctl() - handler for smb2 ioctl command\n * @work:\tsmb work containing ioctl command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_ioctl(struct ksmbd_work *work)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tunsigned int cnt_code, nbytes = 0, out_buf_len, in_buf_len;\n\tu64 id = KSMBD_NO_FID;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint ret = 0;\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id))\n\t\tid = req->VolatileFileId;\n\n\tif (req->Flags != cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL)) {\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tcnt_code = le32_to_cpu(req->CtlCode);\n\tret = smb2_calc_max_out_buf_len(work, 48,\n\t\t\t\t\tle32_to_cpu(req->MaxOutputResponse));\n\tif (ret < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tgoto out;\n\t}\n\tout_buf_len = (unsigned int)ret;\n\tin_buf_len = le32_to_cpu(req->InputCount);\n\n\tswitch (cnt_code) {\n\tcase FSCTL_DFS_GET_REFERRALS:\n\tcase FSCTL_DFS_GET_REFERRALS_EX:\n\t\t/* Not support DFS yet */\n\t\trsp->hdr.Status = STATUS_FS_DRIVER_REQUIRED;\n\t\tgoto out;\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tstruct file_object_buf_type1_ioctl_rsp *obj_buf;\n\n\t\tnbytes = sizeof(struct file_object_buf_type1_ioctl_rsp);\n\t\tobj_buf = (struct file_object_buf_type1_ioctl_rsp *)\n\t\t\t&rsp->Buffer[0];\n\n\t\t/*\n\t\t * TODO: This is dummy implementation to pass smbtorture\n\t\t * Need to check correct response later\n\t\t */\n\t\tmemset(obj_buf->ObjectId, 0x0, 16);\n\t\tmemset(obj_buf->BirthVolumeId, 0x0, 16);\n\t\tmemset(obj_buf->BirthObjectId, 0x0, 16);\n\t\tmemset(obj_buf->DomainId, 0x0, 16);\n\n\t\tbreak;\n\t}\n\tcase FSCTL_PIPE_TRANSCEIVE:\n\t\tout_buf_len = min_t(u32, KSMBD_IPC_MAX_PAYLOAD, out_buf_len);\n\t\tnbytes = fsctl_pipe_transceive(work, id, out_buf_len, req, rsp);\n\t\tbreak;\n\tcase FSCTL_VALIDATE_NEGOTIATE_INFO:\n\t\tif (conn->dialect < SMB30_PROT_ID) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct validate_negotiate_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tif (out_buf_len < sizeof(struct validate_negotiate_info_rsp))\n\t\t\treturn -EINVAL;\n\n\t\tret = fsctl_validate_negotiate_info(conn,\n\t\t\t(struct validate_negotiate_info_req *)&req->Buffer[0],\n\t\t\t(struct validate_negotiate_info_rsp *)&rsp->Buffer[0],\n\t\t\tin_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tnbytes = sizeof(struct validate_negotiate_info_rsp);\n\t\trsp->PersistentFileId = SMB2_NO_FID;\n\t\trsp->VolatileFileId = SMB2_NO_FID;\n\t\tbreak;\n\tcase FSCTL_QUERY_NETWORK_INTERFACE_INFO:\n\t\tret = fsctl_query_iface_info_ioctl(conn, rsp, out_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnbytes = ret;\n\t\tbreak;\n\tcase FSCTL_REQUEST_RESUME_KEY:\n\t\tif (out_buf_len < sizeof(struct resume_key_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_request_resume_key(work, req,\n\t\t\t\t\t       (struct resume_key_ioctl_rsp *)&rsp->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\tnbytes = sizeof(struct resume_key_ioctl_rsp);\n\t\tbreak;\n\tcase FSCTL_COPYCHUNK:\n\tcase FSCTL_COPYCHUNK_WRITE:\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct copychunk_ioctl_req)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (out_buf_len < sizeof(struct copychunk_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = sizeof(struct copychunk_ioctl_rsp);\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\tfsctl_copychunk(work,\n\t\t\t\t(struct copychunk_ioctl_req *)&req->Buffer[0],\n\t\t\t\tle32_to_cpu(req->CtlCode),\n\t\t\t\tle32_to_cpu(req->InputCount),\n\t\t\t\treq->VolatileFileId,\n\t\t\t\treq->PersistentFileId,\n\t\t\t\trsp);\n\t\tbreak;\n\tcase FSCTL_SET_SPARSE:\n\t\tif (in_buf_len < sizeof(struct file_sparse)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_set_sparse(work, id,\n\t\t\t\t       (struct file_sparse *)&req->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase FSCTL_SET_ZERO_DATA:\n\t{\n\t\tstruct file_zero_data_information *zero_data;\n\t\tstruct ksmbd_file *fp;\n\t\tloff_t off, len;\n\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct file_zero_data_information)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tzero_data =\n\t\t\t(struct file_zero_data_information *)&req->Buffer[0];\n\n\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\toff = le64_to_cpu(zero_data->FileOffset);\n\t\tlen = le64_to_cpu(zero_data->BeyondFinalZero) - off;\n\n\t\tret = ksmbd_vfs_zero_data(work, fp, off, len);\n\t\tksmbd_fd_put(work, fp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t\tif (in_buf_len < sizeof(struct file_allocated_range_buffer)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_query_allocated_ranges(work, id,\n\t\t\t(struct file_allocated_range_buffer *)&req->Buffer[0],\n\t\t\t(struct file_allocated_range_buffer *)&rsp->Buffer[0],\n\t\t\tout_buf_len /\n\t\t\tsizeof(struct file_allocated_range_buffer), &nbytes);\n\t\tif (ret == -E2BIG) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t} else if (ret < 0) {\n\t\t\tnbytes = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes *= sizeof(struct file_allocated_range_buffer);\n\t\tbreak;\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tstruct reparse_data_buffer *reparse_ptr;\n\t\tstruct ksmbd_file *fp;\n\n\t\treparse_ptr = (struct reparse_data_buffer *)&rsp->Buffer[0];\n\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp) {\n\t\t\tpr_err(\"not found fp!!\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\treparse_ptr->ReparseTag =\n\t\t\tsmb2_get_reparse_tag_special_file(file_inode(fp->filp)->i_mode);\n\t\treparse_ptr->ReparseDataLength = 0;\n\t\tksmbd_fd_put(work, fp);\n\t\tnbytes = sizeof(struct reparse_data_buffer);\n\t\tbreak;\n\t}\n\tcase FSCTL_DUPLICATE_EXTENTS_TO_FILE:\n\t{\n\t\tstruct ksmbd_file *fp_in, *fp_out = NULL;\n\t\tstruct duplicate_extents_to_file *dup_ext;\n\t\tloff_t src_off, dst_off, length, cloned;\n\n\t\tif (in_buf_len < sizeof(struct duplicate_extents_to_file)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdup_ext = (struct duplicate_extents_to_file *)&req->Buffer[0];\n\n\t\tfp_in = ksmbd_lookup_fd_slow(work, dup_ext->VolatileFileHandle,\n\t\t\t\t\t     dup_ext->PersistentFileHandle);\n\t\tif (!fp_in) {\n\t\t\tpr_err(\"not found file handle in duplicate extent to file\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfp_out = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp_out) {\n\t\t\tpr_err(\"not found fp\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto dup_ext_out;\n\t\t}\n\n\t\tsrc_off = le64_to_cpu(dup_ext->SourceFileOffset);\n\t\tdst_off = le64_to_cpu(dup_ext->TargetFileOffset);\n\t\tlength = le64_to_cpu(dup_ext->ByteCount);\n\t\tcloned = vfs_clone_file_range(fp_in->filp, src_off, fp_out->filp,\n\t\t\t\t\t      dst_off, length, 0);\n\t\tif (cloned == -EXDEV || cloned == -EOPNOTSUPP) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto dup_ext_out;\n\t\t} else if (cloned != length) {\n\t\t\tcloned = vfs_copy_file_range(fp_in->filp, src_off,\n\t\t\t\t\t\t     fp_out->filp, dst_off, length, 0);\n\t\t\tif (cloned != length) {\n\t\t\t\tif (cloned < 0)\n\t\t\t\t\tret = cloned;\n\t\t\t\telse\n\t\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\ndup_ext_out:\n\t\tksmbd_fd_put(work, fp_in);\n\t\tksmbd_fd_put(work, fp_out);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tksmbd_debug(SMB, \"not implemented yet ioctl command 0x%x\\n\",\n\t\t\t    cnt_code);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trsp->CtlCode = cpu_to_le32(cnt_code);\n\trsp->InputCount = cpu_to_le32(0);\n\trsp->InputOffset = cpu_to_le32(112);\n\trsp->OutputOffset = cpu_to_le32(112);\n\trsp->OutputCount = cpu_to_le32(nbytes);\n\trsp->StructureSize = cpu_to_le16(49);\n\trsp->Reserved = cpu_to_le16(0);\n\trsp->Flags = cpu_to_le32(0);\n\trsp->Reserved2 = cpu_to_le32(0);\n\tinc_rfc1001_len(work->response_buf, 48 + nbytes);\n\n\treturn 0;\n\nout:\n\tif (ret == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (ret == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\telse if (ret == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\telse if (ret == -ENOSPC)\n\t\trsp->hdr.Status = STATUS_BUFFER_TOO_SMALL;\n\telse if (ret < 0 || rsp->hdr.Status == 0)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\tsmb2_set_err_rsp(work);\n\treturn 0;\n}\n\n/**\n * smb20_oplock_break_ack() - handler for smb2.0 oplock break command\n * @work:\tsmb work containing oplock break command buffer\n *\n * Return:\t0\n */\nstatic void smb20_oplock_break_ack(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_file *fp;\n\tstruct oplock_info *opinfo = NULL;\n\t__le32 err = 0;\n\tint ret = 0;\n\tu64 volatile_id, persistent_id;\n\tchar req_oplevel = 0, rsp_oplevel = 0;\n\tunsigned int oplock_change_type;\n\n\tvolatile_id = req->VolatileFid;\n\tpersistent_id = req->PersistentFid;\n\treq_oplevel = req->OplockLevel;\n\tksmbd_debug(OPLOCK, \"v_id %llu, p_id %llu request oplock level %d\\n\",\n\t\t    volatile_id, persistent_id, req_oplevel);\n\n\tfp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tif (!fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn;\n\t}\n\n\topinfo = opinfo_get(fp);\n\tif (!opinfo) {\n\t\tpr_err(\"unexpected null oplock_info\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn;\n\t}\n\n\tif (opinfo->level == SMB2_OPLOCK_LEVEL_NONE) {\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tgoto err_out;\n\t}\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tksmbd_debug(SMB, \"unexpected oplock state 0x%x\\n\", opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t    (req_oplevel != SMB2_OPLOCK_LEVEL_II &&\n\t     req_oplevel != SMB2_OPLOCK_LEVEL_NONE)) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t   req_oplevel != SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t} else if (req_oplevel == SMB2_OPLOCK_LEVEL_II ||\n\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t    req_oplevel == SMB2_OPLOCK_LEVEL_II) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_READ;\n\t\t} else if ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t\t    opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else {\n\t\t\toplock_change_type = 0;\n\t\t}\n\t} else {\n\t\toplock_change_type = 0;\n\t}\n\n\tswitch (oplock_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_II;\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown oplock change 0x%x -> 0x%x\\n\",\n\t\t       opinfo->level, rsp_oplevel);\n\t}\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\trsp->StructureSize = cpu_to_le16(24);\n\trsp->OplockLevel = rsp_oplevel;\n\trsp->Reserved = 0;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFid = volatile_id;\n\trsp->PersistentFid = persistent_id;\n\tinc_rfc1001_len(work->response_buf, 24);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\tsmb2_set_err_rsp(work);\n}\n\nstatic int check_lease_state(struct lease *lease, __le32 req_state)\n{\n\tif ((lease->new_state ==\n\t     (SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE)) &&\n\t    !(req_state & SMB2_LEASE_WRITE_CACHING_LE)) {\n\t\tlease->new_state = req_state;\n\t\treturn 0;\n\t}\n\n\tif (lease->new_state == req_state)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * smb21_lease_break_ack() - handler for smb2.1 lease break command\n * @work:\tsmb work containing lease break command buffer\n *\n * Return:\t0\n */\nstatic void smb21_lease_break_ack(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_lease_ack *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lease_ack *rsp = smb2_get_msg(work->response_buf);\n\tstruct oplock_info *opinfo;\n\t__le32 err = 0;\n\tint ret = 0;\n\tunsigned int lease_change_type;\n\t__le32 lease_state;\n\tstruct lease *lease;\n\n\tksmbd_debug(OPLOCK, \"smb21 lease break, lease state(0x%x)\\n\",\n\t\t    le32_to_cpu(req->LeaseState));\n\topinfo = lookup_lease_in_table(conn, req->LeaseKey);\n\tif (!opinfo) {\n\t\tksmbd_debug(OPLOCK, \"file not opened\\n\");\n\t\tsmb2_set_err_rsp(work);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\treturn;\n\t}\n\tlease = opinfo->o_lease;\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tpr_err(\"unexpected lease break state 0x%x\\n\",\n\t\t       opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif (check_lease_state(lease, req->LeaseState)) {\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\t\tksmbd_debug(OPLOCK,\n\t\t\t    \"req lease state: 0x%x, expected state: 0x%x\\n\",\n\t\t\t    req->LeaseState, lease->new_state);\n\t\tgoto err_out;\n\t}\n\n\tif (!atomic_read(&opinfo->breaking_cnt)) {\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\t/* check for bad lease state */\n\tif (req->LeaseState &\n\t    (~(SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE))) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\telse\n\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else if (lease->state == SMB2_LEASE_READ_CACHING_LE &&\n\t\t   req->LeaseState != SMB2_LEASE_NONE_LE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else {\n\t\t/* valid lease state changes */\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif (req->LeaseState == SMB2_LEASE_NONE_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else if (req->LeaseState & SMB2_LEASE_READ_CACHING_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_READ;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_HANDLE_TO_READ;\n\t\t} else {\n\t\t\tlease_change_type = 0;\n\t\t}\n\t}\n\n\tswitch (lease_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_HANDLE_TO_READ:\n\t\tret = opinfo_read_handle_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"unknown lease change 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t}\n\n\tlease_state = lease->state;\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\topinfo_put(opinfo);\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\trsp->StructureSize = cpu_to_le16(36);\n\trsp->Reserved = 0;\n\trsp->Flags = 0;\n\tmemcpy(rsp->LeaseKey, req->LeaseKey, 16);\n\trsp->LeaseState = lease_state;\n\trsp->LeaseDuration = 0;\n\tinc_rfc1001_len(work->response_buf, 36);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\n\topinfo_put(opinfo);\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * smb2_oplock_break() - dispatcher for smb2.0 and 2.1 oplock/lease break\n * @work:\tsmb work containing oplock/lease break command buffer\n *\n * Return:\t0\n */\nint smb2_oplock_break(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\n\tswitch (le16_to_cpu(req->StructureSize)) {\n\tcase OP_BREAK_STRUCT_SIZE_20:\n\t\tsmb20_oplock_break_ack(work);\n\t\tbreak;\n\tcase OP_BREAK_STRUCT_SIZE_21:\n\t\tsmb21_lease_break_ack(work);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"invalid break cmd %d\\n\",\n\t\t\t    le16_to_cpu(req->StructureSize));\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_notify() - handler for smb2 notify request\n * @work:   smb work containing notify command buffer\n *\n * Return:      0\n */\nint smb2_notify(struct ksmbd_work *work)\n{\n\tstruct smb2_change_notify_req *req;\n\tstruct smb2_change_notify_rsp *rsp;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (work->next_smb2_rcv_hdr_off && req->hdr.NextCommand) {\n\t\trsp->hdr.Status = STATUS_INTERNAL_ERROR;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\trsp->hdr.Status = STATUS_NOT_IMPLEMENTED;\n\treturn 0;\n}\n\n/**\n * smb2_is_sign_req() - handler for checking packet signing status\n * @work:\tsmb work containing notify command buffer\n * @command:\tSMB2 command id\n *\n * Return:\ttrue if packed is signed, false otherwise\n */\nbool smb2_is_sign_req(struct ksmbd_work *work, unsigned int command)\n{\n\tstruct smb2_hdr *rcv_hdr2 = smb2_get_msg(work->request_buf);\n\n\tif ((rcv_hdr2->Flags & SMB2_FLAGS_SIGNED) &&\n\t    command != SMB2_NEGOTIATE_HE &&\n\t    command != SMB2_SESSION_SETUP_HE &&\n\t    command != SMB2_OPLOCK_BREAK_HE)\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * smb2_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb2_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, 1,\n\t\t\t\tsignature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb2_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tstruct smb2_hdr *req_hdr;\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[2];\n\tsize_t len;\n\tint n_vec = 1;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, n_vec,\n\t\t\t\t signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb3_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tchar *signing_key;\n\tstruct smb2_hdr *hdr;\n\tstruct channel *chann;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tif (le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tchann = lookup_chann_list(work->sess, conn);\n\t\tif (!chann)\n\t\t\treturn 0;\n\t\tsigning_key = chann->smb3signingkey;\n\t}\n\n\tif (!signing_key) {\n\t\tpr_err(\"SMB3 signing key is not generated\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb3_pdu(conn, signing_key, iov, 1, signature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb3_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb3_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *req_hdr, *hdr;\n\tstruct channel *chann;\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[2];\n\tint n_vec = 1;\n\tsize_t len;\n\tchar *signing_key;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (conn->binding == false &&\n\t    le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tchann = lookup_chann_list(work->sess, work->conn);\n\t\tif (!chann)\n\t\t\treturn;\n\t\tsigning_key = chann->smb3signingkey;\n\t}\n\n\tif (!signing_key)\n\t\treturn;\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb3_pdu(conn, signing_key, iov, n_vec, signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_preauth_hash_rsp() - handler for computing preauth hash on response\n * @work:   smb work containing response buffer\n *\n */\nvoid smb3_preauth_hash_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct smb2_hdr *req, *rsp;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (le16_to_cpu(req->Command) == SMB2_NEGOTIATE_HE &&\n\t    conn->preauth_info)\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE && sess) {\n\t\t__u8 *hash_value;\n\n\t\tif (conn->binding) {\n\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn;\n\t\t\thash_value = preauth_sess->Preauth_HashValue;\n\t\t} else {\n\t\t\thash_value = sess->Preauth_HashValue;\n\t\t\tif (!hash_value)\n\t\t\t\treturn;\n\t\t}\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t hash_value);\n\t}\n}\n\nstatic void fill_transform_hdr(void *tr_buf, char *old_buf, __le16 cipher_type)\n{\n\tstruct smb2_transform_hdr *tr_hdr = tr_buf + 4;\n\tstruct smb2_hdr *hdr = smb2_get_msg(old_buf);\n\tunsigned int orig_len = get_rfc1002_len(old_buf);\n\n\t/* tr_buf must be cleared by the caller */\n\ttr_hdr->ProtocolId = SMB2_TRANSFORM_PROTO_NUM;\n\ttr_hdr->OriginalMessageSize = cpu_to_le32(orig_len);\n\ttr_hdr->Flags = cpu_to_le16(TRANSFORM_FLAG_ENCRYPTED);\n\tif (cipher_type == SMB2_ENCRYPTION_AES128_GCM ||\n\t    cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_GCM_NONCE);\n\telse\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_CCM_NONCE);\n\tmemcpy(&tr_hdr->SessionId, &hdr->SessionId, 8);\n\tinc_rfc1001_len(tr_buf, sizeof(struct smb2_transform_hdr));\n\tinc_rfc1001_len(tr_buf, orig_len);\n}\n\nint smb3_encrypt_resp(struct ksmbd_work *work)\n{\n\tchar *buf = work->response_buf;\n\tstruct kvec iov[3];\n\tint rc = -ENOMEM;\n\tint buf_size = 0, rq_nvec = 2 + (work->aux_payload_sz ? 1 : 0);\n\n\tif (ARRAY_SIZE(iov) < rq_nvec)\n\t\treturn -ENOMEM;\n\n\twork->tr_buf = kzalloc(sizeof(struct smb2_transform_hdr) + 4, GFP_KERNEL);\n\tif (!work->tr_buf)\n\t\treturn rc;\n\n\t/* fill transform header */\n\tfill_transform_hdr(work->tr_buf, buf, work->conn->cipher_type);\n\n\tiov[0].iov_base = work->tr_buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tbuf_size += iov[0].iov_len - 4;\n\n\tiov[1].iov_base = buf + 4;\n\tiov[1].iov_len = get_rfc1002_len(buf);\n\tif (work->aux_payload_sz) {\n\t\tiov[1].iov_len = work->resp_hdr_sz - 4;\n\n\t\tiov[2].iov_base = work->aux_payload_buf;\n\t\tiov[2].iov_len = work->aux_payload_sz;\n\t\tbuf_size += iov[2].iov_len;\n\t}\n\tbuf_size += iov[1].iov_len;\n\twork->resp_hdr_sz = iov[1].iov_len;\n\n\trc = ksmbd_crypt_message(work->conn, iov, rq_nvec, 1);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf, iov[1].iov_base, iov[1].iov_len);\n\t*(__be32 *)work->tr_buf = cpu_to_be32(buf_size);\n\n\treturn rc;\n}\n\nbool smb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = smb2_get_msg(buf);\n\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}\n\nint smb3_decrypt_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess;\n\tchar *buf = work->request_buf;\n\tunsigned int pdu_length = get_rfc1002_len(buf);\n\tstruct kvec iov[2];\n\tint buf_data_size = pdu_length - sizeof(struct smb2_transform_hdr);\n\tstruct smb2_transform_hdr *tr_hdr = smb2_get_msg(buf);\n\tint rc = 0;\n\n\tif (buf_data_size < sizeof(struct smb2_hdr)) {\n\t\tpr_err(\"Transform message is too small (%u)\\n\",\n\t\t       pdu_length);\n\t\treturn -ECONNABORTED;\n\t}\n\n\tif (buf_data_size < le32_to_cpu(tr_hdr->OriginalMessageSize)) {\n\t\tpr_err(\"Transform message is broken\\n\");\n\t\treturn -ECONNABORTED;\n\t}\n\n\tsess = ksmbd_session_lookup_all(conn, le64_to_cpu(tr_hdr->SessionId));\n\tif (!sess) {\n\t\tpr_err(\"invalid session id(%llx) in transform header\\n\",\n\t\t       le64_to_cpu(tr_hdr->SessionId));\n\t\treturn -ECONNABORTED;\n\t}\n\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_base = buf + sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_len = buf_data_size;\n\trc = ksmbd_crypt_message(conn, iov, 2, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf + 4, iov[1].iov_base, buf_data_size);\n\t*(__be32 *)buf = cpu_to_be32(buf_data_size);\n\n\treturn rc;\n}\n\nbool smb3_11_final_sess_setup_resp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *rsp = smb2_get_msg(work->response_buf);\n\n\tif (conn->dialect < SMB30_PROT_ID)\n\t\treturn false;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp = ksmbd_resp_buf_next(work);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE &&\n\t    rsp->Status == STATUS_SUCCESS)\n\t\treturn true;\n\treturn false;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n#include <linux/syscalls.h>\n#include <linux/namei.h>\n#include <linux/statfs.h>\n#include <linux/ethtool.h>\n#include <linux/falloc.h>\n#include <linux/mount.h>\n\n#include \"glob.h\"\n#include \"smbfsctl.h\"\n#include \"oplock.h\"\n#include \"smbacl.h\"\n\n#include \"auth.h\"\n#include \"asn1.h\"\n#include \"connection.h\"\n#include \"transport_ipc.h\"\n#include \"transport_rdma.h\"\n#include \"vfs.h\"\n#include \"vfs_cache.h\"\n#include \"misc.h\"\n\n#include \"server.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"ksmbd_work.h\"\n#include \"mgmt/user_config.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/ksmbd_ida.h\"\n#include \"ndr.h\"\n\nstatic void __wbuf(struct ksmbd_work *work, void **req, void **rsp)\n{\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\t*req = ksmbd_req_buf_next(work);\n\t\t*rsp = ksmbd_resp_buf_next(work);\n\t} else {\n\t\t*req = smb2_get_msg(work->request_buf);\n\t\t*rsp = smb2_get_msg(work->response_buf);\n\t}\n}\n\n#define WORK_BUFFERS(w, rq, rs)\t__wbuf((w), (void **)&(rq), (void **)&(rs))\n\n/**\n * check_session_id() - check for valid session id in smb header\n * @conn:\tconnection instance\n * @id:\t\tsession id from smb header\n *\n * Return:      1 if valid session id, otherwise 0\n */\nstatic inline bool check_session_id(struct ksmbd_conn *conn, u64 id)\n{\n\tstruct ksmbd_session *sess;\n\n\tif (id == 0 || id == -1)\n\t\treturn false;\n\n\tsess = ksmbd_session_lookup_all(conn, id);\n\tif (sess)\n\t\treturn true;\n\tpr_err(\"Invalid user session id: %llu\\n\", id);\n\treturn false;\n}\n\nstruct channel *lookup_chann_list(struct ksmbd_session *sess, struct ksmbd_conn *conn)\n{\n\tstruct channel *chann;\n\n\tlist_for_each_entry(chann, &sess->ksmbd_chann_list, chann_list) {\n\t\tif (chann->conn == conn)\n\t\t\treturn chann;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * smb2_get_ksmbd_tcon() - get tree connection information using a tree id.\n * @work:\tsmb work\n *\n * Return:\t0 if there is a tree connection matched or these are\n *\t\tskipable commands, otherwise error\n */\nint smb2_get_ksmbd_tcon(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tunsigned int cmd = le16_to_cpu(req_hdr->Command);\n\tint tree_id;\n\n\twork->tcon = NULL;\n\tif (cmd == SMB2_TREE_CONNECT_HE ||\n\t    cmd ==  SMB2_CANCEL_HE ||\n\t    cmd ==  SMB2_LOGOFF_HE) {\n\t\tksmbd_debug(SMB, \"skip to check tree connect request\\n\");\n\t\treturn 0;\n\t}\n\n\tif (xa_empty(&work->sess->tree_conns)) {\n\t\tksmbd_debug(SMB, \"NO tree connected\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\ttree_id = le32_to_cpu(req_hdr->Id.SyncId.TreeId);\n\twork->tcon = ksmbd_tree_conn_lookup(work->sess, tree_id);\n\tif (!work->tcon) {\n\t\tpr_err(\"Invalid tid %d\\n\", tree_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_err_rsp() - set error response code on smb response\n * @work:\tsmb work containing response buffer\n */\nvoid smb2_set_err_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_err_rsp *err_rsp;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\terr_rsp = ksmbd_resp_buf_next(work);\n\telse\n\t\terr_rsp = smb2_get_msg(work->response_buf);\n\n\tif (err_rsp->hdr.Status != STATUS_STOPPED_ON_SYMLINK) {\n\t\terr_rsp->StructureSize = SMB2_ERROR_STRUCTURE_SIZE2_LE;\n\t\terr_rsp->ErrorContextCount = 0;\n\t\terr_rsp->Reserved = 0;\n\t\terr_rsp->ByteCount = 0;\n\t\terr_rsp->ErrorData[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, SMB2_ERROR_STRUCTURE_SIZE2);\n\t}\n}\n\n/**\n * is_smb2_neg_cmd() - is it smb2 negotiation command\n * @work:\tsmb work containing smb header\n *\n * Return:      true if smb2 negotiation command, otherwise false\n */\nbool is_smb2_neg_cmd(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is request not response message */\n\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\treturn false;\n\n\tif (hdr->Command != SMB2_NEGOTIATE)\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * is_smb2_rsp() - is it smb2 response\n * @work:\tsmb work containing smb response buffer\n *\n * Return:      true if smb2 response, otherwise false\n */\nbool is_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->response_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is response not request message */\n\tif (!(hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * get_smb2_cmd_val() - get smb command code from smb header\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      smb2 request command value\n */\nu16 get_smb2_cmd_val(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rcv_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trcv_hdr = ksmbd_req_buf_next(work);\n\telse\n\t\trcv_hdr = smb2_get_msg(work->request_buf);\n\treturn le16_to_cpu(rcv_hdr->Command);\n}\n\n/**\n * set_smb2_rsp_status() - set error response code on smb2 header\n * @work:\tsmb work containing response buffer\n * @err:\terror response code\n */\nvoid set_smb2_rsp_status(struct ksmbd_work *work, __le32 err)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp_hdr = ksmbd_resp_buf_next(work);\n\telse\n\t\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Status = err;\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * init_smb2_neg_rsp() - initialize smb2 response for negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * smb2 negotiate response is sent in reply of smb1 negotiate command for\n * dialect auto-negotiation.\n */\nint init_smb2_neg_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tif (conn->need_neg == false)\n\t\treturn -EINVAL;\n\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(2);\n\trsp_hdr->Command = SMB2_NEGOTIATE;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = 0;\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\n\tWARN_ON(ksmbd_conn_good(work));\n\n\trsp->StructureSize = cpu_to_le16(65);\n\tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying connection\n\t */\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\t/* Default Max Message Size till SMB2.0, 64K*/\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\tAUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tif (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\tconn->use_spnego = true;\n\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * smb2_set_rsp_credits() - set number of credits in response buffer\n * @work:\tsmb work containing smb response buffer\n */\nint smb2_set_rsp_credits(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *hdr = ksmbd_resp_buf_next(work);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned short credits_requested, aux_max;\n\tunsigned short credit_charge, credits_granted = 0;\n\n\tif (work->send_no_response)\n\t\treturn 0;\n\n\thdr->CreditCharge = req_hdr->CreditCharge;\n\n\tif (conn->total_credits > conn->vals->max_credits) {\n\t\thdr->CreditRequest = 0;\n\t\tpr_err(\"Total credits overflow: %d\\n\", conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tcredit_charge = max_t(unsigned short,\n\t\t\t      le16_to_cpu(req_hdr->CreditCharge), 1);\n\tif (credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Insufficient credits granted, given: %u, granted: %u\\n\",\n\t\t\t    credit_charge, conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tconn->total_credits -= credit_charge;\n\tconn->outstanding_credits -= credit_charge;\n\tcredits_requested = max_t(unsigned short,\n\t\t\t\t  le16_to_cpu(req_hdr->CreditRequest), 1);\n\n\t/* according to smb2.credits smbtorture, Windows server\n\t * 2016 or later grant up to 8192 credits at once.\n\t *\n\t * TODO: Need to adjuct CreditRequest value according to\n\t * current cpu load\n\t */\n\tif (hdr->Command == SMB2_NEGOTIATE)\n\t\taux_max = 1;\n\telse\n\t\taux_max = conn->vals->max_credits - credit_charge;\n\tcredits_granted = min_t(unsigned short, credits_requested, aux_max);\n\n\tif (conn->vals->max_credits - conn->total_credits < credits_granted)\n\t\tcredits_granted = conn->vals->max_credits -\n\t\t\tconn->total_credits;\n\n\tconn->total_credits += credits_granted;\n\twork->credits_granted += credits_granted;\n\n\tif (!req_hdr->NextCommand) {\n\t\t/* Update CreditRequest in last request */\n\t\thdr->CreditRequest = cpu_to_le16(work->credits_granted);\n\t}\n\tksmbd_debug(SMB,\n\t\t    \"credits: requested[%d] granted[%d] total_granted[%d]\\n\",\n\t\t    credits_requested, credits_granted,\n\t\t    conn->total_credits);\n\treturn 0;\n}\n\n/**\n * init_chained_smb2_rsp() - initialize smb2 chained response\n * @work:\tsmb work containing smb response buffer\n */\nstatic void init_chained_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *rsp = ksmbd_resp_buf_next(work);\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_hdr *rcv_hdr;\n\tint next_hdr_offset = 0;\n\tint len, new_len;\n\n\t/* Len of this response = updated RFC len - offset of previous cmd\n\t * in the compound rsp\n\t */\n\n\t/* Storing the current local FID which may be needed by subsequent\n\t * command in the compound request\n\t */\n\tif (req->Command == SMB2_CREATE && rsp->Status == STATUS_SUCCESS) {\n\t\twork->compound_fid = ((struct smb2_create_rsp *)rsp)->VolatileFileId;\n\t\twork->compound_pfid = ((struct smb2_create_rsp *)rsp)->PersistentFileId;\n\t\twork->compound_sid = le64_to_cpu(rsp->SessionId);\n\t}\n\n\tlen = get_rfc1002_len(work->response_buf) - work->next_smb2_rsp_hdr_off;\n\tnext_hdr_offset = le32_to_cpu(req->NextCommand);\n\n\tnew_len = ALIGN(len, 8);\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_hdr) + new_len - len);\n\trsp->NextCommand = cpu_to_le32(new_len);\n\n\twork->next_smb2_rcv_hdr_off += next_hdr_offset;\n\twork->next_smb2_rsp_hdr_off += new_len;\n\tksmbd_debug(SMB,\n\t\t    \"Compound req new_len = %d rcv off = %d rsp off = %d\\n\",\n\t\t    new_len, work->next_smb2_rcv_hdr_off,\n\t\t    work->next_smb2_rsp_hdr_off);\n\n\trsp_hdr = ksmbd_resp_buf_next(work);\n\trcv_hdr = ksmbd_req_buf_next(work);\n\n\tif (!(rcv_hdr->Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"related flag should be set\\n\");\n\t\twork->compound_fid = KSMBD_NO_FID;\n\t\twork->compound_pfid = KSMBD_NO_FID;\n\t}\n\tmemset((char *)rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR |\n\t\t\t\tSMB2_FLAGS_RELATED_OPERATIONS);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n}\n\n/**\n * is_chained_smb2_message() - check for chained command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      true if chained request, otherwise false\n */\nbool is_chained_smb2_message(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tunsigned int len, next_cmd;\n\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\thdr = ksmbd_req_buf_next(work);\n\tnext_cmd = le32_to_cpu(hdr->NextCommand);\n\tif (next_cmd > 0) {\n\t\tif ((u64)work->next_smb2_rcv_hdr_off + next_cmd +\n\t\t\t__SMB2_HEADER_STRUCTURE_SIZE >\n\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\tpr_err(\"next command(%u) offset exceeds smb msg size\\n\",\n\t\t\t       next_cmd);\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((u64)get_rfc1002_len(work->response_buf) + MAX_CIFS_SMALL_BUFFER_SIZE >\n\t\t    work->response_sz) {\n\t\t\tpr_err(\"next response offset exceeds response buffer size\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"got SMB2 chained command\\n\");\n\t\tinit_chained_smb2_rsp(work);\n\t\treturn true;\n\t} else if (work->next_smb2_rcv_hdr_off) {\n\t\t/*\n\t\t * This is last request in chained command,\n\t\t * align response to 8 byte\n\t\t */\n\t\tlen = ALIGN(get_rfc1002_len(work->response_buf), 8);\n\t\tlen = len - get_rfc1002_len(work->response_buf);\n\t\tif (len) {\n\t\t\tksmbd_debug(SMB, \"padding len %u\\n\", len);\n\t\t\tinc_rfc1001_len(work->response_buf, len);\n\t\t\tif (work->aux_payload_sz)\n\t\t\t\twork->aux_payload_sz += len;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * init_smb2_rsp_hdr() - initialize smb2 response\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint init_smb2_rsp_hdr(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr = smb2_get_msg(work->response_buf);\n\tstruct smb2_hdr *rcv_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\trsp_hdr->ProtocolId = rcv_hdr->ProtocolId;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n\n\twork->syncronous = true;\n\tif (work->async_id) {\n\t\tksmbd_release_id(&conn->async_ida, work->async_id);\n\t\twork->async_id = 0;\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_allocate_rsp_buf() - allocate smb2 response buffer\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise -ENOMEM\n */\nint smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\n\t/* allocate large response buf for chained commands */\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\n\twork->response_sz = sz;\n\treturn 0;\n}\n\n/**\n * smb2_check_user_session() - check for valid session for a user\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_check_user_session(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned int cmd = conn->ops->get_cmd_val(work);\n\tunsigned long long sess_id;\n\n\twork->sess = NULL;\n\t/*\n\t * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not\n\t * require a session id, so no need to validate user session's for\n\t * these commands.\n\t */\n\tif (cmd == SMB2_ECHO_HE || cmd == SMB2_NEGOTIATE_HE ||\n\t    cmd == SMB2_SESSION_SETUP_HE)\n\t\treturn 0;\n\n\tif (!ksmbd_conn_good(work))\n\t\treturn -EINVAL;\n\n\tsess_id = le64_to_cpu(req_hdr->SessionId);\n\t/* Check for validity of user session */\n\twork->sess = ksmbd_session_lookup_all(conn, sess_id);\n\tif (work->sess)\n\t\treturn 1;\n\tksmbd_debug(SMB, \"Invalid user session, Uid %llu\\n\", sess_id);\n\treturn -EINVAL;\n}\n\nstatic void destroy_previous_session(struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz)) {\n\t\tput_session(prev_sess);\n\t\treturn;\n\t}\n\n\tput_session(prev_sess);\n\tksmbd_session_destroy(prev_sess);\n}\n\n/**\n * smb2_get_name() - get filename string from on the wire smb format\n * @src:\tsource buffer\n * @maxlen:\tmaxlen of source string\n * @local_nls:\tnls_table pointer\n *\n * Return:      matching converted filename on success, otherwise error ptr\n */\nstatic char *\nsmb2_get_name(const char *src, const int maxlen, struct nls_table *local_nls)\n{\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(src, maxlen, 1, local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"failed to get name %ld\\n\", PTR_ERR(name));\n\t\treturn name;\n\t}\n\n\tksmbd_conv_path_to_unix(name);\n\tksmbd_strip_last_slash(name);\n\treturn name;\n}\n\nint setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint id;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Flags |= SMB2_FLAGS_ASYNC_COMMAND;\n\n\tid = ksmbd_acquire_async_msg_id(&conn->async_ida);\n\tif (id < 0) {\n\t\tpr_err(\"Failed to alloc async message id\\n\");\n\t\treturn id;\n\t}\n\twork->syncronous = false;\n\twork->async_id = id;\n\trsp_hdr->Id.AsyncId = cpu_to_le64(id);\n\n\tksmbd_debug(SMB,\n\t\t    \"Send interim Response to inform async request id : %d\\n\",\n\t\t    work->async_id);\n\n\twork->cancel_fn = fn;\n\twork->cancel_argv = arg;\n\n\tif (list_empty(&work->async_request_entry)) {\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_add_tail(&work->async_request_entry, &conn->async_requests);\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\treturn 0;\n}\n\nvoid smb2_send_interim_resp(struct ksmbd_work *work, __le32 status)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tsmb2_set_err_rsp(work);\n\trsp_hdr->Status = status;\n\n\twork->multiRsp = 1;\n\tksmbd_conn_write(work);\n\trsp_hdr->Status = 0;\n\twork->multiRsp = 0;\n}\n\nstatic __le32 smb2_get_reparse_tag_special_file(umode_t mode)\n{\n\tif (S_ISDIR(mode) || S_ISREG(mode))\n\t\treturn 0;\n\n\tif (S_ISLNK(mode))\n\t\treturn IO_REPARSE_TAG_LX_SYMLINK_LE;\n\telse if (S_ISFIFO(mode))\n\t\treturn IO_REPARSE_TAG_LX_FIFO_LE;\n\telse if (S_ISSOCK(mode))\n\t\treturn IO_REPARSE_TAG_AF_UNIX_LE;\n\telse if (S_ISCHR(mode))\n\t\treturn IO_REPARSE_TAG_LX_CHR_LE;\n\telse if (S_ISBLK(mode))\n\t\treturn IO_REPARSE_TAG_LX_BLK_LE;\n\n\treturn 0;\n}\n\n/**\n * smb2_get_dos_mode() - get file mode in dos format from unix mode\n * @stat:\tkstat containing file mode\n * @attribute:\tattribute flags\n *\n * Return:      converted dos mode\n */\nstatic int smb2_get_dos_mode(struct kstat *stat, int attribute)\n{\n\tint attr = 0;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\tattr = FILE_ATTRIBUTE_DIRECTORY |\n\t\t\t(attribute & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));\n\t} else {\n\t\tattr = (attribute & 0x00005137) | FILE_ATTRIBUTE_ARCHIVE;\n\t\tattr &= ~(FILE_ATTRIBUTE_DIRECTORY);\n\t\tif (S_ISREG(stat->mode) && (server_conf.share_fake_fscaps &\n\t\t\t\tFILE_SUPPORTS_SPARSE_FILES))\n\t\t\tattr |= FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (smb2_get_reparse_tag_special_file(stat->mode))\n\t\t\tattr |= FILE_ATTRIBUTE_REPARSE_POINT;\n\t}\n\n\treturn attr;\n}\n\nstatic void build_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt,\n\t\t\t       __le16 hash_id)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = hash_id;\n}\n\nstatic void build_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t       __le16 cipher_type)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(4);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CipherCount = cpu_to_le16(1);\n\tpneg_ctxt->Ciphers[0] = cipher_type;\n}\n\nstatic void build_compression_ctxt(struct smb2_compression_capabilities_context *pneg_ctxt,\n\t\t\t\t   __le16 comp_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16(sizeof(struct smb2_compression_capabilities_context)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Flags = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithms[0] = comp_algo;\n}\n\nstatic void build_sign_cap_ctxt(struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t__le16 sign_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_SIGNING_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16((sizeof(struct smb2_signing_capabilities) + 2)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SigningAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SigningAlgorithms[0] = sign_algo;\n}\n\nstatic void build_posix_ctxt(struct smb2_posix_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_POSIX_EXTENSIONS_AVAILABLE;\n\tpneg_ctxt->DataLength = cpu_to_le16(POSIX_CTXT_DATA_LEN);\n\t/* SMB2_CREATE_TAG_POSIX is \"0x93AD25509CB411E7B42383DE968BCD7C\" */\n\tpneg_ctxt->Name[0] = 0x93;\n\tpneg_ctxt->Name[1] = 0xAD;\n\tpneg_ctxt->Name[2] = 0x25;\n\tpneg_ctxt->Name[3] = 0x50;\n\tpneg_ctxt->Name[4] = 0x9C;\n\tpneg_ctxt->Name[5] = 0xB4;\n\tpneg_ctxt->Name[6] = 0x11;\n\tpneg_ctxt->Name[7] = 0xE7;\n\tpneg_ctxt->Name[8] = 0xB4;\n\tpneg_ctxt->Name[9] = 0x23;\n\tpneg_ctxt->Name[10] = 0x83;\n\tpneg_ctxt->Name[11] = 0xDE;\n\tpneg_ctxt->Name[12] = 0x96;\n\tpneg_ctxt->Name[13] = 0x8B;\n\tpneg_ctxt->Name[14] = 0xCD;\n\tpneg_ctxt->Name[15] = 0x7C;\n}\n\nstatic void assemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_negotiate_rsp *rsp,\n\t\t\t\t  void *smb2_buf_len)\n{\n\tchar *pneg_ctxt = (char *)rsp +\n\t\t\tle32_to_cpu(rsp->NegotiateContextOffset);\n\tint neg_ctxt_cnt = 1;\n\tint ctxt_size;\n\n\tksmbd_debug(SMB,\n\t\t    \"assemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt,\n\t\t\t   conn->preauth_info->Preauth_HashId);\n\trsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);\n\tinc_rfc1001_len(smb2_buf_len, AUTH_GSS_PADDING);\n\tctxt_size = sizeof(struct smb2_preauth_neg_context);\n\t/* Round to 8 byte boundary */\n\tpneg_ctxt += round_up(sizeof(struct smb2_preauth_neg_context), 8);\n\n\tif (conn->cipher_type) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt,\n\t\t\t\t   conn->cipher_type);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_encryption_neg_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt +=\n\t\t\tround_up(sizeof(struct smb2_encryption_neg_context) + 2,\n\t\t\t\t 8);\n\t}\n\n\tif (conn->compress_algorithm) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t/* Temporarily set to SMB3_COMPRESS_NONE */\n\t\tbuild_compression_ctxt((struct smb2_compression_capabilities_context *)pneg_ctxt,\n\t\t\t\t       conn->compress_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_compression_capabilities_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_compression_capabilities_context) + 2,\n\t\t\t\t      8);\n\t}\n\n\tif (conn->posix_ext_supported) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\tbuild_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_posix_neg_context);\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_posix_neg_context), 8);\n\t}\n\n\tif (conn->signing_negotiated) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\tbuild_sign_cap_ctxt((struct smb2_signing_capabilities *)pneg_ctxt,\n\t\t\t\t    conn->signing_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_signing_capabilities) + 2;\n\t}\n\n\tinc_rfc1001_len(smb2_buf_len, ctxt_size);\n}\n\nstatic __le32 decode_preauth_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\t__le32 err = STATUS_NO_PREAUTH_INTEGRITY_HASH_OVERLAP;\n\n\tif (pneg_ctxt->HashAlgorithms == SMB2_PREAUTH_INTEGRITY_SHA512) {\n\t\tconn->preauth_info->Preauth_HashId =\n\t\t\tSMB2_PREAUTH_INTEGRITY_SHA512;\n\t\terr = STATUS_SUCCESS;\n\t}\n\n\treturn err;\n}\n\nstatic void decode_encrypt_ctxt(struct ksmbd_conn *conn,\n\t\t\t\tstruct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t\tint len_of_ctxts)\n{\n\tint cph_cnt = le16_to_cpu(pneg_ctxt->CipherCount);\n\tint i, cphs_size = cph_cnt * sizeof(__le16);\n\n\tconn->cipher_type = 0;\n\n\tif (sizeof(struct smb2_encryption_neg_context) + cphs_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid cipher count(%d)\\n\", cph_cnt);\n\t\treturn;\n\t}\n\n\tif (!(server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION))\n\t\treturn;\n\n\tfor (i = 0; i < cph_cnt; i++) {\n\t\tif (pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_GCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_GCM) {\n\t\t\tksmbd_debug(SMB, \"Cipher ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->Ciphers[i]);\n\t\t\tconn->cipher_type = pneg_ctxt->Ciphers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * smb3_encryption_negotiated() - checks if server and client agreed on enabling encryption\n * @conn:\tsmb connection\n *\n * Return:\ttrue if connection should be encrypted, else false\n */\nstatic bool smb3_encryption_negotiated(struct ksmbd_conn *conn)\n{\n\tif (!conn->ops->generate_encryptionkey)\n\t\treturn false;\n\n\t/*\n\t * SMB 3.0 and 3.0.2 dialects use the SMB2_GLOBAL_CAP_ENCRYPTION flag.\n\t * SMB 3.1.1 uses the cipher_type field.\n\t */\n\treturn (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) ||\n\t    conn->cipher_type;\n}\n\nstatic void decode_compress_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_compression_capabilities_context *pneg_ctxt)\n{\n\tconn->compress_algorithm = SMB3_COMPRESS_NONE;\n}\n\nstatic void decode_sign_cap_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t int len_of_ctxts)\n{\n\tint sign_algo_cnt = le16_to_cpu(pneg_ctxt->SigningAlgorithmCount);\n\tint i, sign_alos_size = sign_algo_cnt * sizeof(__le16);\n\n\tconn->signing_negotiated = false;\n\n\tif (sizeof(struct smb2_signing_capabilities) + sign_alos_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid signing algorithm count(%d)\\n\", sign_algo_cnt);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < sign_algo_cnt; i++) {\n\t\tif (pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_HMAC_SHA256_LE ||\n\t\t    pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_AES_CMAC_LE) {\n\t\t\tksmbd_debug(SMB, \"Signing Algorithm ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->SigningAlgorithms[i]);\n\t\t\tconn->signing_negotiated = true;\n\t\t\tconn->signing_algorithm =\n\t\t\t\tpneg_ctxt->SigningAlgorithms[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen;\n\n\t\t/* check that offset is not beyond end of SMB */\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen + sizeof(struct smb2_neg_context) > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    len_of_ctxts);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     len_of_ctxts);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset = clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n\t}\n\treturn status;\n}\n\n/**\n * smb2_handle_negotiate() - handler for smb2 negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint smb2_handle_negotiate(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);\n\tint rc = 0;\n\tunsigned int smb2_buf_len, smb2_neg_size;\n\t__le32 status;\n\n\tksmbd_debug(SMB, \"Received negotiate request\\n\");\n\tconn->need_neg = false;\n\tif (ksmbd_conn_good(work)) {\n\t\tpr_err(\"conn->tcp_status is already in CifsGood State\\n\");\n\t\twork->send_no_response = 1;\n\t\treturn rc;\n\t}\n\n\tif (req->DialectCount == 0) {\n\t\tpr_err(\"malformed packet\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tsmb2_buf_len = get_rfc1002_len(work->request_buf);\n\tsmb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);\n\tif (smb2_neg_size > smb2_buf_len) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (conn->dialect == SMB311_PROT_ID) {\n\t\tunsigned int nego_ctxt_off = le32_to_cpu(req->NegotiateContextOffset);\n\n\t\tif (smb2_buf_len < nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size > nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    smb2_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tconn->cli_cap = le32_to_cpu(req->Capabilities);\n\tswitch (conn->dialect) {\n\tcase SMB311_PROT_ID:\n\t\tconn->preauth_info =\n\t\t\tkzalloc(sizeof(struct preauth_integrity_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!conn->preauth_info) {\n\t\t\trc = -ENOMEM;\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tstatus = deassemble_neg_contexts(conn, req,\n\t\t\t\t\t\t get_rfc1002_len(work->request_buf));\n\t\tif (status != STATUS_SUCCESS) {\n\t\t\tpr_err(\"deassemble_neg_contexts error(0x%x)\\n\",\n\t\t\t       status);\n\t\t\trsp->hdr.Status = status;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\trc = init_smb3_11_server(conn);\n\t\tif (rc < 0) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tksmbd_gen_preauth_integrity_hash(conn,\n\t\t\t\t\t\t work->request_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\t\trsp->NegotiateContextOffset =\n\t\t\t\tcpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\t\tassemble_neg_contexts(conn, rsp, work->response_buf);\n\t\tbreak;\n\tcase SMB302_PROT_ID:\n\t\tinit_smb3_02_server(conn);\n\t\tbreak;\n\tcase SMB30_PROT_ID:\n\t\tinit_smb3_0_server(conn);\n\t\tbreak;\n\tcase SMB21_PROT_ID:\n\t\tinit_smb2_1_server(conn);\n\t\tbreak;\n\tcase SMB2X_PROT_ID:\n\tcase BAD_PROT_ID:\n\tdefault:\n\t\tksmbd_debug(SMB, \"Server dialect :0x%x not supported\\n\",\n\t\t\t    conn->dialect);\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\n\t/* For stats */\n\tconn->connection_type = conn->dialect;\n\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\tmemcpy(conn->ClientGUID, req->ClientGUID,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\tconn->cli_sec_mode = le16_to_cpu(req->SecurityMode);\n\n\trsp->StructureSize = cpu_to_le16(65);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying server\n\t */\n\tmemset(rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\tksmbd_debug(SMB, \"negotiate context offset %d, count %d\\n\",\n\t\t    le32_to_cpu(rsp->NegotiateContextOffset),\n\t\t    le16_to_cpu(rsp->NegotiateContextCount));\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\t\t\t  le16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\t AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tconn->use_spnego = true;\n\n\tif ((server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||\n\t     server_conf.signing == KSMBD_CONFIG_OPT_DISABLED) &&\n\t    req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED_LE)\n\t\tconn->sign = true;\n\telse if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {\n\t\tserver_conf.enforced_signing = true;\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\t\tconn->sign = true;\n\t}\n\n\tconn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tksmbd_conn_set_need_negotiate(work);\n\nerr_out:\n\tif (rc < 0)\n\t\tsmb2_set_err_rsp(work);\n\n\treturn rc;\n}\n\nstatic int alloc_preauth_hash(struct ksmbd_session *sess,\n\t\t\t      struct ksmbd_conn *conn)\n{\n\tif (sess->Preauth_HashValue)\n\t\treturn 0;\n\n\tsess->Preauth_HashValue = kmemdup(conn->preauth_info->Preauth_HashValue,\n\t\t\t\t\t  PREAUTH_HASHVALUE_SIZE, GFP_KERNEL);\n\tif (!sess->Preauth_HashValue)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int generate_preauth_hash(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tu8 *preauth_hash;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn 0;\n\n\tif (conn->binding) {\n\t\tstruct preauth_session *preauth_sess;\n\n\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\tif (!preauth_sess) {\n\t\t\tpreauth_sess = ksmbd_preauth_session_alloc(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpreauth_hash = preauth_sess->Preauth_HashValue;\n\t} else {\n\t\tif (!sess->Preauth_HashValue)\n\t\t\tif (alloc_preauth_hash(sess, conn))\n\t\t\t\treturn -ENOMEM;\n\t\tpreauth_hash = sess->Preauth_HashValue;\n\t}\n\n\tksmbd_gen_preauth_integrity_hash(conn, work->request_buf, preauth_hash);\n\treturn 0;\n}\n\nstatic int decode_negotiation_token(struct ksmbd_conn *conn,\n\t\t\t\t    struct negotiate_message *negblob,\n\t\t\t\t    size_t sz)\n{\n\tif (!conn->use_spnego)\n\t\treturn -EINVAL;\n\n\tif (ksmbd_decode_negTokenInit((char *)negblob, sz, conn)) {\n\t\tif (ksmbd_decode_negTokenTarg((char *)negblob, sz, conn)) {\n\t\t\tconn->auth_mechs |= KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->preferred_auth_mech = KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->use_spnego = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ntlm_negotiate(struct ksmbd_work *work,\n\t\t\t  struct negotiate_message *negblob,\n\t\t\t  size_t negblob_len)\n{\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct challenge_message *chgblob;\n\tunsigned char *spnego_blob = NULL;\n\tu16 spnego_blob_len;\n\tchar *neg_blob;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"negotiate phase\\n\");\n\trc = ksmbd_decode_ntlmssp_neg_blob(negblob, negblob_len, work->conn);\n\tif (rc)\n\t\treturn rc;\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tchgblob =\n\t\t(struct challenge_message *)((char *)&rsp->hdr.ProtocolId + sz);\n\tmemset(chgblob, 0, sizeof(struct challenge_message));\n\n\tif (!work->conn->use_spnego) {\n\t\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\t\tif (sz < 0)\n\t\t\treturn -ENOMEM;\n\n\t\trsp->SecurityBufferLength = cpu_to_le16(sz);\n\t\treturn 0;\n\t}\n\n\tsz = sizeof(struct challenge_message);\n\tsz += (strlen(ksmbd_netbios_name()) * 2 + 1 + 4) * 6;\n\n\tneg_blob = kzalloc(sz, GFP_KERNEL);\n\tif (!neg_blob)\n\t\treturn -ENOMEM;\n\n\tchgblob = (struct challenge_message *)neg_blob;\n\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\tif (sz < 0) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = build_spnego_ntlmssp_neg_blob(&spnego_blob, &spnego_blob_len,\n\t\t\t\t\t   neg_blob, sz);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\nout:\n\tkfree(spnego_blob);\n\tkfree(neg_blob);\n\treturn rc;\n}\n\nstatic struct authenticate_message *user_authblob(struct ksmbd_conn *conn,\n\t\t\t\t\t\t  struct smb2_sess_setup_req *req)\n{\n\tint sz;\n\n\tif (conn->use_spnego && conn->mechToken)\n\t\treturn (struct authenticate_message *)conn->mechToken;\n\n\tsz = le16_to_cpu(req->SecurityBufferOffset);\n\treturn (struct authenticate_message *)((char *)&req->hdr.ProtocolId\n\t\t\t\t\t       + sz);\n}\n\nstatic struct ksmbd_user *session_user(struct ksmbd_conn *conn,\n\t\t\t\t       struct smb2_sess_setup_req *req)\n{\n\tstruct authenticate_message *authblob;\n\tstruct ksmbd_user *user;\n\tchar *name;\n\tunsigned int auth_msg_len, name_off, name_len, secbuf_len;\n\n\tsecbuf_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (secbuf_len < sizeof(struct authenticate_message)) {\n\t\tksmbd_debug(SMB, \"blob len %d too small\\n\", secbuf_len);\n\t\treturn NULL;\n\t}\n\tauthblob = user_authblob(conn, req);\n\tname_off = le32_to_cpu(authblob->UserName.BufferOffset);\n\tname_len = le16_to_cpu(authblob->UserName.Length);\n\tauth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;\n\n\tif (auth_msg_len < (u64)name_off + name_len)\n\t\treturn NULL;\n\n\tname = smb_strndup_from_utf16((const char *)authblob + name_off,\n\t\t\t\t      name_len,\n\t\t\t\t      true,\n\t\t\t\t      conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"cannot allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tksmbd_debug(SMB, \"session setup request for user %s\\n\", name);\n\tuser = ksmbd_login_user(name);\n\tkfree(name);\n\treturn user;\n}\n\nstatic int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(work->response_buf, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t/*\n\t * If session state is SMB2_SESSION_VALID, We can assume\n\t * that it is reauthentication. And the user/password\n\t * has been verified, so return it here.\n\t */\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\tif (conn->binding)\n\t\t\tgoto binding_session;\n\t\treturn 0;\n\t}\n\n\tif ((rsp->SessionFlags != SMB2_SESSION_FLAG_IS_GUEST_LE &&\n\t     (conn->sign || server_conf.enforced_signing)) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn) &&\n\t\t\t!(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\trc = conn->ops->generate_encryptionkey(sess);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t/*\n\t\t * signing is disable if encryption is enable\n\t\t * on this session\n\t\t */\n\t\tsess->sign = false;\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SMB_SERVER_KERBEROS5\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *in_blob, *out_blob;\n\tstruct channel *chann = NULL;\n\tu64 prev_sess_id;\n\tint in_len, out_len;\n\tint retval;\n\n\tin_blob = (char *)&req->hdr.ProtocolId +\n\t\tle16_to_cpu(req->SecurityBufferOffset);\n\tin_len = le16_to_cpu(req->SecurityBufferLength);\n\tout_blob = (char *)&rsp->hdr.ProtocolId +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\tout_len = work->response_sz -\n\t\t(le16_to_cpu(rsp->SecurityBufferOffset) + 4);\n\n\t/* Check previous session */\n\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_sess_id && prev_sess_id != sess->id)\n\t\tdestroy_previous_session(sess->user, prev_sess_id);\n\n\tif (sess->state == SMB2_SESSION_VALID)\n\t\tksmbd_free_user(sess->user);\n\n\tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n\t\t\t\t\t out_blob, &out_len);\n\tif (retval) {\n\t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\trsp->SecurityBufferLength = cpu_to_le16(out_len);\n\tinc_rfc1001_len(work->response_buf, out_len - 1);\n\n\tif ((conn->sign || server_conf.enforced_signing) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn)) {\n\t\tretval = conn->ops->generate_encryptionkey(sess);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\tsess->sign = false;\n\t}\n\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\tretval = conn->ops->generate_signingkey(sess, conn);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n#else\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nint smb2_sess_setup(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess;\n\tstruct negotiate_message *negblob;\n\tunsigned int negblob_len, negblob_off;\n\tint rc = 0;\n\n\tksmbd_debug(SMB, \"Received request for session setup\\n\");\n\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->SessionFlags = 0;\n\trsp->SecurityBufferOffset = cpu_to_le16(72);\n\trsp->SecurityBufferLength = 0;\n\tinc_rfc1001_len(work->response_buf, 9);\n\n\tif (!req->hdr.SessionId) {\n\t\tsess = ksmbd_smb2_session_create();\n\t\tif (!sess) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\trsp->hdr.SessionId = cpu_to_le64(sess->id);\n\t\tksmbd_session_register(conn, sess);\n\t} else if (conn->dialect >= SMB30_PROT_ID &&\n\t\t   (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   req->Flags & SMB2_SESSION_REQ_FLAG_BINDING) {\n\t\tu64 sess_id = le64_to_cpu(req->hdr.SessionId);\n\n\t\tsess = ksmbd_session_lookup_slowpath(sess_id);\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (conn->dialect != sess->conn->dialect) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!(req->hdr.Flags & SMB2_FLAGS_SIGNED)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (strncmp(conn->ClientGUID, sess->conn->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE)) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_IN_PROGRESS) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_EXPIRED) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (ksmbd_session_lookup(conn, sess_id)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tconn->binding = true;\n\t} else if ((conn->dialect < SMB30_PROT_ID ||\n\t\t    server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   (req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\tsess = NULL;\n\t\trc = -EACCES;\n\t\tgoto out_err;\n\t} else {\n\t\tsess = ksmbd_session_lookup(conn,\n\t\t\t\t\t    le64_to_cpu(req->hdr.SessionId));\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\twork->sess = sess;\n\n\tif (sess->state == SMB2_SESSION_EXPIRED)\n\t\tsess->state = SMB2_SESSION_IN_PROGRESS;\n\n\tnegblob_off = le16_to_cpu(req->SecurityBufferOffset);\n\tnegblob_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (negblob_off < offsetof(struct smb2_sess_setup_req, Buffer) ||\n\t    negblob_len < offsetof(struct negotiate_message, NegotiateFlags)) {\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tnegblob = (struct negotiate_message *)((char *)&req->hdr.ProtocolId +\n\t\t\tnegblob_off);\n\n\tif (decode_negotiation_token(conn, negblob, negblob_len) == 0) {\n\t\tif (conn->mechToken)\n\t\t\tnegblob = (struct negotiate_message *)conn->mechToken;\n\t}\n\n\tif (server_conf.auth_mechs & conn->auth_mechs) {\n\t\trc = generate_preauth_hash(work);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\n\t\tif (conn->preferred_auth_mech &\n\t\t\t\t(KSMBD_AUTH_KRB5 | KSMBD_AUTH_MSKRB5)) {\n\t\t\trc = krb5_authenticate(work);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tksmbd_conn_set_good(work);\n\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\tsess->Preauth_HashValue = NULL;\n\t\t} else if (conn->preferred_auth_mech == KSMBD_AUTH_NTLMSSP) {\n\t\t\tif (negblob->MessageType == NtLmNegotiate) {\n\t\t\t\trc = ntlm_negotiate(work, negblob, negblob_len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\t\t\t\trsp->hdr.Status =\n\t\t\t\t\tSTATUS_MORE_PROCESSING_REQUIRED;\n\t\t\t\t/*\n\t\t\t\t * Note: here total size -1 is done as an\n\t\t\t\t * adjustment for 0 size blob\n\t\t\t\t */\n\t\t\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\t\t\tle16_to_cpu(rsp->SecurityBufferLength) - 1);\n\n\t\t\t} else if (negblob->MessageType == NtLmAuthenticate) {\n\t\t\t\trc = ntlm_authenticate(work);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\tksmbd_conn_set_good(work);\n\t\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\t\tif (conn->binding) {\n\t\t\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\t\t\tpreauth_sess =\n\t\t\t\t\t\tksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\t\t\tif (preauth_sess) {\n\t\t\t\t\t\tlist_del(&preauth_sess->preauth_entry);\n\t\t\t\t\t\tkfree(preauth_sess);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\t\tsess->Preauth_HashValue = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: need one more negotiation */\n\t\t\tpr_err(\"Not support the preferred authentication\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"Not support authentication\\n\");\n\t\trc = -EINVAL;\n\t}\n\nout_err:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_NETWORK_SESSION_EXPIRED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\telse if (rc)\n\t\trsp->hdr.Status = STATUS_LOGON_FAILURE;\n\n\tif (conn->use_spnego && conn->mechToken) {\n\t\tkfree(conn->mechToken);\n\t\tconn->mechToken = NULL;\n\t}\n\n\tif (rc < 0) {\n\t\t/*\n\t\t * SecurityBufferOffset should be set to zero\n\t\t * in session setup error response.\n\t\t */\n\t\trsp->SecurityBufferOffset = 0;\n\n\t\tif (sess) {\n\t\t\tbool try_delay = false;\n\n\t\t\t/*\n\t\t\t * To avoid dictionary attacks (repeated session setups rapidly sent) to\n\t\t\t * connect to server, ksmbd make a delay of a 5 seconds on session setup\n\t\t\t * failure to make it harder to send enough random connection requests\n\t\t\t * to break into a server.\n\t\t\t */\n\t\t\tif (sess->user && sess->user->flags & KSMBD_USER_FLAG_DELAY_SESSION)\n\t\t\t\ttry_delay = true;\n\n\t\t\tksmbd_session_destroy(sess);\n\t\t\twork->sess = NULL;\n\t\t\tif (try_delay)\n\t\t\t\tssleep(5);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_tree_connect() - handler for smb2 tree connect command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_tree_connect(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_tree_connect_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_tree_connect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *treename = NULL, *name = NULL;\n\tstruct ksmbd_tree_conn_status status;\n\tstruct ksmbd_share_config *share;\n\tint rc = -EINVAL;\n\n\ttreename = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->PathLength), true,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(treename)) {\n\t\tpr_err(\"treename is NULL\\n\");\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tname = ksmbd_extract_sharename(treename);\n\tif (IS_ERR(name)) {\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tksmbd_debug(SMB, \"tree connect request for tree %s treename %s\\n\",\n\t\t    name, treename);\n\n\tstatus = ksmbd_tree_conn_connect(sess, name);\n\tif (status.ret == KSMBD_TREE_CONN_STATUS_OK)\n\t\trsp->hdr.Id.SyncId.TreeId = cpu_to_le32(status.tree_conn->id);\n\telse\n\t\tgoto out_err1;\n\n\tshare = status.tree_conn->share_conf;\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC share path request\\n\");\n\t\trsp->ShareType = SMB2_SHARE_TYPE_PIPE;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_DELETE_LE | FILE_READ_CONTROL_LE |\n\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\tFILE_SYNCHRONIZE_LE;\n\t} else {\n\t\trsp->ShareType = SMB2_SHARE_TYPE_DISK;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE;\n\t\tif (test_tree_conn_flag(status.tree_conn,\n\t\t\t\t\tKSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\trsp->MaximalAccess |= FILE_WRITE_DATA_LE |\n\t\t\t\tFILE_APPEND_DATA_LE | FILE_WRITE_EA_LE |\n\t\t\t\tFILE_DELETE_LE | FILE_WRITE_ATTRIBUTES_LE |\n\t\t\t\tFILE_DELETE_CHILD_LE | FILE_READ_CONTROL_LE |\n\t\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\t\tFILE_SYNCHRONIZE_LE;\n\t\t}\n\t}\n\n\tstatus.tree_conn->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\tif (conn->posix_ext_supported)\n\t\tstatus.tree_conn->posix_extensions = true;\n\nout_err1:\n\trsp->StructureSize = cpu_to_le16(16);\n\trsp->Capabilities = 0;\n\trsp->Reserved = 0;\n\t/* default manual caching */\n\trsp->ShareFlags = SMB2_SHAREFLAG_MANUAL_CACHING;\n\tinc_rfc1001_len(work->response_buf, 16);\n\n\tif (!IS_ERR(treename))\n\t\tkfree(treename);\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tswitch (status.ret) {\n\tcase KSMBD_TREE_CONN_STATUS_OK:\n\t\trsp->hdr.Status = STATUS_SUCCESS;\n\t\trc = 0;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_NO_SHARE:\n\t\trsp->hdr.Status = STATUS_BAD_NETWORK_PATH;\n\t\tbreak;\n\tcase -ENOMEM:\n\tcase KSMBD_TREE_CONN_STATUS_NOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_ERROR:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_CONNS:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_SESSIONS:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tbreak;\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tdefault:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_create_open_flags() - convert smb open flags to unix open flags\n * @file_present:\tis file already present\n * @access:\t\tfile access flags\n * @disposition:\tfile disposition flags\n * @may_flags:\t\tset with MAY_ flags\n *\n * Return:      file open flags\n */\nstatic int smb2_create_open_flags(bool file_present, __le32 access,\n\t\t\t\t  __le32 disposition,\n\t\t\t\t  int *may_flags)\n{\n\tint oflags = O_NONBLOCK | O_LARGEFILE;\n\n\tif (access & FILE_READ_DESIRED_ACCESS_LE &&\n\t    access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_RDWR;\n\t\t*may_flags = MAY_OPEN | MAY_READ | MAY_WRITE;\n\t} else if (access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_WRONLY;\n\t\t*may_flags = MAY_OPEN | MAY_WRITE;\n\t} else {\n\t\toflags |= O_RDONLY;\n\t\t*may_flags = MAY_OPEN | MAY_READ;\n\t}\n\n\tif (access == FILE_READ_ATTRIBUTES_LE)\n\t\toflags |= O_PATH;\n\n\tif (file_present) {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_CREATE_LE:\n\t\t\tbreak;\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_TRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_CREATE_LE:\n\t\tcase FILE_OPEN_IF_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_CREAT;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\t\toflags &= ~O_CREAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn oflags;\n}\n\n/**\n * smb2_tree_disconnect() - handler for smb tree connect request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\treturn 0;\n}\n\n/**\n * smb2_session_logoff() - handler for session log off request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_session_logoff(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_logoff_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\t/* setting CifsExiting here may race with start_tcp_sess */\n\tksmbd_conn_set_need_reconnect(work);\n\tksmbd_close_session_fds(work);\n\tksmbd_conn_wait_idle(conn);\n\n\tif (ksmbd_tree_conn_session_logoff(sess)) {\n\t\tstruct smb2_logoff_req *req = smb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_destroy_file_table(&sess->file_table);\n\tsess->state = SMB2_SESSION_EXPIRED;\n\n\tksmbd_free_user(sess->user);\n\tsess->user = NULL;\n\n\t/* let start_tcp_sess free connection info now */\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * create_smb2_pipe() - create IPC pipe\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nstatic noinline int create_smb2_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_create_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_create_req *req = smb2_get_msg(work->request_buf);\n\tint id;\n\tint err;\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(req->Buffer, le16_to_cpu(req->NameLength),\n\t\t\t\t      1, work->conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\terr = PTR_ERR(name);\n\t\tgoto out;\n\t}\n\n\tid = ksmbd_session_rpc_open(work->sess, name);\n\tif (id < 0) {\n\t\tpr_err(\"Unable to open RPC pipe: %d\\n\", id);\n\t\terr = id;\n\t\tgoto out;\n\t}\n\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->StructureSize = cpu_to_le16(89);\n\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_NONE;\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(FILE_OPENED);\n\n\trsp->CreationTime = cpu_to_le64(0);\n\trsp->LastAccessTime = cpu_to_le64(0);\n\trsp->ChangeTime = cpu_to_le64(0);\n\trsp->AllocationSize = cpu_to_le64(0);\n\trsp->EndofFile = cpu_to_le64(0);\n\trsp->FileAttributes = FILE_ATTRIBUTE_NORMAL_LE;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFileId = id;\n\trsp->PersistentFileId = 0;\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\tkfree(name);\n\treturn 0;\n\nout:\n\tswitch (err) {\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tcase -ENOSPC:\n\tcase -ENOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\t}\n\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tsmb2_set_err_rsp(work);\n\treturn err;\n}\n\n/**\n * smb2_set_ea() - handler for setting extended attributes using set\n *\t\tinfo command\n * @eabuf:\tset info command buffer\n * @buf_len:\tset info command buffer length\n * @path:\tdentry path for get ea\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,\n\t\t       struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *attr_name = NULL, *value;\n\tint rc = 0;\n\tunsigned int next = 0;\n\n\tif (buf_len < sizeof(struct smb2_ea_info) + eabuf->EaNameLength +\n\t\t\tle16_to_cpu(eabuf->EaValueLength))\n\t\treturn -EINVAL;\n\n\tattr_name = kmalloc(XATTR_NAME_MAX + 1, GFP_KERNEL);\n\tif (!attr_name)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tif (!eabuf->EaNameLength)\n\t\t\tgoto next;\n\n\t\tksmbd_debug(SMB,\n\t\t\t    \"name : <%s>, name_len : %u, value_len : %u, next : %u\\n\",\n\t\t\t    eabuf->name, eabuf->EaNameLength,\n\t\t\t    le16_to_cpu(eabuf->EaValueLength),\n\t\t\t    le32_to_cpu(eabuf->NextEntryOffset));\n\n\t\tif (eabuf->EaNameLength >\n\t\t    (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN)) {\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(attr_name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\t\tmemcpy(&attr_name[XATTR_USER_PREFIX_LEN], eabuf->name,\n\t\t       eabuf->EaNameLength);\n\t\tattr_name[XATTR_USER_PREFIX_LEN + eabuf->EaNameLength] = '\\0';\n\t\tvalue = (char *)&eabuf->name + eabuf->EaNameLength + 1;\n\n\t\tif (!eabuf->EaValueLength) {\n\t\t\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t\t\t     path->dentry,\n\t\t\t\t\t\t     attr_name,\n\t\t\t\t\t\t     XATTR_USER_PREFIX_LEN +\n\t\t\t\t\t\t     eabuf->EaNameLength);\n\n\t\t\t/* delete the EA only when it exits */\n\t\t\tif (rc > 0) {\n\t\t\t\trc = ksmbd_vfs_remove_xattr(user_ns,\n\t\t\t\t\t\t\t    path->dentry,\n\t\t\t\t\t\t\t    attr_name);\n\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\t    \"remove xattr failed(%d)\\n\",\n\t\t\t\t\t\t    rc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* if the EA doesn't exist, just do nothing. */\n\t\t\trc = 0;\n\t\t} else {\n\t\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\t\tpath->dentry, attr_name, value,\n\t\t\t\t\t\tle16_to_cpu(eabuf->EaValueLength), 0);\n\t\t\tif (rc < 0) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"ksmbd_vfs_setxattr is failed(%d)\\n\",\n\t\t\t\t\t    rc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tnext = le32_to_cpu(eabuf->NextEntryOffset);\n\t\tif (next == 0 || buf_len < next)\n\t\t\tbreak;\n\t\tbuf_len -= next;\n\t\teabuf = (struct smb2_ea_info *)((char *)eabuf + next);\n\t\tif (next < (u32)eabuf->EaNameLength + le16_to_cpu(eabuf->EaValueLength))\n\t\t\tbreak;\n\n\t} while (next != 0);\n\n\tkfree(attr_name);\n\treturn rc;\n}\n\nstatic noinline int smb2_set_stream_name_xattr(struct path *path,\n\t\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t\t       char *stream_name, int s_type)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tsize_t xattr_stream_size;\n\tchar *xattr_stream_name;\n\tint rc;\n\n\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t s_type);\n\tif (rc)\n\t\treturn rc;\n\n\tfp->stream.name = xattr_stream_name;\n\tfp->stream.size = xattr_stream_size;\n\n\t/* Check if there is stream prefix in xattr space */\n\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t     path->dentry,\n\t\t\t\t     xattr_stream_name,\n\t\t\t\t     xattr_stream_size);\n\tif (rc >= 0)\n\t\treturn 0;\n\n\tif (fp->cdoption == FILE_OPEN_LE) {\n\t\tksmbd_debug(SMB, \"XATTR stream name lookup failed: %d\\n\", rc);\n\t\treturn -EBADF;\n\t}\n\n\trc = ksmbd_vfs_setxattr(user_ns, path->dentry,\n\t\t\t\txattr_stream_name, NULL, 0, 0);\n\tif (rc < 0)\n\t\tpr_err(\"Failed to store XATTR stream name :%d\\n\", rc);\n\treturn 0;\n}\n\nstatic int smb2_remove_smb_xattrs(struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], DOS_ATTRIBUTE_PREFIX,\n\t\t\t    DOS_ATTRIBUTE_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\terr = ksmbd_vfs_remove_xattr(user_ns, path->dentry, name);\n\t\tif (err)\n\t\t\tksmbd_debug(SMB, \"remove xattr failed : %s\\n\", name);\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nstatic int smb2_create_truncate(struct path *path)\n{\n\tint rc = vfs_truncate(path, 0);\n\n\tif (rc) {\n\t\tpr_err(\"vfs_truncate failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = smb2_remove_smb_xattrs(path);\n\tif (rc == -EOPNOTSUPP)\n\t\trc = 0;\n\tif (rc)\n\t\tksmbd_debug(SMB,\n\t\t\t    \"ksmbd_truncate_stream_name_xattr failed, rc %d\\n\",\n\t\t\t    rc);\n\treturn rc;\n}\n\nstatic void smb2_new_xattrs(struct ksmbd_tree_connect *tcon, struct path *path,\n\t\t\t    struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da = {0};\n\tint rc;\n\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\tda.version = 4;\n\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\tda.itime = da.create_time = fp->create_time;\n\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\tXATTR_DOSINFO_ITIME;\n\n\trc = ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc)\n\t\tksmbd_debug(SMB, \"failed to store file attribute into xattr\\n\");\n}\n\nstatic void smb2_update_xattrs(struct ksmbd_tree_connect *tcon,\n\t\t\t       struct path *path, struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da;\n\tint rc;\n\n\tfp->f_ci->m_fattr &= ~(FILE_ATTRIBUTE_HIDDEN_LE | FILE_ATTRIBUTE_SYSTEM_LE);\n\n\t/* get FileAttributes from XATTR_NAME_DOS_ATTRIBUTE */\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\trc = ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc > 0) {\n\t\tfp->f_ci->m_fattr = cpu_to_le32(da.attr);\n\t\tfp->create_time = da.create_time;\n\t\tfp->itime = da.itime;\n\t}\n}\n\nstatic int smb2_creat(struct ksmbd_work *work, struct path *path, char *name,\n\t\t      int open_flags, umode_t posix_mode, bool is_dir)\n{\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tumode_t mode;\n\tint rc;\n\n\tif (!(open_flags & O_CREAT))\n\t\treturn -EBADF;\n\n\tksmbd_debug(SMB, \"file does not exist, so creating\\n\");\n\tif (is_dir == true) {\n\t\tksmbd_debug(SMB, \"creating directory\\n\");\n\n\t\tmode = share_config_directory_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_mkdir(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tksmbd_debug(SMB, \"creating regular file\\n\");\n\n\t\tmode = share_config_create_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_create(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, 0, path, 0);\n\tif (rc) {\n\t\tpr_err(\"cannot get linux path (%s), err = %d\\n\",\n\t\t       name, rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int smb2_create_sd_buffer(struct ksmbd_work *work,\n\t\t\t\t struct smb2_create_req *req,\n\t\t\t\t struct path *path)\n{\n\tstruct create_context *context;\n\tstruct create_sd_buf_req *sd_buf;\n\n\tif (!req->CreateContextsOffset)\n\t\treturn -ENOENT;\n\n\t/* Parse SD BUFFER create contexts */\n\tcontext = smb2_find_context_vals(req, SMB2_CREATE_SD_BUFFER);\n\tif (!context)\n\t\treturn -ENOENT;\n\telse if (IS_ERR(context))\n\t\treturn PTR_ERR(context);\n\n\tksmbd_debug(SMB,\n\t\t    \"Set ACLs using SMB2_CREATE_SD_BUFFER context\\n\");\n\tsd_buf = (struct create_sd_buf_req *)context;\n\tif (le16_to_cpu(context->DataOffset) +\n\t    le32_to_cpu(context->DataLength) <\n\t    sizeof(struct create_sd_buf_req))\n\t\treturn -EINVAL;\n\treturn set_info_sec(work->conn, work->tcon, path, &sd_buf->ntsd,\n\t\t\t    le32_to_cpu(sd_buf->ccontext.DataLength), true);\n}\n\nstatic void ksmbd_acls_fattr(struct smb_fattr *fattr,\n\t\t\t     struct user_namespace *mnt_userns,\n\t\t\t     struct inode *inode)\n{\n\tfattr->cf_uid = i_uid_into_mnt(mnt_userns, inode);\n\tfattr->cf_gid = i_gid_into_mnt(mnt_userns, inode);\n\tfattr->cf_mode = inode->i_mode;\n\tfattr->cf_acls = NULL;\n\tfattr->cf_dacls = NULL;\n\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\tfattr->cf_acls = get_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tfattr->cf_dacls = get_acl(inode, ACL_TYPE_DEFAULT);\n\t}\n}\n\n/**\n * smb2_open() - handler for smb file open request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_open(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct path path;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file *filp = NULL;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct kstat stat;\n\tstruct create_context *context;\n\tstruct lease_ctx_info *lc = NULL;\n\tstruct create_ea_buf_req *ea_buf = NULL;\n\tstruct oplock_info *opinfo;\n\t__le32 *next_ptr = NULL;\n\tint req_op_level = 0, open_flags = 0, may_flags = 0, file_info = 0;\n\tint rc = 0;\n\tint contxt_cnt = 0, query_disk_id = 0;\n\tint maximal_access_ctxt = 0, posix_ctxt = 0;\n\tint s_type = 0;\n\tint next_off = 0;\n\tchar *name = NULL;\n\tchar *stream_name = NULL;\n\tbool file_present = false, created = false, already_permitted = false;\n\tint share_ret, need_truncate = 0;\n\tu64 time;\n\tumode_t posix_mode = 0;\n\t__le32 daccess, maximal_access = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (req->hdr.NextCommand && !work->next_smb2_rcv_hdr_off &&\n\t    (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"invalid flag in chained command\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe create request\\n\");\n\t\treturn create_smb2_pipe(work);\n\t}\n\n\tif (req->NameLength) {\n\t\tif ((req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t\t    *(char *)req->Buffer == '\\\\') {\n\t\t\tpr_err(\"not allow directory name included leading slash\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tname = smb2_get_name(req->Buffer,\n\t\t\t\t     le16_to_cpu(req->NameLength),\n\t\t\t\t     work->conn->local_nls);\n\t\tif (IS_ERR(name)) {\n\t\t\trc = PTR_ERR(name);\n\t\t\tif (rc != -ENOMEM)\n\t\t\t\trc = -ENOENT;\n\t\t\tname = NULL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"converted name = %s\\n\", name);\n\t\tif (strchr(name, ':')) {\n\t\t\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t    KSMBD_SHARE_FLAG_STREAMS)) {\n\t\t\t\trc = -EBADF;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\trc = parse_stream_name(name, &stream_name, &s_type);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_out1;\n\t\t}\n\n\t\trc = ksmbd_validate_filename(name);\n\t\tif (rc < 0)\n\t\t\tgoto err_out1;\n\n\t\tif (ksmbd_share_veto_filename(share, name)) {\n\t\t\trc = -ENOENT;\n\t\t\tksmbd_debug(SMB, \"Reject open(), vetoed file: %s\\n\",\n\t\t\t\t    name);\n\t\t\tgoto err_out1;\n\t\t}\n\t} else {\n\t\tname = kstrdup(\"\", GFP_KERNEL);\n\t\tif (!name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out1;\n\t\t}\n\t}\n\n\treq_op_level = req->RequestedOplockLevel;\n\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)\n\t\tlc = parse_lease_state(req);\n\n\tif (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE)) {\n\t\tpr_err(\"Invalid impersonationlevel : 0x%x\\n\",\n\t\t       le32_to_cpu(req->ImpersonationLevel));\n\t\trc = -EIO;\n\t\trsp->hdr.Status = STATUS_BAD_IMPERSONATION_LEVEL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK_LE)) {\n\t\tpr_err(\"Invalid create options : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateOptions));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t} else {\n\t\tif (req->CreateOptions & FILE_SEQUENTIAL_ONLY_LE &&\n\t\t    req->CreateOptions & FILE_RANDOM_ACCESS_LE)\n\t\t\treq->CreateOptions = ~(FILE_SEQUENTIAL_ONLY_LE);\n\n\t\tif (req->CreateOptions &\n\t\t    (FILE_OPEN_BY_FILE_ID_LE | CREATE_TREE_CONNECTION |\n\t\t     FILE_RESERVE_OPFILTER_LE)) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (req->CreateOptions & FILE_NO_COMPRESSION_LE) {\n\t\t\t\treq->CreateOptions = ~(FILE_NO_COMPRESSION_LE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (le32_to_cpu(req->CreateDisposition) >\n\t    le32_to_cpu(FILE_OVERWRITE_IF_LE)) {\n\t\tpr_err(\"Invalid create disposition : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateDisposition));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (!(req->DesiredAccess & DESIRED_ACCESS_MASK)) {\n\t\tpr_err(\"Invalid desired access : 0x%x\\n\",\n\t\t       le32_to_cpu(req->DesiredAccess));\n\t\trc = -EACCES;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->FileAttributes && !(req->FileAttributes & FILE_ATTRIBUTE_MASK_LE)) {\n\t\tpr_err(\"Invalid file attribute : 0x%x\\n\",\n\t\t       le32_to_cpu(req->FileAttributes));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\t/* Parse non-durable handle create contexts */\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_EA_BUFFER);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tea_buf = (struct create_ea_buf_req *)context;\n\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t    sizeof(struct create_ea_buf_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\tif (req->CreateOptions & FILE_NO_EA_KNOWLEDGE_LE) {\n\t\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\t\t\trc = -EACCES;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"get query maximal access context\\n\");\n\t\t\tmaximal_access_ctxt = 1;\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_TIMEWARP_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get timewarp context\\n\");\n\t\t\trc = -EBADF;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (tcon->posix_extensions) {\n\t\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t\t SMB2_CREATE_TAG_POSIX);\n\t\t\tif (IS_ERR(context)) {\n\t\t\t\trc = PTR_ERR(context);\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (context) {\n\t\t\t\tstruct create_posix *posix =\n\t\t\t\t\t(struct create_posix *)context;\n\t\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t\t    sizeof(struct create_posix) - 4) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto err_out1;\n\t\t\t\t}\n\t\t\t\tksmbd_debug(SMB, \"get posix context\\n\");\n\n\t\t\t\tposix_mode = le32_to_cpu(posix->Mode);\n\t\t\t\tposix_ctxt = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out1;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (!rc) {\n\t\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE) {\n\t\t\t/*\n\t\t\t * If file exists with under flags, return access\n\t\t\t * denied error.\n\t\t\t */\n\t\t\tif (req->CreateDisposition == FILE_OVERWRITE_IF_LE ||\n\t\t\t    req->CreateDisposition == FILE_OPEN_IF_LE) {\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else if (d_is_symlink(path.dentry)) {\n\t\t\trc = -EACCES;\n\t\t\tpath_put(&path);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto err_out;\n\t\tksmbd_debug(SMB, \"can not get linux path for %s, rc = %d\\n\",\n\t\t\t    name, rc);\n\t\trc = 0;\n\t} else {\n\t\tfile_present = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t}\n\tif (stream_name) {\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\t}\n\t\t} else {\n\t\t\tif (S_ISDIR(stat.mode) && s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\t\t}\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE &&\n\t\t    req->FileAttributes & FILE_ATTRIBUTE_NORMAL_LE) {\n\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\trc = -EIO;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (file_present && req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE &&\n\t    S_ISDIR(stat.mode) && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\tksmbd_debug(SMB, \"open() argument is a directory: %s, %x\\n\",\n\t\t\t    name, req->CreateOptions);\n\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (file_present && (req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t    !(req->CreateDisposition == FILE_CREATE_LE) &&\n\t    !S_ISDIR(stat.mode)) {\n\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (!stream_name && file_present &&\n\t    req->CreateDisposition == FILE_CREATE_LE) {\n\t\trc = -EEXIST;\n\t\tgoto err_out;\n\t}\n\n\tdaccess = smb_map_generic_desired_access(req->DesiredAccess);\n\n\tif (file_present && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\trc = smb_check_perm_dacl(conn, &path, &daccess,\n\t\t\t\t\t sess->user->uid);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (daccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tif (!file_present) {\n\t\t\tdaccess = cpu_to_le32(GENERIC_ALL_FLAGS);\n\t\t} else {\n\t\t\trc = ksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t    &daccess);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t\talready_permitted = true;\n\t\t}\n\t\tmaximal_access = daccess;\n\t}\n\n\topen_flags = smb2_create_open_flags(file_present, daccess,\n\t\t\t\t\t    req->CreateDisposition,\n\t\t\t\t\t    &may_flags);\n\n\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tif (open_flags & O_CREAT) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t/*create file if not present */\n\tif (!file_present) {\n\t\trc = smb2_creat(work, &path, name, open_flags, posix_mode,\n\t\t\t\treq->CreateOptions & FILE_DIRECTORY_FILE_LE);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOENT) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t}\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tcreated = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tif (ea_buf) {\n\t\t\tif (le32_to_cpu(ea_buf->ccontext.DataLength) <\n\t\t\t    sizeof(struct smb2_ea_info)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\trc = smb2_set_ea(&ea_buf->ea,\n\t\t\t\t\t le32_to_cpu(ea_buf->ccontext.DataLength),\n\t\t\t\t\t &path);\n\t\t\tif (rc == -EOPNOTSUPP)\n\t\t\t\trc = 0;\n\t\t\telse if (rc)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (!already_permitted) {\n\t\t/* FILE_READ_ATTRIBUTE is allowed without inode_permission,\n\t\t * because execute(search) permission on a parent directory,\n\t\t * is already granted.\n\t\t */\n\t\tif (daccess & ~(FILE_READ_ATTRIBUTES_LE | FILE_READ_CONTROL_LE)) {\n\t\t\trc = inode_permission(user_ns,\n\t\t\t\t\t      d_inode(path.dentry),\n\t\t\t\t\t      may_flags);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\n\t\t\tif ((daccess & FILE_DELETE_LE) ||\n\t\t\t    (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\t\t\trc = ksmbd_vfs_may_delete(user_ns,\n\t\t\t\t\t\t\t  path.dentry);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = ksmbd_query_inode_status(d_inode(path.dentry->d_parent));\n\tif (rc == KSMBD_INODE_STATUS_PENDING_DELETE) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\trc = 0;\n\tfilp = dentry_open(&path, open_flags, current_cred());\n\tif (IS_ERR(filp)) {\n\t\trc = PTR_ERR(filp);\n\t\tpr_err(\"dentry open for dir failed, rc %d\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\tif (file_present) {\n\t\tif (!(open_flags & O_TRUNC))\n\t\t\tfile_info = FILE_OPENED;\n\t\telse\n\t\t\tfile_info = FILE_OVERWRITTEN;\n\n\t\tif ((req->CreateDisposition & FILE_CREATE_MASK_LE) ==\n\t\t    FILE_SUPERSEDE_LE)\n\t\t\tfile_info = FILE_SUPERSEDED;\n\t} else if (open_flags & O_CREAT) {\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tksmbd_vfs_set_fadvise(filp, req->CreateOptions);\n\n\t/* Obtain Volatile-ID */\n\tfp = ksmbd_open_fd(work, filp);\n\tif (IS_ERR(fp)) {\n\t\tfput(filp);\n\t\trc = PTR_ERR(fp);\n\t\tfp = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/* Get Persistent-ID */\n\tksmbd_open_durable_fd(fp);\n\tif (!has_file_id(fp->persistent_id)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tfp->cdoption = req->CreateDisposition;\n\tfp->daccess = daccess;\n\tfp->saccess = req->ShareAccess;\n\tfp->coption = req->CreateOptions;\n\n\t/* Set default windows and posix acls if creating new file */\n\tif (created) {\n\t\tint posix_acl_rc;\n\t\tstruct inode *inode = d_inode(path.dentry);\n\n\t\tposix_acl_rc = ksmbd_vfs_inherit_posix_acl(user_ns,\n\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t   d_inode(path.dentry->d_parent));\n\t\tif (posix_acl_rc)\n\t\t\tksmbd_debug(SMB, \"inherit posix acl failed : %d\\n\", posix_acl_rc);\n\n\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\trc = smb_inherit_dacl(conn, &path, sess->user->uid,\n\t\t\t\t\t      sess->user->gid);\n\t\t}\n\n\t\tif (rc) {\n\t\t\trc = smb2_create_sd_buffer(work, req, &path);\n\t\t\tif (rc) {\n\t\t\t\tif (posix_acl_rc)\n\t\t\t\t\tksmbd_vfs_set_init_posix_acl(user_ns,\n\t\t\t\t\t\t\t\t     inode);\n\n\t\t\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\t\t\tstruct smb_fattr fattr;\n\t\t\t\t\tstruct smb_ntsd *pntsd;\n\t\t\t\t\tint pntsd_size, ace_num = 0;\n\n\t\t\t\t\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\t\t\t\t\tif (fattr.cf_acls)\n\t\t\t\t\t\tace_num = fattr.cf_acls->a_count;\n\t\t\t\t\tif (fattr.cf_dacls)\n\t\t\t\t\t\tace_num += fattr.cf_dacls->a_count;\n\n\t\t\t\t\tpntsd = kmalloc(sizeof(struct smb_ntsd) +\n\t\t\t\t\t\t\tsizeof(struct smb_sid) * 3 +\n\t\t\t\t\t\t\tsizeof(struct smb_acl) +\n\t\t\t\t\t\t\tsizeof(struct smb_ace) * ace_num * 2,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!pntsd)\n\t\t\t\t\t\tgoto err_out;\n\n\t\t\t\t\trc = build_sec_desc(user_ns,\n\t\t\t\t\t\t\t    pntsd, NULL,\n\t\t\t\t\t\t\t    OWNER_SECINFO |\n\t\t\t\t\t\t\t    GROUP_SECINFO |\n\t\t\t\t\t\t\t    DACL_SECINFO,\n\t\t\t\t\t\t\t    &pntsd_size, &fattr);\n\t\t\t\t\tposix_acl_release(fattr.cf_acls);\n\t\t\t\t\tposix_acl_release(fattr.cf_dacls);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\n\t\t\t\t\trc = ksmbd_vfs_set_sd_xattr(conn,\n\t\t\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t\t    pntsd,\n\t\t\t\t\t\t\t\t    pntsd_size);\n\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tpr_err(\"failed to store ntacl in xattr : %d\\n\",\n\t\t\t\t\t\t       rc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trc = 0;\n\t}\n\n\tif (stream_name) {\n\t\trc = smb2_set_stream_name_xattr(&path,\n\t\t\t\t\t\tfp,\n\t\t\t\t\t\tstream_name,\n\t\t\t\t\t\ts_type);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tfp->attrib_only = !(req->DesiredAccess & ~(FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_WRITE_ATTRIBUTES_LE | FILE_SYNCHRONIZE_LE));\n\tif (!S_ISDIR(file_inode(filp)->i_mode) && open_flags & O_TRUNC &&\n\t    !fp->attrib_only && !stream_name) {\n\t\tsmb_break_all_oplock(work, fp);\n\t\tneed_truncate = 1;\n\t}\n\n\t/* fp should be searchable through ksmbd_inode.m_fp_list\n\t * after daccess, saccess, attrib_only, and stream are\n\t * initialized.\n\t */\n\twrite_lock(&fp->f_ci->m_lock);\n\tlist_add(&fp->node, &fp->f_ci->m_fp_list);\n\twrite_unlock(&fp->f_ci->m_lock);\n\n\trc = ksmbd_vfs_getattr(&path, &stat);\n\tif (rc) {\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t\trc = 0;\n\t}\n\n\t/* Check delete pending among previous fp before oplock break */\n\tif (ksmbd_inode_pending_delete(fp)) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tshare_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);\n\tif (!test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_OPLOCKS) ||\n\t    (req_op_level == SMB2_OPLOCK_LEVEL_LEASE &&\n\t     !(conn->vals->capabilities & SMB2_GLOBAL_CAP_LEASING))) {\n\t\tif (share_ret < 0 && !S_ISDIR(file_inode(fp->filp)->i_mode)) {\n\t\t\trc = share_ret;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE) {\n\t\t\treq_op_level = smb2_map_lease_to_oplock(lc->req_state);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"lease req for(%s) req oplock state 0x%x, lease state 0x%x\\n\",\n\t\t\t\t    name, req_op_level, lc->req_state);\n\t\t\trc = find_same_lease_key(sess, fp->f_ci, lc);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t} else if (open_flags == O_RDONLY &&\n\t\t\t   (req_op_level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t\t\t    req_op_level == SMB2_OPLOCK_LEVEL_EXCLUSIVE))\n\t\t\treq_op_level = SMB2_OPLOCK_LEVEL_II;\n\n\t\trc = smb_grant_oplock(work, req_op_level,\n\t\t\t\t      fp->persistent_id, fp,\n\t\t\t\t      le32_to_cpu(req->hdr.Id.SyncId.TreeId),\n\t\t\t\t      lc, share_ret);\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)\n\t\tksmbd_fd_set_delete_on_close(fp, file_info);\n\n\tif (need_truncate) {\n\t\trc = smb2_create_truncate(&path);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\tstruct create_alloc_size_req *az_req;\n\n\t\taz_req = (struct create_alloc_size_req *)smb2_find_context_vals(req,\n\t\t\t\t\tSMB2_CREATE_ALLOCATION_SIZE);\n\t\tif (IS_ERR(az_req)) {\n\t\t\trc = PTR_ERR(az_req);\n\t\t\tgoto err_out;\n\t\t} else if (az_req) {\n\t\t\tloff_t alloc_size;\n\t\t\tint err;\n\n\t\t\tif (le16_to_cpu(az_req->ccontext.DataOffset) +\n\t\t\t    le32_to_cpu(az_req->ccontext.DataLength) <\n\t\t\t    sizeof(struct create_alloc_size_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\talloc_size = le64_to_cpu(az_req->AllocationSize);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"request smb2 create allocate size : %llu\\n\",\n\t\t\t\t    alloc_size);\n\t\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\t\terr = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t\t    alloc_size);\n\t\t\tif (err < 0)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"vfs_fallocate is failed : %d\\n\",\n\t\t\t\t\t    err);\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_QUERY_ON_DISK_ID);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get query on disk id context\\n\");\n\t\t\tquery_disk_id = 1;\n\t\t}\n\t}\n\n\tif (stat.result_mask & STATX_BTIME)\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.btime);\n\telse\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.ctime);\n\tif (req->FileAttributes || fp->f_ci->m_fattr == 0)\n\t\tfp->f_ci->m_fattr =\n\t\t\tcpu_to_le32(smb2_get_dos_mode(&stat, le32_to_cpu(req->FileAttributes)));\n\n\tif (!created)\n\t\tsmb2_update_xattrs(tcon, &path, fp);\n\telse\n\t\tsmb2_new_xattrs(tcon, &path, fp);\n\n\tmemcpy(fp->client_guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE);\n\n\tgeneric_fillattr(user_ns, file_inode(fp->filp),\n\t\t\t &stat);\n\n\trsp->StructureSize = cpu_to_le16(89);\n\trcu_read_lock();\n\topinfo = rcu_dereference(fp->f_opinfo);\n\trsp->OplockLevel = opinfo != NULL ? opinfo->level : 0;\n\trcu_read_unlock();\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(file_info);\n\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\trsp->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\trsp->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\trsp->ChangeTime = cpu_to_le64(time);\n\trsp->AllocationSize = S_ISDIR(stat.mode) ? 0 :\n\t\tcpu_to_le64(stat.blocks << 9);\n\trsp->EndofFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\trsp->FileAttributes = fp->f_ci->m_fattr;\n\n\trsp->Reserved2 = 0;\n\n\trsp->PersistentFileId = fp->persistent_id;\n\trsp->VolatileFileId = fp->volatile_id;\n\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\n\t/* If lease is request send lease context response */\n\tif (opinfo && opinfo->is_lease) {\n\t\tstruct create_context *lease_ccontext;\n\n\t\tksmbd_debug(SMB, \"lease granted on(%s) lease state 0x%x\\n\",\n\t\t\t    name, opinfo->o_lease->state);\n\t\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\n\t\tlease_ccontext = (struct create_context *)rsp->Buffer;\n\t\tcontxt_cnt++;\n\t\tcreate_lease_buf(rsp->Buffer, opinfo->o_lease);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_lease_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_lease_size);\n\t\tnext_ptr = &lease_ccontext->Next;\n\t\tnext_off = conn->vals->create_lease_size;\n\t}\n\n\tif (maximal_access_ctxt) {\n\t\tstruct create_context *mxac_ccontext;\n\n\t\tif (maximal_access == 0)\n\t\t\tksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t       path.dentry,\n\t\t\t\t\t\t       &maximal_access);\n\t\tmxac_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_mxac_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tle32_to_cpu(maximal_access));\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_mxac_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_mxac_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &mxac_ccontext->Next;\n\t\tnext_off = conn->vals->create_mxac_size;\n\t}\n\n\tif (query_disk_id) {\n\t\tstruct create_context *disk_id_ccontext;\n\n\t\tdisk_id_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_disk_id_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tstat.ino, tcon->id);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_disk_id_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_disk_id_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &disk_id_ccontext->Next;\n\t\tnext_off = conn->vals->create_disk_id_size;\n\t}\n\n\tif (posix_ctxt) {\n\t\tcontxt_cnt++;\n\t\tcreate_posix_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tfp);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_posix_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_posix_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t}\n\n\tif (contxt_cnt > 0) {\n\t\trsp->CreateContextsOffset =\n\t\t\tcpu_to_le32(offsetof(struct smb2_create_rsp, Buffer));\n\t}\n\nerr_out:\n\tif (file_present || created)\n\t\tpath_put(&path);\n\tksmbd_revert_fsids(work);\nerr_out1:\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (rc == -EOPNOTSUPP)\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\telse if (rc == -EACCES || rc == -ESTALE || rc == -EXDEV)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\t\telse if (rc == -EPERM)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (rc == -EBUSY)\n\t\t\trsp->hdr.Status = STATUS_DELETE_PENDING;\n\t\telse if (rc == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\telse if (rc == -ENOEXEC)\n\t\t\trsp->hdr.Status = STATUS_DUPLICATE_OBJECTID;\n\t\telse if (rc == -ENXIO)\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_DEVICE;\n\t\telse if (rc == -EEXIST)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\t\telse if (rc == -EMFILE)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\tif (!rsp->hdr.Status)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\t\tif (fp)\n\t\t\tksmbd_fd_put(work, fp);\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_debug(SMB, \"Error response: %x\\n\", rsp->hdr.Status);\n\t}\n\n\tkfree(name);\n\tkfree(lc);\n\n\treturn 0;\n}\n\nstatic int readdir_info_level_struct_sz(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_full_directory_info);\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_both_directory_info);\n\tcase FILE_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_directory_info);\n\tcase FILE_NAMES_INFORMATION:\n\t\treturn sizeof(struct file_names_info);\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_full_dir_info);\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_both_directory_info);\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\treturn sizeof(struct smb2_posix_info);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dentry_name(struct ksmbd_dir_info *d_info, int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(ffdinfo->NextEntryOffset);\n\t\td_info->name = ffdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(ffdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fbdinfo->NextEntryOffset);\n\t\td_info->name = fbdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fbdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fdinfo->NextEntryOffset);\n\t\td_info->name = fdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fninfo->NextEntryOffset);\n\t\td_info->name = fninfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fninfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(dinfo->NextEntryOffset);\n\t\td_info->name = dinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(dinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fibdinfo->NextEntryOffset);\n\t\td_info->name = fibdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fibdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(posix_info->NextEntryOffset);\n\t\td_info->name = posix_info->name;\n\t\td_info->name_len = le32_to_cpu(posix_info->name_len);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * smb2_populate_readdir_entry() - encode directory entry in smb2 response\n * buffer\n * @conn:\tconnection instance\n * @info_level:\tsmb information level\n * @d_info:\tstructure included variables for query dir\n * @ksmbd_kstat:\tksmbd wrapper of dirent stat information\n *\n * if directory has many entries, find first can't read it fully.\n * find next might be called multiple times to read remaining dir entries\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,\n\t\t\t\t       struct ksmbd_dir_info *d_info,\n\t\t\t\t       struct ksmbd_kstat *ksmbd_kstat)\n{\n\tint next_entry_offset = 0;\n\tchar *conv_name;\n\tint conv_len;\n\tvoid *kstat;\n\tint struct_sz, rc = 0;\n\n\tconv_name = ksmbd_convert_dir_info_name(d_info,\n\t\t\t\t\t\tconn->local_nls,\n\t\t\t\t\t\t&conv_len);\n\tif (!conv_name)\n\t\treturn -ENOMEM;\n\n\t/* Somehow the name has only terminating NULL bytes */\n\tif (conv_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto free_conv_name;\n\t}\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level) - 1 + conv_len;\n\tnext_entry_offset = ALIGN(struct_sz, KSMBD_DIR_INFO_ALIGNMENT);\n\td_info->last_entry_off_align = next_entry_offset - struct_sz;\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\trc = -ENOSPC;\n\t\tgoto free_conv_name;\n\t}\n\n\tkstat = d_info->wptr;\n\tif (info_level != FILE_NAMES_INFORMATION)\n\t\tkstat = ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)kstat;\n\t\tffdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tffdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (ffdinfo->EaSize)\n\t\t\tffdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tffdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(ffdinfo->FileName, conv_name, conv_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)kstat;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfbdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fbdinfo->EaSize)\n\t\t\tfbdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfbdinfo->ShortNameLength = 0;\n\t\tfbdinfo->Reserved = 0;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfbdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fbdinfo->FileName, conv_name, conv_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)kstat;\n\t\tfdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fdinfo->FileName, conv_name, conv_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)kstat;\n\t\tfninfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tmemcpy(fninfo->FileName, conv_name, conv_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)kstat;\n\t\tdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (dinfo->EaSize)\n\t\t\tdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tdinfo->Reserved = 0;\n\t\tdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(dinfo->FileName, conv_name, conv_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)kstat;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfibdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fibdinfo->EaSize)\n\t\t\tfibdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfibdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tfibdinfo->ShortNameLength = 0;\n\t\tfibdinfo->Reserved = 0;\n\t\tfibdinfo->Reserved2 = cpu_to_le16(0);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfibdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fibdinfo->FileName, conv_name, conv_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\t\tu64 time;\n\n\t\tposix_info = (struct smb2_posix_info *)kstat;\n\t\tposix_info->Ignored = 0;\n\t\tposix_info->CreationTime = cpu_to_le64(ksmbd_kstat->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);\n\t\tposix_info->ChangeTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->atime);\n\t\tposix_info->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->mtime);\n\t\tposix_info->LastWriteTime = cpu_to_le64(time);\n\t\tposix_info->EndOfFile = cpu_to_le64(ksmbd_kstat->kstat->size);\n\t\tposix_info->AllocationSize = cpu_to_le64(ksmbd_kstat->kstat->blocks << 9);\n\t\tposix_info->DeviceId = cpu_to_le32(ksmbd_kstat->kstat->rdev);\n\t\tposix_info->HardLinks = cpu_to_le32(ksmbd_kstat->kstat->nlink);\n\t\tposix_info->Mode = cpu_to_le32(ksmbd_kstat->kstat->mode);\n\t\tposix_info->Inode = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tposix_info->DosAttributes =\n\t\t\tS_ISDIR(ksmbd_kstat->kstat->mode) ?\n\t\t\t\tFILE_ATTRIBUTE_DIRECTORY_LE : FILE_ATTRIBUTE_ARCHIVE_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tposix_info->DosAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tid_to_sid(from_kuid_munged(&init_user_ns, ksmbd_kstat->kstat->uid),\n\t\t\t  SIDNFS_USER, (struct smb_sid *)&posix_info->SidBuffer[0]);\n\t\tid_to_sid(from_kgid_munged(&init_user_ns, ksmbd_kstat->kstat->gid),\n\t\t\t  SIDNFS_GROUP, (struct smb_sid *)&posix_info->SidBuffer[20]);\n\t\tmemcpy(posix_info->name, conv_name, conv_len);\n\t\tposix_info->name_len = cpu_to_le32(conv_len);\n\t\tposix_info->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\n\t} /* switch (info_level) */\n\n\td_info->last_entry_offset = d_info->data_count;\n\td_info->data_count += next_entry_offset;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\n\tksmbd_debug(SMB,\n\t\t    \"info_level : %d, buf_len :%d, next_offset : %d, data_count : %d\\n\",\n\t\t    info_level, d_info->out_buf_len,\n\t\t    next_entry_offset, d_info->data_count);\n\nfree_conv_name:\n\tkfree(conv_name);\n\treturn rc;\n}\n\nstruct smb2_query_dir_private {\n\tstruct ksmbd_work\t*work;\n\tchar\t\t\t*search_pattern;\n\tstruct ksmbd_file\t*dir_fp;\n\n\tstruct ksmbd_dir_info\t*d_info;\n\tint\t\t\tinfo_level;\n};\n\nstatic void lock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n}\n\nstatic void unlock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_unlock(d_inode(dir));\n}\n\nstatic int process_query_dir_entries(struct smb2_query_dir_private *priv)\n{\n\tstruct user_namespace\t*user_ns = file_mnt_user_ns(priv->dir_fp->filp);\n\tstruct kstat\t\tkstat;\n\tstruct ksmbd_kstat\tksmbd_kstat;\n\tint\t\t\trc;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < priv->d_info->num_entry; i++) {\n\t\tstruct dentry *dent;\n\n\t\tif (dentry_name(priv->d_info, priv->info_level))\n\t\t\treturn -EINVAL;\n\n\t\tlock_dir(priv->dir_fp);\n\t\tdent = lookup_one(user_ns, priv->d_info->name,\n\t\t\t\t  priv->dir_fp->filp->f_path.dentry,\n\t\t\t\t  priv->d_info->name_len);\n\t\tunlock_dir(priv->dir_fp);\n\n\t\tif (IS_ERR(dent)) {\n\t\t\tksmbd_debug(SMB, \"Cannot lookup `%s' [%ld]\\n\",\n\t\t\t\t    priv->d_info->name,\n\t\t\t\t    PTR_ERR(dent));\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(d_is_negative(dent))) {\n\t\t\tdput(dent);\n\t\t\tksmbd_debug(SMB, \"Negative dentry `%s'\\n\",\n\t\t\t\t    priv->d_info->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tksmbd_kstat.kstat = &kstat;\n\t\tif (priv->info_level != FILE_NAMES_INFORMATION)\n\t\t\tksmbd_vfs_fill_dentry_attrs(priv->work,\n\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t    dent,\n\t\t\t\t\t\t    &ksmbd_kstat);\n\n\t\trc = smb2_populate_readdir_entry(priv->work->conn,\n\t\t\t\t\t\t priv->info_level,\n\t\t\t\t\t\t priv->d_info,\n\t\t\t\t\t\t &ksmbd_kstat);\n\t\tdput(dent);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int reserve_populate_dentry(struct ksmbd_dir_info *d_info,\n\t\t\t\t   int info_level)\n{\n\tint struct_sz;\n\tint conv_len;\n\tint next_entry_offset;\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level);\n\tif (struct_sz == -EOPNOTSUPP)\n\t\treturn -EOPNOTSUPP;\n\n\tconv_len = (d_info->name_len + 1) * 2;\n\tnext_entry_offset = ALIGN(struct_sz - 1 + conv_len,\n\t\t\t\t  KSMBD_DIR_INFO_ALIGNMENT);\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\treturn -ENOSPC;\n\t}\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->wptr;\n\t\tmemcpy(ffdinfo->FileName, d_info->name, d_info->name_len);\n\t\tffdinfo->FileName[d_info->name_len] = 0x00;\n\t\tffdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fbdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfbdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->wptr;\n\t\tmemcpy(fdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->wptr;\n\t\tmemcpy(fninfo->FileName, d_info->name, d_info->name_len);\n\t\tfninfo->FileName[d_info->name_len] = 0x00;\n\t\tfninfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->wptr;\n\t\tmemcpy(dinfo->FileName, d_info->name, d_info->name_len);\n\t\tdinfo->FileName[d_info->name_len] = 0x00;\n\t\tdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fibdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfibdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->wptr;\n\t\tmemcpy(posix_info->name, d_info->name, d_info->name_len);\n\t\tposix_info->name[d_info->name_len] = 0x00;\n\t\tposix_info->name_len = cpu_to_le32(d_info->name_len);\n\t\tposix_info->NextEntryOffset =\n\t\t\tcpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\t} /* switch (info_level) */\n\n\td_info->num_entry++;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\treturn 0;\n}\n\nstatic int __query_dir(struct dir_context *ctx, const char *name, int namlen,\n\t\t       loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data\t*buf;\n\tstruct smb2_query_dir_private\t*priv;\n\tstruct ksmbd_dir_info\t\t*d_info;\n\tint\t\t\t\trc;\n\n\tbuf\t= container_of(ctx, struct ksmbd_readdir_data, ctx);\n\tpriv\t= buf->private;\n\td_info\t= priv->d_info;\n\n\t/* dot and dotdot entries are already reserved */\n\tif (!strcmp(\".\", name) || !strcmp(\"..\", name))\n\t\treturn 0;\n\tif (ksmbd_share_veto_filename(priv->work->tcon->share_conf, name))\n\t\treturn 0;\n\tif (!match_pattern(name, namlen, priv->search_pattern))\n\t\treturn 0;\n\n\td_info->name\t\t= name;\n\td_info->name_len\t= namlen;\n\trc = reserve_populate_dentry(d_info, priv->info_level);\n\tif (rc)\n\t\treturn rc;\n\tif (d_info->flags & SMB2_RETURN_SINGLE_ENTRY) {\n\t\td_info->out_buf_len = 0;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void restart_ctx(struct dir_context *ctx)\n{\n\tctx->pos = 0;\n}\n\nstatic int verify_info_level(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\tcase FILE_DIRECTORY_INFORMATION:\n\tcase FILE_NAMES_INFORMATION:\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\n\treturn min_t(int, out_buf_len, free_len);\n}\n\nint smb2_query_dir(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tstruct ksmbd_file *dir_fp = NULL;\n\tstruct ksmbd_dir_info d_info;\n\tint rc = 0;\n\tchar *srch_ptr = NULL;\n\tunsigned char srch_flag;\n\tint buffer_sz;\n\tstruct smb2_query_dir_private query_dir_private = {NULL, };\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = verify_info_level(req->FileInformationClass);\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto err_out2;\n\t}\n\n\tdir_fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!dir_fp) {\n\t\trc = -EBADF;\n\t\tgoto err_out2;\n\t}\n\n\tif (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||\n\t    inode_permission(file_mnt_user_ns(dir_fp->filp),\n\t\t\t     file_inode(dir_fp->filp),\n\t\t\t     MAY_READ | MAY_EXEC)) {\n\t\tpr_err(\"no right to enumerate directory (%pd)\\n\",\n\t\t       dir_fp->filp->f_path.dentry);\n\t\trc = -EACCES;\n\t\tgoto err_out2;\n\t}\n\n\tif (!S_ISDIR(file_inode(dir_fp->filp)->i_mode)) {\n\t\tpr_err(\"can't do query dir for a file\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t}\n\n\tsrch_flag = req->Flags;\n\tsrch_ptr = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->FileNameLength), 1,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(srch_ptr)) {\n\t\tksmbd_debug(SMB, \"Search Pattern not found\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t} else {\n\t\tksmbd_debug(SMB, \"Search pattern is %s\\n\", srch_ptr);\n\t}\n\n\tif (srch_flag & SMB2_REOPEN || srch_flag & SMB2_RESTART_SCANS) {\n\t\tksmbd_debug(SMB, \"Restart directory scan\\n\");\n\t\tgeneric_file_llseek(dir_fp->filp, 0, SEEK_SET);\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\t}\n\n\tmemset(&d_info, 0, sizeof(struct ksmbd_dir_info));\n\td_info.wptr = (char *)rsp->Buffer;\n\td_info.rptr = (char *)rsp->Buffer;\n\td_info.out_buf_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (d_info.out_buf_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\td_info.flags = srch_flag;\n\n\t/*\n\t * reserve dot and dotdot entries in head of buffer\n\t * in first response\n\t */\n\trc = ksmbd_populate_dot_dotdot_entries(work, req->FileInformationClass,\n\t\t\t\t\t       dir_fp, &d_info, srch_ptr,\n\t\t\t\t\t       smb2_populate_readdir_entry);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\telse if (rc)\n\t\tgoto err_out;\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_HIDE_DOT_FILES))\n\t\td_info.hide_dot_file = true;\n\n\tbuffer_sz\t\t\t\t= d_info.out_buf_len;\n\td_info.rptr\t\t\t\t= d_info.wptr;\n\tquery_dir_private.work\t\t\t= work;\n\tquery_dir_private.search_pattern\t= srch_ptr;\n\tquery_dir_private.dir_fp\t\t= dir_fp;\n\tquery_dir_private.d_info\t\t= &d_info;\n\tquery_dir_private.info_level\t\t= req->FileInformationClass;\n\tdir_fp->readdir_data.private\t\t= &query_dir_private;\n\tset_ctx_actor(&dir_fp->readdir_data.ctx, __query_dir);\n\n\trc = iterate_dir(dir_fp->filp, &dir_fp->readdir_data.ctx);\n\tif (rc == 0)\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\tif (rc)\n\t\tgoto err_out;\n\n\td_info.wptr = d_info.rptr;\n\td_info.out_buf_len = buffer_sz;\n\trc = process_query_dir_entries(&query_dir_private);\n\tif (rc)\n\t\tgoto err_out;\n\n\tif (!d_info.data_count && d_info.out_buf_len >= 0) {\n\t\tif (srch_flag & SMB2_RETURN_SINGLE_ENTRY && !is_asterisk(srch_ptr)) {\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\t\t} else {\n\t\t\tdir_fp->dot_dotdot[0] = dir_fp->dot_dotdot[1] = 0;\n\t\t\trsp->hdr.Status = STATUS_NO_MORE_FILES;\n\t\t}\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(0);\n\t\trsp->OutputBufferLength = cpu_to_le32(0);\n\t\trsp->Buffer[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, 9);\n\t} else {\n\t\t((struct file_directory_info *)\n\t\t((char *)rsp->Buffer + d_info.last_entry_offset))\n\t\t->NextEntryOffset = 0;\n\t\td_info.data_count -= d_info.last_entry_off_align;\n\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(72);\n\t\trsp->OutputBufferLength = cpu_to_le32(d_info.data_count);\n\t\tinc_rfc1001_len(work->response_buf, 8 + d_info.data_count);\n\t}\n\n\tkfree(srch_ptr);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n\nerr_out:\n\tpr_err(\"error while processing smb2 query dir rc = %d\\n\", rc);\n\tkfree(srch_ptr);\n\nerr_out2:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\telse if (rc == -EBADF)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tif (!rsp->hdr.Status)\n\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n}\n\n/**\n * buffer_check_err() - helper function to check buffer errors\n * @reqOutputBufferLength:\tmax buffer length expected in command response\n * @rsp:\t\tquery info response buffer contains output buffer length\n * @rsp_org:\t\tbase response buffer pointer in case of chained response\n * @infoclass_size:\tquery info class response buffer size\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int buffer_check_err(int reqOutputBufferLength,\n\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t    void *rsp_org, int infoclass_size)\n{\n\tif (reqOutputBufferLength < le32_to_cpu(rsp->OutputBufferLength)) {\n\t\tif (reqOutputBufferLength < infoclass_size) {\n\t\t\tpr_err(\"Invalid Buffer Size Requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INFO_LENGTH_MISMATCH;\n\t\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"Buffer Overflow\\n\");\n\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr) +\n\t\t\t\treqOutputBufferLength);\n\t\trsp->OutputBufferLength = cpu_to_le32(reqOutputBufferLength);\n\t}\n\treturn 0;\n}\n\nstatic void get_standard_info_pipe(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\n\tsinfo->AllocationSize = cpu_to_le64(4096);\n\tsinfo->EndOfFile = cpu_to_le64(0);\n\tsinfo->NumberOfLinks = cpu_to_le32(1);\n\tsinfo->DeletePending = 1;\n\tsinfo->Directory = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_internal_info_pipe(struct smb2_query_info_rsp *rsp, u64 num,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\n\t/* any unique number */\n\tfile_info->IndexNumber = cpu_to_le64(num | (1ULL << 63));\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int smb2_get_info_file_pipe(struct ksmbd_session *sess,\n\t\t\t\t   struct smb2_query_info_req *req,\n\t\t\t\t   struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tu64 id;\n\tint rc;\n\n\t/*\n\t * Windows can sometime send query file info request on\n\t * pipe without opening it, checking error condition here\n\t */\n\tid = req->VolatileFileId;\n\tif (!ksmbd_session_rpc_method(sess, id))\n\t\treturn -ENOENT;\n\n\tksmbd_debug(SMB, \"FileInfoClass %u, FileId 0x%llx\\n\",\n\t\t    req->FileInfoClass, req->VolatileFileId);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_standard_info_pipe(rsp, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_STANDARD_INFORMATION_SIZE);\n\t\tbreak;\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_internal_info_pipe(rsp, id, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_INTERNAL_INFORMATION_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"smb2_info_file_pipe for %u not supported\\n\",\n\t\t\t    req->FileInfoClass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\n\n/**\n * smb2_get_ea() - handler for smb2 get extended attribute command\n * @work:\tsmb work containing query info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\tget extended attribute request\n * @rsp:\tresponse buffer pointer\n * @rsp_org:\tbase response buffer pointer in case of chained response\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t       struct smb2_query_info_req *req,\n\t\t       struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_ea_info *eainfo, *prev_eainfo;\n\tchar *name, *ptr, *xattr_list = NULL, *buf;\n\tint rc, name_len, value_len, xattr_list_len, idx;\n\tssize_t buf_free_len, alignment_bytes, next_offset, rsp_data_cnt = 0;\n\tstruct smb2_ea_info_req *ea_req = NULL;\n\tstruct path *path;\n\tstruct user_namespace *user_ns = file_mnt_user_ns(fp->filp);\n\n\tif (!(fp->daccess & FILE_READ_EA_LE)) {\n\t\tpr_err(\"Not permitted to read ext attr : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tpath = &fp->filp->f_path;\n\t/* single EA entry is requested with given user.* name */\n\tif (req->InputBufferLength) {\n\t\tif (le32_to_cpu(req->InputBufferLength) <\n\t\t    sizeof(struct smb2_ea_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tea_req = (struct smb2_ea_info_req *)req->Buffer;\n\t} else {\n\t\t/* need to send all EAs, if no specific EA is requested*/\n\t\tif (le32_to_cpu(req->Flags) & SL_RETURN_SINGLE_ENTRY)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"All EAs are requested but need to send single EA entry in rsp flags 0x%x\\n\",\n\t\t\t\t    le32_to_cpu(req->Flags));\n\t}\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\treturn -EINVAL;\n\n\trc = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (rc < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tgoto out;\n\t} else if (!rc) { /* there is no EA in the file */\n\t\tksmbd_debug(SMB, \"no ea data in the file\\n\");\n\t\tgoto done;\n\t}\n\txattr_list_len = rc;\n\n\tptr = (char *)rsp->Buffer;\n\teainfo = (struct smb2_ea_info *)ptr;\n\tprev_eainfo = eainfo;\n\tidx = 0;\n\n\twhile (idx < xattr_list_len) {\n\t\tname = xattr_list + idx;\n\t\tname_len = strlen(name);\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", name, name_len);\n\t\tidx += name_len + 1;\n\n\t\t/*\n\t\t * CIFS does not support EA other than user.* namespace,\n\t\t * still keep the framework generic, to list other attrs\n\t\t * in future.\n\t\t */\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX,\n\t\t\t     STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (req->InputBufferLength &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], ea_req->name,\n\t\t\t    ea_req->EaNameLength))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN],\n\t\t\t     DOS_ATTRIBUTE_PREFIX, DOS_ATTRIBUTE_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tname_len -= XATTR_USER_PREFIX_LEN;\n\n\t\tptr = (char *)(&eainfo->name + name_len + 1);\n\t\tbuf_free_len -= (offsetof(struct smb2_ea_info, name) +\n\t\t\t\tname_len + 1);\n\t\t/* bailout if xattr can't fit in buf_free_len */\n\t\tvalue_len = ksmbd_vfs_getxattr(user_ns, path->dentry,\n\t\t\t\t\t       name, &buf);\n\t\tif (value_len <= 0) {\n\t\t\trc = -ENOENT;\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf_free_len -= value_len;\n\t\tif (buf_free_len < 0) {\n\t\t\tkfree(buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(ptr, buf, value_len);\n\t\tkfree(buf);\n\n\t\tptr += value_len;\n\t\teainfo->Flags = 0;\n\t\teainfo->EaNameLength = name_len;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tmemcpy(eainfo->name, &name[XATTR_USER_PREFIX_LEN],\n\t\t\t       name_len);\n\t\telse\n\t\t\tmemcpy(eainfo->name, name, name_len);\n\n\t\teainfo->name[name_len] = '\\0';\n\t\teainfo->EaValueLength = cpu_to_le16(value_len);\n\t\tnext_offset = offsetof(struct smb2_ea_info, name) +\n\t\t\tname_len + 1 + value_len;\n\n\t\t/* align next xattr entry at 4 byte bundary */\n\t\talignment_bytes = ((next_offset + 3) & ~3) - next_offset;\n\t\tif (alignment_bytes) {\n\t\t\tmemset(ptr, '\\0', alignment_bytes);\n\t\t\tptr += alignment_bytes;\n\t\t\tnext_offset += alignment_bytes;\n\t\t\tbuf_free_len -= alignment_bytes;\n\t\t}\n\t\teainfo->NextEntryOffset = cpu_to_le32(next_offset);\n\t\tprev_eainfo = eainfo;\n\t\teainfo = (struct smb2_ea_info *)ptr;\n\t\trsp_data_cnt += next_offset;\n\n\t\tif (req->InputBufferLength) {\n\t\t\tksmbd_debug(SMB, \"single entry requested\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no more ea entries */\n\tprev_eainfo->NextEntryOffset = 0;\ndone:\n\trc = 0;\n\tif (rsp_data_cnt == 0)\n\t\trsp->hdr.Status = STATUS_NO_EAS_ON_FILE;\n\trsp->OutputBufferLength = cpu_to_le32(rsp_data_cnt);\n\tinc_rfc1001_len(rsp_org, rsp_data_cnt);\nout:\n\tkvfree(xattr_list);\n\treturn rc;\n}\n\nstatic void get_file_access_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_access_info *file_info;\n\n\tfile_info = (struct smb2_file_access_info *)rsp->Buffer;\n\tfile_info->AccessFlags = fp->daccess;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_access_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_access_info));\n}\n\nstatic int get_file_basic_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_basic_info *basic_info;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tbasic_info = (struct smb2_file_basic_info *)rsp->Buffer;\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tbasic_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tbasic_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tbasic_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tbasic_info->ChangeTime = cpu_to_le64(time);\n\tbasic_info->Attributes = fp->f_ci->m_fattr;\n\tbasic_info->Pad1 = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_basic_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_basic_info));\n\treturn 0;\n}\n\nstatic unsigned long long get_allocation_size(struct inode *inode,\n\t\t\t\t\t      struct kstat *stat)\n{\n\tunsigned long long alloc_size = 0;\n\n\tif (!S_ISDIR(stat->mode)) {\n\t\tif ((inode->i_blocks << 9) <= stat->size)\n\t\t\talloc_size = stat->size;\n\t\telse\n\t\t\talloc_size = inode->i_blocks << 9;\n\t}\n\n\treturn alloc_size;\n}\n\nstatic void get_file_standard_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\n\tsinfo->AllocationSize = cpu_to_le64(get_allocation_size(inode, &stat));\n\tsinfo->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tsinfo->NumberOfLinks = cpu_to_le32(get_nlink(&stat) - delete_pending);\n\tsinfo->DeletePending = delete_pending;\n\tsinfo->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_file_alignment_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct smb2_file_alignment_info *file_info;\n\n\tfile_info = (struct smb2_file_alignment_info *)rsp->Buffer;\n\tfile_info->AlignmentRequirement = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alignment_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_alignment_info));\n}\n\nstatic int get_file_all_info(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_rsp *rsp,\n\t\t\t     struct ksmbd_file *fp,\n\t\t\t     void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_all_info *file_info;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tint conv_len;\n\tchar *filename;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tksmbd_debug(SMB, \"no right to read the attributes : 0x%x\\n\",\n\t\t\t    fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfilename = convert_to_nt_pathname(work->tcon->share_conf, &fp->filp->f_path);\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tksmbd_debug(SMB, \"filename = %s\\n\", filename);\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\tfile_info = (struct smb2_file_all_info *)rsp->Buffer;\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->Pad1 = 0;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->NumberOfLinks =\n\t\t\tcpu_to_le32(get_nlink(&stat) - delete_pending);\n\tfile_info->DeletePending = delete_pending;\n\tfile_info->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\tfile_info->Pad2 = 0;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\tfile_info->EASize = 0;\n\tfile_info->AccessFlags = fp->daccess;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\tfile_info->Mode = fp->coption;\n\tfile_info->AlignmentRequirement = 0;\n\tconv_len = smbConvertToUTF16((__le16 *)file_info->FileName, filename,\n\t\t\t\t     PATH_MAX, conn->local_nls, 0);\n\tconv_len *= 2;\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_all_info) + conv_len - 1);\n\tkfree(filename);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n\treturn 0;\n}\n\nstatic void get_file_alternate_info(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_alt_name_info *file_info;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint conv_len;\n\n\tspin_lock(&dentry->d_lock);\n\tfile_info = (struct smb2_file_alt_name_info *)rsp->Buffer;\n\tconv_len = ksmbd_extract_shortname(conn,\n\t\t\t\t\t   dentry->d_name.name,\n\t\t\t\t\t   file_info->FileName);\n\tspin_unlock(&dentry->d_lock);\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alt_name_info) + conv_len);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n}\n\nstatic void get_file_stream_info(struct ksmbd_work *work,\n\t\t\t\t struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp,\n\t\t\t\t void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_stream_info *file_info;\n\tchar *stream_name, *xattr_list = NULL, *stream_buf;\n\tstruct kstat stat;\n\tstruct path *path = &fp->filp->f_path;\n\tssize_t xattr_list_len;\n\tint nbytes = 0, streamlen, stream_name_len, next, idx = 0;\n\tint buf_free_len;\n\tstruct smb2_query_info_req *req = ksmbd_req_buf_next(work);\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_stream_info *)rsp->Buffer;\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\tgoto out;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (idx < xattr_list_len) {\n\t\tstream_name = xattr_list + idx;\n\t\tstreamlen = strlen(stream_name);\n\t\tidx += streamlen + 1;\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", stream_name, streamlen);\n\n\t\tif (strncmp(&stream_name[XATTR_USER_PREFIX_LEN],\n\t\t\t    STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tstream_name_len = streamlen - (XATTR_USER_PREFIX_LEN +\n\t\t\t\tSTREAM_PREFIX_LEN);\n\t\tstreamlen = stream_name_len;\n\n\t\t/* plus : size */\n\t\tstreamlen += 1;\n\t\tstream_buf = kmalloc(streamlen + 1, GFP_KERNEL);\n\t\tif (!stream_buf)\n\t\t\tbreak;\n\n\t\tstreamlen = snprintf(stream_buf, streamlen + 1,\n\t\t\t\t     \":%s\", &stream_name[XATTR_NAME_STREAM_LEN]);\n\n\t\tnext = sizeof(struct smb2_file_stream_info) + streamlen * 2;\n\t\tif (next > buf_free_len) {\n\t\t\tkfree(stream_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tfile_info = (struct smb2_file_stream_info *)&rsp->Buffer[nbytes];\n\t\tstreamlen  = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t       stream_buf, streamlen,\n\t\t\t\t\t       conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tkfree(stream_buf);\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stream_name_len);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stream_name_len);\n\n\t\tnbytes += next;\n\t\tbuf_free_len -= next;\n\t\tfile_info->NextEntryOffset = cpu_to_le32(next);\n\t}\n\nout:\n\tif (!S_ISDIR(stat.mode) &&\n\t    buf_free_len >= sizeof(struct smb2_file_stream_info) + 7 * 2) {\n\t\tfile_info = (struct smb2_file_stream_info *)\n\t\t\t&rsp->Buffer[nbytes];\n\t\tstreamlen = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t      \"::$DATA\", 7, conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stat.size);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stat.blocks << 9);\n\t\tnbytes += sizeof(struct smb2_file_stream_info) + streamlen;\n\t}\n\n\t/* last entry offset should be 0 */\n\tfile_info->NextEntryOffset = 0;\n\tkvfree(xattr_list);\n\n\trsp->OutputBufferLength = cpu_to_le32(nbytes);\n\tinc_rfc1001_len(rsp_org, nbytes);\n}\n\nstatic void get_file_internal_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int get_file_network_open_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_ntwrk_info *file_info;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_ntwrk_info *)rsp->Buffer;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->Reserved = cpu_to_le32(0);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ntwrk_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ntwrk_info));\n\treturn 0;\n}\n\nstatic void get_file_ea_info(struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_file_ea_info *file_info;\n\n\tfile_info = (struct smb2_file_ea_info *)rsp->Buffer;\n\tfile_info->EASize = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ea_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ea_info));\n}\n\nstatic void get_file_position_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_pos_info *file_info;\n\n\tfile_info = (struct smb2_file_pos_info *)rsp->Buffer;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_pos_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_pos_info));\n}\n\nstatic void get_file_mode_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_mode_info *file_info;\n\n\tfile_info = (struct smb2_file_mode_info *)rsp->Buffer;\n\tfile_info->Mode = fp->coption & FILE_MODE_INFO_MASK;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_mode_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_mode_info));\n}\n\nstatic void get_file_compression_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_comp_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\n\tfile_info = (struct smb2_file_comp_info *)rsp->Buffer;\n\tfile_info->CompressedFileSize = cpu_to_le64(stat.blocks << 9);\n\tfile_info->CompressionFormat = COMPRESSION_FORMAT_NONE;\n\tfile_info->CompressionUnitShift = 0;\n\tfile_info->ChunkShift = 0;\n\tfile_info->ClusterShift = 0;\n\tmemset(&file_info->Reserved[0], 0, 3);\n\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_comp_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_comp_info));\n}\n\nstatic int get_file_attribute_tag_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_attr_tag_info *file_info;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_attr_tag_info *)rsp->Buffer;\n\tfile_info->FileAttributes = fp->f_ci->m_fattr;\n\tfile_info->ReparseTag = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_attr_tag_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_attr_tag_info));\n\treturn 0;\n}\n\nstatic int find_file_posix_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\tstruct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb311_posix_qinfo *file_info;\n\tstruct inode *inode = file_inode(fp->filp);\n\tu64 time;\n\n\tfile_info = (struct smb311_posix_qinfo *)rsp->Buffer;\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->DosAttributes = fp->f_ci->m_fattr;\n\tfile_info->Inode = cpu_to_le64(inode->i_ino);\n\tfile_info->EndOfFile = cpu_to_le64(inode->i_size);\n\tfile_info->AllocationSize = cpu_to_le64(inode->i_blocks << 9);\n\tfile_info->HardLinks = cpu_to_le32(inode->i_nlink);\n\tfile_info->Mode = cpu_to_le32(inode->i_mode);\n\tfile_info->DeviceId = cpu_to_le32(inode->i_rdev);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb311_posix_qinfo));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb311_posix_qinfo));\n\treturn 0;\n}\n\nstatic int smb2_get_info_file(struct ksmbd_work *work,\n\t\t\t      struct smb2_query_info_req *req,\n\t\t\t      struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tint fileinfoclass = 0;\n\tint rc = 0;\n\tint file_infoclass_size;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\t/* smb2 info file called for pipe */\n\t\treturn smb2_get_info_file_pipe(work->sess, req, rsp,\n\t\t\t\t\t       work->response_buf);\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tfileinfoclass = req->FileInfoClass;\n\n\tswitch (fileinfoclass) {\n\tcase FILE_ACCESS_INFORMATION:\n\t\tget_file_access_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ACCESS_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_BASIC_INFORMATION:\n\t\trc = get_file_basic_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_BASIC_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_file_standard_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STANDARD_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALIGNMENT_INFORMATION:\n\t\tget_file_alignment_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALIGNMENT_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALL_INFORMATION:\n\t\trc = get_file_all_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALTERNATE_NAME_INFORMATION:\n\t\tget_file_alternate_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALTERNATE_NAME_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STREAM_INFORMATION:\n\t\tget_file_stream_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STREAM_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_file_internal_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_INTERNAL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_NETWORK_OPEN_INFORMATION:\n\t\trc = get_file_network_open_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_NETWORK_OPEN_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_EA_INFORMATION:\n\t\tget_file_ea_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_FULL_EA_INFORMATION:\n\t\trc = smb2_get_ea(work, fp, req, rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_FULL_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_POSITION_INFORMATION:\n\t\tget_file_position_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_POSITION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_MODE_INFORMATION:\n\t\tget_file_mode_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_MODE_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_COMPRESSION_INFORMATION:\n\t\tget_file_compression_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_COMPRESSION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ATTRIBUTE_TAG_INFORMATION:\n\t\trc = get_file_attribute_tag_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ATTRIBUTE_TAG_INFORMATION_SIZE;\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\trc = find_file_posix_info(rsp, fp, work->response_buf);\n\t\t\tfile_infoclass_size = sizeof(struct smb311_posix_qinfo);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"fileinfoclass %d not supported yet\\n\",\n\t\t\t    fileinfoclass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\tif (!rc)\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, work->response_buf,\n\t\t\t\t      file_infoclass_size);\n\tksmbd_fd_put(work, fp);\n\treturn rc;\n}\n\nstatic int smb2_get_info_filesystem(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_req *req,\n\t\t\t\t    struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_conn *conn = sess->conn;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tint fsinfoclass = 0;\n\tstruct kstatfs stfs;\n\tstruct path path;\n\tint rc = 0, len;\n\tint fs_infoclass_size = 0;\n\n\trc = kern_path(share->path, LOOKUP_NO_SYMLINKS, &path);\n\tif (rc) {\n\t\tpr_err(\"cannot create vfs path\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = vfs_statfs(&path, &stfs);\n\tif (rc) {\n\t\tpr_err(\"cannot do stat of path %s\\n\", share->path);\n\t\tpath_put(&path);\n\t\treturn -EIO;\n\t}\n\n\tfsinfoclass = req->FileInfoClass;\n\n\tswitch (fsinfoclass) {\n\tcase FS_DEVICE_INFORMATION:\n\t{\n\t\tstruct filesystem_device_info *info;\n\n\t\tinfo = (struct filesystem_device_info *)rsp->Buffer;\n\n\t\tinfo->DeviceType = cpu_to_le32(stfs.f_type);\n\t\tinfo->DeviceCharacteristics = cpu_to_le32(0x00000020);\n\t\trsp->OutputBufferLength = cpu_to_le32(8);\n\t\tinc_rfc1001_len(work->response_buf, 8);\n\t\tfs_infoclass_size = FS_DEVICE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_ATTRIBUTE_INFORMATION:\n\t{\n\t\tstruct filesystem_attribute_info *info;\n\t\tsize_t sz;\n\n\t\tinfo = (struct filesystem_attribute_info *)rsp->Buffer;\n\t\tinfo->Attributes = cpu_to_le32(FILE_SUPPORTS_OBJECT_IDS |\n\t\t\t\t\t       FILE_PERSISTENT_ACLS |\n\t\t\t\t\t       FILE_UNICODE_ON_DISK |\n\t\t\t\t\t       FILE_CASE_PRESERVED_NAMES |\n\t\t\t\t\t       FILE_CASE_SENSITIVE_SEARCH |\n\t\t\t\t\t       FILE_SUPPORTS_BLOCK_REFCOUNTING);\n\n\t\tinfo->Attributes |= cpu_to_le32(server_conf.share_fake_fscaps);\n\n\t\tinfo->MaxPathNameComponentLength = cpu_to_le32(stfs.f_namelen);\n\t\tlen = smbConvertToUTF16((__le16 *)info->FileSystemName,\n\t\t\t\t\t\"NTFS\", PATH_MAX, conn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->FileSystemNameLen = cpu_to_le32(len);\n\t\tsz = sizeof(struct filesystem_attribute_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_ATTRIBUTE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_VOLUME_INFORMATION:\n\t{\n\t\tstruct filesystem_vol_info *info;\n\t\tsize_t sz;\n\t\tunsigned int serial_crc = 0;\n\n\t\tinfo = (struct filesystem_vol_info *)(rsp->Buffer);\n\t\tinfo->VolumeCreationTime = 0;\n\t\tserial_crc = crc32_le(serial_crc, share->name,\n\t\t\t\t      strlen(share->name));\n\t\tserial_crc = crc32_le(serial_crc, share->path,\n\t\t\t\t      strlen(share->path));\n\t\tserial_crc = crc32_le(serial_crc, ksmbd_netbios_name(),\n\t\t\t\t      strlen(ksmbd_netbios_name()));\n\t\t/* Taking dummy value of serial number*/\n\t\tinfo->SerialNumber = cpu_to_le32(serial_crc);\n\t\tlen = smbConvertToUTF16((__le16 *)info->VolumeLabel,\n\t\t\t\t\tshare->name, PATH_MAX,\n\t\t\t\t\tconn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->VolumeLabelSize = cpu_to_le32(len);\n\t\tinfo->Reserved = 0;\n\t\tsz = sizeof(struct filesystem_vol_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_VOLUME_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SIZE_INFORMATION:\n\t{\n\t\tstruct filesystem_info *info;\n\n\t\tinfo = (struct filesystem_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->FreeAllocationUnits = cpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(24);\n\t\tinc_rfc1001_len(work->response_buf, 24);\n\t\tfs_infoclass_size = FS_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_FULL_SIZE_INFORMATION:\n\t{\n\t\tstruct smb2_fs_full_size_info *info;\n\n\t\tinfo = (struct smb2_fs_full_size_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->CallerAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bavail);\n\t\tinfo->ActualAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(32);\n\t\tinc_rfc1001_len(work->response_buf, 32);\n\t\tfs_infoclass_size = FS_FULL_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_OBJECT_ID_INFORMATION:\n\t{\n\t\tstruct object_id_info *info;\n\n\t\tinfo = (struct object_id_info *)(rsp->Buffer);\n\n\t\tif (!user_guest(sess->user))\n\t\t\tmemcpy(info->objid, user_passkey(sess->user), 16);\n\t\telse\n\t\t\tmemset(info->objid, 0, 16);\n\n\t\tinfo->extended_info.magic = cpu_to_le32(EXTENDED_INFO_MAGIC);\n\t\tinfo->extended_info.version = cpu_to_le32(1);\n\t\tinfo->extended_info.release = cpu_to_le32(1);\n\t\tinfo->extended_info.rel_date = 0;\n\t\tmemcpy(info->extended_info.version_string, \"1.1.0\", strlen(\"1.1.0\"));\n\t\trsp->OutputBufferLength = cpu_to_le32(64);\n\t\tinc_rfc1001_len(work->response_buf, 64);\n\t\tfs_infoclass_size = FS_OBJECT_ID_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SECTOR_SIZE_INFORMATION:\n\t{\n\t\tstruct smb3_fs_ss_info *info;\n\t\tunsigned int sector_size =\n\t\t\tmin_t(unsigned int, path.mnt->mnt_sb->s_blocksize, 4096);\n\n\t\tinfo = (struct smb3_fs_ss_info *)(rsp->Buffer);\n\n\t\tinfo->LogicalBytesPerSector = cpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForPerf = cpu_to_le32(sector_size);\n\t\tinfo->FSEffPhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->Flags = cpu_to_le32(SSINFO_FLAGS_ALIGNED_DEVICE |\n\t\t\t\t    SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE);\n\t\tinfo->ByteOffsetForSectorAlignment = 0;\n\t\tinfo->ByteOffsetForPartitionAlignment = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(28);\n\t\tinc_rfc1001_len(work->response_buf, 28);\n\t\tfs_infoclass_size = FS_SECTOR_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_CONTROL_INFORMATION:\n\t{\n\t\t/*\n\t\t * TODO : The current implementation is based on\n\t\t * test result with win7(NTFS) server. It's need to\n\t\t * modify this to get valid Quota values\n\t\t * from Linux kernel\n\t\t */\n\t\tstruct smb2_fs_control_info *info;\n\n\t\tinfo = (struct smb2_fs_control_info *)(rsp->Buffer);\n\t\tinfo->FreeSpaceStartFiltering = 0;\n\t\tinfo->FreeSpaceThreshold = 0;\n\t\tinfo->FreeSpaceStopFiltering = 0;\n\t\tinfo->DefaultQuotaThreshold = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->DefaultQuotaLimit = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->Padding = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(48);\n\t\tinc_rfc1001_len(work->response_buf, 48);\n\t\tfs_infoclass_size = FS_CONTROL_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_POSIX_INFORMATION:\n\t{\n\t\tstruct filesystem_posix_info *info;\n\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\tinfo = (struct filesystem_posix_info *)(rsp->Buffer);\n\t\t\tinfo->OptimalTransferSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->BlockSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->TotalBlocks = cpu_to_le64(stfs.f_blocks);\n\t\t\tinfo->BlocksAvail = cpu_to_le64(stfs.f_bfree);\n\t\t\tinfo->UserBlocksAvail = cpu_to_le64(stfs.f_bavail);\n\t\t\tinfo->TotalFileNodes = cpu_to_le64(stfs.f_files);\n\t\t\tinfo->FreeFileNodes = cpu_to_le64(stfs.f_ffree);\n\t\t\trsp->OutputBufferLength = cpu_to_le32(56);\n\t\t\tinc_rfc1001_len(work->response_buf, 56);\n\t\t\tfs_infoclass_size = FS_POSIX_INFORMATION_SIZE;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpath_put(&path);\n\t\treturn -EOPNOTSUPP;\n\t}\n\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t      rsp, work->response_buf,\n\t\t\t      fs_infoclass_size);\n\tpath_put(&path);\n\treturn rc;\n}\n\nstatic int smb2_get_info_sec(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_req *req,\n\t\t\t     struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;\n\tstruct smb_fattr fattr = {{0}};\n\tstruct inode *inode;\n\t__u32 secdesclen;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\tint addition_info = le32_to_cpu(req->AdditionalInformation);\n\tint rc;\n\n\tif (addition_info & ~(OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO |\n\t\t\t      PROTECTED_DACL_SECINFO |\n\t\t\t      UNPROTECTED_DACL_SECINFO)) {\n\t\tksmbd_debug(SMB, \"Unsupported addition info: 0x%x)\\n\",\n\t\t       addition_info);\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PROTECTED);\n\t\tpntsd->osidoffset = 0;\n\t\tpntsd->gsidoffset = 0;\n\t\tpntsd->sacloffset = 0;\n\t\tpntsd->dacloffset = 0;\n\n\t\tsecdesclen = sizeof(struct smb_ntsd);\n\t\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\t\tinc_rfc1001_len(work->response_buf, secdesclen);\n\n\t\treturn 0;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tinode = file_inode(fp->filp);\n\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR))\n\t\tksmbd_vfs_get_sd_xattr(work->conn, user_ns,\n\t\t\t\t       fp->filp->f_path.dentry, &ppntsd);\n\n\trc = build_sec_desc(user_ns, pntsd, ppntsd, addition_info,\n\t\t\t    &secdesclen, &fattr);\n\tposix_acl_release(fattr.cf_acls);\n\tposix_acl_release(fattr.cf_dacls);\n\tkfree(ppntsd);\n\tksmbd_fd_put(work, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\tinc_rfc1001_len(work->response_buf, secdesclen);\n\treturn 0;\n}\n\n/**\n * smb2_query_info() - handler for smb2 query info command\n * @work:\tsmb work containing query info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_query_info(struct ksmbd_work *work)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp;\n\tint rc = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"GOT query info request\\n\");\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_get_info_file(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_FILESYSTEM:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILESYSTEM\\n\");\n\t\trc = smb2_get_info_filesystem(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\trc = smb2_get_info_sec(work, req, rsp);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"InfoType %d not supported yet\\n\",\n\t\t\t    req->InfoType);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0) {\n\t\tif (rc == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (rc == -EIO)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t\telse if (rc == -EOPNOTSUPP || rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\t\tsmb2_set_err_rsp(work);\n\n\t\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\",\n\t\t\t    rc);\n\t\treturn rc;\n\t}\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->OutputBufferOffset = cpu_to_le16(72);\n\tinc_rfc1001_len(work->response_buf, 8);\n\treturn 0;\n}\n\n/**\n * smb2_close_pipe() - handler for closing IPC pipe\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nstatic noinline int smb2_close_pipe(struct ksmbd_work *work)\n{\n\tu64 id;\n\tstruct smb2_close_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_close_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\tksmbd_session_rpc_close(work->sess, id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Flags = 0;\n\trsp->Reserved = 0;\n\trsp->CreationTime = 0;\n\trsp->LastAccessTime = 0;\n\trsp->LastWriteTime = 0;\n\trsp->ChangeTime = 0;\n\trsp->AllocationSize = 0;\n\trsp->EndOfFile = 0;\n\trsp->Attributes = 0;\n\tinc_rfc1001_len(work->response_buf, 60);\n\treturn 0;\n}\n\n/**\n * smb2_close() - handler for smb2 close file command\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nint smb2_close(struct ksmbd_work *work)\n{\n\tu64 volatile_id = KSMBD_NO_FID;\n\tu64 sess_id;\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_file *fp;\n\tstruct inode *inode;\n\tu64 time;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe close request\\n\");\n\t\treturn smb2_close_pipe(work);\n\t}\n\n\tsess_id = le64_to_cpu(req->hdr.SessionId);\n\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\tsess_id = work->compound_sid;\n\n\twork->compound_sid = 0;\n\tif (check_session_id(conn, sess_id)) {\n\t\twork->compound_sid = sess_id;\n\t} else {\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\t\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\terr = -EBADF;\n\t\tgoto out;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off &&\n\t    !has_file_id(req->VolatileFileId)) {\n\t\tif (!has_file_id(work->compound_fid)) {\n\t\t\t/* file already closed, return FILE_CLOSED */\n\t\t\tksmbd_debug(SMB, \"file already closed\\n\");\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Compound request set FID = %llu:%llu\\n\",\n\t\t\t\t    work->compound_fid,\n\t\t\t\t    work->compound_pfid);\n\t\t\tvolatile_id = work->compound_fid;\n\n\t\t\t/* file closed, stored id is not valid anymore */\n\t\t\twork->compound_fid = KSMBD_NO_FID;\n\t\t\twork->compound_pfid = KSMBD_NO_FID;\n\t\t}\n\t} else {\n\t\tvolatile_id = req->VolatileFileId;\n\t}\n\tksmbd_debug(SMB, \"volatile_id = %llu\\n\", volatile_id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Reserved = 0;\n\n\tif (req->Flags == SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB) {\n\t\tfp = ksmbd_lookup_fd_fast(work, volatile_id);\n\t\tif (!fp) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode = file_inode(fp->filp);\n\t\trsp->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;\n\t\trsp->AllocationSize = S_ISDIR(inode->i_mode) ? 0 :\n\t\t\tcpu_to_le64(inode->i_blocks << 9);\n\t\trsp->EndOfFile = cpu_to_le64(inode->i_size);\n\t\trsp->Attributes = fp->f_ci->m_fattr;\n\t\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\t\trsp->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\t\trsp->LastWriteTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\t\trsp->ChangeTime = cpu_to_le64(time);\n\t\tksmbd_fd_put(work, fp);\n\t} else {\n\t\trsp->Flags = 0;\n\t\trsp->AllocationSize = 0;\n\t\trsp->EndOfFile = 0;\n\t\trsp->Attributes = 0;\n\t\trsp->CreationTime = 0;\n\t\trsp->LastAccessTime = 0;\n\t\trsp->LastWriteTime = 0;\n\t\trsp->ChangeTime = 0;\n\t}\n\n\terr = ksmbd_close_fd(work, volatile_id);\nout:\n\tif (err) {\n\t\tif (rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t} else {\n\t\tinc_rfc1001_len(work->response_buf, 60);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_echo() - handler for smb2 echo(ping) command\n * @work:\tsmb work containing echo request buffer\n *\n * Return:\t0\n */\nint smb2_echo(struct ksmbd_work *work)\n{\n\tstruct smb2_echo_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n}\n\nstatic int smb2_rename(struct ksmbd_work *work,\n\t\t       struct ksmbd_file *fp,\n\t\t       struct user_namespace *user_ns,\n\t\t       struct smb2_file_rename_info *file_info,\n\t\t       struct nls_table *local_nls)\n{\n\tstruct ksmbd_share_config *share = fp->tcon->share_conf;\n\tchar *new_name = NULL, *abs_oldname = NULL, *old_name = NULL;\n\tchar *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tksmbd_debug(SMB, \"setting FILE_RENAME_INFO\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tabs_oldname = d_path(&fp->filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(abs_oldname)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\told_name = strrchr(abs_oldname, '/');\n\tif (old_name && old_name[1] != '\\0') {\n\t\told_name++;\n\t} else {\n\t\tksmbd_debug(SMB, \"can't get last component in path %s\\n\",\n\t\t\t    abs_oldname);\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tnew_name = smb2_get_name(file_info->FileName,\n\t\t\t\t le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t local_nls);\n\tif (IS_ERR(new_name)) {\n\t\trc = PTR_ERR(new_name);\n\t\tgoto out;\n\t}\n\n\tif (strchr(new_name, ':')) {\n\t\tint s_type;\n\t\tchar *xattr_stream_name, *stream_name = NULL;\n\t\tsize_t xattr_stream_size;\n\t\tint len;\n\n\t\trc = parse_stream_name(new_name, &stream_name, &s_type);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tlen = strlen(new_name);\n\t\tif (len > 0 && new_name[len - 1] != '/') {\n\t\t\tpr_err(\"not allow base filename in rename\\n\");\n\t\t\trc = -ESHARE;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t\t s_type);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\tfp->filp->f_path.dentry,\n\t\t\t\t\txattr_stream_name,\n\t\t\t\t\tNULL, 0, 0);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"failed to store stream name in xattr: %d\\n\",\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"new name %s\\n\", new_name);\n\trc = ksmbd_vfs_kern_path(work, new_name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (ksmbd_share_veto_filename(share, new_name)) {\n\t\trc = -ENOENT;\n\t\tksmbd_debug(SMB, \"Can't rename vetoed file: %s\\n\", new_name);\n\t\tgoto out;\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, new_name);\n\t\t\tif (rc) {\n\t\t\t\tif (rc != -ENOTEMPTY)\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s, rc %d\\n\",\n\t\t\t\t\t    new_name, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present &&\n\t\t    strncmp(old_name, path.dentry->d_name.name, strlen(old_name))) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"cannot rename already existing file\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_fp_rename(work, fp, new_name);\nout:\n\tkfree(pathname);\n\tif (!IS_ERR(new_name))\n\t\tkfree(new_name);\n\treturn rc;\n}\n\nstatic int smb2_create_link(struct ksmbd_work *work,\n\t\t\t    struct ksmbd_share_config *share,\n\t\t\t    struct smb2_file_link_info *file_info,\n\t\t\t    unsigned int buf_len, struct file *filp,\n\t\t\t    struct nls_table *local_nls)\n{\n\tchar *link_name = NULL, *target_name = NULL, *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_link_info) +\n\t\t\tle32_to_cpu(file_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tksmbd_debug(SMB, \"setting FILE_LINK_INFORMATION\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tlink_name = smb2_get_name(file_info->FileName,\n\t\t\t\t  le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t  local_nls);\n\tif (IS_ERR(link_name) || S_ISDIR(file_inode(filp)->i_mode)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"link name is %s\\n\", link_name);\n\ttarget_name = d_path(&filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(target_name)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"target name is %s\\n\", target_name);\n\trc = ksmbd_vfs_kern_path(work, link_name, LOOKUP_NO_SYMLINKS, &path, 0);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, link_name);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s\\n\",\n\t\t\t\t\t    link_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB, \"link already exists\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_link(work, target_name, link_name);\n\tif (rc)\n\t\trc = -EINVAL;\nout:\n\tif (!IS_ERR(link_name))\n\t\tkfree(link_name);\n\tkfree(pathname);\n\treturn rc;\n}\n\nstatic int set_file_basic_info(struct ksmbd_file *fp,\n\t\t\t       struct smb2_file_basic_info *file_info,\n\t\t\t       struct ksmbd_share_config *share)\n{\n\tstruct iattr attrs;\n\tstruct file *filp;\n\tstruct inode *inode;\n\tstruct user_namespace *user_ns;\n\tint rc = 0;\n\n\tif (!(fp->daccess & FILE_WRITE_ATTRIBUTES_LE))\n\t\treturn -EACCES;\n\n\tattrs.ia_valid = 0;\n\tfilp = fp->filp;\n\tinode = file_inode(filp);\n\tuser_ns = file_mnt_user_ns(filp);\n\n\tif (file_info->CreationTime)\n\t\tfp->create_time = le64_to_cpu(file_info->CreationTime);\n\n\tif (file_info->LastAccessTime) {\n\t\tattrs.ia_atime = ksmbd_NTtimeToUnix(file_info->LastAccessTime);\n\t\tattrs.ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t}\n\n\tattrs.ia_valid |= ATTR_CTIME;\n\tif (file_info->ChangeTime)\n\t\tattrs.ia_ctime = ksmbd_NTtimeToUnix(file_info->ChangeTime);\n\telse\n\t\tattrs.ia_ctime = inode->i_ctime;\n\n\tif (file_info->LastWriteTime) {\n\t\tattrs.ia_mtime = ksmbd_NTtimeToUnix(file_info->LastWriteTime);\n\t\tattrs.ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t}\n\n\tif (file_info->Attributes) {\n\t\tif (!S_ISDIR(inode->i_mode) &&\n\t\t    file_info->Attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {\n\t\t\tpr_err(\"can't change a file to a directory\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(S_ISDIR(inode->i_mode) && file_info->Attributes == FILE_ATTRIBUTE_NORMAL_LE))\n\t\t\tfp->f_ci->m_fattr = file_info->Attributes |\n\t\t\t\t(fp->f_ci->m_fattr & FILE_ATTRIBUTE_DIRECTORY_LE);\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_STORE_DOS_ATTRS) &&\n\t    (file_info->CreationTime || file_info->Attributes)) {\n\t\tstruct xattr_dos_attrib da = {0};\n\n\t\tda.version = 4;\n\t\tda.itime = fp->itime;\n\t\tda.create_time = fp->create_time;\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\t\tXATTR_DOSINFO_ITIME;\n\n\t\trc = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t    filp->f_path.dentry, &da);\n\t\tif (rc)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"failed to restore file attribute in EA\\n\");\n\t\trc = 0;\n\t}\n\n\tif (attrs.ia_valid) {\n\t\tstruct dentry *dentry = filp->f_path.dentry;\n\t\tstruct inode *inode = d_inode(dentry);\n\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EACCES;\n\n\t\tinode_lock(inode);\n\t\tinode->i_ctime = attrs.ia_ctime;\n\t\tattrs.ia_valid &= ~ATTR_CTIME;\n\t\trc = notify_change(user_ns, dentry, &attrs, NULL);\n\t\tinode_unlock(inode);\n\t}\n\treturn rc;\n}\n\nstatic int set_file_allocation_info(struct ksmbd_work *work,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    struct smb2_file_alloc_info *file_alloc_info)\n{\n\t/*\n\t * TODO : It's working fine only when store dos attributes\n\t * is not yes. need to implement a logic which works\n\t * properly with any smb.conf option\n\t */\n\n\tloff_t alloc_blks;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\talloc_blks = (le64_to_cpu(file_alloc_info->AllocationSize) + 511) >> 9;\n\tinode = file_inode(fp->filp);\n\n\tif (alloc_blks > inode->i_blocks) {\n\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\trc = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t   alloc_blks * 512);\n\t\tif (rc && rc != -EOPNOTSUPP) {\n\t\t\tpr_err(\"vfs_fallocate is failed : %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t} else if (alloc_blks < inode->i_blocks) {\n\t\tloff_t size;\n\n\t\t/*\n\t\t * Allocation size could be smaller than original one\n\t\t * which means allocated blocks in file should be\n\t\t * deallocated. use truncate to cut out it, but inode\n\t\t * size is also updated with truncate offset.\n\t\t * inode size is retained by backup inode size.\n\t\t */\n\t\tsize = i_size_read(inode);\n\t\trc = ksmbd_vfs_truncate(work, fp, alloc_blks * 512);\n\t\tif (rc) {\n\t\t\tpr_err(\"truncate failed!, err %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tif (size < alloc_blks * 512)\n\t\t\ti_size_write(inode, size);\n\t}\n\treturn 0;\n}\n\nstatic int set_end_of_file_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t\tstruct smb2_file_eof_info *file_eof_info)\n{\n\tloff_t newsize;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\tnewsize = le64_to_cpu(file_eof_info->EndOfFile);\n\tinode = file_inode(fp->filp);\n\n\t/*\n\t * If FILE_END_OF_FILE_INFORMATION of set_info_file is called\n\t * on FAT32 shared device, truncate execution time is too long\n\t * and network error could cause from windows client. because\n\t * truncate of some filesystem like FAT32 fill zero data in\n\t * truncated range.\n\t */\n\tif (inode->i_sb->s_magic != MSDOS_SUPER_MAGIC) {\n\t\tksmbd_debug(SMB, \"truncated to newsize %lld\\n\", newsize);\n\t\trc = ksmbd_vfs_truncate(work, fp, newsize);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"truncate failed!, err %d\\n\", rc);\n\t\t\tif (rc != -EAGAIN)\n\t\t\t\trc = -EBADF;\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t   struct smb2_file_rename_info *rename_info,\n\t\t\t   unsigned int buf_len)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ksmbd_file *parent_fp;\n\tstruct dentry *parent;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint ret;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_rename_info) +\n\t\t\tle32_to_cpu(rename_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tif (ksmbd_stream_fd(fp))\n\t\tgoto next;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tparent_fp = ksmbd_lookup_fd_inode(d_inode(parent));\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\n\tif (parent_fp) {\n\t\tif (parent_fp->daccess & FILE_DELETE_LE) {\n\t\t\tpr_err(\"parent dir is opened with delete access\\n\");\n\t\t\tksmbd_fd_put(work, parent_fp);\n\t\t\treturn -ESHARE;\n\t\t}\n\t\tksmbd_fd_put(work, parent_fp);\n\t}\nnext:\n\treturn smb2_rename(work, fp, user_ns, rename_info,\n\t\t\t   work->sess->conn->local_nls);\n}\n\nstatic int set_file_disposition_info(struct ksmbd_file *fp,\n\t\t\t\t     struct smb2_file_disposition_info *file_info)\n{\n\tstruct inode *inode;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tinode = file_inode(fp->filp);\n\tif (file_info->DeletePending) {\n\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t    ksmbd_vfs_empty_dir(fp) == -ENOTEMPTY)\n\t\t\treturn -EBUSY;\n\t\tksmbd_set_inode_pending_delete(fp);\n\t} else {\n\t\tksmbd_clear_inode_pending_delete(fp);\n\t}\n\treturn 0;\n}\n\nstatic int set_file_position_info(struct ksmbd_file *fp,\n\t\t\t\t  struct smb2_file_pos_info *file_info)\n{\n\tloff_t current_byte_offset;\n\tunsigned long sector_size;\n\tstruct inode *inode;\n\n\tinode = file_inode(fp->filp);\n\tcurrent_byte_offset = le64_to_cpu(file_info->CurrentByteOffset);\n\tsector_size = inode->i_sb->s_blocksize;\n\n\tif (current_byte_offset < 0 ||\n\t    (fp->coption == FILE_NO_INTERMEDIATE_BUFFERING_LE &&\n\t     current_byte_offset & (sector_size - 1))) {\n\t\tpr_err(\"CurrentByteOffset is not valid : %llu\\n\",\n\t\t       current_byte_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tfp->filp->f_pos = current_byte_offset;\n\treturn 0;\n}\n\nstatic int set_file_mode_info(struct ksmbd_file *fp,\n\t\t\t      struct smb2_file_mode_info *file_info)\n{\n\t__le32 mode;\n\n\tmode = file_info->Mode;\n\n\tif ((mode & ~FILE_MODE_INFO_MASK)) {\n\t\tpr_err(\"Mode is not valid : 0x%x\\n\", le32_to_cpu(mode));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * TODO : need to implement consideration for\n\t * FILE_SYNCHRONOUS_IO_ALERT and FILE_SYNCHRONOUS_IO_NONALERT\n\t */\n\tksmbd_vfs_set_fadvise(fp->filp, mode);\n\tfp->coption = mode;\n\treturn 0;\n}\n\n/**\n * smb2_set_info_file() - handler for smb2 set info command\n * @work:\tsmb work containing set info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\trequest buffer pointer\n * @share:\tksmbd_share_config pointer\n *\n * Return:\t0 on success, otherwise error\n * TODO: need to implement an error handling for STATUS_INFO_LENGTH_MISMATCH\n */\nstatic int smb2_set_info_file(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t      struct smb2_set_info_req *req,\n\t\t\t      struct ksmbd_share_config *share)\n{\n\tunsigned int buf_len = le32_to_cpu(req->BufferLength);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_BASIC_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_basic_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_basic_info(fp, (struct smb2_file_basic_info *)req->Buffer, share);\n\t}\n\tcase FILE_ALLOCATION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_alloc_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_allocation_info(work, fp,\n\t\t\t\t\t\t(struct smb2_file_alloc_info *)req->Buffer);\n\t}\n\tcase FILE_END_OF_FILE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_eof_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_end_of_file_info(work, fp,\n\t\t\t\t\t    (struct smb2_file_eof_info *)req->Buffer);\n\t}\n\tcase FILE_RENAME_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_rename_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_rename_info(work, fp,\n\t\t\t\t       (struct smb2_file_rename_info *)req->Buffer,\n\t\t\t\t       buf_len);\n\t}\n\tcase FILE_LINK_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_link_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_create_link(work, work->tcon->share_conf,\n\t\t\t\t\t(struct smb2_file_link_info *)req->Buffer,\n\t\t\t\t\tbuf_len, fp->filp,\n\t\t\t\t\twork->sess->conn->local_nls);\n\t}\n\tcase FILE_DISPOSITION_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_disposition_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_disposition_info(fp,\n\t\t\t\t\t\t (struct smb2_file_disposition_info *)req->Buffer);\n\t}\n\tcase FILE_FULL_EA_INFORMATION:\n\t{\n\t\tif (!(fp->daccess & FILE_WRITE_EA_LE)) {\n\t\t\tpr_err(\"Not permitted to write ext  attr: 0x%x\\n\",\n\t\t\t       fp->daccess);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_ea_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_set_ea((struct smb2_ea_info *)req->Buffer,\n\t\t\t\t   buf_len, &fp->filp->f_path);\n\t}\n\tcase FILE_POSITION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_pos_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_position_info(fp, (struct smb2_file_pos_info *)req->Buffer);\n\t}\n\tcase FILE_MODE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_mode_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_mode_info(fp, (struct smb2_file_mode_info *)req->Buffer);\n\t}\n\t}\n\n\tpr_err(\"Unimplemented Fileinfoclass :%d\\n\", req->FileInfoClass);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int smb2_set_info_sec(struct ksmbd_file *fp, int addition_info,\n\t\t\t     char *buffer, int buf_len)\n{\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)buffer;\n\n\tfp->saccess |= FILE_SHARE_DELETE_LE;\n\n\treturn set_info_sec(fp->conn, fp->tcon, &fp->filp->f_path, pntsd,\n\t\t\tbuf_len, false);\n}\n\n/**\n * smb2_set_info() - handler for smb2 set info command handler\n * @work:\tsmb work containing set info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_set_info(struct ksmbd_work *work)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp;\n\tstruct ksmbd_file *fp;\n\tint rc = 0;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tksmbd_debug(SMB, \"Received set info request\\n\");\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid id for close: %u\\n\", id);\n\t\trc = -ENOENT;\n\t\tgoto err_out;\n\t}\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_set_info_file(work, fp, req, work->tcon->share_conf);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\tif (ksmbd_override_fsids(work)) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\trc = smb2_set_info_sec(fp,\n\t\t\t\t       le32_to_cpu(req->AdditionalInformation),\n\t\t\t\t       req->Buffer,\n\t\t\t\t       le32_to_cpu(req->BufferLength));\n\t\tksmbd_revert_fsids(work);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0)\n\t\tgoto err_out;\n\n\trsp->StructureSize = cpu_to_le16(2);\n\tinc_rfc1001_len(work->response_buf, 2);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nerr_out:\n\tif (rc == -EACCES || rc == -EPERM || rc == -EXDEV)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\telse if (rc == -EBUSY || rc == -ENOTEMPTY)\n\t\trsp->hdr.Status = STATUS_DIRECTORY_NOT_EMPTY;\n\telse if (rc == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (rc == -EBADF || rc == -ESTALE)\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\telse if (rc == -EEXIST)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\telse if (rsp->hdr.Status == 0 || rc == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\", rc);\n\treturn rc;\n}\n\n/**\n * smb2_read_pipe() - handler for smb2 read from IPC pipe\n * @work:\tsmb work containing read IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_read_pipe(struct ksmbd_work *work)\n{\n\tint nbytes = 0, err;\n\tu64 id;\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tstruct smb2_read_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_read_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\n\tinc_rfc1001_len(work->response_buf, 16);\n\trpc_resp = ksmbd_rpc_read(work->sess, id);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\twork->aux_payload_buf =\n\t\t\tkvmalloc(rpc_resp->payload_sz, GFP_KERNEL | __GFP_ZERO);\n\t\tif (!work->aux_payload_buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(work->aux_payload_buf, rpc_resp->payload,\n\t\t       rpc_resp->payload_sz);\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\t\twork->aux_payload_sz = nbytes;\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\treturn 0;\n\nout:\n\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\tsmb2_set_err_rsp(work);\n\tkvfree(rpc_resp);\n\treturn err;\n}\n\nstatic int smb2_set_remote_key_for_rdma(struct ksmbd_work *work,\n\t\t\t\t\tstruct smb2_buffer_desc_v1 *desc,\n\t\t\t\t\t__le32 Channel,\n\t\t\t\t\t__le16 ChannelInfoOffset,\n\t\t\t\t\t__le16 ChannelInfoLength)\n{\n\tunsigned int i, ch_count;\n\n\tif (work->conn->dialect == SMB30_PROT_ID &&\n\t    Channel != SMB2_CHANNEL_RDMA_V1)\n\t\treturn -EINVAL;\n\n\tch_count = le16_to_cpu(ChannelInfoLength) / sizeof(*desc);\n\tif (ksmbd_debug_types & KSMBD_DEBUG_RDMA) {\n\t\tfor (i = 0; i < ch_count; i++) {\n\t\t\tpr_info(\"RDMA r/w request %#x: token %#x, length %#x\\n\",\n\t\t\t\ti,\n\t\t\t\tle32_to_cpu(desc[i].token),\n\t\t\t\tle32_to_cpu(desc[i].length));\n\t\t}\n\t}\n\tif (ch_count != 1) {\n\t\tksmbd_debug(RDMA, \"RDMA multiple buffer descriptors %d are not supported yet\\n\",\n\t\t\t    ch_count);\n\t\treturn -EINVAL;\n\t}\n\n\twork->need_invalidate_rkey =\n\t\t(Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE);\n\twork->remote_key = le32_to_cpu(desc->token);\n\treturn 0;\n}\n\nstatic ssize_t smb2_read_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t      struct smb2_read_req *req, void *data_buf,\n\t\t\t\t      size_t length)\n{\n\tstruct smb2_buffer_desc_v1 *desc =\n\t\t(struct smb2_buffer_desc_v1 *)&req->Buffer[0];\n\tint err;\n\n\terr = ksmbd_conn_rdma_write(work->conn, data_buf, length,\n\t\t\t\t    le32_to_cpu(desc->token),\n\t\t\t\t    le64_to_cpu(desc->offset),\n\t\t\t\t    le32_to_cpu(desc->length));\n\tif (err)\n\t\treturn err;\n\n\treturn length;\n}\n\n/**\n * smb2_read() - handler for smb2 read from file\n * @work:\tsmb work containing read command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_read(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_read_req *req;\n\tstruct smb2_read_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length, mincount;\n\tssize_t nbytes = 0, remain_bytes = 0;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe read request\\n\");\n\t\treturn smb2_read_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->ReadChannelInfoOffset);\n\n\t\tif (ch_offset < offsetof(struct smb2_read_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->ReadChannelInfoOffset,\n\t\t\t\t\t\t   req->ReadChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to read : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\tmincount = le32_to_cpu(req->MinimumCount);\n\n\tif (length > conn->vals->max_read_size) {\n\t\tksmbd_debug(SMB, \"limiting read size to max size(%u)\\n\",\n\t\t\t    conn->vals->max_read_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t    fp->filp->f_path.dentry, offset, length);\n\n\twork->aux_payload_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->aux_payload_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnbytes = ksmbd_vfs_read(work, fp, length, &offset);\n\tif (nbytes < 0) {\n\t\terr = nbytes;\n\t\tgoto out;\n\t}\n\n\tif ((nbytes == 0 && length != 0) || nbytes < mincount) {\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\t\trsp->hdr.Status = STATUS_END_OF_FILE;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn 0;\n\t}\n\n\tksmbd_debug(SMB, \"nbytes %zu, offset %lld mincount %zu\\n\",\n\t\t    nbytes, offset, mincount);\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1) {\n\t\t/* write data to the client using rdma channel */\n\t\tremain_bytes = smb2_read_rdma_channel(work, req,\n\t\t\t\t\t\t      work->aux_payload_buf,\n\t\t\t\t\t\t      nbytes);\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\n\t\tnbytes = 0;\n\t\tif (remain_bytes < 0) {\n\t\t\terr = (int)remain_bytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = cpu_to_le32(remain_bytes);\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\twork->aux_payload_sz = nbytes;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\tif (err == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\telse if (err == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (err == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (err == -ESHARE)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\t\tsmb2_set_err_rsp(work);\n\t}\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_write_pipe() - handler for smb2 write on IPC pipe\n * @work:\tsmb work containing write IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_write_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_write_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tu64 id = 0;\n\tint err = 0, ret = 0;\n\tchar *data_buf;\n\tsize_t length;\n\n\tlength = le32_to_cpu(req->Length);\n\tid = req->VolatileFileId;\n\n\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t    get_rfc1002_len(work->request_buf)) {\n\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t       le16_to_cpu(req->DataOffset),\n\t\t       get_rfc1002_len(work->request_buf));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t   le16_to_cpu(req->DataOffset));\n\n\trpc_resp = ksmbd_rpc_write(work->sess, id, data_buf, length);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tkvfree(rpc_resp);\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\tkvfree(rpc_resp);\n\t\t\treturn ret;\n\t\t}\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(length);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\treturn 0;\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t smb2_write_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t       struct smb2_write_req *req,\n\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t       loff_t offset, size_t length, bool sync)\n{\n\tstruct smb2_buffer_desc_v1 *desc;\n\tchar *data_buf;\n\tint ret;\n\tssize_t nbytes;\n\n\tdesc = (struct smb2_buffer_desc_v1 *)&req->Buffer[0];\n\n\tdata_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\tret = ksmbd_conn_rdma_read(work->conn, data_buf, length,\n\t\t\t\t   le32_to_cpu(desc->token),\n\t\t\t\t   le64_to_cpu(desc->offset),\n\t\t\t\t   le32_to_cpu(desc->length));\n\tif (ret < 0) {\n\t\tkvfree(data_buf);\n\t\treturn ret;\n\t}\n\n\tret = ksmbd_vfs_write(work, fp, data_buf, length, &offset, sync, &nbytes);\n\tkvfree(data_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn nbytes;\n}\n\n/**\n * smb2_write() - handler for smb2 write from file\n * @work:\tsmb work containing write command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoOffset,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (length > work->conn->vals->max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    work->conn->vals->max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (req->Channel != SMB2_CHANNEL_RDMA_V1 &&\n\t    req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t\t       le16_to_cpu(req->DataOffset),\n\t\t\t       get_rfc1002_len(work->request_buf));\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t    le16_to_cpu(req->DataOffset));\n\n\t\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\t\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\t\twritethrough = true;\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset,\n\t\t\t\t\t\t le32_to_cpu(req->RemainingBytes),\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_flush() - handler for smb2 flush file - fsync\n * @work:\tsmb work containing flush command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_flush(struct ksmbd_work *work)\n{\n\tstruct smb2_flush_req *req;\n\tstruct smb2_flush_rsp *rsp;\n\tint err;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"SMB2_FLUSH called for fid %llu\\n\", req->VolatileFileId);\n\n\terr = ksmbd_vfs_fsync(work, req->VolatileFileId, req->PersistentFileId);\n\tif (err)\n\t\tgoto out;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\n/**\n * smb2_cancel() - handler for smb2 cancel command\n * @work:\tsmb work containing cancel command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_cancel(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tstruct smb2_hdr *chdr;\n\tstruct ksmbd_work *cancel_work = NULL, *iter;\n\tstruct list_head *command_list;\n\n\tksmbd_debug(SMB, \"smb2 cancel called on mid %llu, async flags 0x%x\\n\",\n\t\t    hdr->MessageId, hdr->Flags);\n\n\tif (hdr->Flags & SMB2_FLAGS_ASYNC_COMMAND) {\n\t\tcommand_list = &conn->async_requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list,\n\t\t\t\t    async_request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (iter->async_id !=\n\t\t\t    le64_to_cpu(hdr->Id.AsyncId))\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with AsyncId %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->Id.AsyncId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t} else {\n\t\tcommand_list = &conn->requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list, request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (chdr->MessageId != hdr->MessageId ||\n\t\t\t    iter == work)\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with mid %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->MessageId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\tif (cancel_work) {\n\t\tcancel_work->state = KSMBD_WORK_CANCELLED;\n\t\tif (cancel_work->cancel_fn)\n\t\t\tcancel_work->cancel_fn(cancel_work->cancel_argv);\n\t}\n\n\t/* For SMB2_CANCEL command itself send no response*/\n\twork->send_no_response = 1;\n\treturn 0;\n}\n\nstruct file_lock *smb_flock_init(struct file *f)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\tgoto out;\n\n\tlocks_init_lock(fl);\n\n\tfl->fl_owner = f;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = f;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\nout:\n\treturn fl;\n}\n\nstatic int smb2_set_flock_flags(struct file_lock *flock, int flags)\n{\n\tint cmd = -EINVAL;\n\n\t/* Checking for wrong flag combination during lock request*/\n\tswitch (flags) {\n\tcase SMB2_LOCKFLAG_SHARED:\n\t\tksmbd_debug(SMB, \"received shared request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_RDLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE:\n\t\tksmbd_debug(SMB, \"received exclusive request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_WRLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_SHARED | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received shared & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received exclusive & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_UNLOCK:\n\t\tksmbd_debug(SMB, \"received unlock request\\n\");\n\t\tflock->fl_type = F_UNLCK;\n\t\tcmd = 0;\n\t\tbreak;\n\t}\n\n\treturn cmd;\n}\n\nstatic struct ksmbd_lock *smb2_lock_init(struct file_lock *flock,\n\t\t\t\t\t unsigned int cmd, int flags,\n\t\t\t\t\t struct list_head *lock_list)\n{\n\tstruct ksmbd_lock *lock;\n\n\tlock = kzalloc(sizeof(struct ksmbd_lock), GFP_KERNEL);\n\tif (!lock)\n\t\treturn NULL;\n\n\tlock->cmd = cmd;\n\tlock->fl = flock;\n\tlock->start = flock->fl_start;\n\tlock->end = flock->fl_end;\n\tlock->flags = flags;\n\tif (lock->start == lock->end)\n\t\tlock->zero_len = 1;\n\tINIT_LIST_HEAD(&lock->clist);\n\tINIT_LIST_HEAD(&lock->flist);\n\tINIT_LIST_HEAD(&lock->llist);\n\tlist_add_tail(&lock->llist, lock_list);\n\n\treturn lock;\n}\n\nstatic void smb2_remove_blocked_lock(void **argv)\n{\n\tstruct file_lock *flock = (struct file_lock *)argv[0];\n\n\tksmbd_vfs_posix_lock_unblock(flock);\n\twake_up(&flock->fl_wait);\n}\n\nstatic inline bool lock_defer_pending(struct file_lock *fl)\n{\n\t/* check pending lock waiters */\n\treturn waitqueue_active(&fl->fl_wait);\n}\n\n/**\n * smb2_lock() - handler for smb2 file lock command\n * @work:\tsmb work containing lock command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_lock(struct ksmbd_work *work)\n{\n\tstruct smb2_lock_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lock_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_lock_element *lock_ele;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file_lock *flock = NULL;\n\tstruct file *filp = NULL;\n\tint lock_count;\n\tint flags = 0;\n\tint cmd = 0;\n\tint err = -EIO, i, rc = 0;\n\tu64 lock_start, lock_length;\n\tstruct ksmbd_lock *smb_lock = NULL, *cmp_lock, *tmp, *tmp2;\n\tstruct ksmbd_conn *conn;\n\tint nolock = 0;\n\tLIST_HEAD(lock_list);\n\tLIST_HEAD(rollback_list);\n\tint prior_lock = 0;\n\n\tksmbd_debug(SMB, \"Received lock request\\n\");\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid file id for lock : %llu\\n\", req->VolatileFileId);\n\t\terr = -ENOENT;\n\t\tgoto out2;\n\t}\n\n\tfilp = fp->filp;\n\tlock_count = le16_to_cpu(req->LockCount);\n\tlock_ele = req->locks;\n\n\tksmbd_debug(SMB, \"lock count is %d\\n\", lock_count);\n\tif (!lock_count) {\n\t\terr = -EINVAL;\n\t\tgoto out2;\n\t}\n\n\tfor (i = 0; i < lock_count; i++) {\n\t\tflags = le32_to_cpu(lock_ele[i].Flags);\n\n\t\tflock = smb_flock_init(filp);\n\t\tif (!flock)\n\t\t\tgoto out;\n\n\t\tcmd = smb2_set_flock_flags(flock, flags);\n\n\t\tlock_start = le64_to_cpu(lock_ele[i].Offset);\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_start > U64_MAX - lock_length) {\n\t\t\tpr_err(\"Invalid lock range requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lock_start > OFFSET_MAX)\n\t\t\tflock->fl_start = OFFSET_MAX;\n\t\telse\n\t\t\tflock->fl_start = lock_start;\n\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_length > OFFSET_MAX - flock->fl_start)\n\t\t\tlock_length = OFFSET_MAX - flock->fl_start;\n\n\t\tflock->fl_end = flock->fl_start + lock_length;\n\n\t\tif (flock->fl_end < flock->fl_start) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"the end offset(%llx) is smaller than the start offset(%llx)\\n\",\n\t\t\t\t    flock->fl_end, flock->fl_start);\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check conflict locks in one request */\n\t\tlist_for_each_entry(cmp_lock, &lock_list, llist) {\n\t\t\tif (cmp_lock->fl->fl_start <= flock->fl_start &&\n\t\t\t    cmp_lock->fl->fl_end >= flock->fl_end) {\n\t\t\t\tif (cmp_lock->fl->fl_type != F_UNLCK &&\n\t\t\t\t    flock->fl_type != F_UNLCK) {\n\t\t\t\t\tpr_err(\"conflict two locks in one request\\n\");\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsmb_lock = smb2_lock_init(flock, cmd, flags, &lock_list);\n\t\tif (!smb_lock) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tif (smb_lock->cmd < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_MASK)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((prior_lock & (SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_SHARED) &&\n\t\t     smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) ||\n\t\t    (prior_lock == SMB2_LOCKFLAG_UNLOCK &&\n\t\t     !(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprior_lock = smb_lock->flags;\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) &&\n\t\t    !(smb_lock->flags & SMB2_LOCKFLAG_FAIL_IMMEDIATELY))\n\t\t\tgoto no_check_cl;\n\n\t\tnolock = 1;\n\t\t/* check locks in connection list */\n\t\tread_lock(&conn_list_lock);\n\t\tlist_for_each_entry(conn, &conn_list, conns_list) {\n\t\t\tspin_lock(&conn->llist_lock);\n\t\t\tlist_for_each_entry_safe(cmp_lock, tmp2, &conn->lock_list, clist) {\n\t\t\t\tif (file_inode(cmp_lock->fl->fl_file) !=\n\t\t\t\t    file_inode(smb_lock->fl->fl_file))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (smb_lock->fl->fl_type == F_UNLCK) {\n\t\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file &&\n\t\t\t\t\t    cmp_lock->start == smb_lock->start &&\n\t\t\t\t\t    cmp_lock->end == smb_lock->end &&\n\t\t\t\t\t    !lock_defer_pending(cmp_lock->fl)) {\n\t\t\t\t\t\tnolock = 0;\n\t\t\t\t\t\tlist_del(&cmp_lock->flist);\n\t\t\t\t\t\tlist_del(&cmp_lock->clist);\n\t\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\t\tread_unlock(&conn_list_lock);\n\n\t\t\t\t\t\tlocks_free_lock(cmp_lock->fl);\n\t\t\t\t\t\tkfree(cmp_lock);\n\t\t\t\t\t\tgoto out_check_cl;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file) {\n\t\t\t\t\tif (smb_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tif (cmp_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* check zero byte lock range */\n\t\t\t\tif (cmp_lock->zero_len && !smb_lock->zero_len &&\n\t\t\t\t    cmp_lock->start > smb_lock->start &&\n\t\t\t\t    cmp_lock->start < smb_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"previous lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (smb_lock->zero_len && !cmp_lock->zero_len &&\n\t\t\t\t    smb_lock->start > cmp_lock->start &&\n\t\t\t\t    smb_lock->start < cmp_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"current lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (((cmp_lock->start <= smb_lock->start &&\n\t\t\t\t      cmp_lock->end > smb_lock->start) ||\n\t\t\t\t     (cmp_lock->start < smb_lock->end &&\n\t\t\t\t      cmp_lock->end >= smb_lock->end)) &&\n\t\t\t\t    !cmp_lock->zero_len && !smb_lock->zero_len) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"Not allow lock operation on exclusive lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&conn->llist_lock);\n\t\t}\n\t\tread_unlock(&conn_list_lock);\nout_check_cl:\n\t\tif (smb_lock->fl->fl_type == F_UNLCK && nolock) {\n\t\t\tpr_err(\"Try to unlock nolocked range\\n\");\n\t\t\trsp->hdr.Status = STATUS_RANGE_NOT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\nno_check_cl:\n\t\tif (smb_lock->zero_len) {\n\t\t\terr = 0;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tflock = smb_lock->fl;\n\t\tlist_del(&smb_lock->llist);\nretry:\n\t\trc = vfs_lock_file(filp, smb_lock->cmd, flock, NULL);\nskip:\n\t\tif (flags & SMB2_LOCKFLAG_UNLOCK) {\n\t\t\tif (!rc) {\n\t\t\t\tksmbd_debug(SMB, \"File unlocked\\n\");\n\t\t\t} else if (rc == -ENOENT) {\n\t\t\t\trsp->hdr.Status = STATUS_NOT_LOCKED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlocks_free_lock(flock);\n\t\t\tkfree(smb_lock);\n\t\t} else {\n\t\t\tif (rc == FILE_LOCK_DEFERRED) {\n\t\t\t\tvoid **argv;\n\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"would have to wait for getting lock\\n\");\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\n\t\t\t\targv = kmalloc(sizeof(void *), GFP_KERNEL);\n\t\t\t\tif (!argv) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\targv[0] = flock;\n\n\t\t\t\trc = setup_async_work(work,\n\t\t\t\t\t\t      smb2_remove_blocked_lock,\n\t\t\t\t\t\t      argv);\n\t\t\t\tif (rc) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_add(&work->fp_entry, &fp->blocked_works);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\n\t\t\t\tsmb2_send_interim_resp(work, STATUS_PENDING);\n\n\t\t\t\tksmbd_vfs_posix_lock_wait(flock);\n\n\t\t\t\tif (work->state != KSMBD_WORK_ACTIVE) {\n\t\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\t\tlocks_free_lock(flock);\n\n\t\t\t\t\tif (work->state == KSMBD_WORK_CANCELLED) {\n\t\t\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\t\tSTATUS_CANCELLED;\n\t\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\t\tsmb2_send_interim_resp(work,\n\t\t\t\t\t\t\t\t       STATUS_CANCELLED);\n\t\t\t\t\t\twork->send_no_response = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tinit_smb2_rsp_hdr(work);\n\t\t\t\t\tsmb2_set_err_rsp(work);\n\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\tSTATUS_RANGE_NOT_LOCKED;\n\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\tgoto out2;\n\t\t\t\t}\n\n\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\tgoto retry;\n\t\t\t} else if (!rc) {\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tlist_add_tail(&smb_lock->flist,\n\t\t\t\t\t      &fp->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\t\t\t\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (atomic_read(&fp->f_ci->op_count) > 1)\n\t\tsmb_break_all_oplock(work, fp);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlist_del(&smb_lock->llist);\n\t\tkfree(smb_lock);\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &rollback_list, llist) {\n\t\tstruct file_lock *rlock = NULL;\n\n\t\trlock = smb_flock_init(filp);\n\t\trlock->fl_type = F_UNLCK;\n\t\trlock->fl_start = smb_lock->start;\n\t\trlock->fl_end = smb_lock->end;\n\n\t\trc = vfs_lock_file(filp, 0, rlock, NULL);\n\t\tif (rc)\n\t\t\tpr_err(\"rollback unlock fail : %d\\n\", rc);\n\n\t\tlist_del(&smb_lock->llist);\n\t\tspin_lock(&work->conn->llist_lock);\n\t\tif (!list_empty(&smb_lock->flist))\n\t\t\tlist_del(&smb_lock->flist);\n\t\tlist_del(&smb_lock->clist);\n\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlocks_free_lock(rlock);\n\t\tkfree(smb_lock);\n\t}\nout2:\n\tksmbd_debug(SMB, \"failed in taking lock(flags : %x), err : %d\\n\", flags, err);\n\n\tif (!rsp->hdr.Status) {\n\t\tif (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (err == -ENOMEM)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_LOCK_NOT_GRANTED;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\nstatic int fsctl_copychunk(struct ksmbd_work *work,\n\t\t\t   struct copychunk_ioctl_req *ci_req,\n\t\t\t   unsigned int cnt_code,\n\t\t\t   unsigned int input_count,\n\t\t\t   unsigned long long volatile_id,\n\t\t\t   unsigned long long persistent_id,\n\t\t\t   struct smb2_ioctl_rsp *rsp)\n{\n\tstruct copychunk_ioctl_rsp *ci_rsp;\n\tstruct ksmbd_file *src_fp = NULL, *dst_fp = NULL;\n\tstruct srv_copychunk *chunks;\n\tunsigned int i, chunk_count, chunk_count_written = 0;\n\tunsigned int chunk_size_written = 0;\n\tloff_t total_size_written = 0;\n\tint ret = 0;\n\n\tci_rsp = (struct copychunk_ioctl_rsp *)&rsp->Buffer[0];\n\n\trsp->VolatileFileId = volatile_id;\n\trsp->PersistentFileId = persistent_id;\n\tci_rsp->ChunksWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_count());\n\tci_rsp->ChunkBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_size());\n\tci_rsp->TotalBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_total_size());\n\n\tchunks = (struct srv_copychunk *)&ci_req->Chunks[0];\n\tchunk_count = le32_to_cpu(ci_req->ChunkCount);\n\tif (chunk_count == 0)\n\t\tgoto out;\n\ttotal_size_written = 0;\n\n\t/* verify the SRV_COPYCHUNK_COPY packet */\n\tif (chunk_count > ksmbd_server_side_copy_max_chunk_count() ||\n\t    input_count < offsetof(struct copychunk_ioctl_req, Chunks) +\n\t     chunk_count * sizeof(struct srv_copychunk)) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tif (le32_to_cpu(chunks[i].Length) == 0 ||\n\t\t    le32_to_cpu(chunks[i].Length) > ksmbd_server_side_copy_max_chunk_size())\n\t\t\tbreak;\n\t\ttotal_size_written += le32_to_cpu(chunks[i].Length);\n\t}\n\n\tif (i < chunk_count ||\n\t    total_size_written > ksmbd_server_side_copy_max_total_size()) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tsrc_fp = ksmbd_lookup_foreign_fd(work,\n\t\t\t\t\t le64_to_cpu(ci_req->ResumeKey[0]));\n\tdst_fp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tret = -EINVAL;\n\tif (!src_fp ||\n\t    src_fp->persistent_id != le64_to_cpu(ci_req->ResumeKey[1])) {\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\tgoto out;\n\t}\n\n\tif (!dst_fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FILE_READ_DATA should only be included in\n\t * the FSCTL_COPYCHUNK case\n\t */\n\tif (cnt_code == FSCTL_COPYCHUNK &&\n\t    !(dst_fp->daccess & (FILE_READ_DATA_LE | FILE_GENERIC_READ_LE))) {\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tgoto out;\n\t}\n\n\tret = ksmbd_vfs_copy_file_ranges(work, src_fp, dst_fp,\n\t\t\t\t\t chunks, chunk_count,\n\t\t\t\t\t &chunk_count_written,\n\t\t\t\t\t &chunk_size_written,\n\t\t\t\t\t &total_size_written);\n\tif (ret < 0) {\n\t\tif (ret == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tif (ret == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (ret == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\telse if (ret == -EFBIG || ret == -ENOSPC)\n\t\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\t\telse if (ret == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (ret == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\telse if (ret == -E2BIG)\n\t\t\trsp->hdr.Status = STATUS_INVALID_VIEW_SIZE;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t}\n\n\tci_rsp->ChunksWritten = cpu_to_le32(chunk_count_written);\n\tci_rsp->ChunkBytesWritten = cpu_to_le32(chunk_size_written);\n\tci_rsp->TotalBytesWritten = cpu_to_le32(total_size_written);\nout:\n\tksmbd_fd_put(work, src_fp);\n\tksmbd_fd_put(work, dst_fp);\n\treturn ret;\n}\n\nstatic __be32 idev_ipv4_address(struct in_device *idev)\n{\n\t__be32 addr = 0;\n\n\tstruct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\tin_dev_for_each_ifa_rcu(ifa, idev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\n\t\taddr = ifa->ifa_address;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn addr;\n}\n\nstatic int fsctl_query_iface_info_ioctl(struct ksmbd_conn *conn,\n\t\t\t\t\tstruct smb2_ioctl_rsp *rsp,\n\t\t\t\t\tunsigned int out_buf_len)\n{\n\tstruct network_interface_info_ioctl_rsp *nii_rsp = NULL;\n\tint nbytes = 0;\n\tstruct net_device *netdev;\n\tstruct sockaddr_storage_rsp *sockaddr_storage;\n\tunsigned int flags;\n\tunsigned long long speed;\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, netdev) {\n\t\tbool ipv4_set = false;\n\n\t\tif (netdev->type == ARPHRD_LOOPBACK)\n\t\t\tcontinue;\n\n\t\tflags = dev_get_flags(netdev);\n\t\tif (!(flags & IFF_RUNNING))\n\t\t\tcontinue;\nipv6_retry:\n\t\tif (out_buf_len <\n\t\t    nbytes + sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tnii_rsp = (struct network_interface_info_ioctl_rsp *)\n\t\t\t\t&rsp->Buffer[nbytes];\n\t\tnii_rsp->IfIndex = cpu_to_le32(netdev->ifindex);\n\n\t\tnii_rsp->Capability = 0;\n\t\tif (netdev->real_num_tx_queues > 1)\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RSS_CAPABLE);\n\t\tif (ksmbd_rdma_capable_netdev(netdev))\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RDMA_CAPABLE);\n\n\t\tnii_rsp->Next = cpu_to_le32(152);\n\t\tnii_rsp->Reserved = 0;\n\n\t\tif (netdev->ethtool_ops->get_link_ksettings) {\n\t\t\tstruct ethtool_link_ksettings cmd;\n\n\t\t\tnetdev->ethtool_ops->get_link_ksettings(netdev, &cmd);\n\t\t\tspeed = cmd.base.speed;\n\t\t} else {\n\t\t\tksmbd_debug(SMB, \"%s %s\\n\", netdev->name,\n\t\t\t\t    \"speed is unknown, defaulting to 1Gb/sec\");\n\t\t\tspeed = SPEED_1000;\n\t\t}\n\n\t\tspeed *= 1000000;\n\t\tnii_rsp->LinkSpeed = cpu_to_le64(speed);\n\n\t\tsockaddr_storage = (struct sockaddr_storage_rsp *)\n\t\t\t\t\tnii_rsp->SockAddr_Storage;\n\t\tmemset(sockaddr_storage, 0, 128);\n\n\t\tif (!ipv4_set) {\n\t\t\tstruct in_device *idev;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORK);\n\t\t\tsockaddr_storage->addr4.Port = 0;\n\n\t\t\tidev = __in_dev_get_rtnl(netdev);\n\t\t\tif (!idev)\n\t\t\t\tcontinue;\n\t\t\tsockaddr_storage->addr4.IPv4address =\n\t\t\t\t\t\tidev_ipv4_address(idev);\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t\tipv4_set = true;\n\t\t\tgoto ipv6_retry;\n\t\t} else {\n\t\t\tstruct inet6_dev *idev6;\n\t\t\tstruct inet6_ifaddr *ifa;\n\t\t\t__u8 *ipv6_addr = sockaddr_storage->addr6.IPv6address;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORKV6);\n\t\t\tsockaddr_storage->addr6.Port = 0;\n\t\t\tsockaddr_storage->addr6.FlowInfo = 0;\n\n\t\t\tidev6 = __in6_dev_get(netdev);\n\t\t\tif (!idev6)\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry(ifa, &idev6->addr_list, if_list) {\n\t\t\t\tif (ifa->flags & (IFA_F_TENTATIVE |\n\t\t\t\t\t\t\tIFA_F_DEPRECATED))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(ipv6_addr, ifa->addr.s6_addr, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsockaddr_storage->addr6.ScopeId = 0;\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t}\n\t}\n\trtnl_unlock();\n\n\t/* zero if this is last one */\n\tif (nii_rsp)\n\t\tnii_rsp->Next = 0;\n\n\trsp->PersistentFileId = SMB2_NO_FID;\n\trsp->VolatileFileId = SMB2_NO_FID;\n\treturn nbytes;\n}\n\nstatic int fsctl_validate_negotiate_info(struct ksmbd_conn *conn,\n\t\t\t\t\t struct validate_negotiate_info_req *neg_req,\n\t\t\t\t\t struct validate_negotiate_info_rsp *neg_rsp,\n\t\t\t\t\t unsigned int in_buf_len)\n{\n\tint ret = 0;\n\tint dialect;\n\n\tif (in_buf_len < offsetof(struct validate_negotiate_info_req, Dialects) +\n\t\t\tle16_to_cpu(neg_req->DialectCount) * sizeof(__le16))\n\t\treturn -EINVAL;\n\n\tdialect = ksmbd_lookup_dialect_by_id(neg_req->Dialects,\n\t\t\t\t\t     neg_req->DialectCount);\n\tif (dialect == BAD_PROT_ID || dialect != conn->dialect) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (strncmp(neg_req->Guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le16_to_cpu(neg_req->SecurityMode) != conn->cli_sec_mode) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le32_to_cpu(neg_req->Capabilities) != conn->cli_cap) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tneg_rsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\tmemset(neg_rsp->Guid, 0, SMB2_CLIENT_GUID_SIZE);\n\tneg_rsp->SecurityMode = cpu_to_le16(conn->srv_sec_mode);\n\tneg_rsp->Dialect = cpu_to_le16(conn->dialect);\nerr_out:\n\treturn ret;\n}\n\nstatic int fsctl_query_allocated_ranges(struct ksmbd_work *work, u64 id,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_req,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_rsp,\n\t\t\t\t\tunsigned int in_count, unsigned int *out_count)\n{\n\tstruct ksmbd_file *fp;\n\tloff_t start, length;\n\tint ret = 0;\n\n\t*out_count = 0;\n\tif (in_count == 0)\n\t\treturn -EINVAL;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tstart = le64_to_cpu(qar_req->file_offset);\n\tlength = le64_to_cpu(qar_req->length);\n\n\tret = ksmbd_vfs_fqar_lseek(fp, start, length,\n\t\t\t\t   qar_rsp, in_count, out_count);\n\tif (ret && ret != -E2BIG)\n\t\t*out_count = 0;\n\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_pipe_transceive(struct ksmbd_work *work, u64 id,\n\t\t\t\t unsigned int out_buf_len,\n\t\t\t\t struct smb2_ioctl_req *req,\n\t\t\t\t struct smb2_ioctl_rsp *rsp)\n{\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tchar *data_buf = (char *)&req->Buffer[0];\n\tint nbytes = 0;\n\n\trpc_resp = ksmbd_rpc_ioctl(work->sess, id, data_buf,\n\t\t\t\t   le32_to_cpu(req->InputCount));\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_SOME_NOT_MAPPED) {\n\t\t\t/*\n\t\t\t * set STATUS_SOME_NOT_MAPPED response\n\t\t\t * for unknown domain sid.\n\t\t\t */\n\t\t\trsp->hdr.Status = STATUS_SOME_NOT_MAPPED;\n\t\t} else if (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t} else if (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\tif (rpc_resp->payload_sz > out_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\tnbytes = out_buf_len;\n\t\t}\n\n\t\tif (!rpc_resp->payload_sz) {\n\t\t\trsp->hdr.Status =\n\t\t\t\tSTATUS_UNEXPECTED_IO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy((char *)rsp->Buffer, rpc_resp->payload, nbytes);\n\t}\nout:\n\tkvfree(rpc_resp);\n\treturn nbytes;\n}\n\nstatic inline int fsctl_set_sparse(struct ksmbd_work *work, u64 id,\n\t\t\t\t   struct file_sparse *sparse)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tint ret = 0;\n\t__le32 old_fattr;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\n\told_fattr = fp->f_ci->m_fattr;\n\tif (sparse->SetSparse)\n\t\tfp->f_ci->m_fattr |= FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\telse\n\t\tfp->f_ci->m_fattr &= ~FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\n\tif (fp->f_ci->m_fattr != old_fattr &&\n\t    test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {\n\t\tstruct xattr_dos_attrib da;\n\n\t\tret = ksmbd_vfs_get_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tret = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret)\n\t\t\tfp->f_ci->m_fattr = old_fattr;\n\t}\n\nout:\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_request_resume_key(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_ioctl_req *req,\n\t\t\t\t    struct resume_key_ioctl_rsp *key_rsp)\n{\n\tstruct ksmbd_file *fp;\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tmemset(key_rsp, 0, sizeof(*key_rsp));\n\tkey_rsp->ResumeKey[0] = req->VolatileFileId;\n\tkey_rsp->ResumeKey[1] = req->PersistentFileId;\n\tksmbd_fd_put(work, fp);\n\n\treturn 0;\n}\n\n/**\n * smb2_ioctl() - handler for smb2 ioctl command\n * @work:\tsmb work containing ioctl command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_ioctl(struct ksmbd_work *work)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tunsigned int cnt_code, nbytes = 0, out_buf_len, in_buf_len;\n\tu64 id = KSMBD_NO_FID;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint ret = 0;\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id))\n\t\tid = req->VolatileFileId;\n\n\tif (req->Flags != cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL)) {\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tcnt_code = le32_to_cpu(req->CtlCode);\n\tret = smb2_calc_max_out_buf_len(work, 48,\n\t\t\t\t\tle32_to_cpu(req->MaxOutputResponse));\n\tif (ret < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tgoto out;\n\t}\n\tout_buf_len = (unsigned int)ret;\n\tin_buf_len = le32_to_cpu(req->InputCount);\n\n\tswitch (cnt_code) {\n\tcase FSCTL_DFS_GET_REFERRALS:\n\tcase FSCTL_DFS_GET_REFERRALS_EX:\n\t\t/* Not support DFS yet */\n\t\trsp->hdr.Status = STATUS_FS_DRIVER_REQUIRED;\n\t\tgoto out;\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tstruct file_object_buf_type1_ioctl_rsp *obj_buf;\n\n\t\tnbytes = sizeof(struct file_object_buf_type1_ioctl_rsp);\n\t\tobj_buf = (struct file_object_buf_type1_ioctl_rsp *)\n\t\t\t&rsp->Buffer[0];\n\n\t\t/*\n\t\t * TODO: This is dummy implementation to pass smbtorture\n\t\t * Need to check correct response later\n\t\t */\n\t\tmemset(obj_buf->ObjectId, 0x0, 16);\n\t\tmemset(obj_buf->BirthVolumeId, 0x0, 16);\n\t\tmemset(obj_buf->BirthObjectId, 0x0, 16);\n\t\tmemset(obj_buf->DomainId, 0x0, 16);\n\n\t\tbreak;\n\t}\n\tcase FSCTL_PIPE_TRANSCEIVE:\n\t\tout_buf_len = min_t(u32, KSMBD_IPC_MAX_PAYLOAD, out_buf_len);\n\t\tnbytes = fsctl_pipe_transceive(work, id, out_buf_len, req, rsp);\n\t\tbreak;\n\tcase FSCTL_VALIDATE_NEGOTIATE_INFO:\n\t\tif (conn->dialect < SMB30_PROT_ID) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct validate_negotiate_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tif (out_buf_len < sizeof(struct validate_negotiate_info_rsp))\n\t\t\treturn -EINVAL;\n\n\t\tret = fsctl_validate_negotiate_info(conn,\n\t\t\t(struct validate_negotiate_info_req *)&req->Buffer[0],\n\t\t\t(struct validate_negotiate_info_rsp *)&rsp->Buffer[0],\n\t\t\tin_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tnbytes = sizeof(struct validate_negotiate_info_rsp);\n\t\trsp->PersistentFileId = SMB2_NO_FID;\n\t\trsp->VolatileFileId = SMB2_NO_FID;\n\t\tbreak;\n\tcase FSCTL_QUERY_NETWORK_INTERFACE_INFO:\n\t\tret = fsctl_query_iface_info_ioctl(conn, rsp, out_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnbytes = ret;\n\t\tbreak;\n\tcase FSCTL_REQUEST_RESUME_KEY:\n\t\tif (out_buf_len < sizeof(struct resume_key_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_request_resume_key(work, req,\n\t\t\t\t\t       (struct resume_key_ioctl_rsp *)&rsp->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\tnbytes = sizeof(struct resume_key_ioctl_rsp);\n\t\tbreak;\n\tcase FSCTL_COPYCHUNK:\n\tcase FSCTL_COPYCHUNK_WRITE:\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct copychunk_ioctl_req)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (out_buf_len < sizeof(struct copychunk_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = sizeof(struct copychunk_ioctl_rsp);\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\tfsctl_copychunk(work,\n\t\t\t\t(struct copychunk_ioctl_req *)&req->Buffer[0],\n\t\t\t\tle32_to_cpu(req->CtlCode),\n\t\t\t\tle32_to_cpu(req->InputCount),\n\t\t\t\treq->VolatileFileId,\n\t\t\t\treq->PersistentFileId,\n\t\t\t\trsp);\n\t\tbreak;\n\tcase FSCTL_SET_SPARSE:\n\t\tif (in_buf_len < sizeof(struct file_sparse)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_set_sparse(work, id,\n\t\t\t\t       (struct file_sparse *)&req->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase FSCTL_SET_ZERO_DATA:\n\t{\n\t\tstruct file_zero_data_information *zero_data;\n\t\tstruct ksmbd_file *fp;\n\t\tloff_t off, len;\n\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct file_zero_data_information)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tzero_data =\n\t\t\t(struct file_zero_data_information *)&req->Buffer[0];\n\n\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\toff = le64_to_cpu(zero_data->FileOffset);\n\t\tlen = le64_to_cpu(zero_data->BeyondFinalZero) - off;\n\n\t\tret = ksmbd_vfs_zero_data(work, fp, off, len);\n\t\tksmbd_fd_put(work, fp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t\tif (in_buf_len < sizeof(struct file_allocated_range_buffer)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_query_allocated_ranges(work, id,\n\t\t\t(struct file_allocated_range_buffer *)&req->Buffer[0],\n\t\t\t(struct file_allocated_range_buffer *)&rsp->Buffer[0],\n\t\t\tout_buf_len /\n\t\t\tsizeof(struct file_allocated_range_buffer), &nbytes);\n\t\tif (ret == -E2BIG) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t} else if (ret < 0) {\n\t\t\tnbytes = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes *= sizeof(struct file_allocated_range_buffer);\n\t\tbreak;\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tstruct reparse_data_buffer *reparse_ptr;\n\t\tstruct ksmbd_file *fp;\n\n\t\treparse_ptr = (struct reparse_data_buffer *)&rsp->Buffer[0];\n\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp) {\n\t\t\tpr_err(\"not found fp!!\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\treparse_ptr->ReparseTag =\n\t\t\tsmb2_get_reparse_tag_special_file(file_inode(fp->filp)->i_mode);\n\t\treparse_ptr->ReparseDataLength = 0;\n\t\tksmbd_fd_put(work, fp);\n\t\tnbytes = sizeof(struct reparse_data_buffer);\n\t\tbreak;\n\t}\n\tcase FSCTL_DUPLICATE_EXTENTS_TO_FILE:\n\t{\n\t\tstruct ksmbd_file *fp_in, *fp_out = NULL;\n\t\tstruct duplicate_extents_to_file *dup_ext;\n\t\tloff_t src_off, dst_off, length, cloned;\n\n\t\tif (in_buf_len < sizeof(struct duplicate_extents_to_file)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdup_ext = (struct duplicate_extents_to_file *)&req->Buffer[0];\n\n\t\tfp_in = ksmbd_lookup_fd_slow(work, dup_ext->VolatileFileHandle,\n\t\t\t\t\t     dup_ext->PersistentFileHandle);\n\t\tif (!fp_in) {\n\t\t\tpr_err(\"not found file handle in duplicate extent to file\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfp_out = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp_out) {\n\t\t\tpr_err(\"not found fp\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto dup_ext_out;\n\t\t}\n\n\t\tsrc_off = le64_to_cpu(dup_ext->SourceFileOffset);\n\t\tdst_off = le64_to_cpu(dup_ext->TargetFileOffset);\n\t\tlength = le64_to_cpu(dup_ext->ByteCount);\n\t\tcloned = vfs_clone_file_range(fp_in->filp, src_off, fp_out->filp,\n\t\t\t\t\t      dst_off, length, 0);\n\t\tif (cloned == -EXDEV || cloned == -EOPNOTSUPP) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto dup_ext_out;\n\t\t} else if (cloned != length) {\n\t\t\tcloned = vfs_copy_file_range(fp_in->filp, src_off,\n\t\t\t\t\t\t     fp_out->filp, dst_off, length, 0);\n\t\t\tif (cloned != length) {\n\t\t\t\tif (cloned < 0)\n\t\t\t\t\tret = cloned;\n\t\t\t\telse\n\t\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\ndup_ext_out:\n\t\tksmbd_fd_put(work, fp_in);\n\t\tksmbd_fd_put(work, fp_out);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tksmbd_debug(SMB, \"not implemented yet ioctl command 0x%x\\n\",\n\t\t\t    cnt_code);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trsp->CtlCode = cpu_to_le32(cnt_code);\n\trsp->InputCount = cpu_to_le32(0);\n\trsp->InputOffset = cpu_to_le32(112);\n\trsp->OutputOffset = cpu_to_le32(112);\n\trsp->OutputCount = cpu_to_le32(nbytes);\n\trsp->StructureSize = cpu_to_le16(49);\n\trsp->Reserved = cpu_to_le16(0);\n\trsp->Flags = cpu_to_le32(0);\n\trsp->Reserved2 = cpu_to_le32(0);\n\tinc_rfc1001_len(work->response_buf, 48 + nbytes);\n\n\treturn 0;\n\nout:\n\tif (ret == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (ret == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\telse if (ret == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\telse if (ret == -ENOSPC)\n\t\trsp->hdr.Status = STATUS_BUFFER_TOO_SMALL;\n\telse if (ret < 0 || rsp->hdr.Status == 0)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\tsmb2_set_err_rsp(work);\n\treturn 0;\n}\n\n/**\n * smb20_oplock_break_ack() - handler for smb2.0 oplock break command\n * @work:\tsmb work containing oplock break command buffer\n *\n * Return:\t0\n */\nstatic void smb20_oplock_break_ack(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_file *fp;\n\tstruct oplock_info *opinfo = NULL;\n\t__le32 err = 0;\n\tint ret = 0;\n\tu64 volatile_id, persistent_id;\n\tchar req_oplevel = 0, rsp_oplevel = 0;\n\tunsigned int oplock_change_type;\n\n\tvolatile_id = req->VolatileFid;\n\tpersistent_id = req->PersistentFid;\n\treq_oplevel = req->OplockLevel;\n\tksmbd_debug(OPLOCK, \"v_id %llu, p_id %llu request oplock level %d\\n\",\n\t\t    volatile_id, persistent_id, req_oplevel);\n\n\tfp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tif (!fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn;\n\t}\n\n\topinfo = opinfo_get(fp);\n\tif (!opinfo) {\n\t\tpr_err(\"unexpected null oplock_info\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn;\n\t}\n\n\tif (opinfo->level == SMB2_OPLOCK_LEVEL_NONE) {\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tgoto err_out;\n\t}\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tksmbd_debug(SMB, \"unexpected oplock state 0x%x\\n\", opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t    (req_oplevel != SMB2_OPLOCK_LEVEL_II &&\n\t     req_oplevel != SMB2_OPLOCK_LEVEL_NONE)) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t   req_oplevel != SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t} else if (req_oplevel == SMB2_OPLOCK_LEVEL_II ||\n\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t    req_oplevel == SMB2_OPLOCK_LEVEL_II) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_READ;\n\t\t} else if ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t\t    opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else {\n\t\t\toplock_change_type = 0;\n\t\t}\n\t} else {\n\t\toplock_change_type = 0;\n\t}\n\n\tswitch (oplock_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_II;\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown oplock change 0x%x -> 0x%x\\n\",\n\t\t       opinfo->level, rsp_oplevel);\n\t}\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\trsp->StructureSize = cpu_to_le16(24);\n\trsp->OplockLevel = rsp_oplevel;\n\trsp->Reserved = 0;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFid = volatile_id;\n\trsp->PersistentFid = persistent_id;\n\tinc_rfc1001_len(work->response_buf, 24);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\tsmb2_set_err_rsp(work);\n}\n\nstatic int check_lease_state(struct lease *lease, __le32 req_state)\n{\n\tif ((lease->new_state ==\n\t     (SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE)) &&\n\t    !(req_state & SMB2_LEASE_WRITE_CACHING_LE)) {\n\t\tlease->new_state = req_state;\n\t\treturn 0;\n\t}\n\n\tif (lease->new_state == req_state)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * smb21_lease_break_ack() - handler for smb2.1 lease break command\n * @work:\tsmb work containing lease break command buffer\n *\n * Return:\t0\n */\nstatic void smb21_lease_break_ack(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_lease_ack *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lease_ack *rsp = smb2_get_msg(work->response_buf);\n\tstruct oplock_info *opinfo;\n\t__le32 err = 0;\n\tint ret = 0;\n\tunsigned int lease_change_type;\n\t__le32 lease_state;\n\tstruct lease *lease;\n\n\tksmbd_debug(OPLOCK, \"smb21 lease break, lease state(0x%x)\\n\",\n\t\t    le32_to_cpu(req->LeaseState));\n\topinfo = lookup_lease_in_table(conn, req->LeaseKey);\n\tif (!opinfo) {\n\t\tksmbd_debug(OPLOCK, \"file not opened\\n\");\n\t\tsmb2_set_err_rsp(work);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\treturn;\n\t}\n\tlease = opinfo->o_lease;\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tpr_err(\"unexpected lease break state 0x%x\\n\",\n\t\t       opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif (check_lease_state(lease, req->LeaseState)) {\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\t\tksmbd_debug(OPLOCK,\n\t\t\t    \"req lease state: 0x%x, expected state: 0x%x\\n\",\n\t\t\t    req->LeaseState, lease->new_state);\n\t\tgoto err_out;\n\t}\n\n\tif (!atomic_read(&opinfo->breaking_cnt)) {\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\t/* check for bad lease state */\n\tif (req->LeaseState &\n\t    (~(SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE))) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\telse\n\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else if (lease->state == SMB2_LEASE_READ_CACHING_LE &&\n\t\t   req->LeaseState != SMB2_LEASE_NONE_LE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else {\n\t\t/* valid lease state changes */\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif (req->LeaseState == SMB2_LEASE_NONE_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else if (req->LeaseState & SMB2_LEASE_READ_CACHING_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_READ;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_HANDLE_TO_READ;\n\t\t} else {\n\t\t\tlease_change_type = 0;\n\t\t}\n\t}\n\n\tswitch (lease_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_HANDLE_TO_READ:\n\t\tret = opinfo_read_handle_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"unknown lease change 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t}\n\n\tlease_state = lease->state;\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\topinfo_put(opinfo);\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\trsp->StructureSize = cpu_to_le16(36);\n\trsp->Reserved = 0;\n\trsp->Flags = 0;\n\tmemcpy(rsp->LeaseKey, req->LeaseKey, 16);\n\trsp->LeaseState = lease_state;\n\trsp->LeaseDuration = 0;\n\tinc_rfc1001_len(work->response_buf, 36);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\n\topinfo_put(opinfo);\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * smb2_oplock_break() - dispatcher for smb2.0 and 2.1 oplock/lease break\n * @work:\tsmb work containing oplock/lease break command buffer\n *\n * Return:\t0\n */\nint smb2_oplock_break(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\n\tswitch (le16_to_cpu(req->StructureSize)) {\n\tcase OP_BREAK_STRUCT_SIZE_20:\n\t\tsmb20_oplock_break_ack(work);\n\t\tbreak;\n\tcase OP_BREAK_STRUCT_SIZE_21:\n\t\tsmb21_lease_break_ack(work);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"invalid break cmd %d\\n\",\n\t\t\t    le16_to_cpu(req->StructureSize));\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_notify() - handler for smb2 notify request\n * @work:   smb work containing notify command buffer\n *\n * Return:      0\n */\nint smb2_notify(struct ksmbd_work *work)\n{\n\tstruct smb2_change_notify_req *req;\n\tstruct smb2_change_notify_rsp *rsp;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (work->next_smb2_rcv_hdr_off && req->hdr.NextCommand) {\n\t\trsp->hdr.Status = STATUS_INTERNAL_ERROR;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\trsp->hdr.Status = STATUS_NOT_IMPLEMENTED;\n\treturn 0;\n}\n\n/**\n * smb2_is_sign_req() - handler for checking packet signing status\n * @work:\tsmb work containing notify command buffer\n * @command:\tSMB2 command id\n *\n * Return:\ttrue if packed is signed, false otherwise\n */\nbool smb2_is_sign_req(struct ksmbd_work *work, unsigned int command)\n{\n\tstruct smb2_hdr *rcv_hdr2 = smb2_get_msg(work->request_buf);\n\n\tif ((rcv_hdr2->Flags & SMB2_FLAGS_SIGNED) &&\n\t    command != SMB2_NEGOTIATE_HE &&\n\t    command != SMB2_SESSION_SETUP_HE &&\n\t    command != SMB2_OPLOCK_BREAK_HE)\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * smb2_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb2_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, 1,\n\t\t\t\tsignature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb2_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tstruct smb2_hdr *req_hdr;\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[2];\n\tsize_t len;\n\tint n_vec = 1;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, n_vec,\n\t\t\t\t signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb3_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tchar *signing_key;\n\tstruct smb2_hdr *hdr;\n\tstruct channel *chann;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tif (le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tchann = lookup_chann_list(work->sess, conn);\n\t\tif (!chann)\n\t\t\treturn 0;\n\t\tsigning_key = chann->smb3signingkey;\n\t}\n\n\tif (!signing_key) {\n\t\tpr_err(\"SMB3 signing key is not generated\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb3_pdu(conn, signing_key, iov, 1, signature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb3_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb3_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *req_hdr, *hdr;\n\tstruct channel *chann;\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[2];\n\tint n_vec = 1;\n\tsize_t len;\n\tchar *signing_key;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (conn->binding == false &&\n\t    le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tchann = lookup_chann_list(work->sess, work->conn);\n\t\tif (!chann)\n\t\t\treturn;\n\t\tsigning_key = chann->smb3signingkey;\n\t}\n\n\tif (!signing_key)\n\t\treturn;\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb3_pdu(conn, signing_key, iov, n_vec, signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_preauth_hash_rsp() - handler for computing preauth hash on response\n * @work:   smb work containing response buffer\n *\n */\nvoid smb3_preauth_hash_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct smb2_hdr *req, *rsp;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (le16_to_cpu(req->Command) == SMB2_NEGOTIATE_HE &&\n\t    conn->preauth_info)\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE && sess) {\n\t\t__u8 *hash_value;\n\n\t\tif (conn->binding) {\n\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn;\n\t\t\thash_value = preauth_sess->Preauth_HashValue;\n\t\t} else {\n\t\t\thash_value = sess->Preauth_HashValue;\n\t\t\tif (!hash_value)\n\t\t\t\treturn;\n\t\t}\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t hash_value);\n\t}\n}\n\nstatic void fill_transform_hdr(void *tr_buf, char *old_buf, __le16 cipher_type)\n{\n\tstruct smb2_transform_hdr *tr_hdr = tr_buf + 4;\n\tstruct smb2_hdr *hdr = smb2_get_msg(old_buf);\n\tunsigned int orig_len = get_rfc1002_len(old_buf);\n\n\t/* tr_buf must be cleared by the caller */\n\ttr_hdr->ProtocolId = SMB2_TRANSFORM_PROTO_NUM;\n\ttr_hdr->OriginalMessageSize = cpu_to_le32(orig_len);\n\ttr_hdr->Flags = cpu_to_le16(TRANSFORM_FLAG_ENCRYPTED);\n\tif (cipher_type == SMB2_ENCRYPTION_AES128_GCM ||\n\t    cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_GCM_NONCE);\n\telse\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_CCM_NONCE);\n\tmemcpy(&tr_hdr->SessionId, &hdr->SessionId, 8);\n\tinc_rfc1001_len(tr_buf, sizeof(struct smb2_transform_hdr));\n\tinc_rfc1001_len(tr_buf, orig_len);\n}\n\nint smb3_encrypt_resp(struct ksmbd_work *work)\n{\n\tchar *buf = work->response_buf;\n\tstruct kvec iov[3];\n\tint rc = -ENOMEM;\n\tint buf_size = 0, rq_nvec = 2 + (work->aux_payload_sz ? 1 : 0);\n\n\tif (ARRAY_SIZE(iov) < rq_nvec)\n\t\treturn -ENOMEM;\n\n\twork->tr_buf = kzalloc(sizeof(struct smb2_transform_hdr) + 4, GFP_KERNEL);\n\tif (!work->tr_buf)\n\t\treturn rc;\n\n\t/* fill transform header */\n\tfill_transform_hdr(work->tr_buf, buf, work->conn->cipher_type);\n\n\tiov[0].iov_base = work->tr_buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tbuf_size += iov[0].iov_len - 4;\n\n\tiov[1].iov_base = buf + 4;\n\tiov[1].iov_len = get_rfc1002_len(buf);\n\tif (work->aux_payload_sz) {\n\t\tiov[1].iov_len = work->resp_hdr_sz - 4;\n\n\t\tiov[2].iov_base = work->aux_payload_buf;\n\t\tiov[2].iov_len = work->aux_payload_sz;\n\t\tbuf_size += iov[2].iov_len;\n\t}\n\tbuf_size += iov[1].iov_len;\n\twork->resp_hdr_sz = iov[1].iov_len;\n\n\trc = ksmbd_crypt_message(work->conn, iov, rq_nvec, 1);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf, iov[1].iov_base, iov[1].iov_len);\n\t*(__be32 *)work->tr_buf = cpu_to_be32(buf_size);\n\n\treturn rc;\n}\n\nbool smb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = smb2_get_msg(buf);\n\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}\n\nint smb3_decrypt_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess;\n\tchar *buf = work->request_buf;\n\tunsigned int pdu_length = get_rfc1002_len(buf);\n\tstruct kvec iov[2];\n\tint buf_data_size = pdu_length - sizeof(struct smb2_transform_hdr);\n\tstruct smb2_transform_hdr *tr_hdr = smb2_get_msg(buf);\n\tint rc = 0;\n\n\tif (buf_data_size < sizeof(struct smb2_hdr)) {\n\t\tpr_err(\"Transform message is too small (%u)\\n\",\n\t\t       pdu_length);\n\t\treturn -ECONNABORTED;\n\t}\n\n\tif (buf_data_size < le32_to_cpu(tr_hdr->OriginalMessageSize)) {\n\t\tpr_err(\"Transform message is broken\\n\");\n\t\treturn -ECONNABORTED;\n\t}\n\n\tsess = ksmbd_session_lookup_all(conn, le64_to_cpu(tr_hdr->SessionId));\n\tif (!sess) {\n\t\tpr_err(\"invalid session id(%llx) in transform header\\n\",\n\t\t       le64_to_cpu(tr_hdr->SessionId));\n\t\treturn -ECONNABORTED;\n\t}\n\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_base = buf + sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_len = buf_data_size;\n\trc = ksmbd_crypt_message(conn, iov, 2, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf + 4, iov[1].iov_base, buf_data_size);\n\t*(__be32 *)buf = cpu_to_be32(buf_data_size);\n\n\treturn rc;\n}\n\nbool smb3_11_final_sess_setup_resp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *rsp = smb2_get_msg(work->response_buf);\n\n\tif (conn->dialect < SMB30_PROT_ID)\n\t\treturn false;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp = ksmbd_resp_buf_next(work);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE &&\n\t    rsp->Status == STATUS_SUCCESS)\n\t\treturn true;\n\treturn false;\n}\n"], "filenames": ["fs/ksmbd/smb2pdu.c"], "buggy_code_start_loc": [6331], "buggy_code_end_loc": [6508], "fixing_code_start_loc": [6331], "fixing_code_end_loc": [6497], "type": "CWE-125", "message": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.18 before 5.18.18. fs/ksmbd/smb2pdu.c lacks length validation in the non-padding case in smb2_write.", "other": {"cve": {"id": "CVE-2022-47940", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-23T16:15:12.533", "lastModified": "2022-12-30T15:52:55.570", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.18 before 5.18.18. fs/ksmbd/smb2pdu.c lacks length validation in the non-padding case in smb2_write."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.15", "versionEndExcluding": "5.18.8", "matchCriteriaId": "53F8C813-FEB9-463B-B5EC-2B5FF680552B"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/12/23/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.18.18", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=158a66b245739e15858de42c0ba60fcf3de9b8e6", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/158a66b245739e15858de42c0ba60fcf3de9b8e6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/158a66b245739e15858de42c0ba60fcf3de9b8e6"}}