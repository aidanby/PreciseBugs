{"buggy_code": ["#!/usr/bin/python3\n\nimport os\nimport logging\nimport stat\nimport shutil\n\nfrom gi.repository import GLib, Gio, GObject\n\nimport util\nfrom util import FileType\nimport prefs\nimport warp_pb2\n\nFILE_INFOS = \",\".join([\n    \"standard::size\",\n    \"standard::allocated-size\",\n    \"standard::name\",\n    \"standard::type\",\n    \"standard::symlink-target\",\n    \"time::modified\",\n    \"time::modified-usec\",\n    \"unix::mode\"\n])\n\nFILE_INFOS_SINGLE_FILE = \",\".join([\n    \"standard::size\",\n    \"standard::allocated-size\",\n    \"standard::name\",\n    \"standard::type\",\n    \"standard::symlink-target\",\n    \"standard::content-type\",\n    \"time::modified\",\n    \"time::modified-usec\",\n    \"unix::mode\"\n])\n\nMODE_MASK = (stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n\nPROGRESS_UPDATE_FREQ = 2 * 1000 * 1000\n\ndef load_file_in_chunks(path):\n    gfile = Gio.File.new_for_path(path)\n\n    try:\n        stream = gfile.read(None)\n    except GLib.Error:\n        return\n\n    while True:\n        bytes = stream.read_bytes(1024 * 1024, None)\n        if bytes.get_size() == 0:\n            break\n\n        response = warp_pb2.RemoteMachineAvatar(avatar_chunk=bytes.get_data())\n        yield response\n\n    stream.close()\n\ndef make_symbolic_link(op, path, target):\n    tmppath = os.path.join(os.path.dirname(path), \"%s-%d-%d.tmp\" % (op.sender, op.start_time, GLib.get_monotonic_time()))\n    tmpfile = Gio.File.new_for_path(tmppath)\n\n    tmpfile.make_symbolic_link(target, None)\n    os.replace(tmpfile.get_path(), path)\n\n# This represents a file to be transferred (this is used by the sender)\nclass File:\n    def __init__(self, uri, basename, rel_path, size, file_type, symlink_target=None, file_mode=0, mtime=0, mtime_usec=0):\n        self.uri = uri\n        self.basename = basename\n        self.relative_path = rel_path\n        self.size = size\n        self.file_type = file_type\n        self.symlink_target = symlink_target\n        self.file_mode = file_mode\n        self.mtime = mtime\n        self.mtime_usec = mtime_usec\n\nclass FileSender(GObject.Object):\n    def __init__(self, op, timestamp, cancellable):\n        super(FileSender, self).__init__()\n        self.op = op\n        self.timestamp = timestamp\n        self.cancellable = cancellable\n        self.block_size = prefs.get_block_size()\n\n        self.error = None\n\n    def read_chunks(self):\n        for file in self.op.resolved_files:\n            if self.cancellable.is_set():\n                return # StopIteration as different behaviors between 3.5 and 3.7, this works as well.\n\n            logging.debug(\"get mtime: %lu.%u -- %s\" % (file.mtime, file.mtime_usec, file.relative_path))\n\n            ftime = warp_pb2.FileTime(mtime=file.mtime,\n                                      mtime_usec = file.mtime_usec)\n            if file.file_type == FileType.DIRECTORY:\n                yield warp_pb2.FileChunk(relative_path=file.relative_path,\n                                         file_type=file.file_type,\n                                         file_mode=file.file_mode,\n                                         time=ftime)\n            elif file.file_type == FileType.SYMBOLIC_LINK:\n                yield warp_pb2.FileChunk(relative_path=file.relative_path,\n                                         file_type=file.file_type,\n                                         symlink_target=file.symlink_target,\n                                         file_mode=file.file_mode,\n                                         time=ftime)\n            else:\n                stream = None\n\n                try:\n                    gfile = Gio.File.new_for_uri(file.uri)\n                    stream = gfile.read(None)\n\n                    file_done = False\n                    first_chunk = True\n\n                    while True:\n                        if file_done:\n                            break\n\n                        if self.cancellable.is_set():\n                            return\n\n                        b = stream.read_bytes(self.block_size, None)\n\n                        last_size_read = b.get_size()\n                        if last_size_read < self.block_size:\n                            file_done = True\n\n                        self.op.progress_tracker.update_progress(last_size_read)\n\n                        if first_chunk:\n                            time = ftime\n                            first_chunk = False\n                        else:\n                            time = None\n\n                        yield warp_pb2.FileChunk(relative_path=file.relative_path,\n                                                 file_type=file.file_type,\n                                                 chunk=b.get_data(),\n                                                 file_mode=file.file_mode,\n                                                 time=time)\n\n                    stream.close()\n                    continue\n                except Exception as e:\n                    try:\n                        # If we leave an io stream open, it locks the location.  For instance,\n                        # if this was a mounted location, we wouldn't be able to terminate until\n                        # we closed warp.\n                        stream.close()\n                    except:\n                        pass\n\n                    self.error = e\n                    return\n\n        self.op.progress_tracker.finished()\n\nclass FileReceiver(GObject.Object):\n    def __init__(self, op):\n        super(FileReceiver, self).__init__()\n        self.save_path = prefs.get_save_path()\n        self.op = op\n        self.preserve_perms = prefs.preserve_permissions() and util.save_folder_is_native_fs()\n        self.preserve_timestamp = prefs.preserve_timestamp() and util.save_folder_is_native_fs()\n\n        self.current_path = None\n        self.current_gfile = None\n        self.current_type = None\n        self.current_stream = None\n        self.current_mode = 0\n        self.current_mtime = 0\n        self.current_mtime_usec = 0\n\n        if op.existing:\n            for name in op.top_dir_basenames:\n                try:\n                    path = os.path.join(self.save_path, name)\n                    if os.path.isdir(path): # file not found is ok\n                        shutil.rmtree(path)\n                    else:\n                        os.remove(path)\n                except FileNotFoundError:\n                    pass\n                except Exception as e:\n                    logging.warning(\"Problem removing existing files.  Transfer may not succeed: %s\" % e)\n\n        # We write files top-down.  If we're preserving permissions and we receive\n        # a folder in some hierarchy that is not writable, we won't be able to create\n        # anything inside it.\n        self.folder_permission_change_list = []\n\n    def receive_data(self, s):\n        save_path = prefs.get_save_path()\n\n        path = os.path.join(save_path, s.relative_path)\n        if path != self.current_path:\n            self.close_current_file()\n            self.current_path = path\n            self.current_mode = s.file_mode\n            self.current_type = s.file_type\n            self.current_mtime = s.time.mtime\n            self.current_mtime_usec = s.time.mtime_usec\n\n        if not self.current_gfile:\n            self.current_gfile = Gio.File.new_for_path(path)\n\n        if s.file_type == FileType.DIRECTORY:\n            os.makedirs(path, exist_ok=True)\n        elif s.file_type == FileType.SYMBOLIC_LINK:\n            make_symbolic_link(self.op, path, s.symlink_target)\n        else:\n            if self.current_stream == None:\n                flags = Gio.FileCreateFlags.REPLACE_DESTINATION\n                self.current_stream = self.current_gfile.replace(None, False, flags, None)\n\n            if not s.chunk:\n                return\n\n            self.current_stream.write_bytes(GLib.Bytes(s.chunk), None)\n            self.op.progress_tracker.update_progress(len(s.chunk))\n\n    def close_current_file(self):\n        if self.current_gfile == None:\n            # First block received we self.close_current_file() with an empty path.\n            return\n\n        if self.current_stream:\n            self.current_stream.close()\n            self.current_stream = None\n\n        # set_attributes and os.chmod don't support operating on symlinks directly.\n\n        if self.preserve_timestamp and self.current_mtime > 0 and self.current_type != FileType.SYMBOLIC_LINK:\n            logging.debug(\"Restoring mtime: %s --> %lu.%u\" \\\n                % (self.current_path, self.current_mtime, self.current_mtime_usec))\n\n            info = Gio.FileInfo.new()\n            info.set_attribute_uint64(Gio.FILE_ATTRIBUTE_TIME_MODIFIED, self.current_mtime)\n            info.set_attribute_uint32(Gio.FILE_ATTRIBUTE_TIME_MODIFIED_USEC, self.current_mtime_usec)\n            try:\n                self.current_gfile.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, None)\n            except GLib.Error as e:\n                logging.warning(\"Unable to restore original mtime to '%s': %s\" % (self.current_path, e.message))\n\n        # Only restore permissions on normal files here.\n        # Folder permissions are set in reverse order at the end of the op,\n        if self.preserve_perms and self.current_mode > 0 and self.current_type != FileType.SYMBOLIC_LINK:\n            try:\n                if self.current_type == FileType.REGULAR:\n                    logging.debug(\"Restoring permissions: %s --> %s\" % (self.current_path, self.current_mode))\n                    os.chmod(self.current_path, mode=self.current_mode)\n                else:\n                    self.folder_permission_change_list.append((self.current_path, self.current_mode))\n            except Exception as e:\n                logging.warning(\"Unable to restore original permissions to '%s': %s\" % (self.current_path, str(e)))\n\n        self.current_mtime = 0\n        self.current_mtime_usec = 0\n        self.current_type = None\n        self.current_mode = 0\n        self.current_path = None\n        self.current_gfile = None\n\n    def apply_folder_permissions(self):\n        if self.preserve_perms:\n            while self.folder_permission_change_list:\n                # We added folders from parent->children, this will apply permissions\n                # from child to parent.\n                path, mode = self.folder_permission_change_list.pop()\n                try:\n                    logging.debug(\"Restoring folder permissions: %s --> %s\" % (path, mode))\n                    os.chmod(path, mode)\n                except Exception as e:\n                    logging.warning(\"Unable to restore original permissions to folder '%s': %s\" % (self.current_path, str(e)))\n\n    def receive_finished(self):\n        # We left the last (or only) file open\n        self.close_current_file()\n        self.apply_folder_permissions()\n        self.op.progress_tracker.finished()\n\n\ndef add_file(op, basename, uri, base_uri, info):\n    symlink_target = None\n\n    # Normal files usually take more disk space than their actual size, so we want that\n    # for checking free disk space on the target computer.  However, sparse files can\n    # report a smaller allocated size on disk than their 'actual' size. For now we can\n    # only copy files in their full state, and at the other end they'll no longer be\n    # sparse, so we use the largest of the two sizes for our purposes.\n    alloc_size = info.get_attribute_uint64(Gio.FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE)\n    file_size = info.get_size()\n    size = file_size if file_size > alloc_size else alloc_size\n\n    file_type = info.get_file_type()\n\n    if file_type == FileType.SYMBOLIC_LINK:\n        symlink_target = info.get_symlink_target()\n\n    st_mode = info.get_attribute_uint32(\"unix::mode\")\n    file_mode = (st_mode & MODE_MASK) if (st_mode > 0) else 0\n\n    if base_uri:\n        relative_path = util.relpath_from_uri(uri, base_uri)\n    else:\n        relative_path = basename\n\n    mtime = info.get_attribute_uint64(Gio.FILE_ATTRIBUTE_TIME_MODIFIED)\n    mtime_usec = info.get_attribute_uint32(Gio.FILE_ATTRIBUTE_TIME_MODIFIED_USEC)\n\n    file = File(uri, basename, relative_path, size, file_type, symlink_target, file_mode, mtime, mtime_usec)\n\n    op.resolved_files.append(file)\n    op.total_size += size\n    op.total_count += 1\n\ndef gather_file_info(op):\n        top_dir_basenames = []\n        uri_list = op.uris\n\n        error = None\n\n        if len(uri_list) == 1:\n            infos = FILE_INFOS_SINGLE_FILE\n        else:\n            infos = FILE_INFOS\n\n        # Recursive function for processing folders and their contents.\n        def process_folder(folder_uri, top_dir):\n            folder_file = Gio.File.new_for_uri(folder_uri)\n\n            enumerator = folder_file.enumerate_children(infos,\n                                                        Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,\n                                                        None)\n            info = enumerator.next_file(None)\n\n            while info:\n                child = enumerator.get_child(info)\n                child_uri = child.get_uri()\n                child_basename = child.get_basename()\n\n                file_type = info.get_file_type()\n\n                if file_type == FileType.DIRECTORY:\n                    add_file(op, child_basename, child_uri, top_dir, info)\n                    process_folder(child_uri, top_dir)\n                else:\n                    add_file(op, child_basename, child_uri, top_dir, info)\n\n                info = enumerator.next_file(None)\n\n        # Process the initial list.\n        try:\n            for uri in uri_list:\n                file = Gio.File.new_for_uri(uri)\n                top_dir_basenames.append(file.get_basename())\n\n                info = file.query_info(infos, Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, None)\n                basename = file.get_basename()\n                if len(uri_list) == 1:\n                    op.mime_if_single = info.get_content_type()\n\n                if info and info.get_file_type() == FileType.DIRECTORY:\n                    top_dir = file.get_parent().get_uri()\n                    add_file(op, basename, uri, None, info)\n                    process_folder(uri, top_dir)\n                    continue\n                else:\n                    add_file(op, basename, uri, None, info)\n            op.top_dir_basenames = top_dir_basenames\n        except Exception as e:\n            error = e\n\n        return error\n\nclass Progress():\n    def __init__(self, progress, time_left_sec, bytes_per_sec):\n        self.progress = progress\n        self.time_left_sec = time_left_sec\n        self.bytes_per_sec = bytes_per_sec\n        self.progress_text = \"\"\n\nclass OpProgressTracker():\n    def __init__(self, op):\n        self.op = op\n        self.total_size = op.total_size\n        self.total_transferred = 0\n        self.transfer_start_time = GLib.get_monotonic_time()\n        self.last_update_time = self.transfer_start_time\n\n    @util._idle\n    def update_progress(self, size_read):\n        self.total_transferred += size_read\n\n        now = GLib.get_monotonic_time()\n\n        if ((now - self.last_update_time) > PROGRESS_UPDATE_FREQ):\n            self.last_update_time = now\n\n            progress = self.total_transferred / self.total_size\n            elapsed = now - self.transfer_start_time\n\n            bytes_per_micro = self.total_transferred / elapsed\n            bytes_per_sec = int(bytes_per_micro * 1000 * 1000)\n\n            if bytes_per_sec == 0:\n                bytes_per_sec = 1 # no a/0\n\n            time_left_sec = (self.total_size - self.total_transferred) / bytes_per_sec\n\n            logging.debug(\"Progress: %s time left, %s/s\" % (util.format_time_span(time_left_sec), GLib.format_size(bytes_per_sec)))\n\n            progress_report = Progress(progress, time_left_sec, bytes_per_sec)\n            self.op.progress_report(progress_report)\n\n    def finished(self):\n        self.op.progress_report(Progress(1.0, 0, 0))\n"], "fixing_code": ["#!/usr/bin/python3\n\nimport os\nimport logging\nimport stat\nimport shutil\nimport gettext\n\nfrom gi.repository import GLib, Gio, GObject\n\nimport util\nfrom util import FileType\nimport prefs\nimport warp_pb2\n\n_ = gettext.gettext\n\nFILE_INFOS = \",\".join([\n    \"standard::size\",\n    \"standard::allocated-size\",\n    \"standard::name\",\n    \"standard::type\",\n    \"standard::symlink-target\",\n    \"time::modified\",\n    \"time::modified-usec\",\n    \"unix::mode\"\n])\n\nFILE_INFOS_SINGLE_FILE = \",\".join([\n    \"standard::size\",\n    \"standard::allocated-size\",\n    \"standard::name\",\n    \"standard::type\",\n    \"standard::symlink-target\",\n    \"standard::content-type\",\n    \"time::modified\",\n    \"time::modified-usec\",\n    \"unix::mode\"\n])\n\nMODE_MASK = (stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n\nPROGRESS_UPDATE_FREQ = 2 * 1000 * 1000\n\ndef load_file_in_chunks(path):\n    gfile = Gio.File.new_for_path(path)\n\n    try:\n        stream = gfile.read(None)\n    except GLib.Error:\n        return\n\n    while True:\n        bytes = stream.read_bytes(1024 * 1024, None)\n        if bytes.get_size() == 0:\n            break\n\n        response = warp_pb2.RemoteMachineAvatar(avatar_chunk=bytes.get_data())\n        yield response\n\n    stream.close()\n\ndef make_symbolic_link(op, path, target):\n    tmppath = os.path.join(os.path.dirname(path), \"%s-%d-%d.tmp\" % (op.sender, op.start_time, GLib.get_monotonic_time()))\n    tmpfile = Gio.File.new_for_path(tmppath)\n\n    tmpfile.make_symbolic_link(target, None)\n    os.replace(tmpfile.get_path(), path)\n\n# This represents a file to be transferred (this is used by the sender)\nclass File:\n    def __init__(self, uri, basename, rel_path, size, file_type, symlink_target=None, file_mode=0, mtime=0, mtime_usec=0):\n        self.uri = uri\n        self.basename = basename\n        self.relative_path = rel_path\n        self.size = size\n        self.file_type = file_type\n        self.symlink_target = symlink_target\n        self.file_mode = file_mode\n        self.mtime = mtime\n        self.mtime_usec = mtime_usec\n\nclass FileSender(GObject.Object):\n    def __init__(self, op, timestamp, cancellable):\n        super(FileSender, self).__init__()\n        self.op = op\n        self.timestamp = timestamp\n        self.cancellable = cancellable\n        self.block_size = prefs.get_block_size()\n\n        self.error = None\n\n    def read_chunks(self):\n        for file in self.op.resolved_files:\n            if self.cancellable.is_set():\n                return # StopIteration as different behaviors between 3.5 and 3.7, this works as well.\n\n            logging.debug(\"get mtime: %lu.%u -- %s\" % (file.mtime, file.mtime_usec, file.relative_path))\n\n            ftime = warp_pb2.FileTime(mtime=file.mtime,\n                                      mtime_usec = file.mtime_usec)\n            if file.file_type == FileType.DIRECTORY:\n                yield warp_pb2.FileChunk(relative_path=file.relative_path,\n                                         file_type=file.file_type,\n                                         file_mode=file.file_mode,\n                                         time=ftime)\n            elif file.file_type == FileType.SYMBOLIC_LINK:\n                yield warp_pb2.FileChunk(relative_path=file.relative_path,\n                                         file_type=file.file_type,\n                                         symlink_target=file.symlink_target,\n                                         file_mode=file.file_mode,\n                                         time=ftime)\n            else:\n                stream = None\n\n                try:\n                    gfile = Gio.File.new_for_uri(file.uri)\n                    stream = gfile.read(None)\n\n                    file_done = False\n                    first_chunk = True\n\n                    while True:\n                        if file_done:\n                            break\n\n                        if self.cancellable.is_set():\n                            return\n\n                        b = stream.read_bytes(self.block_size, None)\n\n                        last_size_read = b.get_size()\n                        if last_size_read < self.block_size:\n                            file_done = True\n\n                        self.op.progress_tracker.update_progress(last_size_read)\n\n                        if first_chunk:\n                            time = ftime\n                            first_chunk = False\n                        else:\n                            time = None\n\n                        yield warp_pb2.FileChunk(relative_path=file.relative_path,\n                                                 file_type=file.file_type,\n                                                 chunk=b.get_data(),\n                                                 file_mode=file.file_mode,\n                                                 time=time)\n\n                    stream.close()\n                    continue\n                except Exception as e:\n                    try:\n                        # If we leave an io stream open, it locks the location.  For instance,\n                        # if this was a mounted location, we wouldn't be able to terminate until\n                        # we closed warp.\n                        stream.close()\n                    except:\n                        pass\n\n                    self.error = e\n                    return\n\n        self.op.progress_tracker.finished()\n\nclass FileReceiver(GObject.Object):\n    def __init__(self, op):\n        super(FileReceiver, self).__init__()\n        self.save_path = prefs.get_save_path()\n        self.save_path_file = Gio.File.new_for_path(self.save_path)\n        self.op = op\n        self.preserve_perms = prefs.preserve_permissions() and util.save_folder_is_native_fs()\n        self.preserve_timestamp = prefs.preserve_timestamp() and util.save_folder_is_native_fs()\n\n        self.current_path = None\n        self.current_gfile = None\n        self.current_type = None\n        self.current_stream = None\n        self.current_mode = 0\n        self.current_mtime = 0\n        self.current_mtime_usec = 0\n\n        if op.existing:\n            for name in op.top_dir_basenames:\n                try:\n                    path = os.path.join(self.save_path, name)\n                    if os.path.isdir(path): # file not found is ok\n                        shutil.rmtree(path)\n                    else:\n                        os.remove(path)\n                except FileNotFoundError:\n                    pass\n                except Exception as e:\n                    logging.warning(\"Problem removing existing files.  Transfer may not succeed: %s\" % e)\n\n        # We write files top-down.  If we're preserving permissions and we receive\n        # a folder in some hierarchy that is not writable, we won't be able to create\n        # anything inside it.\n        self.folder_permission_change_list = []\n\n    def receive_data(self, s):\n        save_path = prefs.get_save_path()\n\n        path = os.path.join(save_path, s.relative_path)\n        if path != self.current_path:\n            self.close_current_file()\n            self.current_path = path\n            self.current_mode = s.file_mode\n            self.current_type = s.file_type\n            self.current_mtime = s.time.mtime\n            self.current_mtime_usec = s.time.mtime_usec\n\n        if not self.current_gfile:\n            self.current_gfile = Gio.File.new_for_path(path)\n            # Check for valid path (GFile resolves paths upon creation).\n            if self.save_path_file.get_relative_path(self.current_gfile) is None:\n                raise Exception(_(\"Resolved path is not valid: %s -> %s\") % (path, self.current_gfile.get_path()))\n\n        if s.file_type == FileType.DIRECTORY:\n            os.makedirs(path, exist_ok=True)\n        elif s.file_type == FileType.SYMBOLIC_LINK:\n            make_symbolic_link(self.op, path, s.symlink_target)\n        else:\n            if self.current_stream == None:\n                flags = Gio.FileCreateFlags.REPLACE_DESTINATION\n                self.current_stream = self.current_gfile.replace(None, False, flags, None)\n\n            if not s.chunk:\n                return\n\n            self.current_stream.write_bytes(GLib.Bytes(s.chunk), None)\n            self.op.progress_tracker.update_progress(len(s.chunk))\n\n    def close_current_file(self):\n        if self.current_gfile == None:\n            # First block received we self.close_current_file() with an empty path.\n            return\n\n        if self.current_stream:\n            self.current_stream.close()\n            self.current_stream = None\n\n        # set_attributes and os.chmod don't support operating on symlinks directly.\n\n        if self.preserve_timestamp and self.current_mtime > 0 and self.current_type != FileType.SYMBOLIC_LINK:\n            logging.debug(\"Restoring mtime: %s --> %lu.%u\" \\\n                % (self.current_path, self.current_mtime, self.current_mtime_usec))\n\n            info = Gio.FileInfo.new()\n            info.set_attribute_uint64(Gio.FILE_ATTRIBUTE_TIME_MODIFIED, self.current_mtime)\n            info.set_attribute_uint32(Gio.FILE_ATTRIBUTE_TIME_MODIFIED_USEC, self.current_mtime_usec)\n            try:\n                self.current_gfile.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, None)\n            except GLib.Error as e:\n                logging.warning(\"Unable to restore original mtime to '%s': %s\" % (self.current_path, e.message))\n\n        # Only restore permissions on normal files here.\n        # Folder permissions are set in reverse order at the end of the op,\n        if self.preserve_perms and self.current_mode > 0 and self.current_type != FileType.SYMBOLIC_LINK:\n            try:\n                if self.current_type == FileType.REGULAR:\n                    logging.debug(\"Restoring permissions: %s --> %s\" % (self.current_path, self.current_mode))\n                    os.chmod(self.current_path, mode=self.current_mode)\n                else:\n                    self.folder_permission_change_list.append((self.current_path, self.current_mode))\n            except Exception as e:\n                logging.warning(\"Unable to restore original permissions to '%s': %s\" % (self.current_path, str(e)))\n\n        self.current_mtime = 0\n        self.current_mtime_usec = 0\n        self.current_type = None\n        self.current_mode = 0\n        self.current_path = None\n        self.current_gfile = None\n\n    def apply_folder_permissions(self):\n        if self.preserve_perms:\n            while self.folder_permission_change_list:\n                # We added folders from parent->children, this will apply permissions\n                # from child to parent.\n                path, mode = self.folder_permission_change_list.pop()\n                try:\n                    logging.debug(\"Restoring folder permissions: %s --> %s\" % (path, mode))\n                    os.chmod(path, mode)\n                except Exception as e:\n                    logging.warning(\"Unable to restore original permissions to folder '%s': %s\" % (self.current_path, str(e)))\n\n    def receive_finished(self):\n        # We left the last (or only) file open\n        self.close_current_file()\n        self.apply_folder_permissions()\n        self.op.progress_tracker.finished()\n\n\ndef add_file(op, basename, uri, base_uri, info):\n    symlink_target = None\n\n    # Normal files usually take more disk space than their actual size, so we want that\n    # for checking free disk space on the target computer.  However, sparse files can\n    # report a smaller allocated size on disk than their 'actual' size. For now we can\n    # only copy files in their full state, and at the other end they'll no longer be\n    # sparse, so we use the largest of the two sizes for our purposes.\n    alloc_size = info.get_attribute_uint64(Gio.FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE)\n    file_size = info.get_size()\n    size = file_size if file_size > alloc_size else alloc_size\n\n    file_type = info.get_file_type()\n\n    if file_type == FileType.SYMBOLIC_LINK:\n        symlink_target = info.get_symlink_target()\n\n    st_mode = info.get_attribute_uint32(\"unix::mode\")\n    file_mode = (st_mode & MODE_MASK) if (st_mode > 0) else 0\n\n    if base_uri:\n        relative_path = util.relpath_from_uri(uri, base_uri)\n    else:\n        relative_path = basename\n\n    mtime = info.get_attribute_uint64(Gio.FILE_ATTRIBUTE_TIME_MODIFIED)\n    mtime_usec = info.get_attribute_uint32(Gio.FILE_ATTRIBUTE_TIME_MODIFIED_USEC)\n\n    file = File(uri, basename, relative_path, size, file_type, symlink_target, file_mode, mtime, mtime_usec)\n\n    op.resolved_files.append(file)\n    op.total_size += size\n    op.total_count += 1\n\ndef gather_file_info(op):\n        top_dir_basenames = []\n        uri_list = op.uris\n\n        error = None\n\n        if len(uri_list) == 1:\n            infos = FILE_INFOS_SINGLE_FILE\n        else:\n            infos = FILE_INFOS\n\n        # Recursive function for processing folders and their contents.\n        def process_folder(folder_uri, top_dir):\n            folder_file = Gio.File.new_for_uri(folder_uri)\n\n            enumerator = folder_file.enumerate_children(infos,\n                                                        Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,\n                                                        None)\n            info = enumerator.next_file(None)\n\n            while info:\n                child = enumerator.get_child(info)\n                child_uri = child.get_uri()\n                child_basename = child.get_basename()\n\n                file_type = info.get_file_type()\n\n                if file_type == FileType.DIRECTORY:\n                    add_file(op, child_basename, child_uri, top_dir, info)\n                    process_folder(child_uri, top_dir)\n                else:\n                    add_file(op, child_basename, child_uri, top_dir, info)\n\n                info = enumerator.next_file(None)\n\n        # Process the initial list.\n        try:\n            for uri in uri_list:\n                file = Gio.File.new_for_uri(uri)\n                top_dir_basenames.append(file.get_basename())\n\n                info = file.query_info(infos, Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, None)\n                basename = file.get_basename()\n                if len(uri_list) == 1:\n                    op.mime_if_single = info.get_content_type()\n\n                if info and info.get_file_type() == FileType.DIRECTORY:\n                    top_dir = file.get_parent().get_uri()\n                    add_file(op, basename, uri, None, info)\n                    process_folder(uri, top_dir)\n                    continue\n                else:\n                    add_file(op, basename, uri, None, info)\n            op.top_dir_basenames = top_dir_basenames\n        except Exception as e:\n            error = e\n\n        return error\n\nclass Progress():\n    def __init__(self, progress, time_left_sec, bytes_per_sec):\n        self.progress = progress\n        self.time_left_sec = time_left_sec\n        self.bytes_per_sec = bytes_per_sec\n        self.progress_text = \"\"\n\nclass OpProgressTracker():\n    def __init__(self, op):\n        self.op = op\n        self.total_size = op.total_size\n        self.total_transferred = 0\n        self.transfer_start_time = GLib.get_monotonic_time()\n        self.last_update_time = self.transfer_start_time\n\n    @util._idle\n    def update_progress(self, size_read):\n        self.total_transferred += size_read\n\n        now = GLib.get_monotonic_time()\n\n        if ((now - self.last_update_time) > PROGRESS_UPDATE_FREQ):\n            self.last_update_time = now\n\n            progress = self.total_transferred / self.total_size\n            elapsed = now - self.transfer_start_time\n\n            bytes_per_micro = self.total_transferred / elapsed\n            bytes_per_sec = int(bytes_per_micro * 1000 * 1000)\n\n            if bytes_per_sec == 0:\n                bytes_per_sec = 1 # no a/0\n\n            time_left_sec = (self.total_size - self.total_transferred) / bytes_per_sec\n\n            logging.debug(\"Progress: %s time left, %s/s\" % (util.format_time_span(time_left_sec), GLib.format_size(bytes_per_sec)))\n\n            progress_report = Progress(progress, time_left_sec, bytes_per_sec)\n            self.op.progress_report(progress_report)\n\n    def finished(self):\n        self.op.progress_report(Progress(1.0, 0, 0))\n"], "filenames": ["src/transfers.py"], "buggy_code_start_loc": [6], "buggy_code_end_loc": [210], "fixing_code_start_loc": [7], "fixing_code_end_loc": [218], "type": "CWE-59", "message": "Warpinator through 1.2.14 allows access outside of an intended directory, as demonstrated by symbolic directory links.", "other": {"cve": {"id": "CVE-2022-42725", "sourceIdentifier": "cve@mitre.org", "published": "2022-10-10T05:15:09.330", "lastModified": "2023-04-26T12:15:09.560", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Warpinator through 1.2.14 allows access outside of an intended directory, as demonstrated by symbolic directory links."}, {"lang": "es", "value": "Warpinator versiones hasta 1.2.14, permite un acceso fuera de un directorio previsto, como lo demuestran los enlaces simb\u00f3licos de directorio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxmint:warpinator:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.14", "matchCriteriaId": "A0D79615-D6FC-4FBC-8A0F-A1BBBD97C8EE"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/10/24/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/04/26/1", "source": "cve@mitre.org"}, {"url": "https://github.com/linuxmint/warpinator/commit/5244c33d4c109ede9607b9d94461650410e2cddc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/linuxmint/warpinator/commit/8bfd2f8b3f1b0c0f0a5a6d275702d107b9e08a94", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/linuxmint/warpinator/commit/95124fd4468683dd69ddd7b3da0e9906ce6beae2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/linuxmint/warpinator/commit/f4907ef6a17a189d56ab0a9da4b53190b061ad75", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/linuxmint/warpinator/commit/5244c33d4c109ede9607b9d94461650410e2cddc"}}