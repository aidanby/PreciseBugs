{"buggy_code": ["/*\n    Ming, an SWF output library\n    Copyright (C) 2002  Opaque Industries - http://www.opaque.net/\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n/* $Id$ */\n\n#include <stdlib.h>\n#include <stdio.h> \t \n#include <stdarg.h>\n\n#include \"shape.h\"\n#include \"character.h\"\n#include \"matrix.h\"\n#include \"fillstyle.h\"\n#include \"linestyle.h\"\n#include \"font.h\"\n#include \"libming.h\"\n\nstruct stateChangeRecord\n{\n\tint flags;\n\tint moveToX;\n\tint moveToY;\n\tint leftFill;\n\tint rightFill;\n\tint line;\n\t/* newstyle not used.. */\n};\ntypedef struct stateChangeRecord *StateChangeRecord;\n\n\nstruct lineToRecord\n{\n\tint dx;\n\tint dy;\n};\ntypedef struct lineToRecord *LineToRecord;\n\n\nstruct curveToRecord\n{\n\tint controlx;\n\tint controly;\n\tint anchorx;\n\tint anchory;\n};\ntypedef struct curveToRecord *CurveToRecord;\n\ntypedef enum\n{\n\tSHAPERECORD_STATECHANGE,\n\tSHAPERECORD_LINETO,\n\tSHAPERECORD_CURVETO\n} shapeRecordType;\n\n\nstruct shapeRecord\n{\n\tshapeRecordType type;\n\n\tunion\n\t{\n\t\tStateChangeRecord stateChange;\n\t\tLineToRecord lineTo;\n\t\tCurveToRecord curveTo;\n\t} record;\n};\ntypedef struct shapeRecord ShapeRecord;\n\n\nstruct SWFShape_s\n{\n\tstruct SWFCharacter_s character;\n\n\tShapeRecord *records;\n\tint nRecords;\n\tSWFOutput out;\n\tint xpos;\t/* cursor for using abs. coords in lineTo, curveTo */\n\tint ypos;\n\tSWFLineStyle *lines;\n\tSWFFillStyle *fills;\n\tbyte nLines;\n\tbyte nFills;\n\tshort lineWidth;\n\tBOOL isMorph;\n\tBOOL isEnded;\n\tint useVersion;\n\t// SWF_DEFINESHAPE4 extensions\n\tunsigned char flags;\n\tSWFRect edgeBounds;\n#if TRACK_ALLOCS\n\t/* memory node for garbage collection */\n\tmem_node *gcnode;\n#endif\n};\n\n\nstatic void\nSWFShape_writeShapeRecord(SWFShape shape, ShapeRecord record, SWFOutput out);\n\n\nstatic void\nwriteSWFShapeBlockToMethod(SWFBlock block, \n                           SWFByteOutputMethod method, void* data)\n{\n\tSWFOutput out = ((SWFShape)block)->out;\n\tSWFOutput_writeToMethod(out, method, data);\n}\n\n\nstatic int\ncompleteSWFShapeBlock(SWFBlock block)\n{\n\tSWFShape shape = (SWFShape)block;\n\n\tSWFShape_end(shape);\n\t\n\treturn SWFOutput_getLength(shape->out);\n}\n\n\nvoid\ndestroySWFShape(SWFShape shape)\n{\n\tint i;\n\tif(shape->fills != NULL)\n\t{\n\t\t// Fills have to be destroyed by users. \n\t\t/*\n\t\tfor ( i=0; i<shape->nFills; ++i )\n\t\t\tdestroySWFFillStyle(shape->fills[i]);\n\t\t*/\n\t\tfree(shape->fills);\n\t}\n\tif(shape->records != NULL)\n\t{\n\t\tfor(i = 0; i < shape->nRecords; i++)\n\t\t{\n\t\t\tfree(shape->records[i].record.stateChange);\n\t\t}\n\t \tfree(shape->records);\n\t}\n\n\tif(shape->edgeBounds != NULL)\n\t\tfree(shape->edgeBounds);\n\n\tfor ( i=0; i<shape->nLines; ++i )\n\t\tfree(shape->lines[i]);\n\n\tif ( shape->lines != NULL )\n\t\tfree(shape->lines);\n\n\tdestroySWFOutput(shape->out);\n\n#if TRACK_ALLOCS\n\tming_gc_remove_node(shape->gcnode);\n#endif\n\n\tdestroySWFCharacter((SWFCharacter) shape);\n}\n\nSWFShape \nnewSWFGlyphShape()\n{\n\tSWFShape shape = (SWFShape)malloc(sizeof(struct SWFShape_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == shape)\n\t\treturn NULL;\n\n\tSWFCharacterInit((SWFCharacter)shape);\n\n\tBLOCK(shape)->writeBlock = NULL;\n\tBLOCK(shape)->complete = NULL;\n\tBLOCK(shape)->dtor = NULL;\n\tBLOCK(shape)->type = SWF_UNUSEDBLOCK;\n\t\n\tshape->out = newSWFOutput();\n\tCHARACTER(shape)->bounds = newSWFRect(0,0,0,0);\n\tshape->edgeBounds = newSWFRect(0,0,0,0);\n\n\tshape->records = NULL;\n\tshape->lines = NULL;\n\tshape->fills = NULL;\n\n\tshape->nRecords = 0;\n\tshape->xpos = 0;\n\tshape->ypos = 0;\n\tshape->nLines = 0;\n\tshape->nFills = 0;\n\tshape->lineWidth = 0;\n\tshape->isMorph = FALSE;\n\tshape->isEnded = FALSE;\n\tshape->flags = 0;\n\tshape->useVersion = 0;\n\n\tSWFOutput_writeUInt8(shape->out, 0); /* space for nFillBits, nLineBits */\n\n#if TRACK_ALLOCS\n\tshape->gcnode = ming_gc_add_node(shape, (dtorfunctype) destroySWFShape);\n#endif\n\n\treturn shape;\n}\n\nSWFShape\nnewSWFShape()\n{\n\tSWFShape shape = (SWFShape)malloc(sizeof(struct SWFShape_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == shape)\n\t\treturn NULL;\n\n\tSWFCharacterInit((SWFCharacter)shape);\n\n\tBLOCK(shape)->writeBlock = writeSWFShapeBlockToMethod;\n\tBLOCK(shape)->complete = completeSWFShapeBlock;\n\tBLOCK(shape)->dtor = (destroySWFBlockMethod) destroySWFShape;\n\tBLOCK(shape)->type = SWF_DEFINESHAPE3;\n\t\n\tCHARACTERID(shape) = ++SWF_gNumCharacters;\n\n\tshape->out = newSWFOutput();\n\tCHARACTER(shape)->bounds = newSWFRect(0,0,0,0);\n\tshape->edgeBounds = newSWFRect(0,0,0,0);\n\n\tshape->records = NULL;\n\tshape->lines = NULL;\n\tshape->fills = NULL;\n\n\tshape->nRecords = 0;\n\tshape->xpos = 0;\n\tshape->ypos = 0;\n\tshape->nLines = 0;\n\tshape->nFills = 0;\n\tshape->lineWidth = 0;\n\tshape->isMorph = FALSE;\n\tshape->isEnded = FALSE;\n\tshape->flags = 0;\n\tshape->useVersion = SWF_SHAPE3;\n\n\tSWFOutput_writeUInt8(shape->out, 0); /* space for nFillBits, nLineBits */\n\n#if TRACK_ALLOCS\n\tshape->gcnode = ming_gc_add_node(shape, (dtorfunctype) destroySWFShape);\n#endif\n\n\treturn shape;\n}\n\n\n/*\n * Creates a shape filled with bitmap\n */\nSWFShape\nnewSWFShapeFromBitmap(SWFBitmap bitmap, int flag)\n{\n\tSWFShape shape = newSWFShape();\n\tSWFFillStyle fill;\n\tint width, height;\n\n\tif ( flag != SWFFILL_TILED_BITMAP &&\n\t     flag != SWFFILL_CLIPPED_BITMAP &&\n\t     flag != SWFFILL_NONSMOOTHED_TILED_BITMAP &&\n\t     flag != SWFFILL_NONSMOOTHED_CLIPPED_BITMAP)\n\t{\n\t\tSWF_error(\"Invalid bitmap fill flag\");\n\t}\n\n\tfill = SWFShape_addBitmapFillStyle(shape, bitmap, flag);\n\n\twidth = SWFBitmap_getWidth(bitmap);\n\theight = SWFBitmap_getHeight(bitmap);\n\n\tSWFShape_setRightFillStyle(shape, fill);\n\n\t// XXX - scale shouldn't be hardcoded! (here, or in newSWFBitmapFillStyle)\n\tSWFShape_drawScaledLine(shape, width * 20, 0);\n\tSWFShape_drawScaledLine(shape, 0, height * 20);\n\tSWFShape_drawScaledLine(shape, -width * 20, 0);\n\tSWFShape_drawScaledLine(shape, 0, -height * 20);\n\n\treturn shape;\n}\n\nvoid\nSWFOutput_writeGlyphShape(SWFOutput out, SWFShape shape)\n{\n\tunsigned char c;\n\tint styleDone = 0;\n\tint i;\n\n\tc = 1<<4;\n\tSWFOutput_writeUInt8(out, c);\n\tshape->nFills = 1;\n\tshape->nLines = 0;\t\t\n\tfor ( i=0; i<shape->nRecords; ++i )\n\t{\n\t\tif(!styleDone && shape->records[i].type == SHAPERECORD_STATECHANGE)\n\t\t{\n\t\t\tshape->records[i].record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\t\tshape->records[i].record.stateChange->leftFill = 1;\n\t\t\tstyleDone = 1;\n\t\t}\t\n\t\n\t\tif ( i < shape->nRecords-1 ||\n\t\t\t\t shape->records[i].type != SHAPERECORD_STATECHANGE )\n\t\t{\n\t\t\tSWFShape_writeShapeRecord(shape, shape->records[i], out);\n\t\t}\n\t}\n\n\tSWFOutput_writeBits(out, 0, 6); /* end tag */\n\tSWFOutput_byteAlign(out);\n}\n\nvoid\nSWFShape_end(SWFShape shape)\n{\n\tint i;\n\tbyte* buffer;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tshape->isEnded = TRUE;\n\t\n\tbuffer = SWFOutput_getBuffer(shape->out);\n\tbuffer[0] =\n\t\t(SWFOutput_numBits(shape->nFills) << 4) + SWFOutput_numBits(shape->nLines);\n\n\tfor ( i=0; i<shape->nRecords; ++i )\n\t{\n\t\tif ( i < shape->nRecords-1 ||\n\t\t\t\t shape->records[i].type != SHAPERECORD_STATECHANGE )\n\t\t{\n\t\t\tSWFShape_writeShapeRecord(shape, shape->records[i], shape->out);\n\t\t}\n\n\t\tfree(shape->records[i].record.stateChange); /* all in union are pointers */\n\t}\n\n\tSWFOutput_writeBits(shape->out, 0, 6); /* end tag */\n\tSWFOutput_byteAlign(shape->out);\n\t\t\n\t/* addStyleHeader creates a new output and adds the existing one after\n\t\t itself- so even though it's called afterwards it's written before,\n\t\t as it should be */\n\tif ( BLOCK(shape)->type > 0 )\n\t{\n\t\tswitch (shape->useVersion)\n\t\t{\n\t\tcase SWF_SHAPE1:\n\t\t\tBLOCK(shape)->type = SWF_DEFINESHAPE;\n\t\t\tbreak;\n\t\tcase SWF_SHAPE2:\n\t\t\tBLOCK(shape)->type = SWF_DEFINESHAPE2;\n\t\t\tbreak;\n\t\tcase SWF_SHAPE4:\n\t\t\tBLOCK(shape)->type = SWF_DEFINESHAPE4;\n\t\t\tbreak;\n\t\t}\n\t\tSWFShape_addStyleHeader(shape);\n\t}\n\tfree(shape->records);\n\tshape->records = NULL;\n\tshape->nRecords = 0;\n}\n\n\nSWFOutput\nSWFShape_getOutput(SWFShape shape)\n{\n\treturn shape->out;\n}\n\n\nvoid\nSWFShape_getFills(SWFShape shape, SWFFillStyle** fills, int* nFills)\n{\n\t*fills = shape->fills;\n\t*nFills = shape->nFills;\n}\n\n\nvoid\nSWFShape_getLines(SWFShape shape, SWFLineStyle** lines, int* nLines)\n{\n\t*lines = shape->lines;\n\t*nLines = shape->nLines;\n}\n\n\nvoid\nSWFShape_setMorphFlag(SWFShape shape)\n{\n\tshape->isMorph = TRUE;\n}\n\n\nvoid\nSWFShape_addStyleHeader(SWFShape shape)\n{\n\tSWFOutput out = newSWFOutput();\n\tSWFOutput_writeUInt16(out, CHARACTERID(shape));\n\tSWFOutput_writeRect(out, SWFCharacter_getBounds(CHARACTER(shape)));\n\tif(shape->useVersion == SWF_SHAPE4)\n\t{\n\t\tSWFOutput_writeRect(out, shape->edgeBounds);\n\t\tSWFOutput_writeUInt8(out, shape->flags);\n\t}\n\t\n\tSWFOutput_writeFillStyles(out, shape->fills, shape->nFills, \n\t\tBLOCK(shape)->type, shape->edgeBounds);\n\tSWFOutput_writeLineStyles(out, shape->lines, shape->nLines, \n\t\tBLOCK(shape)->type, shape->edgeBounds);\n\t\n\t/* prepend shape->out w/ shape header */\n\tSWFOutput_setNext(out, shape->out);\n\tshape->out = out;\n}\n\n\n/*\n\tShapeRecords are an intermediate storage so that we don't have to specify\n\tfill/line types in advance.\n*/\n\n#define SHAPERECORD_INCREMENT 32\n\n/* copy shaperecord from other shape */ \nstatic ShapeRecord addShapeRecord(SWFShape shape, ShapeRecord record, \n                                  int *vx, int *vy, float scale)\n{\n\tif ( shape->nRecords % SHAPERECORD_INCREMENT == 0 )\n\t{\n\t\tshape->records = (ShapeRecord*) realloc(shape->records,\n\t\t\t\t\t sizeof(ShapeRecord) *\n\t\t\t\t\t (shape->nRecords + SHAPERECORD_INCREMENT));\n\t}\n\n\tswitch ( record.type )\n\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tStateChangeRecord change = (StateChangeRecord)\n\t\t\t\tcalloc(1,sizeof(struct stateChangeRecord));\n\t\t\t*change = *record.record.stateChange;\n\t\t\tshape->records[shape->nRecords].record.stateChange = change;\n\t\t\tchange->moveToX += shape->xpos;\n\t\t\tchange->moveToY += shape->ypos;\n\t\t\tchange->moveToX *= scale;\n\t\t\tchange->moveToY *= scale;\n\n\t\t\t*vx = change->moveToX;\n\t\t\t*vy = change->moveToY;\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tLineToRecord lineTo = (LineToRecord)\n\t\t\t\tcalloc(1,sizeof(struct lineToRecord));\n\t\t\t*lineTo = *record.record.lineTo;\n\t\t\tlineTo->dx *= scale;\n\t\t\tlineTo->dy *= scale;\n\t\t\tshape->records[shape->nRecords].record.lineTo = lineTo;\n\n\t\t\t*vx += lineTo->dx;\n\t\t\t*vy += lineTo->dy;\n\t\t\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t *vx, *vy, shape->lineWidth);\n\t\t\tSWFRect_includePoint(shape->edgeBounds, *vx, *vy, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_CURVETO:\n\t\t{\n\t\t\tCurveToRecord curveTo = (CurveToRecord) \n\t\t\t\tcalloc(1,sizeof(struct curveToRecord));\n\t\t\t*curveTo = *record.record.curveTo;\n\t\t\tcurveTo->controlx *= scale;\n\t\t\tcurveTo->controly *= scale;\n\t\t\tcurveTo->anchorx *= scale;\n\t\t\tcurveTo->anchory *= scale;\n\t\t\tshape->records[shape->nRecords].record.curveTo = curveTo;\n\t\t\t\n\t\t\t*vx += curveTo->controlx;\n\t\t\t*vy += curveTo->controly;\n\t\t\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t *vx, *vy, shape->lineWidth);\n\t\t\tSWFRect_includePoint(shape->edgeBounds, *vx, *vy, 0);\n\t\t\t*vx += curveTo->anchorx;\n\t\t\t*vy += curveTo->anchory;\n\t\t\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t *vx, *vy, shape->lineWidth);\n\t\t\tSWFRect_includePoint(shape->edgeBounds, *vx, *vy, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tshape->records[shape->nRecords].type = record.type;\n\tshape->nRecords++;\n\treturn shape->records[shape->nRecords-1];\n\n}\n\nstatic ShapeRecord\nnewShapeRecord(SWFShape shape, shapeRecordType type)\n{\n\tif ( shape->nRecords % SHAPERECORD_INCREMENT == 0 )\n\t{\n\t\tshape->records = (ShapeRecord*) realloc(shape->records,\n\t\t\t\t\t sizeof(ShapeRecord) *\n\t\t\t\t\t (shape->nRecords + SHAPERECORD_INCREMENT));\n\t}\n\n\tswitch ( type )\n\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tStateChangeRecord change = (StateChangeRecord)calloc(1,sizeof(struct stateChangeRecord));\n\t\t\tshape->records[shape->nRecords].record.stateChange = change;\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tLineToRecord lineTo = (LineToRecord) calloc(1,sizeof(struct lineToRecord));\n\t\t\tshape->records[shape->nRecords].record.lineTo = lineTo;\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_CURVETO:\n\t\t{\n\t\t\tCurveToRecord curveTo = (CurveToRecord) calloc(1,sizeof(struct curveToRecord));\n\t\t\tshape->records[shape->nRecords].record.curveTo = curveTo;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tshape->records[shape->nRecords].type = type;\n\n// this is intentional - at least one popular compiler cannot handle [shape->nRecords++]\n\tshape->nRecords++;\n\treturn shape->records[shape->nRecords-1];\n}\n\n\nvoid\nSWFShape_writeShapeRecord(SWFShape shape, ShapeRecord record, SWFOutput out)\n{\n\tswitch(record.type)\n\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tint flags = record.record.stateChange->flags;\n\n\t\t\tif(flags == 0)\n\t\t\t\treturn;\n\n\t\t\tSWFOutput_writeBits(out, flags, 6);\n\n\t\t\tif(flags & SWF_SHAPE_MOVETOFLAG)\n\t\t\t{\n\t\t\t\tint x = record.record.stateChange->moveToX;\n\t\t\t\tint y = record.record.stateChange->moveToY;\n\t\t\t\tint nBits = max(SWFOutput_numSBits(x), SWFOutput_numSBits(y));\n\n\t\t\t\tSWF_assert(nBits<32);\n\t\t\t\tSWFOutput_writeBits(out, nBits, 5);\n\t\t\t\tSWFOutput_writeSBits(out, x, nBits);\n\t\t\t\tSWFOutput_writeSBits(out, y, nBits);\n\t\t\t}\n\n\t\t\tif(flags & SWF_SHAPE_FILLSTYLE0FLAG)\n\t\t\t{\n\t\t\t\tSWFOutput_writeBits(out, record.record.stateChange->leftFill,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numBits(shape->nFills));\n\t\t\t}\n\n\t\t\tif(flags & SWF_SHAPE_FILLSTYLE1FLAG)\n\t\t\t{\n\t\t\t\tSWFOutput_writeBits(out, record.record.stateChange->rightFill,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numBits(shape->nFills));\n\t\t\t}\n\n\t\t\tif(flags & SWF_SHAPE_LINESTYLEFLAG)\n\t\t\t{\n\t\t\t\tSWFOutput_writeBits(out, record.record.stateChange->line,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numBits(shape->nLines));\n\t\t\t}\n\n\t\t\t/* newstyle's never used.\t But this is what it looks like:\n\n\t\t\tif ( flags & SWF_SHAPE_NEWSTYLEFLAG )\n\t\t\t{\n\t\t\t\tSWFOutput_writeFillStyles(shape->out, shape->fills, shape->nFills,\n\t\t\t\tBLOCK(shape)->type);\n\n\t\t\t\tSWFOutput_writeLineStyles(shape->out, shape->lines, shape->nLines,\n\t\t\t\t\tBLOCK(shape)->type);\n\n\t\t\t\tSWFOutput_writeBits(shape->out, SWFOutput_numBits(shape->nFills), 4);\n\t\t\t\tSWFOutput_writeBits(shape->out, SWFOutput_numBits(shape->nLines), 4);\n\t\t\t}\n\n\t\t\t*/\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tint nBits;\n\t\t\tint dx = record.record.lineTo->dx;\n\t\t\tint dy = record.record.lineTo->dy;\n\n\t\t\tSWFOutput_writeBits(out, 3, 2); /* straight edge */\n\n\t\t\tif(dx==0)\n\t\t\t{\n\t\t\t\tnBits = SWFOutput_numSBits(dy);\n\t\t\t\tSWF_assert(nBits<18);\n\t\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\t\tSWFOutput_writeBits(out, 1, 2); /* vertical line */\n\t\t\t\tSWFOutput_writeSBits(out, dy, nBits);\n\t\t\t}\n\t\t\telse if(dy==0)\n\t\t\t{\n\t\t\t\tnBits = SWFOutput_numSBits(dx);\n\t\t\t\tSWF_assert(nBits<18);\n\t\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\t\tSWFOutput_writeBits(out, 0, 2); /* horizontal line */\n\t\t\t\tSWFOutput_writeSBits(out, dx, nBits);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnBits = max(SWFOutput_numSBits(dx), SWFOutput_numSBits(dy));\n\t\t\t\tSWF_assert(nBits<18);\n\t\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\t\tSWFOutput_writeBits(out, 1, 1); /* general line */\n\t\t\t\tSWFOutput_writeSBits(out, dx, nBits);\n\t\t\t\tSWFOutput_writeSBits(out, dy, nBits);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SHAPERECORD_CURVETO:\n\t\t{\n\t\t\tint controlx = record.record.curveTo->controlx;\n\t\t\tint controly = record.record.curveTo->controly;\n\t\t\tint anchorx = record.record.curveTo->anchorx;\n\t\t\tint anchory = record.record.curveTo->anchory;\n\n\t\t\tint nBits = max(max(SWFOutput_numSBits(controlx),\n\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numSBits(controly)),\n\t\t\t\t\t\t\t\t\t\t\tmax(SWFOutput_numSBits(anchorx),\n\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numSBits(anchory)));\n\n\t\t\tif ( nBits < 2 )\n\t\t\t\tnBits = 2;\n\n\t\t\tSWF_assert(nBits < 18);\n\n\t\t\tSWFOutput_writeBits(out, 2, 2); /* curved edge */\n\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\tSWFOutput_writeSBits(out, controlx, nBits);\n\t\t\tSWFOutput_writeSBits(out, controly, nBits);\n\t\t\tSWFOutput_writeSBits(out, anchorx, nBits);\n\t\t\tSWFOutput_writeSBits(out, anchory, nBits);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tSWF_error(\"Unknown shapeRecordType\");\n\t}\n}\n\n\n/* x,y relative to shape origin */\nvoid\nSWFShape_drawScaledLineTo(SWFShape shape, int x, int y)\n{\n\tSWFShape_drawScaledLine(shape, x-shape->xpos, y-shape->ypos);\n}\n\n\nvoid\nSWFShape_drawScaledLine(SWFShape shape, int dx, int dy)\n{\n\tShapeRecord record;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tif ( dx == 0 && dy == 0 )\n\t\treturn;\n\n\trecord = newShapeRecord(shape, SHAPERECORD_LINETO);\n\n\tSWF_assert(SWFOutput_numSBits(dx) < 18);\n\tSWF_assert(SWFOutput_numSBits(dy) < 18);\n\n\trecord.record.lineTo->dx = dx;\n\trecord.record.lineTo->dy = dy;\n\n\tshape->xpos += dx;\n\tshape->ypos += dy;\n\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n}\n\n\nvoid\nSWFShape_drawScaledCurveTo(SWFShape shape,\n\t\t\t\t\t\t\t\t\t\t\t\t\t int controlx, int controly,\n\t\t\t\t\t\t\t\t\t\t\t\t\t int anchorx, int anchory)\n{\n\tSWFShape_drawScaledCurve(shape, controlx-shape->xpos, controly-shape->ypos,\n\t\t\t\t\t\t\t\t\t\t\t\t\t anchorx-controlx, anchory-controly);\n}\n\n\nvoid\nSWFShape_drawScaledCurve(SWFShape shape,\n\t\t\t\t\t\t\t\t\t\t\t\t int controldx, int controldy,\n\t\t\t\t\t\t\t\t\t\t\t\t int anchordx, int anchordy)\n{\n\tShapeRecord record;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tif ( controldx == 0 && controldy == 0 && anchordx == 0 && anchordy == 0 )\n\t\treturn;\n\t\n\t// printf(\"curve %i,%i, %i, %i\\n\", controldx, controldy, anchordx,  anchordy);\n\n\trecord = newShapeRecord(shape, SHAPERECORD_CURVETO);\n\n\trecord.record.curveTo->controlx = controldx;\n\trecord.record.curveTo->controly = controldy;\n\trecord.record.curveTo->anchorx = anchordx;\n\trecord.record.curveTo->anchory = anchordy;\n\n\tif ( SWFOutput_numSBits(controldx) >= 18 ||\n\t\t\t SWFOutput_numSBits(controldy) >= 18 ||\n\t\t\t SWFOutput_numSBits(anchordx) >= 18 ||\n\t\t\t SWFOutput_numSBits(anchordy) >= 18 )\n\t\tSWF_error(\"Curve parameters too large\");\n\n\t/* including the control point is sloppy, but safe.. */\n\n\tshape->xpos += controldx;\n\tshape->ypos += controldy;\n\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n\tshape->xpos += anchordx;\n\tshape->ypos += anchordy;\n\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n}\n\n\n#define STYLE_INCREMENT 4\n\nstatic inline void growLineArray(SWFShape shape)\n{\n\tint size;\n\n\tif ( shape->nLines % STYLE_INCREMENT != 0 )\n\t\treturn;\n\n\tsize = (shape->nLines+STYLE_INCREMENT) * sizeof(SWFLineStyle);\n\tshape->lines = (SWFLineStyle*)realloc(shape->lines, size);\t\n}\n\nstatic int \nSWFShape_addLineStyle2filled(SWFShape shape, unsigned short width,\n                             SWFFillStyle fill,\n                             int flags, float miterLimit)\n{\n\tgrowLineArray(shape);\n\tSWFShape_useVersion(shape, SWF_SHAPE4);\n\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\tshape->lines[shape->nLines] = newSWFLineStyle2_filled(width, fill, flags, miterLimit);\n\treturn ++shape->nLines;\n}\n\nstatic int\nSWFShape_addLineStyle2(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a,\n                      int flags, float miterLimit)\n{\n\tgrowLineArray(shape);\n\tSWFShape_useVersion(shape, SWF_SHAPE4);\n\tshape->lines[shape->nLines] = newSWFLineStyle2(width, r, g, b, a, flags, miterLimit);\n\treturn ++shape->nLines;\n}\n\nstatic int\nSWFShape_addLineStyle(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tgrowLineArray(shape);\n\tshape->lines[shape->nLines] = newSWFLineStyle(width, r, g, b, a);\n\treturn ++shape->nLines;\n}\n\n\n/* if the current shape record isn't a style change record, add one */\nstatic ShapeRecord\naddStyleRecord(SWFShape shape)\n{\n\tif ( shape->nRecords > 0 &&\n\t\t\t shape->records[shape->nRecords-1].type == SHAPERECORD_STATECHANGE )\n\t{\n\t\treturn shape->records[shape->nRecords-1];\n\t}\n\telse\n\t\treturn newShapeRecord(shape, SHAPERECORD_STATECHANGE);\n}\n\n\nvoid\nSWFShape_hideLine(SWFShape shape)\n{\n\tShapeRecord record;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tif ( shape->isMorph )\n\t\treturn;\n\n\trecord = addStyleRecord(shape);\n\n\trecord.record.stateChange->line = 0;\n\trecord.record.stateChange->flags |= SWF_SHAPE_LINESTYLEFLAG;\n}\n\nstatic void finishSetLine(SWFShape shape, int line, unsigned short width)\n{\n\tShapeRecord record;\n\t\n\tif ( width == 0 )\n\t\tshape->lineWidth = 0;\n\telse\n\t\tshape->lineWidth = (SWFLineStyle_getWidth(shape->lines[line-1]) + 1) / 2;\n\t\n\tif ( shape->isMorph )\n\t\treturn;\n\n\trecord = addStyleRecord(shape);\n\n\trecord.record.stateChange->line = line;\n\trecord.record.stateChange->flags |= SWF_SHAPE_LINESTYLEFLAG;\n}\n\n/*\n * set filled Linestyle2 introduce with SWF 8.\n * \n * set line width in TWIPS\n *\n * WARNING: this is an internal interface\n * external use is deprecated! use setLine2 instead\n *\n * Instead of providing a fill color, a FillStyle can be applied\n * to a line.\n * \n * Linestyle2 also extends Linestyle1 with some extra flags:\n *\n * Line cap style: select one of the following flags (default is round cap style)\n * SWF_LINESTYLE_CAP_ROUND \n * SWF_LINESTYLE_CAP_NONE\n * SWF_LINESTYLE_CAP_SQUARE \n *\n * Line join style: select one of the following flags (default is round join style)\n * SWF_LINESTYLE_JOIN_ROUND\n * SWF_LINESTYLE_JOIN_BEVEL \n * SWF_LINESTYLE_JOIN_MITER  \n *\n * Scaling flags: disable horizontal / vertical scaling\n * SWF_LINESTYLE_FLAG_NOHSCALE\n * SWF_LINESTYLE_FLAG_NOVSCALE \n *\n * Enable pixel hinting to correct blurry vertical / horizontal lines\n * -> all anchors will be aligned to full pixels\n * SWF_LINESTYLE_FLAG_HINTING  \n *\n * Disable stroke closure: if no-close flag is set caps will be applied \n * instead of joins\n * SWF_LINESTYLE_FLAG_NOCLOSE\n *\n * End-cap style: default round\n * SWF_LINESTYLE_FLAG_ENDCAP_ROUND\n * SWF_LINESTYLE_FLAG_ENDCAP_NONE\n * SWF_LINESTYLE_FLAG_ENDCAP_SQUARE\n *\n * If join style is SWF_LINESTYLE_JOIN_MITER a miter limit factor \n * must be set. Miter max length is then calculated as:\n * max miter len = miter limit * width.\n * If join style is not miter, this value will be ignored.\n */\nvoid \nSWFShape_setLineStyle2filled_internal(SWFShape shape, unsigned short width,\n                       SWFFillStyle fill,\n                       int flags, float miterLimit)\n{\n\tint line;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals2filled(shape->lines[line], width, fill, flags) )\n\t\t\tbreak;\n\t}\n\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle2filled(shape, width, fill, flags, miterLimit);\n\telse\n\t\t++line;\n\n\tfinishSetLine(shape, line, width);\n}\n\n\n/*\n * set Linestyle2 introduce with SWF 8.\n *\n * set line width in TWIPS\n * WARNING: this is an internal interface\n * external use is deprecated! use setLine2 instead !\n * set color {r, g, b, a}\n *\n * Linestyle2 extends Linestyle1 with some extra flags:\n *\n * Line cap style: select one of the following flags (default is round cap style)\n * SWF_LINESTYLE_CAP_ROUND \n * SWF_LINESTYLE_CAP_NONE\n * SWF_LINESTYLE_CAP_SQUARE \n *\n * Line join style: select one of the following flags (default is round join style)\n * SWF_LINESTYLE_JOIN_ROUND\n * SWF_LINESTYLE_JOIN_BEVEL \n * SWF_LINESTYLE_JOIN_MITER  \n *\n * Scaling flags: disable horizontal / vertical scaling\n * SWF_LINESTYLE_FLAG_NOHSCALE\n * SWF_LINESTYLE_FLAG_NOVSCALE \n *\n * Enable pixel hinting to correct blurry vertical / horizontal lines\n * -> all anchors will be aligned to full pixels\n * SWF_LINESTYLE_FLAG_HINTING  \n *\n * Disable stroke closure: if no-close flag is set caps will be applied \n * instead of joins\n * SWF_LINESTYLE_FLAG_NOCLOSE\n *\n * End-cap style: default round\n * SWF_LINESTYLE_FLAG_ENDCAP_ROUND\n * SWF_LINESTYLE_FLAG_ENDCAP_NONE\n * SWF_LINESTYLE_FLAG_ENDCAP_SQUARE\n *\n * If join style is SWF_LINESTYLE_JOIN_MITER a miter limit factor \n * must be set. Miter max length is then calculated as:\n * max miter len = miter limit * width.\n * If join style is not miter, this value will be ignored.\n */\nvoid \nSWFShape_setLineStyle2_internal(SWFShape shape, unsigned short width,\n                       byte r, byte g, byte b, byte a,\n                       int flags, float miterLimit)\n{\n\tint line;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, flags) )\n\t\t\tbreak;\n\t}\n\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle2(shape, width, r, g, b, a, flags, miterLimit);\n\telse\n\t\t++line;\n\n\tfinishSetLine(shape, line, width);\n}\n\n\n/*\n * set line width and line color\n *\n * set line width in TWIPS\n * set line color as {r, g, b, a}\n *\n * WARNING: this is an internal interface.\n * external use is deprecated! use setLine instead ! \n */\nvoid\nSWFShape_setLineStyle_internal(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tint line;\n\t\t\n\tif ( shape->isEnded )\n\t\treturn;\n\t\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, 0) )\n\t\t\tbreak;\n\t}\n\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle(shape, width, r, g, b, a);\n\telse\n\t\t++line;\n\t\n\tfinishSetLine(shape, line, width);\n}\n\n\n/* fill 0 is no fill, so set idx to one more than the shape's fill index */\nstatic int getFillIdx(SWFShape shape, SWFFillStyle fill)\n{\n\tint i;\n\n\tfor ( i=0; i<shape->nFills; ++i )\n\t{\n\t\tif ( SWFFillStyle_equals(fill, shape->fills[i]) )\n\t\t\treturn (i+1);\n\t}\n\treturn 0; // no fill\n}\n\nstatic int addFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tint i;\n\t\n\tfor ( i=0; i<shape->nFills; ++i )\n\t{\n\t\tif ( SWFFillStyle_equals(fill, shape->fills[i]) )\n\t\t\treturn i;\n\t}\n\n\tif ( shape->isEnded )\n\t\treturn -1;\n\n\tif ( shape->nFills%STYLE_INCREMENT == 0 )\n\t{\n\t\tint size = (shape->nFills+STYLE_INCREMENT) * sizeof(SWFFillStyle);\n\t\tshape->fills = (SWFFillStyle*)realloc(shape->fills, size);\n\t}\n\n\tshape->fills[shape->nFills] = fill;\n\t++shape->nFills;\n\treturn shape->nFills;\n}\n\n\nSWFFillStyle\nSWFShape_addSolidFillStyle(SWFShape shape, byte r, byte g, byte b, byte a)\n{\n\tint  ret;\n\n\tSWFFillStyle fill = newSWFSolidFillStyle(r, g, b, a);\n\t\n\tret = addFillStyle(shape, fill);\n\tif(ret < 0) /* error */\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\telse if(ret == shape->nFills)  /* new fill */\n\t{\n\t\treturn fill;\n\t}\n\telse /* fill is known */ \n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn shape->fills[ret];\n\t}\n}\n\n\nSWFFillStyle\nSWFShape_addGradientFillStyle(SWFShape shape, SWFGradient gradient, byte flags)\n{\n\tSWFFillStyle fill = newSWFGradientFillStyle(gradient, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\t\t\n}\n\n\nSWFFillStyle\nSWFShape_addBitmapFillStyle(SWFShape shape, SWFBitmap bitmap, byte flags)\n{\n\tSWFFillStyle fill;\n\n\tif ( bitmap )\n\t{\n\t\tSWFCharacter_addDependency((SWFCharacter)shape,\n\t\t                           (SWFCharacter)bitmap);\n\t}\n\n\tfill = newSWFBitmapFillStyle(bitmap, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\n}\n\n\nvoid\nSWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\t\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) // fill not present in array\n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\t\t\t\t\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}\n\n\nvoid\nSWFShape_setRightFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\t\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->rightFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE1FLAG;\n\t\treturn;\n\t}\n\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) // fill not present in array\n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\t\t\t\t\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->rightFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE1FLAG;\n}\n\n/* move pen relative to shape origin */\nvoid\nSWFShape_moveScaledPenTo(SWFShape shape, int x, int y)\n{\n\tShapeRecord record;\n\tif ( shape->isEnded )\n\t\treturn;\n\n\trecord = addStyleRecord(shape);\n\n\trecord.record.stateChange->moveToX = shape->xpos = x;\n\trecord.record.stateChange->moveToY = shape->ypos = y;\n\n\trecord.record.stateChange->flags |= SWF_SHAPE_MOVETOFLAG;\n\n\tif ( shape->nRecords == 0 ||\n\t\t\t (shape->nRecords == 1 &&\n\t\t\t\tshape->records[0].type == SHAPERECORD_STATECHANGE) )\n\t{\n\t\tSWFRect_setBounds(SWFCharacter_getBounds(CHARACTER(shape)), x, x, y, y);\n\t\tSWFRect_setBounds(shape->edgeBounds, x, x, y, y);\n\t}\n}\n\n\nvoid\nSWFShape_moveScaledPen(SWFShape shape, int x, int y)\n{\n\tSWFShape_moveScaledPenTo(shape, shape->xpos+x, shape->ypos+y);\n}\n\n\nint\nSWFShape_getScaledPenX(SWFShape shape)\n{\n\treturn shape->xpos;\n}\n\n\nint\nSWFShape_getScaledPenY(SWFShape shape)\n{\n\treturn shape->ypos;\n}\n\nvoid\nSWFShape_drawScaledGlyph(SWFShape shape,\n                         SWFFont font, unsigned short c, int size)\n{\n\tSWFShape glyph;\n\tint i, vx, vy;\n\tif(font == NULL)\n\t\treturn;\n\t\n\tglyph = SWFFont_getGlyph(font, c);\n\tif(glyph == NULL)\n\t{\n\t\tSWF_warn(\"SWFShape_drawScaledGlyph: no glyph for code %i found \\n\", c);\n\t\treturn;\n\t}\n\n\tvx = shape->xpos;\n\tvy = shape->ypos;\n\tfor(i = 0; i < glyph->nRecords; i++)\n\t\taddShapeRecord(shape, glyph->records[i], &vx, &vy, size/1024.0);\n}\n\n/*\n * set shape version manualy\n * This function allows to set the shapes version information. The\n * version is only a hint. if necessary the version is upgraded. \n * valid values: SWF_SHAPE3 and SWF_SHAPE4 \n * 3 is default\n * 4 if linestyle2 is used\n */\nvoid SWFShape_useVersion(SWFShape shape, int version)\n{\n\tif(shape->useVersion >= version)\n\t\treturn;\n\tif(version > SWF_SHAPE4)\n\t\treturn;\n\tshape->useVersion = version;\n}\n\n/*\n * get shape version\n * possible values SWF_SHAPE3 and SWF_SHAPE4 \n */\nint SWFShape_getVersion(SWFShape shape)\n{\n\treturn shape->useVersion;\n}\n\n/* \n * set render hinting flags\n * possible values:\n * SWF_SHAPE_USESCALINGSTROKES \tSWF_SHAPE_USENONSCALINGSTROKES\t\n */\nvoid SWFShape_setRenderHintingFlags(SWFShape shape, int flags)\n{\n\tflags &= (SWF_SHAPE_USESCALINGSTROKES | SWF_SHAPE_USENONSCALINGSTROKES);\n\tshape->flags = flags;\n\tSWFShape_useVersion(shape, SWF_SHAPE4);\n}\n\nSWFRect SWFShape_getEdgeBounds(SWFShape shape)\n{\n\tif(shape->useVersion == SWF_SHAPE4)\n\t\treturn shape->edgeBounds;\n\telse\n\t\treturn NULL;\n}\n\nint SWFShape_getFlags(SWFShape shape)\n{\n\tif(shape->useVersion == SWF_SHAPE4)\n\t\treturn shape->flags;\n\telse\n\t\treturn 0;\n}\n\nstruct out \t \n{       char *buf, *ptr; \t \n\tint len; \t \n}; \t \n\t  \t \nstatic void oprintf(struct out *op, const char *fmt, ...) \t \n{\n\tva_list ap; \t \n\tchar buf[256]; \t \n\tint d, l; \t \n\t  \t \n\tva_start(ap, fmt); \t \n\tl = vsprintf(buf, fmt, ap); \t \n\twhile((d = op->ptr - op->buf) + l >= op->len-1) \t \n\t{\n\t\top->buf = (char *) realloc(op->buf, op->len += 100); \t \n\t\top->ptr = op->buf + d; \t \n\t} \t \n\tfor(d = 0 ; d < l ; d++) \t \n\t\t*op->ptr++ = buf[d]; \t \n}\n\nchar * SWFShape_dumpOutline(SWFShape s) \t \n{ \t \n\tstruct out o; \t \n\tint i;\n\tint x = 0, y = 0;\n \n\to.len = 0; \t \n\to.ptr = o.buf = (char *)malloc(1); \t \n\t*o.ptr = 0; \t \n\t  \t \n\tfor (i = 0; i < s->nRecords; i++) \t \n\t{\n\t\tShapeRecord *record = s->records + i;\n\t\tswitch(record->type)\n\t\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tif(!record->record.stateChange->flags & SWF_SHAPE_MOVETOFLAG)\n\t\t\t\tcontinue;\n\t\t\tx = record->record.stateChange->moveToX;\n\t\t\ty = record->record.stateChange->moveToY;\n\t\t\toprintf(&o, \"moveto %d,%d\\n\", x, y);\n\t\t\tbreak;\n\t\t}\n\t  \tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tx += record->record.lineTo->dx;\n\t\t\ty += record->record.lineTo->dy;\n\t\t\toprintf(&o, \"lineto %d,%d\\n\", x, y);\n\t\t\tbreak; \t \n\t\t} \t \n\t\tcase SHAPERECORD_CURVETO: \t \n\t\t{ \t \n\t\t\tint controlX = record->record.curveTo->controlx;\n\t\t\tint controlY = record->record.curveTo->controly;\n\t\t\tint anchorX = record->record.curveTo->anchorx;\n\t\t\tint anchorY = record->record.curveTo->anchory;\n\n\t\t\toprintf(&o, \"curveto %d,%d %d,%d\\n\", \t \n\t\t\t\tx+controlX, y+controlY, \t \n\t\t\t\tx+controlX+anchorX, y+controlY+anchorY); \t \n\t  \t \n\t\t\t\tx += controlX + anchorX; \t \n\t\t\t\ty += controlY + anchorY;\n\t\t\tbreak; \n\t\t}\n\t\tdefault: break;\n\t\t}\n\t} \t \n\t  \t \n\t*o.ptr = 0; \t \n\treturn o.buf; \t \n}\n\n\n/*\n * Local variables:\n * tab-width: 2\n * c-basic-offset: 2\n * End:\n */\n"], "fixing_code": ["/*\n    Ming, an SWF output library\n    Copyright (C) 2002  Opaque Industries - http://www.opaque.net/\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\n/* $Id$ */\n\n#include <stdlib.h>\n#include <stdio.h> \t \n#include <stdarg.h>\n\n#include \"shape.h\"\n#include \"character.h\"\n#include \"matrix.h\"\n#include \"fillstyle.h\"\n#include \"linestyle.h\"\n#include \"font.h\"\n#include \"libming.h\"\n\nstruct stateChangeRecord\n{\n\tint flags;\n\tint moveToX;\n\tint moveToY;\n\tint leftFill;\n\tint rightFill;\n\tint line;\n\t/* newstyle not used.. */\n};\ntypedef struct stateChangeRecord *StateChangeRecord;\n\n\nstruct lineToRecord\n{\n\tint dx;\n\tint dy;\n};\ntypedef struct lineToRecord *LineToRecord;\n\n\nstruct curveToRecord\n{\n\tint controlx;\n\tint controly;\n\tint anchorx;\n\tint anchory;\n};\ntypedef struct curveToRecord *CurveToRecord;\n\ntypedef enum\n{\n\tSHAPERECORD_STATECHANGE,\n\tSHAPERECORD_LINETO,\n\tSHAPERECORD_CURVETO\n} shapeRecordType;\n\n\nstruct shapeRecord\n{\n\tshapeRecordType type;\n\n\tunion\n\t{\n\t\tStateChangeRecord stateChange;\n\t\tLineToRecord lineTo;\n\t\tCurveToRecord curveTo;\n\t} record;\n};\ntypedef struct shapeRecord ShapeRecord;\n\n\nstruct SWFShape_s\n{\n\tstruct SWFCharacter_s character;\n\n\tShapeRecord *records;\n\tint nRecords;\n\tSWFOutput out;\n\tint xpos;\t/* cursor for using abs. coords in lineTo, curveTo */\n\tint ypos;\n\tSWFLineStyle *lines;\n\tSWFFillStyle *fills;\n\tbyte nLines;\n\tbyte nFills;\n\tshort lineWidth;\n\tBOOL isMorph;\n\tBOOL isEnded;\n\tint useVersion;\n\t// SWF_DEFINESHAPE4 extensions\n\tunsigned char flags;\n\tSWFRect edgeBounds;\n#if TRACK_ALLOCS\n\t/* memory node for garbage collection */\n\tmem_node *gcnode;\n#endif\n};\n\n\nstatic void\nSWFShape_writeShapeRecord(SWFShape shape, ShapeRecord record, SWFOutput out);\n\n\nstatic void\nwriteSWFShapeBlockToMethod(SWFBlock block, \n                           SWFByteOutputMethod method, void* data)\n{\n\tSWFOutput out = ((SWFShape)block)->out;\n\tSWFOutput_writeToMethod(out, method, data);\n}\n\n\nstatic int\ncompleteSWFShapeBlock(SWFBlock block)\n{\n\tSWFShape shape = (SWFShape)block;\n\n\tSWFShape_end(shape);\n\t\n\treturn SWFOutput_getLength(shape->out);\n}\n\n\nvoid\ndestroySWFShape(SWFShape shape)\n{\n\tint i;\n\tif(shape->fills != NULL)\n\t{\n\t\t// Fills have to be destroyed by users. \n\t\t/*\n\t\tfor ( i=0; i<shape->nFills; ++i )\n\t\t\tdestroySWFFillStyle(shape->fills[i]);\n\t\t*/\n\t\tfree(shape->fills);\n\t}\n\tif(shape->records != NULL)\n\t{\n\t\tfor(i = 0; i < shape->nRecords; i++)\n\t\t{\n\t\t\tfree(shape->records[i].record.stateChange);\n\t\t}\n\t \tfree(shape->records);\n\t}\n\n\tif(shape->edgeBounds != NULL)\n\t\tfree(shape->edgeBounds);\n\n\tfor ( i=0; i<shape->nLines; ++i )\n\t\tfree(shape->lines[i]);\n\n\tif ( shape->lines != NULL )\n\t\tfree(shape->lines);\n\n\tdestroySWFOutput(shape->out);\n\n#if TRACK_ALLOCS\n\tming_gc_remove_node(shape->gcnode);\n#endif\n\n\tdestroySWFCharacter((SWFCharacter) shape);\n}\n\nSWFShape \nnewSWFGlyphShape()\n{\n\tSWFShape shape = (SWFShape)malloc(sizeof(struct SWFShape_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == shape)\n\t\treturn NULL;\n\n\tSWFCharacterInit((SWFCharacter)shape);\n\n\tBLOCK(shape)->writeBlock = NULL;\n\tBLOCK(shape)->complete = NULL;\n\tBLOCK(shape)->dtor = NULL;\n\tBLOCK(shape)->type = SWF_UNUSEDBLOCK;\n\t\n\tshape->out = newSWFOutput();\n\tCHARACTER(shape)->bounds = newSWFRect(0,0,0,0);\n\tshape->edgeBounds = newSWFRect(0,0,0,0);\n\n\tshape->records = NULL;\n\tshape->lines = NULL;\n\tshape->fills = NULL;\n\n\tshape->nRecords = 0;\n\tshape->xpos = 0;\n\tshape->ypos = 0;\n\tshape->nLines = 0;\n\tshape->nFills = 0;\n\tshape->lineWidth = 0;\n\tshape->isMorph = FALSE;\n\tshape->isEnded = FALSE;\n\tshape->flags = 0;\n\tshape->useVersion = 0;\n\n\tSWFOutput_writeUInt8(shape->out, 0); /* space for nFillBits, nLineBits */\n\n#if TRACK_ALLOCS\n\tshape->gcnode = ming_gc_add_node(shape, (dtorfunctype) destroySWFShape);\n#endif\n\n\treturn shape;\n}\n\nSWFShape\nnewSWFShape()\n{\n\tSWFShape shape = (SWFShape)malloc(sizeof(struct SWFShape_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == shape)\n\t\treturn NULL;\n\n\tSWFCharacterInit((SWFCharacter)shape);\n\n\tBLOCK(shape)->writeBlock = writeSWFShapeBlockToMethod;\n\tBLOCK(shape)->complete = completeSWFShapeBlock;\n\tBLOCK(shape)->dtor = (destroySWFBlockMethod) destroySWFShape;\n\tBLOCK(shape)->type = SWF_DEFINESHAPE3;\n\t\n\tCHARACTERID(shape) = ++SWF_gNumCharacters;\n\n\tshape->out = newSWFOutput();\n\tCHARACTER(shape)->bounds = newSWFRect(0,0,0,0);\n\tshape->edgeBounds = newSWFRect(0,0,0,0);\n\n\tshape->records = NULL;\n\tshape->lines = NULL;\n\tshape->fills = NULL;\n\n\tshape->nRecords = 0;\n\tshape->xpos = 0;\n\tshape->ypos = 0;\n\tshape->nLines = 0;\n\tshape->nFills = 0;\n\tshape->lineWidth = 0;\n\tshape->isMorph = FALSE;\n\tshape->isEnded = FALSE;\n\tshape->flags = 0;\n\tshape->useVersion = SWF_SHAPE3;\n\n\tSWFOutput_writeUInt8(shape->out, 0); /* space for nFillBits, nLineBits */\n\n#if TRACK_ALLOCS\n\tshape->gcnode = ming_gc_add_node(shape, (dtorfunctype) destroySWFShape);\n#endif\n\n\treturn shape;\n}\n\n\n/*\n * Creates a shape filled with bitmap\n */\nSWFShape\nnewSWFShapeFromBitmap(SWFBitmap bitmap, int flag)\n{\n\tSWFShape shape = newSWFShape();\n\tSWFFillStyle fill;\n\tint width, height;\n\n\tif ( flag != SWFFILL_TILED_BITMAP &&\n\t     flag != SWFFILL_CLIPPED_BITMAP &&\n\t     flag != SWFFILL_NONSMOOTHED_TILED_BITMAP &&\n\t     flag != SWFFILL_NONSMOOTHED_CLIPPED_BITMAP)\n\t{\n\t\tSWF_error(\"Invalid bitmap fill flag\");\n\t}\n\n\tfill = SWFShape_addBitmapFillStyle(shape, bitmap, flag);\n\n\twidth = SWFBitmap_getWidth(bitmap);\n\theight = SWFBitmap_getHeight(bitmap);\n\n\tSWFShape_setRightFillStyle(shape, fill);\n\n\t// XXX - scale shouldn't be hardcoded! (here, or in newSWFBitmapFillStyle)\n\tSWFShape_drawScaledLine(shape, width * 20, 0);\n\tSWFShape_drawScaledLine(shape, 0, height * 20);\n\tSWFShape_drawScaledLine(shape, -width * 20, 0);\n\tSWFShape_drawScaledLine(shape, 0, -height * 20);\n\n\treturn shape;\n}\n\nvoid\nSWFOutput_writeGlyphShape(SWFOutput out, SWFShape shape)\n{\n\tunsigned char c;\n\tint styleDone = 0;\n\tint i;\n\n\tc = 1<<4;\n\tSWFOutput_writeUInt8(out, c);\n\tshape->nFills = 1;\n\tshape->nLines = 0;\t\t\n\tfor ( i=0; i<shape->nRecords; ++i )\n\t{\n\t\tif(!styleDone && shape->records[i].type == SHAPERECORD_STATECHANGE)\n\t\t{\n\t\t\tshape->records[i].record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\t\tshape->records[i].record.stateChange->leftFill = 1;\n\t\t\tstyleDone = 1;\n\t\t}\t\n\t\n\t\tif ( i < shape->nRecords-1 ||\n\t\t\t\t shape->records[i].type != SHAPERECORD_STATECHANGE )\n\t\t{\n\t\t\tSWFShape_writeShapeRecord(shape, shape->records[i], out);\n\t\t}\n\t}\n\n\tSWFOutput_writeBits(out, 0, 6); /* end tag */\n\tSWFOutput_byteAlign(out);\n}\n\nvoid\nSWFShape_end(SWFShape shape)\n{\n\tint i;\n\tbyte* buffer;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tshape->isEnded = TRUE;\n\t\n\tbuffer = SWFOutput_getBuffer(shape->out);\n\tbuffer[0] =\n\t\t(SWFOutput_numBits(shape->nFills) << 4) + SWFOutput_numBits(shape->nLines);\n\n\tfor ( i=0; i<shape->nRecords; ++i )\n\t{\n\t\tif ( i < shape->nRecords-1 ||\n\t\t\t\t shape->records[i].type != SHAPERECORD_STATECHANGE )\n\t\t{\n\t\t\tSWFShape_writeShapeRecord(shape, shape->records[i], shape->out);\n\t\t}\n\n\t\tfree(shape->records[i].record.stateChange); /* all in union are pointers */\n\t}\n\n\tSWFOutput_writeBits(shape->out, 0, 6); /* end tag */\n\tSWFOutput_byteAlign(shape->out);\n\t\t\n\t/* addStyleHeader creates a new output and adds the existing one after\n\t\t itself- so even though it's called afterwards it's written before,\n\t\t as it should be */\n\tif ( BLOCK(shape)->type > 0 )\n\t{\n\t\tswitch (shape->useVersion)\n\t\t{\n\t\tcase SWF_SHAPE1:\n\t\t\tBLOCK(shape)->type = SWF_DEFINESHAPE;\n\t\t\tbreak;\n\t\tcase SWF_SHAPE2:\n\t\t\tBLOCK(shape)->type = SWF_DEFINESHAPE2;\n\t\t\tbreak;\n\t\tcase SWF_SHAPE4:\n\t\t\tBLOCK(shape)->type = SWF_DEFINESHAPE4;\n\t\t\tbreak;\n\t\t}\n\t\tSWFShape_addStyleHeader(shape);\n\t}\n\tfree(shape->records);\n\tshape->records = NULL;\n\tshape->nRecords = 0;\n}\n\n\nSWFOutput\nSWFShape_getOutput(SWFShape shape)\n{\n\treturn shape->out;\n}\n\n\nvoid\nSWFShape_getFills(SWFShape shape, SWFFillStyle** fills, int* nFills)\n{\n\t*fills = shape->fills;\n\t*nFills = shape->nFills;\n}\n\n\nvoid\nSWFShape_getLines(SWFShape shape, SWFLineStyle** lines, int* nLines)\n{\n\t*lines = shape->lines;\n\t*nLines = shape->nLines;\n}\n\n\nvoid\nSWFShape_setMorphFlag(SWFShape shape)\n{\n\tshape->isMorph = TRUE;\n}\n\n\nvoid\nSWFShape_addStyleHeader(SWFShape shape)\n{\n\tSWFOutput out = newSWFOutput();\n\tSWFOutput_writeUInt16(out, CHARACTERID(shape));\n\tSWFOutput_writeRect(out, SWFCharacter_getBounds(CHARACTER(shape)));\n\tif(shape->useVersion == SWF_SHAPE4)\n\t{\n\t\tSWFOutput_writeRect(out, shape->edgeBounds);\n\t\tSWFOutput_writeUInt8(out, shape->flags);\n\t}\n\t\n\tSWFOutput_writeFillStyles(out, shape->fills, shape->nFills, \n\t\tBLOCK(shape)->type, shape->edgeBounds);\n\tSWFOutput_writeLineStyles(out, shape->lines, shape->nLines, \n\t\tBLOCK(shape)->type, shape->edgeBounds);\n\t\n\t/* prepend shape->out w/ shape header */\n\tSWFOutput_setNext(out, shape->out);\n\tshape->out = out;\n}\n\n\n/*\n\tShapeRecords are an intermediate storage so that we don't have to specify\n\tfill/line types in advance.\n*/\n\n#define SHAPERECORD_INCREMENT 32\n\n/* copy shaperecord from other shape */ \nstatic ShapeRecord addShapeRecord(SWFShape shape, ShapeRecord record, \n                                  int *vx, int *vy, float scale)\n{\n\tif ( shape->nRecords % SHAPERECORD_INCREMENT == 0 )\n\t{\n\t\tshape->records = (ShapeRecord*) realloc(shape->records,\n\t\t\t\t\t sizeof(ShapeRecord) *\n\t\t\t\t\t (shape->nRecords + SHAPERECORD_INCREMENT));\n\t}\n\n\tswitch ( record.type )\n\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tStateChangeRecord change = (StateChangeRecord)\n\t\t\t\tcalloc(1,sizeof(struct stateChangeRecord));\n\t\t\t*change = *record.record.stateChange;\n\t\t\tshape->records[shape->nRecords].record.stateChange = change;\n\t\t\tchange->moveToX += shape->xpos;\n\t\t\tchange->moveToY += shape->ypos;\n\t\t\tchange->moveToX *= scale;\n\t\t\tchange->moveToY *= scale;\n\n\t\t\t*vx = change->moveToX;\n\t\t\t*vy = change->moveToY;\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tLineToRecord lineTo = (LineToRecord)\n\t\t\t\tcalloc(1,sizeof(struct lineToRecord));\n\t\t\t*lineTo = *record.record.lineTo;\n\t\t\tlineTo->dx *= scale;\n\t\t\tlineTo->dy *= scale;\n\t\t\tshape->records[shape->nRecords].record.lineTo = lineTo;\n\n\t\t\t*vx += lineTo->dx;\n\t\t\t*vy += lineTo->dy;\n\t\t\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t *vx, *vy, shape->lineWidth);\n\t\t\tSWFRect_includePoint(shape->edgeBounds, *vx, *vy, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_CURVETO:\n\t\t{\n\t\t\tCurveToRecord curveTo = (CurveToRecord) \n\t\t\t\tcalloc(1,sizeof(struct curveToRecord));\n\t\t\t*curveTo = *record.record.curveTo;\n\t\t\tcurveTo->controlx *= scale;\n\t\t\tcurveTo->controly *= scale;\n\t\t\tcurveTo->anchorx *= scale;\n\t\t\tcurveTo->anchory *= scale;\n\t\t\tshape->records[shape->nRecords].record.curveTo = curveTo;\n\t\t\t\n\t\t\t*vx += curveTo->controlx;\n\t\t\t*vy += curveTo->controly;\n\t\t\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t *vx, *vy, shape->lineWidth);\n\t\t\tSWFRect_includePoint(shape->edgeBounds, *vx, *vy, 0);\n\t\t\t*vx += curveTo->anchorx;\n\t\t\t*vy += curveTo->anchory;\n\t\t\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t *vx, *vy, shape->lineWidth);\n\t\t\tSWFRect_includePoint(shape->edgeBounds, *vx, *vy, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tshape->records[shape->nRecords].type = record.type;\n\tshape->nRecords++;\n\treturn shape->records[shape->nRecords-1];\n\n}\n\nstatic ShapeRecord\nnewShapeRecord(SWFShape shape, shapeRecordType type)\n{\n\tif ( shape->nRecords % SHAPERECORD_INCREMENT == 0 )\n\t{\n\t\tshape->records = (ShapeRecord*) realloc(shape->records,\n\t\t\t\t\t sizeof(ShapeRecord) *\n\t\t\t\t\t (shape->nRecords + SHAPERECORD_INCREMENT));\n\t}\n\n\tswitch ( type )\n\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tStateChangeRecord change = (StateChangeRecord)calloc(1,sizeof(struct stateChangeRecord));\n\t\t\tshape->records[shape->nRecords].record.stateChange = change;\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tLineToRecord lineTo = (LineToRecord) calloc(1,sizeof(struct lineToRecord));\n\t\t\tshape->records[shape->nRecords].record.lineTo = lineTo;\n\t\t\tbreak;\n\t\t}\n\t\tcase SHAPERECORD_CURVETO:\n\t\t{\n\t\t\tCurveToRecord curveTo = (CurveToRecord) calloc(1,sizeof(struct curveToRecord));\n\t\t\tshape->records[shape->nRecords].record.curveTo = curveTo;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tshape->records[shape->nRecords].type = type;\n\n// this is intentional - at least one popular compiler cannot handle [shape->nRecords++]\n\tshape->nRecords++;\n\treturn shape->records[shape->nRecords-1];\n}\n\n\nvoid\nSWFShape_writeShapeRecord(SWFShape shape, ShapeRecord record, SWFOutput out)\n{\n\tswitch(record.type)\n\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tint flags = record.record.stateChange->flags;\n\n\t\t\tif(flags == 0)\n\t\t\t\treturn;\n\n\t\t\tSWFOutput_writeBits(out, flags, 6);\n\n\t\t\tif(flags & SWF_SHAPE_MOVETOFLAG)\n\t\t\t{\n\t\t\t\tint x = record.record.stateChange->moveToX;\n\t\t\t\tint y = record.record.stateChange->moveToY;\n\t\t\t\tint nBits = max(SWFOutput_numSBits(x), SWFOutput_numSBits(y));\n\n\t\t\t\tSWF_assert(nBits<32);\n\t\t\t\tSWFOutput_writeBits(out, nBits, 5);\n\t\t\t\tSWFOutput_writeSBits(out, x, nBits);\n\t\t\t\tSWFOutput_writeSBits(out, y, nBits);\n\t\t\t}\n\n\t\t\tif(flags & SWF_SHAPE_FILLSTYLE0FLAG)\n\t\t\t{\n\t\t\t\tSWFOutput_writeBits(out, record.record.stateChange->leftFill,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numBits(shape->nFills));\n\t\t\t}\n\n\t\t\tif(flags & SWF_SHAPE_FILLSTYLE1FLAG)\n\t\t\t{\n\t\t\t\tSWFOutput_writeBits(out, record.record.stateChange->rightFill,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numBits(shape->nFills));\n\t\t\t}\n\n\t\t\tif(flags & SWF_SHAPE_LINESTYLEFLAG)\n\t\t\t{\n\t\t\t\tSWFOutput_writeBits(out, record.record.stateChange->line,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numBits(shape->nLines));\n\t\t\t}\n\n\t\t\t/* newstyle's never used.\t But this is what it looks like:\n\n\t\t\tif ( flags & SWF_SHAPE_NEWSTYLEFLAG )\n\t\t\t{\n\t\t\t\tSWFOutput_writeFillStyles(shape->out, shape->fills, shape->nFills,\n\t\t\t\tBLOCK(shape)->type);\n\n\t\t\t\tSWFOutput_writeLineStyles(shape->out, shape->lines, shape->nLines,\n\t\t\t\t\tBLOCK(shape)->type);\n\n\t\t\t\tSWFOutput_writeBits(shape->out, SWFOutput_numBits(shape->nFills), 4);\n\t\t\t\tSWFOutput_writeBits(shape->out, SWFOutput_numBits(shape->nLines), 4);\n\t\t\t}\n\n\t\t\t*/\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tint nBits;\n\t\t\tint dx = record.record.lineTo->dx;\n\t\t\tint dy = record.record.lineTo->dy;\n\n\t\t\tSWFOutput_writeBits(out, 3, 2); /* straight edge */\n\n\t\t\tif(dx==0)\n\t\t\t{\n\t\t\t\tnBits = SWFOutput_numSBits(dy);\n\t\t\t\tSWF_assert(nBits<18);\n\t\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\t\tSWFOutput_writeBits(out, 1, 2); /* vertical line */\n\t\t\t\tSWFOutput_writeSBits(out, dy, nBits);\n\t\t\t}\n\t\t\telse if(dy==0)\n\t\t\t{\n\t\t\t\tnBits = SWFOutput_numSBits(dx);\n\t\t\t\tSWF_assert(nBits<18);\n\t\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\t\tSWFOutput_writeBits(out, 0, 2); /* horizontal line */\n\t\t\t\tSWFOutput_writeSBits(out, dx, nBits);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnBits = max(SWFOutput_numSBits(dx), SWFOutput_numSBits(dy));\n\t\t\t\tSWF_assert(nBits<18);\n\t\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\t\tSWFOutput_writeBits(out, 1, 1); /* general line */\n\t\t\t\tSWFOutput_writeSBits(out, dx, nBits);\n\t\t\t\tSWFOutput_writeSBits(out, dy, nBits);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase SHAPERECORD_CURVETO:\n\t\t{\n\t\t\tint controlx = record.record.curveTo->controlx;\n\t\t\tint controly = record.record.curveTo->controly;\n\t\t\tint anchorx = record.record.curveTo->anchorx;\n\t\t\tint anchory = record.record.curveTo->anchory;\n\n\t\t\tint nBits = max(max(SWFOutput_numSBits(controlx),\n\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numSBits(controly)),\n\t\t\t\t\t\t\t\t\t\t\tmax(SWFOutput_numSBits(anchorx),\n\t\t\t\t\t\t\t\t\t\t\t\t\tSWFOutput_numSBits(anchory)));\n\n\t\t\tif ( nBits < 2 )\n\t\t\t\tnBits = 2;\n\n\t\t\tSWF_assert(nBits < 18);\n\n\t\t\tSWFOutput_writeBits(out, 2, 2); /* curved edge */\n\t\t\tSWFOutput_writeBits(out, nBits-2, 4);\n\t\t\tSWFOutput_writeSBits(out, controlx, nBits);\n\t\t\tSWFOutput_writeSBits(out, controly, nBits);\n\t\t\tSWFOutput_writeSBits(out, anchorx, nBits);\n\t\t\tSWFOutput_writeSBits(out, anchory, nBits);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tSWF_error(\"Unknown shapeRecordType\");\n\t}\n}\n\n\n/* x,y relative to shape origin */\nvoid\nSWFShape_drawScaledLineTo(SWFShape shape, int x, int y)\n{\n\tSWFShape_drawScaledLine(shape, x-shape->xpos, y-shape->ypos);\n}\n\n\nvoid\nSWFShape_drawScaledLine(SWFShape shape, int dx, int dy)\n{\n\tShapeRecord record;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tif ( dx == 0 && dy == 0 )\n\t\treturn;\n\n\trecord = newShapeRecord(shape, SHAPERECORD_LINETO);\n\n\tSWF_assert(SWFOutput_numSBits(dx) < 18);\n\tSWF_assert(SWFOutput_numSBits(dy) < 18);\n\n\trecord.record.lineTo->dx = dx;\n\trecord.record.lineTo->dy = dy;\n\n\tshape->xpos += dx;\n\tshape->ypos += dy;\n\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n}\n\n\nvoid\nSWFShape_drawScaledCurveTo(SWFShape shape,\n\t\t\t\t\t\t\t\t\t\t\t\t\t int controlx, int controly,\n\t\t\t\t\t\t\t\t\t\t\t\t\t int anchorx, int anchory)\n{\n\tSWFShape_drawScaledCurve(shape, controlx-shape->xpos, controly-shape->ypos,\n\t\t\t\t\t\t\t\t\t\t\t\t\t anchorx-controlx, anchory-controly);\n}\n\n\nvoid\nSWFShape_drawScaledCurve(SWFShape shape,\n\t\t\t\t\t\t\t\t\t\t\t\t int controldx, int controldy,\n\t\t\t\t\t\t\t\t\t\t\t\t int anchordx, int anchordy)\n{\n\tShapeRecord record;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tif ( controldx == 0 && controldy == 0 && anchordx == 0 && anchordy == 0 )\n\t\treturn;\n\t\n\t// printf(\"curve %i,%i, %i, %i\\n\", controldx, controldy, anchordx,  anchordy);\n\n\trecord = newShapeRecord(shape, SHAPERECORD_CURVETO);\n\n\trecord.record.curveTo->controlx = controldx;\n\trecord.record.curveTo->controly = controldy;\n\trecord.record.curveTo->anchorx = anchordx;\n\trecord.record.curveTo->anchory = anchordy;\n\n\tif ( SWFOutput_numSBits(controldx) >= 18 ||\n\t\t\t SWFOutput_numSBits(controldy) >= 18 ||\n\t\t\t SWFOutput_numSBits(anchordx) >= 18 ||\n\t\t\t SWFOutput_numSBits(anchordy) >= 18 )\n\t\tSWF_error(\"Curve parameters too large\");\n\n\t/* including the control point is sloppy, but safe.. */\n\n\tshape->xpos += controldx;\n\tshape->ypos += controldy;\n\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n\tshape->xpos += anchordx;\n\tshape->ypos += anchordy;\n\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n}\n\n\n#define STYLE_INCREMENT 4\n\nstatic inline void growLineArray(SWFShape shape)\n{\n\tint size;\n\n\tif ( shape->nLines % STYLE_INCREMENT != 0 )\n\t\treturn;\n\n\tsize = (shape->nLines+STYLE_INCREMENT) * sizeof(SWFLineStyle);\n\tshape->lines = (SWFLineStyle*)realloc(shape->lines, size);\t\n}\n\nstatic int \nSWFShape_addLineStyle2filled(SWFShape shape, unsigned short width,\n                             SWFFillStyle fill,\n                             int flags, float miterLimit)\n{\n\tgrowLineArray(shape);\n\tSWFShape_useVersion(shape, SWF_SHAPE4);\n\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\tshape->lines[shape->nLines] = newSWFLineStyle2_filled(width, fill, flags, miterLimit);\n\treturn ++shape->nLines;\n}\n\nstatic int\nSWFShape_addLineStyle2(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a,\n                      int flags, float miterLimit)\n{\n\tgrowLineArray(shape);\n\tSWFShape_useVersion(shape, SWF_SHAPE4);\n\tshape->lines[shape->nLines] = newSWFLineStyle2(width, r, g, b, a, flags, miterLimit);\n\treturn ++shape->nLines;\n}\n\nstatic int\nSWFShape_addLineStyle(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tgrowLineArray(shape);\n\tshape->lines[shape->nLines] = newSWFLineStyle(width, r, g, b, a);\n\treturn ++shape->nLines;\n}\n\n\n/* if the current shape record isn't a style change record, add one */\nstatic ShapeRecord\naddStyleRecord(SWFShape shape)\n{\n\tif ( shape->nRecords > 0 &&\n\t\t\t shape->records[shape->nRecords-1].type == SHAPERECORD_STATECHANGE )\n\t{\n\t\treturn shape->records[shape->nRecords-1];\n\t}\n\telse\n\t\treturn newShapeRecord(shape, SHAPERECORD_STATECHANGE);\n}\n\n\nvoid\nSWFShape_hideLine(SWFShape shape)\n{\n\tShapeRecord record;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tif ( shape->isMorph )\n\t\treturn;\n\n\trecord = addStyleRecord(shape);\n\n\trecord.record.stateChange->line = 0;\n\trecord.record.stateChange->flags |= SWF_SHAPE_LINESTYLEFLAG;\n}\n\nstatic void finishSetLine(SWFShape shape, int line, unsigned short width)\n{\n\tShapeRecord record;\n\t\n\tif ( width == 0 )\n\t\tshape->lineWidth = 0;\n\telse\n\t\tshape->lineWidth = (SWFLineStyle_getWidth(shape->lines[line-1]) + 1) / 2;\n\t\n\tif ( shape->isMorph )\n\t\treturn;\n\n\trecord = addStyleRecord(shape);\n\n\trecord.record.stateChange->line = line;\n\trecord.record.stateChange->flags |= SWF_SHAPE_LINESTYLEFLAG;\n}\n\n/*\n * set filled Linestyle2 introduce with SWF 8.\n * \n * set line width in TWIPS\n *\n * WARNING: this is an internal interface\n * external use is deprecated! use setLine2 instead\n *\n * Instead of providing a fill color, a FillStyle can be applied\n * to a line.\n * \n * Linestyle2 also extends Linestyle1 with some extra flags:\n *\n * Line cap style: select one of the following flags (default is round cap style)\n * SWF_LINESTYLE_CAP_ROUND \n * SWF_LINESTYLE_CAP_NONE\n * SWF_LINESTYLE_CAP_SQUARE \n *\n * Line join style: select one of the following flags (default is round join style)\n * SWF_LINESTYLE_JOIN_ROUND\n * SWF_LINESTYLE_JOIN_BEVEL \n * SWF_LINESTYLE_JOIN_MITER  \n *\n * Scaling flags: disable horizontal / vertical scaling\n * SWF_LINESTYLE_FLAG_NOHSCALE\n * SWF_LINESTYLE_FLAG_NOVSCALE \n *\n * Enable pixel hinting to correct blurry vertical / horizontal lines\n * -> all anchors will be aligned to full pixels\n * SWF_LINESTYLE_FLAG_HINTING  \n *\n * Disable stroke closure: if no-close flag is set caps will be applied \n * instead of joins\n * SWF_LINESTYLE_FLAG_NOCLOSE\n *\n * End-cap style: default round\n * SWF_LINESTYLE_FLAG_ENDCAP_ROUND\n * SWF_LINESTYLE_FLAG_ENDCAP_NONE\n * SWF_LINESTYLE_FLAG_ENDCAP_SQUARE\n *\n * If join style is SWF_LINESTYLE_JOIN_MITER a miter limit factor \n * must be set. Miter max length is then calculated as:\n * max miter len = miter limit * width.\n * If join style is not miter, this value will be ignored.\n */\nvoid \nSWFShape_setLineStyle2filled_internal(SWFShape shape, unsigned short width,\n                       SWFFillStyle fill,\n                       int flags, float miterLimit)\n{\n\tint line;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals2filled(shape->lines[line], width, fill, flags) )\n\t\t\tbreak;\n\t}\n\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle2filled(shape, width, fill, flags, miterLimit);\n\telse\n\t\t++line;\n\n\tfinishSetLine(shape, line, width);\n}\n\n\n/*\n * set Linestyle2 introduce with SWF 8.\n *\n * set line width in TWIPS\n * WARNING: this is an internal interface\n * external use is deprecated! use setLine2 instead !\n * set color {r, g, b, a}\n *\n * Linestyle2 extends Linestyle1 with some extra flags:\n *\n * Line cap style: select one of the following flags (default is round cap style)\n * SWF_LINESTYLE_CAP_ROUND \n * SWF_LINESTYLE_CAP_NONE\n * SWF_LINESTYLE_CAP_SQUARE \n *\n * Line join style: select one of the following flags (default is round join style)\n * SWF_LINESTYLE_JOIN_ROUND\n * SWF_LINESTYLE_JOIN_BEVEL \n * SWF_LINESTYLE_JOIN_MITER  \n *\n * Scaling flags: disable horizontal / vertical scaling\n * SWF_LINESTYLE_FLAG_NOHSCALE\n * SWF_LINESTYLE_FLAG_NOVSCALE \n *\n * Enable pixel hinting to correct blurry vertical / horizontal lines\n * -> all anchors will be aligned to full pixels\n * SWF_LINESTYLE_FLAG_HINTING  \n *\n * Disable stroke closure: if no-close flag is set caps will be applied \n * instead of joins\n * SWF_LINESTYLE_FLAG_NOCLOSE\n *\n * End-cap style: default round\n * SWF_LINESTYLE_FLAG_ENDCAP_ROUND\n * SWF_LINESTYLE_FLAG_ENDCAP_NONE\n * SWF_LINESTYLE_FLAG_ENDCAP_SQUARE\n *\n * If join style is SWF_LINESTYLE_JOIN_MITER a miter limit factor \n * must be set. Miter max length is then calculated as:\n * max miter len = miter limit * width.\n * If join style is not miter, this value will be ignored.\n */\nvoid \nSWFShape_setLineStyle2_internal(SWFShape shape, unsigned short width,\n                       byte r, byte g, byte b, byte a,\n                       int flags, float miterLimit)\n{\n\tint line;\n\n\tif ( shape->isEnded )\n\t\treturn;\n\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, flags) )\n\t\t\tbreak;\n\t}\n\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle2(shape, width, r, g, b, a, flags, miterLimit);\n\telse\n\t\t++line;\n\n\tfinishSetLine(shape, line, width);\n}\n\n\n/*\n * set line width and line color\n *\n * set line width in TWIPS\n * set line color as {r, g, b, a}\n *\n * WARNING: this is an internal interface.\n * external use is deprecated! use setLine instead ! \n */\nvoid\nSWFShape_setLineStyle_internal(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tint line;\n\t\t\n\tif ( shape->isEnded )\n\t\treturn;\n\t\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, 0) )\n\t\t\tbreak;\n\t}\n\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle(shape, width, r, g, b, a);\n\telse\n\t\t++line;\n\t\n\tfinishSetLine(shape, line, width);\n}\n\n\n/* fill 0 is no fill, so set idx to one more than the shape's fill index */\nstatic int getFillIdx(SWFShape shape, SWFFillStyle fill)\n{\n\tint i;\n\n\tfor ( i=0; i<shape->nFills; ++i )\n\t{\n\t\tif ( SWFFillStyle_equals(fill, shape->fills[i]) )\n\t\t\treturn (i+1);\n\t}\n\treturn 0; // no fill\n}\n\nstatic int addFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tint i;\n\t\n\tfor ( i=0; i<shape->nFills; ++i )\n\t{\n\t\tif ( SWFFillStyle_equals(fill, shape->fills[i]) )\n\t\t\treturn i;\n\t}\n\n\tif ( shape->isEnded )\n\t\treturn -1;\n\n\tif ( shape->nFills%STYLE_INCREMENT == 0 )\n\t{\n\t\tint size = (shape->nFills+STYLE_INCREMENT) * sizeof(SWFFillStyle);\n\t\tshape->fills = (SWFFillStyle*)realloc(shape->fills, size);\n\t}\n\n\tshape->fills[shape->nFills] = fill;\n\t++shape->nFills;\n\treturn shape->nFills;\n}\n\n\nSWFFillStyle\nSWFShape_addSolidFillStyle(SWFShape shape, byte r, byte g, byte b, byte a)\n{\n\tint  ret;\n\n\tSWFFillStyle fill = newSWFSolidFillStyle(r, g, b, a);\n\t\n\tret = addFillStyle(shape, fill);\n\tif(ret < 0) /* error */\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\telse if(ret == shape->nFills)  /* new fill */\n\t{\n\t\treturn fill;\n\t}\n\telse /* fill is known */ \n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn shape->fills[ret];\n\t}\n}\n\n\nSWFFillStyle\nSWFShape_addGradientFillStyle(SWFShape shape, SWFGradient gradient, byte flags)\n{\n\tSWFFillStyle fill = newSWFGradientFillStyle(gradient, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\t\t\n}\n\n\nSWFFillStyle\nSWFShape_addBitmapFillStyle(SWFShape shape, SWFBitmap bitmap, byte flags)\n{\n\tSWFFillStyle fill;\n\n\tif ( bitmap )\n\t{\n\t\tSWFCharacter_addDependency((SWFCharacter)shape,\n\t\t                           (SWFCharacter)bitmap);\n\t}\n\n\tfill = newSWFBitmapFillStyle(bitmap, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\n}\n\n\nvoid\nSWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\t\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) // fill not present in array\n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\t\t\t\t\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}\n\n\nvoid\nSWFShape_setRightFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\t\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->rightFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE1FLAG;\n\t\treturn;\n\t}\n\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) // fill not present in array\n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\t\t\t\t\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->rightFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE1FLAG;\n}\n\n/* move pen relative to shape origin */\nvoid\nSWFShape_moveScaledPenTo(SWFShape shape, int x, int y)\n{\n\tShapeRecord record;\n\tif ( shape->isEnded )\n\t\treturn;\n\n\trecord = addStyleRecord(shape);\n\n\trecord.record.stateChange->moveToX = shape->xpos = x;\n\trecord.record.stateChange->moveToY = shape->ypos = y;\n\n\trecord.record.stateChange->flags |= SWF_SHAPE_MOVETOFLAG;\n\n\tif ( shape->nRecords == 0 ||\n\t\t\t (shape->nRecords == 1 &&\n\t\t\t\tshape->records[0].type == SHAPERECORD_STATECHANGE) )\n\t{\n\t\tSWFRect_setBounds(SWFCharacter_getBounds(CHARACTER(shape)), x, x, y, y);\n\t\tSWFRect_setBounds(shape->edgeBounds, x, x, y, y);\n\t}\n}\n\n\nvoid\nSWFShape_moveScaledPen(SWFShape shape, int x, int y)\n{\n\tSWFShape_moveScaledPenTo(shape, shape->xpos+x, shape->ypos+y);\n}\n\n\nint\nSWFShape_getScaledPenX(SWFShape shape)\n{\n\treturn shape->xpos;\n}\n\n\nint\nSWFShape_getScaledPenY(SWFShape shape)\n{\n\treturn shape->ypos;\n}\n\nvoid\nSWFShape_drawScaledGlyph(SWFShape shape,\n                         SWFFont font, unsigned short c, int size)\n{\n\tSWFShape glyph;\n\tint i, vx, vy;\n\tif(font == NULL)\n\t\treturn;\n\t\n\tglyph = SWFFont_getGlyph(font, c);\n\tif(glyph == NULL)\n\t{\n\t\tSWF_warn(\"SWFShape_drawScaledGlyph: no glyph for code %i found \\n\", c);\n\t\treturn;\n\t}\n\n\tvx = shape->xpos;\n\tvy = shape->ypos;\n\tfor(i = 0; i < glyph->nRecords; i++)\n\t\taddShapeRecord(shape, glyph->records[i], &vx, &vy, size/1024.0);\n}\n\n/*\n * set shape version manualy\n * This function allows to set the shapes version information. The\n * version is only a hint. if necessary the version is upgraded. \n * valid values: SWF_SHAPE3 and SWF_SHAPE4 \n * 3 is default\n * 4 if linestyle2 is used\n */\nvoid SWFShape_useVersion(SWFShape shape, int version)\n{\n\tif(shape->useVersion >= version)\n\t\treturn;\n\tif(version > SWF_SHAPE4)\n\t\treturn;\n\tshape->useVersion = version;\n}\n\n/*\n * get shape version\n * possible values SWF_SHAPE3 and SWF_SHAPE4 \n */\nint SWFShape_getVersion(SWFShape shape)\n{\n\treturn shape->useVersion;\n}\n\n/* \n * set render hinting flags\n * possible values:\n * SWF_SHAPE_USESCALINGSTROKES \tSWF_SHAPE_USENONSCALINGSTROKES\t\n */\nvoid SWFShape_setRenderHintingFlags(SWFShape shape, int flags)\n{\n\tflags &= (SWF_SHAPE_USESCALINGSTROKES | SWF_SHAPE_USENONSCALINGSTROKES);\n\tshape->flags = flags;\n\tSWFShape_useVersion(shape, SWF_SHAPE4);\n}\n\nSWFRect SWFShape_getEdgeBounds(SWFShape shape)\n{\n\tif(shape->useVersion == SWF_SHAPE4)\n\t\treturn shape->edgeBounds;\n\telse\n\t\treturn NULL;\n}\n\nint SWFShape_getFlags(SWFShape shape)\n{\n\tif(shape->useVersion == SWF_SHAPE4)\n\t\treturn shape->flags;\n\telse\n\t\treturn 0;\n}\n\nstruct out \t \n{       char *buf, *ptr; \t \n\tint len; \t \n}; \t \n\t  \t \nstatic void oprintf(struct out *op, const char *fmt, ...) \t \n{\n\tva_list ap; \t \n\tchar buf[256]; \t \n\tint d, l; \t \n\t  \t \n\tva_start(ap, fmt); \t \n\tl = vsprintf(buf, fmt, ap); \t \n\twhile((d = op->ptr - op->buf) + l >= op->len-1) \t \n\t{\n\t\top->buf = (char *) realloc(op->buf, op->len += 100); \t \n\t\top->ptr = op->buf + d; \t \n\t} \t \n\tfor(d = 0 ; d < l ; d++) \t \n\t\t*op->ptr++ = buf[d]; \t \n}\n\nchar * SWFShape_dumpOutline(SWFShape s) \t \n{ \t \n\tstruct out o; \t \n\tint i;\n\tint x = 0, y = 0;\n \n\to.len = 0; \t \n\to.ptr = o.buf = (char *)malloc(1); \t \n\t*o.ptr = 0; \t \n\t  \t \n\tfor (i = 0; i < s->nRecords; i++) \t \n\t{\n\t\tShapeRecord *record = s->records + i;\n\t\tswitch(record->type)\n\t\t{\n\t\tcase SHAPERECORD_STATECHANGE:\n\t\t{\n\t\t\tif(!record->record.stateChange->flags & SWF_SHAPE_MOVETOFLAG)\n\t\t\t\tcontinue;\n\t\t\tx = record->record.stateChange->moveToX;\n\t\t\ty = record->record.stateChange->moveToY;\n\t\t\toprintf(&o, \"moveto %d,%d\\n\", x, y);\n\t\t\tbreak;\n\t\t}\n\t  \tcase SHAPERECORD_LINETO:\n\t\t{\n\t\t\tx += record->record.lineTo->dx;\n\t\t\ty += record->record.lineTo->dy;\n\t\t\toprintf(&o, \"lineto %d,%d\\n\", x, y);\n\t\t\tbreak; \t \n\t\t} \t \n\t\tcase SHAPERECORD_CURVETO: \t \n\t\t{ \t \n\t\t\tint controlX = record->record.curveTo->controlx;\n\t\t\tint controlY = record->record.curveTo->controly;\n\t\t\tint anchorX = record->record.curveTo->anchorx;\n\t\t\tint anchorY = record->record.curveTo->anchory;\n\n\t\t\toprintf(&o, \"curveto %d,%d %d,%d\\n\", \t \n\t\t\t\tx+controlX, y+controlY, \t \n\t\t\t\tx+controlX+anchorX, y+controlY+anchorY); \t \n\t  \t \n\t\t\t\tx += controlX + anchorX; \t \n\t\t\t\ty += controlY + anchorY;\n\t\t\tbreak; \n\t\t}\n\t\tdefault: break;\n\t\t}\n\t} \t \n\t  \t \n\t*o.ptr = 0; \t \n\treturn o.buf; \t \n}\n\n\n/*\n * Local variables:\n * tab-width: 2\n * c-basic-offset: 2\n * End:\n */\n"], "filenames": ["src/blocks/shape.c"], "buggy_code_start_loc": [1171], "buggy_code_end_loc": [1171], "fixing_code_start_loc": [1172], "fixing_code_end_loc": [1177], "type": "CWE-20", "message": "Ming (aka libming) 0.4.8 has an \"fill overflow\" vulnerability in the function SWFShape_setLeftFillStyle in blocks/shape.c.", "other": {"cve": {"id": "CVE-2019-12981", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-26T18:15:10.543", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ming (aka libming) 0.4.8 has an \"fill overflow\" vulnerability in the function SWFShape_setLeftFillStyle in blocks/shape.c."}, {"lang": "es", "value": "Ming (aka libming) versi\u00f3n 0.4.8 tiene una vulnerabilidad de \"fill overflow\" en la funci\u00f3n SWFShape_setLeftFillStyle en blocks/shape.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libming:libming:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "DD92BC79-2548-4C6F-9BDD-26C12BDF68AC"}]}]}], "references": [{"url": "https://github.com/libming/libming/commit/6e76e8c71cb51c8ba0aa9737a636b9ac3029887f", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libming/libming/commit/6e76e8c71cb51c8ba0aa9737a636b9ac3029887f"}}