{"buggy_code": ["require 'rexml/parsers/streamparser'\nrequire 'rexml/parsers/baseparser'\nrequire 'rexml/light/node'\nrequire 'rexml/text'\nrequire 'date'\nrequire 'time'\nrequire 'yaml'\nrequire 'bigdecimal'\n\n# This is a slighly modified version of the XMLUtilityNode from\n# http://merb.devjavu.com/projects/merb/ticket/95 (has.sox@gmail.com)\n# It's mainly just adding vowels, as I ht cd wth n vwls :)\n# This represents the hard part of the work, all I did was change the\n# underlying parser.\nclass REXMLUtilityNode #:nodoc:\n  attr_accessor :name, :attributes, :children, :type\n\n  def self.typecasts\n    @@typecasts\n  end\n\n  def self.typecasts=(obj)\n    @@typecasts = obj\n  end\n\n  def self.available_typecasts\n    @@available_typecasts\n  end\n\n  def self.available_typecasts=(obj)\n    @@available_typecasts = obj\n  end\n\n  self.typecasts = {}\n  self.typecasts[\"integer\"]       = lambda{|v| v.nil? ? nil : v.to_i}\n  self.typecasts[\"boolean\"]       = lambda{|v| v.nil? ? nil : (v.strip != \"false\")}\n  self.typecasts[\"datetime\"]      = lambda{|v| v.nil? ? nil : Time.parse(v).utc}\n  self.typecasts[\"date\"]          = lambda{|v| v.nil? ? nil : Date.parse(v)}\n  self.typecasts[\"dateTime\"]      = lambda{|v| v.nil? ? nil : Time.parse(v).utc}\n  self.typecasts[\"decimal\"]       = lambda{|v| v.nil? ? nil : BigDecimal(v.to_s)}\n  self.typecasts[\"double\"]        = lambda{|v| v.nil? ? nil : v.to_f}\n  self.typecasts[\"float\"]         = lambda{|v| v.nil? ? nil : v.to_f}\n  self.typecasts[\"symbol\"]        = lambda{|v| v.nil? ? nil : v.to_sym}\n  self.typecasts[\"string\"]        = lambda{|v| v.to_s}\n  self.typecasts[\"yaml\"]          = lambda{|v| v.nil? ? nil : YAML.load(v)}\n  self.typecasts[\"base64Binary\"]  = lambda{|v| v.unpack('m').first }\n\n  self.available_typecasts = self.typecasts.keys\n\n  def initialize(name, normalized_attributes = {})\n\n    # unnormalize attribute values\n    attributes = Hash[* normalized_attributes.map { |key, value|\n      [ key, unnormalize_xml_entities(value) ]\n    }.flatten]\n\n    @name         = name.tr(\"-\", \"_\")\n    # leave the type alone if we don't know what it is\n    @type         = self.class.available_typecasts.include?(attributes[\"type\"]) ? attributes.delete(\"type\") : attributes[\"type\"]\n\n    @nil_element  = attributes.delete(\"nil\") == \"true\"\n    @attributes   = undasherize_keys(attributes)\n    @children     = []\n    @text         = false\n  end\n\n  def add_node(node)\n    @text = true if node.is_a? String\n    @children << node\n  end\n\n  def to_hash\n    if @type == \"file\"\n      f = StringIO.new((@children.first || '').unpack('m').first)\n      class << f\n        attr_accessor :original_filename, :content_type\n      end\n      f.original_filename = attributes['name'] || 'untitled'\n      f.content_type = attributes['content_type'] || 'application/octet-stream'\n      return {name => f}\n    end\n\n    if @text\n      t = typecast_value( unnormalize_xml_entities( inner_html ) )\n      if t.is_a?(String)\n        class << t\n          attr_accessor :attributes\n        end\n        t.attributes = attributes\n      end\n      return { name => t }\n    else\n      #change repeating groups into an array\n      groups = @children.inject({}) { |s,e| (s[e.name] ||= []) << e; s }\n\n      out = nil\n      if @type == \"array\"\n        out = []\n        groups.each do |k, v|\n          if v.size == 1\n            out << v.first.to_hash.entries.first.last\n          else\n            out << v.map{|e| e.to_hash[k]}\n          end\n        end\n        out = out.flatten\n\n      else # If Hash\n        out = {}\n        groups.each do |k,v|\n          if v.size == 1\n            out.merge!(v.first)\n          else\n            out.merge!( k => v.map{|e| e.to_hash[k]})\n          end\n        end\n        out.merge! attributes unless attributes.empty?\n        out = out.empty? ? nil : out\n      end\n\n      if @type && out.nil?\n        { name => typecast_value(out) }\n      else\n        { name => out }\n      end\n    end\n  end\n\n  # Typecasts a value based upon its type. For instance, if\n  # +node+ has #type == \"integer\",\n  # {{[node.typecast_value(\"12\") #=> 12]}}\n  #\n  # @param value<String> The value that is being typecast.\n  #\n  # @details [:type options]\n  #   \"integer\"::\n  #     converts +value+ to an integer with #to_i\n  #   \"boolean\"::\n  #     checks whether +value+, after removing spaces, is the literal\n  #     \"true\"\n  #   \"datetime\"::\n  #     Parses +value+ using Time.parse, and returns a UTC Time\n  #   \"date\"::\n  #     Parses +value+ using Date.parse\n  #\n  # @return <Integer, TrueClass, FalseClass, Time, Date, Object>\n  #   The result of typecasting +value+.\n  #\n  # @note\n  #   If +self+ does not have a \"type\" key, or if it's not one of the\n  #   options specified above, the raw +value+ will be returned.\n  def typecast_value(value)\n    return value unless @type\n    proc = self.class.typecasts[@type]\n    proc.nil? ? value : proc.call(value)\n  end\n\n  # Take keys of the form foo-bar and convert them to foo_bar\n  def undasherize_keys(params)\n    params.keys.each do |key, value|\n      params[key.tr(\"-\", \"_\")] = params.delete(key)\n    end\n    params\n  end\n\n  # Get the inner_html of the REXML node.\n  def inner_html\n    @children.join\n  end\n\n  # Converts the node into a readable HTML node.\n  #\n  # @return <String> The HTML node in text form.\n  def to_html\n    attributes.merge!(:type => @type ) if @type\n    \"<#{name}#{Crack::Util.to_xml_attributes(attributes)}>#{@nil_element ? '' : inner_html}</#{name}>\"\n  end\n\n  # @alias #to_html #to_s\n  def to_s\n    to_html\n  end\n\n  private\n\n  def unnormalize_xml_entities value\n    REXML::Text.unnormalize(value)\n  end\nend\n\nmodule Crack\n\tclass REXMLParser\n    def self.parse(xml)\n      stack = []\n      parser = REXML::Parsers::BaseParser.new(xml)\n\n      while true\n        event = parser.pull\n        case event[0]\n        when :end_document\n          break\n        when :end_doctype, :start_doctype\n          # do nothing\n        when :start_element\n          stack.push REXMLUtilityNode.new(event[1], event[2])\n        when :end_element\n          if stack.size > 1\n            temp = stack.pop\n            stack.last.add_node(temp)\n          end\n        when :text, :cdata\n          stack.last.add_node(event[1]) unless event[1].strip.length == 0 || stack.empty?\n        end\n      end\n      stack.length > 0 ? stack.pop.to_hash : {}\n    end\n  end\n\n  class XML\n    def self.parser\n      @@parser ||= REXMLParser\n    end\n\n    def self.parser=(parser)\n      @@parser = parser\n    end\n\n    def self.parse(xml)\n      parser.parse(xml)\n    end\n  end\nend\n", "require 'test_helper'\n\nclass XmlTest < Test::Unit::TestCase\n  should \"should transform a simple tag with content\" do\n    xml = \"<tag>This is the contents</tag>\"\n    Crack::XML.parse(xml).should == { 'tag' => 'This is the contents' }\n  end\n\n  should \"should work with cdata tags\" do\n    xml = <<-END\n      <tag>\n      <![CDATA[\n        text inside cdata\n      ]]>\n      </tag>\n    END\n    Crack::XML.parse(xml)[\"tag\"].strip.should == \"text inside cdata\"\n  end\n\n  should \"should transform a simple tag with attributes\" do\n    xml = \"<tag attr1='1' attr2='2'></tag>\"\n    hash = { 'tag' => { 'attr1' => '1', 'attr2' => '2' } }\n    Crack::XML.parse(xml).should == hash\n  end\n\n  should \"should transform repeating siblings into an array\" do\n    xml =<<-XML\n      <opt>\n        <user login=\"grep\" fullname=\"Gary R Epstein\" />\n        <user login=\"stty\" fullname=\"Simon T Tyson\" />\n      </opt>\n    XML\n\n    Crack::XML.parse(xml)['opt']['user'].class.should == Array\n\n    hash = {\n      'opt' => {\n        'user' => [{\n          'login'    => 'grep',\n          'fullname' => 'Gary R Epstein'\n        },{\n          'login'    => 'stty',\n          'fullname' => 'Simon T Tyson'\n        }]\n      }\n    }\n\n    Crack::XML.parse(xml).should == hash\n  end\n\n  should \"should not transform non-repeating siblings into an array\" do\n    xml =<<-XML\n      <opt>\n        <user login=\"grep\" fullname=\"Gary R Epstein\" />\n      </opt>\n    XML\n\n    Crack::XML.parse(xml)['opt']['user'].class.should == Hash\n\n    hash = {\n      'opt' => {\n        'user' => {\n          'login' => 'grep',\n          'fullname' => 'Gary R Epstein'\n        }\n      }\n    }\n    \n    Crack::XML.parse(xml).should == hash\n  end\n  \n  context \"Parsing xml with text and attributes\" do\n    setup do\n      xml =<<-XML\n        <opt>\n          <user login=\"grep\">Gary R Epstein</user>\n          <user>Simon T Tyson</user>\n        </opt>\n      XML\n      @data = Crack::XML.parse(xml)\n    end\n\n    should \"correctly parse text nodes\" do\n      @data.should == {\n        'opt' => {\n          'user' => [\n            'Gary R Epstein',\n            'Simon T Tyson'\n          ]\n        }\n      }\n    end\n    \n    should \"be parse attributes for text node if present\" do\n      @data['opt']['user'][0].attributes.should == {'login' => 'grep'}\n    end\n    \n    should \"default attributes to empty hash if not present\" do\n      @data['opt']['user'][1].attributes.should == {}\n    end\n    \n    should \"add 'attributes' accessor methods to parsed instances of String\" do\n      @data['opt']['user'][0].respond_to?(:attributes).should be(true)\n      @data['opt']['user'][0].respond_to?(:attributes=).should be(true)\n    end\n    \n    should \"not add 'attributes' accessor methods to all instances of String\" do\n      \"some-string\".respond_to?(:attributes).should be(false)\n      \"some-string\".respond_to?(:attributes=).should be(false)\n    end\n  end\n\n  should \"should typecast an integer\" do\n    xml = \"<tag type='integer'>10</tag>\"\n    Crack::XML.parse(xml)['tag'].should == 10\n  end\n\n  should \"should typecast a true boolean\" do\n    xml = \"<tag type='boolean'>true</tag>\"\n    Crack::XML.parse(xml)['tag'].should be(true)\n  end\n\n  should \"should typecast a false boolean\" do\n    [\"false\"].each do |w|\n      Crack::XML.parse(\"<tag type='boolean'>#{w}</tag>\")['tag'].should be(false)\n    end\n  end\n\n  should \"should typecast a datetime\" do\n    xml = \"<tag type='datetime'>2007-12-31 10:32</tag>\"\n    Crack::XML.parse(xml)['tag'].should == Time.parse( '2007-12-31 10:32' ).utc\n  end\n\n  should \"should typecast a date\" do\n    xml = \"<tag type='date'>2007-12-31</tag>\"\n    Crack::XML.parse(xml)['tag'].should == Date.parse('2007-12-31')\n  end\n\n  xml_entities = {\n    \"<\" => \"&lt;\",\n    \">\" => \"&gt;\",\n    '\"' => \"&quot;\",\n    \"'\" => \"&apos;\",\n    \"&\" => \"&amp;\"\n  }\n  should \"should unescape html entities\" do\n    xml_entities.each do |k,v|\n      xml = \"<tag>Some content #{v}</tag>\"\n      Crack::XML.parse(xml)['tag'].should =~ Regexp.new(k)\n    end\n  end\n  \n  should \"should unescape XML entities in attributes\" do\n    xml_entities.each do |k,v|\n      xml = \"<tag attr='Some content #{v}'></tag>\"\n      Crack::XML.parse(xml)['tag']['attr'].should =~ Regexp.new(k)\n    end\n  end\n\n  should \"should undasherize keys as tags\" do\n    xml = \"<tag-1>Stuff</tag-1>\"\n    Crack::XML.parse(xml).keys.should include( 'tag_1' )\n  end\n\n  should \"should undasherize keys as attributes\" do\n    xml = \"<tag1 attr-1='1'></tag1>\"\n    Crack::XML.parse(xml)['tag1'].keys.should include( 'attr_1')\n  end\n\n  should \"should undasherize keys as tags and attributes\" do\n    xml = \"<tag-1 attr-1='1'></tag-1>\"\n    Crack::XML.parse(xml).keys.should include( 'tag_1' )\n    Crack::XML.parse(xml)['tag_1'].keys.should include( 'attr_1')\n  end\n\n  should \"should render nested content correctly\" do\n    xml = \"<root><tag1>Tag1 Content <em><strong>This is strong</strong></em></tag1></root>\"\n    Crack::XML.parse(xml)['root']['tag1'].should == \"Tag1 Content <em><strong>This is strong</strong></em>\"\n  end\n\n  should \"should render nested content with splshould text nodes correctly\" do\n    xml = \"<root>Tag1 Content<em>Stuff</em> Hi There</root>\"\n    Crack::XML.parse(xml)['root'].should == \"Tag1 Content<em>Stuff</em> Hi There\"\n  end\n\n  should \"should ignore attributes when a child is a text node\" do\n    xml = \"<root attr1='1'>Stuff</root>\"\n    Crack::XML.parse(xml).should == { \"root\" => \"Stuff\" }\n  end\n\n  should \"should ignore attributes when any child is a text node\" do\n    xml = \"<root attr1='1'>Stuff <em>in italics</em></root>\"\n    Crack::XML.parse(xml).should == { \"root\" => \"Stuff <em>in italics</em>\" }\n  end\n\n  should \"should correctly transform multiple children\" do\n    xml = <<-XML\n    <user gender='m'>\n      <age type='integer'>35</age>\n      <name>Home Simpson</name>\n      <dob type='date'>1988-01-01</dob>\n      <joined-at type='datetime'>2000-04-28 23:01</joined-at>\n      <is-cool type='boolean'>true</is-cool>\n    </user>\n    XML\n\n    hash =  {\n      \"user\" => {\n        \"gender\"    => \"m\",\n        \"age\"       => 35,\n        \"name\"      => \"Home Simpson\",\n        \"dob\"       => Date.parse('1988-01-01'),\n        \"joined_at\" => Time.parse(\"2000-04-28 23:01\"),\n        \"is_cool\"   => true\n      }\n    }\n\n    Crack::XML.parse(xml).should == hash\n  end\n\n  should \"should properly handle nil values (ActiveSupport Compatible)\" do\n    topic_xml = <<-EOT\n      <topic>\n        <title></title>\n        <id type=\"integer\"></id>\n        <approved type=\"boolean\"></approved>\n        <written-on type=\"date\"></written-on>\n        <viewed-at type=\"datetime\"></viewed-at>\n        <content type=\"yaml\"></content>\n        <parent-id></parent-id>\n      </topic>\n    EOT\n\n    expected_topic_hash = {\n      'title'      => nil,\n      'id'         => nil,\n      'approved'   => nil,\n      'written_on' => nil,\n      'viewed_at'  => nil,\n      'content'    => nil,\n      'parent_id'  => nil\n    }\n    Crack::XML.parse(topic_xml)[\"topic\"].should == expected_topic_hash\n  end\n\n  should \"should handle a single record from xml (ActiveSupport Compatible)\" do\n    topic_xml = <<-EOT\n      <topic>\n        <title>The First Topic</title>\n        <author-name>David</author-name>\n        <id type=\"integer\">1</id>\n        <approved type=\"boolean\"> true </approved>\n        <replies-count type=\"integer\">0</replies-count>\n        <replies-close-in type=\"integer\">2592000000</replies-close-in>\n        <written-on type=\"date\">2003-07-16</written-on>\n        <viewed-at type=\"datetime\">2003-07-16T09:28:00+0000</viewed-at>\n        <content type=\"yaml\">--- \\n1: should be an integer\\n:message: Have a nice day\\narray: \\n- should-have-dashes: true\\n  should_have_underscores: true\\n</content>\n        <author-email-address>david@loudthinking.com</author-email-address>\n        <parent-id></parent-id>\n        <ad-revenue type=\"decimal\">1.5</ad-revenue>\n        <optimum-viewing-angle type=\"float\">135</optimum-viewing-angle>\n        <resident type=\"symbol\">yes</resident>\n      </topic>\n    EOT\n\n    expected_topic_hash = {\n      'title' => \"The First Topic\",\n      'author_name' => \"David\",\n      'id' => 1,\n      'approved' => true,\n      'replies_count' => 0,\n      'replies_close_in' => 2592000000,\n      'written_on' => Date.new(2003, 7, 16),\n      'viewed_at' => Time.utc(2003, 7, 16, 9, 28),\n      # Changed this line where the key is :message.  The yaml specifies this as a symbol, and who am I to change what you specify\n      # The line in ActiveSupport is\n      # 'content' => { 'message' => \"Have a nice day\", 1 => \"should be an integer\", \"array\" => [{ \"should-have-dashes\" => true, \"should_have_underscores\" => true }] },\n      'content' => { :message => \"Have a nice day\", 1 => \"should be an integer\", \"array\" => [{ \"should-have-dashes\" => true, \"should_have_underscores\" => true }] },\n      'author_email_address' => \"david@loudthinking.com\",\n      'parent_id' => nil,\n      'ad_revenue' => BigDecimal(\"1.50\"),\n      'optimum_viewing_angle' => 135.0,\n      'resident' => :yes\n    }\n\n    Crack::XML.parse(topic_xml)[\"topic\"].each do |k,v|\n      v.should == expected_topic_hash[k]\n    end\n  end\n\n  should \"should handle multiple records (ActiveSupport Compatible)\" do\n    topics_xml = <<-EOT\n      <topics type=\"array\">\n        <topic>\n          <title>The First Topic</title>\n          <author-name>David</author-name>\n          <id type=\"integer\">1</id>\n          <approved type=\"boolean\">false</approved>\n          <replies-count type=\"integer\">0</replies-count>\n          <replies-close-in type=\"integer\">2592000000</replies-close-in>\n          <written-on type=\"date\">2003-07-16</written-on>\n          <viewed-at type=\"datetime\">2003-07-16T09:28:00+0000</viewed-at>\n          <content>Have a nice day</content>\n          <author-email-address>david@loudthinking.com</author-email-address>\n          <parent-id nil=\"true\"></parent-id>\n        </topic>\n        <topic>\n          <title>The Second Topic</title>\n          <author-name>Jason</author-name>\n          <id type=\"integer\">1</id>\n          <approved type=\"boolean\">false</approved>\n          <replies-count type=\"integer\">0</replies-count>\n          <replies-close-in type=\"integer\">2592000000</replies-close-in>\n          <written-on type=\"date\">2003-07-16</written-on>\n          <viewed-at type=\"datetime\">2003-07-16T09:28:00+0000</viewed-at>\n          <content>Have a nice day</content>\n          <author-email-address>david@loudthinking.com</author-email-address>\n          <parent-id></parent-id>\n        </topic>\n      </topics>\n    EOT\n\n    expected_topic_hash = {\n      'title' => \"The First Topic\",\n      'author_name' => \"David\",\n      'id' => 1,\n      'approved' => false,\n      'replies_count' => 0,\n      'replies_close_in' => 2592000000,\n      'written_on' => Date.new(2003, 7, 16),\n      'viewed_at' => Time.utc(2003, 7, 16, 9, 28),\n      'content' => \"Have a nice day\",\n      'author_email_address' => \"david@loudthinking.com\",\n      'parent_id' => nil\n    }\n    # puts Crack::XML.parse(topics_xml)['topics'].first.inspect\n    Crack::XML.parse(topics_xml)[\"topics\"].first.each do |k,v|\n      v.should == expected_topic_hash[k]\n    end\n  end\n\n  should \"should handle a single record from_xml with attributes other than type (ActiveSupport Compatible)\" do\n    topic_xml = <<-EOT\n    <rsp stat=\"ok\">\n      <photos page=\"1\" pages=\"1\" perpage=\"100\" total=\"16\">\n        <photo id=\"175756086\" owner=\"55569174@N00\" secret=\"0279bf37a1\" server=\"76\" title=\"Colored Pencil PhotoBooth Fun\" ispublic=\"1\" isfriend=\"0\" isfamily=\"0\"/>\n      </photos>\n    </rsp>\n    EOT\n\n    expected_topic_hash = {\n      'id' => \"175756086\",\n      'owner' => \"55569174@N00\",\n      'secret' => \"0279bf37a1\",\n      'server' => \"76\",\n      'title' => \"Colored Pencil PhotoBooth Fun\",\n      'ispublic' => \"1\",\n      'isfriend' => \"0\",\n      'isfamily' => \"0\",\n    }\n    Crack::XML.parse(topic_xml)[\"rsp\"][\"photos\"][\"photo\"].each do |k,v|\n      v.should == expected_topic_hash[k]\n    end\n  end\n\n  should \"should handle an emtpy array (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\"></posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => []}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle empty array with whitespace from xml (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\">\n        </posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => []}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle array with one entry from_xml (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\">\n          <post>a post</post>\n        </posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => [\"a post\"]}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle array with multiple entries from xml (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\">\n          <post>a post</post>\n          <post>another post</post>\n        </posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => [\"a post\", \"another post\"]}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle file types (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <logo type=\"file\" name=\"logo.png\" content_type=\"image/png\">\n        </logo>\n      </blog>\n    XML\n    hash = Crack::XML.parse(blog_xml)\n    hash.keys.should include('blog')\n    hash['blog'].keys.should include('logo')\n\n    file = hash['blog']['logo']\n    file.original_filename.should == 'logo.png'\n    file.content_type.should == 'image/png'\n  end\n\n  should \"should handle file from xml with defaults (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <logo type=\"file\">\n        </logo>\n      </blog>\n    XML\n    file = Crack::XML.parse(blog_xml)['blog']['logo']\n    file.original_filename.should == 'untitled'\n    file.content_type.should == 'application/octet-stream'\n  end\n\n  should \"should handle xsd like types from xml (ActiveSupport Compatible)\" do\n    bacon_xml = <<-EOT\n    <bacon>\n      <weight type=\"double\">0.5</weight>\n      <price type=\"decimal\">12.50</price>\n      <chunky type=\"boolean\"> 1 </chunky>\n      <expires-at type=\"dateTime\">2007-12-25T12:34:56+0000</expires-at>\n      <notes type=\"string\"></notes>\n      <illustration type=\"base64Binary\">YmFiZS5wbmc=</illustration>\n    </bacon>\n    EOT\n\n    expected_bacon_hash = {\n      'weight' => 0.5,\n      'chunky' => true,\n      'price' => BigDecimal(\"12.50\"),\n      'expires_at' => Time.utc(2007,12,25,12,34,56),\n      'notes' => \"\",\n      'illustration' => \"babe.png\"\n    }\n\n    Crack::XML.parse(bacon_xml)[\"bacon\"].should == expected_bacon_hash\n  end\n\n  should \"should let type trickle through when unknown (ActiveSupport Compatible)\" do\n    product_xml = <<-EOT\n    <product>\n      <weight type=\"double\">0.5</weight>\n      <image type=\"ProductImage\"><filename>image.gif</filename></image>\n\n    </product>\n    EOT\n\n    expected_product_hash = {\n      'weight' => 0.5,\n      'image' => {'type' => 'ProductImage', 'filename' => 'image.gif' },\n    }\n\n    Crack::XML.parse(product_xml)[\"product\"].should == expected_product_hash\n  end\n\n  should \"should handle unescaping from xml (ActiveResource Compatible)\" do\n    xml_string = '<person><bare-string>First &amp; Last Name</bare-string><pre-escaped-string>First &amp;amp; Last Name</pre-escaped-string></person>'\n    expected_hash = {\n      'bare_string'        => 'First & Last Name',\n      'pre_escaped_string' => 'First &amp; Last Name'\n    }\n\n    Crack::XML.parse(xml_string)['person'].should == expected_hash\n  end\n  \n  should \"handle an empty xml string\" do\n    Crack::XML.parse('').should == {}\n  end\n  \n  # As returned in the response body by the unfuddle XML API when creating objects\n  should \"handle an xml string containing a single space\" do\n    Crack::XML.parse(' ').should == {}\n  end\nend"], "fixing_code": ["require 'rexml/parsers/streamparser'\nrequire 'rexml/parsers/baseparser'\nrequire 'rexml/light/node'\nrequire 'rexml/text'\nrequire 'date'\nrequire 'time'\nrequire 'yaml'\nrequire 'bigdecimal'\n\n# This is a slighly modified version of the XMLUtilityNode from\n# http://merb.devjavu.com/projects/merb/ticket/95 (has.sox@gmail.com)\n# It's mainly just adding vowels, as I ht cd wth n vwls :)\n# This represents the hard part of the work, all I did was change the\n# underlying parser.\nclass REXMLUtilityNode #:nodoc:\n  attr_accessor :name, :attributes, :children, :type\n\n  def self.typecasts\n    @@typecasts\n  end\n\n  def self.typecasts=(obj)\n    @@typecasts = obj\n  end\n\n  def self.available_typecasts\n    @@available_typecasts\n  end\n\n  def self.available_typecasts=(obj)\n    @@available_typecasts = obj\n  end\n\n  self.typecasts = {}\n  self.typecasts[\"integer\"]       = lambda{|v| v.nil? ? nil : v.to_i}\n  self.typecasts[\"boolean\"]       = lambda{|v| v.nil? ? nil : (v.strip != \"false\")}\n  self.typecasts[\"datetime\"]      = lambda{|v| v.nil? ? nil : Time.parse(v).utc}\n  self.typecasts[\"date\"]          = lambda{|v| v.nil? ? nil : Date.parse(v)}\n  self.typecasts[\"dateTime\"]      = lambda{|v| v.nil? ? nil : Time.parse(v).utc}\n  self.typecasts[\"decimal\"]       = lambda{|v| v.nil? ? nil : BigDecimal(v.to_s)}\n  self.typecasts[\"double\"]        = lambda{|v| v.nil? ? nil : v.to_f}\n  self.typecasts[\"float\"]         = lambda{|v| v.nil? ? nil : v.to_f}\n  self.typecasts[\"string\"]        = lambda{|v| v.to_s}\n  self.typecasts[\"base64Binary\"]  = lambda{|v| v.unpack('m').first }\n\n  self.available_typecasts = self.typecasts.keys\n\n  def initialize(name, normalized_attributes = {})\n\n    # unnormalize attribute values\n    attributes = Hash[* normalized_attributes.map { |key, value|\n      [ key, unnormalize_xml_entities(value) ]\n    }.flatten]\n\n    @name         = name.tr(\"-\", \"_\")\n    # leave the type alone if we don't know what it is\n    @type         = self.class.available_typecasts.include?(attributes[\"type\"]) ? attributes.delete(\"type\") : attributes[\"type\"]\n\n    @nil_element  = attributes.delete(\"nil\") == \"true\"\n    @attributes   = undasherize_keys(attributes)\n    @children     = []\n    @text         = false\n  end\n\n  def add_node(node)\n    @text = true if node.is_a? String\n    @children << node\n  end\n\n  def to_hash\n    if @type == \"file\"\n      f = StringIO.new((@children.first || '').unpack('m').first)\n      class << f\n        attr_accessor :original_filename, :content_type\n      end\n      f.original_filename = attributes['name'] || 'untitled'\n      f.content_type = attributes['content_type'] || 'application/octet-stream'\n      return {name => f}\n    end\n\n    if @text\n      t = typecast_value( unnormalize_xml_entities( inner_html ) )\n      if t.is_a?(String)\n        class << t\n          attr_accessor :attributes\n        end\n        t.attributes = attributes\n      end\n      return { name => t }\n    else\n      #change repeating groups into an array\n      groups = @children.inject({}) { |s,e| (s[e.name] ||= []) << e; s }\n\n      out = nil\n      if @type == \"array\"\n        out = []\n        groups.each do |k, v|\n          if v.size == 1\n            out << v.first.to_hash.entries.first.last\n          else\n            out << v.map{|e| e.to_hash[k]}\n          end\n        end\n        out = out.flatten\n\n      else # If Hash\n        out = {}\n        groups.each do |k,v|\n          if v.size == 1\n            out.merge!(v.first)\n          else\n            out.merge!( k => v.map{|e| e.to_hash[k]})\n          end\n        end\n        out.merge! attributes unless attributes.empty?\n        out = out.empty? ? nil : out\n      end\n\n      if @type && out.nil?\n        { name => typecast_value(out) }\n      else\n        { name => out }\n      end\n    end\n  end\n\n  # Typecasts a value based upon its type. For instance, if\n  # +node+ has #type == \"integer\",\n  # {{[node.typecast_value(\"12\") #=> 12]}}\n  #\n  # @param value<String> The value that is being typecast.\n  #\n  # @details [:type options]\n  #   \"integer\"::\n  #     converts +value+ to an integer with #to_i\n  #   \"boolean\"::\n  #     checks whether +value+, after removing spaces, is the literal\n  #     \"true\"\n  #   \"datetime\"::\n  #     Parses +value+ using Time.parse, and returns a UTC Time\n  #   \"date\"::\n  #     Parses +value+ using Date.parse\n  #\n  # @return <Integer, TrueClass, FalseClass, Time, Date, Object>\n  #   The result of typecasting +value+.\n  #\n  # @note\n  #   If +self+ does not have a \"type\" key, or if it's not one of the\n  #   options specified above, the raw +value+ will be returned.\n  def typecast_value(value)\n    return value unless @type\n    proc = self.class.typecasts[@type]\n    proc.nil? ? value : proc.call(value)\n  end\n\n  # Take keys of the form foo-bar and convert them to foo_bar\n  def undasherize_keys(params)\n    params.keys.each do |key, value|\n      params[key.tr(\"-\", \"_\")] = params.delete(key)\n    end\n    params\n  end\n\n  # Get the inner_html of the REXML node.\n  def inner_html\n    @children.join\n  end\n\n  # Converts the node into a readable HTML node.\n  #\n  # @return <String> The HTML node in text form.\n  def to_html\n    attributes.merge!(:type => @type ) if @type\n    \"<#{name}#{Crack::Util.to_xml_attributes(attributes)}>#{@nil_element ? '' : inner_html}</#{name}>\"\n  end\n\n  # @alias #to_html #to_s\n  def to_s\n    to_html\n  end\n\n  private\n\n  def unnormalize_xml_entities value\n    REXML::Text.unnormalize(value)\n  end\nend\n\nmodule Crack\n\tclass REXMLParser\n    def self.parse(xml)\n      stack = []\n      parser = REXML::Parsers::BaseParser.new(xml)\n\n      while true\n        event = parser.pull\n        case event[0]\n        when :end_document\n          break\n        when :end_doctype, :start_doctype\n          # do nothing\n        when :start_element\n          stack.push REXMLUtilityNode.new(event[1], event[2])\n        when :end_element\n          if stack.size > 1\n            temp = stack.pop\n            stack.last.add_node(temp)\n          end\n        when :text, :cdata\n          stack.last.add_node(event[1]) unless event[1].strip.length == 0 || stack.empty?\n        end\n      end\n      stack.length > 0 ? stack.pop.to_hash : {}\n    end\n  end\n\n  class XML\n    def self.parser\n      @@parser ||= REXMLParser\n    end\n\n    def self.parser=(parser)\n      @@parser = parser\n    end\n\n    def self.parse(xml)\n      parser.parse(xml)\n    end\n  end\nend\n", "require 'test_helper'\n\nclass XmlTest < Test::Unit::TestCase\n  should \"should transform a simple tag with content\" do\n    xml = \"<tag>This is the contents</tag>\"\n    Crack::XML.parse(xml).should == { 'tag' => 'This is the contents' }\n  end\n\n  should \"should work with cdata tags\" do\n    xml = <<-END\n      <tag>\n      <![CDATA[\n        text inside cdata\n      ]]>\n      </tag>\n    END\n    Crack::XML.parse(xml)[\"tag\"].strip.should == \"text inside cdata\"\n  end\n\n  should \"should transform a simple tag with attributes\" do\n    xml = \"<tag attr1='1' attr2='2'></tag>\"\n    hash = { 'tag' => { 'attr1' => '1', 'attr2' => '2' } }\n    Crack::XML.parse(xml).should == hash\n  end\n\n  should \"should transform repeating siblings into an array\" do\n    xml =<<-XML\n      <opt>\n        <user login=\"grep\" fullname=\"Gary R Epstein\" />\n        <user login=\"stty\" fullname=\"Simon T Tyson\" />\n      </opt>\n    XML\n\n    Crack::XML.parse(xml)['opt']['user'].class.should == Array\n\n    hash = {\n      'opt' => {\n        'user' => [{\n          'login'    => 'grep',\n          'fullname' => 'Gary R Epstein'\n        },{\n          'login'    => 'stty',\n          'fullname' => 'Simon T Tyson'\n        }]\n      }\n    }\n\n    Crack::XML.parse(xml).should == hash\n  end\n\n  should \"should not transform non-repeating siblings into an array\" do\n    xml =<<-XML\n      <opt>\n        <user login=\"grep\" fullname=\"Gary R Epstein\" />\n      </opt>\n    XML\n\n    Crack::XML.parse(xml)['opt']['user'].class.should == Hash\n\n    hash = {\n      'opt' => {\n        'user' => {\n          'login' => 'grep',\n          'fullname' => 'Gary R Epstein'\n        }\n      }\n    }\n\n    Crack::XML.parse(xml).should == hash\n  end\n\n  context \"Parsing xml with text and attributes\" do\n    setup do\n      xml =<<-XML\n        <opt>\n          <user login=\"grep\">Gary R Epstein</user>\n          <user>Simon T Tyson</user>\n        </opt>\n      XML\n      @data = Crack::XML.parse(xml)\n    end\n\n    should \"correctly parse text nodes\" do\n      @data.should == {\n        'opt' => {\n          'user' => [\n            'Gary R Epstein',\n            'Simon T Tyson'\n          ]\n        }\n      }\n    end\n\n    should \"be parse attributes for text node if present\" do\n      @data['opt']['user'][0].attributes.should == {'login' => 'grep'}\n    end\n\n    should \"default attributes to empty hash if not present\" do\n      @data['opt']['user'][1].attributes.should == {}\n    end\n\n    should \"add 'attributes' accessor methods to parsed instances of String\" do\n      @data['opt']['user'][0].respond_to?(:attributes).should be(true)\n      @data['opt']['user'][0].respond_to?(:attributes=).should be(true)\n    end\n\n    should \"not add 'attributes' accessor methods to all instances of String\" do\n      \"some-string\".respond_to?(:attributes).should be(false)\n      \"some-string\".respond_to?(:attributes=).should be(false)\n    end\n  end\n\n  should \"should typecast an integer\" do\n    xml = \"<tag type='integer'>10</tag>\"\n    Crack::XML.parse(xml)['tag'].should == 10\n  end\n\n  should \"should typecast a true boolean\" do\n    xml = \"<tag type='boolean'>true</tag>\"\n    Crack::XML.parse(xml)['tag'].should be(true)\n  end\n\n  should \"should typecast a false boolean\" do\n    [\"false\"].each do |w|\n      Crack::XML.parse(\"<tag type='boolean'>#{w}</tag>\")['tag'].should be(false)\n    end\n  end\n\n  should \"should typecast a datetime\" do\n    xml = \"<tag type='datetime'>2007-12-31 10:32</tag>\"\n    Crack::XML.parse(xml)['tag'].should == Time.parse( '2007-12-31 10:32' ).utc\n  end\n\n  should \"should typecast a date\" do\n    xml = \"<tag type='date'>2007-12-31</tag>\"\n    Crack::XML.parse(xml)['tag'].should == Date.parse('2007-12-31')\n  end\n\n  xml_entities = {\n    \"<\" => \"&lt;\",\n    \">\" => \"&gt;\",\n    '\"' => \"&quot;\",\n    \"'\" => \"&apos;\",\n    \"&\" => \"&amp;\"\n  }\n  should \"should unescape html entities\" do\n    xml_entities.each do |k,v|\n      xml = \"<tag>Some content #{v}</tag>\"\n      Crack::XML.parse(xml)['tag'].should =~ Regexp.new(k)\n    end\n  end\n\n  should \"should unescape XML entities in attributes\" do\n    xml_entities.each do |k,v|\n      xml = \"<tag attr='Some content #{v}'></tag>\"\n      Crack::XML.parse(xml)['tag']['attr'].should =~ Regexp.new(k)\n    end\n  end\n\n  should \"should undasherize keys as tags\" do\n    xml = \"<tag-1>Stuff</tag-1>\"\n    Crack::XML.parse(xml).keys.should include( 'tag_1' )\n  end\n\n  should \"should undasherize keys as attributes\" do\n    xml = \"<tag1 attr-1='1'></tag1>\"\n    Crack::XML.parse(xml)['tag1'].keys.should include( 'attr_1')\n  end\n\n  should \"should undasherize keys as tags and attributes\" do\n    xml = \"<tag-1 attr-1='1'></tag-1>\"\n    Crack::XML.parse(xml).keys.should include( 'tag_1' )\n    Crack::XML.parse(xml)['tag_1'].keys.should include( 'attr_1')\n  end\n\n  should \"should render nested content correctly\" do\n    xml = \"<root><tag1>Tag1 Content <em><strong>This is strong</strong></em></tag1></root>\"\n    Crack::XML.parse(xml)['root']['tag1'].should == \"Tag1 Content <em><strong>This is strong</strong></em>\"\n  end\n\n  should \"should render nested content with splshould text nodes correctly\" do\n    xml = \"<root>Tag1 Content<em>Stuff</em> Hi There</root>\"\n    Crack::XML.parse(xml)['root'].should == \"Tag1 Content<em>Stuff</em> Hi There\"\n  end\n\n  should \"should ignore attributes when a child is a text node\" do\n    xml = \"<root attr1='1'>Stuff</root>\"\n    Crack::XML.parse(xml).should == { \"root\" => \"Stuff\" }\n  end\n\n  should \"should ignore attributes when any child is a text node\" do\n    xml = \"<root attr1='1'>Stuff <em>in italics</em></root>\"\n    Crack::XML.parse(xml).should == { \"root\" => \"Stuff <em>in italics</em>\" }\n  end\n\n  should \"should correctly transform multiple children\" do\n    xml = <<-XML\n    <user gender='m'>\n      <age type='integer'>35</age>\n      <name>Home Simpson</name>\n      <dob type='date'>1988-01-01</dob>\n      <joined-at type='datetime'>2000-04-28 23:01</joined-at>\n      <is-cool type='boolean'>true</is-cool>\n    </user>\n    XML\n\n    hash =  {\n      \"user\" => {\n        \"gender\"    => \"m\",\n        \"age\"       => 35,\n        \"name\"      => \"Home Simpson\",\n        \"dob\"       => Date.parse('1988-01-01'),\n        \"joined_at\" => Time.parse(\"2000-04-28 23:01\"),\n        \"is_cool\"   => true\n      }\n    }\n\n    Crack::XML.parse(xml).should == hash\n  end\n\n  should \"should properly handle nil values (ActiveSupport Compatible)\" do\n    topic_xml = <<-EOT\n      <topic>\n        <title></title>\n        <id type=\"integer\"></id>\n        <approved type=\"boolean\"></approved>\n        <written-on type=\"date\"></written-on>\n        <viewed-at type=\"datetime\"></viewed-at>\n        <parent-id></parent-id>\n      </topic>\n    EOT\n\n    expected_topic_hash = {\n      'title'      => nil,\n      'id'         => nil,\n      'approved'   => nil,\n      'written_on' => nil,\n      'viewed_at'  => nil,\n      'parent_id'  => nil\n    }\n    Crack::XML.parse(topic_xml)[\"topic\"].should == expected_topic_hash\n  end\n\n  should \"should handle a single record from xml (ActiveSupport Compatible)\" do\n    topic_xml = <<-EOT\n      <topic>\n        <title>The First Topic</title>\n        <author-name>David</author-name>\n        <id type=\"integer\">1</id>\n        <approved type=\"boolean\"> true </approved>\n        <replies-count type=\"integer\">0</replies-count>\n        <replies-close-in type=\"integer\">2592000000</replies-close-in>\n        <written-on type=\"date\">2003-07-16</written-on>\n        <viewed-at type=\"datetime\">2003-07-16T09:28:00+0000</viewed-at>\n        <author-email-address>david@loudthinking.com</author-email-address>\n        <parent-id></parent-id>\n        <ad-revenue type=\"decimal\">1.5</ad-revenue>\n        <optimum-viewing-angle type=\"float\">135</optimum-viewing-angle>\n        <resident type=\"symbol\">yes</resident>\n      </topic>\n    EOT\n\n    expected_topic_hash = {\n      'title' => \"The First Topic\",\n      'author_name' => \"David\",\n      'id' => 1,\n      'approved' => true,\n      'replies_count' => 0,\n      'replies_close_in' => 2592000000,\n      'written_on' => Date.new(2003, 7, 16),\n      'viewed_at' => Time.utc(2003, 7, 16, 9, 28),\n      'author_email_address' => \"david@loudthinking.com\",\n      'parent_id' => nil,\n      'ad_revenue' => BigDecimal(\"1.50\"),\n      'optimum_viewing_angle' => 135.0,\n      'resident' => 'yes',\n    }\n\n    Crack::XML.parse(topic_xml)[\"topic\"].each do |k,v|\n      v.should == expected_topic_hash[k]\n    end\n  end\n\n  should \"should handle multiple records (ActiveSupport Compatible)\" do\n    topics_xml = <<-EOT\n      <topics type=\"array\">\n        <topic>\n          <title>The First Topic</title>\n          <author-name>David</author-name>\n          <id type=\"integer\">1</id>\n          <approved type=\"boolean\">false</approved>\n          <replies-count type=\"integer\">0</replies-count>\n          <replies-close-in type=\"integer\">2592000000</replies-close-in>\n          <written-on type=\"date\">2003-07-16</written-on>\n          <viewed-at type=\"datetime\">2003-07-16T09:28:00+0000</viewed-at>\n          <content>Have a nice day</content>\n          <author-email-address>david@loudthinking.com</author-email-address>\n          <parent-id nil=\"true\"></parent-id>\n        </topic>\n        <topic>\n          <title>The Second Topic</title>\n          <author-name>Jason</author-name>\n          <id type=\"integer\">1</id>\n          <approved type=\"boolean\">false</approved>\n          <replies-count type=\"integer\">0</replies-count>\n          <replies-close-in type=\"integer\">2592000000</replies-close-in>\n          <written-on type=\"date\">2003-07-16</written-on>\n          <viewed-at type=\"datetime\">2003-07-16T09:28:00+0000</viewed-at>\n          <content>Have a nice day</content>\n          <author-email-address>david@loudthinking.com</author-email-address>\n          <parent-id></parent-id>\n        </topic>\n      </topics>\n    EOT\n\n    expected_topic_hash = {\n      'title' => \"The First Topic\",\n      'author_name' => \"David\",\n      'id' => 1,\n      'approved' => false,\n      'replies_count' => 0,\n      'replies_close_in' => 2592000000,\n      'written_on' => Date.new(2003, 7, 16),\n      'viewed_at' => Time.utc(2003, 7, 16, 9, 28),\n      'content' => \"Have a nice day\",\n      'author_email_address' => \"david@loudthinking.com\",\n      'parent_id' => nil\n    }\n    # puts Crack::XML.parse(topics_xml)['topics'].first.inspect\n    Crack::XML.parse(topics_xml)[\"topics\"].first.each do |k,v|\n      v.should == expected_topic_hash[k]\n    end\n  end\n\n  should \"should handle a single record from_xml with attributes other than type (ActiveSupport Compatible)\" do\n    topic_xml = <<-EOT\n    <rsp stat=\"ok\">\n      <photos page=\"1\" pages=\"1\" perpage=\"100\" total=\"16\">\n        <photo id=\"175756086\" owner=\"55569174@N00\" secret=\"0279bf37a1\" server=\"76\" title=\"Colored Pencil PhotoBooth Fun\" ispublic=\"1\" isfriend=\"0\" isfamily=\"0\"/>\n      </photos>\n    </rsp>\n    EOT\n\n    expected_topic_hash = {\n      'id' => \"175756086\",\n      'owner' => \"55569174@N00\",\n      'secret' => \"0279bf37a1\",\n      'server' => \"76\",\n      'title' => \"Colored Pencil PhotoBooth Fun\",\n      'ispublic' => \"1\",\n      'isfriend' => \"0\",\n      'isfamily' => \"0\",\n    }\n    Crack::XML.parse(topic_xml)[\"rsp\"][\"photos\"][\"photo\"].each do |k,v|\n      v.should == expected_topic_hash[k]\n    end\n  end\n\n  should \"should handle an emtpy array (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\"></posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => []}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle empty array with whitespace from xml (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\">\n        </posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => []}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle array with one entry from_xml (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\">\n          <post>a post</post>\n        </posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => [\"a post\"]}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle array with multiple entries from xml (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <posts type=\"array\">\n          <post>a post</post>\n          <post>another post</post>\n        </posts>\n      </blog>\n    XML\n    expected_blog_hash = {\"blog\" => {\"posts\" => [\"a post\", \"another post\"]}}\n    Crack::XML.parse(blog_xml).should == expected_blog_hash\n  end\n\n  should \"should handle file types (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <logo type=\"file\" name=\"logo.png\" content_type=\"image/png\">\n        </logo>\n      </blog>\n    XML\n    hash = Crack::XML.parse(blog_xml)\n    hash.keys.should include('blog')\n    hash['blog'].keys.should include('logo')\n\n    file = hash['blog']['logo']\n    file.original_filename.should == 'logo.png'\n    file.content_type.should == 'image/png'\n  end\n\n  should \"should handle file from xml with defaults (ActiveSupport Compatible)\" do\n    blog_xml = <<-XML\n      <blog>\n        <logo type=\"file\">\n        </logo>\n      </blog>\n    XML\n    file = Crack::XML.parse(blog_xml)['blog']['logo']\n    file.original_filename.should == 'untitled'\n    file.content_type.should == 'application/octet-stream'\n  end\n\n  should \"should handle xsd like types from xml (ActiveSupport Compatible)\" do\n    bacon_xml = <<-EOT\n    <bacon>\n      <weight type=\"double\">0.5</weight>\n      <price type=\"decimal\">12.50</price>\n      <chunky type=\"boolean\"> 1 </chunky>\n      <expires-at type=\"dateTime\">2007-12-25T12:34:56+0000</expires-at>\n      <notes type=\"string\"></notes>\n      <illustration type=\"base64Binary\">YmFiZS5wbmc=</illustration>\n    </bacon>\n    EOT\n\n    expected_bacon_hash = {\n      'weight' => 0.5,\n      'chunky' => true,\n      'price' => BigDecimal(\"12.50\"),\n      'expires_at' => Time.utc(2007,12,25,12,34,56),\n      'notes' => \"\",\n      'illustration' => \"babe.png\"\n    }\n\n    Crack::XML.parse(bacon_xml)[\"bacon\"].should == expected_bacon_hash\n  end\n\n  should \"should let type trickle through when unknown (ActiveSupport Compatible)\" do\n    product_xml = <<-EOT\n    <product>\n      <weight type=\"double\">0.5</weight>\n      <image type=\"ProductImage\"><filename>image.gif</filename></image>\n\n    </product>\n    EOT\n\n    expected_product_hash = {\n      'weight' => 0.5,\n      'image' => {'type' => 'ProductImage', 'filename' => 'image.gif' },\n    }\n\n    Crack::XML.parse(product_xml)[\"product\"].should == expected_product_hash\n  end\n\n  should \"should handle unescaping from xml (ActiveResource Compatible)\" do\n    xml_string = '<person><bare-string>First &amp; Last Name</bare-string><pre-escaped-string>First &amp;amp; Last Name</pre-escaped-string></person>'\n    expected_hash = {\n      'bare_string'        => 'First & Last Name',\n      'pre_escaped_string' => 'First &amp; Last Name'\n    }\n\n    Crack::XML.parse(xml_string)['person'].should == expected_hash\n  end\n\n  should \"handle an empty xml string\" do\n    Crack::XML.parse('').should == {}\n  end\n\n  # As returned in the response body by the unfuddle XML API when creating objects\n  should \"handle an xml string containing a single space\" do\n    Crack::XML.parse(' ').should == {}\n  end\nend\n"], "filenames": ["lib/crack/xml.rb", "test/xml_test.rb"], "buggy_code_start_loc": [43, 68], "buggy_code_end_loc": [46, 500], "fixing_code_start_loc": [42, 68], "fixing_code_end_loc": [43, 493], "type": "CWE-264", "message": "The crack gem 0.3.1 and earlier for Ruby does not properly restrict casts of string values, which might allow remote attackers to conduct object-injection attacks and execute arbitrary code, or cause a denial of service (memory and CPU consumption) by leveraging Action Pack support for (1) YAML type conversion or (2) Symbol type conversion, a similar vulnerability to CVE-2013-0156.", "other": {"cve": {"id": "CVE-2013-1800", "sourceIdentifier": "secalert@redhat.com", "published": "2013-04-09T20:55:01.927", "lastModified": "2013-04-10T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The crack gem 0.3.1 and earlier for Ruby does not properly restrict casts of string values, which might allow remote attackers to conduct object-injection attacks and execute arbitrary code, or cause a denial of service (memory and CPU consumption) by leveraging Action Pack support for (1) YAML type conversion or (2) Symbol type conversion, a similar vulnerability to CVE-2013-0156."}, {"lang": "es", "value": "La gema crack  0.3.1 y anteriores para Ruby  no restringe adecuadamente las conversiones de los valores de cadena, lo que podr\u00eda permitir a atacantes remotos llevar a cabo ataques de inyecci\u00f3n de objetos y la ejecuci\u00f3n de c\u00f3digo arbitrario o provocar incluso una denegaci\u00f3n de servicio (consumo de memoria y CPU), aprovechando el soporte Action PAck para (1) los conversores de tipo YALM o (2) los conversores de tipo Symbol. Vulnerabilidad similar a  CVE-2013-0156."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:crack:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.3.1", "matchCriteriaId": "534E1684-91E9-4307-9023-B19A066AC21A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:crack:0.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "381F202C-AB3F-4A76-9D5B-C0431494A8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:crack:0.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "D1A3F36D-003A-4EE5-BE26-9114B6319A36"}, {"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:crack:0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "E7FB1D86-7E24-4AD9-8851-6A6FC8720E25"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2013-04/msg00003.html", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=804721", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=917236", "source": "secalert@redhat.com"}, {"url": "https://github.com/jnunemaker/crack/commit/e3da1212a1f84a898ee3601336d1dbbf118fb5f6", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://support.cloud.engineyard.com/entries/22915701-january-14-2013-security-vulnerabilities-httparty-extlib-crack-nori-update-these-gems-immediately", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/jnunemaker/crack/commit/e3da1212a1f84a898ee3601336d1dbbf118fb5f6"}}