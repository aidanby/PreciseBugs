{"buggy_code": ["// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// A Binder translates between string parameters and Go data structures.\ntype Binder struct {\n\t// Bind takes the name and type of the desired parameter and constructs it\n\t// from one or more values from Params.\n\t//\n\t// Example\n\t//\n\t// Request:\n\t//   url?id=123&ol[0]=1&ol[1]=2&ul[]=str&ul[]=array&user.Name=rob\n\t//\n\t// Action:\n\t//   Example.Action(id int, ol []int, ul []string, user User)\n\t//\n\t// Calls:\n\t//   Bind(params, \"id\", int): 123\n\t//   Bind(params, \"ol\", []int): {1, 2}\n\t//   Bind(params, \"ul\", []string): {\"str\", \"array\"}\n\t//   Bind(params, \"user\", User): User{Name:\"rob\"}\n\t//\n\t// Note that only exported struct fields may be bound.\n\tBind func(params *Params, name string, typ reflect.Type) reflect.Value\n\n\t// Unbind serializes a given value to one or more URL parameters of the given\n\t// name.\n\tUnbind func(output map[string]string, name string, val interface{})\n}\n\nvar binderLog = RevelLog.New(\"section\", \"binder\")\n\n// ValueBinder is adapter for easily making one-key-value binders.\nfunc ValueBinder(f func(value string, typ reflect.Type) reflect.Value) func(*Params, string, reflect.Type) reflect.Value {\n\treturn func(params *Params, name string, typ reflect.Type) reflect.Value {\n\t\tvals, ok := params.Values[name]\n\t\tif !ok || len(vals) == 0 {\n\t\t\treturn reflect.Zero(typ)\n\t\t}\n\t\treturn f(vals[0], typ)\n\t}\n}\n\n// Revel's default date and time constants\nconst (\n\tDefaultDateFormat     = \"2006-01-02\"\n\tDefaultDateTimeFormat = \"2006-01-02 15:04\"\n)\n\n// Binders type and kind definition\nvar (\n\t// These are the lookups to find a Binder for any type of data.\n\t// The most specific binder found will be used (Type before Kind)\n\tTypeBinders = make(map[reflect.Type]Binder)\n\tKindBinders = make(map[reflect.Kind]Binder)\n\n\t// Applications can add custom time formats to this array, and they will be\n\t// automatically attempted when binding a time.Time.\n\tTimeFormats = []string{}\n\n\tDateFormat     string\n\tDateTimeFormat string\n\tTimeZone       = time.UTC\n\n\tIntBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tintValue, err := strconv.ParseInt(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"IntBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetInt(intValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%d\", val)\n\t\t},\n\t}\n\n\tUintBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tuintValue, err := strconv.ParseUint(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"UintBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetUint(uintValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%d\", val)\n\t\t},\n\t}\n\n\tFloatBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tfloatValue, err := strconv.ParseFloat(val, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"FloatBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetFloat(floatValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%f\", val)\n\t\t},\n\t}\n\n\tStringBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\treturn reflect.ValueOf(val)\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\toutput[name] = val.(string)\n\t\t},\n\t}\n\n\t// Booleans support a various value formats,\n\t// refer `revel.Atob` method.\n\tBoolBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\treturn reflect.ValueOf(Atob(val))\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\toutput[name] = fmt.Sprintf(\"%t\", val)\n\t\t},\n\t}\n\n\tPointerBinder = Binder{\n\t\tBind: func(params *Params, name string, typ reflect.Type) reflect.Value {\n\t\t\tv := Bind(params, name, typ.Elem())\n\t\t\tif v.CanAddr() {\n\t\t\t\treturn v.Addr()\n\t\t\t}\n\n\t\t\treturn v\n\t\t},\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\tUnbind(output, name, reflect.ValueOf(val).Elem().Interface())\n\t\t},\n\t}\n\n\tTimeBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tfor _, f := range TimeFormats {\n\t\t\t\tif r, err := time.ParseInLocation(f, val, TimeZone); err == nil {\n\t\t\t\t\treturn reflect.ValueOf(r)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reflect.Zero(typ)\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\tvar (\n\t\t\t\tt       = val.(time.Time)\n\t\t\t\tformat  = DateTimeFormat\n\t\t\t\th, m, s = t.Clock()\n\t\t\t)\n\t\t\tif h == 0 && m == 0 && s == 0 {\n\t\t\t\tformat = DateFormat\n\t\t\t}\n\t\t\toutput[name] = t.Format(format)\n\t\t},\n\t}\n\n\tMapBinder = Binder{\n\t\tBind:   bindMap,\n\t\tUnbind: unbindMap,\n\t}\n)\n\n// Used to keep track of the index for individual keyvalues.\ntype sliceValue struct {\n\tindex int           // Index extracted from brackets.  If -1, no index was provided.\n\tvalue reflect.Value // the bound value for this slice element.\n}\n\n// This function creates a slice of the given type, Binds each of the individual\n// elements, and then sets them to their appropriate location in the slice.\n// If elements are provided without an explicit index, they are added (in\n// unspecified order) to the end of the slice.\nfunc bindSlice(params *Params, name string, typ reflect.Type) reflect.Value {\n\t// Collect an array of slice elements with their indexes (and the max index).\n\tmaxIndex := -1\n\tnumNoIndex := 0\n\tsliceValues := []sliceValue{}\n\n\t// Factor out the common slice logic (between form values and files).\n\tprocessElement := func(key string, vals []string, files []*multipart.FileHeader) {\n\t\tif !strings.HasPrefix(key, name+\"[\") {\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the index, and the index where a sub-key starts. (e.g. field[0].subkey)\n\t\tindex := -1\n\t\tleftBracket, rightBracket := len(name), strings.Index(key[len(name):], \"]\")+len(name)\n\t\tif rightBracket > leftBracket+1 {\n\t\t\tindex, _ = strconv.Atoi(key[leftBracket+1 : rightBracket])\n\t\t}\n\t\tsubKeyIndex := rightBracket + 1\n\n\t\t// Handle the indexed case.\n\t\tif index > -1 {\n\t\t\tif index > maxIndex {\n\t\t\t\tmaxIndex = index\n\t\t\t}\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: index,\n\t\t\t\tvalue: Bind(params, key[:subKeyIndex], typ.Elem()),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// It's an un-indexed element.  (e.g. element[])\n\t\tnumNoIndex += len(vals) + len(files)\n\t\tfor _, val := range vals {\n\t\t\t// Unindexed values can only be direct-bound.\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: -1,\n\t\t\t\tvalue: BindValue(val, typ.Elem()),\n\t\t\t})\n\t\t}\n\n\t\tfor _, fileHeader := range files {\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: -1,\n\t\t\t\tvalue: BindFile(fileHeader, typ.Elem()),\n\t\t\t})\n\t\t}\n\t}\n\n\tfor key, vals := range params.Values {\n\t\tprocessElement(key, vals, nil)\n\t}\n\tfor key, fileHeaders := range params.Files {\n\t\tprocessElement(key, nil, fileHeaders)\n\t}\n\n\tresultArray := reflect.MakeSlice(typ, maxIndex+1, maxIndex+1+numNoIndex)\n\tfor _, sv := range sliceValues {\n\t\tif sv.index != -1 {\n\t\t\tresultArray.Index(sv.index).Set(sv.value)\n\t\t} else {\n\t\t\tresultArray = reflect.Append(resultArray, sv.value)\n\t\t}\n\t}\n\n\treturn resultArray\n}\n\n// Break on dots and brackets.\n// e.g. bar => \"bar\", bar.baz => \"bar\", bar[0] => \"bar\"\nfunc nextKey(key string) string {\n\tfieldLen := strings.IndexAny(key, \".[\")\n\tif fieldLen == -1 {\n\t\treturn key\n\t}\n\treturn key[:fieldLen]\n}\n\nfunc unbindSlice(output map[string]string, name string, val interface{}) {\n\tv := reflect.ValueOf(val)\n\tfor i := 0; i < v.Len(); i++ {\n\t\tUnbind(output, fmt.Sprintf(\"%s[%d]\", name, i), v.Index(i).Interface())\n\t}\n}\n\nfunc bindStruct(params *Params, name string, typ reflect.Type) reflect.Value {\n\tresultPointer := reflect.New(typ)\n\tresult := resultPointer.Elem()\n\tif params.JSON != nil {\n\t\t// Try to inject the response as a json into the created result\n\t\tif err := json.Unmarshal(params.JSON, resultPointer.Interface()); err != nil {\n\t\t\tbinderLog.Error(\"bindStruct Unable to unmarshal request\", \"name\", name, \"error\", err, \"data\", string(params.JSON))\n\t\t}\n\t\treturn result\n\t}\n\tfieldValues := make(map[string]reflect.Value)\n\tfor key := range params.Values {\n\t\tif !strings.HasPrefix(key, name+\".\") {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the name of the struct property.\n\t\t// Strip off the prefix. e.g. foo.bar.baz => bar.baz\n\t\tsuffix := key[len(name)+1:]\n\t\tfieldName := nextKey(suffix)\n\t\tfieldLen := len(fieldName)\n\n\t\tif _, ok := fieldValues[fieldName]; !ok {\n\t\t\t// Time to bind this field.  Get it and make sure we can set it.\n\t\t\tfieldValue := result.FieldByName(fieldName)\n\t\t\tif !fieldValue.IsValid() {\n\t\t\t\tbinderLog.Warn(\"bindStruct Field not found\", \"name\", fieldName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !fieldValue.CanSet() {\n\t\t\t\tbinderLog.Warn(\"bindStruct Field not settable\", \"name\", fieldName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tboundVal := Bind(params, key[:len(name)+1+fieldLen], fieldValue.Type())\n\t\t\tfieldValue.Set(boundVal)\n\t\t\tfieldValues[fieldName] = boundVal\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc unbindStruct(output map[string]string, name string, iface interface{}) {\n\tval := reflect.ValueOf(iface)\n\ttyp := val.Type()\n\tfor i := 0; i < val.NumField(); i++ {\n\t\tstructField := typ.Field(i)\n\t\tfieldValue := val.Field(i)\n\n\t\t// PkgPath is specified to be empty exactly for exported fields.\n\t\tif structField.PkgPath == \"\" {\n\t\t\tUnbind(output, fmt.Sprintf(\"%s.%s\", name, structField.Name), fieldValue.Interface())\n\t\t}\n\t}\n}\n\n// Helper that returns an upload of the given name, or nil.\nfunc getMultipartFile(params *Params, name string) multipart.File {\n\tfor _, fileHeader := range params.Files[name] {\n\t\tfile, err := fileHeader.Open()\n\t\tif err == nil {\n\t\t\treturn file\n\t\t}\n\t\tbinderLog.Warn(\"getMultipartFile: Failed to open uploaded file\", \"name\", name, \"error\", err)\n\t}\n\treturn nil\n}\n\nfunc bindFile(params *Params, name string, typ reflect.Type) reflect.Value {\n\treader := getMultipartFile(params, name)\n\tif reader == nil {\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t// If it's already stored in a temp file, just return that.\n\tif osFile, ok := reader.(*os.File); ok {\n\t\treturn reflect.ValueOf(osFile)\n\t}\n\n\t// Otherwise, have to store it.\n\ttmpFile, err := ioutil.TempFile(\"\", \"revel-upload\")\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to create a temp file to store upload\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t// Register it to be deleted after the request is done.\n\tparams.tmpFiles = append(params.tmpFiles, tmpFile)\n\n\t_, err = io.Copy(tmpFile, reader)\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to copy upload to temp file\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t_, err = tmpFile.Seek(0, 0)\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to seek to beginning of temp file\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\treturn reflect.ValueOf(tmpFile)\n}\n\nfunc bindByteArray(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif reader := getMultipartFile(params, name); reader != nil {\n\t\tb, err := ioutil.ReadAll(reader)\n\t\tif err == nil {\n\t\t\treturn reflect.ValueOf(b)\n\t\t}\n\t\tbinderLog.Warn(\"bindByteArray: Error reading uploaded file contents\", \"name\", name, \"error\", err)\n\t}\n\treturn reflect.Zero(typ)\n}\n\nfunc bindReadSeeker(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif reader := getMultipartFile(params, name); reader != nil {\n\t\treturn reflect.ValueOf(reader.(io.ReadSeeker))\n\t}\n\treturn reflect.Zero(typ)\n}\n\n// bindMap converts parameters using map syntax into the corresponding map. e.g.:\n//   params[\"a[5]\"]=foo, name=\"a\", typ=map[int]string => map[int]string{5: \"foo\"}\nfunc bindMap(params *Params, name string, typ reflect.Type) reflect.Value {\n\tvar (\n\t\tkeyType   = typ.Key()\n\t\tvalueType = typ.Elem()\n\t\tresultPtr = reflect.New(reflect.MapOf(keyType, valueType))\n\t\tresult    = resultPtr.Elem()\n\t)\n\tresult.Set(reflect.MakeMap(typ))\n\tif params.JSON != nil {\n\t\t// Try to inject the response as a json into the created result\n\t\tif err := json.Unmarshal(params.JSON, resultPtr.Interface()); err != nil {\n\t\t\tbinderLog.Warn(\"bindMap: Unable to unmarshal request\", \"name\", name, \"error\", err)\n\t\t}\n\t\treturn result\n\t}\n\n\tfor paramName := range params.Values {\n\t\t// The paramName string must start with the value in the \"name\" parameter,\n\t\t// otherwise there is no way the parameter is part of the map\n\t\tif !strings.HasPrefix(paramName, name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tsuffix := paramName[len(name)+1:]\n\t\tfieldName := nextKey(suffix)\n\t\tif fieldName != \"\" {\n\t\t\tfieldName = fieldName[:len(fieldName)-1]\n\t\t}\n\t\tif !strings.HasPrefix(paramName, name+\"[\"+fieldName+\"]\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult.SetMapIndex(BindValue(fieldName, keyType), Bind(params, name+\"[\"+fieldName+\"]\", valueType))\n\t}\n\treturn result\n}\n\nfunc unbindMap(output map[string]string, name string, iface interface{}) {\n\tmapValue := reflect.ValueOf(iface)\n\tfor _, key := range mapValue.MapKeys() {\n\t\tUnbind(output, name+\"[\"+fmt.Sprintf(\"%v\", key.Interface())+\"]\",\n\t\t\tmapValue.MapIndex(key).Interface())\n\t}\n}\n\n// Bind takes the name and type of the desired parameter and constructs it\n// from one or more values from Params.\n// Returns the zero value of the type upon any sort of failure.\nfunc Bind(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif binder, found := binderForType(typ); found {\n\t\treturn binder.Bind(params, name, typ)\n\t}\n\treturn reflect.Zero(typ)\n}\n\nfunc BindValue(val string, typ reflect.Type) reflect.Value {\n\treturn Bind(&Params{Values: map[string][]string{\"\": {val}}}, \"\", typ)\n}\n\nfunc BindFile(fileHeader *multipart.FileHeader, typ reflect.Type) reflect.Value {\n\treturn Bind(&Params{Files: map[string][]*multipart.FileHeader{\"\": {fileHeader}}}, \"\", typ)\n}\n\nfunc Unbind(output map[string]string, name string, val interface{}) {\n\tif binder, found := binderForType(reflect.TypeOf(val)); found {\n\t\tif binder.Unbind != nil {\n\t\t\tbinder.Unbind(output, name, val)\n\t\t} else {\n\t\t\tbinderLog.Error(\"Unbind: Unable to unmarshal request\", \"name\", name, \"value\", val)\n\t\t}\n\t}\n}\n\nfunc binderForType(typ reflect.Type) (Binder, bool) {\n\tbinder, ok := TypeBinders[typ]\n\tif !ok {\n\t\tbinder, ok = KindBinders[typ.Kind()]\n\t\tif !ok {\n\t\t\tbinderLog.Error(\"binderForType: no binder for type\", \"type\", typ)\n\t\t\treturn Binder{}, false\n\t\t}\n\t}\n\treturn binder, true\n}\n\n// Sadly, the binder lookups can not be declared initialized -- that results in\n// an \"initialization loop\" compile error.\nfunc init() {\n\tKindBinders[reflect.Int] = IntBinder\n\tKindBinders[reflect.Int8] = IntBinder\n\tKindBinders[reflect.Int16] = IntBinder\n\tKindBinders[reflect.Int32] = IntBinder\n\tKindBinders[reflect.Int64] = IntBinder\n\n\tKindBinders[reflect.Uint] = UintBinder\n\tKindBinders[reflect.Uint8] = UintBinder\n\tKindBinders[reflect.Uint16] = UintBinder\n\tKindBinders[reflect.Uint32] = UintBinder\n\tKindBinders[reflect.Uint64] = UintBinder\n\n\tKindBinders[reflect.Float32] = FloatBinder\n\tKindBinders[reflect.Float64] = FloatBinder\n\n\tKindBinders[reflect.String] = StringBinder\n\tKindBinders[reflect.Bool] = BoolBinder\n\tKindBinders[reflect.Slice] = Binder{bindSlice, unbindSlice}\n\tKindBinders[reflect.Struct] = Binder{bindStruct, unbindStruct}\n\tKindBinders[reflect.Ptr] = PointerBinder\n\tKindBinders[reflect.Map] = MapBinder\n\n\tTypeBinders[reflect.TypeOf(time.Time{})] = TimeBinder\n\n\t// Uploads\n\tTypeBinders[reflect.TypeOf(&os.File{})] = Binder{bindFile, nil}\n\tTypeBinders[reflect.TypeOf([]byte{})] = Binder{bindByteArray, nil}\n\tTypeBinders[reflect.TypeOf((*io.Reader)(nil)).Elem()] = Binder{bindReadSeeker, nil}\n\tTypeBinders[reflect.TypeOf((*io.ReadSeeker)(nil)).Elem()] = Binder{bindReadSeeker, nil}\n\n\tOnAppStart(func() {\n\t\tDateTimeFormat = Config.StringDefault(\"format.datetime\", DefaultDateTimeFormat)\n\t\tDateFormat = Config.StringDefault(\"format.date\", DefaultDateFormat)\n\t\tTimeFormats = append(TimeFormats, DateTimeFormat, DateFormat)\n\t})\n}\n", "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype A struct {\n\tID      int\n\tName    string\n\tB       B\n\tprivate int\n}\n\ntype B struct {\n\tExtra string\n}\n\nvar (\n\tParamTestValues = map[string][]string{\n\t\t\"int\":                            {\"1\"},\n\t\t\"int8\":                           {\"1\"},\n\t\t\"int16\":                          {\"1\"},\n\t\t\"int32\":                          {\"1\"},\n\t\t\"int64\":                          {\"1\"},\n\t\t\"uint\":                           {\"1\"},\n\t\t\"uint8\":                          {\"1\"},\n\t\t\"uint16\":                         {\"1\"},\n\t\t\"uint32\":                         {\"1\"},\n\t\t\"uint64\":                         {\"1\"},\n\t\t\"float32\":                        {\"1.000000\"},\n\t\t\"float64\":                        {\"1.000000\"},\n\t\t\"str\":                            {\"hello\"},\n\t\t\"bool-true\":                      {\"true\"},\n\t\t\"bool-1\":                         {\"1\"},\n\t\t\"bool-on\":                        {\"on\"},\n\t\t\"bool-false\":                     {\"false\"},\n\t\t\"bool-0\":                         {\"0\"},\n\t\t\"bool-0.0\":                       {\"0.0\"},\n\t\t\"bool-off\":                       {\"off\"},\n\t\t\"bool-f\":                         {\"f\"},\n\t\t\"date\":                           {\"1982-07-09\"},\n\t\t\"datetime\":                       {\"1982-07-09 21:30\"},\n\t\t\"customDate\":                     {\"07/09/1982\"},\n\t\t\"arr[0]\":                         {\"1\"},\n\t\t\"arr[1]\":                         {\"2\"},\n\t\t\"arr[3]\":                         {\"3\"},\n\t\t\"uarr[]\":                         {\"1\", \"2\"},\n\t\t\"arruarr[0][]\":                   {\"1\", \"2\"},\n\t\t\"arruarr[1][]\":                   {\"3\", \"4\"},\n\t\t\"2darr[0][0]\":                    {\"0\"},\n\t\t\"2darr[0][1]\":                    {\"1\"},\n\t\t\"2darr[1][0]\":                    {\"10\"},\n\t\t\"2darr[1][1]\":                    {\"11\"},\n\t\t\"A.ID\":                           {\"123\"},\n\t\t\"A.Name\":                         {\"rob\"},\n\t\t\"B.ID\":                           {\"123\"},\n\t\t\"B.Name\":                         {\"rob\"},\n\t\t\"B.B.Extra\":                      {\"hello\"},\n\t\t\"pB.ID\":                          {\"123\"},\n\t\t\"pB.Name\":                        {\"rob\"},\n\t\t\"pB.B.Extra\":                     {\"hello\"},\n\t\t\"priv.private\":                   {\"123\"},\n\t\t\"arrC[0].ID\":                     {\"5\"},\n\t\t\"arrC[0].Name\":                   {\"rob\"},\n\t\t\"arrC[0].B.Extra\":                {\"foo\"},\n\t\t\"arrC[1].ID\":                     {\"8\"},\n\t\t\"arrC[1].Name\":                   {\"bill\"},\n\t\t\"m[a]\":                           {\"foo\"},\n\t\t\"m[b]\":                           {\"bar\"},\n\t\t\"m2[1]\":                          {\"foo\"},\n\t\t\"m2[2]\":                          {\"bar\"},\n\t\t\"m3[a]\":                          {\"1\"},\n\t\t\"m3[b]\":                          {\"2\"},\n\t\t\"m4[a].ID\":                       {\"1\"},\n\t\t\"m4[a].Name\":                     {\"foo\"},\n\t\t\"m4[b].ID\":                       {\"2\"},\n\t\t\"m4[b].Name\":                     {\"bar\"},\n\t\t\"mapWithAMuchLongerName[a].ID\":   {\"1\"},\n\t\t\"mapWithAMuchLongerName[a].Name\": {\"foo\"},\n\t\t\"mapWithAMuchLongerName[b].ID\":   {\"2\"},\n\t\t\"mapWithAMuchLongerName[b].Name\": {\"bar\"},\n\t\t\"invalidInt\":                     {\"xyz\"},\n\t\t\"invalidInt2\":                    {\"\"},\n\t\t\"invalidBool\":                    {\"xyz\"},\n\t\t\"invalidArr\":                     {\"xyz\"},\n\t\t\"int8-overflow\":                  {\"1024\"},\n\t\t\"uint8-overflow\":                 {\"1024\"},\n\t}\n\n\ttestDate     = time.Date(1982, time.July, 9, 0, 0, 0, 0, time.UTC)\n\ttestDatetime = time.Date(1982, time.July, 9, 21, 30, 0, 0, time.UTC)\n)\n\nvar binderTestCases = map[string]interface{}{\n\t\"int\":        1,\n\t\"int8\":       int8(1),\n\t\"int16\":      int16(1),\n\t\"int32\":      int32(1),\n\t\"int64\":      int64(1),\n\t\"uint\":       1,\n\t\"uint8\":      uint8(1),\n\t\"uint16\":     uint16(1),\n\t\"uint32\":     uint32(1),\n\t\"uint64\":     uint64(1),\n\t\"float32\":    float32(1.0),\n\t\"float64\":    float64(1.0),\n\t\"str\":        \"hello\",\n\t\"bool-true\":  true,\n\t\"bool-1\":     true,\n\t\"bool-on\":    true,\n\t\"bool-false\": false,\n\t\"bool-0\":     false,\n\t\"bool-0.0\":   false,\n\t\"bool-off\":   false,\n\t\"bool-f\":     false,\n\t\"date\":       testDate,\n\t\"datetime\":   testDatetime,\n\t\"customDate\": testDate,\n\t\"arr\":        []int{1, 2, 0, 3},\n\t\"uarr\":       []int{1, 2},\n\t\"arruarr\":    [][]int{{1, 2}, {3, 4}},\n\t\"2darr\":      [][]int{{0, 1}, {10, 11}},\n\t\"A\":          A{ID: 123, Name: \"rob\"},\n\t\"B\":          A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"pB\":         &A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"arrC\": []A{\n\t\t{\n\t\t\tID:   5,\n\t\t\tName: \"rob\",\n\t\t\tB:    B{\"foo\"},\n\t\t},\n\t\t{\n\t\t\tID:   8,\n\t\t\tName: \"bill\",\n\t\t},\n\t},\n\t\"m\":  map[string]string{\"a\": \"foo\", \"b\": \"bar\"},\n\t\"m2\": map[int]string{1: \"foo\", 2: \"bar\"},\n\t\"m3\": map[string]int{\"a\": 1, \"b\": 2},\n\t\"m4\": map[string]A{\"a\": {ID: 1, Name: \"foo\"}, \"b\": {ID: 2, Name: \"bar\"}},\n\n\t// NOTE: We also include a map with a longer name than the others since this has caused problems\n\t// described in github issue #1285, resolved in pull request #1344. This test case should\n\t// prevent regression.\n\t\"mapWithAMuchLongerName\": map[string]A{\"a\": {ID: 1, Name: \"foo\"}, \"b\": {ID: 2, Name: \"bar\"}},\n\n\t// TODO: Tests that use TypeBinders\n\n\t// Invalid value tests (the result should always be the zero value for that type)\n\t// The point of these is to ensure that invalid user input does not cause panics.\n\t\"invalidInt\":     0,\n\t\"invalidInt2\":    0,\n\t\"invalidBool\":    true,\n\t\"invalidArr\":     []int{},\n\t\"priv\":           A{},\n\t\"int8-overflow\":  int8(0),\n\t\"uint8-overflow\": uint8(0),\n}\n\n// Types that files may be bound to, and a func that can read the content from\n// that type.\n// TODO: Is there any way to create a slice, given only the element Type?\nvar fileBindings = []struct{ val, arrval, f interface{} }{\n\t{(**os.File)(nil), []*os.File{}, ioutil.ReadAll},\n\t{(*[]byte)(nil), [][]byte{}, func(b []byte) []byte { return b }},\n\t{(*io.Reader)(nil), []io.Reader{}, ioutil.ReadAll},\n\t{(*io.ReadSeeker)(nil), []io.ReadSeeker{}, ioutil.ReadAll},\n}\n\nfunc TestJsonBinder(t *testing.T) {\n\t// create a structure to be populated\n\t{\n\t\td, _ := json.Marshal(map[string]int{\"a\": 1})\n\t\tparams := &Params{JSON: d}\n\t\tfoo := struct{ A int }{}\n\t\tc := NewTestController(nil, getMultipartRequest())\n\n\t\tParseParams(params, NewRequest(c.Request.In))\n\t\tactual := Bind(params, \"test\", reflect.TypeOf(foo))\n\t\tvalEq(t, \"TestJsonBinder\", reflect.ValueOf(actual.Interface().(struct{ A int }).A), reflect.ValueOf(1))\n\t}\n\t{\n\t\td, _ := json.Marshal(map[string]interface{}{\"a\": map[string]int{\"b\": 45}})\n\t\tparams := &Params{JSON: d}\n\t\ttestMap := map[string]interface{}{}\n\t\tactual := Bind(params, \"test\", reflect.TypeOf(testMap)).Interface().(map[string]interface{})\n\t\tif actual[\"a\"].(map[string]interface{})[\"b\"].(float64) != 45 {\n\t\t\tt.Errorf(\"Failed to fetch map value %#v\", actual[\"a\"])\n\t\t}\n\t\t// Check to see if a named map works\n\t\tactualb := Bind(params, \"test\", reflect.TypeOf(map[string]map[string]float64{})).Interface().(map[string]map[string]float64)\n\t\tif actualb[\"a\"][\"b\"] != 45 {\n\t\t\tt.Errorf(\"Failed to fetch map value %#v\", actual[\"a\"])\n\t\t}\n\n\t}\n}\n\nfunc TestBinder(t *testing.T) {\n\t// Reuse the mvc_test.go multipart request to test the binder.\n\tparams := &Params{}\n\tc := NewTestController(nil, getMultipartRequest())\n\tParseParams(params, NewRequest(c.Request.In))\n\tparams.Values = ParamTestValues\n\n\t// Values\n\tfor k, v := range binderTestCases {\n\t\tactual := Bind(params, k, reflect.TypeOf(v))\n\t\texpected := reflect.ValueOf(v)\n\t\tvalEq(t, k, actual, expected)\n\t}\n\n\t// Files\n\n\t// Get the keys in sorted order to make the expectation right.\n\tkeys := []string{}\n\tfor k := range expectedFiles {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\texpectedBoundFiles := make(map[string][]fh)\n\tfor _, k := range keys {\n\t\tfhs := expectedFiles[k]\n\t\tk := nextKey(k)\n\t\texpectedBoundFiles[k] = append(expectedBoundFiles[k], fhs...)\n\t}\n\n\tfor k, fhs := range expectedBoundFiles {\n\n\t\tif len(fhs) == 1 {\n\t\t\t// Test binding single files to: *os.File, []byte, io.Reader, io.ReadSeeker\n\t\t\tfor _, binding := range fileBindings {\n\t\t\t\ttyp := reflect.TypeOf(binding.val).Elem()\n\t\t\t\tactual := Bind(params, k, typ)\n\t\t\t\tif !actual.IsValid() || (actual.Kind() == reflect.Interface && actual.IsNil()) {\n\t\t\t\t\tt.Errorf(\"%s (%s) - Returned nil.\", k, typ)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturns := reflect.ValueOf(binding.f).Call([]reflect.Value{actual})\n\t\t\t\tvalEq(t, k, returns[0], reflect.ValueOf(fhs[0].content))\n\t\t\t}\n\n\t\t} else {\n\t\t\t// Test binding multi to:\n\t\t\t// []*os.File, [][]byte, []io.Reader, []io.ReadSeeker\n\t\t\tfor _, binding := range fileBindings {\n\t\t\t\ttyp := reflect.TypeOf(binding.arrval)\n\t\t\t\tactual := Bind(params, k, typ)\n\t\t\t\tif actual.Len() != len(fhs) {\n\t\t\t\t\tt.Fatalf(\"%s (%s) - Number of files: (expected) %d != %d (actual)\",\n\t\t\t\t\t\tk, typ, len(fhs), actual.Len())\n\t\t\t\t}\n\t\t\t\tfor i := range fhs {\n\t\t\t\t\treturns := reflect.ValueOf(binding.f).Call([]reflect.Value{actual.Index(i)})\n\t\t\t\t\tif !returns[0].IsValid() {\n\t\t\t\t\t\tt.Errorf(\"%s (%s) - Returned nil.\", k, typ)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvalEq(t, k, returns[0], reflect.ValueOf(fhs[i].content))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Unbinding tests\n\nvar unbinderTestCases = map[string]interface{}{\n\t\"int\":        1,\n\t\"int8\":       int8(1),\n\t\"int16\":      int16(1),\n\t\"int32\":      int32(1),\n\t\"int64\":      int64(1),\n\t\"uint\":       1,\n\t\"uint8\":      uint8(1),\n\t\"uint16\":     uint16(1),\n\t\"uint32\":     uint32(1),\n\t\"uint64\":     uint64(1),\n\t\"float32\":    float32(1.0),\n\t\"float64\":    float64(1.0),\n\t\"str\":        \"hello\",\n\t\"bool-true\":  true,\n\t\"bool-false\": false,\n\t\"date\":       testDate,\n\t\"datetime\":   testDatetime,\n\t\"arr\":        []int{1, 2, 0, 3},\n\t\"2darr\":      [][]int{{0, 1}, {10, 11}},\n\t\"A\":          A{ID: 123, Name: \"rob\"},\n\t\"B\":          A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"pB\":         &A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"arrC\": []A{\n\t\t{\n\t\t\tID:   5,\n\t\t\tName: \"rob\",\n\t\t\tB:    B{\"foo\"},\n\t\t},\n\t\t{\n\t\t\tID:   8,\n\t\t\tName: \"bill\",\n\t\t},\n\t},\n\t\"m\":  map[string]string{\"a\": \"foo\", \"b\": \"bar\"},\n\t\"m2\": map[int]string{1: \"foo\", 2: \"bar\"},\n\t\"m3\": map[string]int{\"a\": 1, \"b\": 2},\n}\n\n// Some of the unbinding results are not exactly what is in ParamTestValues, since it\n// serializes implicit zero values explicitly.\nvar unbinderOverrideAnswers = map[string]map[string]string{\n\t\"arr\": {\n\t\t\"arr[0]\": \"1\",\n\t\t\"arr[1]\": \"2\",\n\t\t\"arr[2]\": \"0\",\n\t\t\"arr[3]\": \"3\",\n\t},\n\t\"A\": {\n\t\t\"A.ID\":      \"123\",\n\t\t\"A.Name\":    \"rob\",\n\t\t\"A.B.Extra\": \"\",\n\t},\n\t\"arrC\": {\n\t\t\"arrC[0].ID\":      \"5\",\n\t\t\"arrC[0].Name\":    \"rob\",\n\t\t\"arrC[0].B.Extra\": \"foo\",\n\t\t\"arrC[1].ID\":      \"8\",\n\t\t\"arrC[1].Name\":    \"bill\",\n\t\t\"arrC[1].B.Extra\": \"\",\n\t},\n\t\"m\":  {\"m[a]\": \"foo\", \"m[b]\": \"bar\"},\n\t\"m2\": {\"m2[1]\": \"foo\", \"m2[2]\": \"bar\"},\n\t\"m3\": {\"m3[a]\": \"1\", \"m3[b]\": \"2\"},\n}\n\nfunc TestUnbinder(t *testing.T) {\n\tfor k, v := range unbinderTestCases {\n\t\tactual := make(map[string]string)\n\t\tUnbind(actual, k, v)\n\n\t\t// Get the expected key/values.\n\t\texpected, ok := unbinderOverrideAnswers[k]\n\t\tif !ok {\n\t\t\texpected = make(map[string]string)\n\t\t\tfor k2, v2 := range ParamTestValues {\n\t\t\t\tif k == k2 || strings.HasPrefix(k2, k+\".\") || strings.HasPrefix(k2, k+\"[\") {\n\t\t\t\t\texpected[k2] = v2[0]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Compare length and values.\n\t\tif len(actual) != len(expected) {\n\t\t\tt.Errorf(\"Length mismatch\\nExpected length %d, actual %d\\nExpected: %s\\nActual: %s\",\n\t\t\t\tlen(expected), len(actual), expected, actual)\n\t\t}\n\t\tfor k, v := range actual {\n\t\t\tif expected[k] != v {\n\t\t\t\tt.Errorf(\"Value mismatch.\\nExpected: %s\\nActual: %s\", expected, actual)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helpers\n\nfunc valEq(t *testing.T, name string, actual, expected reflect.Value) {\n\tswitch expected.Kind() {\n\tcase reflect.Slice:\n\t\t// Check the type/length/element type\n\t\tif !eq(t, name+\" (type)\", actual.Kind(), expected.Kind()) ||\n\t\t\t!eq(t, name+\" (len)\", actual.Len(), expected.Len()) ||\n\t\t\t!eq(t, name+\" (elem)\", actual.Type().Elem(), expected.Type().Elem()) {\n\t\t\treturn\n\t\t}\n\n\t\t// Check value equality for each element.\n\t\tfor i := 0; i < actual.Len(); i++ {\n\t\t\tvalEq(t, fmt.Sprintf(\"%s[%d]\", name, i), actual.Index(i), expected.Index(i))\n\t\t}\n\n\tcase reflect.Ptr:\n\t\t// Check equality on the element type.\n\t\tvalEq(t, name, actual.Elem(), expected.Elem())\n\tcase reflect.Map:\n\t\tif !eq(t, name+\" (len)\", actual.Len(), expected.Len()) {\n\t\t\treturn\n\t\t}\n\t\tfor _, key := range expected.MapKeys() {\n\t\t\texpectedValue := expected.MapIndex(key)\n\t\t\tactualValue := actual.MapIndex(key)\n\t\t\tif actualValue.IsValid() {\n\t\t\t\tvalEq(t, fmt.Sprintf(\"%s[%s]\", name, key), actualValue, expectedValue)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Expected key %s not found\", key)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\teq(t, name, actual.Interface(), expected.Interface())\n\t}\n}\n\nfunc init() {\n\tDateFormat = DefaultDateFormat\n\tDateTimeFormat = DefaultDateTimeFormat\n\tTimeFormats = append(TimeFormats, DefaultDateFormat, DefaultDateTimeFormat, \"01/02/2006\")\n}\n"], "fixing_code": ["// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// A Binder translates between string parameters and Go data structures.\ntype Binder struct {\n\t// Bind takes the name and type of the desired parameter and constructs it\n\t// from one or more values from Params.\n\t//\n\t// Example\n\t//\n\t// Request:\n\t//   url?id=123&ol[0]=1&ol[1]=2&ul[]=str&ul[]=array&user.Name=rob\n\t//\n\t// Action:\n\t//   Example.Action(id int, ol []int, ul []string, user User)\n\t//\n\t// Calls:\n\t//   Bind(params, \"id\", int): 123\n\t//   Bind(params, \"ol\", []int): {1, 2}\n\t//   Bind(params, \"ul\", []string): {\"str\", \"array\"}\n\t//   Bind(params, \"user\", User): User{Name:\"rob\"}\n\t//\n\t// Note that only exported struct fields may be bound.\n\tBind func(params *Params, name string, typ reflect.Type) reflect.Value\n\n\t// Unbind serializes a given value to one or more URL parameters of the given\n\t// name.\n\tUnbind func(output map[string]string, name string, val interface{})\n}\n\nvar binderLog = RevelLog.New(\"section\", \"binder\")\n\n// ValueBinder is adapter for easily making one-key-value binders.\nfunc ValueBinder(f func(value string, typ reflect.Type) reflect.Value) func(*Params, string, reflect.Type) reflect.Value {\n\treturn func(params *Params, name string, typ reflect.Type) reflect.Value {\n\t\tvals, ok := params.Values[name]\n\t\tif !ok || len(vals) == 0 {\n\t\t\treturn reflect.Zero(typ)\n\t\t}\n\t\treturn f(vals[0], typ)\n\t}\n}\n\n// Revel's default date and time constants\nconst (\n\tDefaultDateFormat     = \"2006-01-02\"\n\tDefaultDateTimeFormat = \"2006-01-02 15:04\"\n)\n\n// Binders type and kind definition\nvar (\n\t// These are the lookups to find a Binder for any type of data.\n\t// The most specific binder found will be used (Type before Kind)\n\tTypeBinders = make(map[reflect.Type]Binder)\n\tKindBinders = make(map[reflect.Kind]Binder)\n\n\t// Applications can add custom time formats to this array, and they will be\n\t// automatically attempted when binding a time.Time.\n\tTimeFormats = []string{}\n\n\tDateFormat     string\n\tDateTimeFormat string\n\tTimeZone       = time.UTC\n\n\tIntBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tintValue, err := strconv.ParseInt(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"IntBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetInt(intValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%d\", val)\n\t\t},\n\t}\n\n\tUintBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tuintValue, err := strconv.ParseUint(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"UintBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetUint(uintValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%d\", val)\n\t\t},\n\t}\n\n\tFloatBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tfloatValue, err := strconv.ParseFloat(val, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"FloatBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetFloat(floatValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%f\", val)\n\t\t},\n\t}\n\n\tStringBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\treturn reflect.ValueOf(val)\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\toutput[name] = val.(string)\n\t\t},\n\t}\n\n\t// Booleans support a various value formats,\n\t// refer `revel.Atob` method.\n\tBoolBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\treturn reflect.ValueOf(Atob(val))\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\toutput[name] = fmt.Sprintf(\"%t\", val)\n\t\t},\n\t}\n\n\tPointerBinder = Binder{\n\t\tBind: func(params *Params, name string, typ reflect.Type) reflect.Value {\n\t\t\tv := Bind(params, name, typ.Elem())\n\t\t\tif v.CanAddr() {\n\t\t\t\treturn v.Addr()\n\t\t\t}\n\n\t\t\treturn v\n\t\t},\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\tUnbind(output, name, reflect.ValueOf(val).Elem().Interface())\n\t\t},\n\t}\n\n\tTimeBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tfor _, f := range TimeFormats {\n\t\t\t\tif r, err := time.ParseInLocation(f, val, TimeZone); err == nil {\n\t\t\t\t\treturn reflect.ValueOf(r)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reflect.Zero(typ)\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\tvar (\n\t\t\t\tt       = val.(time.Time)\n\t\t\t\tformat  = DateTimeFormat\n\t\t\t\th, m, s = t.Clock()\n\t\t\t)\n\t\t\tif h == 0 && m == 0 && s == 0 {\n\t\t\t\tformat = DateFormat\n\t\t\t}\n\t\t\toutput[name] = t.Format(format)\n\t\t},\n\t}\n\n\tMapBinder = Binder{\n\t\tBind:   bindMap,\n\t\tUnbind: unbindMap,\n\t}\n)\n\n// Used to keep track of the index for individual keyvalues.\ntype sliceValue struct {\n\tindex int           // Index extracted from brackets.  If -1, no index was provided.\n\tvalue reflect.Value // the bound value for this slice element.\n}\n\n// This function creates a slice of the given type, Binds each of the individual\n// elements, and then sets them to their appropriate location in the slice.\n// If elements are provided without an explicit index, they are added (in\n// unspecified order) to the end of the slice.\nfunc bindSlice(params *Params, name string, typ reflect.Type) reflect.Value {\n\t// Collect an array of slice elements with their indexes (and the max index).\n\tmaxIndex := -1\n\tnumNoIndex := 0\n\tsliceValues := []sliceValue{}\n\n\tmaxIndexBound := Config.IntDefault(\"params.max_index\", 4096)\n\n\t// Factor out the common slice logic (between form values and files).\n\tprocessElement := func(key string, vals []string, files []*multipart.FileHeader) {\n\t\tif !strings.HasPrefix(key, name+\"[\") {\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the index, and the index where a sub-key starts. (e.g. field[0].subkey)\n\t\tindex := -1\n\t\tleftBracket, rightBracket := len(name), strings.Index(key[len(name):], \"]\")+len(name)\n\t\tif rightBracket > leftBracket+1 {\n\t\t\tindex, _ = strconv.Atoi(key[leftBracket+1 : rightBracket])\n\t\t}\n\t\tsubKeyIndex := rightBracket + 1\n\n\t\t// Handle the indexed case.\n\t\tif index > -1 {\n\t\t\t// Just ignore illegal index, fix issue #1424\n\t\t\tif index > maxIndexBound {\n\t\t\t\tbinderLog.Error(\"Ignoring parameter for security reason\", \"index\", index, \"key\", key)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif index > maxIndex {\n\t\t\t\tmaxIndex = index\n\t\t\t}\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: index,\n\t\t\t\tvalue: Bind(params, key[:subKeyIndex], typ.Elem()),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// It's an un-indexed element.  (e.g. element[])\n\t\tnumNoIndex += len(vals) + len(files)\n\t\tfor _, val := range vals {\n\t\t\t// Unindexed values can only be direct-bound.\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: -1,\n\t\t\t\tvalue: BindValue(val, typ.Elem()),\n\t\t\t})\n\t\t}\n\n\t\tfor _, fileHeader := range files {\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: -1,\n\t\t\t\tvalue: BindFile(fileHeader, typ.Elem()),\n\t\t\t})\n\t\t}\n\t}\n\n\tfor key, vals := range params.Values {\n\t\tprocessElement(key, vals, nil)\n\t}\n\tfor key, fileHeaders := range params.Files {\n\t\tprocessElement(key, nil, fileHeaders)\n\t}\n\n\tresultArray := reflect.MakeSlice(typ, maxIndex+1, maxIndex+1+numNoIndex)\n\tfor _, sv := range sliceValues {\n\t\tif sv.index != -1 {\n\t\t\tresultArray.Index(sv.index).Set(sv.value)\n\t\t} else {\n\t\t\tresultArray = reflect.Append(resultArray, sv.value)\n\t\t}\n\t}\n\n\treturn resultArray\n}\n\n// Break on dots and brackets.\n// e.g. bar => \"bar\", bar.baz => \"bar\", bar[0] => \"bar\"\nfunc nextKey(key string) string {\n\tfieldLen := strings.IndexAny(key, \".[\")\n\tif fieldLen == -1 {\n\t\treturn key\n\t}\n\treturn key[:fieldLen]\n}\n\nfunc unbindSlice(output map[string]string, name string, val interface{}) {\n\tv := reflect.ValueOf(val)\n\tfor i := 0; i < v.Len(); i++ {\n\t\tUnbind(output, fmt.Sprintf(\"%s[%d]\", name, i), v.Index(i).Interface())\n\t}\n}\n\nfunc bindStruct(params *Params, name string, typ reflect.Type) reflect.Value {\n\tresultPointer := reflect.New(typ)\n\tresult := resultPointer.Elem()\n\tif params.JSON != nil {\n\t\t// Try to inject the response as a json into the created result\n\t\tif err := json.Unmarshal(params.JSON, resultPointer.Interface()); err != nil {\n\t\t\tbinderLog.Error(\"bindStruct Unable to unmarshal request\", \"name\", name, \"error\", err, \"data\", string(params.JSON))\n\t\t}\n\t\treturn result\n\t}\n\tfieldValues := make(map[string]reflect.Value)\n\tfor key := range params.Values {\n\t\tif !strings.HasPrefix(key, name+\".\") {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the name of the struct property.\n\t\t// Strip off the prefix. e.g. foo.bar.baz => bar.baz\n\t\tsuffix := key[len(name)+1:]\n\t\tfieldName := nextKey(suffix)\n\t\tfieldLen := len(fieldName)\n\n\t\tif _, ok := fieldValues[fieldName]; !ok {\n\t\t\t// Time to bind this field.  Get it and make sure we can set it.\n\t\t\tfieldValue := result.FieldByName(fieldName)\n\t\t\tif !fieldValue.IsValid() {\n\t\t\t\tbinderLog.Warn(\"bindStruct Field not found\", \"name\", fieldName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !fieldValue.CanSet() {\n\t\t\t\tbinderLog.Warn(\"bindStruct Field not settable\", \"name\", fieldName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tboundVal := Bind(params, key[:len(name)+1+fieldLen], fieldValue.Type())\n\t\t\tfieldValue.Set(boundVal)\n\t\t\tfieldValues[fieldName] = boundVal\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc unbindStruct(output map[string]string, name string, iface interface{}) {\n\tval := reflect.ValueOf(iface)\n\ttyp := val.Type()\n\tfor i := 0; i < val.NumField(); i++ {\n\t\tstructField := typ.Field(i)\n\t\tfieldValue := val.Field(i)\n\n\t\t// PkgPath is specified to be empty exactly for exported fields.\n\t\tif structField.PkgPath == \"\" {\n\t\t\tUnbind(output, fmt.Sprintf(\"%s.%s\", name, structField.Name), fieldValue.Interface())\n\t\t}\n\t}\n}\n\n// Helper that returns an upload of the given name, or nil.\nfunc getMultipartFile(params *Params, name string) multipart.File {\n\tfor _, fileHeader := range params.Files[name] {\n\t\tfile, err := fileHeader.Open()\n\t\tif err == nil {\n\t\t\treturn file\n\t\t}\n\t\tbinderLog.Warn(\"getMultipartFile: Failed to open uploaded file\", \"name\", name, \"error\", err)\n\t}\n\treturn nil\n}\n\nfunc bindFile(params *Params, name string, typ reflect.Type) reflect.Value {\n\treader := getMultipartFile(params, name)\n\tif reader == nil {\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t// If it's already stored in a temp file, just return that.\n\tif osFile, ok := reader.(*os.File); ok {\n\t\treturn reflect.ValueOf(osFile)\n\t}\n\n\t// Otherwise, have to store it.\n\ttmpFile, err := ioutil.TempFile(\"\", \"revel-upload\")\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to create a temp file to store upload\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t// Register it to be deleted after the request is done.\n\tparams.tmpFiles = append(params.tmpFiles, tmpFile)\n\n\t_, err = io.Copy(tmpFile, reader)\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to copy upload to temp file\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t_, err = tmpFile.Seek(0, 0)\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to seek to beginning of temp file\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\treturn reflect.ValueOf(tmpFile)\n}\n\nfunc bindByteArray(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif reader := getMultipartFile(params, name); reader != nil {\n\t\tb, err := ioutil.ReadAll(reader)\n\t\tif err == nil {\n\t\t\treturn reflect.ValueOf(b)\n\t\t}\n\t\tbinderLog.Warn(\"bindByteArray: Error reading uploaded file contents\", \"name\", name, \"error\", err)\n\t}\n\treturn reflect.Zero(typ)\n}\n\nfunc bindReadSeeker(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif reader := getMultipartFile(params, name); reader != nil {\n\t\treturn reflect.ValueOf(reader.(io.ReadSeeker))\n\t}\n\treturn reflect.Zero(typ)\n}\n\n// bindMap converts parameters using map syntax into the corresponding map. e.g.:\n//   params[\"a[5]\"]=foo, name=\"a\", typ=map[int]string => map[int]string{5: \"foo\"}\nfunc bindMap(params *Params, name string, typ reflect.Type) reflect.Value {\n\tvar (\n\t\tkeyType   = typ.Key()\n\t\tvalueType = typ.Elem()\n\t\tresultPtr = reflect.New(reflect.MapOf(keyType, valueType))\n\t\tresult    = resultPtr.Elem()\n\t)\n\tresult.Set(reflect.MakeMap(typ))\n\tif params.JSON != nil {\n\t\t// Try to inject the response as a json into the created result\n\t\tif err := json.Unmarshal(params.JSON, resultPtr.Interface()); err != nil {\n\t\t\tbinderLog.Warn(\"bindMap: Unable to unmarshal request\", \"name\", name, \"error\", err)\n\t\t}\n\t\treturn result\n\t}\n\n\tfor paramName := range params.Values {\n\t\t// The paramName string must start with the value in the \"name\" parameter,\n\t\t// otherwise there is no way the parameter is part of the map\n\t\tif !strings.HasPrefix(paramName, name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tsuffix := paramName[len(name)+1:]\n\t\tfieldName := nextKey(suffix)\n\t\tif fieldName != \"\" {\n\t\t\tfieldName = fieldName[:len(fieldName)-1]\n\t\t}\n\t\tif !strings.HasPrefix(paramName, name+\"[\"+fieldName+\"]\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult.SetMapIndex(BindValue(fieldName, keyType), Bind(params, name+\"[\"+fieldName+\"]\", valueType))\n\t}\n\treturn result\n}\n\nfunc unbindMap(output map[string]string, name string, iface interface{}) {\n\tmapValue := reflect.ValueOf(iface)\n\tfor _, key := range mapValue.MapKeys() {\n\t\tUnbind(output, name+\"[\"+fmt.Sprintf(\"%v\", key.Interface())+\"]\",\n\t\t\tmapValue.MapIndex(key).Interface())\n\t}\n}\n\n// Bind takes the name and type of the desired parameter and constructs it\n// from one or more values from Params.\n// Returns the zero value of the type upon any sort of failure.\nfunc Bind(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif binder, found := binderForType(typ); found {\n\t\treturn binder.Bind(params, name, typ)\n\t}\n\treturn reflect.Zero(typ)\n}\n\nfunc BindValue(val string, typ reflect.Type) reflect.Value {\n\treturn Bind(&Params{Values: map[string][]string{\"\": {val}}}, \"\", typ)\n}\n\nfunc BindFile(fileHeader *multipart.FileHeader, typ reflect.Type) reflect.Value {\n\treturn Bind(&Params{Files: map[string][]*multipart.FileHeader{\"\": {fileHeader}}}, \"\", typ)\n}\n\nfunc Unbind(output map[string]string, name string, val interface{}) {\n\tif binder, found := binderForType(reflect.TypeOf(val)); found {\n\t\tif binder.Unbind != nil {\n\t\t\tbinder.Unbind(output, name, val)\n\t\t} else {\n\t\t\tbinderLog.Error(\"Unbind: Unable to unmarshal request\", \"name\", name, \"value\", val)\n\t\t}\n\t}\n}\n\nfunc binderForType(typ reflect.Type) (Binder, bool) {\n\tbinder, ok := TypeBinders[typ]\n\tif !ok {\n\t\tbinder, ok = KindBinders[typ.Kind()]\n\t\tif !ok {\n\t\t\tbinderLog.Error(\"binderForType: no binder for type\", \"type\", typ)\n\t\t\treturn Binder{}, false\n\t\t}\n\t}\n\treturn binder, true\n}\n\n// Sadly, the binder lookups can not be declared initialized -- that results in\n// an \"initialization loop\" compile error.\nfunc init() {\n\tKindBinders[reflect.Int] = IntBinder\n\tKindBinders[reflect.Int8] = IntBinder\n\tKindBinders[reflect.Int16] = IntBinder\n\tKindBinders[reflect.Int32] = IntBinder\n\tKindBinders[reflect.Int64] = IntBinder\n\n\tKindBinders[reflect.Uint] = UintBinder\n\tKindBinders[reflect.Uint8] = UintBinder\n\tKindBinders[reflect.Uint16] = UintBinder\n\tKindBinders[reflect.Uint32] = UintBinder\n\tKindBinders[reflect.Uint64] = UintBinder\n\n\tKindBinders[reflect.Float32] = FloatBinder\n\tKindBinders[reflect.Float64] = FloatBinder\n\n\tKindBinders[reflect.String] = StringBinder\n\tKindBinders[reflect.Bool] = BoolBinder\n\tKindBinders[reflect.Slice] = Binder{bindSlice, unbindSlice}\n\tKindBinders[reflect.Struct] = Binder{bindStruct, unbindStruct}\n\tKindBinders[reflect.Ptr] = PointerBinder\n\tKindBinders[reflect.Map] = MapBinder\n\n\tTypeBinders[reflect.TypeOf(time.Time{})] = TimeBinder\n\n\t// Uploads\n\tTypeBinders[reflect.TypeOf(&os.File{})] = Binder{bindFile, nil}\n\tTypeBinders[reflect.TypeOf([]byte{})] = Binder{bindByteArray, nil}\n\tTypeBinders[reflect.TypeOf((*io.Reader)(nil)).Elem()] = Binder{bindReadSeeker, nil}\n\tTypeBinders[reflect.TypeOf((*io.ReadSeeker)(nil)).Elem()] = Binder{bindReadSeeker, nil}\n\n\tOnAppStart(func() {\n\t\tDateTimeFormat = Config.StringDefault(\"format.datetime\", DefaultDateTimeFormat)\n\t\tDateFormat = Config.StringDefault(\"format.date\", DefaultDateFormat)\n\t\tTimeFormats = append(TimeFormats, DateTimeFormat, DateFormat)\n\t})\n}\n", "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/revel/config\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype A struct {\n\tID      int\n\tName    string\n\tB       B\n\tprivate int\n}\n\ntype B struct {\n\tExtra string\n}\n\nvar (\n\tParamTestValues = map[string][]string{\n\t\t\"int\":                            {\"1\"},\n\t\t\"int8\":                           {\"1\"},\n\t\t\"int16\":                          {\"1\"},\n\t\t\"int32\":                          {\"1\"},\n\t\t\"int64\":                          {\"1\"},\n\t\t\"uint\":                           {\"1\"},\n\t\t\"uint8\":                          {\"1\"},\n\t\t\"uint16\":                         {\"1\"},\n\t\t\"uint32\":                         {\"1\"},\n\t\t\"uint64\":                         {\"1\"},\n\t\t\"float32\":                        {\"1.000000\"},\n\t\t\"float64\":                        {\"1.000000\"},\n\t\t\"str\":                            {\"hello\"},\n\t\t\"bool-true\":                      {\"true\"},\n\t\t\"bool-1\":                         {\"1\"},\n\t\t\"bool-on\":                        {\"on\"},\n\t\t\"bool-false\":                     {\"false\"},\n\t\t\"bool-0\":                         {\"0\"},\n\t\t\"bool-0.0\":                       {\"0.0\"},\n\t\t\"bool-off\":                       {\"off\"},\n\t\t\"bool-f\":                         {\"f\"},\n\t\t\"date\":                           {\"1982-07-09\"},\n\t\t\"datetime\":                       {\"1982-07-09 21:30\"},\n\t\t\"customDate\":                     {\"07/09/1982\"},\n\t\t\"arr[0]\":                         {\"1\"},\n\t\t\"arr[1]\":                         {\"2\"},\n\t\t\"arr[3]\":                         {\"3\"},\n\t\t\"uarr[]\":                         {\"1\", \"2\"},\n\t\t\"arruarr[0][]\":                   {\"1\", \"2\"},\n\t\t\"arruarr[1][]\":                   {\"3\", \"4\"},\n\t\t\"2darr[0][0]\":                    {\"0\"},\n\t\t\"2darr[0][1]\":                    {\"1\"},\n\t\t\"2darr[1][0]\":                    {\"10\"},\n\t\t\"2darr[1][1]\":                    {\"11\"},\n\t\t\"A.ID\":                           {\"123\"},\n\t\t\"A.Name\":                         {\"rob\"},\n\t\t\"B.ID\":                           {\"123\"},\n\t\t\"B.Name\":                         {\"rob\"},\n\t\t\"B.B.Extra\":                      {\"hello\"},\n\t\t\"pB.ID\":                          {\"123\"},\n\t\t\"pB.Name\":                        {\"rob\"},\n\t\t\"pB.B.Extra\":                     {\"hello\"},\n\t\t\"priv.private\":                   {\"123\"},\n\t\t\"arrC[0].ID\":                     {\"5\"},\n\t\t\"arrC[0].Name\":                   {\"rob\"},\n\t\t\"arrC[0].B.Extra\":                {\"foo\"},\n\t\t\"arrC[1].ID\":                     {\"8\"},\n\t\t\"arrC[1].Name\":                   {\"bill\"},\n\t\t\"m[a]\":                           {\"foo\"},\n\t\t\"m[b]\":                           {\"bar\"},\n\t\t\"m2[1]\":                          {\"foo\"},\n\t\t\"m2[2]\":                          {\"bar\"},\n\t\t\"m3[a]\":                          {\"1\"},\n\t\t\"m3[b]\":                          {\"2\"},\n\t\t\"m4[a].ID\":                       {\"1\"},\n\t\t\"m4[a].Name\":                     {\"foo\"},\n\t\t\"m4[b].ID\":                       {\"2\"},\n\t\t\"m4[b].Name\":                     {\"bar\"},\n\t\t\"mapWithAMuchLongerName[a].ID\":   {\"1\"},\n\t\t\"mapWithAMuchLongerName[a].Name\": {\"foo\"},\n\t\t\"mapWithAMuchLongerName[b].ID\":   {\"2\"},\n\t\t\"mapWithAMuchLongerName[b].Name\": {\"bar\"},\n\t\t\"invalidInt\":                     {\"xyz\"},\n\t\t\"invalidInt2\":                    {\"\"},\n\t\t\"invalidBool\":                    {\"xyz\"},\n\t\t\"invalidArr\":                     {\"xyz\"},\n\t\t\"int8-overflow\":                  {\"1024\"},\n\t\t\"uint8-overflow\":                 {\"1024\"},\n\t\t\"arrDoS[2]\":                      {\"2\"},\n\t\t\"arrDoS[65535]\":                  {\"65535\"},\n\t}\n\n\ttestDate     = time.Date(1982, time.July, 9, 0, 0, 0, 0, time.UTC)\n\ttestDatetime = time.Date(1982, time.July, 9, 21, 30, 0, 0, time.UTC)\n)\n\nvar binderTestCases = map[string]interface{}{\n\t\"int\":        1,\n\t\"int8\":       int8(1),\n\t\"int16\":      int16(1),\n\t\"int32\":      int32(1),\n\t\"int64\":      int64(1),\n\t\"uint\":       1,\n\t\"uint8\":      uint8(1),\n\t\"uint16\":     uint16(1),\n\t\"uint32\":     uint32(1),\n\t\"uint64\":     uint64(1),\n\t\"float32\":    float32(1.0),\n\t\"float64\":    float64(1.0),\n\t\"str\":        \"hello\",\n\t\"bool-true\":  true,\n\t\"bool-1\":     true,\n\t\"bool-on\":    true,\n\t\"bool-false\": false,\n\t\"bool-0\":     false,\n\t\"bool-0.0\":   false,\n\t\"bool-off\":   false,\n\t\"bool-f\":     false,\n\t\"date\":       testDate,\n\t\"datetime\":   testDatetime,\n\t\"customDate\": testDate,\n\t\"arr\":        []int{1, 2, 0, 3},\n\t\"uarr\":       []int{1, 2},\n\t\"arruarr\":    [][]int{{1, 2}, {3, 4}},\n\t\"2darr\":      [][]int{{0, 1}, {10, 11}},\n\t\"A\":          A{ID: 123, Name: \"rob\"},\n\t\"B\":          A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"pB\":         &A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"arrC\": []A{\n\t\t{\n\t\t\tID:   5,\n\t\t\tName: \"rob\",\n\t\t\tB:    B{\"foo\"},\n\t\t},\n\t\t{\n\t\t\tID:   8,\n\t\t\tName: \"bill\",\n\t\t},\n\t},\n\t\"m\":  map[string]string{\"a\": \"foo\", \"b\": \"bar\"},\n\t\"m2\": map[int]string{1: \"foo\", 2: \"bar\"},\n\t\"m3\": map[string]int{\"a\": 1, \"b\": 2},\n\t\"m4\": map[string]A{\"a\": {ID: 1, Name: \"foo\"}, \"b\": {ID: 2, Name: \"bar\"}},\n\n\t// NOTE: We also include a map with a longer name than the others since this has caused problems\n\t// described in github issue #1285, resolved in pull request #1344. This test case should\n\t// prevent regression.\n\t\"mapWithAMuchLongerName\": map[string]A{\"a\": {ID: 1, Name: \"foo\"}, \"b\": {ID: 2, Name: \"bar\"}},\n\n\t// TODO: Tests that use TypeBinders\n\n\t// Invalid value tests (the result should always be the zero value for that type)\n\t// The point of these is to ensure that invalid user input does not cause panics.\n\t\"invalidInt\":     0,\n\t\"invalidInt2\":    0,\n\t\"invalidBool\":    true,\n\t\"invalidArr\":     []int{},\n\t\"priv\":           A{},\n\t\"int8-overflow\":  int8(0),\n\t\"uint8-overflow\": uint8(0),\n\t\"arrDoS\":         []int{0, 0, 2},\n}\n\n// Types that files may be bound to, and a func that can read the content from\n// that type.\n// TODO: Is there any way to create a slice, given only the element Type?\nvar fileBindings = []struct{ val, arrval, f interface{} }{\n\t{(**os.File)(nil), []*os.File{}, ioutil.ReadAll},\n\t{(*[]byte)(nil), [][]byte{}, func(b []byte) []byte { return b }},\n\t{(*io.Reader)(nil), []io.Reader{}, ioutil.ReadAll},\n\t{(*io.ReadSeeker)(nil), []io.ReadSeeker{}, ioutil.ReadAll},\n}\n\nfunc TestJsonBinder(t *testing.T) {\n\t// create a structure to be populated\n\t{\n\t\td, _ := json.Marshal(map[string]int{\"a\": 1})\n\t\tparams := &Params{JSON: d}\n\t\tfoo := struct{ A int }{}\n\t\tc := NewTestController(nil, getMultipartRequest())\n\n\t\tParseParams(params, NewRequest(c.Request.In))\n\t\tactual := Bind(params, \"test\", reflect.TypeOf(foo))\n\t\tvalEq(t, \"TestJsonBinder\", reflect.ValueOf(actual.Interface().(struct{ A int }).A), reflect.ValueOf(1))\n\t}\n\t{\n\t\td, _ := json.Marshal(map[string]interface{}{\"a\": map[string]int{\"b\": 45}})\n\t\tparams := &Params{JSON: d}\n\t\ttestMap := map[string]interface{}{}\n\t\tactual := Bind(params, \"test\", reflect.TypeOf(testMap)).Interface().(map[string]interface{})\n\t\tif actual[\"a\"].(map[string]interface{})[\"b\"].(float64) != 45 {\n\t\t\tt.Errorf(\"Failed to fetch map value %#v\", actual[\"a\"])\n\t\t}\n\t\t// Check to see if a named map works\n\t\tactualb := Bind(params, \"test\", reflect.TypeOf(map[string]map[string]float64{})).Interface().(map[string]map[string]float64)\n\t\tif actualb[\"a\"][\"b\"] != 45 {\n\t\t\tt.Errorf(\"Failed to fetch map value %#v\", actual[\"a\"])\n\t\t}\n\n\t}\n}\n\nfunc TestBinder(t *testing.T) {\n\t// Reuse the mvc_test.go multipart request to test the binder.\n\tparams := &Params{}\n\tc := NewTestController(nil, getMultipartRequest())\n\tif Config == nil {\n\t\tConfig = config.NewContext()\n\t\tdefer func() {\n\t\t\tConfig = nil\n\t\t}()\n\t}\n\tParseParams(params, NewRequest(c.Request.In))\n\tparams.Values = ParamTestValues\n\n\t// Values\n\tfor k, v := range binderTestCases {\n\t\tactual := Bind(params, k, reflect.TypeOf(v))\n\t\texpected := reflect.ValueOf(v)\n\t\tvalEq(t, k, actual, expected)\n\t}\n\n\t// Files\n\n\t// Get the keys in sorted order to make the expectation right.\n\tkeys := []string{}\n\tfor k := range expectedFiles {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\texpectedBoundFiles := make(map[string][]fh)\n\tfor _, k := range keys {\n\t\tfhs := expectedFiles[k]\n\t\tk := nextKey(k)\n\t\texpectedBoundFiles[k] = append(expectedBoundFiles[k], fhs...)\n\t}\n\n\tfor k, fhs := range expectedBoundFiles {\n\n\t\tif len(fhs) == 1 {\n\t\t\t// Test binding single files to: *os.File, []byte, io.Reader, io.ReadSeeker\n\t\t\tfor _, binding := range fileBindings {\n\t\t\t\ttyp := reflect.TypeOf(binding.val).Elem()\n\t\t\t\tactual := Bind(params, k, typ)\n\t\t\t\tif !actual.IsValid() || (actual.Kind() == reflect.Interface && actual.IsNil()) {\n\t\t\t\t\tt.Errorf(\"%s (%s) - Returned nil.\", k, typ)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturns := reflect.ValueOf(binding.f).Call([]reflect.Value{actual})\n\t\t\t\tvalEq(t, k, returns[0], reflect.ValueOf(fhs[0].content))\n\t\t\t}\n\n\t\t} else {\n\t\t\t// Test binding multi to:\n\t\t\t// []*os.File, [][]byte, []io.Reader, []io.ReadSeeker\n\t\t\tfor _, binding := range fileBindings {\n\t\t\t\ttyp := reflect.TypeOf(binding.arrval)\n\t\t\t\tactual := Bind(params, k, typ)\n\t\t\t\tif actual.Len() != len(fhs) {\n\t\t\t\t\tt.Fatalf(\"%s (%s) - Number of files: (expected) %d != %d (actual)\",\n\t\t\t\t\t\tk, typ, len(fhs), actual.Len())\n\t\t\t\t}\n\t\t\t\tfor i := range fhs {\n\t\t\t\t\treturns := reflect.ValueOf(binding.f).Call([]reflect.Value{actual.Index(i)})\n\t\t\t\t\tif !returns[0].IsValid() {\n\t\t\t\t\t\tt.Errorf(\"%s (%s) - Returned nil.\", k, typ)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvalEq(t, k, returns[0], reflect.ValueOf(fhs[i].content))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Unbinding tests\n\nvar unbinderTestCases = map[string]interface{}{\n\t\"int\":        1,\n\t\"int8\":       int8(1),\n\t\"int16\":      int16(1),\n\t\"int32\":      int32(1),\n\t\"int64\":      int64(1),\n\t\"uint\":       1,\n\t\"uint8\":      uint8(1),\n\t\"uint16\":     uint16(1),\n\t\"uint32\":     uint32(1),\n\t\"uint64\":     uint64(1),\n\t\"float32\":    float32(1.0),\n\t\"float64\":    float64(1.0),\n\t\"str\":        \"hello\",\n\t\"bool-true\":  true,\n\t\"bool-false\": false,\n\t\"date\":       testDate,\n\t\"datetime\":   testDatetime,\n\t\"arr\":        []int{1, 2, 0, 3},\n\t\"2darr\":      [][]int{{0, 1}, {10, 11}},\n\t\"A\":          A{ID: 123, Name: \"rob\"},\n\t\"B\":          A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"pB\":         &A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"arrC\": []A{\n\t\t{\n\t\t\tID:   5,\n\t\t\tName: \"rob\",\n\t\t\tB:    B{\"foo\"},\n\t\t},\n\t\t{\n\t\t\tID:   8,\n\t\t\tName: \"bill\",\n\t\t},\n\t},\n\t\"m\":  map[string]string{\"a\": \"foo\", \"b\": \"bar\"},\n\t\"m2\": map[int]string{1: \"foo\", 2: \"bar\"},\n\t\"m3\": map[string]int{\"a\": 1, \"b\": 2},\n}\n\n// Some of the unbinding results are not exactly what is in ParamTestValues, since it\n// serializes implicit zero values explicitly.\nvar unbinderOverrideAnswers = map[string]map[string]string{\n\t\"arr\": {\n\t\t\"arr[0]\": \"1\",\n\t\t\"arr[1]\": \"2\",\n\t\t\"arr[2]\": \"0\",\n\t\t\"arr[3]\": \"3\",\n\t},\n\t\"A\": {\n\t\t\"A.ID\":      \"123\",\n\t\t\"A.Name\":    \"rob\",\n\t\t\"A.B.Extra\": \"\",\n\t},\n\t\"arrC\": {\n\t\t\"arrC[0].ID\":      \"5\",\n\t\t\"arrC[0].Name\":    \"rob\",\n\t\t\"arrC[0].B.Extra\": \"foo\",\n\t\t\"arrC[1].ID\":      \"8\",\n\t\t\"arrC[1].Name\":    \"bill\",\n\t\t\"arrC[1].B.Extra\": \"\",\n\t},\n\t\"m\":  {\"m[a]\": \"foo\", \"m[b]\": \"bar\"},\n\t\"m2\": {\"m2[1]\": \"foo\", \"m2[2]\": \"bar\"},\n\t\"m3\": {\"m3[a]\": \"1\", \"m3[b]\": \"2\"},\n}\n\nfunc TestUnbinder(t *testing.T) {\n\tfor k, v := range unbinderTestCases {\n\t\tactual := make(map[string]string)\n\t\tUnbind(actual, k, v)\n\n\t\t// Get the expected key/values.\n\t\texpected, ok := unbinderOverrideAnswers[k]\n\t\tif !ok {\n\t\t\texpected = make(map[string]string)\n\t\t\tfor k2, v2 := range ParamTestValues {\n\t\t\t\tif k == k2 || strings.HasPrefix(k2, k+\".\") || strings.HasPrefix(k2, k+\"[\") {\n\t\t\t\t\texpected[k2] = v2[0]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Compare length and values.\n\t\tif len(actual) != len(expected) {\n\t\t\tt.Errorf(\"Length mismatch\\nExpected length %d, actual %d\\nExpected: %s\\nActual: %s\",\n\t\t\t\tlen(expected), len(actual), expected, actual)\n\t\t}\n\t\tfor k, v := range actual {\n\t\t\tif expected[k] != v {\n\t\t\t\tt.Errorf(\"Value mismatch.\\nExpected: %s\\nActual: %s\", expected, actual)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helpers\n\nfunc valEq(t *testing.T, name string, actual, expected reflect.Value) {\n\tswitch expected.Kind() {\n\tcase reflect.Slice:\n\t\t// Check the type/length/element type\n\t\tif !eq(t, name+\" (type)\", actual.Kind(), expected.Kind()) ||\n\t\t\t!eq(t, name+\" (len)\", actual.Len(), expected.Len()) ||\n\t\t\t!eq(t, name+\" (elem)\", actual.Type().Elem(), expected.Type().Elem()) {\n\t\t\treturn\n\t\t}\n\n\t\t// Check value equality for each element.\n\t\tfor i := 0; i < actual.Len(); i++ {\n\t\t\tvalEq(t, fmt.Sprintf(\"%s[%d]\", name, i), actual.Index(i), expected.Index(i))\n\t\t}\n\n\tcase reflect.Ptr:\n\t\t// Check equality on the element type.\n\t\tvalEq(t, name, actual.Elem(), expected.Elem())\n\tcase reflect.Map:\n\t\tif !eq(t, name+\" (len)\", actual.Len(), expected.Len()) {\n\t\t\treturn\n\t\t}\n\t\tfor _, key := range expected.MapKeys() {\n\t\t\texpectedValue := expected.MapIndex(key)\n\t\t\tactualValue := actual.MapIndex(key)\n\t\t\tif actualValue.IsValid() {\n\t\t\t\tvalEq(t, fmt.Sprintf(\"%s[%s]\", name, key), actualValue, expectedValue)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Expected key %s not found\", key)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\teq(t, name, actual.Interface(), expected.Interface())\n\t}\n}\n\nfunc init() {\n\tDateFormat = DefaultDateFormat\n\tDateTimeFormat = DefaultDateTimeFormat\n\tTimeFormats = append(TimeFormats, DefaultDateFormat, DefaultDateTimeFormat, \"01/02/2006\")\n}\n"], "filenames": ["binder.go", "binder_test.go"], "buggy_code_start_loc": [215, 9], "buggy_code_end_loc": [231, 215], "fixing_code_start_loc": [216, 10], "fixing_code_end_loc": [239, 226], "type": "CWE-770", "message": "Unsanitized input in the query parser in github.com/revel/revel before v1.0.0 allows remote attackers to cause resource exhaustion via memory allocation.", "other": {"cve": {"id": "CVE-2020-36568", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.783", "lastModified": "2023-01-06T01:27:48.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unsanitized input in the query parser in github.com/revel/revel before v1.0.0 allows remote attackers to cause resource exhaustion via memory allocation."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:revel:revel:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "92050CBF-8549-4C5A-8C50-BCEA5A29847F"}]}]}], "references": [{"url": "https://github.com/revel/revel/commit/d160ecb72207824005b19778594cbdc272e8a605", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/revel/revel/issues/1424", "source": "security@golang.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/revel/revel/pull/1427", "source": "security@golang.org", "tags": ["Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0003", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/revel/revel/commit/d160ecb72207824005b19778594cbdc272e8a605"}}