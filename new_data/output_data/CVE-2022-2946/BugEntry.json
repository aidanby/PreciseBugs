{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle tags and the tag stack\n */\n\n#include \"vim.h\"\n\n/*\n * Structure to hold pointers to various items in a tag line.\n */\ntypedef struct tag_pointers\n{\n    // filled in by parse_tag_line():\n    char_u\t*tagname;\t// start of tag name (skip \"file:\")\n    char_u\t*tagname_end;\t// char after tag name\n    char_u\t*fname;\t\t// first char of file name\n    char_u\t*fname_end;\t// char after file name\n    char_u\t*command;\t// first char of command\n    // filled in by parse_match():\n    char_u\t*command_end;\t// first char after command\n    char_u\t*tag_fname;\t// file name of the tags file. This is used\n\t\t\t\t// when 'tr' is set.\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t// TRUE for emacs tag\n#endif\n    char_u\t*tagkind;\t// \"kind:\" value\n    char_u\t*tagkind_end;\t// end of tagkind\n    char_u\t*user_data;\t// user_data string\n    char_u\t*user_data_end;\t// end of user_data\n    linenr_T\ttagline;\t// \"line:\" value\n} tagptrs_T;\n\n/*\n * Return values used when reading lines from a tags file.\n */\ntypedef enum\n{\n    TAGS_READ_SUCCESS = 1,\n    TAGS_READ_EOF,\n    TAGS_READ_IGNORE,\n} tags_read_status_T;\n\n/*\n * States used during a tags search\n */\ntypedef enum\n{\n    TS_START,\t\t// at start of file\n    TS_LINEAR,\t\t// linear searching forward, till EOF\n    TS_BINARY,\t\t// binary searching\n    TS_SKIP_BACK,\t// skipping backwards\n    TS_STEP_FORWARD\t// stepping forwards\n} tagsearch_state_T;\t// Current search state\n\n/*\n * Binary search file offsets in a tags file\n */\ntypedef struct\n{\n    off_T\tlow_offset;\t// offset for first char of first line that\n\t\t\t\t// could match\n    off_T\thigh_offset;\t// offset of char after last line that could\n\t\t\t\t// match\n    off_T\tcurr_offset;\t// Current file offset in search range\n    off_T\tcurr_offset_used; // curr_offset used when skipping back\n    off_T\tmatch_offset;\t// Where the binary search found a tag\n    int\tlow_char;\t\t// first char at low_offset\n    int\thigh_char;\t\t// first char at high_offset\n} tagsearch_info_T;\n\n/*\n * Return values used when matching tags against a pattern.\n */\ntypedef enum\n{\n    TAG_MATCH_SUCCESS = 1,\n    TAG_MATCH_FAIL,\n    TAG_MATCH_STOP,\n    TAG_MATCH_NEXT\n} tagmatch_status_T;\n\n/*\n * Arguments used for matching tags read from a tags file against a pattern.\n */\ntypedef struct\n{\n    int\tmatchoff;\t\t// tag match offset\n    int\tmatch_re;\t\t// TRUE if the tag matches a regexp\n    int\tmatch_no_ic;\t\t// TRUE if the tag matches with case\n    int\thas_re;\t\t\t// regular expression used\n    int\tsortic;\t\t\t// tags file sorted ignoring case (foldcase)\n    int\tsort_error;\t\t// tags file not sorted\n} findtags_match_args_T;\n\n/*\n * The matching tags are first stored in one of the hash tables.  In\n * which one depends on the priority of the match.\n * ht_match[] is used to find duplicates, ga_match[] to keep them in sequence.\n * At the end, all the matches from ga_match[] are concatenated, to make a list\n * sorted on priority.\n */\n#define MT_ST_CUR\t0\t\t// static match in current file\n#define MT_GL_CUR\t1\t\t// global match in current file\n#define MT_GL_OTH\t2\t\t// global match in other file\n#define MT_ST_OTH\t3\t\t// static match in other file\n#define MT_IC_OFF\t4\t\t// add for icase match\n#define MT_RE_OFF\t8\t\t// add for regexp match\n#define MT_MASK\t\t7\t\t// mask for printing priority\n#define MT_COUNT\t16\n\nstatic char\t*mt_names[MT_COUNT/2] =\n\t\t{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};\n\n#define NOTAGFILE\t99\t\t// return value for jumpto_tag\nstatic char_u\t*nofile_fname = NULL;\t// fname for NOTAGFILE error\n\nstatic void taglen_advance(int l);\n\nstatic int jumpto_tag(char_u *lbuf, int forceit, int keep_help);\n#ifdef FEAT_EMACS_TAGS\nstatic int parse_tag_line(char_u *lbuf, int is_etag, tagptrs_T *tagp);\n#else\nstatic int parse_tag_line(char_u *lbuf, tagptrs_T *tagp);\n#endif\nstatic int test_for_static(tagptrs_T *);\nstatic int parse_match(char_u *lbuf, tagptrs_T *tagp);\nstatic char_u *tag_full_fname(tagptrs_T *tagp);\nstatic char_u *expand_tag_fname(char_u *fname, char_u *tag_fname, int expand);\n#ifdef FEAT_EMACS_TAGS\nstatic int test_for_current(int, char_u *, char_u *, char_u *, char_u *);\n#else\nstatic int test_for_current(char_u *, char_u *, char_u *, char_u *);\n#endif\nstatic int find_extra(char_u **pp);\nstatic void print_tag_list(int new_tag, int use_tagstack, int num_matches, char_u **matches);\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\nstatic int add_llist_tags(char_u *tag, int num_matches, char_u **matches);\n#endif\nstatic void tagstack_clear_entry(taggy_T *item);\n\nstatic char_u\t*tagmatchname = NULL;\t// name of last used tag\n\n#if defined(FEAT_QUICKFIX)\n/*\n * Tag for preview window is remembered separately, to avoid messing up the\n * normal tagstack.\n */\nstatic taggy_T ptag_entry = {NULL, {{0, 0, 0}, 0}, 0, 0, NULL};\n#endif\n\n#ifdef FEAT_EVAL\nstatic int  tfu_in_use = FALSE;\t    // disallow recursive call of tagfunc\nstatic callback_T tfu_cb;\t    // 'tagfunc' callback function\n#endif\n\n// Used instead of NUL to separate tag fields in the growarrays.\n#define TAG_SEP 0x02\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Reads the 'tagfunc' option value and convert that to a callback value.\n * Invoked when the 'tagfunc' option is set. The option value can be a name of\n * a function (string), or function(<name>) or funcref(<name>) or a lambda.\n */\n    int\nset_tagfunc_option(void)\n{\n#ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n    free_callback(&curbuf->b_tfu_cb);\n\n    if (*curbuf->b_p_tfu == NUL)\n\treturn OK;\n\n    if (option_set_callback_func(curbuf->b_p_tfu, &tfu_cb) == FAIL)\n\treturn FAIL;\n\n    copy_callback(&curbuf->b_tfu_cb, &tfu_cb);\n#endif\n\n    return OK;\n}\n#endif\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tagfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n# endif\n}\n# endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'tagfunc' callback with 'copyID' so that it is not garbage\n * collected.\n */\n    int\nset_ref_in_tagfunc(int copyID UNUSED)\n{\n    int\tabort = FALSE;\n\n    abort = set_ref_in_callback(&tfu_cb, copyID);\n\n    return abort;\n}\n\n/*\n * Copy the global 'tagfunc' callback function to the buffer-local 'tagfunc'\n * callback for 'buf'.\n */\n    void\nset_buflocal_tfu_callback(buf_T *buf UNUSED)\n{\n    free_callback(&buf->b_tfu_cb);\n    if (tfu_cb.cb_name != NULL && *tfu_cb.cb_name != NUL)\n\tcopy_callback(&buf->b_tfu_cb, &tfu_cb);\n}\n#endif\n\n/*\n * Jump to tag; handling of tag commands and tag stack\n *\n * *tag != NUL: \":tag {tag}\", jump to new tag, add to tag stack\n *\n * type == DT_TAG:\t\":tag [tag]\", jump to newer position or same tag again\n * type == DT_HELP:\tlike DT_TAG, but don't use regexp.\n * type == DT_POP:\t\":pop\" or CTRL-T, jump to old position\n * type == DT_NEXT:\tjump to next match of same tag\n * type == DT_PREV:\tjump to previous match of same tag\n * type == DT_FIRST:\tjump to first match of same tag\n * type == DT_LAST:\tjump to last match of same tag\n * type == DT_SELECT:\t\":tselect [tag]\", select tag from a list of all matches\n * type == DT_JUMP:\t\":tjump [tag]\", jump to tag or select tag from a list\n * type == DT_CSCOPE:\tuse cscope to find the tag\n * type == DT_LTAG:\tuse location list for displaying tag matches\n * type == DT_FREE:\tfree cached matches\n *\n * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise\n */\n    int\ndo_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t    name = tagstack[tagstackidx].tagname;\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * List all the matching tags.\n */\n    static void\nprint_tag_list(\n    int\t\tnew_tag,\n    int\t\tuse_tagstack,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ti;\n    char_u\t*p;\n    char_u\t*command_end;\n    tagptrs_T\ttagp;\n    int\t\ttaglen;\n    int\t\tattr;\n\n    /*\n     * Assume that the first match indicates how long the tags can\n     * be, and align the file names to that.\n     */\n    parse_match(matches[0], &tagp);\n    taglen = (int)(tagp.tagname_end - tagp.tagname + 2);\n    if (taglen < 18)\n\ttaglen = 18;\n    if (taglen > Columns - 25)\n\ttaglen = MAXCOL;\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\t// overwrite previous message\n    msg_start();\n    msg_puts_attr(_(\"  # pri kind tag\"), HL_ATTR(HLF_T));\n    msg_clr_eos();\n    taglen_advance(taglen);\n    msg_puts_attr(_(\"file\\n\"), HL_ATTR(HLF_T));\n\n    for (i = 0; i < num_matches && !got_int; ++i)\n    {\n\tparse_match(matches[i], &tagp);\n\tif (!new_tag && (\n#if defined(FEAT_QUICKFIX)\n\t\t    (g_do_tagpreview != 0\n\t\t     && i == ptag_entry.cur_match) ||\n#endif\n\t\t    (use_tagstack\n\t\t     && i == tagstack[tagstackidx].cur_match)))\n\t    *IObuff = '>';\n\telse\n\t    *IObuff = ' ';\n\tvim_snprintf((char *)IObuff + 1, IOSIZE - 1,\n\t\t\"%2d %s \", i + 1,\n\t\t\t       mt_names[matches[i][0] & MT_MASK]);\n\tmsg_puts((char *)IObuff);\n\tif (tagp.tagkind != NULL)\n\t    msg_outtrans_len(tagp.tagkind,\n\t\t\t  (int)(tagp.tagkind_end - tagp.tagkind));\n\tmsg_advance(13);\n\tmsg_outtrans_len_attr(tagp.tagname,\n\t\t\t   (int)(tagp.tagname_end - tagp.tagname),\n\t\t\t\t\t\t  HL_ATTR(HLF_T));\n\tmsg_putchar(' ');\n\ttaglen_advance(taglen);\n\n\t// Find out the actual file name. If it is long, truncate\n\t// it and put \"...\" in the middle\n\tp = tag_full_fname(&tagp);\n\tif (p != NULL)\n\t{\n\t    msg_outtrans_long_attr(p, HL_ATTR(HLF_D));\n\t    vim_free(p);\n\t}\n\tif (msg_col > 0)\n\t    msg_putchar('\\n');\n\tif (got_int)\n\t    break;\n\tmsg_advance(15);\n\n\t// print any extra fields\n\tcommand_end = tagp.command_end;\n\tif (command_end != NULL)\n\t{\n\t    p = command_end + 3;\n\t    while (*p && *p != '\\r' && *p != '\\n')\n\t    {\n\t\twhile (*p == TAB)\n\t\t    ++p;\n\n\t\t// skip \"file:\" without a value (static tag)\n\t\tif (STRNCMP(p, \"file:\", 5) == 0\n\t\t\t\t\t     && vim_isspace(p[5]))\n\t\t{\n\t\t    p += 5;\n\t\t    continue;\n\t\t}\n\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\tif (p == tagp.tagkind\n\t\t\t|| (p + 5 == tagp.tagkind\n\t\t\t\t&& STRNCMP(p, \"kind:\", 5) == 0))\n\t\t{\n\t\t    p = tagp.tagkind_end;\n\t\t    continue;\n\t\t}\n\t\t// print all other extra fields\n\t\tattr = HL_ATTR(HLF_CM);\n\t\twhile (*p && *p != '\\r' && *p != '\\n')\n\t\t{\n\t\t    if (msg_col + ptr2cells(p) >= Columns)\n\t\t    {\n\t\t\tmsg_putchar('\\n');\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t\tmsg_advance(15);\n\t\t    }\n\t\t    p = msg_outtrans_one(p, attr);\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tmsg_puts_attr(\" \", attr);\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*p == ':')\n\t\t\tattr = 0;\n\t\t}\n\t    }\n\t    if (msg_col > 15)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    break;\n\t\tmsg_advance(15);\n\t    }\n\t}\n\telse\n\t{\n\t    for (p = tagp.command;\n\t\t\t      *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t;\n\t    command_end = p;\n\t}\n\n\t// Put the info (in several lines) at column 15.\n\t// Don't display \"/^\" and \"?^\".\n\tp = tagp.command;\n\tif (*p == '/' || *p == '?')\n\t{\n\t    ++p;\n\t    if (*p == '^')\n\t\t++p;\n\t}\n\t// Remove leading whitespace from pattern\n\twhile (p != command_end && vim_isspace(*p))\n\t    ++p;\n\n\twhile (p != command_end)\n\t{\n\t    if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)\n\t\tmsg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_advance(15);\n\n\t    // skip backslash used for escaping a command char or\n\t    // a backslash\n\t    if (*p == '\\\\' && (*(p + 1) == *tagp.command\n\t\t\t    || *(p + 1) == '\\\\'))\n\t\t++p;\n\n\t    if (*p == TAB)\n\t    {\n\t\tmsg_putchar(' ');\n\t\t++p;\n\t    }\n\t    else\n\t\tp = msg_outtrans_one(p, 0);\n\n\t    // don't display the \"$/;\\\"\" and \"$?;\\\"\"\n\t    if (p == command_end - 2 && *p == '$'\n\t\t\t\t     && *(p + 1) == *tagp.command)\n\t\tbreak;\n\t    // don't display matching '/' or '?'\n\t    if (p == command_end - 1 && *p == *tagp.command\n\t\t\t\t     && (*p == '/' || *p == '?'))\n\t\tbreak;\n\t}\n\tif (msg_col)\n\t    msg_putchar('\\n');\n\tui_breakcheck();\n    }\n    if (got_int)\n\tgot_int = FALSE;\t// only stop the listing\n}\n\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n/*\n * Add the matching tags to the location list for the current\n * window.\n */\n    static int\nadd_llist_tags(\n    char_u\t*tag,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    list_T\t*list;\n    char_u\ttag_name[128 + 1];\n    char_u\t*fname;\n    char_u\t*cmd;\n    int\t\ti;\n    char_u\t*p;\n    tagptrs_T\ttagp;\n\n    fname = alloc(MAXPATHL + 1);\n    cmd = alloc(CMDBUFFSIZE + 1);\n    list = list_alloc();\n    if (list == NULL || fname == NULL || cmd == NULL)\n    {\n\tvim_free(cmd);\n\tvim_free(fname);\n\tif (list != NULL)\n\t    list_free(list);\n\treturn FAIL;\n    }\n\n    for (i = 0; i < num_matches; ++i)\n    {\n\tint\t    len, cmd_len;\n\tlong    lnum;\n\tdict_T  *dict;\n\n\tparse_match(matches[i], &tagp);\n\n\t// Save the tag name\n\tlen = (int)(tagp.tagname_end - tagp.tagname);\n\tif (len > 128)\n\t    len = 128;\n\tvim_strncpy(tag_name, tagp.tagname, len);\n\ttag_name[len] = NUL;\n\n\t// Save the tag file name\n\tp = tag_full_fname(&tagp);\n\tif (p == NULL)\n\t    continue;\n\tvim_strncpy(fname, p, MAXPATHL);\n\tvim_free(p);\n\n\t// Get the line number or the search pattern used to locate\n\t// the tag.\n\tlnum = 0;\n\tif (isdigit(*tagp.command))\n\t    // Line number is used to locate the tag\n\t    lnum = atol((char *)tagp.command);\n\telse\n\t{\n\t    char_u *cmd_start, *cmd_end;\n\n\t    // Search pattern is used to locate the tag\n\n\t    // Locate the end of the command\n\t    cmd_start = tagp.command;\n\t    cmd_end = tagp.command_end;\n\t    if (cmd_end == NULL)\n\t    {\n\t\tfor (p = tagp.command;\n\t\t     *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t    ;\n\t\tcmd_end = p;\n\t    }\n\n\t    // Now, cmd_end points to the character after the\n\t    // command. Adjust it to point to the last\n\t    // character of the command.\n\t    cmd_end--;\n\n\t    // Skip the '/' and '?' characters at the\n\t    // beginning and end of the search pattern.\n\t    if (*cmd_start == '/' || *cmd_start == '?')\n\t\tcmd_start++;\n\n\t    if (*cmd_end == '/' || *cmd_end == '?')\n\t\tcmd_end--;\n\n\t    len = 0;\n\t    cmd[0] = NUL;\n\n\t    // If \"^\" is present in the tag search pattern, then\n\t    // copy it first.\n\t    if (*cmd_start == '^')\n\t    {\n\t\tSTRCPY(cmd, \"^\");\n\t\tcmd_start++;\n\t\tlen++;\n\t    }\n\n\t    // Precede the tag pattern with \\V to make it very\n\t    // nomagic.\n\t    STRCAT(cmd, \"\\\\V\");\n\t    len += 2;\n\n\t    cmd_len = (int)(cmd_end - cmd_start + 1);\n\t    if (cmd_len > (CMDBUFFSIZE - 5))\n\t\tcmd_len = CMDBUFFSIZE - 5;\n\t    STRNCAT(cmd, cmd_start, cmd_len);\n\t    len += cmd_len;\n\n\t    if (cmd[len - 1] == '$')\n\t    {\n\t\t// Replace '$' at the end of the search pattern\n\t\t// with '\\$'\n\t\tcmd[len - 1] = '\\\\';\n\t\tcmd[len] = '$';\n\t\tlen++;\n\t    }\n\n\t    cmd[len] = NUL;\n\t}\n\n\tif ((dict = dict_alloc()) == NULL)\n\t    continue;\n\tif (list_append_dict(list, dict) == FAIL)\n\t{\n\t    vim_free(dict);\n\t    continue;\n\t}\n\n\tdict_add_string(dict, \"text\", tag_name);\n\tdict_add_string(dict, \"filename\", fname);\n\tdict_add_number(dict, \"lnum\", lnum);\n\tif (lnum == 0)\n\t    dict_add_string(dict, \"pattern\", cmd);\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, \"ltag %s\", tag);\n    set_errorlist(curwin, list, ' ', IObuff, NULL);\n\n    list_free(list);\n    vim_free(fname);\n    vim_free(cmd);\n\n    return OK;\n}\n#endif\n\n/*\n * Free cached tags.\n */\n    void\ntag_freematch(void)\n{\n    VIM_CLEAR(tagmatchname);\n}\n\n    static void\ntaglen_advance(int l)\n{\n    if (l == MAXCOL)\n    {\n\tmsg_putchar('\\n');\n\tmsg_advance(24);\n    }\n    else\n\tmsg_advance(13 + l);\n}\n\n/*\n * Print the tag stack\n */\n    void\ndo_tags(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n\n    // Highlight title\n    msg_puts_title(_(\"\\n  # TO tag         FROM line  in file/text\"));\n    for (i = 0; i < tagstacklen; ++i)\n    {\n\tif (tagstack[i].tagname != NULL)\n\t{\n\t    name = fm_getname(&(tagstack[i].fmark), 30);\n\t    if (name == NULL)\t    // file name not available\n\t\tcontinue;\n\n\t    msg_putchar('\\n');\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%c%2d %2d %-15s %5ld  \",\n\t\ti == tagstackidx ? '>' : ' ',\n\t\ti + 1,\n\t\ttagstack[i].cur_match + 1,\n\t\ttagstack[i].tagname,\n\t\ttagstack[i].fmark.mark.lnum);\n\t    msg_outtrans(IObuff);\n\t    msg_outtrans_attr(name, tagstack[i].fmark.fnum == curbuf->b_fnum\n\t\t\t\t\t\t\t? HL_ATTR(HLF_D) : 0);\n\t    vim_free(name);\n\t}\n\tout_flush();\t\t    // show one line at a time\n    }\n    if (tagstackidx == tagstacklen)\t// idx at top of stack\n\tmsg_puts(\"\\n>\");\n}\n\n/*\n * Compare two strings, for length \"len\", ignoring case the ASCII way.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n * Make sure case is folded to uppercase in comparison (like for 'sort -f')\n */\n    static int\ntag_strnicmp(char_u *s1, char_u *s2, size_t len)\n{\n    int\t\ti;\n\n    while (len > 0)\n    {\n\ti = (int)TOUPPER_ASC(*s1) - (int)TOUPPER_ASC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t// this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t// strings match until NUL\n\t++s1;\n\t++s2;\n\t--len;\n    }\n    return 0;\t\t\t\t// strings match\n}\n\n/*\n * Structure to hold info about the tag pattern being used.\n */\ntypedef struct\n{\n    char_u\t*pat;\t\t// the pattern\n    int\t\tlen;\t\t// length of pat[]\n    char_u\t*head;\t\t// start of pattern head\n    int\t\theadlen;\t// length of head[]\n    regmatch_T\tregmatch;\t// regexp program, may be NULL\n} pat_T;\n\n/*\n * Extract info from the tag search pattern \"pats->pat\".\n */\n    static void\nprepare_pats(pat_T *pats, int has_re)\n{\n    pats->head = pats->pat;\n    pats->headlen = pats->len;\n    if (has_re)\n    {\n\t// When the pattern starts with '^' or \"\\\\<\", binary searching can be\n\t// used (much faster).\n\tif (pats->pat[0] == '^')\n\t    pats->head = pats->pat + 1;\n\telse if (pats->pat[0] == '\\\\' && pats->pat[1] == '<')\n\t    pats->head = pats->pat + 2;\n\tif (pats->head == pats->pat)\n\t    pats->headlen = 0;\n\telse\n\t    for (pats->headlen = 0; pats->head[pats->headlen] != NUL;\n\t\t\t\t\t\t\t      ++pats->headlen)\n\t\tif (vim_strchr((char_u *)(magic_isset() ? \".[~*\\\\$\" : \"\\\\$\"),\n\t\t\t\t\t   pats->head[pats->headlen]) != NULL)\n\t\t    break;\n\tif (p_tl != 0 && pats->headlen > p_tl)\t// adjust for 'taglength'\n\t    pats->headlen = p_tl;\n    }\n\n    if (has_re)\n\tpats->regmatch.regprog = vim_regcomp(pats->pat,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n    else\n\tpats->regmatch.regprog = NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call the user-defined function to generate a list of tags used by\n * find_tags().\n *\n * Return OK if at least 1 tag has been successfully found,\n * NOTDONE if the function returns v:null, and FAIL otherwise.\n */\n    static int\nfind_tagfunc_tags(\n    char_u\t*pat,\t\t// pattern supplied to the user-defined function\n    garray_T\t*ga,\t\t// the tags will be placed here\n    int\t\t*match_count,\t// here the number of tags found will be placed\n    int\t\tflags,\t\t// flags from find_tags (TAG_*)\n    char_u\t*buf_ffname)\t// name of buffer for priority\n{\n    pos_T       save_pos;\n    list_T      *taglist;\n    listitem_T  *item;\n    int\t\tntags = 0;\n    int\t\tresult = FAIL;\n    typval_T\targs[4];\n    typval_T\trettv;\n    char_u      flagString[4];\n    dict_T\t*d;\n    taggy_T\t*tag = &curwin->w_tagstack[curwin->w_tagstackidx];\n\n    if (*curbuf->b_p_tfu == NUL || curbuf->b_tfu_cb.cb_name == NULL\n\t\t\t\t\t   || *curbuf->b_tfu_cb.cb_name == NUL)\n\treturn FAIL;\n\n    args[0].v_type = VAR_STRING;\n    args[0].vval.v_string = pat;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = flagString;\n\n    // create 'info' dict argument\n    if ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\treturn FAIL;\n    if (tag->user_data != NULL)\n\tdict_add_string(d, \"user_data\", tag->user_data);\n    if (buf_ffname != NULL)\n\tdict_add_string(d, \"buf_ffname\", buf_ffname);\n\n    ++d->dv_refcount;\n    args[2].v_type = VAR_DICT;\n    args[2].vval.v_dict = d;\n\n    args[3].v_type = VAR_UNKNOWN;\n\n    vim_snprintf((char *)flagString, sizeof(flagString),\n\t\t \"%s%s%s\",\n\t\t g_tag_at_cursor      ? \"c\": \"\",\n\t\t flags & TAG_INS_COMP ? \"i\": \"\",\n\t\t flags & TAG_REGEXP   ? \"r\": \"\");\n\n    save_pos = curwin->w_cursor;\n    result = call_callback(&curbuf->b_tfu_cb, 0, &rettv, 3, args);\n    curwin->w_cursor = save_pos;\t// restore the cursor position\n    --d->dv_refcount;\n\n    if (result == FAIL)\n\treturn FAIL;\n    if (rettv.v_type == VAR_SPECIAL && rettv.vval.v_number == VVAL_NULL)\n    {\n\tclear_tv(&rettv);\n\treturn NOTDONE;\n    }\n    if (rettv.v_type != VAR_LIST || !rettv.vval.v_list)\n    {\n\tclear_tv(&rettv);\n\temsg(_(e_invalid_return_value_from_tagfunc));\n\treturn FAIL;\n    }\n    taglist = rettv.vval.v_list;\n\n    FOR_ALL_LIST_ITEMS(taglist, item)\n    {\n\tchar_u\t\t*mfp;\n\tchar_u\t\t*res_name, *res_fname, *res_cmd, *res_kind;\n\tint\t\tlen;\n\tdict_iterator_T\titer;\n\tchar_u\t\t*dict_key;\n\ttypval_T\t*tv;\n\tint\t\thas_extra = 0;\n\tint\t\tname_only = flags & TAG_NAMES;\n\n\tif (item->li_tv.v_type != VAR_DICT)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n#ifdef FEAT_EMACS_TAGS\n\tlen = 3;\n#else\n\tlen = 2;\n#endif\n\tres_name = NULL;\n\tres_fname = NULL;\n\tres_cmd = NULL;\n\tres_kind = NULL;\n\n\tdict_iterate_start(&item->li_tv, &iter);\n\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t{\n\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\tcontinue;\n\n\t    len += (int)STRLEN(tv->vval.v_string) + 1;   // Space for \"\\tVALUE\"\n\t    if (!STRCMP(dict_key, \"name\"))\n\t    {\n\t\tres_name = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"filename\"))\n\t    {\n\t\tres_fname = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"cmd\"))\n\t    {\n\t\tres_cmd = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    has_extra = 1;\n\t    if (!STRCMP(dict_key, \"kind\"))\n\t    {\n\t\tres_kind = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    // Other elements will be stored as \"\\tKEY:VALUE\"\n\t    // Allocate space for the key and the colon\n\t    len += (int)STRLEN(dict_key) + 1;\n\t}\n\n\tif (has_extra)\n\t    len += 2;\t// need space for ;\"\n\n\tif (!res_name || !res_fname || !res_cmd)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n\tif (name_only)\n\t    mfp = vim_strsave(res_name);\n\telse\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\n\tif (mfp == NULL)\n\t    continue;\n\n\tif (!name_only)\n\t{\n\t    char_u *p = mfp;\n\n\t    *p++ = MT_GL_OTH + 1;   // mtt\n\t    *p++ = TAG_SEP;\t    // no tag file name\n#ifdef FEAT_EMACS_TAGS\n\t    *p++ = TAG_SEP;\n#endif\n\n\t    STRCPY(p, res_name);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_fname);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_cmd);\n\t    p += STRLEN(p);\n\n\t    if (has_extra)\n\t    {\n\t\tSTRCPY(p, \";\\\"\");\n\t\tp += STRLEN(p);\n\n\t\tif (res_kind)\n\t\t{\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, res_kind);\n\t\t    p += STRLEN(p);\n\t\t}\n\n\t\tdict_iterate_start(&item->li_tv, &iter);\n\t\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t\t{\n\t\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\t\tcontinue;\n\n\t\t    if (!STRCMP(dict_key, \"name\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"filename\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"cmd\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"kind\"))\n\t\t\tcontinue;\n\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, dict_key);\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, \":\");\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, tv->vval.v_string);\n\t\t    p += STRLEN(p);\n\t\t}\n\t    }\n\t}\n\n\t// Add all matches because tagfunc should do filtering.\n\tif (ga_grow(ga, 1) == OK)\n\t{\n\t    ((char_u **)(ga->ga_data))[ga->ga_len++] = mfp;\n\t    ++ntags;\n\t    result = OK;\n\t}\n\telse\n\t{\n\t    vim_free(mfp);\n\t    break;\n\t}\n    }\n\n    clear_tv(&rettv);\n\n    *match_count = ntags;\n    return result;\n}\n#endif\n\n/*\n * State information used during a tag search\n */\ntypedef struct\n{\n    tagsearch_state_T\tstate;\t\t// tag search state\n    int\t\tstop_searching;\t\t// stop when match found or error\n    pat_T\t*orgpat;\t\t// holds unconverted pattern info\n    char_u     *lbuf;\t\t\t// line buffer\n    int\t\tlbuf_size;\t\t// length of lbuf\n    char_u\t*tag_fname;\t\t// name of the tag file\n    FILE\t*fp;\t\t\t// current tags file pointer\n    int\t\tflags;\t\t\t// flags used for tag search\n    int\t\ttag_file_sorted;\t// !_TAG_FILE_SORTED value\n    int\t\tget_searchpat;\t\t// used for 'showfulltag'\n    int\t\thelp_only;\t\t// only search for help tags\n    int\t\tdid_open;\t\t// did open a tag file\n    int\t\tmincount;\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    int\t\tlinear;\t\t\t// do a linear search\n    vimconv_T\tvimconv;\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t\t// current file is emacs style\n    char_u\t*ebuf;\t\t\t// additional buffer for etag fname\n#endif\n#ifdef FEAT_MULTI_LANG\n    char_u\thelp_lang[3];\t\t// lang of current tags file\n    int\t\thelp_pri;\t\t// help language priority\n    char_u\t*help_lang_find;\t// lang to be found\n    int\t\tis_txt;\t\t\t// flag of file extension\n#endif\n    int\t\tmatch_count;\t\t// number of matches found\n    garray_T\tga_match[MT_COUNT];\t// stores matches in sequence\n    hashtab_T\tht_match[MT_COUNT];\t// stores matches by key\n} findtags_state_T;\n\n/*\n * Initialize the state used by find_tags().\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    static int\nfindtags_state_init(\n    findtags_state_T\t*st,\n    char_u\t\t*pat,\n    int\t\t\tflags,\n    int\t\t\tmincount)\n{\n    int\t\tmtt;\n\n    st->tag_fname = alloc(MAXPATHL + 1);\n    st->fp = NULL;\n    st->orgpat = ALLOC_ONE(pat_T);\n    st->orgpat->pat = pat;\n    st->orgpat->len = (int)STRLEN(pat);\n    st->orgpat->regmatch.regprog = NULL;\n    st->flags = flags;\n    st->tag_file_sorted = NUL;\n    st->help_only = (flags & TAG_HELP);\n    st->get_searchpat = FALSE;\n#ifdef FEAT_MULTI_LANG\n    st->help_lang[0] = NUL;\n    st->help_pri = 0;\n    st->help_lang_find = NULL;\n    st->is_txt = FALSE;\n#endif\n    st->did_open = FALSE;\n    st->mincount = mincount;\n    st->lbuf_size = LSIZE;\n    st->lbuf = alloc(st->lbuf_size);\n#ifdef FEAT_EMACS_TAGS\n    st->ebuf = alloc(LSIZE);\n#endif\n    st->match_count = 0;\n    st->stop_searching = FALSE;\n\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tga_init2(&st->ga_match[mtt], sizeof(char_u *), 100);\n\thash_init(&st->ht_match[mtt]);\n    }\n\n    // check for out of memory situation\n    if (st->tag_fname == NULL\n\t    || st->lbuf == NULL\n#ifdef FEAT_EMACS_TAGS\n\t    || st->ebuf == NULL\n#endif\n       )\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the state used by find_tags()\n */\n    static void\nfindtags_state_free(findtags_state_T *st)\n{\n    vim_free(st->tag_fname);\n    vim_free(st->lbuf);\n    vim_regfree(st->orgpat->regmatch.regprog);\n    vim_free(st->orgpat);\n#ifdef FEAT_EMACS_TAGS\n    vim_free(st->ebuf);\n#endif\n}\n\n#ifdef FEAT_MULTI_LANG\n/*\n * Initialize the language and priority used for searching tags in a Vim help\n * file.\n * Returns TRUE to process the help file for tags and FALSE to skip the file.\n */\n    static int\nfindtags_in_help_init(findtags_state_T *st)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    // Keep 'en' as the language if the file extension is '.txt'\n    if (st->is_txt)\n\tSTRCPY(st->help_lang, \"en\");\n    else\n    {\n\t// Prefer help tags according to 'helplang'.  Put the two-letter\n\t// language name in help_lang[].\n\ti = (int)STRLEN(st->tag_fname);\n\tif (i > 3 && st->tag_fname[i - 3] == '-')\n\t    vim_strncpy(st->help_lang, st->tag_fname + i - 2, 2);\n\telse\n\t    STRCPY(st->help_lang, \"en\");\n    }\n    // When searching for a specific language skip tags files for other\n    // languages.\n    if (st->help_lang_find != NULL\n\t    && STRICMP(st->help_lang, st->help_lang_find) != 0)\n\treturn FALSE;\n\n    // For CTRL-] in a help file prefer a match with the same language.\n    if ((st->flags & TAG_KEEP_LANG)\n\t    && st->help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && curbuf->b_fname[i - 1] == 'x'\n\t    && curbuf->b_fname[i - 4] == '.'\n\t    && STRNICMP(curbuf->b_fname + i - 3, st->help_lang, 2) == 0)\n\tst->help_pri = 0;\n    else\n    {\n\t// search for the language in 'helplang'\n\tst->help_pri = 1;\n\tfor (s = p_hlg; *s != NUL; ++s)\n\t{\n\t    if (STRNICMP(s, st->help_lang, 2) == 0)\n\t\tbreak;\n\t    ++st->help_pri;\n\t    if ((s = vim_strchr(s, ',')) == NULL)\n\t\tbreak;\n\t}\n\tif (s == NULL || *s == NUL)\n\t{\n\t    // Language not in 'helplang': use last, prefer English, unless\n\t    // found already.\n\t    ++st->help_pri;\n\t    if (STRICMP(st->help_lang, \"en\") != 0)\n\t\t++st->help_pri;\n\t}\n    }\n\n    return TRUE;\n}\n#endif\n\n#ifdef FEAT_EVAL\n/*\n * Use the function set in 'tagfunc' (if configured and enabled) to get the\n * tags.\n * Return OK if at least 1 tag has been successfully found, NOTDONE if the\n * 'tagfunc' is not used or the 'tagfunc' returns v:null and FAIL otherwise.\n */\n    static int\nfindtags_apply_tfu(findtags_state_T *st, char_u *pat, char_u *buf_ffname)\n{\n    int\t\tuse_tfu = ((st->flags & TAG_NO_TAGFUNC) == 0);\n    int\t\tretval;\n\n    if (!use_tfu || tfu_in_use || *curbuf->b_p_tfu == NUL)\n\treturn NOTDONE;\n\n    tfu_in_use = TRUE;\n    retval = find_tagfunc_tags(pat, st->ga_match, &st->match_count,\n\t\t\t\t\t\tst->flags, buf_ffname);\n    tfu_in_use = FALSE;\n\n    return retval;\n}\n#endif\n\n#ifdef FEAT_EMACS_TAGS\n/*\n * Stack for included emacs-tags file.\n * It has a fixed size, to truncate cyclic includes. jw\n */\n# define INCSTACK_SIZE 42\nstatic struct\n{\n    FILE\t*fp;\n    char_u\t*etag_fname;\n} incstack[INCSTACK_SIZE];\nstatic int incstack_idx = 0;\t// index in incstack\n\n/*\n * Free the emacs include tags file stack.\n */\n    static void\nemacs_tags_incstack_free(void)\n{\n    while (incstack_idx)\n    {\n\t--incstack_idx;\n\tfclose(incstack[incstack_idx].fp);\n\tincstack[incstack_idx].fp = NULL;\n\tVIM_CLEAR(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Emacs tags line with CTRL-L: New file name on next line.\n * The file name is followed by a ','.  Remember etag file name in ebuf.\n * The FILE pointer to the tags file is stored in 'st->fp'.  If another tags\n * file is included, then the FILE pointer to the new tags file is stored in\n * 'st->fp'. The old file pointer is saved in incstack.\n */\n    static void\nemacs_tags_new_filename(findtags_state_T *st)\n{\n    char_u\t*p;\n    char_u\t*fullpath_ebuf;\n\n    if (vim_fgets(st->ebuf, LSIZE, st->fp))\n\treturn;\n\n    for (p = st->ebuf; *p && *p != ','; p++)\n\t;\n    *p = NUL;\n\n    // check for an included tags file.\n    // atoi(p+1) is the number of bytes before the next ^L unless it is an\n    // include statement. Skip the included tags file if it exceeds the\n    // maximum.\n    if (STRNCMP(p + 1, \"include\", 7) != 0 || incstack_idx >= INCSTACK_SIZE)\n\treturn;\n\n    // Save current \"fp\" and \"tag_fname\" in the stack.\n    incstack[incstack_idx].etag_fname = vim_strsave(st->tag_fname);\n    if (incstack[incstack_idx].etag_fname == NULL)\n\treturn;\n\n    incstack[incstack_idx].fp = st->fp;\n    st->fp = NULL;\n\n    // Figure out \"tag_fname\" and \"fp\" to use for\n    // included file.\n    fullpath_ebuf = expand_tag_fname(st->ebuf, st->tag_fname, FALSE);\n    if (fullpath_ebuf != NULL)\n    {\n\tst->fp = mch_fopen((char *)fullpath_ebuf, \"r\");\n\tif (st->fp != NULL)\n\t{\n\t    if (STRLEN(fullpath_ebuf) > LSIZE)\n\t\tsemsg(_(e_tag_file_path_truncated_for_str), st->ebuf);\n\t    vim_strncpy(st->tag_fname, fullpath_ebuf, MAXPATHL);\n\t    ++incstack_idx;\n\t    st->is_etag = FALSE; // we can include anything\n\t}\n\tvim_free(fullpath_ebuf);\n    }\n    if (st->fp == NULL)\n    {\n\t// Can't open the included file, skip it and\n\t// restore old value of \"fp\".\n\tst->fp = incstack[incstack_idx].fp;\n\tvim_free(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Reached the end of an emacs-style tags file. If this is an included tags\n * file, then pop it from the incstack and continue processing the parent tags\n * file. Otherwise, processed all the tags.\n * Returns TRUE if an included tags file is popped and processing should\n * continue with the parent tags file. Returns FALSE to stop processing tags.\n */\n    static int\nemacs_tags_file_eof(findtags_state_T *st)\n{\n    if (!incstack_idx)\t// reached end of file. stop processing.\n\treturn FALSE;\n\n    // reached the end of an included tags file. pop it.\n    --incstack_idx;\n    fclose(st->fp);\t// end of this file ...\n    st->fp = incstack[incstack_idx].fp;\n    STRCPY(st->tag_fname, incstack[incstack_idx].etag_fname);\n    vim_free(incstack[incstack_idx].etag_fname);\n    st->is_etag = TRUE;\t// (only etags can include)\n\n    return TRUE;\n}\n\n/*\n * Parse a line from an emacs-style tags file.\n * Returns OK if the line is parsed successfully, returns FAIL if the line is\n * not terminated by a newline.\n */\n    static int\nemacs_tags_parse_line(char_u *lbuf, tagptrs_T *tagp)\n{\n    char_u\t*p_7f;\n    char_u\t*p;\n\n    // There are two formats for an emacs tag line:\n    // 1:  struct EnvBase ^?EnvBase^A139,4627\n    // 2: #define\tARPB_WILD_WORLD ^?153,5194\n    p_7f = vim_strchr(lbuf, 0x7f);\n    if (p_7f == NULL)\n    {\netag_fail:\n\tif (vim_strchr(lbuf, '\\n') != NULL)\n\t    return FAIL;\n\n\t// Truncated line.  Ignore it.\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    msg(_(\"Ignoring long line in tags file\"));\n\t    verbose_leave();\n\t}\n\ttagp->command = lbuf;\n\ttagp->tagname = lbuf;\n\ttagp->tagname_end = lbuf;\n\treturn OK;\n    }\n\n    // Find ^A.  If not found the line number is after the 0x7f\n    p = vim_strchr(p_7f, Ctrl_A);\n    if (p == NULL)\n\tp = p_7f + 1;\n    else\n\t++p;\n\n    if (!VIM_ISDIGIT(*p))\t    // check for start of line number\n\tgoto etag_fail;\n    tagp->command = p;\n\n    if (p[-1] == Ctrl_A)\t    // first format: explicit tagname given\n    {\n\ttagp->tagname = p_7f + 1;\n\ttagp->tagname_end = p - 1;\n    }\n    else\t\t\t    // second format: isolate tagname\n    {\n\t// find end of tagname\n\tfor (p = p_7f - 1; !vim_iswordc(*p); --p)\n\t    if (p == lbuf)\n\t\tgoto etag_fail;\n\ttagp->tagname_end = p + 1;\n\twhile (p >= lbuf && vim_iswordc(*p))\n\t    --p;\n\ttagp->tagname = p + 1;\n    }\n\n    return OK;\n}\n#endif\n\n/*\n * Read the next line from a tags file.\n * Returns TAGS_READ_SUCCESS if a tags line is successfully read and should be\n * processed.\n * Returns TAGS_READ_EOF if the end of file is reached.\n * Returns TAGS_READ_IGNORE if the current line should be ignored (used when\n * reached end of a emacs included tags file)\n */\n    static tags_read_status_T\nfindtags_get_next_line(findtags_state_T *st, tagsearch_info_T *sinfo_p)\n{\n    int\t\teof;\n    off_T\toffset;\n\n    // For binary search: compute the next offset to use.\n    if (st->state == TS_BINARY)\n    {\n\toffset = sinfo_p->low_offset + ((sinfo_p->high_offset\n\t\t\t\t\t\t- sinfo_p->low_offset) / 2);\n\tif (offset == sinfo_p->curr_offset)\n\t    return TAGS_READ_EOF; // End the binary search without a match.\n\telse\n\t    sinfo_p->curr_offset = offset;\n    }\n\n    // Skipping back (after a match during binary search).\n    else if (st->state == TS_SKIP_BACK)\n    {\n\tsinfo_p->curr_offset -= st->lbuf_size * 2;\n\tif (sinfo_p->curr_offset < 0)\n\t{\n\t    sinfo_p->curr_offset = 0;\n\t    rewind(st->fp);\n\t    st->state = TS_STEP_FORWARD;\n\t}\n    }\n\n    // When jumping around in the file, first read a line to find the\n    // start of the next line.\n    if (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n    {\n\t// Adjust the search file offset to the correct position\n\tsinfo_p->curr_offset_used = sinfo_p->curr_offset;\n\tvim_ignored = vim_fseek(st->fp, sinfo_p->curr_offset, SEEK_SET);\n\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\tif (!eof && sinfo_p->curr_offset != 0)\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    if (sinfo_p->curr_offset == sinfo_p->high_offset)\n\t    {\n\t\t// oops, gone a bit too far; try from low offset\n\t\tvim_ignored = vim_fseek(st->fp, sinfo_p->low_offset, SEEK_SET);\n\t\tsinfo_p->curr_offset = sinfo_p->low_offset;\n\t    }\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\t// skip empty and blank lines\n\twhile (!eof && vim_isblankline(st->lbuf))\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\tif (eof)\n\t{\n\t    // Hit end of file.  Skip backwards.\n\t    st->state = TS_SKIP_BACK;\n\t    sinfo_p->match_offset = vim_ftell(st->fp);\n\t    sinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAGS_READ_IGNORE;\n\t}\n    }\n    // Not jumping around in the file: Read the next line.\n    else\n    {\n\t// skip empty and blank lines\n\tdo\n\t{\n#ifdef FEAT_CSCOPE\n\t    if (st->flags & TAG_CSCOPE)\n\t\teof = cs_fgets(st->lbuf, st->lbuf_size);\n\t    else\n#endif\n\t\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t} while (!eof && vim_isblankline(st->lbuf));\n\n\tif (eof)\n\t{\n#ifdef FEAT_EMACS_TAGS\n\t    if (emacs_tags_file_eof(st) == TRUE)\n\t\t// an included tags file. Continue processing the parent\n\t\t// tags file.\n\t\treturn TAGS_READ_IGNORE;\n#endif\n\t    return TAGS_READ_EOF;\n\t}\n    }\n\n    return TAGS_READ_SUCCESS;\n}\n\n/*\n * Parse a tags file header line in 'st->lbuf'.\n * Returns TRUE if the current line in st->lbuf is not a tags header line and\n * should be parsed as a regular tag line. Returns FALSE if the line is a\n * header line and the next header line should be read.\n */\n    static int\nfindtags_hdr_parse(findtags_state_T *st)\n{\n    char_u\t*p;\n\n    // Header lines in a tags file start with \"!_TAG_\"\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) != 0)\n\t// Non-header item before the header, e.g. \"!\" itself.\n\treturn TRUE;\n\n    // Process the header line.\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_SORTED\\t\", 18) == 0)\n\tst->tag_file_sorted = st->lbuf[18];\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_ENCODING\\t\", 20) == 0)\n    {\n\t// Prepare to convert every line from the specified encoding to\n\t// 'encoding'.\n\tfor (p = st->lbuf + 20; *p > ' ' && *p < 127; ++p)\n\t    ;\n\t*p = NUL;\n\tconvert_setup(&st->vimconv, st->lbuf + 20, p_enc);\n    }\n\n    // Read the next line.  Unrecognized flags are ignored.\n    return FALSE;\n}\n\n/*\n * Handler to initialize the state when starting to process a new tags file.\n * Called in the TS_START state when finding tags from a tags file.\n * Returns TRUE if the line read from the tags file should be parsed and\n * FALSE if the line should be ignored.\n */\n    static int\nfindtags_start_state_handler(\n    findtags_state_T\t*st,\n    int\t\t\t*sortic,\n    tagsearch_info_T\t*sinfo_p)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tnoic = (st->flags & TAG_NOIC);\n    off_T\tfilesize;\n\n    // The header ends when the line sorts below \"!_TAG_\".  When case is\n    // folded lower case letters sort before \"_\".\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) <= 0\n\t    || (st->lbuf[0] == '!' && ASCII_ISLOWER(st->lbuf[1])))\n\treturn findtags_hdr_parse(st);\n\n    // Headers ends.\n\n    // When there is no tag head, or ignoring case, need to do a\n    // linear search.\n    // When no \"!_TAG_\" is found, default to binary search.  If\n    // the tag file isn't sorted, the second loop will find it.\n    // When \"!_TAG_FILE_SORTED\" found: start binary search if\n    // flag set.\n    // For cscope, it's always linear.\n# ifdef FEAT_CSCOPE\n    if (st->linear || use_cscope)\n# else\n    if (st->linear)\n# endif\n\tst->state = TS_LINEAR;\n    else if (st->tag_file_sorted == NUL)\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '1')\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '2')\n    {\n\tst->state = TS_BINARY;\n\t*sortic = TRUE;\n\tst->orgpat->regmatch.rm_ic = (p_ic || !noic);\n    }\n    else\n\tst->state = TS_LINEAR;\n\n    if (st->state == TS_BINARY && st->orgpat->regmatch.rm_ic && !*sortic)\n    {\n\t// Binary search won't work for ignoring case, use linear\n\t// search.\n\tst->linear = TRUE;\n\tst->state = TS_LINEAR;\n    }\n\n    // When starting a binary search, get the size of the file and\n    // compute the first offset.\n    if (st->state == TS_BINARY)\n    {\n\tif (vim_fseek(st->fp, 0L, SEEK_END) != 0)\n\t    // can't seek, don't use binary search\n\t    st->state = TS_LINEAR;\n\telse\n\t{\n\t    // Get the tag file size (don't use mch_fstat(), it's\n\t    // not portable).  Don't use lseek(), it doesn't work\n\t    // properly on MacOS Catalina.\n\t    filesize = vim_ftell(st->fp);\n\t    vim_ignored = vim_fseek(st->fp, 0L, SEEK_SET);\n\n\t    // Calculate the first read offset in the file.  Start\n\t    // the search in the middle of the file.\n\t    sinfo_p->low_offset = 0;\n\t    sinfo_p->low_char = 0;\n\t    sinfo_p->high_offset = filesize;\n\t    sinfo_p->curr_offset = 0;\n\t    sinfo_p->high_char = 0xff;\n\t}\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Parse a tag line read from a tags file.\n * Returns OK if a tags line is successfully parsed.\n * Returns FAIL if a format error is encountered.\n */\n    static int\nfindtags_parse_line(\n    findtags_state_T\t\t*st,\n    tagptrs_T\t\t\t*tagpp,\n    findtags_match_args_T\t*margs,\n    tagsearch_info_T\t\t*sinfo_p)\n{\n    int\t\tstatus;\n    int\t\ti;\n    int\t\tcmplen;\n    int\t\ttagcmp;\n\n    // Figure out where the different strings are in this line.\n    // For \"normal\" tags: Do a quick check if the tag matches.\n    // This speeds up tag searching a lot!\n    if (st->orgpat->headlen\n#ifdef FEAT_EMACS_TAGS\n\t    && !st->is_etag\n#endif\n       )\n    {\n\tCLEAR_FIELD(*tagpp);\n\ttagpp->tagname = st->lbuf;\n\ttagpp->tagname_end = vim_strchr(st->lbuf, TAB);\n\tif (tagpp->tagname_end == NULL)\n\t    // Corrupted tag line.\n\t    return TAG_MATCH_FAIL;\n\n\t// Skip this line if the length of the tag is different and\n\t// there is no regexp, or the tag is too short.\n\tcmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tif (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\t    cmplen = p_tl;\n\tif ((st->flags & TAG_REGEXP) && st->orgpat->headlen < cmplen)\n\t    cmplen = st->orgpat->headlen;\n\telse if (st->state == TS_LINEAR && st->orgpat->headlen != cmplen)\n\t    return TAG_MATCH_NEXT;\n\n\tif (st->state == TS_BINARY)\n\t{\n\t    // Simplistic check for unsorted tags file.\n\t    i = (int)tagpp->tagname[0];\n\t    if (margs->sortic)\n\t\ti = (int)TOUPPER_ASC(tagpp->tagname[0]);\n\t    if (i < sinfo_p->low_char || i > sinfo_p->high_char)\n\t\tmargs->sort_error = TRUE;\n\n\t    // Compare the current tag with the searched tag.\n\t    if (margs->sortic)\n\t\ttagcmp = tag_strnicmp(tagpp->tagname, st->orgpat->head,\n\t\t\t\t\t\t\t(size_t)cmplen);\n\t    else\n\t\ttagcmp = STRNCMP(tagpp->tagname, st->orgpat->head, cmplen);\n\n\t    // A match with a shorter tag means to search forward.\n\t    // A match with a longer tag means to search backward.\n\t    if (tagcmp == 0)\n\t    {\n\t\tif (cmplen < st->orgpat->headlen)\n\t\t    tagcmp = -1;\n\t\telse if (cmplen > st->orgpat->headlen)\n\t\t    tagcmp = 1;\n\t    }\n\n\t    if (tagcmp == 0)\n\t    {\n\t\t// We've located the tag, now skip back and search\n\t\t// forward until the first matching tag is found.\n\t\tst->state = TS_SKIP_BACK;\n\t\tsinfo_p->match_offset = sinfo_p->curr_offset;\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\t    if (tagcmp < 0)\n\t    {\n\t\tsinfo_p->curr_offset = vim_ftell(st->fp);\n\t\tif (sinfo_p->curr_offset < sinfo_p->high_offset)\n\t\t{\n\t\t    sinfo_p->low_offset = sinfo_p->curr_offset;\n\t\t    if (margs->sortic)\n\t\t\tsinfo_p->low_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\t    else\n\t\t\tsinfo_p->low_char = tagpp->tagname[0];\n\t\t    return TAG_MATCH_NEXT;\n\t\t}\n\t    }\n\t    if (tagcmp > 0 && sinfo_p->curr_offset != sinfo_p->high_offset)\n\t    {\n\t\tsinfo_p->high_offset = sinfo_p->curr_offset;\n\t\tif (margs->sortic)\n\t\t    sinfo_p->high_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\telse\n\t\t    sinfo_p->high_char = tagpp->tagname[0];\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\n\t    // No match yet and are at the end of the binary search.\n\t    return TAG_MATCH_STOP;\n\t}\n\telse if (st->state == TS_SKIP_BACK)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\tst->state = TS_STEP_FORWARD;\n\t    else\n\t\t// Have to skip back more.  Restore the curr_offset\n\t\t// used, otherwise we get stuck at a long line.\n\t\tsinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAG_MATCH_NEXT;\n\t}\n\telse if (st->state == TS_STEP_FORWARD)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t    {\n\t\tif ((off_T)vim_ftell(st->fp) > sinfo_p->match_offset)\n\t\t    return TAG_MATCH_STOP;\t// past last match\n\t\telse\n\t\t    return TAG_MATCH_NEXT;\t// before first match\n\t    }\n\t}\n\telse\n\t    // skip this match if it can't match\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\treturn TAG_MATCH_NEXT;\n\n\t// Can be a matching tag, isolate the file name and command.\n\ttagpp->fname = tagpp->tagname_end + 1;\n\ttagpp->fname_end = vim_strchr(tagpp->fname, TAB);\n\tif (tagpp->fname_end == NULL)\n\t    status = FAIL;\n\telse\n\t{\n\t    tagpp->command = tagpp->fname_end + 1;\n\t    status = OK;\n\t}\n    }\n    else\n\tstatus = parse_tag_line(st->lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp);\n\n    if (status == FAIL)\n\treturn TAG_MATCH_FAIL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (st->is_etag)\n\ttagpp->fname = st->ebuf;\n#endif\n\n    return TAG_MATCH_SUCCESS;\n}\n\n/*\n * Initialize the structure used for tag matching.\n */\n    static void\nfindtags_matchargs_init(findtags_match_args_T *margs, int flags)\n{\n    margs->matchoff = 0;\t\t\t// match offset\n    margs->match_re = FALSE;\t\t\t// match with regexp\n    margs->match_no_ic = FALSE;\t\t\t// matches with case\n    margs->has_re = (flags & TAG_REGEXP);\t// regexp used\n    margs->sortic = FALSE;\t\t\t// tag file sorted in nocase\n    margs->sort_error = FALSE;\t\t\t// tags file not sorted\n}\n\n/*\n * Compares the tag name in 'tagpp->tagname' with a search pattern in\n * 'st->orgpat.head'.\n * Returns TAG_MATCH_SUCCESS if the tag matches, TAG_MATCH_FAIL if the tag\n * doesn't match, TAG_MATCH_NEXT to look for the next matching tag (used in a\n * binary search) and TAG_MATCH_STOP if all the tags are processed without a\n * match. Uses the values in 'margs' for doing the comparison.\n */\n    static tagmatch_status_T\nfindtags_match_tag(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T *margs)\n{\n    int\t\tmatch = FALSE;\n    int\t\tcmplen;\n\n    // First try matching with the pattern literally (also when it is\n    // a regexp).\n    cmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n    if (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\tcmplen = p_tl;\n    // if tag length does not match, don't try comparing\n    if (st->orgpat->len != cmplen)\n\tmatch = FALSE;\n    else\n    {\n\tif (st->orgpat->regmatch.rm_ic)\n\t{\n\t    match =\n\t\t(MB_STRNICMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t    if (match)\n\t\tmargs->match_no_ic =\n\t\t    (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t}\n\telse\n\t    match = (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n    }\n\n    // Has a regexp: Also find tags matching regexp.\n    margs->match_re = FALSE;\n    if (!match && st->orgpat->regmatch.regprog != NULL)\n    {\n\tint\tcc;\n\n\tcc = *tagpp->tagname_end;\n\t*tagpp->tagname_end = NUL;\n\tmatch = vim_regexec(&st->orgpat->regmatch, tagpp->tagname, (colnr_T)0);\n\tif (match)\n\t{\n\t    margs->matchoff = (int)(st->orgpat->regmatch.startp[0] -\n\t\t\t\t\t\t\ttagpp->tagname);\n\t    if (st->orgpat->regmatch.rm_ic)\n\t    {\n\t\tst->orgpat->regmatch.rm_ic = FALSE;\n\t\tmargs->match_no_ic = vim_regexec(&st->orgpat->regmatch,\n\t\t\ttagpp->tagname, (colnr_T)0);\n\t\tst->orgpat->regmatch.rm_ic = TRUE;\n\t    }\n\t}\n\t*tagpp->tagname_end = cc;\n\tmargs->match_re = TRUE;\n    }\n\n    return match ? TAG_MATCH_SUCCESS : TAG_MATCH_FAIL;\n}\n\n/*\n * Convert the encoding of a line read from a tags file in 'st->lbuf'.\n * Converting the pattern from 'enc' to the tags file encoding doesn't work,\n * because characters are not recognized. The converted line is saved in\n * st->lbuf.\n */\n    static void\nfindtags_string_convert(findtags_state_T *st)\n{\n    char_u\t*conv_line;\n    int\t\tlen;\n\n    conv_line = string_convert(&st->vimconv, st->lbuf, NULL);\n    if (conv_line == NULL)\n\treturn;\n\n    // Copy or swap lbuf and conv_line.\n    len = (int)STRLEN(conv_line) + 1;\n    if (len > st->lbuf_size)\n    {\n\tvim_free(st->lbuf);\n\tst->lbuf = conv_line;\n\tst->lbuf_size = len;\n    }\n    else\n    {\n\tSTRCPY(st->lbuf, conv_line);\n\tvim_free(conv_line);\n    }\n}\n\n/*\n * Add a matching tag found in a tags file to st->ht_match and st->ga_match.\n * Returns OK if successfully added the match and FAIL on memory allocation\n * failure.\n */\n    static int\nfindtags_add_match(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T   *margs,\n    char_u\t\t*buf_ffname,\n    hash_T\t\t*hash)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    int\t\tmtt;\n    int\t\tlen = 0;\n    int\t\tis_current;\t\t// file name matches\n    int\t\tis_static;\t\t// current tag line is static\n    char_u\t*mfp;\n    char_u\t*p;\n    char_u\t*s;\n\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n    {\n\t// Don't change the ordering, always use the same table.\n\tmtt = MT_GL_OTH;\n    }\n    else\n#endif\n    {\n\t// Decide in which array to store this match.\n\tis_current = test_for_current(\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp->fname, tagpp->fname_end, st->tag_fname, buf_ffname);\n#ifdef FEAT_EMACS_TAGS\n\tis_static = FALSE;\n\tif (!st->is_etag)\t// emacs tags are never static\n#endif\n\t    is_static = test_for_static(tagpp);\n\n\t// decide in which of the sixteen tables to store this\n\t// match\n\tif (is_static)\n\t{\n\t    if (is_current)\n\t\tmtt = MT_ST_CUR;\n\t    else\n\t\tmtt = MT_ST_OTH;\n\t}\n\telse\n\t{\n\t    if (is_current)\n\t\tmtt = MT_GL_CUR;\n\t    else\n\t\tmtt = MT_GL_OTH;\n\t}\n\tif (st->orgpat->regmatch.rm_ic && !margs->match_no_ic)\n\t    mtt += MT_IC_OFF;\n\tif (margs->match_re)\n\t    mtt += MT_RE_OFF;\n    }\n\n    // Add the found match in ht_match[mtt] and ga_match[mtt].\n    // Store the info we need later, which depends on the kind of\n    // tags we are dealing with.\n    if (st->help_only)\n    {\n#ifdef FEAT_MULTI_LANG\n# define ML_EXTRA 3\n#else\n# define ML_EXTRA 0\n#endif\n\t// Append the help-heuristic number after the tagname, for\n\t// sorting it later.  The heuristic is ignored for\n\t// detecting duplicates.\n\t// The format is {tagname}@{lang}NUL{heuristic}NUL\n\t*tagpp->tagname_end = NUL;\n\tlen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tmfp = alloc(sizeof(char_u) + len + 10 + ML_EXTRA + 1);\n\tif (mfp != NULL)\n\t{\n\t    int heuristic;\n\n\t    p = mfp;\n\t    STRCPY(p, tagpp->tagname);\n#ifdef FEAT_MULTI_LANG\n\t    p[len] = '@';\n\t    STRCPY(p + len + 1, st->help_lang);\n#endif\n\n\t    heuristic = help_heuristic(tagpp->tagname,\n\t\t\t\tmargs->match_re ? margs->matchoff : 0,\n\t\t\t\t!margs->match_no_ic);\n#ifdef FEAT_MULTI_LANG\n\t    heuristic += st->help_pri;\n#endif\n\t    sprintf((char *)p + len + 1 + ML_EXTRA, \"%06d\",\n\t\t    heuristic);\n\t}\n\t*tagpp->tagname_end = TAB;\n    }\n    else if (name_only)\n    {\n\tif (st->get_searchpat)\n\t{\n\t    char_u *temp_end = tagpp->command;\n\n\t    if (*temp_end == '/')\n\t\twhile (*temp_end && *temp_end != '\\r'\n\t\t\t&& *temp_end != '\\n'\n\t\t\t&& *temp_end != '$')\n\t\t    temp_end++;\n\n\t    if (tagpp->command + 2 < temp_end)\n\t    {\n\t\tlen = (int)(temp_end - tagpp->command - 2);\n\t\tmfp = alloc(len + 2);\n\t\tif (mfp != NULL)\n\t\t    vim_strncpy(mfp, tagpp->command + 2, len);\n\t    }\n\t    else\n\t\tmfp = NULL;\n\t    st->get_searchpat = FALSE;\n\t}\n\telse\n\t{\n\t    len = (int)(tagpp->tagname_end - tagpp->tagname);\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\t    if (mfp != NULL)\n\t\tvim_strncpy(mfp, tagpp->tagname, len);\n\n\t    // if wanted, re-read line to get long form too\n\t    if (State & MODE_INSERT)\n\t\tst->get_searchpat = p_sft;\n\t}\n    }\n    else\n    {\n\tsize_t tag_fname_len = STRLEN(st->tag_fname);\n#ifdef FEAT_EMACS_TAGS\n\tsize_t ebuf_len = 0;\n#endif\n\n\t// Save the tag in a buffer.\n\t// Use 0x02 to separate fields (Can't use NUL because the\n\t// hash key is terminated by NUL, or Ctrl_A because that is\n\t// part of some Emacs tag files -- see parse_tag_line).\n\t// Emacs tag: <mtt><tag_fname><0x02><ebuf><0x02><lbuf><NUL>\n\t// other tag: <mtt><tag_fname><0x02><0x02><lbuf><NUL>\n\t// without Emacs tags: <mtt><tag_fname><0x02><lbuf><NUL>\n\t// Here <mtt> is the \"mtt\" value plus 1 to avoid NUL.\n\tlen = (int)tag_fname_len + (int)STRLEN(st->lbuf) + 3;\n#ifdef FEAT_EMACS_TAGS\n\tif (st->is_etag)\n\t{\n\t    ebuf_len = STRLEN(st->ebuf);\n\t    len += (int)ebuf_len + 1;\n\t}\n\telse\n\t    ++len;\n#endif\n\tmfp = alloc(sizeof(char_u) + len + 1);\n\tif (mfp != NULL)\n\t{\n\t    p = mfp;\n\t    p[0] = mtt + 1;\n\t    STRCPY(p + 1, st->tag_fname);\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Ignore differences in slashes, avoid adding\n\t    // both path/file and path\\file.\n\t    slash_adjust(p + 1);\n#endif\n\t    p[tag_fname_len + 1] = TAG_SEP;\n\t    s = p + 1 + tag_fname_len + 1;\n#ifdef FEAT_EMACS_TAGS\n\t    if (st->is_etag)\n\t    {\n\t\tSTRCPY(s, st->ebuf);\n\t\ts[ebuf_len] = TAG_SEP;\n\t\ts += ebuf_len + 1;\n\t    }\n\t    else\n\t\t*s++ = TAG_SEP;\n#endif\n\t    STRCPY(s, st->lbuf);\n\t}\n    }\n\n    if (mfp != NULL)\n    {\n\thashitem_T\t*hi;\n\n\t// Don't add identical matches.\n\t// Add all cscope tags, because they are all listed.\n\t// \"mfp\" is used as a hash key, there is a NUL byte to end\n\t// the part that matters for comparing, more bytes may\n\t// follow after it.  E.g. help tags store the priority\n\t// after the NUL.\n#ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    ++*hash;\n\telse\n#endif\n\t    *hash = hash_hash(mfp);\n\thi = hash_lookup(&st->ht_match[mtt], mfp, *hash);\n\tif (HASHITEM_EMPTY(hi))\n\t{\n\t    if (hash_add_item(&st->ht_match[mtt], hi, mfp, *hash) == FAIL\n\t\t    || ga_grow(&st->ga_match[mtt], 1) != OK)\n\t    {\n\t\t// Out of memory! Just forget about the rest.\n\t\tst->stop_searching = TRUE;\n\t\treturn FAIL;\n\t    }\n\n\t    ((char_u **)(st->ga_match[mtt].ga_data))\n\t\t[st->ga_match[mtt].ga_len++] = mfp;\n\t    st->match_count++;\n\t}\n\telse\n\t    // duplicate tag, drop it\n\t    vim_free(mfp);\n    }\n\n    return OK;\n}\n\n/*\n * Read and get all the tags from file st->tag_fname.\n * Sets 'st->stop_searching' to TRUE to stop searching for additional tags.\n */\n    static void\nfindtags_get_all_tags(\n    findtags_state_T\t\t*st,\n    findtags_match_args_T\t*margs,\n    char_u\t\t\t*buf_ffname)\n{\n    tagptrs_T\t\ttagp;\n    tagsearch_info_T\tsearch_info;\n    int\t\t\tretval;\n#ifdef FEAT_CSCOPE\n    int\t\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    hash_T\t\thash = 0;\n\n    // This is only to avoid a compiler warning for using search_info\n    // uninitialised.\n    CLEAR_FIELD(search_info);\n\n    // Read and parse the lines in the file one by one\n    for (;;)\n    {\n\t// check for CTRL-C typed, more often when jumping around\n\tif (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n\t    line_breakcheck();\n\telse\n\t    fast_breakcheck();\n\tif ((st->flags & TAG_INS_COMP))\t// Double brackets for gcc\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\t// When mincount is TAG_MANY, stop when enough matches have been\n\t// found (for completion).\n\tif (st->mincount == TAG_MANY && st->match_count >= TAG_MANY)\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\tif (st->get_searchpat)\n\t    goto line_read_in;\n\n\tretval = findtags_get_next_line(st, &search_info);\n\tif (retval == TAGS_READ_IGNORE)\n\t    continue;\n\tif (retval == TAGS_READ_EOF)\n\t    break;\n\nline_read_in:\n\n\tif (st->vimconv.vc_type != CONV_NONE)\n\t    findtags_string_convert(st);\n\n#ifdef FEAT_EMACS_TAGS\n\t// Emacs tags line with CTRL-L: New file name on next line.\n\t// The file name is followed by a ','.\n\t// Remember etag file name in ebuf.\n\tif (*st->lbuf == Ctrl_L\n# ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n# endif\n\t   )\n\t{\n\t    st->is_etag = TRUE;\t\t// in case at the start\n\t    st->state = TS_LINEAR;\n\t    emacs_tags_new_filename(st);\n\t    continue;\n\t}\n#endif\n\n\t// When still at the start of the file, check for Emacs tags file\n\t// format, and for \"not sorted\" flag.\n\tif (st->state == TS_START)\n\t{\n\t    if (findtags_start_state_handler(st, &margs->sortic, &search_info) == FALSE)\n\t\tcontinue;\n\t}\n\n\t// When the line is too long the NUL will not be in the\n\t// last-but-one byte (see vim_fgets()).\n\t// Has been reported for Mozilla JS with extremely long names.\n\t// In that case we need to increase lbuf_size.\n\tif (st->lbuf[st->lbuf_size - 2] != NUL\n#ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n#endif\n\t   )\n\t{\n\t    st->lbuf_size *= 2;\n\t    vim_free(st->lbuf);\n\t    st->lbuf = alloc(st->lbuf_size);\n\t    if (st->lbuf == NULL)\n\t    {\n\t\tif (st->fp != NULL)\n\t\t    fclose(st->fp);\n\t\tst->fp = NULL;\n\t\tst->stop_searching = TRUE;\n\t\treturn;\n\t    }\n\n\t    if (st->state == TS_STEP_FORWARD || st->state == TS_LINEAR)\n\t\t// Seek to the same position to read the same line again\n\t\tvim_ignored = vim_fseek(st->fp, search_info.curr_offset,\n\t\t\t\t\t\t\t\t     SEEK_SET);\n\t    // this will try the same thing again, make sure the offset is\n\t    // different\n\t    search_info.curr_offset = 0;\n\t    continue;\n\t}\n\n\tretval = findtags_parse_line(st, &tagp, margs, &search_info);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\tif (retval == TAG_MATCH_FAIL)\n\t{\n\t    semsg(_(e_format_error_in_tags_file_str), st->tag_fname);\n#ifdef FEAT_CSCOPE\n\t    if (!use_cscope)\n#endif\n\t\tsemsg(_(\"Before byte %ld\"), (long)vim_ftell(st->fp));\n\t    st->stop_searching = TRUE;\n\t    return;\n\t}\n\n\tretval = findtags_match_tag(st, &tagp, margs);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\n\t// If a match is found, add it to ht_match[] and ga_match[].\n\tif (retval == TAG_MATCH_SUCCESS)\n\t{\n\t    if (findtags_add_match(st, &tagp, margs, buf_ffname, &hash)\n\t\t\t\t\t\t\t\t== FAIL)\n\t\tbreak;\n\t}\n    } // forever\n}\n\n/*\n * Search for tags matching 'st->orgpat.pat' in the 'st->tag_fname' tags file.\n * Information needed to search for the tags is in the 'st' state structure.\n * The matching tags are returned in 'st'. If an error is encountered, then\n * 'st->stop_searching' is set to TRUE.\n */\n    static void\nfindtags_in_file(findtags_state_T *st, char_u *buf_ffname)\n{\n    findtags_match_args_T margs;\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n\n    st->vimconv.vc_type = CONV_NONE;\n    st->tag_file_sorted = NUL;\n    st->fp = NULL;\n    findtags_matchargs_init(&margs, st->flags);\n\n    // A file that doesn't exist is silently ignored.  Only when not a\n    // single file is found, an error message is given (further on).\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n\tst->fp = NULL;\t    // avoid GCC warning\n    else\n#endif\n    {\n#ifdef FEAT_MULTI_LANG\n\tif (curbuf->b_help)\n\t{\n\t    if (!findtags_in_help_init(st))\n\t\treturn;\n\t}\n#endif\n\n\tst->fp = mch_fopen((char *)st->tag_fname, \"r\");\n\tif (st->fp == NULL)\n\t    return;\n\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Searching tags file %s\"), st->tag_fname);\n\t    verbose_leave();\n\t}\n    }\n    st->did_open = TRUE;\t// remember that we found at least one file\n\n    st->state = TS_START;\t// we're at the start of the file\n#ifdef FEAT_EMACS_TAGS\n    st->is_etag = FALSE;\t// default is: not emacs style\n#endif\n\n    // Read and parse the lines in the file one by one\n    findtags_get_all_tags(st, &margs, buf_ffname);\n\n    if (st->fp != NULL)\n    {\n\tfclose(st->fp);\n\tst->fp = NULL;\n    }\n#ifdef FEAT_EMACS_TAGS\n    emacs_tags_incstack_free();\n#endif\n    if (st->vimconv.vc_type != CONV_NONE)\n\tconvert_setup(&st->vimconv, NULL, NULL);\n\n    if (margs.sort_error)\n\tsemsg(_(e_tags_file_not_sorted_str), st->tag_fname);\n\n    // Stop searching if sufficient tags have been found.\n    if (st->match_count >= st->mincount)\n\tst->stop_searching = TRUE;\n}\n\n/*\n * Copy the tags found by find_tags() to 'matchesp'.\n * Returns the number of matches copied.\n */\n    static int\nfindtags_copy_matches(findtags_state_T *st, char_u ***matchesp)\n{\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    char_u\t**matches;\n    int\t\tmtt;\n    int\t\ti;\n    char_u\t*mfp;\n    char_u\t*p;\n\n    if (st->match_count > 0)\n\tmatches = ALLOC_MULT(char_u *, st->match_count);\n    else\n\tmatches = NULL;\n    st->match_count = 0;\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tfor (i = 0; i < st->ga_match[mtt].ga_len; ++i)\n\t{\n\t    mfp = ((char_u **)(st->ga_match[mtt].ga_data))[i];\n\t    if (matches == NULL)\n\t\tvim_free(mfp);\n\t    else\n\t    {\n\t\tif (!name_only)\n\t\t{\n\t\t    // Change mtt back to zero-based.\n\t\t    *mfp = *mfp - 1;\n\n\t\t    // change the TAG_SEP back to NUL\n\t\t    for (p = mfp + 1; *p != NUL; ++p)\n\t\t\tif (*p == TAG_SEP)\n\t\t\t    *p = NUL;\n\t\t}\n\t\tmatches[st->match_count++] = mfp;\n\t    }\n\t}\n\n\tga_clear(&st->ga_match[mtt]);\n\thash_clear(&st->ht_match[mtt]);\n    }\n\n    *matchesp = matches;\n    return st->match_count;\n}\n\n/*\n * find_tags() - search for tags in tags files\n *\n * Return FAIL if search completely failed (*num_matches will be 0, *matchesp\n * will be NULL), OK otherwise.\n *\n * Priority depending on which type of tag is recognized:\n *  6.\tA static or global tag with a full matching tag for the current file.\n *  5.\tA global tag with a full matching tag for another file.\n *  4.\tA static tag with a full matching tag for another file.\n *  3.\tA static or global tag with an ignore-case matching tag for the\n *\tcurrent file.\n *  2.\tA global tag with an ignore-case matching tag for another file.\n *  1.\tA static tag with an ignore-case matching tag for another file.\n *\n * Tags in an emacs-style tags file are always global.\n *\n * flags:\n * TAG_HELP\t  only search for help tags\n * TAG_NAMES\t  only return name of tag\n * TAG_REGEXP\t  use \"pat\" as a regexp\n * TAG_NOIC\t  don't always ignore case\n * TAG_KEEP_LANG  keep language\n * TAG_CSCOPE\t  use cscope results for tags\n * TAG_NO_TAGFUNC do not call the 'tagfunc' function\n */\n    int\nfind_tags(\n    char_u\t*pat,\t\t\t// pattern to search for\n    int\t\t*num_matches,\t\t// return: number of matches found\n    char_u\t***matchesp,\t\t// return: array of matches found\n    int\t\tflags,\n    int\t\tmincount,\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    char_u\t*buf_ffname)\t\t// name of buffer for priority\n{\n    findtags_state_T\tst;\n    tagname_T\ttn;\t\t\t// info for get_tagfname()\n    int\t\tfirst_file;\t\t// trying first tag file\n    int\t\tretval = FAIL;\t\t// return value\n    int\t\tround;\n\n    int\t\tsave_emsg_off;\n\n    int\t\thelp_save;\n#ifdef FEAT_MULTI_LANG\n    int\t\ti;\n    char_u\t*saved_pat = NULL;\t\t// copy of pat[]\n#endif\n\n    int\t\tfindall = (mincount == MAXCOL || mincount == TAG_MANY);\n\t\t\t\t\t\t// find all matching tags\n    int\t\thas_re = (flags & TAG_REGEXP);\t// regexp used\n    int\t\tnoic = (flags & TAG_NOIC);\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (flags & TAG_CSCOPE);\n#endif\n    int\t\tverbose = (flags & TAG_VERBOSE);\n    int\t\tsave_p_ic = p_ic;\n\n    /*\n     * Change the value of 'ignorecase' according to 'tagcase' for the\n     * duration of this function.\n     */\n    switch (curbuf->b_tc_flags ? curbuf->b_tc_flags : tc_flags)\n    {\n\tcase TC_FOLLOWIC:\t\t break;\n\tcase TC_IGNORE:    p_ic = TRUE;  break;\n\tcase TC_MATCH:     p_ic = FALSE; break;\n\tcase TC_FOLLOWSCS: p_ic = ignorecase(pat); break;\n\tcase TC_SMART:     p_ic = ignorecase_opt(pat, TRUE, TRUE); break;\n    }\n\n    help_save = curbuf->b_help;\n\n    if (findtags_state_init(&st, pat, flags, mincount) == FAIL)\n\tgoto findtag_end;\n\n#ifdef FEAT_CSCOPE\n    STRCPY(st.tag_fname, \"from cscope\");\t// for error messages\n#endif\n\n    /*\n     * Initialize a few variables\n     */\n    if (st.help_only)\t\t\t\t// want tags from help file\n\tcurbuf->b_help = TRUE;\t\t\t// will be restored later\n#ifdef FEAT_CSCOPE\n    else if (use_cscope)\n    {\n\t// Make sure we don't mix help and cscope, confuses Coverity.\n\tst.help_only = FALSE;\n\tcurbuf->b_help = FALSE;\n    }\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    if (curbuf->b_help)\n    {\n\t// When \"@ab\" is specified use only the \"ab\" language, otherwise\n\t// search all languages.\n\tif (st.orgpat->len > 3 && pat[st.orgpat->len - 3] == '@'\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 2])\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 1]))\n\t{\n\t    saved_pat = vim_strnsave(pat, st.orgpat->len - 3);\n\t    if (saved_pat != NULL)\n\t    {\n\t\tst.help_lang_find = &pat[st.orgpat->len - 2];\n\t\tst.orgpat->pat = saved_pat;\n\t\tst.orgpat->len -= 3;\n\t    }\n\t}\n    }\n#endif\n    if (p_tl != 0 && st.orgpat->len > p_tl)\t// adjust for 'taglength'\n\tst.orgpat->len = p_tl;\n\n    save_emsg_off = emsg_off;\n    emsg_off = TRUE;  // don't want error for invalid RE here\n    prepare_pats(st.orgpat, has_re);\n    emsg_off = save_emsg_off;\n    if (has_re && st.orgpat->regmatch.regprog == NULL)\n\tgoto findtag_end;\n\n#ifdef FEAT_EVAL\n    retval = findtags_apply_tfu(&st, pat, buf_ffname);\n    if (retval != NOTDONE)\n\tgoto findtag_end;\n\n    // re-initialize the default return value\n    retval = FAIL;\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    // Set a flag if the file extension is .txt\n    if ((flags & TAG_KEEP_LANG)\n\t    && st.help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && STRICMP(curbuf->b_fname + i - 4, \".txt\") == 0)\n\tst.is_txt = TRUE;\n#endif\n\n    /*\n     * When finding a specified number of matches, first try with matching\n     * case, so binary search can be used, and try ignore-case matches in a\n     * second loop.\n     * When finding all matches, 'tagbsearch' is off, or there is no fixed\n     * string to look for, ignore case right away to avoid going though the\n     * tags files twice.\n     * When the tag file is case-fold sorted, it is either one or the other.\n     * Only ignore case when TAG_NOIC not used or 'ignorecase' set.\n     */\n    st.orgpat->regmatch.rm_ic = ((p_ic || !noic)\n\t\t\t&& (findall || st.orgpat->headlen == 0 || !p_tbs));\n    for (round = 1; round <= 2; ++round)\n    {\n\tst.linear = (st.orgpat->headlen == 0 || !p_tbs || round == 2);\n\n      /*\n       * Try tag file names from tags option one by one.\n       */\n      for (first_file = TRUE;\n#ifdef FEAT_CSCOPE\n\t    use_cscope ||\n#endif\n\t\tget_tagfname(&tn, first_file, st.tag_fname) == OK;\n\t\t\t\t\t\t\t   first_file = FALSE)\n      {\n\t  findtags_in_file(&st, buf_ffname);\n\t  if (st.stop_searching\n#ifdef FEAT_CSCOPE\n\t\t  || use_cscope\n#endif\n\t     )\n\t  {\n\t      retval = OK;\n\t      break;\n\t  }\n      } // end of for-each-file loop\n\n#ifdef FEAT_CSCOPE\n\tif (!use_cscope)\n#endif\n\t    tagname_free(&tn);\n\n\t// stop searching when already did a linear search, or when TAG_NOIC\n\t// used, and 'ignorecase' not set or already did case-ignore search\n\tif (st.stop_searching || st.linear || (!p_ic && noic) ||\n\t\t\t\t\t\tst.orgpat->regmatch.rm_ic)\n\t    break;\n# ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    break;\n# endif\n\n\t// try another time while ignoring case\n\tst.orgpat->regmatch.rm_ic = TRUE;\n    }\n\n    if (!st.stop_searching)\n    {\n\tif (!st.did_open && verbose)\t// never opened any tags file\n\t    emsg(_(e_no_tags_file));\n\tretval = OK;\t\t// It's OK even when no tag found\n    }\n\nfindtag_end:\n    findtags_state_free(&st);\n\n    /*\n     * Move the matches from the ga_match[] arrays into one list of\n     * matches.  When retval == FAIL, free the matches.\n     */\n    if (retval == FAIL)\n\tst.match_count = 0;\n\n    *num_matches = findtags_copy_matches(&st, matchesp);\n\n    curbuf->b_help = help_save;\n#ifdef FEAT_MULTI_LANG\n    vim_free(saved_pat);\n#endif\n\n    p_ic = save_p_ic;\n\n    return retval;\n}\n\nstatic garray_T tag_fnames = GA_EMPTY;\n\n/*\n * Callback function for finding all \"tags\" and \"tags-??\" files in\n * 'runtimepath' doc directories.\n */\n    static void\nfound_tagfile_cb(char_u *fname, void *cookie UNUSED)\n{\n    if (ga_grow(&tag_fnames, 1) == OK)\n    {\n\tchar_u\t*tag_fname = vim_strsave(fname);\n\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(tag_fname);\n#endif\n\tsimplify_filename(tag_fname);\n\t((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] = tag_fname;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tag_stuff(void)\n{\n    ga_clear_strings(&tag_fnames);\n    if (curwin != NULL)\n\tdo_tag(NULL, DT_FREE, 0, 0, 0);\n    tag_freematch();\n\n# if defined(FEAT_QUICKFIX)\n    tagstack_clear_entry(&ptag_entry);\n# endif\n}\n#endif\n\n/*\n * Get the next name of a tag file from the tag file list.\n * For help files, use \"tags\" file only.\n *\n * Return FAIL if no more tag file names, OK otherwise.\n */\n    int\nget_tagfname(\n    tagname_T\t*tnp,\t// holds status info\n    int\t\tfirst,\t// TRUE when first file name is wanted\n    char_u\t*buf)\t// pointer to buffer of MAXPATHL chars\n{\n    char_u\t\t*fname = NULL;\n    char_u\t\t*r_ptr;\n    int\t\t\ti;\n\n    if (first)\n\tCLEAR_POINTER(tnp);\n\n    if (curbuf->b_help)\n    {\n\t/*\n\t * For help files it's done in a completely different way:\n\t * Find \"doc/tags\" and \"doc/tags-??\" in all directories in\n\t * 'runtimepath'.\n\t */\n\tif (first)\n\t{\n\t    ga_clear_strings(&tag_fnames);\n\t    ga_init2(&tag_fnames, sizeof(char_u *), 10);\n\t    do_in_runtimepath((char_u *)\n#ifdef FEAT_MULTI_LANG\n# ifdef VMS\n\t\t    // Functions decc$to_vms() and decc$translate_vms() crash\n\t\t    // on some VMS systems with wildcards \"??\".  Seems ECO\n\t\t    // patches do fix the problem in C RTL, but we can't use\n\t\t    // an #ifdef for that.\n\t\t    \"doc/tags doc/tags-*\"\n# else\n\t\t    \"doc/tags doc/tags-??\"\n# endif\n#else\n\t\t    \"doc/tags\"\n#endif\n\t\t\t\t\t   , DIP_ALL, found_tagfile_cb, NULL);\n\t}\n\n\tif (tnp->tn_hf_idx >= tag_fnames.ga_len)\n\t{\n\t    // Not found in 'runtimepath', use 'helpfile', if it exists and\n\t    // wasn't used yet, replacing \"help.txt\" with \"tags\".\n\t    if (tnp->tn_hf_idx > tag_fnames.ga_len || *p_hf == NUL)\n\t\treturn FAIL;\n\t    ++tnp->tn_hf_idx;\n\t    STRCPY(buf, p_hf);\n\t    STRCPY(gettail(buf), \"tags\");\n#ifdef BACKSLASH_IN_FILENAME\n\t    slash_adjust(buf);\n#endif\n\t    simplify_filename(buf);\n\n\t    for (i = 0; i < tag_fnames.ga_len; ++i)\n\t\tif (STRCMP(buf, ((char_u **)(tag_fnames.ga_data))[i]) == 0)\n\t\t    return FAIL; // avoid duplicate file names\n\t}\n\telse\n\t    vim_strncpy(buf, ((char_u **)(tag_fnames.ga_data))[\n\t\t\t\t\t     tnp->tn_hf_idx++], MAXPATHL - 1);\n\treturn OK;\n    }\n\n    if (first)\n    {\n\t// Init.  We make a copy of 'tags', because autocommands may change\n\t// the value without notifying us.\n\ttnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)\n\t\t\t\t\t\t ? curbuf->b_p_tags : p_tags);\n\tif (tnp->tn_tags == NULL)\n\t    return FAIL;\n\ttnp->tn_np = tnp->tn_tags;\n    }\n\n    /*\n     * Loop until we have found a file name that can be used.\n     * There are two states:\n     * tnp->tn_did_filefind_init == FALSE: setup for next part in 'tags'.\n     * tnp->tn_did_filefind_init == TRUE: find next file in this part.\n     */\n    for (;;)\n    {\n\tif (tnp->tn_did_filefind_init)\n\t{\n\t    fname = vim_findfile(tnp->tn_search_ctx);\n\t    if (fname != NULL)\n\t\tbreak;\n\n\t    tnp->tn_did_filefind_init = FALSE;\n\t}\n\telse\n\t{\n\t    char_u  *filename = NULL;\n\n\t    // Stop when used all parts of 'tags'.\n\t    if (*tnp->tn_np == NUL)\n\t    {\n\t\tvim_findfile_cleanup(tnp->tn_search_ctx);\n\t\ttnp->tn_search_ctx = NULL;\n\t\treturn FAIL;\n\t    }\n\n\t    /*\n\t     * Copy next file name into buf.\n\t     */\n\t    buf[0] = NUL;\n\t    (void)copy_option_part(&tnp->tn_np, buf, MAXPATHL - 1, \" ,\");\n\n#ifdef FEAT_PATH_EXTRA\n\t    r_ptr = vim_findfile_stopdir(buf);\n#else\n\t    r_ptr = NULL;\n#endif\n\t    // move the filename one char forward and truncate the\n\t    // filepath with a NUL\n\t    filename = gettail(buf);\n\t    STRMOVE(filename + 1, filename);\n\t    *filename++ = NUL;\n\n\t    tnp->tn_search_ctx = vim_findfile_init(buf, filename,\n\t\t    r_ptr, 100,\n\t\t    FALSE,\t   // don't free visited list\n\t\t    FINDFILE_FILE, // we search for a file\n\t\t    tnp->tn_search_ctx, TRUE, curbuf->b_ffname);\n\t    if (tnp->tn_search_ctx != NULL)\n\t\ttnp->tn_did_filefind_init = TRUE;\n\t}\n    }\n\n    STRCPY(buf, fname);\n    vim_free(fname);\n    return OK;\n}\n\n/*\n * Free the contents of a tagname_T that was filled by get_tagfname().\n */\n    void\ntagname_free(tagname_T *tnp)\n{\n    vim_free(tnp->tn_tags);\n    vim_findfile_cleanup(tnp->tn_search_ctx);\n    tnp->tn_search_ctx = NULL;\n    ga_clear_strings(&tag_fnames);\n}\n\n/*\n * Parse one line from the tags file. Find start/end of tag name, start/end of\n * file name and start of search pattern.\n *\n * If is_etag is TRUE, tagp->fname and tagp->fname_end are not set.\n *\n * Return FAIL if there is a format error in this line, OK otherwise.\n */\n    static int\nparse_tag_line(\n    char_u\t*lbuf,\t\t// line to be parsed\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag,\n#endif\n    tagptrs_T\t*tagp)\n{\n    char_u\t*p;\n\n#ifdef FEAT_EMACS_TAGS\n    if (is_etag)\n\t// emacs-style tag file\n\treturn emacs_tags_parse_line(lbuf, tagp);\n#endif\n\n    // Isolate the tagname, from lbuf up to the first white\n    tagp->tagname = lbuf;\n    p = vim_strchr(lbuf, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->tagname_end = p;\n\n    // Isolate file name, from first to second white space\n    if (*p != NUL)\n\t++p;\n    tagp->fname = p;\n    p = vim_strchr(p, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->fname_end = p;\n\n    // find start of search command, after second white space\n    if (*p != NUL)\n\t++p;\n    if (*p == NUL)\n\treturn FAIL;\n    tagp->command = p;\n\n    return OK;\n}\n\n/*\n * Check if tagname is a static tag\n *\n * Static tags produced by the older ctags program have the format:\n *\t'file:tag  file  /pattern'.\n * This is only recognized when both occurrence of 'file' are the same, to\n * avoid recognizing \"string::string\" or \":exit\".\n *\n * Static tags produced by the new ctags program have the format:\n *\t'tag  file  /pattern/;\"<Tab>file:'\t    \"\n *\n * Return TRUE if it is a static tag and adjust *tagname to the real tag.\n * Return FALSE if it is not a static tag.\n */\n    static int\ntest_for_static(tagptrs_T *tagp)\n{\n    char_u\t*p;\n\n    /*\n     * Check for new style static tag \":...<Tab>file:[<Tab>...]\"\n     */\n    p = tagp->command;\n    while ((p = vim_strchr(p, '\\t')) != NULL)\n    {\n\t++p;\n\tif (STRNCMP(p, \"file:\", 5) == 0)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Returns the length of a matching tag line.\n */\n    static size_t\nmatching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n\n    // does the same thing as parse_match()\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}\n\n/*\n * Parse a line from a matching tag.  Does not change the line itself.\n *\n * The line that we get looks like this:\n * Emacs tag: <mtt><tag_fname><NUL><ebuf><NUL><lbuf>\n * other tag: <mtt><tag_fname><NUL><NUL><lbuf>\n * without Emacs tags: <mtt><tag_fname><NUL><lbuf>\n *\n * Return OK or FAIL.\n */\n    static int\nparse_match(\n    char_u\t*lbuf,\t    // input: matching line\n    tagptrs_T\t*tagp)\t    // output: pointers into the line\n{\n    int\t\tretval;\n    char_u\t*p;\n    char_u\t*pc, *pt;\n\n    tagp->tag_fname = lbuf + 1;\n    lbuf += STRLEN(tagp->tag_fname) + 2;\n#ifdef FEAT_EMACS_TAGS\n    if (*lbuf)\n    {\n\ttagp->is_etag = TRUE;\n\ttagp->fname = lbuf;\n\tlbuf += STRLEN(lbuf);\n\ttagp->fname_end = lbuf++;\n    }\n    else\n    {\n\ttagp->is_etag = FALSE;\n\t++lbuf;\n    }\n#endif\n\n    // Find search pattern and the file name for non-etags.\n    retval = parse_tag_line(lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\t\ttagp->is_etag,\n#endif\n\t\t\ttagp);\n\n    tagp->tagkind = NULL;\n    tagp->user_data = NULL;\n    tagp->tagline = 0;\n    tagp->command_end = NULL;\n\n    if (retval == OK)\n    {\n\t// Try to find a kind field: \"kind:<kind>\" or just \"<kind>\"\n\tp = tagp->command;\n\tif (find_extra(&p) == OK)\n\t{\n\t    if (p > tagp->command && p[-1] == '|')\n\t\ttagp->command_end = p - 1;  // drop trailing bar\n\t    else\n\t\ttagp->command_end = p;\n\t    p += 2;\t// skip \";\\\"\"\n\t    if (*p++ == TAB)\n\t\t// Accept ASCII alphabetic kind characters and any multi-byte\n\t\t// character.\n\t\twhile (ASCII_ISALPHA(*p) || mb_ptr2len(p) > 1)\n\t\t{\n\t\t    if (STRNCMP(p, \"kind:\", 5) == 0)\n\t\t\ttagp->tagkind = p + 5;\n\t\t    else if (STRNCMP(p, \"user_data:\", 10) == 0)\n\t\t\ttagp->user_data = p + 10;\n\t\t    else if (STRNCMP(p, \"line:\", 5) == 0)\n\t\t\ttagp->tagline = atoi((char *)p + 5);\n\t\t    if (tagp->tagkind != NULL && tagp->user_data != NULL)\n\t\t\tbreak;\n\t\t    pc = vim_strchr(p, ':');\n\t\t    pt = vim_strchr(p, '\\t');\n\t\t    if (pc == NULL || (pt != NULL && pc > pt))\n\t\t\ttagp->tagkind = p;\n\t\t    if (pt == NULL)\n\t\t\tbreak;\n\t\t    p = pt;\n\t\t    MB_PTR_ADV(p);\n\t\t}\n\t}\n\tif (tagp->tagkind != NULL)\n\t{\n\t    for (p = tagp->tagkind;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->tagkind_end = p;\n\t}\n\tif (tagp->user_data != NULL)\n\t{\n\t    for (p = tagp->user_data;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->user_data_end = p;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Find out the actual file name of a tag.  Concatenate the tags file name\n * with the matching tag file name.\n * Returns an allocated string or NULL (out of memory).\n */\n    static char_u *\ntag_full_fname(tagptrs_T *tagp)\n{\n    char_u\t*fullname;\n    int\t\tc;\n\n#ifdef FEAT_EMACS_TAGS\n    if (tagp->is_etag)\n\tc = 0;\t    // to shut up GCC\n    else\n#endif\n    {\n\tc = *tagp->fname_end;\n\t*tagp->fname_end = NUL;\n    }\n    fullname = expand_tag_fname(tagp->fname, tagp->tag_fname, FALSE);\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp->is_etag)\n#endif\n\t*tagp->fname_end = c;\n\n    return fullname;\n}\n\n/*\n * Jump to a tag that has been found in one of the tag files\n *\n * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.\n */\n    static int\njumpto_tag(\n    char_u\t*lbuf_arg,\t// line from the tags file for this tag\n    int\t\tforceit,\t// :ta with !\n    int\t\tkeep_help)\t// keep help flag (FALSE for cscope)\n{\n    optmagic_T\tsave_magic_overruled;\n    int\t\tsave_p_ws, save_p_scs, save_p_ic;\n    linenr_T\tsave_lnum;\n    char_u\t*str;\n    char_u\t*pbuf;\t\t\t// search pattern buffer\n    char_u\t*pbuf_end;\n    char_u\t*tofree_fname = NULL;\n    char_u\t*fname;\n    tagptrs_T\ttagp;\n    int\t\tretval = FAIL;\n    int\t\tgetfile_result = GETFILE_UNUSED;\n    int\t\tsearch_options;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tsave_no_hlsearch;\n#endif\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n    char_u\t*full_fname = NULL;\n#ifdef FEAT_FOLDING\n    int\t\told_KeyTyped = KeyTyped;    // getting the file may reset it\n#endif\n    size_t\tlen;\n    char_u\t*lbuf;\n\n    // Make a copy of the line, it can become invalid when an autocommand calls\n    // back here recursively.\n    len = matching_line_len(lbuf_arg) + 1;\n    lbuf = alloc(len);\n    if (lbuf != NULL)\n\tmch_memmove(lbuf, lbuf_arg, len);\n\n    pbuf = alloc(LSIZE);\n\n    // parse the match line into the tagp structure\n    if (pbuf == NULL || lbuf == NULL || parse_match(lbuf, &tagp) == FAIL)\n    {\n\ttagp.fname_end = NULL;\n\tgoto erret;\n    }\n\n    // truncate the file name, so it can be used as a string\n    *tagp.fname_end = NUL;\n    fname = tagp.fname;\n\n    // copy the command to pbuf[], remove trailing CR/NL\n    str = tagp.command;\n    for (pbuf_end = pbuf; *str && *str != '\\n' && *str != '\\r'; )\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (tagp.is_etag && *str == ',')// stop at ',' after line number\n\t    break;\n#endif\n\t*pbuf_end++ = *str++;\n\tif (pbuf_end - pbuf + 1 >= LSIZE)\n\t    break;\n    }\n    *pbuf_end = NUL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp.is_etag)\n#endif\n    {\n\t/*\n\t * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here.\n\t */\n\tstr = pbuf;\n\tif (find_extra(&str) == OK)\n\t{\n\t    pbuf_end = str;\n\t    *pbuf_end = NUL;\n\t}\n    }\n\n    /*\n     * Expand file name, when needed (for environment variables).\n     * If 'tagrelative' option set, may change file name.\n     */\n    fname = expand_tag_fname(fname, tagp.tag_fname, TRUE);\n    if (fname == NULL)\n\tgoto erret;\n    tofree_fname = fname;\t// free() it later\n\n    /*\n     * Check if the file with the tag exists before abandoning the current\n     * file.  Also accept a file name for which there is a matching BufReadCmd\n     * autocommand event (e.g., http://sys/file).\n     */\n    if (mch_getperm(fname) < 0 && !has_autocmd(EVENT_BUFREADCMD, fname, NULL))\n    {\n\tretval = NOTAGFILE;\n\tvim_free(nofile_fname);\n\tnofile_fname = vim_strsave(fname);\n\tif (nofile_fname == NULL)\n\t    nofile_fname = empty_option;\n\tgoto erret;\n    }\n\n    ++RedrawingDisabled;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#if defined(FEAT_QUICKFIX)\n    if (g_do_tagpreview != 0)\n    {\n\tpostponed_split = 0;\t// don't split again below\n\tcurwin_save = curwin;\t// Save current window\n\n\t/*\n\t * If we are reusing a window, we may change dir when\n\t * entering it (autocommands) so turn the tag filename\n\t * into a fullpath\n\t */\n\tif (!curwin->w_p_pvw)\n\t{\n\t    full_fname = FullName_save(fname, FALSE);\n\t    fname = full_fname;\n\n\t    /*\n\t     * Make the preview window the current window.\n\t     * Open a preview window when needed.\n\t     */\n\t    prepare_tagpreview(TRUE, TRUE, FALSE);\n\t}\n    }\n\n    // If it was a CTRL-W CTRL-] command split window now.  For \":tab tag\"\n    // open a new tab page.\n    if (postponed_split && (swb_flags & (SWB_USEOPEN | SWB_USETAB)))\n    {\n\tbuf_T *existing_buf = buflist_findname_exp(fname);\n\n\tif (existing_buf != NULL)\n\t{\n\t    win_T *wp = NULL;\n\n\t    if (swb_flags & SWB_USEOPEN)\n\t\twp = buf_jump_open_win(existing_buf);\n\n\t    // If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t    // page containing \"existing_buf\" if one exists\n\t    if (wp == NULL && (swb_flags & SWB_USETAB))\n\t\twp = buf_jump_open_tab(existing_buf);\n\t    // We've switched to the buffer, the usual loading of the file must\n\t    // be skipped.\n\t    if (wp != NULL)\n\t\tgetfile_result = GETFILE_SAME_FILE;\n\t}\n    }\n    if (getfile_result == GETFILE_UNUSED\n\t\t\t\t  && (postponed_split || cmdmod.cmod_tab != 0))\n    {\n\tif (win_split(postponed_split > 0 ? postponed_split : 0,\n\t\t\t\t\t\tpostponed_split_flags) == FAIL)\n\t{\n\t    --RedrawingDisabled;\n\t    goto erret;\n\t}\n\tRESET_BINDING(curwin);\n    }\n#endif\n\n    if (keep_help)\n    {\n\t// A :ta from a help file will keep the b_help flag set.  For \":ptag\"\n\t// we need to use the flag from the window where we came from.\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    keep_help_flag = bt_help(curwin_save->w_buffer);\n\telse\n#endif\n\t    keep_help_flag = curbuf->b_help;\n    }\n\n    if (getfile_result == GETFILE_UNUSED)\n\t// Careful: getfile() may trigger autocommands and call jumpto_tag()\n\t// recursively.\n\tgetfile_result = getfile(0, fname, NULL, TRUE, (linenr_T)0, forceit);\n    keep_help_flag = FALSE;\n\n    if (GETFILE_SUCCESS(getfile_result))\t// got to the right file\n    {\n\tcurwin->w_set_curswant = TRUE;\n\tpostponed_split = 0;\n\n\tsave_magic_overruled = magic_overruled;\n\tmagic_overruled = OPTION_MAGIC_OFF;\t// always execute with 'nomagic'\n#ifdef FEAT_SEARCH_EXTRA\n\t// Save value of no_hlsearch, jumping to a tag is not a real search\n\tsave_no_hlsearch = no_hlsearch;\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\t// getfile() may have cleared options, apply 'previewpopup' again.\n\tif (g_do_tagpreview != 0 && *p_pvp != NUL)\n\t    parse_previewpopup(curwin);\n#endif\n\n\t/*\n\t * If 'cpoptions' contains 't', store the search pattern for the \"n\"\n\t * command.  If 'cpoptions' does not contain 't', the search pattern\n\t * is not stored.\n\t */\n\tif (vim_strchr(p_cpo, CPO_TAGPAT) != NULL)\n\t    search_options = 0;\n\telse\n\t    search_options = SEARCH_KEEP;\n\n\t/*\n\t * If the command is a search, try here.\n\t *\n\t * Reset 'smartcase' for the search, since the search pattern was not\n\t * typed by the user.\n\t * Only use do_search() when there is a full search command, without\n\t * anything following.\n\t */\n\tstr = pbuf;\n\tif (pbuf[0] == '/' || pbuf[0] == '?')\n\t    str = skip_regexp(pbuf + 1, pbuf[0], FALSE) + 1;\n\tif (str > pbuf_end - 1)\t// search command with nothing following\n\t{\n\t    save_p_ws = p_ws;\n\t    save_p_ic = p_ic;\n\t    save_p_scs = p_scs;\n\t    p_ws = TRUE;\t// need 'wrapscan' for backward searches\n\t    p_ic = FALSE;\t// don't ignore case now\n\t    p_scs = FALSE;\n\t    save_lnum = curwin->w_cursor.lnum;\n\t    if (tagp.tagline > 0)\n\t\t// start search before line from \"line:\" field\n\t\tcurwin->w_cursor.lnum = tagp.tagline - 1;\n\t    else\n\t\t// start search before first line\n\t\tcurwin->w_cursor.lnum = 0;\n\t    if (do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\tretval = OK;\n\t    else\n\t    {\n\t\tint\tfound = 1;\n\t\tint\tcc;\n\n\t\t/*\n\t\t * try again, ignore case now\n\t\t */\n\t\tp_ic = TRUE;\n\t\tif (!do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t{\n\t\t    /*\n\t\t     * Failed to find pattern, take a guess: \"^func  (\"\n\t\t     */\n\t\t    found = 2;\n\t\t    (void)test_for_static(&tagp);\n\t\t    cc = *tagp.tagname_end;\n\t\t    *tagp.tagname_end = NUL;\n\t\t    sprintf((char *)pbuf, \"^%s\\\\s\\\\*(\", tagp.tagname);\n\t\t    if (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t    {\n\t\t\t// Guess again: \"^char * \\<func  (\"\n\t\t\tsprintf((char *)pbuf, \"^\\\\[#a-zA-Z_]\\\\.\\\\*\\\\<%s\\\\s\\\\*(\",\n\t\t\t\t\t\t\t\ttagp.tagname);\n\t\t\tif (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t\t    found = 0;\n\t\t    }\n\t\t    *tagp.tagname_end = cc;\n\t\t}\n\t\tif (found == 0)\n\t\t{\n\t\t    emsg(_(e_canot_find_tag_pattern));\n\t\t    curwin->w_cursor.lnum = save_lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Only give a message when really guessed, not when 'ic'\n\t\t     * is set and match found while ignoring case.\n\t\t     */\n\t\t    if (found == 2 || !save_p_ic)\n\t\t    {\n\t\t\tmsg(_(e_couldnt_find_tag_just_guessing));\n\t\t\tif (!msg_scrolled && msg_silent == 0)\n\t\t\t{\n\t\t\t    out_flush();\n\t\t\t    ui_delay(1010L, TRUE);\n\t\t\t}\n\t\t    }\n\t\t    retval = OK;\n\t\t}\n\t    }\n\t    p_ws = save_p_ws;\n\t    p_ic = save_p_ic;\n\t    p_scs = save_p_scs;\n\n\t    // A search command may have positioned the cursor beyond the end\n\t    // of the line.  May need to correct that here.\n\t    check_cursor();\n\t}\n\telse\n\t{\n\t    int\t\tsave_secure = secure;\n\n\t    // Setup the sandbox for executing the command from the tags file.\n\t    secure = 1;\n#ifdef HAVE_SANDBOX\n\t    ++sandbox;\n#endif\n\t    curwin->w_cursor.lnum = 1;\t\t// start command in line 1\n\t    do_cmdline_cmd(pbuf);\n\t    retval = OK;\n\n\t    // When the command has done something that is not allowed make\n\t    // sure the error message can be seen.\n\t    if (secure == 2)\n\t\twait_return(TRUE);\n\t    secure = save_secure;\n#ifdef HAVE_SANDBOX\n\t    --sandbox;\n#endif\n\t}\n\n\tmagic_overruled = save_magic_overruled;\n#ifdef FEAT_SEARCH_EXTRA\n\t// restore no_hlsearch when keeping the old search pattern\n\tif (search_options)\n\t    set_no_hlsearch(save_no_hlsearch);\n#endif\n\n\t// Return OK if jumped to another file (at least we found the file!).\n\tif (getfile_result == GETFILE_OPEN_OTHER)\n\t    retval = OK;\n\n\tif (retval == OK)\n\t{\n\t    /*\n\t     * For a help buffer: Put the cursor line at the top of the window,\n\t     * the help subject will be below it.\n\t     */\n\t    if (curbuf->b_help)\n\t\tset_topline(curwin, curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\tfoldOpenCursor();\n#endif\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t{\n\t    // Return cursor to where we were\n\t    validate_cursor();\n\t    redraw_later(UPD_VALID);\n\t    win_enter(curwin_save, TRUE);\n\t}\n#endif\n\n\t--RedrawingDisabled;\n    }\n    else\n    {\n\t--RedrawingDisabled;\n\tgot_int = FALSE;  // don't want entering window to fail\n\n\tif (postponed_split)\t\t// close the window\n\t{\n\t    win_close(curwin, FALSE);\n\t    postponed_split = 0;\n\t}\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n\telse if (WIN_IS_POPUP(curwin))\n\t{\n\t    win_T   *wp = curwin;\n\n\t    if (win_valid(curwin_save))\n\t\twin_enter(curwin_save, TRUE);\n\t    popup_close(wp->w_id, FALSE);\n\t}\n#endif\n    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n    if (WIN_IS_POPUP(curwin))\n\t// something went wrong, still in popup, but it can't have focus\n\twin_enter(firstwin, TRUE);\n#endif\n\nerret:\n#if defined(FEAT_QUICKFIX)\n    g_do_tagpreview = 0; // For next time\n#endif\n    vim_free(lbuf);\n    vim_free(pbuf);\n    vim_free(tofree_fname);\n    vim_free(full_fname);\n\n    return retval;\n}\n\n/*\n * If \"expand\" is TRUE, expand wildcards in fname.\n * If 'tagrelative' option set, change fname (name of file containing tag)\n * according to tag_fname (name of tag file containing fname).\n * Returns a pointer to allocated memory (or NULL when out of memory).\n */\n    static char_u *\nexpand_tag_fname(char_u *fname, char_u *tag_fname, int expand)\n{\n    char_u\t*p;\n    char_u\t*retval;\n    char_u\t*expanded_fname = NULL;\n    expand_T\txpc;\n\n    /*\n     * Expand file name (for environment variables) when needed.\n     */\n    if (expand && mch_has_wildcard(fname))\n    {\n\tExpandInit(&xpc);\n\txpc.xp_context = EXPAND_FILES;\n\texpanded_fname = ExpandOne(&xpc, fname, NULL,\n\t\t\t    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);\n\tif (expanded_fname != NULL)\n\t    fname = expanded_fname;\n    }\n\n    if ((p_tr || curbuf->b_help)\n\t    && !vim_isAbsName(fname)\n\t    && (p = gettail(tag_fname)) != tag_fname)\n    {\n\tretval = alloc(MAXPATHL);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, tag_fname);\n\t    vim_strncpy(retval + (p - tag_fname), fname,\n\t\t\t\t\t      MAXPATHL - (p - tag_fname) - 1);\n\t    /*\n\t     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\".\n\t     */\n\t    simplify_filename(retval);\n\t}\n    }\n    else\n\tretval = vim_strsave(fname);\n\n    vim_free(expanded_fname);\n\n    return retval;\n}\n\n/*\n * Check if we have a tag for the buffer with name \"buf_ffname\".\n * This is a bit slow, because of the full path compare in fullpathcmp().\n * Return TRUE if tag for file \"fname\" if tag file \"tag_fname\" is for current\n * file.\n */\n    static int\ntest_for_current(\n#ifdef FEAT_EMACS_TAGS\n    int\t    is_etag,\n#endif\n    char_u  *fname,\n    char_u  *fname_end,\n    char_u  *tag_fname,\n    char_u  *buf_ffname)\n{\n    int\t    c;\n    int\t    retval = FALSE;\n    char_u  *fullname;\n\n    if (buf_ffname != NULL)\t// if the buffer has a name\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (is_etag)\n\t    c = 0;\t    // to shut up GCC\n\telse\n#endif\n\t{\n\t    c = *fname_end;\n\t    *fname_end = NUL;\n\t}\n\tfullname = expand_tag_fname(fname, tag_fname, TRUE);\n\tif (fullname != NULL)\n\t{\n\t    retval = (fullpathcmp(fullname, buf_ffname, TRUE, TRUE) & FPC_SAME);\n\t    vim_free(fullname);\n\t}\n#ifdef FEAT_EMACS_TAGS\n\tif (!is_etag)\n#endif\n\t    *fname_end = c;\n    }\n\n    return retval;\n}\n\n/*\n * Find the end of the tagaddress.\n * Return OK if \";\\\"\" is following, FAIL otherwise.\n */\n    static int\nfind_extra(char_u **pp)\n{\n    char_u\t*str = *pp;\n    char_u\tfirst_char = **pp;\n\n    // Repeat for addresses separated with ';'\n    for (;;)\n    {\n\tif (VIM_ISDIGIT(*str))\n\t    str = skipdigits(str + 1);\n\telse if (*str == '/' || *str == '?')\n\t{\n\t    str = skip_regexp(str + 1, *str, FALSE);\n\t    if (*str != first_char)\n\t\tstr = NULL;\n\t    else\n\t\t++str;\n\t}\n\telse\n\t{\n\t    // not a line number or search string, look for terminator.\n\t    str = (char_u *)strstr((char *)str, \"|;\\\"\");\n\t    if (str != NULL)\n\t    {\n\t\t++str;\n\t\tbreak;\n\t    }\n\n\t}\n\tif (str == NULL || *str != ';'\n\t\t  || !(VIM_ISDIGIT(str[1]) || str[1] == '/' || str[1] == '?'))\n\t    break;\n\t++str;\t// skip ';'\n\tfirst_char = *str;\n    }\n\n    if (str != NULL && STRNCMP(str, \";\\\"\", 2) == 0)\n    {\n\t*pp = str;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free a single entry in a tag stack\n */\n    static void\ntagstack_clear_entry(taggy_T *item)\n{\n    VIM_CLEAR(item->tagname);\n    VIM_CLEAR(item->user_data);\n}\n\n    int\nexpand_tags(\n    int\t\ttagnames,\t// expand tag names\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\ti;\n    int\t\textra_flag;\n    char_u\t*name_buf;\n    size_t\tname_buf_size = 100;\n    tagptrs_T\tt_p;\n    int\t\tret;\n\n    name_buf = alloc(name_buf_size);\n    if (name_buf == NULL)\n\treturn FAIL;\n\n    if (tagnames)\n\textra_flag = TAG_NAMES;\n    else\n\textra_flag = 0;\n    if (pat[0] == '/')\n\tret = find_tags(pat + 1, num_file, file,\n\t\tTAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    else\n\tret = find_tags(pat, num_file, file,\n\t      TAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC | TAG_NOIC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    if (ret == OK && !tagnames)\n    {\n\t // Reorganize the tags for display and matching as strings of:\n\t // \"<tagname>\\0<kind>\\0<filename>\\0\"\n\t for (i = 0; i < *num_file; i++)\n\t {\n\t     size_t\tlen;\n\n\t     parse_match((*file)[i], &t_p);\n\t     len = t_p.tagname_end - t_p.tagname;\n\t     if (len > name_buf_size - 3)\n\t     {\n\t\t char_u *buf;\n\n\t\t name_buf_size = len + 3;\n\t\t buf = vim_realloc(name_buf, name_buf_size);\n\t\t if (buf == NULL)\n\t\t {\n\t\t     vim_free(name_buf);\n\t\t     return FAIL;\n\t\t }\n\t\t name_buf = buf;\n\t     }\n\n\t     mch_memmove(name_buf, t_p.tagname, len);\n\t     name_buf[len++] = 0;\n\t     name_buf[len++] = (t_p.tagkind != NULL && *t_p.tagkind)\n\t\t\t\t\t\t\t  ? *t_p.tagkind : 'f';\n\t     name_buf[len++] = 0;\n\t     mch_memmove((*file)[i] + len, t_p.fname,\n\t\t\t\t\t\t    t_p.fname_end - t_p.fname);\n\t     (*file)[i][len + (t_p.fname_end - t_p.fname)] = 0;\n\t     mch_memmove((*file)[i], name_buf, len);\n\t}\n    }\n\n    vim_free(name_buf);\n    return ret;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add a tag field to the dictionary \"dict\".\n * Return OK or FAIL.\n */\n    static int\nadd_tag_field(\n    dict_T  *dict,\n    char    *field_name,\n    char_u  *start,\t\t// start of the value\n    char_u  *end)\t\t// after the value; can be NULL\n{\n    char_u\t*buf;\n    int\t\tlen = 0;\n    int\t\tretval;\n\n    // check that the field name doesn't exist yet\n    if (dict_has_key(dict, field_name))\n    {\n\tif (p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Duplicate field name: %s\"), field_name);\n\t    verbose_leave();\n\t}\n\treturn FAIL;\n    }\n    buf = alloc(MAXPATHL);\n    if (buf == NULL)\n\treturn FAIL;\n    if (start != NULL)\n    {\n\tif (end == NULL)\n\t{\n\t    end = start + STRLEN(start);\n\t    while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))\n\t\t--end;\n\t}\n\tlen = (int)(end - start);\n\tif (len > MAXPATHL - 1)\n\t    len = MAXPATHL - 1;\n\tvim_strncpy(buf, start, len);\n    }\n    buf[len] = NUL;\n    retval = dict_add_string(dict, field_name, buf);\n    vim_free(buf);\n    return retval;\n}\n\n/*\n * Add the tags matching the specified pattern \"pat\" to the list \"list\"\n * as a dictionary. Use \"buf_fname\" for priority, unless NULL.\n */\n    int\nget_tags(list_T *list, char_u *pat, char_u *buf_fname)\n{\n    int\t\tnum_matches, i, ret;\n    char_u\t**matches, *p;\n    char_u\t*full_fname;\n    dict_T\t*dict;\n    tagptrs_T\ttp;\n    long\tis_static;\n\n    ret = find_tags(pat, &num_matches, &matches,\n\t\t\t\tTAG_REGEXP | TAG_NOIC, (int)MAXCOL, buf_fname);\n    if (ret == OK && num_matches > 0)\n    {\n\tfor (i = 0; i < num_matches; ++i)\n\t{\n\t    parse_match(matches[i], &tp);\n\t    is_static = test_for_static(&tp);\n\n\t    // Skip pseudo-tag lines.\n\t    if (STRNCMP(tp.tagname, \"!_TAG_\", 6) == 0)\n\t    {\n\t\tvim_free(matches[i]);\n\t\tcontinue;\n\t    }\n\n\t    if ((dict = dict_alloc()) == NULL)\n\t\tret = FAIL;\n\t    if (list_append_dict(list, dict) == FAIL)\n\t\tret = FAIL;\n\n\t    full_fname = tag_full_fname(&tp);\n\t    if (add_tag_field(dict, \"name\", tp.tagname, tp.tagname_end) == FAIL\n\t\t    || add_tag_field(dict, \"filename\", full_fname,\n\t\t\t\t\t\t\t NULL) == FAIL\n\t\t    || add_tag_field(dict, \"cmd\", tp.command,\n\t\t\t\t\t\t       tp.command_end) == FAIL\n\t\t    || add_tag_field(dict, \"kind\", tp.tagkind,\n\t\t\t\t\t\t      tp.tagkind_end) == FAIL\n\t\t    || dict_add_number(dict, \"static\", is_static) == FAIL)\n\t\tret = FAIL;\n\n\t    vim_free(full_fname);\n\n\t    if (tp.command_end != NULL)\n\t    {\n\t\tfor (p = tp.command_end + 3;\n\t\t\t  *p != NUL && *p != '\\n' && *p != '\\r'; MB_PTR_ADV(p))\n\t\t{\n\t\t    if (p == tp.tagkind || (p + 5 == tp.tagkind\n\t\t\t\t\t      && STRNCMP(p, \"kind:\", 5) == 0))\n\t\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\t\tp = tp.tagkind_end - 1;\n\t\t    else if (STRNCMP(p, \"file:\", 5) == 0)\n\t\t\t// skip \"file:\" (static tag)\n\t\t\tp += 4;\n\t\t    else if (!VIM_ISWHITE(*p))\n\t\t    {\n\t\t\tchar_u\t*s, *n;\n\t\t\tint\tlen;\n\n\t\t\t// Add extra field as a dict entry.  Fields are\n\t\t\t// separated by Tabs.\n\t\t\tn = p;\n\t\t\twhile (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')\n\t\t\t    ++p;\n\t\t\tlen = (int)(p - n);\n\t\t\tif (*p == ':' && len > 0)\n\t\t\t{\n\t\t\t    s = ++p;\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\t    n[len] = NUL;\n\t\t\t    if (add_tag_field(dict, (char *)n, s, p) == FAIL)\n\t\t\t\tret = FAIL;\n\t\t\t    n[len] = ':';\n\t\t\t}\n\t\t\telse\n\t\t\t    // Skip field without colon.\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\tif (*p == NUL)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    vim_free(matches[i]);\n\t}\n\tvim_free(matches);\n    }\n    return ret;\n}\n\n/*\n * Return information about 'tag' in dict 'retdict'.\n */\n    static void\nget_tag_details(taggy_T *tag, dict_T *retdict)\n{\n    list_T\t*pos;\n    fmark_T\t*fmark;\n\n    dict_add_string(retdict, \"tagname\", tag->tagname);\n    dict_add_number(retdict, \"matchnr\", tag->cur_match + 1);\n    dict_add_number(retdict, \"bufnr\", tag->cur_fnum);\n    if (tag->user_data)\n\tdict_add_string(retdict, \"user_data\", tag->user_data);\n\n    if ((pos = list_alloc_id(aid_tagstack_from)) == NULL)\n\treturn;\n    dict_add_list(retdict, \"from\", pos);\n\n    fmark = &tag->fmark;\n    list_append_number(pos,\n\t\t\t(varnumber_T)(fmark->fnum != -1 ? fmark->fnum : 0));\n    list_append_number(pos, (varnumber_T)fmark->mark.lnum);\n    list_append_number(pos, (varnumber_T)(fmark->mark.col == MAXCOL ?\n\t\t\t\t\tMAXCOL : fmark->mark.col + 1));\n    list_append_number(pos, (varnumber_T)fmark->mark.coladd);\n}\n\n/*\n * Return the tag stack entries of the specified window 'wp' in dictionary\n * 'retdict'.\n */\n    void\nget_tagstack(win_T *wp, dict_T *retdict)\n{\n    list_T\t*l;\n    int\t\ti;\n    dict_T\t*d;\n\n    dict_add_number(retdict, \"length\", wp->w_tagstacklen);\n    dict_add_number(retdict, \"curidx\", wp->w_tagstackidx + 1);\n    l = list_alloc_id(aid_tagstack_items);\n    if (l == NULL)\n\treturn;\n    dict_add_list(retdict, \"items\", l);\n\n    for (i = 0; i < wp->w_tagstacklen; i++)\n    {\n\tif ((d = dict_alloc_id(aid_tagstack_details)) == NULL)\n\t    return;\n\tlist_append_dict(l, d);\n\n\tget_tag_details(&wp->w_tagstack[i], d);\n    }\n}\n\n/*\n * Free all the entries in the tag stack of the specified window\n */\n    static void\ntagstack_clear(win_T *wp)\n{\n    int i;\n\n    // Free the current tag stack\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n\ttagstack_clear_entry(&wp->w_tagstack[i]);\n    wp->w_tagstacklen = 0;\n    wp->w_tagstackidx = 0;\n}\n\n/*\n * Remove the oldest entry from the tag stack and shift the rest of\n * the entries to free up the top of the stack.\n */\n    static void\ntagstack_shift(win_T *wp)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\ti;\n\n    tagstack_clear_entry(&tagstack[0]);\n    for (i = 1; i < wp->w_tagstacklen; ++i)\n\ttagstack[i - 1] = tagstack[i];\n    wp->w_tagstacklen--;\n}\n\n/*\n * Push a new item to the tag stack\n */\n    static void\ntagstack_push_item(\n\twin_T\t*wp,\n\tchar_u\t*tagname,\n\tint\tcur_fnum,\n\tint\tcur_match,\n\tpos_T\tmark,\n\tint\tfnum,\n\tchar_u  *user_data)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\tidx = wp->w_tagstacklen;\t// top of the stack\n\n    // if the tagstack is full: remove the oldest entry\n    if (idx >= TAGSTACKSIZE)\n    {\n\ttagstack_shift(wp);\n\tidx = TAGSTACKSIZE - 1;\n    }\n\n    wp->w_tagstacklen++;\n    tagstack[idx].tagname = tagname;\n    tagstack[idx].cur_fnum = cur_fnum;\n    tagstack[idx].cur_match = cur_match;\n    if (tagstack[idx].cur_match < 0)\n\ttagstack[idx].cur_match = 0;\n    tagstack[idx].fmark.mark = mark;\n    tagstack[idx].fmark.fnum = fnum;\n    tagstack[idx].user_data = user_data;\n}\n\n/*\n * Add a list of items to the tag stack in the specified window\n */\n    static void\ntagstack_push_items(win_T *wp, list_T *l)\n{\n    listitem_T\t*li;\n    dictitem_T\t*di;\n    dict_T\t*itemdict;\n    char_u\t*tagname;\n    pos_T\tmark;\n    int\t\tfnum;\n\n    // Add one entry at a time to the tag stack\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT || li->li_tv.vval.v_dict == NULL)\n\t    continue;\t\t\t\t// Skip non-dict items\n\titemdict = li->li_tv.vval.v_dict;\n\n\t// parse 'from' for the cursor position before the tag jump\n\tif ((di = dict_find(itemdict, (char_u *)\"from\", -1)) == NULL)\n\t    continue;\n\tif (list2fpos(&di->di_tv, &mark, &fnum, NULL, FALSE) != OK)\n\t    continue;\n\tif ((tagname = dict_get_string(itemdict, \"tagname\", TRUE)) == NULL)\n\t    continue;\n\n\tif (mark.col > 0)\n\t    mark.col--;\n\ttagstack_push_item(wp, tagname,\n\t\t(int)dict_get_number(itemdict, \"bufnr\"),\n\t\t(int)dict_get_number(itemdict, \"matchnr\") - 1,\n\t\tmark, fnum,\n\t\tdict_get_string(itemdict, \"user_data\", TRUE));\n    }\n}\n\n/*\n * Set the current index in the tag stack. Valid values are between 0\n * and the stack length (inclusive).\n */\n    static void\ntagstack_set_curidx(win_T *wp, int curidx)\n{\n    wp->w_tagstackidx = curidx;\n    if (wp->w_tagstackidx < 0)\t\t\t// sanity check\n\twp->w_tagstackidx = 0;\n    if (wp->w_tagstackidx > wp->w_tagstacklen)\n\twp->w_tagstackidx = wp->w_tagstacklen;\n}\n\n/*\n * Set the tag stack entries of the specified window.\n * 'action' is set to one of:\n *\t'a' for append\n *\t'r' for replace\n *\t't' for truncate\n */\n    int\nset_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n\n#ifdef FEAT_EVAL\n    // not allowed to alter the tag stack entries from inside tagfunc\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n\n    if (action == 't')\t\t    // truncate the stack\n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\n\t// delete all the tag stack entries above the current entry\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t// replace the stack\n\t    tagstack_clear(wp);\n\n\ttagstack_push_items(wp, l);\n\t// set the current index after the last entry\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n\n    return OK;\n}\n#endif\n", "\" Test 'tagfunc'\n\nimport './vim9.vim' as v9\nsource check.vim\nsource screendump.vim\n\nfunc TagFunc(pat, flag, info)\n  let g:tagfunc_args = [a:pat, a:flag, a:info]\n  let tags = []\n  for num in range(1,10)\n    let tags += [{\n          \\ 'cmd': '2', 'name': 'nothing'.num, 'kind': 'm',\n          \\ 'filename': 'Xfile1', 'user_data': 'somedata'.num,\n          \\}]\n  endfor\n  return tags\nendfunc\n\nfunc Test_tagfunc()\n  set tagfunc=TagFunc\n  new Xfile1\n  call setline(1, ['empty', 'one()', 'empty'])\n  write\n\n  call assert_equal({'cmd': '2', 'static': 0,\n        \\ 'name': 'nothing2', 'user_data': 'somedata2',\n        \\ 'kind': 'm', 'filename': 'Xfile1'}, taglist('.')[1])\n\n  call settagstack(win_getid(), {'items': []})\n\n  tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata1', gettagstack().items[0].user_data)\n  5tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n  pop\n  tag\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n\n  let g:tagfunc_args=[]\n  execute \"normal! \\<c-]>\"\n  call assert_equal('one', g:tagfunc_args[0])\n  call assert_equal('c', g:tagfunc_args[1])\n\n  let g:tagfunc_args=[]\n  execute \"tag /foo$\"\n  call assert_equal('foo$', g:tagfunc_args[0])\n  call assert_equal('r', g:tagfunc_args[1])\n\n  set cpt=t\n  let g:tagfunc_args=[]\n  execute \"normal! i\\<c-n>\\<c-y>\"\n  call assert_equal('\\<\\k\\k', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing1', getline('.')[0:7])\n\n  let g:tagfunc_args=[]\n  execute \"normal! ono\\<c-n>\\<c-n>\\<c-y>\"\n  call assert_equal('\\<no', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing2', getline('.')[0:7])\n\n  func BadTagFunc1(...)\n    return 0\n  endfunc\n  func BadTagFunc2(...)\n    return [1]\n  endfunc\n  func BadTagFunc3(...)\n    return [{'name': 'foo'}]\n  endfunc\n\n  for &tagfunc in ['BadTagFunc1', 'BadTagFunc2', 'BadTagFunc3']\n    try\n      tag nothing\n      call assert_false(1, 'tag command should have failed')\n    catch\n      call assert_exception('E987:')\n    endtry\n    exe 'delf' &tagfunc\n  endfor\n\n  func NullTagFunc(...)\n    return v:null\n  endfunc\n  set tags= tfu=NullTagFunc\n  call assert_fails('tag nothing', 'E433:')\n  delf NullTagFunc\n\n  bwipe!\n  set tags& tfu& cpt& \n  call delete('Xfile1')\nendfunc\n\n\" Test for modifying the tag stack from a tag function and jumping to a tag\n\" from a tag function\nfunc Test_tagfunc_settagstack()\n  func Mytagfunc1(pat, flags, info)\n    call settagstack(1, {'tagname' : 'mytag', 'from' : [0, 10, 1, 0]})\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc1\n  call writefile([''], 'Xtest')\n  call assert_fails('tag xyz', 'E986:')\n\n  func Mytagfunc2(pat, flags, info)\n    tag test_tag\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc2\n  call assert_fails('tag xyz', 'E986:')\n\n  call delete('Xtest')\n  set tagfunc&\n  delfunc Mytagfunc1\n  delfunc Mytagfunc2\nendfunc\n\n\" Script local tagfunc callback function\nfunc s:ScriptLocalTagFunc(pat, flags, info)\n  let g:ScriptLocalFuncArgs = [a:pat, a:flags, a:info]\n  return v:null\nendfunc\n\n\" Test for different ways of setting the 'tagfunc' option\nfunc Test_tagfunc_callback()\n  func TagFunc1(callnr, pat, flags, info)\n    let g:TagFunc1Args = [a:callnr, a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  func TagFunc2(pat, flags, info)\n    let g:TagFunc2Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &tagfunc = 'g:TagFunc2'\n    new\n    LET g:TagFunc2Args = []\n    call assert_fails('tag a10', 'E433:')\n    call assert_equal(['a10', '', {}], g:TagFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set tagfunc=function('g:TagFunc1',\\ [10])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a11', 'E433:')\n    call assert_equal([10, 'a11', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    VAR Fn = function('g:TagFunc1', [11])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([11, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = function('g:TagFunc1', [12])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([12, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set tagfunc=funcref('g:TagFunc1',\\ [13])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a13', 'E433:')\n    call assert_equal([13, 'a13', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [14])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([14, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [15])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([15, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function\n    VAR optval = \"LSTART a, b, c LMIDDLE g:TagFunc1(16, a, b, c) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set tagfunc=\" .. optval\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a17', 'E433:')\n    call assert_equal([16, 'a17', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a lambda expression\n    LET &tagfunc = LSTART a, b, c LMIDDLE g:TagFunc1(17, a, b, c) LEND\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([17, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(lambda expression)\n    LET &tagfunc = 'LSTART a, b, c LMIDDLE g:TagFunc1(18, a, b, c) LEND'\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([18, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(19, a, b, c) LEND\n    LET &tagfunc = Lambda\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([19, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(20, a, b, c) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([20, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b, c LMIDDLE strlen(a) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    call assert_fails(\"tag a20\", \"E987:\")\n    bw!\n\n    #\" Test for clearing the 'tagfunc' option\n    set tagfunc=''\n    set tagfunc&\n    call assert_fails(\"set tagfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set tagfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'tagfunc' to a non-existing function\n    LET &tagfunc = function('g:TagFunc2', [21])\n    LET g:TagFunc2Args = []\n    call assert_fails(\"set tagfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &tagfunc = function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"tag axb123\", 'E426:')\n    call assert_equal([], g:TagFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TagFunc3(pat, flags, info)\n    let g:TagFunc3Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  set tagfunc=s:TagFunc3\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a21', 'E433:')\n  call assert_equal(['a21', '', {}], g:TagFunc3Args)\n  bw!\n  let &tagfunc = 's:TagFunc3'\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a22', 'E433:')\n  call assert_equal(['a22', '', {}], g:TagFunc3Args)\n  bw!\n  delfunc s:TagFunc3\n\n  \" invalid return value\n  let &tagfunc = \"{a -> 'abc'}\"\n  call assert_fails(\"echo taglist('a')\", \"E987:\")\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set tagfunc=(a,\\ b,\\ c)\\ =>\\ g:TagFunc1(21,\\ a,\\ b,\\ c)\n  new\n  let g:TagFunc1Args = []\n  call assert_fails(\"tag a17\", \"E117:\")\n  call assert_equal([], g:TagFunc1Args)\n  bw!\n\n  \" Test for using a script local function\n  set tagfunc=<SID>ScriptLocalTagFunc\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a15', 'E433:')\n  call assert_equal(['a15', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a script local funcref variable\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= Fn\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a string(script local funcref variable)\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= string(Fn)\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" set 'tagfunc' to a partial with dict. This used to cause a crash.\n  func SetTagFunc()\n    let params = {'tagfn': function('g:DictTagFunc')}\n    let &tagfunc = params.tagfn\n  endfunc\n  func g:DictTagFunc(_) dict\n  endfunc\n  call SetTagFunc()\n  new\n  call SetTagFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set tagfunc=\n  wincmd w\n  set tagfunc=\n  :%bw!\n  delfunc g:DictTagFunc\n  delfunc SetTagFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9tagFunc(callnr: number, pat: string, flags: string, info: dict<any>): any\n      g:Vim9tagFuncArgs = [callnr, pat, flags, info]\n      return null\n    enddef\n\n    # Test for using a def function with completefunc\n    set tagfunc=function('Vim9tagFunc',\\ [60])\n    new\n    g:Vim9tagFuncArgs = []\n    assert_fails('tag a10', 'E433:')\n    assert_equal([60, 'a10', '', {}], g:Vim9tagFuncArgs)\n\n    # Test for using a global function name\n    &tagfunc = g:TagFunc2\n    new\n    g:TagFunc2Args = []\n    assert_fails('tag a11', 'E433:')\n    assert_equal(['a11', '', {}], g:TagFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalTagFunc(pat: string, flags: string, info: dict<any> ): any\n      g:LocalTagFuncArgs = [pat, flags, info]\n      return null\n    enddef\n    &tagfunc = LocalTagFunc\n    new\n    g:LocalTagFuncArgs = []\n    assert_fails('tag a12', 'E433:')\n    assert_equal(['a12', '', {}], g:LocalTagFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  delfunc TagFunc1\n  delfunc TagFunc2\n  set tagfunc&\n  %bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Code to handle tags and the tag stack\n */\n\n#include \"vim.h\"\n\n/*\n * Structure to hold pointers to various items in a tag line.\n */\ntypedef struct tag_pointers\n{\n    // filled in by parse_tag_line():\n    char_u\t*tagname;\t// start of tag name (skip \"file:\")\n    char_u\t*tagname_end;\t// char after tag name\n    char_u\t*fname;\t\t// first char of file name\n    char_u\t*fname_end;\t// char after file name\n    char_u\t*command;\t// first char of command\n    // filled in by parse_match():\n    char_u\t*command_end;\t// first char after command\n    char_u\t*tag_fname;\t// file name of the tags file. This is used\n\t\t\t\t// when 'tr' is set.\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t// TRUE for emacs tag\n#endif\n    char_u\t*tagkind;\t// \"kind:\" value\n    char_u\t*tagkind_end;\t// end of tagkind\n    char_u\t*user_data;\t// user_data string\n    char_u\t*user_data_end;\t// end of user_data\n    linenr_T\ttagline;\t// \"line:\" value\n} tagptrs_T;\n\n/*\n * Return values used when reading lines from a tags file.\n */\ntypedef enum\n{\n    TAGS_READ_SUCCESS = 1,\n    TAGS_READ_EOF,\n    TAGS_READ_IGNORE,\n} tags_read_status_T;\n\n/*\n * States used during a tags search\n */\ntypedef enum\n{\n    TS_START,\t\t// at start of file\n    TS_LINEAR,\t\t// linear searching forward, till EOF\n    TS_BINARY,\t\t// binary searching\n    TS_SKIP_BACK,\t// skipping backwards\n    TS_STEP_FORWARD\t// stepping forwards\n} tagsearch_state_T;\t// Current search state\n\n/*\n * Binary search file offsets in a tags file\n */\ntypedef struct\n{\n    off_T\tlow_offset;\t// offset for first char of first line that\n\t\t\t\t// could match\n    off_T\thigh_offset;\t// offset of char after last line that could\n\t\t\t\t// match\n    off_T\tcurr_offset;\t// Current file offset in search range\n    off_T\tcurr_offset_used; // curr_offset used when skipping back\n    off_T\tmatch_offset;\t// Where the binary search found a tag\n    int\tlow_char;\t\t// first char at low_offset\n    int\thigh_char;\t\t// first char at high_offset\n} tagsearch_info_T;\n\n/*\n * Return values used when matching tags against a pattern.\n */\ntypedef enum\n{\n    TAG_MATCH_SUCCESS = 1,\n    TAG_MATCH_FAIL,\n    TAG_MATCH_STOP,\n    TAG_MATCH_NEXT\n} tagmatch_status_T;\n\n/*\n * Arguments used for matching tags read from a tags file against a pattern.\n */\ntypedef struct\n{\n    int\tmatchoff;\t\t// tag match offset\n    int\tmatch_re;\t\t// TRUE if the tag matches a regexp\n    int\tmatch_no_ic;\t\t// TRUE if the tag matches with case\n    int\thas_re;\t\t\t// regular expression used\n    int\tsortic;\t\t\t// tags file sorted ignoring case (foldcase)\n    int\tsort_error;\t\t// tags file not sorted\n} findtags_match_args_T;\n\n/*\n * The matching tags are first stored in one of the hash tables.  In\n * which one depends on the priority of the match.\n * ht_match[] is used to find duplicates, ga_match[] to keep them in sequence.\n * At the end, all the matches from ga_match[] are concatenated, to make a list\n * sorted on priority.\n */\n#define MT_ST_CUR\t0\t\t// static match in current file\n#define MT_GL_CUR\t1\t\t// global match in current file\n#define MT_GL_OTH\t2\t\t// global match in other file\n#define MT_ST_OTH\t3\t\t// static match in other file\n#define MT_IC_OFF\t4\t\t// add for icase match\n#define MT_RE_OFF\t8\t\t// add for regexp match\n#define MT_MASK\t\t7\t\t// mask for printing priority\n#define MT_COUNT\t16\n\nstatic char\t*mt_names[MT_COUNT/2] =\n\t\t{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};\n\n#define NOTAGFILE\t99\t\t// return value for jumpto_tag\nstatic char_u\t*nofile_fname = NULL;\t// fname for NOTAGFILE error\n\nstatic void taglen_advance(int l);\n\nstatic int jumpto_tag(char_u *lbuf, int forceit, int keep_help);\n#ifdef FEAT_EMACS_TAGS\nstatic int parse_tag_line(char_u *lbuf, int is_etag, tagptrs_T *tagp);\n#else\nstatic int parse_tag_line(char_u *lbuf, tagptrs_T *tagp);\n#endif\nstatic int test_for_static(tagptrs_T *);\nstatic int parse_match(char_u *lbuf, tagptrs_T *tagp);\nstatic char_u *tag_full_fname(tagptrs_T *tagp);\nstatic char_u *expand_tag_fname(char_u *fname, char_u *tag_fname, int expand);\n#ifdef FEAT_EMACS_TAGS\nstatic int test_for_current(int, char_u *, char_u *, char_u *, char_u *);\n#else\nstatic int test_for_current(char_u *, char_u *, char_u *, char_u *);\n#endif\nstatic int find_extra(char_u **pp);\nstatic void print_tag_list(int new_tag, int use_tagstack, int num_matches, char_u **matches);\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\nstatic int add_llist_tags(char_u *tag, int num_matches, char_u **matches);\n#endif\nstatic void tagstack_clear_entry(taggy_T *item);\n\nstatic char_u\t*tagmatchname = NULL;\t// name of last used tag\n\n#if defined(FEAT_QUICKFIX)\n/*\n * Tag for preview window is remembered separately, to avoid messing up the\n * normal tagstack.\n */\nstatic taggy_T ptag_entry = {NULL, {{0, 0, 0}, 0}, 0, 0, NULL};\n#endif\n\n#ifdef FEAT_EVAL\nstatic int  tfu_in_use = FALSE;\t    // disallow recursive call of tagfunc\nstatic callback_T tfu_cb;\t    // 'tagfunc' callback function\n#endif\n\n// Used instead of NUL to separate tag fields in the growarrays.\n#define TAG_SEP 0x02\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Reads the 'tagfunc' option value and convert that to a callback value.\n * Invoked when the 'tagfunc' option is set. The option value can be a name of\n * a function (string), or function(<name>) or funcref(<name>) or a lambda.\n */\n    int\nset_tagfunc_option(void)\n{\n#ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n    free_callback(&curbuf->b_tfu_cb);\n\n    if (*curbuf->b_p_tfu == NUL)\n\treturn OK;\n\n    if (option_set_callback_func(curbuf->b_p_tfu, &tfu_cb) == FAIL)\n\treturn FAIL;\n\n    copy_callback(&curbuf->b_tfu_cb, &tfu_cb);\n#endif\n\n    return OK;\n}\n#endif\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tagfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&tfu_cb);\n# endif\n}\n# endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'tagfunc' callback with 'copyID' so that it is not garbage\n * collected.\n */\n    int\nset_ref_in_tagfunc(int copyID UNUSED)\n{\n    int\tabort = FALSE;\n\n    abort = set_ref_in_callback(&tfu_cb, copyID);\n\n    return abort;\n}\n\n/*\n * Copy the global 'tagfunc' callback function to the buffer-local 'tagfunc'\n * callback for 'buf'.\n */\n    void\nset_buflocal_tfu_callback(buf_T *buf UNUSED)\n{\n    free_callback(&buf->b_tfu_cb);\n    if (tfu_cb.cb_name != NULL && *tfu_cb.cb_name != NUL)\n\tcopy_callback(&buf->b_tfu_cb, &tfu_cb);\n}\n#endif\n\n/*\n * Jump to tag; handling of tag commands and tag stack\n *\n * *tag != NUL: \":tag {tag}\", jump to new tag, add to tag stack\n *\n * type == DT_TAG:\t\":tag [tag]\", jump to newer position or same tag again\n * type == DT_HELP:\tlike DT_TAG, but don't use regexp.\n * type == DT_POP:\t\":pop\" or CTRL-T, jump to old position\n * type == DT_NEXT:\tjump to next match of same tag\n * type == DT_PREV:\tjump to previous match of same tag\n * type == DT_FIRST:\tjump to first match of same tag\n * type == DT_LAST:\tjump to last match of same tag\n * type == DT_SELECT:\t\":tselect [tag]\", select tag from a list of all matches\n * type == DT_JUMP:\t\":tjump [tag]\", jump to tag or select tag from a list\n * type == DT_CSCOPE:\tuse cscope to find the tag\n * type == DT_LTAG:\tuse location list for displaying tag matches\n * type == DT_FREE:\tfree cached matches\n *\n * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise\n */\n    int\ndo_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * List all the matching tags.\n */\n    static void\nprint_tag_list(\n    int\t\tnew_tag,\n    int\t\tuse_tagstack,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ti;\n    char_u\t*p;\n    char_u\t*command_end;\n    tagptrs_T\ttagp;\n    int\t\ttaglen;\n    int\t\tattr;\n\n    /*\n     * Assume that the first match indicates how long the tags can\n     * be, and align the file names to that.\n     */\n    parse_match(matches[0], &tagp);\n    taglen = (int)(tagp.tagname_end - tagp.tagname + 2);\n    if (taglen < 18)\n\ttaglen = 18;\n    if (taglen > Columns - 25)\n\ttaglen = MAXCOL;\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\t// overwrite previous message\n    msg_start();\n    msg_puts_attr(_(\"  # pri kind tag\"), HL_ATTR(HLF_T));\n    msg_clr_eos();\n    taglen_advance(taglen);\n    msg_puts_attr(_(\"file\\n\"), HL_ATTR(HLF_T));\n\n    for (i = 0; i < num_matches && !got_int; ++i)\n    {\n\tparse_match(matches[i], &tagp);\n\tif (!new_tag && (\n#if defined(FEAT_QUICKFIX)\n\t\t    (g_do_tagpreview != 0\n\t\t     && i == ptag_entry.cur_match) ||\n#endif\n\t\t    (use_tagstack\n\t\t     && i == tagstack[tagstackidx].cur_match)))\n\t    *IObuff = '>';\n\telse\n\t    *IObuff = ' ';\n\tvim_snprintf((char *)IObuff + 1, IOSIZE - 1,\n\t\t\"%2d %s \", i + 1,\n\t\t\t       mt_names[matches[i][0] & MT_MASK]);\n\tmsg_puts((char *)IObuff);\n\tif (tagp.tagkind != NULL)\n\t    msg_outtrans_len(tagp.tagkind,\n\t\t\t  (int)(tagp.tagkind_end - tagp.tagkind));\n\tmsg_advance(13);\n\tmsg_outtrans_len_attr(tagp.tagname,\n\t\t\t   (int)(tagp.tagname_end - tagp.tagname),\n\t\t\t\t\t\t  HL_ATTR(HLF_T));\n\tmsg_putchar(' ');\n\ttaglen_advance(taglen);\n\n\t// Find out the actual file name. If it is long, truncate\n\t// it and put \"...\" in the middle\n\tp = tag_full_fname(&tagp);\n\tif (p != NULL)\n\t{\n\t    msg_outtrans_long_attr(p, HL_ATTR(HLF_D));\n\t    vim_free(p);\n\t}\n\tif (msg_col > 0)\n\t    msg_putchar('\\n');\n\tif (got_int)\n\t    break;\n\tmsg_advance(15);\n\n\t// print any extra fields\n\tcommand_end = tagp.command_end;\n\tif (command_end != NULL)\n\t{\n\t    p = command_end + 3;\n\t    while (*p && *p != '\\r' && *p != '\\n')\n\t    {\n\t\twhile (*p == TAB)\n\t\t    ++p;\n\n\t\t// skip \"file:\" without a value (static tag)\n\t\tif (STRNCMP(p, \"file:\", 5) == 0\n\t\t\t\t\t     && vim_isspace(p[5]))\n\t\t{\n\t\t    p += 5;\n\t\t    continue;\n\t\t}\n\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\tif (p == tagp.tagkind\n\t\t\t|| (p + 5 == tagp.tagkind\n\t\t\t\t&& STRNCMP(p, \"kind:\", 5) == 0))\n\t\t{\n\t\t    p = tagp.tagkind_end;\n\t\t    continue;\n\t\t}\n\t\t// print all other extra fields\n\t\tattr = HL_ATTR(HLF_CM);\n\t\twhile (*p && *p != '\\r' && *p != '\\n')\n\t\t{\n\t\t    if (msg_col + ptr2cells(p) >= Columns)\n\t\t    {\n\t\t\tmsg_putchar('\\n');\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t\tmsg_advance(15);\n\t\t    }\n\t\t    p = msg_outtrans_one(p, attr);\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tmsg_puts_attr(\" \", attr);\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*p == ':')\n\t\t\tattr = 0;\n\t\t}\n\t    }\n\t    if (msg_col > 15)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    break;\n\t\tmsg_advance(15);\n\t    }\n\t}\n\telse\n\t{\n\t    for (p = tagp.command;\n\t\t\t      *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t;\n\t    command_end = p;\n\t}\n\n\t// Put the info (in several lines) at column 15.\n\t// Don't display \"/^\" and \"?^\".\n\tp = tagp.command;\n\tif (*p == '/' || *p == '?')\n\t{\n\t    ++p;\n\t    if (*p == '^')\n\t\t++p;\n\t}\n\t// Remove leading whitespace from pattern\n\twhile (p != command_end && vim_isspace(*p))\n\t    ++p;\n\n\twhile (p != command_end)\n\t{\n\t    if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)\n\t\tmsg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_advance(15);\n\n\t    // skip backslash used for escaping a command char or\n\t    // a backslash\n\t    if (*p == '\\\\' && (*(p + 1) == *tagp.command\n\t\t\t    || *(p + 1) == '\\\\'))\n\t\t++p;\n\n\t    if (*p == TAB)\n\t    {\n\t\tmsg_putchar(' ');\n\t\t++p;\n\t    }\n\t    else\n\t\tp = msg_outtrans_one(p, 0);\n\n\t    // don't display the \"$/;\\\"\" and \"$?;\\\"\"\n\t    if (p == command_end - 2 && *p == '$'\n\t\t\t\t     && *(p + 1) == *tagp.command)\n\t\tbreak;\n\t    // don't display matching '/' or '?'\n\t    if (p == command_end - 1 && *p == *tagp.command\n\t\t\t\t     && (*p == '/' || *p == '?'))\n\t\tbreak;\n\t}\n\tif (msg_col)\n\t    msg_putchar('\\n');\n\tui_breakcheck();\n    }\n    if (got_int)\n\tgot_int = FALSE;\t// only stop the listing\n}\n\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n/*\n * Add the matching tags to the location list for the current\n * window.\n */\n    static int\nadd_llist_tags(\n    char_u\t*tag,\n    int\t\tnum_matches,\n    char_u\t**matches)\n{\n    list_T\t*list;\n    char_u\ttag_name[128 + 1];\n    char_u\t*fname;\n    char_u\t*cmd;\n    int\t\ti;\n    char_u\t*p;\n    tagptrs_T\ttagp;\n\n    fname = alloc(MAXPATHL + 1);\n    cmd = alloc(CMDBUFFSIZE + 1);\n    list = list_alloc();\n    if (list == NULL || fname == NULL || cmd == NULL)\n    {\n\tvim_free(cmd);\n\tvim_free(fname);\n\tif (list != NULL)\n\t    list_free(list);\n\treturn FAIL;\n    }\n\n    for (i = 0; i < num_matches; ++i)\n    {\n\tint\t    len, cmd_len;\n\tlong    lnum;\n\tdict_T  *dict;\n\n\tparse_match(matches[i], &tagp);\n\n\t// Save the tag name\n\tlen = (int)(tagp.tagname_end - tagp.tagname);\n\tif (len > 128)\n\t    len = 128;\n\tvim_strncpy(tag_name, tagp.tagname, len);\n\ttag_name[len] = NUL;\n\n\t// Save the tag file name\n\tp = tag_full_fname(&tagp);\n\tif (p == NULL)\n\t    continue;\n\tvim_strncpy(fname, p, MAXPATHL);\n\tvim_free(p);\n\n\t// Get the line number or the search pattern used to locate\n\t// the tag.\n\tlnum = 0;\n\tif (isdigit(*tagp.command))\n\t    // Line number is used to locate the tag\n\t    lnum = atol((char *)tagp.command);\n\telse\n\t{\n\t    char_u *cmd_start, *cmd_end;\n\n\t    // Search pattern is used to locate the tag\n\n\t    // Locate the end of the command\n\t    cmd_start = tagp.command;\n\t    cmd_end = tagp.command_end;\n\t    if (cmd_end == NULL)\n\t    {\n\t\tfor (p = tagp.command;\n\t\t     *p && *p != '\\r' && *p != '\\n'; ++p)\n\t\t    ;\n\t\tcmd_end = p;\n\t    }\n\n\t    // Now, cmd_end points to the character after the\n\t    // command. Adjust it to point to the last\n\t    // character of the command.\n\t    cmd_end--;\n\n\t    // Skip the '/' and '?' characters at the\n\t    // beginning and end of the search pattern.\n\t    if (*cmd_start == '/' || *cmd_start == '?')\n\t\tcmd_start++;\n\n\t    if (*cmd_end == '/' || *cmd_end == '?')\n\t\tcmd_end--;\n\n\t    len = 0;\n\t    cmd[0] = NUL;\n\n\t    // If \"^\" is present in the tag search pattern, then\n\t    // copy it first.\n\t    if (*cmd_start == '^')\n\t    {\n\t\tSTRCPY(cmd, \"^\");\n\t\tcmd_start++;\n\t\tlen++;\n\t    }\n\n\t    // Precede the tag pattern with \\V to make it very\n\t    // nomagic.\n\t    STRCAT(cmd, \"\\\\V\");\n\t    len += 2;\n\n\t    cmd_len = (int)(cmd_end - cmd_start + 1);\n\t    if (cmd_len > (CMDBUFFSIZE - 5))\n\t\tcmd_len = CMDBUFFSIZE - 5;\n\t    STRNCAT(cmd, cmd_start, cmd_len);\n\t    len += cmd_len;\n\n\t    if (cmd[len - 1] == '$')\n\t    {\n\t\t// Replace '$' at the end of the search pattern\n\t\t// with '\\$'\n\t\tcmd[len - 1] = '\\\\';\n\t\tcmd[len] = '$';\n\t\tlen++;\n\t    }\n\n\t    cmd[len] = NUL;\n\t}\n\n\tif ((dict = dict_alloc()) == NULL)\n\t    continue;\n\tif (list_append_dict(list, dict) == FAIL)\n\t{\n\t    vim_free(dict);\n\t    continue;\n\t}\n\n\tdict_add_string(dict, \"text\", tag_name);\n\tdict_add_string(dict, \"filename\", fname);\n\tdict_add_number(dict, \"lnum\", lnum);\n\tif (lnum == 0)\n\t    dict_add_string(dict, \"pattern\", cmd);\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, \"ltag %s\", tag);\n    set_errorlist(curwin, list, ' ', IObuff, NULL);\n\n    list_free(list);\n    vim_free(fname);\n    vim_free(cmd);\n\n    return OK;\n}\n#endif\n\n/*\n * Free cached tags.\n */\n    void\ntag_freematch(void)\n{\n    VIM_CLEAR(tagmatchname);\n}\n\n    static void\ntaglen_advance(int l)\n{\n    if (l == MAXCOL)\n    {\n\tmsg_putchar('\\n');\n\tmsg_advance(24);\n    }\n    else\n\tmsg_advance(13 + l);\n}\n\n/*\n * Print the tag stack\n */\n    void\ndo_tags(exarg_T *eap UNUSED)\n{\n    int\t\ti;\n    char_u\t*name;\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n\n    // Highlight title\n    msg_puts_title(_(\"\\n  # TO tag         FROM line  in file/text\"));\n    for (i = 0; i < tagstacklen; ++i)\n    {\n\tif (tagstack[i].tagname != NULL)\n\t{\n\t    name = fm_getname(&(tagstack[i].fmark), 30);\n\t    if (name == NULL)\t    // file name not available\n\t\tcontinue;\n\n\t    msg_putchar('\\n');\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%c%2d %2d %-15s %5ld  \",\n\t\ti == tagstackidx ? '>' : ' ',\n\t\ti + 1,\n\t\ttagstack[i].cur_match + 1,\n\t\ttagstack[i].tagname,\n\t\ttagstack[i].fmark.mark.lnum);\n\t    msg_outtrans(IObuff);\n\t    msg_outtrans_attr(name, tagstack[i].fmark.fnum == curbuf->b_fnum\n\t\t\t\t\t\t\t? HL_ATTR(HLF_D) : 0);\n\t    vim_free(name);\n\t}\n\tout_flush();\t\t    // show one line at a time\n    }\n    if (tagstackidx == tagstacklen)\t// idx at top of stack\n\tmsg_puts(\"\\n>\");\n}\n\n/*\n * Compare two strings, for length \"len\", ignoring case the ASCII way.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n * Make sure case is folded to uppercase in comparison (like for 'sort -f')\n */\n    static int\ntag_strnicmp(char_u *s1, char_u *s2, size_t len)\n{\n    int\t\ti;\n\n    while (len > 0)\n    {\n\ti = (int)TOUPPER_ASC(*s1) - (int)TOUPPER_ASC(*s2);\n\tif (i != 0)\n\t    return i;\t\t\t// this character different\n\tif (*s1 == NUL)\n\t    break;\t\t\t// strings match until NUL\n\t++s1;\n\t++s2;\n\t--len;\n    }\n    return 0;\t\t\t\t// strings match\n}\n\n/*\n * Structure to hold info about the tag pattern being used.\n */\ntypedef struct\n{\n    char_u\t*pat;\t\t// the pattern\n    int\t\tlen;\t\t// length of pat[]\n    char_u\t*head;\t\t// start of pattern head\n    int\t\theadlen;\t// length of head[]\n    regmatch_T\tregmatch;\t// regexp program, may be NULL\n} pat_T;\n\n/*\n * Extract info from the tag search pattern \"pats->pat\".\n */\n    static void\nprepare_pats(pat_T *pats, int has_re)\n{\n    pats->head = pats->pat;\n    pats->headlen = pats->len;\n    if (has_re)\n    {\n\t// When the pattern starts with '^' or \"\\\\<\", binary searching can be\n\t// used (much faster).\n\tif (pats->pat[0] == '^')\n\t    pats->head = pats->pat + 1;\n\telse if (pats->pat[0] == '\\\\' && pats->pat[1] == '<')\n\t    pats->head = pats->pat + 2;\n\tif (pats->head == pats->pat)\n\t    pats->headlen = 0;\n\telse\n\t    for (pats->headlen = 0; pats->head[pats->headlen] != NUL;\n\t\t\t\t\t\t\t      ++pats->headlen)\n\t\tif (vim_strchr((char_u *)(magic_isset() ? \".[~*\\\\$\" : \"\\\\$\"),\n\t\t\t\t\t   pats->head[pats->headlen]) != NULL)\n\t\t    break;\n\tif (p_tl != 0 && pats->headlen > p_tl)\t// adjust for 'taglength'\n\t    pats->headlen = p_tl;\n    }\n\n    if (has_re)\n\tpats->regmatch.regprog = vim_regcomp(pats->pat,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n    else\n\tpats->regmatch.regprog = NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call the user-defined function to generate a list of tags used by\n * find_tags().\n *\n * Return OK if at least 1 tag has been successfully found,\n * NOTDONE if the function returns v:null, and FAIL otherwise.\n */\n    static int\nfind_tagfunc_tags(\n    char_u\t*pat,\t\t// pattern supplied to the user-defined function\n    garray_T\t*ga,\t\t// the tags will be placed here\n    int\t\t*match_count,\t// here the number of tags found will be placed\n    int\t\tflags,\t\t// flags from find_tags (TAG_*)\n    char_u\t*buf_ffname)\t// name of buffer for priority\n{\n    pos_T       save_pos;\n    list_T      *taglist;\n    listitem_T  *item;\n    int\t\tntags = 0;\n    int\t\tresult = FAIL;\n    typval_T\targs[4];\n    typval_T\trettv;\n    char_u      flagString[4];\n    dict_T\t*d;\n    taggy_T\t*tag = &curwin->w_tagstack[curwin->w_tagstackidx];\n\n    if (*curbuf->b_p_tfu == NUL || curbuf->b_tfu_cb.cb_name == NULL\n\t\t\t\t\t   || *curbuf->b_tfu_cb.cb_name == NUL)\n\treturn FAIL;\n\n    args[0].v_type = VAR_STRING;\n    args[0].vval.v_string = pat;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = flagString;\n\n    // create 'info' dict argument\n    if ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\treturn FAIL;\n    if (tag->user_data != NULL)\n\tdict_add_string(d, \"user_data\", tag->user_data);\n    if (buf_ffname != NULL)\n\tdict_add_string(d, \"buf_ffname\", buf_ffname);\n\n    ++d->dv_refcount;\n    args[2].v_type = VAR_DICT;\n    args[2].vval.v_dict = d;\n\n    args[3].v_type = VAR_UNKNOWN;\n\n    vim_snprintf((char *)flagString, sizeof(flagString),\n\t\t \"%s%s%s\",\n\t\t g_tag_at_cursor      ? \"c\": \"\",\n\t\t flags & TAG_INS_COMP ? \"i\": \"\",\n\t\t flags & TAG_REGEXP   ? \"r\": \"\");\n\n    save_pos = curwin->w_cursor;\n    result = call_callback(&curbuf->b_tfu_cb, 0, &rettv, 3, args);\n    curwin->w_cursor = save_pos;\t// restore the cursor position\n    --d->dv_refcount;\n\n    if (result == FAIL)\n\treturn FAIL;\n    if (rettv.v_type == VAR_SPECIAL && rettv.vval.v_number == VVAL_NULL)\n    {\n\tclear_tv(&rettv);\n\treturn NOTDONE;\n    }\n    if (rettv.v_type != VAR_LIST || !rettv.vval.v_list)\n    {\n\tclear_tv(&rettv);\n\temsg(_(e_invalid_return_value_from_tagfunc));\n\treturn FAIL;\n    }\n    taglist = rettv.vval.v_list;\n\n    FOR_ALL_LIST_ITEMS(taglist, item)\n    {\n\tchar_u\t\t*mfp;\n\tchar_u\t\t*res_name, *res_fname, *res_cmd, *res_kind;\n\tint\t\tlen;\n\tdict_iterator_T\titer;\n\tchar_u\t\t*dict_key;\n\ttypval_T\t*tv;\n\tint\t\thas_extra = 0;\n\tint\t\tname_only = flags & TAG_NAMES;\n\n\tif (item->li_tv.v_type != VAR_DICT)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n#ifdef FEAT_EMACS_TAGS\n\tlen = 3;\n#else\n\tlen = 2;\n#endif\n\tres_name = NULL;\n\tres_fname = NULL;\n\tres_cmd = NULL;\n\tres_kind = NULL;\n\n\tdict_iterate_start(&item->li_tv, &iter);\n\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t{\n\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\tcontinue;\n\n\t    len += (int)STRLEN(tv->vval.v_string) + 1;   // Space for \"\\tVALUE\"\n\t    if (!STRCMP(dict_key, \"name\"))\n\t    {\n\t\tres_name = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"filename\"))\n\t    {\n\t\tres_fname = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    if (!STRCMP(dict_key, \"cmd\"))\n\t    {\n\t\tres_cmd = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    has_extra = 1;\n\t    if (!STRCMP(dict_key, \"kind\"))\n\t    {\n\t\tres_kind = tv->vval.v_string;\n\t\tcontinue;\n\t    }\n\t    // Other elements will be stored as \"\\tKEY:VALUE\"\n\t    // Allocate space for the key and the colon\n\t    len += (int)STRLEN(dict_key) + 1;\n\t}\n\n\tif (has_extra)\n\t    len += 2;\t// need space for ;\"\n\n\tif (!res_name || !res_fname || !res_cmd)\n\t{\n\t    emsg(_(e_invalid_return_value_from_tagfunc));\n\t    break;\n\t}\n\n\tif (name_only)\n\t    mfp = vim_strsave(res_name);\n\telse\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\n\tif (mfp == NULL)\n\t    continue;\n\n\tif (!name_only)\n\t{\n\t    char_u *p = mfp;\n\n\t    *p++ = MT_GL_OTH + 1;   // mtt\n\t    *p++ = TAG_SEP;\t    // no tag file name\n#ifdef FEAT_EMACS_TAGS\n\t    *p++ = TAG_SEP;\n#endif\n\n\t    STRCPY(p, res_name);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_fname);\n\t    p += STRLEN(p);\n\n\t    *p++ = TAB;\n\t    STRCPY(p, res_cmd);\n\t    p += STRLEN(p);\n\n\t    if (has_extra)\n\t    {\n\t\tSTRCPY(p, \";\\\"\");\n\t\tp += STRLEN(p);\n\n\t\tif (res_kind)\n\t\t{\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, res_kind);\n\t\t    p += STRLEN(p);\n\t\t}\n\n\t\tdict_iterate_start(&item->li_tv, &iter);\n\t\twhile (NULL != (dict_key = dict_iterate_next(&iter, &tv)))\n\t\t{\n\t\t    if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL)\n\t\t\tcontinue;\n\n\t\t    if (!STRCMP(dict_key, \"name\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"filename\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"cmd\"))\n\t\t\tcontinue;\n\t\t    if (!STRCMP(dict_key, \"kind\"))\n\t\t\tcontinue;\n\n\t\t    *p++ = TAB;\n\t\t    STRCPY(p, dict_key);\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, \":\");\n\t\t    p += STRLEN(p);\n\t\t    STRCPY(p, tv->vval.v_string);\n\t\t    p += STRLEN(p);\n\t\t}\n\t    }\n\t}\n\n\t// Add all matches because tagfunc should do filtering.\n\tif (ga_grow(ga, 1) == OK)\n\t{\n\t    ((char_u **)(ga->ga_data))[ga->ga_len++] = mfp;\n\t    ++ntags;\n\t    result = OK;\n\t}\n\telse\n\t{\n\t    vim_free(mfp);\n\t    break;\n\t}\n    }\n\n    clear_tv(&rettv);\n\n    *match_count = ntags;\n    return result;\n}\n#endif\n\n/*\n * State information used during a tag search\n */\ntypedef struct\n{\n    tagsearch_state_T\tstate;\t\t// tag search state\n    int\t\tstop_searching;\t\t// stop when match found or error\n    pat_T\t*orgpat;\t\t// holds unconverted pattern info\n    char_u     *lbuf;\t\t\t// line buffer\n    int\t\tlbuf_size;\t\t// length of lbuf\n    char_u\t*tag_fname;\t\t// name of the tag file\n    FILE\t*fp;\t\t\t// current tags file pointer\n    int\t\tflags;\t\t\t// flags used for tag search\n    int\t\ttag_file_sorted;\t// !_TAG_FILE_SORTED value\n    int\t\tget_searchpat;\t\t// used for 'showfulltag'\n    int\t\thelp_only;\t\t// only search for help tags\n    int\t\tdid_open;\t\t// did open a tag file\n    int\t\tmincount;\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    int\t\tlinear;\t\t\t// do a linear search\n    vimconv_T\tvimconv;\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t\t// current file is emacs style\n    char_u\t*ebuf;\t\t\t// additional buffer for etag fname\n#endif\n#ifdef FEAT_MULTI_LANG\n    char_u\thelp_lang[3];\t\t// lang of current tags file\n    int\t\thelp_pri;\t\t// help language priority\n    char_u\t*help_lang_find;\t// lang to be found\n    int\t\tis_txt;\t\t\t// flag of file extension\n#endif\n    int\t\tmatch_count;\t\t// number of matches found\n    garray_T\tga_match[MT_COUNT];\t// stores matches in sequence\n    hashtab_T\tht_match[MT_COUNT];\t// stores matches by key\n} findtags_state_T;\n\n/*\n * Initialize the state used by find_tags().\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    static int\nfindtags_state_init(\n    findtags_state_T\t*st,\n    char_u\t\t*pat,\n    int\t\t\tflags,\n    int\t\t\tmincount)\n{\n    int\t\tmtt;\n\n    st->tag_fname = alloc(MAXPATHL + 1);\n    st->fp = NULL;\n    st->orgpat = ALLOC_ONE(pat_T);\n    st->orgpat->pat = pat;\n    st->orgpat->len = (int)STRLEN(pat);\n    st->orgpat->regmatch.regprog = NULL;\n    st->flags = flags;\n    st->tag_file_sorted = NUL;\n    st->help_only = (flags & TAG_HELP);\n    st->get_searchpat = FALSE;\n#ifdef FEAT_MULTI_LANG\n    st->help_lang[0] = NUL;\n    st->help_pri = 0;\n    st->help_lang_find = NULL;\n    st->is_txt = FALSE;\n#endif\n    st->did_open = FALSE;\n    st->mincount = mincount;\n    st->lbuf_size = LSIZE;\n    st->lbuf = alloc(st->lbuf_size);\n#ifdef FEAT_EMACS_TAGS\n    st->ebuf = alloc(LSIZE);\n#endif\n    st->match_count = 0;\n    st->stop_searching = FALSE;\n\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tga_init2(&st->ga_match[mtt], sizeof(char_u *), 100);\n\thash_init(&st->ht_match[mtt]);\n    }\n\n    // check for out of memory situation\n    if (st->tag_fname == NULL\n\t    || st->lbuf == NULL\n#ifdef FEAT_EMACS_TAGS\n\t    || st->ebuf == NULL\n#endif\n       )\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the state used by find_tags()\n */\n    static void\nfindtags_state_free(findtags_state_T *st)\n{\n    vim_free(st->tag_fname);\n    vim_free(st->lbuf);\n    vim_regfree(st->orgpat->regmatch.regprog);\n    vim_free(st->orgpat);\n#ifdef FEAT_EMACS_TAGS\n    vim_free(st->ebuf);\n#endif\n}\n\n#ifdef FEAT_MULTI_LANG\n/*\n * Initialize the language and priority used for searching tags in a Vim help\n * file.\n * Returns TRUE to process the help file for tags and FALSE to skip the file.\n */\n    static int\nfindtags_in_help_init(findtags_state_T *st)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    // Keep 'en' as the language if the file extension is '.txt'\n    if (st->is_txt)\n\tSTRCPY(st->help_lang, \"en\");\n    else\n    {\n\t// Prefer help tags according to 'helplang'.  Put the two-letter\n\t// language name in help_lang[].\n\ti = (int)STRLEN(st->tag_fname);\n\tif (i > 3 && st->tag_fname[i - 3] == '-')\n\t    vim_strncpy(st->help_lang, st->tag_fname + i - 2, 2);\n\telse\n\t    STRCPY(st->help_lang, \"en\");\n    }\n    // When searching for a specific language skip tags files for other\n    // languages.\n    if (st->help_lang_find != NULL\n\t    && STRICMP(st->help_lang, st->help_lang_find) != 0)\n\treturn FALSE;\n\n    // For CTRL-] in a help file prefer a match with the same language.\n    if ((st->flags & TAG_KEEP_LANG)\n\t    && st->help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && curbuf->b_fname[i - 1] == 'x'\n\t    && curbuf->b_fname[i - 4] == '.'\n\t    && STRNICMP(curbuf->b_fname + i - 3, st->help_lang, 2) == 0)\n\tst->help_pri = 0;\n    else\n    {\n\t// search for the language in 'helplang'\n\tst->help_pri = 1;\n\tfor (s = p_hlg; *s != NUL; ++s)\n\t{\n\t    if (STRNICMP(s, st->help_lang, 2) == 0)\n\t\tbreak;\n\t    ++st->help_pri;\n\t    if ((s = vim_strchr(s, ',')) == NULL)\n\t\tbreak;\n\t}\n\tif (s == NULL || *s == NUL)\n\t{\n\t    // Language not in 'helplang': use last, prefer English, unless\n\t    // found already.\n\t    ++st->help_pri;\n\t    if (STRICMP(st->help_lang, \"en\") != 0)\n\t\t++st->help_pri;\n\t}\n    }\n\n    return TRUE;\n}\n#endif\n\n#ifdef FEAT_EVAL\n/*\n * Use the function set in 'tagfunc' (if configured and enabled) to get the\n * tags.\n * Return OK if at least 1 tag has been successfully found, NOTDONE if the\n * 'tagfunc' is not used or the 'tagfunc' returns v:null and FAIL otherwise.\n */\n    static int\nfindtags_apply_tfu(findtags_state_T *st, char_u *pat, char_u *buf_ffname)\n{\n    int\t\tuse_tfu = ((st->flags & TAG_NO_TAGFUNC) == 0);\n    int\t\tretval;\n\n    if (!use_tfu || tfu_in_use || *curbuf->b_p_tfu == NUL)\n\treturn NOTDONE;\n\n    tfu_in_use = TRUE;\n    retval = find_tagfunc_tags(pat, st->ga_match, &st->match_count,\n\t\t\t\t\t\tst->flags, buf_ffname);\n    tfu_in_use = FALSE;\n\n    return retval;\n}\n#endif\n\n#ifdef FEAT_EMACS_TAGS\n/*\n * Stack for included emacs-tags file.\n * It has a fixed size, to truncate cyclic includes. jw\n */\n# define INCSTACK_SIZE 42\nstatic struct\n{\n    FILE\t*fp;\n    char_u\t*etag_fname;\n} incstack[INCSTACK_SIZE];\nstatic int incstack_idx = 0;\t// index in incstack\n\n/*\n * Free the emacs include tags file stack.\n */\n    static void\nemacs_tags_incstack_free(void)\n{\n    while (incstack_idx)\n    {\n\t--incstack_idx;\n\tfclose(incstack[incstack_idx].fp);\n\tincstack[incstack_idx].fp = NULL;\n\tVIM_CLEAR(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Emacs tags line with CTRL-L: New file name on next line.\n * The file name is followed by a ','.  Remember etag file name in ebuf.\n * The FILE pointer to the tags file is stored in 'st->fp'.  If another tags\n * file is included, then the FILE pointer to the new tags file is stored in\n * 'st->fp'. The old file pointer is saved in incstack.\n */\n    static void\nemacs_tags_new_filename(findtags_state_T *st)\n{\n    char_u\t*p;\n    char_u\t*fullpath_ebuf;\n\n    if (vim_fgets(st->ebuf, LSIZE, st->fp))\n\treturn;\n\n    for (p = st->ebuf; *p && *p != ','; p++)\n\t;\n    *p = NUL;\n\n    // check for an included tags file.\n    // atoi(p+1) is the number of bytes before the next ^L unless it is an\n    // include statement. Skip the included tags file if it exceeds the\n    // maximum.\n    if (STRNCMP(p + 1, \"include\", 7) != 0 || incstack_idx >= INCSTACK_SIZE)\n\treturn;\n\n    // Save current \"fp\" and \"tag_fname\" in the stack.\n    incstack[incstack_idx].etag_fname = vim_strsave(st->tag_fname);\n    if (incstack[incstack_idx].etag_fname == NULL)\n\treturn;\n\n    incstack[incstack_idx].fp = st->fp;\n    st->fp = NULL;\n\n    // Figure out \"tag_fname\" and \"fp\" to use for\n    // included file.\n    fullpath_ebuf = expand_tag_fname(st->ebuf, st->tag_fname, FALSE);\n    if (fullpath_ebuf != NULL)\n    {\n\tst->fp = mch_fopen((char *)fullpath_ebuf, \"r\");\n\tif (st->fp != NULL)\n\t{\n\t    if (STRLEN(fullpath_ebuf) > LSIZE)\n\t\tsemsg(_(e_tag_file_path_truncated_for_str), st->ebuf);\n\t    vim_strncpy(st->tag_fname, fullpath_ebuf, MAXPATHL);\n\t    ++incstack_idx;\n\t    st->is_etag = FALSE; // we can include anything\n\t}\n\tvim_free(fullpath_ebuf);\n    }\n    if (st->fp == NULL)\n    {\n\t// Can't open the included file, skip it and\n\t// restore old value of \"fp\".\n\tst->fp = incstack[incstack_idx].fp;\n\tvim_free(incstack[incstack_idx].etag_fname);\n    }\n}\n\n/*\n * Reached the end of an emacs-style tags file. If this is an included tags\n * file, then pop it from the incstack and continue processing the parent tags\n * file. Otherwise, processed all the tags.\n * Returns TRUE if an included tags file is popped and processing should\n * continue with the parent tags file. Returns FALSE to stop processing tags.\n */\n    static int\nemacs_tags_file_eof(findtags_state_T *st)\n{\n    if (!incstack_idx)\t// reached end of file. stop processing.\n\treturn FALSE;\n\n    // reached the end of an included tags file. pop it.\n    --incstack_idx;\n    fclose(st->fp);\t// end of this file ...\n    st->fp = incstack[incstack_idx].fp;\n    STRCPY(st->tag_fname, incstack[incstack_idx].etag_fname);\n    vim_free(incstack[incstack_idx].etag_fname);\n    st->is_etag = TRUE;\t// (only etags can include)\n\n    return TRUE;\n}\n\n/*\n * Parse a line from an emacs-style tags file.\n * Returns OK if the line is parsed successfully, returns FAIL if the line is\n * not terminated by a newline.\n */\n    static int\nemacs_tags_parse_line(char_u *lbuf, tagptrs_T *tagp)\n{\n    char_u\t*p_7f;\n    char_u\t*p;\n\n    // There are two formats for an emacs tag line:\n    // 1:  struct EnvBase ^?EnvBase^A139,4627\n    // 2: #define\tARPB_WILD_WORLD ^?153,5194\n    p_7f = vim_strchr(lbuf, 0x7f);\n    if (p_7f == NULL)\n    {\netag_fail:\n\tif (vim_strchr(lbuf, '\\n') != NULL)\n\t    return FAIL;\n\n\t// Truncated line.  Ignore it.\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    msg(_(\"Ignoring long line in tags file\"));\n\t    verbose_leave();\n\t}\n\ttagp->command = lbuf;\n\ttagp->tagname = lbuf;\n\ttagp->tagname_end = lbuf;\n\treturn OK;\n    }\n\n    // Find ^A.  If not found the line number is after the 0x7f\n    p = vim_strchr(p_7f, Ctrl_A);\n    if (p == NULL)\n\tp = p_7f + 1;\n    else\n\t++p;\n\n    if (!VIM_ISDIGIT(*p))\t    // check for start of line number\n\tgoto etag_fail;\n    tagp->command = p;\n\n    if (p[-1] == Ctrl_A)\t    // first format: explicit tagname given\n    {\n\ttagp->tagname = p_7f + 1;\n\ttagp->tagname_end = p - 1;\n    }\n    else\t\t\t    // second format: isolate tagname\n    {\n\t// find end of tagname\n\tfor (p = p_7f - 1; !vim_iswordc(*p); --p)\n\t    if (p == lbuf)\n\t\tgoto etag_fail;\n\ttagp->tagname_end = p + 1;\n\twhile (p >= lbuf && vim_iswordc(*p))\n\t    --p;\n\ttagp->tagname = p + 1;\n    }\n\n    return OK;\n}\n#endif\n\n/*\n * Read the next line from a tags file.\n * Returns TAGS_READ_SUCCESS if a tags line is successfully read and should be\n * processed.\n * Returns TAGS_READ_EOF if the end of file is reached.\n * Returns TAGS_READ_IGNORE if the current line should be ignored (used when\n * reached end of a emacs included tags file)\n */\n    static tags_read_status_T\nfindtags_get_next_line(findtags_state_T *st, tagsearch_info_T *sinfo_p)\n{\n    int\t\teof;\n    off_T\toffset;\n\n    // For binary search: compute the next offset to use.\n    if (st->state == TS_BINARY)\n    {\n\toffset = sinfo_p->low_offset + ((sinfo_p->high_offset\n\t\t\t\t\t\t- sinfo_p->low_offset) / 2);\n\tif (offset == sinfo_p->curr_offset)\n\t    return TAGS_READ_EOF; // End the binary search without a match.\n\telse\n\t    sinfo_p->curr_offset = offset;\n    }\n\n    // Skipping back (after a match during binary search).\n    else if (st->state == TS_SKIP_BACK)\n    {\n\tsinfo_p->curr_offset -= st->lbuf_size * 2;\n\tif (sinfo_p->curr_offset < 0)\n\t{\n\t    sinfo_p->curr_offset = 0;\n\t    rewind(st->fp);\n\t    st->state = TS_STEP_FORWARD;\n\t}\n    }\n\n    // When jumping around in the file, first read a line to find the\n    // start of the next line.\n    if (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n    {\n\t// Adjust the search file offset to the correct position\n\tsinfo_p->curr_offset_used = sinfo_p->curr_offset;\n\tvim_ignored = vim_fseek(st->fp, sinfo_p->curr_offset, SEEK_SET);\n\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\tif (!eof && sinfo_p->curr_offset != 0)\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    if (sinfo_p->curr_offset == sinfo_p->high_offset)\n\t    {\n\t\t// oops, gone a bit too far; try from low offset\n\t\tvim_ignored = vim_fseek(st->fp, sinfo_p->low_offset, SEEK_SET);\n\t\tsinfo_p->curr_offset = sinfo_p->low_offset;\n\t    }\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\t// skip empty and blank lines\n\twhile (!eof && vim_isblankline(st->lbuf))\n\t{\n\t    sinfo_p->curr_offset = vim_ftell(st->fp);\n\t    eof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t}\n\tif (eof)\n\t{\n\t    // Hit end of file.  Skip backwards.\n\t    st->state = TS_SKIP_BACK;\n\t    sinfo_p->match_offset = vim_ftell(st->fp);\n\t    sinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAGS_READ_IGNORE;\n\t}\n    }\n    // Not jumping around in the file: Read the next line.\n    else\n    {\n\t// skip empty and blank lines\n\tdo\n\t{\n#ifdef FEAT_CSCOPE\n\t    if (st->flags & TAG_CSCOPE)\n\t\teof = cs_fgets(st->lbuf, st->lbuf_size);\n\t    else\n#endif\n\t\teof = vim_fgets(st->lbuf, st->lbuf_size, st->fp);\n\t} while (!eof && vim_isblankline(st->lbuf));\n\n\tif (eof)\n\t{\n#ifdef FEAT_EMACS_TAGS\n\t    if (emacs_tags_file_eof(st) == TRUE)\n\t\t// an included tags file. Continue processing the parent\n\t\t// tags file.\n\t\treturn TAGS_READ_IGNORE;\n#endif\n\t    return TAGS_READ_EOF;\n\t}\n    }\n\n    return TAGS_READ_SUCCESS;\n}\n\n/*\n * Parse a tags file header line in 'st->lbuf'.\n * Returns TRUE if the current line in st->lbuf is not a tags header line and\n * should be parsed as a regular tag line. Returns FALSE if the line is a\n * header line and the next header line should be read.\n */\n    static int\nfindtags_hdr_parse(findtags_state_T *st)\n{\n    char_u\t*p;\n\n    // Header lines in a tags file start with \"!_TAG_\"\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) != 0)\n\t// Non-header item before the header, e.g. \"!\" itself.\n\treturn TRUE;\n\n    // Process the header line.\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_SORTED\\t\", 18) == 0)\n\tst->tag_file_sorted = st->lbuf[18];\n    if (STRNCMP(st->lbuf, \"!_TAG_FILE_ENCODING\\t\", 20) == 0)\n    {\n\t// Prepare to convert every line from the specified encoding to\n\t// 'encoding'.\n\tfor (p = st->lbuf + 20; *p > ' ' && *p < 127; ++p)\n\t    ;\n\t*p = NUL;\n\tconvert_setup(&st->vimconv, st->lbuf + 20, p_enc);\n    }\n\n    // Read the next line.  Unrecognized flags are ignored.\n    return FALSE;\n}\n\n/*\n * Handler to initialize the state when starting to process a new tags file.\n * Called in the TS_START state when finding tags from a tags file.\n * Returns TRUE if the line read from the tags file should be parsed and\n * FALSE if the line should be ignored.\n */\n    static int\nfindtags_start_state_handler(\n    findtags_state_T\t*st,\n    int\t\t\t*sortic,\n    tagsearch_info_T\t*sinfo_p)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tnoic = (st->flags & TAG_NOIC);\n    off_T\tfilesize;\n\n    // The header ends when the line sorts below \"!_TAG_\".  When case is\n    // folded lower case letters sort before \"_\".\n    if (STRNCMP(st->lbuf, \"!_TAG_\", 6) <= 0\n\t    || (st->lbuf[0] == '!' && ASCII_ISLOWER(st->lbuf[1])))\n\treturn findtags_hdr_parse(st);\n\n    // Headers ends.\n\n    // When there is no tag head, or ignoring case, need to do a\n    // linear search.\n    // When no \"!_TAG_\" is found, default to binary search.  If\n    // the tag file isn't sorted, the second loop will find it.\n    // When \"!_TAG_FILE_SORTED\" found: start binary search if\n    // flag set.\n    // For cscope, it's always linear.\n# ifdef FEAT_CSCOPE\n    if (st->linear || use_cscope)\n# else\n    if (st->linear)\n# endif\n\tst->state = TS_LINEAR;\n    else if (st->tag_file_sorted == NUL)\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '1')\n\tst->state = TS_BINARY;\n    else if (st->tag_file_sorted == '2')\n    {\n\tst->state = TS_BINARY;\n\t*sortic = TRUE;\n\tst->orgpat->regmatch.rm_ic = (p_ic || !noic);\n    }\n    else\n\tst->state = TS_LINEAR;\n\n    if (st->state == TS_BINARY && st->orgpat->regmatch.rm_ic && !*sortic)\n    {\n\t// Binary search won't work for ignoring case, use linear\n\t// search.\n\tst->linear = TRUE;\n\tst->state = TS_LINEAR;\n    }\n\n    // When starting a binary search, get the size of the file and\n    // compute the first offset.\n    if (st->state == TS_BINARY)\n    {\n\tif (vim_fseek(st->fp, 0L, SEEK_END) != 0)\n\t    // can't seek, don't use binary search\n\t    st->state = TS_LINEAR;\n\telse\n\t{\n\t    // Get the tag file size (don't use mch_fstat(), it's\n\t    // not portable).  Don't use lseek(), it doesn't work\n\t    // properly on MacOS Catalina.\n\t    filesize = vim_ftell(st->fp);\n\t    vim_ignored = vim_fseek(st->fp, 0L, SEEK_SET);\n\n\t    // Calculate the first read offset in the file.  Start\n\t    // the search in the middle of the file.\n\t    sinfo_p->low_offset = 0;\n\t    sinfo_p->low_char = 0;\n\t    sinfo_p->high_offset = filesize;\n\t    sinfo_p->curr_offset = 0;\n\t    sinfo_p->high_char = 0xff;\n\t}\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Parse a tag line read from a tags file.\n * Returns OK if a tags line is successfully parsed.\n * Returns FAIL if a format error is encountered.\n */\n    static int\nfindtags_parse_line(\n    findtags_state_T\t\t*st,\n    tagptrs_T\t\t\t*tagpp,\n    findtags_match_args_T\t*margs,\n    tagsearch_info_T\t\t*sinfo_p)\n{\n    int\t\tstatus;\n    int\t\ti;\n    int\t\tcmplen;\n    int\t\ttagcmp;\n\n    // Figure out where the different strings are in this line.\n    // For \"normal\" tags: Do a quick check if the tag matches.\n    // This speeds up tag searching a lot!\n    if (st->orgpat->headlen\n#ifdef FEAT_EMACS_TAGS\n\t    && !st->is_etag\n#endif\n       )\n    {\n\tCLEAR_FIELD(*tagpp);\n\ttagpp->tagname = st->lbuf;\n\ttagpp->tagname_end = vim_strchr(st->lbuf, TAB);\n\tif (tagpp->tagname_end == NULL)\n\t    // Corrupted tag line.\n\t    return TAG_MATCH_FAIL;\n\n\t// Skip this line if the length of the tag is different and\n\t// there is no regexp, or the tag is too short.\n\tcmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tif (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\t    cmplen = p_tl;\n\tif ((st->flags & TAG_REGEXP) && st->orgpat->headlen < cmplen)\n\t    cmplen = st->orgpat->headlen;\n\telse if (st->state == TS_LINEAR && st->orgpat->headlen != cmplen)\n\t    return TAG_MATCH_NEXT;\n\n\tif (st->state == TS_BINARY)\n\t{\n\t    // Simplistic check for unsorted tags file.\n\t    i = (int)tagpp->tagname[0];\n\t    if (margs->sortic)\n\t\ti = (int)TOUPPER_ASC(tagpp->tagname[0]);\n\t    if (i < sinfo_p->low_char || i > sinfo_p->high_char)\n\t\tmargs->sort_error = TRUE;\n\n\t    // Compare the current tag with the searched tag.\n\t    if (margs->sortic)\n\t\ttagcmp = tag_strnicmp(tagpp->tagname, st->orgpat->head,\n\t\t\t\t\t\t\t(size_t)cmplen);\n\t    else\n\t\ttagcmp = STRNCMP(tagpp->tagname, st->orgpat->head, cmplen);\n\n\t    // A match with a shorter tag means to search forward.\n\t    // A match with a longer tag means to search backward.\n\t    if (tagcmp == 0)\n\t    {\n\t\tif (cmplen < st->orgpat->headlen)\n\t\t    tagcmp = -1;\n\t\telse if (cmplen > st->orgpat->headlen)\n\t\t    tagcmp = 1;\n\t    }\n\n\t    if (tagcmp == 0)\n\t    {\n\t\t// We've located the tag, now skip back and search\n\t\t// forward until the first matching tag is found.\n\t\tst->state = TS_SKIP_BACK;\n\t\tsinfo_p->match_offset = sinfo_p->curr_offset;\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\t    if (tagcmp < 0)\n\t    {\n\t\tsinfo_p->curr_offset = vim_ftell(st->fp);\n\t\tif (sinfo_p->curr_offset < sinfo_p->high_offset)\n\t\t{\n\t\t    sinfo_p->low_offset = sinfo_p->curr_offset;\n\t\t    if (margs->sortic)\n\t\t\tsinfo_p->low_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\t    else\n\t\t\tsinfo_p->low_char = tagpp->tagname[0];\n\t\t    return TAG_MATCH_NEXT;\n\t\t}\n\t    }\n\t    if (tagcmp > 0 && sinfo_p->curr_offset != sinfo_p->high_offset)\n\t    {\n\t\tsinfo_p->high_offset = sinfo_p->curr_offset;\n\t\tif (margs->sortic)\n\t\t    sinfo_p->high_char = TOUPPER_ASC(tagpp->tagname[0]);\n\t\telse\n\t\t    sinfo_p->high_char = tagpp->tagname[0];\n\t\treturn TAG_MATCH_NEXT;\n\t    }\n\n\t    // No match yet and are at the end of the binary search.\n\t    return TAG_MATCH_STOP;\n\t}\n\telse if (st->state == TS_SKIP_BACK)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\tst->state = TS_STEP_FORWARD;\n\t    else\n\t\t// Have to skip back more.  Restore the curr_offset\n\t\t// used, otherwise we get stuck at a long line.\n\t\tsinfo_p->curr_offset = sinfo_p->curr_offset_used;\n\t    return TAG_MATCH_NEXT;\n\t}\n\telse if (st->state == TS_STEP_FORWARD)\n\t{\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t    {\n\t\tif ((off_T)vim_ftell(st->fp) > sinfo_p->match_offset)\n\t\t    return TAG_MATCH_STOP;\t// past last match\n\t\telse\n\t\t    return TAG_MATCH_NEXT;\t// before first match\n\t    }\n\t}\n\telse\n\t    // skip this match if it can't match\n\t    if (MB_STRNICMP(tagpp->tagname, st->orgpat->head, cmplen) != 0)\n\t\treturn TAG_MATCH_NEXT;\n\n\t// Can be a matching tag, isolate the file name and command.\n\ttagpp->fname = tagpp->tagname_end + 1;\n\ttagpp->fname_end = vim_strchr(tagpp->fname, TAB);\n\tif (tagpp->fname_end == NULL)\n\t    status = FAIL;\n\telse\n\t{\n\t    tagpp->command = tagpp->fname_end + 1;\n\t    status = OK;\n\t}\n    }\n    else\n\tstatus = parse_tag_line(st->lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp);\n\n    if (status == FAIL)\n\treturn TAG_MATCH_FAIL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (st->is_etag)\n\ttagpp->fname = st->ebuf;\n#endif\n\n    return TAG_MATCH_SUCCESS;\n}\n\n/*\n * Initialize the structure used for tag matching.\n */\n    static void\nfindtags_matchargs_init(findtags_match_args_T *margs, int flags)\n{\n    margs->matchoff = 0;\t\t\t// match offset\n    margs->match_re = FALSE;\t\t\t// match with regexp\n    margs->match_no_ic = FALSE;\t\t\t// matches with case\n    margs->has_re = (flags & TAG_REGEXP);\t// regexp used\n    margs->sortic = FALSE;\t\t\t// tag file sorted in nocase\n    margs->sort_error = FALSE;\t\t\t// tags file not sorted\n}\n\n/*\n * Compares the tag name in 'tagpp->tagname' with a search pattern in\n * 'st->orgpat.head'.\n * Returns TAG_MATCH_SUCCESS if the tag matches, TAG_MATCH_FAIL if the tag\n * doesn't match, TAG_MATCH_NEXT to look for the next matching tag (used in a\n * binary search) and TAG_MATCH_STOP if all the tags are processed without a\n * match. Uses the values in 'margs' for doing the comparison.\n */\n    static tagmatch_status_T\nfindtags_match_tag(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T *margs)\n{\n    int\t\tmatch = FALSE;\n    int\t\tcmplen;\n\n    // First try matching with the pattern literally (also when it is\n    // a regexp).\n    cmplen = (int)(tagpp->tagname_end - tagpp->tagname);\n    if (p_tl != 0 && cmplen > p_tl)\t    // adjust for 'taglength'\n\tcmplen = p_tl;\n    // if tag length does not match, don't try comparing\n    if (st->orgpat->len != cmplen)\n\tmatch = FALSE;\n    else\n    {\n\tif (st->orgpat->regmatch.rm_ic)\n\t{\n\t    match =\n\t\t(MB_STRNICMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t    if (match)\n\t\tmargs->match_no_ic =\n\t\t    (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n\t}\n\telse\n\t    match = (STRNCMP(tagpp->tagname, st->orgpat->pat, cmplen) == 0);\n    }\n\n    // Has a regexp: Also find tags matching regexp.\n    margs->match_re = FALSE;\n    if (!match && st->orgpat->regmatch.regprog != NULL)\n    {\n\tint\tcc;\n\n\tcc = *tagpp->tagname_end;\n\t*tagpp->tagname_end = NUL;\n\tmatch = vim_regexec(&st->orgpat->regmatch, tagpp->tagname, (colnr_T)0);\n\tif (match)\n\t{\n\t    margs->matchoff = (int)(st->orgpat->regmatch.startp[0] -\n\t\t\t\t\t\t\ttagpp->tagname);\n\t    if (st->orgpat->regmatch.rm_ic)\n\t    {\n\t\tst->orgpat->regmatch.rm_ic = FALSE;\n\t\tmargs->match_no_ic = vim_regexec(&st->orgpat->regmatch,\n\t\t\ttagpp->tagname, (colnr_T)0);\n\t\tst->orgpat->regmatch.rm_ic = TRUE;\n\t    }\n\t}\n\t*tagpp->tagname_end = cc;\n\tmargs->match_re = TRUE;\n    }\n\n    return match ? TAG_MATCH_SUCCESS : TAG_MATCH_FAIL;\n}\n\n/*\n * Convert the encoding of a line read from a tags file in 'st->lbuf'.\n * Converting the pattern from 'enc' to the tags file encoding doesn't work,\n * because characters are not recognized. The converted line is saved in\n * st->lbuf.\n */\n    static void\nfindtags_string_convert(findtags_state_T *st)\n{\n    char_u\t*conv_line;\n    int\t\tlen;\n\n    conv_line = string_convert(&st->vimconv, st->lbuf, NULL);\n    if (conv_line == NULL)\n\treturn;\n\n    // Copy or swap lbuf and conv_line.\n    len = (int)STRLEN(conv_line) + 1;\n    if (len > st->lbuf_size)\n    {\n\tvim_free(st->lbuf);\n\tst->lbuf = conv_line;\n\tst->lbuf_size = len;\n    }\n    else\n    {\n\tSTRCPY(st->lbuf, conv_line);\n\tvim_free(conv_line);\n    }\n}\n\n/*\n * Add a matching tag found in a tags file to st->ht_match and st->ga_match.\n * Returns OK if successfully added the match and FAIL on memory allocation\n * failure.\n */\n    static int\nfindtags_add_match(\n    findtags_state_T\t*st,\n    tagptrs_T\t\t*tagpp,\n    findtags_match_args_T   *margs,\n    char_u\t\t*buf_ffname,\n    hash_T\t\t*hash)\n{\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    int\t\tmtt;\n    int\t\tlen = 0;\n    int\t\tis_current;\t\t// file name matches\n    int\t\tis_static;\t\t// current tag line is static\n    char_u\t*mfp;\n    char_u\t*p;\n    char_u\t*s;\n\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n    {\n\t// Don't change the ordering, always use the same table.\n\tmtt = MT_GL_OTH;\n    }\n    else\n#endif\n    {\n\t// Decide in which array to store this match.\n\tis_current = test_for_current(\n#ifdef FEAT_EMACS_TAGS\n\t\tst->is_etag,\n#endif\n\t\ttagpp->fname, tagpp->fname_end, st->tag_fname, buf_ffname);\n#ifdef FEAT_EMACS_TAGS\n\tis_static = FALSE;\n\tif (!st->is_etag)\t// emacs tags are never static\n#endif\n\t    is_static = test_for_static(tagpp);\n\n\t// decide in which of the sixteen tables to store this\n\t// match\n\tif (is_static)\n\t{\n\t    if (is_current)\n\t\tmtt = MT_ST_CUR;\n\t    else\n\t\tmtt = MT_ST_OTH;\n\t}\n\telse\n\t{\n\t    if (is_current)\n\t\tmtt = MT_GL_CUR;\n\t    else\n\t\tmtt = MT_GL_OTH;\n\t}\n\tif (st->orgpat->regmatch.rm_ic && !margs->match_no_ic)\n\t    mtt += MT_IC_OFF;\n\tif (margs->match_re)\n\t    mtt += MT_RE_OFF;\n    }\n\n    // Add the found match in ht_match[mtt] and ga_match[mtt].\n    // Store the info we need later, which depends on the kind of\n    // tags we are dealing with.\n    if (st->help_only)\n    {\n#ifdef FEAT_MULTI_LANG\n# define ML_EXTRA 3\n#else\n# define ML_EXTRA 0\n#endif\n\t// Append the help-heuristic number after the tagname, for\n\t// sorting it later.  The heuristic is ignored for\n\t// detecting duplicates.\n\t// The format is {tagname}@{lang}NUL{heuristic}NUL\n\t*tagpp->tagname_end = NUL;\n\tlen = (int)(tagpp->tagname_end - tagpp->tagname);\n\tmfp = alloc(sizeof(char_u) + len + 10 + ML_EXTRA + 1);\n\tif (mfp != NULL)\n\t{\n\t    int heuristic;\n\n\t    p = mfp;\n\t    STRCPY(p, tagpp->tagname);\n#ifdef FEAT_MULTI_LANG\n\t    p[len] = '@';\n\t    STRCPY(p + len + 1, st->help_lang);\n#endif\n\n\t    heuristic = help_heuristic(tagpp->tagname,\n\t\t\t\tmargs->match_re ? margs->matchoff : 0,\n\t\t\t\t!margs->match_no_ic);\n#ifdef FEAT_MULTI_LANG\n\t    heuristic += st->help_pri;\n#endif\n\t    sprintf((char *)p + len + 1 + ML_EXTRA, \"%06d\",\n\t\t    heuristic);\n\t}\n\t*tagpp->tagname_end = TAB;\n    }\n    else if (name_only)\n    {\n\tif (st->get_searchpat)\n\t{\n\t    char_u *temp_end = tagpp->command;\n\n\t    if (*temp_end == '/')\n\t\twhile (*temp_end && *temp_end != '\\r'\n\t\t\t&& *temp_end != '\\n'\n\t\t\t&& *temp_end != '$')\n\t\t    temp_end++;\n\n\t    if (tagpp->command + 2 < temp_end)\n\t    {\n\t\tlen = (int)(temp_end - tagpp->command - 2);\n\t\tmfp = alloc(len + 2);\n\t\tif (mfp != NULL)\n\t\t    vim_strncpy(mfp, tagpp->command + 2, len);\n\t    }\n\t    else\n\t\tmfp = NULL;\n\t    st->get_searchpat = FALSE;\n\t}\n\telse\n\t{\n\t    len = (int)(tagpp->tagname_end - tagpp->tagname);\n\t    mfp = alloc(sizeof(char_u) + len + 1);\n\t    if (mfp != NULL)\n\t\tvim_strncpy(mfp, tagpp->tagname, len);\n\n\t    // if wanted, re-read line to get long form too\n\t    if (State & MODE_INSERT)\n\t\tst->get_searchpat = p_sft;\n\t}\n    }\n    else\n    {\n\tsize_t tag_fname_len = STRLEN(st->tag_fname);\n#ifdef FEAT_EMACS_TAGS\n\tsize_t ebuf_len = 0;\n#endif\n\n\t// Save the tag in a buffer.\n\t// Use 0x02 to separate fields (Can't use NUL because the\n\t// hash key is terminated by NUL, or Ctrl_A because that is\n\t// part of some Emacs tag files -- see parse_tag_line).\n\t// Emacs tag: <mtt><tag_fname><0x02><ebuf><0x02><lbuf><NUL>\n\t// other tag: <mtt><tag_fname><0x02><0x02><lbuf><NUL>\n\t// without Emacs tags: <mtt><tag_fname><0x02><lbuf><NUL>\n\t// Here <mtt> is the \"mtt\" value plus 1 to avoid NUL.\n\tlen = (int)tag_fname_len + (int)STRLEN(st->lbuf) + 3;\n#ifdef FEAT_EMACS_TAGS\n\tif (st->is_etag)\n\t{\n\t    ebuf_len = STRLEN(st->ebuf);\n\t    len += (int)ebuf_len + 1;\n\t}\n\telse\n\t    ++len;\n#endif\n\tmfp = alloc(sizeof(char_u) + len + 1);\n\tif (mfp != NULL)\n\t{\n\t    p = mfp;\n\t    p[0] = mtt + 1;\n\t    STRCPY(p + 1, st->tag_fname);\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Ignore differences in slashes, avoid adding\n\t    // both path/file and path\\file.\n\t    slash_adjust(p + 1);\n#endif\n\t    p[tag_fname_len + 1] = TAG_SEP;\n\t    s = p + 1 + tag_fname_len + 1;\n#ifdef FEAT_EMACS_TAGS\n\t    if (st->is_etag)\n\t    {\n\t\tSTRCPY(s, st->ebuf);\n\t\ts[ebuf_len] = TAG_SEP;\n\t\ts += ebuf_len + 1;\n\t    }\n\t    else\n\t\t*s++ = TAG_SEP;\n#endif\n\t    STRCPY(s, st->lbuf);\n\t}\n    }\n\n    if (mfp != NULL)\n    {\n\thashitem_T\t*hi;\n\n\t// Don't add identical matches.\n\t// Add all cscope tags, because they are all listed.\n\t// \"mfp\" is used as a hash key, there is a NUL byte to end\n\t// the part that matters for comparing, more bytes may\n\t// follow after it.  E.g. help tags store the priority\n\t// after the NUL.\n#ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    ++*hash;\n\telse\n#endif\n\t    *hash = hash_hash(mfp);\n\thi = hash_lookup(&st->ht_match[mtt], mfp, *hash);\n\tif (HASHITEM_EMPTY(hi))\n\t{\n\t    if (hash_add_item(&st->ht_match[mtt], hi, mfp, *hash) == FAIL\n\t\t    || ga_grow(&st->ga_match[mtt], 1) != OK)\n\t    {\n\t\t// Out of memory! Just forget about the rest.\n\t\tst->stop_searching = TRUE;\n\t\treturn FAIL;\n\t    }\n\n\t    ((char_u **)(st->ga_match[mtt].ga_data))\n\t\t[st->ga_match[mtt].ga_len++] = mfp;\n\t    st->match_count++;\n\t}\n\telse\n\t    // duplicate tag, drop it\n\t    vim_free(mfp);\n    }\n\n    return OK;\n}\n\n/*\n * Read and get all the tags from file st->tag_fname.\n * Sets 'st->stop_searching' to TRUE to stop searching for additional tags.\n */\n    static void\nfindtags_get_all_tags(\n    findtags_state_T\t\t*st,\n    findtags_match_args_T\t*margs,\n    char_u\t\t\t*buf_ffname)\n{\n    tagptrs_T\t\ttagp;\n    tagsearch_info_T\tsearch_info;\n    int\t\t\tretval;\n#ifdef FEAT_CSCOPE\n    int\t\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n    hash_T\t\thash = 0;\n\n    // This is only to avoid a compiler warning for using search_info\n    // uninitialised.\n    CLEAR_FIELD(search_info);\n\n    // Read and parse the lines in the file one by one\n    for (;;)\n    {\n\t// check for CTRL-C typed, more often when jumping around\n\tif (st->state == TS_BINARY || st->state == TS_SKIP_BACK)\n\t    line_breakcheck();\n\telse\n\t    fast_breakcheck();\n\tif ((st->flags & TAG_INS_COMP))\t// Double brackets for gcc\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\t// When mincount is TAG_MANY, stop when enough matches have been\n\t// found (for completion).\n\tif (st->mincount == TAG_MANY && st->match_count >= TAG_MANY)\n\t{\n\t    st->stop_searching = TRUE;\n\t    break;\n\t}\n\tif (st->get_searchpat)\n\t    goto line_read_in;\n\n\tretval = findtags_get_next_line(st, &search_info);\n\tif (retval == TAGS_READ_IGNORE)\n\t    continue;\n\tif (retval == TAGS_READ_EOF)\n\t    break;\n\nline_read_in:\n\n\tif (st->vimconv.vc_type != CONV_NONE)\n\t    findtags_string_convert(st);\n\n#ifdef FEAT_EMACS_TAGS\n\t// Emacs tags line with CTRL-L: New file name on next line.\n\t// The file name is followed by a ','.\n\t// Remember etag file name in ebuf.\n\tif (*st->lbuf == Ctrl_L\n# ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n# endif\n\t   )\n\t{\n\t    st->is_etag = TRUE;\t\t// in case at the start\n\t    st->state = TS_LINEAR;\n\t    emacs_tags_new_filename(st);\n\t    continue;\n\t}\n#endif\n\n\t// When still at the start of the file, check for Emacs tags file\n\t// format, and for \"not sorted\" flag.\n\tif (st->state == TS_START)\n\t{\n\t    if (findtags_start_state_handler(st, &margs->sortic, &search_info) == FALSE)\n\t\tcontinue;\n\t}\n\n\t// When the line is too long the NUL will not be in the\n\t// last-but-one byte (see vim_fgets()).\n\t// Has been reported for Mozilla JS with extremely long names.\n\t// In that case we need to increase lbuf_size.\n\tif (st->lbuf[st->lbuf_size - 2] != NUL\n#ifdef FEAT_CSCOPE\n\t\t&& !use_cscope\n#endif\n\t   )\n\t{\n\t    st->lbuf_size *= 2;\n\t    vim_free(st->lbuf);\n\t    st->lbuf = alloc(st->lbuf_size);\n\t    if (st->lbuf == NULL)\n\t    {\n\t\tif (st->fp != NULL)\n\t\t    fclose(st->fp);\n\t\tst->fp = NULL;\n\t\tst->stop_searching = TRUE;\n\t\treturn;\n\t    }\n\n\t    if (st->state == TS_STEP_FORWARD || st->state == TS_LINEAR)\n\t\t// Seek to the same position to read the same line again\n\t\tvim_ignored = vim_fseek(st->fp, search_info.curr_offset,\n\t\t\t\t\t\t\t\t     SEEK_SET);\n\t    // this will try the same thing again, make sure the offset is\n\t    // different\n\t    search_info.curr_offset = 0;\n\t    continue;\n\t}\n\n\tretval = findtags_parse_line(st, &tagp, margs, &search_info);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\tif (retval == TAG_MATCH_FAIL)\n\t{\n\t    semsg(_(e_format_error_in_tags_file_str), st->tag_fname);\n#ifdef FEAT_CSCOPE\n\t    if (!use_cscope)\n#endif\n\t\tsemsg(_(\"Before byte %ld\"), (long)vim_ftell(st->fp));\n\t    st->stop_searching = TRUE;\n\t    return;\n\t}\n\n\tretval = findtags_match_tag(st, &tagp, margs);\n\tif (retval == TAG_MATCH_NEXT)\n\t    continue;\n\tif (retval == TAG_MATCH_STOP)\n\t    break;\n\n\t// If a match is found, add it to ht_match[] and ga_match[].\n\tif (retval == TAG_MATCH_SUCCESS)\n\t{\n\t    if (findtags_add_match(st, &tagp, margs, buf_ffname, &hash)\n\t\t\t\t\t\t\t\t== FAIL)\n\t\tbreak;\n\t}\n    } // forever\n}\n\n/*\n * Search for tags matching 'st->orgpat.pat' in the 'st->tag_fname' tags file.\n * Information needed to search for the tags is in the 'st' state structure.\n * The matching tags are returned in 'st'. If an error is encountered, then\n * 'st->stop_searching' is set to TRUE.\n */\n    static void\nfindtags_in_file(findtags_state_T *st, char_u *buf_ffname)\n{\n    findtags_match_args_T margs;\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (st->flags & TAG_CSCOPE);\n#endif\n\n    st->vimconv.vc_type = CONV_NONE;\n    st->tag_file_sorted = NUL;\n    st->fp = NULL;\n    findtags_matchargs_init(&margs, st->flags);\n\n    // A file that doesn't exist is silently ignored.  Only when not a\n    // single file is found, an error message is given (further on).\n#ifdef FEAT_CSCOPE\n    if (use_cscope)\n\tst->fp = NULL;\t    // avoid GCC warning\n    else\n#endif\n    {\n#ifdef FEAT_MULTI_LANG\n\tif (curbuf->b_help)\n\t{\n\t    if (!findtags_in_help_init(st))\n\t\treturn;\n\t}\n#endif\n\n\tst->fp = mch_fopen((char *)st->tag_fname, \"r\");\n\tif (st->fp == NULL)\n\t    return;\n\n\tif (p_verbose >= 5)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Searching tags file %s\"), st->tag_fname);\n\t    verbose_leave();\n\t}\n    }\n    st->did_open = TRUE;\t// remember that we found at least one file\n\n    st->state = TS_START;\t// we're at the start of the file\n#ifdef FEAT_EMACS_TAGS\n    st->is_etag = FALSE;\t// default is: not emacs style\n#endif\n\n    // Read and parse the lines in the file one by one\n    findtags_get_all_tags(st, &margs, buf_ffname);\n\n    if (st->fp != NULL)\n    {\n\tfclose(st->fp);\n\tst->fp = NULL;\n    }\n#ifdef FEAT_EMACS_TAGS\n    emacs_tags_incstack_free();\n#endif\n    if (st->vimconv.vc_type != CONV_NONE)\n\tconvert_setup(&st->vimconv, NULL, NULL);\n\n    if (margs.sort_error)\n\tsemsg(_(e_tags_file_not_sorted_str), st->tag_fname);\n\n    // Stop searching if sufficient tags have been found.\n    if (st->match_count >= st->mincount)\n\tst->stop_searching = TRUE;\n}\n\n/*\n * Copy the tags found by find_tags() to 'matchesp'.\n * Returns the number of matches copied.\n */\n    static int\nfindtags_copy_matches(findtags_state_T *st, char_u ***matchesp)\n{\n    int\t\tname_only = (st->flags & TAG_NAMES);\n    char_u\t**matches;\n    int\t\tmtt;\n    int\t\ti;\n    char_u\t*mfp;\n    char_u\t*p;\n\n    if (st->match_count > 0)\n\tmatches = ALLOC_MULT(char_u *, st->match_count);\n    else\n\tmatches = NULL;\n    st->match_count = 0;\n    for (mtt = 0; mtt < MT_COUNT; ++mtt)\n    {\n\tfor (i = 0; i < st->ga_match[mtt].ga_len; ++i)\n\t{\n\t    mfp = ((char_u **)(st->ga_match[mtt].ga_data))[i];\n\t    if (matches == NULL)\n\t\tvim_free(mfp);\n\t    else\n\t    {\n\t\tif (!name_only)\n\t\t{\n\t\t    // Change mtt back to zero-based.\n\t\t    *mfp = *mfp - 1;\n\n\t\t    // change the TAG_SEP back to NUL\n\t\t    for (p = mfp + 1; *p != NUL; ++p)\n\t\t\tif (*p == TAG_SEP)\n\t\t\t    *p = NUL;\n\t\t}\n\t\tmatches[st->match_count++] = mfp;\n\t    }\n\t}\n\n\tga_clear(&st->ga_match[mtt]);\n\thash_clear(&st->ht_match[mtt]);\n    }\n\n    *matchesp = matches;\n    return st->match_count;\n}\n\n/*\n * find_tags() - search for tags in tags files\n *\n * Return FAIL if search completely failed (*num_matches will be 0, *matchesp\n * will be NULL), OK otherwise.\n *\n * Priority depending on which type of tag is recognized:\n *  6.\tA static or global tag with a full matching tag for the current file.\n *  5.\tA global tag with a full matching tag for another file.\n *  4.\tA static tag with a full matching tag for another file.\n *  3.\tA static or global tag with an ignore-case matching tag for the\n *\tcurrent file.\n *  2.\tA global tag with an ignore-case matching tag for another file.\n *  1.\tA static tag with an ignore-case matching tag for another file.\n *\n * Tags in an emacs-style tags file are always global.\n *\n * flags:\n * TAG_HELP\t  only search for help tags\n * TAG_NAMES\t  only return name of tag\n * TAG_REGEXP\t  use \"pat\" as a regexp\n * TAG_NOIC\t  don't always ignore case\n * TAG_KEEP_LANG  keep language\n * TAG_CSCOPE\t  use cscope results for tags\n * TAG_NO_TAGFUNC do not call the 'tagfunc' function\n */\n    int\nfind_tags(\n    char_u\t*pat,\t\t\t// pattern to search for\n    int\t\t*num_matches,\t\t// return: number of matches found\n    char_u\t***matchesp,\t\t// return: array of matches found\n    int\t\tflags,\n    int\t\tmincount,\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    char_u\t*buf_ffname)\t\t// name of buffer for priority\n{\n    findtags_state_T\tst;\n    tagname_T\ttn;\t\t\t// info for get_tagfname()\n    int\t\tfirst_file;\t\t// trying first tag file\n    int\t\tretval = FAIL;\t\t// return value\n    int\t\tround;\n\n    int\t\tsave_emsg_off;\n\n    int\t\thelp_save;\n#ifdef FEAT_MULTI_LANG\n    int\t\ti;\n    char_u\t*saved_pat = NULL;\t\t// copy of pat[]\n#endif\n\n    int\t\tfindall = (mincount == MAXCOL || mincount == TAG_MANY);\n\t\t\t\t\t\t// find all matching tags\n    int\t\thas_re = (flags & TAG_REGEXP);\t// regexp used\n    int\t\tnoic = (flags & TAG_NOIC);\n#ifdef FEAT_CSCOPE\n    int\t\tuse_cscope = (flags & TAG_CSCOPE);\n#endif\n    int\t\tverbose = (flags & TAG_VERBOSE);\n    int\t\tsave_p_ic = p_ic;\n\n    /*\n     * Change the value of 'ignorecase' according to 'tagcase' for the\n     * duration of this function.\n     */\n    switch (curbuf->b_tc_flags ? curbuf->b_tc_flags : tc_flags)\n    {\n\tcase TC_FOLLOWIC:\t\t break;\n\tcase TC_IGNORE:    p_ic = TRUE;  break;\n\tcase TC_MATCH:     p_ic = FALSE; break;\n\tcase TC_FOLLOWSCS: p_ic = ignorecase(pat); break;\n\tcase TC_SMART:     p_ic = ignorecase_opt(pat, TRUE, TRUE); break;\n    }\n\n    help_save = curbuf->b_help;\n\n    if (findtags_state_init(&st, pat, flags, mincount) == FAIL)\n\tgoto findtag_end;\n\n#ifdef FEAT_CSCOPE\n    STRCPY(st.tag_fname, \"from cscope\");\t// for error messages\n#endif\n\n    /*\n     * Initialize a few variables\n     */\n    if (st.help_only)\t\t\t\t// want tags from help file\n\tcurbuf->b_help = TRUE;\t\t\t// will be restored later\n#ifdef FEAT_CSCOPE\n    else if (use_cscope)\n    {\n\t// Make sure we don't mix help and cscope, confuses Coverity.\n\tst.help_only = FALSE;\n\tcurbuf->b_help = FALSE;\n    }\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    if (curbuf->b_help)\n    {\n\t// When \"@ab\" is specified use only the \"ab\" language, otherwise\n\t// search all languages.\n\tif (st.orgpat->len > 3 && pat[st.orgpat->len - 3] == '@'\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 2])\n\t\t\t\t&& ASCII_ISALPHA(pat[st.orgpat->len - 1]))\n\t{\n\t    saved_pat = vim_strnsave(pat, st.orgpat->len - 3);\n\t    if (saved_pat != NULL)\n\t    {\n\t\tst.help_lang_find = &pat[st.orgpat->len - 2];\n\t\tst.orgpat->pat = saved_pat;\n\t\tst.orgpat->len -= 3;\n\t    }\n\t}\n    }\n#endif\n    if (p_tl != 0 && st.orgpat->len > p_tl)\t// adjust for 'taglength'\n\tst.orgpat->len = p_tl;\n\n    save_emsg_off = emsg_off;\n    emsg_off = TRUE;  // don't want error for invalid RE here\n    prepare_pats(st.orgpat, has_re);\n    emsg_off = save_emsg_off;\n    if (has_re && st.orgpat->regmatch.regprog == NULL)\n\tgoto findtag_end;\n\n#ifdef FEAT_EVAL\n    retval = findtags_apply_tfu(&st, pat, buf_ffname);\n    if (retval != NOTDONE)\n\tgoto findtag_end;\n\n    // re-initialize the default return value\n    retval = FAIL;\n#endif\n\n#ifdef FEAT_MULTI_LANG\n    // Set a flag if the file extension is .txt\n    if ((flags & TAG_KEEP_LANG)\n\t    && st.help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && STRICMP(curbuf->b_fname + i - 4, \".txt\") == 0)\n\tst.is_txt = TRUE;\n#endif\n\n    /*\n     * When finding a specified number of matches, first try with matching\n     * case, so binary search can be used, and try ignore-case matches in a\n     * second loop.\n     * When finding all matches, 'tagbsearch' is off, or there is no fixed\n     * string to look for, ignore case right away to avoid going though the\n     * tags files twice.\n     * When the tag file is case-fold sorted, it is either one or the other.\n     * Only ignore case when TAG_NOIC not used or 'ignorecase' set.\n     */\n    st.orgpat->regmatch.rm_ic = ((p_ic || !noic)\n\t\t\t&& (findall || st.orgpat->headlen == 0 || !p_tbs));\n    for (round = 1; round <= 2; ++round)\n    {\n\tst.linear = (st.orgpat->headlen == 0 || !p_tbs || round == 2);\n\n      /*\n       * Try tag file names from tags option one by one.\n       */\n      for (first_file = TRUE;\n#ifdef FEAT_CSCOPE\n\t    use_cscope ||\n#endif\n\t\tget_tagfname(&tn, first_file, st.tag_fname) == OK;\n\t\t\t\t\t\t\t   first_file = FALSE)\n      {\n\t  findtags_in_file(&st, buf_ffname);\n\t  if (st.stop_searching\n#ifdef FEAT_CSCOPE\n\t\t  || use_cscope\n#endif\n\t     )\n\t  {\n\t      retval = OK;\n\t      break;\n\t  }\n      } // end of for-each-file loop\n\n#ifdef FEAT_CSCOPE\n\tif (!use_cscope)\n#endif\n\t    tagname_free(&tn);\n\n\t// stop searching when already did a linear search, or when TAG_NOIC\n\t// used, and 'ignorecase' not set or already did case-ignore search\n\tif (st.stop_searching || st.linear || (!p_ic && noic) ||\n\t\t\t\t\t\tst.orgpat->regmatch.rm_ic)\n\t    break;\n# ifdef FEAT_CSCOPE\n\tif (use_cscope)\n\t    break;\n# endif\n\n\t// try another time while ignoring case\n\tst.orgpat->regmatch.rm_ic = TRUE;\n    }\n\n    if (!st.stop_searching)\n    {\n\tif (!st.did_open && verbose)\t// never opened any tags file\n\t    emsg(_(e_no_tags_file));\n\tretval = OK;\t\t// It's OK even when no tag found\n    }\n\nfindtag_end:\n    findtags_state_free(&st);\n\n    /*\n     * Move the matches from the ga_match[] arrays into one list of\n     * matches.  When retval == FAIL, free the matches.\n     */\n    if (retval == FAIL)\n\tst.match_count = 0;\n\n    *num_matches = findtags_copy_matches(&st, matchesp);\n\n    curbuf->b_help = help_save;\n#ifdef FEAT_MULTI_LANG\n    vim_free(saved_pat);\n#endif\n\n    p_ic = save_p_ic;\n\n    return retval;\n}\n\nstatic garray_T tag_fnames = GA_EMPTY;\n\n/*\n * Callback function for finding all \"tags\" and \"tags-??\" files in\n * 'runtimepath' doc directories.\n */\n    static void\nfound_tagfile_cb(char_u *fname, void *cookie UNUSED)\n{\n    if (ga_grow(&tag_fnames, 1) == OK)\n    {\n\tchar_u\t*tag_fname = vim_strsave(fname);\n\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(tag_fname);\n#endif\n\tsimplify_filename(tag_fname);\n\t((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] = tag_fname;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_tag_stuff(void)\n{\n    ga_clear_strings(&tag_fnames);\n    if (curwin != NULL)\n\tdo_tag(NULL, DT_FREE, 0, 0, 0);\n    tag_freematch();\n\n# if defined(FEAT_QUICKFIX)\n    tagstack_clear_entry(&ptag_entry);\n# endif\n}\n#endif\n\n/*\n * Get the next name of a tag file from the tag file list.\n * For help files, use \"tags\" file only.\n *\n * Return FAIL if no more tag file names, OK otherwise.\n */\n    int\nget_tagfname(\n    tagname_T\t*tnp,\t// holds status info\n    int\t\tfirst,\t// TRUE when first file name is wanted\n    char_u\t*buf)\t// pointer to buffer of MAXPATHL chars\n{\n    char_u\t\t*fname = NULL;\n    char_u\t\t*r_ptr;\n    int\t\t\ti;\n\n    if (first)\n\tCLEAR_POINTER(tnp);\n\n    if (curbuf->b_help)\n    {\n\t/*\n\t * For help files it's done in a completely different way:\n\t * Find \"doc/tags\" and \"doc/tags-??\" in all directories in\n\t * 'runtimepath'.\n\t */\n\tif (first)\n\t{\n\t    ga_clear_strings(&tag_fnames);\n\t    ga_init2(&tag_fnames, sizeof(char_u *), 10);\n\t    do_in_runtimepath((char_u *)\n#ifdef FEAT_MULTI_LANG\n# ifdef VMS\n\t\t    // Functions decc$to_vms() and decc$translate_vms() crash\n\t\t    // on some VMS systems with wildcards \"??\".  Seems ECO\n\t\t    // patches do fix the problem in C RTL, but we can't use\n\t\t    // an #ifdef for that.\n\t\t    \"doc/tags doc/tags-*\"\n# else\n\t\t    \"doc/tags doc/tags-??\"\n# endif\n#else\n\t\t    \"doc/tags\"\n#endif\n\t\t\t\t\t   , DIP_ALL, found_tagfile_cb, NULL);\n\t}\n\n\tif (tnp->tn_hf_idx >= tag_fnames.ga_len)\n\t{\n\t    // Not found in 'runtimepath', use 'helpfile', if it exists and\n\t    // wasn't used yet, replacing \"help.txt\" with \"tags\".\n\t    if (tnp->tn_hf_idx > tag_fnames.ga_len || *p_hf == NUL)\n\t\treturn FAIL;\n\t    ++tnp->tn_hf_idx;\n\t    STRCPY(buf, p_hf);\n\t    STRCPY(gettail(buf), \"tags\");\n#ifdef BACKSLASH_IN_FILENAME\n\t    slash_adjust(buf);\n#endif\n\t    simplify_filename(buf);\n\n\t    for (i = 0; i < tag_fnames.ga_len; ++i)\n\t\tif (STRCMP(buf, ((char_u **)(tag_fnames.ga_data))[i]) == 0)\n\t\t    return FAIL; // avoid duplicate file names\n\t}\n\telse\n\t    vim_strncpy(buf, ((char_u **)(tag_fnames.ga_data))[\n\t\t\t\t\t     tnp->tn_hf_idx++], MAXPATHL - 1);\n\treturn OK;\n    }\n\n    if (first)\n    {\n\t// Init.  We make a copy of 'tags', because autocommands may change\n\t// the value without notifying us.\n\ttnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)\n\t\t\t\t\t\t ? curbuf->b_p_tags : p_tags);\n\tif (tnp->tn_tags == NULL)\n\t    return FAIL;\n\ttnp->tn_np = tnp->tn_tags;\n    }\n\n    /*\n     * Loop until we have found a file name that can be used.\n     * There are two states:\n     * tnp->tn_did_filefind_init == FALSE: setup for next part in 'tags'.\n     * tnp->tn_did_filefind_init == TRUE: find next file in this part.\n     */\n    for (;;)\n    {\n\tif (tnp->tn_did_filefind_init)\n\t{\n\t    fname = vim_findfile(tnp->tn_search_ctx);\n\t    if (fname != NULL)\n\t\tbreak;\n\n\t    tnp->tn_did_filefind_init = FALSE;\n\t}\n\telse\n\t{\n\t    char_u  *filename = NULL;\n\n\t    // Stop when used all parts of 'tags'.\n\t    if (*tnp->tn_np == NUL)\n\t    {\n\t\tvim_findfile_cleanup(tnp->tn_search_ctx);\n\t\ttnp->tn_search_ctx = NULL;\n\t\treturn FAIL;\n\t    }\n\n\t    /*\n\t     * Copy next file name into buf.\n\t     */\n\t    buf[0] = NUL;\n\t    (void)copy_option_part(&tnp->tn_np, buf, MAXPATHL - 1, \" ,\");\n\n#ifdef FEAT_PATH_EXTRA\n\t    r_ptr = vim_findfile_stopdir(buf);\n#else\n\t    r_ptr = NULL;\n#endif\n\t    // move the filename one char forward and truncate the\n\t    // filepath with a NUL\n\t    filename = gettail(buf);\n\t    STRMOVE(filename + 1, filename);\n\t    *filename++ = NUL;\n\n\t    tnp->tn_search_ctx = vim_findfile_init(buf, filename,\n\t\t    r_ptr, 100,\n\t\t    FALSE,\t   // don't free visited list\n\t\t    FINDFILE_FILE, // we search for a file\n\t\t    tnp->tn_search_ctx, TRUE, curbuf->b_ffname);\n\t    if (tnp->tn_search_ctx != NULL)\n\t\ttnp->tn_did_filefind_init = TRUE;\n\t}\n    }\n\n    STRCPY(buf, fname);\n    vim_free(fname);\n    return OK;\n}\n\n/*\n * Free the contents of a tagname_T that was filled by get_tagfname().\n */\n    void\ntagname_free(tagname_T *tnp)\n{\n    vim_free(tnp->tn_tags);\n    vim_findfile_cleanup(tnp->tn_search_ctx);\n    tnp->tn_search_ctx = NULL;\n    ga_clear_strings(&tag_fnames);\n}\n\n/*\n * Parse one line from the tags file. Find start/end of tag name, start/end of\n * file name and start of search pattern.\n *\n * If is_etag is TRUE, tagp->fname and tagp->fname_end are not set.\n *\n * Return FAIL if there is a format error in this line, OK otherwise.\n */\n    static int\nparse_tag_line(\n    char_u\t*lbuf,\t\t// line to be parsed\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag,\n#endif\n    tagptrs_T\t*tagp)\n{\n    char_u\t*p;\n\n#ifdef FEAT_EMACS_TAGS\n    if (is_etag)\n\t// emacs-style tag file\n\treturn emacs_tags_parse_line(lbuf, tagp);\n#endif\n\n    // Isolate the tagname, from lbuf up to the first white\n    tagp->tagname = lbuf;\n    p = vim_strchr(lbuf, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->tagname_end = p;\n\n    // Isolate file name, from first to second white space\n    if (*p != NUL)\n\t++p;\n    tagp->fname = p;\n    p = vim_strchr(p, TAB);\n    if (p == NULL)\n\treturn FAIL;\n    tagp->fname_end = p;\n\n    // find start of search command, after second white space\n    if (*p != NUL)\n\t++p;\n    if (*p == NUL)\n\treturn FAIL;\n    tagp->command = p;\n\n    return OK;\n}\n\n/*\n * Check if tagname is a static tag\n *\n * Static tags produced by the older ctags program have the format:\n *\t'file:tag  file  /pattern'.\n * This is only recognized when both occurrence of 'file' are the same, to\n * avoid recognizing \"string::string\" or \":exit\".\n *\n * Static tags produced by the new ctags program have the format:\n *\t'tag  file  /pattern/;\"<Tab>file:'\t    \"\n *\n * Return TRUE if it is a static tag and adjust *tagname to the real tag.\n * Return FALSE if it is not a static tag.\n */\n    static int\ntest_for_static(tagptrs_T *tagp)\n{\n    char_u\t*p;\n\n    /*\n     * Check for new style static tag \":...<Tab>file:[<Tab>...]\"\n     */\n    p = tagp->command;\n    while ((p = vim_strchr(p, '\\t')) != NULL)\n    {\n\t++p;\n\tif (STRNCMP(p, \"file:\", 5) == 0)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Returns the length of a matching tag line.\n */\n    static size_t\nmatching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n\n    // does the same thing as parse_match()\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}\n\n/*\n * Parse a line from a matching tag.  Does not change the line itself.\n *\n * The line that we get looks like this:\n * Emacs tag: <mtt><tag_fname><NUL><ebuf><NUL><lbuf>\n * other tag: <mtt><tag_fname><NUL><NUL><lbuf>\n * without Emacs tags: <mtt><tag_fname><NUL><lbuf>\n *\n * Return OK or FAIL.\n */\n    static int\nparse_match(\n    char_u\t*lbuf,\t    // input: matching line\n    tagptrs_T\t*tagp)\t    // output: pointers into the line\n{\n    int\t\tretval;\n    char_u\t*p;\n    char_u\t*pc, *pt;\n\n    tagp->tag_fname = lbuf + 1;\n    lbuf += STRLEN(tagp->tag_fname) + 2;\n#ifdef FEAT_EMACS_TAGS\n    if (*lbuf)\n    {\n\ttagp->is_etag = TRUE;\n\ttagp->fname = lbuf;\n\tlbuf += STRLEN(lbuf);\n\ttagp->fname_end = lbuf++;\n    }\n    else\n    {\n\ttagp->is_etag = FALSE;\n\t++lbuf;\n    }\n#endif\n\n    // Find search pattern and the file name for non-etags.\n    retval = parse_tag_line(lbuf,\n#ifdef FEAT_EMACS_TAGS\n\t\t\ttagp->is_etag,\n#endif\n\t\t\ttagp);\n\n    tagp->tagkind = NULL;\n    tagp->user_data = NULL;\n    tagp->tagline = 0;\n    tagp->command_end = NULL;\n\n    if (retval == OK)\n    {\n\t// Try to find a kind field: \"kind:<kind>\" or just \"<kind>\"\n\tp = tagp->command;\n\tif (find_extra(&p) == OK)\n\t{\n\t    if (p > tagp->command && p[-1] == '|')\n\t\ttagp->command_end = p - 1;  // drop trailing bar\n\t    else\n\t\ttagp->command_end = p;\n\t    p += 2;\t// skip \";\\\"\"\n\t    if (*p++ == TAB)\n\t\t// Accept ASCII alphabetic kind characters and any multi-byte\n\t\t// character.\n\t\twhile (ASCII_ISALPHA(*p) || mb_ptr2len(p) > 1)\n\t\t{\n\t\t    if (STRNCMP(p, \"kind:\", 5) == 0)\n\t\t\ttagp->tagkind = p + 5;\n\t\t    else if (STRNCMP(p, \"user_data:\", 10) == 0)\n\t\t\ttagp->user_data = p + 10;\n\t\t    else if (STRNCMP(p, \"line:\", 5) == 0)\n\t\t\ttagp->tagline = atoi((char *)p + 5);\n\t\t    if (tagp->tagkind != NULL && tagp->user_data != NULL)\n\t\t\tbreak;\n\t\t    pc = vim_strchr(p, ':');\n\t\t    pt = vim_strchr(p, '\\t');\n\t\t    if (pc == NULL || (pt != NULL && pc > pt))\n\t\t\ttagp->tagkind = p;\n\t\t    if (pt == NULL)\n\t\t\tbreak;\n\t\t    p = pt;\n\t\t    MB_PTR_ADV(p);\n\t\t}\n\t}\n\tif (tagp->tagkind != NULL)\n\t{\n\t    for (p = tagp->tagkind;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->tagkind_end = p;\n\t}\n\tif (tagp->user_data != NULL)\n\t{\n\t    for (p = tagp->user_data;\n\t\t\t    *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; MB_PTR_ADV(p))\n\t\t;\n\t    tagp->user_data_end = p;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Find out the actual file name of a tag.  Concatenate the tags file name\n * with the matching tag file name.\n * Returns an allocated string or NULL (out of memory).\n */\n    static char_u *\ntag_full_fname(tagptrs_T *tagp)\n{\n    char_u\t*fullname;\n    int\t\tc;\n\n#ifdef FEAT_EMACS_TAGS\n    if (tagp->is_etag)\n\tc = 0;\t    // to shut up GCC\n    else\n#endif\n    {\n\tc = *tagp->fname_end;\n\t*tagp->fname_end = NUL;\n    }\n    fullname = expand_tag_fname(tagp->fname, tagp->tag_fname, FALSE);\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp->is_etag)\n#endif\n\t*tagp->fname_end = c;\n\n    return fullname;\n}\n\n/*\n * Jump to a tag that has been found in one of the tag files\n *\n * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.\n */\n    static int\njumpto_tag(\n    char_u\t*lbuf_arg,\t// line from the tags file for this tag\n    int\t\tforceit,\t// :ta with !\n    int\t\tkeep_help)\t// keep help flag (FALSE for cscope)\n{\n    optmagic_T\tsave_magic_overruled;\n    int\t\tsave_p_ws, save_p_scs, save_p_ic;\n    linenr_T\tsave_lnum;\n    char_u\t*str;\n    char_u\t*pbuf;\t\t\t// search pattern buffer\n    char_u\t*pbuf_end;\n    char_u\t*tofree_fname = NULL;\n    char_u\t*fname;\n    tagptrs_T\ttagp;\n    int\t\tretval = FAIL;\n    int\t\tgetfile_result = GETFILE_UNUSED;\n    int\t\tsearch_options;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tsave_no_hlsearch;\n#endif\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n    char_u\t*full_fname = NULL;\n#ifdef FEAT_FOLDING\n    int\t\told_KeyTyped = KeyTyped;    // getting the file may reset it\n#endif\n    size_t\tlen;\n    char_u\t*lbuf;\n\n    // Make a copy of the line, it can become invalid when an autocommand calls\n    // back here recursively.\n    len = matching_line_len(lbuf_arg) + 1;\n    lbuf = alloc(len);\n    if (lbuf != NULL)\n\tmch_memmove(lbuf, lbuf_arg, len);\n\n    pbuf = alloc(LSIZE);\n\n    // parse the match line into the tagp structure\n    if (pbuf == NULL || lbuf == NULL || parse_match(lbuf, &tagp) == FAIL)\n    {\n\ttagp.fname_end = NULL;\n\tgoto erret;\n    }\n\n    // truncate the file name, so it can be used as a string\n    *tagp.fname_end = NUL;\n    fname = tagp.fname;\n\n    // copy the command to pbuf[], remove trailing CR/NL\n    str = tagp.command;\n    for (pbuf_end = pbuf; *str && *str != '\\n' && *str != '\\r'; )\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (tagp.is_etag && *str == ',')// stop at ',' after line number\n\t    break;\n#endif\n\t*pbuf_end++ = *str++;\n\tif (pbuf_end - pbuf + 1 >= LSIZE)\n\t    break;\n    }\n    *pbuf_end = NUL;\n\n#ifdef FEAT_EMACS_TAGS\n    if (!tagp.is_etag)\n#endif\n    {\n\t/*\n\t * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here.\n\t */\n\tstr = pbuf;\n\tif (find_extra(&str) == OK)\n\t{\n\t    pbuf_end = str;\n\t    *pbuf_end = NUL;\n\t}\n    }\n\n    /*\n     * Expand file name, when needed (for environment variables).\n     * If 'tagrelative' option set, may change file name.\n     */\n    fname = expand_tag_fname(fname, tagp.tag_fname, TRUE);\n    if (fname == NULL)\n\tgoto erret;\n    tofree_fname = fname;\t// free() it later\n\n    /*\n     * Check if the file with the tag exists before abandoning the current\n     * file.  Also accept a file name for which there is a matching BufReadCmd\n     * autocommand event (e.g., http://sys/file).\n     */\n    if (mch_getperm(fname) < 0 && !has_autocmd(EVENT_BUFREADCMD, fname, NULL))\n    {\n\tretval = NOTAGFILE;\n\tvim_free(nofile_fname);\n\tnofile_fname = vim_strsave(fname);\n\tif (nofile_fname == NULL)\n\t    nofile_fname = empty_option;\n\tgoto erret;\n    }\n\n    ++RedrawingDisabled;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#if defined(FEAT_QUICKFIX)\n    if (g_do_tagpreview != 0)\n    {\n\tpostponed_split = 0;\t// don't split again below\n\tcurwin_save = curwin;\t// Save current window\n\n\t/*\n\t * If we are reusing a window, we may change dir when\n\t * entering it (autocommands) so turn the tag filename\n\t * into a fullpath\n\t */\n\tif (!curwin->w_p_pvw)\n\t{\n\t    full_fname = FullName_save(fname, FALSE);\n\t    fname = full_fname;\n\n\t    /*\n\t     * Make the preview window the current window.\n\t     * Open a preview window when needed.\n\t     */\n\t    prepare_tagpreview(TRUE, TRUE, FALSE);\n\t}\n    }\n\n    // If it was a CTRL-W CTRL-] command split window now.  For \":tab tag\"\n    // open a new tab page.\n    if (postponed_split && (swb_flags & (SWB_USEOPEN | SWB_USETAB)))\n    {\n\tbuf_T *existing_buf = buflist_findname_exp(fname);\n\n\tif (existing_buf != NULL)\n\t{\n\t    win_T *wp = NULL;\n\n\t    if (swb_flags & SWB_USEOPEN)\n\t\twp = buf_jump_open_win(existing_buf);\n\n\t    // If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t    // page containing \"existing_buf\" if one exists\n\t    if (wp == NULL && (swb_flags & SWB_USETAB))\n\t\twp = buf_jump_open_tab(existing_buf);\n\t    // We've switched to the buffer, the usual loading of the file must\n\t    // be skipped.\n\t    if (wp != NULL)\n\t\tgetfile_result = GETFILE_SAME_FILE;\n\t}\n    }\n    if (getfile_result == GETFILE_UNUSED\n\t\t\t\t  && (postponed_split || cmdmod.cmod_tab != 0))\n    {\n\tif (win_split(postponed_split > 0 ? postponed_split : 0,\n\t\t\t\t\t\tpostponed_split_flags) == FAIL)\n\t{\n\t    --RedrawingDisabled;\n\t    goto erret;\n\t}\n\tRESET_BINDING(curwin);\n    }\n#endif\n\n    if (keep_help)\n    {\n\t// A :ta from a help file will keep the b_help flag set.  For \":ptag\"\n\t// we need to use the flag from the window where we came from.\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    keep_help_flag = bt_help(curwin_save->w_buffer);\n\telse\n#endif\n\t    keep_help_flag = curbuf->b_help;\n    }\n\n    if (getfile_result == GETFILE_UNUSED)\n\t// Careful: getfile() may trigger autocommands and call jumpto_tag()\n\t// recursively.\n\tgetfile_result = getfile(0, fname, NULL, TRUE, (linenr_T)0, forceit);\n    keep_help_flag = FALSE;\n\n    if (GETFILE_SUCCESS(getfile_result))\t// got to the right file\n    {\n\tcurwin->w_set_curswant = TRUE;\n\tpostponed_split = 0;\n\n\tsave_magic_overruled = magic_overruled;\n\tmagic_overruled = OPTION_MAGIC_OFF;\t// always execute with 'nomagic'\n#ifdef FEAT_SEARCH_EXTRA\n\t// Save value of no_hlsearch, jumping to a tag is not a real search\n\tsave_no_hlsearch = no_hlsearch;\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\t// getfile() may have cleared options, apply 'previewpopup' again.\n\tif (g_do_tagpreview != 0 && *p_pvp != NUL)\n\t    parse_previewpopup(curwin);\n#endif\n\n\t/*\n\t * If 'cpoptions' contains 't', store the search pattern for the \"n\"\n\t * command.  If 'cpoptions' does not contain 't', the search pattern\n\t * is not stored.\n\t */\n\tif (vim_strchr(p_cpo, CPO_TAGPAT) != NULL)\n\t    search_options = 0;\n\telse\n\t    search_options = SEARCH_KEEP;\n\n\t/*\n\t * If the command is a search, try here.\n\t *\n\t * Reset 'smartcase' for the search, since the search pattern was not\n\t * typed by the user.\n\t * Only use do_search() when there is a full search command, without\n\t * anything following.\n\t */\n\tstr = pbuf;\n\tif (pbuf[0] == '/' || pbuf[0] == '?')\n\t    str = skip_regexp(pbuf + 1, pbuf[0], FALSE) + 1;\n\tif (str > pbuf_end - 1)\t// search command with nothing following\n\t{\n\t    save_p_ws = p_ws;\n\t    save_p_ic = p_ic;\n\t    save_p_scs = p_scs;\n\t    p_ws = TRUE;\t// need 'wrapscan' for backward searches\n\t    p_ic = FALSE;\t// don't ignore case now\n\t    p_scs = FALSE;\n\t    save_lnum = curwin->w_cursor.lnum;\n\t    if (tagp.tagline > 0)\n\t\t// start search before line from \"line:\" field\n\t\tcurwin->w_cursor.lnum = tagp.tagline - 1;\n\t    else\n\t\t// start search before first line\n\t\tcurwin->w_cursor.lnum = 0;\n\t    if (do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\tretval = OK;\n\t    else\n\t    {\n\t\tint\tfound = 1;\n\t\tint\tcc;\n\n\t\t/*\n\t\t * try again, ignore case now\n\t\t */\n\t\tp_ic = TRUE;\n\t\tif (!do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t{\n\t\t    /*\n\t\t     * Failed to find pattern, take a guess: \"^func  (\"\n\t\t     */\n\t\t    found = 2;\n\t\t    (void)test_for_static(&tagp);\n\t\t    cc = *tagp.tagname_end;\n\t\t    *tagp.tagname_end = NUL;\n\t\t    sprintf((char *)pbuf, \"^%s\\\\s\\\\*(\", tagp.tagname);\n\t\t    if (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t    {\n\t\t\t// Guess again: \"^char * \\<func  (\"\n\t\t\tsprintf((char *)pbuf, \"^\\\\[#a-zA-Z_]\\\\.\\\\*\\\\<%s\\\\s\\\\*(\",\n\t\t\t\t\t\t\t\ttagp.tagname);\n\t\t\tif (!do_search(NULL, '/', '/', pbuf, (long)1,\n\t\t\t\t\t\t\t search_options, NULL))\n\t\t\t    found = 0;\n\t\t    }\n\t\t    *tagp.tagname_end = cc;\n\t\t}\n\t\tif (found == 0)\n\t\t{\n\t\t    emsg(_(e_canot_find_tag_pattern));\n\t\t    curwin->w_cursor.lnum = save_lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Only give a message when really guessed, not when 'ic'\n\t\t     * is set and match found while ignoring case.\n\t\t     */\n\t\t    if (found == 2 || !save_p_ic)\n\t\t    {\n\t\t\tmsg(_(e_couldnt_find_tag_just_guessing));\n\t\t\tif (!msg_scrolled && msg_silent == 0)\n\t\t\t{\n\t\t\t    out_flush();\n\t\t\t    ui_delay(1010L, TRUE);\n\t\t\t}\n\t\t    }\n\t\t    retval = OK;\n\t\t}\n\t    }\n\t    p_ws = save_p_ws;\n\t    p_ic = save_p_ic;\n\t    p_scs = save_p_scs;\n\n\t    // A search command may have positioned the cursor beyond the end\n\t    // of the line.  May need to correct that here.\n\t    check_cursor();\n\t}\n\telse\n\t{\n\t    int\t\tsave_secure = secure;\n\n\t    // Setup the sandbox for executing the command from the tags file.\n\t    secure = 1;\n#ifdef HAVE_SANDBOX\n\t    ++sandbox;\n#endif\n\t    curwin->w_cursor.lnum = 1;\t\t// start command in line 1\n\t    do_cmdline_cmd(pbuf);\n\t    retval = OK;\n\n\t    // When the command has done something that is not allowed make\n\t    // sure the error message can be seen.\n\t    if (secure == 2)\n\t\twait_return(TRUE);\n\t    secure = save_secure;\n#ifdef HAVE_SANDBOX\n\t    --sandbox;\n#endif\n\t}\n\n\tmagic_overruled = save_magic_overruled;\n#ifdef FEAT_SEARCH_EXTRA\n\t// restore no_hlsearch when keeping the old search pattern\n\tif (search_options)\n\t    set_no_hlsearch(save_no_hlsearch);\n#endif\n\n\t// Return OK if jumped to another file (at least we found the file!).\n\tif (getfile_result == GETFILE_OPEN_OTHER)\n\t    retval = OK;\n\n\tif (retval == OK)\n\t{\n\t    /*\n\t     * For a help buffer: Put the cursor line at the top of the window,\n\t     * the help subject will be below it.\n\t     */\n\t    if (curbuf->b_help)\n\t\tset_topline(curwin, curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\tfoldOpenCursor();\n#endif\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t{\n\t    // Return cursor to where we were\n\t    validate_cursor();\n\t    redraw_later(UPD_VALID);\n\t    win_enter(curwin_save, TRUE);\n\t}\n#endif\n\n\t--RedrawingDisabled;\n    }\n    else\n    {\n\t--RedrawingDisabled;\n\tgot_int = FALSE;  // don't want entering window to fail\n\n\tif (postponed_split)\t\t// close the window\n\t{\n\t    win_close(curwin, FALSE);\n\t    postponed_split = 0;\n\t}\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n\telse if (WIN_IS_POPUP(curwin))\n\t{\n\t    win_T   *wp = curwin;\n\n\t    if (win_valid(curwin_save))\n\t\twin_enter(curwin_save, TRUE);\n\t    popup_close(wp->w_id, FALSE);\n\t}\n#endif\n    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_PROP_POPUP)\n    if (WIN_IS_POPUP(curwin))\n\t// something went wrong, still in popup, but it can't have focus\n\twin_enter(firstwin, TRUE);\n#endif\n\nerret:\n#if defined(FEAT_QUICKFIX)\n    g_do_tagpreview = 0; // For next time\n#endif\n    vim_free(lbuf);\n    vim_free(pbuf);\n    vim_free(tofree_fname);\n    vim_free(full_fname);\n\n    return retval;\n}\n\n/*\n * If \"expand\" is TRUE, expand wildcards in fname.\n * If 'tagrelative' option set, change fname (name of file containing tag)\n * according to tag_fname (name of tag file containing fname).\n * Returns a pointer to allocated memory (or NULL when out of memory).\n */\n    static char_u *\nexpand_tag_fname(char_u *fname, char_u *tag_fname, int expand)\n{\n    char_u\t*p;\n    char_u\t*retval;\n    char_u\t*expanded_fname = NULL;\n    expand_T\txpc;\n\n    /*\n     * Expand file name (for environment variables) when needed.\n     */\n    if (expand && mch_has_wildcard(fname))\n    {\n\tExpandInit(&xpc);\n\txpc.xp_context = EXPAND_FILES;\n\texpanded_fname = ExpandOne(&xpc, fname, NULL,\n\t\t\t    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);\n\tif (expanded_fname != NULL)\n\t    fname = expanded_fname;\n    }\n\n    if ((p_tr || curbuf->b_help)\n\t    && !vim_isAbsName(fname)\n\t    && (p = gettail(tag_fname)) != tag_fname)\n    {\n\tretval = alloc(MAXPATHL);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, tag_fname);\n\t    vim_strncpy(retval + (p - tag_fname), fname,\n\t\t\t\t\t      MAXPATHL - (p - tag_fname) - 1);\n\t    /*\n\t     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\".\n\t     */\n\t    simplify_filename(retval);\n\t}\n    }\n    else\n\tretval = vim_strsave(fname);\n\n    vim_free(expanded_fname);\n\n    return retval;\n}\n\n/*\n * Check if we have a tag for the buffer with name \"buf_ffname\".\n * This is a bit slow, because of the full path compare in fullpathcmp().\n * Return TRUE if tag for file \"fname\" if tag file \"tag_fname\" is for current\n * file.\n */\n    static int\ntest_for_current(\n#ifdef FEAT_EMACS_TAGS\n    int\t    is_etag,\n#endif\n    char_u  *fname,\n    char_u  *fname_end,\n    char_u  *tag_fname,\n    char_u  *buf_ffname)\n{\n    int\t    c;\n    int\t    retval = FALSE;\n    char_u  *fullname;\n\n    if (buf_ffname != NULL)\t// if the buffer has a name\n    {\n#ifdef FEAT_EMACS_TAGS\n\tif (is_etag)\n\t    c = 0;\t    // to shut up GCC\n\telse\n#endif\n\t{\n\t    c = *fname_end;\n\t    *fname_end = NUL;\n\t}\n\tfullname = expand_tag_fname(fname, tag_fname, TRUE);\n\tif (fullname != NULL)\n\t{\n\t    retval = (fullpathcmp(fullname, buf_ffname, TRUE, TRUE) & FPC_SAME);\n\t    vim_free(fullname);\n\t}\n#ifdef FEAT_EMACS_TAGS\n\tif (!is_etag)\n#endif\n\t    *fname_end = c;\n    }\n\n    return retval;\n}\n\n/*\n * Find the end of the tagaddress.\n * Return OK if \";\\\"\" is following, FAIL otherwise.\n */\n    static int\nfind_extra(char_u **pp)\n{\n    char_u\t*str = *pp;\n    char_u\tfirst_char = **pp;\n\n    // Repeat for addresses separated with ';'\n    for (;;)\n    {\n\tif (VIM_ISDIGIT(*str))\n\t    str = skipdigits(str + 1);\n\telse if (*str == '/' || *str == '?')\n\t{\n\t    str = skip_regexp(str + 1, *str, FALSE);\n\t    if (*str != first_char)\n\t\tstr = NULL;\n\t    else\n\t\t++str;\n\t}\n\telse\n\t{\n\t    // not a line number or search string, look for terminator.\n\t    str = (char_u *)strstr((char *)str, \"|;\\\"\");\n\t    if (str != NULL)\n\t    {\n\t\t++str;\n\t\tbreak;\n\t    }\n\n\t}\n\tif (str == NULL || *str != ';'\n\t\t  || !(VIM_ISDIGIT(str[1]) || str[1] == '/' || str[1] == '?'))\n\t    break;\n\t++str;\t// skip ';'\n\tfirst_char = *str;\n    }\n\n    if (str != NULL && STRNCMP(str, \";\\\"\", 2) == 0)\n    {\n\t*pp = str;\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free a single entry in a tag stack\n */\n    static void\ntagstack_clear_entry(taggy_T *item)\n{\n    VIM_CLEAR(item->tagname);\n    VIM_CLEAR(item->user_data);\n}\n\n    int\nexpand_tags(\n    int\t\ttagnames,\t// expand tag names\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file)\n{\n    int\t\ti;\n    int\t\textra_flag;\n    char_u\t*name_buf;\n    size_t\tname_buf_size = 100;\n    tagptrs_T\tt_p;\n    int\t\tret;\n\n    name_buf = alloc(name_buf_size);\n    if (name_buf == NULL)\n\treturn FAIL;\n\n    if (tagnames)\n\textra_flag = TAG_NAMES;\n    else\n\textra_flag = 0;\n    if (pat[0] == '/')\n\tret = find_tags(pat + 1, num_file, file,\n\t\tTAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    else\n\tret = find_tags(pat, num_file, file,\n\t      TAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC | TAG_NOIC,\n\t\tTAG_MANY, curbuf->b_ffname);\n    if (ret == OK && !tagnames)\n    {\n\t // Reorganize the tags for display and matching as strings of:\n\t // \"<tagname>\\0<kind>\\0<filename>\\0\"\n\t for (i = 0; i < *num_file; i++)\n\t {\n\t     size_t\tlen;\n\n\t     parse_match((*file)[i], &t_p);\n\t     len = t_p.tagname_end - t_p.tagname;\n\t     if (len > name_buf_size - 3)\n\t     {\n\t\t char_u *buf;\n\n\t\t name_buf_size = len + 3;\n\t\t buf = vim_realloc(name_buf, name_buf_size);\n\t\t if (buf == NULL)\n\t\t {\n\t\t     vim_free(name_buf);\n\t\t     return FAIL;\n\t\t }\n\t\t name_buf = buf;\n\t     }\n\n\t     mch_memmove(name_buf, t_p.tagname, len);\n\t     name_buf[len++] = 0;\n\t     name_buf[len++] = (t_p.tagkind != NULL && *t_p.tagkind)\n\t\t\t\t\t\t\t  ? *t_p.tagkind : 'f';\n\t     name_buf[len++] = 0;\n\t     mch_memmove((*file)[i] + len, t_p.fname,\n\t\t\t\t\t\t    t_p.fname_end - t_p.fname);\n\t     (*file)[i][len + (t_p.fname_end - t_p.fname)] = 0;\n\t     mch_memmove((*file)[i], name_buf, len);\n\t}\n    }\n\n    vim_free(name_buf);\n    return ret;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add a tag field to the dictionary \"dict\".\n * Return OK or FAIL.\n */\n    static int\nadd_tag_field(\n    dict_T  *dict,\n    char    *field_name,\n    char_u  *start,\t\t// start of the value\n    char_u  *end)\t\t// after the value; can be NULL\n{\n    char_u\t*buf;\n    int\t\tlen = 0;\n    int\t\tretval;\n\n    // check that the field name doesn't exist yet\n    if (dict_has_key(dict, field_name))\n    {\n\tif (p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Duplicate field name: %s\"), field_name);\n\t    verbose_leave();\n\t}\n\treturn FAIL;\n    }\n    buf = alloc(MAXPATHL);\n    if (buf == NULL)\n\treturn FAIL;\n    if (start != NULL)\n    {\n\tif (end == NULL)\n\t{\n\t    end = start + STRLEN(start);\n\t    while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))\n\t\t--end;\n\t}\n\tlen = (int)(end - start);\n\tif (len > MAXPATHL - 1)\n\t    len = MAXPATHL - 1;\n\tvim_strncpy(buf, start, len);\n    }\n    buf[len] = NUL;\n    retval = dict_add_string(dict, field_name, buf);\n    vim_free(buf);\n    return retval;\n}\n\n/*\n * Add the tags matching the specified pattern \"pat\" to the list \"list\"\n * as a dictionary. Use \"buf_fname\" for priority, unless NULL.\n */\n    int\nget_tags(list_T *list, char_u *pat, char_u *buf_fname)\n{\n    int\t\tnum_matches, i, ret;\n    char_u\t**matches, *p;\n    char_u\t*full_fname;\n    dict_T\t*dict;\n    tagptrs_T\ttp;\n    long\tis_static;\n\n    ret = find_tags(pat, &num_matches, &matches,\n\t\t\t\tTAG_REGEXP | TAG_NOIC, (int)MAXCOL, buf_fname);\n    if (ret == OK && num_matches > 0)\n    {\n\tfor (i = 0; i < num_matches; ++i)\n\t{\n\t    parse_match(matches[i], &tp);\n\t    is_static = test_for_static(&tp);\n\n\t    // Skip pseudo-tag lines.\n\t    if (STRNCMP(tp.tagname, \"!_TAG_\", 6) == 0)\n\t    {\n\t\tvim_free(matches[i]);\n\t\tcontinue;\n\t    }\n\n\t    if ((dict = dict_alloc()) == NULL)\n\t\tret = FAIL;\n\t    if (list_append_dict(list, dict) == FAIL)\n\t\tret = FAIL;\n\n\t    full_fname = tag_full_fname(&tp);\n\t    if (add_tag_field(dict, \"name\", tp.tagname, tp.tagname_end) == FAIL\n\t\t    || add_tag_field(dict, \"filename\", full_fname,\n\t\t\t\t\t\t\t NULL) == FAIL\n\t\t    || add_tag_field(dict, \"cmd\", tp.command,\n\t\t\t\t\t\t       tp.command_end) == FAIL\n\t\t    || add_tag_field(dict, \"kind\", tp.tagkind,\n\t\t\t\t\t\t      tp.tagkind_end) == FAIL\n\t\t    || dict_add_number(dict, \"static\", is_static) == FAIL)\n\t\tret = FAIL;\n\n\t    vim_free(full_fname);\n\n\t    if (tp.command_end != NULL)\n\t    {\n\t\tfor (p = tp.command_end + 3;\n\t\t\t  *p != NUL && *p != '\\n' && *p != '\\r'; MB_PTR_ADV(p))\n\t\t{\n\t\t    if (p == tp.tagkind || (p + 5 == tp.tagkind\n\t\t\t\t\t      && STRNCMP(p, \"kind:\", 5) == 0))\n\t\t\t// skip \"kind:<kind>\" and \"<kind>\"\n\t\t\tp = tp.tagkind_end - 1;\n\t\t    else if (STRNCMP(p, \"file:\", 5) == 0)\n\t\t\t// skip \"file:\" (static tag)\n\t\t\tp += 4;\n\t\t    else if (!VIM_ISWHITE(*p))\n\t\t    {\n\t\t\tchar_u\t*s, *n;\n\t\t\tint\tlen;\n\n\t\t\t// Add extra field as a dict entry.  Fields are\n\t\t\t// separated by Tabs.\n\t\t\tn = p;\n\t\t\twhile (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')\n\t\t\t    ++p;\n\t\t\tlen = (int)(p - n);\n\t\t\tif (*p == ':' && len > 0)\n\t\t\t{\n\t\t\t    s = ++p;\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\t    n[len] = NUL;\n\t\t\t    if (add_tag_field(dict, (char *)n, s, p) == FAIL)\n\t\t\t\tret = FAIL;\n\t\t\t    n[len] = ':';\n\t\t\t}\n\t\t\telse\n\t\t\t    // Skip field without colon.\n\t\t\t    while (*p != NUL && *p >= ' ')\n\t\t\t\t++p;\n\t\t\tif (*p == NUL)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    vim_free(matches[i]);\n\t}\n\tvim_free(matches);\n    }\n    return ret;\n}\n\n/*\n * Return information about 'tag' in dict 'retdict'.\n */\n    static void\nget_tag_details(taggy_T *tag, dict_T *retdict)\n{\n    list_T\t*pos;\n    fmark_T\t*fmark;\n\n    dict_add_string(retdict, \"tagname\", tag->tagname);\n    dict_add_number(retdict, \"matchnr\", tag->cur_match + 1);\n    dict_add_number(retdict, \"bufnr\", tag->cur_fnum);\n    if (tag->user_data)\n\tdict_add_string(retdict, \"user_data\", tag->user_data);\n\n    if ((pos = list_alloc_id(aid_tagstack_from)) == NULL)\n\treturn;\n    dict_add_list(retdict, \"from\", pos);\n\n    fmark = &tag->fmark;\n    list_append_number(pos,\n\t\t\t(varnumber_T)(fmark->fnum != -1 ? fmark->fnum : 0));\n    list_append_number(pos, (varnumber_T)fmark->mark.lnum);\n    list_append_number(pos, (varnumber_T)(fmark->mark.col == MAXCOL ?\n\t\t\t\t\tMAXCOL : fmark->mark.col + 1));\n    list_append_number(pos, (varnumber_T)fmark->mark.coladd);\n}\n\n/*\n * Return the tag stack entries of the specified window 'wp' in dictionary\n * 'retdict'.\n */\n    void\nget_tagstack(win_T *wp, dict_T *retdict)\n{\n    list_T\t*l;\n    int\t\ti;\n    dict_T\t*d;\n\n    dict_add_number(retdict, \"length\", wp->w_tagstacklen);\n    dict_add_number(retdict, \"curidx\", wp->w_tagstackidx + 1);\n    l = list_alloc_id(aid_tagstack_items);\n    if (l == NULL)\n\treturn;\n    dict_add_list(retdict, \"items\", l);\n\n    for (i = 0; i < wp->w_tagstacklen; i++)\n    {\n\tif ((d = dict_alloc_id(aid_tagstack_details)) == NULL)\n\t    return;\n\tlist_append_dict(l, d);\n\n\tget_tag_details(&wp->w_tagstack[i], d);\n    }\n}\n\n/*\n * Free all the entries in the tag stack of the specified window\n */\n    static void\ntagstack_clear(win_T *wp)\n{\n    int i;\n\n    // Free the current tag stack\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n\ttagstack_clear_entry(&wp->w_tagstack[i]);\n    wp->w_tagstacklen = 0;\n    wp->w_tagstackidx = 0;\n}\n\n/*\n * Remove the oldest entry from the tag stack and shift the rest of\n * the entries to free up the top of the stack.\n */\n    static void\ntagstack_shift(win_T *wp)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\ti;\n\n    tagstack_clear_entry(&tagstack[0]);\n    for (i = 1; i < wp->w_tagstacklen; ++i)\n\ttagstack[i - 1] = tagstack[i];\n    wp->w_tagstacklen--;\n}\n\n/*\n * Push a new item to the tag stack\n */\n    static void\ntagstack_push_item(\n\twin_T\t*wp,\n\tchar_u\t*tagname,\n\tint\tcur_fnum,\n\tint\tcur_match,\n\tpos_T\tmark,\n\tint\tfnum,\n\tchar_u  *user_data)\n{\n    taggy_T\t*tagstack = wp->w_tagstack;\n    int\t\tidx = wp->w_tagstacklen;\t// top of the stack\n\n    // if the tagstack is full: remove the oldest entry\n    if (idx >= TAGSTACKSIZE)\n    {\n\ttagstack_shift(wp);\n\tidx = TAGSTACKSIZE - 1;\n    }\n\n    wp->w_tagstacklen++;\n    tagstack[idx].tagname = tagname;\n    tagstack[idx].cur_fnum = cur_fnum;\n    tagstack[idx].cur_match = cur_match;\n    if (tagstack[idx].cur_match < 0)\n\ttagstack[idx].cur_match = 0;\n    tagstack[idx].fmark.mark = mark;\n    tagstack[idx].fmark.fnum = fnum;\n    tagstack[idx].user_data = user_data;\n}\n\n/*\n * Add a list of items to the tag stack in the specified window\n */\n    static void\ntagstack_push_items(win_T *wp, list_T *l)\n{\n    listitem_T\t*li;\n    dictitem_T\t*di;\n    dict_T\t*itemdict;\n    char_u\t*tagname;\n    pos_T\tmark;\n    int\t\tfnum;\n\n    // Add one entry at a time to the tag stack\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT || li->li_tv.vval.v_dict == NULL)\n\t    continue;\t\t\t\t// Skip non-dict items\n\titemdict = li->li_tv.vval.v_dict;\n\n\t// parse 'from' for the cursor position before the tag jump\n\tif ((di = dict_find(itemdict, (char_u *)\"from\", -1)) == NULL)\n\t    continue;\n\tif (list2fpos(&di->di_tv, &mark, &fnum, NULL, FALSE) != OK)\n\t    continue;\n\tif ((tagname = dict_get_string(itemdict, \"tagname\", TRUE)) == NULL)\n\t    continue;\n\n\tif (mark.col > 0)\n\t    mark.col--;\n\ttagstack_push_item(wp, tagname,\n\t\t(int)dict_get_number(itemdict, \"bufnr\"),\n\t\t(int)dict_get_number(itemdict, \"matchnr\") - 1,\n\t\tmark, fnum,\n\t\tdict_get_string(itemdict, \"user_data\", TRUE));\n    }\n}\n\n/*\n * Set the current index in the tag stack. Valid values are between 0\n * and the stack length (inclusive).\n */\n    static void\ntagstack_set_curidx(win_T *wp, int curidx)\n{\n    wp->w_tagstackidx = curidx;\n    if (wp->w_tagstackidx < 0)\t\t\t// sanity check\n\twp->w_tagstackidx = 0;\n    if (wp->w_tagstackidx > wp->w_tagstacklen)\n\twp->w_tagstackidx = wp->w_tagstacklen;\n}\n\n/*\n * Set the tag stack entries of the specified window.\n * 'action' is set to one of:\n *\t'a' for append\n *\t'r' for replace\n *\t't' for truncate\n */\n    int\nset_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n\n#ifdef FEAT_EVAL\n    // not allowed to alter the tag stack entries from inside tagfunc\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n\n    if (action == 't')\t\t    // truncate the stack\n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\n\t// delete all the tag stack entries above the current entry\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t// replace the stack\n\t    tagstack_clear(wp);\n\n\ttagstack_push_items(wp, l);\n\t// set the current index after the last entry\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n\n    return OK;\n}\n#endif\n", "\" Test 'tagfunc'\n\nimport './vim9.vim' as v9\nsource check.vim\nsource screendump.vim\n\nfunc TagFunc(pat, flag, info)\n  let g:tagfunc_args = [a:pat, a:flag, a:info]\n  let tags = []\n  for num in range(1,10)\n    let tags += [{\n          \\ 'cmd': '2', 'name': 'nothing'.num, 'kind': 'm',\n          \\ 'filename': 'Xfile1', 'user_data': 'somedata'.num,\n          \\}]\n  endfor\n  return tags\nendfunc\n\nfunc Test_tagfunc()\n  set tagfunc=TagFunc\n  new Xfile1\n  call setline(1, ['empty', 'one()', 'empty'])\n  write\n\n  call assert_equal({'cmd': '2', 'static': 0,\n        \\ 'name': 'nothing2', 'user_data': 'somedata2',\n        \\ 'kind': 'm', 'filename': 'Xfile1'}, taglist('.')[1])\n\n  call settagstack(win_getid(), {'items': []})\n\n  tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata1', gettagstack().items[0].user_data)\n  5tag arbitrary\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n  pop\n  tag\n  call assert_equal('arbitrary', g:tagfunc_args[0])\n  call assert_equal('', g:tagfunc_args[1])\n  call assert_equal('somedata5', gettagstack().items[1].user_data)\n\n  let g:tagfunc_args=[]\n  execute \"normal! \\<c-]>\"\n  call assert_equal('one', g:tagfunc_args[0])\n  call assert_equal('c', g:tagfunc_args[1])\n\n  let g:tagfunc_args=[]\n  execute \"tag /foo$\"\n  call assert_equal('foo$', g:tagfunc_args[0])\n  call assert_equal('r', g:tagfunc_args[1])\n\n  set cpt=t\n  let g:tagfunc_args=[]\n  execute \"normal! i\\<c-n>\\<c-y>\"\n  call assert_equal('\\<\\k\\k', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing1', getline('.')[0:7])\n\n  let g:tagfunc_args=[]\n  execute \"normal! ono\\<c-n>\\<c-n>\\<c-y>\"\n  call assert_equal('\\<no', g:tagfunc_args[0])\n  call assert_equal('cir', g:tagfunc_args[1])\n  call assert_equal('nothing2', getline('.')[0:7])\n\n  func BadTagFunc1(...)\n    return 0\n  endfunc\n  func BadTagFunc2(...)\n    return [1]\n  endfunc\n  func BadTagFunc3(...)\n    return [{'name': 'foo'}]\n  endfunc\n\n  for &tagfunc in ['BadTagFunc1', 'BadTagFunc2', 'BadTagFunc3']\n    try\n      tag nothing\n      call assert_false(1, 'tag command should have failed')\n    catch\n      call assert_exception('E987:')\n    endtry\n    exe 'delf' &tagfunc\n  endfor\n\n  func NullTagFunc(...)\n    return v:null\n  endfunc\n  set tags= tfu=NullTagFunc\n  call assert_fails('tag nothing', 'E433:')\n  delf NullTagFunc\n\n  bwipe!\n  set tags& tfu& cpt& \n  call delete('Xfile1')\nendfunc\n\n\" Test for modifying the tag stack from a tag function and jumping to a tag\n\" from a tag function\nfunc Test_tagfunc_settagstack()\n  func Mytagfunc1(pat, flags, info)\n    call settagstack(1, {'tagname' : 'mytag', 'from' : [0, 10, 1, 0]})\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc1\n  call writefile([''], 'Xtest')\n  call assert_fails('tag xyz', 'E986:')\n\n  func Mytagfunc2(pat, flags, info)\n    tag test_tag\n    return [{'name' : 'mytag', 'filename' : 'Xtest', 'cmd' : '1'}]\n  endfunc\n  set tagfunc=Mytagfunc2\n  call assert_fails('tag xyz', 'E986:')\n\n  call delete('Xtest')\n  set tagfunc&\n  delfunc Mytagfunc1\n  delfunc Mytagfunc2\nendfunc\n\n\" Script local tagfunc callback function\nfunc s:ScriptLocalTagFunc(pat, flags, info)\n  let g:ScriptLocalFuncArgs = [a:pat, a:flags, a:info]\n  return v:null\nendfunc\n\n\" Test for different ways of setting the 'tagfunc' option\nfunc Test_tagfunc_callback()\n  func TagFunc1(callnr, pat, flags, info)\n    let g:TagFunc1Args = [a:callnr, a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  func TagFunc2(pat, flags, info)\n    let g:TagFunc2Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &tagfunc = 'g:TagFunc2'\n    new\n    LET g:TagFunc2Args = []\n    call assert_fails('tag a10', 'E433:')\n    call assert_equal(['a10', '', {}], g:TagFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set tagfunc=function('g:TagFunc1',\\ [10])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a11', 'E433:')\n    call assert_equal([10, 'a11', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    VAR Fn = function('g:TagFunc1', [11])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([11, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = function('g:TagFunc1', [12])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a12', 'E433:')\n    call assert_equal([12, 'a12', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set tagfunc=funcref('g:TagFunc1',\\ [13])\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a13', 'E433:')\n    call assert_equal([13, 'a13', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [14])\n    LET &tagfunc = Fn\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([14, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'tagfunc'\n    LET Fn = funcref('g:TagFunc1', [15])\n    LET &tagfunc = string(Fn)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a14', 'E433:')\n    call assert_equal([15, 'a14', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function\n    VAR optval = \"LSTART a, b, c LMIDDLE g:TagFunc1(16, a, b, c) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set tagfunc=\" .. optval\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a17', 'E433:')\n    call assert_equal([16, 'a17', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a lambda expression\n    LET &tagfunc = LSTART a, b, c LMIDDLE g:TagFunc1(17, a, b, c) LEND\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([17, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(lambda expression)\n    LET &tagfunc = 'LSTART a, b, c LMIDDLE g:TagFunc1(18, a, b, c) LEND'\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails('tag a18', 'E433:')\n    call assert_equal([18, 'a18', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(19, a, b, c) LEND\n    LET &tagfunc = Lambda\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([19, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Set 'tagfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b, c LMIDDLE g:TagFunc1(20, a, b, c) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    LET g:TagFunc1Args = []\n    call assert_fails(\"tag a19\", \"E433:\")\n    call assert_equal([20, 'a19', '', {}], g:TagFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b, c LMIDDLE strlen(a) LEND\n    LET &tagfunc = string(Lambda)\n    new\n    call assert_fails(\"tag a20\", \"E987:\")\n    bw!\n\n    #\" Test for clearing the 'tagfunc' option\n    set tagfunc=''\n    set tagfunc&\n    call assert_fails(\"set tagfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set tagfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'tagfunc' to a non-existing function\n    LET &tagfunc = function('g:TagFunc2', [21])\n    LET g:TagFunc2Args = []\n    call assert_fails(\"set tagfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &tagfunc = function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"tag axb123\", 'E426:')\n    call assert_equal([], g:TagFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TagFunc3(pat, flags, info)\n    let g:TagFunc3Args = [a:pat, a:flags, a:info]\n    return v:null\n  endfunc\n  set tagfunc=s:TagFunc3\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a21', 'E433:')\n  call assert_equal(['a21', '', {}], g:TagFunc3Args)\n  bw!\n  let &tagfunc = 's:TagFunc3'\n  new\n  let g:TagFunc3Args = []\n  call assert_fails('tag a22', 'E433:')\n  call assert_equal(['a22', '', {}], g:TagFunc3Args)\n  bw!\n  delfunc s:TagFunc3\n\n  \" invalid return value\n  let &tagfunc = \"{a -> 'abc'}\"\n  call assert_fails(\"echo taglist('a')\", \"E987:\")\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set tagfunc=(a,\\ b,\\ c)\\ =>\\ g:TagFunc1(21,\\ a,\\ b,\\ c)\n  new\n  let g:TagFunc1Args = []\n  call assert_fails(\"tag a17\", \"E117:\")\n  call assert_equal([], g:TagFunc1Args)\n  bw!\n\n  \" Test for using a script local function\n  set tagfunc=<SID>ScriptLocalTagFunc\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a15', 'E433:')\n  call assert_equal(['a15', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a script local funcref variable\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= Fn\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" Test for using a string(script local funcref variable)\n  let Fn = function(\"s:ScriptLocalTagFunc\")\n  let &tagfunc= string(Fn)\n  new\n  let g:ScriptLocalFuncArgs = []\n  call assert_fails('tag a16', 'E433:')\n  call assert_equal(['a16', '', {}], g:ScriptLocalFuncArgs)\n  bw!\n\n  \" set 'tagfunc' to a partial with dict. This used to cause a crash.\n  func SetTagFunc()\n    let params = {'tagfn': function('g:DictTagFunc')}\n    let &tagfunc = params.tagfn\n  endfunc\n  func g:DictTagFunc(_) dict\n  endfunc\n  call SetTagFunc()\n  new\n  call SetTagFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set tagfunc=\n  wincmd w\n  set tagfunc=\n  :%bw!\n  delfunc g:DictTagFunc\n  delfunc SetTagFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9tagFunc(callnr: number, pat: string, flags: string, info: dict<any>): any\n      g:Vim9tagFuncArgs = [callnr, pat, flags, info]\n      return null\n    enddef\n\n    # Test for using a def function with completefunc\n    set tagfunc=function('Vim9tagFunc',\\ [60])\n    new\n    g:Vim9tagFuncArgs = []\n    assert_fails('tag a10', 'E433:')\n    assert_equal([60, 'a10', '', {}], g:Vim9tagFuncArgs)\n\n    # Test for using a global function name\n    &tagfunc = g:TagFunc2\n    new\n    g:TagFunc2Args = []\n    assert_fails('tag a11', 'E433:')\n    assert_equal(['a11', '', {}], g:TagFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalTagFunc(pat: string, flags: string, info: dict<any> ): any\n      g:LocalTagFuncArgs = [pat, flags, info]\n      return null\n    enddef\n    &tagfunc = LocalTagFunc\n    new\n    g:LocalTagFuncArgs = []\n    assert_fails('tag a12', 'E433:')\n    assert_equal(['a12', '', {}], g:LocalTagFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  delfunc TagFunc1\n  delfunc TagFunc2\n  set tagfunc&\n  %bw!\nendfunc\n\nfunc Test_tagfunc_wipes_buffer()\n  func g:Tag0unc0(t,f,o)\n   bwipe\n  endfunc\n  set tagfunc=g:Tag0unc0\n  new\n  cal assert_fails('tag 0', 'E987:')\n\n  delfunc g:Tag0unc0\n  set tagfunc=\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/tag.c", "src/testdir/test_tagfunc.vim", "src/version.c"], "buggy_code_start_loc": [283, 391, 733], "buggy_code_end_loc": [924, 391, 733], "fixing_code_start_loc": [284, 392, 734], "fixing_code_end_loc": [932, 404, 736], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0246.", "other": {"cve": {"id": "CVE-2022-2946", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-23T17:15:14.383", "lastModified": "2023-05-03T12:16:09.070", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0246."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0246."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0246", "matchCriteriaId": "ED65245F-3239-4021-8683-8AC409AEBB86"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/adce965162dd89bf29ee0e5baf53652e7515762c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/5d389a18-5026-47df-a5d0-1548a9b555d5", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C72HDIMR3KTTAO7QGTXWUMPBNFUFIBRD/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/adce965162dd89bf29ee0e5baf53652e7515762c"}}