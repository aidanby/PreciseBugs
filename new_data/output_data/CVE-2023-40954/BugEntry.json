{"buggy_code": ["# Part of web_progress. See LICENSE file for full copyright and licensing details.\nfrom odoo import models, api, registry, fields, _, SUPERUSER_ID\nfrom odoo.exceptions import UserError\nfrom threading import RLock\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nimport html\nimport odoo\nimport json\nimport logging\n\n_logger = logging.getLogger(__name__)\nlock = RLock()\n# track time between progress reports\nlast_report_time = {}\n# track time from the beginnig\nfirst_report_time = {}\n# store recursion depth for every operation\nrecur_depths = {}\n# progress reports data\nprogress_data = defaultdict(dict)\n# user name\nuser_name = {}\n\n\ndef json_dump(v):\n    return json.dumps(v, separators=(',', ':'))\n\n\nclass CancelledProgress(models.UserError):\n    # exception used to cancel the execution\n    pass\n\n\nclass RestoreEnvToComputeToWrite(Exception):\n    \"\"\"\n    Used to restore the towrite and to compute of an old env\n    \"\"\"\n\nclass WebProgress(models.TransientModel):\n    _name = 'web.progress'\n    _description = \"Operation Progress\"\n    _transient_max_hours = 0.5\n    # time between progress reports (in seconds)\n    _progress_period_secs = 5\n\n    msg = fields.Char(\"Message\")\n    code = fields.Char(\"Code\", required=True, index=True)\n    recur_depth = fields.Integer(\"Recursion depth\", index=True, default=0)\n    progress = fields.Integer(\"Progress\")\n    progress_total = fields.Float(\"Progress Total\")\n    done = fields.Integer(\"Done\")\n    total = fields.Integer(\"Total\")\n    time_left = fields.Char(\"Time Left\")\n    time_total = fields.Char(\"Time Total\")\n    time_elapsed = fields.Char(\"Elapsed Time\")\n    state = fields.Selection([('ongoing', \"Ongoing\"),\n                              ('done', \"Done\"),\n                              ('cancel', \"Cancelled\"),\n                              ], \"State\")\n    cancellable = fields.Boolean(\"Cancellable\")\n\n    #\n    # Called by web client\n    #\n\n    @api.model\n    def cancel_progress(self, code=None):\n        \"\"\"\n        Register cancelled operation\n        :param code: web progress code\n        \"\"\"\n        vals = {\n            'code': code,\n            'state': 'cancel',\n        }\n        _logger.info('Cancelling progress {}'.format(code))\n        self._create_progress([vals], notify=False)\n\n    @api.model\n    def get_user_name(self, code):\n        \"\"\"\n        Cache user name to avoid SELECT queries touching potentially locked tables\n        res_users and res_partner on progress reporting.\n        :param user_id: (int) ID of res.users record\n        :return: (str) User Name\n        \"\"\"\n        with lock:\n            # use cached user name\n            return user_name.get(code, '')\n\n    @api.model\n    def get_progress_rpc(self, code=None):\n        \"\"\"\n        External call to get progress for given code\n        :param code: web progress code\n        \"\"\"\n        with registry(self.env.cr.dbname).cursor() as new_cr:\n            # Create a new environment with new cursor database\n            new_env = api.Environment(new_cr, self.env.uid, self.env.context)\n            # with_env replace original env for this method\n            progress_obj = self.with_env(new_env)\n            return progress_obj.get_progress(code)\n\n    @api.model\n    def get_progress(self, code=None, recur_depth=None):\n        \"\"\"\n        Get progress for given code\n        :param code: web progress code\n        :param recur_depth: recursion depth\n        \"\"\"\n        result = []\n        domain = []\n        if recur_depth is not None:\n            domain.append(('recur_depth', '=', recur_depth))\n        if code:\n            domain.append(('code', '=', code))\n        if domain:\n            progress_id = self.search(domain, order='create_date DESC,recur_depth DESC', limit=1)\n        else:\n            progress_id = self.env[self._name]\n        # check progress of parent operations\n        if recur_depth is None and progress_id.recur_depth:\n            for parent_depth in range(progress_id.recur_depth):\n                result += self.get_progress(code, recur_depth=parent_depth)\n        progress_vals = {\n            'msg': html.escape(progress_id.msg or ''),\n            'code': progress_id.code,\n            'progress': progress_id.progress,\n            'progress_total': progress_id.progress_total,\n            'done': progress_id.done,\n            'total': progress_id.total,\n            'time_left': progress_id.time_left,\n            'time_total': progress_id.time_total,\n            'time_elapsed': progress_id.time_elapsed,\n            'state': progress_id.state,\n            'cancellable': progress_id.cancellable,\n            'uid': progress_id.create_uid.id,\n            'user': self.get_user_name(code) or progress_id.create_uid.name,\n        }\n        # register this operation progress\n        result.append(progress_vals)\n\n        return result\n\n    @api.model\n    def is_progress_admin(self, user_id=None):\n        \"\"\"\n        Check if the current user (or a user given by parameter)\n        has progress admin credentials.\n        :return:\n        \"\"\"\n        if not user_id:\n            user_id = self.env.user\n        # superuser and users being in group system are progress admins\n        return user_id._is_superuser() or user_id._is_system()\n\n    @api.model\n    def get_all_progress(self, recency=_progress_period_secs * 2):\n        \"\"\"\n        Get progress information for all ongoing operations\n        :param recency: (int) seconds back\n        :return list of progress codes\n        \"\"\"\n        query = \"\"\"\n        SELECT code, array_agg(state) FROM web_progress\n        WHERE create_date > timezone('utc', now()) - INTERVAL '{recency} SECOND'\n              AND recur_depth = 0 {user_id}\n        GROUP BY code\n        \"\"\".format(\n            recency=recency or 0,\n            user_id=not self.is_progress_admin() and \"AND create_uid = {user_id}\"\n                .format(\n                user_id=self.env.user.id,\n            ) or '')\n        # superuser has right to see (and cancel) progress of everybody\n        self.env.cr.execute(query)\n        result = self.env.cr.fetchall()\n        ret = [{\n            'code': r[0],\n        } for r in result if r[0] and 'cancel' not in r[1] and 'done' not in r[1]]\n        return ret\n\n    #\n    # Protected members called by backend\n    # Do not call them directly\n    #\n\n    @api.model\n    def _report_progress(self, data, msg='', total=None, cancellable=True, log_level=\"info\"):\n        \"\"\"\n        Progress reporting generator\n        :param data: collection / generator to iterate onto\n        :param msg: msg to mass in progress report\n        :param total: provide total directly to avoid calling len on data (which fails on generators)\n        :param cancellable: indicates whether the operation is cancellable\n        :param log_level: log level to use when logging progress\n        :return: yields every element of iteration\n        \"\"\"\n        global recur_depths\n        # web progress_code typically comes from web client in call context\n        code = self.env.context.get('progress_code')\n        if total is None:\n            total = len(data)\n        if not code or total <= 1:\n            # no progress reporting when no code and for singletons\n            for elem in data:\n                yield elem\n            return\n        with lock:\n            recur_depth = self._get_recur_depth(code)\n            if recur_depth:\n                recur_depths[code] += 1\n            else:\n                recur_depths[code] = 1\n            # cache user name at the beginning of the base-level progress\n                user_name[code] = self.env.user.name\n        params = dict(done=0, progress=0.0, state='ongoing', code=code, total=total, msg=msg, recur_depth=recur_depth,\n                          cancellable=cancellable, log_level=log_level)\n        precise_code = self._get_precise_code(params)\n        with lock:\n            progress_data[precise_code] = dict(params)\n        try:\n            for done, rec in zip(range(total), data):\n                params['done'] = done\n                params['progress'] = round(100 * done / total, 2)\n                params['state'] = done >= total and 'done' or 'ongoing'\n                self._report_progress_do_percent(params)\n                yield rec\n        finally:\n            # finally record progress as finished\n            self._report_progress_done(params)\n            with lock:\n                recur_depths[code] -= 1\n                if not recur_depths[code]:\n                    del recur_depths[code]\n                    # destroy user name only at the end of the base-level progress\n                    if code in user_name:\n                        del user_name[code]\n\n    @api.model\n    def _get_recur_depth(self, code):\n        \"\"\"\n        Get current recursion depth\n        :param code: web progress code\n        :return: current recursion depth\n        \"\"\"\n        global recur_depths\n        with lock:\n            recur_depth = recur_depths.get(code, 0)\n        return recur_depth\n\n    @api.model\n    def _create_progress(self, vals_list, notify=True):\n        \"\"\"\n        Create a web progress record\n        Creation uses a fresh cursor, i.e. outside the current transaction scope\n        :param vals: list of creation vals\n        :return: None\n        \"\"\"\n        if not vals_list:\n            return\n        code = vals_list[0].get('code')\n        try:\n            with registry(self.env.cr.dbname).cursor() as new_cr:\n                # Create a new environment with a new cursor\n                new_env = api.Environment(new_cr, self.env.uid, self.env.context)\n                # clear whatever is to be computed or written\n                # it will be restored later on\n                new_env.clear()\n                # with_env replaces the original env for this method\n                progress_obj = self.with_env(new_env)\n                progress_obj.create(vals_list)\n                # notify bus\n                if notify:\n                    progress_notif = progress_obj.get_progress(code)\n                    new_env['bus.bus']._sendone('web_progress', 'web_progress', progress_notif)\n                # isolated transaction to commit\n                new_env.cr.commit()\n                # restore main transaction's data\n                raise RestoreEnvToComputeToWrite\n        except RestoreEnvToComputeToWrite:\n            pass\n\n    @api.model\n    def _check_cancelled(self, params):\n        \"\"\"\n        Check if operation was not cancelled by the user or progress admin.\n        The check is executed using a fresh cursor, i.e., it looks outside the current transaction scope\n        :param code: web progress code\n        :return: (recordset) res.users of the user that cancelled the operation\n        \"\"\"\n        code = params.get('code')\n        with registry(self.env.cr.dbname).cursor() as new_cr:\n            # use new cursor to check for cancel\n            query = \"\"\"\n            SELECT create_uid FROM web_progress\n            WHERE code = %s AND state = 'cancel' AND recur_depth = 0\n                \n            \"\"\"\n            new_cr.execute(query, (code, ))\n            result = new_cr.fetchall()\n            if result:\n                user_id = self.create_uid.browse(result[0])\n                if self.env.user == user_id or self.is_progress_admin(user_id):\n                    return user_id\n        return False\n\n    def _get_parent_codes(self, params):\n        \"\"\"\n        Get list of precise codes of all parents\n        \"\"\"\n        code = params.get('code')\n        return [code + '##' + str(d) for d in range(params.get('recur_depth'))]\n\n    def _get_precise_code(self, params):\n        \"\"\"\n        Get precise code, i.e. progress code + recurency depth level\n        \"\"\"\n        return params.get('code') + '##' + str(params.get('recur_depth'))\n\n    def _format_time(self, seconds):\n        \"\"\"\n        Format seconds in h:mm:ss format\n        :param seconds: number of seconds\n        :return: (str) time left in h:mm:ss format\n        \"\"\"\n        ts_min, ts_sec = divmod(int(seconds), 60)\n        ts_hour, ts_min = divmod(ts_min, 60)\n        ret = \"{}:{:0>2d}:{:0>2d}\".format(ts_hour, ts_min, ts_sec)\n        return ret\n\n    def _get_time_left(self, params, time_now, first_ts):\n        \"\"\"\n        Compute est. time left and total\n        :param params: params of progress\n        :param time_now: datetime of now\n        :param first_ts: datetime of first progress report\n        :return: (pair of str) time left in h:mm:ss format and time total of operation\n        \"\"\"\n        time_left = ''\n        time_total = ''\n        time_elapsed = ''\n        if first_ts:\n            pogress_total = params.get('progress_total', 0)\n            if pogress_total > 0:\n                time_per_percent = (time_now - first_ts) / pogress_total\n                progress_left = 100.0 - pogress_total\n                time_left = self._format_time(progress_left * time_per_percent.total_seconds())\n                time_total = self._format_time(100.0 * time_per_percent.total_seconds())\n                time_elapsed = self._format_time((time_now - first_ts).total_seconds())\n        return time_left, time_total, time_elapsed\n\n    def _get_progress_total(self, params):\n        \"\"\"\n        Get total progress taking into account all progress recur depths\n        :return: (float) real progress\n        \"\"\"\n        global progress_data\n        codes = self._get_parent_codes(params)\n        codes.append(self._get_precise_code(params))\n        progress_total = 0.0\n        progress_depth = 100.0\n        for precise_code in codes:\n            with lock:\n                params_prec = progress_data.get(precise_code)\n            if not params_prec or 'done' not in params_prec or 'total' not in params_prec or params_prec['total'] == 0:\n                continue\n            progress_total += float(params_prec['progress']) * progress_depth / 100\n            progress_depth /= params_prec['total']\n        return progress_total\n\n    def _set_attrib_for_all(self, params, attrib, value):\n        \"\"\"\n        Set value of an attrbute to params in all recur depth levels\n        :param params: params to identify code and depth\n        :param attrib: name of attribute to change\n        :param value: value of attribute to change\n        \"\"\"\n        global progress_data\n        codes = self._get_parent_codes(params)\n        codes.append(self._get_precise_code(params))\n        with lock:\n            params[attrib] = value\n            with lock:\n                for precise_code in codes:\n                    progress_data[precise_code][attrib] = value\n\n    def _report_progress_do_percent(self, params):\n        \"\"\"\n        Progress reporting function\n        At the moment this only logs the progress.\n        :param params: dict with parameters:\n            done: how much items processed\n            total: total of items to process\n            msg: message for progress report\n            recur_depth: recursion depth\n            cancellable: indicates whether the operation is cancellable\n        :return: None\n        \"\"\"\n        # check the time from last progress report\n        global last_report_time, first_report_time, progress_data\n        code = params.get('code')\n        precise_code = self._get_precise_code(params)\n        time_now = datetime.now()\n        with lock:\n            first_ts = first_report_time.get(code)\n            if not first_ts:\n                first_report_time[code] = time_now\n            last_ts = last_report_time.get(code)\n            if not last_ts:\n                last_ts = (time_now - timedelta(seconds=self._progress_period_secs + 1))\n            progress_data[precise_code] = dict(params)\n            progress_total = self._get_progress_total(params)\n            self._set_attrib_for_all(params, 'progress_total', progress_total)\n        period_sec = (time_now - last_ts).total_seconds()\n        # report progress every time period\n        if period_sec >= self._progress_period_secs:\n            if params.get('cancellable', True):\n                user_id = self._check_cancelled(params)\n                if user_id:\n                    raise CancelledProgress(_(\"Operation has been cancelled by\") + \" \" + user_id.sudo().name)\n            time_left, time_total, time_elapsed = self._get_time_left(params, time_now, first_ts)\n            if time_left:\n                self._set_attrib_for_all(params, 'time_left', time_left)\n            if time_total:\n                self._set_attrib_for_all(params, 'time_total', time_total)\n            if time_elapsed:\n                self._set_attrib_for_all(params, 'time_elapsed', time_elapsed)\n            self._report_progress_store(params)\n            with lock:\n                last_report_time[code] = time_now\n\n    def _report_progress_done(self, params):\n        \"\"\"\n        Report progress as done.\n        :param code: progress operation code\n        :param total: total units\n        :param msg: logging message\n        :param recur_depth: recursion depth\n        :param cancellable: indicates whether the operation is cancellable\n        :return:\n        \"\"\"\n        global progress_data\n        precise_code = self._get_precise_code(params)\n        params['progress'] = 100\n        params['done'] = params['total']\n        params['state'] = 'done'\n        code = params.get('code')\n        if params.get('recur_depth'):\n            # done sub-level progress, lazy report\n            ret = self._report_progress_do_percent(params)\n        else:\n            # done main-level progress, report immediately\n            progress_data[precise_code] = dict(params)\n            ret = self._report_progress_store(params)\n            with lock:\n                # remove last report time for this code\n                if code in last_report_time:\n                    del last_report_time[code]\n                if code in first_report_time:\n                    del first_report_time[code]\n        # remove data for this precise code code\n        with lock:\n            if precise_code in progress_data:\n                del progress_data[precise_code]\n        return ret\n\n    def _report_progress_prepare_vals(self, params):\n        \"\"\"\n        Filter out all params that are not web.progress fields\n        \"\"\"\n        vals = {k: v for k, v in params.items() if k in self._fields}\n        return vals\n\n    def _report_progress_store(self, params):\n        \"\"\"\n        Progress storing function. Stores progress in log and in db.\n        :param code: progress operation code\n        :param percent: done percent\n        :param done: done units\n        :param total: total units\n        :param msg: logging message\n        :param recur_depth: recursion depth\n        :param cancellable: indicates whether the operation is cancellable\n        :param state: state of progress: ongoing or done\n        \"\"\"\n        global progress_data\n        codes = self._get_parent_codes(params)\n        codes.append(self._get_precise_code(params))\n        vals_list = []\n        first_line = True\n        for precise_code in codes:\n            with lock:\n                my_progress_data = progress_data.get(precise_code)\n            if not my_progress_data:\n                continue\n            log_message = \"Progress {code} {level} {progress}% ({done}/{total}) {msg}\".format(\n                level=(\">\" * (my_progress_data.get('recur_depth') + 1)),\n                **my_progress_data)\n            log_level = my_progress_data.get('log_level')\n            if hasattr(_logger, log_level):\n                logger_cmd = getattr(_logger, log_level)\n            else:\n                logger_cmd = _logger.info\n            if first_line and \"progress_total\" in my_progress_data:\n                log_message_pre = \\\n                    \"Progress {code} total {progress_total:.02f}%\".format(**my_progress_data)\n                if \"time_left\" in my_progress_data:\n                    log_message_pre += \", est. time left {}\".format(my_progress_data.get('time_left'))\n                if \"time_total\" in my_progress_data:\n                    log_message_pre += \", est. time total {}\".format(my_progress_data.get('time_total'))\n                if \"time_elapsed\" in my_progress_data:\n                    log_message_pre += \", elapsed time {}\".format(my_progress_data.get('time_elapsed'))\n                logger_cmd(log_message_pre)\n            logger_cmd(log_message)\n            vals_list.append(self._report_progress_prepare_vals(my_progress_data))\n            first_line = False\n        self._create_progress(vals_list)\n", "from odoo.tests import common, tagged\nfrom odoo import exceptions\nimport uuid\nimport logging\nfrom ..models.web_progress import last_report_time\n\n_logger = logging.getLogger(__name__)\n\n\n@tagged('at_install', '-post_install')\nclass WebProgressTest(common.SavepointCase):\n\n    def check_all_progress_data_empty(self):\n        \"\"\"\n        Check that all global progress data is empty after tests\n        \"\"\"\n        self.assertFalse(last_report_time, msg=\"Global variable last_report_time shall be empty by now\")\n\n    def setUp(self):\n        super(WebProgressTest, self).setUp()\n        self.maxDiff = None\n        self.partner_obj = self.env['res.partner']\n        self.web_progress_obj = self.env['web.progress']\n        self.partner_ids = self.partner_obj\n        self.partner_vals = {}\n        for idx in range(20):\n            self.partner_vals[idx] = dict(name='Test{}'.format(idx),\n                                          email='email{}@test.me'.format(idx))\n            self.partner_ids |= self.partner_obj.create(dict(self.partner_vals[idx]))\n        self.addCleanup(self.check_all_progress_data_empty)\n\n    def _check_web_progress_iter_recordset(self, total, recur_level=0):\n        \"\"\"\n        Check that web_progress_iter works correctly for a recordset\n        :param total: total number of collection elements\n        \"\"\"\n        progress_iter = self.partner_ids[:total].with_progress(msg=\"Total {} Level {}\".format(total,\n                                                                                              recur_level))\n        self.assertEqual(len(progress_iter), total, msg=\"Length shall be accessible\")\n        if total > 0:\n            self.assertEqual(progress_iter[0], self.partner_ids[0], msg=\"Indexing shall be accessible\")\n            self.assertEqual(progress_iter._name, self.partner_ids._name, msg=\"Attributes shall be accessible\")\n        if total == len(self.partner_ids):\n            self.assertEqual(progress_iter.ids, self.partner_ids.ids, msg=\"Attributes shall be accessible\")\n        count = 0\n        for idx, partner_id in zip(range(total),progress_iter):\n            self.assertEqual(partner_id.name, self.partner_vals[idx]['name'].format(idx), msg=\"Wrong name\")\n            self.assertEqual(partner_id.email, self.partner_vals[idx]['email'].format(idx), msg=\"Wrong email\")\n            count += 1\n            if recur_level > 0:\n                self._check_web_progress_iter_recordset(total, recur_level - 1)\n        self.assertEqual(count, total, msg=\"Not all elements are yielded from a collection\")\n\n    def _check_web_progress_iter_recordset_many(self, recur_level=0):\n        \"\"\"\n        Iterate recordsets of different lengths\n        :param recur_level: recursion level of iterations\n        \"\"\"\n        # iterate all partners\n        self._check_web_progress_iter_recordset(len(self.partner_ids), recur_level)\n        # iterate half of all partners\n        self._check_web_progress_iter_recordset(round(len(self.partner_ids)/2), recur_level)\n        # iterate again all partners (no recursion)\n        self._check_web_progress_iter_recordset(len(self.partner_ids))\n        # iterate one partner\n        self._check_web_progress_iter_recordset(1, recur_level)\n        # iterate empty recordset\n        self._check_web_progress_iter_recordset(0, recur_level)\n\n    def _check_web_progress_cancelled(self):\n        \"\"\"\n        Checks that the current operation has been cancelled\n        \"\"\"\n        code = self.partner_ids._context.get('progress_code', None)\n        self.assertIsNotNone(code, msg=\"Progress code shall be in the context\")\n        cancelled = self.web_progress_obj._check_cancelled(dict(code=code))\n        self.assertTrue(cancelled, msg=\"Currect operation should have been cancelled\")\n\n    def test_web_progress_iter_without_web_progress_code(self):\n        \"\"\"\n        Check that web_progress_iter works correctly without a progress_code in context\n        \"\"\"\n        self._check_web_progress_iter_recordset_many(0)\n        self._check_web_progress_iter_recordset_many(1)\n\n    def test_web_progress_iter_with_web_progress_code(self):\n        \"\"\"\n        Check that web_progress_iter works correctly with a progress_code in context\n        \"\"\"\n        progress_code = str(uuid.uuid4())\n        self.partner_ids = self.partner_ids.with_context(progress_code=progress_code)\n        self._check_web_progress_iter_recordset_many(0)\n        self._check_web_progress_iter_recordset_many(1)\n\n    def test_web_progress_iter_with_web_progress_code_cancel(self):\n        \"\"\"\n        Check that cancel request is respected by web_progress_iter\n        \"\"\"\n        progress_code = str(uuid.uuid4())\n        self.partner_ids = self.partner_ids.with_context(progress_code=progress_code)\n        self._check_web_progress_iter_recordset_many(0)\n        self.partner_ids.web_progress_cancel()\n        self._check_web_progress_cancelled()\n        # any further iteration shall raise UserError\n        with self.assertRaises(exceptions.UserError, msg=\"Exception UserErro shall have been raised\"):\n            self._check_web_progress_iter_recordset_many(0)\n        self._check_web_progress_cancelled()\n\n    def test_web_progress_percent(self):\n        \"\"\"\n        Check web_progress_percent\n        \"\"\"\n        progress_code = str(uuid.uuid4())\n        self.partner_ids = self.partner_ids.with_context(progress_code=progress_code)\n        self.partner_ids.web_progress_percent(0, \"Start\")\n        self.partner_ids.web_progress_percent(50, \"Middle\")\n        self.partner_ids.web_progress_percent(100, \"End\")\n"], "fixing_code": ["# Part of web_progress. See LICENSE file for full copyright and licensing details.\nfrom odoo import models, api, registry, fields, _, SUPERUSER_ID\nfrom odoo.exceptions import UserError\nfrom threading import RLock\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nimport html\nimport odoo\nimport json\nimport logging\n\n_logger = logging.getLogger(__name__)\nlock = RLock()\n# track time between progress reports\nlast_report_time = {}\n# track time from the beginnig\nfirst_report_time = {}\n# store recursion depth for every operation\nrecur_depths = {}\n# progress reports data\nprogress_data = defaultdict(dict)\n# user name\nuser_name = {}\n\n\ndef json_dump(v):\n    return json.dumps(v, separators=(',', ':'))\n\n\nclass CancelledProgress(models.UserError):\n    # exception used to cancel the execution\n    pass\n\n\nclass RestoreEnvToComputeToWrite(Exception):\n    \"\"\"\n    Used to restore the towrite and to compute of an old env\n    \"\"\"\n\nclass WebProgress(models.TransientModel):\n    _name = 'web.progress'\n    _description = \"Operation Progress\"\n    _transient_max_hours = 0.5\n    # time between progress reports (in seconds)\n    _progress_period_secs = 5\n\n    msg = fields.Char(\"Message\")\n    code = fields.Char(\"Code\", required=True, index=True)\n    recur_depth = fields.Integer(\"Recursion depth\", index=True, default=0)\n    progress = fields.Integer(\"Progress\")\n    progress_total = fields.Float(\"Progress Total\")\n    done = fields.Integer(\"Done\")\n    total = fields.Integer(\"Total\")\n    time_left = fields.Char(\"Time Left\")\n    time_total = fields.Char(\"Time Total\")\n    time_elapsed = fields.Char(\"Elapsed Time\")\n    state = fields.Selection([('ongoing', \"Ongoing\"),\n                              ('done', \"Done\"),\n                              ('cancel', \"Cancelled\"),\n                              ], \"State\")\n    cancellable = fields.Boolean(\"Cancellable\")\n\n    #\n    # Called by web client\n    #\n\n    @api.model\n    def cancel_progress(self, code=None):\n        \"\"\"\n        Register cancelled operation\n        :param code: web progress code\n        \"\"\"\n        vals = {\n            'code': code,\n            'state': 'cancel',\n        }\n        _logger.info('Cancelling progress {}'.format(code))\n        self._create_progress([vals], notify=False)\n\n    @api.model\n    def get_user_name(self, code):\n        \"\"\"\n        Cache user name to avoid SELECT queries touching potentially locked tables\n        res_users and res_partner on progress reporting.\n        :param user_id: (int) ID of res.users record\n        :return: (str) User Name\n        \"\"\"\n        with lock:\n            # use cached user name\n            return user_name.get(code, '')\n\n    @api.model\n    def get_progress_rpc(self, code=None):\n        \"\"\"\n        External call to get progress for given code\n        :param code: web progress code\n        \"\"\"\n        with registry(self.env.cr.dbname).cursor() as new_cr:\n            # Create a new environment with new cursor database\n            new_env = api.Environment(new_cr, self.env.uid, self.env.context)\n            # with_env replace original env for this method\n            progress_obj = self.with_env(new_env)\n            return progress_obj.get_progress(code)\n\n    @api.model\n    def get_progress(self, code=None, recur_depth=None):\n        \"\"\"\n        Get progress for given code\n        :param code: web progress code\n        :param recur_depth: recursion depth\n        \"\"\"\n        result = []\n        domain = []\n        if recur_depth is not None:\n            domain.append(('recur_depth', '=', recur_depth))\n        if code:\n            domain.append(('code', '=', code))\n        if domain:\n            progress_id = self.search(domain, order='create_date DESC,recur_depth DESC', limit=1)\n        else:\n            progress_id = self.env[self._name]\n        # check progress of parent operations\n        if recur_depth is None and progress_id.recur_depth:\n            for parent_depth in range(progress_id.recur_depth):\n                result += self.get_progress(code, recur_depth=parent_depth)\n        progress_vals = {\n            'msg': html.escape(progress_id.msg or ''),\n            'code': progress_id.code,\n            'progress': progress_id.progress,\n            'progress_total': progress_id.progress_total,\n            'done': progress_id.done,\n            'total': progress_id.total,\n            'time_left': progress_id.time_left,\n            'time_total': progress_id.time_total,\n            'time_elapsed': progress_id.time_elapsed,\n            'state': progress_id.state,\n            'cancellable': progress_id.cancellable,\n            'uid': progress_id.create_uid.id,\n            'user': self.get_user_name(code) or progress_id.create_uid.name,\n        }\n        # register this operation progress\n        result.append(progress_vals)\n\n        return result\n\n    @api.model\n    def is_progress_admin(self, user_id=None):\n        \"\"\"\n        Check if the current user (or a user given by parameter)\n        has progress admin credentials.\n        :return:\n        \"\"\"\n        if not user_id:\n            user_id = self.env.user\n        # superuser and users being in group system are progress admins\n        return user_id._is_superuser() or user_id._is_system()\n\n    @api.model\n    def get_all_progress(self, recency=_progress_period_secs * 2):\n        \"\"\"\n        Get progress information for all ongoing operations\n        :param recency: (int) seconds back\n        :return list of progress codes\n        \"\"\"\n        query = \"\"\"\n        SELECT code, array_agg(state) FROM web_progress\n        WHERE create_date > timezone('utc', now()) - INTERVAL '%s SECOND'\n              AND recur_depth = 0 {user_id}\n        GROUP BY code\n        \"\"\".format(\n            recency=recency or 0,\n            user_id=not self.is_progress_admin() and \"AND create_uid = {user_id}\"\n                .format(\n                user_id=self.env.user.id,\n            ) or '')\n        # superuser has right to see (and cancel) progress of everybody\n        self.env.cr.execute(query, (recency, ))\n        result = self.env.cr.fetchall()\n        ret = [{\n            'code': r[0],\n        } for r in result if r[0] and 'cancel' not in r[1] and 'done' not in r[1]]\n        return ret\n\n    #\n    # Protected members called by backend\n    # Do not call them directly\n    #\n\n    @api.model\n    def _report_progress(self, data, msg='', total=None, cancellable=True, log_level=\"info\"):\n        \"\"\"\n        Progress reporting generator\n        :param data: collection / generator to iterate onto\n        :param msg: msg to mass in progress report\n        :param total: provide total directly to avoid calling len on data (which fails on generators)\n        :param cancellable: indicates whether the operation is cancellable\n        :param log_level: log level to use when logging progress\n        :return: yields every element of iteration\n        \"\"\"\n        global recur_depths\n        # web progress_code typically comes from web client in call context\n        code = self.env.context.get('progress_code')\n        if total is None:\n            total = len(data)\n        if not code or total <= 1:\n            # no progress reporting when no code and for singletons\n            for elem in data:\n                yield elem\n            return\n        with lock:\n            recur_depth = self._get_recur_depth(code)\n            if recur_depth:\n                recur_depths[code] += 1\n            else:\n                recur_depths[code] = 1\n            # cache user name at the beginning of the base-level progress\n                user_name[code] = self.env.user.name\n        params = dict(done=0, progress=0.0, state='ongoing', code=code, total=total, msg=msg, recur_depth=recur_depth,\n                          cancellable=cancellable, log_level=log_level)\n        precise_code = self._get_precise_code(params)\n        with lock:\n            progress_data[precise_code] = dict(params)\n        try:\n            for done, rec in zip(range(total), data):\n                params['done'] = done\n                params['progress'] = round(100 * done / total, 2)\n                params['state'] = done >= total and 'done' or 'ongoing'\n                self._report_progress_do_percent(params)\n                yield rec\n        finally:\n            # finally record progress as finished\n            self._report_progress_done(params)\n            with lock:\n                recur_depths[code] -= 1\n                if not recur_depths[code]:\n                    del recur_depths[code]\n                    # destroy user name only at the end of the base-level progress\n                    if code in user_name:\n                        del user_name[code]\n\n    @api.model\n    def _get_recur_depth(self, code):\n        \"\"\"\n        Get current recursion depth\n        :param code: web progress code\n        :return: current recursion depth\n        \"\"\"\n        global recur_depths\n        with lock:\n            recur_depth = recur_depths.get(code, 0)\n        return recur_depth\n\n    @api.model\n    def _create_progress(self, vals_list, notify=True):\n        \"\"\"\n        Create a web progress record\n        Creation uses a fresh cursor, i.e. outside the current transaction scope\n        :param vals: list of creation vals\n        :return: None\n        \"\"\"\n        if not vals_list:\n            return\n        code = vals_list[0].get('code')\n        try:\n            with registry(self.env.cr.dbname).cursor() as new_cr:\n                # Create a new environment with a new cursor\n                new_env = api.Environment(new_cr, self.env.uid, self.env.context)\n                # clear whatever is to be computed or written\n                # it will be restored later on\n                new_env.clear()\n                # with_env replaces the original env for this method\n                progress_obj = self.with_env(new_env)\n                progress_obj.create(vals_list)\n                # notify bus\n                if notify:\n                    progress_notif = progress_obj.get_progress(code)\n                    new_env['bus.bus']._sendone('web_progress', 'web_progress', progress_notif)\n                # isolated transaction to commit\n                new_env.cr.commit()\n                # restore main transaction's data\n                raise RestoreEnvToComputeToWrite\n        except RestoreEnvToComputeToWrite:\n            pass\n\n    @api.model\n    def _check_cancelled(self, params):\n        \"\"\"\n        Check if operation was not cancelled by the user or progress admin.\n        The check is executed using a fresh cursor, i.e., it looks outside the current transaction scope\n        :param code: web progress code\n        :return: (recordset) res.users of the user that cancelled the operation\n        \"\"\"\n        code = params.get('code')\n        with registry(self.env.cr.dbname).cursor() as new_cr:\n            # use new cursor to check for cancel\n            query = \"\"\"\n            SELECT create_uid FROM web_progress\n            WHERE code = %s AND state = 'cancel' AND recur_depth = 0\n                \n            \"\"\"\n            new_cr.execute(query, (code, ))\n            result = new_cr.fetchall()\n            if result:\n                user_id = self.create_uid.browse(result[0])\n                if self.env.user == user_id or self.is_progress_admin(user_id):\n                    return user_id\n        return False\n\n    def _get_parent_codes(self, params):\n        \"\"\"\n        Get list of precise codes of all parents\n        \"\"\"\n        code = params.get('code')\n        return [code + '##' + str(d) for d in range(params.get('recur_depth'))]\n\n    def _get_precise_code(self, params):\n        \"\"\"\n        Get precise code, i.e. progress code + recurency depth level\n        \"\"\"\n        return params.get('code') + '##' + str(params.get('recur_depth'))\n\n    def _format_time(self, seconds):\n        \"\"\"\n        Format seconds in h:mm:ss format\n        :param seconds: number of seconds\n        :return: (str) time left in h:mm:ss format\n        \"\"\"\n        ts_min, ts_sec = divmod(int(seconds), 60)\n        ts_hour, ts_min = divmod(ts_min, 60)\n        ret = \"{}:{:0>2d}:{:0>2d}\".format(ts_hour, ts_min, ts_sec)\n        return ret\n\n    def _get_time_left(self, params, time_now, first_ts):\n        \"\"\"\n        Compute est. time left and total\n        :param params: params of progress\n        :param time_now: datetime of now\n        :param first_ts: datetime of first progress report\n        :return: (pair of str) time left in h:mm:ss format and time total of operation\n        \"\"\"\n        time_left = ''\n        time_total = ''\n        time_elapsed = ''\n        if first_ts:\n            pogress_total = params.get('progress_total', 0)\n            if pogress_total > 0:\n                time_per_percent = (time_now - first_ts) / pogress_total\n                progress_left = 100.0 - pogress_total\n                time_left = self._format_time(progress_left * time_per_percent.total_seconds())\n                time_total = self._format_time(100.0 * time_per_percent.total_seconds())\n                time_elapsed = self._format_time((time_now - first_ts).total_seconds())\n        return time_left, time_total, time_elapsed\n\n    def _get_progress_total(self, params):\n        \"\"\"\n        Get total progress taking into account all progress recur depths\n        :return: (float) real progress\n        \"\"\"\n        global progress_data\n        codes = self._get_parent_codes(params)\n        codes.append(self._get_precise_code(params))\n        progress_total = 0.0\n        progress_depth = 100.0\n        for precise_code in codes:\n            with lock:\n                params_prec = progress_data.get(precise_code)\n            if not params_prec or 'done' not in params_prec or 'total' not in params_prec or params_prec['total'] == 0:\n                continue\n            progress_total += float(params_prec['progress']) * progress_depth / 100\n            progress_depth /= params_prec['total']\n        return progress_total\n\n    def _set_attrib_for_all(self, params, attrib, value):\n        \"\"\"\n        Set value of an attrbute to params in all recur depth levels\n        :param params: params to identify code and depth\n        :param attrib: name of attribute to change\n        :param value: value of attribute to change\n        \"\"\"\n        global progress_data\n        codes = self._get_parent_codes(params)\n        codes.append(self._get_precise_code(params))\n        with lock:\n            params[attrib] = value\n            with lock:\n                for precise_code in codes:\n                    progress_data[precise_code][attrib] = value\n\n    def _report_progress_do_percent(self, params):\n        \"\"\"\n        Progress reporting function\n        At the moment this only logs the progress.\n        :param params: dict with parameters:\n            done: how much items processed\n            total: total of items to process\n            msg: message for progress report\n            recur_depth: recursion depth\n            cancellable: indicates whether the operation is cancellable\n        :return: None\n        \"\"\"\n        # check the time from last progress report\n        global last_report_time, first_report_time, progress_data\n        code = params.get('code')\n        precise_code = self._get_precise_code(params)\n        time_now = datetime.now()\n        with lock:\n            first_ts = first_report_time.get(code)\n            if not first_ts:\n                first_report_time[code] = time_now\n            last_ts = last_report_time.get(code)\n            if not last_ts:\n                last_ts = (time_now - timedelta(seconds=self._progress_period_secs + 1))\n            progress_data[precise_code] = dict(params)\n            progress_total = self._get_progress_total(params)\n            self._set_attrib_for_all(params, 'progress_total', progress_total)\n        period_sec = (time_now - last_ts).total_seconds()\n        # report progress every time period\n        if period_sec >= self._progress_period_secs:\n            if params.get('cancellable', True):\n                user_id = self._check_cancelled(params)\n                if user_id:\n                    raise CancelledProgress(_(\"Operation has been cancelled by\") + \" \" + user_id.sudo().name)\n            time_left, time_total, time_elapsed = self._get_time_left(params, time_now, first_ts)\n            if time_left:\n                self._set_attrib_for_all(params, 'time_left', time_left)\n            if time_total:\n                self._set_attrib_for_all(params, 'time_total', time_total)\n            if time_elapsed:\n                self._set_attrib_for_all(params, 'time_elapsed', time_elapsed)\n            self._report_progress_store(params)\n            with lock:\n                last_report_time[code] = time_now\n\n    def _report_progress_done(self, params):\n        \"\"\"\n        Report progress as done.\n        :param code: progress operation code\n        :param total: total units\n        :param msg: logging message\n        :param recur_depth: recursion depth\n        :param cancellable: indicates whether the operation is cancellable\n        :return:\n        \"\"\"\n        global progress_data\n        precise_code = self._get_precise_code(params)\n        params['progress'] = 100\n        params['done'] = params['total']\n        params['state'] = 'done'\n        code = params.get('code')\n        if params.get('recur_depth'):\n            # done sub-level progress, lazy report\n            ret = self._report_progress_do_percent(params)\n        else:\n            # done main-level progress, report immediately\n            progress_data[precise_code] = dict(params)\n            ret = self._report_progress_store(params)\n            with lock:\n                # remove last report time for this code\n                if code in last_report_time:\n                    del last_report_time[code]\n                if code in first_report_time:\n                    del first_report_time[code]\n        # remove data for this precise code code\n        with lock:\n            if precise_code in progress_data:\n                del progress_data[precise_code]\n        return ret\n\n    def _report_progress_prepare_vals(self, params):\n        \"\"\"\n        Filter out all params that are not web.progress fields\n        \"\"\"\n        vals = {k: v for k, v in params.items() if k in self._fields}\n        return vals\n\n    def _report_progress_store(self, params):\n        \"\"\"\n        Progress storing function. Stores progress in log and in db.\n        :param code: progress operation code\n        :param percent: done percent\n        :param done: done units\n        :param total: total units\n        :param msg: logging message\n        :param recur_depth: recursion depth\n        :param cancellable: indicates whether the operation is cancellable\n        :param state: state of progress: ongoing or done\n        \"\"\"\n        global progress_data\n        codes = self._get_parent_codes(params)\n        codes.append(self._get_precise_code(params))\n        vals_list = []\n        first_line = True\n        for precise_code in codes:\n            with lock:\n                my_progress_data = progress_data.get(precise_code)\n            if not my_progress_data:\n                continue\n            log_message = \"Progress {code} {level} {progress}% ({done}/{total}) {msg}\".format(\n                level=(\">\" * (my_progress_data.get('recur_depth') + 1)),\n                **my_progress_data)\n            log_level = my_progress_data.get('log_level')\n            if hasattr(_logger, log_level):\n                logger_cmd = getattr(_logger, log_level)\n            else:\n                logger_cmd = _logger.info\n            if first_line and \"progress_total\" in my_progress_data:\n                log_message_pre = \\\n                    \"Progress {code} total {progress_total:.02f}%\".format(**my_progress_data)\n                if \"time_left\" in my_progress_data:\n                    log_message_pre += \", est. time left {}\".format(my_progress_data.get('time_left'))\n                if \"time_total\" in my_progress_data:\n                    log_message_pre += \", est. time total {}\".format(my_progress_data.get('time_total'))\n                if \"time_elapsed\" in my_progress_data:\n                    log_message_pre += \", elapsed time {}\".format(my_progress_data.get('time_elapsed'))\n                logger_cmd(log_message_pre)\n            logger_cmd(log_message)\n            vals_list.append(self._report_progress_prepare_vals(my_progress_data))\n            first_line = False\n        self._create_progress(vals_list)\n", "from odoo.tests import common, tagged\nfrom odoo import exceptions, api, registry\nfrom odoo.tools import mute_logger\nfrom psycopg2.errors import SyntaxError\nimport uuid\nimport logging\nfrom ..models.web_progress import last_report_time\n\n_logger = logging.getLogger(__name__)\n\n\n@tagged('at_install', '-post_install')\nclass WebProgressTest(common.SavepointCase):\n\n    def check_all_progress_data_empty(self):\n        \"\"\"\n        Check that all global progress data is empty after tests\n        \"\"\"\n        self.assertFalse(last_report_time, msg=\"Global variable last_report_time shall be empty by now\")\n\n    def setUp(self):\n        super(WebProgressTest, self).setUp()\n        self.maxDiff = None\n        self.partner_obj = self.env['res.partner']\n        self.web_progress_obj = self.env['web.progress']\n        self.partner_ids = self.partner_obj\n        self.partner_vals = {}\n        for idx in range(20):\n            self.partner_vals[idx] = dict(name='Test{}'.format(idx),\n                                          email='email{}@test.me'.format(idx))\n            self.partner_ids |= self.partner_obj.create(dict(self.partner_vals[idx]))\n        self.addCleanup(self.check_all_progress_data_empty)\n\n    def _check_web_progress_iter_recordset(self, total, recur_level=0):\n        \"\"\"\n        Check that web_progress_iter works correctly for a recordset\n        :param total: total number of collection elements\n        \"\"\"\n        progress_iter = self.partner_ids[:total].with_progress(msg=\"Total {} Level {}\".format(total,\n                                                                                              recur_level))\n        self.assertEqual(len(progress_iter), total, msg=\"Length shall be accessible\")\n        if total > 0:\n            self.assertEqual(progress_iter[0], self.partner_ids[0], msg=\"Indexing shall be accessible\")\n            self.assertEqual(progress_iter._name, self.partner_ids._name, msg=\"Attributes shall be accessible\")\n        if total == len(self.partner_ids):\n            self.assertEqual(progress_iter.ids, self.partner_ids.ids, msg=\"Attributes shall be accessible\")\n        count = 0\n        for idx, partner_id in zip(range(total),progress_iter):\n            self.assertEqual(partner_id.name, self.partner_vals[idx]['name'].format(idx), msg=\"Wrong name\")\n            self.assertEqual(partner_id.email, self.partner_vals[idx]['email'].format(idx), msg=\"Wrong email\")\n            count += 1\n            if recur_level > 0:\n                self._check_web_progress_iter_recordset(total, recur_level - 1)\n        self.assertEqual(count, total, msg=\"Not all elements are yielded from a collection\")\n\n    def _check_web_progress_iter_recordset_many(self, recur_level=0):\n        \"\"\"\n        Iterate recordsets of different lengths\n        :param recur_level: recursion level of iterations\n        \"\"\"\n        # iterate all partners\n        self._check_web_progress_iter_recordset(len(self.partner_ids), recur_level)\n        # iterate half of all partners\n        self._check_web_progress_iter_recordset(round(len(self.partner_ids)/2), recur_level)\n        # iterate again all partners (no recursion)\n        self._check_web_progress_iter_recordset(len(self.partner_ids))\n        # iterate one partner\n        self._check_web_progress_iter_recordset(1, recur_level)\n        # iterate empty recordset\n        self._check_web_progress_iter_recordset(0, recur_level)\n\n    def _check_web_progress_cancelled(self):\n        \"\"\"\n        Checks that the current operation has been cancelled\n        \"\"\"\n        code = self.partner_ids._context.get('progress_code', None)\n        self.assertIsNotNone(code, msg=\"Progress code shall be in the context\")\n        cancelled = self.web_progress_obj._check_cancelled(dict(code=code))\n        self.assertTrue(cancelled, msg=\"Currect operation should have been cancelled\")\n\n    def test_web_progress_iter_without_web_progress_code(self):\n        \"\"\"\n        Check that web_progress_iter works correctly without a progress_code in context\n        \"\"\"\n        self._check_web_progress_iter_recordset_many(0)\n        self._check_web_progress_iter_recordset_many(1)\n\n    def test_web_progress_iter_with_web_progress_code(self):\n        \"\"\"\n        Check that web_progress_iter works correctly with a progress_code in context\n        \"\"\"\n        progress_code = str(uuid.uuid4())\n        self.partner_ids = self.partner_ids.with_context(progress_code=progress_code)\n        self._check_web_progress_iter_recordset_many(0)\n        self._check_web_progress_iter_recordset_many(1)\n\n    def test_web_progress_iter_with_web_progress_code_cancel(self):\n        \"\"\"\n        Check that cancel request is respected by web_progress_iter\n        \"\"\"\n        progress_code = str(uuid.uuid4())\n        self.partner_ids = self.partner_ids.with_context(progress_code=progress_code)\n        self._check_web_progress_iter_recordset_many(0)\n        self.partner_ids.web_progress_cancel()\n        self._check_web_progress_cancelled()\n        # any further iteration shall raise UserError\n        with self.assertRaises(exceptions.UserError, msg=\"Exception UserErro shall have been raised\"):\n            self._check_web_progress_iter_recordset_many(0)\n        self._check_web_progress_cancelled()\n\n    def test_web_progress_percent(self):\n        \"\"\"\n        Check web_progress_percent\n        \"\"\"\n        progress_code = str(uuid.uuid4())\n        self.partner_ids = self.partner_ids.with_context(progress_code=progress_code)\n        self.partner_ids.web_progress_percent(0, \"Start\")\n        self.partner_ids.web_progress_percent(50, \"Middle\")\n        self.partner_ids.web_progress_percent(100, \"End\")\n\n\nclass WebProgressTestAllProgress(common.SavepointCase):\n    at_install = True\n    post_install = False\n\n    @mute_logger('odoo.sql_db')\n    def test_get_all_progress(self):\n        \"\"\"\n        Check call to get_all_progress without and with parameters.\n        Verify if the parameter is properly escaped in the internal SQL query.\n        \"\"\"\n        progress_code = str(uuid.uuid4())\n        partner_obj = self.env['res.partner'].with_context(progress_code=progress_code)\n        partner_obj.web_progress_percent(0, \"Start\")\n        with api.Environment.manage():\n            with registry(self.env.cr.dbname).cursor() as new_cr:\n                # Create a new environment with a new cursor\n                new_env = api.Environment(new_cr, self.env.uid, self.env.context)\n                progress_obj = self.env['web.progress'].with_env(new_env)\n                res = progress_obj.get_all_progress()\n                self.assertEqual(res, [{'code': progress_code}])\n                res = progress_obj.get_all_progress(0)\n                self.assertEqual(res, [])\n                with self.assertRaises(SyntaxError) as e:\n                    progress_obj.get_all_progress(\"0 SECOND' GROUP BY code; \"\n                                                  \"SELECT code, array_agg(state) FROM web_progress \"\n                                                  \"WHERE create_date > timezone('utc', now()) - INTERVAL '10\")\n                new_cr.rollback()\n"], "filenames": ["web_progress/models/web_progress.py", "web_progress/tests/test_web_progress.py"], "buggy_code_start_loc": [168, 2], "buggy_code_end_loc": [179, 117], "fixing_code_start_loc": [168, 2], "fixing_code_end_loc": [179, 149], "type": "CWE-89", "message": "A SQL injection vulnerability in Grzegorz Marczynski Dynamic Progress Bar (aka web_progress) v. 11.0 through 11.0.2, v12.0 through v12.0.2, v.13.0 through v13.0.2, v.14.0 through v14.0.2.1, v.15.0 through v15.0.2, and v16.0 through v16.0.2.1 allows a remote attacker to gain privileges via the recency parameter in models/web_progress.py component.", "other": {"cve": {"id": "CVE-2023-40954", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-15T01:15:07.993", "lastModified": "2023-12-20T17:55:09.060", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A SQL injection vulnerability in Grzegorz Marczynski Dynamic Progress Bar (aka web_progress) v. 11.0 through 11.0.2, v12.0 through v12.0.2, v.13.0 through v13.0.2, v.14.0 through v14.0.2.1, v.15.0 through v15.0.2, and v16.0 through v16.0.2.1 allows a remote attacker to gain privileges via the recency parameter in models/web_progress.py component."}, {"lang": "es", "value": "Una vulnerabilidad de inyecci\u00f3n SQL en Grzegorz Marczynski Dynamic Progress Bar (tambi\u00e9n conocido como web_progress) v. 11.0 a 11.0.2, v12.0 a v12.0.2, v.13.0 a v13.0.2, v.14.0 a v14.0.2.1, v. 15.0 a v15.0.2 y v16.0 a v16.0.2.1 permiten que un atacante remoto obtenga privilegios a trav\u00e9s del par\u00e1metro de recency en el componente models/web_progress.py."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gmarczynski:dynamic_progress_bar:*:*:*:*:*:odoo:*:*", "versionStartIncluding": "11.0", "versionEndIncluding": "11.0.2", "matchCriteriaId": "531985A9-B207-4725-A508-655C123CF6E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gmarczynski:dynamic_progress_bar:*:*:*:*:*:odoo:*:*", "versionStartIncluding": "12.0", "versionEndIncluding": "12.0.2", "matchCriteriaId": "42FC7AF6-AE47-4E22-9B09-676E195138D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gmarczynski:dynamic_progress_bar:*:*:*:*:*:odoo:*:*", "versionStartIncluding": "13.0", "versionEndIncluding": "13.0.2", "matchCriteriaId": "17D1D5E9-5642-40EE-B479-9B784BE3F165"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gmarczynski:dynamic_progress_bar:*:*:*:*:*:odoo:*:*", "versionStartIncluding": "14.0", "versionEndIncluding": "14.0.2.1", "matchCriteriaId": "7E0D60DD-2F14-408E-9046-E7F1628480D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gmarczynski:dynamic_progress_bar:*:*:*:*:*:odoo:*:*", "versionStartIncluding": "15.0", "versionEndIncluding": "15.0.2", "matchCriteriaId": "BDE686CC-6D2E-4987-B730-396C326D0442"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gmarczynski:dynamic_progress_bar:*:*:*:*:*:odoo:*:*", "versionStartIncluding": "16.0", "versionEndIncluding": "16.0.2.1", "matchCriteriaId": "3C6442BB-E4BD-4909-9A0D-DCA9C2C8881C"}]}]}], "references": [{"url": "https://github.com/gmarczynski/odoo-web-progress/commit/3c867f1cf7447449c81b1aa24ebb1f7ae757489f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/luvsn/OdZoo/tree/main/exploits/web_progress", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gmarczynski/odoo-web-progress/commit/3c867f1cf7447449c81b1aa24ebb1f7ae757489f"}}