{"buggy_code": ["from typing import List, Optional, Tuple\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.encoding import force_str\nfrom rest_framework.authentication import BasicAuthentication, get_authorization_header\nfrom rest_framework.exceptions import AuthenticationFailed\nfrom rest_framework.request import Request\nfrom sentry_relay import UnpackError\n\nfrom sentry import options\nfrom sentry.auth.system import SystemToken, is_internal_ip\nfrom sentry.models import ApiApplication, ApiKey, ApiToken, OrgAuthToken, ProjectKey, Relay\nfrom sentry.relay.utils import get_header_relay_id, get_header_relay_signature\nfrom sentry.services.hybrid_cloud.rpc import compare_signature\nfrom sentry.utils.sdk import configure_scope\nfrom sentry.utils.security.orgauthtoken_token import SENTRY_ORG_AUTH_TOKEN_PREFIX, hash_token\n\n\ndef is_internal_relay(request, public_key):\n    \"\"\"\n    Checks if the relay is trusted (authorized for all project configs)\n    \"\"\"\n\n    # check legacy whitelisted public_key settings\n    # (we can't check specific relays but we can check public keys)\n    if settings.DEBUG or public_key in settings.SENTRY_RELAY_WHITELIST_PK:\n        return True\n\n    return is_internal_ip(request)\n\n\ndef is_static_relay(request):\n    \"\"\"\n    Checks if the request comes from a statically configured relay\n\n    Note: Only checks the relay_id (no public key validation is done).\n    \"\"\"\n    relay_id = get_header_relay_id(request)\n    static_relays = options.get(\"relay.static_auth\")\n    relay_info = static_relays.get(relay_id)\n    return relay_info is not None\n\n\ndef relay_from_id(request, relay_id) -> Tuple[Optional[Relay], bool]:\n    \"\"\"\n    Tries to find a Relay for a given id\n    If the id is statically registered than no DB access will be done.\n    If the id is not among the statically registered relays a lookup in the DB will be performed\n    :return: A tuple (Relay,bool) containing the Relay model and a flag True for statically configured\n    relays and False for Relays configured in the DB.\n    \"\"\"\n\n    # first see if we have a statically configured relay and therefore we don't\n    # need to go to the database for it\n    static_relays = options.get(\"relay.static_auth\")\n    relay_info = static_relays.get(relay_id)\n\n    if relay_info is not None:\n        # we have a statically configured Relay\n        relay = Relay(\n            relay_id=relay_id,\n            public_key=relay_info.get(\"public_key\"),\n            is_internal=relay_info.get(\"internal\") is True,\n        )\n        return relay, True  # a statically configured Relay\n    else:\n        try:\n            relay = Relay.objects.get(relay_id=relay_id)\n            relay.is_internal = is_internal_relay(request, relay.public_key)\n            return relay, False  # a Relay from the database\n        except Relay.DoesNotExist:\n            return None, False  # no Relay found\n\n\nclass QuietBasicAuthentication(BasicAuthentication):\n    def authenticate_header(self, request: Request):\n        return 'xBasic realm=\"%s\"' % self.www_authenticate_realm\n\n\nclass StandardAuthentication(QuietBasicAuthentication):\n    token_name = None\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        return auth and auth[0].lower() == self.token_name\n\n    def authenticate(self, request: Request):\n        auth = get_authorization_header(request).split()\n\n        if not self.accepts_auth(auth):\n            return None\n\n        if len(auth) == 1:\n            msg = \"Invalid token header. No credentials provided.\"\n            raise AuthenticationFailed(msg)\n        elif len(auth) > 2:\n            msg = \"Invalid token header. Token string should not contain spaces.\"\n            raise AuthenticationFailed(msg)\n\n        return self.authenticate_credentials(request, force_str(auth[1]))\n\n\nclass RelayAuthentication(BasicAuthentication):\n    def authenticate(self, request: Request):\n        relay_id = get_header_relay_id(request)\n        relay_sig = get_header_relay_signature(request)\n        if not relay_id:\n            raise AuthenticationFailed(\"Invalid relay ID\")\n        if not relay_sig:\n            raise AuthenticationFailed(\"Missing relay signature\")\n        return self.authenticate_credentials(relay_id, relay_sig, request)\n\n    def authenticate_credentials(self, relay_id, relay_sig, request):\n        with configure_scope() as scope:\n            scope.set_tag(\"relay_id\", relay_id)\n\n        relay, static = relay_from_id(request, relay_id)\n\n        if relay is None:\n            raise AuthenticationFailed(\"Unknown relay\")\n\n        try:\n            data = relay.public_key_object.unpack(request.body, relay_sig, max_age=60 * 5)\n            request.relay = relay\n            request.relay_request_data = data\n        except UnpackError:\n            raise AuthenticationFailed(\"Invalid relay signature\")\n\n        # TODO(mitsuhiko): can we return the relay here?  would be nice if we\n        # could find some common interface for it\n        return (AnonymousUser(), None)\n\n\nclass ApiKeyAuthentication(QuietBasicAuthentication):\n    token_name = b\"basic\"\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        return auth and auth[0].lower() == self.token_name\n\n    def authenticate_credentials(self, userid, password, request=None):\n        # We don't use request, but it needs to be passed through to DRF 3.7+.\n        if password:\n            return None\n\n        try:\n            key = ApiKey.objects.get_from_cache(key=userid)\n        except ApiKey.DoesNotExist:\n            raise AuthenticationFailed(\"API key is not valid\")\n\n        if not key.is_active:\n            raise AuthenticationFailed(\"Key is disabled\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_key\", key.id)\n\n        return (AnonymousUser(), key)\n\n\nclass ClientIdSecretAuthentication(QuietBasicAuthentication):\n    \"\"\"\n    Authenticates a Sentry Application using its Client ID and Secret\n\n    This will be the method by which we identify which Sentry Application is\n    making the request, for any requests not scoped to an installation.\n\n    For example, the request to exchange a Grant Code for an Api Token.\n    \"\"\"\n\n    def authenticate(self, request: Request):\n        if not request.json_body:\n            raise AuthenticationFailed(\"Invalid request\")\n\n        client_id = request.json_body.get(\"client_id\")\n        client_secret = request.json_body.get(\"client_secret\")\n\n        invalid_pair_error = AuthenticationFailed(\"Invalid Client ID / Secret pair\")\n\n        if not client_id or not client_secret:\n            raise invalid_pair_error\n\n        try:\n            application = ApiApplication.objects.get(client_id=client_id)\n        except ApiApplication.DoesNotExist:\n            raise invalid_pair_error\n\n        if not constant_time_compare(application.client_secret, client_secret):\n            raise invalid_pair_error\n\n        try:\n            return (application.sentry_app.proxy_user, None)\n        except Exception:\n            raise invalid_pair_error\n\n\nclass TokenAuthentication(StandardAuthentication):\n    token_name = b\"bearer\"\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        if not super().accepts_auth(auth):\n            return False\n\n        # Technically, this will not match if auth length is not 2\n        # However, we want to run into `authenticate()` in this case, as this throws a more helpful error message\n        if len(auth) != 2:\n            return True\n\n        token_str = force_str(auth[1])\n        return not token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)\n\n    def authenticate_credentials(self, request: Request, token_str):\n        token = SystemToken.from_request(request, token_str)\n        try:\n            token = (\n                token\n                or ApiToken.objects.filter(token=token_str)\n                .select_related(\"user\", \"application\")\n                .get()\n            )\n        except ApiToken.DoesNotExist:\n            raise AuthenticationFailed(\"Invalid token\")\n\n        if token.is_expired():\n            raise AuthenticationFailed(\"Token expired\")\n\n        if not token.user.is_active:\n            raise AuthenticationFailed(\"User inactive or deleted\")\n\n        if token.application and not token.application.is_active:\n            raise AuthenticationFailed(\"UserApplication inactive or deleted\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_token_type\", self.token_name)\n            scope.set_tag(\"api_token\", token.id)\n            scope.set_tag(\"api_token_is_sentry_app\", getattr(token.user, \"is_sentry_app\", False))\n\n        return (token.user, token)\n\n\nclass OrgAuthTokenAuthentication(StandardAuthentication):\n    token_name = b\"bearer\"\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        if not super().accepts_auth(auth) or len(auth) != 2:\n            return False\n\n        token_str = force_str(auth[1])\n        return token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)\n\n    def authenticate_credentials(self, request: Request, token_str):\n        token = None\n        token_hashed = hash_token(token_str)\n\n        try:\n            token = OrgAuthToken.objects.filter(\n                token_hashed=token_hashed, date_deactivated__isnull=True\n            ).get()\n        except OrgAuthToken.DoesNotExist:\n            raise AuthenticationFailed(\"Invalid org token\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_token_type\", self.token_name)\n            scope.set_tag(\"api_token\", token.id)\n            scope.set_tag(\"api_token_is_org_token\", True)\n\n        return (AnonymousUser(), token)\n\n\nclass DSNAuthentication(StandardAuthentication):\n    token_name = b\"dsn\"\n\n    def authenticate_credentials(self, request: Request, token):\n        try:\n            key = ProjectKey.from_dsn(token)\n        except ProjectKey.DoesNotExist:\n            raise AuthenticationFailed(\"Invalid dsn\")\n\n        if not key.is_active:\n            raise AuthenticationFailed(\"Invalid dsn\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_token_type\", self.token_name)\n            scope.set_tag(\"api_project_key\", key.id)\n\n        return (AnonymousUser(), key)\n\n\nclass RpcSignatureAuthentication(StandardAuthentication):\n    \"\"\"\n    Authentication for cross-region RPC requests.\n    Requests are sent with an HMAC signed by a shared private key.\n    \"\"\"\n\n    token_name = b\"rpcsignature\"\n\n    def accepts_auth(self, auth: List[bytes]) -> bool:\n        if not auth or len(auth) < 2:\n            return False\n        return auth[0].lower() == self.token_name\n\n    def authenticate_credentials(self, request: Request, token: str):\n        if not compare_signature(request.path_info, request.body, token):\n            raise AuthenticationFailed(\"Invalid signature\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"rpc_auth\", True)\n\n        return (AnonymousUser(), token)\n", "from django.conf import settings\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.cache import never_cache\nfrom rest_framework import serializers\nfrom rest_framework.authentication import SessionAuthentication\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\n\nfrom sentry import analytics\nfrom sentry.api.base import Endpoint, control_silo_endpoint\nfrom sentry.api.fields import MultipleChoiceField\nfrom sentry.api.serializers import serialize\nfrom sentry.auth.superuser import is_active_superuser\nfrom sentry.models import ApiToken\nfrom sentry.security import capture_security_activity\n\n\nclass ApiTokenSerializer(serializers.Serializer):\n    scopes = MultipleChoiceField(required=True, choices=settings.SENTRY_SCOPES)\n\n\n@control_silo_endpoint\nclass ApiTokensEndpoint(Endpoint):\n    authentication_classes = (SessionAuthentication,)\n    permission_classes = (IsAuthenticated,)\n\n    @method_decorator(never_cache)\n    def get(self, request: Request) -> Response:\n        user_id = request.user.id\n        if is_active_superuser(request):\n            user_id = request.GET.get(\"userId\", user_id)\n\n        token_list = list(\n            ApiToken.objects.filter(application__isnull=True, user_id=user_id).select_related(\n                \"application\"\n            )\n        )\n\n        return Response(serialize(token_list, request.user))\n\n    @method_decorator(never_cache)\n    def post(self, request: Request) -> Response:\n        serializer = ApiTokenSerializer(data=request.data)\n\n        if serializer.is_valid():\n            result = serializer.validated_data\n\n            token = ApiToken.objects.create(\n                user_id=request.user.id,\n                scope_list=result[\"scopes\"],\n                refresh_token=None,\n                expires_at=None,\n            )\n\n            capture_security_activity(\n                account=request.user,\n                type=\"api-token-generated\",\n                actor=request.user,\n                ip_address=request.META[\"REMOTE_ADDR\"],\n                context={},\n                send_email=True,\n            )\n\n            analytics.record(\"api_token.created\", user_id=request.user.id)\n\n            return Response(serialize(token, request.user), status=201)\n        return Response(serializer.errors, status=400)\n\n    @method_decorator(never_cache)\n    def delete(self, request: Request):\n        user_id = request.user.id\n        if is_active_superuser(request):\n            user_id = request.data.get(\"userId\", user_id)\n        token = request.data.get(\"token\")\n        if not token:\n            return Response({\"token\": \"\"}, status=400)\n\n        ApiToken.objects.filter(user_id=user_id, token=token, application__isnull=True).delete()\n\n        analytics.record(\"api_token.deleted\", user_id=request.user.id)\n\n        return Response(status=204)\n", "from django.urls import reverse\nfrom rest_framework import status\n\nfrom sentry.models import ApiToken\nfrom sentry.testutils.cases import APITestCase\nfrom sentry.testutils.silo import control_silo_test\n\n\n@control_silo_test(stable=True)\nclass ApiTokensListTest(APITestCase):\n    def test_simple(self):\n        ApiToken.objects.create(user=self.user)\n        ApiToken.objects.create(user=self.user)\n\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.get(url)\n        assert response.status_code == 200, response.content\n        assert len(response.data) == 2\n\n    def test_never_cache(self):\n        ApiToken.objects.create(user=self.user)\n        ApiToken.objects.create(user=self.user)\n\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.get(url)\n        assert response.status_code == 200, response.content\n        assert (\n            response.get(\"cache-control\")\n            == \"max-age=0, no-cache, no-store, must-revalidate, private\"\n        )\n\n\n@control_silo_test(stable=True)\nclass ApiTokensCreateTest(APITestCase):\n    def test_no_scopes(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(url)\n        assert response.status_code == 400\n\n    def test_simple(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(url, data={\"scopes\": [\"event:read\"]})\n        assert response.status_code == 201\n        token = ApiToken.objects.get(user=self.user)\n        assert not token.expires_at\n        assert not token.refresh_token\n        assert token.get_scopes() == [\"event:read\"]\n\n    def test_never_cache(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(url, data={\"scopes\": [\"event:read\"]})\n        assert response.status_code == 201\n        assert (\n            response.get(\"cache-control\")\n            == \"max-age=0, no-cache, no-store, must-revalidate, private\"\n        )\n\n    def test_invalid_choice(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(\n            url,\n            data={\n                \"scopes\": [\n                    \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\n                ]\n            },\n        )\n        assert response.status_code == 400\n        assert not ApiToken.objects.filter(user=self.user).exists()\n\n\n@control_silo_test(stable=True)\nclass ApiTokensDeleteTest(APITestCase):\n    def test_simple(self):\n        token = ApiToken.objects.create(user=self.user)\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.delete(url, data={\"token\": token.token})\n        assert response.status_code == 204\n        assert not ApiToken.objects.filter(id=token.id).exists()\n\n    def test_never_cache(self):\n        token = ApiToken.objects.create(user=self.user)\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.delete(url, data={\"token\": token.token})\n        assert response.status_code == 204\n        assert (\n            response.get(\"cache-control\")\n            == \"max-age=0, no-cache, no-store, must-revalidate, private\"\n        )\n\n\n@control_silo_test(stable=True)\nclass ApiTokensSuperUserTest(APITestCase):\n    url = reverse(\"sentry-api-0-api-tokens\")\n\n    def test_get_as_su(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.get(self.url, {\"userId\": self.user.id})\n        assert response.status_code == status.HTTP_200_OK\n        assert len(response.data) == 1\n        assert response.data[0][\"token\"] == user_token.token\n\n    def test_get_as_su_implicit_userid(self):\n        super_user = self.create_user(is_superuser=True)\n        superuser_token = ApiToken.objects.create(user=super_user)\n        user_token = ApiToken.objects.create(user=self.user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.get(self.url)\n        assert response.status_code == status.HTTP_200_OK\n        assert len(response.data) == 1\n        assert response.data[0][\"token\"] != user_token.token\n        assert response.data[0][\"token\"] == superuser_token.token\n\n    def test_get_as_user(self):\n        super_user = self.create_user(is_superuser=True)\n        su_token = ApiToken.objects.create(user=super_user)\n        self.login_as(super_user)\n        # Ignores trying to fetch the user's token, since we're not an active superuser\n        response = self.client.get(self.url, {\"userId\": self.user.id})\n        assert response.status_code == status.HTTP_200_OK\n        assert len(response.data) == 1\n        assert response.data[0][\"token\"] == su_token.token\n\n    def test_delete_as_su(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.delete(self.url, {\"userId\": self.user.id, \"token\": user_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert not ApiToken.objects.filter(id=user_token.id).exists()\n\n    def test_delete_as_su_implicit_userid(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        su_token = ApiToken.objects.create(user=super_user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.delete(self.url, {\"token\": user_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert ApiToken.objects.filter(id=user_token.id).exists()\n        assert ApiToken.objects.filter(id=su_token.id).exists()\n\n        response = self.client.delete(self.url, {\"token\": su_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert ApiToken.objects.filter(id=user_token.id).exists()\n        assert not ApiToken.objects.filter(id=su_token.id).exists()\n\n    def test_delete_as_user(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        su_token = ApiToken.objects.create(user=super_user)\n        self.login_as(super_user)\n        # Fails trying to delete the user's token, since we're not an active superuser\n        response = self.client.delete(self.url, {\"userId\": self.user.id, \"token\": user_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert ApiToken.objects.filter(id=user_token.id).exists()\n        assert ApiToken.objects.filter(id=su_token.id).exists()\n"], "fixing_code": ["from typing import List, Optional, Tuple\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.encoding import force_str\nfrom rest_framework.authentication import (\n    BasicAuthentication,\n    SessionAuthentication,\n    get_authorization_header,\n)\nfrom rest_framework.exceptions import AuthenticationFailed\nfrom rest_framework.request import Request\nfrom sentry_relay import UnpackError\n\nfrom sentry import options\nfrom sentry.auth.system import SystemToken, is_internal_ip\nfrom sentry.models import ApiApplication, ApiKey, ApiToken, OrgAuthToken, ProjectKey, Relay\nfrom sentry.relay.utils import get_header_relay_id, get_header_relay_signature\nfrom sentry.services.hybrid_cloud.rpc import compare_signature\nfrom sentry.utils.sdk import configure_scope\nfrom sentry.utils.security.orgauthtoken_token import SENTRY_ORG_AUTH_TOKEN_PREFIX, hash_token\n\n\ndef is_internal_relay(request, public_key):\n    \"\"\"\n    Checks if the relay is trusted (authorized for all project configs)\n    \"\"\"\n\n    # check legacy whitelisted public_key settings\n    # (we can't check specific relays but we can check public keys)\n    if settings.DEBUG or public_key in settings.SENTRY_RELAY_WHITELIST_PK:\n        return True\n\n    return is_internal_ip(request)\n\n\ndef is_static_relay(request):\n    \"\"\"\n    Checks if the request comes from a statically configured relay\n\n    Note: Only checks the relay_id (no public key validation is done).\n    \"\"\"\n    relay_id = get_header_relay_id(request)\n    static_relays = options.get(\"relay.static_auth\")\n    relay_info = static_relays.get(relay_id)\n    return relay_info is not None\n\n\ndef relay_from_id(request, relay_id) -> Tuple[Optional[Relay], bool]:\n    \"\"\"\n    Tries to find a Relay for a given id\n    If the id is statically registered than no DB access will be done.\n    If the id is not among the statically registered relays a lookup in the DB will be performed\n    :return: A tuple (Relay,bool) containing the Relay model and a flag True for statically configured\n    relays and False for Relays configured in the DB.\n    \"\"\"\n\n    # first see if we have a statically configured relay and therefore we don't\n    # need to go to the database for it\n    static_relays = options.get(\"relay.static_auth\")\n    relay_info = static_relays.get(relay_id)\n\n    if relay_info is not None:\n        # we have a statically configured Relay\n        relay = Relay(\n            relay_id=relay_id,\n            public_key=relay_info.get(\"public_key\"),\n            is_internal=relay_info.get(\"internal\") is True,\n        )\n        return relay, True  # a statically configured Relay\n    else:\n        try:\n            relay = Relay.objects.get(relay_id=relay_id)\n            relay.is_internal = is_internal_relay(request, relay.public_key)\n            return relay, False  # a Relay from the database\n        except Relay.DoesNotExist:\n            return None, False  # no Relay found\n\n\nclass QuietBasicAuthentication(BasicAuthentication):\n    def authenticate_header(self, request: Request):\n        return 'xBasic realm=\"%s\"' % self.www_authenticate_realm\n\n\nclass StandardAuthentication(QuietBasicAuthentication):\n    token_name = None\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        return auth and auth[0].lower() == self.token_name\n\n    def authenticate(self, request: Request):\n        auth = get_authorization_header(request).split()\n\n        if not self.accepts_auth(auth):\n            return None\n\n        if len(auth) == 1:\n            msg = \"Invalid token header. No credentials provided.\"\n            raise AuthenticationFailed(msg)\n        elif len(auth) > 2:\n            msg = \"Invalid token header. Token string should not contain spaces.\"\n            raise AuthenticationFailed(msg)\n\n        return self.authenticate_credentials(request, force_str(auth[1]))\n\n\nclass RelayAuthentication(BasicAuthentication):\n    def authenticate(self, request: Request):\n        relay_id = get_header_relay_id(request)\n        relay_sig = get_header_relay_signature(request)\n        if not relay_id:\n            raise AuthenticationFailed(\"Invalid relay ID\")\n        if not relay_sig:\n            raise AuthenticationFailed(\"Missing relay signature\")\n        return self.authenticate_credentials(relay_id, relay_sig, request)\n\n    def authenticate_credentials(self, relay_id, relay_sig, request):\n        with configure_scope() as scope:\n            scope.set_tag(\"relay_id\", relay_id)\n\n        relay, static = relay_from_id(request, relay_id)\n\n        if relay is None:\n            raise AuthenticationFailed(\"Unknown relay\")\n\n        try:\n            data = relay.public_key_object.unpack(request.body, relay_sig, max_age=60 * 5)\n            request.relay = relay\n            request.relay_request_data = data\n        except UnpackError:\n            raise AuthenticationFailed(\"Invalid relay signature\")\n\n        # TODO(mitsuhiko): can we return the relay here?  would be nice if we\n        # could find some common interface for it\n        return (AnonymousUser(), None)\n\n\nclass ApiKeyAuthentication(QuietBasicAuthentication):\n    token_name = b\"basic\"\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        return auth and auth[0].lower() == self.token_name\n\n    def authenticate_credentials(self, userid, password, request=None):\n        # We don't use request, but it needs to be passed through to DRF 3.7+.\n        if password:\n            return None\n\n        try:\n            key = ApiKey.objects.get_from_cache(key=userid)\n        except ApiKey.DoesNotExist:\n            raise AuthenticationFailed(\"API key is not valid\")\n\n        if not key.is_active:\n            raise AuthenticationFailed(\"Key is disabled\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_key\", key.id)\n\n        return (AnonymousUser(), key)\n\n\nclass SessionNoAuthTokenAuthentication(SessionAuthentication):\n    def authenticate(self, request: Request):\n        auth = get_authorization_header(request)\n        if auth:\n            return None\n        return super().authenticate(request)\n\n\nclass ClientIdSecretAuthentication(QuietBasicAuthentication):\n    \"\"\"\n    Authenticates a Sentry Application using its Client ID and Secret\n\n    This will be the method by which we identify which Sentry Application is\n    making the request, for any requests not scoped to an installation.\n\n    For example, the request to exchange a Grant Code for an Api Token.\n    \"\"\"\n\n    def authenticate(self, request: Request):\n        if not request.json_body:\n            raise AuthenticationFailed(\"Invalid request\")\n\n        client_id = request.json_body.get(\"client_id\")\n        client_secret = request.json_body.get(\"client_secret\")\n\n        invalid_pair_error = AuthenticationFailed(\"Invalid Client ID / Secret pair\")\n\n        if not client_id or not client_secret:\n            raise invalid_pair_error\n\n        try:\n            application = ApiApplication.objects.get(client_id=client_id)\n        except ApiApplication.DoesNotExist:\n            raise invalid_pair_error\n\n        if not constant_time_compare(application.client_secret, client_secret):\n            raise invalid_pair_error\n\n        try:\n            return (application.sentry_app.proxy_user, None)\n        except Exception:\n            raise invalid_pair_error\n\n\nclass TokenAuthentication(StandardAuthentication):\n    token_name = b\"bearer\"\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        if not super().accepts_auth(auth):\n            return False\n\n        # Technically, this will not match if auth length is not 2\n        # However, we want to run into `authenticate()` in this case, as this throws a more helpful error message\n        if len(auth) != 2:\n            return True\n\n        token_str = force_str(auth[1])\n        return not token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)\n\n    def authenticate_credentials(self, request: Request, token_str):\n        token = SystemToken.from_request(request, token_str)\n        try:\n            token = (\n                token\n                or ApiToken.objects.filter(token=token_str)\n                .select_related(\"user\", \"application\")\n                .get()\n            )\n        except ApiToken.DoesNotExist:\n            raise AuthenticationFailed(\"Invalid token\")\n\n        if token.is_expired():\n            raise AuthenticationFailed(\"Token expired\")\n\n        if not token.user.is_active:\n            raise AuthenticationFailed(\"User inactive or deleted\")\n\n        if token.application and not token.application.is_active:\n            raise AuthenticationFailed(\"UserApplication inactive or deleted\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_token_type\", self.token_name)\n            scope.set_tag(\"api_token\", token.id)\n            scope.set_tag(\"api_token_is_sentry_app\", getattr(token.user, \"is_sentry_app\", False))\n\n        return (token.user, token)\n\n\nclass OrgAuthTokenAuthentication(StandardAuthentication):\n    token_name = b\"bearer\"\n\n    def accepts_auth(self, auth: \"list[bytes]\") -> bool:\n        if not super().accepts_auth(auth) or len(auth) != 2:\n            return False\n\n        token_str = force_str(auth[1])\n        return token_str.startswith(SENTRY_ORG_AUTH_TOKEN_PREFIX)\n\n    def authenticate_credentials(self, request: Request, token_str):\n        token = None\n        token_hashed = hash_token(token_str)\n\n        try:\n            token = OrgAuthToken.objects.filter(\n                token_hashed=token_hashed, date_deactivated__isnull=True\n            ).get()\n        except OrgAuthToken.DoesNotExist:\n            raise AuthenticationFailed(\"Invalid org token\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_token_type\", self.token_name)\n            scope.set_tag(\"api_token\", token.id)\n            scope.set_tag(\"api_token_is_org_token\", True)\n\n        return (AnonymousUser(), token)\n\n\nclass DSNAuthentication(StandardAuthentication):\n    token_name = b\"dsn\"\n\n    def authenticate_credentials(self, request: Request, token):\n        try:\n            key = ProjectKey.from_dsn(token)\n        except ProjectKey.DoesNotExist:\n            raise AuthenticationFailed(\"Invalid dsn\")\n\n        if not key.is_active:\n            raise AuthenticationFailed(\"Invalid dsn\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"api_token_type\", self.token_name)\n            scope.set_tag(\"api_project_key\", key.id)\n\n        return (AnonymousUser(), key)\n\n\nclass RpcSignatureAuthentication(StandardAuthentication):\n    \"\"\"\n    Authentication for cross-region RPC requests.\n    Requests are sent with an HMAC signed by a shared private key.\n    \"\"\"\n\n    token_name = b\"rpcsignature\"\n\n    def accepts_auth(self, auth: List[bytes]) -> bool:\n        if not auth or len(auth) < 2:\n            return False\n        return auth[0].lower() == self.token_name\n\n    def authenticate_credentials(self, request: Request, token: str):\n        if not compare_signature(request.path_info, request.body, token):\n            raise AuthenticationFailed(\"Invalid signature\")\n\n        with configure_scope() as scope:\n            scope.set_tag(\"rpc_auth\", True)\n\n        return (AnonymousUser(), token)\n", "from django.conf import settings\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.cache import never_cache\nfrom rest_framework import serializers\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\n\nfrom sentry import analytics\nfrom sentry.api.authentication import SessionNoAuthTokenAuthentication\nfrom sentry.api.base import Endpoint, control_silo_endpoint\nfrom sentry.api.fields import MultipleChoiceField\nfrom sentry.api.serializers import serialize\nfrom sentry.auth.superuser import is_active_superuser\nfrom sentry.models import ApiToken\nfrom sentry.security import capture_security_activity\n\n\nclass ApiTokenSerializer(serializers.Serializer):\n    scopes = MultipleChoiceField(required=True, choices=settings.SENTRY_SCOPES)\n\n\n@control_silo_endpoint\nclass ApiTokensEndpoint(Endpoint):\n    authentication_classes = (SessionNoAuthTokenAuthentication,)\n    permission_classes = (IsAuthenticated,)\n\n    @method_decorator(never_cache)\n    def get(self, request: Request) -> Response:\n        user_id = request.user.id\n        if is_active_superuser(request):\n            user_id = request.GET.get(\"userId\", user_id)\n\n        token_list = list(\n            ApiToken.objects.filter(application__isnull=True, user_id=user_id).select_related(\n                \"application\"\n            )\n        )\n\n        return Response(serialize(token_list, request.user))\n\n    @method_decorator(never_cache)\n    def post(self, request: Request) -> Response:\n        serializer = ApiTokenSerializer(data=request.data)\n\n        if serializer.is_valid():\n            result = serializer.validated_data\n\n            token = ApiToken.objects.create(\n                user_id=request.user.id,\n                scope_list=result[\"scopes\"],\n                refresh_token=None,\n                expires_at=None,\n            )\n\n            capture_security_activity(\n                account=request.user,\n                type=\"api-token-generated\",\n                actor=request.user,\n                ip_address=request.META[\"REMOTE_ADDR\"],\n                context={},\n                send_email=True,\n            )\n\n            analytics.record(\"api_token.created\", user_id=request.user.id)\n\n            return Response(serialize(token, request.user), status=201)\n        return Response(serializer.errors, status=400)\n\n    @method_decorator(never_cache)\n    def delete(self, request: Request):\n        user_id = request.user.id\n        if is_active_superuser(request):\n            user_id = request.data.get(\"userId\", user_id)\n        token = request.data.get(\"token\")\n        if not token:\n            return Response({\"token\": \"\"}, status=400)\n\n        ApiToken.objects.filter(user_id=user_id, token=token, application__isnull=True).delete()\n\n        analytics.record(\"api_token.deleted\", user_id=request.user.id)\n\n        return Response(status=204)\n", "from django.urls import reverse\nfrom rest_framework import status\n\nfrom sentry.models import ApiToken\nfrom sentry.testutils.cases import APITestCase\nfrom sentry.testutils.silo import control_silo_test\n\n\n@control_silo_test(stable=True)\nclass ApiTokensListTest(APITestCase):\n    def test_simple(self):\n        ApiToken.objects.create(user=self.user)\n        ApiToken.objects.create(user=self.user)\n\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.get(url)\n        assert response.status_code == 200, response.content\n        assert len(response.data) == 2\n\n    def test_never_cache(self):\n        ApiToken.objects.create(user=self.user)\n        ApiToken.objects.create(user=self.user)\n\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.get(url)\n        assert response.status_code == 200, response.content\n        assert (\n            response.get(\"cache-control\")\n            == \"max-age=0, no-cache, no-store, must-revalidate, private\"\n        )\n\n    def test_deny_token_access(self):\n        token = ApiToken.objects.create(user=self.user, scope_list=[])\n\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.get(url, format=\"json\", HTTP_AUTHORIZATION=f\"Bearer {token.token}\")\n        assert response.status_code == 403, response.content\n\n\n@control_silo_test(stable=True)\nclass ApiTokensCreateTest(APITestCase):\n    def test_no_scopes(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(url)\n        assert response.status_code == 400\n\n    def test_simple(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(url, data={\"scopes\": [\"event:read\"]})\n        assert response.status_code == 201\n        token = ApiToken.objects.get(user=self.user)\n        assert not token.expires_at\n        assert not token.refresh_token\n        assert token.get_scopes() == [\"event:read\"]\n\n    def test_never_cache(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(url, data={\"scopes\": [\"event:read\"]})\n        assert response.status_code == 201\n        assert (\n            response.get(\"cache-control\")\n            == \"max-age=0, no-cache, no-store, must-revalidate, private\"\n        )\n\n    def test_invalid_choice(self):\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.post(\n            url,\n            data={\n                \"scopes\": [\n                    \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\n                ]\n            },\n        )\n        assert response.status_code == 400\n        assert not ApiToken.objects.filter(user=self.user).exists()\n\n\n@control_silo_test(stable=True)\nclass ApiTokensDeleteTest(APITestCase):\n    def test_simple(self):\n        token = ApiToken.objects.create(user=self.user)\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.delete(url, data={\"token\": token.token})\n        assert response.status_code == 204\n        assert not ApiToken.objects.filter(id=token.id).exists()\n\n    def test_never_cache(self):\n        token = ApiToken.objects.create(user=self.user)\n        self.login_as(self.user)\n        url = reverse(\"sentry-api-0-api-tokens\")\n        response = self.client.delete(url, data={\"token\": token.token})\n        assert response.status_code == 204\n        assert (\n            response.get(\"cache-control\")\n            == \"max-age=0, no-cache, no-store, must-revalidate, private\"\n        )\n\n\n@control_silo_test(stable=True)\nclass ApiTokensSuperUserTest(APITestCase):\n    url = reverse(\"sentry-api-0-api-tokens\")\n\n    def test_get_as_su(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.get(self.url, {\"userId\": self.user.id})\n        assert response.status_code == status.HTTP_200_OK\n        assert len(response.data) == 1\n        assert response.data[0][\"token\"] == user_token.token\n\n    def test_get_as_su_implicit_userid(self):\n        super_user = self.create_user(is_superuser=True)\n        superuser_token = ApiToken.objects.create(user=super_user)\n        user_token = ApiToken.objects.create(user=self.user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.get(self.url)\n        assert response.status_code == status.HTTP_200_OK\n        assert len(response.data) == 1\n        assert response.data[0][\"token\"] != user_token.token\n        assert response.data[0][\"token\"] == superuser_token.token\n\n    def test_get_as_user(self):\n        super_user = self.create_user(is_superuser=True)\n        su_token = ApiToken.objects.create(user=super_user)\n        self.login_as(super_user)\n        # Ignores trying to fetch the user's token, since we're not an active superuser\n        response = self.client.get(self.url, {\"userId\": self.user.id})\n        assert response.status_code == status.HTTP_200_OK\n        assert len(response.data) == 1\n        assert response.data[0][\"token\"] == su_token.token\n\n    def test_delete_as_su(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.delete(self.url, {\"userId\": self.user.id, \"token\": user_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert not ApiToken.objects.filter(id=user_token.id).exists()\n\n    def test_delete_as_su_implicit_userid(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        su_token = ApiToken.objects.create(user=super_user)\n        self.login_as(super_user, superuser=True)\n\n        response = self.client.delete(self.url, {\"token\": user_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert ApiToken.objects.filter(id=user_token.id).exists()\n        assert ApiToken.objects.filter(id=su_token.id).exists()\n\n        response = self.client.delete(self.url, {\"token\": su_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert ApiToken.objects.filter(id=user_token.id).exists()\n        assert not ApiToken.objects.filter(id=su_token.id).exists()\n\n    def test_delete_as_user(self):\n        super_user = self.create_user(is_superuser=True)\n        user_token = ApiToken.objects.create(user=self.user)\n        su_token = ApiToken.objects.create(user=super_user)\n        self.login_as(super_user)\n        # Fails trying to delete the user's token, since we're not an active superuser\n        response = self.client.delete(self.url, {\"userId\": self.user.id, \"token\": user_token.token})\n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        assert ApiToken.objects.filter(id=user_token.id).exists()\n        assert ApiToken.objects.filter(id=su_token.id).exists()\n"], "filenames": ["src/sentry/api/authentication.py", "src/sentry/api/endpoints/api_tokens.py", "tests/sentry/api/endpoints/test_api_tokens.py"], "buggy_code_start_loc": [7, 5, 32], "buggy_code_end_loc": [159, 26, 32], "fixing_code_start_loc": [7, 4, 33], "fixing_code_end_loc": [172, 26, 40], "type": "CWE-284", "message": "Sentry is an error tracking and performance monitoring platform. Starting in version 22.1.0 and prior to version 23.7.2, an attacker with access to a token with few or no scopes can query `/api/0/api-tokens/` for a list of all tokens created by a user, including tokens with greater scopes, and use those tokens in other requests. There is no evidence that the issue was exploited on `sentry.io`. For self-hosted users, it is advised to rotate user auth tokens. A fix is available in version 23.7.2 of `sentry` and `self-hosted`. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-39349", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-07T19:15:11.697", "lastModified": "2023-08-10T17:04:48.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sentry is an error tracking and performance monitoring platform. Starting in version 22.1.0 and prior to version 23.7.2, an attacker with access to a token with few or no scopes can query `/api/0/api-tokens/` for a list of all tokens created by a user, including tokens with greater scopes, and use those tokens in other requests. There is no evidence that the issue was exploited on `sentry.io`. For self-hosted users, it is advised to rotate user auth tokens. A fix is available in version 23.7.2 of `sentry` and `self-hosted`. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}, {"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sentry:sentry:*:*:*:*:*:*:*:*", "versionStartIncluding": "22.1.0", "versionEndExcluding": "23.7.2", "matchCriteriaId": "C9764018-F8B3-4978-83C0-D5362EED433D"}]}]}], "references": [{"url": "https://github.com/getsentry/self-hosted/releases/tag/23.7.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/getsentry/sentry/commit/fad12c1150d1135edf9666ea72ca11bc110c1083", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/getsentry/sentry/pull/53850", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/getsentry/sentry/releases/tag/23.7.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/getsentry/sentry/security/advisories/GHSA-9jcq-jf57-c62c", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/getsentry/sentry/commit/fad12c1150d1135edf9666ea72ca11bc110c1083"}}