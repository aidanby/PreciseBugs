{"buggy_code": ["/*\n * OpenEXR (.exr) image decoder\n * Copyright (c) 2006 Industrial Light & Magic, a division of Lucas Digital Ltd. LLC\n * Copyright (c) 2009 Jimmy Christensen\n *\n * B44/B44A, Tile, UINT32 added by Jokyo Images support by CNC - French National Center for Cinema\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * OpenEXR decoder\n * @author Jimmy Christensen\n *\n * For more information on the OpenEXR format, visit:\n *  http://openexr.com/\n *\n * exr_half2float() is credited to Aaftab Munshi, Dan Ginsburg, Dave Shreiner.\n */\n\n#include <float.h>\n#include <zlib.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/color_utils.h\"\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n\n#if HAVE_BIGENDIAN\n#include \"bswapdsp.h\"\n#endif\n\n#include \"exrdsp.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n#include \"mathops.h\"\n#include \"thread.h\"\n\nenum ExrCompr {\n    EXR_RAW,\n    EXR_RLE,\n    EXR_ZIP1,\n    EXR_ZIP16,\n    EXR_PIZ,\n    EXR_PXR24,\n    EXR_B44,\n    EXR_B44A,\n    EXR_DWA,\n    EXR_DWB,\n    EXR_UNKN,\n};\n\nenum ExrPixelType {\n    EXR_UINT,\n    EXR_HALF,\n    EXR_FLOAT,\n    EXR_UNKNOWN,\n};\n\nenum ExrTileLevelMode {\n    EXR_TILE_LEVEL_ONE,\n    EXR_TILE_LEVEL_MIPMAP,\n    EXR_TILE_LEVEL_RIPMAP,\n    EXR_TILE_LEVEL_UNKNOWN,\n};\n\nenum ExrTileLevelRound {\n    EXR_TILE_ROUND_UP,\n    EXR_TILE_ROUND_DOWN,\n    EXR_TILE_ROUND_UNKNOWN,\n};\n\ntypedef struct EXRChannel {\n    int xsub, ysub;\n    enum ExrPixelType pixel_type;\n} EXRChannel;\n\ntypedef struct EXRTileAttribute {\n    int32_t xSize;\n    int32_t ySize;\n    enum ExrTileLevelMode level_mode;\n    enum ExrTileLevelRound level_round;\n} EXRTileAttribute;\n\ntypedef struct EXRThreadData {\n    uint8_t *uncompressed_data;\n    int uncompressed_size;\n\n    uint8_t *tmp;\n    int tmp_size;\n\n    uint8_t *bitmap;\n    uint16_t *lut;\n\n    int ysize, xsize;\n\n    int channel_line_size;\n} EXRThreadData;\n\ntypedef struct EXRContext {\n    AVClass *class;\n    AVFrame *picture;\n    AVCodecContext *avctx;\n    ExrDSPContext dsp;\n\n#if HAVE_BIGENDIAN\n    BswapDSPContext bbdsp;\n#endif\n\n    enum ExrCompr compression;\n    enum ExrPixelType pixel_type;\n    int channel_offsets[4]; // 0 = red, 1 = green, 2 = blue and 3 = alpha\n    const AVPixFmtDescriptor *desc;\n\n    int w, h;\n    int32_t xmax, xmin;\n    int32_t ymax, ymin;\n    uint32_t xdelta, ydelta;\n\n    int scan_lines_per_block;\n\n    EXRTileAttribute tile_attr; /* header data attribute of tile */\n    int is_tile; /* 0 if scanline, 1 if tile */\n\n    int is_luma;/* 1 if there is an Y plane */\n\n    GetByteContext gb;\n    const uint8_t *buf;\n    int buf_size;\n\n    EXRChannel *channels;\n    int nb_channels;\n    int current_channel_offset;\n\n    EXRThreadData *thread_data;\n\n    const char *layer;\n\n    enum AVColorTransferCharacteristic apply_trc_type;\n    float gamma;\n    union av_intfloat32 gamma_table[65536];\n} EXRContext;\n\n/* -15 stored using a single precision bias of 127 */\n#define HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP 0x38000000\n\n/* max exponent value in single precision that will be converted\n * to Inf or Nan when stored as a half-float */\n#define HALF_FLOAT_MAX_BIASED_EXP_AS_SINGLE_FP_EXP 0x47800000\n\n/* 255 is the max exponent biased value */\n#define FLOAT_MAX_BIASED_EXP (0xFF << 23)\n\n#define HALF_FLOAT_MAX_BIASED_EXP (0x1F << 10)\n\n/**\n * Convert a half float as a uint16_t into a full float.\n *\n * @param hf half float as uint16_t\n *\n * @return float value\n */\nstatic union av_intfloat32 exr_half2float(uint16_t hf)\n{\n    unsigned int sign = (unsigned int) (hf >> 15);\n    unsigned int mantissa = (unsigned int) (hf & ((1 << 10) - 1));\n    unsigned int exp = (unsigned int) (hf & HALF_FLOAT_MAX_BIASED_EXP);\n    union av_intfloat32 f;\n\n    if (exp == HALF_FLOAT_MAX_BIASED_EXP) {\n        // we have a half-float NaN or Inf\n        // half-float NaNs will be converted to a single precision NaN\n        // half-float Infs will be converted to a single precision Inf\n        exp = FLOAT_MAX_BIASED_EXP;\n        if (mantissa)\n            mantissa = (1 << 23) - 1;    // set all bits to indicate a NaN\n    } else if (exp == 0x0) {\n        // convert half-float zero/denorm to single precision value\n        if (mantissa) {\n            mantissa <<= 1;\n            exp = HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP;\n            // check for leading 1 in denorm mantissa\n            while (!(mantissa & (1 << 10))) {\n                // for every leading 0, decrement single precision exponent by 1\n                // and shift half-float mantissa value to the left\n                mantissa <<= 1;\n                exp -= (1 << 23);\n            }\n            // clamp the mantissa to 10 bits\n            mantissa &= ((1 << 10) - 1);\n            // shift left to generate single-precision mantissa of 23 bits\n            mantissa <<= 13;\n        }\n    } else {\n        // shift left to generate single-precision mantissa of 23 bits\n        mantissa <<= 13;\n        // generate single precision biased exponent value\n        exp = (exp << 13) + HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP;\n    }\n\n    f.i = (sign << 31) | exp | mantissa;\n\n    return f;\n}\n\nstatic int zip_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    unsigned long dest_len = uncompressed_size;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK ||\n        dest_len != uncompressed_size)\n        return AVERROR_INVALIDDATA;\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    s->dsp.predictor(td->tmp, uncompressed_size);\n    s->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\nstatic int rle_uncompress(EXRContext *ctx, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    uint8_t *d      = td->tmp;\n    const int8_t *s = src;\n    int ssize       = compressed_size;\n    int dsize       = uncompressed_size;\n    uint8_t *dend   = d + dsize;\n    int count;\n\n    while (ssize > 0) {\n        count = *s++;\n\n        if (count < 0) {\n            count = -count;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= count + 1) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s++;\n        } else {\n            count++;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= 2) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s;\n\n            s++;\n        }\n    }\n\n    if (dend != d)\n        return AVERROR_INVALIDDATA;\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    ctx->dsp.predictor(td->tmp, uncompressed_size);\n    ctx->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\n#define USHORT_RANGE (1 << 16)\n#define BITMAP_SIZE  (1 << 13)\n\nstatic uint16_t reverse_lut(const uint8_t *bitmap, uint16_t *lut)\n{\n    int i, k = 0;\n\n    for (i = 0; i < USHORT_RANGE; i++)\n        if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))\n            lut[k++] = i;\n\n    i = k - 1;\n\n    memset(lut + k, 0, (USHORT_RANGE - k) * 2);\n\n    return i;\n}\n\nstatic void apply_lut(const uint16_t *lut, uint16_t *dst, int dsize)\n{\n    int i;\n\n    for (i = 0; i < dsize; ++i)\n        dst[i] = lut[dst[i]];\n}\n\n#define HUF_ENCBITS 16  // literal (value) bit length\n#define HUF_DECBITS 14  // decoding bit size (>= 8)\n\n#define HUF_ENCSIZE ((1 << HUF_ENCBITS) + 1)  // encoding table size\n#define HUF_DECSIZE (1 << HUF_DECBITS)        // decoding table size\n#define HUF_DECMASK (HUF_DECSIZE - 1)\n\ntypedef struct HufDec {\n    int len;\n    int lit;\n    int *p;\n} HufDec;\n\nstatic void huf_canonical_code_table(uint64_t *hcode)\n{\n    uint64_t c, n[59] = { 0 };\n    int i;\n\n    for (i = 0; i < HUF_ENCSIZE; ++i)\n        n[hcode[i]] += 1;\n\n    c = 0;\n    for (i = 58; i > 0; --i) {\n        uint64_t nc = ((c + n[i]) >> 1);\n        n[i] = c;\n        c    = nc;\n    }\n\n    for (i = 0; i < HUF_ENCSIZE; ++i) {\n        int l = hcode[i];\n\n        if (l > 0)\n            hcode[i] = l | (n[l]++ << 6);\n    }\n}\n\n#define SHORT_ZEROCODE_RUN  59\n#define LONG_ZEROCODE_RUN   63\n#define SHORTEST_LONG_RUN   (2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN)\n#define LONGEST_LONG_RUN    (255 + SHORTEST_LONG_RUN)\n\nstatic int huf_unpack_enc_table(GetByteContext *gb,\n                                int32_t im, int32_t iM, uint64_t *hcode)\n{\n    GetBitContext gbit;\n    int ret = init_get_bits8(&gbit, gb->buffer, bytestream2_get_bytes_left(gb));\n    if (ret < 0)\n        return ret;\n\n    for (; im <= iM; im++) {\n        uint64_t l = hcode[im] = get_bits(&gbit, 6);\n\n        if (l == LONG_ZEROCODE_RUN) {\n            int zerun = get_bits(&gbit, 8) + SHORTEST_LONG_RUN;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                hcode[im++] = 0;\n\n            im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n            int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                hcode[im++] = 0;\n\n            im--;\n        }\n    }\n\n    bytestream2_skip(gb, (get_bits_count(&gbit) + 7) / 8);\n    huf_canonical_code_table(hcode);\n\n    return 0;\n}\n\nstatic int huf_build_dec_table(const uint64_t *hcode, int im,\n                               int iM, HufDec *hdecod)\n{\n    for (; im <= iM; im++) {\n        uint64_t c = hcode[im] >> 6;\n        int i, l = hcode[im] & 63;\n\n        if (c >> l)\n            return AVERROR_INVALIDDATA;\n\n        if (l > HUF_DECBITS) {\n            HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));\n            if (pl->len)\n                return AVERROR_INVALIDDATA;\n\n            pl->lit++;\n\n            pl->p = av_realloc(pl->p, pl->lit * sizeof(int));\n            if (!pl->p)\n                return AVERROR(ENOMEM);\n\n            pl->p[pl->lit - 1] = im;\n        } else if (l) {\n            HufDec *pl = hdecod + (c << (HUF_DECBITS - l));\n\n            for (i = 1 << (HUF_DECBITS - l); i > 0; i--, pl++) {\n                if (pl->len || pl->p)\n                    return AVERROR_INVALIDDATA;\n                pl->len = l;\n                pl->lit = im;\n            }\n        }\n    }\n\n    return 0;\n}\n\n#define get_char(c, lc, gb)                                                   \\\n{                                                                             \\\n        c   = (c << 8) | bytestream2_get_byte(gb);                            \\\n        lc += 8;                                                              \\\n}\n\n#define get_code(po, rlc, c, lc, gb, out, oe, outb)                           \\\n{                                                                             \\\n        if (po == rlc) {                                                      \\\n            if (lc < 8)                                                       \\\n                get_char(c, lc, gb);                                          \\\n            lc -= 8;                                                          \\\n                                                                              \\\n            cs = c >> lc;                                                     \\\n                                                                              \\\n            if (out + cs > oe || out == outb)                                 \\\n                return AVERROR_INVALIDDATA;                                   \\\n                                                                              \\\n            s = out[-1];                                                      \\\n                                                                              \\\n            while (cs-- > 0)                                                  \\\n                *out++ = s;                                                   \\\n        } else if (out < oe) {                                                \\\n            *out++ = po;                                                      \\\n        } else {                                                              \\\n            return AVERROR_INVALIDDATA;                                       \\\n        }                                                                     \\\n}\n\nstatic int huf_decode(const uint64_t *hcode, const HufDec *hdecod,\n                      GetByteContext *gb, int nbits,\n                      int rlc, int no, uint16_t *out)\n{\n    uint64_t c        = 0;\n    uint16_t *outb    = out;\n    uint16_t *oe      = out + no;\n    const uint8_t *ie = gb->buffer + (nbits + 7) / 8; // input byte size\n    uint8_t cs;\n    uint16_t s;\n    int i, lc = 0;\n\n    while (gb->buffer < ie) {\n        get_char(c, lc, gb);\n\n        while (lc >= HUF_DECBITS) {\n            const HufDec pl = hdecod[(c >> (lc - HUF_DECBITS)) & HUF_DECMASK];\n\n            if (pl.len) {\n                lc -= pl.len;\n                get_code(pl.lit, rlc, c, lc, gb, out, oe, outb);\n            } else {\n                int j;\n\n                if (!pl.p)\n                    return AVERROR_INVALIDDATA;\n\n                for (j = 0; j < pl.lit; j++) {\n                    int l = hcode[pl.p[j]] & 63;\n\n                    while (lc < l && bytestream2_get_bytes_left(gb) > 0)\n                        get_char(c, lc, gb);\n\n                    if (lc >= l) {\n                        if ((hcode[pl.p[j]] >> 6) ==\n                            ((c >> (lc - l)) & ((1LL << l) - 1))) {\n                            lc -= l;\n                            get_code(pl.p[j], rlc, c, lc, gb, out, oe, outb);\n                            break;\n                        }\n                    }\n                }\n\n                if (j == pl.lit)\n                    return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n\n    i   = (8 - nbits) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0) {\n        const HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n        if (pl.len && lc >= pl.len) {\n            lc -= pl.len;\n            get_code(pl.lit, rlc, c, lc, gb, out, oe, outb);\n        } else {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (out - outb != no)\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nstatic int huf_uncompress(GetByteContext *gb,\n                          uint16_t *dst, int dst_size)\n{\n    int32_t src_size, im, iM;\n    uint32_t nBits;\n    uint64_t *freq;\n    HufDec *hdec;\n    int ret, i;\n\n    src_size = bytestream2_get_le32(gb);\n    im       = bytestream2_get_le32(gb);\n    iM       = bytestream2_get_le32(gb);\n    bytestream2_skip(gb, 4);\n    nBits = bytestream2_get_le32(gb);\n    if (im < 0 || im >= HUF_ENCSIZE ||\n        iM < 0 || iM >= HUF_ENCSIZE ||\n        src_size < 0)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(gb, 4);\n\n    freq = av_mallocz_array(HUF_ENCSIZE, sizeof(*freq));\n    hdec = av_mallocz_array(HUF_DECSIZE, sizeof(*hdec));\n    if (!freq || !hdec) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n        goto fail;\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n        goto fail;\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\nfail:\n    for (i = 0; i < HUF_DECSIZE; i++)\n        if (hdec)\n            av_freep(&hdec[i].p);\n\n    av_free(freq);\n    av_free(hdec);\n\n    return ret;\n}\n\nstatic inline void wdec14(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int16_t ls = l;\n    int16_t hs = h;\n    int hi     = hs;\n    int ai     = ls + (hi & 1) + (hi >> 1);\n    int16_t as = ai;\n    int16_t bs = ai - hi;\n\n    *a = as;\n    *b = bs;\n}\n\n#define NBITS      16\n#define A_OFFSET  (1 << (NBITS - 1))\n#define MOD_MASK  ((1 << NBITS) - 1)\n\nstatic inline void wdec16(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int m  = l;\n    int d  = h;\n    int bb = (m - (d >> 1)) & MOD_MASK;\n    int aa = (d + bb - A_OFFSET) & MOD_MASK;\n    *b = bb;\n    *a = aa;\n}\n\nstatic void wav_decode(uint16_t *in, int nx, int ox,\n                       int ny, int oy, uint16_t mx)\n{\n    int w14 = (mx < (1 << 14));\n    int n   = (nx > ny) ? ny : nx;\n    int p   = 1;\n    int p2;\n\n    while (p <= n)\n        p <<= 1;\n\n    p >>= 1;\n    p2  = p;\n    p >>= 1;\n\n    while (p >= 1) {\n        uint16_t *py = in;\n        uint16_t *ey = in + oy * (ny - p2);\n        uint16_t i00, i01, i10, i11;\n        int oy1 = oy * p;\n        int oy2 = oy * p2;\n        int ox1 = ox * p;\n        int ox2 = ox * p2;\n\n        for (; py <= ey; py += oy2) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n                uint16_t *p10 = px + oy1;\n                uint16_t *p11 = p10 + ox1;\n\n                if (w14) {\n                    wdec14(*px, *p10, &i00, &i10);\n                    wdec14(*p01, *p11, &i01, &i11);\n                    wdec14(i00, i01, px, p01);\n                    wdec14(i10, i11, p10, p11);\n                } else {\n                    wdec16(*px, *p10, &i00, &i10);\n                    wdec16(*p01, *p11, &i01, &i11);\n                    wdec16(i00, i01, px, p01);\n                    wdec16(i10, i11, p10, p11);\n                }\n            }\n\n            if (nx & p) {\n                uint16_t *p10 = px + oy1;\n\n                if (w14)\n                    wdec14(*px, *p10, &i00, p10);\n                else\n                    wdec16(*px, *p10, &i00, p10);\n\n                *px = i00;\n            }\n        }\n\n        if (ny & p) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n\n                if (w14)\n                    wdec14(*px, *p01, &i00, p01);\n                else\n                    wdec16(*px, *p01, &i00, p01);\n\n                *px = i00;\n            }\n        }\n\n        p2  = p;\n        p >>= 1;\n    }\n}\n\nstatic int piz_uncompress(EXRContext *s, const uint8_t *src, int ssize,\n                          int dsize, EXRThreadData *td)\n{\n    GetByteContext gb;\n    uint16_t maxval, min_non_zero, max_non_zero;\n    uint16_t *ptr;\n    uint16_t *tmp = (uint16_t *)td->tmp;\n    uint16_t *out;\n    uint16_t *in;\n    int ret, i, j;\n    int pixel_half_size;/* 1 for half, 2 for float and uint32 */\n    EXRChannel *channel;\n    int tmp_offset;\n\n    if (!td->bitmap)\n        td->bitmap = av_malloc(BITMAP_SIZE);\n    if (!td->lut)\n        td->lut = av_malloc(1 << 17);\n    if (!td->bitmap || !td->lut) {\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n        return AVERROR(ENOMEM);\n    }\n\n    bytestream2_init(&gb, src, ssize);\n    min_non_zero = bytestream2_get_le16(&gb);\n    max_non_zero = bytestream2_get_le16(&gb);\n\n    if (max_non_zero >= BITMAP_SIZE)\n        return AVERROR_INVALIDDATA;\n\n    memset(td->bitmap, 0, FFMIN(min_non_zero, BITMAP_SIZE));\n    if (min_non_zero <= max_non_zero)\n        bytestream2_get_buffer(&gb, td->bitmap + min_non_zero,\n                               max_non_zero - min_non_zero + 1);\n    memset(td->bitmap + max_non_zero + 1, 0, BITMAP_SIZE - max_non_zero - 1);\n\n    maxval = reverse_lut(td->bitmap, td->lut);\n\n    ret = huf_uncompress(&gb, tmp, dsize / sizeof(uint16_t));\n    if (ret)\n        return ret;\n\n    ptr = tmp;\n    for (i = 0; i < s->nb_channels; i++) {\n        channel = &s->channels[i];\n\n        if (channel->pixel_type == EXR_HALF)\n            pixel_half_size = 1;\n        else\n            pixel_half_size = 2;\n\n        for (j = 0; j < pixel_half_size; j++)\n            wav_decode(ptr + j, td->xsize, pixel_half_size, td->ysize,\n                       td->xsize * pixel_half_size, maxval);\n        ptr += td->xsize * td->ysize * pixel_half_size;\n    }\n\n    apply_lut(td->lut, tmp, dsize / sizeof(uint16_t));\n\n    out = (uint16_t *)td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++) {\n        tmp_offset = 0;\n        for (j = 0; j < s->nb_channels; j++) {\n            channel = &s->channels[j];\n            if (channel->pixel_type == EXR_HALF)\n                pixel_half_size = 1;\n            else\n                pixel_half_size = 2;\n\n            in = tmp + tmp_offset * td->xsize * td->ysize + i * td->xsize * pixel_half_size;\n            tmp_offset += pixel_half_size;\n\n#if HAVE_BIGENDIAN\n            s->bbdsp.bswap16_buf(out, in, td->xsize * pixel_half_size);\n#else\n            memcpy(out, in, td->xsize * 2 * pixel_half_size);\n#endif\n            out += td->xsize * pixel_half_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n                            int compressed_size, int uncompressed_size,\n                            EXRThreadData *td)\n{\n    unsigned long dest_len, expected_len = 0;\n    const uint8_t *in = td->tmp;\n    uint8_t *out;\n    int c, i, j;\n\n    for (i = 0; i < s->nb_channels; i++) {\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n            expected_len += (td->xsize * td->ysize * 2);\n        } else {//UINT 32\n            expected_len += (td->xsize * td->ysize * 4);\n        }\n    }\n\n    dest_len = expected_len;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n        return AVERROR_INVALIDDATA;\n    } else if (dest_len != expected_len) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    out = td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++)\n        for (c = 0; c < s->nb_channels; c++) {\n            EXRChannel *channel = &s->channels[c];\n            const uint8_t *ptr[4];\n            uint32_t pixel = 0;\n\n            switch (channel->pixel_type) {\n            case EXR_FLOAT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                ptr[2] = ptr[1] + td->xsize;\n                in     = ptr[2] + td->xsize;\n\n                for (j = 0; j < td->xsize; ++j) {\n                    uint32_t diff = ((unsigned)*(ptr[0]++) << 24) |\n                                    (*(ptr[1]++) << 16) |\n                                    (*(ptr[2]++) << 8);\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            case EXR_HALF:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                in     = ptr[1] + td->xsize;\n                for (j = 0; j < td->xsize; j++) {\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n                    pixel += diff;\n                    bytestream_put_le16(&out, pixel);\n                }\n                break;\n            case EXR_UINT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + s->xdelta;\n                ptr[2] = ptr[1] + s->xdelta;\n                ptr[3] = ptr[2] + s->xdelta;\n                in     = ptr[3] + s->xdelta;\n\n                for (j = 0; j < s->xdelta; ++j) {\n                    uint32_t diff = ((uint32_t)*(ptr[0]++) << 24) |\n                    (*(ptr[1]++) << 16) |\n                    (*(ptr[2]++) << 8 ) |\n                    (*(ptr[3]++));\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            default:\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n    return 0;\n}\n\nstatic void unpack_14(const uint8_t b[14], uint16_t s[16])\n{\n    unsigned short shift = (b[ 2] >> 2) & 15;\n    unsigned short bias = (0x20 << shift);\n    int i;\n\n    s[ 0] = (b[0] << 8) | b[1];\n\n    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3f) << shift) - bias;\n    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3f) << shift) - bias;\n    s[12] = s[ 8] +   ((b[ 4]                       & 0x3f) << shift) - bias;\n\n    s[ 1] = s[ 0] +   ((b[ 5] >> 2)                         << shift) - bias;\n    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3f) << shift) - bias;\n    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3f) << shift) - bias;\n    s[13] = s[12] +   ((b[ 7]                       & 0x3f) << shift) - bias;\n\n    s[ 2] = s[ 1] +   ((b[ 8] >> 2)                         << shift) - bias;\n    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3f) << shift) - bias;\n    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3f) << shift) - bias;\n    s[14] = s[13] +   ((b[10]                       & 0x3f) << shift) - bias;\n\n    s[ 3] = s[ 2] +   ((b[11] >> 2)                         << shift) - bias;\n    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3f) << shift) - bias;\n    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3f) << shift) - bias;\n    s[15] = s[14] +   ((b[13]                       & 0x3f) << shift) - bias;\n\n    for (i = 0; i < 16; ++i) {\n        if (s[i] & 0x8000)\n            s[i] &= 0x7fff;\n        else\n            s[i] = ~s[i];\n    }\n}\n\nstatic void unpack_3(const uint8_t b[3], uint16_t s[16])\n{\n    int i;\n\n    s[0] = (b[0] << 8) | b[1];\n\n    if (s[0] & 0x8000)\n        s[0] &= 0x7fff;\n    else\n        s[0] = ~s[0];\n\n    for (i = 1; i < 16; i++)\n        s[i] = s[0];\n}\n\n\nstatic int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td) {\n    const int8_t *sr = src;\n    int stay_to_uncompress = compressed_size;\n    int nb_b44_block_w, nb_b44_block_h;\n    int index_tl_x, index_tl_y, index_out, index_tmp;\n    uint16_t tmp_buffer[16]; /* B44 use 4x4 half float pixel */\n    int c, iY, iX, y, x;\n    int target_channel_offset = 0;\n\n    /* calc B44 block count */\n    nb_b44_block_w = td->xsize / 4;\n    if ((td->xsize % 4) != 0)\n        nb_b44_block_w++;\n\n    nb_b44_block_h = td->ysize / 4;\n    if ((td->ysize % 4) != 0)\n        nb_b44_block_h++;\n\n    for (c = 0; c < s->nb_channels; c++) {\n        if (s->channels[c].pixel_type == EXR_HALF) {/* B44 only compress half float data */\n            for (iY = 0; iY < nb_b44_block_h; iY++) {\n                for (iX = 0; iX < nb_b44_block_w; iX++) {/* For each B44 block */\n                    if (stay_to_uncompress < 3) {\n                        av_log(s, AV_LOG_ERROR, \"Not enough data for B44A block: %d\", stay_to_uncompress);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (src[compressed_size - stay_to_uncompress + 2] == 0xfc) { /* B44A block */\n                        unpack_3(sr, tmp_buffer);\n                        sr += 3;\n                        stay_to_uncompress -= 3;\n                    }  else {/* B44 Block */\n                        if (stay_to_uncompress < 14) {\n                            av_log(s, AV_LOG_ERROR, \"Not enough data for B44 block: %d\", stay_to_uncompress);\n                            return AVERROR_INVALIDDATA;\n                        }\n                        unpack_14(sr, tmp_buffer);\n                        sr += 14;\n                        stay_to_uncompress -= 14;\n                    }\n\n                    /* copy data to uncompress buffer (B44 block can exceed target resolution)*/\n                    index_tl_x = iX * 4;\n                    index_tl_y = iY * 4;\n\n                    for (y = index_tl_y; y < FFMIN(index_tl_y + 4, td->ysize); y++) {\n                        for (x = index_tl_x; x < FFMIN(index_tl_x + 4, td->xsize); x++) {\n                            index_out = target_channel_offset * td->xsize + y * td->channel_line_size + 2 * x;\n                            index_tmp = (y-index_tl_y) * 4 + (x-index_tl_x);\n                            td->uncompressed_data[index_out] = tmp_buffer[index_tmp] & 0xff;\n                            td->uncompressed_data[index_out + 1] = tmp_buffer[index_tmp] >> 8;\n                        }\n                    }\n                }\n            }\n            target_channel_offset += 2;\n        } else {/* Float or UINT 32 channel */\n            if (stay_to_uncompress < td->ysize * td->xsize * 4) {\n                av_log(s, AV_LOG_ERROR, \"Not enough data for uncompress channel: %d\", stay_to_uncompress);\n                return AVERROR_INVALIDDATA;\n            }\n\n            for (y = 0; y < td->ysize; y++) {\n                index_out = target_channel_offset * td->xsize + y * td->channel_line_size;\n                memcpy(&td->uncompressed_data[index_out], sr, td->xsize * 4);\n                sr += td->xsize * 4;\n            }\n            target_channel_offset += 4;\n\n            stay_to_uncompress -= td->ysize * td->xsize * 4;\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_block(AVCodecContext *avctx, void *tdata,\n                        int jobnr, int threadnr)\n{\n    EXRContext *s = avctx->priv_data;\n    AVFrame *const p = s->picture;\n    EXRThreadData *td = &s->thread_data[threadnr];\n    const uint8_t *channel_buffer[4] = { 0 };\n    const uint8_t *buf = s->buf;\n    uint64_t line_offset, uncompressed_size;\n    uint8_t *ptr;\n    uint32_t data_size;\n    int line, col = 0;\n    uint64_t tile_x, tile_y, tile_level_x, tile_level_y;\n    const uint8_t *src;\n    int step = s->desc->flags & AV_PIX_FMT_FLAG_FLOAT ? 4 : 2 * s->desc->nb_components;\n    int bxmin = 0, axmax = 0, window_xoffset = 0;\n    int window_xmin, window_xmax, window_ymin, window_ymax;\n    int data_xoffset, data_yoffset, data_window_offset, xsize, ysize;\n    int i, x, buf_size = s->buf_size;\n    int c, rgb_channel_count;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    int ret;\n\n    line_offset = AV_RL64(s->gb.buffer + jobnr * 8);\n\n    if (s->is_tile) {\n        if (buf_size < 20 || line_offset > buf_size - 20)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 20;\n\n        tile_x = AV_RL32(src - 20);\n        tile_y = AV_RL32(src - 16);\n        tile_level_x = AV_RL32(src - 12);\n        tile_level_y = AV_RL32(src - 8);\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 20)\n            return AVERROR_INVALIDDATA;\n\n        if (tile_level_x || tile_level_y) { /* tile level, is not the full res level */\n            avpriv_report_missing_feature(s->avctx, \"Subres tile before full res tile\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        line = s->ymin + s->tile_attr.ySize * tile_y;\n        col = s->tile_attr.xSize * tile_x;\n\n        if (line < s->ymin || line > s->ymax ||\n            s->xmin + col  < s->xmin ||  s->xmin + col  > s->xmax)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tile_y * s->tile_attr.ySize);\n        td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tile_x * s->tile_attr.xSize);\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n    } else {\n        if (buf_size < 8 || line_offset > buf_size - 8)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 8;\n        line = AV_RL32(src - 8);\n\n        if (line < s->ymin || line > s->ymax)\n            return AVERROR_INVALIDDATA;\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 8)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1); /* s->ydelta - line ?? */\n        td->xsize          = s->xdelta;\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n\n        if ((s->compression == EXR_RAW && (data_size != uncompressed_size ||\n                                           line_offset > buf_size - uncompressed_size)) ||\n            (s->compression != EXR_RAW && (data_size > uncompressed_size ||\n                                           line_offset > buf_size - data_size))) {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    window_xmin = FFMIN(avctx->width, FFMAX(0, s->xmin + col));\n    window_xmax = FFMIN(avctx->width, FFMAX(0, s->xmin + col + td->xsize));\n    window_ymin = FFMIN(avctx->height, FFMAX(0, line ));\n    window_ymax = FFMIN(avctx->height, FFMAX(0, line + td->ysize));\n    xsize = window_xmax - window_xmin;\n    ysize = window_ymax - window_ymin;\n\n    /* tile or scanline not visible skip decoding */\n    if (xsize <= 0 || ysize <= 0)\n        return 0;\n\n    /* is the first tile or is a scanline */\n    if(col == 0) {\n        window_xmin = 0;\n        /* pixels to add at the left of the display window */\n        window_xoffset = FFMAX(0, s->xmin);\n        /* bytes to add at the left of the display window */\n        bxmin = window_xoffset * step;\n    }\n\n    /* is the last tile or is a scanline */\n    if(col + td->xsize == s->xdelta) {\n        window_xmax = avctx->width;\n         /* bytes to add at the right of the display window */\n        axmax = FFMAX(0, (avctx->width - (s->xmax + 1))) * step;\n    }\n\n    if (data_size < uncompressed_size || s->is_tile) { /* td->tmp is use for tile reorganization */\n        av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size);\n        if (!td->tmp)\n            return AVERROR(ENOMEM);\n    }\n\n    if (data_size < uncompressed_size) {\n        av_fast_padded_malloc(&td->uncompressed_data,\n                              &td->uncompressed_size, uncompressed_size + 64);/* Force 64 padding for AVX2 reorder_pixels dst */\n\n        if (!td->uncompressed_data)\n            return AVERROR(ENOMEM);\n\n        ret = AVERROR_INVALIDDATA;\n        switch (s->compression) {\n        case EXR_ZIP1:\n        case EXR_ZIP16:\n            ret = zip_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PIZ:\n            ret = piz_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PXR24:\n            ret = pxr24_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_RLE:\n            ret = rle_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_B44:\n        case EXR_B44A:\n            ret = b44_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        }\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"decode_block() failed.\\n\");\n            return ret;\n        }\n        src = td->uncompressed_data;\n    }\n\n    /* offsets to crop data outside display window */\n    data_xoffset = FFABS(FFMIN(0, s->xmin + col)) * (s->pixel_type == EXR_HALF ? 2 : 4);\n    data_yoffset = FFABS(FFMIN(0, line));\n    data_window_offset = (data_yoffset * td->channel_line_size) + data_xoffset;\n\n    if (!s->is_luma) {\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[0]) + data_window_offset;\n        channel_buffer[1] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        channel_buffer[2] = src + (td->xsize * s->channel_offsets[2]) + data_window_offset;\n        rgb_channel_count = 3;\n    } else { /* put y data in the first channel_buffer */\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        rgb_channel_count = 1;\n    }\n     if (s->channel_offsets[3] >= 0)\n        channel_buffer[3] = src + (td->xsize * s->channel_offsets[3]) + data_window_offset;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n\n        /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n        int channel_count = s->channel_offsets[3] >= 0 ? 4 : rgb_channel_count;\n        if (s->is_luma) {\n            channel_buffer[1] = channel_buffer[0];\n            channel_buffer[2] = channel_buffer[0];\n        }\n\n        for (c = 0; c < channel_count; c++) {\n            int plane = s->desc->comp[c].plane;\n            ptr = p->data[plane] + window_ymin * p->linesize[plane] + (window_xmin * 4);\n\n            for (i = 0; i < ysize; i++, ptr += p->linesize[plane]) {\n                const uint8_t *src;\n                union av_intfloat32 *ptr_x;\n\n                src = channel_buffer[c];\n                ptr_x = (union av_intfloat32 *)ptr;\n\n                // Zero out the start if xmin is not 0\n                memset(ptr_x, 0, bxmin);\n                ptr_x += window_xoffset;\n\n                if (s->pixel_type == EXR_FLOAT) {\n                    // 32-bit\n                    union av_intfloat32 t;\n                    if (trc_func && c < 3) {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            t.f = trc_func(t.f);\n                            *ptr_x++ = t;\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            if (t.f > 0.0f && c < 3)  /* avoid negative values */\n                                t.f = powf(t.f, one_gamma);\n                            *ptr_x++ = t;\n                        }\n                    }\n                } else if (s->pixel_type == EXR_HALF) {\n                    // 16-bit\n                    if (c < 3 || !trc_func) {\n                        for (x = 0; x < xsize; x++) {\n                            *ptr_x++ = s->gamma_table[bytestream_get_le16(&src)];\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            *ptr_x++ = exr_half2float(bytestream_get_le16(&src));;\n                        }\n                    }\n                }\n\n                // Zero out the end if xmax+1 is not w\n                memset(ptr_x, 0, axmax);\n                channel_buffer[c] += td->channel_line_size;\n            }\n        }\n    } else {\n\n        av_assert1(s->pixel_type == EXR_UINT);\n        ptr = p->data[0] + window_ymin * p->linesize[0] + (window_xmin * s->desc->nb_components * 2);\n\n        for (i = 0; i < ysize; i++, ptr += p->linesize[0]) {\n\n            const uint8_t * a;\n            const uint8_t *rgb[3];\n            uint16_t *ptr_x;\n\n            for (c = 0; c < rgb_channel_count; c++) {\n                rgb[c] = channel_buffer[c];\n            }\n\n            if (channel_buffer[3])\n                a = channel_buffer[3];\n\n            ptr_x = (uint16_t *) ptr;\n\n            // Zero out the start if xmin is not 0\n            memset(ptr_x, 0, bxmin);\n            ptr_x += window_xoffset * s->desc->nb_components;\n\n            for (x = 0; x < xsize; x++) {\n                for (c = 0; c < rgb_channel_count; c++) {\n                    *ptr_x++ = bytestream_get_le32(&rgb[c]) >> 16;\n                }\n\n                if (channel_buffer[3])\n                    *ptr_x++ = bytestream_get_le32(&a) >> 16;\n            }\n\n            // Zero out the end if xmax+1 is not w\n            memset(ptr_x, 0, axmax);\n\n            channel_buffer[0] += td->channel_line_size;\n            channel_buffer[1] += td->channel_line_size;\n            channel_buffer[2] += td->channel_line_size;\n            if (channel_buffer[3])\n                channel_buffer[3] += td->channel_line_size;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Check if the variable name corresponds to its data type.\n *\n * @param s              the EXRContext\n * @param value_name     name of the variable to check\n * @param value_type     type of the variable to check\n * @param minimum_length minimum length of the variable data\n *\n * @return bytes to read containing variable data\n *         -1 if variable is not found\n *         0 if buffer ended prematurely\n */\nstatic int check_header_variable(EXRContext *s,\n                                 const char *value_name,\n                                 const char *value_type,\n                                 unsigned int minimum_length)\n{\n    int var_size = -1;\n\n    if (bytestream2_get_bytes_left(&s->gb) >= minimum_length &&\n        !strcmp(s->gb.buffer, value_name)) {\n        // found value_name, jump to value_type (null terminated strings)\n        s->gb.buffer += strlen(value_name) + 1;\n        if (!strcmp(s->gb.buffer, value_type)) {\n            s->gb.buffer += strlen(value_type) + 1;\n            var_size = bytestream2_get_le32(&s->gb);\n            // don't go read past boundaries\n            if (var_size > bytestream2_get_bytes_left(&s->gb))\n                var_size = 0;\n        } else {\n            // value_type not found, reset the buffer\n            s->gb.buffer -= strlen(value_name) + 1;\n            av_log(s->avctx, AV_LOG_WARNING,\n                   \"Unknown data type %s for header variable %s.\\n\",\n                   value_type, value_name);\n        }\n    }\n\n    return var_size;\n}\n\nstatic int decode_header(EXRContext *s, AVFrame *frame)\n{\n    AVDictionary *metadata = NULL;\n    int magic_number, version, i, flags, sar = 0;\n    int layer_match = 0;\n    int ret;\n    int dup_channels = 0;\n\n    s->current_channel_offset = 0;\n    s->xmin               = ~0;\n    s->xmax               = ~0;\n    s->ymin               = ~0;\n    s->ymax               = ~0;\n    s->xdelta             = ~0;\n    s->ydelta             = ~0;\n    s->channel_offsets[0] = -1;\n    s->channel_offsets[1] = -1;\n    s->channel_offsets[2] = -1;\n    s->channel_offsets[3] = -1;\n    s->pixel_type         = EXR_UNKNOWN;\n    s->compression        = EXR_UNKN;\n    s->nb_channels        = 0;\n    s->w                  = 0;\n    s->h                  = 0;\n    s->tile_attr.xSize    = -1;\n    s->tile_attr.ySize    = -1;\n    s->is_tile            = 0;\n    s->is_luma            = 0;\n\n    if (bytestream2_get_bytes_left(&s->gb) < 10) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    magic_number = bytestream2_get_le32(&s->gb);\n    if (magic_number != 20000630) {\n        /* As per documentation of OpenEXR, it is supposed to be\n         * int 20000630 little-endian */\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = bytestream2_get_byte(&s->gb);\n    if (version != 2) {\n        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    flags = bytestream2_get_le24(&s->gb);\n\n    if (flags & 0x02)\n        s->is_tile = 1;\n    if (flags & 0x08) {\n        avpriv_report_missing_feature(s->avctx, \"deep data\");\n        return AVERROR_PATCHWELCOME;\n    }\n    if (flags & 0x10) {\n        avpriv_report_missing_feature(s->avctx, \"multipart\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    // Parse the header\n    while (bytestream2_get_bytes_left(&s->gb) > 0 && *s->gb.buffer) {\n        int var_size;\n        if ((var_size = check_header_variable(s, \"channels\",\n                                              \"chlist\", 38)) >= 0) {\n            GetByteContext ch_gb;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            bytestream2_init(&ch_gb, s->gb.buffer, var_size);\n\n            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {\n                EXRChannel *channel;\n                enum ExrPixelType current_pixel_type;\n                int channel_index = -1;\n                int xsub, ysub;\n\n                if (strcmp(s->layer, \"\") != 0) {\n                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {\n                        layer_match = 1;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer);\n                        ch_gb.buffer += strlen(s->layer);\n                        if (*ch_gb.buffer == '.')\n                            ch_gb.buffer++;         /* skip dot if not given */\n                    } else {\n                        layer_match = 0;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer);\n                    }\n                } else {\n                    layer_match = 1;\n                }\n\n                if (layer_match) { /* only search channel if the layer match is valid */\n                    if (!av_strcasecmp(ch_gb.buffer, \"R\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"X\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"U\")) {\n                        channel_index = 0;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"G\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"V\")) {\n                        channel_index = 1;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"Y\")) {\n                        channel_index = 1;\n                        s->is_luma = 1;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"B\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"Z\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"W\")) {\n                        channel_index = 2;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"A\")) {\n                        channel_index = 3;\n                    } else {\n                        av_log(s->avctx, AV_LOG_WARNING,\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer);\n                    }\n                }\n\n                /* skip until you get a 0 */\n                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&\n                       bytestream2_get_byte(&ch_gb))\n                    continue;\n\n                if (bytestream2_get_bytes_left(&ch_gb) < 4) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n\n                current_pixel_type = bytestream2_get_le32(&ch_gb);\n                if (current_pixel_type >= EXR_UNKNOWN) {\n                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n                                                  current_pixel_type);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                bytestream2_skip(&ch_gb, 4);\n                xsub = bytestream2_get_le32(&ch_gb);\n                ysub = bytestream2_get_le32(&ch_gb);\n\n                if (xsub != 1 || ysub != 1) {\n                    avpriv_report_missing_feature(s->avctx,\n                                                  \"Subsampling %dx%d\",\n                                                  xsub, ysub);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                if (channel_index >= 0 && s->channel_offsets[channel_index] == -1) { /* channel has not been previously assigned */\n                    if (s->pixel_type != EXR_UNKNOWN &&\n                        s->pixel_type != current_pixel_type) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"RGB channels not of the same depth.\\n\");\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                    s->pixel_type                     = current_pixel_type;\n                    s->channel_offsets[channel_index] = s->current_channel_offset;\n                } else if (channel_index >= 0) {\n                    av_log(s->avctx, AV_LOG_WARNING,\n                            \"Multiple channels with index %d.\\n\", channel_index);\n                    if (++dup_channels > 10) {\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                }\n\n                s->channels = av_realloc(s->channels,\n                                         ++s->nb_channels * sizeof(EXRChannel));\n                if (!s->channels) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                channel             = &s->channels[s->nb_channels - 1];\n                channel->pixel_type = current_pixel_type;\n                channel->xsub       = xsub;\n                channel->ysub       = ysub;\n\n                if (current_pixel_type == EXR_HALF) {\n                    s->current_channel_offset += 2;\n                } else {/* Float or UINT32 */\n                    s->current_channel_offset += 4;\n                }\n            }\n\n            /* Check if all channels are set with an offset or if the channels\n             * are causing an overflow  */\n            if (!s->is_luma) {/* if we expected to have at least 3 channels */\n                if (FFMIN3(s->channel_offsets[0],\n                           s->channel_offsets[1],\n                           s->channel_offsets[2]) < 0) {\n                    if (s->channel_offsets[0] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");\n                    if (s->channel_offsets[1] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");\n                    if (s->channel_offsets[2] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n            }\n\n            // skip one last byte and update main gb\n            s->gb.buffer = ch_gb.buffer + 1;\n            continue;\n        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",\n                                                     31)) >= 0) {\n            int xmin, ymin, xmax, ymax;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            xmin   = bytestream2_get_le32(&s->gb);\n            ymin   = bytestream2_get_le32(&s->gb);\n            xmax   = bytestream2_get_le32(&s->gb);\n            ymax   = bytestream2_get_le32(&s->gb);\n\n            if (xmin > xmax || ymin > ymax ||\n                (unsigned)xmax - xmin >= INT_MAX ||\n                (unsigned)ymax - ymin >= INT_MAX) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            s->xmin = xmin;\n            s->xmax = xmax;\n            s->ymin = ymin;\n            s->ymax = ymax;\n            s->xdelta = (s->xmax - s->xmin) + 1;\n            s->ydelta = (s->ymax - s->ymin) + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"displayWindow\",\n                                                     \"box2i\", 34)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            bytestream2_skip(&s->gb, 8);\n            s->w = bytestream2_get_le32(&s->gb) + 1;\n            s->h = bytestream2_get_le32(&s->gb) + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"lineOrder\",\n                                                     \"lineOrder\", 25)) >= 0) {\n            int line_order;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            line_order = bytestream2_get_byte(&s->gb);\n            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);\n            if (line_order > 2) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",\n                                                     \"float\", 31)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            sar = bytestream2_get_le32(&s->gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"compression\",\n                                                     \"compression\", 29)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            if (s->compression == EXR_UNKN)\n                s->compression = bytestream2_get_byte(&s->gb);\n            else\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found more than one compression attribute.\\n\");\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"tiles\",\n                                                     \"tiledesc\", 22)) >= 0) {\n            char tileLevel;\n\n            if (!s->is_tile)\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");\n\n            s->tile_attr.xSize = bytestream2_get_le32(&s->gb);\n            s->tile_attr.ySize = bytestream2_get_le32(&s->gb);\n\n            tileLevel = bytestream2_get_byte(&s->gb);\n            s->tile_attr.level_mode = tileLevel & 0x0f;\n            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;\n\n            if (s->tile_attr.level_mode >= EXR_TILE_LEVEL_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n                                              s->tile_attr.level_mode);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            if (s->tile_attr.level_round >= EXR_TILE_ROUND_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n                                              s->tile_attr.level_round);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"writer\",\n                                                     \"string\", 1)) >= 0) {\n            uint8_t key[256] = { 0 };\n\n            bytestream2_get_buffer(&s->gb, key, FFMIN(sizeof(key) - 1, var_size));\n            av_dict_set(&metadata, \"writer\", key, 0);\n\n            continue;\n        }\n\n        // Check if there are enough bytes for a header\n        if (bytestream2_get_bytes_left(&s->gb) <= 9) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        // Process unknown variables\n        for (i = 0; i < 2; i++) // value_name and value_type\n            while (bytestream2_get_byte(&s->gb) != 0);\n\n        // Skip variable length\n        bytestream2_skip(&s->gb, bytestream2_get_le32(&s->gb));\n    }\n\n    ff_set_sar(s->avctx, av_d2q(av_int2float(sar), 255));\n\n    if (s->compression == EXR_UNKN) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (s->is_tile) {\n        if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    frame->metadata = metadata;\n\n    // aaand we are done\n    bytestream2_skip(&s->gb, 1);\n    return 0;\nfail:\n    av_dict_free(&metadata);\n    return ret;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   /* nb scanline or nb tile */\n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n        s->scan_lines_per_block = 32;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* Verify the xmin, xmax, ymin and ymax before setting the actual image size.\n     * It's possible for the data window can larger or outside the display window */\n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { /* scanline */\n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n    // check offset table and recreate it if need\n    if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(&s->gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            /* write offset of prev scanline in offset table */\n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            /* get len of next scanline */\n            bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);/* skip line number */\n            start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);\n        }\n        bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);\n    }\n\n    // save pointer we are going to use in decode_block\n    s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n    // Zero out the start if ymin is not 0\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < s->ymin; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    uint32_t i;\n    union av_intfloat32 t;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = NULL;\n\n    s->avctx              = avctx;\n\n    ff_exrdsp_init(&s->dsp);\n\n#if HAVE_BIGENDIAN\n    ff_bswapdsp_init(&s->bbdsp);\n#endif\n\n    trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    if (trc_func) {\n        for (i = 0; i < 65536; ++i) {\n            t = exr_half2float(i);\n            t.f = trc_func(t.f);\n            s->gamma_table[i] = t;\n        }\n    } else {\n        if (one_gamma > 0.9999f && one_gamma < 1.0001f) {\n            for (i = 0; i < 65536; ++i) {\n                s->gamma_table[i] = exr_half2float(i);\n            }\n        } else {\n            for (i = 0; i < 65536; ++i) {\n                t = exr_half2float(i);\n                /* If negative value we reuse half value */\n                if (t.f <= 0.0f) {\n                    s->gamma_table[i] = t;\n                } else {\n                    t.f = powf(t.f, one_gamma);\n                    s->gamma_table[i] = t;\n                }\n            }\n        }\n    }\n\n    // allocate thread data, used for non EXR_RAW compression types\n    s->thread_data = av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData));\n    if (!s->thread_data)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    int i;\n    for (i = 0; i < avctx->thread_count; i++) {\n        EXRThreadData *td = &s->thread_data[i];\n        av_freep(&td->uncompressed_data);\n        av_freep(&td->tmp);\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n    }\n\n    av_freep(&s->thread_data);\n    av_freep(&s->channels);\n\n    return 0;\n}\n\n#define OFFSET(x) offsetof(EXRContext, x)\n#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption options[] = {\n    { \"layer\", \"Set the decoding layer\", OFFSET(layer),\n        AV_OPT_TYPE_STRING, { .str = \"\" }, 0, 0, VD },\n    { \"gamma\", \"Set the float gamma value when decoding\", OFFSET(gamma),\n        AV_OPT_TYPE_FLOAT, { .dbl = 1.0f }, 0.001, FLT_MAX, VD },\n\n    // XXX: Note the abuse of the enum using AVCOL_TRC_UNSPECIFIED to subsume the existing gamma option\n    { \"apply_trc\", \"color transfer characteristics to apply to EXR linear input\", OFFSET(apply_trc_type),\n        AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, AVCOL_TRC_NB-1, VD, \"apply_trc_type\"},\n    { \"bt709\",        \"BT.709\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT709 },        INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma\",        \"gamma\",            0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma22\",      \"BT.470 M\",         0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA22 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma28\",      \"BT.470 BG\",        0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA28 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte170m\",    \"SMPTE 170 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE170M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte240m\",    \"SMPTE 240 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE240M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"linear\",       \"Linear\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LINEAR },       INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log\",          \"Log\",              0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log_sqrt\",     \"Log square root\",  0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_4\", \"IEC 61966-2-4\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt1361\",       \"BT.1361\",          0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_1\", \"IEC 61966-2-1\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_10bit\", \"BT.2020 - 10 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_12bit\", \"BT.2020 - 12 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte2084\",    \"SMPTE ST 2084\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST2084 },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte428_1\",   \"SMPTE ST 428-1\",   0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST428_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n\n    { NULL },\n};\n\nstatic const AVClass exr_class = {\n    .class_name = \"EXR\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_exr_decoder = {\n    .name             = \"exr\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_EXR,\n    .priv_data_size   = sizeof(EXRContext),\n    .init             = decode_init,\n    .close            = decode_end,\n    .decode           = decode_frame,\n    .capabilities     = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |\n                        AV_CODEC_CAP_SLICE_THREADS,\n    .priv_class       = &exr_class,\n};\n"], "fixing_code": ["/*\n * OpenEXR (.exr) image decoder\n * Copyright (c) 2006 Industrial Light & Magic, a division of Lucas Digital Ltd. LLC\n * Copyright (c) 2009 Jimmy Christensen\n *\n * B44/B44A, Tile, UINT32 added by Jokyo Images support by CNC - French National Center for Cinema\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * OpenEXR decoder\n * @author Jimmy Christensen\n *\n * For more information on the OpenEXR format, visit:\n *  http://openexr.com/\n *\n * exr_half2float() is credited to Aaftab Munshi, Dan Ginsburg, Dave Shreiner.\n */\n\n#include <float.h>\n#include <zlib.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/color_utils.h\"\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n\n#if HAVE_BIGENDIAN\n#include \"bswapdsp.h\"\n#endif\n\n#include \"exrdsp.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n#include \"mathops.h\"\n#include \"thread.h\"\n\nenum ExrCompr {\n    EXR_RAW,\n    EXR_RLE,\n    EXR_ZIP1,\n    EXR_ZIP16,\n    EXR_PIZ,\n    EXR_PXR24,\n    EXR_B44,\n    EXR_B44A,\n    EXR_DWA,\n    EXR_DWB,\n    EXR_UNKN,\n};\n\nenum ExrPixelType {\n    EXR_UINT,\n    EXR_HALF,\n    EXR_FLOAT,\n    EXR_UNKNOWN,\n};\n\nenum ExrTileLevelMode {\n    EXR_TILE_LEVEL_ONE,\n    EXR_TILE_LEVEL_MIPMAP,\n    EXR_TILE_LEVEL_RIPMAP,\n    EXR_TILE_LEVEL_UNKNOWN,\n};\n\nenum ExrTileLevelRound {\n    EXR_TILE_ROUND_UP,\n    EXR_TILE_ROUND_DOWN,\n    EXR_TILE_ROUND_UNKNOWN,\n};\n\ntypedef struct EXRChannel {\n    int xsub, ysub;\n    enum ExrPixelType pixel_type;\n} EXRChannel;\n\ntypedef struct EXRTileAttribute {\n    int32_t xSize;\n    int32_t ySize;\n    enum ExrTileLevelMode level_mode;\n    enum ExrTileLevelRound level_round;\n} EXRTileAttribute;\n\ntypedef struct EXRThreadData {\n    uint8_t *uncompressed_data;\n    int uncompressed_size;\n\n    uint8_t *tmp;\n    int tmp_size;\n\n    uint8_t *bitmap;\n    uint16_t *lut;\n\n    int ysize, xsize;\n\n    int channel_line_size;\n} EXRThreadData;\n\ntypedef struct EXRContext {\n    AVClass *class;\n    AVFrame *picture;\n    AVCodecContext *avctx;\n    ExrDSPContext dsp;\n\n#if HAVE_BIGENDIAN\n    BswapDSPContext bbdsp;\n#endif\n\n    enum ExrCompr compression;\n    enum ExrPixelType pixel_type;\n    int channel_offsets[4]; // 0 = red, 1 = green, 2 = blue and 3 = alpha\n    const AVPixFmtDescriptor *desc;\n\n    int w, h;\n    int32_t xmax, xmin;\n    int32_t ymax, ymin;\n    uint32_t xdelta, ydelta;\n\n    int scan_lines_per_block;\n\n    EXRTileAttribute tile_attr; /* header data attribute of tile */\n    int is_tile; /* 0 if scanline, 1 if tile */\n\n    int is_luma;/* 1 if there is an Y plane */\n\n    GetByteContext gb;\n    const uint8_t *buf;\n    int buf_size;\n\n    EXRChannel *channels;\n    int nb_channels;\n    int current_channel_offset;\n\n    EXRThreadData *thread_data;\n\n    const char *layer;\n\n    enum AVColorTransferCharacteristic apply_trc_type;\n    float gamma;\n    union av_intfloat32 gamma_table[65536];\n} EXRContext;\n\n/* -15 stored using a single precision bias of 127 */\n#define HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP 0x38000000\n\n/* max exponent value in single precision that will be converted\n * to Inf or Nan when stored as a half-float */\n#define HALF_FLOAT_MAX_BIASED_EXP_AS_SINGLE_FP_EXP 0x47800000\n\n/* 255 is the max exponent biased value */\n#define FLOAT_MAX_BIASED_EXP (0xFF << 23)\n\n#define HALF_FLOAT_MAX_BIASED_EXP (0x1F << 10)\n\n/**\n * Convert a half float as a uint16_t into a full float.\n *\n * @param hf half float as uint16_t\n *\n * @return float value\n */\nstatic union av_intfloat32 exr_half2float(uint16_t hf)\n{\n    unsigned int sign = (unsigned int) (hf >> 15);\n    unsigned int mantissa = (unsigned int) (hf & ((1 << 10) - 1));\n    unsigned int exp = (unsigned int) (hf & HALF_FLOAT_MAX_BIASED_EXP);\n    union av_intfloat32 f;\n\n    if (exp == HALF_FLOAT_MAX_BIASED_EXP) {\n        // we have a half-float NaN or Inf\n        // half-float NaNs will be converted to a single precision NaN\n        // half-float Infs will be converted to a single precision Inf\n        exp = FLOAT_MAX_BIASED_EXP;\n        if (mantissa)\n            mantissa = (1 << 23) - 1;    // set all bits to indicate a NaN\n    } else if (exp == 0x0) {\n        // convert half-float zero/denorm to single precision value\n        if (mantissa) {\n            mantissa <<= 1;\n            exp = HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP;\n            // check for leading 1 in denorm mantissa\n            while (!(mantissa & (1 << 10))) {\n                // for every leading 0, decrement single precision exponent by 1\n                // and shift half-float mantissa value to the left\n                mantissa <<= 1;\n                exp -= (1 << 23);\n            }\n            // clamp the mantissa to 10 bits\n            mantissa &= ((1 << 10) - 1);\n            // shift left to generate single-precision mantissa of 23 bits\n            mantissa <<= 13;\n        }\n    } else {\n        // shift left to generate single-precision mantissa of 23 bits\n        mantissa <<= 13;\n        // generate single precision biased exponent value\n        exp = (exp << 13) + HALF_FLOAT_MIN_BIASED_EXP_AS_SINGLE_FP_EXP;\n    }\n\n    f.i = (sign << 31) | exp | mantissa;\n\n    return f;\n}\n\nstatic int zip_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    unsigned long dest_len = uncompressed_size;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK ||\n        dest_len != uncompressed_size)\n        return AVERROR_INVALIDDATA;\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    s->dsp.predictor(td->tmp, uncompressed_size);\n    s->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\nstatic int rle_uncompress(EXRContext *ctx, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    uint8_t *d      = td->tmp;\n    const int8_t *s = src;\n    int ssize       = compressed_size;\n    int dsize       = uncompressed_size;\n    uint8_t *dend   = d + dsize;\n    int count;\n\n    while (ssize > 0) {\n        count = *s++;\n\n        if (count < 0) {\n            count = -count;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= count + 1) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s++;\n        } else {\n            count++;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= 2) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s;\n\n            s++;\n        }\n    }\n\n    if (dend != d)\n        return AVERROR_INVALIDDATA;\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    ctx->dsp.predictor(td->tmp, uncompressed_size);\n    ctx->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\n#define USHORT_RANGE (1 << 16)\n#define BITMAP_SIZE  (1 << 13)\n\nstatic uint16_t reverse_lut(const uint8_t *bitmap, uint16_t *lut)\n{\n    int i, k = 0;\n\n    for (i = 0; i < USHORT_RANGE; i++)\n        if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))\n            lut[k++] = i;\n\n    i = k - 1;\n\n    memset(lut + k, 0, (USHORT_RANGE - k) * 2);\n\n    return i;\n}\n\nstatic void apply_lut(const uint16_t *lut, uint16_t *dst, int dsize)\n{\n    int i;\n\n    for (i = 0; i < dsize; ++i)\n        dst[i] = lut[dst[i]];\n}\n\n#define HUF_ENCBITS 16  // literal (value) bit length\n#define HUF_DECBITS 14  // decoding bit size (>= 8)\n\n#define HUF_ENCSIZE ((1 << HUF_ENCBITS) + 1)  // encoding table size\n#define HUF_DECSIZE (1 << HUF_DECBITS)        // decoding table size\n#define HUF_DECMASK (HUF_DECSIZE - 1)\n\ntypedef struct HufDec {\n    int len;\n    int lit;\n    int *p;\n} HufDec;\n\nstatic void huf_canonical_code_table(uint64_t *hcode)\n{\n    uint64_t c, n[59] = { 0 };\n    int i;\n\n    for (i = 0; i < HUF_ENCSIZE; ++i)\n        n[hcode[i]] += 1;\n\n    c = 0;\n    for (i = 58; i > 0; --i) {\n        uint64_t nc = ((c + n[i]) >> 1);\n        n[i] = c;\n        c    = nc;\n    }\n\n    for (i = 0; i < HUF_ENCSIZE; ++i) {\n        int l = hcode[i];\n\n        if (l > 0)\n            hcode[i] = l | (n[l]++ << 6);\n    }\n}\n\n#define SHORT_ZEROCODE_RUN  59\n#define LONG_ZEROCODE_RUN   63\n#define SHORTEST_LONG_RUN   (2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN)\n#define LONGEST_LONG_RUN    (255 + SHORTEST_LONG_RUN)\n\nstatic int huf_unpack_enc_table(GetByteContext *gb,\n                                int32_t im, int32_t iM, uint64_t *hcode)\n{\n    GetBitContext gbit;\n    int ret = init_get_bits8(&gbit, gb->buffer, bytestream2_get_bytes_left(gb));\n    if (ret < 0)\n        return ret;\n\n    for (; im <= iM; im++) {\n        uint64_t l = hcode[im] = get_bits(&gbit, 6);\n\n        if (l == LONG_ZEROCODE_RUN) {\n            int zerun = get_bits(&gbit, 8) + SHORTEST_LONG_RUN;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                hcode[im++] = 0;\n\n            im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n            int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                hcode[im++] = 0;\n\n            im--;\n        }\n    }\n\n    bytestream2_skip(gb, (get_bits_count(&gbit) + 7) / 8);\n    huf_canonical_code_table(hcode);\n\n    return 0;\n}\n\nstatic int huf_build_dec_table(const uint64_t *hcode, int im,\n                               int iM, HufDec *hdecod)\n{\n    for (; im <= iM; im++) {\n        uint64_t c = hcode[im] >> 6;\n        int i, l = hcode[im] & 63;\n\n        if (c >> l)\n            return AVERROR_INVALIDDATA;\n\n        if (l > HUF_DECBITS) {\n            HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));\n            if (pl->len)\n                return AVERROR_INVALIDDATA;\n\n            pl->lit++;\n\n            pl->p = av_realloc(pl->p, pl->lit * sizeof(int));\n            if (!pl->p)\n                return AVERROR(ENOMEM);\n\n            pl->p[pl->lit - 1] = im;\n        } else if (l) {\n            HufDec *pl = hdecod + (c << (HUF_DECBITS - l));\n\n            for (i = 1 << (HUF_DECBITS - l); i > 0; i--, pl++) {\n                if (pl->len || pl->p)\n                    return AVERROR_INVALIDDATA;\n                pl->len = l;\n                pl->lit = im;\n            }\n        }\n    }\n\n    return 0;\n}\n\n#define get_char(c, lc, gb)                                                   \\\n{                                                                             \\\n        c   = (c << 8) | bytestream2_get_byte(gb);                            \\\n        lc += 8;                                                              \\\n}\n\n#define get_code(po, rlc, c, lc, gb, out, oe, outb)                           \\\n{                                                                             \\\n        if (po == rlc) {                                                      \\\n            if (lc < 8)                                                       \\\n                get_char(c, lc, gb);                                          \\\n            lc -= 8;                                                          \\\n                                                                              \\\n            cs = c >> lc;                                                     \\\n                                                                              \\\n            if (out + cs > oe || out == outb)                                 \\\n                return AVERROR_INVALIDDATA;                                   \\\n                                                                              \\\n            s = out[-1];                                                      \\\n                                                                              \\\n            while (cs-- > 0)                                                  \\\n                *out++ = s;                                                   \\\n        } else if (out < oe) {                                                \\\n            *out++ = po;                                                      \\\n        } else {                                                              \\\n            return AVERROR_INVALIDDATA;                                       \\\n        }                                                                     \\\n}\n\nstatic int huf_decode(const uint64_t *hcode, const HufDec *hdecod,\n                      GetByteContext *gb, int nbits,\n                      int rlc, int no, uint16_t *out)\n{\n    uint64_t c        = 0;\n    uint16_t *outb    = out;\n    uint16_t *oe      = out + no;\n    const uint8_t *ie = gb->buffer + (nbits + 7) / 8; // input byte size\n    uint8_t cs;\n    uint16_t s;\n    int i, lc = 0;\n\n    while (gb->buffer < ie) {\n        get_char(c, lc, gb);\n\n        while (lc >= HUF_DECBITS) {\n            const HufDec pl = hdecod[(c >> (lc - HUF_DECBITS)) & HUF_DECMASK];\n\n            if (pl.len) {\n                lc -= pl.len;\n                get_code(pl.lit, rlc, c, lc, gb, out, oe, outb);\n            } else {\n                int j;\n\n                if (!pl.p)\n                    return AVERROR_INVALIDDATA;\n\n                for (j = 0; j < pl.lit; j++) {\n                    int l = hcode[pl.p[j]] & 63;\n\n                    while (lc < l && bytestream2_get_bytes_left(gb) > 0)\n                        get_char(c, lc, gb);\n\n                    if (lc >= l) {\n                        if ((hcode[pl.p[j]] >> 6) ==\n                            ((c >> (lc - l)) & ((1LL << l) - 1))) {\n                            lc -= l;\n                            get_code(pl.p[j], rlc, c, lc, gb, out, oe, outb);\n                            break;\n                        }\n                    }\n                }\n\n                if (j == pl.lit)\n                    return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n\n    i   = (8 - nbits) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0) {\n        const HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n        if (pl.len && lc >= pl.len) {\n            lc -= pl.len;\n            get_code(pl.lit, rlc, c, lc, gb, out, oe, outb);\n        } else {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (out - outb != no)\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nstatic int huf_uncompress(GetByteContext *gb,\n                          uint16_t *dst, int dst_size)\n{\n    int32_t src_size, im, iM;\n    uint32_t nBits;\n    uint64_t *freq;\n    HufDec *hdec;\n    int ret, i;\n\n    src_size = bytestream2_get_le32(gb);\n    im       = bytestream2_get_le32(gb);\n    iM       = bytestream2_get_le32(gb);\n    bytestream2_skip(gb, 4);\n    nBits = bytestream2_get_le32(gb);\n    if (im < 0 || im >= HUF_ENCSIZE ||\n        iM < 0 || iM >= HUF_ENCSIZE ||\n        src_size < 0)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(gb, 4);\n\n    freq = av_mallocz_array(HUF_ENCSIZE, sizeof(*freq));\n    hdec = av_mallocz_array(HUF_DECSIZE, sizeof(*hdec));\n    if (!freq || !hdec) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n        goto fail;\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n        goto fail;\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\nfail:\n    for (i = 0; i < HUF_DECSIZE; i++)\n        if (hdec)\n            av_freep(&hdec[i].p);\n\n    av_free(freq);\n    av_free(hdec);\n\n    return ret;\n}\n\nstatic inline void wdec14(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int16_t ls = l;\n    int16_t hs = h;\n    int hi     = hs;\n    int ai     = ls + (hi & 1) + (hi >> 1);\n    int16_t as = ai;\n    int16_t bs = ai - hi;\n\n    *a = as;\n    *b = bs;\n}\n\n#define NBITS      16\n#define A_OFFSET  (1 << (NBITS - 1))\n#define MOD_MASK  ((1 << NBITS) - 1)\n\nstatic inline void wdec16(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int m  = l;\n    int d  = h;\n    int bb = (m - (d >> 1)) & MOD_MASK;\n    int aa = (d + bb - A_OFFSET) & MOD_MASK;\n    *b = bb;\n    *a = aa;\n}\n\nstatic void wav_decode(uint16_t *in, int nx, int ox,\n                       int ny, int oy, uint16_t mx)\n{\n    int w14 = (mx < (1 << 14));\n    int n   = (nx > ny) ? ny : nx;\n    int p   = 1;\n    int p2;\n\n    while (p <= n)\n        p <<= 1;\n\n    p >>= 1;\n    p2  = p;\n    p >>= 1;\n\n    while (p >= 1) {\n        uint16_t *py = in;\n        uint16_t *ey = in + oy * (ny - p2);\n        uint16_t i00, i01, i10, i11;\n        int oy1 = oy * p;\n        int oy2 = oy * p2;\n        int ox1 = ox * p;\n        int ox2 = ox * p2;\n\n        for (; py <= ey; py += oy2) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n                uint16_t *p10 = px + oy1;\n                uint16_t *p11 = p10 + ox1;\n\n                if (w14) {\n                    wdec14(*px, *p10, &i00, &i10);\n                    wdec14(*p01, *p11, &i01, &i11);\n                    wdec14(i00, i01, px, p01);\n                    wdec14(i10, i11, p10, p11);\n                } else {\n                    wdec16(*px, *p10, &i00, &i10);\n                    wdec16(*p01, *p11, &i01, &i11);\n                    wdec16(i00, i01, px, p01);\n                    wdec16(i10, i11, p10, p11);\n                }\n            }\n\n            if (nx & p) {\n                uint16_t *p10 = px + oy1;\n\n                if (w14)\n                    wdec14(*px, *p10, &i00, p10);\n                else\n                    wdec16(*px, *p10, &i00, p10);\n\n                *px = i00;\n            }\n        }\n\n        if (ny & p) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n\n                if (w14)\n                    wdec14(*px, *p01, &i00, p01);\n                else\n                    wdec16(*px, *p01, &i00, p01);\n\n                *px = i00;\n            }\n        }\n\n        p2  = p;\n        p >>= 1;\n    }\n}\n\nstatic int piz_uncompress(EXRContext *s, const uint8_t *src, int ssize,\n                          int dsize, EXRThreadData *td)\n{\n    GetByteContext gb;\n    uint16_t maxval, min_non_zero, max_non_zero;\n    uint16_t *ptr;\n    uint16_t *tmp = (uint16_t *)td->tmp;\n    uint16_t *out;\n    uint16_t *in;\n    int ret, i, j;\n    int pixel_half_size;/* 1 for half, 2 for float and uint32 */\n    EXRChannel *channel;\n    int tmp_offset;\n\n    if (!td->bitmap)\n        td->bitmap = av_malloc(BITMAP_SIZE);\n    if (!td->lut)\n        td->lut = av_malloc(1 << 17);\n    if (!td->bitmap || !td->lut) {\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n        return AVERROR(ENOMEM);\n    }\n\n    bytestream2_init(&gb, src, ssize);\n    min_non_zero = bytestream2_get_le16(&gb);\n    max_non_zero = bytestream2_get_le16(&gb);\n\n    if (max_non_zero >= BITMAP_SIZE)\n        return AVERROR_INVALIDDATA;\n\n    memset(td->bitmap, 0, FFMIN(min_non_zero, BITMAP_SIZE));\n    if (min_non_zero <= max_non_zero)\n        bytestream2_get_buffer(&gb, td->bitmap + min_non_zero,\n                               max_non_zero - min_non_zero + 1);\n    memset(td->bitmap + max_non_zero + 1, 0, BITMAP_SIZE - max_non_zero - 1);\n\n    maxval = reverse_lut(td->bitmap, td->lut);\n\n    ret = huf_uncompress(&gb, tmp, dsize / sizeof(uint16_t));\n    if (ret)\n        return ret;\n\n    ptr = tmp;\n    for (i = 0; i < s->nb_channels; i++) {\n        channel = &s->channels[i];\n\n        if (channel->pixel_type == EXR_HALF)\n            pixel_half_size = 1;\n        else\n            pixel_half_size = 2;\n\n        for (j = 0; j < pixel_half_size; j++)\n            wav_decode(ptr + j, td->xsize, pixel_half_size, td->ysize,\n                       td->xsize * pixel_half_size, maxval);\n        ptr += td->xsize * td->ysize * pixel_half_size;\n    }\n\n    apply_lut(td->lut, tmp, dsize / sizeof(uint16_t));\n\n    out = (uint16_t *)td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++) {\n        tmp_offset = 0;\n        for (j = 0; j < s->nb_channels; j++) {\n            channel = &s->channels[j];\n            if (channel->pixel_type == EXR_HALF)\n                pixel_half_size = 1;\n            else\n                pixel_half_size = 2;\n\n            in = tmp + tmp_offset * td->xsize * td->ysize + i * td->xsize * pixel_half_size;\n            tmp_offset += pixel_half_size;\n\n#if HAVE_BIGENDIAN\n            s->bbdsp.bswap16_buf(out, in, td->xsize * pixel_half_size);\n#else\n            memcpy(out, in, td->xsize * 2 * pixel_half_size);\n#endif\n            out += td->xsize * pixel_half_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n                            int compressed_size, int uncompressed_size,\n                            EXRThreadData *td)\n{\n    unsigned long dest_len, expected_len = 0;\n    const uint8_t *in = td->tmp;\n    uint8_t *out;\n    int c, i, j;\n\n    for (i = 0; i < s->nb_channels; i++) {\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n            expected_len += (td->xsize * td->ysize * 2);\n        } else {//UINT 32\n            expected_len += (td->xsize * td->ysize * 4);\n        }\n    }\n\n    dest_len = expected_len;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n        return AVERROR_INVALIDDATA;\n    } else if (dest_len != expected_len) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    out = td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++)\n        for (c = 0; c < s->nb_channels; c++) {\n            EXRChannel *channel = &s->channels[c];\n            const uint8_t *ptr[4];\n            uint32_t pixel = 0;\n\n            switch (channel->pixel_type) {\n            case EXR_FLOAT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                ptr[2] = ptr[1] + td->xsize;\n                in     = ptr[2] + td->xsize;\n\n                for (j = 0; j < td->xsize; ++j) {\n                    uint32_t diff = ((unsigned)*(ptr[0]++) << 24) |\n                                    (*(ptr[1]++) << 16) |\n                                    (*(ptr[2]++) << 8);\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            case EXR_HALF:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                in     = ptr[1] + td->xsize;\n                for (j = 0; j < td->xsize; j++) {\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n                    pixel += diff;\n                    bytestream_put_le16(&out, pixel);\n                }\n                break;\n            case EXR_UINT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + s->xdelta;\n                ptr[2] = ptr[1] + s->xdelta;\n                ptr[3] = ptr[2] + s->xdelta;\n                in     = ptr[3] + s->xdelta;\n\n                for (j = 0; j < s->xdelta; ++j) {\n                    uint32_t diff = ((uint32_t)*(ptr[0]++) << 24) |\n                    (*(ptr[1]++) << 16) |\n                    (*(ptr[2]++) << 8 ) |\n                    (*(ptr[3]++));\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            default:\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n    return 0;\n}\n\nstatic void unpack_14(const uint8_t b[14], uint16_t s[16])\n{\n    unsigned short shift = (b[ 2] >> 2) & 15;\n    unsigned short bias = (0x20 << shift);\n    int i;\n\n    s[ 0] = (b[0] << 8) | b[1];\n\n    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3f) << shift) - bias;\n    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3f) << shift) - bias;\n    s[12] = s[ 8] +   ((b[ 4]                       & 0x3f) << shift) - bias;\n\n    s[ 1] = s[ 0] +   ((b[ 5] >> 2)                         << shift) - bias;\n    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3f) << shift) - bias;\n    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3f) << shift) - bias;\n    s[13] = s[12] +   ((b[ 7]                       & 0x3f) << shift) - bias;\n\n    s[ 2] = s[ 1] +   ((b[ 8] >> 2)                         << shift) - bias;\n    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3f) << shift) - bias;\n    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3f) << shift) - bias;\n    s[14] = s[13] +   ((b[10]                       & 0x3f) << shift) - bias;\n\n    s[ 3] = s[ 2] +   ((b[11] >> 2)                         << shift) - bias;\n    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3f) << shift) - bias;\n    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3f) << shift) - bias;\n    s[15] = s[14] +   ((b[13]                       & 0x3f) << shift) - bias;\n\n    for (i = 0; i < 16; ++i) {\n        if (s[i] & 0x8000)\n            s[i] &= 0x7fff;\n        else\n            s[i] = ~s[i];\n    }\n}\n\nstatic void unpack_3(const uint8_t b[3], uint16_t s[16])\n{\n    int i;\n\n    s[0] = (b[0] << 8) | b[1];\n\n    if (s[0] & 0x8000)\n        s[0] &= 0x7fff;\n    else\n        s[0] = ~s[0];\n\n    for (i = 1; i < 16; i++)\n        s[i] = s[0];\n}\n\n\nstatic int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td) {\n    const int8_t *sr = src;\n    int stay_to_uncompress = compressed_size;\n    int nb_b44_block_w, nb_b44_block_h;\n    int index_tl_x, index_tl_y, index_out, index_tmp;\n    uint16_t tmp_buffer[16]; /* B44 use 4x4 half float pixel */\n    int c, iY, iX, y, x;\n    int target_channel_offset = 0;\n\n    /* calc B44 block count */\n    nb_b44_block_w = td->xsize / 4;\n    if ((td->xsize % 4) != 0)\n        nb_b44_block_w++;\n\n    nb_b44_block_h = td->ysize / 4;\n    if ((td->ysize % 4) != 0)\n        nb_b44_block_h++;\n\n    for (c = 0; c < s->nb_channels; c++) {\n        if (s->channels[c].pixel_type == EXR_HALF) {/* B44 only compress half float data */\n            for (iY = 0; iY < nb_b44_block_h; iY++) {\n                for (iX = 0; iX < nb_b44_block_w; iX++) {/* For each B44 block */\n                    if (stay_to_uncompress < 3) {\n                        av_log(s, AV_LOG_ERROR, \"Not enough data for B44A block: %d\", stay_to_uncompress);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (src[compressed_size - stay_to_uncompress + 2] == 0xfc) { /* B44A block */\n                        unpack_3(sr, tmp_buffer);\n                        sr += 3;\n                        stay_to_uncompress -= 3;\n                    }  else {/* B44 Block */\n                        if (stay_to_uncompress < 14) {\n                            av_log(s, AV_LOG_ERROR, \"Not enough data for B44 block: %d\", stay_to_uncompress);\n                            return AVERROR_INVALIDDATA;\n                        }\n                        unpack_14(sr, tmp_buffer);\n                        sr += 14;\n                        stay_to_uncompress -= 14;\n                    }\n\n                    /* copy data to uncompress buffer (B44 block can exceed target resolution)*/\n                    index_tl_x = iX * 4;\n                    index_tl_y = iY * 4;\n\n                    for (y = index_tl_y; y < FFMIN(index_tl_y + 4, td->ysize); y++) {\n                        for (x = index_tl_x; x < FFMIN(index_tl_x + 4, td->xsize); x++) {\n                            index_out = target_channel_offset * td->xsize + y * td->channel_line_size + 2 * x;\n                            index_tmp = (y-index_tl_y) * 4 + (x-index_tl_x);\n                            td->uncompressed_data[index_out] = tmp_buffer[index_tmp] & 0xff;\n                            td->uncompressed_data[index_out + 1] = tmp_buffer[index_tmp] >> 8;\n                        }\n                    }\n                }\n            }\n            target_channel_offset += 2;\n        } else {/* Float or UINT 32 channel */\n            if (stay_to_uncompress < td->ysize * td->xsize * 4) {\n                av_log(s, AV_LOG_ERROR, \"Not enough data for uncompress channel: %d\", stay_to_uncompress);\n                return AVERROR_INVALIDDATA;\n            }\n\n            for (y = 0; y < td->ysize; y++) {\n                index_out = target_channel_offset * td->xsize + y * td->channel_line_size;\n                memcpy(&td->uncompressed_data[index_out], sr, td->xsize * 4);\n                sr += td->xsize * 4;\n            }\n            target_channel_offset += 4;\n\n            stay_to_uncompress -= td->ysize * td->xsize * 4;\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_block(AVCodecContext *avctx, void *tdata,\n                        int jobnr, int threadnr)\n{\n    EXRContext *s = avctx->priv_data;\n    AVFrame *const p = s->picture;\n    EXRThreadData *td = &s->thread_data[threadnr];\n    const uint8_t *channel_buffer[4] = { 0 };\n    const uint8_t *buf = s->buf;\n    uint64_t line_offset, uncompressed_size;\n    uint8_t *ptr;\n    uint32_t data_size;\n    int line, col = 0;\n    uint64_t tile_x, tile_y, tile_level_x, tile_level_y;\n    const uint8_t *src;\n    int step = s->desc->flags & AV_PIX_FMT_FLAG_FLOAT ? 4 : 2 * s->desc->nb_components;\n    int bxmin = 0, axmax = 0, window_xoffset = 0;\n    int window_xmin, window_xmax, window_ymin, window_ymax;\n    int data_xoffset, data_yoffset, data_window_offset, xsize, ysize;\n    int i, x, buf_size = s->buf_size;\n    int c, rgb_channel_count;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    int ret;\n\n    line_offset = AV_RL64(s->gb.buffer + jobnr * 8);\n\n    if (s->is_tile) {\n        if (buf_size < 20 || line_offset > buf_size - 20)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 20;\n\n        tile_x = AV_RL32(src - 20);\n        tile_y = AV_RL32(src - 16);\n        tile_level_x = AV_RL32(src - 12);\n        tile_level_y = AV_RL32(src - 8);\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 20)\n            return AVERROR_INVALIDDATA;\n\n        if (tile_level_x || tile_level_y) { /* tile level, is not the full res level */\n            avpriv_report_missing_feature(s->avctx, \"Subres tile before full res tile\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        line = s->ymin + s->tile_attr.ySize * tile_y;\n        col = s->tile_attr.xSize * tile_x;\n\n        if (line < s->ymin || line > s->ymax ||\n            s->xmin + col  < s->xmin ||  s->xmin + col  > s->xmax)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tile_y * s->tile_attr.ySize);\n        td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tile_x * s->tile_attr.xSize);\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n    } else {\n        if (buf_size < 8 || line_offset > buf_size - 8)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 8;\n        line = AV_RL32(src - 8);\n\n        if (line < s->ymin || line > s->ymax)\n            return AVERROR_INVALIDDATA;\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 8)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1); /* s->ydelta - line ?? */\n        td->xsize          = s->xdelta;\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n\n        if ((s->compression == EXR_RAW && (data_size != uncompressed_size ||\n                                           line_offset > buf_size - uncompressed_size)) ||\n            (s->compression != EXR_RAW && (data_size > uncompressed_size ||\n                                           line_offset > buf_size - data_size))) {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    window_xmin = FFMIN(avctx->width, FFMAX(0, s->xmin + col));\n    window_xmax = FFMIN(avctx->width, FFMAX(0, s->xmin + col + td->xsize));\n    window_ymin = FFMIN(avctx->height, FFMAX(0, line ));\n    window_ymax = FFMIN(avctx->height, FFMAX(0, line + td->ysize));\n    xsize = window_xmax - window_xmin;\n    ysize = window_ymax - window_ymin;\n\n    /* tile or scanline not visible skip decoding */\n    if (xsize <= 0 || ysize <= 0)\n        return 0;\n\n    /* is the first tile or is a scanline */\n    if(col == 0) {\n        window_xmin = 0;\n        /* pixels to add at the left of the display window */\n        window_xoffset = FFMAX(0, s->xmin);\n        /* bytes to add at the left of the display window */\n        bxmin = window_xoffset * step;\n    }\n\n    /* is the last tile or is a scanline */\n    if(col + td->xsize == s->xdelta) {\n        window_xmax = avctx->width;\n         /* bytes to add at the right of the display window */\n        axmax = FFMAX(0, (avctx->width - (s->xmax + 1))) * step;\n    }\n\n    if (data_size < uncompressed_size || s->is_tile) { /* td->tmp is use for tile reorganization */\n        av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size);\n        if (!td->tmp)\n            return AVERROR(ENOMEM);\n    }\n\n    if (data_size < uncompressed_size) {\n        av_fast_padded_malloc(&td->uncompressed_data,\n                              &td->uncompressed_size, uncompressed_size + 64);/* Force 64 padding for AVX2 reorder_pixels dst */\n\n        if (!td->uncompressed_data)\n            return AVERROR(ENOMEM);\n\n        ret = AVERROR_INVALIDDATA;\n        switch (s->compression) {\n        case EXR_ZIP1:\n        case EXR_ZIP16:\n            ret = zip_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PIZ:\n            ret = piz_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PXR24:\n            ret = pxr24_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_RLE:\n            ret = rle_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_B44:\n        case EXR_B44A:\n            ret = b44_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        }\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"decode_block() failed.\\n\");\n            return ret;\n        }\n        src = td->uncompressed_data;\n    }\n\n    /* offsets to crop data outside display window */\n    data_xoffset = FFABS(FFMIN(0, s->xmin + col)) * (s->pixel_type == EXR_HALF ? 2 : 4);\n    data_yoffset = FFABS(FFMIN(0, line));\n    data_window_offset = (data_yoffset * td->channel_line_size) + data_xoffset;\n\n    if (!s->is_luma) {\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[0]) + data_window_offset;\n        channel_buffer[1] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        channel_buffer[2] = src + (td->xsize * s->channel_offsets[2]) + data_window_offset;\n        rgb_channel_count = 3;\n    } else { /* put y data in the first channel_buffer */\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        rgb_channel_count = 1;\n    }\n     if (s->channel_offsets[3] >= 0)\n        channel_buffer[3] = src + (td->xsize * s->channel_offsets[3]) + data_window_offset;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n\n        /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n        int channel_count = s->channel_offsets[3] >= 0 ? 4 : rgb_channel_count;\n        if (s->is_luma) {\n            channel_buffer[1] = channel_buffer[0];\n            channel_buffer[2] = channel_buffer[0];\n        }\n\n        for (c = 0; c < channel_count; c++) {\n            int plane = s->desc->comp[c].plane;\n            ptr = p->data[plane] + window_ymin * p->linesize[plane] + (window_xmin * 4);\n\n            for (i = 0; i < ysize; i++, ptr += p->linesize[plane]) {\n                const uint8_t *src;\n                union av_intfloat32 *ptr_x;\n\n                src = channel_buffer[c];\n                ptr_x = (union av_intfloat32 *)ptr;\n\n                // Zero out the start if xmin is not 0\n                memset(ptr_x, 0, bxmin);\n                ptr_x += window_xoffset;\n\n                if (s->pixel_type == EXR_FLOAT) {\n                    // 32-bit\n                    union av_intfloat32 t;\n                    if (trc_func && c < 3) {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            t.f = trc_func(t.f);\n                            *ptr_x++ = t;\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            if (t.f > 0.0f && c < 3)  /* avoid negative values */\n                                t.f = powf(t.f, one_gamma);\n                            *ptr_x++ = t;\n                        }\n                    }\n                } else if (s->pixel_type == EXR_HALF) {\n                    // 16-bit\n                    if (c < 3 || !trc_func) {\n                        for (x = 0; x < xsize; x++) {\n                            *ptr_x++ = s->gamma_table[bytestream_get_le16(&src)];\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            *ptr_x++ = exr_half2float(bytestream_get_le16(&src));;\n                        }\n                    }\n                }\n\n                // Zero out the end if xmax+1 is not w\n                memset(ptr_x, 0, axmax);\n                channel_buffer[c] += td->channel_line_size;\n            }\n        }\n    } else {\n\n        av_assert1(s->pixel_type == EXR_UINT);\n        ptr = p->data[0] + window_ymin * p->linesize[0] + (window_xmin * s->desc->nb_components * 2);\n\n        for (i = 0; i < ysize; i++, ptr += p->linesize[0]) {\n\n            const uint8_t * a;\n            const uint8_t *rgb[3];\n            uint16_t *ptr_x;\n\n            for (c = 0; c < rgb_channel_count; c++) {\n                rgb[c] = channel_buffer[c];\n            }\n\n            if (channel_buffer[3])\n                a = channel_buffer[3];\n\n            ptr_x = (uint16_t *) ptr;\n\n            // Zero out the start if xmin is not 0\n            memset(ptr_x, 0, bxmin);\n            ptr_x += window_xoffset * s->desc->nb_components;\n\n            for (x = 0; x < xsize; x++) {\n                for (c = 0; c < rgb_channel_count; c++) {\n                    *ptr_x++ = bytestream_get_le32(&rgb[c]) >> 16;\n                }\n\n                if (channel_buffer[3])\n                    *ptr_x++ = bytestream_get_le32(&a) >> 16;\n            }\n\n            // Zero out the end if xmax+1 is not w\n            memset(ptr_x, 0, axmax);\n\n            channel_buffer[0] += td->channel_line_size;\n            channel_buffer[1] += td->channel_line_size;\n            channel_buffer[2] += td->channel_line_size;\n            if (channel_buffer[3])\n                channel_buffer[3] += td->channel_line_size;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Check if the variable name corresponds to its data type.\n *\n * @param s              the EXRContext\n * @param value_name     name of the variable to check\n * @param value_type     type of the variable to check\n * @param minimum_length minimum length of the variable data\n *\n * @return bytes to read containing variable data\n *         -1 if variable is not found\n *         0 if buffer ended prematurely\n */\nstatic int check_header_variable(EXRContext *s,\n                                 const char *value_name,\n                                 const char *value_type,\n                                 unsigned int minimum_length)\n{\n    int var_size = -1;\n\n    if (bytestream2_get_bytes_left(&s->gb) >= minimum_length &&\n        !strcmp(s->gb.buffer, value_name)) {\n        // found value_name, jump to value_type (null terminated strings)\n        s->gb.buffer += strlen(value_name) + 1;\n        if (!strcmp(s->gb.buffer, value_type)) {\n            s->gb.buffer += strlen(value_type) + 1;\n            var_size = bytestream2_get_le32(&s->gb);\n            // don't go read past boundaries\n            if (var_size > bytestream2_get_bytes_left(&s->gb))\n                var_size = 0;\n        } else {\n            // value_type not found, reset the buffer\n            s->gb.buffer -= strlen(value_name) + 1;\n            av_log(s->avctx, AV_LOG_WARNING,\n                   \"Unknown data type %s for header variable %s.\\n\",\n                   value_type, value_name);\n        }\n    }\n\n    return var_size;\n}\n\nstatic int decode_header(EXRContext *s, AVFrame *frame)\n{\n    AVDictionary *metadata = NULL;\n    int magic_number, version, i, flags, sar = 0;\n    int layer_match = 0;\n    int ret;\n    int dup_channels = 0;\n\n    s->current_channel_offset = 0;\n    s->xmin               = ~0;\n    s->xmax               = ~0;\n    s->ymin               = ~0;\n    s->ymax               = ~0;\n    s->xdelta             = ~0;\n    s->ydelta             = ~0;\n    s->channel_offsets[0] = -1;\n    s->channel_offsets[1] = -1;\n    s->channel_offsets[2] = -1;\n    s->channel_offsets[3] = -1;\n    s->pixel_type         = EXR_UNKNOWN;\n    s->compression        = EXR_UNKN;\n    s->nb_channels        = 0;\n    s->w                  = 0;\n    s->h                  = 0;\n    s->tile_attr.xSize    = -1;\n    s->tile_attr.ySize    = -1;\n    s->is_tile            = 0;\n    s->is_luma            = 0;\n\n    if (bytestream2_get_bytes_left(&s->gb) < 10) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    magic_number = bytestream2_get_le32(&s->gb);\n    if (magic_number != 20000630) {\n        /* As per documentation of OpenEXR, it is supposed to be\n         * int 20000630 little-endian */\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = bytestream2_get_byte(&s->gb);\n    if (version != 2) {\n        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    flags = bytestream2_get_le24(&s->gb);\n\n    if (flags & 0x02)\n        s->is_tile = 1;\n    if (flags & 0x08) {\n        avpriv_report_missing_feature(s->avctx, \"deep data\");\n        return AVERROR_PATCHWELCOME;\n    }\n    if (flags & 0x10) {\n        avpriv_report_missing_feature(s->avctx, \"multipart\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    // Parse the header\n    while (bytestream2_get_bytes_left(&s->gb) > 0 && *s->gb.buffer) {\n        int var_size;\n        if ((var_size = check_header_variable(s, \"channels\",\n                                              \"chlist\", 38)) >= 0) {\n            GetByteContext ch_gb;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            bytestream2_init(&ch_gb, s->gb.buffer, var_size);\n\n            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {\n                EXRChannel *channel;\n                enum ExrPixelType current_pixel_type;\n                int channel_index = -1;\n                int xsub, ysub;\n\n                if (strcmp(s->layer, \"\") != 0) {\n                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {\n                        layer_match = 1;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer);\n                        ch_gb.buffer += strlen(s->layer);\n                        if (*ch_gb.buffer == '.')\n                            ch_gb.buffer++;         /* skip dot if not given */\n                    } else {\n                        layer_match = 0;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer);\n                    }\n                } else {\n                    layer_match = 1;\n                }\n\n                if (layer_match) { /* only search channel if the layer match is valid */\n                    if (!av_strcasecmp(ch_gb.buffer, \"R\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"X\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"U\")) {\n                        channel_index = 0;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"G\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"V\")) {\n                        channel_index = 1;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"Y\")) {\n                        channel_index = 1;\n                        s->is_luma = 1;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"B\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"Z\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"W\")) {\n                        channel_index = 2;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"A\")) {\n                        channel_index = 3;\n                    } else {\n                        av_log(s->avctx, AV_LOG_WARNING,\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer);\n                    }\n                }\n\n                /* skip until you get a 0 */\n                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&\n                       bytestream2_get_byte(&ch_gb))\n                    continue;\n\n                if (bytestream2_get_bytes_left(&ch_gb) < 4) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n\n                current_pixel_type = bytestream2_get_le32(&ch_gb);\n                if (current_pixel_type >= EXR_UNKNOWN) {\n                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n                                                  current_pixel_type);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                bytestream2_skip(&ch_gb, 4);\n                xsub = bytestream2_get_le32(&ch_gb);\n                ysub = bytestream2_get_le32(&ch_gb);\n\n                if (xsub != 1 || ysub != 1) {\n                    avpriv_report_missing_feature(s->avctx,\n                                                  \"Subsampling %dx%d\",\n                                                  xsub, ysub);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                if (channel_index >= 0 && s->channel_offsets[channel_index] == -1) { /* channel has not been previously assigned */\n                    if (s->pixel_type != EXR_UNKNOWN &&\n                        s->pixel_type != current_pixel_type) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"RGB channels not of the same depth.\\n\");\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                    s->pixel_type                     = current_pixel_type;\n                    s->channel_offsets[channel_index] = s->current_channel_offset;\n                } else if (channel_index >= 0) {\n                    av_log(s->avctx, AV_LOG_WARNING,\n                            \"Multiple channels with index %d.\\n\", channel_index);\n                    if (++dup_channels > 10) {\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                }\n\n                s->channels = av_realloc(s->channels,\n                                         ++s->nb_channels * sizeof(EXRChannel));\n                if (!s->channels) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                channel             = &s->channels[s->nb_channels - 1];\n                channel->pixel_type = current_pixel_type;\n                channel->xsub       = xsub;\n                channel->ysub       = ysub;\n\n                if (current_pixel_type == EXR_HALF) {\n                    s->current_channel_offset += 2;\n                } else {/* Float or UINT32 */\n                    s->current_channel_offset += 4;\n                }\n            }\n\n            /* Check if all channels are set with an offset or if the channels\n             * are causing an overflow  */\n            if (!s->is_luma) {/* if we expected to have at least 3 channels */\n                if (FFMIN3(s->channel_offsets[0],\n                           s->channel_offsets[1],\n                           s->channel_offsets[2]) < 0) {\n                    if (s->channel_offsets[0] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");\n                    if (s->channel_offsets[1] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");\n                    if (s->channel_offsets[2] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n            }\n\n            // skip one last byte and update main gb\n            s->gb.buffer = ch_gb.buffer + 1;\n            continue;\n        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",\n                                                     31)) >= 0) {\n            int xmin, ymin, xmax, ymax;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            xmin   = bytestream2_get_le32(&s->gb);\n            ymin   = bytestream2_get_le32(&s->gb);\n            xmax   = bytestream2_get_le32(&s->gb);\n            ymax   = bytestream2_get_le32(&s->gb);\n\n            if (xmin > xmax || ymin > ymax ||\n                (unsigned)xmax - xmin >= INT_MAX ||\n                (unsigned)ymax - ymin >= INT_MAX) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            s->xmin = xmin;\n            s->xmax = xmax;\n            s->ymin = ymin;\n            s->ymax = ymax;\n            s->xdelta = (s->xmax - s->xmin) + 1;\n            s->ydelta = (s->ymax - s->ymin) + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"displayWindow\",\n                                                     \"box2i\", 34)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            bytestream2_skip(&s->gb, 8);\n            s->w = bytestream2_get_le32(&s->gb) + 1;\n            s->h = bytestream2_get_le32(&s->gb) + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"lineOrder\",\n                                                     \"lineOrder\", 25)) >= 0) {\n            int line_order;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            line_order = bytestream2_get_byte(&s->gb);\n            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);\n            if (line_order > 2) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",\n                                                     \"float\", 31)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            sar = bytestream2_get_le32(&s->gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"compression\",\n                                                     \"compression\", 29)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            if (s->compression == EXR_UNKN)\n                s->compression = bytestream2_get_byte(&s->gb);\n            else\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found more than one compression attribute.\\n\");\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"tiles\",\n                                                     \"tiledesc\", 22)) >= 0) {\n            char tileLevel;\n\n            if (!s->is_tile)\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");\n\n            s->tile_attr.xSize = bytestream2_get_le32(&s->gb);\n            s->tile_attr.ySize = bytestream2_get_le32(&s->gb);\n\n            tileLevel = bytestream2_get_byte(&s->gb);\n            s->tile_attr.level_mode = tileLevel & 0x0f;\n            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;\n\n            if (s->tile_attr.level_mode >= EXR_TILE_LEVEL_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n                                              s->tile_attr.level_mode);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            if (s->tile_attr.level_round >= EXR_TILE_ROUND_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n                                              s->tile_attr.level_round);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"writer\",\n                                                     \"string\", 1)) >= 0) {\n            uint8_t key[256] = { 0 };\n\n            bytestream2_get_buffer(&s->gb, key, FFMIN(sizeof(key) - 1, var_size));\n            av_dict_set(&metadata, \"writer\", key, 0);\n\n            continue;\n        }\n\n        // Check if there are enough bytes for a header\n        if (bytestream2_get_bytes_left(&s->gb) <= 9) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        // Process unknown variables\n        for (i = 0; i < 2; i++) // value_name and value_type\n            while (bytestream2_get_byte(&s->gb) != 0);\n\n        // Skip variable length\n        bytestream2_skip(&s->gb, bytestream2_get_le32(&s->gb));\n    }\n\n    ff_set_sar(s->avctx, av_d2q(av_int2float(sar), 255));\n\n    if (s->compression == EXR_UNKN) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (s->is_tile) {\n        if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    frame->metadata = metadata;\n\n    // aaand we are done\n    bytestream2_skip(&s->gb, 1);\n    return 0;\nfail:\n    av_dict_free(&metadata);\n    return ret;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   /* nb scanline or nb tile */\n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n        s->scan_lines_per_block = 32;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* Verify the xmin, xmax, ymin and ymax before setting the actual image size.\n     * It's possible for the data window can larger or outside the display window */\n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { /* scanline */\n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n    // check offset table and recreate it if need\n    if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(&s->gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            /* write offset of prev scanline in offset table */\n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            /* get len of next scanline */\n            bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);/* skip line number */\n            start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);\n        }\n        bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);\n    }\n\n    // save pointer we are going to use in decode_block\n    s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n    // Zero out the start if ymin is not 0\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    uint32_t i;\n    union av_intfloat32 t;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = NULL;\n\n    s->avctx              = avctx;\n\n    ff_exrdsp_init(&s->dsp);\n\n#if HAVE_BIGENDIAN\n    ff_bswapdsp_init(&s->bbdsp);\n#endif\n\n    trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    if (trc_func) {\n        for (i = 0; i < 65536; ++i) {\n            t = exr_half2float(i);\n            t.f = trc_func(t.f);\n            s->gamma_table[i] = t;\n        }\n    } else {\n        if (one_gamma > 0.9999f && one_gamma < 1.0001f) {\n            for (i = 0; i < 65536; ++i) {\n                s->gamma_table[i] = exr_half2float(i);\n            }\n        } else {\n            for (i = 0; i < 65536; ++i) {\n                t = exr_half2float(i);\n                /* If negative value we reuse half value */\n                if (t.f <= 0.0f) {\n                    s->gamma_table[i] = t;\n                } else {\n                    t.f = powf(t.f, one_gamma);\n                    s->gamma_table[i] = t;\n                }\n            }\n        }\n    }\n\n    // allocate thread data, used for non EXR_RAW compression types\n    s->thread_data = av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData));\n    if (!s->thread_data)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    int i;\n    for (i = 0; i < avctx->thread_count; i++) {\n        EXRThreadData *td = &s->thread_data[i];\n        av_freep(&td->uncompressed_data);\n        av_freep(&td->tmp);\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n    }\n\n    av_freep(&s->thread_data);\n    av_freep(&s->channels);\n\n    return 0;\n}\n\n#define OFFSET(x) offsetof(EXRContext, x)\n#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption options[] = {\n    { \"layer\", \"Set the decoding layer\", OFFSET(layer),\n        AV_OPT_TYPE_STRING, { .str = \"\" }, 0, 0, VD },\n    { \"gamma\", \"Set the float gamma value when decoding\", OFFSET(gamma),\n        AV_OPT_TYPE_FLOAT, { .dbl = 1.0f }, 0.001, FLT_MAX, VD },\n\n    // XXX: Note the abuse of the enum using AVCOL_TRC_UNSPECIFIED to subsume the existing gamma option\n    { \"apply_trc\", \"color transfer characteristics to apply to EXR linear input\", OFFSET(apply_trc_type),\n        AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, AVCOL_TRC_NB-1, VD, \"apply_trc_type\"},\n    { \"bt709\",        \"BT.709\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT709 },        INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma\",        \"gamma\",            0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma22\",      \"BT.470 M\",         0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA22 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma28\",      \"BT.470 BG\",        0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA28 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte170m\",    \"SMPTE 170 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE170M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte240m\",    \"SMPTE 240 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE240M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"linear\",       \"Linear\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LINEAR },       INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log\",          \"Log\",              0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log_sqrt\",     \"Log square root\",  0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_4\", \"IEC 61966-2-4\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt1361\",       \"BT.1361\",          0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_1\", \"IEC 61966-2-1\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_10bit\", \"BT.2020 - 10 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_12bit\", \"BT.2020 - 12 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte2084\",    \"SMPTE ST 2084\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST2084 },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte428_1\",   \"SMPTE ST 428-1\",   0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST428_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n\n    { NULL },\n};\n\nstatic const AVClass exr_class = {\n    .class_name = \"EXR\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_exr_decoder = {\n    .name             = \"exr\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_EXR,\n    .priv_data_size   = sizeof(EXRContext),\n    .init             = decode_init,\n    .close            = decode_end,\n    .decode           = decode_frame,\n    .capabilities     = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |\n                        AV_CODEC_CAP_SLICE_THREADS,\n    .priv_class       = &exr_class,\n};\n"], "filenames": ["libavcodec/exr.c"], "buggy_code_start_loc": [1833], "buggy_code_end_loc": [1834], "fixing_code_start_loc": [1833], "fixing_code_end_loc": [1834], "type": "CWE-787", "message": "decode_frame in libavcodec/exr.c in FFmpeg 4.3.1 has an out-of-bounds write because of errors in calculations of when to perform memset zero operations.", "other": {"cve": {"id": "CVE-2020-35965", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-04T02:15:11.273", "lastModified": "2021-11-05T21:57:10.253", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "decode_frame in libavcodec/exr.c in FFmpeg 4.3.1 has an out-of-bounds write because of errors in calculations of when to perform memset zero operations."}, {"lang": "es", "value": "La funci\u00f3n decode_frame en la biblioteca libavcodec/exr.c en FFmpeg versi\u00f3n 4.3.1, presenta una escritura fuera de l\u00edmites debido a errores en los c\u00e1lculos de cu\u00e1ndo realiza operaciones memset zero."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.3.1", "versionEndExcluding": "4.4", "matchCriteriaId": "FD315272-E8F8-41A5-8E82-B0C498685B5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26532", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/3e5959b3457f7f1856d997261e6ac672bba49e8b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/b0a8b40294ea212c1938348ff112ef1b9bf16bb3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/01/msg00026.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202105-24", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4990", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3e5959b3457f7f1856d997261e6ac672bba49e8b"}}