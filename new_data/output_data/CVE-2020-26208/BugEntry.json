{"buggy_code": ["//--------------------------------------------------------------------------\r\n// Program to pull the information out of various types of EXIF digital \r\n// camera files and show it in a reasonably consistent way\r\n//\r\n// This module handles basic Jpeg file handling\r\n//\r\n// Matthias Wandel\r\n//--------------------------------------------------------------------------\r\n#include \"jhead.h\"\r\n\r\n// Storage for simplified info extracted from file.\r\nImageInfo_t ImageInfo;\r\n\r\n\r\nstatic Section_t * Sections = NULL;\r\nstatic int SectionsAllocated;\r\nstatic int SectionsRead;\r\nstatic int HaveAll;\r\n\r\n\r\n\r\n#define PSEUDO_IMAGE_MARKER 0x123; // Extra value.\r\n//--------------------------------------------------------------------------\r\n// Get 16 bits motorola order (always) for jpeg header stuff.\r\n//--------------------------------------------------------------------------\r\nstatic int Get16m(const void * Short)\r\n{\r\n    return (((uchar *)Short)[0] << 8) | ((uchar *)Short)[1];\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Process a COM marker.\r\n// We want to print out the marker contents as legible text;\r\n// we must guard against random junk and varying newline representations.\r\n//--------------------------------------------------------------------------\r\nstatic void process_COM (const uchar * Data, int length)\r\n{\r\n    int ch;\r\n    char Comment[MAX_COMMENT_SIZE+1];\r\n    int nch;\r\n    int a;\r\n\r\n    nch = 0;\r\n\r\n    if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE; // Truncate if it won't fit in our structure.\r\n\r\n    for (a=2;a<length;a++){\r\n        ch = Data[a];\r\n\r\n        if (ch == '\\r' && a < length-1 && Data[a+1] == '\\n') continue; // Remove cr followed by lf.\r\n\r\n        if (ch >= 32 || ch == '\\n' || ch == '\\t'){\r\n            Comment[nch++] = (char)ch;\r\n        }else{\r\n            Comment[nch++] = '?';\r\n        }\r\n    }\r\n\r\n    Comment[nch] = '\\0'; // Null terminate\r\n\r\n    if (ShowTags){\r\n        printf(\"COM marker comment: %s\\n\",Comment);\r\n    }\r\n\r\n    strcpy(ImageInfo.Comments,Comment);\r\n}\r\n\r\n \r\n//--------------------------------------------------------------------------\r\n// Process a SOFn marker.  This is useful for the image dimensions\r\n//--------------------------------------------------------------------------\r\nstatic void process_SOFn (const uchar * Data, int marker)\r\n{\r\n    int data_precision, num_components;\r\n\r\n    data_precision = Data[2];\r\n    ImageInfo.Height = Get16m(Data+3);\r\n    ImageInfo.Width = Get16m(Data+5);\r\n    num_components = Data[7];\r\n\r\n    if (num_components == 3){\r\n        ImageInfo.IsColor = 1;\r\n    }else{\r\n        ImageInfo.IsColor = 0;\r\n    }\r\n\r\n    ImageInfo.Process = marker;\r\n\r\n    if (ShowTags){\r\n        printf(\"JPEG image is %uw * %uh, %d color components, %d bits per sample\\n\",\r\n                   ImageInfo.Width, ImageInfo.Height, num_components, data_precision);\r\n    }\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Check sections array to see if it needs to be increased in size.\r\n//--------------------------------------------------------------------------\r\nstatic void CheckSectionsAllocated(void)\r\n{\r\n    if (SectionsRead > SectionsAllocated){\r\n        ErrFatal(\"allocation screwup\");\r\n    }\r\n    if (SectionsRead >= SectionsAllocated){\r\n        SectionsAllocated += SectionsAllocated/2;\r\n        Sections = (Section_t *)realloc(Sections, sizeof(Section_t)*SectionsAllocated);\r\n        if (Sections == NULL){\r\n            ErrFatal(\"could not allocate data for entire image\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Parse the marker stream until SOS or EOI is seen;\r\n//--------------------------------------------------------------------------\r\nint ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\r\n{\r\n    int a;\r\n    int HaveCom = FALSE;\r\n\r\n    a = fgetc(infile);\r\n\r\n    if (a != 0xff || fgetc(infile) != M_SOI){\r\n        return FALSE;\r\n    }\r\n\r\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\r\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\r\n\r\n    for(;;){\r\n        int itemlen;\r\n        int prev;\r\n        int marker = 0;\r\n        int ll,lh, got;\r\n        uchar * Data;\r\n\r\n        CheckSectionsAllocated();\r\n\r\n        prev = 0;\r\n        for (a=0;;a++){\r\n            marker = fgetc(infile);\r\n            if (marker != 0xff && prev == 0xff) break;\r\n            if (marker == EOF){\r\n                ErrFatal(\"Unexpected end of file\");\r\n            }\r\n            prev = marker;\r\n        }\r\n\r\n        if (a > 10){\r\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\r\n        }\r\n\r\n        Sections[SectionsRead].Type = marker;\r\n  \r\n        // Read the length of the section.\r\n        lh = fgetc(infile);\r\n        ll = fgetc(infile);\r\n        if (lh == EOF || ll == EOF){\r\n            ErrFatal(\"Unexpected end of file\");\r\n        }\r\n\r\n        itemlen = (lh << 8) | ll;\r\n\r\n        if (itemlen < 2){\r\n            ErrFatal(\"invalid marker\");\r\n        }\r\n\r\n        Sections[SectionsRead].Size = itemlen;\r\n\r\n        Data = (uchar *)malloc(itemlen);\r\n        if (Data == NULL){\r\n            ErrFatal(\"Could not allocate memory\");\r\n        }\r\n        Sections[SectionsRead].Data = Data;\r\n\r\n        // Store first two pre-read bytes.\r\n        Data[0] = (uchar)lh;\r\n        Data[1] = (uchar)ll;\r\n\r\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\r\n        if (got != itemlen-2){\r\n            ErrFatal(\"Premature end of file?\");\r\n        }\r\n        SectionsRead += 1;\r\n\r\n        switch(marker){\r\n\r\n            case M_SOS:   // stop before hitting compressed data \r\n                // If reading entire image is requested, read the rest of the data.\r\n                if (ReadMode & READ_IMAGE){\r\n                    int cp, ep, size;\r\n                    // Determine how much file is left.\r\n                    cp = ftell(infile);\r\n                    fseek(infile, 0, SEEK_END);\r\n                    ep = ftell(infile);\r\n                    fseek(infile, cp, SEEK_SET);\r\n\r\n                    size = ep-cp;\r\n                    Data = (uchar *)malloc(size);\r\n                    if (Data == NULL){\r\n                        ErrFatal(\"could not allocate data for entire image\");\r\n                    }\r\n\r\n                    got = fread(Data, 1, size, infile);\r\n                    if (got != size){\r\n                        ErrFatal(\"could not read the rest of the image\");\r\n                    }\r\n\r\n                    CheckSectionsAllocated();\r\n                    Sections[SectionsRead].Data = Data;\r\n                    Sections[SectionsRead].Size = size;\r\n                    Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;\r\n                    SectionsRead ++;\r\n                    HaveAll = 1;\r\n                }\r\n                return TRUE;\r\n\r\n            case M_DQT:\r\n                // Use for jpeg quality guessing\r\n                process_DQT(Data, itemlen);\r\n                break;\r\n\r\n            case M_DHT:   \r\n                // Use for jpeg quality guessing\r\n                process_DHT(Data, itemlen);\r\n                break;\r\n\r\n\r\n            case M_EOI:   // in case it's a tables-only JPEG stream\r\n                fprintf(stderr,\"No image in jpeg!\\n\");\r\n                return FALSE;\r\n\r\n            case M_COM: // Comment section\r\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\r\n                    // Discard this section.\r\n                    free(Sections[--SectionsRead].Data);\r\n                }else{\r\n                    process_COM(Data, itemlen);\r\n                    HaveCom = TRUE;\r\n                }\r\n                break;\r\n\r\n            case M_JFIF:\r\n                // Regular jpegs always have this tag, exif images have the exif\r\n                // marker instead, althogh ACDsee will write images with both markers.\r\n                // this program will re-create this marker on absence of exif marker.\r\n                // hence no need to keep the copy from the file.\r\n                if (itemlen < 16){\r\n                    fprintf(stderr,\"Jfif header too short\\n\");\r\n                    goto ignore;\r\n                }\r\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\r\n                    fprintf(stderr,\"Header missing JFIF marker\\n\");\r\n                }\r\n\r\n                ImageInfo.JfifHeader.Present = TRUE;\r\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\r\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\r\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\r\n                if (ShowTags){\r\n                    printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);\r\n                    switch(ImageInfo.JfifHeader.ResolutionUnits){\r\n                        case 0: printf(\"(aspect ratio)\"); break;\r\n                        case 1: printf(\"(dots per inch)\"); break;\r\n                        case 2: printf(\"(dots per cm)\"); break;\r\n                        default: printf(\"(unknown)\"); break;\r\n                    }\r\n                    printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);\r\n\r\n                    if (Data[14] || Data[15]){\r\n                        fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");\r\n                    }\r\n                }\r\n\r\n                ignore:\r\n\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_EXIF:\r\n                // There can be different section using the same marker.\r\n                if (ReadMode & READ_METADATA){\r\n                    if (memcmp(Data+2, \"Exif\", 4) == 0){\r\n                        process_EXIF(Data, itemlen);\r\n                        break;\r\n                    }else if (memcmp(Data+2, \"http:\", 5) == 0){\r\n                        Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes.\r\n                        if (ShowTags){\r\n                            printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);\r\n                            if (ShowTags){\r\n                                ShowXmp(Sections[SectionsRead-1]);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // Oterwise, discard this section.\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_IPTC:\r\n                if (ReadMode & READ_METADATA){\r\n                    if (ShowTags){\r\n                        printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);\r\n                    }\r\n                    // Note: We just store the IPTC section.  Its relatively straightforward\r\n                    // and we don't act on any part of it, so just display it at parse time.\r\n                }else{\r\n                    free(Sections[--SectionsRead].Data);\r\n                }\r\n                break;\r\n           \r\n            case M_SOF0: \r\n            case M_SOF1: \r\n            case M_SOF2: \r\n            case M_SOF3: \r\n            case M_SOF5: \r\n            case M_SOF6: \r\n            case M_SOF7: \r\n            case M_SOF9: \r\n            case M_SOF10:\r\n            case M_SOF11:\r\n            case M_SOF13:\r\n            case M_SOF14:\r\n            case M_SOF15:\r\n                if (itemlen < 8){\r\n                    fprintf(stderr,\"Section too short\\n\");\r\n                    break;\r\n                }\r\n                process_SOFn(Data, marker);\r\n                break;\r\n            default:\r\n                // Skip any other sections.\r\n                if (ShowTags){\r\n                    printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Discard read data.\r\n//--------------------------------------------------------------------------\r\nvoid DiscardData(void)\r\n{\r\n    int a;\r\n\r\n    for (a=0;a<SectionsRead;a++){\r\n        free(Sections[a].Data);\r\n    }\r\n\r\n    memset(&ImageInfo, 0, sizeof(ImageInfo));\r\n    SectionsRead = 0;\r\n    HaveAll = 0;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Read image data.\r\n//--------------------------------------------------------------------------\r\nint ReadJpegFile(const char * FileName, ReadMode_t ReadMode)\r\n{\r\n    FILE * infile;\r\n    int ret;\r\n\r\n    infile = fopen(FileName, \"rb\"); // Unix ignores 'b', windows needs it.\r\n\r\n    if (infile == NULL) {\r\n        fprintf(stderr, \"can't open '%s'\\n\", FileName);\r\n        return FALSE;\r\n    }\r\n\r\n\r\n    // Scan the JPEG headers.\r\n    ret = ReadJpegSections(infile, ReadMode);\r\n    if (!ret){\r\n        if (ReadMode == READ_ANY){\r\n            // Process any files mode.  Ignore the fact that it's not\r\n            // a jpeg file.\r\n            ret = TRUE;\r\n        }else{\r\n            fprintf(stderr,\"Not JPEG: %s\\n\",FileName);\r\n        }\r\n    }\r\n\r\n    fclose(infile);\r\n\r\n    if (ret == FALSE){\r\n        DiscardData();\r\n    }\r\n    return ret;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Replace or remove exif thumbnail\r\n//--------------------------------------------------------------------------\r\nint SaveThumbnail(char * ThumbFileName)\r\n{\r\n    FILE * ThumbnailFile;\r\n\r\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailSize == 0){\r\n        fprintf(stderr,\"Image contains no thumbnail\\n\");\r\n        return FALSE;\r\n    }\r\n\r\n    if (strcmp(ThumbFileName, \"-\") == 0){\r\n        // A filename of '-' indicates thumbnail goes to stdout.\r\n        // This doesn't make much sense under Windows, so this feature is unix only.\r\n        ThumbnailFile = stdout;\r\n    }else{\r\n        ThumbnailFile = fopen(ThumbFileName,\"wb\");\r\n    }\r\n\r\n    if (ThumbnailFile){\r\n        uchar * ThumbnailPointer;\r\n        Section_t * ExifSection;\r\n        ExifSection = FindSection(M_EXIF);\r\n        ThumbnailPointer = ExifSection->Data+ImageInfo.ThumbnailOffset+8;\r\n\r\n        fwrite(ThumbnailPointer, ImageInfo.ThumbnailSize ,1, ThumbnailFile);\r\n        fclose(ThumbnailFile);\r\n        return TRUE;\r\n    }else{\r\n        ErrFatal(\"Could not write thumbnail file\");\r\n        return FALSE;\r\n    }\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Replace or remove exif thumbnail\r\n//--------------------------------------------------------------------------\r\nint ReplaceThumbnail(const char * ThumbFileName)\r\n{\r\n    FILE * ThumbnailFile;\r\n    int ThumbLen, NewExifSize;\r\n    Section_t * ExifSection;\r\n    uchar * ThumbnailPointer;\r\n\r\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\r\n        if (ThumbFileName == NULL){\r\n            // Delete of nonexistent thumbnail (not even pointers present)\r\n            // No action, no error.\r\n            return FALSE;\r\n        }\r\n\r\n        // Adding or removing of thumbnail is not possible - that would require rearranging\r\n        // of the exif header, which is risky, and jhad doesn't know how to do.\r\n        fprintf(stderr,\"Image contains no thumbnail to replace - add is not possible\\n\");\r\n        return FALSE;\r\n    }\r\n\r\n    if (ThumbFileName){\r\n        ThumbnailFile = fopen(ThumbFileName,\"rb\");\r\n\r\n        if (ThumbnailFile == NULL){\r\n            noread:\r\n            ErrFatal(\"Could not read thumbnail file\");\r\n            return FALSE;\r\n        }\r\n\r\n        // get length\r\n        fseek(ThumbnailFile, 0, SEEK_END);\r\n\r\n        ThumbLen = ftell(ThumbnailFile);\r\n        fseek(ThumbnailFile, 0, SEEK_SET);\r\n\r\n        if (ThumbLen + ImageInfo.ThumbnailOffset > 0x10000-20){\r\n            ErrFatal(\"Thumbnail is too large to insert into exif header\");\r\n        }\r\n    }else{\r\n        if (ImageInfo.ThumbnailSize == 0){\r\n             return FALSE;\r\n        }\r\n\r\n        ThumbLen = 0;\r\r\n        ThumbnailFile = NULL;\r\n    }\r\n\r\n    ExifSection = FindSection(M_EXIF);\r\n\r\n    NewExifSize = ImageInfo.ThumbnailOffset+8+ThumbLen;\r\n    ExifSection->Data = (uchar *)realloc(ExifSection->Data, NewExifSize);\r\n\r\n    ThumbnailPointer = ExifSection->Data+ImageInfo.ThumbnailOffset+8;\r\n\r\n    if (ThumbnailFile){\r\n        if (fread(ThumbnailPointer, 1, ThumbLen, ThumbnailFile) != ThumbLen){\r\n            goto noread;\r\n        }\r\n        fclose(ThumbnailFile);\r\n    }\r\n\r\n    ImageInfo.ThumbnailSize = ThumbLen;\r\n\r\n    Put32u(ExifSection->Data+ImageInfo.ThumbnailSizeOffset+8, ThumbLen);\r\n\r\n    ExifSection->Data[0] = (uchar)(NewExifSize >> 8);\r\n    ExifSection->Data[1] = (uchar)NewExifSize;\r\n    ExifSection->Size = NewExifSize;\r\n\r\n    return TRUE;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Discard everything but the exif and comment sections.\r\n//--------------------------------------------------------------------------\r\nvoid DiscardAllButExif(void)\r\n{\r\n    Section_t ExifKeeper;\r\n    Section_t CommentKeeper;\r\n    Section_t IptcKeeper;\r\n    Section_t XmpKeeper;\r\n    int a;\r\n\r\n    memset(&ExifKeeper, 0, sizeof(ExifKeeper));\r\n    memset(&CommentKeeper, 0, sizeof(CommentKeeper));\r\n    memset(&IptcKeeper, 0, sizeof(IptcKeeper));\r\n    memset(&XmpKeeper, 0, sizeof(IptcKeeper));\r\n\r\n    for (a=0;a<SectionsRead;a++){\r\n        if (Sections[a].Type == M_EXIF && ExifKeeper.Type == 0){\r\n           ExifKeeper = Sections[a];\r\n        }else if (Sections[a].Type == M_XMP && XmpKeeper.Type == 0){\r\n           XmpKeeper = Sections[a];\r\n        }else if (Sections[a].Type == M_COM && CommentKeeper.Type == 0){\r\n            CommentKeeper = Sections[a];\r\n        }else if (Sections[a].Type == M_IPTC && IptcKeeper.Type == 0){\r\n            IptcKeeper = Sections[a];\r\n        }else{\r\n            free(Sections[a].Data);\r\n        }\r\n    }\r\n    SectionsRead = 0;\r\n    if (ExifKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = ExifKeeper;\r\n    }\r\n    if (CommentKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = CommentKeeper;\r\n    }\r\n    if (IptcKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = IptcKeeper;\r\n    }\r\n\r\n    if (XmpKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = XmpKeeper;\r\n    }\r\n}    \r\n\r\n//--------------------------------------------------------------------------\r\n// Write image data back to disk.\r\n//--------------------------------------------------------------------------\r\nvoid WriteJpegFile(const char * FileName)\r\n{\r\n    FILE * outfile;\r\n    int a;\r\n\r\n    if (!HaveAll){\r\n        ErrFatal(\"Can't write back - didn't read all\");\r\n    }\r\n\r\n    outfile = fopen(FileName,\"wb\");\r\n    if (outfile == NULL){\r\n        ErrFatal(\"Could not open file for write\");\r\n    }\r\n\r\n    // Initial static jpeg marker.\r\n    fputc(0xff,outfile);\r\n    fputc(0xd8,outfile);\r\n    \r\n    if (Sections[0].Type != M_EXIF && Sections[0].Type != M_JFIF){\r\n        // The image must start with an exif or jfif marker.  If we threw those away, create one.\r\n        static uchar JfifHead[18] = {\r\n            0xff, M_JFIF,\r\n            0x00, 0x10, 'J' , 'F' , 'I' , 'F' , 0x00, 0x01, \r\n            0x01, 0x01, 0x01, 0x2C, 0x01, 0x2C, 0x00, 0x00 \r\n        };\r\n\r\n        if (ImageInfo.ResolutionUnit == 2 || ImageInfo.ResolutionUnit == 3){\r\n            // Use the exif resolution info to fill out the jfif header.\r\n            // Usually, for exif images, there's no jfif header, so if wediscard\r\n            // the exif header, use info from the exif header for the jfif header.\r\n            \r\n            ImageInfo.JfifHeader.ResolutionUnits = (char)(ImageInfo.ResolutionUnit-1);\r\n            // Jfif is 1 and 2, Exif is 2 and 3 for In and cm respecively\r\n            ImageInfo.JfifHeader.XDensity = (int)ImageInfo.xResolution;\r\n            ImageInfo.JfifHeader.YDensity = (int)ImageInfo.yResolution;\r\n        }\r\n\r\n        JfifHead[11] = ImageInfo.JfifHeader.ResolutionUnits;\r\n        JfifHead[12] = (uchar)(ImageInfo.JfifHeader.XDensity >> 8);\r\n        JfifHead[13] = (uchar)ImageInfo.JfifHeader.XDensity;\r\n        JfifHead[14] = (uchar)(ImageInfo.JfifHeader.YDensity >> 8);\r\n        JfifHead[15] = (uchar)ImageInfo.JfifHeader.YDensity;\r\n        \r\n\r\n        fwrite(JfifHead, 18, 1, outfile);\r\n\r\n        // use the values from the exif data for the jfif header, if we have found values\r\n        if (ImageInfo.ResolutionUnit != 0) { \r\n            // JFIF.ResolutionUnit is {1,2}, EXIF.ResolutionUnit is {2,3}\r\n            JfifHead[11] = (uchar)ImageInfo.ResolutionUnit - 1; \r\n        }\r\n        if (ImageInfo.xResolution > 0.0 && ImageInfo.yResolution > 0.0) { \r\n            JfifHead[12] = (uchar)((int)ImageInfo.xResolution>>8);\r\n            JfifHead[13] = (uchar)((int)ImageInfo.xResolution);\r\n\r\n            JfifHead[14] = (uchar)((int)ImageInfo.yResolution>>8);\r\n            JfifHead[15] = (uchar)((int)ImageInfo.yResolution);\r\n        }\r\n    }\r\n\r\n\r\n    // Write all the misc sections\r\n    for (a=0;a<SectionsRead-1;a++){\r\n        fputc(0xff,outfile);\r\n        fputc((unsigned char)Sections[a].Type, outfile);\r\n        fwrite(Sections[a].Data, Sections[a].Size, 1, outfile);\r\n    }\r\n\r\n    // Write the remaining image data.\r\n    fwrite(Sections[a].Data, Sections[a].Size, 1, outfile);\r\n       \r\n    fclose(outfile);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Check if image has exif header.\r\n//--------------------------------------------------------------------------\r\nSection_t * FindSection(int SectionType)\r\n{\r\n    int a;\r\n\r\n    for (a=0;a<SectionsRead;a++){\r\n        if (Sections[a].Type == SectionType){\r\n            return &Sections[a];\r\n        }\r\n    }\r\n    // Could not be found.\r\n    return NULL;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Remove a certain type of section.\r\n//--------------------------------------------------------------------------\r\nint RemoveSectionType(int SectionType)\r\n{\r\n    int a;\r\n    int retval = FALSE;\r\n    for (a=0;a<SectionsRead-1;a++){\r\n        if (Sections[a].Type == SectionType){\r\n            // Free up this section\r\n            free (Sections[a].Data);\r\n            // Move succeding sections back by one to close space in array.\r\n            memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));\r\n            SectionsRead -= 1;\r\n            a -= 1;\r\n            retval = TRUE;\r\n        }\r\n    }\r\n    return retval;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Remove sectons not part of image and not exif or comment sections.\r\n//--------------------------------------------------------------------------\r\nint RemoveUnknownSections(void)\r\n{\r\n    int a;\r\n    int Modified = FALSE;\r\n    for (a=0;a<SectionsRead-1;){\r\n        switch(Sections[a].Type){\r\n            case  M_SOF0:\r\n            case  M_SOF1:\r\n            case  M_SOF2:\r\n            case  M_SOF3:\r\n            case  M_SOF5:\r\n            case  M_SOF6:\r\n            case  M_SOF7:\r\n            case  M_SOF9:\r\n            case  M_SOF10:\r\n            case  M_SOF11:\r\n            case  M_SOF13:\r\n            case  M_SOF14:\r\n            case  M_SOF15:\r\n            case  M_SOI:\r\n            case  M_EOI:\r\n            case  M_SOS:\r\n            case  M_JFIF:\r\n            case  M_EXIF:\r\n            case  M_XMP:\r\n            case  M_COM:\r\n            case  M_DQT:\r\n            case  M_DHT:\r\n            case  M_DRI:\r\n            case  M_IPTC:\r\n                // keep.\r\n                a++;\r\n                break;\r\n            default:\r\n                // Unknown.  Delete.\r\n                free (Sections[a].Data);\r\n                // Move succeding sections back by one to close space in array.\r\n                memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));\r\n                SectionsRead -= 1;\r\n                Modified = TRUE;\r\n        }\r\n    }\r\n    return Modified;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Add a section (assume it doesn't already exist) - used for \r\n// adding comment sections and exif sections\r\n//--------------------------------------------------------------------------\r\nSection_t * CreateSection(int SectionType, unsigned char * Data, int Size)\r\n{\r\n    Section_t * NewSection;\r\n    int a;\r\n    int NewIndex;\r\n\r\n    NewIndex = 0; // Figure out where to put the comment section.\r\n    if (SectionType == M_EXIF){\r\n        // Exif alwas goes first!\r\n    }else{\r\n        for (;NewIndex < 3;NewIndex++){ // Maximum fourth position (just for the heck of it)\r\n            if (Sections[NewIndex].Type == M_JFIF) continue; // Put it after Jfif\r\n            if (Sections[NewIndex].Type == M_EXIF) continue; // Put it after Exif\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (SectionsRead < NewIndex){\r\n        ErrFatal(\"Too few sections!\");\r\n    }\r\n\r\n    CheckSectionsAllocated();\r\n    for (a=SectionsRead;a>NewIndex;a--){\r\n        Sections[a] = Sections[a-1];          \r\n    }\r\n    SectionsRead += 1;\r\n\r\n    NewSection = Sections+NewIndex;\r\n\r\n    NewSection->Type = SectionType;\r\n    NewSection->Size = Size;\r\n    NewSection->Data = Data;\r\n\r\n    return NewSection;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Initialisation.\r\n//--------------------------------------------------------------------------\r\nvoid ResetJpgfile(void)\r\n{\r\n    if (Sections == NULL){\r\n        Sections = (Section_t *)malloc(sizeof(Section_t)*5);\r\n        SectionsAllocated = 5;\r\n    }\r\n\r\n    SectionsRead = 0;\r\n    HaveAll = 0;\r\n}\r\n"], "fixing_code": ["//--------------------------------------------------------------------------\r\n// Program to pull the information out of various types of EXIF digital \r\n// camera files and show it in a reasonably consistent way\r\n//\r\n// This module handles basic Jpeg file handling\r\n//\r\n// Matthias Wandel\r\n//--------------------------------------------------------------------------\r\n#include \"jhead.h\"\r\n\r\n// Storage for simplified info extracted from file.\r\nImageInfo_t ImageInfo;\r\n\r\n\r\nstatic Section_t * Sections = NULL;\r\nstatic int SectionsAllocated;\r\nstatic int SectionsRead;\r\nstatic int HaveAll;\r\n\r\n\r\n\r\n#define PSEUDO_IMAGE_MARKER 0x123; // Extra value.\r\n//--------------------------------------------------------------------------\r\n// Get 16 bits motorola order (always) for jpeg header stuff.\r\n//--------------------------------------------------------------------------\r\nstatic int Get16m(const void * Short)\r\n{\r\n    return (((uchar *)Short)[0] << 8) | ((uchar *)Short)[1];\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Process a COM marker.\r\n// We want to print out the marker contents as legible text;\r\n// we must guard against random junk and varying newline representations.\r\n//--------------------------------------------------------------------------\r\nstatic void process_COM (const uchar * Data, int length)\r\n{\r\n    int ch;\r\n    char Comment[MAX_COMMENT_SIZE+1];\r\n    int nch;\r\n    int a;\r\n\r\n    nch = 0;\r\n\r\n    if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE; // Truncate if it won't fit in our structure.\r\n\r\n    for (a=2;a<length;a++){\r\n        ch = Data[a];\r\n\r\n        if (ch == '\\r' && a < length-1 && Data[a+1] == '\\n') continue; // Remove cr followed by lf.\r\n\r\n        if (ch >= 32 || ch == '\\n' || ch == '\\t'){\r\n            Comment[nch++] = (char)ch;\r\n        }else{\r\n            Comment[nch++] = '?';\r\n        }\r\n    }\r\n\r\n    Comment[nch] = '\\0'; // Null terminate\r\n\r\n    if (ShowTags){\r\n        printf(\"COM marker comment: %s\\n\",Comment);\r\n    }\r\n\r\n    strcpy(ImageInfo.Comments,Comment);\r\n}\r\n\r\n \r\n//--------------------------------------------------------------------------\r\n// Process a SOFn marker.  This is useful for the image dimensions\r\n//--------------------------------------------------------------------------\r\nstatic void process_SOFn (const uchar * Data, int marker)\r\n{\r\n    int data_precision, num_components;\r\n\r\n    data_precision = Data[2];\r\n    ImageInfo.Height = Get16m(Data+3);\r\n    ImageInfo.Width = Get16m(Data+5);\r\n    num_components = Data[7];\r\n\r\n    if (num_components == 3){\r\n        ImageInfo.IsColor = 1;\r\n    }else{\r\n        ImageInfo.IsColor = 0;\r\n    }\r\n\r\n    ImageInfo.Process = marker;\r\n\r\n    if (ShowTags){\r\n        printf(\"JPEG image is %uw * %uh, %d color components, %d bits per sample\\n\",\r\n                   ImageInfo.Width, ImageInfo.Height, num_components, data_precision);\r\n    }\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Check sections array to see if it needs to be increased in size.\r\n//--------------------------------------------------------------------------\r\nstatic void CheckSectionsAllocated(void)\r\n{\r\n    if (SectionsRead > SectionsAllocated){\r\n        ErrFatal(\"allocation screwup\");\r\n    }\r\n    if (SectionsRead >= SectionsAllocated){\r\n        SectionsAllocated += SectionsAllocated/2;\r\n        Sections = (Section_t *)realloc(Sections, sizeof(Section_t)*SectionsAllocated);\r\n        if (Sections == NULL){\r\n            ErrFatal(\"could not allocate data for entire image\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Parse the marker stream until SOS or EOI is seen;\r\n//--------------------------------------------------------------------------\r\nint ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\r\n{\r\n    int a;\r\n    int HaveCom = FALSE;\r\n\r\n    a = fgetc(infile);\r\n\r\n    if (a != 0xff || fgetc(infile) != M_SOI){\r\n        return FALSE;\r\n    }\r\n\r\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\r\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\r\n\r\n    for(;;){\r\n        int itemlen;\r\n        int prev;\r\n        int marker = 0;\r\n        int ll,lh, got;\r\n        uchar * Data;\r\n\r\n        CheckSectionsAllocated();\r\n\r\n        prev = 0;\r\n        for (a=0;;a++){\r\n            marker = fgetc(infile);\r\n            if (marker != 0xff && prev == 0xff) break;\r\n            if (marker == EOF){\r\n                ErrFatal(\"Unexpected end of file\");\r\n            }\r\n            prev = marker;\r\n        }\r\n\r\n        if (a > 10){\r\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\r\n        }\r\n\r\n        Sections[SectionsRead].Type = marker;\r\n  \r\n        // Read the length of the section.\r\n        lh = fgetc(infile);\r\n        ll = fgetc(infile);\r\n        if (lh == EOF || ll == EOF){\r\n            ErrFatal(\"Unexpected end of file\");\r\n        }\r\n\r\n        itemlen = (lh << 8) | ll;\r\n\r\n        if (itemlen < 2){\r\n            ErrFatal(\"invalid marker\");\r\n        }\r\n\r\n        Sections[SectionsRead].Size = itemlen;\r\n\r\n        // Allocate an extra 20 bytes more than needed, because sometimes when reading structures,\r\n        // if the section erroneously ends before short structures that should be there, that can trip\r\n        // memory checkers in combination with fuzzers.\r\n        Data = (uchar *)malloc(itemlen+20);\r\n        if (Data == NULL){\r\n            ErrFatal(\"Could not allocate memory\");\r\n        }\r\n        Sections[SectionsRead].Data = Data;\r\n\r\n        // Store first two pre-read bytes.\r\n        Data[0] = (uchar)lh;\r\n        Data[1] = (uchar)ll;\r\n\r\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\r\n        if (got != itemlen-2){\r\n            ErrFatal(\"Premature end of file?\");\r\n        }\r\n        SectionsRead += 1;\r\n\r\n        switch(marker){\r\n\r\n            case M_SOS:   // stop before hitting compressed data \r\n                // If reading entire image is requested, read the rest of the data.\r\n                if (ReadMode & READ_IMAGE){\r\n                    int cp, ep, size;\r\n                    // Determine how much file is left.\r\n                    cp = ftell(infile);\r\n                    fseek(infile, 0, SEEK_END);\r\n                    ep = ftell(infile);\r\n                    fseek(infile, cp, SEEK_SET);\r\n\r\n                    size = ep-cp;\r\n                    Data = (uchar *)malloc(size);\r\n                    if (Data == NULL){\r\n                        ErrFatal(\"could not allocate data for entire image\");\r\n                    }\r\n\r\n                    got = fread(Data, 1, size, infile);\r\n                    if (got != size){\r\n                        ErrFatal(\"could not read the rest of the image\");\r\n                    }\r\n\r\n                    CheckSectionsAllocated();\r\n                    Sections[SectionsRead].Data = Data;\r\n                    Sections[SectionsRead].Size = size;\r\n                    Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;\r\n                    SectionsRead ++;\r\n                    HaveAll = 1;\r\n                }\r\n                return TRUE;\r\n\r\n            case M_DQT:\r\n                // Use for jpeg quality guessing\r\n                process_DQT(Data, itemlen);\r\n                break;\r\n\r\n            case M_DHT:   \r\n                // Use for jpeg quality guessing\r\n                process_DHT(Data, itemlen);\r\n                break;\r\n\r\n\r\n            case M_EOI:   // in case it's a tables-only JPEG stream\r\n                fprintf(stderr,\"No image in jpeg!\\n\");\r\n                return FALSE;\r\n\r\n            case M_COM: // Comment section\r\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\r\n                    // Discard this section.\r\n                    free(Sections[--SectionsRead].Data);\r\n                }else{\r\n                    process_COM(Data, itemlen);\r\n                    HaveCom = TRUE;\r\n                }\r\n                break;\r\n\r\n            case M_JFIF:\r\n                // Regular jpegs always have this tag, exif images have the exif\r\n                // marker instead, althogh ACDsee will write images with both markers.\r\n                // this program will re-create this marker on absence of exif marker.\r\n                // hence no need to keep the copy from the file.\r\n                if (itemlen < 16){\r\n                    fprintf(stderr,\"Jfif header too short\\n\");\r\n                    goto ignore;\r\n                }\r\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\r\n                    fprintf(stderr,\"Header missing JFIF marker\\n\");\r\n                }\r\n\r\n                ImageInfo.JfifHeader.Present = TRUE;\r\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\r\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\r\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\r\n                if (ShowTags){\r\n                    printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);\r\n                    switch(ImageInfo.JfifHeader.ResolutionUnits){\r\n                        case 0: printf(\"(aspect ratio)\"); break;\r\n                        case 1: printf(\"(dots per inch)\"); break;\r\n                        case 2: printf(\"(dots per cm)\"); break;\r\n                        default: printf(\"(unknown)\"); break;\r\n                    }\r\n                    printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);\r\n\r\n                    if (Data[14] || Data[15]){\r\n                        fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");\r\n                    }\r\n                }\r\n\r\n                ignore:\r\n\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_EXIF:\r\n                // There can be different section using the same marker.\r\n                if (ReadMode & READ_METADATA){\r\n                    if (memcmp(Data+2, \"Exif\", 4) == 0){\r\n                        process_EXIF(Data, itemlen);\r\n                        break;\r\n                    }else if (memcmp(Data+2, \"http:\", 5) == 0){\r\n                        Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes.\r\n                        if (ShowTags){\r\n                            printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);\r\n                            if (ShowTags){\r\n                                ShowXmp(Sections[SectionsRead-1]);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // Oterwise, discard this section.\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_IPTC:\r\n                if (ReadMode & READ_METADATA){\r\n                    if (ShowTags){\r\n                        printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);\r\n                    }\r\n                    // Note: We just store the IPTC section.  Its relatively straightforward\r\n                    // and we don't act on any part of it, so just display it at parse time.\r\n                }else{\r\n                    free(Sections[--SectionsRead].Data);\r\n                }\r\n                break;\r\n           \r\n            case M_SOF0: \r\n            case M_SOF1: \r\n            case M_SOF2: \r\n            case M_SOF3: \r\n            case M_SOF5: \r\n            case M_SOF6: \r\n            case M_SOF7: \r\n            case M_SOF9: \r\n            case M_SOF10:\r\n            case M_SOF11:\r\n            case M_SOF13:\r\n            case M_SOF14:\r\n            case M_SOF15:\r\n                if (itemlen < 8){\r\n                    fprintf(stderr,\"Section too short\\n\");\r\n                    break;\r\n                }\r\n                process_SOFn(Data, marker);\r\n                break;\r\n            default:\r\n                // Skip any other sections.\r\n                if (ShowTags){\r\n                    printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Discard read data.\r\n//--------------------------------------------------------------------------\r\nvoid DiscardData(void)\r\n{\r\n    int a;\r\n\r\n    for (a=0;a<SectionsRead;a++){\r\n        free(Sections[a].Data);\r\n    }\r\n\r\n    memset(&ImageInfo, 0, sizeof(ImageInfo));\r\n    SectionsRead = 0;\r\n    HaveAll = 0;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Read image data.\r\n//--------------------------------------------------------------------------\r\nint ReadJpegFile(const char * FileName, ReadMode_t ReadMode)\r\n{\r\n    FILE * infile;\r\n    int ret;\r\n\r\n    infile = fopen(FileName, \"rb\"); // Unix ignores 'b', windows needs it.\r\n\r\n    if (infile == NULL) {\r\n        fprintf(stderr, \"can't open '%s'\\n\", FileName);\r\n        return FALSE;\r\n    }\r\n\r\n\r\n    // Scan the JPEG headers.\r\n    ret = ReadJpegSections(infile, ReadMode);\r\n    if (!ret){\r\n        if (ReadMode == READ_ANY){\r\n            // Process any files mode.  Ignore the fact that it's not\r\n            // a jpeg file.\r\n            ret = TRUE;\r\n        }else{\r\n            fprintf(stderr,\"Not JPEG: %s\\n\",FileName);\r\n        }\r\n    }\r\n\r\n    fclose(infile);\r\n\r\n    if (ret == FALSE){\r\n        DiscardData();\r\n    }\r\n    return ret;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Replace or remove exif thumbnail\r\n//--------------------------------------------------------------------------\r\nint SaveThumbnail(char * ThumbFileName)\r\n{\r\n    FILE * ThumbnailFile;\r\n\r\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailSize == 0){\r\n        fprintf(stderr,\"Image contains no thumbnail\\n\");\r\n        return FALSE;\r\n    }\r\n\r\n    if (strcmp(ThumbFileName, \"-\") == 0){\r\n        // A filename of '-' indicates thumbnail goes to stdout.\r\n        // This doesn't make much sense under Windows, so this feature is unix only.\r\n        ThumbnailFile = stdout;\r\n    }else{\r\n        ThumbnailFile = fopen(ThumbFileName,\"wb\");\r\n    }\r\n\r\n    if (ThumbnailFile){\r\n        uchar * ThumbnailPointer;\r\n        Section_t * ExifSection;\r\n        ExifSection = FindSection(M_EXIF);\r\n        ThumbnailPointer = ExifSection->Data+ImageInfo.ThumbnailOffset+8;\r\n\r\n        fwrite(ThumbnailPointer, ImageInfo.ThumbnailSize ,1, ThumbnailFile);\r\n        fclose(ThumbnailFile);\r\n        return TRUE;\r\n    }else{\r\n        ErrFatal(\"Could not write thumbnail file\");\r\n        return FALSE;\r\n    }\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Replace or remove exif thumbnail\r\n//--------------------------------------------------------------------------\r\nint ReplaceThumbnail(const char * ThumbFileName)\r\n{\r\n    FILE * ThumbnailFile;\r\n    int ThumbLen, NewExifSize;\r\n    Section_t * ExifSection;\r\n    uchar * ThumbnailPointer;\r\n\r\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\r\n        if (ThumbFileName == NULL){\r\n            // Delete of nonexistent thumbnail (not even pointers present)\r\n            // No action, no error.\r\n            return FALSE;\r\n        }\r\n\r\n        // Adding or removing of thumbnail is not possible - that would require rearranging\r\n        // of the exif header, which is risky, and jhad doesn't know how to do.\r\n        fprintf(stderr,\"Image contains no thumbnail to replace - add is not possible\\n\");\r\n        return FALSE;\r\n    }\r\n\r\n    if (ThumbFileName){\r\n        ThumbnailFile = fopen(ThumbFileName,\"rb\");\r\n\r\n        if (ThumbnailFile == NULL){\r\n            noread:\r\n            ErrFatal(\"Could not read thumbnail file\");\r\n            return FALSE;\r\n        }\r\n\r\n        // get length\r\n        fseek(ThumbnailFile, 0, SEEK_END);\r\n\r\n        ThumbLen = ftell(ThumbnailFile);\r\n        fseek(ThumbnailFile, 0, SEEK_SET);\r\n\r\n        if (ThumbLen + ImageInfo.ThumbnailOffset > 0x10000-20){\r\n            ErrFatal(\"Thumbnail is too large to insert into exif header\");\r\n        }\r\n    }else{\r\n        if (ImageInfo.ThumbnailSize == 0){\r\n             return FALSE;\r\n        }\r\n\r\n        ThumbLen = 0;\r\r\r\n        ThumbnailFile = NULL;\r\n    }\r\n\r\n    ExifSection = FindSection(M_EXIF);\r\n\r\n    NewExifSize = ImageInfo.ThumbnailOffset+8+ThumbLen;\r\n    ExifSection->Data = (uchar *)realloc(ExifSection->Data, NewExifSize);\r\n\r\n    ThumbnailPointer = ExifSection->Data+ImageInfo.ThumbnailOffset+8;\r\n\r\n    if (ThumbnailFile){\r\n        if (fread(ThumbnailPointer, 1, ThumbLen, ThumbnailFile) != ThumbLen){\r\n            goto noread;\r\n        }\r\n        fclose(ThumbnailFile);\r\n    }\r\n\r\n    ImageInfo.ThumbnailSize = ThumbLen;\r\n\r\n    Put32u(ExifSection->Data+ImageInfo.ThumbnailSizeOffset+8, ThumbLen);\r\n\r\n    ExifSection->Data[0] = (uchar)(NewExifSize >> 8);\r\n    ExifSection->Data[1] = (uchar)NewExifSize;\r\n    ExifSection->Size = NewExifSize;\r\n\r\n    return TRUE;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Discard everything but the exif and comment sections.\r\n//--------------------------------------------------------------------------\r\nvoid DiscardAllButExif(void)\r\n{\r\n    Section_t ExifKeeper;\r\n    Section_t CommentKeeper;\r\n    Section_t IptcKeeper;\r\n    Section_t XmpKeeper;\r\n    int a;\r\n\r\n    memset(&ExifKeeper, 0, sizeof(ExifKeeper));\r\n    memset(&CommentKeeper, 0, sizeof(CommentKeeper));\r\n    memset(&IptcKeeper, 0, sizeof(IptcKeeper));\r\n    memset(&XmpKeeper, 0, sizeof(IptcKeeper));\r\n\r\n    for (a=0;a<SectionsRead;a++){\r\n        if (Sections[a].Type == M_EXIF && ExifKeeper.Type == 0){\r\n           ExifKeeper = Sections[a];\r\n        }else if (Sections[a].Type == M_XMP && XmpKeeper.Type == 0){\r\n           XmpKeeper = Sections[a];\r\n        }else if (Sections[a].Type == M_COM && CommentKeeper.Type == 0){\r\n            CommentKeeper = Sections[a];\r\n        }else if (Sections[a].Type == M_IPTC && IptcKeeper.Type == 0){\r\n            IptcKeeper = Sections[a];\r\n        }else{\r\n            free(Sections[a].Data);\r\n        }\r\n    }\r\n    SectionsRead = 0;\r\n    if (ExifKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = ExifKeeper;\r\n    }\r\n    if (CommentKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = CommentKeeper;\r\n    }\r\n    if (IptcKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = IptcKeeper;\r\n    }\r\n\r\n    if (XmpKeeper.Type){\r\n        CheckSectionsAllocated();\r\n        Sections[SectionsRead++] = XmpKeeper;\r\n    }\r\n}    \r\n\r\n//--------------------------------------------------------------------------\r\n// Write image data back to disk.\r\n//--------------------------------------------------------------------------\r\nvoid WriteJpegFile(const char * FileName)\r\n{\r\n    FILE * outfile;\r\n    int a;\r\n\r\n    if (!HaveAll){\r\n        ErrFatal(\"Can't write back - didn't read all\");\r\n    }\r\n\r\n    outfile = fopen(FileName,\"wb\");\r\n    if (outfile == NULL){\r\n        ErrFatal(\"Could not open file for write\");\r\n    }\r\n\r\n    // Initial static jpeg marker.\r\n    fputc(0xff,outfile);\r\n    fputc(0xd8,outfile);\r\n    \r\n    if (Sections[0].Type != M_EXIF && Sections[0].Type != M_JFIF){\r\n        // The image must start with an exif or jfif marker.  If we threw those away, create one.\r\n        static uchar JfifHead[18] = {\r\n            0xff, M_JFIF,\r\n            0x00, 0x10, 'J' , 'F' , 'I' , 'F' , 0x00, 0x01, \r\n            0x01, 0x01, 0x01, 0x2C, 0x01, 0x2C, 0x00, 0x00 \r\n        };\r\n\r\n        if (ImageInfo.ResolutionUnit == 2 || ImageInfo.ResolutionUnit == 3){\r\n            // Use the exif resolution info to fill out the jfif header.\r\n            // Usually, for exif images, there's no jfif header, so if wediscard\r\n            // the exif header, use info from the exif header for the jfif header.\r\n            \r\n            ImageInfo.JfifHeader.ResolutionUnits = (char)(ImageInfo.ResolutionUnit-1);\r\n            // Jfif is 1 and 2, Exif is 2 and 3 for In and cm respecively\r\n            ImageInfo.JfifHeader.XDensity = (int)ImageInfo.xResolution;\r\n            ImageInfo.JfifHeader.YDensity = (int)ImageInfo.yResolution;\r\n        }\r\n\r\n        JfifHead[11] = ImageInfo.JfifHeader.ResolutionUnits;\r\n        JfifHead[12] = (uchar)(ImageInfo.JfifHeader.XDensity >> 8);\r\n        JfifHead[13] = (uchar)ImageInfo.JfifHeader.XDensity;\r\n        JfifHead[14] = (uchar)(ImageInfo.JfifHeader.YDensity >> 8);\r\n        JfifHead[15] = (uchar)ImageInfo.JfifHeader.YDensity;\r\n        \r\n\r\n        fwrite(JfifHead, 18, 1, outfile);\r\n\r\n        // use the values from the exif data for the jfif header, if we have found values\r\n        if (ImageInfo.ResolutionUnit != 0) { \r\n            // JFIF.ResolutionUnit is {1,2}, EXIF.ResolutionUnit is {2,3}\r\n            JfifHead[11] = (uchar)ImageInfo.ResolutionUnit - 1; \r\n        }\r\n        if (ImageInfo.xResolution > 0.0 && ImageInfo.yResolution > 0.0) { \r\n            JfifHead[12] = (uchar)((int)ImageInfo.xResolution>>8);\r\n            JfifHead[13] = (uchar)((int)ImageInfo.xResolution);\r\n\r\n            JfifHead[14] = (uchar)((int)ImageInfo.yResolution>>8);\r\n            JfifHead[15] = (uchar)((int)ImageInfo.yResolution);\r\n        }\r\n    }\r\n\r\n\r\n    // Write all the misc sections\r\n    for (a=0;a<SectionsRead-1;a++){\r\n        fputc(0xff,outfile);\r\n        fputc((unsigned char)Sections[a].Type, outfile);\r\n        fwrite(Sections[a].Data, Sections[a].Size, 1, outfile);\r\n    }\r\n\r\n    // Write the remaining image data.\r\n    fwrite(Sections[a].Data, Sections[a].Size, 1, outfile);\r\n       \r\n    fclose(outfile);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Check if image has exif header.\r\n//--------------------------------------------------------------------------\r\nSection_t * FindSection(int SectionType)\r\n{\r\n    int a;\r\n\r\n    for (a=0;a<SectionsRead;a++){\r\n        if (Sections[a].Type == SectionType){\r\n            return &Sections[a];\r\n        }\r\n    }\r\n    // Could not be found.\r\n    return NULL;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Remove a certain type of section.\r\n//--------------------------------------------------------------------------\r\nint RemoveSectionType(int SectionType)\r\n{\r\n    int a;\r\n    int retval = FALSE;\r\n    for (a=0;a<SectionsRead-1;a++){\r\n        if (Sections[a].Type == SectionType){\r\n            // Free up this section\r\n            free (Sections[a].Data);\r\n            // Move succeding sections back by one to close space in array.\r\n            memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));\r\n            SectionsRead -= 1;\r\n            a -= 1;\r\n            retval = TRUE;\r\n        }\r\n    }\r\n    return retval;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Remove sectons not part of image and not exif or comment sections.\r\n//--------------------------------------------------------------------------\r\nint RemoveUnknownSections(void)\r\n{\r\n    int a;\r\n    int Modified = FALSE;\r\n    for (a=0;a<SectionsRead-1;){\r\n        switch(Sections[a].Type){\r\n            case  M_SOF0:\r\n            case  M_SOF1:\r\n            case  M_SOF2:\r\n            case  M_SOF3:\r\n            case  M_SOF5:\r\n            case  M_SOF6:\r\n            case  M_SOF7:\r\n            case  M_SOF9:\r\n            case  M_SOF10:\r\n            case  M_SOF11:\r\n            case  M_SOF13:\r\n            case  M_SOF14:\r\n            case  M_SOF15:\r\n            case  M_SOI:\r\n            case  M_EOI:\r\n            case  M_SOS:\r\n            case  M_JFIF:\r\n            case  M_EXIF:\r\n            case  M_XMP:\r\n            case  M_COM:\r\n            case  M_DQT:\r\n            case  M_DHT:\r\n            case  M_DRI:\r\n            case  M_IPTC:\r\n                // keep.\r\n                a++;\r\n                break;\r\n            default:\r\n                // Unknown.  Delete.\r\n                free (Sections[a].Data);\r\n                // Move succeding sections back by one to close space in array.\r\n                memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));\r\n                SectionsRead -= 1;\r\n                Modified = TRUE;\r\n        }\r\n    }\r\n    return Modified;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Add a section (assume it doesn't already exist) - used for \r\n// adding comment sections and exif sections\r\n//--------------------------------------------------------------------------\r\nSection_t * CreateSection(int SectionType, unsigned char * Data, int Size)\r\n{\r\n    Section_t * NewSection;\r\n    int a;\r\n    int NewIndex;\r\n\r\n    NewIndex = 0; // Figure out where to put the comment section.\r\n    if (SectionType == M_EXIF){\r\n        // Exif alwas goes first!\r\n    }else{\r\n        for (;NewIndex < 3;NewIndex++){ // Maximum fourth position (just for the heck of it)\r\n            if (Sections[NewIndex].Type == M_JFIF) continue; // Put it after Jfif\r\n            if (Sections[NewIndex].Type == M_EXIF) continue; // Put it after Exif\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (SectionsRead < NewIndex){\r\n        ErrFatal(\"Too few sections!\");\r\n    }\r\n\r\n    CheckSectionsAllocated();\r\n    for (a=SectionsRead;a>NewIndex;a--){\r\n        Sections[a] = Sections[a-1];          \r\n    }\r\n    SectionsRead += 1;\r\n\r\n    NewSection = Sections+NewIndex;\r\n\r\n    NewSection->Type = SectionType;\r\n    NewSection->Size = Size;\r\n    NewSection->Data = Data;\r\n\r\n    return NewSection;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Initialisation.\r\n//--------------------------------------------------------------------------\r\nvoid ResetJpgfile(void)\r\n{\r\n    if (Sections == NULL){\r\n        Sections = (Section_t *)malloc(sizeof(Section_t)*5);\r\n        SectionsAllocated = 5;\r\n    }\r\n\r\n    SectionsRead = 0;\r\n    HaveAll = 0;\r\n}\r\n"], "filenames": ["jpgfile.c"], "buggy_code_start_loc": [172], "buggy_code_end_loc": [479], "fixing_code_start_loc": [172], "fixing_code_end_loc": [484], "type": "CWE-787", "message": "JHEAD is a simple command line tool for displaying and some manipulation of EXIF header data embedded in Jpeg images from digital cameras. In affected versions there is a heap-buffer-overflow on jhead-3.04/jpgfile.c:285 ReadJpegSections. Crafted jpeg images can be provided to the user resulting in a program crash or potentially incorrect exif information retrieval. Users are advised to upgrade. There is no known workaround for this issue.", "other": {"cve": {"id": "CVE-2020-26208", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-02T12:15:07.783", "lastModified": "2022-02-07T15:54:51.910", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JHEAD is a simple command line tool for displaying and some manipulation of EXIF header data embedded in Jpeg images from digital cameras. In affected versions there is a heap-buffer-overflow on jhead-3.04/jpgfile.c:285 ReadJpegSections. Crafted jpeg images can be provided to the user resulting in a program crash or potentially incorrect exif information retrieval. Users are advised to upgrade. There is no known workaround for this issue."}, {"lang": "es", "value": "JHEAD es una sencilla herramienta de l\u00ednea de comandos para la visualizaci\u00f3n y determinada manipulaci\u00f3n de los datos de encabezados EXIF insertados en las im\u00e1genes Jpeg de las c\u00e1maras digitales. En las versiones afectadas se presenta un desbordamiento del b\u00fafer de la pila en jhead-3.04/jpgfile.c:285 ReadJpegSections. Las im\u00e1genes jpeg dise\u00f1adas pueden ser proporcionadas al usuario resultando en un bloqueo del programa o en la recuperaci\u00f3n de informaci\u00f3n exif potencialmente incorrecta. Se recomienda a usuarios actualizar. No es conocida alguna medida de mitigaci\u00f3n adicional para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jhead_project:jhead:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.04", "matchCriteriaId": "F4043AC5-DC93-4FE4-8675-6AB0B60A385C"}]}]}], "references": [{"url": "https://bugs.launchpad.net/ubuntu/+source/jhead/+bug/1900821", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/F-ZhaoYang/jhead/commit/5186ddcf9e35a7aa0ff0539489a930434a1325f4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/F-ZhaoYang/jhead/security/advisories/GHSA-7pr6-xq4f-qhgc", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/Matthias-Wandel/jhead/issues/7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/F-ZhaoYang/jhead/commit/5186ddcf9e35a7aa0ff0539489a930434a1325f4"}}