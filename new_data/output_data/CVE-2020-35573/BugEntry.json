{"buggy_code": ["/* This file is copied from the libsrs2 sources */\n/* Modified by Timo R\u00f6hling <timo.roehling@gmx.de> */\n\n/* Copyright (c) 2004 Shevek (srs@anarres.org)\n * All rights reserved.\n *\n * This file is a part of libsrs2 from http://www.libsrs2.org/\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, under the terms of either the GNU General Public\n * License version 2 or the BSD license, at the discretion of the\n * user. Copies of these licenses have been included in the libsrs2\n * distribution. See the the file called LICENSE for more\n * information.\n */\n\n#undef USE_OPENSSL\n\n#include <stdarg.h>\n#include <string.h>\t\t/* memcpy, strcpy, memset */\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n\n#ifdef USE_OPENSSL\n#include <openssl/hmac.h>\n#endif\n\n#include \"srs2.h\"\n\n\n#ifndef EVP_MAX_MD_SIZE\n#define EVP_MAX_MD_SIZE (16+20) /* The SSLv3 md5+sha1 type */\n#endif\n\n#ifndef HAVE_STRCASECMP\n# ifdef HAVE__STRICMP\n#  define strcasecmp _stricmp\n# endif\n#endif\n\n#ifndef HAVE_STRNCASECMP\n# ifdef HAVE__STRNICMP\n#  define strncasecmp _strnicmp\n# endif\n#endif\n\n\t/* Use this */\n#define STRINGP(s) ((s != NULL) && (*(s) != '\\0'))\n\nstatic const char *srs_separators = \"=-+\";\n\nstatic srs_malloc_t\t\tsrs_f_malloc\t= malloc;\nstatic srs_realloc_t\tsrs_f_realloc\t= realloc;\nstatic srs_free_t\t\tsrs_f_free\t\t= free;\n\nint\nsrs_set_malloc(srs_malloc_t m, srs_realloc_t r, srs_free_t f)\n{\n\tsrs_f_malloc = m;\n\tsrs_f_realloc = r;\n\tsrs_f_free = f;\n\treturn SRS_SUCCESS;\n}\n\nconst char *\nsrs_strerror(int code)\n{\n\tswitch (code) {\n\t\t/* Simple errors */\n\t\tcase SRS_SUCCESS:\n\t\t\treturn \"Success\";\n\t\tcase SRS_ENOTSRSADDRESS:\n\t\t\treturn \"Not an SRS address.\";\n\n\t\t/* Config errors */\n\t\tcase SRS_ENOSECRETS:\n\t\t\treturn \"No secrets in SRS configuration.\";\n\t\tcase SRS_ESEPARATORINVALID:\n\t\t\treturn \"Invalid separator suggested.\";\n\n\t\t/* Input errors */\n\t\tcase SRS_ENOSENDERATSIGN:\n\t\t\treturn \"No at sign in sender address\";\n\t\tcase SRS_EBUFTOOSMALL:\n\t\t\treturn \"Buffer too small.\";\n\n\t\t/* Syntax errors */\n\t\tcase SRS_ENOSRS0HOST:\n\t\t\treturn \"No host in SRS0 address.\";\n\t\tcase SRS_ENOSRS0USER:\n\t\t\treturn \"No user in SRS0 address.\";\n\t\tcase SRS_ENOSRS0HASH:\n\t\t\treturn \"No hash in SRS0 address.\";\n\t\tcase SRS_ENOSRS0STAMP:\n\t\t\treturn \"No timestamp in SRS0 address.\";\n\t\tcase SRS_ENOSRS1HOST:\n\t\t\treturn \"No host in SRS1 address.\";\n\t\tcase SRS_ENOSRS1USER:\n\t\t\treturn \"No user in SRS1 address.\";\n\t\tcase SRS_ENOSRS1HASH:\n\t\t\treturn \"No hash in SRS1 address.\";\n\t\tcase SRS_EBADTIMESTAMPCHAR:\n\t\t\treturn \"Bad base32 character in timestamp.\";\n\t\tcase SRS_EHASHTOOSHORT:\n\t\t\treturn \"Hash too short in SRS address.\";\n\n\t\t/* SRS errors */\n\t\tcase SRS_ETIMESTAMPOUTOFDATE:\n\t\t\treturn \"Time stamp out of date.\";\n\t\tcase SRS_EHASHINVALID:\n\t\t\treturn \"Hash invalid in SRS address.\";\n\n\t\tdefault:\n\t\t\treturn \"Unknown error in SRS library.\";\n\t}\n}\n\nsrs_t *\nsrs_new()\n{\n\tsrs_t\t*srs = (srs_t *)srs_f_malloc(sizeof(srs_t));\n\tsrs_init(srs);\n\treturn srs;\n}\n\nvoid\nsrs_init(srs_t *srs)\n{\n\tmemset(srs, 0, sizeof(srs_t));\n\tsrs->secrets = NULL;\n\tsrs->numsecrets = 0;\n\tsrs->separator = '=';\n\tsrs->maxage = 21;\n\tsrs->hashlength = 4;\n\tsrs->hashmin = srs->hashlength;\n\tsrs->alwaysrewrite = FALSE;\n}\n\nvoid\nsrs_free(srs_t *srs)\n{\n\tint\t i;\n\tfor (i = 0; i < srs->numsecrets; i++) {\n\t\tmemset(srs->secrets[i], 0, strlen(srs->secrets[i]));\n\t\tsrs_f_free(srs->secrets[i]);\n\t\tsrs->secrets[i] = 0;\n\t}\n\tsrs_f_free(srs);\n}\n\nint\nsrs_add_secret(srs_t *srs, const char *secret)\n{\n\tint\t\tnewlen = (srs->numsecrets + 1) * sizeof(char *);\n\tsrs->secrets = (char **)srs_f_realloc(srs->secrets, newlen);\n\tsrs->secrets[srs->numsecrets++] = strdup(secret);\n\treturn SRS_SUCCESS;\n}\n\nconst char *\nsrs_get_secret(srs_t *srs, int idx)\n{\n\tif (idx < srs->numsecrets)\n\t\treturn srs->secrets[idx];\n\treturn NULL;\n}\n\n#define SRS_PARAM_DEFINE(n, t) \\\n\tint srs_set_ ## n (srs_t *srs, t value) { \\\n\t\tsrs->n = value; \\\n\t\treturn SRS_SUCCESS; \\\n\t} \\\n\tt srs_get_ ## n (srs_t *srs) { \\\n\t\treturn srs->n; \\\n\t}\n\nint\nsrs_set_separator(srs_t *srs, char value)\n{\n\tif (strchr(srs_separators, value) == NULL)\n\t\treturn SRS_ESEPARATORINVALID;\n\tsrs->separator = value;\n\treturn SRS_SUCCESS;\n}\n\nchar\nsrs_get_separator(srs_t *srs)\n{\n\treturn srs->separator;\n}\n\nSRS_PARAM_DEFINE(maxage, int)\n\t/* XXX Check hashlength >= hashmin */\nSRS_PARAM_DEFINE(hashlength, int)\nSRS_PARAM_DEFINE(hashmin, int)\nSRS_PARAM_DEFINE(alwaysrewrite, srs_bool)\nSRS_PARAM_DEFINE(noforward, srs_bool)\nSRS_PARAM_DEFINE(noreverse, srs_bool)\n\n/* Don't mess with these unless you know what you're doing well\n * enough to rewrite the timestamp functions. These are based on\n * a 2 character timestamp. Changing these in the wild is probably\n * a bad idea. */\n#define SRS_TIME_PRECISION\t(60 * 60 * 24)\t/* One day */\n#define SRS_TIME_BASEBITS\t5\t\t/* 2^5 = 32 = strlen(CHARS) */\n/* This had better be a real variable since we do arithmethic\n * with it. */\nconst char *SRS_TIME_BASECHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n#define SRS_TIME_SIZE\t\t2\n#define SRS_TIME_SLOTS\t\t(1<<(SRS_TIME_BASEBITS<<(SRS_TIME_SIZE-1)))\n\nint\nsrs_timestamp_create(srs_t *srs __attribute__((unused)), char *buf, time_t now)\n{\n\tnow = now / SRS_TIME_PRECISION;\n\tbuf[1] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];\n\tnow = now >> SRS_TIME_BASEBITS;\n\tbuf[0] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];\n\tbuf[2] = '\\0';\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}\n\nconst char *SRS_HASH_BASECHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\t\t\t\t\t\t \"abcdefghijklmnopqrstuvwxyz\"\n\t\t\t\t\t\t\t\t \"0123456789+/\";\n\nstatic void\nsrs_hash_create_v(srs_t *srs, int idx, char *buf, int nargs, va_list ap)\n{\n#ifdef USE_OPENSSL\n\tHMAC_CTX\t\t ctx;\n\tint\t\t\t\t srshashlen;\n\tchar\t\t\t srshash[EVP_MAX_MD_SIZE + 1];\n#else\n\tsrs_hmac_ctx_t\t ctx;\n\tchar\t\t\t srshash[SHA_DIGESTSIZE + 1];\n#endif\n\tchar\t\t\t*secret;\n\tchar\t\t\t*data;\n\tint\t\t\t\t len;\n\tchar\t\t\t*lcdata;\n\tunsigned char\t*hp;\n\tchar\t\t\t*bp;\n\tint\t\t\t\t i;\n\tint\t\t\t\t j;\n\n\tsecret = srs->secrets[idx];\n\n#ifdef USE_OPENSSL\n\tHMAC_CTX_init(&ctx);\n\tHMAC_Init(&ctx, secret, strlen(secret), EVP_sha1());\n#else\n\tsrs_hmac_init(&ctx, secret, strlen(secret));\n#endif\n\n\tfor (i = 0; i < nargs; i++) {\n\t\tdata = va_arg(ap, char *);\n\t\tlen = strlen(data);\n\t\tlcdata = alloca(len + 1);\n\t\tfor (j = 0; j < len; j++) {\n\t\t\tif (isupper(data[j]))\n\t\t\t\tlcdata[j] = tolower(data[j]);\n\t\t\telse\n\t\t\t\tlcdata[j] = data[j];\n\t\t}\n#ifdef USE_OPENSSL\n\t\tHMAC_Update(&ctx, lcdata, len);\n#else\n\t\tsrs_hmac_update(&ctx, lcdata, len);\n#endif\n\t}\n\n#ifdef USE_OPENSSL\n\tHMAC_Final(&ctx, srshash, &srshashlen);\n\tHMAC_CTX_cleanup(&ctx);\n\tsrshash[EVP_MAX_MD_SIZE] = '\\0';\n#else\n\tsrs_hmac_fini(&ctx, srshash);\n\tsrshash[SHA_DIGESTSIZE] = '\\0';\n#endif\n\n\n\t/* A little base64 encoding. Just a little. */\n\thp = (unsigned char *)srshash;\n\tbp = buf;\n\tfor (i = 0; i < srs->hashlength; i++) {\n\t\tswitch (i & 0x03) {\n\t\t\tdefault:\t/* NOTREACHED */\n\t\t\tcase 0:\n\t\t\t\tj = (*hp >> 2);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tj = ((*hp & 0x03) << 4) |\n\t\t\t\t\t\t((*(hp + 1) & 0xF0) >> 4);\n\t\t\t\thp++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tj = ((*hp & 0x0F) << 2) |\n\t\t\t\t\t\t((*(hp + 1) & 0xC0) >> 6);\n\t\t\t\thp++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tj = (*hp++ & 0x3F);\n\t\t\t\tbreak;\n\t\t}\n\t\t*bp++ = SRS_HASH_BASECHARS[j];\n\t}\n\n\t*bp = '\\0';\n\tbuf[srs->hashlength] = '\\0';\n}\n\nint\nsrs_hash_create(srs_t *srs, char *buf, int nargs, ...)\n{\n\tva_list\t ap;\n\n\tif (srs->numsecrets == 0)\n\t\treturn SRS_ENOSECRETS;\n\tif (srs->secrets == NULL)\n\t\treturn SRS_ENOSECRETS;\n\tif (srs->secrets[0] == NULL)\n\t\treturn SRS_ENOSECRETS;\n\n\tva_start(ap, nargs);\n\tsrs_hash_create_v(srs, 0, buf, nargs, ap);\n\tva_end(ap);\n\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_hash_check(srs_t *srs, char *hash, int nargs, ...)\n{\n\tva_list\tap;\n\tchar\t*srshash;\n\tchar\t*tmp;\n\tint\t\t len;\n\tint\t\t i;\n\n\tlen = strlen(hash);\n\tif (len < srs->hashmin)\n\t\treturn SRS_EHASHTOOSHORT;\n\tif (len > srs->hashlength) {\n\t\ttmp = alloca(srs->hashlength + 1);\n\t\tstrncpy(tmp, hash, srs->hashlength);\n\t\ttmp[srs->hashlength] = '\\0';\n\t\thash = tmp;\n\t\tlen = srs->hashlength;\n\t}\n\n\tfor (i = 0; i < srs->numsecrets; i++) {\n\t\tva_start(ap, nargs);\n\t\tsrshash = alloca(srs->hashlength + 1);\n\t\tsrs_hash_create_v(srs, i, srshash, nargs, ap);\n\t\tva_end(ap);\n\t\tif (strncasecmp(hash, srshash, len) == 0)\n\t\t\treturn SRS_SUCCESS;\n\t}\n\n\treturn SRS_EHASHINVALID;\n}\n\nint\nsrs_compile_shortcut(srs_t *srs,\n\t\t\t\tchar *buf, int buflen,\n\t\t\t\tchar *sendhost, char *senduser,\n\t\t\t\tconst char *aliashost) {\n\tchar\t*srshash;\n\tchar\t srsstamp[SRS_TIME_SIZE + 1];\n\tint\t\t len;\n\tint\t\t ret;\n\n\t/* This never happens if we get called from guarded() */\n\tif ((strncasecmp(senduser, SRS0TAG, 4) == 0) &&\n\t\t(strchr(srs_separators, senduser[4]) != NULL)) {\n\t\tsendhost = senduser + 5;\n\t\tif (*sendhost == '\\0')\n\t\t\treturn SRS_ENOSRS0HOST;\n\t\tsenduser = strchr(sendhost, SRSSEP);\n\t\tif ((senduser == NULL) || (*senduser == '\\0'))\n\t\t\treturn SRS_ENOSRS0USER;\n\t}\n\n\tlen = strlen(SRS0TAG) + 1 +\n\t\tsrs->hashlength + 1 +\n\t\t\tSRS_TIME_SIZE + 1 +\n\t\t\t\tstrlen(sendhost) + 1 + strlen(senduser)\n\t\t\t+ 1 + strlen(aliashost);\n\tif (len >= buflen)\n\t\treturn SRS_EBUFTOOSMALL;\n\n\tret = srs_timestamp_create(srs, srsstamp, time(NULL));\n\tif (ret != SRS_SUCCESS)\n\t\treturn ret;\n\tsrshash = alloca(srs->hashlength + 1);\n\tret = srs_hash_create(srs, srshash,3, srsstamp, sendhost, senduser);\n\tif (ret != SRS_SUCCESS)\n\t\treturn ret;\n\n\tsprintf(buf, SRS0TAG \"%c%s%c%s%c%s%c%s@%s\", srs->separator,\n\t\t\t\t\tsrshash, SRSSEP, srsstamp, SRSSEP,\n\t\t\t\t\t\tsendhost, SRSSEP, senduser,\n\t\t\t\t\t\t\taliashost);\n\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_compile_guarded(srs_t *srs,\n\t\t\t\tchar *buf, int buflen,\n\t\t\t\tchar *sendhost, char *senduser,\n\t\t\t\tconst char *aliashost) {\n\tchar\t*srshost;\n\tchar\t*srsuser;\n\tchar\t*srshash;\n\tint\t\t len;\n\tint\t\t ret;\n\n\tif ((strncasecmp(senduser, SRS1TAG, 4) == 0) &&\n\t\t(strchr(srs_separators, senduser[4]) != NULL)) {\n\t\t/* Used as a temporary convenience var */\n\t\tsrshash = senduser + 5;\n\t\tif (*srshash == '\\0')\n\t\t\treturn SRS_ENOSRS1HASH;\n\t\t/* Used as a temporary convenience var */\n\t\tsrshost = strchr(srshash, SRSSEP);\n\t\tif (!STRINGP(srshost))\n\t\t\treturn SRS_ENOSRS1HOST;\n\t\t*srshost++ = '\\0';\n\t\tsrsuser = strchr(srshost, SRSSEP);\n\t\tif (!STRINGP(srsuser))\n\t\t\treturn SRS_ENOSRS1USER;\n\t\t*srsuser++ = '\\0';\n\t\tsrshash = alloca(srs->hashlength + 1);\n\t\tret = srs_hash_create(srs, srshash, 2, srshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tlen = strlen(SRS1TAG) + 1 +\n\t\t\tsrs->hashlength + 1 +\n\t\t\t\tstrlen(srshost) + 1 + strlen(srsuser)\n\t\t\t+ 1 + strlen(aliashost);\n\t\tif (len >= buflen)\n\t\t\treturn SRS_EBUFTOOSMALL;\n\t\tsprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator,\n\t\t\t\t\t\tsrshash, SRSSEP,\n\t\t\t\t\t\t\tsrshost, SRSSEP, srsuser,\n\t\t\t\t\t\t\t\taliashost);\n\t\treturn SRS_SUCCESS;\n\t}\n\telse if ((strncasecmp(senduser, SRS0TAG, 4) == 0) &&\n\t\t(strchr(srs_separators, senduser[4]) != NULL)) {\n\t\tsrsuser = senduser + 4;\n\t\tsrshost = sendhost;\n\t\tsrshash = alloca(srs->hashlength + 1);\n\t\tret = srs_hash_create(srs, srshash, 2, srshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tlen = strlen(SRS1TAG) + 1 +\n\t\t\tsrs->hashlength + 1 +\n\t\t\t\tstrlen(srshost) + 1 + strlen(srsuser)\n\t\t\t+ 1 + strlen(aliashost);\n\t\tif (len >= buflen)\n\t\t\treturn SRS_EBUFTOOSMALL;\n\t\tsprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator,\n\t\t\t\t\t\tsrshash, SRSSEP,\n\t\t\t\t\t\t\tsrshost, SRSSEP, srsuser,\n\t\t\t\t\t\t\t\taliashost);\n\t}\n\telse {\n\t\treturn srs_compile_shortcut(srs, buf, buflen,\n\t\t\t\t\t\tsendhost, senduser, aliashost);\n\t}\n\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_parse_shortcut(srs_t *srs, char *buf, unsigned buflen, char *senduser)\n{\n\tchar\t*srshash;\n\tchar\t*srsstamp;\n\tchar\t*srshost;\n\tchar\t*srsuser;\n\tint\t\t ret;\n\n\tif (strncasecmp(senduser, SRS0TAG, 4) == 0) {\n\t\tsrshash = senduser + 5;\n\t\tif (!STRINGP(srshash))\n\t\t\treturn SRS_ENOSRS0HASH;\n\t\tsrsstamp = strchr(srshash, SRSSEP);\n\t\tif (!STRINGP(srsstamp))\n\t\t\treturn SRS_ENOSRS0STAMP;\n\t\t*srsstamp++ = '\\0';\n\t\tsrshost = strchr(srsstamp, SRSSEP);\n\t\tif (!STRINGP(srshost))\n\t\t\treturn SRS_ENOSRS0HOST;\n\t\t*srshost++ = '\\0';\n\t\tsrsuser = strchr(srshost, SRSSEP);\n\t\tif (!STRINGP(srsuser))\n\t\t\treturn SRS_ENOSRS0USER;\n\t\t*srsuser++ = '\\0';\n\t\tret = srs_timestamp_check(srs, srsstamp);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tret = srs_hash_check(srs, srshash, 3, srsstamp,\n\t\t\t\t\t\tsrshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tsnprintf(buf, buflen, \"%s@%s\", srsuser, srshost);\n\t\treturn SRS_SUCCESS;\n\t}\n\n\treturn SRS_ENOTSRSADDRESS;\n}\n\nint\nsrs_parse_guarded(srs_t *srs, char *buf, int buflen, char *senduser)\n{\n\tchar\t*srshash;\n\tchar\t*srshost;\n\tchar\t*srsuser;\n\tint\t\t ret;\n\n\tif (strncasecmp(senduser, SRS1TAG, 4) == 0) {\n\t\tsrshash = senduser + 5;\n\t\tif (!STRINGP(srshash))\n\t\t\treturn SRS_ENOSRS1HASH;\n\t\tsrshost = strchr(srshash, SRSSEP);\n\t\tif (!STRINGP(srshost))\n\t\t\treturn SRS_ENOSRS1HOST;\n\t\t*srshost++ = '\\0';\n\t\tsrsuser = strchr(srshost, SRSSEP);\n\t\tif (!STRINGP(srsuser))\n\t\t\treturn SRS_ENOSRS1USER;\n\t\t*srsuser++ = '\\0';\n\t\tret = srs_hash_check(srs, srshash, 2, srshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tsprintf(buf, SRS0TAG \"%s@%s\", srsuser, srshost);\n\t\treturn SRS_SUCCESS;\n\t}\n\telse {\n\t\treturn srs_parse_shortcut(srs, buf, buflen, senduser);\n\t}\n}\n\nint\nsrs_forward(srs_t *srs, char *buf, unsigned buflen,\n\t\t\t\tconst char *sender, const char *alias)\n{\n\tchar\t*senduser;\n\tchar\t*sendhost;\n\tchar\t*tmp;\n\tunsigned\t\t len;\n\n\tif (srs->noforward)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\t/* This is allowed to be a plain domain */\n\twhile ((tmp = strchr(alias, '@')) != NULL)\n\t\talias = tmp + 1;\n\n\ttmp = strchr(sender, '@');\n\tif (tmp == NULL)\n\t\treturn SRS_ENOSENDERATSIGN;\n\tsendhost = tmp + 1;\n\n\tlen = strlen(sender);\n\n\tif (! srs->alwaysrewrite) {\n\t\tif (strcasecmp(sendhost, alias) == 0) {\n\t\t\tif (strlen(sender) >= buflen)\n\t\t\t\treturn SRS_EBUFTOOSMALL;\n\t\t\tstrcpy(buf, sender);\n\t\t\treturn SRS_SUCCESS;\n\t\t}\n\t}\n\n\t/* Reconstruct the whole show into our alloca() buffer. */\n\tsenduser = alloca(len + 1);\n\tstrcpy(senduser, sender);\n\ttmp = (senduser + (tmp - sender));\n\tsendhost = tmp + 1;\n\t*tmp = '\\0';\n\n\treturn srs_compile_guarded(srs, buf, buflen,\n\t\t\t\t\tsendhost, senduser, alias);\n}\n\nint\nsrs_forward_alloc(srs_t *srs, char **sptr,\n\t\t\t\tconst char *sender, const char *alias)\n{\n\tchar\t*buf;\n\tint\t\t slen;\n\tint\t\t alen;\n\tint\t\t len;\n\tint\t\t ret;\n\n\tif (srs->noforward)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\tslen = strlen(sender);\n\talen = strlen(alias);\n\n\t/* strlen(SRSxTAG) + strlen(\"====+@\") < 64 */\n\tlen = slen + alen + srs->hashlength + SRS_TIME_SIZE + 64;\n\tbuf = (char *)srs_f_malloc(len);\n\n\tret = srs_forward(srs, buf, len, sender, alias);\n\n\tif (ret == SRS_SUCCESS)\n\t\t*sptr = buf;\n\telse\n\t\tsrs_f_free(buf);\n\n\treturn ret;\n}\n\nint\nsrs_reverse(srs_t *srs, char *buf, unsigned buflen, const char *sender)\n{\n\tchar\t*senduser;\n\tchar\t*tmp;\n\tunsigned\t\t len;\n\n\tif (!SRS_IS_SRS_ADDRESS(sender))\n\t\treturn SRS_ENOTSRSADDRESS;\n\n\tif (srs->noreverse)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\tlen = strlen(sender);\n\tif (len >= buflen)\n\t\treturn SRS_EBUFTOOSMALL;\n\tsenduser = alloca(len + 1);\n\tstrcpy(senduser, sender);\n\n\t/* We don't really care about the host for reversal. */\n\ttmp = strchr(senduser, '@');\n\tif (tmp != NULL)\n\t\t*tmp = '\\0';\n\treturn srs_parse_guarded(srs, buf, buflen, senduser);\n}\n\nint\nsrs_reverse_alloc(srs_t *srs, char **sptr, const char *sender)\n{\n\tchar\t*buf;\n\tint\t\t len;\n\tint\t\t ret;\n\n\t*sptr = NULL;\n\n\tif (!SRS_IS_SRS_ADDRESS(sender))\n\t\treturn SRS_ENOTSRSADDRESS;\n\n\tif (srs->noreverse)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\tlen = strlen(sender) + 1;\n\tbuf = (char *)srs_f_malloc(len);\n\n\tret = srs_reverse(srs, buf, len, sender);\n\n\tif (ret == SRS_SUCCESS)\n\t\t*sptr = buf;\n\telse\n\t\tsrs_f_free(buf);\n\n\treturn ret;\n}\n"], "fixing_code": ["/* This file is copied from the libsrs2 sources */\n/* Modified by Timo R\u00f6hling <timo.roehling@gmx.de> */\n\n/* Copyright (c) 2004 Shevek (srs@anarres.org)\n * All rights reserved.\n *\n * This file is a part of libsrs2 from http://www.libsrs2.org/\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, under the terms of either the GNU General Public\n * License version 2 or the BSD license, at the discretion of the\n * user. Copies of these licenses have been included in the libsrs2\n * distribution. See the the file called LICENSE for more\n * information.\n */\n\n#undef USE_OPENSSL\n\n#include <stdarg.h>\n#include <string.h>\t\t/* memcpy, strcpy, memset */\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n\n#ifdef USE_OPENSSL\n#include <openssl/hmac.h>\n#endif\n\n#include \"srs2.h\"\n\n\n#ifndef EVP_MAX_MD_SIZE\n#define EVP_MAX_MD_SIZE (16+20) /* The SSLv3 md5+sha1 type */\n#endif\n\n#ifndef HAVE_STRCASECMP\n# ifdef HAVE__STRICMP\n#  define strcasecmp _stricmp\n# endif\n#endif\n\n#ifndef HAVE_STRNCASECMP\n# ifdef HAVE__STRNICMP\n#  define strncasecmp _strnicmp\n# endif\n#endif\n\n\t/* Use this */\n#define STRINGP(s) ((s != NULL) && (*(s) != '\\0'))\n\nstatic const char *srs_separators = \"=-+\";\n\nstatic srs_malloc_t\t\tsrs_f_malloc\t= malloc;\nstatic srs_realloc_t\tsrs_f_realloc\t= realloc;\nstatic srs_free_t\t\tsrs_f_free\t\t= free;\n\nint\nsrs_set_malloc(srs_malloc_t m, srs_realloc_t r, srs_free_t f)\n{\n\tsrs_f_malloc = m;\n\tsrs_f_realloc = r;\n\tsrs_f_free = f;\n\treturn SRS_SUCCESS;\n}\n\nconst char *\nsrs_strerror(int code)\n{\n\tswitch (code) {\n\t\t/* Simple errors */\n\t\tcase SRS_SUCCESS:\n\t\t\treturn \"Success\";\n\t\tcase SRS_ENOTSRSADDRESS:\n\t\t\treturn \"Not an SRS address.\";\n\n\t\t/* Config errors */\n\t\tcase SRS_ENOSECRETS:\n\t\t\treturn \"No secrets in SRS configuration.\";\n\t\tcase SRS_ESEPARATORINVALID:\n\t\t\treturn \"Invalid separator suggested.\";\n\n\t\t/* Input errors */\n\t\tcase SRS_ENOSENDERATSIGN:\n\t\t\treturn \"No at sign in sender address\";\n\t\tcase SRS_EBUFTOOSMALL:\n\t\t\treturn \"Buffer too small.\";\n\n\t\t/* Syntax errors */\n\t\tcase SRS_ENOSRS0HOST:\n\t\t\treturn \"No host in SRS0 address.\";\n\t\tcase SRS_ENOSRS0USER:\n\t\t\treturn \"No user in SRS0 address.\";\n\t\tcase SRS_ENOSRS0HASH:\n\t\t\treturn \"No hash in SRS0 address.\";\n\t\tcase SRS_ENOSRS0STAMP:\n\t\t\treturn \"No timestamp in SRS0 address.\";\n\t\tcase SRS_ENOSRS1HOST:\n\t\t\treturn \"No host in SRS1 address.\";\n\t\tcase SRS_ENOSRS1USER:\n\t\t\treturn \"No user in SRS1 address.\";\n\t\tcase SRS_ENOSRS1HASH:\n\t\t\treturn \"No hash in SRS1 address.\";\n\t\tcase SRS_EBADTIMESTAMPCHAR:\n\t\t\treturn \"Bad base32 character in timestamp.\";\n\t\tcase SRS_EHASHTOOSHORT:\n\t\t\treturn \"Hash too short in SRS address.\";\n\n\t\t/* SRS errors */\n\t\tcase SRS_ETIMESTAMPOUTOFDATE:\n\t\t\treturn \"Time stamp out of date.\";\n\t\tcase SRS_EHASHINVALID:\n\t\t\treturn \"Hash invalid in SRS address.\";\n\n\t\tdefault:\n\t\t\treturn \"Unknown error in SRS library.\";\n\t}\n}\n\nsrs_t *\nsrs_new()\n{\n\tsrs_t\t*srs = (srs_t *)srs_f_malloc(sizeof(srs_t));\n\tsrs_init(srs);\n\treturn srs;\n}\n\nvoid\nsrs_init(srs_t *srs)\n{\n\tmemset(srs, 0, sizeof(srs_t));\n\tsrs->secrets = NULL;\n\tsrs->numsecrets = 0;\n\tsrs->separator = '=';\n\tsrs->maxage = 21;\n\tsrs->hashlength = 4;\n\tsrs->hashmin = srs->hashlength;\n\tsrs->alwaysrewrite = FALSE;\n}\n\nvoid\nsrs_free(srs_t *srs)\n{\n\tint\t i;\n\tfor (i = 0; i < srs->numsecrets; i++) {\n\t\tmemset(srs->secrets[i], 0, strlen(srs->secrets[i]));\n\t\tsrs_f_free(srs->secrets[i]);\n\t\tsrs->secrets[i] = 0;\n\t}\n\tsrs_f_free(srs);\n}\n\nint\nsrs_add_secret(srs_t *srs, const char *secret)\n{\n\tint\t\tnewlen = (srs->numsecrets + 1) * sizeof(char *);\n\tsrs->secrets = (char **)srs_f_realloc(srs->secrets, newlen);\n\tsrs->secrets[srs->numsecrets++] = strdup(secret);\n\treturn SRS_SUCCESS;\n}\n\nconst char *\nsrs_get_secret(srs_t *srs, int idx)\n{\n\tif (idx < srs->numsecrets)\n\t\treturn srs->secrets[idx];\n\treturn NULL;\n}\n\n#define SRS_PARAM_DEFINE(n, t) \\\n\tint srs_set_ ## n (srs_t *srs, t value) { \\\n\t\tsrs->n = value; \\\n\t\treturn SRS_SUCCESS; \\\n\t} \\\n\tt srs_get_ ## n (srs_t *srs) { \\\n\t\treturn srs->n; \\\n\t}\n\nint\nsrs_set_separator(srs_t *srs, char value)\n{\n\tif (strchr(srs_separators, value) == NULL)\n\t\treturn SRS_ESEPARATORINVALID;\n\tsrs->separator = value;\n\treturn SRS_SUCCESS;\n}\n\nchar\nsrs_get_separator(srs_t *srs)\n{\n\treturn srs->separator;\n}\n\nSRS_PARAM_DEFINE(maxage, int)\n\t/* XXX Check hashlength >= hashmin */\nSRS_PARAM_DEFINE(hashlength, int)\nSRS_PARAM_DEFINE(hashmin, int)\nSRS_PARAM_DEFINE(alwaysrewrite, srs_bool)\nSRS_PARAM_DEFINE(noforward, srs_bool)\nSRS_PARAM_DEFINE(noreverse, srs_bool)\n\n/* Don't mess with these unless you know what you're doing well\n * enough to rewrite the timestamp functions. These are based on\n * a 2 character timestamp. Changing these in the wild is probably\n * a bad idea. */\n#define SRS_TIME_PRECISION\t(60 * 60 * 24)\t/* One day */\n#define SRS_TIME_BASEBITS\t5\t\t/* 2^5 = 32 = strlen(CHARS) */\n/* This had better be a real variable since we do arithmethic\n * with it. */\nconst char *SRS_TIME_BASECHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n#define SRS_TIME_SIZE\t\t2\n#define SRS_TIME_SLOTS\t\t(1<<(SRS_TIME_BASEBITS<<(SRS_TIME_SIZE-1)))\n\nint\nsrs_timestamp_create(srs_t *srs __attribute__((unused)), char *buf, time_t now)\n{\n\tnow = now / SRS_TIME_PRECISION;\n\tbuf[1] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];\n\tnow = now >> SRS_TIME_BASEBITS;\n\tbuf[0] = SRS_TIME_BASECHARS[now & ((1 << SRS_TIME_BASEBITS) - 1)];\n\tbuf[2] = '\\0';\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}\n\nconst char *SRS_HASH_BASECHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\t\t\t\t\t\t \"abcdefghijklmnopqrstuvwxyz\"\n\t\t\t\t\t\t\t\t \"0123456789+/\";\n\nstatic void\nsrs_hash_create_v(srs_t *srs, int idx, char *buf, int nargs, va_list ap)\n{\n#ifdef USE_OPENSSL\n\tHMAC_CTX\t\t ctx;\n\tint\t\t\t\t srshashlen;\n\tchar\t\t\t srshash[EVP_MAX_MD_SIZE + 1];\n#else\n\tsrs_hmac_ctx_t\t ctx;\n\tchar\t\t\t srshash[SHA_DIGESTSIZE + 1];\n#endif\n\tchar\t\t\t*secret;\n\tchar\t\t\t*data;\n\tint\t\t\t\t len;\n\tchar\t\t\t*lcdata;\n\tunsigned char\t*hp;\n\tchar\t\t\t*bp;\n\tint\t\t\t\t i;\n\tint\t\t\t\t j;\n\n\tsecret = srs->secrets[idx];\n\n#ifdef USE_OPENSSL\n\tHMAC_CTX_init(&ctx);\n\tHMAC_Init(&ctx, secret, strlen(secret), EVP_sha1());\n#else\n\tsrs_hmac_init(&ctx, secret, strlen(secret));\n#endif\n\n\tfor (i = 0; i < nargs; i++) {\n\t\tdata = va_arg(ap, char *);\n\t\tlen = strlen(data);\n\t\tlcdata = alloca(len + 1);\n\t\tfor (j = 0; j < len; j++) {\n\t\t\tif (isupper(data[j]))\n\t\t\t\tlcdata[j] = tolower(data[j]);\n\t\t\telse\n\t\t\t\tlcdata[j] = data[j];\n\t\t}\n#ifdef USE_OPENSSL\n\t\tHMAC_Update(&ctx, lcdata, len);\n#else\n\t\tsrs_hmac_update(&ctx, lcdata, len);\n#endif\n\t}\n\n#ifdef USE_OPENSSL\n\tHMAC_Final(&ctx, srshash, &srshashlen);\n\tHMAC_CTX_cleanup(&ctx);\n\tsrshash[EVP_MAX_MD_SIZE] = '\\0';\n#else\n\tsrs_hmac_fini(&ctx, srshash);\n\tsrshash[SHA_DIGESTSIZE] = '\\0';\n#endif\n\n\n\t/* A little base64 encoding. Just a little. */\n\thp = (unsigned char *)srshash;\n\tbp = buf;\n\tfor (i = 0; i < srs->hashlength; i++) {\n\t\tswitch (i & 0x03) {\n\t\t\tdefault:\t/* NOTREACHED */\n\t\t\tcase 0:\n\t\t\t\tj = (*hp >> 2);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tj = ((*hp & 0x03) << 4) |\n\t\t\t\t\t\t((*(hp + 1) & 0xF0) >> 4);\n\t\t\t\thp++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tj = ((*hp & 0x0F) << 2) |\n\t\t\t\t\t\t((*(hp + 1) & 0xC0) >> 6);\n\t\t\t\thp++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tj = (*hp++ & 0x3F);\n\t\t\t\tbreak;\n\t\t}\n\t\t*bp++ = SRS_HASH_BASECHARS[j];\n\t}\n\n\t*bp = '\\0';\n\tbuf[srs->hashlength] = '\\0';\n}\n\nint\nsrs_hash_create(srs_t *srs, char *buf, int nargs, ...)\n{\n\tva_list\t ap;\n\n\tif (srs->numsecrets == 0)\n\t\treturn SRS_ENOSECRETS;\n\tif (srs->secrets == NULL)\n\t\treturn SRS_ENOSECRETS;\n\tif (srs->secrets[0] == NULL)\n\t\treturn SRS_ENOSECRETS;\n\n\tva_start(ap, nargs);\n\tsrs_hash_create_v(srs, 0, buf, nargs, ap);\n\tva_end(ap);\n\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_hash_check(srs_t *srs, char *hash, int nargs, ...)\n{\n\tva_list\tap;\n\tchar\t*srshash;\n\tchar\t*tmp;\n\tint\t\t len;\n\tint\t\t i;\n\n\tlen = strlen(hash);\n\tif (len < srs->hashmin)\n\t\treturn SRS_EHASHTOOSHORT;\n\tif (len > srs->hashlength) {\n\t\ttmp = alloca(srs->hashlength + 1);\n\t\tstrncpy(tmp, hash, srs->hashlength);\n\t\ttmp[srs->hashlength] = '\\0';\n\t\thash = tmp;\n\t\tlen = srs->hashlength;\n\t}\n\n\tfor (i = 0; i < srs->numsecrets; i++) {\n\t\tva_start(ap, nargs);\n\t\tsrshash = alloca(srs->hashlength + 1);\n\t\tsrs_hash_create_v(srs, i, srshash, nargs, ap);\n\t\tva_end(ap);\n\t\tif (strncasecmp(hash, srshash, len) == 0)\n\t\t\treturn SRS_SUCCESS;\n\t}\n\n\treturn SRS_EHASHINVALID;\n}\n\nint\nsrs_compile_shortcut(srs_t *srs,\n\t\t\t\tchar *buf, int buflen,\n\t\t\t\tchar *sendhost, char *senduser,\n\t\t\t\tconst char *aliashost) {\n\tchar\t*srshash;\n\tchar\t srsstamp[SRS_TIME_SIZE + 1];\n\tint\t\t len;\n\tint\t\t ret;\n\n\t/* This never happens if we get called from guarded() */\n\tif ((strncasecmp(senduser, SRS0TAG, 4) == 0) &&\n\t\t(strchr(srs_separators, senduser[4]) != NULL)) {\n\t\tsendhost = senduser + 5;\n\t\tif (*sendhost == '\\0')\n\t\t\treturn SRS_ENOSRS0HOST;\n\t\tsenduser = strchr(sendhost, SRSSEP);\n\t\tif ((senduser == NULL) || (*senduser == '\\0'))\n\t\t\treturn SRS_ENOSRS0USER;\n\t}\n\n\tlen = strlen(SRS0TAG) + 1 +\n\t\tsrs->hashlength + 1 +\n\t\t\tSRS_TIME_SIZE + 1 +\n\t\t\t\tstrlen(sendhost) + 1 + strlen(senduser)\n\t\t\t+ 1 + strlen(aliashost);\n\tif (len >= buflen)\n\t\treturn SRS_EBUFTOOSMALL;\n\n\tret = srs_timestamp_create(srs, srsstamp, time(NULL));\n\tif (ret != SRS_SUCCESS)\n\t\treturn ret;\n\tsrshash = alloca(srs->hashlength + 1);\n\tret = srs_hash_create(srs, srshash,3, srsstamp, sendhost, senduser);\n\tif (ret != SRS_SUCCESS)\n\t\treturn ret;\n\n\tsprintf(buf, SRS0TAG \"%c%s%c%s%c%s%c%s@%s\", srs->separator,\n\t\t\t\t\tsrshash, SRSSEP, srsstamp, SRSSEP,\n\t\t\t\t\t\tsendhost, SRSSEP, senduser,\n\t\t\t\t\t\t\taliashost);\n\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_compile_guarded(srs_t *srs,\n\t\t\t\tchar *buf, int buflen,\n\t\t\t\tchar *sendhost, char *senduser,\n\t\t\t\tconst char *aliashost) {\n\tchar\t*srshost;\n\tchar\t*srsuser;\n\tchar\t*srshash;\n\tint\t\t len;\n\tint\t\t ret;\n\n\tif ((strncasecmp(senduser, SRS1TAG, 4) == 0) &&\n\t\t(strchr(srs_separators, senduser[4]) != NULL)) {\n\t\t/* Used as a temporary convenience var */\n\t\tsrshash = senduser + 5;\n\t\tif (*srshash == '\\0')\n\t\t\treturn SRS_ENOSRS1HASH;\n\t\t/* Used as a temporary convenience var */\n\t\tsrshost = strchr(srshash, SRSSEP);\n\t\tif (!STRINGP(srshost))\n\t\t\treturn SRS_ENOSRS1HOST;\n\t\t*srshost++ = '\\0';\n\t\tsrsuser = strchr(srshost, SRSSEP);\n\t\tif (!STRINGP(srsuser))\n\t\t\treturn SRS_ENOSRS1USER;\n\t\t*srsuser++ = '\\0';\n\t\tsrshash = alloca(srs->hashlength + 1);\n\t\tret = srs_hash_create(srs, srshash, 2, srshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tlen = strlen(SRS1TAG) + 1 +\n\t\t\tsrs->hashlength + 1 +\n\t\t\t\tstrlen(srshost) + 1 + strlen(srsuser)\n\t\t\t+ 1 + strlen(aliashost);\n\t\tif (len >= buflen)\n\t\t\treturn SRS_EBUFTOOSMALL;\n\t\tsprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator,\n\t\t\t\t\t\tsrshash, SRSSEP,\n\t\t\t\t\t\t\tsrshost, SRSSEP, srsuser,\n\t\t\t\t\t\t\t\taliashost);\n\t\treturn SRS_SUCCESS;\n\t}\n\telse if ((strncasecmp(senduser, SRS0TAG, 4) == 0) &&\n\t\t(strchr(srs_separators, senduser[4]) != NULL)) {\n\t\tsrsuser = senduser + 4;\n\t\tsrshost = sendhost;\n\t\tsrshash = alloca(srs->hashlength + 1);\n\t\tret = srs_hash_create(srs, srshash, 2, srshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tlen = strlen(SRS1TAG) + 1 +\n\t\t\tsrs->hashlength + 1 +\n\t\t\t\tstrlen(srshost) + 1 + strlen(srsuser)\n\t\t\t+ 1 + strlen(aliashost);\n\t\tif (len >= buflen)\n\t\t\treturn SRS_EBUFTOOSMALL;\n\t\tsprintf(buf, SRS1TAG \"%c%s%c%s%c%s@%s\", srs->separator,\n\t\t\t\t\t\tsrshash, SRSSEP,\n\t\t\t\t\t\t\tsrshost, SRSSEP, srsuser,\n\t\t\t\t\t\t\t\taliashost);\n\t}\n\telse {\n\t\treturn srs_compile_shortcut(srs, buf, buflen,\n\t\t\t\t\t\tsendhost, senduser, aliashost);\n\t}\n\n\treturn SRS_SUCCESS;\n}\n\nint\nsrs_parse_shortcut(srs_t *srs, char *buf, unsigned buflen, char *senduser)\n{\n\tchar\t*srshash;\n\tchar\t*srsstamp;\n\tchar\t*srshost;\n\tchar\t*srsuser;\n\tint\t\t ret;\n\n\tif (strncasecmp(senduser, SRS0TAG, 4) == 0) {\n\t\tsrshash = senduser + 5;\n\t\tif (!STRINGP(srshash))\n\t\t\treturn SRS_ENOSRS0HASH;\n\t\tsrsstamp = strchr(srshash, SRSSEP);\n\t\tif (!STRINGP(srsstamp))\n\t\t\treturn SRS_ENOSRS0STAMP;\n\t\t*srsstamp++ = '\\0';\n\t\tsrshost = strchr(srsstamp, SRSSEP);\n\t\tif (!STRINGP(srshost))\n\t\t\treturn SRS_ENOSRS0HOST;\n\t\t*srshost++ = '\\0';\n\t\tsrsuser = strchr(srshost, SRSSEP);\n\t\tif (!STRINGP(srsuser))\n\t\t\treturn SRS_ENOSRS0USER;\n\t\t*srsuser++ = '\\0';\n\t\tret = srs_timestamp_check(srs, srsstamp);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tret = srs_hash_check(srs, srshash, 3, srsstamp,\n\t\t\t\t\t\tsrshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tsnprintf(buf, buflen, \"%s@%s\", srsuser, srshost);\n\t\treturn SRS_SUCCESS;\n\t}\n\n\treturn SRS_ENOTSRSADDRESS;\n}\n\nint\nsrs_parse_guarded(srs_t *srs, char *buf, int buflen, char *senduser)\n{\n\tchar\t*srshash;\n\tchar\t*srshost;\n\tchar\t*srsuser;\n\tint\t\t ret;\n\n\tif (strncasecmp(senduser, SRS1TAG, 4) == 0) {\n\t\tsrshash = senduser + 5;\n\t\tif (!STRINGP(srshash))\n\t\t\treturn SRS_ENOSRS1HASH;\n\t\tsrshost = strchr(srshash, SRSSEP);\n\t\tif (!STRINGP(srshost))\n\t\t\treturn SRS_ENOSRS1HOST;\n\t\t*srshost++ = '\\0';\n\t\tsrsuser = strchr(srshost, SRSSEP);\n\t\tif (!STRINGP(srsuser))\n\t\t\treturn SRS_ENOSRS1USER;\n\t\t*srsuser++ = '\\0';\n\t\tret = srs_hash_check(srs, srshash, 2, srshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tsprintf(buf, SRS0TAG \"%s@%s\", srsuser, srshost);\n\t\treturn SRS_SUCCESS;\n\t}\n\telse {\n\t\treturn srs_parse_shortcut(srs, buf, buflen, senduser);\n\t}\n}\n\nint\nsrs_forward(srs_t *srs, char *buf, unsigned buflen,\n\t\t\t\tconst char *sender, const char *alias)\n{\n\tchar\t*senduser;\n\tchar\t*sendhost;\n\tchar\t*tmp;\n\tunsigned\t\t len;\n\n\tif (srs->noforward)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\t/* This is allowed to be a plain domain */\n\twhile ((tmp = strchr(alias, '@')) != NULL)\n\t\talias = tmp + 1;\n\n\ttmp = strchr(sender, '@');\n\tif (tmp == NULL)\n\t\treturn SRS_ENOSENDERATSIGN;\n\tsendhost = tmp + 1;\n\n\tlen = strlen(sender);\n\n\tif (! srs->alwaysrewrite) {\n\t\tif (strcasecmp(sendhost, alias) == 0) {\n\t\t\tif (strlen(sender) >= buflen)\n\t\t\t\treturn SRS_EBUFTOOSMALL;\n\t\t\tstrcpy(buf, sender);\n\t\t\treturn SRS_SUCCESS;\n\t\t}\n\t}\n\n\t/* Reconstruct the whole show into our alloca() buffer. */\n\tsenduser = alloca(len + 1);\n\tstrcpy(senduser, sender);\n\ttmp = (senduser + (tmp - sender));\n\tsendhost = tmp + 1;\n\t*tmp = '\\0';\n\n\treturn srs_compile_guarded(srs, buf, buflen,\n\t\t\t\t\tsendhost, senduser, alias);\n}\n\nint\nsrs_forward_alloc(srs_t *srs, char **sptr,\n\t\t\t\tconst char *sender, const char *alias)\n{\n\tchar\t*buf;\n\tint\t\t slen;\n\tint\t\t alen;\n\tint\t\t len;\n\tint\t\t ret;\n\n\tif (srs->noforward)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\tslen = strlen(sender);\n\talen = strlen(alias);\n\n\t/* strlen(SRSxTAG) + strlen(\"====+@\") < 64 */\n\tlen = slen + alen + srs->hashlength + SRS_TIME_SIZE + 64;\n\tbuf = (char *)srs_f_malloc(len);\n\n\tret = srs_forward(srs, buf, len, sender, alias);\n\n\tif (ret == SRS_SUCCESS)\n\t\t*sptr = buf;\n\telse\n\t\tsrs_f_free(buf);\n\n\treturn ret;\n}\n\nint\nsrs_reverse(srs_t *srs, char *buf, unsigned buflen, const char *sender)\n{\n\tchar\t*senduser;\n\tchar\t*tmp;\n\tunsigned\t\t len;\n\n\tif (!SRS_IS_SRS_ADDRESS(sender))\n\t\treturn SRS_ENOTSRSADDRESS;\n\n\tif (srs->noreverse)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\tlen = strlen(sender);\n\tif (len >= buflen)\n\t\treturn SRS_EBUFTOOSMALL;\n\tsenduser = alloca(len + 1);\n\tstrcpy(senduser, sender);\n\n\t/* We don't really care about the host for reversal. */\n\ttmp = strchr(senduser, '@');\n\tif (tmp != NULL)\n\t\t*tmp = '\\0';\n\treturn srs_parse_guarded(srs, buf, buflen, senduser);\n}\n\nint\nsrs_reverse_alloc(srs_t *srs, char **sptr, const char *sender)\n{\n\tchar\t*buf;\n\tint\t\t len;\n\tint\t\t ret;\n\n\t*sptr = NULL;\n\n\tif (!SRS_IS_SRS_ADDRESS(sender))\n\t\treturn SRS_ENOTSRSADDRESS;\n\n\tif (srs->noreverse)\n\t\treturn SRS_ENOTREWRITTEN;\n\n\tlen = strlen(sender) + 1;\n\tbuf = (char *)srs_f_malloc(len);\n\n\tret = srs_reverse(srs, buf, len, sender);\n\n\tif (ret == SRS_SUCCESS)\n\t\t*sptr = buf;\n\telse\n\t\tsrs_f_free(buf);\n\n\treturn ret;\n}\n"], "filenames": ["srs2.c"], "buggy_code_start_loc": [232], "buggy_code_end_loc": [232], "fixing_code_start_loc": [233], "fixing_code_end_loc": [234], "type": "CWE-834", "message": "srs2.c in PostSRSd before 1.10 allows remote attackers to cause a denial of service (CPU consumption) via a long timestamp tag in an SRS address.", "other": {"cve": {"id": "CVE-2020-35573", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-20T05:15:09.553", "lastModified": "2022-04-26T16:12:27.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "srs2.c in PostSRSd before 1.10 allows remote attackers to cause a denial of service (CPU consumption) via a long timestamp tag in an SRS address."}, {"lang": "es", "value": "El archivo srs2.c en PostSRSd versiones anteriores a 1.10, permite a atacantes remotos causar una denegaci\u00f3n de servicio (consumo de la CPU) por medio de una etiqueta timestamp en una direcci\u00f3n SRS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:postsrsd_project:postsrsd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10", "matchCriteriaId": "C69CC6AF-388C-4250-BEA4-7A914183CA70"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/roehling/postsrsd/commit/4733fb11f6bec6524bb8518c5e1a699288c26bac", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-08", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/roehling/postsrsd/commit/4733fb11f6bec6524bb8518c5e1a699288c26bac"}}