{"buggy_code": ["(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function(){\n  'use strict';\n\n  var toStr = Object.prototype.toString;\n  function hasOwnProperty(obj, prop) {\n    if(obj == null) {\n      return false\n    }\n    //to handle objects with null prototypes (too edge case?)\n    return Object.prototype.hasOwnProperty.call(obj, prop)\n  }\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (typeof value !== 'string') {\n        for (var i in value) {\n            if (hasOwnProperty(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  var isArray = Array.isArray || function(obj){\n    /*istanbul ignore next:cant test*/\n    return toStr.call(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function factory(options) {\n    options = options || {}\n\n    var objectPath = function(obj) {\n      return Object.keys(objectPath).reduce(function(proxy, prop) {\n        if(prop === 'create') {\n          return proxy;\n        }\n\n        /*istanbul ignore else*/\n        if (typeof objectPath[prop] === 'function') {\n          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n        }\n\n        return proxy;\n      }, {});\n    };\n\n    var hasShallowProperty\n    if (options.includeInheritedProps) {\n      hasShallowProperty = function () {\n        return true\n      }\n    } else {\n      hasShallowProperty = function (obj, prop) {\n        return (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop)\n      }\n    }\n\n    function getShallowProperty(obj, prop) {\n      if (hasShallowProperty(obj, prop)) {\n        return obj[prop];\n      }\n    }\n\n    function set(obj, path, value, doNotReplace){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (typeof path === 'string') {\n        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n      }\n      var currentPath = path[0];\n      var currentValue = getShallowProperty(obj, currentPath);\n      if (path.length === 1) {\n        if (currentValue === void 0 || !doNotReplace) {\n          obj[currentPath] = value;\n        }\n        return currentValue;\n      }\n\n      if (currentValue === void 0) {\n        //check if we assume an array\n        if(typeof path[1] === 'number') {\n          obj[currentPath] = [];\n        } else {\n          obj[currentPath] = {};\n        }\n      }\n\n      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n    }\n\n    objectPath.has = function (obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      } else if (typeof path === 'string') {\n        path = path.split('.');\n      }\n\n      if (!path || path.length === 0) {\n        return !!obj;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        var j = getKey(path[i]);\n\n        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n          obj = obj[j];\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    objectPath.ensureExists = function (obj, path, value){\n      return set(obj, path, value, true);\n    };\n\n    objectPath.set = function (obj, path, value, doNotReplace){\n      return set(obj, path, value, doNotReplace);\n    };\n\n    objectPath.insert = function (obj, path, value, at){\n      var arr = objectPath.get(obj, path);\n      at = ~~at;\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n      arr.splice(at, 0, value);\n    };\n\n    objectPath.empty = function(obj, path) {\n      if (isEmpty(path)) {\n        return void 0;\n      }\n      if (obj == null) {\n        return void 0;\n      }\n\n      var value, i;\n      if (!(value = objectPath.get(obj, path))) {\n        return void 0;\n      }\n\n      if (typeof value === 'string') {\n        return objectPath.set(obj, path, '');\n      } else if (isBoolean(value)) {\n        return objectPath.set(obj, path, false);\n      } else if (typeof value === 'number') {\n        return objectPath.set(obj, path, 0);\n      } else if (isArray(value)) {\n        value.length = 0;\n      } else if (isObject(value)) {\n        for (i in value) {\n          if (hasShallowProperty(value, i)) {\n            delete value[i];\n          }\n        }\n      } else {\n        return objectPath.set(obj, path, null);\n      }\n    };\n\n    objectPath.push = function (obj, path /*, values */){\n      var arr = objectPath.get(obj, path);\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n\n      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n    };\n\n    objectPath.coalesce = function (obj, paths, defaultValue) {\n      var value;\n\n      for (var i = 0, len = paths.length; i < len; i++) {\n        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n          return value;\n        }\n      }\n\n      return defaultValue;\n    };\n\n    objectPath.get = function (obj, path, defaultValue){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (obj == null) {\n        return defaultValue;\n      }\n      if (typeof path === 'string') {\n        return objectPath.get(obj, path.split('.'), defaultValue);\n      }\n\n      var currentPath = getKey(path[0]);\n      var nextObj = getShallowProperty(obj, currentPath)\n      if (nextObj === void 0) {\n        return defaultValue;\n      }\n\n      if (path.length === 1) {\n        return nextObj;\n      }\n\n      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n    };\n\n    objectPath.del = function del(obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      }\n\n      if (obj == null) {\n        return obj;\n      }\n\n      if (isEmpty(path)) {\n        return obj;\n      }\n      if(typeof path === 'string') {\n        return objectPath.del(obj, path.split('.'));\n      }\n\n      var currentPath = getKey(path[0]);\n      if (!hasShallowProperty(obj, currentPath)) {\n        return obj;\n      }\n\n      if(path.length === 1) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      } else {\n        return objectPath.del(obj[currentPath], path.slice(1));\n      }\n\n      return obj;\n    }\n\n    return objectPath;\n  }\n\n  var mod = factory();\n  mod.create = factory;\n  mod.withInheritedProps = factory({includeInheritedProps: true})\n  return mod;\n});\n", "'use strict';\nvar expect = require('chai').expect,\nobjectPath = require('./index.js');\n\n\nfunction getTestObj() {\n  return {\n    a: 'b',\n    b: {\n      c: [],\n      d: ['a', 'b'],\n      e: [{},{f: 'g'}],\n      f: 'i'\n    }\n  };\n}\n\ndescribe('get', function() {\n  it('should return the value using unicode key', function() {\n    var obj = {\n      '15\\u00f8C': {\n        '3\\u0111': 1\n      }\n    };\n    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(1);\n    expect(objectPath.get(obj, ['15\\u00f8C','3\\u0111'])).to.be.equal(1);\n  });\n\n  it('should return the value using dot in key', function() {\n    var obj = {\n      'a.b': {\n        'looks.like': 1\n      }\n    };\n    expect(objectPath.get(obj, 'a.b.looks.like')).to.be.equal(void 0);\n    expect(objectPath.get(obj, ['a.b','looks.like'])).to.be.equal(1);\n  });\n\n  it('should return the value under shallow object', function() {\n    var obj = getTestObj();\n    expect(objectPath.get(obj, 'a')).to.be.equal('b');\n    expect(objectPath.get(obj, ['a'])).to.be.equal('b');\n  });\n\n  it('should work with number path', function() {\n    var obj = getTestObj();\n    expect(objectPath.get(obj.b.d, 0)).to.be.equal('a');\n    expect(objectPath.get(obj.b, 0)).to.be.equal(void 0);\n  });\n\n  it('should return the value under deep object', function() {\n    var obj = getTestObj();\n    expect(objectPath.get(obj, 'b.f')).to.be.equal('i');\n    expect(objectPath.get(obj, ['b','f'])).to.be.equal('i');\n  });\n\n  it('should return the value under array', function() {\n    var obj = getTestObj();\n    expect(objectPath.get(obj, 'b.d.0')).to.be.equal('a');\n    expect(objectPath.get(obj, ['b','d',0])).to.be.equal('a');\n  });\n\n  it('should return the value under array deep', function() {\n    var obj = getTestObj();\n    expect(objectPath.get(obj, 'b.e.1.f')).to.be.equal('g');\n    expect(objectPath.get(obj, ['b','e',1,'f'])).to.be.equal('g');\n  });\n\n  it('should return undefined for missing values under object', function() {\n    var obj = getTestObj();\n    expect(objectPath.get(obj, 'a.b')).to.not.exist;\n    expect(objectPath.get(obj, ['a','b'])).to.not.exist;\n  });\n\n  it('should return undefined for missing values under array', function() {\n    var obj = getTestObj();\n    expect(objectPath.get(obj, 'b.d.5')).to.not.exist;\n    expect(objectPath.get(obj, ['b','d','5'])).to.not.exist;\n  });\n\n  it('should return the value under integer-like key', function() {\n    var obj = { '1a': 'foo' };\n    expect(objectPath.get(obj, '1a')).to.be.equal('foo');\n    expect(objectPath.get(obj, ['1a'])).to.be.equal('foo');\n  });\n\n  it('should return the default value when the key doesnt exist', function() {\n    var obj = { '1a': 'foo' };\n    expect(objectPath.get(obj, '1b', null)).to.be.equal(null);\n    expect(objectPath.get(obj, ['1b'], null)).to.be.equal(null);\n  });\n\n  it('should return the default value when path is empty', function() {\n    var obj = { '1a': 'foo' };\n    expect(objectPath.get(obj, '', null)).to.be.deep.equal({ '1a': 'foo' });\n    expect(objectPath.get(obj, [])).to.be.deep.equal({ '1a': 'foo' });\n    expect(objectPath.get({  }, ['1'])).to.be.equal(undefined);\n  });\n\n  it('should return the default value when object is null or undefined', function() {\n    expect(objectPath.get(null, 'test', 'a')).to.be.deep.equal('a');\n    expect(objectPath.get(undefined, 'test', 'a')).to.be.deep.equal('a');\n  });\n\n  it(\n    'should not fail on an object with a null prototype',\n    function assertSuccessForObjWithNullProto(){\n      var foo = 'FOO';\n      var objWithNullProto = Object.create(null);\n      objWithNullProto.foo = foo;\n      expect(objectPath.get(objWithNullProto, 'foo')).to.equal(foo);\n    }\n  );\n\n  it('should skip non own properties', function() {\n    var Base = function(enabled){ };\n    Base.prototype = {\n      one: {\n        two: true\n      }\n    };\n    var Extended = function(){\n      Base.call(this,  true);\n    };\n    Extended.prototype = Object.create(Base.prototype);\n\n    var extended = new Extended();\n\n    expect(objectPath.get(extended, ['one','two'])).to.be.equal(undefined);\n    extended.enabled = true;\n\n    expect(objectPath.get(extended, 'enabled')).to.be.equal(true);\n    expect(objectPath.get(extended, 'one')).to.be.equal(undefined);\n  });\n});\n\n\ndescribe('set', function() {\n  it('should set the value using unicode key', function() {\n    var obj = {\n      '15\\u00f8C': {\n        '3\\u0111': 1\n      }\n    };\n    objectPath.set(obj, '15\\u00f8C.3\\u0111', 2);\n    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(2);\n    objectPath.set(obj, '15\\u00f8C.3\\u0111', 3);\n    expect(objectPath.get(obj, ['15\\u00f8C','3\\u0111'])).to.be.equal(3);\n  });\n\n  it('should set the value using dot in key', function() {\n    var obj = {\n      'a.b': {\n        'looks.like': 1\n      }\n    };\n    objectPath.set(obj, ['a.b','looks.like'], 2);\n    expect(objectPath.get(obj, ['a.b','looks.like'])).to.be.equal(2);\n  });\n\n  it('should set value under shallow object', function() {\n    var obj = getTestObj();\n    objectPath.set(obj, 'c', {m: 'o'});\n    expect(obj).to.include.nested.property('c.m', 'o');\n    obj = getTestObj();\n    objectPath.set(obj, ['c'], {m: 'o'});\n    expect(obj).to.include.nested.property('c.m', 'o');\n  });\n\n  it('should set value using number path', function() {\n    var obj = getTestObj();\n    objectPath.set(obj.b.d, 0, 'o');\n    expect(obj).to.have.nested.property('b.d.0', 'o');\n  });\n\n  it('should set value under deep object', function() {\n    var obj = getTestObj();\n    objectPath.set(obj, 'b.c', 'o');\n    expect(obj).to.have.nested.property('b.c', 'o');\n    obj = getTestObj();\n    objectPath.set(obj, ['b','c'], 'o');\n    expect(obj).to.have.nested.property('b.c', 'o');\n  });\n\n  it('should set value under array', function() {\n    var obj = getTestObj();\n    objectPath.set(obj, 'b.e.1.g', 'f');\n    expect(obj).to.have.nested.property('b.e.1.g', 'f');\n    obj = getTestObj();\n    objectPath.set(obj, ['b','e',1,'g'], 'f');\n    expect(obj).to.have.nested.property('b.e.1.g', 'f');\n\n    obj = {}\n    objectPath.set(obj, 'b.0', 'a');\n    objectPath.set(obj, 'b.1', 'b');\n    expect(obj.b).to.be.deep.equal(['a', 'b']);\n  });\n\n  it('should create intermediate objects', function() {\n    var obj = getTestObj();\n    objectPath.set(obj, 'c.d.e.f', 'l');\n    expect(obj).to.have.nested.property('c.d.e.f', 'l');\n    obj = getTestObj();\n    objectPath.set(obj, ['c','d','e','f'], 'l');\n    expect(obj).to.have.nested.property('c.d.e.f', 'l');\n  });\n\n  it('should create intermediate arrays', function() {\n    var obj = getTestObj();\n    objectPath.set(obj, 'c.0.1.m', 'l');\n    expect(obj.c).to.be.an('array');\n    expect(obj.c[0]).to.be.an('array');\n    expect(obj).to.have.nested.property('c.0.1.m', 'l');\n    obj = getTestObj();\n    objectPath.set(obj, ['c','0', 1,'m'], 'l');\n    expect(obj.c).to.be.an('object');\n    expect(obj.c[0]).to.be.an('array');\n    expect(obj).to.have.nested.property('c.0.1.m', 'l');\n  });\n\n  it('should set value under integer-like key', function() {\n    var obj = getTestObj();\n    objectPath.set(obj, '1a', 'foo');\n    expect(obj).to.have.nested.property('1a', 'foo');\n    obj = getTestObj();\n    objectPath.set(obj, ['1a'], 'foo');\n    expect(obj).to.have.nested.property('1a', 'foo');\n  });\n\n  it('should set value under empty array', function() {\n    var obj = [];\n    objectPath.set(obj, [0], 'foo');\n    expect(obj[0]).to.be.equal('foo');\n    obj = [];\n    objectPath.set(obj, '0', 'foo');\n    expect(obj[0]).to.be.equal('foo');\n  });\n});\n\n\ndescribe('push', function() {\n  it('should push value to existing array using unicode key', function() {\n    var obj = getTestObj();\n    objectPath.push(obj, 'b.\\u1290c', 'l');\n    expect(obj).to.have.nested.property('b.\\u1290c.0', 'l');\n    objectPath.push(obj, ['b','\\u1290c'], 'l');\n    expect(obj).to.have.nested.property('b.\\u1290c.1', 'l');\n  });\n\n  it('should push value to existing array using dot key', function() {\n    var obj = getTestObj();\n    objectPath.push(obj, ['b','z.d'], 'l');\n    expect(objectPath.get(obj, ['b','z.d', 0])).to.be.equal('l');\n  });\n\n  it('should push value to existing array', function() {\n    var obj = getTestObj();\n    objectPath.push(obj, 'b.c', 'l');\n    expect(obj).to.have.nested.property('b.c.0', 'l');\n    obj = getTestObj();\n    objectPath.push(obj, ['b','c'], 'l');\n    expect(obj).to.have.nested.property('b.c.0', 'l');\n  });\n\n  it('should push value to new array', function() {\n    var obj = getTestObj();\n    objectPath.push(obj, 'b.h', 'l');\n    expect(obj).to.have.nested.property('b.h.0', 'l');\n    obj = getTestObj();\n    objectPath.push(obj, ['b','h'], 'l');\n    expect(obj).to.have.nested.property('b.h.0', 'l');\n  });\n\n  it('should push value to existing array using number path', function() {\n    var obj = getTestObj();\n    objectPath.push(obj.b.e, 0, 'l');\n    expect(obj).to.have.nested.property('b.e.0.0', 'l');\n  });\n\n});\n\n\ndescribe('ensureExists', function() {\n  it('should create the path if it does not exists', function() {\n    var obj = getTestObj();\n    var oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test');\n    expect(oldVal).to.not.exist;\n    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n    oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test1');\n    expect(oldVal).to.be.equal('test');\n    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n    oldVal = objectPath.ensureExists(obj, 'b.\\u8210', 'ok');\n    expect(oldVal).to.not.exist;\n    expect(obj).to.have.nested.property('b.\\u8210', 'ok');\n    oldVal = objectPath.ensureExists(obj, ['b','dot.dot'], 'ok');\n    expect(oldVal).to.not.exist;\n    expect(objectPath.get(obj, ['b','dot.dot'])).to.be.equal('ok');\n  });\n\n\n  it('should return the object if path is empty', function() {\n    var obj = getTestObj();\n    expect(objectPath.ensureExists(obj, [], 'test')).to.have.property('a', 'b');\n  });\n\n  it('Issue #26', function() {\n    var any = {};\n    objectPath.ensureExists(any, ['1','1'], {});\n    expect(any).to.be.an('object');\n    expect(any[1]).to.be.an('object');\n    expect(any[1][1]).to.be.an('object');\n  });\n});\n\ndescribe('coalesce', function(){\n  it('should return the first non-undefined value', function(){\n    var obj = {\n      should: {have: 'prop'}\n    };\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      ['might','not','exist'],\n      'should.have'\n    ])).to.equal('prop');\n  });\n\n  it('should work with falsy values (null, 0, \\'\\', false)', function(){\n    var obj = {\n      is: {\n        false: false,\n        null: null,\n        empty: '',\n        zero: 0\n      }\n    };\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.zero'\n    ])).to.equal(0);\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.false'\n    ])).to.equal(false);\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.null'\n    ])).to.equal(null);\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.empty'\n    ])).to.equal('');\n  });\n\n  it('returns defaultValue if no paths found', function(){\n    var obj = {\n      doesnt: 'matter'\n    };\n\n    expect(objectPath.coalesce(obj, ['some.inexistant','path',['on','object']], 'false')).to.equal('false');\n  });\n\n  it('works with unicode and dot keys', function(){\n    var obj = {\n      '\\u7591': true,\n      'dot.dot': false\n    };\n\n    expect(objectPath.coalesce(obj, ['1', '\\u7591', 'a.b'])).to.equal(true);\n    expect(objectPath.coalesce(obj, ['1', ['dot.dot'], '\\u7591'])).to.equal(false);\n  });\n});\n\ndescribe('empty', function(){\n  it('should ignore invalid arguments safely', function(){\n    var obj = {};\n    expect(objectPath.empty()).to.equal(void 0);\n    expect(objectPath.empty(obj, 'path')).to.equal(void 0);\n    expect(objectPath.empty(obj, '')).to.equal(void 0);\n\n    obj.path = true;\n\n    expect(objectPath.empty(obj, 'inexistant')).to.equal(void 0);\n\n    expect(objectPath.empty(null, 'path')).to.equal(void 0);\n    expect(objectPath.empty(void 0, 'path')).to.equal(void 0);\n  });\n\n  it('should empty each path according to their types', function(){\n    function Instance(){\n      this.notOwn = true;\n    }\n\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.test = function(){};\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.arr = [];\n\n    var\n      obj = {\n        string: 'some string',\n        array: ['some','array',[1,2,3]],\n        number: 21,\n        boolean: true,\n        object: {\n          some:'property',\n          sub: {\n            'property': true\n          },\n          nullProp: null,\n          undefinedProp: void 0\n        },\n        instance: new Instance()\n      };\n\n    /*istanbul ignore next: not part of code */\n    obj['function'] = function(){};\n\n    objectPath.empty(obj, ['array','2']);\n    expect(obj.array[2]).to.deep.equal([]);\n\n    objectPath.empty(obj, 'object.sub');\n    expect(obj.object.sub).to.deep.equal({});\n\n    objectPath.empty(obj, 'object.nullProp');\n    expect(obj.object.nullProp).to.equal(null);\n\n    objectPath.empty(obj, 'object.undefinedProp');\n    expect(obj.object.undefinedProp).to.equal(void 0);\n    expect(obj.object).to.have.property('undefinedProp');\n\n    objectPath.empty(obj, 'object.notAProp');\n    expect(obj.object.notAProp).to.equal(void 0);\n    expect(obj.object).to.not.have.property('notAProp');\n\n    objectPath.empty(obj, 'instance.test');\n    //instance.test is not own property, so it shouldn't be emptied\n    expect(obj.instance.test).to.be.a('function');\n    expect(Instance.prototype.test).to.be.a('function');\n\n    objectPath.empty(obj, 'string');\n    objectPath.empty(obj, 'number');\n    objectPath.empty(obj, 'boolean');\n    objectPath.empty(obj, 'function');\n    objectPath.empty(obj, 'array');\n    objectPath.empty(obj, 'object');\n    objectPath.empty(obj, 'instance');\n\n    expect(obj.string).to.equal('');\n    expect(obj.array).to.deep.equal([]);\n    expect(obj.number).to.equal(0);\n    expect(obj.boolean).to.equal(false);\n    expect(obj.object).to.deep.equal({});\n    expect(obj.instance.notOwn).to.be.an('undefined');\n    expect(obj.instance.arr).to.be.an('array');\n    expect(obj['function']).to.equal(null);\n  });\n});\n\ndescribe('del', function(){\n  it('should work with number path', function(){\n    var obj = getTestObj();\n    objectPath.del(obj.b.d, 1);\n    expect(obj.b.d).to.deep.equal(['a']);\n  });\n\n  it('should remove null and undefined props (but not explode on nested)', function(){\n    var obj = { nullProp: null, undefinedProp: void 0 };\n    expect(obj).to.have.property('nullProp');\n    expect(obj).to.have.property('undefinedProp');\n\n    objectPath.del(obj, 'nullProp.foo');\n    objectPath.del(obj, 'undefinedProp.bar');\n    expect(obj).to.have.property('nullProp');\n    expect(obj).to.have.property('undefinedProp');\n    expect(obj).to.deep.equal({ nullProp: null, undefinedProp: void 0 });\n\n    objectPath.del(obj, 'nullProp');\n    objectPath.del(obj, 'undefinedProp');\n    expect(obj).to.not.have.property('nullProp');\n    expect(obj).to.not.have.property('undefinedProp');\n    expect(obj).to.deep.equal({});\n  });\n\n  it('should delete deep paths', function(){\n    var obj = getTestObj();\n\n    expect(objectPath.del(obj)).to.be.equal(obj);\n\n    objectPath.set(obj, 'b.g.1.0', 'test');\n    objectPath.set(obj, 'b.g.1.1', 'test');\n    objectPath.set(obj, 'b.h.az', 'test');\n    objectPath.set(obj, 'b.\\ubeef', 'test');\n    objectPath.set(obj, ['b','dot.dot'], 'test');\n\n    expect(obj).to.have.nested.property('b.g.1.0','test');\n    expect(obj).to.have.nested.property('b.g.1.1','test');\n    expect(obj).to.have.nested.property('b.h.az','test');\n    expect(obj).to.have.nested.property('b.\\ubeef','test');\n\n    objectPath.del(obj, 'b.h.az');\n    expect(obj).to.not.have.nested.property('b.h.az');\n    expect(obj).to.have.nested.property('b.h');\n\n    objectPath.del(obj, 'b.g.1.1');\n    expect(obj).to.not.have.nested.property('b.g.1.1');\n    expect(obj).to.have.nested.property('b.g.1.0','test');\n\n    objectPath.del(obj, 'b.\\ubeef');\n    expect(obj).to.not.have.nested.property('b.\\ubeef');\n\n    objectPath.del(obj, ['b','dot.dot']);\n    expect(objectPath.get(obj, ['b','dot.dot'])).to.be.equal(void 0);\n\n    objectPath.del(obj, ['b','g','1','0']);\n    expect(obj).to.not.have.nested.property('b.g.1.0');\n    expect(obj).to.have.nested.property('b.g.1');\n\n    expect(objectPath.del(obj, ['b'])).to.not.have.nested.property('b.g');\n    expect(obj).to.be.deep.equal({'a':'b'});\n  });\n\n  it('should remove items from existing array', function(){\n    var obj = getTestObj();\n\n    objectPath.del(obj, 'b.d.0');\n    expect(obj.b.d).to.have.length(1);\n    expect(obj.b.d).to.be.deep.equal(['b']);\n\n    objectPath.del(obj, 'b.d.0');\n    expect(obj.b.d).to.have.length(0);\n    expect(obj.b.d).to.be.deep.equal([]);\n  });\n});\n\ndescribe('insert', function(){\n  it('should insert value into existing array', function(){\n    var obj = getTestObj();\n\n    objectPath.insert(obj, 'b.c', 'asdf');\n    expect(obj).to.have.nested.property('b.c.0', 'asdf');\n    expect(obj).to.not.have.nested.property('b.c.1');\n  });\n\n  it('should create intermediary array', function(){\n    var obj = getTestObj();\n\n    objectPath.insert(obj, 'b.c.0', 'asdf');\n    expect(obj).to.have.nested.property('b.c.0.0', 'asdf');\n  });\n\n  it('should insert in another index', function(){\n    var obj = getTestObj();\n\n    objectPath.insert(obj, 'b.d', 'asdf', 1);\n    expect(obj).to.have.nested.property('b.d.1', 'asdf');\n    expect(obj).to.have.nested.property('b.d.0', 'a');\n    expect(obj).to.have.nested.property('b.d.2', 'b');\n  });\n\n  it('should handle sparse array', function(){\n    var obj = getTestObj();\n    obj.b.d = new Array(4);\n    obj.b.d[0] = 'a';\n    obj.b.d[1] = 'b';\n\n    objectPath.insert(obj, 'b.d', 'asdf', 3);\n    expect(obj.b.d).to.have.members([\n      'a',\n      'b',\n      ,\n      ,\n      'asdf'\n    ]);\n  });\n});\n\ndescribe('has', function () {\n  it('should return false for empty object', function () {\n    expect(objectPath.has({}, 'a')).to.be.equal(false);\n  });\n\n  it('should handle empty paths properly', function () {\n    var obj = getTestObj();\n    expect(objectPath.has(obj, '')).to.be.equal(false);\n    expect(objectPath.has(obj, [''])).to.be.equal(false);\n    obj[''] = 1\n    expect(objectPath.has(obj, '')).to.be.equal(true);\n    expect(objectPath.has(obj, [''])).to.be.equal(true);\n\n    expect(objectPath.has(obj, [])).to.be.equal(true);\n    expect(objectPath.has(null, [])).to.be.equal(false);\n  });\n\n  it('should test under shallow object', function() {\n    var obj = getTestObj();\n    expect(objectPath.has(obj, 'a')).to.be.equal(true);\n    expect(objectPath.has(obj, ['a'])).to.be.equal(true);\n    expect(objectPath.has(obj, 'z')).to.be.equal(false);\n    expect(objectPath.has(obj, ['z'])).to.be.equal(false);\n  });\n\n  it('should work with number path', function() {\n    var obj = getTestObj();\n    expect(objectPath.has(obj.b.d, 0)).to.be.equal(true);\n    expect(objectPath.has(obj.b, 0)).to.be.equal(false);\n    expect(objectPath.has(obj.b.d, 10)).to.be.equal(false);\n    expect(objectPath.has(obj.b, 10)).to.be.equal(false);\n  });\n\n  it('should test under deep object', function() {\n    var obj = getTestObj();\n    expect(objectPath.has(obj, 'b.f')).to.be.equal(true);\n    expect(objectPath.has(obj, ['b','f'])).to.be.equal(true);\n    expect(objectPath.has(obj, 'b.g')).to.be.equal(false);\n    expect(objectPath.has(obj, ['b','g'])).to.be.equal(false);\n  });\n\n  it('should test value under array', function() {\n    var obj = {\n      b: ['a']\n    };\n    obj.b[3] = {o: 'a'}\n    expect(objectPath.has(obj, 'b.0')).to.be.equal(true);\n    expect(objectPath.has(obj, 'b.1')).to.be.equal(true);\n    expect(objectPath.has(obj, 'b.3.o')).to.be.equal(true);\n    expect(objectPath.has(obj, 'b.3.qwe')).to.be.equal(false);\n    expect(objectPath.has(obj, 'b.4')).to.be.equal(false);\n  });\n\n  it('should test the value under array deep', function() {\n    var obj = getTestObj();\n    expect(objectPath.has(obj, 'b.e.1.f')).to.be.equal(true);\n    expect(objectPath.has(obj, ['b','e',1,'f'])).to.be.equal(true);\n    expect(objectPath.has(obj, 'b.e.1.f.g.h.i')).to.be.equal(false);\n    expect(objectPath.has(obj, ['b','e',1,'f','g','h','i'])).to.be.equal(false);\n  });\n\n  it('should test the value under integer-like key', function() {\n    var obj = { '1a': 'foo' };\n    expect(objectPath.has(obj, '1a')).to.be.equal(true);\n    expect(objectPath.has(obj, ['1a'])).to.be.equal(true);\n  });\n\n  it('should distinct nonexistent key and key = undefined', function() {\n    var obj = {};\n    expect(objectPath.has(obj, 'key')).to.be.equal(false);\n\n    obj.key = undefined;\n    expect(objectPath.has(obj, 'key')).to.be.equal(true);\n  });\n\n  it('should work with deep undefined/null values', function() {\n    var obj = {};\n    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false);\n\n    obj.missing = null;\n    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false);\n\n    obj.sparseArray = [1, undefined, 3]\n    expect(objectPath.has(obj, 'sparseArray.1.test')).to.be.equal(false);\n  });\n});\n\n\n\ndescribe('bind object', function () {\n  // just get one scenario from each feature, so whole functionality is proxied well\n  it('should return the value under shallow object', function() {\n    var obj = getTestObj();\n    var model = objectPath(obj);\n    expect(model.get('a')).to.be.equal('b');\n    expect(model.get(['a'])).to.be.equal('b');\n  });\n\n  it('should set value under shallow object', function() {\n    var obj = getTestObj();\n    var model = objectPath(obj);\n    model.set('c', {m: 'o'});\n    expect(obj).to.have.nested.property('c.m', 'o');\n    obj = getTestObj();\n    model = objectPath(obj);\n    model.set(['c'], {m: 'o'});\n    expect(obj).to.have.nested.property('c.m', 'o');\n  });\n\n  it('should push value to existing array', function() {\n    var obj = getTestObj();\n    var model = objectPath(obj);\n    model.push('b.c', 'l');\n    expect(obj).to.have.nested.property('b.c.0', 'l');\n    obj = getTestObj();\n    model = objectPath(obj);\n    model.push(['b','c'], 'l');\n    expect(obj).to.have.nested.property('b.c.0', 'l');\n  });\n\n  it('should create the path if it does not exists', function() {\n    var obj = getTestObj();\n    var model = objectPath(obj);\n    var oldVal = model.ensureExists('b.g.1.l', 'test');\n    expect(oldVal).to.not.exist;\n    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n    oldVal = model.ensureExists('b.g.1.l', 'test1');\n    expect(oldVal).to.be.equal('test');\n    expect(obj).to.have.nested.property('b.g.1.l', 'test');\n  });\n\n  it('should return the first non-undefined value', function(){\n    var obj = {\n      should: {have: 'prop'}\n    };\n    var model = objectPath(obj);\n\n    expect(model.coalesce([\n      'doesnt.exist',\n      ['might','not','exist'],\n      'should.have'\n    ])).to.equal('prop');\n  });\n\n  it('should empty each path according to their types', function(){\n    function Instance(){\n      this.notOwn = true;\n    }\n\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.test = function(){};\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.arr = [];\n\n    var\n      obj = {\n        string: 'some string',\n        array: ['some','array',[1,2,3]],\n        number: 21,\n        boolean: true,\n        object: {\n          some:'property',\n          sub: {\n            'property': true\n          }\n        },\n        instance: new Instance()\n      };\n\n    /*istanbul ignore next: not part of code */\n    obj['function'] = function(){};\n\n    var model = objectPath(obj);\n\n    model.empty(['array','2']);\n    expect(obj.array[2]).to.deep.equal([]);\n\n    model.empty('object.sub');\n    expect(obj.object.sub).to.deep.equal({});\n\n    model.empty('instance.test');\n    //instance.test is not own property so it shouldn't be emptied\n    expect(obj.instance.test).to.be.a('function');\n    expect(Instance.prototype.test).to.be.a('function');\n\n    model.empty('string');\n    model.empty('number');\n    model.empty('boolean');\n    model.empty('function');\n    model.empty('array');\n    model.empty('object');\n    model.empty('instance');\n\n    expect(obj.string).to.equal('');\n    expect(obj.array).to.deep.equal([]);\n    expect(obj.number).to.equal(0);\n    expect(obj.boolean).to.equal(false);\n    expect(obj.object).to.deep.equal({});\n    expect(obj.instance.notOwn).to.be.an('undefined');\n    expect(obj.instance.arr).to.be.an('array');\n    expect(obj['function']).to.equal(null);\n  });\n\n  it('should delete deep paths', function(){\n    var obj = getTestObj();\n    var model = objectPath(obj);\n\n    expect(model.del()).to.be.equal(obj);\n\n    model.set('b.g.1.0', 'test');\n    model.set('b.g.1.1', 'test');\n    model.set('b.h.az', 'test');\n\n    expect(obj).to.have.nested.property('b.g.1.0','test');\n    expect(obj).to.have.nested.property('b.g.1.1','test');\n    expect(obj).to.have.nested.property('b.h.az','test');\n\n    model.del('b.h.az');\n    expect(obj).to.not.have.nested.property('b.h.az');\n    expect(obj).to.have.nested.property('b.h');\n\n    model.del('b.g.1.1');\n    expect(obj).to.not.have.nested.property('b.g.1.1');\n    expect(obj).to.have.nested.property('b.g.1.0','test');\n\n    model.del(['b','g','1','0']);\n    expect(obj).to.not.have.nested.property('b.g.1.0');\n    expect(obj).to.have.nested.property('b.g.1');\n\n    expect(model.del(['b'])).to.not.have.nested.property('b.g');\n    expect(obj).to.be.deep.equal({'a':'b'});\n  });\n\n  it('should insert value into existing array', function(){\n    var obj = getTestObj();\n    var model = objectPath(obj);\n\n    model.insert('b.c', 'asdf');\n    expect(obj).to.have.nested.property('b.c.0', 'asdf');\n    expect(obj).to.not.have.nested.property('b.c.1');\n  });\n\n  it('should test under shallow object', function() {\n    var obj = getTestObj();\n    var model = objectPath(obj);\n\n    expect(model.has('a')).to.be.equal(true);\n    expect(model.has(['a'])).to.be.equal(true);\n    expect(model.has('z')).to.be.equal(false);\n    expect(model.has(['z'])).to.be.equal(false);\n  });\n});\n\ndescribe('Don\\'t access not own properties [default]', function () {\n  it('should not get a not own property', function() {\n    var Obj = function() {};\n    Obj.prototype.notOwn = {a: 'a'};\n    var obj = new Obj();\n\n    expect(objectPath.get(obj, 'notOwn')).to.be.undefined\n  });\n\n  it('should set a not own property on the instance (not the prototype)', function() {\n    var proto = {\n      notOwn: {}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.set(obj, 'notOwn.test', 'a');\n    expect(obj.notOwn.test).to.be.equal('a');\n    expect(proto.notOwn).to.be.deep.equal({});\n  });\n\n  it('has should return false on a not own property', function() {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n\n    expect(objectPath.has(obj, 'notOwn')).to.be.false;\n    expect(objectPath.has(obj, 'notOwn.a')).to.be.false;\n  });\n\n  it('empty should not empty on a not own property', function() {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto);\n\n    objectPath.empty(obj, 'notOwn');\n    expect(proto.notOwn).to.be.deep.equal({a: 'a'});\n    expect(obj.notOwn).to.be.deep.equal({a: 'a'});\n  });\n\n  it('del should not delete not own property', function() {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto);\n\n    objectPath.del(obj, 'notOwn.a');\n    expect(proto.notOwn).to.be.deep.equal({a: 'a'});\n    //expect(obj.notOwn).to.be.deep.equal({a: 'a'});\n    //objectPath.del(obj, 'notOwn');\n    //expect(proto).to.be.deep.equal({notOwn: {a: 'a'}});\n    //expect(obj).to.be.deep.equal({notOwn: {a: 'a'}});\n  });\n});\n\ndescribe('Access own properties [optional]', function () {\n  it('should get a not own property', function() {\n    var Obj = function() {};\n    Obj.prototype.notOwn = {a: 'a'};\n    var obj = new Obj();\n\n    expect(objectPath.withInheritedProps.get(obj, 'notOwn.a')).to.be.equal('a')\n  });\n\n  it('should set a deep not own property on the prototype (if exists)', function() {\n    var proto = {\n      notOwn: {}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.withInheritedProps.set(obj, 'notOwn.test', 'a');\n    expect(obj.notOwn.test).to.be.equal('a');\n    expect(proto.notOwn).to.be.deep.equal({test: 'a'});\n  });\n\n\n  it('has should return true on a not own property', function() {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n    expect(objectPath.withInheritedProps.has(obj, 'notOwn')).to.be.true;\n    expect(objectPath.withInheritedProps.has(obj, 'notOwn.a')).to.be.true;\n  });\n\n  it('empty should empty a not own property', function() {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto);\n\n    objectPath.withInheritedProps.empty(obj, 'notOwn');\n    expect(proto.notOwn).to.be.deep.equal({});\n    expect(obj.notOwn).to.be.deep.equal({});\n  });\n\n  it('del should delete a not own property', function() {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto);\n\n    objectPath.withInheritedProps.del(obj, 'notOwn.a');\n    expect(proto.notOwn).to.be.deep.equal({});\n    //expect(obj.notOwn).to.be.deep.equal({});\n    objectPath.withInheritedProps.del(obj, 'notOwn');\n    //expect(proto).to.be.deep.equal({notOwn: {}});\n    //expect(obj).to.be.deep.equal({notOwn: {}});\n  });\n});\n"], "fixing_code": ["(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function(){\n  'use strict';\n\n  var toStr = Object.prototype.toString;\n  function hasOwnProperty(obj, prop) {\n    if(obj == null) {\n      return false\n    }\n    //to handle objects with null prototypes (too edge case?)\n    return Object.prototype.hasOwnProperty.call(obj, prop)\n  }\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (typeof value !== 'string') {\n        for (var i in value) {\n            if (hasOwnProperty(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  var isArray = Array.isArray || function(obj){\n    /*istanbul ignore next:cant test*/\n    return toStr.call(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function factory(options) {\n    options = options || {}\n\n    var objectPath = function(obj) {\n      return Object.keys(objectPath).reduce(function(proxy, prop) {\n        if(prop === 'create') {\n          return proxy;\n        }\n\n        /*istanbul ignore else*/\n        if (typeof objectPath[prop] === 'function') {\n          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n        }\n\n        return proxy;\n      }, {});\n    };\n\n    var hasShallowProperty\n    if (options.includeInheritedProps) {\n      hasShallowProperty = function () {\n        return true\n      }\n    } else {\n      hasShallowProperty = function (obj, prop) {\n        return (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop)\n      }\n    }\n\n    function getShallowProperty(obj, prop) {\n      if (hasShallowProperty(obj, prop)) {\n        return obj[prop];\n      }\n    }\n\n    function set(obj, path, value, doNotReplace){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (typeof path === 'string') {\n        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n      }\n      var currentPath = path[0];\n      var currentValue = getShallowProperty(obj, currentPath);\n      if (options.includeInheritedProps && (currentPath === '__proto__' ||\n        (currentPath === 'constructor' && typeof currentValue === 'function'))) {\n        throw new Error('For security reasons, object\\'s magic properties cannot be set')\n      }\n      if (path.length === 1) {\n        if (currentValue === void 0 || !doNotReplace) {\n          obj[currentPath] = value;\n        }\n        return currentValue;\n      }\n\n      if (currentValue === void 0) {\n        //check if we assume an array\n        if(typeof path[1] === 'number') {\n          obj[currentPath] = [];\n        } else {\n          obj[currentPath] = {};\n        }\n      }\n\n      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n    }\n\n    objectPath.has = function (obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      } else if (typeof path === 'string') {\n        path = path.split('.');\n      }\n\n      if (!path || path.length === 0) {\n        return !!obj;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        var j = getKey(path[i]);\n\n        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n          obj = obj[j];\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    objectPath.ensureExists = function (obj, path, value){\n      return set(obj, path, value, true);\n    };\n\n    objectPath.set = function (obj, path, value, doNotReplace){\n      return set(obj, path, value, doNotReplace);\n    };\n\n    objectPath.insert = function (obj, path, value, at){\n      var arr = objectPath.get(obj, path);\n      at = ~~at;\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n      arr.splice(at, 0, value);\n    };\n\n    objectPath.empty = function(obj, path) {\n      if (isEmpty(path)) {\n        return void 0;\n      }\n      if (obj == null) {\n        return void 0;\n      }\n\n      var value, i;\n      if (!(value = objectPath.get(obj, path))) {\n        return void 0;\n      }\n\n      if (typeof value === 'string') {\n        return objectPath.set(obj, path, '');\n      } else if (isBoolean(value)) {\n        return objectPath.set(obj, path, false);\n      } else if (typeof value === 'number') {\n        return objectPath.set(obj, path, 0);\n      } else if (isArray(value)) {\n        value.length = 0;\n      } else if (isObject(value)) {\n        for (i in value) {\n          if (hasShallowProperty(value, i)) {\n            delete value[i];\n          }\n        }\n      } else {\n        return objectPath.set(obj, path, null);\n      }\n    };\n\n    objectPath.push = function (obj, path /*, values */){\n      var arr = objectPath.get(obj, path);\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n\n      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n    };\n\n    objectPath.coalesce = function (obj, paths, defaultValue) {\n      var value;\n\n      for (var i = 0, len = paths.length; i < len; i++) {\n        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n          return value;\n        }\n      }\n\n      return defaultValue;\n    };\n\n    objectPath.get = function (obj, path, defaultValue){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (obj == null) {\n        return defaultValue;\n      }\n      if (typeof path === 'string') {\n        return objectPath.get(obj, path.split('.'), defaultValue);\n      }\n\n      var currentPath = getKey(path[0]);\n      var nextObj = getShallowProperty(obj, currentPath)\n      if (nextObj === void 0) {\n        return defaultValue;\n      }\n\n      if (path.length === 1) {\n        return nextObj;\n      }\n\n      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n    };\n\n    objectPath.del = function del(obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      }\n\n      if (obj == null) {\n        return obj;\n      }\n\n      if (isEmpty(path)) {\n        return obj;\n      }\n      if(typeof path === 'string') {\n        return objectPath.del(obj, path.split('.'));\n      }\n\n      var currentPath = getKey(path[0]);\n      if (!hasShallowProperty(obj, currentPath)) {\n        return obj;\n      }\n\n      if(path.length === 1) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      } else {\n        return objectPath.del(obj[currentPath], path.slice(1));\n      }\n\n      return obj;\n    }\n\n    return objectPath;\n  }\n\n  var mod = factory();\n  mod.create = factory;\n  mod.withInheritedProps = factory({includeInheritedProps: true})\n  return mod;\n});\n", "'use strict'\nvar expect = require('chai').expect,\n  objectPath = require('./index.js')\n\n\nfunction getTestObj () {\n  return {\n    a: 'b',\n    b: {\n      c: [],\n      d: ['a', 'b'],\n      e: [{}, {f: 'g'}],\n      f: 'i'\n    }\n  }\n}\n\ndescribe('get', function () {\n  it('should return the value using unicode key', function () {\n    var obj = {\n      '15\\u00f8C': {\n        '3\\u0111': 1\n      }\n    }\n    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(1)\n    expect(objectPath.get(obj, ['15\\u00f8C', '3\\u0111'])).to.be.equal(1)\n  })\n\n  it('should return the value using dot in key', function () {\n    var obj = {\n      'a.b': {\n        'looks.like': 1\n      }\n    }\n    expect(objectPath.get(obj, 'a.b.looks.like')).to.be.equal(void 0)\n    expect(objectPath.get(obj, ['a.b', 'looks.like'])).to.be.equal(1)\n  })\n\n  it('should return the value under shallow object', function () {\n    var obj = getTestObj()\n    expect(objectPath.get(obj, 'a')).to.be.equal('b')\n    expect(objectPath.get(obj, ['a'])).to.be.equal('b')\n  })\n\n  it('should work with number path', function () {\n    var obj = getTestObj()\n    expect(objectPath.get(obj.b.d, 0)).to.be.equal('a')\n    expect(objectPath.get(obj.b, 0)).to.be.equal(void 0)\n  })\n\n  it('should return the value under deep object', function () {\n    var obj = getTestObj()\n    expect(objectPath.get(obj, 'b.f')).to.be.equal('i')\n    expect(objectPath.get(obj, ['b', 'f'])).to.be.equal('i')\n  })\n\n  it('should return the value under array', function () {\n    var obj = getTestObj()\n    expect(objectPath.get(obj, 'b.d.0')).to.be.equal('a')\n    expect(objectPath.get(obj, ['b', 'd', 0])).to.be.equal('a')\n  })\n\n  it('should return the value under array deep', function () {\n    var obj = getTestObj()\n    expect(objectPath.get(obj, 'b.e.1.f')).to.be.equal('g')\n    expect(objectPath.get(obj, ['b', 'e', 1, 'f'])).to.be.equal('g')\n  })\n\n  it('should return undefined for missing values under object', function () {\n    var obj = getTestObj()\n    expect(objectPath.get(obj, 'a.b')).to.not.exist\n    expect(objectPath.get(obj, ['a', 'b'])).to.not.exist\n  })\n\n  it('should return undefined for missing values under array', function () {\n    var obj = getTestObj()\n    expect(objectPath.get(obj, 'b.d.5')).to.not.exist\n    expect(objectPath.get(obj, ['b', 'd', '5'])).to.not.exist\n  })\n\n  it('should return the value under integer-like key', function () {\n    var obj = {'1a': 'foo'}\n    expect(objectPath.get(obj, '1a')).to.be.equal('foo')\n    expect(objectPath.get(obj, ['1a'])).to.be.equal('foo')\n  })\n\n  it('should return the default value when the key doesnt exist', function () {\n    var obj = {'1a': 'foo'}\n    expect(objectPath.get(obj, '1b', null)).to.be.equal(null)\n    expect(objectPath.get(obj, ['1b'], null)).to.be.equal(null)\n  })\n\n  it('should return the default value when path is empty', function () {\n    var obj = {'1a': 'foo'}\n    expect(objectPath.get(obj, '', null)).to.be.deep.equal({'1a': 'foo'})\n    expect(objectPath.get(obj, [])).to.be.deep.equal({'1a': 'foo'})\n    expect(objectPath.get({}, ['1'])).to.be.equal(undefined)\n  })\n\n  it('should return the default value when object is null or undefined', function () {\n    expect(objectPath.get(null, 'test', 'a')).to.be.deep.equal('a')\n    expect(objectPath.get(undefined, 'test', 'a')).to.be.deep.equal('a')\n  })\n\n  it(\n    'should not fail on an object with a null prototype',\n    function assertSuccessForObjWithNullProto () {\n      var foo = 'FOO'\n      var objWithNullProto = Object.create(null)\n      objWithNullProto.foo = foo\n      expect(objectPath.get(objWithNullProto, 'foo')).to.equal(foo)\n    }\n  )\n\n  it('should skip non own properties', function () {\n    var Base = function (enabled) {\n    }\n    Base.prototype = {\n      one: {\n        two: true\n      }\n    }\n    var Extended = function () {\n      Base.call(this, true)\n    }\n    Extended.prototype = Object.create(Base.prototype)\n\n    var extended = new Extended()\n\n    expect(objectPath.get(extended, ['one', 'two'])).to.be.equal(undefined)\n    extended.enabled = true\n\n    expect(objectPath.get(extended, 'enabled')).to.be.equal(true)\n    expect(objectPath.get(extended, 'one')).to.be.equal(undefined)\n  })\n})\n\n\ndescribe('set', function () {\n  it('should set the value using unicode key', function () {\n    var obj = {\n      '15\\u00f8C': {\n        '3\\u0111': 1\n      }\n    }\n    objectPath.set(obj, '15\\u00f8C.3\\u0111', 2)\n    expect(objectPath.get(obj, '15\\u00f8C.3\\u0111')).to.be.equal(2)\n    objectPath.set(obj, '15\\u00f8C.3\\u0111', 3)\n    expect(objectPath.get(obj, ['15\\u00f8C', '3\\u0111'])).to.be.equal(3)\n  })\n\n  it('should set the value using dot in key', function () {\n    var obj = {\n      'a.b': {\n        'looks.like': 1\n      }\n    }\n    objectPath.set(obj, ['a.b', 'looks.like'], 2)\n    expect(objectPath.get(obj, ['a.b', 'looks.like'])).to.be.equal(2)\n  })\n\n  it('should set value under shallow object', function () {\n    var obj = getTestObj()\n    objectPath.set(obj, 'c', {m: 'o'})\n    expect(obj).to.include.nested.property('c.m', 'o')\n    obj = getTestObj()\n    objectPath.set(obj, ['c'], {m: 'o'})\n    expect(obj).to.include.nested.property('c.m', 'o')\n  })\n\n  it('should set value using number path', function () {\n    var obj = getTestObj()\n    objectPath.set(obj.b.d, 0, 'o')\n    expect(obj).to.have.nested.property('b.d.0', 'o')\n  })\n\n  it('should set value under deep object', function () {\n    var obj = getTestObj()\n    objectPath.set(obj, 'b.c', 'o')\n    expect(obj).to.have.nested.property('b.c', 'o')\n    obj = getTestObj()\n    objectPath.set(obj, ['b', 'c'], 'o')\n    expect(obj).to.have.nested.property('b.c', 'o')\n  })\n\n  it('should set value under array', function () {\n    var obj = getTestObj()\n    objectPath.set(obj, 'b.e.1.g', 'f')\n    expect(obj).to.have.nested.property('b.e.1.g', 'f')\n    obj = getTestObj()\n    objectPath.set(obj, ['b', 'e', 1, 'g'], 'f')\n    expect(obj).to.have.nested.property('b.e.1.g', 'f')\n\n    obj = {}\n    objectPath.set(obj, 'b.0', 'a')\n    objectPath.set(obj, 'b.1', 'b')\n    expect(obj.b).to.be.deep.equal(['a', 'b'])\n  })\n\n  it('should create intermediate objects', function () {\n    var obj = getTestObj()\n    objectPath.set(obj, 'c.d.e.f', 'l')\n    expect(obj).to.have.nested.property('c.d.e.f', 'l')\n    obj = getTestObj()\n    objectPath.set(obj, ['c', 'd', 'e', 'f'], 'l')\n    expect(obj).to.have.nested.property('c.d.e.f', 'l')\n  })\n\n  it('should create intermediate arrays', function () {\n    var obj = getTestObj()\n    objectPath.set(obj, 'c.0.1.m', 'l')\n    expect(obj.c).to.be.an('array')\n    expect(obj.c[0]).to.be.an('array')\n    expect(obj).to.have.nested.property('c.0.1.m', 'l')\n    obj = getTestObj()\n    objectPath.set(obj, ['c', '0', 1, 'm'], 'l')\n    expect(obj.c).to.be.an('object')\n    expect(obj.c[0]).to.be.an('array')\n    expect(obj).to.have.nested.property('c.0.1.m', 'l')\n  })\n\n  it('should set value under integer-like key', function () {\n    var obj = getTestObj()\n    objectPath.set(obj, '1a', 'foo')\n    expect(obj).to.have.nested.property('1a', 'foo')\n    obj = getTestObj()\n    objectPath.set(obj, ['1a'], 'foo')\n    expect(obj).to.have.nested.property('1a', 'foo')\n  })\n\n  it('should set value under empty array', function () {\n    var obj = []\n    objectPath.set(obj, [0], 'foo')\n    expect(obj[0]).to.be.equal('foo')\n    obj = []\n    objectPath.set(obj, '0', 'foo')\n    expect(obj[0]).to.be.equal('foo')\n  })\n\n  it('[security] should not set magic properties in default mode', function () {\n    objectPath.set({}, '__proto__.injected', 'this is bad')\n    expect(Object.prototype.injected).to.be.undefined\n\n    function Clazz() {}\n    Clazz.prototype.test = 'original'\n\n    objectPath.set(new Clazz(), '__proto__.test', 'this is bad')\n    expect(Clazz.prototype.test).to.be.equal('original')\n\n    objectPath.set(new Clazz(), 'constructor.prototype.test', 'this is bad')\n    expect(Clazz.prototype.test).to.be.equal('original')\n  })\n\n  it('[security] should throw an exception if trying to set magic properties in inheritedProps mode', function () {\n    expect(function() {objectPath.withInheritedProps.set({}, '__proto__.injected', 'this is bad')})\n      .to.throw('For security reasons')\n    expect(Object.prototype.injected).to.be.undefined\n\n    function Clazz() {}\n    Clazz.prototype.test = 'original'\n\n    expect(function() {objectPath.withInheritedProps.set(new Clazz(), '__proto__.test', 'this is bad')})\n      .to.throw('For security reasons')\n    expect(Clazz.prototype.test).to.be.equal('original')\n\n    expect(function() {objectPath.withInheritedProps.set(new Clazz(), 'constructor.prototype.test', 'this is bad')})\n      .to.throw('For security reasons')\n    expect(Clazz.prototype.test).to.be.equal('original')\n\n    const obj = {}\n    expect(function() {objectPath.withInheritedProps.set(obj, 'constructor.prototype.injected', 'this is OK')})\n      .to.throw('For security reasons')\n    expect(Object.prototype.injected).to.be.undefined\n  })\n})\n\n\ndescribe('push', function () {\n  it('should push value to existing array using unicode key', function () {\n    var obj = getTestObj()\n    objectPath.push(obj, 'b.\\u1290c', 'l')\n    expect(obj).to.have.nested.property('b.\\u1290c.0', 'l')\n    objectPath.push(obj, ['b', '\\u1290c'], 'l')\n    expect(obj).to.have.nested.property('b.\\u1290c.1', 'l')\n  })\n\n  it('should push value to existing array using dot key', function () {\n    var obj = getTestObj()\n    objectPath.push(obj, ['b', 'z.d'], 'l')\n    expect(objectPath.get(obj, ['b', 'z.d', 0])).to.be.equal('l')\n  })\n\n  it('should push value to existing array', function () {\n    var obj = getTestObj()\n    objectPath.push(obj, 'b.c', 'l')\n    expect(obj).to.have.nested.property('b.c.0', 'l')\n    obj = getTestObj()\n    objectPath.push(obj, ['b', 'c'], 'l')\n    expect(obj).to.have.nested.property('b.c.0', 'l')\n  })\n\n  it('should push value to new array', function () {\n    var obj = getTestObj()\n    objectPath.push(obj, 'b.h', 'l')\n    expect(obj).to.have.nested.property('b.h.0', 'l')\n    obj = getTestObj()\n    objectPath.push(obj, ['b', 'h'], 'l')\n    expect(obj).to.have.nested.property('b.h.0', 'l')\n  })\n\n  it('should push value to existing array using number path', function () {\n    var obj = getTestObj()\n    objectPath.push(obj.b.e, 0, 'l')\n    expect(obj).to.have.nested.property('b.e.0.0', 'l')\n  })\n\n})\n\n\ndescribe('ensureExists', function () {\n  it('should create the path if it does not exists', function () {\n    var obj = getTestObj()\n    var oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test')\n    expect(oldVal).to.not.exist\n    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n    oldVal = objectPath.ensureExists(obj, 'b.g.1.l', 'test1')\n    expect(oldVal).to.be.equal('test')\n    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n    oldVal = objectPath.ensureExists(obj, 'b.\\u8210', 'ok')\n    expect(oldVal).to.not.exist\n    expect(obj).to.have.nested.property('b.\\u8210', 'ok')\n    oldVal = objectPath.ensureExists(obj, ['b', 'dot.dot'], 'ok')\n    expect(oldVal).to.not.exist\n    expect(objectPath.get(obj, ['b', 'dot.dot'])).to.be.equal('ok')\n  })\n\n\n  it('should return the object if path is empty', function () {\n    var obj = getTestObj()\n    expect(objectPath.ensureExists(obj, [], 'test')).to.have.property('a', 'b')\n  })\n\n  it('Issue #26', function () {\n    var any = {}\n    objectPath.ensureExists(any, ['1', '1'], {})\n    expect(any).to.be.an('object')\n    expect(any[1]).to.be.an('object')\n    expect(any[1][1]).to.be.an('object')\n  })\n})\n\ndescribe('coalesce', function () {\n  it('should return the first non-undefined value', function () {\n    var obj = {\n      should: {have: 'prop'}\n    }\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      ['might', 'not', 'exist'],\n      'should.have'\n    ])).to.equal('prop')\n  })\n\n  it('should work with falsy values (null, 0, \\'\\', false)', function () {\n    var obj = {\n      is: {\n        false: false,\n        null: null,\n        empty: '',\n        zero: 0\n      }\n    }\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.zero'\n    ])).to.equal(0)\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.false'\n    ])).to.equal(false)\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.null'\n    ])).to.equal(null)\n\n    expect(objectPath.coalesce(obj, [\n      'doesnt.exist',\n      'is.empty'\n    ])).to.equal('')\n  })\n\n  it('returns defaultValue if no paths found', function () {\n    var obj = {\n      doesnt: 'matter'\n    }\n\n    expect(objectPath.coalesce(obj, ['some.inexistant', 'path', ['on', 'object']], 'false')).to.equal('false')\n  })\n\n  it('works with unicode and dot keys', function () {\n    var obj = {\n      '\\u7591': true,\n      'dot.dot': false\n    }\n\n    expect(objectPath.coalesce(obj, ['1', '\\u7591', 'a.b'])).to.equal(true)\n    expect(objectPath.coalesce(obj, ['1', ['dot.dot'], '\\u7591'])).to.equal(false)\n  })\n})\n\ndescribe('empty', function () {\n  it('should ignore invalid arguments safely', function () {\n    var obj = {}\n    expect(objectPath.empty()).to.equal(void 0)\n    expect(objectPath.empty(obj, 'path')).to.equal(void 0)\n    expect(objectPath.empty(obj, '')).to.equal(void 0)\n\n    obj.path = true\n\n    expect(objectPath.empty(obj, 'inexistant')).to.equal(void 0)\n\n    expect(objectPath.empty(null, 'path')).to.equal(void 0)\n    expect(objectPath.empty(void 0, 'path')).to.equal(void 0)\n  })\n\n  it('should empty each path according to their types', function () {\n    function Instance () {\n      this.notOwn = true\n    }\n\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.test = function () {\n    }\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.arr = []\n\n    var\n      obj = {\n        string: 'some string',\n        array: ['some', 'array', [1, 2, 3]],\n        number: 21,\n        boolean: true,\n        object: {\n          some: 'property',\n          sub: {\n            'property': true\n          },\n          nullProp: null,\n          undefinedProp: void 0\n        },\n        instance: new Instance()\n      }\n\n    /*istanbul ignore next: not part of code */\n    obj['function'] = function () {\n    }\n\n    objectPath.empty(obj, ['array', '2'])\n    expect(obj.array[2]).to.deep.equal([])\n\n    objectPath.empty(obj, 'object.sub')\n    expect(obj.object.sub).to.deep.equal({})\n\n    objectPath.empty(obj, 'object.nullProp')\n    expect(obj.object.nullProp).to.equal(null)\n\n    objectPath.empty(obj, 'object.undefinedProp')\n    expect(obj.object.undefinedProp).to.equal(void 0)\n    expect(obj.object).to.have.property('undefinedProp')\n\n    objectPath.empty(obj, 'object.notAProp')\n    expect(obj.object.notAProp).to.equal(void 0)\n    expect(obj.object).to.not.have.property('notAProp')\n\n    objectPath.empty(obj, 'instance.test')\n    //instance.test is not own property, so it shouldn't be emptied\n    expect(obj.instance.test).to.be.a('function')\n    expect(Instance.prototype.test).to.be.a('function')\n\n    objectPath.empty(obj, 'string')\n    objectPath.empty(obj, 'number')\n    objectPath.empty(obj, 'boolean')\n    objectPath.empty(obj, 'function')\n    objectPath.empty(obj, 'array')\n    objectPath.empty(obj, 'object')\n    objectPath.empty(obj, 'instance')\n\n    expect(obj.string).to.equal('')\n    expect(obj.array).to.deep.equal([])\n    expect(obj.number).to.equal(0)\n    expect(obj.boolean).to.equal(false)\n    expect(obj.object).to.deep.equal({})\n    expect(obj.instance.notOwn).to.be.an('undefined')\n    expect(obj.instance.arr).to.be.an('array')\n    expect(obj['function']).to.equal(null)\n  })\n})\n\ndescribe('del', function () {\n  it('should work with number path', function () {\n    var obj = getTestObj()\n    objectPath.del(obj.b.d, 1)\n    expect(obj.b.d).to.deep.equal(['a'])\n  })\n\n  it('should remove null and undefined props (but not explode on nested)', function () {\n    var obj = {nullProp: null, undefinedProp: void 0}\n    expect(obj).to.have.property('nullProp')\n    expect(obj).to.have.property('undefinedProp')\n\n    objectPath.del(obj, 'nullProp.foo')\n    objectPath.del(obj, 'undefinedProp.bar')\n    expect(obj).to.have.property('nullProp')\n    expect(obj).to.have.property('undefinedProp')\n    expect(obj).to.deep.equal({nullProp: null, undefinedProp: void 0})\n\n    objectPath.del(obj, 'nullProp')\n    objectPath.del(obj, 'undefinedProp')\n    expect(obj).to.not.have.property('nullProp')\n    expect(obj).to.not.have.property('undefinedProp')\n    expect(obj).to.deep.equal({})\n  })\n\n  it('should delete deep paths', function () {\n    var obj = getTestObj()\n\n    expect(objectPath.del(obj)).to.be.equal(obj)\n\n    objectPath.set(obj, 'b.g.1.0', 'test')\n    objectPath.set(obj, 'b.g.1.1', 'test')\n    objectPath.set(obj, 'b.h.az', 'test')\n    objectPath.set(obj, 'b.\\ubeef', 'test')\n    objectPath.set(obj, ['b', 'dot.dot'], 'test')\n\n    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n    expect(obj).to.have.nested.property('b.g.1.1', 'test')\n    expect(obj).to.have.nested.property('b.h.az', 'test')\n    expect(obj).to.have.nested.property('b.\\ubeef', 'test')\n\n    objectPath.del(obj, 'b.h.az')\n    expect(obj).to.not.have.nested.property('b.h.az')\n    expect(obj).to.have.nested.property('b.h')\n\n    objectPath.del(obj, 'b.g.1.1')\n    expect(obj).to.not.have.nested.property('b.g.1.1')\n    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n\n    objectPath.del(obj, 'b.\\ubeef')\n    expect(obj).to.not.have.nested.property('b.\\ubeef')\n\n    objectPath.del(obj, ['b', 'dot.dot'])\n    expect(objectPath.get(obj, ['b', 'dot.dot'])).to.be.equal(void 0)\n\n    objectPath.del(obj, ['b', 'g', '1', '0'])\n    expect(obj).to.not.have.nested.property('b.g.1.0')\n    expect(obj).to.have.nested.property('b.g.1')\n\n    expect(objectPath.del(obj, ['b'])).to.not.have.nested.property('b.g')\n    expect(obj).to.be.deep.equal({'a': 'b'})\n  })\n\n  it('should remove items from existing array', function () {\n    var obj = getTestObj()\n\n    objectPath.del(obj, 'b.d.0')\n    expect(obj.b.d).to.have.length(1)\n    expect(obj.b.d).to.be.deep.equal(['b'])\n\n    objectPath.del(obj, 'b.d.0')\n    expect(obj.b.d).to.have.length(0)\n    expect(obj.b.d).to.be.deep.equal([])\n  })\n})\n\ndescribe('insert', function () {\n  it('should insert value into existing array', function () {\n    var obj = getTestObj()\n\n    objectPath.insert(obj, 'b.c', 'asdf')\n    expect(obj).to.have.nested.property('b.c.0', 'asdf')\n    expect(obj).to.not.have.nested.property('b.c.1')\n  })\n\n  it('should create intermediary array', function () {\n    var obj = getTestObj()\n\n    objectPath.insert(obj, 'b.c.0', 'asdf')\n    expect(obj).to.have.nested.property('b.c.0.0', 'asdf')\n  })\n\n  it('should insert in another index', function () {\n    var obj = getTestObj()\n\n    objectPath.insert(obj, 'b.d', 'asdf', 1)\n    expect(obj).to.have.nested.property('b.d.1', 'asdf')\n    expect(obj).to.have.nested.property('b.d.0', 'a')\n    expect(obj).to.have.nested.property('b.d.2', 'b')\n  })\n\n  it('should handle sparse array', function () {\n    var obj = getTestObj()\n    obj.b.d = new Array(4)\n    obj.b.d[0] = 'a'\n    obj.b.d[1] = 'b'\n\n    objectPath.insert(obj, 'b.d', 'asdf', 3)\n    expect(obj.b.d).to.have.members([\n      'a',\n      'b',\n      ,\n      ,\n      'asdf'\n    ])\n  })\n})\n\ndescribe('has', function () {\n  it('should return false for empty object', function () {\n    expect(objectPath.has({}, 'a')).to.be.equal(false)\n  })\n\n  it('should handle empty paths properly', function () {\n    var obj = getTestObj()\n    expect(objectPath.has(obj, '')).to.be.equal(false)\n    expect(objectPath.has(obj, [''])).to.be.equal(false)\n    obj[''] = 1\n    expect(objectPath.has(obj, '')).to.be.equal(true)\n    expect(objectPath.has(obj, [''])).to.be.equal(true)\n\n    expect(objectPath.has(obj, [])).to.be.equal(true)\n    expect(objectPath.has(null, [])).to.be.equal(false)\n  })\n\n  it('should test under shallow object', function () {\n    var obj = getTestObj()\n    expect(objectPath.has(obj, 'a')).to.be.equal(true)\n    expect(objectPath.has(obj, ['a'])).to.be.equal(true)\n    expect(objectPath.has(obj, 'z')).to.be.equal(false)\n    expect(objectPath.has(obj, ['z'])).to.be.equal(false)\n  })\n\n  it('should work with number path', function () {\n    var obj = getTestObj()\n    expect(objectPath.has(obj.b.d, 0)).to.be.equal(true)\n    expect(objectPath.has(obj.b, 0)).to.be.equal(false)\n    expect(objectPath.has(obj.b.d, 10)).to.be.equal(false)\n    expect(objectPath.has(obj.b, 10)).to.be.equal(false)\n  })\n\n  it('should test under deep object', function () {\n    var obj = getTestObj()\n    expect(objectPath.has(obj, 'b.f')).to.be.equal(true)\n    expect(objectPath.has(obj, ['b', 'f'])).to.be.equal(true)\n    expect(objectPath.has(obj, 'b.g')).to.be.equal(false)\n    expect(objectPath.has(obj, ['b', 'g'])).to.be.equal(false)\n  })\n\n  it('should test value under array', function () {\n    var obj = {\n      b: ['a']\n    }\n    obj.b[3] = {o: 'a'}\n    expect(objectPath.has(obj, 'b.0')).to.be.equal(true)\n    expect(objectPath.has(obj, 'b.1')).to.be.equal(true)\n    expect(objectPath.has(obj, 'b.3.o')).to.be.equal(true)\n    expect(objectPath.has(obj, 'b.3.qwe')).to.be.equal(false)\n    expect(objectPath.has(obj, 'b.4')).to.be.equal(false)\n  })\n\n  it('should test the value under array deep', function () {\n    var obj = getTestObj()\n    expect(objectPath.has(obj, 'b.e.1.f')).to.be.equal(true)\n    expect(objectPath.has(obj, ['b', 'e', 1, 'f'])).to.be.equal(true)\n    expect(objectPath.has(obj, 'b.e.1.f.g.h.i')).to.be.equal(false)\n    expect(objectPath.has(obj, ['b', 'e', 1, 'f', 'g', 'h', 'i'])).to.be.equal(false)\n  })\n\n  it('should test the value under integer-like key', function () {\n    var obj = {'1a': 'foo'}\n    expect(objectPath.has(obj, '1a')).to.be.equal(true)\n    expect(objectPath.has(obj, ['1a'])).to.be.equal(true)\n  })\n\n  it('should distinct nonexistent key and key = undefined', function () {\n    var obj = {}\n    expect(objectPath.has(obj, 'key')).to.be.equal(false)\n\n    obj.key = undefined\n    expect(objectPath.has(obj, 'key')).to.be.equal(true)\n  })\n\n  it('should work with deep undefined/null values', function () {\n    var obj = {}\n    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false)\n\n    obj.missing = null\n    expect(objectPath.has(obj, 'missing.test')).to.be.equal(false)\n\n    obj.sparseArray = [1, undefined, 3]\n    expect(objectPath.has(obj, 'sparseArray.1.test')).to.be.equal(false)\n  })\n})\n\n\ndescribe('bind object', function () {\n  // just get one scenario from each feature, so whole functionality is proxied well\n  it('should return the value under shallow object', function () {\n    var obj = getTestObj()\n    var model = objectPath(obj)\n    expect(model.get('a')).to.be.equal('b')\n    expect(model.get(['a'])).to.be.equal('b')\n  })\n\n  it('should set value under shallow object', function () {\n    var obj = getTestObj()\n    var model = objectPath(obj)\n    model.set('c', {m: 'o'})\n    expect(obj).to.have.nested.property('c.m', 'o')\n    obj = getTestObj()\n    model = objectPath(obj)\n    model.set(['c'], {m: 'o'})\n    expect(obj).to.have.nested.property('c.m', 'o')\n  })\n\n  it('should push value to existing array', function () {\n    var obj = getTestObj()\n    var model = objectPath(obj)\n    model.push('b.c', 'l')\n    expect(obj).to.have.nested.property('b.c.0', 'l')\n    obj = getTestObj()\n    model = objectPath(obj)\n    model.push(['b', 'c'], 'l')\n    expect(obj).to.have.nested.property('b.c.0', 'l')\n  })\n\n  it('should create the path if it does not exists', function () {\n    var obj = getTestObj()\n    var model = objectPath(obj)\n    var oldVal = model.ensureExists('b.g.1.l', 'test')\n    expect(oldVal).to.not.exist\n    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n    oldVal = model.ensureExists('b.g.1.l', 'test1')\n    expect(oldVal).to.be.equal('test')\n    expect(obj).to.have.nested.property('b.g.1.l', 'test')\n  })\n\n  it('should return the first non-undefined value', function () {\n    var obj = {\n      should: {have: 'prop'}\n    }\n    var model = objectPath(obj)\n\n    expect(model.coalesce([\n      'doesnt.exist',\n      ['might', 'not', 'exist'],\n      'should.have'\n    ])).to.equal('prop')\n  })\n\n  it('should empty each path according to their types', function () {\n    function Instance () {\n      this.notOwn = true\n    }\n\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.test = function () {\n    }\n    /*istanbul ignore next: not part of code */\n    Instance.prototype.arr = []\n\n    var\n      obj = {\n        string: 'some string',\n        array: ['some', 'array', [1, 2, 3]],\n        number: 21,\n        boolean: true,\n        object: {\n          some: 'property',\n          sub: {\n            'property': true\n          }\n        },\n        instance: new Instance()\n      }\n\n    /*istanbul ignore next: not part of code */\n    obj['function'] = function () {\n    }\n\n    var model = objectPath(obj)\n\n    model.empty(['array', '2'])\n    expect(obj.array[2]).to.deep.equal([])\n\n    model.empty('object.sub')\n    expect(obj.object.sub).to.deep.equal({})\n\n    model.empty('instance.test')\n    //instance.test is not own property so it shouldn't be emptied\n    expect(obj.instance.test).to.be.a('function')\n    expect(Instance.prototype.test).to.be.a('function')\n\n    model.empty('string')\n    model.empty('number')\n    model.empty('boolean')\n    model.empty('function')\n    model.empty('array')\n    model.empty('object')\n    model.empty('instance')\n\n    expect(obj.string).to.equal('')\n    expect(obj.array).to.deep.equal([])\n    expect(obj.number).to.equal(0)\n    expect(obj.boolean).to.equal(false)\n    expect(obj.object).to.deep.equal({})\n    expect(obj.instance.notOwn).to.be.an('undefined')\n    expect(obj.instance.arr).to.be.an('array')\n    expect(obj['function']).to.equal(null)\n  })\n\n  it('should delete deep paths', function () {\n    var obj = getTestObj()\n    var model = objectPath(obj)\n\n    expect(model.del()).to.be.equal(obj)\n\n    model.set('b.g.1.0', 'test')\n    model.set('b.g.1.1', 'test')\n    model.set('b.h.az', 'test')\n\n    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n    expect(obj).to.have.nested.property('b.g.1.1', 'test')\n    expect(obj).to.have.nested.property('b.h.az', 'test')\n\n    model.del('b.h.az')\n    expect(obj).to.not.have.nested.property('b.h.az')\n    expect(obj).to.have.nested.property('b.h')\n\n    model.del('b.g.1.1')\n    expect(obj).to.not.have.nested.property('b.g.1.1')\n    expect(obj).to.have.nested.property('b.g.1.0', 'test')\n\n    model.del(['b', 'g', '1', '0'])\n    expect(obj).to.not.have.nested.property('b.g.1.0')\n    expect(obj).to.have.nested.property('b.g.1')\n\n    expect(model.del(['b'])).to.not.have.nested.property('b.g')\n    expect(obj).to.be.deep.equal({'a': 'b'})\n  })\n\n  it('should insert value into existing array', function () {\n    var obj = getTestObj()\n    var model = objectPath(obj)\n\n    model.insert('b.c', 'asdf')\n    expect(obj).to.have.nested.property('b.c.0', 'asdf')\n    expect(obj).to.not.have.nested.property('b.c.1')\n  })\n\n  it('should test under shallow object', function () {\n    var obj = getTestObj()\n    var model = objectPath(obj)\n\n    expect(model.has('a')).to.be.equal(true)\n    expect(model.has(['a'])).to.be.equal(true)\n    expect(model.has('z')).to.be.equal(false)\n    expect(model.has(['z'])).to.be.equal(false)\n  })\n})\n\ndescribe('Don\\'t access not own properties [default]', function () {\n  it('should not get a not own property', function () {\n    var Obj = function () {\n    }\n    Obj.prototype.notOwn = {a: 'a'}\n    var obj = new Obj()\n\n    expect(objectPath.get(obj, 'notOwn')).to.be.undefined\n  })\n\n  it('should set a not own property on the instance (not the prototype)', function () {\n    var proto = {\n      notOwn: {}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.set(obj, 'notOwn.test', 'a')\n    expect(obj.notOwn.test).to.be.equal('a')\n    expect(proto.notOwn).to.be.deep.equal({})\n  })\n\n  it('has should return false on a not own property', function () {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n\n    expect(objectPath.has(obj, 'notOwn')).to.be.false\n    expect(objectPath.has(obj, 'notOwn.a')).to.be.false\n  })\n\n  it('empty should not empty on a not own property', function () {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.empty(obj, 'notOwn')\n    expect(proto.notOwn).to.be.deep.equal({a: 'a'})\n    expect(obj.notOwn).to.be.deep.equal({a: 'a'})\n  })\n\n  it('del should not delete not own property', function () {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.del(obj, 'notOwn.a')\n    expect(proto.notOwn).to.be.deep.equal({a: 'a'})\n    //expect(obj.notOwn).to.be.deep.equal({a: 'a'});\n    //objectPath.del(obj, 'notOwn');\n    //expect(proto).to.be.deep.equal({notOwn: {a: 'a'}});\n    //expect(obj).to.be.deep.equal({notOwn: {a: 'a'}});\n  })\n})\n\ndescribe('Access own properties [optional]', function () {\n  it('should get a not own property', function () {\n    var Obj = function () {\n    }\n    Obj.prototype.notOwn = {a: 'a'}\n    var obj = new Obj()\n\n    expect(objectPath.withInheritedProps.get(obj, 'notOwn.a')).to.be.equal('a')\n  })\n\n  it('should set a deep not own property on the prototype (if exists)', function () {\n    var proto = {\n      notOwn: {}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.withInheritedProps.set(obj, 'notOwn.test', 'a')\n    expect(obj.notOwn.test).to.be.equal('a')\n    expect(proto.notOwn).to.be.deep.equal({test: 'a'})\n  })\n\n\n  it('has should return true on a not own property', function () {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n    expect(objectPath.withInheritedProps.has(obj, 'notOwn')).to.be.true\n    expect(objectPath.withInheritedProps.has(obj, 'notOwn.a')).to.be.true\n  })\n\n  it('empty should empty a not own property', function () {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.withInheritedProps.empty(obj, 'notOwn')\n    expect(proto.notOwn).to.be.deep.equal({})\n    expect(obj.notOwn).to.be.deep.equal({})\n  })\n\n  it('del should delete a not own property', function () {\n    var proto = {\n      notOwn: {a: 'a'}\n    }\n    var obj = Object.create(proto)\n\n    objectPath.withInheritedProps.del(obj, 'notOwn.a')\n    expect(proto.notOwn).to.be.deep.equal({})\n    //expect(obj.notOwn).to.be.deep.equal({});\n    objectPath.withInheritedProps.del(obj, 'notOwn')\n    //expect(proto).to.be.deep.equal({notOwn: {}});\n    //expect(obj).to.be.deep.equal({notOwn: {}});\n  })\n})\n"], "filenames": ["index.js", "test.js"], "buggy_code_start_loc": [114, 1], "buggy_code_end_loc": [114, 948], "fixing_code_start_loc": [115, 1], "fixing_code_end_loc": [119, 990], "type": "NVD-CWE-Other", "message": "A prototype pollution vulnerability has been found in `object-path` <= 0.11.4 affecting the `set()` method. The vulnerability is limited to the `includeInheritedProps` mode (if version >= 0.11.0 is used), which has to be explicitly enabled by creating a new instance of `object-path` and setting the option `includeInheritedProps: true`, or by using the default `withInheritedProps` instance. The default operating mode is not affected by the vulnerability if version >= 0.11.0 is used. Any usage of `set()` in versions < 0.11.0 is vulnerable. The issue is fixed in object-path version 0.11.5 As a workaround, don't use the `includeInheritedProps: true` options or the `withInheritedProps` instance if using a version >= 0.11.0.", "other": {"cve": {"id": "CVE-2020-15256", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-19T22:15:13.017", "lastModified": "2021-11-18T16:20:26.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A prototype pollution vulnerability has been found in `object-path` <= 0.11.4 affecting the `set()` method. The vulnerability is limited to the `includeInheritedProps` mode (if version >= 0.11.0 is used), which has to be explicitly enabled by creating a new instance of `object-path` and setting the option `includeInheritedProps: true`, or by using the default `withInheritedProps` instance. The default operating mode is not affected by the vulnerability if version >= 0.11.0 is used. Any usage of `set()` in versions < 0.11.0 is vulnerable. The issue is fixed in object-path version 0.11.5 As a workaround, don't use the `includeInheritedProps: true` options or the `withInheritedProps` instance if using a version >= 0.11.0."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad de contaminaci\u00f3n de prototipo en \"object-path\" versiones anteriores a 0.11.4, incluy\u00e9ndola afectando al m\u00e9todo \"set()\".&#xa0;La vulnerabilidad es limitada al modo \"includeInheritedProps\" (si la versi\u00f3n posterior a 0.11.0 incluy\u00e9ndola es usada), que debe habilitarse expl\u00edcitamente mediante la creaci\u00f3n de una nueva instancia de \"object-path\" y configurando la opci\u00f3n \"includeInheritedProps: true\", o usando la instancia predeterminada \"withInheritedProps\".&#xa0;El modo de funcionamiento predeterminado no est\u00e1 afectado por la vulnerabilidad si las versiones posteriores a 0.11.0 incluy\u00e9ndola es usada.&#xa0;Cualquier uso de \"set()\" en versiones anteriores a 0.11.0 es vulnerable.&#xa0;El problema es corregido en la versi\u00f3n 0.11.5 de la ruta de objeto. Como soluci\u00f3n alternativa, no use las opciones \"includeInheritedProps: true\" o la instancia \"withInheritedProps\" si usa una versi\u00f3n anterior a 0.11.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-471"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:object-path_project:object-path:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.11.5", "matchCriteriaId": "90D9A1B9-5AA5-4299-AB35-C836582F44FB"}]}]}], "references": [{"url": "https://github.com/mariocasciaro/object-path/commit/2be3354c6c46215c7635eb1b76d80f1319403c68", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mariocasciaro/object-path/security/advisories/GHSA-cwx2-736x-mf6w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mariocasciaro/object-path/commit/2be3354c6c46215c7635eb1b76d80f1319403c68"}}