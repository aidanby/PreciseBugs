{"buggy_code": ["'use strict';\n\nconst async = require('async');\nconst passport = require('passport');\nconst passportLocal = require('passport-local').Strategy;\nconst BearerStrategy = require('passport-http-bearer').Strategy;\nconst winston = require('winston');\n\nconst meta = require('../meta');\nconst controllers = require('../controllers');\nconst helpers = require('../controllers/helpers');\nconst plugins = require('../plugins');\n\nlet loginStrategies = [];\n\nconst Auth = module.exports;\n\nAuth.initialize = function (app, middleware) {\n\tconst passportInitMiddleware = passport.initialize();\n\tapp.use((req, res, next) => {\n\t\tpassportInitMiddleware(req, res, next);\n\t});\n\tconst passportSessionMiddleware = passport.session();\n\tapp.use((req, res, next) => {\n\t\tpassportSessionMiddleware(req, res, next);\n\t});\n\n\tapp.use((req, res, next) => {\n\t\tAuth.setAuthVars(req, res);\n\t\tnext();\n\t});\n\n\tAuth.app = app;\n\tAuth.middleware = middleware;\n};\n\nAuth.setAuthVars = function setAuthVars(req) {\n\tconst isSpider = req.isSpider();\n\treq.loggedIn = !isSpider && !!req.user;\n\tif (req.user) {\n\t\treq.uid = parseInt(req.user.uid, 10);\n\t} else if (isSpider) {\n\t\treq.uid = -1;\n\t} else {\n\t\treq.uid = 0;\n\t}\n};\n\nAuth.getLoginStrategies = function () {\n\treturn loginStrategies;\n};\n\nAuth.verifyToken = async function (token, done) {\n\tlet { tokens = [] } = await meta.settings.get('core.api');\n\ttokens = tokens.reduce((memo, cur) => {\n\t\tmemo[cur.token] = cur.uid;\n\t\treturn memo;\n\t}, {});\n\n\tconst uid = tokens[token];\n\n\tif (uid !== undefined) {\n\t\tif (parseInt(uid, 10) > 0) {\n\t\t\tdone(null, {\n\t\t\t\tuid: uid,\n\t\t\t});\n\t\t} else {\n\t\t\tdone(null, {\n\t\t\t\tmaster: true,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tdone(false);\n\t}\n};\n\nAuth.reloadRoutes = async function (params) {\n\tloginStrategies.length = 0;\n\tconst { router } = params;\n\n\t// Local Logins\n\tif (plugins.hooks.hasListeners('action:auth.overrideLogin')) {\n\t\twinston.warn('[authentication] Login override detected, skipping local login strategy.');\n\t\tplugins.hooks.fire('action:auth.overrideLogin');\n\t} else {\n\t\tpassport.use(new passportLocal({ passReqToCallback: true }, controllers.authentication.localLogin));\n\t}\n\n\t// HTTP bearer authentication\n\tpassport.use('core.api', new BearerStrategy({}, Auth.verifyToken));\n\n\t// Additional logins via SSO plugins\n\ttry {\n\t\tloginStrategies = await plugins.hooks.fire('filter:auth.init', loginStrategies);\n\t} catch (err) {\n\t\twinston.error(`[authentication] ${err.stack}`);\n\t}\n\tloginStrategies = loginStrategies || [];\n\tloginStrategies.forEach((strategy) => {\n\t\tif (strategy.url) {\n\t\t\trouter[strategy.urlMethod || 'get'](strategy.url, Auth.middleware.applyCSRF, async (req, res, next) => {\n\t\t\t\tlet opts = {\n\t\t\t\t\tscope: strategy.scope,\n\t\t\t\t\tprompt: strategy.prompt || undefined,\n\t\t\t\t};\n\n\t\t\t\tif (strategy.checkState) {\n\t\t\t\t\treq.session.ssoState = req.csrfToken && req.csrfToken();\n\t\t\t\t\topts.state = req.session.ssoState;\n\t\t\t\t}\n\n\t\t\t\t// Allow SSO plugins to override/append options (for use in passport prototype authorizationParams)\n\t\t\t\t({ opts } = await plugins.hooks.fire('filter:auth.options', { req, res, opts }));\n\t\t\t\tpassport.authenticate(strategy.name, opts)(req, res, next);\n\t\t\t});\n\t\t}\n\n\t\trouter[strategy.callbackMethod || 'get'](strategy.callbackURL, (req, res, next) => {\n\t\t\t// Ensure the passed-back state value is identical to the saved ssoState (unless explicitly skipped)\n\t\t\tif (strategy.checkState === false) {\n\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\tnext(req.query.state !== req.session.ssoState ? new Error('[[error:csrf-invalid]]') : null);\n\t\t}, (req, res, next) => {\n\t\t\t// Trigger registration interstitial checks\n\t\t\treq.session.registration = req.session.registration || {};\n\t\t\t// save returnTo for later usage in /register/complete\n\t\t\t// passport seems to remove `req.session.returnTo` after it redirects\n\t\t\treq.session.registration.returnTo = req.session.returnTo;\n\n\t\t\tpassport.authenticate(strategy.name, (err, user) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn helpers.redirect(res, strategy.failureUrl !== undefined ? strategy.failureUrl : '/login');\n\t\t\t\t}\n\n\t\t\t\tres.locals.user = user;\n\t\t\t\tres.locals.strategy = strategy;\n\t\t\t\tnext();\n\t\t\t})(req, res, next);\n\t\t},\n\t\tAuth.middleware.validateAuth,\n\t\t(req, res, next) => {\n\t\t\tasync.waterfall([\n\t\t\t\tasync.apply(req.login.bind(req), res.locals.user),\n\t\t\t\tasync.apply(controllers.authentication.onSuccessfulLogin, req, req.uid),\n\t\t\t], (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\thelpers.redirect(res, strategy.successUrl !== undefined ? strategy.successUrl : '/');\n\t\t\t});\n\t\t});\n\t});\n\n\tconst multipart = require('connect-multiparty');\n\tconst multipartMiddleware = multipart();\n\tconst middlewares = [multipartMiddleware, Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist];\n\n\trouter.post('/register', middlewares, controllers.authentication.register);\n\trouter.post('/register/complete', middlewares, controllers.authentication.registerComplete);\n\trouter.post('/register/abort', controllers.authentication.registerAbort);\n\trouter.post('/login', Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist, controllers.authentication.login);\n\trouter.post('/logout', Auth.middleware.applyCSRF, controllers.authentication.logout);\n};\n\npassport.serializeUser((user, done) => {\n\tdone(null, user.uid);\n});\n\npassport.deserializeUser((uid, done) => {\n\tdone(null, {\n\t\tuid: uid,\n\t});\n});\n"], "fixing_code": ["'use strict';\n\nconst async = require('async');\nconst passport = require('passport');\nconst passportLocal = require('passport-local').Strategy;\nconst BearerStrategy = require('passport-http-bearer').Strategy;\nconst winston = require('winston');\n\nconst meta = require('../meta');\nconst controllers = require('../controllers');\nconst helpers = require('../controllers/helpers');\nconst plugins = require('../plugins');\n\nlet loginStrategies = [];\n\nconst Auth = module.exports;\n\nAuth.initialize = function (app, middleware) {\n\tconst passportInitMiddleware = passport.initialize();\n\tapp.use((req, res, next) => {\n\t\tpassportInitMiddleware(req, res, next);\n\t});\n\tconst passportSessionMiddleware = passport.session();\n\tapp.use((req, res, next) => {\n\t\tpassportSessionMiddleware(req, res, next);\n\t});\n\n\tapp.use((req, res, next) => {\n\t\tAuth.setAuthVars(req, res);\n\t\tnext();\n\t});\n\n\tAuth.app = app;\n\tAuth.middleware = middleware;\n};\n\nAuth.setAuthVars = function setAuthVars(req) {\n\tconst isSpider = req.isSpider();\n\treq.loggedIn = !isSpider && !!req.user;\n\tif (req.user) {\n\t\treq.uid = parseInt(req.user.uid, 10);\n\t} else if (isSpider) {\n\t\treq.uid = -1;\n\t} else {\n\t\treq.uid = 0;\n\t}\n};\n\nAuth.getLoginStrategies = function () {\n\treturn loginStrategies;\n};\n\nAuth.verifyToken = async function (token, done) {\n\tlet { tokens = [] } = await meta.settings.get('core.api');\n\ttokens = tokens.reduce((memo, cur) => {\n\t\tmemo[cur.token] = cur.uid;\n\t\treturn memo;\n\t}, {});\n\n\tconst uid = tokens[token];\n\n\tif (uid !== undefined) {\n\t\tif (parseInt(uid, 10) > 0) {\n\t\t\tdone(null, {\n\t\t\t\tuid: uid,\n\t\t\t});\n\t\t} else {\n\t\t\tdone(null, {\n\t\t\t\tmaster: true,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tdone(false);\n\t}\n};\n\nAuth.reloadRoutes = async function (params) {\n\tloginStrategies.length = 0;\n\tconst { router } = params;\n\n\t// Local Logins\n\tif (plugins.hooks.hasListeners('action:auth.overrideLogin')) {\n\t\twinston.warn('[authentication] Login override detected, skipping local login strategy.');\n\t\tplugins.hooks.fire('action:auth.overrideLogin');\n\t} else {\n\t\tpassport.use(new passportLocal({ passReqToCallback: true }, controllers.authentication.localLogin));\n\t}\n\n\t// HTTP bearer authentication\n\tpassport.use('core.api', new BearerStrategy({}, Auth.verifyToken));\n\n\t// Additional logins via SSO plugins\n\ttry {\n\t\tloginStrategies = await plugins.hooks.fire('filter:auth.init', loginStrategies);\n\t} catch (err) {\n\t\twinston.error(`[authentication] ${err.stack}`);\n\t}\n\tloginStrategies = loginStrategies || [];\n\tloginStrategies.forEach((strategy) => {\n\t\tif (strategy.url) {\n\t\t\trouter[strategy.urlMethod || 'get'](strategy.url, Auth.middleware.applyCSRF, async (req, res, next) => {\n\t\t\t\tlet opts = {\n\t\t\t\t\tscope: strategy.scope,\n\t\t\t\t\tprompt: strategy.prompt || undefined,\n\t\t\t\t};\n\n\t\t\t\tif (strategy.checkState !== false) {\n\t\t\t\t\treq.session.ssoState = req.csrfToken && req.csrfToken();\n\t\t\t\t\topts.state = req.session.ssoState;\n\t\t\t\t}\n\n\t\t\t\t// Allow SSO plugins to override/append options (for use in passport prototype authorizationParams)\n\t\t\t\t({ opts } = await plugins.hooks.fire('filter:auth.options', { req, res, opts }));\n\t\t\t\tpassport.authenticate(strategy.name, opts)(req, res, next);\n\t\t\t});\n\t\t}\n\n\t\trouter[strategy.callbackMethod || 'get'](strategy.callbackURL, (req, res, next) => {\n\t\t\t// Ensure the passed-back state value is identical to the saved ssoState (unless explicitly skipped)\n\t\t\tif (strategy.checkState === false) {\n\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\tnext(req.query.state !== req.session.ssoState ? new Error('[[error:csrf-invalid]]') : null);\n\t\t}, (req, res, next) => {\n\t\t\t// Trigger registration interstitial checks\n\t\t\treq.session.registration = req.session.registration || {};\n\t\t\t// save returnTo for later usage in /register/complete\n\t\t\t// passport seems to remove `req.session.returnTo` after it redirects\n\t\t\treq.session.registration.returnTo = req.session.returnTo;\n\n\t\t\tpassport.authenticate(strategy.name, (err, user) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn helpers.redirect(res, strategy.failureUrl !== undefined ? strategy.failureUrl : '/login');\n\t\t\t\t}\n\n\t\t\t\tres.locals.user = user;\n\t\t\t\tres.locals.strategy = strategy;\n\t\t\t\tnext();\n\t\t\t})(req, res, next);\n\t\t},\n\t\tAuth.middleware.validateAuth,\n\t\t(req, res, next) => {\n\t\t\tasync.waterfall([\n\t\t\t\tasync.apply(req.login.bind(req), res.locals.user),\n\t\t\t\tasync.apply(controllers.authentication.onSuccessfulLogin, req, req.uid),\n\t\t\t], (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\thelpers.redirect(res, strategy.successUrl !== undefined ? strategy.successUrl : '/');\n\t\t\t});\n\t\t});\n\t});\n\n\tconst multipart = require('connect-multiparty');\n\tconst multipartMiddleware = multipart();\n\tconst middlewares = [multipartMiddleware, Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist];\n\n\trouter.post('/register', middlewares, controllers.authentication.register);\n\trouter.post('/register/complete', middlewares, controllers.authentication.registerComplete);\n\trouter.post('/register/abort', controllers.authentication.registerAbort);\n\trouter.post('/login', Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist, controllers.authentication.login);\n\trouter.post('/logout', Auth.middleware.applyCSRF, controllers.authentication.logout);\n};\n\npassport.serializeUser((user, done) => {\n\tdone(null, user.uid);\n});\n\npassport.deserializeUser((uid, done) => {\n\tdone(null, {\n\t\tuid: uid,\n\t});\n});\n"], "filenames": ["src/routes/authentication.js"], "buggy_code_start_loc": [107], "buggy_code_end_loc": [108], "fixing_code_start_loc": [107], "fixing_code_end_loc": [108], "type": "CWE-352", "message": "NodeBB Forum Software is powered by Node.js and supports either Redis, MongoDB, or a PostgreSQL database. Due to an unnecessarily strict conditional in the code handling the first step of the SSO process, the pre-existing logic that added (and later checked) a nonce was inadvertently rendered opt-in instead of opt-out. This re-exposed a vulnerability in that a specially crafted Man-in-the-Middle (MITM) attack could theoretically take over another user account during the single sign-on process. The issue has been fully patched in version 1.17.2.", "other": {"cve": {"id": "CVE-2022-36076", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-02T13:15:08.847", "lastModified": "2022-09-08T03:23:11.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NodeBB Forum Software is powered by Node.js and supports either Redis, MongoDB, or a PostgreSQL database. Due to an unnecessarily strict conditional in the code handling the first step of the SSO process, the pre-existing logic that added (and later checked) a nonce was inadvertently rendered opt-in instead of opt-out. This re-exposed a vulnerability in that a specially crafted Man-in-the-Middle (MITM) attack could theoretically take over another user account during the single sign-on process. The issue has been fully patched in version 1.17.2."}, {"lang": "es", "value": "El software de foros NodeBB funciona con Node.js y soporta Redis, MongoDB o una base de datos PostgreSQL. Debido a un condicional innecesariamente estricto en el c\u00f3digo que maneja el primer paso del proceso de SSO, la l\u00f3gica preexistente que agregaba (y luego verificaba) un nonce es convertido inadvertidamente en opt-in en lugar de opt-out. Esto Re expuso una vulnerabilidad en la que un ataque de tipo Man-in-the-Middle (MITM) especialmente dise\u00f1ado podr\u00eda te\u00f3ricamente tomar el control de otra cuenta de usuario durante el proceso de inicio de sesi\u00f3n \u00fanico. El problema ha sido completamente parcheado en la versi\u00f3n 1.17.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.17.2", "matchCriteriaId": "AEDC91B9-9893-4291-86CE-33A92DB28E54"}]}]}], "references": [{"url": "https://blogs.opera.com/security/2022/03/bug-bounty-adventures-a-nodebb-0-day/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/commit/a2400f6baff44cb2996487bcd0cc6e2acc74b3d4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/security/advisories/GHSA-xmgg-fx9p-prq6", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/a2400f6baff44cb2996487bcd0cc6e2acc74b3d4"}}