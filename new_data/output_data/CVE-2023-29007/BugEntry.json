{"buggy_code": ["/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n * Copyright (C) Johannes Schindelin, 2005\n *\n */\n#include \"cache.h\"\n#include \"branch.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"lockfile.h\"\n#include \"exec-cmd.h\"\n#include \"strbuf.h\"\n#include \"quote.h\"\n#include \"hashmap.h\"\n#include \"string-list.h\"\n#include \"object-store.h\"\n#include \"utf8.h\"\n#include \"dir.h\"\n#include \"color.h\"\n#include \"refs.h\"\n\nstruct config_source {\n\tstruct config_source *prev;\n\tunion {\n\t\tFILE *file;\n\t\tstruct config_buf {\n\t\t\tconst char *buf;\n\t\t\tsize_t len;\n\t\t\tsize_t pos;\n\t\t} buf;\n\t} u;\n\tenum config_origin_type origin_type;\n\tconst char *name;\n\tconst char *path;\n\tenum config_error_action default_error_action;\n\tint linenr;\n\tint eof;\n\tsize_t total_len;\n\tstruct strbuf value;\n\tstruct strbuf var;\n\tunsigned subsection_case_sensitive : 1;\n\n\tint (*do_fgetc)(struct config_source *c);\n\tint (*do_ungetc)(int c, struct config_source *conf);\n\tlong (*do_ftell)(struct config_source *c);\n};\n\n/*\n * These variables record the \"current\" config source, which\n * can be accessed by parsing callbacks.\n *\n * The \"cf\" variable will be non-NULL only when we are actually parsing a real\n * config source (file, blob, cmdline, etc).\n *\n * The \"current_config_kvi\" variable will be non-NULL only when we are feeding\n * cached config from a configset into a callback.\n *\n * They should generally never be non-NULL at the same time. If they are both\n * NULL, then we aren't parsing anything (and depending on the function looking\n * at the variables, it's either a bug for it to be called in the first place,\n * or it's a function which can be reused for non-config purposes, and should\n * fall back to some sane behavior).\n */\nstatic struct config_source *cf;\nstatic struct key_value_info *current_config_kvi;\n\n/*\n * Similar to the variables above, this gives access to the \"scope\" of the\n * current value (repo, global, etc). For cached values, it can be found via\n * the current_config_kvi as above. During parsing, the current value can be\n * found in this variable. It's not part of \"cf\" because it transcends a single\n * file (i.e., a file included from .git/config is still in \"repo\" scope).\n */\nstatic enum config_scope current_parsing_scope;\n\nstatic int core_compression_seen;\nstatic int pack_compression_seen;\nstatic int zlib_compression_seen;\n\nstatic int config_file_fgetc(struct config_source *conf)\n{\n\treturn getc_unlocked(conf->u.file);\n}\n\nstatic int config_file_ungetc(int c, struct config_source *conf)\n{\n\treturn ungetc(c, conf->u.file);\n}\n\nstatic long config_file_ftell(struct config_source *conf)\n{\n\treturn ftell(conf->u.file);\n}\n\n\nstatic int config_buf_fgetc(struct config_source *conf)\n{\n\tif (conf->u.buf.pos < conf->u.buf.len)\n\t\treturn conf->u.buf.buf[conf->u.buf.pos++];\n\n\treturn EOF;\n}\n\nstatic int config_buf_ungetc(int c, struct config_source *conf)\n{\n\tif (conf->u.buf.pos > 0) {\n\t\tconf->u.buf.pos--;\n\t\tif (conf->u.buf.buf[conf->u.buf.pos] != c)\n\t\t\tBUG(\"config_buf can only ungetc the same character\");\n\t\treturn c;\n\t}\n\n\treturn EOF;\n}\n\nstatic long config_buf_ftell(struct config_source *conf)\n{\n\treturn conf->u.buf.pos;\n}\n\n#define MAX_INCLUDE_DEPTH 10\nstatic const char include_depth_advice[] = N_(\n\"exceeded maximum include depth (%d) while including\\n\"\n\"\t%s\\n\"\n\"from\\n\"\n\"\t%s\\n\"\n\"This might be due to circular includes.\");\nstatic int handle_path_include(const char *path, struct config_include_data *inc)\n{\n\tint ret = 0;\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *expanded;\n\n\tif (!path)\n\t\treturn config_error_nonbool(\"include.path\");\n\n\texpanded = expand_user_path(path, 0);\n\tif (!expanded)\n\t\treturn error(_(\"could not expand include path '%s'\"), path);\n\tpath = expanded;\n\n\t/*\n\t * Use an absolute path as-is, but interpret relative paths\n\t * based on the including config file.\n\t */\n\tif (!is_absolute_path(path)) {\n\t\tchar *slash;\n\n\t\tif (!cf || !cf->path)\n\t\t\treturn error(_(\"relative config includes must come from files\"));\n\n\t\tslash = find_last_dir_sep(cf->path);\n\t\tif (slash)\n\t\t\tstrbuf_add(&buf, cf->path, slash - cf->path + 1);\n\t\tstrbuf_addstr(&buf, path);\n\t\tpath = buf.buf;\n\t}\n\n\tif (!access_or_die(path, R_OK, 0)) {\n\t\tif (++inc->depth > MAX_INCLUDE_DEPTH)\n\t\t\tdie(_(include_depth_advice), MAX_INCLUDE_DEPTH, path,\n\t\t\t    !cf ? \"<unknown>\" :\n\t\t\t    cf->name ? cf->name :\n\t\t\t    \"the command line\");\n\t\tret = git_config_from_file(git_config_include, path, inc);\n\t\tinc->depth--;\n\t}\n\tstrbuf_release(&buf);\n\tfree(expanded);\n\treturn ret;\n}\n\nstatic void add_trailing_starstar_for_dir(struct strbuf *pat)\n{\n\tif (pat->len && is_dir_sep(pat->buf[pat->len - 1]))\n\t\tstrbuf_addstr(pat, \"**\");\n}\n\nstatic int prepare_include_condition_pattern(struct strbuf *pat)\n{\n\tstruct strbuf path = STRBUF_INIT;\n\tchar *expanded;\n\tint prefix = 0;\n\n\texpanded = expand_user_path(pat->buf, 1);\n\tif (expanded) {\n\t\tstrbuf_reset(pat);\n\t\tstrbuf_addstr(pat, expanded);\n\t\tfree(expanded);\n\t}\n\n\tif (pat->buf[0] == '.' && is_dir_sep(pat->buf[1])) {\n\t\tconst char *slash;\n\n\t\tif (!cf || !cf->path)\n\t\t\treturn error(_(\"relative config include \"\n\t\t\t\t       \"conditionals must come from files\"));\n\n\t\tstrbuf_realpath(&path, cf->path, 1);\n\t\tslash = find_last_dir_sep(path.buf);\n\t\tif (!slash)\n\t\t\tBUG(\"how is this possible?\");\n\t\tstrbuf_splice(pat, 0, 1, path.buf, slash - path.buf);\n\t\tprefix = slash - path.buf + 1 /* slash */;\n\t} else if (!is_absolute_path(pat->buf))\n\t\tstrbuf_insertstr(pat, 0, \"**/\");\n\n\tadd_trailing_starstar_for_dir(pat);\n\n\tstrbuf_release(&path);\n\treturn prefix;\n}\n\nstatic int include_by_gitdir(const struct config_options *opts,\n\t\t\t     const char *cond, size_t cond_len, int icase)\n{\n\tstruct strbuf text = STRBUF_INIT;\n\tstruct strbuf pattern = STRBUF_INIT;\n\tint ret = 0, prefix;\n\tconst char *git_dir;\n\tint already_tried_absolute = 0;\n\n\tif (opts->git_dir)\n\t\tgit_dir = opts->git_dir;\n\telse\n\t\tgoto done;\n\n\tstrbuf_realpath(&text, git_dir, 1);\n\tstrbuf_add(&pattern, cond, cond_len);\n\tprefix = prepare_include_condition_pattern(&pattern);\n\nagain:\n\tif (prefix < 0)\n\t\tgoto done;\n\n\tif (prefix > 0) {\n\t\t/*\n\t\t * perform literal matching on the prefix part so that\n\t\t * any wildcard character in it can't create side effects.\n\t\t */\n\t\tif (text.len < prefix)\n\t\t\tgoto done;\n\t\tif (!icase && strncmp(pattern.buf, text.buf, prefix))\n\t\t\tgoto done;\n\t\tif (icase && strncasecmp(pattern.buf, text.buf, prefix))\n\t\t\tgoto done;\n\t}\n\n\tret = !wildmatch(pattern.buf + prefix, text.buf + prefix,\n\t\t\t WM_PATHNAME | (icase ? WM_CASEFOLD : 0));\n\n\tif (!ret && !already_tried_absolute) {\n\t\t/*\n\t\t * We've tried e.g. matching gitdir:~/work, but if\n\t\t * ~/work is a symlink to /mnt/storage/work\n\t\t * strbuf_realpath() will expand it, so the rule won't\n\t\t * match. Let's match against a\n\t\t * strbuf_add_absolute_path() version of the path,\n\t\t * which'll do the right thing\n\t\t */\n\t\tstrbuf_reset(&text);\n\t\tstrbuf_add_absolute_path(&text, git_dir);\n\t\talready_tried_absolute = 1;\n\t\tgoto again;\n\t}\ndone:\n\tstrbuf_release(&pattern);\n\tstrbuf_release(&text);\n\treturn ret;\n}\n\nstatic int include_by_branch(const char *cond, size_t cond_len)\n{\n\tint flags;\n\tint ret;\n\tstruct strbuf pattern = STRBUF_INIT;\n\tconst char *refname = !the_repository->gitdir ?\n\t\tNULL : resolve_ref_unsafe(\"HEAD\", 0, NULL, &flags);\n\tconst char *shortname;\n\n\tif (!refname || !(flags & REF_ISSYMREF)\t||\n\t\t\t!skip_prefix(refname, \"refs/heads/\", &shortname))\n\t\treturn 0;\n\n\tstrbuf_add(&pattern, cond, cond_len);\n\tadd_trailing_starstar_for_dir(&pattern);\n\tret = !wildmatch(pattern.buf, shortname, WM_PATHNAME);\n\tstrbuf_release(&pattern);\n\treturn ret;\n}\n\nstatic int include_condition_is_true(const struct config_options *opts,\n\t\t\t\t     const char *cond, size_t cond_len)\n{\n\n\tif (skip_prefix_mem(cond, cond_len, \"gitdir:\", &cond, &cond_len))\n\t\treturn include_by_gitdir(opts, cond, cond_len, 0);\n\telse if (skip_prefix_mem(cond, cond_len, \"gitdir/i:\", &cond, &cond_len))\n\t\treturn include_by_gitdir(opts, cond, cond_len, 1);\n\telse if (skip_prefix_mem(cond, cond_len, \"onbranch:\", &cond, &cond_len))\n\t\treturn include_by_branch(cond, cond_len);\n\n\t/* unknown conditionals are always false */\n\treturn 0;\n}\n\nint git_config_include(const char *var, const char *value, void *data)\n{\n\tstruct config_include_data *inc = data;\n\tconst char *cond, *key;\n\tsize_t cond_len;\n\tint ret;\n\n\t/*\n\t * Pass along all values, including \"include\" directives; this makes it\n\t * possible to query information on the includes themselves.\n\t */\n\tret = inc->fn(var, value, inc->data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!strcmp(var, \"include.path\"))\n\t\tret = handle_path_include(value, inc);\n\n\tif (!parse_config_key(var, \"includeif\", &cond, &cond_len, &key) &&\n\t    (cond && include_condition_is_true(inc->opts, cond, cond_len)) &&\n\t    !strcmp(key, \"path\"))\n\t\tret = handle_path_include(value, inc);\n\n\treturn ret;\n}\n\nvoid git_config_push_parameter(const char *text)\n{\n\tstruct strbuf env = STRBUF_INIT;\n\tconst char *old = getenv(CONFIG_DATA_ENVIRONMENT);\n\tif (old && *old) {\n\t\tstrbuf_addstr(&env, old);\n\t\tstrbuf_addch(&env, ' ');\n\t}\n\tsq_quote_buf(&env, text);\n\tsetenv(CONFIG_DATA_ENVIRONMENT, env.buf, 1);\n\tstrbuf_release(&env);\n}\n\nstatic inline int iskeychar(int c)\n{\n\treturn isalnum(c) || c == '-';\n}\n\n/*\n * Auxiliary function to sanity-check and split the key into the section\n * identifier and variable name.\n *\n * Returns 0 on success, -1 when there is an invalid character in the key and\n * -2 if there is no section name in the key.\n *\n * store_key - pointer to char* which will hold a copy of the key with\n *             lowercase section and variable name\n * baselen - pointer to size_t which will hold the length of the\n *           section + subsection part, can be NULL\n */\nstatic int git_config_parse_key_1(const char *key, char **store_key, size_t *baselen_, int quiet)\n{\n\tsize_t i, baselen;\n\tint dot;\n\tconst char *last_dot = strrchr(key, '.');\n\n\t/*\n\t * Since \"key\" actually contains the section name and the real\n\t * key name separated by a dot, we have to know where the dot is.\n\t */\n\n\tif (last_dot == NULL || last_dot == key) {\n\t\tif (!quiet)\n\t\t\terror(_(\"key does not contain a section: %s\"), key);\n\t\treturn -CONFIG_NO_SECTION_OR_NAME;\n\t}\n\n\tif (!last_dot[1]) {\n\t\tif (!quiet)\n\t\t\terror(_(\"key does not contain variable name: %s\"), key);\n\t\treturn -CONFIG_NO_SECTION_OR_NAME;\n\t}\n\n\tbaselen = last_dot - key;\n\tif (baselen_)\n\t\t*baselen_ = baselen;\n\n\t/*\n\t * Validate the key and while at it, lower case it for matching.\n\t */\n\tif (store_key)\n\t\t*store_key = xmallocz(strlen(key));\n\n\tdot = 0;\n\tfor (i = 0; key[i]; i++) {\n\t\tunsigned char c = key[i];\n\t\tif (c == '.')\n\t\t\tdot = 1;\n\t\t/* Leave the extended basename untouched.. */\n\t\tif (!dot || i > baselen) {\n\t\t\tif (!iskeychar(c) ||\n\t\t\t    (i == baselen + 1 && !isalpha(c))) {\n\t\t\t\tif (!quiet)\n\t\t\t\t\terror(_(\"invalid key: %s\"), key);\n\t\t\t\tgoto out_free_ret_1;\n\t\t\t}\n\t\t\tc = tolower(c);\n\t\t} else if (c == '\\n') {\n\t\t\tif (!quiet)\n\t\t\t\terror(_(\"invalid key (newline): %s\"), key);\n\t\t\tgoto out_free_ret_1;\n\t\t}\n\t\tif (store_key)\n\t\t\t(*store_key)[i] = c;\n\t}\n\n\treturn 0;\n\nout_free_ret_1:\n\tif (store_key) {\n\t\tFREE_AND_NULL(*store_key);\n\t}\n\treturn -CONFIG_INVALID_KEY;\n}\n\nint git_config_parse_key(const char *key, char **store_key, size_t *baselen)\n{\n\treturn git_config_parse_key_1(key, store_key, baselen, 0);\n}\n\nint git_config_key_is_valid(const char *key)\n{\n\treturn !git_config_parse_key_1(key, NULL, NULL, 1);\n}\n\nint git_config_parse_parameter(const char *text,\n\t\t\t       config_fn_t fn, void *data)\n{\n\tconst char *value;\n\tchar *canonical_name;\n\tstruct strbuf **pair;\n\tint ret;\n\n\tpair = strbuf_split_str(text, '=', 2);\n\tif (!pair[0])\n\t\treturn error(_(\"bogus config parameter: %s\"), text);\n\n\tif (pair[0]->len && pair[0]->buf[pair[0]->len - 1] == '=') {\n\t\tstrbuf_setlen(pair[0], pair[0]->len - 1);\n\t\tvalue = pair[1] ? pair[1]->buf : \"\";\n\t} else {\n\t\tvalue = NULL;\n\t}\n\n\tstrbuf_trim(pair[0]);\n\tif (!pair[0]->len) {\n\t\tstrbuf_list_free(pair);\n\t\treturn error(_(\"bogus config parameter: %s\"), text);\n\t}\n\n\tif (git_config_parse_key(pair[0]->buf, &canonical_name, NULL)) {\n\t\tret = -1;\n\t} else {\n\t\tret = (fn(canonical_name, value, data) < 0) ? -1 : 0;\n\t\tfree(canonical_name);\n\t}\n\tstrbuf_list_free(pair);\n\treturn ret;\n}\n\nint git_config_from_parameters(config_fn_t fn, void *data)\n{\n\tconst char *env = getenv(CONFIG_DATA_ENVIRONMENT);\n\tint ret = 0;\n\tchar *envw;\n\tconst char **argv = NULL;\n\tint nr = 0, alloc = 0;\n\tint i;\n\tstruct config_source source;\n\n\tif (!env)\n\t\treturn 0;\n\n\tmemset(&source, 0, sizeof(source));\n\tsource.prev = cf;\n\tsource.origin_type = CONFIG_ORIGIN_CMDLINE;\n\tcf = &source;\n\n\t/* sq_dequote will write over it */\n\tenvw = xstrdup(env);\n\n\tif (sq_dequote_to_argv(envw, &argv, &nr, &alloc) < 0) {\n\t\tret = error(_(\"bogus format in %s\"), CONFIG_DATA_ENVIRONMENT);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (git_config_parse_parameter(argv[i], fn, data) < 0) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(argv);\n\tfree(envw);\n\tcf = source.prev;\n\treturn ret;\n}\n\nstatic int get_next_char(void)\n{\n\tint c = cf->do_fgetc(cf);\n\n\tif (c == '\\r') {\n\t\t/* DOS like systems */\n\t\tc = cf->do_fgetc(cf);\n\t\tif (c != '\\n') {\n\t\t\tif (c != EOF)\n\t\t\t\tcf->do_ungetc(c, cf);\n\t\t\tc = '\\r';\n\t\t}\n\t}\n\n\tif (c != EOF && ++cf->total_len > INT_MAX) {\n\t\t/*\n\t\t * This is an absurdly long config file; refuse to parse\n\t\t * further in order to protect downstream code from integer\n\t\t * overflows. Note that we can't return an error specifically,\n\t\t * but we can mark EOF and put trash in the return value,\n\t\t * which will trigger a parse error.\n\t\t */\n\t\tcf->eof = 1;\n\t\treturn 0;\n\t}\n\n\tif (c == '\\n')\n\t\tcf->linenr++;\n\tif (c == EOF) {\n\t\tcf->eof = 1;\n\t\tcf->linenr++;\n\t\tc = '\\n';\n\t}\n\treturn c;\n}\n\nstatic char *parse_value(void)\n{\n\tint quote = 0, comment = 0, space = 0;\n\n\tstrbuf_reset(&cf->value);\n\tfor (;;) {\n\t\tint c = get_next_char();\n\t\tif (c == '\\n') {\n\t\t\tif (quote) {\n\t\t\t\tcf->linenr--;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cf->value.buf;\n\t\t}\n\t\tif (comment)\n\t\t\tcontinue;\n\t\tif (isspace(c) && !quote) {\n\t\t\tif (cf->value.len)\n\t\t\t\tspace++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!quote) {\n\t\t\tif (c == ';' || c == '#') {\n\t\t\t\tcomment = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (; space; space--)\n\t\t\tstrbuf_addch(&cf->value, ' ');\n\t\tif (c == '\\\\') {\n\t\t\tc = get_next_char();\n\t\t\tswitch (c) {\n\t\t\tcase '\\n':\n\t\t\t\tcontinue;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\tbreak;\n\t\t\t/* Some characters escape as themselves */\n\t\t\tcase '\\\\': case '\"':\n\t\t\t\tbreak;\n\t\t\t/* Reject unknown escape sequences */\n\t\t\tdefault:\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrbuf_addch(&cf->value, c);\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '\"') {\n\t\t\tquote = 1-quote;\n\t\t\tcontinue;\n\t\t}\n\t\tstrbuf_addch(&cf->value, c);\n\t}\n}\n\nstatic int get_value(config_fn_t fn, void *data, struct strbuf *name)\n{\n\tint c;\n\tchar *value;\n\tint ret;\n\n\t/* Get the full name */\n\tfor (;;) {\n\t\tc = get_next_char();\n\t\tif (cf->eof)\n\t\t\tbreak;\n\t\tif (!iskeychar(c))\n\t\t\tbreak;\n\t\tstrbuf_addch(name, tolower(c));\n\t}\n\n\twhile (c == ' ' || c == '\\t')\n\t\tc = get_next_char();\n\n\tvalue = NULL;\n\tif (c != '\\n') {\n\t\tif (c != '=')\n\t\t\treturn -1;\n\t\tvalue = parse_value();\n\t\tif (!value)\n\t\t\treturn -1;\n\t}\n\t/*\n\t * We already consumed the \\n, but we need linenr to point to\n\t * the line we just parsed during the call to fn to get\n\t * accurate line number in error messages.\n\t */\n\tcf->linenr--;\n\tret = fn(name->buf, value, data);\n\tif (ret >= 0)\n\t\tcf->linenr++;\n\treturn ret;\n}\n\nstatic int get_extended_base_var(struct strbuf *name, int c)\n{\n\tcf->subsection_case_sensitive = 0;\n\tdo {\n\t\tif (c == '\\n')\n\t\t\tgoto error_incomplete_line;\n\t\tc = get_next_char();\n\t} while (isspace(c));\n\n\t/* We require the format to be '[base \"extension\"]' */\n\tif (c != '\"')\n\t\treturn -1;\n\tstrbuf_addch(name, '.');\n\n\tfor (;;) {\n\t\tint c = get_next_char();\n\t\tif (c == '\\n')\n\t\t\tgoto error_incomplete_line;\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tif (c == '\\\\') {\n\t\t\tc = get_next_char();\n\t\t\tif (c == '\\n')\n\t\t\t\tgoto error_incomplete_line;\n\t\t}\n\t\tstrbuf_addch(name, c);\n\t}\n\n\t/* Final ']' */\n\tif (get_next_char() != ']')\n\t\treturn -1;\n\treturn 0;\nerror_incomplete_line:\n\tcf->linenr--;\n\treturn -1;\n}\n\nstatic int get_base_var(struct strbuf *name)\n{\n\tcf->subsection_case_sensitive = 1;\n\tfor (;;) {\n\t\tint c = get_next_char();\n\t\tif (cf->eof)\n\t\t\treturn -1;\n\t\tif (c == ']')\n\t\t\treturn 0;\n\t\tif (isspace(c))\n\t\t\treturn get_extended_base_var(name, c);\n\t\tif (!iskeychar(c) && c != '.')\n\t\t\treturn -1;\n\t\tstrbuf_addch(name, tolower(c));\n\t}\n}\n\nstruct parse_event_data {\n\tenum config_event_t previous_type;\n\tsize_t previous_offset;\n\tconst struct config_options *opts;\n};\n\nstatic int do_event(enum config_event_t type, struct parse_event_data *data)\n{\n\tsize_t offset;\n\n\tif (!data->opts || !data->opts->event_fn)\n\t\treturn 0;\n\n\tif (type == CONFIG_EVENT_WHITESPACE &&\n\t    data->previous_type == type)\n\t\treturn 0;\n\n\toffset = cf->do_ftell(cf);\n\t/*\n\t * At EOF, the parser always \"inserts\" an extra '\\n', therefore\n\t * the end offset of the event is the current file position, otherwise\n\t * we will already have advanced to the next event.\n\t */\n\tif (type != CONFIG_EVENT_EOF)\n\t\toffset--;\n\n\tif (data->previous_type != CONFIG_EVENT_EOF &&\n\t    data->opts->event_fn(data->previous_type, data->previous_offset,\n\t\t\t\t offset, data->opts->event_fn_data) < 0)\n\t\treturn -1;\n\n\tdata->previous_type = type;\n\tdata->previous_offset = offset;\n\n\treturn 0;\n}\n\nstatic int git_parse_source(config_fn_t fn, void *data,\n\t\t\t    const struct config_options *opts)\n{\n\tint comment = 0;\n\tsize_t baselen = 0;\n\tstruct strbuf *var = &cf->var;\n\tint error_return = 0;\n\tchar *error_msg = NULL;\n\n\t/* U+FEFF Byte Order Mark in UTF8 */\n\tconst char *bomptr = utf8_bom;\n\n\t/* For the parser event callback */\n\tstruct parse_event_data event_data = {\n\t\tCONFIG_EVENT_EOF, 0, opts\n\t};\n\n\tfor (;;) {\n\t\tint c;\n\n\t\tc = get_next_char();\n\t\tif (bomptr && *bomptr) {\n\t\t\t/* We are at the file beginning; skip UTF8-encoded BOM\n\t\t\t * if present. Sane editors won't put this in on their\n\t\t\t * own, but e.g. Windows Notepad will do it happily. */\n\t\t\tif (c == (*bomptr & 0377)) {\n\t\t\t\tbomptr++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Do not tolerate partial BOM. */\n\t\t\t\tif (bomptr != utf8_bom)\n\t\t\t\t\tbreak;\n\t\t\t\t/* No BOM at file beginning. Cool. */\n\t\t\t\tbomptr = NULL;\n\t\t\t}\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tif (cf->eof) {\n\t\t\t\tif (do_event(CONFIG_EVENT_EOF, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (do_event(CONFIG_EVENT_WHITESPACE, &event_data) < 0)\n\t\t\t\treturn -1;\n\t\t\tcomment = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (comment)\n\t\t\tcontinue;\n\t\tif (isspace(c)) {\n\t\t\tif (do_event(CONFIG_EVENT_WHITESPACE, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '#' || c == ';') {\n\t\t\tif (do_event(CONFIG_EVENT_COMMENT, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\t\t\tcomment = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '[') {\n\t\t\tif (do_event(CONFIG_EVENT_SECTION, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t/* Reset prior to determining a new stem */\n\t\t\tstrbuf_reset(var);\n\t\t\tif (get_base_var(var) < 0 || var->len < 1)\n\t\t\t\tbreak;\n\t\t\tstrbuf_addch(var, '.');\n\t\t\tbaselen = var->len;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isalpha(c))\n\t\t\tbreak;\n\n\t\tif (do_event(CONFIG_EVENT_ENTRY, &event_data) < 0)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Truncate the var name back to the section header\n\t\t * stem prior to grabbing the suffix part of the name\n\t\t * and the value.\n\t\t */\n\t\tstrbuf_setlen(var, baselen);\n\t\tstrbuf_addch(var, tolower(c));\n\t\tif (get_value(fn, data, var) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (do_event(CONFIG_EVENT_ERROR, &event_data) < 0)\n\t\treturn -1;\n\n\tswitch (cf->origin_type) {\n\tcase CONFIG_ORIGIN_BLOB:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in blob %s\"),\n\t\t\t\t      cf->linenr, cf->name);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_FILE:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in file %s\"),\n\t\t\t\t      cf->linenr, cf->name);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_STDIN:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in standard input\"),\n\t\t\t\t      cf->linenr);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_SUBMODULE_BLOB:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in submodule-blob %s\"),\n\t\t\t\t       cf->linenr, cf->name);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_CMDLINE:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in command line %s\"),\n\t\t\t\t       cf->linenr, cf->name);\n\t\tbreak;\n\tdefault:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in %s\"),\n\t\t\t\t      cf->linenr, cf->name);\n\t}\n\n\tswitch (opts && opts->error_action ?\n\t\topts->error_action :\n\t\tcf->default_error_action) {\n\tcase CONFIG_ERROR_DIE:\n\t\tdie(\"%s\", error_msg);\n\t\tbreak;\n\tcase CONFIG_ERROR_ERROR:\n\t\terror_return = error(\"%s\", error_msg);\n\t\tbreak;\n\tcase CONFIG_ERROR_SILENT:\n\t\terror_return = -1;\n\t\tbreak;\n\tcase CONFIG_ERROR_UNSET:\n\t\tBUG(\"config error action unset\");\n\t}\n\n\tfree(error_msg);\n\treturn error_return;\n}\n\nstatic uintmax_t get_unit_factor(const char *end)\n{\n\tif (!*end)\n\t\treturn 1;\n\telse if (!strcasecmp(end, \"k\"))\n\t\treturn 1024;\n\telse if (!strcasecmp(end, \"m\"))\n\t\treturn 1024 * 1024;\n\telse if (!strcasecmp(end, \"g\"))\n\t\treturn 1024 * 1024 * 1024;\n\treturn 0;\n}\n\nstatic int git_parse_signed(const char *value, intmax_t *ret, intmax_t max)\n{\n\tif (value && *value) {\n\t\tchar *end;\n\t\tintmax_t val;\n\t\tuintmax_t uval;\n\t\tuintmax_t factor;\n\n\t\terrno = 0;\n\t\tval = strtoimax(value, &end, 0);\n\t\tif (errno == ERANGE)\n\t\t\treturn 0;\n\t\tfactor = get_unit_factor(end);\n\t\tif (!factor) {\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n\t\tuval = val < 0 ? -val : val;\n\t\tif (unsigned_mult_overflows(factor, uval) ||\n\t\t    factor * uval > max) {\n\t\t\terrno = ERANGE;\n\t\t\treturn 0;\n\t\t}\n\t\tval *= factor;\n\t\t*ret = val;\n\t\treturn 1;\n\t}\n\terrno = EINVAL;\n\treturn 0;\n}\n\nstatic int git_parse_unsigned(const char *value, uintmax_t *ret, uintmax_t max)\n{\n\tif (value && *value) {\n\t\tchar *end;\n\t\tuintmax_t val;\n\t\tuintmax_t factor;\n\n\t\terrno = 0;\n\t\tval = strtoumax(value, &end, 0);\n\t\tif (errno == ERANGE)\n\t\t\treturn 0;\n\t\tfactor = get_unit_factor(end);\n\t\tif (!factor) {\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n\t\tif (unsigned_mult_overflows(factor, val) ||\n\t\t    factor * val > max) {\n\t\t\terrno = ERANGE;\n\t\t\treturn 0;\n\t\t}\n\t\tval *= factor;\n\t\t*ret = val;\n\t\treturn 1;\n\t}\n\terrno = EINVAL;\n\treturn 0;\n}\n\nstatic int git_parse_int(const char *value, int *ret)\n{\n\tintmax_t tmp;\n\tif (!git_parse_signed(value, &tmp, maximum_signed_value_of_type(int)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nstatic int git_parse_int64(const char *value, int64_t *ret)\n{\n\tintmax_t tmp;\n\tif (!git_parse_signed(value, &tmp, maximum_signed_value_of_type(int64_t)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nint git_parse_ulong(const char *value, unsigned long *ret)\n{\n\tuintmax_t tmp;\n\tif (!git_parse_unsigned(value, &tmp, maximum_unsigned_value_of_type(long)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nint git_parse_ssize_t(const char *value, ssize_t *ret)\n{\n\tintmax_t tmp;\n\tif (!git_parse_signed(value, &tmp, maximum_signed_value_of_type(ssize_t)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nNORETURN\nstatic void die_bad_number(const char *name, const char *value)\n{\n\tconst char *error_type = (errno == ERANGE) ?\n\t\tN_(\"out of range\") : N_(\"invalid unit\");\n\tconst char *bad_numeric = N_(\"bad numeric config value '%s' for '%s': %s\");\n\n\tif (!value)\n\t\tvalue = \"\";\n\n\tif (!strcmp(name, \"GIT_TEST_GETTEXT_POISON\"))\n\t\t/*\n\t\t * We explicitly *don't* use _() here since it would\n\t\t * cause an infinite loop with _() needing to call\n\t\t * use_gettext_poison(). This is why marked up\n\t\t * translations with N_() above.\n\t\t */\n\t\tdie(bad_numeric, value, name, error_type);\n\n\tif (!(cf && cf->name))\n\t\tdie(_(bad_numeric), value, name, _(error_type));\n\n\tswitch (cf->origin_type) {\n\tcase CONFIG_ORIGIN_BLOB:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in blob %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tcase CONFIG_ORIGIN_FILE:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in file %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tcase CONFIG_ORIGIN_STDIN:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in standard input: %s\"),\n\t\t    value, name, _(error_type));\n\tcase CONFIG_ORIGIN_SUBMODULE_BLOB:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in submodule-blob %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tcase CONFIG_ORIGIN_CMDLINE:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in command line %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tdefault:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\t}\n}\n\nint git_config_int(const char *name, const char *value)\n{\n\tint ret;\n\tif (!git_parse_int(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nint64_t git_config_int64(const char *name, const char *value)\n{\n\tint64_t ret;\n\tif (!git_parse_int64(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nunsigned long git_config_ulong(const char *name, const char *value)\n{\n\tunsigned long ret;\n\tif (!git_parse_ulong(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nssize_t git_config_ssize_t(const char *name, const char *value)\n{\n\tssize_t ret;\n\tif (!git_parse_ssize_t(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nstatic int git_parse_maybe_bool_text(const char *value)\n{\n\tif (!value)\n\t\treturn 1;\n\tif (!*value)\n\t\treturn 0;\n\tif (!strcasecmp(value, \"true\")\n\t    || !strcasecmp(value, \"yes\")\n\t    || !strcasecmp(value, \"on\"))\n\t\treturn 1;\n\tif (!strcasecmp(value, \"false\")\n\t    || !strcasecmp(value, \"no\")\n\t    || !strcasecmp(value, \"off\"))\n\t\treturn 0;\n\treturn -1;\n}\n\nint git_parse_maybe_bool(const char *value)\n{\n\tint v = git_parse_maybe_bool_text(value);\n\tif (0 <= v)\n\t\treturn v;\n\tif (git_parse_int(value, &v))\n\t\treturn !!v;\n\treturn -1;\n}\n\nint git_config_bool_or_int(const char *name, const char *value, int *is_bool)\n{\n\tint v = git_parse_maybe_bool_text(value);\n\tif (0 <= v) {\n\t\t*is_bool = 1;\n\t\treturn v;\n\t}\n\t*is_bool = 0;\n\treturn git_config_int(name, value);\n}\n\nint git_config_bool(const char *name, const char *value)\n{\n\tint discard;\n\treturn !!git_config_bool_or_int(name, value, &discard);\n}\n\nint git_config_string(const char **dest, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\t*dest = xstrdup(value);\n\treturn 0;\n}\n\nint git_config_pathname(const char **dest, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\t*dest = expand_user_path(value, 0);\n\tif (!*dest)\n\t\tdie(_(\"failed to expand user dir in: '%s'\"), value);\n\treturn 0;\n}\n\nint git_config_expiry_date(timestamp_t *timestamp, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\tif (parse_expiry_date(value, timestamp))\n\t\treturn error(_(\"'%s' for '%s' is not a valid timestamp\"),\n\t\t\t     value, var);\n\treturn 0;\n}\n\nint git_config_color(char *dest, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\tif (color_parse(value, dest) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int git_default_core_config(const char *var, const char *value, void *cb)\n{\n\t/* This needs a better name */\n\tif (!strcmp(var, \"core.filemode\")) {\n\t\ttrust_executable_bit = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"core.trustctime\")) {\n\t\ttrust_ctime = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"core.checkstat\")) {\n\t\tif (!strcasecmp(value, \"default\"))\n\t\t\tcheck_stat = 1;\n\t\telse if (!strcasecmp(value, \"minimal\"))\n\t\t\tcheck_stat = 0;\n\t}\n\n\tif (!strcmp(var, \"core.quotepath\")) {\n\t\tquote_path_fully = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.symlinks\")) {\n\t\thas_symlinks = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.ignorecase\")) {\n\t\tignore_case = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.attributesfile\"))\n\t\treturn git_config_pathname(&git_attributes_file, var, value);\n\n\tif (!strcmp(var, \"core.hookspath\"))\n\t\treturn git_config_pathname(&git_hooks_path, var, value);\n\n\tif (!strcmp(var, \"core.bare\")) {\n\t\tis_bare_repository_cfg = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.ignorestat\")) {\n\t\tassume_unchanged = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.prefersymlinkrefs\")) {\n\t\tprefer_symlink_refs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.logallrefupdates\")) {\n\t\tif (value && !strcasecmp(value, \"always\"))\n\t\t\tlog_all_ref_updates = LOG_REFS_ALWAYS;\n\t\telse if (git_config_bool(var, value))\n\t\t\tlog_all_ref_updates = LOG_REFS_NORMAL;\n\t\telse\n\t\t\tlog_all_ref_updates = LOG_REFS_NONE;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.warnambiguousrefs\")) {\n\t\twarn_ambiguous_refs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.abbrev\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tif (!strcasecmp(value, \"auto\"))\n\t\t\tdefault_abbrev = -1;\n\t\telse {\n\t\t\tint abbrev = git_config_int(var, value);\n\t\t\tif (abbrev < minimum_abbrev || abbrev > the_hash_algo->hexsz)\n\t\t\t\treturn error(_(\"abbrev length out of range: %d\"), abbrev);\n\t\t\tdefault_abbrev = abbrev;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.disambiguate\"))\n\t\treturn set_disambiguate_hint_config(var, value);\n\n\tif (!strcmp(var, \"core.loosecompression\")) {\n\t\tint level = git_config_int(var, value);\n\t\tif (level == -1)\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\telse if (level < 0 || level > Z_BEST_COMPRESSION)\n\t\t\tdie(_(\"bad zlib compression level %d\"), level);\n\t\tzlib_compression_level = level;\n\t\tzlib_compression_seen = 1;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.compression\")) {\n\t\tint level = git_config_int(var, value);\n\t\tif (level == -1)\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\telse if (level < 0 || level > Z_BEST_COMPRESSION)\n\t\t\tdie(_(\"bad zlib compression level %d\"), level);\n\t\tcore_compression_level = level;\n\t\tcore_compression_seen = 1;\n\t\tif (!zlib_compression_seen)\n\t\t\tzlib_compression_level = level;\n\t\tif (!pack_compression_seen)\n\t\t\tpack_compression_level = level;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.packedgitwindowsize\")) {\n\t\tint pgsz_x2 = getpagesize() * 2;\n\t\tpacked_git_window_size = git_config_ulong(var, value);\n\n\t\t/* This value must be multiple of (pagesize * 2) */\n\t\tpacked_git_window_size /= pgsz_x2;\n\t\tif (packed_git_window_size < 1)\n\t\t\tpacked_git_window_size = 1;\n\t\tpacked_git_window_size *= pgsz_x2;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.bigfilethreshold\")) {\n\t\tbig_file_threshold = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.packedgitlimit\")) {\n\t\tpacked_git_limit = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.deltabasecachelimit\")) {\n\t\tdelta_base_cache_limit = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.autocrlf\")) {\n\t\tif (value && !strcasecmp(value, \"input\")) {\n\t\t\tauto_crlf = AUTO_CRLF_INPUT;\n\t\t\treturn 0;\n\t\t}\n\t\tauto_crlf = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.safecrlf\")) {\n\t\tint eol_rndtrp_die;\n\t\tif (value && !strcasecmp(value, \"warn\")) {\n\t\t\tglobal_conv_flags_eol = CONV_EOL_RNDTRP_WARN;\n\t\t\treturn 0;\n\t\t}\n\t\teol_rndtrp_die = git_config_bool(var, value);\n\t\tglobal_conv_flags_eol = eol_rndtrp_die ?\n\t\t\tCONV_EOL_RNDTRP_DIE : 0;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.eol\")) {\n\t\tif (value && !strcasecmp(value, \"lf\"))\n\t\t\tcore_eol = EOL_LF;\n\t\telse if (value && !strcasecmp(value, \"crlf\"))\n\t\t\tcore_eol = EOL_CRLF;\n\t\telse if (value && !strcasecmp(value, \"native\"))\n\t\t\tcore_eol = EOL_NATIVE;\n\t\telse\n\t\t\tcore_eol = EOL_UNSET;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.checkroundtripencoding\")) {\n\t\tcheck_roundtrip_encoding = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.notesref\")) {\n\t\tnotes_ref_name = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.editor\"))\n\t\treturn git_config_string(&editor_program, var, value);\n\n\tif (!strcmp(var, \"core.commentchar\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\telse if (!strcasecmp(value, \"auto\"))\n\t\t\tauto_comment_line_char = 1;\n\t\telse if (value[0] && !value[1]) {\n\t\t\tcomment_line_char = value[0];\n\t\t\tauto_comment_line_char = 0;\n\t\t} else\n\t\t\treturn error(_(\"core.commentChar should only be one character\"));\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.askpass\"))\n\t\treturn git_config_string(&askpass_program, var, value);\n\n\tif (!strcmp(var, \"core.excludesfile\"))\n\t\treturn git_config_pathname(&excludes_file, var, value);\n\n\tif (!strcmp(var, \"core.whitespace\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\twhitespace_rule_cfg = parse_whitespace_rule(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.fsyncobjectfiles\")) {\n\t\tfsync_object_files = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.preloadindex\")) {\n\t\tcore_preload_index = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.createobject\")) {\n\t\tif (!strcmp(value, \"rename\"))\n\t\t\tobject_creation_mode = OBJECT_CREATION_USES_RENAMES;\n\t\telse if (!strcmp(value, \"link\"))\n\t\t\tobject_creation_mode = OBJECT_CREATION_USES_HARDLINKS;\n\t\telse\n\t\t\tdie(_(\"invalid mode for object creation: %s\"), value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.sparsecheckout\")) {\n\t\tcore_apply_sparse_checkout = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.sparsecheckoutcone\")) {\n\t\tcore_sparse_checkout_cone = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.precomposeunicode\")) {\n\t\tprecomposed_unicode = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.protecthfs\")) {\n\t\tprotect_hfs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.protectntfs\")) {\n\t\tprotect_ntfs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.usereplacerefs\")) {\n\t\tread_replace_refs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn platform_core_config(var, value, cb);\n}\n\nstatic int git_default_i18n_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"i18n.commitencoding\"))\n\t\treturn git_config_string(&git_commit_encoding, var, value);\n\n\tif (!strcmp(var, \"i18n.logoutputencoding\"))\n\t\treturn git_config_string(&git_log_output_encoding, var, value);\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nstatic int git_default_branch_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"branch.autosetupmerge\")) {\n\t\tif (value && !strcasecmp(value, \"always\")) {\n\t\t\tgit_branch_track = BRANCH_TRACK_ALWAYS;\n\t\t\treturn 0;\n\t\t}\n\t\tgit_branch_track = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"branch.autosetuprebase\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\telse if (!strcmp(value, \"never\"))\n\t\t\tautorebase = AUTOREBASE_NEVER;\n\t\telse if (!strcmp(value, \"local\"))\n\t\t\tautorebase = AUTOREBASE_LOCAL;\n\t\telse if (!strcmp(value, \"remote\"))\n\t\t\tautorebase = AUTOREBASE_REMOTE;\n\t\telse if (!strcmp(value, \"always\"))\n\t\t\tautorebase = AUTOREBASE_ALWAYS;\n\t\telse\n\t\t\treturn error(_(\"malformed value for %s\"), var);\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nstatic int git_default_push_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"push.default\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\telse if (!strcmp(value, \"nothing\"))\n\t\t\tpush_default = PUSH_DEFAULT_NOTHING;\n\t\telse if (!strcmp(value, \"matching\"))\n\t\t\tpush_default = PUSH_DEFAULT_MATCHING;\n\t\telse if (!strcmp(value, \"simple\"))\n\t\t\tpush_default = PUSH_DEFAULT_SIMPLE;\n\t\telse if (!strcmp(value, \"upstream\"))\n\t\t\tpush_default = PUSH_DEFAULT_UPSTREAM;\n\t\telse if (!strcmp(value, \"tracking\")) /* deprecated */\n\t\t\tpush_default = PUSH_DEFAULT_UPSTREAM;\n\t\telse if (!strcmp(value, \"current\"))\n\t\t\tpush_default = PUSH_DEFAULT_CURRENT;\n\t\telse {\n\t\t\terror(_(\"malformed value for %s: %s\"), var, value);\n\t\t\treturn error(_(\"must be one of nothing, matching, simple, \"\n\t\t\t\t       \"upstream or current\"));\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nstatic int git_default_mailmap_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"mailmap.file\"))\n\t\treturn git_config_pathname(&git_mailmap_file, var, value);\n\tif (!strcmp(var, \"mailmap.blob\"))\n\t\treturn git_config_string(&git_mailmap_blob, var, value);\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nint git_default_config(const char *var, const char *value, void *cb)\n{\n\tif (starts_with(var, \"core.\"))\n\t\treturn git_default_core_config(var, value, cb);\n\n\tif (starts_with(var, \"user.\") ||\n\t    starts_with(var, \"author.\") ||\n\t    starts_with(var, \"committer.\"))\n\t\treturn git_ident_config(var, value, cb);\n\n\tif (starts_with(var, \"i18n.\"))\n\t\treturn git_default_i18n_config(var, value);\n\n\tif (starts_with(var, \"branch.\"))\n\t\treturn git_default_branch_config(var, value);\n\n\tif (starts_with(var, \"push.\"))\n\t\treturn git_default_push_config(var, value);\n\n\tif (starts_with(var, \"mailmap.\"))\n\t\treturn git_default_mailmap_config(var, value);\n\n\tif (starts_with(var, \"advice.\") || starts_with(var, \"color.advice\"))\n\t\treturn git_default_advice_config(var, value);\n\n\tif (!strcmp(var, \"pager.color\") || !strcmp(var, \"color.pager\")) {\n\t\tpager_use_color = git_config_bool(var,value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"pack.packsizelimit\")) {\n\t\tpack_size_limit_cfg = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"pack.compression\")) {\n\t\tint level = git_config_int(var, value);\n\t\tif (level == -1)\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\telse if (level < 0 || level > Z_BEST_COMPRESSION)\n\t\t\tdie(_(\"bad pack compression level %d\"), level);\n\t\tpack_compression_level = level;\n\t\tpack_compression_seen = 1;\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\n/*\n * All source specific fields in the union, die_on_error, name and the callbacks\n * fgetc, ungetc, ftell of top need to be initialized before calling\n * this function.\n */\nstatic int do_config_from(struct config_source *top, config_fn_t fn, void *data,\n\t\t\t  const struct config_options *opts)\n{\n\tint ret;\n\n\t/* push config-file parsing state stack */\n\ttop->prev = cf;\n\ttop->linenr = 1;\n\ttop->eof = 0;\n\ttop->total_len = 0;\n\tstrbuf_init(&top->value, 1024);\n\tstrbuf_init(&top->var, 1024);\n\tcf = top;\n\n\tret = git_parse_source(fn, data, opts);\n\n\t/* pop config-file parsing state stack */\n\tstrbuf_release(&top->value);\n\tstrbuf_release(&top->var);\n\tcf = top->prev;\n\n\treturn ret;\n}\n\nstatic int do_config_from_file(config_fn_t fn,\n\t\tconst enum config_origin_type origin_type,\n\t\tconst char *name, const char *path, FILE *f,\n\t\tvoid *data, const struct config_options *opts)\n{\n\tstruct config_source top;\n\tint ret;\n\n\ttop.u.file = f;\n\ttop.origin_type = origin_type;\n\ttop.name = name;\n\ttop.path = path;\n\ttop.default_error_action = CONFIG_ERROR_DIE;\n\ttop.do_fgetc = config_file_fgetc;\n\ttop.do_ungetc = config_file_ungetc;\n\ttop.do_ftell = config_file_ftell;\n\n\tflockfile(f);\n\tret = do_config_from(&top, fn, data, opts);\n\tfunlockfile(f);\n\treturn ret;\n}\n\nstatic int git_config_from_stdin(config_fn_t fn, void *data)\n{\n\treturn do_config_from_file(fn, CONFIG_ORIGIN_STDIN, \"\", NULL, stdin,\n\t\t\t\t   data, NULL);\n}\n\nint git_config_from_file_with_options(config_fn_t fn, const char *filename,\n\t\t\t\t      void *data,\n\t\t\t\t      const struct config_options *opts)\n{\n\tint ret = -1;\n\tFILE *f;\n\n\tf = fopen_or_warn(filename, \"r\");\n\tif (f) {\n\t\tret = do_config_from_file(fn, CONFIG_ORIGIN_FILE, filename,\n\t\t\t\t\t  filename, f, data, opts);\n\t\tfclose(f);\n\t}\n\treturn ret;\n}\n\nint git_config_from_file(config_fn_t fn, const char *filename, void *data)\n{\n\treturn git_config_from_file_with_options(fn, filename, data, NULL);\n}\n\nint git_config_from_mem(config_fn_t fn,\n\t\t\tconst enum config_origin_type origin_type,\n\t\t\tconst char *name, const char *buf, size_t len,\n\t\t\tvoid *data, const struct config_options *opts)\n{\n\tstruct config_source top;\n\n\ttop.u.buf.buf = buf;\n\ttop.u.buf.len = len;\n\ttop.u.buf.pos = 0;\n\ttop.origin_type = origin_type;\n\ttop.name = name;\n\ttop.path = NULL;\n\ttop.default_error_action = CONFIG_ERROR_ERROR;\n\ttop.do_fgetc = config_buf_fgetc;\n\ttop.do_ungetc = config_buf_ungetc;\n\ttop.do_ftell = config_buf_ftell;\n\n\treturn do_config_from(&top, fn, data, opts);\n}\n\nint git_config_from_blob_oid(config_fn_t fn,\n\t\t\t      const char *name,\n\t\t\t      const struct object_id *oid,\n\t\t\t      void *data)\n{\n\tenum object_type type;\n\tchar *buf;\n\tunsigned long size;\n\tint ret;\n\n\tbuf = read_object_file(oid, &type, &size);\n\tif (!buf)\n\t\treturn error(_(\"unable to load config blob object '%s'\"), name);\n\tif (type != OBJ_BLOB) {\n\t\tfree(buf);\n\t\treturn error(_(\"reference '%s' does not point to a blob\"), name);\n\t}\n\n\tret = git_config_from_mem(fn, CONFIG_ORIGIN_BLOB, name, buf, size,\n\t\t\t\t  data, NULL);\n\tfree(buf);\n\n\treturn ret;\n}\n\nstatic int git_config_from_blob_ref(config_fn_t fn,\n\t\t\t\t    const char *name,\n\t\t\t\t    void *data)\n{\n\tstruct object_id oid;\n\n\tif (get_oid(name, &oid) < 0)\n\t\treturn error(_(\"unable to resolve config blob '%s'\"), name);\n\treturn git_config_from_blob_oid(fn, name, &oid, data);\n}\n\nconst char *git_etc_gitconfig(void)\n{\n\tstatic const char *system_wide;\n\tif (!system_wide)\n\t\tsystem_wide = system_path(ETC_GITCONFIG);\n\treturn system_wide;\n}\n\n/*\n * Parse environment variable 'k' as a boolean (in various\n * possible spellings); if missing, use the default value 'def'.\n */\nint git_env_bool(const char *k, int def)\n{\n\tconst char *v = getenv(k);\n\treturn v ? git_config_bool(k, v) : def;\n}\n\n/*\n * Parse environment variable 'k' as ulong with possibly a unit\n * suffix; if missing, use the default value 'val'.\n */\nunsigned long git_env_ulong(const char *k, unsigned long val)\n{\n\tconst char *v = getenv(k);\n\tif (v && !git_parse_ulong(v, &val))\n\t\tdie(_(\"failed to parse %s\"), k);\n\treturn val;\n}\n\nint git_config_system(void)\n{\n\treturn !git_env_bool(\"GIT_CONFIG_NOSYSTEM\", 0);\n}\n\nstatic int do_git_config_sequence(const struct config_options *opts,\n\t\t\t\t  config_fn_t fn, void *data)\n{\n\tint ret = 0;\n\tchar *xdg_config = xdg_config_home(\"config\");\n\tchar *user_config = expand_user_path(\"~/.gitconfig\", 0);\n\tchar *repo_config;\n\tenum config_scope prev_parsing_scope = current_parsing_scope;\n\n\tif (opts->commondir)\n\t\trepo_config = mkpathdup(\"%s/config\", opts->commondir);\n\telse if (opts->git_dir)\n\t\tBUG(\"git_dir without commondir\");\n\telse\n\t\trepo_config = NULL;\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_SYSTEM;\n\tif (git_config_system() && !access_or_die(git_etc_gitconfig(), R_OK,\n\t\t\t\t\t\t  opts->system_gently ?\n\t\t\t\t\t\t  ACCESS_EACCES_OK : 0))\n\t\tret += git_config_from_file(fn, git_etc_gitconfig(),\n\t\t\t\t\t    data);\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_GLOBAL;\n\tif (xdg_config && !access_or_die(xdg_config, R_OK, ACCESS_EACCES_OK))\n\t\tret += git_config_from_file(fn, xdg_config, data);\n\n\tif (user_config && !access_or_die(user_config, R_OK, ACCESS_EACCES_OK))\n\t\tret += git_config_from_file(fn, user_config, data);\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_LOCAL;\n\tif (!opts->ignore_repo && repo_config &&\n\t    !access_or_die(repo_config, R_OK, 0))\n\t\tret += git_config_from_file(fn, repo_config, data);\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_WORKTREE;\n\tif (!opts->ignore_worktree && repository_format_worktree_config) {\n\t\tchar *path = git_pathdup(\"config.worktree\");\n\t\tif (!access_or_die(path, R_OK, 0))\n\t\t\tret += git_config_from_file(fn, path, data);\n\t\tfree(path);\n\t}\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_COMMAND;\n\tif (!opts->ignore_cmdline && git_config_from_parameters(fn, data) < 0)\n\t\tdie(_(\"unable to parse command-line config\"));\n\n\tcurrent_parsing_scope = prev_parsing_scope;\n\tfree(xdg_config);\n\tfree(user_config);\n\tfree(repo_config);\n\treturn ret;\n}\n\nint config_with_options(config_fn_t fn, void *data,\n\t\t\tstruct git_config_source *config_source,\n\t\t\tconst struct config_options *opts)\n{\n\tstruct config_include_data inc = CONFIG_INCLUDE_INIT;\n\n\tif (opts->respect_includes) {\n\t\tinc.fn = fn;\n\t\tinc.data = data;\n\t\tinc.opts = opts;\n\t\tfn = git_config_include;\n\t\tdata = &inc;\n\t}\n\n\tif (config_source)\n\t\tcurrent_parsing_scope = config_source->scope;\n\n\t/*\n\t * If we have a specific filename, use it. Otherwise, follow the\n\t * regular lookup sequence.\n\t */\n\tif (config_source && config_source->use_stdin)\n\t\treturn git_config_from_stdin(fn, data);\n\telse if (config_source && config_source->file)\n\t\treturn git_config_from_file(fn, config_source->file, data);\n\telse if (config_source && config_source->blob)\n\t\treturn git_config_from_blob_ref(fn, config_source->blob, data);\n\n\treturn do_git_config_sequence(opts, fn, data);\n}\n\nstatic void configset_iter(struct config_set *cs, config_fn_t fn, void *data)\n{\n\tint i, value_index;\n\tstruct string_list *values;\n\tstruct config_set_element *entry;\n\tstruct configset_list *list = &cs->list;\n\n\tfor (i = 0; i < list->nr; i++) {\n\t\tentry = list->items[i].e;\n\t\tvalue_index = list->items[i].value_index;\n\t\tvalues = &entry->value_list;\n\n\t\tcurrent_config_kvi = values->items[value_index].util;\n\n\t\tif (fn(entry->key, values->items[value_index].string, data) < 0)\n\t\t\tgit_die_config_linenr(entry->key,\n\t\t\t\t\t      current_config_kvi->filename,\n\t\t\t\t\t      current_config_kvi->linenr);\n\n\t\tcurrent_config_kvi = NULL;\n\t}\n}\n\nvoid read_early_config(config_fn_t cb, void *data)\n{\n\tstruct config_options opts = {0};\n\tstruct strbuf commondir = STRBUF_INIT;\n\tstruct strbuf gitdir = STRBUF_INIT;\n\n\topts.respect_includes = 1;\n\n\tif (have_git_dir()) {\n\t\topts.commondir = get_git_common_dir();\n\t\topts.git_dir = get_git_dir();\n\t/*\n\t * When setup_git_directory() was not yet asked to discover the\n\t * GIT_DIR, we ask discover_git_directory() to figure out whether there\n\t * is any repository config we should use (but unlike\n\t * setup_git_directory_gently(), no global state is changed, most\n\t * notably, the current working directory is still the same after the\n\t * call).\n\t */\n\t} else if (!discover_git_directory(&commondir, &gitdir)) {\n\t\topts.commondir = commondir.buf;\n\t\topts.git_dir = gitdir.buf;\n\t}\n\n\tconfig_with_options(cb, data, NULL, &opts);\n\n\tstrbuf_release(&commondir);\n\tstrbuf_release(&gitdir);\n}\n\n/*\n * Read config but only enumerate system and global settings.\n * Omit any repo-local, worktree-local, or command-line settings.\n */\nvoid read_very_early_config(config_fn_t cb, void *data)\n{\n\tstruct config_options opts = { 0 };\n\n\topts.respect_includes = 1;\n\topts.ignore_repo = 1;\n\topts.ignore_worktree = 1;\n\topts.ignore_cmdline = 1;\n\topts.system_gently = 1;\n\n\tconfig_with_options(cb, data, NULL, &opts);\n}\n\nstatic struct config_set_element *configset_find_element(struct config_set *cs, const char *key)\n{\n\tstruct config_set_element k;\n\tstruct config_set_element *found_entry;\n\tchar *normalized_key;\n\t/*\n\t * `key` may come from the user, so normalize it before using it\n\t * for querying entries from the hashmap.\n\t */\n\tif (git_config_parse_key(key, &normalized_key, NULL))\n\t\treturn NULL;\n\n\thashmap_entry_init(&k.ent, strhash(normalized_key));\n\tk.key = normalized_key;\n\tfound_entry = hashmap_get_entry(&cs->config_hash, &k, ent, NULL);\n\tfree(normalized_key);\n\treturn found_entry;\n}\n\nstatic int configset_add_value(struct config_set *cs, const char *key, const char *value)\n{\n\tstruct config_set_element *e;\n\tstruct string_list_item *si;\n\tstruct configset_list_item *l_item;\n\tstruct key_value_info *kv_info = xmalloc(sizeof(*kv_info));\n\n\te = configset_find_element(cs, key);\n\t/*\n\t * Since the keys are being fed by git_config*() callback mechanism, they\n\t * are already normalized. So simply add them without any further munging.\n\t */\n\tif (!e) {\n\t\te = xmalloc(sizeof(*e));\n\t\thashmap_entry_init(&e->ent, strhash(key));\n\t\te->key = xstrdup(key);\n\t\tstring_list_init(&e->value_list, 1);\n\t\thashmap_add(&cs->config_hash, &e->ent);\n\t}\n\tsi = string_list_append_nodup(&e->value_list, xstrdup_or_null(value));\n\n\tALLOC_GROW(cs->list.items, cs->list.nr + 1, cs->list.alloc);\n\tl_item = &cs->list.items[cs->list.nr++];\n\tl_item->e = e;\n\tl_item->value_index = e->value_list.nr - 1;\n\n\tif (!cf)\n\t\tBUG(\"configset_add_value has no source\");\n\tif (cf->name) {\n\t\tkv_info->filename = strintern(cf->name);\n\t\tkv_info->linenr = cf->linenr;\n\t\tkv_info->origin_type = cf->origin_type;\n\t} else {\n\t\t/* for values read from `git_config_from_parameters()` */\n\t\tkv_info->filename = NULL;\n\t\tkv_info->linenr = -1;\n\t\tkv_info->origin_type = CONFIG_ORIGIN_CMDLINE;\n\t}\n\tkv_info->scope = current_parsing_scope;\n\tsi->util = kv_info;\n\n\treturn 0;\n}\n\nstatic int config_set_element_cmp(const void *unused_cmp_data,\n\t\t\t\t  const struct hashmap_entry *eptr,\n\t\t\t\t  const struct hashmap_entry *entry_or_key,\n\t\t\t\t  const void *unused_keydata)\n{\n\tconst struct config_set_element *e1, *e2;\n\n\te1 = container_of(eptr, const struct config_set_element, ent);\n\te2 = container_of(entry_or_key, const struct config_set_element, ent);\n\n\treturn strcmp(e1->key, e2->key);\n}\n\nvoid git_configset_init(struct config_set *cs)\n{\n\thashmap_init(&cs->config_hash, config_set_element_cmp, NULL, 0);\n\tcs->hash_initialized = 1;\n\tcs->list.nr = 0;\n\tcs->list.alloc = 0;\n\tcs->list.items = NULL;\n}\n\nvoid git_configset_clear(struct config_set *cs)\n{\n\tstruct config_set_element *entry;\n\tstruct hashmap_iter iter;\n\tif (!cs->hash_initialized)\n\t\treturn;\n\n\thashmap_for_each_entry(&cs->config_hash, &iter, entry,\n\t\t\t\tent /* member name */) {\n\t\tfree(entry->key);\n\t\tstring_list_clear(&entry->value_list, 1);\n\t}\n\thashmap_clear_and_free(&cs->config_hash, struct config_set_element, ent);\n\tcs->hash_initialized = 0;\n\tfree(cs->list.items);\n\tcs->list.nr = 0;\n\tcs->list.alloc = 0;\n\tcs->list.items = NULL;\n}\n\nstatic int config_set_callback(const char *key, const char *value, void *cb)\n{\n\tstruct config_set *cs = cb;\n\tconfigset_add_value(cs, key, value);\n\treturn 0;\n}\n\nint git_configset_add_file(struct config_set *cs, const char *filename)\n{\n\treturn git_config_from_file(config_set_callback, filename, cs);\n}\n\nint git_configset_get_value(struct config_set *cs, const char *key, const char **value)\n{\n\tconst struct string_list *values = NULL;\n\t/*\n\t * Follows \"last one wins\" semantic, i.e., if there are multiple matches for the\n\t * queried key in the files of the configset, the value returned will be the last\n\t * value in the value list for that key.\n\t */\n\tvalues = git_configset_get_value_multi(cs, key);\n\n\tif (!values)\n\t\treturn 1;\n\tassert(values->nr > 0);\n\t*value = values->items[values->nr - 1].string;\n\treturn 0;\n}\n\nconst struct string_list *git_configset_get_value_multi(struct config_set *cs, const char *key)\n{\n\tstruct config_set_element *e = configset_find_element(cs, key);\n\treturn e ? &e->value_list : NULL;\n}\n\nint git_configset_get_string(struct config_set *cs, const char *key, char **dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value))\n\t\treturn git_config_string((const char **)dest, key, value);\n\telse\n\t\treturn 1;\n}\n\nint git_configset_get_string_tmp(struct config_set *cs, const char *key,\n\t\t\t\t const char **dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(key);\n\t\t*dest = value;\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\nint git_configset_get_int(struct config_set *cs, const char *key, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_int(key, value);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_ulong(struct config_set *cs, const char *key, unsigned long *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_ulong(key, value);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_bool(struct config_set *cs, const char *key, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_bool(key, value);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_bool_or_int(struct config_set *cs, const char *key,\n\t\t\t\tint *is_bool, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_bool_or_int(key, value, is_bool);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_maybe_bool(struct config_set *cs, const char *key, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_parse_maybe_bool(value);\n\t\tif (*dest == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_pathname(struct config_set *cs, const char *key, const char **dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value))\n\t\treturn git_config_pathname(dest, key, value);\n\telse\n\t\treturn 1;\n}\n\n/* Functions use to read configuration from a repository */\nstatic void repo_read_config(struct repository *repo)\n{\n\tstruct config_options opts = { 0 };\n\n\topts.respect_includes = 1;\n\topts.commondir = repo->commondir;\n\topts.git_dir = repo->gitdir;\n\n\tif (!repo->config)\n\t\trepo->config = xcalloc(1, sizeof(struct config_set));\n\telse\n\t\tgit_configset_clear(repo->config);\n\n\tgit_configset_init(repo->config);\n\n\tif (config_with_options(config_set_callback, repo->config, NULL, &opts) < 0)\n\t\t/*\n\t\t * config_with_options() normally returns only\n\t\t * zero, as most errors are fatal, and\n\t\t * non-fatal potential errors are guarded by \"if\"\n\t\t * statements that are entered only when no error is\n\t\t * possible.\n\t\t *\n\t\t * If we ever encounter a non-fatal error, it means\n\t\t * something went really wrong and we should stop\n\t\t * immediately.\n\t\t */\n\t\tdie(_(\"unknown error occurred while reading the configuration files\"));\n}\n\nstatic void git_config_check_init(struct repository *repo)\n{\n\tif (repo->config && repo->config->hash_initialized)\n\t\treturn;\n\trepo_read_config(repo);\n}\n\nstatic void repo_config_clear(struct repository *repo)\n{\n\tif (!repo->config || !repo->config->hash_initialized)\n\t\treturn;\n\tgit_configset_clear(repo->config);\n}\n\nvoid repo_config(struct repository *repo, config_fn_t fn, void *data)\n{\n\tgit_config_check_init(repo);\n\tconfigset_iter(repo->config, fn, data);\n}\n\nint repo_config_get_value(struct repository *repo,\n\t\t\t  const char *key, const char **value)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_value(repo->config, key, value);\n}\n\nconst struct string_list *repo_config_get_value_multi(struct repository *repo,\n\t\t\t\t\t\t      const char *key)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_value_multi(repo->config, key);\n}\n\nint repo_config_get_string(struct repository *repo,\n\t\t\t   const char *key, char **dest)\n{\n\tint ret;\n\tgit_config_check_init(repo);\n\tret = git_configset_get_string(repo->config, key, dest);\n\tif (ret < 0)\n\t\tgit_die_config(key, NULL);\n\treturn ret;\n}\n\nint repo_config_get_string_tmp(struct repository *repo,\n\t\t\t       const char *key, const char **dest)\n{\n\tint ret;\n\tgit_config_check_init(repo);\n\tret = git_configset_get_string_tmp(repo->config, key, dest);\n\tif (ret < 0)\n\t\tgit_die_config(key, NULL);\n\treturn ret;\n}\n\nint repo_config_get_int(struct repository *repo,\n\t\t\tconst char *key, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_int(repo->config, key, dest);\n}\n\nint repo_config_get_ulong(struct repository *repo,\n\t\t\t  const char *key, unsigned long *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_ulong(repo->config, key, dest);\n}\n\nint repo_config_get_bool(struct repository *repo,\n\t\t\t const char *key, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_bool(repo->config, key, dest);\n}\n\nint repo_config_get_bool_or_int(struct repository *repo,\n\t\t\t\tconst char *key, int *is_bool, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_bool_or_int(repo->config, key, is_bool, dest);\n}\n\nint repo_config_get_maybe_bool(struct repository *repo,\n\t\t\t       const char *key, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_maybe_bool(repo->config, key, dest);\n}\n\nint repo_config_get_pathname(struct repository *repo,\n\t\t\t     const char *key, const char **dest)\n{\n\tint ret;\n\tgit_config_check_init(repo);\n\tret = git_configset_get_pathname(repo->config, key, dest);\n\tif (ret < 0)\n\t\tgit_die_config(key, NULL);\n\treturn ret;\n}\n\n/* Functions used historically to read configuration from 'the_repository' */\nvoid git_config(config_fn_t fn, void *data)\n{\n\trepo_config(the_repository, fn, data);\n}\n\nvoid git_config_clear(void)\n{\n\trepo_config_clear(the_repository);\n}\n\nint git_config_get_value(const char *key, const char **value)\n{\n\treturn repo_config_get_value(the_repository, key, value);\n}\n\nconst struct string_list *git_config_get_value_multi(const char *key)\n{\n\treturn repo_config_get_value_multi(the_repository, key);\n}\n\nint git_config_get_string(const char *key, char **dest)\n{\n\treturn repo_config_get_string(the_repository, key, dest);\n}\n\nint git_config_get_string_tmp(const char *key, const char **dest)\n{\n\treturn repo_config_get_string_tmp(the_repository, key, dest);\n}\n\nint git_config_get_int(const char *key, int *dest)\n{\n\treturn repo_config_get_int(the_repository, key, dest);\n}\n\nint git_config_get_ulong(const char *key, unsigned long *dest)\n{\n\treturn repo_config_get_ulong(the_repository, key, dest);\n}\n\nint git_config_get_bool(const char *key, int *dest)\n{\n\treturn repo_config_get_bool(the_repository, key, dest);\n}\n\nint git_config_get_bool_or_int(const char *key, int *is_bool, int *dest)\n{\n\treturn repo_config_get_bool_or_int(the_repository, key, is_bool, dest);\n}\n\nint git_config_get_maybe_bool(const char *key, int *dest)\n{\n\treturn repo_config_get_maybe_bool(the_repository, key, dest);\n}\n\nint git_config_get_pathname(const char *key, const char **dest)\n{\n\treturn repo_config_get_pathname(the_repository, key, dest);\n}\n\nint git_config_get_expiry(const char *key, const char **output)\n{\n\tint ret = git_config_get_string(key, (char **)output);\n\tif (ret)\n\t\treturn ret;\n\tif (strcmp(*output, \"now\")) {\n\t\ttimestamp_t now = approxidate(\"now\");\n\t\tif (approxidate(*output) >= now)\n\t\t\tgit_die_config(key, _(\"Invalid %s: '%s'\"), key, *output);\n\t}\n\treturn ret;\n}\n\nint git_config_get_expiry_in_days(const char *key, timestamp_t *expiry, timestamp_t now)\n{\n\tconst char *expiry_string;\n\tintmax_t days;\n\ttimestamp_t when;\n\n\tif (git_config_get_string_tmp(key, &expiry_string))\n\t\treturn 1; /* no such thing */\n\n\tif (git_parse_signed(expiry_string, &days, maximum_signed_value_of_type(int))) {\n\t\tconst int scale = 86400;\n\t\t*expiry = now - days * scale;\n\t\treturn 0;\n\t}\n\n\tif (!parse_expiry_date(expiry_string, &when)) {\n\t\t*expiry = when;\n\t\treturn 0;\n\t}\n\treturn -1; /* thing exists but cannot be parsed */\n}\n\nint git_config_get_split_index(void)\n{\n\tint val;\n\n\tif (!git_config_get_maybe_bool(\"core.splitindex\", &val))\n\t\treturn val;\n\n\treturn -1; /* default value */\n}\n\nint git_config_get_max_percent_split_change(void)\n{\n\tint val = -1;\n\n\tif (!git_config_get_int(\"splitindex.maxpercentchange\", &val)) {\n\t\tif (0 <= val && val <= 100)\n\t\t\treturn val;\n\n\t\treturn error(_(\"splitIndex.maxPercentChange value '%d' \"\n\t\t\t       \"should be between 0 and 100\"), val);\n\t}\n\n\treturn -1; /* default value */\n}\n\nint git_config_get_fsmonitor(void)\n{\n\tif (git_config_get_pathname(\"core.fsmonitor\", &core_fsmonitor))\n\t\tcore_fsmonitor = getenv(\"GIT_TEST_FSMONITOR\");\n\n\tif (core_fsmonitor && !*core_fsmonitor)\n\t\tcore_fsmonitor = NULL;\n\n\tif (core_fsmonitor)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint git_config_get_index_threads(int *dest)\n{\n\tint is_bool, val;\n\n\tval = git_env_ulong(\"GIT_TEST_INDEX_THREADS\", 0);\n\tif (val) {\n\t\t*dest = val;\n\t\treturn 0;\n\t}\n\n\tif (!git_config_get_bool_or_int(\"index.threads\", &is_bool, &val)) {\n\t\tif (is_bool)\n\t\t\t*dest = val ? 0 : 1;\n\t\telse\n\t\t\t*dest = val;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nNORETURN\nvoid git_die_config_linenr(const char *key, const char *filename, int linenr)\n{\n\tif (!filename)\n\t\tdie(_(\"unable to parse '%s' from command-line config\"), key);\n\telse\n\t\tdie(_(\"bad config variable '%s' in file '%s' at line %d\"),\n\t\t    key, filename, linenr);\n}\n\nNORETURN __attribute__((format(printf, 2, 3)))\nvoid git_die_config(const char *key, const char *err, ...)\n{\n\tconst struct string_list *values;\n\tstruct key_value_info *kv_info;\n\n\tif (err) {\n\t\tva_list params;\n\t\tva_start(params, err);\n\t\tvreportf(\"error: \", err, params);\n\t\tva_end(params);\n\t}\n\tvalues = git_config_get_value_multi(key);\n\tkv_info = values->items[values->nr - 1].util;\n\tgit_die_config_linenr(key, kv_info->filename, kv_info->linenr);\n}\n\n/*\n * Find all the stuff for git_config_set() below.\n */\n\nstruct config_store_data {\n\tsize_t baselen;\n\tchar *key;\n\tint do_not_match;\n\tconst char *fixed_value;\n\tregex_t *value_pattern;\n\tint multi_replace;\n\tstruct {\n\t\tsize_t begin, end;\n\t\tenum config_event_t type;\n\t\tint is_keys_section;\n\t} *parsed;\n\tunsigned int parsed_nr, parsed_alloc, *seen, seen_nr, seen_alloc;\n\tunsigned int key_seen:1, section_seen:1, is_keys_section:1;\n};\n\nstatic void config_store_data_clear(struct config_store_data *store)\n{\n\tfree(store->key);\n\tif (store->value_pattern != NULL &&\n\t    store->value_pattern != CONFIG_REGEX_NONE) {\n\t\tregfree(store->value_pattern);\n\t\tfree(store->value_pattern);\n\t}\n\tfree(store->parsed);\n\tfree(store->seen);\n\tmemset(store, 0, sizeof(*store));\n}\n\nstatic int matches(const char *key, const char *value,\n\t\t   const struct config_store_data *store)\n{\n\tif (strcmp(key, store->key))\n\t\treturn 0; /* not ours */\n\tif (store->fixed_value)\n\t\treturn !strcmp(store->fixed_value, value);\n\tif (!store->value_pattern)\n\t\treturn 1; /* always matches */\n\tif (store->value_pattern == CONFIG_REGEX_NONE)\n\t\treturn 0; /* never matches */\n\n\treturn store->do_not_match ^\n\t\t(value && !regexec(store->value_pattern, value, 0, NULL, 0));\n}\n\nstatic int store_aux_event(enum config_event_t type,\n\t\t\t   size_t begin, size_t end, void *data)\n{\n\tstruct config_store_data *store = data;\n\n\tALLOC_GROW(store->parsed, store->parsed_nr + 1, store->parsed_alloc);\n\tstore->parsed[store->parsed_nr].begin = begin;\n\tstore->parsed[store->parsed_nr].end = end;\n\tstore->parsed[store->parsed_nr].type = type;\n\n\tif (type == CONFIG_EVENT_SECTION) {\n\t\tint (*cmpfn)(const char *, const char *, size_t);\n\n\t\tif (cf->var.len < 2 || cf->var.buf[cf->var.len - 1] != '.')\n\t\t\treturn error(_(\"invalid section name '%s'\"), cf->var.buf);\n\n\t\tif (cf->subsection_case_sensitive)\n\t\t\tcmpfn = strncasecmp;\n\t\telse\n\t\t\tcmpfn = strncmp;\n\n\t\t/* Is this the section we were looking for? */\n\t\tstore->is_keys_section =\n\t\t\tstore->parsed[store->parsed_nr].is_keys_section =\n\t\t\tcf->var.len - 1 == store->baselen &&\n\t\t\t!cmpfn(cf->var.buf, store->key, store->baselen);\n\t\tif (store->is_keys_section) {\n\t\t\tstore->section_seen = 1;\n\t\t\tALLOC_GROW(store->seen, store->seen_nr + 1,\n\t\t\t\t   store->seen_alloc);\n\t\t\tstore->seen[store->seen_nr] = store->parsed_nr;\n\t\t}\n\t}\n\n\tstore->parsed_nr++;\n\n\treturn 0;\n}\n\nstatic int store_aux(const char *key, const char *value, void *cb)\n{\n\tstruct config_store_data *store = cb;\n\n\tif (store->key_seen) {\n\t\tif (matches(key, value, store)) {\n\t\t\tif (store->seen_nr == 1 && store->multi_replace == 0) {\n\t\t\t\twarning(_(\"%s has multiple values\"), key);\n\t\t\t}\n\n\t\t\tALLOC_GROW(store->seen, store->seen_nr + 1,\n\t\t\t\t   store->seen_alloc);\n\n\t\t\tstore->seen[store->seen_nr] = store->parsed_nr;\n\t\t\tstore->seen_nr++;\n\t\t}\n\t} else if (store->is_keys_section) {\n\t\t/*\n\t\t * Do not increment matches yet: this may not be a match, but we\n\t\t * are in the desired section.\n\t\t */\n\t\tALLOC_GROW(store->seen, store->seen_nr + 1, store->seen_alloc);\n\t\tstore->seen[store->seen_nr] = store->parsed_nr;\n\t\tstore->section_seen = 1;\n\n\t\tif (matches(key, value, store)) {\n\t\t\tstore->seen_nr++;\n\t\t\tstore->key_seen = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int write_error(const char *filename)\n{\n\terror(_(\"failed to write new configuration file %s\"), filename);\n\n\t/* Same error code as \"failed to rename\". */\n\treturn 4;\n}\n\nstatic struct strbuf store_create_section(const char *key,\n\t\t\t\t\t  const struct config_store_data *store)\n{\n\tconst char *dot;\n\tsize_t i;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tdot = memchr(key, '.', store->baselen);\n\tif (dot) {\n\t\tstrbuf_addf(&sb, \"[%.*s \\\"\", (int)(dot - key), key);\n\t\tfor (i = dot - key + 1; i < store->baselen; i++) {\n\t\t\tif (key[i] == '\"' || key[i] == '\\\\')\n\t\t\t\tstrbuf_addch(&sb, '\\\\');\n\t\t\tstrbuf_addch(&sb, key[i]);\n\t\t}\n\t\tstrbuf_addstr(&sb, \"\\\"]\\n\");\n\t} else {\n\t\tstrbuf_addch(&sb, '[');\n\t\tstrbuf_add(&sb, key, store->baselen);\n\t\tstrbuf_addstr(&sb, \"]\\n\");\n\t}\n\n\treturn sb;\n}\n\nstatic ssize_t write_section(int fd, const char *key,\n\t\t\t     const struct config_store_data *store)\n{\n\tstruct strbuf sb = store_create_section(key, store);\n\tssize_t ret;\n\n\tret = write_in_full(fd, sb.buf, sb.len);\n\tstrbuf_release(&sb);\n\n\treturn ret;\n}\n\nstatic ssize_t write_pair(int fd, const char *key, const char *value,\n\t\t\t  const struct config_store_data *store)\n{\n\tint i;\n\tssize_t ret;\n\tconst char *quote = \"\";\n\tstruct strbuf sb = STRBUF_INIT;\n\n\t/*\n\t * Check to see if the value needs to be surrounded with a dq pair.\n\t * Note that problematic characters are always backslash-quoted; this\n\t * check is about not losing leading or trailing SP and strings that\n\t * follow beginning-of-comment characters (i.e. ';' and '#') by the\n\t * configuration parser.\n\t */\n\tif (value[0] == ' ')\n\t\tquote = \"\\\"\";\n\tfor (i = 0; value[i]; i++)\n\t\tif (value[i] == ';' || value[i] == '#')\n\t\t\tquote = \"\\\"\";\n\tif (i && value[i - 1] == ' ')\n\t\tquote = \"\\\"\";\n\n\tstrbuf_addf(&sb, \"\\t%s = %s\", key + store->baselen + 1, quote);\n\n\tfor (i = 0; value[i]; i++)\n\t\tswitch (value[i]) {\n\t\tcase '\\n':\n\t\t\tstrbuf_addstr(&sb, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tstrbuf_addstr(&sb, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\t\tstrbuf_addch(&sb, '\\\\');\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tstrbuf_addch(&sb, value[i]);\n\t\t\tbreak;\n\t\t}\n\tstrbuf_addf(&sb, \"%s\\n\", quote);\n\n\tret = write_in_full(fd, sb.buf, sb.len);\n\tstrbuf_release(&sb);\n\n\treturn ret;\n}\n\n/*\n * If we are about to unset the last key(s) in a section, and if there are\n * no comments surrounding (or included in) the section, we will want to\n * extend begin/end to remove the entire section.\n *\n * Note: the parameter `seen_ptr` points to the index into the store.seen\n * array.  * This index may be incremented if a section has more than one\n * entry (which all are to be removed).\n */\nstatic void maybe_remove_section(struct config_store_data *store,\n\t\t\t\t size_t *begin_offset, size_t *end_offset,\n\t\t\t\t int *seen_ptr)\n{\n\tsize_t begin;\n\tint i, seen, section_seen = 0;\n\n\t/*\n\t * First, ensure that this is the first key, and that there are no\n\t * comments before the entry nor before the section header.\n\t */\n\tseen = *seen_ptr;\n\tfor (i = store->seen[seen]; i > 0; i--) {\n\t\tenum config_event_t type = store->parsed[i - 1].type;\n\n\t\tif (type == CONFIG_EVENT_COMMENT)\n\t\t\t/* There is a comment before this entry or section */\n\t\t\treturn;\n\t\tif (type == CONFIG_EVENT_ENTRY) {\n\t\t\tif (!section_seen)\n\t\t\t\t/* This is not the section's first entry. */\n\t\t\t\treturn;\n\t\t\t/* We encountered no comment before the section. */\n\t\t\tbreak;\n\t\t}\n\t\tif (type == CONFIG_EVENT_SECTION) {\n\t\t\tif (!store->parsed[i - 1].is_keys_section)\n\t\t\t\tbreak;\n\t\t\tsection_seen = 1;\n\t\t}\n\t}\n\tbegin = store->parsed[i].begin;\n\n\t/*\n\t * Next, make sure that we are removing he last key(s) in the section,\n\t * and that there are no comments that are possibly about the current\n\t * section.\n\t */\n\tfor (i = store->seen[seen] + 1; i < store->parsed_nr; i++) {\n\t\tenum config_event_t type = store->parsed[i].type;\n\n\t\tif (type == CONFIG_EVENT_COMMENT)\n\t\t\treturn;\n\t\tif (type == CONFIG_EVENT_SECTION) {\n\t\t\tif (store->parsed[i].is_keys_section)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (type == CONFIG_EVENT_ENTRY) {\n\t\t\tif (++seen < store->seen_nr &&\n\t\t\t    i == store->seen[seen])\n\t\t\t\t/* We want to remove this entry, too */\n\t\t\t\tcontinue;\n\t\t\t/* There is another entry in this section. */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * We are really removing the last entry/entries from this section, and\n\t * there are no enclosed or surrounding comments. Remove the entire,\n\t * now-empty section.\n\t */\n\t*seen_ptr = seen;\n\t*begin_offset = begin;\n\tif (i < store->parsed_nr)\n\t\t*end_offset = store->parsed[i].begin;\n\telse\n\t\t*end_offset = store->parsed[store->parsed_nr - 1].end;\n}\n\nint git_config_set_in_file_gently(const char *config_filename,\n\t\t\t\t  const char *key, const char *value)\n{\n\treturn git_config_set_multivar_in_file_gently(config_filename, key, value, NULL, 0);\n}\n\nvoid git_config_set_in_file(const char *config_filename,\n\t\t\t    const char *key, const char *value)\n{\n\tgit_config_set_multivar_in_file(config_filename, key, value, NULL, 0);\n}\n\nint git_config_set_gently(const char *key, const char *value)\n{\n\treturn git_config_set_multivar_gently(key, value, NULL, 0);\n}\n\nvoid git_config_set(const char *key, const char *value)\n{\n\tgit_config_set_multivar(key, value, NULL, 0);\n\n\ttrace2_cmd_set_config(key, value);\n}\n\n/*\n * If value==NULL, unset in (remove from) config,\n * if value_pattern!=NULL, disregard key/value pairs where value does not match.\n * if value_pattern==CONFIG_REGEX_NONE, do not match any existing values\n *     (only add a new one)\n * if flags contains the CONFIG_FLAGS_MULTI_REPLACE flag, all matching\n *     key/values are removed before a single new pair is written. If the\n *     flag is not present, then replace only the first match.\n *\n * Returns 0 on success.\n *\n * This function does this:\n *\n * - it locks the config file by creating \".git/config.lock\"\n *\n * - it then parses the config using store_aux() as validator to find\n *   the position on the key/value pair to replace. If it is to be unset,\n *   it must be found exactly once.\n *\n * - the config file is mmap()ed and the part before the match (if any) is\n *   written to the lock file, then the changed part and the rest.\n *\n * - the config file is removed and the lock file rename()d to it.\n *\n */\nint git_config_set_multivar_in_file_gently(const char *config_filename,\n\t\t\t\t\t   const char *key, const char *value,\n\t\t\t\t\t   const char *value_pattern,\n\t\t\t\t\t   unsigned flags)\n{\n\tint fd = -1, in_fd = -1;\n\tint ret;\n\tstruct lock_file lock = LOCK_INIT;\n\tchar *filename_buf = NULL;\n\tchar *contents = NULL;\n\tsize_t contents_sz;\n\tstruct config_store_data store;\n\n\tmemset(&store, 0, sizeof(store));\n\n\t/* parse-key returns negative; flip the sign to feed exit(3) */\n\tret = 0 - git_config_parse_key(key, &store.key, &store.baselen);\n\tif (ret)\n\t\tgoto out_free;\n\n\tstore.multi_replace = (flags & CONFIG_FLAGS_MULTI_REPLACE) != 0;\n\n\tif (!config_filename)\n\t\tconfig_filename = filename_buf = git_pathdup(\"config\");\n\n\t/*\n\t * The lock serves a purpose in addition to locking: the new\n\t * contents of .git/config will be written into it.\n\t */\n\tfd = hold_lock_file_for_update(&lock, config_filename, 0);\n\tif (fd < 0) {\n\t\terror_errno(_(\"could not lock config file %s\"), config_filename);\n\t\tret = CONFIG_NO_LOCK;\n\t\tgoto out_free;\n\t}\n\n\t/*\n\t * If .git/config does not exist yet, write a minimal version.\n\t */\n\tin_fd = open(config_filename, O_RDONLY);\n\tif ( in_fd < 0 ) {\n\t\tif ( ENOENT != errno ) {\n\t\t\terror_errno(_(\"opening %s\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE; /* same as \"invalid config file\" */\n\t\t\tgoto out_free;\n\t\t}\n\t\t/* if nothing to unset, error out */\n\t\tif (value == NULL) {\n\t\t\tret = CONFIG_NOTHING_SET;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tfree(store.key);\n\t\tstore.key = xstrdup(key);\n\t\tif (write_section(fd, key, &store) < 0 ||\n\t\t    write_pair(fd, key, value, &store) < 0)\n\t\t\tgoto write_err_out;\n\t} else {\n\t\tstruct stat st;\n\t\tsize_t copy_begin, copy_end;\n\t\tint i, new_line = 0;\n\t\tstruct config_options opts;\n\n\t\tif (value_pattern == NULL)\n\t\t\tstore.value_pattern = NULL;\n\t\telse if (value_pattern == CONFIG_REGEX_NONE)\n\t\t\tstore.value_pattern = CONFIG_REGEX_NONE;\n\t\telse if (flags & CONFIG_FLAGS_FIXED_VALUE)\n\t\t\tstore.fixed_value = value_pattern;\n\t\telse {\n\t\t\tif (value_pattern[0] == '!') {\n\t\t\t\tstore.do_not_match = 1;\n\t\t\t\tvalue_pattern++;\n\t\t\t} else\n\t\t\t\tstore.do_not_match = 0;\n\n\t\t\tstore.value_pattern = (regex_t*)xmalloc(sizeof(regex_t));\n\t\t\tif (regcomp(store.value_pattern, value_pattern,\n\t\t\t\t\tREG_EXTENDED)) {\n\t\t\t\terror(_(\"invalid pattern: %s\"), value_pattern);\n\t\t\t\tFREE_AND_NULL(store.value_pattern);\n\t\t\t\tret = CONFIG_INVALID_PATTERN;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\n\t\tALLOC_GROW(store.parsed, 1, store.parsed_alloc);\n\t\tstore.parsed[0].end = 0;\n\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\topts.event_fn = store_aux_event;\n\t\topts.event_fn_data = &store;\n\n\t\t/*\n\t\t * After this, store.parsed will contain offsets of all the\n\t\t * parsed elements, and store.seen will contain a list of\n\t\t * matches, as indices into store.parsed.\n\t\t *\n\t\t * As a side effect, we make sure to transform only a valid\n\t\t * existing config file.\n\t\t */\n\t\tif (git_config_from_file_with_options(store_aux,\n\t\t\t\t\t\t      config_filename,\n\t\t\t\t\t\t      &store, &opts)) {\n\t\t\terror(_(\"invalid config file %s\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* if nothing to unset, or too many matches, error out */\n\t\tif ((store.seen_nr == 0 && value == NULL) ||\n\t\t    (store.seen_nr > 1 && !store.multi_replace)) {\n\t\t\tret = CONFIG_NOTHING_SET;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (fstat(in_fd, &st) == -1) {\n\t\t\terror_errno(_(\"fstat on %s failed\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcontents_sz = xsize_t(st.st_size);\n\t\tcontents = xmmap_gently(NULL, contents_sz, PROT_READ,\n\t\t\t\t\tMAP_PRIVATE, in_fd, 0);\n\t\tif (contents == MAP_FAILED) {\n\t\t\tif (errno == ENODEV && S_ISDIR(st.st_mode))\n\t\t\t\terrno = EISDIR;\n\t\t\terror_errno(_(\"unable to mmap '%s'\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE;\n\t\t\tcontents = NULL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tclose(in_fd);\n\t\tin_fd = -1;\n\n\t\tif (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {\n\t\t\terror_errno(_(\"chmod on %s failed\"), get_lock_file_path(&lock));\n\t\t\tret = CONFIG_NO_WRITE;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (store.seen_nr == 0) {\n\t\t\tif (!store.seen_alloc) {\n\t\t\t\t/* Did not see key nor section */\n\t\t\t\tALLOC_GROW(store.seen, 1, store.seen_alloc);\n\t\t\t\tstore.seen[0] = store.parsed_nr\n\t\t\t\t\t- !!store.parsed_nr;\n\t\t\t}\n\t\t\tstore.seen_nr = 1;\n\t\t}\n\n\t\tfor (i = 0, copy_begin = 0; i < store.seen_nr; i++) {\n\t\t\tsize_t replace_end;\n\t\t\tint j = store.seen[i];\n\n\t\t\tnew_line = 0;\n\t\t\tif (!store.key_seen) {\n\t\t\t\tcopy_end = store.parsed[j].end;\n\t\t\t\t/* include '\\n' when copying section header */\n\t\t\t\tif (copy_end > 0 && copy_end < contents_sz &&\n\t\t\t\t    contents[copy_end - 1] != '\\n' &&\n\t\t\t\t    contents[copy_end] == '\\n')\n\t\t\t\t\tcopy_end++;\n\t\t\t\treplace_end = copy_end;\n\t\t\t} else {\n\t\t\t\treplace_end = store.parsed[j].end;\n\t\t\t\tcopy_end = store.parsed[j].begin;\n\t\t\t\tif (!value)\n\t\t\t\t\tmaybe_remove_section(&store,\n\t\t\t\t\t\t\t     &copy_end,\n\t\t\t\t\t\t\t     &replace_end, &i);\n\t\t\t\t/*\n\t\t\t\t * Swallow preceding white-space on the same\n\t\t\t\t * line.\n\t\t\t\t */\n\t\t\t\twhile (copy_end > 0 ) {\n\t\t\t\t\tchar c = contents[copy_end - 1];\n\n\t\t\t\t\tif (isspace(c) && c != '\\n')\n\t\t\t\t\t\tcopy_end--;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (copy_end > 0 && contents[copy_end-1] != '\\n')\n\t\t\t\tnew_line = 1;\n\n\t\t\t/* write the first part of the config */\n\t\t\tif (copy_end > copy_begin) {\n\t\t\t\tif (write_in_full(fd, contents + copy_begin,\n\t\t\t\t\t\t  copy_end - copy_begin) < 0)\n\t\t\t\t\tgoto write_err_out;\n\t\t\t\tif (new_line &&\n\t\t\t\t    write_str_in_full(fd, \"\\n\") < 0)\n\t\t\t\t\tgoto write_err_out;\n\t\t\t}\n\t\t\tcopy_begin = replace_end;\n\t\t}\n\n\t\t/* write the pair (value == NULL means unset) */\n\t\tif (value != NULL) {\n\t\t\tif (!store.section_seen) {\n\t\t\t\tif (write_section(fd, key, &store) < 0)\n\t\t\t\t\tgoto write_err_out;\n\t\t\t}\n\t\t\tif (write_pair(fd, key, value, &store) < 0)\n\t\t\t\tgoto write_err_out;\n\t\t}\n\n\t\t/* write the rest of the config */\n\t\tif (copy_begin < contents_sz)\n\t\t\tif (write_in_full(fd, contents + copy_begin,\n\t\t\t\t\t  contents_sz - copy_begin) < 0)\n\t\t\t\tgoto write_err_out;\n\n\t\tmunmap(contents, contents_sz);\n\t\tcontents = NULL;\n\t}\n\n\tif (commit_lock_file(&lock) < 0) {\n\t\terror_errno(_(\"could not write config file %s\"), config_filename);\n\t\tret = CONFIG_NO_WRITE;\n\t\tgoto out_free;\n\t}\n\n\tret = 0;\n\n\t/* Invalidate the config cache */\n\tgit_config_clear();\n\nout_free:\n\trollback_lock_file(&lock);\n\tfree(filename_buf);\n\tif (contents)\n\t\tmunmap(contents, contents_sz);\n\tif (in_fd >= 0)\n\t\tclose(in_fd);\n\tconfig_store_data_clear(&store);\n\treturn ret;\n\nwrite_err_out:\n\tret = write_error(get_lock_file_path(&lock));\n\tgoto out_free;\n\n}\n\nvoid git_config_set_multivar_in_file(const char *config_filename,\n\t\t\t\t     const char *key, const char *value,\n\t\t\t\t     const char *value_pattern, unsigned flags)\n{\n\tif (!git_config_set_multivar_in_file_gently(config_filename, key, value,\n\t\t\t\t\t\t    value_pattern, flags))\n\t\treturn;\n\tif (value)\n\t\tdie(_(\"could not set '%s' to '%s'\"), key, value);\n\telse\n\t\tdie(_(\"could not unset '%s'\"), key);\n}\n\nint git_config_set_multivar_gently(const char *key, const char *value,\n\t\t\t\t   const char *value_pattern, unsigned flags)\n{\n\treturn git_config_set_multivar_in_file_gently(NULL, key, value, value_pattern,\n\t\t\t\t\t\t      flags);\n}\n\nvoid git_config_set_multivar(const char *key, const char *value,\n\t\t\t     const char *value_pattern, unsigned flags)\n{\n\tgit_config_set_multivar_in_file(NULL, key, value, value_pattern,\n\t\t\t\t\tflags);\n}\n\nstatic int section_name_match (const char *buf, const char *name)\n{\n\tint i = 0, j = 0, dot = 0;\n\tif (buf[i] != '[')\n\t\treturn 0;\n\tfor (i = 1; buf[i] && buf[i] != ']'; i++) {\n\t\tif (!dot && isspace(buf[i])) {\n\t\t\tdot = 1;\n\t\t\tif (name[j++] != '.')\n\t\t\t\tbreak;\n\t\t\tfor (i++; isspace(buf[i]); i++)\n\t\t\t\t; /* do nothing */\n\t\t\tif (buf[i] != '\"')\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] == '\\\\' && dot)\n\t\t\ti++;\n\t\telse if (buf[i] == '\"' && dot) {\n\t\t\tfor (i++; isspace(buf[i]); i++)\n\t\t\t\t; /* do_nothing */\n\t\t\tbreak;\n\t\t}\n\t\tif (buf[i] != name[j++])\n\t\t\tbreak;\n\t}\n\tif (buf[i] == ']' && name[j] == 0) {\n\t\t/*\n\t\t * We match, now just find the right length offset by\n\t\t * gobbling up any whitespace after it, as well\n\t\t */\n\t\ti++;\n\t\tfor (; buf[i] && isspace(buf[i]); i++)\n\t\t\t; /* do nothing */\n\t\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int section_name_is_ok(const char *name)\n{\n\t/* Empty section names are bogus. */\n\tif (!*name)\n\t\treturn 0;\n\n\t/*\n\t * Before a dot, we must be alphanumeric or dash. After the first dot,\n\t * anything goes, so we can stop checking.\n\t */\n\tfor (; *name && *name != '.'; name++)\n\t\tif (*name != '-' && !isalnum(*name))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n/* if new_name == NULL, the section is removed instead */\nstatic int git_config_copy_or_rename_section_in_file(const char *config_filename,\n\t\t\t\t      const char *old_name,\n\t\t\t\t      const char *new_name, int copy)\n{\n\tint ret = 0, remove = 0;\n\tchar *filename_buf = NULL;\n\tstruct lock_file lock = LOCK_INIT;\n\tint out_fd;\n\tchar buf[1024];\n\tFILE *config_file = NULL;\n\tstruct stat st;\n\tstruct strbuf copystr = STRBUF_INIT;\n\tstruct config_store_data store;\n\n\tmemset(&store, 0, sizeof(store));\n\n\tif (new_name && !section_name_is_ok(new_name)) {\n\t\tret = error(_(\"invalid section name: %s\"), new_name);\n\t\tgoto out_no_rollback;\n\t}\n\n\tif (!config_filename)\n\t\tconfig_filename = filename_buf = git_pathdup(\"config\");\n\n\tout_fd = hold_lock_file_for_update(&lock, config_filename, 0);\n\tif (out_fd < 0) {\n\t\tret = error(_(\"could not lock config file %s\"), config_filename);\n\t\tgoto out;\n\t}\n\n\tif (!(config_file = fopen(config_filename, \"rb\"))) {\n\t\tret = warn_on_fopen_errors(config_filename);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/* no config file means nothing to rename, no error */\n\t\tgoto commit_and_out;\n\t}\n\n\tif (fstat(fileno(config_file), &st) == -1) {\n\t\tret = error_errno(_(\"fstat on %s failed\"), config_filename);\n\t\tgoto out;\n\t}\n\n\tif (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {\n\t\tret = error_errno(_(\"chmod on %s failed\"),\n\t\t\t\t  get_lock_file_path(&lock));\n\t\tgoto out;\n\t}\n\n\twhile (fgets(buf, sizeof(buf), config_file)) {\n\t\tunsigned i;\n\t\tint length;\n\t\tint is_section = 0;\n\t\tchar *output = buf;\n\t\tfor (i = 0; buf[i] && isspace(buf[i]); i++)\n\t\t\t; /* do nothing */\n\t\tif (buf[i] == '[') {\n\t\t\t/* it's a section */\n\t\t\tint offset;\n\t\t\tis_section = 1;\n\n\t\t\t/*\n\t\t\t * When encountering a new section under -c we\n\t\t\t * need to flush out any section we're already\n\t\t\t * coping and begin anew. There might be\n\t\t\t * multiple [branch \"$name\"] sections.\n\t\t\t */\n\t\t\tif (copystr.len > 0) {\n\t\t\t\tif (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {\n\t\t\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tstrbuf_reset(&copystr);\n\t\t\t}\n\n\t\t\toffset = section_name_match(&buf[i], old_name);\n\t\t\tif (offset > 0) {\n\t\t\t\tret++;\n\t\t\t\tif (new_name == NULL) {\n\t\t\t\t\tremove = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstore.baselen = strlen(new_name);\n\t\t\t\tif (!copy) {\n\t\t\t\t\tif (write_section(out_fd, new_name, &store) < 0) {\n\t\t\t\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * We wrote out the new section, with\n\t\t\t\t\t * a newline, now skip the old\n\t\t\t\t\t * section's length\n\t\t\t\t\t */\n\t\t\t\t\toutput += offset + i;\n\t\t\t\t\tif (strlen(output) > 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * More content means there's\n\t\t\t\t\t\t * a declaration to put on the\n\t\t\t\t\t\t * next line; indent with a\n\t\t\t\t\t\t * tab\n\t\t\t\t\t\t */\n\t\t\t\t\t\toutput -= 1;\n\t\t\t\t\t\toutput[0] = '\\t';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcopystr = store_create_section(new_name, &store);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove = 0;\n\t\t}\n\t\tif (remove)\n\t\t\tcontinue;\n\t\tlength = strlen(output);\n\n\t\tif (!is_section && copystr.len > 0) {\n\t\t\tstrbuf_add(&copystr, output, length);\n\t\t}\n\n\t\tif (write_in_full(out_fd, output, length) < 0) {\n\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Copy a trailing section at the end of the config, won't be\n\t * flushed by the usual \"flush because we have a new section\n\t * logic in the loop above.\n\t */\n\tif (copystr.len > 0) {\n\t\tif (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {\n\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\tgoto out;\n\t\t}\n\t\tstrbuf_reset(&copystr);\n\t}\n\n\tfclose(config_file);\n\tconfig_file = NULL;\ncommit_and_out:\n\tif (commit_lock_file(&lock) < 0)\n\t\tret = error_errno(_(\"could not write config file %s\"),\n\t\t\t\t  config_filename);\nout:\n\tif (config_file)\n\t\tfclose(config_file);\n\trollback_lock_file(&lock);\nout_no_rollback:\n\tfree(filename_buf);\n\tconfig_store_data_clear(&store);\n\treturn ret;\n}\n\nint git_config_rename_section_in_file(const char *config_filename,\n\t\t\t\t      const char *old_name, const char *new_name)\n{\n\treturn git_config_copy_or_rename_section_in_file(config_filename,\n\t\t\t\t\t old_name, new_name, 0);\n}\n\nint git_config_rename_section(const char *old_name, const char *new_name)\n{\n\treturn git_config_rename_section_in_file(NULL, old_name, new_name);\n}\n\nint git_config_copy_section_in_file(const char *config_filename,\n\t\t\t\t      const char *old_name, const char *new_name)\n{\n\treturn git_config_copy_or_rename_section_in_file(config_filename,\n\t\t\t\t\t old_name, new_name, 1);\n}\n\nint git_config_copy_section(const char *old_name, const char *new_name)\n{\n\treturn git_config_copy_section_in_file(NULL, old_name, new_name);\n}\n\n/*\n * Call this to report error for your variable that should not\n * get a boolean value (i.e. \"[my] var\" means \"true\").\n */\n#undef config_error_nonbool\nint config_error_nonbool(const char *var)\n{\n\treturn error(_(\"missing value for '%s'\"), var);\n}\n\nint parse_config_key(const char *var,\n\t\t     const char *section,\n\t\t     const char **subsection, size_t *subsection_len,\n\t\t     const char **key)\n{\n\tconst char *dot;\n\n\t/* Does it start with \"section.\" ? */\n\tif (!skip_prefix(var, section, &var) || *var != '.')\n\t\treturn -1;\n\n\t/*\n\t * Find the key; we don't know yet if we have a subsection, but we must\n\t * parse backwards from the end, since the subsection may have dots in\n\t * it, too.\n\t */\n\tdot = strrchr(var, '.');\n\t*key = dot + 1;\n\n\t/* Did we have a subsection at all? */\n\tif (dot == var) {\n\t\tif (subsection) {\n\t\t\t*subsection = NULL;\n\t\t\t*subsection_len = 0;\n\t\t}\n\t}\n\telse {\n\t\tif (!subsection)\n\t\t\treturn -1;\n\t\t*subsection = var + 1;\n\t\t*subsection_len = dot - *subsection;\n\t}\n\n\treturn 0;\n}\n\nconst char *current_config_origin_type(void)\n{\n\tint type;\n\tif (current_config_kvi)\n\t\ttype = current_config_kvi->origin_type;\n\telse if(cf)\n\t\ttype = cf->origin_type;\n\telse\n\t\tBUG(\"current_config_origin_type called outside config callback\");\n\n\tswitch (type) {\n\tcase CONFIG_ORIGIN_BLOB:\n\t\treturn \"blob\";\n\tcase CONFIG_ORIGIN_FILE:\n\t\treturn \"file\";\n\tcase CONFIG_ORIGIN_STDIN:\n\t\treturn \"standard input\";\n\tcase CONFIG_ORIGIN_SUBMODULE_BLOB:\n\t\treturn \"submodule-blob\";\n\tcase CONFIG_ORIGIN_CMDLINE:\n\t\treturn \"command line\";\n\tdefault:\n\t\tBUG(\"unknown config origin type\");\n\t}\n}\n\nconst char *config_scope_name(enum config_scope scope)\n{\n\tswitch (scope) {\n\tcase CONFIG_SCOPE_SYSTEM:\n\t\treturn \"system\";\n\tcase CONFIG_SCOPE_GLOBAL:\n\t\treturn \"global\";\n\tcase CONFIG_SCOPE_LOCAL:\n\t\treturn \"local\";\n\tcase CONFIG_SCOPE_WORKTREE:\n\t\treturn \"worktree\";\n\tcase CONFIG_SCOPE_COMMAND:\n\t\treturn \"command\";\n\tcase CONFIG_SCOPE_SUBMODULE:\n\t\treturn \"submodule\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nconst char *current_config_name(void)\n{\n\tconst char *name;\n\tif (current_config_kvi)\n\t\tname = current_config_kvi->filename;\n\telse if (cf)\n\t\tname = cf->name;\n\telse\n\t\tBUG(\"current_config_name called outside config callback\");\n\treturn name ? name : \"\";\n}\n\nenum config_scope current_config_scope(void)\n{\n\tif (current_config_kvi)\n\t\treturn current_config_kvi->scope;\n\telse\n\t\treturn current_parsing_scope;\n}\n\nint current_config_line(void)\n{\n\tif (current_config_kvi)\n\t\treturn current_config_kvi->linenr;\n\telse\n\t\treturn cf->linenr;\n}\n\nint lookup_config(const char **mapping, int nr_mapping, const char *var)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_mapping; i++) {\n\t\tconst char *name = mapping[i];\n\n\t\tif (name && !strcasecmp(var, name))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2005 Johannes Schindelin\n#\n\ntest_description='Test git config in different settings'\n\n. ./test-lib.sh\n\ntest_expect_success 'clear default config' '\n\trm -f .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\nEOF\ntest_expect_success 'initial' '\n\tgit config section.penguin \"little blue\" &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\n\tMovie = BadPhysics\nEOF\ntest_expect_success 'mixed case' '\n\tgit config Section.Movie BadPhysics &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\n\tMovie = BadPhysics\n[Sections]\n\tWhatEver = Second\nEOF\ntest_expect_success 'similar section' '\n\tgit config Sections.WhatEver Second &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\n\tMovie = BadPhysics\n\tUPPERCASE = true\n[Sections]\n\tWhatEver = Second\nEOF\ntest_expect_success 'uppercase section' '\n\tgit config SECTION.UPPERCASE true &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'replace with non-match' '\n\tgit config section.penguin kingpin !blue\n'\n\ntest_expect_success 'replace with non-match (actually matching)' '\n\tgit config section.penguin \"very blue\" !kingpin\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = very blue\n\tMovie = BadPhysics\n\tUPPERCASE = true\n\tpenguin = kingpin\n[Sections]\n\tWhatEver = Second\nEOF\n\ntest_expect_success 'non-match result' 'test_cmp expect .git/config'\n\ntest_expect_success 'find mixed-case key by canonical name' '\n\ttest_cmp_config Second sections.whatever\n'\n\ntest_expect_success 'find mixed-case key by non-canonical name' '\n\ttest_cmp_config Second SeCtIoNs.WhAtEvEr\n'\n\ntest_expect_success 'subsections are not canonicalized by git-config' '\n\tcat >>.git/config <<-\\EOF &&\n\t[section.SubSection]\n\tkey = one\n\t[section \"SubSection\"]\n\tkey = two\n\tEOF\n\ttest_cmp_config one section.subsection.key &&\n\ttest_cmp_config two section.SubSection.key\n'\n\ncat > .git/config <<\\EOF\n[alpha]\nbar = foo\n[beta]\nbaz = multiple \\\nlines\nfoo = bar\nEOF\n\ntest_expect_success 'unset with cont. lines' '\n\tgit config --unset beta.baz\n'\n\ncat > expect <<\\EOF\n[alpha]\nbar = foo\n[beta]\nfoo = bar\nEOF\n\ntest_expect_success 'unset with cont. lines is correct' 'test_cmp expect .git/config'\n\ncat > .git/config << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\t\thaha   =\"beta\" # last silly comment\nhaha = hello\n\thaha = bello\n[nextSection] noNewline = ouch\nEOF\n\ncp .git/config .git/config2\n\ntest_expect_success 'multiple unset' '\n\tgit config --unset-all beta.haha\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection] noNewline = ouch\nEOF\n\ntest_expect_success 'multiple unset is correct' '\n\ttest_cmp expect .git/config\n'\n\ncp .git/config2 .git/config\n\ntest_expect_success '--replace-all missing value' '\n\ttest_must_fail git config --replace-all beta.haha &&\n\ttest_cmp .git/config2 .git/config\n'\n\nrm .git/config2\n\ntest_expect_success '--replace-all' '\n\tgit config --replace-all beta.haha gamma\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\thaha = gamma\n[nextSection] noNewline = ouch\nEOF\n\ntest_expect_success 'all replaced' '\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\thaha = alpha\n[nextSection] noNewline = ouch\nEOF\ntest_expect_success 'really mean test' '\n\tgit config beta.haha alpha &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\thaha = alpha\n[nextSection]\n\tnonewline = wow\nEOF\ntest_expect_success 'really really mean test' '\n\tgit config nextsection.nonewline wow &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'get value' '\n\ttest_cmp_config alpha beta.haha\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tnonewline = wow\nEOF\ntest_expect_success 'unset' '\n\tgit config --unset beta.haha &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tnonewline = wow\n\tNoNewLine = wow2 for me\nEOF\ntest_expect_success 'multivar' '\n\tgit config nextsection.NoNewLine \"wow2 for me\" \"for me$\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'non-match' '\n\tgit config --get nextsection.nonewline !for\n'\n\ntest_expect_success 'non-match value' '\n\ttest_cmp_config wow --get nextsection.nonewline !for\n'\n\ntest_expect_success 'multi-valued get returns final one' '\n\ttest_cmp_config \"wow2 for me\" --get nextsection.nonewline\n'\n\ntest_expect_success 'multi-valued get-all returns all' '\n\tcat >expect <<-\\EOF &&\n\twow\n\twow2 for me\n\tEOF\n\tgit config --get-all nextsection.nonewline >actual &&\n\ttest_cmp expect actual\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tnonewline = wow3\n\tNoNewLine = wow2 for me\nEOF\ntest_expect_success 'multivar replace' '\n\tgit config nextsection.nonewline \"wow3\" \"wow$\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'ambiguous unset' '\n\ttest_must_fail git config --unset nextsection.nonewline\n'\n\ntest_expect_success 'invalid unset' '\n\ttest_must_fail git config --unset somesection.nonewline\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tNoNewLine = wow2 for me\nEOF\n\ntest_expect_success 'multivar unset' '\n\tgit config --unset nextsection.nonewline \"wow3$\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'invalid key' 'test_must_fail git config inval.2key blabla'\n\ntest_expect_success 'correct key' 'git config 123456.a123 987'\n\ntest_expect_success 'hierarchical section' '\n\tgit config Version.1.2.3eX.Alpha beta\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tNoNewLine = wow2 for me\n[123456]\n\ta123 = 987\n[Version \"1.2.3eX\"]\n\tAlpha = beta\nEOF\n\ntest_expect_success 'hierarchical section value' '\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\nbeta.noindent=sillyValue\nnextsection.nonewline=wow2 for me\n123456.a123=987\nversion.1.2.3eX.alpha=beta\nEOF\n\ntest_expect_success 'working --list' '\n\tgit config --list > output &&\n\ttest_cmp expect output\n'\ntest_expect_success '--list without repo produces empty output' '\n\tgit --git-dir=nonexistent config --list >output &&\n\ttest_must_be_empty output\n'\n\ncat > expect << EOF\nbeta.noindent\nnextsection.nonewline\n123456.a123\nversion.1.2.3eX.alpha\nEOF\n\ntest_expect_success '--name-only --list' '\n\tgit config --name-only --list >output &&\n\ttest_cmp expect output\n'\n\ncat > expect << EOF\nbeta.noindent sillyValue\nnextsection.nonewline wow2 for me\nEOF\n\ntest_expect_success '--get-regexp' '\n\tgit config --get-regexp in >output &&\n\ttest_cmp expect output\n'\n\ncat > expect << EOF\nbeta.noindent\nnextsection.nonewline\nEOF\n\ntest_expect_success '--name-only --get-regexp' '\n\tgit config --name-only --get-regexp in >output &&\n\ttest_cmp expect output\n'\n\ncat > expect << EOF\nwow2 for me\nwow4 for you\nEOF\n\ntest_expect_success '--add' '\n\tgit config --add nextsection.nonewline \"wow4 for you\" &&\n\tgit config --get-all nextsection.nonewline > output &&\n\ttest_cmp expect output\n'\n\ncat > .git/config << EOF\n[novalue]\n\tvariable\n[emptyvalue]\n\tvariable =\nEOF\n\ntest_expect_success 'get variable with no value' '\n\tgit config --get novalue.variable ^$\n'\n\ntest_expect_success 'get variable with empty value' '\n\tgit config --get emptyvalue.variable ^$\n'\n\necho novalue.variable > expect\n\ntest_expect_success 'get-regexp variable with no value' '\n\tgit config --get-regexp novalue > output &&\n\ttest_cmp expect output\n'\n\necho 'novalue.variable true' > expect\n\ntest_expect_success 'get-regexp --bool variable with no value' '\n\tgit config --bool --get-regexp novalue > output &&\n\ttest_cmp expect output\n'\n\necho 'emptyvalue.variable ' > expect\n\ntest_expect_success 'get-regexp variable with empty value' '\n\tgit config --get-regexp emptyvalue > output &&\n\ttest_cmp expect output\n'\n\necho true > expect\n\ntest_expect_success 'get bool variable with no value' '\n\tgit config --bool novalue.variable > output &&\n\ttest_cmp expect output\n'\n\necho false > expect\n\ntest_expect_success 'get bool variable with empty value' '\n\tgit config --bool emptyvalue.variable > output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'no arguments, but no crash' '\n\ttest_must_fail git config >output 2>&1 &&\n\ttest_i18ngrep usage output\n'\n\ncat > .git/config << EOF\n[a.b]\n\tc = d\nEOF\n\ncat > expect << EOF\n[a.b]\n\tc = d\n[a]\n\tx = y\nEOF\n\ntest_expect_success 'new section is partial match of another' '\n\tgit config a.x y &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[a.b]\n\tc = d\n[a]\n\tx = y\n\tb = c\n[b]\n\tx = y\nEOF\n\ntest_expect_success 'new variable inserts into proper section' '\n\tgit config b.x y &&\n\tgit config a.b c &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'alternative --file (non-existing file should fail)' '\n\ttest_must_fail git config --file non-existing-config -l &&\n\ttest_must_fail git config --file non-existing-config test.xyzzy\n'\n\ncat > other-config << EOF\n[ein]\n\tbahn = strasse\nEOF\n\ncat > expect << EOF\nein.bahn=strasse\nEOF\n\ntest_expect_success 'alternative GIT_CONFIG' '\n\tGIT_CONFIG=other-config git config --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'alternative GIT_CONFIG (--file)' '\n\tgit config --file other-config --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'alternative GIT_CONFIG (--file=-)' '\n\tgit config --file - --list <other-config >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'setting a value in stdin is an error' '\n\ttest_must_fail git config --file - some.value foo\n'\n\ntest_expect_success 'editing stdin is an error' '\n\ttest_must_fail git config --file - --edit\n'\n\ntest_expect_success 'refer config from subdirectory' '\n\tmkdir x &&\n\ttest_cmp_config -C x strasse --file=../other-config --get ein.bahn\n'\n\ncat > expect << EOF\n[ein]\n\tbahn = strasse\n[anwohner]\n\tpark = ausweis\nEOF\n\ntest_expect_success '--set in alternative file' '\n\tgit config --file=other-config anwohner.park ausweis &&\n\ttest_cmp expect other-config\n'\n\ncat > .git/config << EOF\n# Hallo\n\t#Bello\n[branch \"eins\"]\n\tx = 1\n[branch.eins]\n\ty = 1\n\t[branch \"1 234 blabl/a\"]\nweird\nEOF\n\ntest_expect_success 'rename section' '\n\tgit config --rename-section branch.eins branch.zwei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"zwei\"]\n\tx = 1\n[branch \"zwei\"]\n\ty = 1\n\t[branch \"1 234 blabl/a\"]\nweird\nEOF\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'rename non-existing section' '\n\ttest_must_fail git config --rename-section \\\n\t\tbranch.\"world domination\" branch.drei\n'\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'rename another section' '\n\tgit config --rename-section branch.\"1 234 blabl/a\" branch.drei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"zwei\"]\n\tx = 1\n[branch \"zwei\"]\n\ty = 1\n[branch \"drei\"]\nweird\nEOF\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ncat >> .git/config << EOF\n[branch \"vier\"] z = 1\nEOF\n\ntest_expect_success 'rename a section with a var on the same line' '\n\tgit config --rename-section branch.vier branch.zwei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"zwei\"]\n\tx = 1\n[branch \"zwei\"]\n\ty = 1\n[branch \"drei\"]\nweird\n[branch \"zwei\"]\n\tz = 1\nEOF\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'renaming empty section name is rejected' '\n\ttest_must_fail git config --rename-section branch.zwei \"\"\n'\n\ntest_expect_success 'renaming to bogus section is rejected' '\n\ttest_must_fail git config --rename-section branch.zwei \"bogus name\"\n'\n\ncat >> .git/config << EOF\n  [branch \"zwei\"] a = 1 [branch \"vier\"]\nEOF\n\ntest_expect_success 'remove section' '\n\tgit config --remove-section branch.zwei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"drei\"]\nweird\nEOF\n\ntest_expect_success 'section was removed properly' '\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[gitcvs]\n\tenabled = true\n\tdbname = %Ggitcvs2.%a.%m.sqlite\n[gitcvs \"ext\"]\n\tdbname = %Ggitcvs1.%a.%m.sqlite\nEOF\n\ntest_expect_success 'section ending' '\n\trm -f .git/config &&\n\tgit config gitcvs.enabled true &&\n\tgit config gitcvs.ext.dbname %Ggitcvs1.%a.%m.sqlite &&\n\tgit config gitcvs.dbname %Ggitcvs2.%a.%m.sqlite &&\n\ttest_cmp expect .git/config\n\n'\n\ntest_expect_success numbers '\n\tgit config kilo.gram 1k &&\n\tgit config mega.ton 1m &&\n\techo 1024 >expect &&\n\techo 1048576 >>expect &&\n\tgit config --int --get kilo.gram >actual &&\n\tgit config --int --get mega.ton >>actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success '--int is at least 64 bits' '\n\tgit config giga.watts 121g &&\n\techo  >expect &&\n\ttest_cmp_config 129922760704 --int --get giga.watts\n'\n\ntest_expect_success 'invalid unit' '\n\tgit config aninvalid.unit \"1auto\" &&\n\ttest_cmp_config 1auto aninvalid.unit &&\n\ttest_must_fail git config --int --get aninvalid.unit 2>actual &&\n\ttest_i18ngrep \"bad numeric config value .1auto. for .aninvalid.unit. in file .git/config: invalid unit\" actual\n'\n\ntest_expect_success 'line number is reported correctly' '\n\tprintf \"[bool]\\n\\tvar\\n\" >invalid &&\n\ttest_must_fail git config -f invalid --path bool.var 2>actual &&\n\ttest_i18ngrep \"line 2\" actual\n'\n\ntest_expect_success 'invalid stdin config' '\n\techo \"[broken\" | test_must_fail git config --list --file - >output 2>&1 &&\n\ttest_i18ngrep \"bad config line 1 in standard input\" output\n'\n\ncat > expect << EOF\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nEOF\n\ntest_expect_success bool '\n\n\tgit config bool.true1 01 &&\n\tgit config bool.true2 -1 &&\n\tgit config bool.true3 YeS &&\n\tgit config bool.true4 true &&\n\tgit config bool.false1 000 &&\n\tgit config bool.false2 \"\" &&\n\tgit config bool.false3 nO &&\n\tgit config bool.false4 FALSE &&\n\trm -f result &&\n\tfor i in 1 2 3 4\n\tdo\n\t    git config --bool --get bool.true$i >>result\n\t    git config --bool --get bool.false$i >>result\n\tdone &&\n\ttest_cmp expect result'\n\ntest_expect_success 'invalid bool (--get)' '\n\n\tgit config bool.nobool foobar &&\n\ttest_must_fail git config --bool --get bool.nobool'\n\ntest_expect_success 'invalid bool (set)' '\n\n\ttest_must_fail git config --bool bool.nobool foobar'\n\ncat > expect <<\\EOF\n[bool]\n\ttrue1 = true\n\ttrue2 = true\n\ttrue3 = true\n\ttrue4 = true\n\tfalse1 = false\n\tfalse2 = false\n\tfalse3 = false\n\tfalse4 = false\nEOF\n\ntest_expect_success 'set --bool' '\n\n\trm -f .git/config &&\n\tgit config --bool bool.true1 01 &&\n\tgit config --bool bool.true2 -1 &&\n\tgit config --bool bool.true3 YeS &&\n\tgit config --bool bool.true4 true &&\n\tgit config --bool bool.false1 000 &&\n\tgit config --bool bool.false2 \"\" &&\n\tgit config --bool bool.false3 nO &&\n\tgit config --bool bool.false4 FALSE &&\n\ttest_cmp expect .git/config'\n\ncat > expect <<\\EOF\n[int]\n\tval1 = 1\n\tval2 = -1\n\tval3 = 5242880\nEOF\n\ntest_expect_success 'set --int' '\n\n\trm -f .git/config &&\n\tgit config --int int.val1 01 &&\n\tgit config --int int.val2 -1 &&\n\tgit config --int int.val3 5m &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'get --bool-or-int' '\n\tcat >.git/config <<-\\EOF &&\n\t[bool]\n\ttrue1\n\ttrue2 = true\n\tfalse = false\n\t[int]\n\tint1 = 0\n\tint2 = 1\n\tint3 = -1\n\tEOF\n\tcat >expect <<-\\EOF &&\n\ttrue\n\ttrue\n\tfalse\n\t0\n\t1\n\t-1\n\tEOF\n\t{\n\t\tgit config --bool-or-int bool.true1 &&\n\t\tgit config --bool-or-int bool.true2 &&\n\t\tgit config --bool-or-int bool.false &&\n\t\tgit config --bool-or-int int.int1 &&\n\t\tgit config --bool-or-int int.int2 &&\n\t\tgit config --bool-or-int int.int3\n\t} >actual &&\n\ttest_cmp expect actual\n'\n\ncat >expect <<\\EOF\n[bool]\n\ttrue1 = true\n\tfalse1 = false\n\ttrue2 = true\n\tfalse2 = false\n[int]\n\tint1 = 0\n\tint2 = 1\n\tint3 = -1\nEOF\n\ntest_expect_success 'set --bool-or-int' '\n\trm -f .git/config &&\n\tgit config --bool-or-int bool.true1 true &&\n\tgit config --bool-or-int bool.false1 false &&\n\tgit config --bool-or-int bool.true2 yes &&\n\tgit config --bool-or-int bool.false2 no &&\n\tgit config --bool-or-int int.int1 0 &&\n\tgit config --bool-or-int int.int2 1 &&\n\tgit config --bool-or-int int.int3 -1 &&\n\ttest_cmp expect .git/config\n'\n\ncat >expect <<\\EOF\n[path]\n\thome = ~/\n\tnormal = /dev/null\n\ttrailingtilde = foo~\nEOF\n\ntest_expect_success !MINGW 'set --path' '\n\trm -f .git/config &&\n\tgit config --path path.home \"~/\" &&\n\tgit config --path path.normal \"/dev/null\" &&\n\tgit config --path path.trailingtilde \"foo~\" &&\n\ttest_cmp expect .git/config'\n\nif test_have_prereq !MINGW && test \"${HOME+set}\"\nthen\n\ttest_set_prereq HOMEVAR\nfi\n\ncat >expect <<EOF\n$HOME/\n/dev/null\nfoo~\nEOF\n\ntest_expect_success HOMEVAR 'get --path' '\n\tgit config --get --path path.home > result &&\n\tgit config --get --path path.normal >> result &&\n\tgit config --get --path path.trailingtilde >> result &&\n\ttest_cmp expect result\n'\n\ncat >expect <<\\EOF\n/dev/null\nfoo~\nEOF\n\ntest_expect_success !MINGW 'get --path copes with unset $HOME' '\n\t(\n\t\tsane_unset HOME &&\n\t\ttest_must_fail git config --get --path path.home \\\n\t\t\t>result 2>msg &&\n\t\tgit config --get --path path.normal >>result &&\n\t\tgit config --get --path path.trailingtilde >>result\n\t) &&\n\ttest_i18ngrep \"[Ff]ailed to expand.*~/\" msg &&\n\ttest_cmp expect result\n'\n\ntest_expect_success 'get --path barfs on boolean variable' '\n\techo \"[path]bool\" >.git/config &&\n\ttest_must_fail git config --get --path path.bool\n'\n\ntest_expect_success 'get --expiry-date' '\n\trel=\"3.weeks.5.days.00:00\" &&\n\trel_out=\"$rel ->\" &&\n\tcat >.git/config <<-\\EOF &&\n\t[date]\n\tvalid1 = \"3.weeks.5.days 00:00\"\n\tvalid2 = \"Fri Jun 4 15:46:55 2010\"\n\tvalid3 = \"2017/11/11 11:11:11PM\"\n\tvalid4 = \"2017/11/10 09:08:07 PM\"\n\tvalid5 = \"never\"\n\tinvalid1 = \"abc\"\n\tEOF\n\tcat >expect <<-EOF &&\n\t$(test-tool date timestamp $rel)\n\t1275666415\n\t1510441871\n\t1510348087\n\t0\n\tEOF\n\t: \"work around heredoc parsing bug fixed in dash 0.5.7 (in ec2c84d)\" &&\n\t{\n\t\techo \"$rel_out $(git config --expiry-date date.valid1)\"\n\t\tgit config --expiry-date date.valid2 &&\n\t\tgit config --expiry-date date.valid3 &&\n\t\tgit config --expiry-date date.valid4 &&\n\t\tgit config --expiry-date date.valid5\n\t} >actual &&\n\ttest_cmp expect actual &&\n\ttest_must_fail git config --expiry-date date.invalid1\n'\n\ntest_expect_success 'get --type=color' '\n\trm .git/config &&\n\tgit config foo.color \"red\" &&\n\tgit config --get --type=color foo.color >actual.raw &&\n\ttest_decode_color <actual.raw >actual &&\n\techo \"<RED>\" >expect &&\n\ttest_cmp expect actual\n'\n\ncat >expect << EOF\n[foo]\n\tcolor = red\nEOF\n\ntest_expect_success 'set --type=color' '\n\trm .git/config &&\n\tgit config --type=color foo.color \"red\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'get --type=color barfs on non-color' '\n\techo \"[foo]bar=not-a-color\" >.git/config &&\n\ttest_must_fail git config --get --type=color foo.bar\n'\n\ntest_expect_success 'set --type=color barfs on non-color' '\n\ttest_must_fail git config --type=color foo.color \"not-a-color\" 2>error &&\n\ttest_i18ngrep \"cannot parse color\" error\n'\n\ncat > expect << EOF\n[quote]\n\tleading = \" test\"\n\tending = \"test \"\n\tsemicolon = \"test;test\"\n\thash = \"test#test\"\nEOF\ntest_expect_success 'quoting' '\n\trm -f .git/config &&\n\tgit config quote.leading \" test\" &&\n\tgit config quote.ending \"test \" &&\n\tgit config quote.semicolon \"test;test\" &&\n\tgit config quote.hash \"test#test\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'key with newline' '\n\ttest_must_fail git config \"key.with\nnewline\" 123'\n\ntest_expect_success 'value with newline' 'git config key.sub value.with\\\\\\\nnewline'\n\ncat > .git/config <<\\EOF\n[section]\n\t; comment \\\n\tcontinued = cont\\\ninued\n\tnoncont   = not continued ; \\\n\tquotecont = \"cont;\\\ninued\"\nEOF\n\ncat > expect <<\\EOF\nsection.continued=continued\nsection.noncont=not continued\nsection.quotecont=cont;inued\nEOF\n\ntest_expect_success 'value continued on next line' '\n\tgit config --list > result &&\n\ttest_cmp expect result\n'\n\ncat > .git/config <<\\EOF\n[section \"sub=section\"]\n\tval1 = foo=bar\n\tval2 = foo\\nbar\n\tval3 = \\n\\n\n\tval4 =\n\tval5\nEOF\n\ncat > expect <<\\EOF\nsection.sub=section.val1\nfoo=barQsection.sub=section.val2\nfoo\nbarQsection.sub=section.val3\n\n\nQsection.sub=section.val4\nQsection.sub=section.val5Q\nEOF\ntest_expect_success '--null --list' '\n\tgit config --null --list >result.raw &&\n\tnul_to_q <result.raw >result &&\n\techo >>result &&\n\ttest_cmp expect result\n'\n\ntest_expect_success '--null --get-regexp' '\n\tgit config --null --get-regexp \"val[0-9]\" >result.raw &&\n\tnul_to_q <result.raw >result &&\n\techo >>result &&\n\ttest_cmp expect result\n'\n\ntest_expect_success 'inner whitespace kept verbatim' '\n\tgit config section.val \"foo \t  bar\" &&\n\ttest_cmp_config \"foo \t  bar\" section.val\n'\n\ntest_expect_success SYMLINKS 'symlinked configuration' '\n\tln -s notyet myconfig &&\n\tgit config --file=myconfig test.frotz nitfol &&\n\ttest -h myconfig &&\n\ttest -f notyet &&\n\ttest \"z$(git config --file=notyet test.frotz)\" = znitfol &&\n\tgit config --file=myconfig test.xyzzy rezrov &&\n\ttest -h myconfig &&\n\ttest -f notyet &&\n\tcat >expect <<-\\EOF &&\n\tnitfol\n\trezrov\n\tEOF\n\t{\n\t\tgit config --file=notyet test.frotz &&\n\t\tgit config --file=notyet test.xyzzy\n\t} >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success SYMLINKS 'symlink to nonexistent configuration' '\n\tln -s doesnotexist linktonada &&\n\tln -s linktonada linktolinktonada &&\n\ttest_must_fail git config --file=linktonada --list &&\n\ttest_must_fail git config --file=linktolinktonada --list\n'\n\ntest_expect_success 'check split_cmdline return' \"\n\tgit config alias.split-cmdline-fix 'echo \\\"' &&\n\ttest_must_fail git split-cmdline-fix &&\n\techo foo > foo &&\n\tgit add foo &&\n\tgit commit -m 'initial commit' &&\n\tgit config branch.master.mergeoptions 'echo \\\"' &&\n\ttest_must_fail git merge master\n\"\n\ntest_expect_success 'git -c \"key=value\" support' '\n\tcat >expect <<-\\EOF &&\n\tvalue\n\tvalue\n\ttrue\n\tEOF\n\t{\n\t\tgit -c section.name=value config section.name &&\n\t\tgit -c foo.CamelCase=value config foo.camelcase &&\n\t\tgit -c foo.flag config --bool foo.flag\n\t} >actual &&\n\ttest_cmp expect actual &&\n\ttest_must_fail git -c name=value config section.name\n'\n\n# We just need a type-specifier here that cares about the\n# distinction internally between a NULL boolean and a real\n# string (because most of git's internal parsers do care).\n# Using \"--path\" works, but we do not otherwise care about\n# its semantics.\ntest_expect_success 'git -c can represent empty string' '\n\techo >expect &&\n\tgit -c foo.empty= config --path foo.empty >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'key sanity-checking' '\n\ttest_must_fail git config foo=bar &&\n\ttest_must_fail git config foo=.bar &&\n\ttest_must_fail git config foo.ba=r &&\n\ttest_must_fail git config foo.1bar &&\n\ttest_must_fail git config foo.\"ba\n\t\t\t\tz\".bar &&\n\ttest_must_fail git config . false &&\n\ttest_must_fail git config .foo false &&\n\ttest_must_fail git config foo. false &&\n\ttest_must_fail git config .foo. false &&\n\tgit config foo.bar true &&\n\tgit config foo.\"ba =z\".bar false\n'\n\ntest_expect_success 'git -c works with aliases of builtins' '\n\tgit config alias.checkconfig \"-c foo.check=bar config foo.check\" &&\n\techo bar >expect &&\n\tgit checkconfig >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'aliases can be CamelCased' '\n\ttest_config alias.CamelCased \"rev-parse HEAD\" &&\n\tgit CamelCased >out &&\n\tgit rev-parse HEAD >expect &&\n\ttest_cmp expect out\n'\n\ntest_expect_success 'git -c does not split values on equals' '\n\techo \"value with = in it\" >expect &&\n\tgit -c section.foo=\"value with = in it\" config section.foo >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'git -c dies on bogus config' '\n\ttest_must_fail git -c core.bare=foo rev-parse\n'\n\ntest_expect_success 'git -c complains about empty key' '\n\ttest_must_fail git -c \"=foo\" rev-parse\n'\n\ntest_expect_success 'git -c complains about empty key and value' '\n\ttest_must_fail git -c \"\" rev-parse\n'\n\ntest_expect_success 'multiple git -c appends config' '\n\ttest_config alias.x \"!git -c x.two=2 config --get-regexp ^x\\.*\" &&\n\tcat >expect <<-\\EOF &&\n\tx.one 1\n\tx.two 2\n\tEOF\n\tgit -c x.one=1 x >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'last one wins: two level vars' '\n\n\t# sec.var and sec.VAR are the same variable, as the first\n\t# and the last level of a configuration variable name is\n\t# case insensitive.\n\n\techo VAL >expect &&\n\n\tgit -c sec.var=val -c sec.VAR=VAL config --get sec.var >actual &&\n\ttest_cmp expect actual &&\n\tgit -c SEC.var=val -c sec.var=VAL config --get sec.var >actual &&\n\ttest_cmp expect actual &&\n\n\tgit -c sec.var=val -c sec.VAR=VAL config --get SEC.var >actual &&\n\ttest_cmp expect actual &&\n\tgit -c SEC.var=val -c sec.var=VAL config --get sec.VAR >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'last one wins: three level vars' '\n\n\t# v.a.r and v.A.r are not the same variable, as the middle\n\t# level of a three-level configuration variable name is\n\t# case sensitive.\n\n\techo val >expect &&\n\tgit -c v.a.r=val -c v.A.r=VAL config --get v.a.r >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c v.A.r=VAL config --get V.a.R >actual &&\n\ttest_cmp expect actual &&\n\n\t# v.a.r and V.a.R are the same variable, as the first\n\t# and the last level of a configuration variable name is\n\t# case insensitive.\n\n\techo VAL >expect &&\n\tgit -c v.a.r=val -c v.a.R=VAL config --get v.a.r >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c V.a.r=VAL config --get v.a.r >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c v.a.R=VAL config --get V.a.R >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c V.a.r=VAL config --get V.a.R >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'old-fashioned settings are case insensitive' '\n\ttest_when_finished \"rm -f testConfig testConfig_expect testConfig_actual\" &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tQr = value2\n\tEOF\n\tgit config -f testConfig_actual \"v.a.r\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tQR = value2\n\tEOF\n\tgit config -f testConfig_actual \"V.a.R\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tr = value1\n\tQr = value2\n\tEOF\n\tgit config -f testConfig_actual \"V.A.r\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tr = value1\n\tQr = value2\n\tEOF\n\tgit config -f testConfig_actual \"v.A.r\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual\n'\n\ntest_expect_success 'setting different case sensitive subsections ' '\n\ttest_when_finished \"rm -f testConfig testConfig_expect testConfig_actual\" &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V \"A\"]\n\tR = v1\n\t[K \"E\"]\n\tY = v1\n\t[a \"b\"]\n\tc = v1\n\t[d \"e\"]\n\tf = v1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V \"A\"]\n\tQr = v2\n\t[K \"E\"]\n\tQy = v2\n\t[a \"b\"]\n\tQc = v2\n\t[d \"e\"]\n\tf = v1\n\t[d \"E\"]\n\tQf = v2\n\tEOF\n\t# exact match\n\tgit config -f testConfig_actual a.b.c v2 &&\n\t# match section and subsection, key is cased differently.\n\tgit config -f testConfig_actual K.E.y v2 &&\n\t# section and key are matched case insensitive, but subsection needs\n\t# to match; When writing out new values only the key is adjusted\n\tgit config -f testConfig_actual v.A.r v2 &&\n\t# subsection is not matched:\n\tgit config -f testConfig_actual d.E.f v2 &&\n\ttest_cmp testConfig_expect testConfig_actual\n'\n\nfor VAR in a .a a. a.0b a.\"b c\". a.\"b c\".0d\ndo\n\ttest_expect_success \"git -c $VAR=VAL rejects invalid '$VAR'\" '\n\t\ttest_must_fail git -c \"$VAR=VAL\" config -l\n\t'\ndone\n\nfor VAR in a.b a.\"b c\".d\ndo\n\ttest_expect_success \"git -c $VAR=VAL works with valid '$VAR'\" '\n\t\techo VAL >expect &&\n\t\tgit -c \"$VAR=VAL\" config --get \"$VAR\" >actual &&\n\t\ttest_cmp expect actual\n\t'\ndone\n\ntest_expect_success 'git -c is not confused by empty environment' '\n\tGIT_CONFIG_PARAMETERS=\"\" git -c x.one=1 config --list\n'\n\ntest_expect_success 'detect bogus GIT_CONFIG_PARAMETERS' '\n\tcat >expect <<-\\EOF &&\n\tenv.one one\n\tenv.two two\n\tEOF\n\tGIT_CONFIG_PARAMETERS=\"${SQ}env.one=one${SQ} ${SQ}env.two=two${SQ}\" \\\n\t\tgit config --get-regexp \"env.*\" >actual &&\n\ttest_cmp expect actual &&\n\n\tcat >expect <<-EOF &&\n\tenv.one one${SQ}\n\tenv.two two\n\tEOF\n\tGIT_CONFIG_PARAMETERS=\"${SQ}env.one=one${SQ}\\\\$SQ$SQ$SQ ${SQ}env.two=two${SQ}\" \\\n\t\tgit config --get-regexp \"env.*\" >actual &&\n\ttest_cmp expect actual &&\n\n\ttest_must_fail env \\\n\t\tGIT_CONFIG_PARAMETERS=\"${SQ}env.one=one${SQ}\\\\$SQ ${SQ}env.two=two${SQ}\" \\\n\t\tgit config --get-regexp \"env.*\"\n'\n\ntest_expect_success 'git config --edit works' '\n\tgit config -f tmp test.value no &&\n\techo test.value=yes >expect &&\n\tGIT_EDITOR=\"echo [test]value=yes >\" git config -f tmp --edit &&\n\tgit config -f tmp --list >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'git config --edit respects core.editor' '\n\tgit config -f tmp test.value no &&\n\techo test.value=yes >expect &&\n\ttest_config core.editor \"echo [test]value=yes >\" &&\n\tgit config -f tmp --edit &&\n\tgit config -f tmp --list >actual &&\n\ttest_cmp expect actual\n'\n\n# malformed configuration files\ntest_expect_success 'barf on syntax error' '\n\tcat >.git/config <<-\\EOF &&\n\t# broken section line\n\t[section]\n\tkey garbage\n\tEOF\n\ttest_must_fail git config --get section.key >actual 2>error &&\n\ttest_i18ngrep \" line 3 \" error\n'\n\ntest_expect_success 'barf on incomplete section header' '\n\tcat >.git/config <<-\\EOF &&\n\t# broken section line\n\t[section\n\tkey = value\n\tEOF\n\ttest_must_fail git config --get section.key >actual 2>error &&\n\ttest_i18ngrep \" line 2 \" error\n'\n\ntest_expect_success 'barf on incomplete string' '\n\tcat >.git/config <<-\\EOF &&\n\t# broken section line\n\t[section]\n\tkey = \"value string\n\tEOF\n\ttest_must_fail git config --get section.key >actual 2>error &&\n\ttest_i18ngrep \" line 3 \" error\n'\n\ntest_expect_success 'urlmatch' '\n\tcat >.git/config <<-\\EOF &&\n\t[http]\n\t\tsslVerify\n\t[http \"https://weak.example.com\"]\n\t\tsslVerify = false\n\t\tcookieFile = /tmp/cookie.txt\n\tEOF\n\n\ttest_expect_code 1 git config --bool --get-urlmatch doesnt.exist https://good.example.com >actual &&\n\ttest_must_be_empty actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.SSLverify https://good.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo false >expect &&\n\tgit config --bool --get-urlmatch http.sslverify https://weak.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\t{\n\t\techo http.cookiefile /tmp/cookie.txt &&\n\t\techo http.sslverify false\n\t} >expect &&\n\tgit config --get-urlmatch HTTP https://weak.example.com >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'urlmatch favors more specific URLs' '\n\tcat >.git/config <<-\\EOF &&\n\t[http \"https://example.com/\"]\n\t\tcookieFile = /tmp/root.txt\n\t[http \"https://example.com/subdirectory\"]\n\t\tcookieFile = /tmp/subdirectory.txt\n\t[http \"https://user@example.com/\"]\n\t\tcookieFile = /tmp/user.txt\n\t[http \"https://averylonguser@example.com/\"]\n\t\tcookieFile = /tmp/averylonguser.txt\n\t[http \"https://preceding.example.com\"]\n\t\tcookieFile = /tmp/preceding.txt\n\t[http \"https://*.example.com\"]\n\t\tcookieFile = /tmp/wildcard.txt\n\t[http \"https://*.example.com/wildcardwithsubdomain\"]\n\t\tcookieFile = /tmp/wildcardwithsubdomain.txt\n\t[http \"https://*.example.*\"]\n\t\tcookieFile = /tmp/multiwildcard.txt\n\t[http \"https://trailing.example.com\"]\n\t\tcookieFile = /tmp/trailing.txt\n\t[http \"https://user@*.example.com/\"]\n\t\tcookieFile = /tmp/wildcardwithuser.txt\n\t[http \"https://sub.example.com/\"]\n\t\tcookieFile = /tmp/sub.txt\n\tEOF\n\n\techo http.cookiefile /tmp/root.txt >expect &&\n\tgit config --get-urlmatch HTTP https://example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/subdirectory.txt >expect &&\n\tgit config --get-urlmatch HTTP https://example.com/subdirectory >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/subdirectory.txt >expect &&\n\tgit config --get-urlmatch HTTP https://example.com/subdirectory/nested >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/user.txt >expect &&\n\tgit config --get-urlmatch HTTP https://user@example.com/ >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/subdirectory.txt >expect &&\n\tgit config --get-urlmatch HTTP https://averylonguser@example.com/subdirectory >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/preceding.txt >expect &&\n\tgit config --get-urlmatch HTTP https://preceding.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/wildcard.txt >expect &&\n\tgit config --get-urlmatch HTTP https://wildcard.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/sub.txt >expect &&\n\tgit config --get-urlmatch HTTP https://sub.example.com/wildcardwithsubdomain >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/trailing.txt >expect &&\n\tgit config --get-urlmatch HTTP https://trailing.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/sub.txt >expect &&\n\tgit config --get-urlmatch HTTP https://user@sub.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/multiwildcard.txt >expect &&\n\tgit config --get-urlmatch HTTP https://wildcard.example.org >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'urlmatch with wildcard' '\n\tcat >.git/config <<-\\EOF &&\n\t[http]\n\t\tsslVerify\n\t[http \"https://*.example.com\"]\n\t\tsslVerify = false\n\t\tcookieFile = /tmp/cookie.txt\n\tEOF\n\n\ttest_expect_code 1 git config --bool --get-urlmatch doesnt.exist https://good.example.com >actual &&\n\ttest_must_be_empty actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.SSLverify https://example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.SSLverify https://good-example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.sslverify https://deep.nested.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo false >expect &&\n\tgit config --bool --get-urlmatch http.sslverify https://good.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\t{\n\t\techo http.cookiefile /tmp/cookie.txt &&\n\t\techo http.sslverify false\n\t} >expect &&\n\tgit config --get-urlmatch HTTP https://good.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.sslverify >expect &&\n\tgit config --get-urlmatch HTTP https://more.example.com.au >actual &&\n\ttest_cmp expect actual\n'\n\n# good section hygiene\ntest_expect_success '--unset last key removes section (except if commented)' '\n\tcat >.git/config <<-\\EOF &&\n\t# some generic comment on the configuration file itself\n\t# a comment specific to this \"section\" section.\n\t[section]\n\t# some intervening lines\n\t# that should also be dropped\n\n\tkey = value\n\t# please be careful when you update the above variable\n\tEOF\n\n\tcat >expect <<-\\EOF &&\n\t# some generic comment on the configuration file itself\n\t# a comment specific to this \"section\" section.\n\t[section]\n\t# some intervening lines\n\t# that should also be dropped\n\n\t# please be careful when you update the above variable\n\tEOF\n\n\tgit config --unset section.key &&\n\ttest_cmp expect .git/config &&\n\n\tcat >.git/config <<-\\EOF &&\n\t[section]\n\tkey = value\n\t[next-section]\n\tEOF\n\n\tcat >expect <<-\\EOF &&\n\t[next-section]\n\tEOF\n\n\tgit config --unset section.key &&\n\ttest_cmp expect .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = \"multiline \\\n\tQQ# with comment\"\n\t[two]\n\tkey = true\n\tEOF\n\tgit config --unset two.key &&\n\t! grep two .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = \"multiline \\\n\tQQ# with comment\"\n\t[one]\n\tkey = true\n\tEOF\n\tgit config --unset-all one.key &&\n\ttest_line_count = 0 .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = true\n\tQ# a comment not at the start\n\t[two]\n\tQkey = true\n\tEOF\n\tgit config --unset two.key &&\n\tgrep two .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = not [two \"subsection\"]\n\t[two \"subsection\"]\n\t[two \"subsection\"]\n\tQkey = true\n\t[TWO \"subsection\"]\n\t[one]\n\tEOF\n\tgit config --unset two.subsection.key &&\n\ttest \"not [two subsection]\" = \"$(git config one.key)\" &&\n\ttest_line_count = 3 .git/config\n'\n\ntest_expect_success '--unset-all removes section if empty & uncommented' '\n\tcat >.git/config <<-\\EOF &&\n\t[section]\n\tkey = value1\n\tkey = value2\n\tEOF\n\n\tgit config --unset-all section.key &&\n\ttest_line_count = 0 .git/config\n'\n\ntest_expect_success 'adding a key into an empty section reuses header' '\n\tcat >.git/config <<-\\EOF &&\n\t[section]\n\tEOF\n\n\tq_to_tab >expect <<-\\EOF &&\n\t[section]\n\tQkey = value\n\tEOF\n\n\tgit config section.key value &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success POSIXPERM,PERL 'preserves existing permissions' '\n\tchmod 0600 .git/config &&\n\tgit config imap.pass Hunter2 &&\n\tperl -e \\\n\t  \"die q(badset) if ((stat(q(.git/config)))[2] & 07777) != 0600\" &&\n\tgit config --rename-section imap pop &&\n\tperl -e \\\n\t  \"die q(badrename) if ((stat(q(.git/config)))[2] & 07777) != 0600\"\n'\n\n! test_have_prereq MINGW ||\nHOME=\"$(pwd)\" # convert to Windows path\n\ntest_expect_success 'set up --show-origin tests' '\n\tINCLUDE_DIR=\"$HOME/include\" &&\n\tmkdir -p \"$INCLUDE_DIR\" &&\n\tcat >\"$INCLUDE_DIR\"/absolute.include <<-\\EOF &&\n\t[user]\n\t\tabsolute = include\n\tEOF\n\tcat >\"$INCLUDE_DIR\"/relative.include <<-\\EOF &&\n\t[user]\n\t\trelative = include\n\tEOF\n\tcat >\"$HOME\"/.gitconfig <<-EOF &&\n\t[user]\n\t\tglobal = true\n\t\toverride = global\n\t[include]\n\t\tpath = \"$INCLUDE_DIR/absolute.include\"\n\tEOF\n\tcat >.git/config <<-\\EOF\n\t[user]\n\t\tlocal = true\n\t\toverride = local\n\t[include]\n\t\tpath = ../include/relative.include\n\tEOF\n'\n\ntest_expect_success '--show-origin with --list' '\n\tcat >expect <<-EOF &&\n\tfile:$HOME/.gitconfig\tuser.global=true\n\tfile:$HOME/.gitconfig\tuser.override=global\n\tfile:$HOME/.gitconfig\tinclude.path=$INCLUDE_DIR/absolute.include\n\tfile:$INCLUDE_DIR/absolute.include\tuser.absolute=include\n\tfile:.git/config\tuser.local=true\n\tfile:.git/config\tuser.override=local\n\tfile:.git/config\tinclude.path=../include/relative.include\n\tfile:.git/../include/relative.include\tuser.relative=include\n\tcommand line:\tuser.cmdline=true\n\tEOF\n\tgit -c user.cmdline=true config --list --show-origin >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin with --list --null' '\n\tcat >expect <<-EOF &&\n\tfile:$HOME/.gitconfigQuser.global\n\ttrueQfile:$HOME/.gitconfigQuser.override\n\tglobalQfile:$HOME/.gitconfigQinclude.path\n\t$INCLUDE_DIR/absolute.includeQfile:$INCLUDE_DIR/absolute.includeQuser.absolute\n\tincludeQfile:.git/configQuser.local\n\ttrueQfile:.git/configQuser.override\n\tlocalQfile:.git/configQinclude.path\n\t../include/relative.includeQfile:.git/../include/relative.includeQuser.relative\n\tincludeQcommand line:Quser.cmdline\n\ttrueQ\n\tEOF\n\tgit -c user.cmdline=true config --null --list --show-origin >output.raw &&\n\tnul_to_q <output.raw >output &&\n\t# The here-doc above adds a newline that the --null output would not\n\t# include. Add it here to make the two comparable.\n\techo >>output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin with single file' '\n\tcat >expect <<-\\EOF &&\n\tfile:.git/config\tuser.local=true\n\tfile:.git/config\tuser.override=local\n\tfile:.git/config\tinclude.path=../include/relative.include\n\tEOF\n\tgit config --local --list --show-origin >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin with --get-regexp' '\n\tcat >expect <<-EOF &&\n\tfile:$HOME/.gitconfig\tuser.global true\n\tfile:.git/config\tuser.local true\n\tEOF\n\tgit config --show-origin --get-regexp \"user\\.[g|l].*\" >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin getting a single key' '\n\tcat >expect <<-\\EOF &&\n\tfile:.git/config\tlocal\n\tEOF\n\tgit config --show-origin user.override >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'set up custom config file' '\n\tCUSTOM_CONFIG_FILE=\"custom.conf\" &&\n\tcat >\"$CUSTOM_CONFIG_FILE\" <<-\\EOF\n\t[user]\n\t\tcustom = true\n\tEOF\n'\n\ntest_expect_success !MINGW 'set up custom config file with special name characters' '\n\tWEIRDLY_NAMED_FILE=\"file\\\" (dq) and spaces.conf\" &&\n\tcp \"$CUSTOM_CONFIG_FILE\" \"$WEIRDLY_NAMED_FILE\"\n'\n\ntest_expect_success !MINGW '--show-origin escape special file name characters' '\n\tcat >expect <<-\\EOF &&\n\tfile:\"file\\\" (dq) and spaces.conf\"\tuser.custom=true\n\tEOF\n\tgit config --file \"$WEIRDLY_NAMED_FILE\" --show-origin --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin stdin' '\n\tcat >expect <<-\\EOF &&\n\tstandard input:\tuser.custom=true\n\tEOF\n\tgit config --file - --show-origin --list <\"$CUSTOM_CONFIG_FILE\" >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin stdin with file include' '\n\tcat >\"$INCLUDE_DIR\"/stdin.include <<-EOF &&\n\t[user]\n\t\tstdin = include\n\tEOF\n\tcat >expect <<-EOF &&\n\tfile:$INCLUDE_DIR/stdin.include\tinclude\n\tEOF\n\techo \"[include]path=\\\"$INCLUDE_DIR\\\"/stdin.include\" |\n\tgit config --show-origin --includes --file - user.stdin >output &&\n\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin blob' '\n\tblob=$(git hash-object -w \"$CUSTOM_CONFIG_FILE\") &&\n\tcat >expect <<-EOF &&\n\tblob:$blob\tuser.custom=true\n\tEOF\n\tgit config --blob=$blob --show-origin --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin blob ref' '\n\tcat >expect <<-\\EOF &&\n\tblob:master:custom.conf\tuser.custom=true\n\tEOF\n\tgit add \"$CUSTOM_CONFIG_FILE\" &&\n\tgit commit -m \"new config file\" &&\n\tgit config --blob=master:\"$CUSTOM_CONFIG_FILE\" --show-origin --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope with --list' '\n\tcat >expect <<-EOF &&\n\tglobal\tuser.global=true\n\tglobal\tuser.override=global\n\tglobal\tinclude.path=$INCLUDE_DIR/absolute.include\n\tglobal\tuser.absolute=include\n\tlocal\tuser.local=true\n\tlocal\tuser.override=local\n\tlocal\tinclude.path=../include/relative.include\n\tlocal\tuser.relative=include\n\tcommand\tuser.cmdline=true\n\tEOF\n\tgit -c user.cmdline=true config --list --show-scope >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success !MINGW '--show-scope with --blob' '\n\tblob=$(git hash-object -w \"$CUSTOM_CONFIG_FILE\") &&\n\tcat >expect <<-EOF &&\n\tcommand\tuser.custom=true\n\tEOF\n\tgit config --blob=$blob --show-scope --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope with --local' '\n\tcat >expect <<-\\EOF &&\n\tlocal\tuser.local=true\n\tlocal\tuser.override=local\n\tlocal\tinclude.path=../include/relative.include\n\tEOF\n\tgit config --local --list --show-scope >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope getting a single value' '\n\tcat >expect <<-\\EOF &&\n\tlocal\ttrue\n\tEOF\n\tgit config --show-scope --get user.local >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope with --show-origin' '\n\tcat >expect <<-EOF &&\n\tglobal\tfile:$HOME/.gitconfig\tuser.global=true\n\tglobal\tfile:$HOME/.gitconfig\tuser.override=global\n\tglobal\tfile:$HOME/.gitconfig\tinclude.path=$INCLUDE_DIR/absolute.include\n\tglobal\tfile:$INCLUDE_DIR/absolute.include\tuser.absolute=include\n\tlocal\tfile:.git/config\tuser.local=true\n\tlocal\tfile:.git/config\tuser.override=local\n\tlocal\tfile:.git/config\tinclude.path=../include/relative.include\n\tlocal\tfile:.git/../include/relative.include\tuser.relative=include\n\tcommand\tcommand line:\tuser.cmdline=true\n\tEOF\n\tgit -c user.cmdline=true config --list --show-origin --show-scope >output &&\n\ttest_cmp expect output\n'\n\nfor opt in --local --worktree\ndo\n\ttest_expect_success \"$opt requires a repo\" '\n\t\t# we expect 128 to ensure that we do not simply\n\t\t# fail to find anything and return code \"1\"\n\t\ttest_expect_code 128 nongit git config $opt foo.bar\n\t'\ndone\n\ncat >.git/config <<-\\EOF &&\n[section]\nfoo = true\nnumber = 10\nbig = 1M\nEOF\n\ntest_expect_success 'identical modern --type specifiers are allowed' '\n\ttest_cmp_config 1048576 --type=int --type=int section.big\n'\n\ntest_expect_success 'identical legacy --type specifiers are allowed' '\n\ttest_cmp_config 1048576 --int --int section.big\n'\n\ntest_expect_success 'identical mixed --type specifiers are allowed' '\n\ttest_cmp_config 1048576 --int --type=int section.big\n'\n\ntest_expect_success 'non-identical modern --type specifiers are not allowed' '\n\ttest_must_fail git config --type=int --type=bool section.big 2>error &&\n\ttest_i18ngrep \"only one type at a time\" error\n'\n\ntest_expect_success 'non-identical legacy --type specifiers are not allowed' '\n\ttest_must_fail git config --int --bool section.big 2>error &&\n\ttest_i18ngrep \"only one type at a time\" error\n'\n\ntest_expect_success 'non-identical mixed --type specifiers are not allowed' '\n\ttest_must_fail git config --type=int --bool section.big 2>error &&\n\ttest_i18ngrep \"only one type at a time\" error\n'\n\ntest_expect_success '--type allows valid type specifiers' '\n\ttest_cmp_config true  --type=bool section.foo\n'\n\ntest_expect_success '--no-type unsets type specifiers' '\n\ttest_cmp_config 10 --type=bool --no-type section.number\n'\n\ntest_expect_success 'unset type specifiers may be reset to conflicting ones' '\n\ttest_cmp_config 1048576 --type=bool --no-type --type=int section.big\n'\n\ntest_expect_success '--type rejects unknown specifiers' '\n\ttest_must_fail git config --type=nonsense section.foo 2>error &&\n\ttest_i18ngrep \"unrecognized --type argument\" error\n'\n\ntest_expect_success '--replace-all does not invent newlines' '\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[abc]key\n\tQkeepSection\n\t[xyz]\n\tQkey = 1\n\t[abc]\n\tQkey = a\n\tEOF\n\tq_to_tab >expect <<-\\EOF &&\n\t[abc]\n\tQkeepSection\n\t[xyz]\n\tQkey = 1\n\t[abc]\n\tQkey = b\n\tEOF\n\tgit config --replace-all abc.key b &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'set all config with value-pattern' '\n\ttest_when_finished rm -f config initial &&\n\tgit config --file=initial abc.key one &&\n\n\t# no match => add new entry\n\tcp initial config &&\n\tgit config --file=config abc.key two a+ &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=one\n\tabc.key=two\n\tEOF\n\ttest_cmp expect actual &&\n\n\t# multiple matches => failure\n\ttest_must_fail git config --file=config abc.key three o+ 2>err &&\n\ttest_i18ngrep \"has multiple values\" err &&\n\n\t# multiple values, no match => add\n\tgit config --file=config abc.key three a+ &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=one\n\tabc.key=two\n\tabc.key=three\n\tEOF\n\ttest_cmp expect actual &&\n\n\t# single match => replace\n\tgit config --file=config abc.key four h+ &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=one\n\tabc.key=two\n\tabc.key=four\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success '--replace-all and value-pattern' '\n\ttest_when_finished rm -f config &&\n\tgit config --file=config --add abc.key one &&\n\tgit config --file=config --add abc.key two &&\n\tgit config --file=config --add abc.key three &&\n\tgit config --file=config --replace-all abc.key four \"o+\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=four\n\tabc.key=three\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'refuse --fixed-value for incompatible actions' '\n\ttest_when_finished rm -f config &&\n\tgit config --file=config dev.null bogus &&\n\n\t# These modes do not allow --fixed-value at all\n\ttest_must_fail git config --file=config --fixed-value --add dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --get-urlmatch dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --get-urlmatch dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --rename-section dev null &&\n\ttest_must_fail git config --file=config --fixed-value --remove-section dev &&\n\ttest_must_fail git config --file=config --fixed-value --list &&\n\ttest_must_fail git config --file=config --fixed-value --get-color dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --get-colorbool dev.null &&\n\n\t# These modes complain when --fixed-value has no value-pattern\n\ttest_must_fail git config --file=config --fixed-value dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --replace-all dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --get dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --get-all dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --get-regexp \"dev.*\" &&\n\ttest_must_fail git config --file=config --fixed-value --unset dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --unset-all dev.null\n'\n\ntest_expect_success '--fixed-value uses exact string matching' '\n\ttest_when_finished rm -f config initial &&\n\tMETA=\"a+b*c?d[e]f.g\" &&\n\tgit config --file=initial fixed.test \"$META\" &&\n\n\tcp initial config &&\n\tgit config --file=config fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-EOF &&\n\tfixed.test=$META\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual &&\n\n\tcp initial config &&\n\tgit config --file=config --fixed-value fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual &&\n\n\tcp initial config &&\n\ttest_must_fail git config --file=config --unset fixed.test \"$META\" &&\n\tgit config --file=config --fixed-value --unset fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config fixed.test &&\n\n\tcp initial config &&\n\ttest_must_fail git config --file=config --unset-all fixed.test \"$META\" &&\n\tgit config --file=config --fixed-value --unset-all fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config fixed.test &&\n\n\tcp initial config &&\n\tgit config --file=config --replace-all fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-EOF &&\n\tfixed.test=$META\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual &&\n\n\tgit config --file=config --fixed-value --replace-all fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-EOF &&\n\tfixed.test=bogus\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success '--get and --get-all with --fixed-value' '\n\ttest_when_finished rm -f config &&\n\tMETA=\"a+b*c?d[e]f.g\" &&\n\tgit config --file=config fixed.test bogus &&\n\tgit config --file=config --add fixed.test \"$META\" &&\n\n\tgit config --file=config --get fixed.test bogus &&\n\ttest_must_fail git config --file=config --get fixed.test \"$META\" &&\n\tgit config --file=config --get --fixed-value fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config --get --fixed-value fixed.test non-existent &&\n\n\tgit config --file=config --get-all fixed.test bogus &&\n\ttest_must_fail git config --file=config --get-all fixed.test \"$META\" &&\n\tgit config --file=config --get-all --fixed-value fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config --get-all --fixed-value fixed.test non-existent &&\n\n\tgit config --file=config --get-regexp fixed+ bogus &&\n\ttest_must_fail git config --file=config --get-regexp fixed+ \"$META\" &&\n\tgit config --file=config --get-regexp --fixed-value fixed+ \"$META\" &&\n\ttest_must_fail git config --file=config --get-regexp --fixed-value fixed+ non-existent\n'\n\ntest_done\n"], "fixing_code": ["/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n * Copyright (C) Johannes Schindelin, 2005\n *\n */\n#include \"cache.h\"\n#include \"branch.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"lockfile.h\"\n#include \"exec-cmd.h\"\n#include \"strbuf.h\"\n#include \"quote.h\"\n#include \"hashmap.h\"\n#include \"string-list.h\"\n#include \"object-store.h\"\n#include \"utf8.h\"\n#include \"dir.h\"\n#include \"color.h\"\n#include \"refs.h\"\n\nstruct config_source {\n\tstruct config_source *prev;\n\tunion {\n\t\tFILE *file;\n\t\tstruct config_buf {\n\t\t\tconst char *buf;\n\t\t\tsize_t len;\n\t\t\tsize_t pos;\n\t\t} buf;\n\t} u;\n\tenum config_origin_type origin_type;\n\tconst char *name;\n\tconst char *path;\n\tenum config_error_action default_error_action;\n\tint linenr;\n\tint eof;\n\tsize_t total_len;\n\tstruct strbuf value;\n\tstruct strbuf var;\n\tunsigned subsection_case_sensitive : 1;\n\n\tint (*do_fgetc)(struct config_source *c);\n\tint (*do_ungetc)(int c, struct config_source *conf);\n\tlong (*do_ftell)(struct config_source *c);\n};\n\n/*\n * These variables record the \"current\" config source, which\n * can be accessed by parsing callbacks.\n *\n * The \"cf\" variable will be non-NULL only when we are actually parsing a real\n * config source (file, blob, cmdline, etc).\n *\n * The \"current_config_kvi\" variable will be non-NULL only when we are feeding\n * cached config from a configset into a callback.\n *\n * They should generally never be non-NULL at the same time. If they are both\n * NULL, then we aren't parsing anything (and depending on the function looking\n * at the variables, it's either a bug for it to be called in the first place,\n * or it's a function which can be reused for non-config purposes, and should\n * fall back to some sane behavior).\n */\nstatic struct config_source *cf;\nstatic struct key_value_info *current_config_kvi;\n\n/*\n * Similar to the variables above, this gives access to the \"scope\" of the\n * current value (repo, global, etc). For cached values, it can be found via\n * the current_config_kvi as above. During parsing, the current value can be\n * found in this variable. It's not part of \"cf\" because it transcends a single\n * file (i.e., a file included from .git/config is still in \"repo\" scope).\n */\nstatic enum config_scope current_parsing_scope;\n\nstatic int core_compression_seen;\nstatic int pack_compression_seen;\nstatic int zlib_compression_seen;\n\nstatic int config_file_fgetc(struct config_source *conf)\n{\n\treturn getc_unlocked(conf->u.file);\n}\n\nstatic int config_file_ungetc(int c, struct config_source *conf)\n{\n\treturn ungetc(c, conf->u.file);\n}\n\nstatic long config_file_ftell(struct config_source *conf)\n{\n\treturn ftell(conf->u.file);\n}\n\n\nstatic int config_buf_fgetc(struct config_source *conf)\n{\n\tif (conf->u.buf.pos < conf->u.buf.len)\n\t\treturn conf->u.buf.buf[conf->u.buf.pos++];\n\n\treturn EOF;\n}\n\nstatic int config_buf_ungetc(int c, struct config_source *conf)\n{\n\tif (conf->u.buf.pos > 0) {\n\t\tconf->u.buf.pos--;\n\t\tif (conf->u.buf.buf[conf->u.buf.pos] != c)\n\t\t\tBUG(\"config_buf can only ungetc the same character\");\n\t\treturn c;\n\t}\n\n\treturn EOF;\n}\n\nstatic long config_buf_ftell(struct config_source *conf)\n{\n\treturn conf->u.buf.pos;\n}\n\n#define MAX_INCLUDE_DEPTH 10\nstatic const char include_depth_advice[] = N_(\n\"exceeded maximum include depth (%d) while including\\n\"\n\"\t%s\\n\"\n\"from\\n\"\n\"\t%s\\n\"\n\"This might be due to circular includes.\");\nstatic int handle_path_include(const char *path, struct config_include_data *inc)\n{\n\tint ret = 0;\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *expanded;\n\n\tif (!path)\n\t\treturn config_error_nonbool(\"include.path\");\n\n\texpanded = expand_user_path(path, 0);\n\tif (!expanded)\n\t\treturn error(_(\"could not expand include path '%s'\"), path);\n\tpath = expanded;\n\n\t/*\n\t * Use an absolute path as-is, but interpret relative paths\n\t * based on the including config file.\n\t */\n\tif (!is_absolute_path(path)) {\n\t\tchar *slash;\n\n\t\tif (!cf || !cf->path)\n\t\t\treturn error(_(\"relative config includes must come from files\"));\n\n\t\tslash = find_last_dir_sep(cf->path);\n\t\tif (slash)\n\t\t\tstrbuf_add(&buf, cf->path, slash - cf->path + 1);\n\t\tstrbuf_addstr(&buf, path);\n\t\tpath = buf.buf;\n\t}\n\n\tif (!access_or_die(path, R_OK, 0)) {\n\t\tif (++inc->depth > MAX_INCLUDE_DEPTH)\n\t\t\tdie(_(include_depth_advice), MAX_INCLUDE_DEPTH, path,\n\t\t\t    !cf ? \"<unknown>\" :\n\t\t\t    cf->name ? cf->name :\n\t\t\t    \"the command line\");\n\t\tret = git_config_from_file(git_config_include, path, inc);\n\t\tinc->depth--;\n\t}\n\tstrbuf_release(&buf);\n\tfree(expanded);\n\treturn ret;\n}\n\nstatic void add_trailing_starstar_for_dir(struct strbuf *pat)\n{\n\tif (pat->len && is_dir_sep(pat->buf[pat->len - 1]))\n\t\tstrbuf_addstr(pat, \"**\");\n}\n\nstatic int prepare_include_condition_pattern(struct strbuf *pat)\n{\n\tstruct strbuf path = STRBUF_INIT;\n\tchar *expanded;\n\tint prefix = 0;\n\n\texpanded = expand_user_path(pat->buf, 1);\n\tif (expanded) {\n\t\tstrbuf_reset(pat);\n\t\tstrbuf_addstr(pat, expanded);\n\t\tfree(expanded);\n\t}\n\n\tif (pat->buf[0] == '.' && is_dir_sep(pat->buf[1])) {\n\t\tconst char *slash;\n\n\t\tif (!cf || !cf->path)\n\t\t\treturn error(_(\"relative config include \"\n\t\t\t\t       \"conditionals must come from files\"));\n\n\t\tstrbuf_realpath(&path, cf->path, 1);\n\t\tslash = find_last_dir_sep(path.buf);\n\t\tif (!slash)\n\t\t\tBUG(\"how is this possible?\");\n\t\tstrbuf_splice(pat, 0, 1, path.buf, slash - path.buf);\n\t\tprefix = slash - path.buf + 1 /* slash */;\n\t} else if (!is_absolute_path(pat->buf))\n\t\tstrbuf_insertstr(pat, 0, \"**/\");\n\n\tadd_trailing_starstar_for_dir(pat);\n\n\tstrbuf_release(&path);\n\treturn prefix;\n}\n\nstatic int include_by_gitdir(const struct config_options *opts,\n\t\t\t     const char *cond, size_t cond_len, int icase)\n{\n\tstruct strbuf text = STRBUF_INIT;\n\tstruct strbuf pattern = STRBUF_INIT;\n\tint ret = 0, prefix;\n\tconst char *git_dir;\n\tint already_tried_absolute = 0;\n\n\tif (opts->git_dir)\n\t\tgit_dir = opts->git_dir;\n\telse\n\t\tgoto done;\n\n\tstrbuf_realpath(&text, git_dir, 1);\n\tstrbuf_add(&pattern, cond, cond_len);\n\tprefix = prepare_include_condition_pattern(&pattern);\n\nagain:\n\tif (prefix < 0)\n\t\tgoto done;\n\n\tif (prefix > 0) {\n\t\t/*\n\t\t * perform literal matching on the prefix part so that\n\t\t * any wildcard character in it can't create side effects.\n\t\t */\n\t\tif (text.len < prefix)\n\t\t\tgoto done;\n\t\tif (!icase && strncmp(pattern.buf, text.buf, prefix))\n\t\t\tgoto done;\n\t\tif (icase && strncasecmp(pattern.buf, text.buf, prefix))\n\t\t\tgoto done;\n\t}\n\n\tret = !wildmatch(pattern.buf + prefix, text.buf + prefix,\n\t\t\t WM_PATHNAME | (icase ? WM_CASEFOLD : 0));\n\n\tif (!ret && !already_tried_absolute) {\n\t\t/*\n\t\t * We've tried e.g. matching gitdir:~/work, but if\n\t\t * ~/work is a symlink to /mnt/storage/work\n\t\t * strbuf_realpath() will expand it, so the rule won't\n\t\t * match. Let's match against a\n\t\t * strbuf_add_absolute_path() version of the path,\n\t\t * which'll do the right thing\n\t\t */\n\t\tstrbuf_reset(&text);\n\t\tstrbuf_add_absolute_path(&text, git_dir);\n\t\talready_tried_absolute = 1;\n\t\tgoto again;\n\t}\ndone:\n\tstrbuf_release(&pattern);\n\tstrbuf_release(&text);\n\treturn ret;\n}\n\nstatic int include_by_branch(const char *cond, size_t cond_len)\n{\n\tint flags;\n\tint ret;\n\tstruct strbuf pattern = STRBUF_INIT;\n\tconst char *refname = !the_repository->gitdir ?\n\t\tNULL : resolve_ref_unsafe(\"HEAD\", 0, NULL, &flags);\n\tconst char *shortname;\n\n\tif (!refname || !(flags & REF_ISSYMREF)\t||\n\t\t\t!skip_prefix(refname, \"refs/heads/\", &shortname))\n\t\treturn 0;\n\n\tstrbuf_add(&pattern, cond, cond_len);\n\tadd_trailing_starstar_for_dir(&pattern);\n\tret = !wildmatch(pattern.buf, shortname, WM_PATHNAME);\n\tstrbuf_release(&pattern);\n\treturn ret;\n}\n\nstatic int include_condition_is_true(const struct config_options *opts,\n\t\t\t\t     const char *cond, size_t cond_len)\n{\n\n\tif (skip_prefix_mem(cond, cond_len, \"gitdir:\", &cond, &cond_len))\n\t\treturn include_by_gitdir(opts, cond, cond_len, 0);\n\telse if (skip_prefix_mem(cond, cond_len, \"gitdir/i:\", &cond, &cond_len))\n\t\treturn include_by_gitdir(opts, cond, cond_len, 1);\n\telse if (skip_prefix_mem(cond, cond_len, \"onbranch:\", &cond, &cond_len))\n\t\treturn include_by_branch(cond, cond_len);\n\n\t/* unknown conditionals are always false */\n\treturn 0;\n}\n\nint git_config_include(const char *var, const char *value, void *data)\n{\n\tstruct config_include_data *inc = data;\n\tconst char *cond, *key;\n\tsize_t cond_len;\n\tint ret;\n\n\t/*\n\t * Pass along all values, including \"include\" directives; this makes it\n\t * possible to query information on the includes themselves.\n\t */\n\tret = inc->fn(var, value, inc->data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!strcmp(var, \"include.path\"))\n\t\tret = handle_path_include(value, inc);\n\n\tif (!parse_config_key(var, \"includeif\", &cond, &cond_len, &key) &&\n\t    (cond && include_condition_is_true(inc->opts, cond, cond_len)) &&\n\t    !strcmp(key, \"path\"))\n\t\tret = handle_path_include(value, inc);\n\n\treturn ret;\n}\n\nvoid git_config_push_parameter(const char *text)\n{\n\tstruct strbuf env = STRBUF_INIT;\n\tconst char *old = getenv(CONFIG_DATA_ENVIRONMENT);\n\tif (old && *old) {\n\t\tstrbuf_addstr(&env, old);\n\t\tstrbuf_addch(&env, ' ');\n\t}\n\tsq_quote_buf(&env, text);\n\tsetenv(CONFIG_DATA_ENVIRONMENT, env.buf, 1);\n\tstrbuf_release(&env);\n}\n\nstatic inline int iskeychar(int c)\n{\n\treturn isalnum(c) || c == '-';\n}\n\n/*\n * Auxiliary function to sanity-check and split the key into the section\n * identifier and variable name.\n *\n * Returns 0 on success, -1 when there is an invalid character in the key and\n * -2 if there is no section name in the key.\n *\n * store_key - pointer to char* which will hold a copy of the key with\n *             lowercase section and variable name\n * baselen - pointer to size_t which will hold the length of the\n *           section + subsection part, can be NULL\n */\nstatic int git_config_parse_key_1(const char *key, char **store_key, size_t *baselen_, int quiet)\n{\n\tsize_t i, baselen;\n\tint dot;\n\tconst char *last_dot = strrchr(key, '.');\n\n\t/*\n\t * Since \"key\" actually contains the section name and the real\n\t * key name separated by a dot, we have to know where the dot is.\n\t */\n\n\tif (last_dot == NULL || last_dot == key) {\n\t\tif (!quiet)\n\t\t\terror(_(\"key does not contain a section: %s\"), key);\n\t\treturn -CONFIG_NO_SECTION_OR_NAME;\n\t}\n\n\tif (!last_dot[1]) {\n\t\tif (!quiet)\n\t\t\terror(_(\"key does not contain variable name: %s\"), key);\n\t\treturn -CONFIG_NO_SECTION_OR_NAME;\n\t}\n\n\tbaselen = last_dot - key;\n\tif (baselen_)\n\t\t*baselen_ = baselen;\n\n\t/*\n\t * Validate the key and while at it, lower case it for matching.\n\t */\n\tif (store_key)\n\t\t*store_key = xmallocz(strlen(key));\n\n\tdot = 0;\n\tfor (i = 0; key[i]; i++) {\n\t\tunsigned char c = key[i];\n\t\tif (c == '.')\n\t\t\tdot = 1;\n\t\t/* Leave the extended basename untouched.. */\n\t\tif (!dot || i > baselen) {\n\t\t\tif (!iskeychar(c) ||\n\t\t\t    (i == baselen + 1 && !isalpha(c))) {\n\t\t\t\tif (!quiet)\n\t\t\t\t\terror(_(\"invalid key: %s\"), key);\n\t\t\t\tgoto out_free_ret_1;\n\t\t\t}\n\t\t\tc = tolower(c);\n\t\t} else if (c == '\\n') {\n\t\t\tif (!quiet)\n\t\t\t\terror(_(\"invalid key (newline): %s\"), key);\n\t\t\tgoto out_free_ret_1;\n\t\t}\n\t\tif (store_key)\n\t\t\t(*store_key)[i] = c;\n\t}\n\n\treturn 0;\n\nout_free_ret_1:\n\tif (store_key) {\n\t\tFREE_AND_NULL(*store_key);\n\t}\n\treturn -CONFIG_INVALID_KEY;\n}\n\nint git_config_parse_key(const char *key, char **store_key, size_t *baselen)\n{\n\treturn git_config_parse_key_1(key, store_key, baselen, 0);\n}\n\nint git_config_key_is_valid(const char *key)\n{\n\treturn !git_config_parse_key_1(key, NULL, NULL, 1);\n}\n\nint git_config_parse_parameter(const char *text,\n\t\t\t       config_fn_t fn, void *data)\n{\n\tconst char *value;\n\tchar *canonical_name;\n\tstruct strbuf **pair;\n\tint ret;\n\n\tpair = strbuf_split_str(text, '=', 2);\n\tif (!pair[0])\n\t\treturn error(_(\"bogus config parameter: %s\"), text);\n\n\tif (pair[0]->len && pair[0]->buf[pair[0]->len - 1] == '=') {\n\t\tstrbuf_setlen(pair[0], pair[0]->len - 1);\n\t\tvalue = pair[1] ? pair[1]->buf : \"\";\n\t} else {\n\t\tvalue = NULL;\n\t}\n\n\tstrbuf_trim(pair[0]);\n\tif (!pair[0]->len) {\n\t\tstrbuf_list_free(pair);\n\t\treturn error(_(\"bogus config parameter: %s\"), text);\n\t}\n\n\tif (git_config_parse_key(pair[0]->buf, &canonical_name, NULL)) {\n\t\tret = -1;\n\t} else {\n\t\tret = (fn(canonical_name, value, data) < 0) ? -1 : 0;\n\t\tfree(canonical_name);\n\t}\n\tstrbuf_list_free(pair);\n\treturn ret;\n}\n\nint git_config_from_parameters(config_fn_t fn, void *data)\n{\n\tconst char *env = getenv(CONFIG_DATA_ENVIRONMENT);\n\tint ret = 0;\n\tchar *envw;\n\tconst char **argv = NULL;\n\tint nr = 0, alloc = 0;\n\tint i;\n\tstruct config_source source;\n\n\tif (!env)\n\t\treturn 0;\n\n\tmemset(&source, 0, sizeof(source));\n\tsource.prev = cf;\n\tsource.origin_type = CONFIG_ORIGIN_CMDLINE;\n\tcf = &source;\n\n\t/* sq_dequote will write over it */\n\tenvw = xstrdup(env);\n\n\tif (sq_dequote_to_argv(envw, &argv, &nr, &alloc) < 0) {\n\t\tret = error(_(\"bogus format in %s\"), CONFIG_DATA_ENVIRONMENT);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (git_config_parse_parameter(argv[i], fn, data) < 0) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(argv);\n\tfree(envw);\n\tcf = source.prev;\n\treturn ret;\n}\n\nstatic int get_next_char(void)\n{\n\tint c = cf->do_fgetc(cf);\n\n\tif (c == '\\r') {\n\t\t/* DOS like systems */\n\t\tc = cf->do_fgetc(cf);\n\t\tif (c != '\\n') {\n\t\t\tif (c != EOF)\n\t\t\t\tcf->do_ungetc(c, cf);\n\t\t\tc = '\\r';\n\t\t}\n\t}\n\n\tif (c != EOF && ++cf->total_len > INT_MAX) {\n\t\t/*\n\t\t * This is an absurdly long config file; refuse to parse\n\t\t * further in order to protect downstream code from integer\n\t\t * overflows. Note that we can't return an error specifically,\n\t\t * but we can mark EOF and put trash in the return value,\n\t\t * which will trigger a parse error.\n\t\t */\n\t\tcf->eof = 1;\n\t\treturn 0;\n\t}\n\n\tif (c == '\\n')\n\t\tcf->linenr++;\n\tif (c == EOF) {\n\t\tcf->eof = 1;\n\t\tcf->linenr++;\n\t\tc = '\\n';\n\t}\n\treturn c;\n}\n\nstatic char *parse_value(void)\n{\n\tint quote = 0, comment = 0, space = 0;\n\n\tstrbuf_reset(&cf->value);\n\tfor (;;) {\n\t\tint c = get_next_char();\n\t\tif (c == '\\n') {\n\t\t\tif (quote) {\n\t\t\t\tcf->linenr--;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cf->value.buf;\n\t\t}\n\t\tif (comment)\n\t\t\tcontinue;\n\t\tif (isspace(c) && !quote) {\n\t\t\tif (cf->value.len)\n\t\t\t\tspace++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!quote) {\n\t\t\tif (c == ';' || c == '#') {\n\t\t\t\tcomment = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (; space; space--)\n\t\t\tstrbuf_addch(&cf->value, ' ');\n\t\tif (c == '\\\\') {\n\t\t\tc = get_next_char();\n\t\t\tswitch (c) {\n\t\t\tcase '\\n':\n\t\t\t\tcontinue;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\tbreak;\n\t\t\t/* Some characters escape as themselves */\n\t\t\tcase '\\\\': case '\"':\n\t\t\t\tbreak;\n\t\t\t/* Reject unknown escape sequences */\n\t\t\tdefault:\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrbuf_addch(&cf->value, c);\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '\"') {\n\t\t\tquote = 1-quote;\n\t\t\tcontinue;\n\t\t}\n\t\tstrbuf_addch(&cf->value, c);\n\t}\n}\n\nstatic int get_value(config_fn_t fn, void *data, struct strbuf *name)\n{\n\tint c;\n\tchar *value;\n\tint ret;\n\n\t/* Get the full name */\n\tfor (;;) {\n\t\tc = get_next_char();\n\t\tif (cf->eof)\n\t\t\tbreak;\n\t\tif (!iskeychar(c))\n\t\t\tbreak;\n\t\tstrbuf_addch(name, tolower(c));\n\t}\n\n\twhile (c == ' ' || c == '\\t')\n\t\tc = get_next_char();\n\n\tvalue = NULL;\n\tif (c != '\\n') {\n\t\tif (c != '=')\n\t\t\treturn -1;\n\t\tvalue = parse_value();\n\t\tif (!value)\n\t\t\treturn -1;\n\t}\n\t/*\n\t * We already consumed the \\n, but we need linenr to point to\n\t * the line we just parsed during the call to fn to get\n\t * accurate line number in error messages.\n\t */\n\tcf->linenr--;\n\tret = fn(name->buf, value, data);\n\tif (ret >= 0)\n\t\tcf->linenr++;\n\treturn ret;\n}\n\nstatic int get_extended_base_var(struct strbuf *name, int c)\n{\n\tcf->subsection_case_sensitive = 0;\n\tdo {\n\t\tif (c == '\\n')\n\t\t\tgoto error_incomplete_line;\n\t\tc = get_next_char();\n\t} while (isspace(c));\n\n\t/* We require the format to be '[base \"extension\"]' */\n\tif (c != '\"')\n\t\treturn -1;\n\tstrbuf_addch(name, '.');\n\n\tfor (;;) {\n\t\tint c = get_next_char();\n\t\tif (c == '\\n')\n\t\t\tgoto error_incomplete_line;\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tif (c == '\\\\') {\n\t\t\tc = get_next_char();\n\t\t\tif (c == '\\n')\n\t\t\t\tgoto error_incomplete_line;\n\t\t}\n\t\tstrbuf_addch(name, c);\n\t}\n\n\t/* Final ']' */\n\tif (get_next_char() != ']')\n\t\treturn -1;\n\treturn 0;\nerror_incomplete_line:\n\tcf->linenr--;\n\treturn -1;\n}\n\nstatic int get_base_var(struct strbuf *name)\n{\n\tcf->subsection_case_sensitive = 1;\n\tfor (;;) {\n\t\tint c = get_next_char();\n\t\tif (cf->eof)\n\t\t\treturn -1;\n\t\tif (c == ']')\n\t\t\treturn 0;\n\t\tif (isspace(c))\n\t\t\treturn get_extended_base_var(name, c);\n\t\tif (!iskeychar(c) && c != '.')\n\t\t\treturn -1;\n\t\tstrbuf_addch(name, tolower(c));\n\t}\n}\n\nstruct parse_event_data {\n\tenum config_event_t previous_type;\n\tsize_t previous_offset;\n\tconst struct config_options *opts;\n};\n\nstatic int do_event(enum config_event_t type, struct parse_event_data *data)\n{\n\tsize_t offset;\n\n\tif (!data->opts || !data->opts->event_fn)\n\t\treturn 0;\n\n\tif (type == CONFIG_EVENT_WHITESPACE &&\n\t    data->previous_type == type)\n\t\treturn 0;\n\n\toffset = cf->do_ftell(cf);\n\t/*\n\t * At EOF, the parser always \"inserts\" an extra '\\n', therefore\n\t * the end offset of the event is the current file position, otherwise\n\t * we will already have advanced to the next event.\n\t */\n\tif (type != CONFIG_EVENT_EOF)\n\t\toffset--;\n\n\tif (data->previous_type != CONFIG_EVENT_EOF &&\n\t    data->opts->event_fn(data->previous_type, data->previous_offset,\n\t\t\t\t offset, data->opts->event_fn_data) < 0)\n\t\treturn -1;\n\n\tdata->previous_type = type;\n\tdata->previous_offset = offset;\n\n\treturn 0;\n}\n\nstatic int git_parse_source(config_fn_t fn, void *data,\n\t\t\t    const struct config_options *opts)\n{\n\tint comment = 0;\n\tsize_t baselen = 0;\n\tstruct strbuf *var = &cf->var;\n\tint error_return = 0;\n\tchar *error_msg = NULL;\n\n\t/* U+FEFF Byte Order Mark in UTF8 */\n\tconst char *bomptr = utf8_bom;\n\n\t/* For the parser event callback */\n\tstruct parse_event_data event_data = {\n\t\tCONFIG_EVENT_EOF, 0, opts\n\t};\n\n\tfor (;;) {\n\t\tint c;\n\n\t\tc = get_next_char();\n\t\tif (bomptr && *bomptr) {\n\t\t\t/* We are at the file beginning; skip UTF8-encoded BOM\n\t\t\t * if present. Sane editors won't put this in on their\n\t\t\t * own, but e.g. Windows Notepad will do it happily. */\n\t\t\tif (c == (*bomptr & 0377)) {\n\t\t\t\tbomptr++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Do not tolerate partial BOM. */\n\t\t\t\tif (bomptr != utf8_bom)\n\t\t\t\t\tbreak;\n\t\t\t\t/* No BOM at file beginning. Cool. */\n\t\t\t\tbomptr = NULL;\n\t\t\t}\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tif (cf->eof) {\n\t\t\t\tif (do_event(CONFIG_EVENT_EOF, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (do_event(CONFIG_EVENT_WHITESPACE, &event_data) < 0)\n\t\t\t\treturn -1;\n\t\t\tcomment = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (comment)\n\t\t\tcontinue;\n\t\tif (isspace(c)) {\n\t\t\tif (do_event(CONFIG_EVENT_WHITESPACE, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '#' || c == ';') {\n\t\t\tif (do_event(CONFIG_EVENT_COMMENT, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\t\t\tcomment = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '[') {\n\t\t\tif (do_event(CONFIG_EVENT_SECTION, &event_data) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t/* Reset prior to determining a new stem */\n\t\t\tstrbuf_reset(var);\n\t\t\tif (get_base_var(var) < 0 || var->len < 1)\n\t\t\t\tbreak;\n\t\t\tstrbuf_addch(var, '.');\n\t\t\tbaselen = var->len;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isalpha(c))\n\t\t\tbreak;\n\n\t\tif (do_event(CONFIG_EVENT_ENTRY, &event_data) < 0)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Truncate the var name back to the section header\n\t\t * stem prior to grabbing the suffix part of the name\n\t\t * and the value.\n\t\t */\n\t\tstrbuf_setlen(var, baselen);\n\t\tstrbuf_addch(var, tolower(c));\n\t\tif (get_value(fn, data, var) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (do_event(CONFIG_EVENT_ERROR, &event_data) < 0)\n\t\treturn -1;\n\n\tswitch (cf->origin_type) {\n\tcase CONFIG_ORIGIN_BLOB:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in blob %s\"),\n\t\t\t\t      cf->linenr, cf->name);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_FILE:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in file %s\"),\n\t\t\t\t      cf->linenr, cf->name);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_STDIN:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in standard input\"),\n\t\t\t\t      cf->linenr);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_SUBMODULE_BLOB:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in submodule-blob %s\"),\n\t\t\t\t       cf->linenr, cf->name);\n\t\tbreak;\n\tcase CONFIG_ORIGIN_CMDLINE:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in command line %s\"),\n\t\t\t\t       cf->linenr, cf->name);\n\t\tbreak;\n\tdefault:\n\t\terror_msg = xstrfmt(_(\"bad config line %d in %s\"),\n\t\t\t\t      cf->linenr, cf->name);\n\t}\n\n\tswitch (opts && opts->error_action ?\n\t\topts->error_action :\n\t\tcf->default_error_action) {\n\tcase CONFIG_ERROR_DIE:\n\t\tdie(\"%s\", error_msg);\n\t\tbreak;\n\tcase CONFIG_ERROR_ERROR:\n\t\terror_return = error(\"%s\", error_msg);\n\t\tbreak;\n\tcase CONFIG_ERROR_SILENT:\n\t\terror_return = -1;\n\t\tbreak;\n\tcase CONFIG_ERROR_UNSET:\n\t\tBUG(\"config error action unset\");\n\t}\n\n\tfree(error_msg);\n\treturn error_return;\n}\n\nstatic uintmax_t get_unit_factor(const char *end)\n{\n\tif (!*end)\n\t\treturn 1;\n\telse if (!strcasecmp(end, \"k\"))\n\t\treturn 1024;\n\telse if (!strcasecmp(end, \"m\"))\n\t\treturn 1024 * 1024;\n\telse if (!strcasecmp(end, \"g\"))\n\t\treturn 1024 * 1024 * 1024;\n\treturn 0;\n}\n\nstatic int git_parse_signed(const char *value, intmax_t *ret, intmax_t max)\n{\n\tif (value && *value) {\n\t\tchar *end;\n\t\tintmax_t val;\n\t\tuintmax_t uval;\n\t\tuintmax_t factor;\n\n\t\terrno = 0;\n\t\tval = strtoimax(value, &end, 0);\n\t\tif (errno == ERANGE)\n\t\t\treturn 0;\n\t\tfactor = get_unit_factor(end);\n\t\tif (!factor) {\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n\t\tuval = val < 0 ? -val : val;\n\t\tif (unsigned_mult_overflows(factor, uval) ||\n\t\t    factor * uval > max) {\n\t\t\terrno = ERANGE;\n\t\t\treturn 0;\n\t\t}\n\t\tval *= factor;\n\t\t*ret = val;\n\t\treturn 1;\n\t}\n\terrno = EINVAL;\n\treturn 0;\n}\n\nstatic int git_parse_unsigned(const char *value, uintmax_t *ret, uintmax_t max)\n{\n\tif (value && *value) {\n\t\tchar *end;\n\t\tuintmax_t val;\n\t\tuintmax_t factor;\n\n\t\terrno = 0;\n\t\tval = strtoumax(value, &end, 0);\n\t\tif (errno == ERANGE)\n\t\t\treturn 0;\n\t\tfactor = get_unit_factor(end);\n\t\tif (!factor) {\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n\t\tif (unsigned_mult_overflows(factor, val) ||\n\t\t    factor * val > max) {\n\t\t\terrno = ERANGE;\n\t\t\treturn 0;\n\t\t}\n\t\tval *= factor;\n\t\t*ret = val;\n\t\treturn 1;\n\t}\n\terrno = EINVAL;\n\treturn 0;\n}\n\nstatic int git_parse_int(const char *value, int *ret)\n{\n\tintmax_t tmp;\n\tif (!git_parse_signed(value, &tmp, maximum_signed_value_of_type(int)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nstatic int git_parse_int64(const char *value, int64_t *ret)\n{\n\tintmax_t tmp;\n\tif (!git_parse_signed(value, &tmp, maximum_signed_value_of_type(int64_t)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nint git_parse_ulong(const char *value, unsigned long *ret)\n{\n\tuintmax_t tmp;\n\tif (!git_parse_unsigned(value, &tmp, maximum_unsigned_value_of_type(long)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nint git_parse_ssize_t(const char *value, ssize_t *ret)\n{\n\tintmax_t tmp;\n\tif (!git_parse_signed(value, &tmp, maximum_signed_value_of_type(ssize_t)))\n\t\treturn 0;\n\t*ret = tmp;\n\treturn 1;\n}\n\nNORETURN\nstatic void die_bad_number(const char *name, const char *value)\n{\n\tconst char *error_type = (errno == ERANGE) ?\n\t\tN_(\"out of range\") : N_(\"invalid unit\");\n\tconst char *bad_numeric = N_(\"bad numeric config value '%s' for '%s': %s\");\n\n\tif (!value)\n\t\tvalue = \"\";\n\n\tif (!strcmp(name, \"GIT_TEST_GETTEXT_POISON\"))\n\t\t/*\n\t\t * We explicitly *don't* use _() here since it would\n\t\t * cause an infinite loop with _() needing to call\n\t\t * use_gettext_poison(). This is why marked up\n\t\t * translations with N_() above.\n\t\t */\n\t\tdie(bad_numeric, value, name, error_type);\n\n\tif (!(cf && cf->name))\n\t\tdie(_(bad_numeric), value, name, _(error_type));\n\n\tswitch (cf->origin_type) {\n\tcase CONFIG_ORIGIN_BLOB:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in blob %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tcase CONFIG_ORIGIN_FILE:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in file %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tcase CONFIG_ORIGIN_STDIN:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in standard input: %s\"),\n\t\t    value, name, _(error_type));\n\tcase CONFIG_ORIGIN_SUBMODULE_BLOB:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in submodule-blob %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tcase CONFIG_ORIGIN_CMDLINE:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in command line %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\tdefault:\n\t\tdie(_(\"bad numeric config value '%s' for '%s' in %s: %s\"),\n\t\t    value, name, cf->name, _(error_type));\n\t}\n}\n\nint git_config_int(const char *name, const char *value)\n{\n\tint ret;\n\tif (!git_parse_int(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nint64_t git_config_int64(const char *name, const char *value)\n{\n\tint64_t ret;\n\tif (!git_parse_int64(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nunsigned long git_config_ulong(const char *name, const char *value)\n{\n\tunsigned long ret;\n\tif (!git_parse_ulong(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nssize_t git_config_ssize_t(const char *name, const char *value)\n{\n\tssize_t ret;\n\tif (!git_parse_ssize_t(value, &ret))\n\t\tdie_bad_number(name, value);\n\treturn ret;\n}\n\nstatic int git_parse_maybe_bool_text(const char *value)\n{\n\tif (!value)\n\t\treturn 1;\n\tif (!*value)\n\t\treturn 0;\n\tif (!strcasecmp(value, \"true\")\n\t    || !strcasecmp(value, \"yes\")\n\t    || !strcasecmp(value, \"on\"))\n\t\treturn 1;\n\tif (!strcasecmp(value, \"false\")\n\t    || !strcasecmp(value, \"no\")\n\t    || !strcasecmp(value, \"off\"))\n\t\treturn 0;\n\treturn -1;\n}\n\nint git_parse_maybe_bool(const char *value)\n{\n\tint v = git_parse_maybe_bool_text(value);\n\tif (0 <= v)\n\t\treturn v;\n\tif (git_parse_int(value, &v))\n\t\treturn !!v;\n\treturn -1;\n}\n\nint git_config_bool_or_int(const char *name, const char *value, int *is_bool)\n{\n\tint v = git_parse_maybe_bool_text(value);\n\tif (0 <= v) {\n\t\t*is_bool = 1;\n\t\treturn v;\n\t}\n\t*is_bool = 0;\n\treturn git_config_int(name, value);\n}\n\nint git_config_bool(const char *name, const char *value)\n{\n\tint discard;\n\treturn !!git_config_bool_or_int(name, value, &discard);\n}\n\nint git_config_string(const char **dest, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\t*dest = xstrdup(value);\n\treturn 0;\n}\n\nint git_config_pathname(const char **dest, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\t*dest = expand_user_path(value, 0);\n\tif (!*dest)\n\t\tdie(_(\"failed to expand user dir in: '%s'\"), value);\n\treturn 0;\n}\n\nint git_config_expiry_date(timestamp_t *timestamp, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\tif (parse_expiry_date(value, timestamp))\n\t\treturn error(_(\"'%s' for '%s' is not a valid timestamp\"),\n\t\t\t     value, var);\n\treturn 0;\n}\n\nint git_config_color(char *dest, const char *var, const char *value)\n{\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\tif (color_parse(value, dest) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int git_default_core_config(const char *var, const char *value, void *cb)\n{\n\t/* This needs a better name */\n\tif (!strcmp(var, \"core.filemode\")) {\n\t\ttrust_executable_bit = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"core.trustctime\")) {\n\t\ttrust_ctime = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"core.checkstat\")) {\n\t\tif (!strcasecmp(value, \"default\"))\n\t\t\tcheck_stat = 1;\n\t\telse if (!strcasecmp(value, \"minimal\"))\n\t\t\tcheck_stat = 0;\n\t}\n\n\tif (!strcmp(var, \"core.quotepath\")) {\n\t\tquote_path_fully = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.symlinks\")) {\n\t\thas_symlinks = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.ignorecase\")) {\n\t\tignore_case = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.attributesfile\"))\n\t\treturn git_config_pathname(&git_attributes_file, var, value);\n\n\tif (!strcmp(var, \"core.hookspath\"))\n\t\treturn git_config_pathname(&git_hooks_path, var, value);\n\n\tif (!strcmp(var, \"core.bare\")) {\n\t\tis_bare_repository_cfg = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.ignorestat\")) {\n\t\tassume_unchanged = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.prefersymlinkrefs\")) {\n\t\tprefer_symlink_refs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.logallrefupdates\")) {\n\t\tif (value && !strcasecmp(value, \"always\"))\n\t\t\tlog_all_ref_updates = LOG_REFS_ALWAYS;\n\t\telse if (git_config_bool(var, value))\n\t\t\tlog_all_ref_updates = LOG_REFS_NORMAL;\n\t\telse\n\t\t\tlog_all_ref_updates = LOG_REFS_NONE;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.warnambiguousrefs\")) {\n\t\twarn_ambiguous_refs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.abbrev\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tif (!strcasecmp(value, \"auto\"))\n\t\t\tdefault_abbrev = -1;\n\t\telse {\n\t\t\tint abbrev = git_config_int(var, value);\n\t\t\tif (abbrev < minimum_abbrev || abbrev > the_hash_algo->hexsz)\n\t\t\t\treturn error(_(\"abbrev length out of range: %d\"), abbrev);\n\t\t\tdefault_abbrev = abbrev;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.disambiguate\"))\n\t\treturn set_disambiguate_hint_config(var, value);\n\n\tif (!strcmp(var, \"core.loosecompression\")) {\n\t\tint level = git_config_int(var, value);\n\t\tif (level == -1)\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\telse if (level < 0 || level > Z_BEST_COMPRESSION)\n\t\t\tdie(_(\"bad zlib compression level %d\"), level);\n\t\tzlib_compression_level = level;\n\t\tzlib_compression_seen = 1;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.compression\")) {\n\t\tint level = git_config_int(var, value);\n\t\tif (level == -1)\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\telse if (level < 0 || level > Z_BEST_COMPRESSION)\n\t\t\tdie(_(\"bad zlib compression level %d\"), level);\n\t\tcore_compression_level = level;\n\t\tcore_compression_seen = 1;\n\t\tif (!zlib_compression_seen)\n\t\t\tzlib_compression_level = level;\n\t\tif (!pack_compression_seen)\n\t\t\tpack_compression_level = level;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.packedgitwindowsize\")) {\n\t\tint pgsz_x2 = getpagesize() * 2;\n\t\tpacked_git_window_size = git_config_ulong(var, value);\n\n\t\t/* This value must be multiple of (pagesize * 2) */\n\t\tpacked_git_window_size /= pgsz_x2;\n\t\tif (packed_git_window_size < 1)\n\t\t\tpacked_git_window_size = 1;\n\t\tpacked_git_window_size *= pgsz_x2;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.bigfilethreshold\")) {\n\t\tbig_file_threshold = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.packedgitlimit\")) {\n\t\tpacked_git_limit = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.deltabasecachelimit\")) {\n\t\tdelta_base_cache_limit = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.autocrlf\")) {\n\t\tif (value && !strcasecmp(value, \"input\")) {\n\t\t\tauto_crlf = AUTO_CRLF_INPUT;\n\t\t\treturn 0;\n\t\t}\n\t\tauto_crlf = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.safecrlf\")) {\n\t\tint eol_rndtrp_die;\n\t\tif (value && !strcasecmp(value, \"warn\")) {\n\t\t\tglobal_conv_flags_eol = CONV_EOL_RNDTRP_WARN;\n\t\t\treturn 0;\n\t\t}\n\t\teol_rndtrp_die = git_config_bool(var, value);\n\t\tglobal_conv_flags_eol = eol_rndtrp_die ?\n\t\t\tCONV_EOL_RNDTRP_DIE : 0;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.eol\")) {\n\t\tif (value && !strcasecmp(value, \"lf\"))\n\t\t\tcore_eol = EOL_LF;\n\t\telse if (value && !strcasecmp(value, \"crlf\"))\n\t\t\tcore_eol = EOL_CRLF;\n\t\telse if (value && !strcasecmp(value, \"native\"))\n\t\t\tcore_eol = EOL_NATIVE;\n\t\telse\n\t\t\tcore_eol = EOL_UNSET;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.checkroundtripencoding\")) {\n\t\tcheck_roundtrip_encoding = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.notesref\")) {\n\t\tnotes_ref_name = xstrdup(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.editor\"))\n\t\treturn git_config_string(&editor_program, var, value);\n\n\tif (!strcmp(var, \"core.commentchar\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\telse if (!strcasecmp(value, \"auto\"))\n\t\t\tauto_comment_line_char = 1;\n\t\telse if (value[0] && !value[1]) {\n\t\t\tcomment_line_char = value[0];\n\t\t\tauto_comment_line_char = 0;\n\t\t} else\n\t\t\treturn error(_(\"core.commentChar should only be one character\"));\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.askpass\"))\n\t\treturn git_config_string(&askpass_program, var, value);\n\n\tif (!strcmp(var, \"core.excludesfile\"))\n\t\treturn git_config_pathname(&excludes_file, var, value);\n\n\tif (!strcmp(var, \"core.whitespace\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\twhitespace_rule_cfg = parse_whitespace_rule(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.fsyncobjectfiles\")) {\n\t\tfsync_object_files = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.preloadindex\")) {\n\t\tcore_preload_index = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.createobject\")) {\n\t\tif (!strcmp(value, \"rename\"))\n\t\t\tobject_creation_mode = OBJECT_CREATION_USES_RENAMES;\n\t\telse if (!strcmp(value, \"link\"))\n\t\t\tobject_creation_mode = OBJECT_CREATION_USES_HARDLINKS;\n\t\telse\n\t\t\tdie(_(\"invalid mode for object creation: %s\"), value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.sparsecheckout\")) {\n\t\tcore_apply_sparse_checkout = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.sparsecheckoutcone\")) {\n\t\tcore_sparse_checkout_cone = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.precomposeunicode\")) {\n\t\tprecomposed_unicode = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.protecthfs\")) {\n\t\tprotect_hfs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.protectntfs\")) {\n\t\tprotect_ntfs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"core.usereplacerefs\")) {\n\t\tread_replace_refs = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn platform_core_config(var, value, cb);\n}\n\nstatic int git_default_i18n_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"i18n.commitencoding\"))\n\t\treturn git_config_string(&git_commit_encoding, var, value);\n\n\tif (!strcmp(var, \"i18n.logoutputencoding\"))\n\t\treturn git_config_string(&git_log_output_encoding, var, value);\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nstatic int git_default_branch_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"branch.autosetupmerge\")) {\n\t\tif (value && !strcasecmp(value, \"always\")) {\n\t\t\tgit_branch_track = BRANCH_TRACK_ALWAYS;\n\t\t\treturn 0;\n\t\t}\n\t\tgit_branch_track = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"branch.autosetuprebase\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\telse if (!strcmp(value, \"never\"))\n\t\t\tautorebase = AUTOREBASE_NEVER;\n\t\telse if (!strcmp(value, \"local\"))\n\t\t\tautorebase = AUTOREBASE_LOCAL;\n\t\telse if (!strcmp(value, \"remote\"))\n\t\t\tautorebase = AUTOREBASE_REMOTE;\n\t\telse if (!strcmp(value, \"always\"))\n\t\t\tautorebase = AUTOREBASE_ALWAYS;\n\t\telse\n\t\t\treturn error(_(\"malformed value for %s\"), var);\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nstatic int git_default_push_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"push.default\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\telse if (!strcmp(value, \"nothing\"))\n\t\t\tpush_default = PUSH_DEFAULT_NOTHING;\n\t\telse if (!strcmp(value, \"matching\"))\n\t\t\tpush_default = PUSH_DEFAULT_MATCHING;\n\t\telse if (!strcmp(value, \"simple\"))\n\t\t\tpush_default = PUSH_DEFAULT_SIMPLE;\n\t\telse if (!strcmp(value, \"upstream\"))\n\t\t\tpush_default = PUSH_DEFAULT_UPSTREAM;\n\t\telse if (!strcmp(value, \"tracking\")) /* deprecated */\n\t\t\tpush_default = PUSH_DEFAULT_UPSTREAM;\n\t\telse if (!strcmp(value, \"current\"))\n\t\t\tpush_default = PUSH_DEFAULT_CURRENT;\n\t\telse {\n\t\t\terror(_(\"malformed value for %s: %s\"), var, value);\n\t\t\treturn error(_(\"must be one of nothing, matching, simple, \"\n\t\t\t\t       \"upstream or current\"));\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nstatic int git_default_mailmap_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"mailmap.file\"))\n\t\treturn git_config_pathname(&git_mailmap_file, var, value);\n\tif (!strcmp(var, \"mailmap.blob\"))\n\t\treturn git_config_string(&git_mailmap_blob, var, value);\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\nint git_default_config(const char *var, const char *value, void *cb)\n{\n\tif (starts_with(var, \"core.\"))\n\t\treturn git_default_core_config(var, value, cb);\n\n\tif (starts_with(var, \"user.\") ||\n\t    starts_with(var, \"author.\") ||\n\t    starts_with(var, \"committer.\"))\n\t\treturn git_ident_config(var, value, cb);\n\n\tif (starts_with(var, \"i18n.\"))\n\t\treturn git_default_i18n_config(var, value);\n\n\tif (starts_with(var, \"branch.\"))\n\t\treturn git_default_branch_config(var, value);\n\n\tif (starts_with(var, \"push.\"))\n\t\treturn git_default_push_config(var, value);\n\n\tif (starts_with(var, \"mailmap.\"))\n\t\treturn git_default_mailmap_config(var, value);\n\n\tif (starts_with(var, \"advice.\") || starts_with(var, \"color.advice\"))\n\t\treturn git_default_advice_config(var, value);\n\n\tif (!strcmp(var, \"pager.color\") || !strcmp(var, \"color.pager\")) {\n\t\tpager_use_color = git_config_bool(var,value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"pack.packsizelimit\")) {\n\t\tpack_size_limit_cfg = git_config_ulong(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"pack.compression\")) {\n\t\tint level = git_config_int(var, value);\n\t\tif (level == -1)\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\telse if (level < 0 || level > Z_BEST_COMPRESSION)\n\t\t\tdie(_(\"bad pack compression level %d\"), level);\n\t\tpack_compression_level = level;\n\t\tpack_compression_seen = 1;\n\t\treturn 0;\n\t}\n\n\t/* Add other config variables here and to Documentation/config.txt. */\n\treturn 0;\n}\n\n/*\n * All source specific fields in the union, die_on_error, name and the callbacks\n * fgetc, ungetc, ftell of top need to be initialized before calling\n * this function.\n */\nstatic int do_config_from(struct config_source *top, config_fn_t fn, void *data,\n\t\t\t  const struct config_options *opts)\n{\n\tint ret;\n\n\t/* push config-file parsing state stack */\n\ttop->prev = cf;\n\ttop->linenr = 1;\n\ttop->eof = 0;\n\ttop->total_len = 0;\n\tstrbuf_init(&top->value, 1024);\n\tstrbuf_init(&top->var, 1024);\n\tcf = top;\n\n\tret = git_parse_source(fn, data, opts);\n\n\t/* pop config-file parsing state stack */\n\tstrbuf_release(&top->value);\n\tstrbuf_release(&top->var);\n\tcf = top->prev;\n\n\treturn ret;\n}\n\nstatic int do_config_from_file(config_fn_t fn,\n\t\tconst enum config_origin_type origin_type,\n\t\tconst char *name, const char *path, FILE *f,\n\t\tvoid *data, const struct config_options *opts)\n{\n\tstruct config_source top;\n\tint ret;\n\n\ttop.u.file = f;\n\ttop.origin_type = origin_type;\n\ttop.name = name;\n\ttop.path = path;\n\ttop.default_error_action = CONFIG_ERROR_DIE;\n\ttop.do_fgetc = config_file_fgetc;\n\ttop.do_ungetc = config_file_ungetc;\n\ttop.do_ftell = config_file_ftell;\n\n\tflockfile(f);\n\tret = do_config_from(&top, fn, data, opts);\n\tfunlockfile(f);\n\treturn ret;\n}\n\nstatic int git_config_from_stdin(config_fn_t fn, void *data)\n{\n\treturn do_config_from_file(fn, CONFIG_ORIGIN_STDIN, \"\", NULL, stdin,\n\t\t\t\t   data, NULL);\n}\n\nint git_config_from_file_with_options(config_fn_t fn, const char *filename,\n\t\t\t\t      void *data,\n\t\t\t\t      const struct config_options *opts)\n{\n\tint ret = -1;\n\tFILE *f;\n\n\tf = fopen_or_warn(filename, \"r\");\n\tif (f) {\n\t\tret = do_config_from_file(fn, CONFIG_ORIGIN_FILE, filename,\n\t\t\t\t\t  filename, f, data, opts);\n\t\tfclose(f);\n\t}\n\treturn ret;\n}\n\nint git_config_from_file(config_fn_t fn, const char *filename, void *data)\n{\n\treturn git_config_from_file_with_options(fn, filename, data, NULL);\n}\n\nint git_config_from_mem(config_fn_t fn,\n\t\t\tconst enum config_origin_type origin_type,\n\t\t\tconst char *name, const char *buf, size_t len,\n\t\t\tvoid *data, const struct config_options *opts)\n{\n\tstruct config_source top;\n\n\ttop.u.buf.buf = buf;\n\ttop.u.buf.len = len;\n\ttop.u.buf.pos = 0;\n\ttop.origin_type = origin_type;\n\ttop.name = name;\n\ttop.path = NULL;\n\ttop.default_error_action = CONFIG_ERROR_ERROR;\n\ttop.do_fgetc = config_buf_fgetc;\n\ttop.do_ungetc = config_buf_ungetc;\n\ttop.do_ftell = config_buf_ftell;\n\n\treturn do_config_from(&top, fn, data, opts);\n}\n\nint git_config_from_blob_oid(config_fn_t fn,\n\t\t\t      const char *name,\n\t\t\t      const struct object_id *oid,\n\t\t\t      void *data)\n{\n\tenum object_type type;\n\tchar *buf;\n\tunsigned long size;\n\tint ret;\n\n\tbuf = read_object_file(oid, &type, &size);\n\tif (!buf)\n\t\treturn error(_(\"unable to load config blob object '%s'\"), name);\n\tif (type != OBJ_BLOB) {\n\t\tfree(buf);\n\t\treturn error(_(\"reference '%s' does not point to a blob\"), name);\n\t}\n\n\tret = git_config_from_mem(fn, CONFIG_ORIGIN_BLOB, name, buf, size,\n\t\t\t\t  data, NULL);\n\tfree(buf);\n\n\treturn ret;\n}\n\nstatic int git_config_from_blob_ref(config_fn_t fn,\n\t\t\t\t    const char *name,\n\t\t\t\t    void *data)\n{\n\tstruct object_id oid;\n\n\tif (get_oid(name, &oid) < 0)\n\t\treturn error(_(\"unable to resolve config blob '%s'\"), name);\n\treturn git_config_from_blob_oid(fn, name, &oid, data);\n}\n\nconst char *git_etc_gitconfig(void)\n{\n\tstatic const char *system_wide;\n\tif (!system_wide)\n\t\tsystem_wide = system_path(ETC_GITCONFIG);\n\treturn system_wide;\n}\n\n/*\n * Parse environment variable 'k' as a boolean (in various\n * possible spellings); if missing, use the default value 'def'.\n */\nint git_env_bool(const char *k, int def)\n{\n\tconst char *v = getenv(k);\n\treturn v ? git_config_bool(k, v) : def;\n}\n\n/*\n * Parse environment variable 'k' as ulong with possibly a unit\n * suffix; if missing, use the default value 'val'.\n */\nunsigned long git_env_ulong(const char *k, unsigned long val)\n{\n\tconst char *v = getenv(k);\n\tif (v && !git_parse_ulong(v, &val))\n\t\tdie(_(\"failed to parse %s\"), k);\n\treturn val;\n}\n\nint git_config_system(void)\n{\n\treturn !git_env_bool(\"GIT_CONFIG_NOSYSTEM\", 0);\n}\n\nstatic int do_git_config_sequence(const struct config_options *opts,\n\t\t\t\t  config_fn_t fn, void *data)\n{\n\tint ret = 0;\n\tchar *xdg_config = xdg_config_home(\"config\");\n\tchar *user_config = expand_user_path(\"~/.gitconfig\", 0);\n\tchar *repo_config;\n\tenum config_scope prev_parsing_scope = current_parsing_scope;\n\n\tif (opts->commondir)\n\t\trepo_config = mkpathdup(\"%s/config\", opts->commondir);\n\telse if (opts->git_dir)\n\t\tBUG(\"git_dir without commondir\");\n\telse\n\t\trepo_config = NULL;\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_SYSTEM;\n\tif (git_config_system() && !access_or_die(git_etc_gitconfig(), R_OK,\n\t\t\t\t\t\t  opts->system_gently ?\n\t\t\t\t\t\t  ACCESS_EACCES_OK : 0))\n\t\tret += git_config_from_file(fn, git_etc_gitconfig(),\n\t\t\t\t\t    data);\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_GLOBAL;\n\tif (xdg_config && !access_or_die(xdg_config, R_OK, ACCESS_EACCES_OK))\n\t\tret += git_config_from_file(fn, xdg_config, data);\n\n\tif (user_config && !access_or_die(user_config, R_OK, ACCESS_EACCES_OK))\n\t\tret += git_config_from_file(fn, user_config, data);\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_LOCAL;\n\tif (!opts->ignore_repo && repo_config &&\n\t    !access_or_die(repo_config, R_OK, 0))\n\t\tret += git_config_from_file(fn, repo_config, data);\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_WORKTREE;\n\tif (!opts->ignore_worktree && repository_format_worktree_config) {\n\t\tchar *path = git_pathdup(\"config.worktree\");\n\t\tif (!access_or_die(path, R_OK, 0))\n\t\t\tret += git_config_from_file(fn, path, data);\n\t\tfree(path);\n\t}\n\n\tcurrent_parsing_scope = CONFIG_SCOPE_COMMAND;\n\tif (!opts->ignore_cmdline && git_config_from_parameters(fn, data) < 0)\n\t\tdie(_(\"unable to parse command-line config\"));\n\n\tcurrent_parsing_scope = prev_parsing_scope;\n\tfree(xdg_config);\n\tfree(user_config);\n\tfree(repo_config);\n\treturn ret;\n}\n\nint config_with_options(config_fn_t fn, void *data,\n\t\t\tstruct git_config_source *config_source,\n\t\t\tconst struct config_options *opts)\n{\n\tstruct config_include_data inc = CONFIG_INCLUDE_INIT;\n\n\tif (opts->respect_includes) {\n\t\tinc.fn = fn;\n\t\tinc.data = data;\n\t\tinc.opts = opts;\n\t\tfn = git_config_include;\n\t\tdata = &inc;\n\t}\n\n\tif (config_source)\n\t\tcurrent_parsing_scope = config_source->scope;\n\n\t/*\n\t * If we have a specific filename, use it. Otherwise, follow the\n\t * regular lookup sequence.\n\t */\n\tif (config_source && config_source->use_stdin)\n\t\treturn git_config_from_stdin(fn, data);\n\telse if (config_source && config_source->file)\n\t\treturn git_config_from_file(fn, config_source->file, data);\n\telse if (config_source && config_source->blob)\n\t\treturn git_config_from_blob_ref(fn, config_source->blob, data);\n\n\treturn do_git_config_sequence(opts, fn, data);\n}\n\nstatic void configset_iter(struct config_set *cs, config_fn_t fn, void *data)\n{\n\tint i, value_index;\n\tstruct string_list *values;\n\tstruct config_set_element *entry;\n\tstruct configset_list *list = &cs->list;\n\n\tfor (i = 0; i < list->nr; i++) {\n\t\tentry = list->items[i].e;\n\t\tvalue_index = list->items[i].value_index;\n\t\tvalues = &entry->value_list;\n\n\t\tcurrent_config_kvi = values->items[value_index].util;\n\n\t\tif (fn(entry->key, values->items[value_index].string, data) < 0)\n\t\t\tgit_die_config_linenr(entry->key,\n\t\t\t\t\t      current_config_kvi->filename,\n\t\t\t\t\t      current_config_kvi->linenr);\n\n\t\tcurrent_config_kvi = NULL;\n\t}\n}\n\nvoid read_early_config(config_fn_t cb, void *data)\n{\n\tstruct config_options opts = {0};\n\tstruct strbuf commondir = STRBUF_INIT;\n\tstruct strbuf gitdir = STRBUF_INIT;\n\n\topts.respect_includes = 1;\n\n\tif (have_git_dir()) {\n\t\topts.commondir = get_git_common_dir();\n\t\topts.git_dir = get_git_dir();\n\t/*\n\t * When setup_git_directory() was not yet asked to discover the\n\t * GIT_DIR, we ask discover_git_directory() to figure out whether there\n\t * is any repository config we should use (but unlike\n\t * setup_git_directory_gently(), no global state is changed, most\n\t * notably, the current working directory is still the same after the\n\t * call).\n\t */\n\t} else if (!discover_git_directory(&commondir, &gitdir)) {\n\t\topts.commondir = commondir.buf;\n\t\topts.git_dir = gitdir.buf;\n\t}\n\n\tconfig_with_options(cb, data, NULL, &opts);\n\n\tstrbuf_release(&commondir);\n\tstrbuf_release(&gitdir);\n}\n\n/*\n * Read config but only enumerate system and global settings.\n * Omit any repo-local, worktree-local, or command-line settings.\n */\nvoid read_very_early_config(config_fn_t cb, void *data)\n{\n\tstruct config_options opts = { 0 };\n\n\topts.respect_includes = 1;\n\topts.ignore_repo = 1;\n\topts.ignore_worktree = 1;\n\topts.ignore_cmdline = 1;\n\topts.system_gently = 1;\n\n\tconfig_with_options(cb, data, NULL, &opts);\n}\n\nstatic struct config_set_element *configset_find_element(struct config_set *cs, const char *key)\n{\n\tstruct config_set_element k;\n\tstruct config_set_element *found_entry;\n\tchar *normalized_key;\n\t/*\n\t * `key` may come from the user, so normalize it before using it\n\t * for querying entries from the hashmap.\n\t */\n\tif (git_config_parse_key(key, &normalized_key, NULL))\n\t\treturn NULL;\n\n\thashmap_entry_init(&k.ent, strhash(normalized_key));\n\tk.key = normalized_key;\n\tfound_entry = hashmap_get_entry(&cs->config_hash, &k, ent, NULL);\n\tfree(normalized_key);\n\treturn found_entry;\n}\n\nstatic int configset_add_value(struct config_set *cs, const char *key, const char *value)\n{\n\tstruct config_set_element *e;\n\tstruct string_list_item *si;\n\tstruct configset_list_item *l_item;\n\tstruct key_value_info *kv_info = xmalloc(sizeof(*kv_info));\n\n\te = configset_find_element(cs, key);\n\t/*\n\t * Since the keys are being fed by git_config*() callback mechanism, they\n\t * are already normalized. So simply add them without any further munging.\n\t */\n\tif (!e) {\n\t\te = xmalloc(sizeof(*e));\n\t\thashmap_entry_init(&e->ent, strhash(key));\n\t\te->key = xstrdup(key);\n\t\tstring_list_init(&e->value_list, 1);\n\t\thashmap_add(&cs->config_hash, &e->ent);\n\t}\n\tsi = string_list_append_nodup(&e->value_list, xstrdup_or_null(value));\n\n\tALLOC_GROW(cs->list.items, cs->list.nr + 1, cs->list.alloc);\n\tl_item = &cs->list.items[cs->list.nr++];\n\tl_item->e = e;\n\tl_item->value_index = e->value_list.nr - 1;\n\n\tif (!cf)\n\t\tBUG(\"configset_add_value has no source\");\n\tif (cf->name) {\n\t\tkv_info->filename = strintern(cf->name);\n\t\tkv_info->linenr = cf->linenr;\n\t\tkv_info->origin_type = cf->origin_type;\n\t} else {\n\t\t/* for values read from `git_config_from_parameters()` */\n\t\tkv_info->filename = NULL;\n\t\tkv_info->linenr = -1;\n\t\tkv_info->origin_type = CONFIG_ORIGIN_CMDLINE;\n\t}\n\tkv_info->scope = current_parsing_scope;\n\tsi->util = kv_info;\n\n\treturn 0;\n}\n\nstatic int config_set_element_cmp(const void *unused_cmp_data,\n\t\t\t\t  const struct hashmap_entry *eptr,\n\t\t\t\t  const struct hashmap_entry *entry_or_key,\n\t\t\t\t  const void *unused_keydata)\n{\n\tconst struct config_set_element *e1, *e2;\n\n\te1 = container_of(eptr, const struct config_set_element, ent);\n\te2 = container_of(entry_or_key, const struct config_set_element, ent);\n\n\treturn strcmp(e1->key, e2->key);\n}\n\nvoid git_configset_init(struct config_set *cs)\n{\n\thashmap_init(&cs->config_hash, config_set_element_cmp, NULL, 0);\n\tcs->hash_initialized = 1;\n\tcs->list.nr = 0;\n\tcs->list.alloc = 0;\n\tcs->list.items = NULL;\n}\n\nvoid git_configset_clear(struct config_set *cs)\n{\n\tstruct config_set_element *entry;\n\tstruct hashmap_iter iter;\n\tif (!cs->hash_initialized)\n\t\treturn;\n\n\thashmap_for_each_entry(&cs->config_hash, &iter, entry,\n\t\t\t\tent /* member name */) {\n\t\tfree(entry->key);\n\t\tstring_list_clear(&entry->value_list, 1);\n\t}\n\thashmap_clear_and_free(&cs->config_hash, struct config_set_element, ent);\n\tcs->hash_initialized = 0;\n\tfree(cs->list.items);\n\tcs->list.nr = 0;\n\tcs->list.alloc = 0;\n\tcs->list.items = NULL;\n}\n\nstatic int config_set_callback(const char *key, const char *value, void *cb)\n{\n\tstruct config_set *cs = cb;\n\tconfigset_add_value(cs, key, value);\n\treturn 0;\n}\n\nint git_configset_add_file(struct config_set *cs, const char *filename)\n{\n\treturn git_config_from_file(config_set_callback, filename, cs);\n}\n\nint git_configset_get_value(struct config_set *cs, const char *key, const char **value)\n{\n\tconst struct string_list *values = NULL;\n\t/*\n\t * Follows \"last one wins\" semantic, i.e., if there are multiple matches for the\n\t * queried key in the files of the configset, the value returned will be the last\n\t * value in the value list for that key.\n\t */\n\tvalues = git_configset_get_value_multi(cs, key);\n\n\tif (!values)\n\t\treturn 1;\n\tassert(values->nr > 0);\n\t*value = values->items[values->nr - 1].string;\n\treturn 0;\n}\n\nconst struct string_list *git_configset_get_value_multi(struct config_set *cs, const char *key)\n{\n\tstruct config_set_element *e = configset_find_element(cs, key);\n\treturn e ? &e->value_list : NULL;\n}\n\nint git_configset_get_string(struct config_set *cs, const char *key, char **dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value))\n\t\treturn git_config_string((const char **)dest, key, value);\n\telse\n\t\treturn 1;\n}\n\nint git_configset_get_string_tmp(struct config_set *cs, const char *key,\n\t\t\t\t const char **dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(key);\n\t\t*dest = value;\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\nint git_configset_get_int(struct config_set *cs, const char *key, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_int(key, value);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_ulong(struct config_set *cs, const char *key, unsigned long *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_ulong(key, value);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_bool(struct config_set *cs, const char *key, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_bool(key, value);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_bool_or_int(struct config_set *cs, const char *key,\n\t\t\t\tint *is_bool, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_config_bool_or_int(key, value, is_bool);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_maybe_bool(struct config_set *cs, const char *key, int *dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value)) {\n\t\t*dest = git_parse_maybe_bool(value);\n\t\tif (*dest == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nint git_configset_get_pathname(struct config_set *cs, const char *key, const char **dest)\n{\n\tconst char *value;\n\tif (!git_configset_get_value(cs, key, &value))\n\t\treturn git_config_pathname(dest, key, value);\n\telse\n\t\treturn 1;\n}\n\n/* Functions use to read configuration from a repository */\nstatic void repo_read_config(struct repository *repo)\n{\n\tstruct config_options opts = { 0 };\n\n\topts.respect_includes = 1;\n\topts.commondir = repo->commondir;\n\topts.git_dir = repo->gitdir;\n\n\tif (!repo->config)\n\t\trepo->config = xcalloc(1, sizeof(struct config_set));\n\telse\n\t\tgit_configset_clear(repo->config);\n\n\tgit_configset_init(repo->config);\n\n\tif (config_with_options(config_set_callback, repo->config, NULL, &opts) < 0)\n\t\t/*\n\t\t * config_with_options() normally returns only\n\t\t * zero, as most errors are fatal, and\n\t\t * non-fatal potential errors are guarded by \"if\"\n\t\t * statements that are entered only when no error is\n\t\t * possible.\n\t\t *\n\t\t * If we ever encounter a non-fatal error, it means\n\t\t * something went really wrong and we should stop\n\t\t * immediately.\n\t\t */\n\t\tdie(_(\"unknown error occurred while reading the configuration files\"));\n}\n\nstatic void git_config_check_init(struct repository *repo)\n{\n\tif (repo->config && repo->config->hash_initialized)\n\t\treturn;\n\trepo_read_config(repo);\n}\n\nstatic void repo_config_clear(struct repository *repo)\n{\n\tif (!repo->config || !repo->config->hash_initialized)\n\t\treturn;\n\tgit_configset_clear(repo->config);\n}\n\nvoid repo_config(struct repository *repo, config_fn_t fn, void *data)\n{\n\tgit_config_check_init(repo);\n\tconfigset_iter(repo->config, fn, data);\n}\n\nint repo_config_get_value(struct repository *repo,\n\t\t\t  const char *key, const char **value)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_value(repo->config, key, value);\n}\n\nconst struct string_list *repo_config_get_value_multi(struct repository *repo,\n\t\t\t\t\t\t      const char *key)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_value_multi(repo->config, key);\n}\n\nint repo_config_get_string(struct repository *repo,\n\t\t\t   const char *key, char **dest)\n{\n\tint ret;\n\tgit_config_check_init(repo);\n\tret = git_configset_get_string(repo->config, key, dest);\n\tif (ret < 0)\n\t\tgit_die_config(key, NULL);\n\treturn ret;\n}\n\nint repo_config_get_string_tmp(struct repository *repo,\n\t\t\t       const char *key, const char **dest)\n{\n\tint ret;\n\tgit_config_check_init(repo);\n\tret = git_configset_get_string_tmp(repo->config, key, dest);\n\tif (ret < 0)\n\t\tgit_die_config(key, NULL);\n\treturn ret;\n}\n\nint repo_config_get_int(struct repository *repo,\n\t\t\tconst char *key, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_int(repo->config, key, dest);\n}\n\nint repo_config_get_ulong(struct repository *repo,\n\t\t\t  const char *key, unsigned long *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_ulong(repo->config, key, dest);\n}\n\nint repo_config_get_bool(struct repository *repo,\n\t\t\t const char *key, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_bool(repo->config, key, dest);\n}\n\nint repo_config_get_bool_or_int(struct repository *repo,\n\t\t\t\tconst char *key, int *is_bool, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_bool_or_int(repo->config, key, is_bool, dest);\n}\n\nint repo_config_get_maybe_bool(struct repository *repo,\n\t\t\t       const char *key, int *dest)\n{\n\tgit_config_check_init(repo);\n\treturn git_configset_get_maybe_bool(repo->config, key, dest);\n}\n\nint repo_config_get_pathname(struct repository *repo,\n\t\t\t     const char *key, const char **dest)\n{\n\tint ret;\n\tgit_config_check_init(repo);\n\tret = git_configset_get_pathname(repo->config, key, dest);\n\tif (ret < 0)\n\t\tgit_die_config(key, NULL);\n\treturn ret;\n}\n\n/* Functions used historically to read configuration from 'the_repository' */\nvoid git_config(config_fn_t fn, void *data)\n{\n\trepo_config(the_repository, fn, data);\n}\n\nvoid git_config_clear(void)\n{\n\trepo_config_clear(the_repository);\n}\n\nint git_config_get_value(const char *key, const char **value)\n{\n\treturn repo_config_get_value(the_repository, key, value);\n}\n\nconst struct string_list *git_config_get_value_multi(const char *key)\n{\n\treturn repo_config_get_value_multi(the_repository, key);\n}\n\nint git_config_get_string(const char *key, char **dest)\n{\n\treturn repo_config_get_string(the_repository, key, dest);\n}\n\nint git_config_get_string_tmp(const char *key, const char **dest)\n{\n\treturn repo_config_get_string_tmp(the_repository, key, dest);\n}\n\nint git_config_get_int(const char *key, int *dest)\n{\n\treturn repo_config_get_int(the_repository, key, dest);\n}\n\nint git_config_get_ulong(const char *key, unsigned long *dest)\n{\n\treturn repo_config_get_ulong(the_repository, key, dest);\n}\n\nint git_config_get_bool(const char *key, int *dest)\n{\n\treturn repo_config_get_bool(the_repository, key, dest);\n}\n\nint git_config_get_bool_or_int(const char *key, int *is_bool, int *dest)\n{\n\treturn repo_config_get_bool_or_int(the_repository, key, is_bool, dest);\n}\n\nint git_config_get_maybe_bool(const char *key, int *dest)\n{\n\treturn repo_config_get_maybe_bool(the_repository, key, dest);\n}\n\nint git_config_get_pathname(const char *key, const char **dest)\n{\n\treturn repo_config_get_pathname(the_repository, key, dest);\n}\n\nint git_config_get_expiry(const char *key, const char **output)\n{\n\tint ret = git_config_get_string(key, (char **)output);\n\tif (ret)\n\t\treturn ret;\n\tif (strcmp(*output, \"now\")) {\n\t\ttimestamp_t now = approxidate(\"now\");\n\t\tif (approxidate(*output) >= now)\n\t\t\tgit_die_config(key, _(\"Invalid %s: '%s'\"), key, *output);\n\t}\n\treturn ret;\n}\n\nint git_config_get_expiry_in_days(const char *key, timestamp_t *expiry, timestamp_t now)\n{\n\tconst char *expiry_string;\n\tintmax_t days;\n\ttimestamp_t when;\n\n\tif (git_config_get_string_tmp(key, &expiry_string))\n\t\treturn 1; /* no such thing */\n\n\tif (git_parse_signed(expiry_string, &days, maximum_signed_value_of_type(int))) {\n\t\tconst int scale = 86400;\n\t\t*expiry = now - days * scale;\n\t\treturn 0;\n\t}\n\n\tif (!parse_expiry_date(expiry_string, &when)) {\n\t\t*expiry = when;\n\t\treturn 0;\n\t}\n\treturn -1; /* thing exists but cannot be parsed */\n}\n\nint git_config_get_split_index(void)\n{\n\tint val;\n\n\tif (!git_config_get_maybe_bool(\"core.splitindex\", &val))\n\t\treturn val;\n\n\treturn -1; /* default value */\n}\n\nint git_config_get_max_percent_split_change(void)\n{\n\tint val = -1;\n\n\tif (!git_config_get_int(\"splitindex.maxpercentchange\", &val)) {\n\t\tif (0 <= val && val <= 100)\n\t\t\treturn val;\n\n\t\treturn error(_(\"splitIndex.maxPercentChange value '%d' \"\n\t\t\t       \"should be between 0 and 100\"), val);\n\t}\n\n\treturn -1; /* default value */\n}\n\nint git_config_get_fsmonitor(void)\n{\n\tif (git_config_get_pathname(\"core.fsmonitor\", &core_fsmonitor))\n\t\tcore_fsmonitor = getenv(\"GIT_TEST_FSMONITOR\");\n\n\tif (core_fsmonitor && !*core_fsmonitor)\n\t\tcore_fsmonitor = NULL;\n\n\tif (core_fsmonitor)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint git_config_get_index_threads(int *dest)\n{\n\tint is_bool, val;\n\n\tval = git_env_ulong(\"GIT_TEST_INDEX_THREADS\", 0);\n\tif (val) {\n\t\t*dest = val;\n\t\treturn 0;\n\t}\n\n\tif (!git_config_get_bool_or_int(\"index.threads\", &is_bool, &val)) {\n\t\tif (is_bool)\n\t\t\t*dest = val ? 0 : 1;\n\t\telse\n\t\t\t*dest = val;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nNORETURN\nvoid git_die_config_linenr(const char *key, const char *filename, int linenr)\n{\n\tif (!filename)\n\t\tdie(_(\"unable to parse '%s' from command-line config\"), key);\n\telse\n\t\tdie(_(\"bad config variable '%s' in file '%s' at line %d\"),\n\t\t    key, filename, linenr);\n}\n\nNORETURN __attribute__((format(printf, 2, 3)))\nvoid git_die_config(const char *key, const char *err, ...)\n{\n\tconst struct string_list *values;\n\tstruct key_value_info *kv_info;\n\n\tif (err) {\n\t\tva_list params;\n\t\tva_start(params, err);\n\t\tvreportf(\"error: \", err, params);\n\t\tva_end(params);\n\t}\n\tvalues = git_config_get_value_multi(key);\n\tkv_info = values->items[values->nr - 1].util;\n\tgit_die_config_linenr(key, kv_info->filename, kv_info->linenr);\n}\n\n/*\n * Find all the stuff for git_config_set() below.\n */\n\nstruct config_store_data {\n\tsize_t baselen;\n\tchar *key;\n\tint do_not_match;\n\tconst char *fixed_value;\n\tregex_t *value_pattern;\n\tint multi_replace;\n\tstruct {\n\t\tsize_t begin, end;\n\t\tenum config_event_t type;\n\t\tint is_keys_section;\n\t} *parsed;\n\tunsigned int parsed_nr, parsed_alloc, *seen, seen_nr, seen_alloc;\n\tunsigned int key_seen:1, section_seen:1, is_keys_section:1;\n};\n\nstatic void config_store_data_clear(struct config_store_data *store)\n{\n\tfree(store->key);\n\tif (store->value_pattern != NULL &&\n\t    store->value_pattern != CONFIG_REGEX_NONE) {\n\t\tregfree(store->value_pattern);\n\t\tfree(store->value_pattern);\n\t}\n\tfree(store->parsed);\n\tfree(store->seen);\n\tmemset(store, 0, sizeof(*store));\n}\n\nstatic int matches(const char *key, const char *value,\n\t\t   const struct config_store_data *store)\n{\n\tif (strcmp(key, store->key))\n\t\treturn 0; /* not ours */\n\tif (store->fixed_value)\n\t\treturn !strcmp(store->fixed_value, value);\n\tif (!store->value_pattern)\n\t\treturn 1; /* always matches */\n\tif (store->value_pattern == CONFIG_REGEX_NONE)\n\t\treturn 0; /* never matches */\n\n\treturn store->do_not_match ^\n\t\t(value && !regexec(store->value_pattern, value, 0, NULL, 0));\n}\n\nstatic int store_aux_event(enum config_event_t type,\n\t\t\t   size_t begin, size_t end, void *data)\n{\n\tstruct config_store_data *store = data;\n\n\tALLOC_GROW(store->parsed, store->parsed_nr + 1, store->parsed_alloc);\n\tstore->parsed[store->parsed_nr].begin = begin;\n\tstore->parsed[store->parsed_nr].end = end;\n\tstore->parsed[store->parsed_nr].type = type;\n\n\tif (type == CONFIG_EVENT_SECTION) {\n\t\tint (*cmpfn)(const char *, const char *, size_t);\n\n\t\tif (cf->var.len < 2 || cf->var.buf[cf->var.len - 1] != '.')\n\t\t\treturn error(_(\"invalid section name '%s'\"), cf->var.buf);\n\n\t\tif (cf->subsection_case_sensitive)\n\t\t\tcmpfn = strncasecmp;\n\t\telse\n\t\t\tcmpfn = strncmp;\n\n\t\t/* Is this the section we were looking for? */\n\t\tstore->is_keys_section =\n\t\t\tstore->parsed[store->parsed_nr].is_keys_section =\n\t\t\tcf->var.len - 1 == store->baselen &&\n\t\t\t!cmpfn(cf->var.buf, store->key, store->baselen);\n\t\tif (store->is_keys_section) {\n\t\t\tstore->section_seen = 1;\n\t\t\tALLOC_GROW(store->seen, store->seen_nr + 1,\n\t\t\t\t   store->seen_alloc);\n\t\t\tstore->seen[store->seen_nr] = store->parsed_nr;\n\t\t}\n\t}\n\n\tstore->parsed_nr++;\n\n\treturn 0;\n}\n\nstatic int store_aux(const char *key, const char *value, void *cb)\n{\n\tstruct config_store_data *store = cb;\n\n\tif (store->key_seen) {\n\t\tif (matches(key, value, store)) {\n\t\t\tif (store->seen_nr == 1 && store->multi_replace == 0) {\n\t\t\t\twarning(_(\"%s has multiple values\"), key);\n\t\t\t}\n\n\t\t\tALLOC_GROW(store->seen, store->seen_nr + 1,\n\t\t\t\t   store->seen_alloc);\n\n\t\t\tstore->seen[store->seen_nr] = store->parsed_nr;\n\t\t\tstore->seen_nr++;\n\t\t}\n\t} else if (store->is_keys_section) {\n\t\t/*\n\t\t * Do not increment matches yet: this may not be a match, but we\n\t\t * are in the desired section.\n\t\t */\n\t\tALLOC_GROW(store->seen, store->seen_nr + 1, store->seen_alloc);\n\t\tstore->seen[store->seen_nr] = store->parsed_nr;\n\t\tstore->section_seen = 1;\n\n\t\tif (matches(key, value, store)) {\n\t\t\tstore->seen_nr++;\n\t\t\tstore->key_seen = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int write_error(const char *filename)\n{\n\terror(_(\"failed to write new configuration file %s\"), filename);\n\n\t/* Same error code as \"failed to rename\". */\n\treturn 4;\n}\n\nstatic struct strbuf store_create_section(const char *key,\n\t\t\t\t\t  const struct config_store_data *store)\n{\n\tconst char *dot;\n\tsize_t i;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tdot = memchr(key, '.', store->baselen);\n\tif (dot) {\n\t\tstrbuf_addf(&sb, \"[%.*s \\\"\", (int)(dot - key), key);\n\t\tfor (i = dot - key + 1; i < store->baselen; i++) {\n\t\t\tif (key[i] == '\"' || key[i] == '\\\\')\n\t\t\t\tstrbuf_addch(&sb, '\\\\');\n\t\t\tstrbuf_addch(&sb, key[i]);\n\t\t}\n\t\tstrbuf_addstr(&sb, \"\\\"]\\n\");\n\t} else {\n\t\tstrbuf_addch(&sb, '[');\n\t\tstrbuf_add(&sb, key, store->baselen);\n\t\tstrbuf_addstr(&sb, \"]\\n\");\n\t}\n\n\treturn sb;\n}\n\nstatic ssize_t write_section(int fd, const char *key,\n\t\t\t     const struct config_store_data *store)\n{\n\tstruct strbuf sb = store_create_section(key, store);\n\tssize_t ret;\n\n\tret = write_in_full(fd, sb.buf, sb.len);\n\tstrbuf_release(&sb);\n\n\treturn ret;\n}\n\nstatic ssize_t write_pair(int fd, const char *key, const char *value,\n\t\t\t  const struct config_store_data *store)\n{\n\tint i;\n\tssize_t ret;\n\tconst char *quote = \"\";\n\tstruct strbuf sb = STRBUF_INIT;\n\n\t/*\n\t * Check to see if the value needs to be surrounded with a dq pair.\n\t * Note that problematic characters are always backslash-quoted; this\n\t * check is about not losing leading or trailing SP and strings that\n\t * follow beginning-of-comment characters (i.e. ';' and '#') by the\n\t * configuration parser.\n\t */\n\tif (value[0] == ' ')\n\t\tquote = \"\\\"\";\n\tfor (i = 0; value[i]; i++)\n\t\tif (value[i] == ';' || value[i] == '#')\n\t\t\tquote = \"\\\"\";\n\tif (i && value[i - 1] == ' ')\n\t\tquote = \"\\\"\";\n\n\tstrbuf_addf(&sb, \"\\t%s = %s\", key + store->baselen + 1, quote);\n\n\tfor (i = 0; value[i]; i++)\n\t\tswitch (value[i]) {\n\t\tcase '\\n':\n\t\t\tstrbuf_addstr(&sb, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tstrbuf_addstr(&sb, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\t\tstrbuf_addch(&sb, '\\\\');\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tstrbuf_addch(&sb, value[i]);\n\t\t\tbreak;\n\t\t}\n\tstrbuf_addf(&sb, \"%s\\n\", quote);\n\n\tret = write_in_full(fd, sb.buf, sb.len);\n\tstrbuf_release(&sb);\n\n\treturn ret;\n}\n\n/*\n * If we are about to unset the last key(s) in a section, and if there are\n * no comments surrounding (or included in) the section, we will want to\n * extend begin/end to remove the entire section.\n *\n * Note: the parameter `seen_ptr` points to the index into the store.seen\n * array.  * This index may be incremented if a section has more than one\n * entry (which all are to be removed).\n */\nstatic void maybe_remove_section(struct config_store_data *store,\n\t\t\t\t size_t *begin_offset, size_t *end_offset,\n\t\t\t\t int *seen_ptr)\n{\n\tsize_t begin;\n\tint i, seen, section_seen = 0;\n\n\t/*\n\t * First, ensure that this is the first key, and that there are no\n\t * comments before the entry nor before the section header.\n\t */\n\tseen = *seen_ptr;\n\tfor (i = store->seen[seen]; i > 0; i--) {\n\t\tenum config_event_t type = store->parsed[i - 1].type;\n\n\t\tif (type == CONFIG_EVENT_COMMENT)\n\t\t\t/* There is a comment before this entry or section */\n\t\t\treturn;\n\t\tif (type == CONFIG_EVENT_ENTRY) {\n\t\t\tif (!section_seen)\n\t\t\t\t/* This is not the section's first entry. */\n\t\t\t\treturn;\n\t\t\t/* We encountered no comment before the section. */\n\t\t\tbreak;\n\t\t}\n\t\tif (type == CONFIG_EVENT_SECTION) {\n\t\t\tif (!store->parsed[i - 1].is_keys_section)\n\t\t\t\tbreak;\n\t\t\tsection_seen = 1;\n\t\t}\n\t}\n\tbegin = store->parsed[i].begin;\n\n\t/*\n\t * Next, make sure that we are removing he last key(s) in the section,\n\t * and that there are no comments that are possibly about the current\n\t * section.\n\t */\n\tfor (i = store->seen[seen] + 1; i < store->parsed_nr; i++) {\n\t\tenum config_event_t type = store->parsed[i].type;\n\n\t\tif (type == CONFIG_EVENT_COMMENT)\n\t\t\treturn;\n\t\tif (type == CONFIG_EVENT_SECTION) {\n\t\t\tif (store->parsed[i].is_keys_section)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (type == CONFIG_EVENT_ENTRY) {\n\t\t\tif (++seen < store->seen_nr &&\n\t\t\t    i == store->seen[seen])\n\t\t\t\t/* We want to remove this entry, too */\n\t\t\t\tcontinue;\n\t\t\t/* There is another entry in this section. */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * We are really removing the last entry/entries from this section, and\n\t * there are no enclosed or surrounding comments. Remove the entire,\n\t * now-empty section.\n\t */\n\t*seen_ptr = seen;\n\t*begin_offset = begin;\n\tif (i < store->parsed_nr)\n\t\t*end_offset = store->parsed[i].begin;\n\telse\n\t\t*end_offset = store->parsed[store->parsed_nr - 1].end;\n}\n\nint git_config_set_in_file_gently(const char *config_filename,\n\t\t\t\t  const char *key, const char *value)\n{\n\treturn git_config_set_multivar_in_file_gently(config_filename, key, value, NULL, 0);\n}\n\nvoid git_config_set_in_file(const char *config_filename,\n\t\t\t    const char *key, const char *value)\n{\n\tgit_config_set_multivar_in_file(config_filename, key, value, NULL, 0);\n}\n\nint git_config_set_gently(const char *key, const char *value)\n{\n\treturn git_config_set_multivar_gently(key, value, NULL, 0);\n}\n\nvoid git_config_set(const char *key, const char *value)\n{\n\tgit_config_set_multivar(key, value, NULL, 0);\n\n\ttrace2_cmd_set_config(key, value);\n}\n\n/*\n * If value==NULL, unset in (remove from) config,\n * if value_pattern!=NULL, disregard key/value pairs where value does not match.\n * if value_pattern==CONFIG_REGEX_NONE, do not match any existing values\n *     (only add a new one)\n * if flags contains the CONFIG_FLAGS_MULTI_REPLACE flag, all matching\n *     key/values are removed before a single new pair is written. If the\n *     flag is not present, then replace only the first match.\n *\n * Returns 0 on success.\n *\n * This function does this:\n *\n * - it locks the config file by creating \".git/config.lock\"\n *\n * - it then parses the config using store_aux() as validator to find\n *   the position on the key/value pair to replace. If it is to be unset,\n *   it must be found exactly once.\n *\n * - the config file is mmap()ed and the part before the match (if any) is\n *   written to the lock file, then the changed part and the rest.\n *\n * - the config file is removed and the lock file rename()d to it.\n *\n */\nint git_config_set_multivar_in_file_gently(const char *config_filename,\n\t\t\t\t\t   const char *key, const char *value,\n\t\t\t\t\t   const char *value_pattern,\n\t\t\t\t\t   unsigned flags)\n{\n\tint fd = -1, in_fd = -1;\n\tint ret;\n\tstruct lock_file lock = LOCK_INIT;\n\tchar *filename_buf = NULL;\n\tchar *contents = NULL;\n\tsize_t contents_sz;\n\tstruct config_store_data store;\n\n\tmemset(&store, 0, sizeof(store));\n\n\t/* parse-key returns negative; flip the sign to feed exit(3) */\n\tret = 0 - git_config_parse_key(key, &store.key, &store.baselen);\n\tif (ret)\n\t\tgoto out_free;\n\n\tstore.multi_replace = (flags & CONFIG_FLAGS_MULTI_REPLACE) != 0;\n\n\tif (!config_filename)\n\t\tconfig_filename = filename_buf = git_pathdup(\"config\");\n\n\t/*\n\t * The lock serves a purpose in addition to locking: the new\n\t * contents of .git/config will be written into it.\n\t */\n\tfd = hold_lock_file_for_update(&lock, config_filename, 0);\n\tif (fd < 0) {\n\t\terror_errno(_(\"could not lock config file %s\"), config_filename);\n\t\tret = CONFIG_NO_LOCK;\n\t\tgoto out_free;\n\t}\n\n\t/*\n\t * If .git/config does not exist yet, write a minimal version.\n\t */\n\tin_fd = open(config_filename, O_RDONLY);\n\tif ( in_fd < 0 ) {\n\t\tif ( ENOENT != errno ) {\n\t\t\terror_errno(_(\"opening %s\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE; /* same as \"invalid config file\" */\n\t\t\tgoto out_free;\n\t\t}\n\t\t/* if nothing to unset, error out */\n\t\tif (value == NULL) {\n\t\t\tret = CONFIG_NOTHING_SET;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tfree(store.key);\n\t\tstore.key = xstrdup(key);\n\t\tif (write_section(fd, key, &store) < 0 ||\n\t\t    write_pair(fd, key, value, &store) < 0)\n\t\t\tgoto write_err_out;\n\t} else {\n\t\tstruct stat st;\n\t\tsize_t copy_begin, copy_end;\n\t\tint i, new_line = 0;\n\t\tstruct config_options opts;\n\n\t\tif (value_pattern == NULL)\n\t\t\tstore.value_pattern = NULL;\n\t\telse if (value_pattern == CONFIG_REGEX_NONE)\n\t\t\tstore.value_pattern = CONFIG_REGEX_NONE;\n\t\telse if (flags & CONFIG_FLAGS_FIXED_VALUE)\n\t\t\tstore.fixed_value = value_pattern;\n\t\telse {\n\t\t\tif (value_pattern[0] == '!') {\n\t\t\t\tstore.do_not_match = 1;\n\t\t\t\tvalue_pattern++;\n\t\t\t} else\n\t\t\t\tstore.do_not_match = 0;\n\n\t\t\tstore.value_pattern = (regex_t*)xmalloc(sizeof(regex_t));\n\t\t\tif (regcomp(store.value_pattern, value_pattern,\n\t\t\t\t\tREG_EXTENDED)) {\n\t\t\t\terror(_(\"invalid pattern: %s\"), value_pattern);\n\t\t\t\tFREE_AND_NULL(store.value_pattern);\n\t\t\t\tret = CONFIG_INVALID_PATTERN;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\n\t\tALLOC_GROW(store.parsed, 1, store.parsed_alloc);\n\t\tstore.parsed[0].end = 0;\n\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\topts.event_fn = store_aux_event;\n\t\topts.event_fn_data = &store;\n\n\t\t/*\n\t\t * After this, store.parsed will contain offsets of all the\n\t\t * parsed elements, and store.seen will contain a list of\n\t\t * matches, as indices into store.parsed.\n\t\t *\n\t\t * As a side effect, we make sure to transform only a valid\n\t\t * existing config file.\n\t\t */\n\t\tif (git_config_from_file_with_options(store_aux,\n\t\t\t\t\t\t      config_filename,\n\t\t\t\t\t\t      &store, &opts)) {\n\t\t\terror(_(\"invalid config file %s\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* if nothing to unset, or too many matches, error out */\n\t\tif ((store.seen_nr == 0 && value == NULL) ||\n\t\t    (store.seen_nr > 1 && !store.multi_replace)) {\n\t\t\tret = CONFIG_NOTHING_SET;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (fstat(in_fd, &st) == -1) {\n\t\t\terror_errno(_(\"fstat on %s failed\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcontents_sz = xsize_t(st.st_size);\n\t\tcontents = xmmap_gently(NULL, contents_sz, PROT_READ,\n\t\t\t\t\tMAP_PRIVATE, in_fd, 0);\n\t\tif (contents == MAP_FAILED) {\n\t\t\tif (errno == ENODEV && S_ISDIR(st.st_mode))\n\t\t\t\terrno = EISDIR;\n\t\t\terror_errno(_(\"unable to mmap '%s'\"), config_filename);\n\t\t\tret = CONFIG_INVALID_FILE;\n\t\t\tcontents = NULL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tclose(in_fd);\n\t\tin_fd = -1;\n\n\t\tif (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {\n\t\t\terror_errno(_(\"chmod on %s failed\"), get_lock_file_path(&lock));\n\t\t\tret = CONFIG_NO_WRITE;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (store.seen_nr == 0) {\n\t\t\tif (!store.seen_alloc) {\n\t\t\t\t/* Did not see key nor section */\n\t\t\t\tALLOC_GROW(store.seen, 1, store.seen_alloc);\n\t\t\t\tstore.seen[0] = store.parsed_nr\n\t\t\t\t\t- !!store.parsed_nr;\n\t\t\t}\n\t\t\tstore.seen_nr = 1;\n\t\t}\n\n\t\tfor (i = 0, copy_begin = 0; i < store.seen_nr; i++) {\n\t\t\tsize_t replace_end;\n\t\t\tint j = store.seen[i];\n\n\t\t\tnew_line = 0;\n\t\t\tif (!store.key_seen) {\n\t\t\t\tcopy_end = store.parsed[j].end;\n\t\t\t\t/* include '\\n' when copying section header */\n\t\t\t\tif (copy_end > 0 && copy_end < contents_sz &&\n\t\t\t\t    contents[copy_end - 1] != '\\n' &&\n\t\t\t\t    contents[copy_end] == '\\n')\n\t\t\t\t\tcopy_end++;\n\t\t\t\treplace_end = copy_end;\n\t\t\t} else {\n\t\t\t\treplace_end = store.parsed[j].end;\n\t\t\t\tcopy_end = store.parsed[j].begin;\n\t\t\t\tif (!value)\n\t\t\t\t\tmaybe_remove_section(&store,\n\t\t\t\t\t\t\t     &copy_end,\n\t\t\t\t\t\t\t     &replace_end, &i);\n\t\t\t\t/*\n\t\t\t\t * Swallow preceding white-space on the same\n\t\t\t\t * line.\n\t\t\t\t */\n\t\t\t\twhile (copy_end > 0 ) {\n\t\t\t\t\tchar c = contents[copy_end - 1];\n\n\t\t\t\t\tif (isspace(c) && c != '\\n')\n\t\t\t\t\t\tcopy_end--;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (copy_end > 0 && contents[copy_end-1] != '\\n')\n\t\t\t\tnew_line = 1;\n\n\t\t\t/* write the first part of the config */\n\t\t\tif (copy_end > copy_begin) {\n\t\t\t\tif (write_in_full(fd, contents + copy_begin,\n\t\t\t\t\t\t  copy_end - copy_begin) < 0)\n\t\t\t\t\tgoto write_err_out;\n\t\t\t\tif (new_line &&\n\t\t\t\t    write_str_in_full(fd, \"\\n\") < 0)\n\t\t\t\t\tgoto write_err_out;\n\t\t\t}\n\t\t\tcopy_begin = replace_end;\n\t\t}\n\n\t\t/* write the pair (value == NULL means unset) */\n\t\tif (value != NULL) {\n\t\t\tif (!store.section_seen) {\n\t\t\t\tif (write_section(fd, key, &store) < 0)\n\t\t\t\t\tgoto write_err_out;\n\t\t\t}\n\t\t\tif (write_pair(fd, key, value, &store) < 0)\n\t\t\t\tgoto write_err_out;\n\t\t}\n\n\t\t/* write the rest of the config */\n\t\tif (copy_begin < contents_sz)\n\t\t\tif (write_in_full(fd, contents + copy_begin,\n\t\t\t\t\t  contents_sz - copy_begin) < 0)\n\t\t\t\tgoto write_err_out;\n\n\t\tmunmap(contents, contents_sz);\n\t\tcontents = NULL;\n\t}\n\n\tif (commit_lock_file(&lock) < 0) {\n\t\terror_errno(_(\"could not write config file %s\"), config_filename);\n\t\tret = CONFIG_NO_WRITE;\n\t\tgoto out_free;\n\t}\n\n\tret = 0;\n\n\t/* Invalidate the config cache */\n\tgit_config_clear();\n\nout_free:\n\trollback_lock_file(&lock);\n\tfree(filename_buf);\n\tif (contents)\n\t\tmunmap(contents, contents_sz);\n\tif (in_fd >= 0)\n\t\tclose(in_fd);\n\tconfig_store_data_clear(&store);\n\treturn ret;\n\nwrite_err_out:\n\tret = write_error(get_lock_file_path(&lock));\n\tgoto out_free;\n\n}\n\nvoid git_config_set_multivar_in_file(const char *config_filename,\n\t\t\t\t     const char *key, const char *value,\n\t\t\t\t     const char *value_pattern, unsigned flags)\n{\n\tif (!git_config_set_multivar_in_file_gently(config_filename, key, value,\n\t\t\t\t\t\t    value_pattern, flags))\n\t\treturn;\n\tif (value)\n\t\tdie(_(\"could not set '%s' to '%s'\"), key, value);\n\telse\n\t\tdie(_(\"could not unset '%s'\"), key);\n}\n\nint git_config_set_multivar_gently(const char *key, const char *value,\n\t\t\t\t   const char *value_pattern, unsigned flags)\n{\n\treturn git_config_set_multivar_in_file_gently(NULL, key, value, value_pattern,\n\t\t\t\t\t\t      flags);\n}\n\nvoid git_config_set_multivar(const char *key, const char *value,\n\t\t\t     const char *value_pattern, unsigned flags)\n{\n\tgit_config_set_multivar_in_file(NULL, key, value, value_pattern,\n\t\t\t\t\tflags);\n}\n\nstatic size_t section_name_match (const char *buf, const char *name)\n{\n\tsize_t i = 0, j = 0;\n\tint dot = 0;\n\tif (buf[i] != '[')\n\t\treturn 0;\n\tfor (i = 1; buf[i] && buf[i] != ']'; i++) {\n\t\tif (!dot && isspace(buf[i])) {\n\t\t\tdot = 1;\n\t\t\tif (name[j++] != '.')\n\t\t\t\tbreak;\n\t\t\tfor (i++; isspace(buf[i]); i++)\n\t\t\t\t; /* do nothing */\n\t\t\tif (buf[i] != '\"')\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] == '\\\\' && dot)\n\t\t\ti++;\n\t\telse if (buf[i] == '\"' && dot) {\n\t\t\tfor (i++; isspace(buf[i]); i++)\n\t\t\t\t; /* do_nothing */\n\t\t\tbreak;\n\t\t}\n\t\tif (buf[i] != name[j++])\n\t\t\tbreak;\n\t}\n\tif (buf[i] == ']' && name[j] == 0) {\n\t\t/*\n\t\t * We match, now just find the right length offset by\n\t\t * gobbling up any whitespace after it, as well\n\t\t */\n\t\ti++;\n\t\tfor (; buf[i] && isspace(buf[i]); i++)\n\t\t\t; /* do nothing */\n\t\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int section_name_is_ok(const char *name)\n{\n\t/* Empty section names are bogus. */\n\tif (!*name)\n\t\treturn 0;\n\n\t/*\n\t * Before a dot, we must be alphanumeric or dash. After the first dot,\n\t * anything goes, so we can stop checking.\n\t */\n\tfor (; *name && *name != '.'; name++)\n\t\tif (*name != '-' && !isalnum(*name))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n#define GIT_CONFIG_MAX_LINE_LEN (512 * 1024)\n\n/* if new_name == NULL, the section is removed instead */\nstatic int git_config_copy_or_rename_section_in_file(const char *config_filename,\n\t\t\t\t      const char *old_name,\n\t\t\t\t      const char *new_name, int copy)\n{\n\tint ret = 0, remove = 0;\n\tchar *filename_buf = NULL;\n\tstruct lock_file lock = LOCK_INIT;\n\tint out_fd;\n\tstruct strbuf buf = STRBUF_INIT;\n\tFILE *config_file = NULL;\n\tstruct stat st;\n\tstruct strbuf copystr = STRBUF_INIT;\n\tstruct config_store_data store;\n\tuint32_t line_nr = 0;\n\n\tmemset(&store, 0, sizeof(store));\n\n\tif (new_name && !section_name_is_ok(new_name)) {\n\t\tret = error(_(\"invalid section name: %s\"), new_name);\n\t\tgoto out_no_rollback;\n\t}\n\n\tif (!config_filename)\n\t\tconfig_filename = filename_buf = git_pathdup(\"config\");\n\n\tout_fd = hold_lock_file_for_update(&lock, config_filename, 0);\n\tif (out_fd < 0) {\n\t\tret = error(_(\"could not lock config file %s\"), config_filename);\n\t\tgoto out;\n\t}\n\n\tif (!(config_file = fopen(config_filename, \"rb\"))) {\n\t\tret = warn_on_fopen_errors(config_filename);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/* no config file means nothing to rename, no error */\n\t\tgoto commit_and_out;\n\t}\n\n\tif (fstat(fileno(config_file), &st) == -1) {\n\t\tret = error_errno(_(\"fstat on %s failed\"), config_filename);\n\t\tgoto out;\n\t}\n\n\tif (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {\n\t\tret = error_errno(_(\"chmod on %s failed\"),\n\t\t\t\t  get_lock_file_path(&lock));\n\t\tgoto out;\n\t}\n\n\twhile (!strbuf_getwholeline(&buf, config_file, '\\n')) {\n\t\tsize_t i, length;\n\t\tint is_section = 0;\n\t\tchar *output = buf.buf;\n\n\t\tline_nr++;\n\n\t\tif (buf.len >= GIT_CONFIG_MAX_LINE_LEN) {\n\t\t\tret = error(_(\"refusing to work with overly long line \"\n\t\t\t\t      \"in '%s' on line %\"PRIuMAX),\n\t\t\t\t    config_filename, (uintmax_t)line_nr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; buf.buf[i] && isspace(buf.buf[i]); i++)\n\t\t\t; /* do nothing */\n\t\tif (buf.buf[i] == '[') {\n\t\t\t/* it's a section */\n\t\t\tsize_t offset;\n\t\t\tis_section = 1;\n\n\t\t\t/*\n\t\t\t * When encountering a new section under -c we\n\t\t\t * need to flush out any section we're already\n\t\t\t * coping and begin anew. There might be\n\t\t\t * multiple [branch \"$name\"] sections.\n\t\t\t */\n\t\t\tif (copystr.len > 0) {\n\t\t\t\tif (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {\n\t\t\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tstrbuf_reset(&copystr);\n\t\t\t}\n\n\t\t\toffset = section_name_match(&buf.buf[i], old_name);\n\t\t\tif (offset > 0) {\n\t\t\t\tret++;\n\t\t\t\tif (new_name == NULL) {\n\t\t\t\t\tremove = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstore.baselen = strlen(new_name);\n\t\t\t\tif (!copy) {\n\t\t\t\t\tif (write_section(out_fd, new_name, &store) < 0) {\n\t\t\t\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * We wrote out the new section, with\n\t\t\t\t\t * a newline, now skip the old\n\t\t\t\t\t * section's length\n\t\t\t\t\t */\n\t\t\t\t\toutput += offset + i;\n\t\t\t\t\tif (strlen(output) > 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * More content means there's\n\t\t\t\t\t\t * a declaration to put on the\n\t\t\t\t\t\t * next line; indent with a\n\t\t\t\t\t\t * tab\n\t\t\t\t\t\t */\n\t\t\t\t\t\toutput -= 1;\n\t\t\t\t\t\toutput[0] = '\\t';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcopystr = store_create_section(new_name, &store);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove = 0;\n\t\t}\n\t\tif (remove)\n\t\t\tcontinue;\n\t\tlength = strlen(output);\n\n\t\tif (!is_section && copystr.len > 0) {\n\t\t\tstrbuf_add(&copystr, output, length);\n\t\t}\n\n\t\tif (write_in_full(out_fd, output, length) < 0) {\n\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Copy a trailing section at the end of the config, won't be\n\t * flushed by the usual \"flush because we have a new section\n\t * logic in the loop above.\n\t */\n\tif (copystr.len > 0) {\n\t\tif (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {\n\t\t\tret = write_error(get_lock_file_path(&lock));\n\t\t\tgoto out;\n\t\t}\n\t\tstrbuf_reset(&copystr);\n\t}\n\n\tfclose(config_file);\n\tconfig_file = NULL;\ncommit_and_out:\n\tif (commit_lock_file(&lock) < 0)\n\t\tret = error_errno(_(\"could not write config file %s\"),\n\t\t\t\t  config_filename);\nout:\n\tif (config_file)\n\t\tfclose(config_file);\n\trollback_lock_file(&lock);\nout_no_rollback:\n\tfree(filename_buf);\n\tconfig_store_data_clear(&store);\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nint git_config_rename_section_in_file(const char *config_filename,\n\t\t\t\t      const char *old_name, const char *new_name)\n{\n\treturn git_config_copy_or_rename_section_in_file(config_filename,\n\t\t\t\t\t old_name, new_name, 0);\n}\n\nint git_config_rename_section(const char *old_name, const char *new_name)\n{\n\treturn git_config_rename_section_in_file(NULL, old_name, new_name);\n}\n\nint git_config_copy_section_in_file(const char *config_filename,\n\t\t\t\t      const char *old_name, const char *new_name)\n{\n\treturn git_config_copy_or_rename_section_in_file(config_filename,\n\t\t\t\t\t old_name, new_name, 1);\n}\n\nint git_config_copy_section(const char *old_name, const char *new_name)\n{\n\treturn git_config_copy_section_in_file(NULL, old_name, new_name);\n}\n\n/*\n * Call this to report error for your variable that should not\n * get a boolean value (i.e. \"[my] var\" means \"true\").\n */\n#undef config_error_nonbool\nint config_error_nonbool(const char *var)\n{\n\treturn error(_(\"missing value for '%s'\"), var);\n}\n\nint parse_config_key(const char *var,\n\t\t     const char *section,\n\t\t     const char **subsection, size_t *subsection_len,\n\t\t     const char **key)\n{\n\tconst char *dot;\n\n\t/* Does it start with \"section.\" ? */\n\tif (!skip_prefix(var, section, &var) || *var != '.')\n\t\treturn -1;\n\n\t/*\n\t * Find the key; we don't know yet if we have a subsection, but we must\n\t * parse backwards from the end, since the subsection may have dots in\n\t * it, too.\n\t */\n\tdot = strrchr(var, '.');\n\t*key = dot + 1;\n\n\t/* Did we have a subsection at all? */\n\tif (dot == var) {\n\t\tif (subsection) {\n\t\t\t*subsection = NULL;\n\t\t\t*subsection_len = 0;\n\t\t}\n\t}\n\telse {\n\t\tif (!subsection)\n\t\t\treturn -1;\n\t\t*subsection = var + 1;\n\t\t*subsection_len = dot - *subsection;\n\t}\n\n\treturn 0;\n}\n\nconst char *current_config_origin_type(void)\n{\n\tint type;\n\tif (current_config_kvi)\n\t\ttype = current_config_kvi->origin_type;\n\telse if(cf)\n\t\ttype = cf->origin_type;\n\telse\n\t\tBUG(\"current_config_origin_type called outside config callback\");\n\n\tswitch (type) {\n\tcase CONFIG_ORIGIN_BLOB:\n\t\treturn \"blob\";\n\tcase CONFIG_ORIGIN_FILE:\n\t\treturn \"file\";\n\tcase CONFIG_ORIGIN_STDIN:\n\t\treturn \"standard input\";\n\tcase CONFIG_ORIGIN_SUBMODULE_BLOB:\n\t\treturn \"submodule-blob\";\n\tcase CONFIG_ORIGIN_CMDLINE:\n\t\treturn \"command line\";\n\tdefault:\n\t\tBUG(\"unknown config origin type\");\n\t}\n}\n\nconst char *config_scope_name(enum config_scope scope)\n{\n\tswitch (scope) {\n\tcase CONFIG_SCOPE_SYSTEM:\n\t\treturn \"system\";\n\tcase CONFIG_SCOPE_GLOBAL:\n\t\treturn \"global\";\n\tcase CONFIG_SCOPE_LOCAL:\n\t\treturn \"local\";\n\tcase CONFIG_SCOPE_WORKTREE:\n\t\treturn \"worktree\";\n\tcase CONFIG_SCOPE_COMMAND:\n\t\treturn \"command\";\n\tcase CONFIG_SCOPE_SUBMODULE:\n\t\treturn \"submodule\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nconst char *current_config_name(void)\n{\n\tconst char *name;\n\tif (current_config_kvi)\n\t\tname = current_config_kvi->filename;\n\telse if (cf)\n\t\tname = cf->name;\n\telse\n\t\tBUG(\"current_config_name called outside config callback\");\n\treturn name ? name : \"\";\n}\n\nenum config_scope current_config_scope(void)\n{\n\tif (current_config_kvi)\n\t\treturn current_config_kvi->scope;\n\telse\n\t\treturn current_parsing_scope;\n}\n\nint current_config_line(void)\n{\n\tif (current_config_kvi)\n\t\treturn current_config_kvi->linenr;\n\telse\n\t\treturn cf->linenr;\n}\n\nint lookup_config(const char **mapping, int nr_mapping, const char *var)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_mapping; i++) {\n\t\tconst char *name = mapping[i];\n\n\t\tif (name && !strcasecmp(var, name))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2005 Johannes Schindelin\n#\n\ntest_description='Test git config in different settings'\n\n. ./test-lib.sh\n\ntest_expect_success 'clear default config' '\n\trm -f .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\nEOF\ntest_expect_success 'initial' '\n\tgit config section.penguin \"little blue\" &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\n\tMovie = BadPhysics\nEOF\ntest_expect_success 'mixed case' '\n\tgit config Section.Movie BadPhysics &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\n\tMovie = BadPhysics\n[Sections]\n\tWhatEver = Second\nEOF\ntest_expect_success 'similar section' '\n\tgit config Sections.WhatEver Second &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = little blue\n\tMovie = BadPhysics\n\tUPPERCASE = true\n[Sections]\n\tWhatEver = Second\nEOF\ntest_expect_success 'uppercase section' '\n\tgit config SECTION.UPPERCASE true &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'replace with non-match' '\n\tgit config section.penguin kingpin !blue\n'\n\ntest_expect_success 'replace with non-match (actually matching)' '\n\tgit config section.penguin \"very blue\" !kingpin\n'\n\ncat > expect << EOF\n[section]\n\tpenguin = very blue\n\tMovie = BadPhysics\n\tUPPERCASE = true\n\tpenguin = kingpin\n[Sections]\n\tWhatEver = Second\nEOF\n\ntest_expect_success 'non-match result' 'test_cmp expect .git/config'\n\ntest_expect_success 'find mixed-case key by canonical name' '\n\ttest_cmp_config Second sections.whatever\n'\n\ntest_expect_success 'find mixed-case key by non-canonical name' '\n\ttest_cmp_config Second SeCtIoNs.WhAtEvEr\n'\n\ntest_expect_success 'subsections are not canonicalized by git-config' '\n\tcat >>.git/config <<-\\EOF &&\n\t[section.SubSection]\n\tkey = one\n\t[section \"SubSection\"]\n\tkey = two\n\tEOF\n\ttest_cmp_config one section.subsection.key &&\n\ttest_cmp_config two section.SubSection.key\n'\n\ncat > .git/config <<\\EOF\n[alpha]\nbar = foo\n[beta]\nbaz = multiple \\\nlines\nfoo = bar\nEOF\n\ntest_expect_success 'unset with cont. lines' '\n\tgit config --unset beta.baz\n'\n\ncat > expect <<\\EOF\n[alpha]\nbar = foo\n[beta]\nfoo = bar\nEOF\n\ntest_expect_success 'unset with cont. lines is correct' 'test_cmp expect .git/config'\n\ncat > .git/config << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\t\thaha   =\"beta\" # last silly comment\nhaha = hello\n\thaha = bello\n[nextSection] noNewline = ouch\nEOF\n\ncp .git/config .git/config2\n\ntest_expect_success 'multiple unset' '\n\tgit config --unset-all beta.haha\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection] noNewline = ouch\nEOF\n\ntest_expect_success 'multiple unset is correct' '\n\ttest_cmp expect .git/config\n'\n\ncp .git/config2 .git/config\n\ntest_expect_success '--replace-all missing value' '\n\ttest_must_fail git config --replace-all beta.haha &&\n\ttest_cmp .git/config2 .git/config\n'\n\nrm .git/config2\n\ntest_expect_success '--replace-all' '\n\tgit config --replace-all beta.haha gamma\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\thaha = gamma\n[nextSection] noNewline = ouch\nEOF\n\ntest_expect_success 'all replaced' '\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\thaha = alpha\n[nextSection] noNewline = ouch\nEOF\ntest_expect_success 'really mean test' '\n\tgit config beta.haha alpha &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n\thaha = alpha\n[nextSection]\n\tnonewline = wow\nEOF\ntest_expect_success 'really really mean test' '\n\tgit config nextsection.nonewline wow &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'get value' '\n\ttest_cmp_config alpha beta.haha\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tnonewline = wow\nEOF\ntest_expect_success 'unset' '\n\tgit config --unset beta.haha &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tnonewline = wow\n\tNoNewLine = wow2 for me\nEOF\ntest_expect_success 'multivar' '\n\tgit config nextsection.NoNewLine \"wow2 for me\" \"for me$\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'non-match' '\n\tgit config --get nextsection.nonewline !for\n'\n\ntest_expect_success 'non-match value' '\n\ttest_cmp_config wow --get nextsection.nonewline !for\n'\n\ntest_expect_success 'multi-valued get returns final one' '\n\ttest_cmp_config \"wow2 for me\" --get nextsection.nonewline\n'\n\ntest_expect_success 'multi-valued get-all returns all' '\n\tcat >expect <<-\\EOF &&\n\twow\n\twow2 for me\n\tEOF\n\tgit config --get-all nextsection.nonewline >actual &&\n\ttest_cmp expect actual\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tnonewline = wow3\n\tNoNewLine = wow2 for me\nEOF\ntest_expect_success 'multivar replace' '\n\tgit config nextsection.nonewline \"wow3\" \"wow$\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'ambiguous unset' '\n\ttest_must_fail git config --unset nextsection.nonewline\n'\n\ntest_expect_success 'invalid unset' '\n\ttest_must_fail git config --unset somesection.nonewline\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tNoNewLine = wow2 for me\nEOF\n\ntest_expect_success 'multivar unset' '\n\tgit config --unset nextsection.nonewline \"wow3$\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'invalid key' 'test_must_fail git config inval.2key blabla'\n\ntest_expect_success 'correct key' 'git config 123456.a123 987'\n\ntest_expect_success 'hierarchical section' '\n\tgit config Version.1.2.3eX.Alpha beta\n'\n\ncat > expect << EOF\n[beta] ; silly comment # another comment\nnoIndent= sillyValue ; 'nother silly comment\n\n# empty line\n\t\t; comment\n[nextSection]\n\tNoNewLine = wow2 for me\n[123456]\n\ta123 = 987\n[Version \"1.2.3eX\"]\n\tAlpha = beta\nEOF\n\ntest_expect_success 'hierarchical section value' '\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\nbeta.noindent=sillyValue\nnextsection.nonewline=wow2 for me\n123456.a123=987\nversion.1.2.3eX.alpha=beta\nEOF\n\ntest_expect_success 'working --list' '\n\tgit config --list > output &&\n\ttest_cmp expect output\n'\ntest_expect_success '--list without repo produces empty output' '\n\tgit --git-dir=nonexistent config --list >output &&\n\ttest_must_be_empty output\n'\n\ncat > expect << EOF\nbeta.noindent\nnextsection.nonewline\n123456.a123\nversion.1.2.3eX.alpha\nEOF\n\ntest_expect_success '--name-only --list' '\n\tgit config --name-only --list >output &&\n\ttest_cmp expect output\n'\n\ncat > expect << EOF\nbeta.noindent sillyValue\nnextsection.nonewline wow2 for me\nEOF\n\ntest_expect_success '--get-regexp' '\n\tgit config --get-regexp in >output &&\n\ttest_cmp expect output\n'\n\ncat > expect << EOF\nbeta.noindent\nnextsection.nonewline\nEOF\n\ntest_expect_success '--name-only --get-regexp' '\n\tgit config --name-only --get-regexp in >output &&\n\ttest_cmp expect output\n'\n\ncat > expect << EOF\nwow2 for me\nwow4 for you\nEOF\n\ntest_expect_success '--add' '\n\tgit config --add nextsection.nonewline \"wow4 for you\" &&\n\tgit config --get-all nextsection.nonewline > output &&\n\ttest_cmp expect output\n'\n\ncat > .git/config << EOF\n[novalue]\n\tvariable\n[emptyvalue]\n\tvariable =\nEOF\n\ntest_expect_success 'get variable with no value' '\n\tgit config --get novalue.variable ^$\n'\n\ntest_expect_success 'get variable with empty value' '\n\tgit config --get emptyvalue.variable ^$\n'\n\necho novalue.variable > expect\n\ntest_expect_success 'get-regexp variable with no value' '\n\tgit config --get-regexp novalue > output &&\n\ttest_cmp expect output\n'\n\necho 'novalue.variable true' > expect\n\ntest_expect_success 'get-regexp --bool variable with no value' '\n\tgit config --bool --get-regexp novalue > output &&\n\ttest_cmp expect output\n'\n\necho 'emptyvalue.variable ' > expect\n\ntest_expect_success 'get-regexp variable with empty value' '\n\tgit config --get-regexp emptyvalue > output &&\n\ttest_cmp expect output\n'\n\necho true > expect\n\ntest_expect_success 'get bool variable with no value' '\n\tgit config --bool novalue.variable > output &&\n\ttest_cmp expect output\n'\n\necho false > expect\n\ntest_expect_success 'get bool variable with empty value' '\n\tgit config --bool emptyvalue.variable > output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'no arguments, but no crash' '\n\ttest_must_fail git config >output 2>&1 &&\n\ttest_i18ngrep usage output\n'\n\ncat > .git/config << EOF\n[a.b]\n\tc = d\nEOF\n\ncat > expect << EOF\n[a.b]\n\tc = d\n[a]\n\tx = y\nEOF\n\ntest_expect_success 'new section is partial match of another' '\n\tgit config a.x y &&\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[a.b]\n\tc = d\n[a]\n\tx = y\n\tb = c\n[b]\n\tx = y\nEOF\n\ntest_expect_success 'new variable inserts into proper section' '\n\tgit config b.x y &&\n\tgit config a.b c &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'alternative --file (non-existing file should fail)' '\n\ttest_must_fail git config --file non-existing-config -l &&\n\ttest_must_fail git config --file non-existing-config test.xyzzy\n'\n\ncat > other-config << EOF\n[ein]\n\tbahn = strasse\nEOF\n\ncat > expect << EOF\nein.bahn=strasse\nEOF\n\ntest_expect_success 'alternative GIT_CONFIG' '\n\tGIT_CONFIG=other-config git config --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'alternative GIT_CONFIG (--file)' '\n\tgit config --file other-config --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'alternative GIT_CONFIG (--file=-)' '\n\tgit config --file - --list <other-config >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'setting a value in stdin is an error' '\n\ttest_must_fail git config --file - some.value foo\n'\n\ntest_expect_success 'editing stdin is an error' '\n\ttest_must_fail git config --file - --edit\n'\n\ntest_expect_success 'refer config from subdirectory' '\n\tmkdir x &&\n\ttest_cmp_config -C x strasse --file=../other-config --get ein.bahn\n'\n\ncat > expect << EOF\n[ein]\n\tbahn = strasse\n[anwohner]\n\tpark = ausweis\nEOF\n\ntest_expect_success '--set in alternative file' '\n\tgit config --file=other-config anwohner.park ausweis &&\n\ttest_cmp expect other-config\n'\n\ncat > .git/config << EOF\n# Hallo\n\t#Bello\n[branch \"eins\"]\n\tx = 1\n[branch.eins]\n\ty = 1\n\t[branch \"1 234 blabl/a\"]\nweird\nEOF\n\ntest_expect_success 'rename section' '\n\tgit config --rename-section branch.eins branch.zwei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"zwei\"]\n\tx = 1\n[branch \"zwei\"]\n\ty = 1\n\t[branch \"1 234 blabl/a\"]\nweird\nEOF\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'rename non-existing section' '\n\ttest_must_fail git config --rename-section \\\n\t\tbranch.\"world domination\" branch.drei\n'\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'rename another section' '\n\tgit config --rename-section branch.\"1 234 blabl/a\" branch.drei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"zwei\"]\n\tx = 1\n[branch \"zwei\"]\n\ty = 1\n[branch \"drei\"]\nweird\nEOF\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ncat >> .git/config << EOF\n[branch \"vier\"] z = 1\nEOF\n\ntest_expect_success 'rename a section with a var on the same line' '\n\tgit config --rename-section branch.vier branch.zwei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"zwei\"]\n\tx = 1\n[branch \"zwei\"]\n\ty = 1\n[branch \"drei\"]\nweird\n[branch \"zwei\"]\n\tz = 1\nEOF\n\ntest_expect_success 'rename succeeded' '\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'renaming empty section name is rejected' '\n\ttest_must_fail git config --rename-section branch.zwei \"\"\n'\n\ntest_expect_success 'renaming to bogus section is rejected' '\n\ttest_must_fail git config --rename-section branch.zwei \"bogus name\"\n'\n\ntest_expect_success 'renaming a section with a long line' '\n\t{\n\t\tprintf \"[b]\\\\n\" &&\n\t\tprintf \"  c = d %1024s [a] e = f\\\\n\" \" \" &&\n\t\tprintf \"[a] g = h\\\\n\"\n\t} >y &&\n\tgit config -f y --rename-section a xyz &&\n\ttest_must_fail git config -f y b.e\n'\n\ntest_expect_success 'renaming an embedded section with a long line' '\n\t{\n\t\tprintf \"[b]\\\\n\" &&\n\t\tprintf \"  c = d %1024s [a] [foo] e = f\\\\n\" \" \" &&\n\t\tprintf \"[a] g = h\\\\n\"\n\t} >y &&\n\tgit config -f y --rename-section a xyz &&\n\ttest_must_fail git config -f y foo.e\n'\n\ntest_expect_success 'renaming a section with an overly-long line' '\n\t{\n\t\tprintf \"[b]\\\\n\" &&\n\t\tprintf \"  c = d %525000s e\" \" \" &&\n\t\tprintf \"[a] g = h\\\\n\"\n\t} >y &&\n\ttest_must_fail git config -f y --rename-section a xyz 2>err &&\n\ttest_i18ngrep \"refusing to work with overly long line in .y. on line 2\" err\n'\n\ncat >> .git/config << EOF\n  [branch \"zwei\"] a = 1 [branch \"vier\"]\nEOF\n\ntest_expect_success 'remove section' '\n\tgit config --remove-section branch.zwei\n'\n\ncat > expect << EOF\n# Hallo\n\t#Bello\n[branch \"drei\"]\nweird\nEOF\n\ntest_expect_success 'section was removed properly' '\n\ttest_cmp expect .git/config\n'\n\ncat > expect << EOF\n[gitcvs]\n\tenabled = true\n\tdbname = %Ggitcvs2.%a.%m.sqlite\n[gitcvs \"ext\"]\n\tdbname = %Ggitcvs1.%a.%m.sqlite\nEOF\n\ntest_expect_success 'section ending' '\n\trm -f .git/config &&\n\tgit config gitcvs.enabled true &&\n\tgit config gitcvs.ext.dbname %Ggitcvs1.%a.%m.sqlite &&\n\tgit config gitcvs.dbname %Ggitcvs2.%a.%m.sqlite &&\n\ttest_cmp expect .git/config\n\n'\n\ntest_expect_success numbers '\n\tgit config kilo.gram 1k &&\n\tgit config mega.ton 1m &&\n\techo 1024 >expect &&\n\techo 1048576 >>expect &&\n\tgit config --int --get kilo.gram >actual &&\n\tgit config --int --get mega.ton >>actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success '--int is at least 64 bits' '\n\tgit config giga.watts 121g &&\n\techo  >expect &&\n\ttest_cmp_config 129922760704 --int --get giga.watts\n'\n\ntest_expect_success 'invalid unit' '\n\tgit config aninvalid.unit \"1auto\" &&\n\ttest_cmp_config 1auto aninvalid.unit &&\n\ttest_must_fail git config --int --get aninvalid.unit 2>actual &&\n\ttest_i18ngrep \"bad numeric config value .1auto. for .aninvalid.unit. in file .git/config: invalid unit\" actual\n'\n\ntest_expect_success 'line number is reported correctly' '\n\tprintf \"[bool]\\n\\tvar\\n\" >invalid &&\n\ttest_must_fail git config -f invalid --path bool.var 2>actual &&\n\ttest_i18ngrep \"line 2\" actual\n'\n\ntest_expect_success 'invalid stdin config' '\n\techo \"[broken\" | test_must_fail git config --list --file - >output 2>&1 &&\n\ttest_i18ngrep \"bad config line 1 in standard input\" output\n'\n\ncat > expect << EOF\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nEOF\n\ntest_expect_success bool '\n\n\tgit config bool.true1 01 &&\n\tgit config bool.true2 -1 &&\n\tgit config bool.true3 YeS &&\n\tgit config bool.true4 true &&\n\tgit config bool.false1 000 &&\n\tgit config bool.false2 \"\" &&\n\tgit config bool.false3 nO &&\n\tgit config bool.false4 FALSE &&\n\trm -f result &&\n\tfor i in 1 2 3 4\n\tdo\n\t    git config --bool --get bool.true$i >>result\n\t    git config --bool --get bool.false$i >>result\n\tdone &&\n\ttest_cmp expect result'\n\ntest_expect_success 'invalid bool (--get)' '\n\n\tgit config bool.nobool foobar &&\n\ttest_must_fail git config --bool --get bool.nobool'\n\ntest_expect_success 'invalid bool (set)' '\n\n\ttest_must_fail git config --bool bool.nobool foobar'\n\ncat > expect <<\\EOF\n[bool]\n\ttrue1 = true\n\ttrue2 = true\n\ttrue3 = true\n\ttrue4 = true\n\tfalse1 = false\n\tfalse2 = false\n\tfalse3 = false\n\tfalse4 = false\nEOF\n\ntest_expect_success 'set --bool' '\n\n\trm -f .git/config &&\n\tgit config --bool bool.true1 01 &&\n\tgit config --bool bool.true2 -1 &&\n\tgit config --bool bool.true3 YeS &&\n\tgit config --bool bool.true4 true &&\n\tgit config --bool bool.false1 000 &&\n\tgit config --bool bool.false2 \"\" &&\n\tgit config --bool bool.false3 nO &&\n\tgit config --bool bool.false4 FALSE &&\n\ttest_cmp expect .git/config'\n\ncat > expect <<\\EOF\n[int]\n\tval1 = 1\n\tval2 = -1\n\tval3 = 5242880\nEOF\n\ntest_expect_success 'set --int' '\n\n\trm -f .git/config &&\n\tgit config --int int.val1 01 &&\n\tgit config --int int.val2 -1 &&\n\tgit config --int int.val3 5m &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'get --bool-or-int' '\n\tcat >.git/config <<-\\EOF &&\n\t[bool]\n\ttrue1\n\ttrue2 = true\n\tfalse = false\n\t[int]\n\tint1 = 0\n\tint2 = 1\n\tint3 = -1\n\tEOF\n\tcat >expect <<-\\EOF &&\n\ttrue\n\ttrue\n\tfalse\n\t0\n\t1\n\t-1\n\tEOF\n\t{\n\t\tgit config --bool-or-int bool.true1 &&\n\t\tgit config --bool-or-int bool.true2 &&\n\t\tgit config --bool-or-int bool.false &&\n\t\tgit config --bool-or-int int.int1 &&\n\t\tgit config --bool-or-int int.int2 &&\n\t\tgit config --bool-or-int int.int3\n\t} >actual &&\n\ttest_cmp expect actual\n'\n\ncat >expect <<\\EOF\n[bool]\n\ttrue1 = true\n\tfalse1 = false\n\ttrue2 = true\n\tfalse2 = false\n[int]\n\tint1 = 0\n\tint2 = 1\n\tint3 = -1\nEOF\n\ntest_expect_success 'set --bool-or-int' '\n\trm -f .git/config &&\n\tgit config --bool-or-int bool.true1 true &&\n\tgit config --bool-or-int bool.false1 false &&\n\tgit config --bool-or-int bool.true2 yes &&\n\tgit config --bool-or-int bool.false2 no &&\n\tgit config --bool-or-int int.int1 0 &&\n\tgit config --bool-or-int int.int2 1 &&\n\tgit config --bool-or-int int.int3 -1 &&\n\ttest_cmp expect .git/config\n'\n\ncat >expect <<\\EOF\n[path]\n\thome = ~/\n\tnormal = /dev/null\n\ttrailingtilde = foo~\nEOF\n\ntest_expect_success !MINGW 'set --path' '\n\trm -f .git/config &&\n\tgit config --path path.home \"~/\" &&\n\tgit config --path path.normal \"/dev/null\" &&\n\tgit config --path path.trailingtilde \"foo~\" &&\n\ttest_cmp expect .git/config'\n\nif test_have_prereq !MINGW && test \"${HOME+set}\"\nthen\n\ttest_set_prereq HOMEVAR\nfi\n\ncat >expect <<EOF\n$HOME/\n/dev/null\nfoo~\nEOF\n\ntest_expect_success HOMEVAR 'get --path' '\n\tgit config --get --path path.home > result &&\n\tgit config --get --path path.normal >> result &&\n\tgit config --get --path path.trailingtilde >> result &&\n\ttest_cmp expect result\n'\n\ncat >expect <<\\EOF\n/dev/null\nfoo~\nEOF\n\ntest_expect_success !MINGW 'get --path copes with unset $HOME' '\n\t(\n\t\tsane_unset HOME &&\n\t\ttest_must_fail git config --get --path path.home \\\n\t\t\t>result 2>msg &&\n\t\tgit config --get --path path.normal >>result &&\n\t\tgit config --get --path path.trailingtilde >>result\n\t) &&\n\ttest_i18ngrep \"[Ff]ailed to expand.*~/\" msg &&\n\ttest_cmp expect result\n'\n\ntest_expect_success 'get --path barfs on boolean variable' '\n\techo \"[path]bool\" >.git/config &&\n\ttest_must_fail git config --get --path path.bool\n'\n\ntest_expect_success 'get --expiry-date' '\n\trel=\"3.weeks.5.days.00:00\" &&\n\trel_out=\"$rel ->\" &&\n\tcat >.git/config <<-\\EOF &&\n\t[date]\n\tvalid1 = \"3.weeks.5.days 00:00\"\n\tvalid2 = \"Fri Jun 4 15:46:55 2010\"\n\tvalid3 = \"2017/11/11 11:11:11PM\"\n\tvalid4 = \"2017/11/10 09:08:07 PM\"\n\tvalid5 = \"never\"\n\tinvalid1 = \"abc\"\n\tEOF\n\tcat >expect <<-EOF &&\n\t$(test-tool date timestamp $rel)\n\t1275666415\n\t1510441871\n\t1510348087\n\t0\n\tEOF\n\t: \"work around heredoc parsing bug fixed in dash 0.5.7 (in ec2c84d)\" &&\n\t{\n\t\techo \"$rel_out $(git config --expiry-date date.valid1)\"\n\t\tgit config --expiry-date date.valid2 &&\n\t\tgit config --expiry-date date.valid3 &&\n\t\tgit config --expiry-date date.valid4 &&\n\t\tgit config --expiry-date date.valid5\n\t} >actual &&\n\ttest_cmp expect actual &&\n\ttest_must_fail git config --expiry-date date.invalid1\n'\n\ntest_expect_success 'get --type=color' '\n\trm .git/config &&\n\tgit config foo.color \"red\" &&\n\tgit config --get --type=color foo.color >actual.raw &&\n\ttest_decode_color <actual.raw >actual &&\n\techo \"<RED>\" >expect &&\n\ttest_cmp expect actual\n'\n\ncat >expect << EOF\n[foo]\n\tcolor = red\nEOF\n\ntest_expect_success 'set --type=color' '\n\trm .git/config &&\n\tgit config --type=color foo.color \"red\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'get --type=color barfs on non-color' '\n\techo \"[foo]bar=not-a-color\" >.git/config &&\n\ttest_must_fail git config --get --type=color foo.bar\n'\n\ntest_expect_success 'set --type=color barfs on non-color' '\n\ttest_must_fail git config --type=color foo.color \"not-a-color\" 2>error &&\n\ttest_i18ngrep \"cannot parse color\" error\n'\n\ncat > expect << EOF\n[quote]\n\tleading = \" test\"\n\tending = \"test \"\n\tsemicolon = \"test;test\"\n\thash = \"test#test\"\nEOF\ntest_expect_success 'quoting' '\n\trm -f .git/config &&\n\tgit config quote.leading \" test\" &&\n\tgit config quote.ending \"test \" &&\n\tgit config quote.semicolon \"test;test\" &&\n\tgit config quote.hash \"test#test\" &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'key with newline' '\n\ttest_must_fail git config \"key.with\nnewline\" 123'\n\ntest_expect_success 'value with newline' 'git config key.sub value.with\\\\\\\nnewline'\n\ncat > .git/config <<\\EOF\n[section]\n\t; comment \\\n\tcontinued = cont\\\ninued\n\tnoncont   = not continued ; \\\n\tquotecont = \"cont;\\\ninued\"\nEOF\n\ncat > expect <<\\EOF\nsection.continued=continued\nsection.noncont=not continued\nsection.quotecont=cont;inued\nEOF\n\ntest_expect_success 'value continued on next line' '\n\tgit config --list > result &&\n\ttest_cmp expect result\n'\n\ncat > .git/config <<\\EOF\n[section \"sub=section\"]\n\tval1 = foo=bar\n\tval2 = foo\\nbar\n\tval3 = \\n\\n\n\tval4 =\n\tval5\nEOF\n\ncat > expect <<\\EOF\nsection.sub=section.val1\nfoo=barQsection.sub=section.val2\nfoo\nbarQsection.sub=section.val3\n\n\nQsection.sub=section.val4\nQsection.sub=section.val5Q\nEOF\ntest_expect_success '--null --list' '\n\tgit config --null --list >result.raw &&\n\tnul_to_q <result.raw >result &&\n\techo >>result &&\n\ttest_cmp expect result\n'\n\ntest_expect_success '--null --get-regexp' '\n\tgit config --null --get-regexp \"val[0-9]\" >result.raw &&\n\tnul_to_q <result.raw >result &&\n\techo >>result &&\n\ttest_cmp expect result\n'\n\ntest_expect_success 'inner whitespace kept verbatim' '\n\tgit config section.val \"foo \t  bar\" &&\n\ttest_cmp_config \"foo \t  bar\" section.val\n'\n\ntest_expect_success SYMLINKS 'symlinked configuration' '\n\tln -s notyet myconfig &&\n\tgit config --file=myconfig test.frotz nitfol &&\n\ttest -h myconfig &&\n\ttest -f notyet &&\n\ttest \"z$(git config --file=notyet test.frotz)\" = znitfol &&\n\tgit config --file=myconfig test.xyzzy rezrov &&\n\ttest -h myconfig &&\n\ttest -f notyet &&\n\tcat >expect <<-\\EOF &&\n\tnitfol\n\trezrov\n\tEOF\n\t{\n\t\tgit config --file=notyet test.frotz &&\n\t\tgit config --file=notyet test.xyzzy\n\t} >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success SYMLINKS 'symlink to nonexistent configuration' '\n\tln -s doesnotexist linktonada &&\n\tln -s linktonada linktolinktonada &&\n\ttest_must_fail git config --file=linktonada --list &&\n\ttest_must_fail git config --file=linktolinktonada --list\n'\n\ntest_expect_success 'check split_cmdline return' \"\n\tgit config alias.split-cmdline-fix 'echo \\\"' &&\n\ttest_must_fail git split-cmdline-fix &&\n\techo foo > foo &&\n\tgit add foo &&\n\tgit commit -m 'initial commit' &&\n\tgit config branch.master.mergeoptions 'echo \\\"' &&\n\ttest_must_fail git merge master\n\"\n\ntest_expect_success 'git -c \"key=value\" support' '\n\tcat >expect <<-\\EOF &&\n\tvalue\n\tvalue\n\ttrue\n\tEOF\n\t{\n\t\tgit -c section.name=value config section.name &&\n\t\tgit -c foo.CamelCase=value config foo.camelcase &&\n\t\tgit -c foo.flag config --bool foo.flag\n\t} >actual &&\n\ttest_cmp expect actual &&\n\ttest_must_fail git -c name=value config section.name\n'\n\n# We just need a type-specifier here that cares about the\n# distinction internally between a NULL boolean and a real\n# string (because most of git's internal parsers do care).\n# Using \"--path\" works, but we do not otherwise care about\n# its semantics.\ntest_expect_success 'git -c can represent empty string' '\n\techo >expect &&\n\tgit -c foo.empty= config --path foo.empty >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'key sanity-checking' '\n\ttest_must_fail git config foo=bar &&\n\ttest_must_fail git config foo=.bar &&\n\ttest_must_fail git config foo.ba=r &&\n\ttest_must_fail git config foo.1bar &&\n\ttest_must_fail git config foo.\"ba\n\t\t\t\tz\".bar &&\n\ttest_must_fail git config . false &&\n\ttest_must_fail git config .foo false &&\n\ttest_must_fail git config foo. false &&\n\ttest_must_fail git config .foo. false &&\n\tgit config foo.bar true &&\n\tgit config foo.\"ba =z\".bar false\n'\n\ntest_expect_success 'git -c works with aliases of builtins' '\n\tgit config alias.checkconfig \"-c foo.check=bar config foo.check\" &&\n\techo bar >expect &&\n\tgit checkconfig >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'aliases can be CamelCased' '\n\ttest_config alias.CamelCased \"rev-parse HEAD\" &&\n\tgit CamelCased >out &&\n\tgit rev-parse HEAD >expect &&\n\ttest_cmp expect out\n'\n\ntest_expect_success 'git -c does not split values on equals' '\n\techo \"value with = in it\" >expect &&\n\tgit -c section.foo=\"value with = in it\" config section.foo >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'git -c dies on bogus config' '\n\ttest_must_fail git -c core.bare=foo rev-parse\n'\n\ntest_expect_success 'git -c complains about empty key' '\n\ttest_must_fail git -c \"=foo\" rev-parse\n'\n\ntest_expect_success 'git -c complains about empty key and value' '\n\ttest_must_fail git -c \"\" rev-parse\n'\n\ntest_expect_success 'multiple git -c appends config' '\n\ttest_config alias.x \"!git -c x.two=2 config --get-regexp ^x\\.*\" &&\n\tcat >expect <<-\\EOF &&\n\tx.one 1\n\tx.two 2\n\tEOF\n\tgit -c x.one=1 x >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'last one wins: two level vars' '\n\n\t# sec.var and sec.VAR are the same variable, as the first\n\t# and the last level of a configuration variable name is\n\t# case insensitive.\n\n\techo VAL >expect &&\n\n\tgit -c sec.var=val -c sec.VAR=VAL config --get sec.var >actual &&\n\ttest_cmp expect actual &&\n\tgit -c SEC.var=val -c sec.var=VAL config --get sec.var >actual &&\n\ttest_cmp expect actual &&\n\n\tgit -c sec.var=val -c sec.VAR=VAL config --get SEC.var >actual &&\n\ttest_cmp expect actual &&\n\tgit -c SEC.var=val -c sec.var=VAL config --get sec.VAR >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'last one wins: three level vars' '\n\n\t# v.a.r and v.A.r are not the same variable, as the middle\n\t# level of a three-level configuration variable name is\n\t# case sensitive.\n\n\techo val >expect &&\n\tgit -c v.a.r=val -c v.A.r=VAL config --get v.a.r >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c v.A.r=VAL config --get V.a.R >actual &&\n\ttest_cmp expect actual &&\n\n\t# v.a.r and V.a.R are the same variable, as the first\n\t# and the last level of a configuration variable name is\n\t# case insensitive.\n\n\techo VAL >expect &&\n\tgit -c v.a.r=val -c v.a.R=VAL config --get v.a.r >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c V.a.r=VAL config --get v.a.r >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c v.a.R=VAL config --get V.a.R >actual &&\n\ttest_cmp expect actual &&\n\tgit -c v.a.r=val -c V.a.r=VAL config --get V.a.R >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'old-fashioned settings are case insensitive' '\n\ttest_when_finished \"rm -f testConfig testConfig_expect testConfig_actual\" &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tQr = value2\n\tEOF\n\tgit config -f testConfig_actual \"v.a.r\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tQR = value2\n\tEOF\n\tgit config -f testConfig_actual \"V.a.R\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tr = value1\n\tQr = value2\n\tEOF\n\tgit config -f testConfig_actual \"V.A.r\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V.A]\n\tr = value1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V.A]\n\tr = value1\n\tQr = value2\n\tEOF\n\tgit config -f testConfig_actual \"v.A.r\" value2 &&\n\ttest_cmp testConfig_expect testConfig_actual\n'\n\ntest_expect_success 'setting different case sensitive subsections ' '\n\ttest_when_finished \"rm -f testConfig testConfig_expect testConfig_actual\" &&\n\n\tcat >testConfig_actual <<-EOF &&\n\t[V \"A\"]\n\tR = v1\n\t[K \"E\"]\n\tY = v1\n\t[a \"b\"]\n\tc = v1\n\t[d \"e\"]\n\tf = v1\n\tEOF\n\tq_to_tab >testConfig_expect <<-EOF &&\n\t[V \"A\"]\n\tQr = v2\n\t[K \"E\"]\n\tQy = v2\n\t[a \"b\"]\n\tQc = v2\n\t[d \"e\"]\n\tf = v1\n\t[d \"E\"]\n\tQf = v2\n\tEOF\n\t# exact match\n\tgit config -f testConfig_actual a.b.c v2 &&\n\t# match section and subsection, key is cased differently.\n\tgit config -f testConfig_actual K.E.y v2 &&\n\t# section and key are matched case insensitive, but subsection needs\n\t# to match; When writing out new values only the key is adjusted\n\tgit config -f testConfig_actual v.A.r v2 &&\n\t# subsection is not matched:\n\tgit config -f testConfig_actual d.E.f v2 &&\n\ttest_cmp testConfig_expect testConfig_actual\n'\n\nfor VAR in a .a a. a.0b a.\"b c\". a.\"b c\".0d\ndo\n\ttest_expect_success \"git -c $VAR=VAL rejects invalid '$VAR'\" '\n\t\ttest_must_fail git -c \"$VAR=VAL\" config -l\n\t'\ndone\n\nfor VAR in a.b a.\"b c\".d\ndo\n\ttest_expect_success \"git -c $VAR=VAL works with valid '$VAR'\" '\n\t\techo VAL >expect &&\n\t\tgit -c \"$VAR=VAL\" config --get \"$VAR\" >actual &&\n\t\ttest_cmp expect actual\n\t'\ndone\n\ntest_expect_success 'git -c is not confused by empty environment' '\n\tGIT_CONFIG_PARAMETERS=\"\" git -c x.one=1 config --list\n'\n\ntest_expect_success 'detect bogus GIT_CONFIG_PARAMETERS' '\n\tcat >expect <<-\\EOF &&\n\tenv.one one\n\tenv.two two\n\tEOF\n\tGIT_CONFIG_PARAMETERS=\"${SQ}env.one=one${SQ} ${SQ}env.two=two${SQ}\" \\\n\t\tgit config --get-regexp \"env.*\" >actual &&\n\ttest_cmp expect actual &&\n\n\tcat >expect <<-EOF &&\n\tenv.one one${SQ}\n\tenv.two two\n\tEOF\n\tGIT_CONFIG_PARAMETERS=\"${SQ}env.one=one${SQ}\\\\$SQ$SQ$SQ ${SQ}env.two=two${SQ}\" \\\n\t\tgit config --get-regexp \"env.*\" >actual &&\n\ttest_cmp expect actual &&\n\n\ttest_must_fail env \\\n\t\tGIT_CONFIG_PARAMETERS=\"${SQ}env.one=one${SQ}\\\\$SQ ${SQ}env.two=two${SQ}\" \\\n\t\tgit config --get-regexp \"env.*\"\n'\n\ntest_expect_success 'git config --edit works' '\n\tgit config -f tmp test.value no &&\n\techo test.value=yes >expect &&\n\tGIT_EDITOR=\"echo [test]value=yes >\" git config -f tmp --edit &&\n\tgit config -f tmp --list >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'git config --edit respects core.editor' '\n\tgit config -f tmp test.value no &&\n\techo test.value=yes >expect &&\n\ttest_config core.editor \"echo [test]value=yes >\" &&\n\tgit config -f tmp --edit &&\n\tgit config -f tmp --list >actual &&\n\ttest_cmp expect actual\n'\n\n# malformed configuration files\ntest_expect_success 'barf on syntax error' '\n\tcat >.git/config <<-\\EOF &&\n\t# broken section line\n\t[section]\n\tkey garbage\n\tEOF\n\ttest_must_fail git config --get section.key >actual 2>error &&\n\ttest_i18ngrep \" line 3 \" error\n'\n\ntest_expect_success 'barf on incomplete section header' '\n\tcat >.git/config <<-\\EOF &&\n\t# broken section line\n\t[section\n\tkey = value\n\tEOF\n\ttest_must_fail git config --get section.key >actual 2>error &&\n\ttest_i18ngrep \" line 2 \" error\n'\n\ntest_expect_success 'barf on incomplete string' '\n\tcat >.git/config <<-\\EOF &&\n\t# broken section line\n\t[section]\n\tkey = \"value string\n\tEOF\n\ttest_must_fail git config --get section.key >actual 2>error &&\n\ttest_i18ngrep \" line 3 \" error\n'\n\ntest_expect_success 'urlmatch' '\n\tcat >.git/config <<-\\EOF &&\n\t[http]\n\t\tsslVerify\n\t[http \"https://weak.example.com\"]\n\t\tsslVerify = false\n\t\tcookieFile = /tmp/cookie.txt\n\tEOF\n\n\ttest_expect_code 1 git config --bool --get-urlmatch doesnt.exist https://good.example.com >actual &&\n\ttest_must_be_empty actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.SSLverify https://good.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo false >expect &&\n\tgit config --bool --get-urlmatch http.sslverify https://weak.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\t{\n\t\techo http.cookiefile /tmp/cookie.txt &&\n\t\techo http.sslverify false\n\t} >expect &&\n\tgit config --get-urlmatch HTTP https://weak.example.com >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'urlmatch favors more specific URLs' '\n\tcat >.git/config <<-\\EOF &&\n\t[http \"https://example.com/\"]\n\t\tcookieFile = /tmp/root.txt\n\t[http \"https://example.com/subdirectory\"]\n\t\tcookieFile = /tmp/subdirectory.txt\n\t[http \"https://user@example.com/\"]\n\t\tcookieFile = /tmp/user.txt\n\t[http \"https://averylonguser@example.com/\"]\n\t\tcookieFile = /tmp/averylonguser.txt\n\t[http \"https://preceding.example.com\"]\n\t\tcookieFile = /tmp/preceding.txt\n\t[http \"https://*.example.com\"]\n\t\tcookieFile = /tmp/wildcard.txt\n\t[http \"https://*.example.com/wildcardwithsubdomain\"]\n\t\tcookieFile = /tmp/wildcardwithsubdomain.txt\n\t[http \"https://*.example.*\"]\n\t\tcookieFile = /tmp/multiwildcard.txt\n\t[http \"https://trailing.example.com\"]\n\t\tcookieFile = /tmp/trailing.txt\n\t[http \"https://user@*.example.com/\"]\n\t\tcookieFile = /tmp/wildcardwithuser.txt\n\t[http \"https://sub.example.com/\"]\n\t\tcookieFile = /tmp/sub.txt\n\tEOF\n\n\techo http.cookiefile /tmp/root.txt >expect &&\n\tgit config --get-urlmatch HTTP https://example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/subdirectory.txt >expect &&\n\tgit config --get-urlmatch HTTP https://example.com/subdirectory >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/subdirectory.txt >expect &&\n\tgit config --get-urlmatch HTTP https://example.com/subdirectory/nested >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/user.txt >expect &&\n\tgit config --get-urlmatch HTTP https://user@example.com/ >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/subdirectory.txt >expect &&\n\tgit config --get-urlmatch HTTP https://averylonguser@example.com/subdirectory >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/preceding.txt >expect &&\n\tgit config --get-urlmatch HTTP https://preceding.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/wildcard.txt >expect &&\n\tgit config --get-urlmatch HTTP https://wildcard.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/sub.txt >expect &&\n\tgit config --get-urlmatch HTTP https://sub.example.com/wildcardwithsubdomain >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/trailing.txt >expect &&\n\tgit config --get-urlmatch HTTP https://trailing.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/sub.txt >expect &&\n\tgit config --get-urlmatch HTTP https://user@sub.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.cookiefile /tmp/multiwildcard.txt >expect &&\n\tgit config --get-urlmatch HTTP https://wildcard.example.org >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'urlmatch with wildcard' '\n\tcat >.git/config <<-\\EOF &&\n\t[http]\n\t\tsslVerify\n\t[http \"https://*.example.com\"]\n\t\tsslVerify = false\n\t\tcookieFile = /tmp/cookie.txt\n\tEOF\n\n\ttest_expect_code 1 git config --bool --get-urlmatch doesnt.exist https://good.example.com >actual &&\n\ttest_must_be_empty actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.SSLverify https://example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.SSLverify https://good-example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo true >expect &&\n\tgit config --bool --get-urlmatch http.sslverify https://deep.nested.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo false >expect &&\n\tgit config --bool --get-urlmatch http.sslverify https://good.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\t{\n\t\techo http.cookiefile /tmp/cookie.txt &&\n\t\techo http.sslverify false\n\t} >expect &&\n\tgit config --get-urlmatch HTTP https://good.example.com >actual &&\n\ttest_cmp expect actual &&\n\n\techo http.sslverify >expect &&\n\tgit config --get-urlmatch HTTP https://more.example.com.au >actual &&\n\ttest_cmp expect actual\n'\n\n# good section hygiene\ntest_expect_success '--unset last key removes section (except if commented)' '\n\tcat >.git/config <<-\\EOF &&\n\t# some generic comment on the configuration file itself\n\t# a comment specific to this \"section\" section.\n\t[section]\n\t# some intervening lines\n\t# that should also be dropped\n\n\tkey = value\n\t# please be careful when you update the above variable\n\tEOF\n\n\tcat >expect <<-\\EOF &&\n\t# some generic comment on the configuration file itself\n\t# a comment specific to this \"section\" section.\n\t[section]\n\t# some intervening lines\n\t# that should also be dropped\n\n\t# please be careful when you update the above variable\n\tEOF\n\n\tgit config --unset section.key &&\n\ttest_cmp expect .git/config &&\n\n\tcat >.git/config <<-\\EOF &&\n\t[section]\n\tkey = value\n\t[next-section]\n\tEOF\n\n\tcat >expect <<-\\EOF &&\n\t[next-section]\n\tEOF\n\n\tgit config --unset section.key &&\n\ttest_cmp expect .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = \"multiline \\\n\tQQ# with comment\"\n\t[two]\n\tkey = true\n\tEOF\n\tgit config --unset two.key &&\n\t! grep two .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = \"multiline \\\n\tQQ# with comment\"\n\t[one]\n\tkey = true\n\tEOF\n\tgit config --unset-all one.key &&\n\ttest_line_count = 0 .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = true\n\tQ# a comment not at the start\n\t[two]\n\tQkey = true\n\tEOF\n\tgit config --unset two.key &&\n\tgrep two .git/config &&\n\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[one]\n\tQkey = not [two \"subsection\"]\n\t[two \"subsection\"]\n\t[two \"subsection\"]\n\tQkey = true\n\t[TWO \"subsection\"]\n\t[one]\n\tEOF\n\tgit config --unset two.subsection.key &&\n\ttest \"not [two subsection]\" = \"$(git config one.key)\" &&\n\ttest_line_count = 3 .git/config\n'\n\ntest_expect_success '--unset-all removes section if empty & uncommented' '\n\tcat >.git/config <<-\\EOF &&\n\t[section]\n\tkey = value1\n\tkey = value2\n\tEOF\n\n\tgit config --unset-all section.key &&\n\ttest_line_count = 0 .git/config\n'\n\ntest_expect_success 'adding a key into an empty section reuses header' '\n\tcat >.git/config <<-\\EOF &&\n\t[section]\n\tEOF\n\n\tq_to_tab >expect <<-\\EOF &&\n\t[section]\n\tQkey = value\n\tEOF\n\n\tgit config section.key value &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success POSIXPERM,PERL 'preserves existing permissions' '\n\tchmod 0600 .git/config &&\n\tgit config imap.pass Hunter2 &&\n\tperl -e \\\n\t  \"die q(badset) if ((stat(q(.git/config)))[2] & 07777) != 0600\" &&\n\tgit config --rename-section imap pop &&\n\tperl -e \\\n\t  \"die q(badrename) if ((stat(q(.git/config)))[2] & 07777) != 0600\"\n'\n\n! test_have_prereq MINGW ||\nHOME=\"$(pwd)\" # convert to Windows path\n\ntest_expect_success 'set up --show-origin tests' '\n\tINCLUDE_DIR=\"$HOME/include\" &&\n\tmkdir -p \"$INCLUDE_DIR\" &&\n\tcat >\"$INCLUDE_DIR\"/absolute.include <<-\\EOF &&\n\t[user]\n\t\tabsolute = include\n\tEOF\n\tcat >\"$INCLUDE_DIR\"/relative.include <<-\\EOF &&\n\t[user]\n\t\trelative = include\n\tEOF\n\tcat >\"$HOME\"/.gitconfig <<-EOF &&\n\t[user]\n\t\tglobal = true\n\t\toverride = global\n\t[include]\n\t\tpath = \"$INCLUDE_DIR/absolute.include\"\n\tEOF\n\tcat >.git/config <<-\\EOF\n\t[user]\n\t\tlocal = true\n\t\toverride = local\n\t[include]\n\t\tpath = ../include/relative.include\n\tEOF\n'\n\ntest_expect_success '--show-origin with --list' '\n\tcat >expect <<-EOF &&\n\tfile:$HOME/.gitconfig\tuser.global=true\n\tfile:$HOME/.gitconfig\tuser.override=global\n\tfile:$HOME/.gitconfig\tinclude.path=$INCLUDE_DIR/absolute.include\n\tfile:$INCLUDE_DIR/absolute.include\tuser.absolute=include\n\tfile:.git/config\tuser.local=true\n\tfile:.git/config\tuser.override=local\n\tfile:.git/config\tinclude.path=../include/relative.include\n\tfile:.git/../include/relative.include\tuser.relative=include\n\tcommand line:\tuser.cmdline=true\n\tEOF\n\tgit -c user.cmdline=true config --list --show-origin >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin with --list --null' '\n\tcat >expect <<-EOF &&\n\tfile:$HOME/.gitconfigQuser.global\n\ttrueQfile:$HOME/.gitconfigQuser.override\n\tglobalQfile:$HOME/.gitconfigQinclude.path\n\t$INCLUDE_DIR/absolute.includeQfile:$INCLUDE_DIR/absolute.includeQuser.absolute\n\tincludeQfile:.git/configQuser.local\n\ttrueQfile:.git/configQuser.override\n\tlocalQfile:.git/configQinclude.path\n\t../include/relative.includeQfile:.git/../include/relative.includeQuser.relative\n\tincludeQcommand line:Quser.cmdline\n\ttrueQ\n\tEOF\n\tgit -c user.cmdline=true config --null --list --show-origin >output.raw &&\n\tnul_to_q <output.raw >output &&\n\t# The here-doc above adds a newline that the --null output would not\n\t# include. Add it here to make the two comparable.\n\techo >>output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin with single file' '\n\tcat >expect <<-\\EOF &&\n\tfile:.git/config\tuser.local=true\n\tfile:.git/config\tuser.override=local\n\tfile:.git/config\tinclude.path=../include/relative.include\n\tEOF\n\tgit config --local --list --show-origin >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin with --get-regexp' '\n\tcat >expect <<-EOF &&\n\tfile:$HOME/.gitconfig\tuser.global true\n\tfile:.git/config\tuser.local true\n\tEOF\n\tgit config --show-origin --get-regexp \"user\\.[g|l].*\" >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin getting a single key' '\n\tcat >expect <<-\\EOF &&\n\tfile:.git/config\tlocal\n\tEOF\n\tgit config --show-origin user.override >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success 'set up custom config file' '\n\tCUSTOM_CONFIG_FILE=\"custom.conf\" &&\n\tcat >\"$CUSTOM_CONFIG_FILE\" <<-\\EOF\n\t[user]\n\t\tcustom = true\n\tEOF\n'\n\ntest_expect_success !MINGW 'set up custom config file with special name characters' '\n\tWEIRDLY_NAMED_FILE=\"file\\\" (dq) and spaces.conf\" &&\n\tcp \"$CUSTOM_CONFIG_FILE\" \"$WEIRDLY_NAMED_FILE\"\n'\n\ntest_expect_success !MINGW '--show-origin escape special file name characters' '\n\tcat >expect <<-\\EOF &&\n\tfile:\"file\\\" (dq) and spaces.conf\"\tuser.custom=true\n\tEOF\n\tgit config --file \"$WEIRDLY_NAMED_FILE\" --show-origin --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin stdin' '\n\tcat >expect <<-\\EOF &&\n\tstandard input:\tuser.custom=true\n\tEOF\n\tgit config --file - --show-origin --list <\"$CUSTOM_CONFIG_FILE\" >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin stdin with file include' '\n\tcat >\"$INCLUDE_DIR\"/stdin.include <<-EOF &&\n\t[user]\n\t\tstdin = include\n\tEOF\n\tcat >expect <<-EOF &&\n\tfile:$INCLUDE_DIR/stdin.include\tinclude\n\tEOF\n\techo \"[include]path=\\\"$INCLUDE_DIR\\\"/stdin.include\" |\n\tgit config --show-origin --includes --file - user.stdin >output &&\n\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin blob' '\n\tblob=$(git hash-object -w \"$CUSTOM_CONFIG_FILE\") &&\n\tcat >expect <<-EOF &&\n\tblob:$blob\tuser.custom=true\n\tEOF\n\tgit config --blob=$blob --show-origin --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-origin blob ref' '\n\tcat >expect <<-\\EOF &&\n\tblob:master:custom.conf\tuser.custom=true\n\tEOF\n\tgit add \"$CUSTOM_CONFIG_FILE\" &&\n\tgit commit -m \"new config file\" &&\n\tgit config --blob=master:\"$CUSTOM_CONFIG_FILE\" --show-origin --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope with --list' '\n\tcat >expect <<-EOF &&\n\tglobal\tuser.global=true\n\tglobal\tuser.override=global\n\tglobal\tinclude.path=$INCLUDE_DIR/absolute.include\n\tglobal\tuser.absolute=include\n\tlocal\tuser.local=true\n\tlocal\tuser.override=local\n\tlocal\tinclude.path=../include/relative.include\n\tlocal\tuser.relative=include\n\tcommand\tuser.cmdline=true\n\tEOF\n\tgit -c user.cmdline=true config --list --show-scope >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success !MINGW '--show-scope with --blob' '\n\tblob=$(git hash-object -w \"$CUSTOM_CONFIG_FILE\") &&\n\tcat >expect <<-EOF &&\n\tcommand\tuser.custom=true\n\tEOF\n\tgit config --blob=$blob --show-scope --list >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope with --local' '\n\tcat >expect <<-\\EOF &&\n\tlocal\tuser.local=true\n\tlocal\tuser.override=local\n\tlocal\tinclude.path=../include/relative.include\n\tEOF\n\tgit config --local --list --show-scope >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope getting a single value' '\n\tcat >expect <<-\\EOF &&\n\tlocal\ttrue\n\tEOF\n\tgit config --show-scope --get user.local >output &&\n\ttest_cmp expect output\n'\n\ntest_expect_success '--show-scope with --show-origin' '\n\tcat >expect <<-EOF &&\n\tglobal\tfile:$HOME/.gitconfig\tuser.global=true\n\tglobal\tfile:$HOME/.gitconfig\tuser.override=global\n\tglobal\tfile:$HOME/.gitconfig\tinclude.path=$INCLUDE_DIR/absolute.include\n\tglobal\tfile:$INCLUDE_DIR/absolute.include\tuser.absolute=include\n\tlocal\tfile:.git/config\tuser.local=true\n\tlocal\tfile:.git/config\tuser.override=local\n\tlocal\tfile:.git/config\tinclude.path=../include/relative.include\n\tlocal\tfile:.git/../include/relative.include\tuser.relative=include\n\tcommand\tcommand line:\tuser.cmdline=true\n\tEOF\n\tgit -c user.cmdline=true config --list --show-origin --show-scope >output &&\n\ttest_cmp expect output\n'\n\nfor opt in --local --worktree\ndo\n\ttest_expect_success \"$opt requires a repo\" '\n\t\t# we expect 128 to ensure that we do not simply\n\t\t# fail to find anything and return code \"1\"\n\t\ttest_expect_code 128 nongit git config $opt foo.bar\n\t'\ndone\n\ncat >.git/config <<-\\EOF &&\n[section]\nfoo = true\nnumber = 10\nbig = 1M\nEOF\n\ntest_expect_success 'identical modern --type specifiers are allowed' '\n\ttest_cmp_config 1048576 --type=int --type=int section.big\n'\n\ntest_expect_success 'identical legacy --type specifiers are allowed' '\n\ttest_cmp_config 1048576 --int --int section.big\n'\n\ntest_expect_success 'identical mixed --type specifiers are allowed' '\n\ttest_cmp_config 1048576 --int --type=int section.big\n'\n\ntest_expect_success 'non-identical modern --type specifiers are not allowed' '\n\ttest_must_fail git config --type=int --type=bool section.big 2>error &&\n\ttest_i18ngrep \"only one type at a time\" error\n'\n\ntest_expect_success 'non-identical legacy --type specifiers are not allowed' '\n\ttest_must_fail git config --int --bool section.big 2>error &&\n\ttest_i18ngrep \"only one type at a time\" error\n'\n\ntest_expect_success 'non-identical mixed --type specifiers are not allowed' '\n\ttest_must_fail git config --type=int --bool section.big 2>error &&\n\ttest_i18ngrep \"only one type at a time\" error\n'\n\ntest_expect_success '--type allows valid type specifiers' '\n\ttest_cmp_config true  --type=bool section.foo\n'\n\ntest_expect_success '--no-type unsets type specifiers' '\n\ttest_cmp_config 10 --type=bool --no-type section.number\n'\n\ntest_expect_success 'unset type specifiers may be reset to conflicting ones' '\n\ttest_cmp_config 1048576 --type=bool --no-type --type=int section.big\n'\n\ntest_expect_success '--type rejects unknown specifiers' '\n\ttest_must_fail git config --type=nonsense section.foo 2>error &&\n\ttest_i18ngrep \"unrecognized --type argument\" error\n'\n\ntest_expect_success '--replace-all does not invent newlines' '\n\tq_to_tab >.git/config <<-\\EOF &&\n\t[abc]key\n\tQkeepSection\n\t[xyz]\n\tQkey = 1\n\t[abc]\n\tQkey = a\n\tEOF\n\tq_to_tab >expect <<-\\EOF &&\n\t[abc]\n\tQkeepSection\n\t[xyz]\n\tQkey = 1\n\t[abc]\n\tQkey = b\n\tEOF\n\tgit config --replace-all abc.key b &&\n\ttest_cmp expect .git/config\n'\n\ntest_expect_success 'set all config with value-pattern' '\n\ttest_when_finished rm -f config initial &&\n\tgit config --file=initial abc.key one &&\n\n\t# no match => add new entry\n\tcp initial config &&\n\tgit config --file=config abc.key two a+ &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=one\n\tabc.key=two\n\tEOF\n\ttest_cmp expect actual &&\n\n\t# multiple matches => failure\n\ttest_must_fail git config --file=config abc.key three o+ 2>err &&\n\ttest_i18ngrep \"has multiple values\" err &&\n\n\t# multiple values, no match => add\n\tgit config --file=config abc.key three a+ &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=one\n\tabc.key=two\n\tabc.key=three\n\tEOF\n\ttest_cmp expect actual &&\n\n\t# single match => replace\n\tgit config --file=config abc.key four h+ &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=one\n\tabc.key=two\n\tabc.key=four\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success '--replace-all and value-pattern' '\n\ttest_when_finished rm -f config &&\n\tgit config --file=config --add abc.key one &&\n\tgit config --file=config --add abc.key two &&\n\tgit config --file=config --add abc.key three &&\n\tgit config --file=config --replace-all abc.key four \"o+\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tabc.key=four\n\tabc.key=three\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'refuse --fixed-value for incompatible actions' '\n\ttest_when_finished rm -f config &&\n\tgit config --file=config dev.null bogus &&\n\n\t# These modes do not allow --fixed-value at all\n\ttest_must_fail git config --file=config --fixed-value --add dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --get-urlmatch dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --get-urlmatch dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --rename-section dev null &&\n\ttest_must_fail git config --file=config --fixed-value --remove-section dev &&\n\ttest_must_fail git config --file=config --fixed-value --list &&\n\ttest_must_fail git config --file=config --fixed-value --get-color dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --get-colorbool dev.null &&\n\n\t# These modes complain when --fixed-value has no value-pattern\n\ttest_must_fail git config --file=config --fixed-value dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --replace-all dev.null bogus &&\n\ttest_must_fail git config --file=config --fixed-value --get dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --get-all dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --get-regexp \"dev.*\" &&\n\ttest_must_fail git config --file=config --fixed-value --unset dev.null &&\n\ttest_must_fail git config --file=config --fixed-value --unset-all dev.null\n'\n\ntest_expect_success '--fixed-value uses exact string matching' '\n\ttest_when_finished rm -f config initial &&\n\tMETA=\"a+b*c?d[e]f.g\" &&\n\tgit config --file=initial fixed.test \"$META\" &&\n\n\tcp initial config &&\n\tgit config --file=config fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-EOF &&\n\tfixed.test=$META\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual &&\n\n\tcp initial config &&\n\tgit config --file=config --fixed-value fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-\\EOF &&\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual &&\n\n\tcp initial config &&\n\ttest_must_fail git config --file=config --unset fixed.test \"$META\" &&\n\tgit config --file=config --fixed-value --unset fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config fixed.test &&\n\n\tcp initial config &&\n\ttest_must_fail git config --file=config --unset-all fixed.test \"$META\" &&\n\tgit config --file=config --fixed-value --unset-all fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config fixed.test &&\n\n\tcp initial config &&\n\tgit config --file=config --replace-all fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-EOF &&\n\tfixed.test=$META\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual &&\n\n\tgit config --file=config --fixed-value --replace-all fixed.test bogus \"$META\" &&\n\tgit config --file=config --list >actual &&\n\tcat >expect <<-EOF &&\n\tfixed.test=bogus\n\tfixed.test=bogus\n\tEOF\n\ttest_cmp expect actual\n'\n\ntest_expect_success '--get and --get-all with --fixed-value' '\n\ttest_when_finished rm -f config &&\n\tMETA=\"a+b*c?d[e]f.g\" &&\n\tgit config --file=config fixed.test bogus &&\n\tgit config --file=config --add fixed.test \"$META\" &&\n\n\tgit config --file=config --get fixed.test bogus &&\n\ttest_must_fail git config --file=config --get fixed.test \"$META\" &&\n\tgit config --file=config --get --fixed-value fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config --get --fixed-value fixed.test non-existent &&\n\n\tgit config --file=config --get-all fixed.test bogus &&\n\ttest_must_fail git config --file=config --get-all fixed.test \"$META\" &&\n\tgit config --file=config --get-all --fixed-value fixed.test \"$META\" &&\n\ttest_must_fail git config --file=config --get-all --fixed-value fixed.test non-existent &&\n\n\tgit config --file=config --get-regexp fixed+ bogus &&\n\ttest_must_fail git config --file=config --get-regexp fixed+ \"$META\" &&\n\tgit config --file=config --get-regexp --fixed-value fixed+ \"$META\" &&\n\ttest_must_fail git config --file=config --get-regexp --fixed-value fixed+ non-existent\n'\n\ntest_done\n"], "filenames": ["config.c", "t/t1300-config.sh"], "buggy_code_start_loc": [3030, 613], "buggy_code_end_loc": [3235, 613], "fixing_code_start_loc": [3030, 614], "fixing_code_end_loc": [3250, 644], "type": "CWE-74", "message": "Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, a specially crafted `.gitmodules` file with submodule URLs that are longer than 1024 characters can used to exploit a bug in `config.c::git_config_copy_or_rename_section_in_file()`. This bug can be used to inject arbitrary configuration into a user's `$GIT_DIR/config` when attempting to remove the configuration section associated with that submodule. When the attacker injects configuration values which specify executables to run (such as `core.pager`, `core.editor`, `core.sshCommand`, etc.) this can lead to a remote code execution. A fix A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid running `git submodule deinit` on untrusted repositories or without prior inspection of any submodule sections in `$GIT_DIR/config`.", "other": {"cve": {"id": "CVE-2023-29007", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-25T21:15:10.403", "lastModified": "2023-05-12T05:15:18.117", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, a specially crafted `.gitmodules` file with submodule URLs that are longer than 1024 characters can used to exploit a bug in `config.c::git_config_copy_or_rename_section_in_file()`. This bug can be used to inject arbitrary configuration into a user's `$GIT_DIR/config` when attempting to remove the configuration section associated with that submodule. When the attacker injects configuration values which specify executables to run (such as `core.pager`, `core.editor`, `core.sshCommand`, etc.) this can lead to a remote code execution. A fix A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid running `git submodule deinit` on untrusted repositories or without prior inspection of any submodule sections in `$GIT_DIR/config`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.30.9", "matchCriteriaId": "A2E4BF99-17B8-4424-B97E-DDB8A4793DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.31.0", "versionEndExcluding": "2.31.8", "matchCriteriaId": "2A1D7F29-E06F-4277-8713-1C19DE714300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.32.0", "versionEndExcluding": "2.32.7", "matchCriteriaId": "0B69F022-B29E-4D9A-B4FC-78430AFF0C9C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.33.0", "versionEndExcluding": "2.33.8", "matchCriteriaId": "8A2B603F-B8E2-4123-80A4-64E983FF1F86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.34.0", "versionEndExcluding": "2.34.8", "matchCriteriaId": "26D3ED4E-246E-4D4D-9E2D-7890E93ECED8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.35.0", "versionEndExcluding": "2.35.8", "matchCriteriaId": "D3988013-1332-49F8-85E7-7EB59BE36A63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.36.0", "versionEndExcluding": "2.36.5", "matchCriteriaId": "0588D372-41D2-442E-976E-6B24DB1A1EC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.37.0", "versionEndExcluding": "2.37.7", "matchCriteriaId": "030542CA-76BF-4252-9E03-D7E44D3DEE19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.38.0", "versionEndExcluding": "2.38.5", "matchCriteriaId": "6EAEE109-8AD8-4383-AAC3-E9D2A4794F8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.39.0", "versionEndExcluding": "2.39.3", "matchCriteriaId": "BE329F8E-076F-4895-A2A2-A1C0330C1F6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:2.40.0:*:*:*:*:*:*:*", "matchCriteriaId": "89633B46-319A-499C-9848-2EA60AC030EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://github.com/git/git/blob/9ce9dea4e1c2419cca126d29fa7730baa078a11b/Documentation/RelNotes/2.30.9.txt", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/git/git/commit/528290f8c61222433a8cf02fb7cfffa8438432b4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/git/git/security/advisories/GHSA-v48j-4xgg-4844", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PI7FZ4NNR5S5J5K6AMVQBH2JFP6NE4L7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RKOXOAZ42HLXHXTW6JZI4L5DAIYDTYCU/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YFZWGQKB6MM5MNF2DLFTD7KS2KWPICKL/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/528290f8c61222433a8cf02fb7cfffa8438432b4"}}