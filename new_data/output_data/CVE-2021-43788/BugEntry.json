{"buggy_code": ["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst utils = require('./utils');\nconst { paths } = require('./constants');\nconst plugins = require('./plugins');\n\nconst Languages = module.exports;\nconst languagesPath = path.join(__dirname, '../build/public/language');\n\nconst files = fs.readdirSync(path.join(paths.nodeModules, '/timeago/locales'));\nLanguages.timeagoCodes = files.filter(f => f.startsWith('jquery.timeago')).map(f => f.split('.')[2]);\n\nLanguages.get = async function (language, namespace) {\n\tconst data = await fs.promises.readFile(path.join(languagesPath, language, `${namespace}.json`), 'utf8');\n\tconst parsed = JSON.parse(data) || {};\n\tconst result = await plugins.hooks.fire('filter:languages.get', {\n\t\tlanguage,\n\t\tnamespace,\n\t\tdata: parsed,\n\t});\n\treturn result.data;\n};\n\nlet codeCache = null;\nLanguages.listCodes = async function () {\n\tif (codeCache && codeCache.length) {\n\t\treturn codeCache;\n\t}\n\ttry {\n\t\tconst file = await fs.promises.readFile(path.join(languagesPath, 'metadata.json'), 'utf8');\n\t\tconst parsed = JSON.parse(file);\n\n\t\tcodeCache = parsed.languages;\n\t\treturn parsed.languages;\n\t} catch (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn [];\n\t\t}\n\t\tthrow err;\n\t}\n};\n\nlet listCache = null;\nLanguages.list = async function () {\n\tif (listCache && listCache.length) {\n\t\treturn listCache;\n\t}\n\n\tconst codes = await Languages.listCodes();\n\n\tlet languages = await Promise.all(codes.map(async (folder) => {\n\t\ttry {\n\t\t\tconst configPath = path.join(languagesPath, folder, 'language.json');\n\t\t\tconst file = await fs.promises.readFile(configPath, 'utf8');\n\t\t\tconst lang = JSON.parse(file);\n\t\t\treturn lang;\n\t\t} catch (err) {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}));\n\n\t// filter out invalid ones\n\tlanguages = languages.filter(lang => lang && lang.code && lang.name && lang.dir);\n\n\tlistCache = languages;\n\treturn languages;\n};\n\nLanguages.userTimeagoCode = async function (userLang) {\n\tconst languageCodes = await Languages.listCodes();\n\tconst timeagoCode = utils.userLangToTimeagoCode(userLang);\n\tif (languageCodes.includes(userLang) && Languages.timeagoCodes.includes(timeagoCode)) {\n\t\treturn timeagoCode;\n\t}\n\treturn '';\n};\n\nrequire('./promisify')(Languages);\n", "'use strict';\n\n\nconst\tassert = require('assert');\nconst async = require('async');\nconst request = require('request');\nconst nconf = require('nconf');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\n\nconst db = require('./mocks/databasemock');\nconst topics = require('../src/topics');\nconst posts = require('../src/posts');\nconst categories = require('../src/categories');\nconst privileges = require('../src/privileges');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst socketPosts = require('../src/socket.io/posts');\nconst socketTopics = require('../src/socket.io/topics');\nconst meta = require('../src/meta');\nconst helpers = require('./helpers');\n\ndescribe('Post\\'s', () => {\n\tlet voterUid;\n\tlet voteeUid;\n\tlet globalModUid;\n\tlet postData;\n\tlet topicData;\n\tlet cid;\n\n\tbefore((done) => {\n\t\tasync.series({\n\t\t\tvoterUid: function (next) {\n\t\t\t\tuser.create({ username: 'upvoter' }, next);\n\t\t\t},\n\t\t\tvoteeUid: function (next) {\n\t\t\t\tuser.create({ username: 'upvotee' }, next);\n\t\t\t},\n\t\t\tglobalModUid: function (next) {\n\t\t\t\tuser.create({ username: 'globalmod', password: 'globalmodpwd' }, next);\n\t\t\t},\n\t\t\tcategory: function (next) {\n\t\t\t\tcategories.create({\n\t\t\t\t\tname: 'Test Category',\n\t\t\t\t\tdescription: 'Test category created by testing script',\n\t\t\t\t}, next);\n\t\t\t},\n\t\t}, (err, results) => {\n\t\t\tif (err) {\n\t\t\t\treturn done(err);\n\t\t\t}\n\n\t\t\tvoterUid = results.voterUid;\n\t\t\tvoteeUid = results.voteeUid;\n\t\t\tglobalModUid = results.globalModUid;\n\t\t\tcid = results.category.cid;\n\n\t\t\ttopics.post({\n\t\t\t\tuid: results.voteeUid,\n\t\t\t\tcid: results.category.cid,\n\t\t\t\ttitle: 'Test Topic Title',\n\t\t\t\tcontent: 'The content of test topic',\n\t\t\t}, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn done(err);\n\t\t\t\t}\n\t\t\t\tpostData = data.postData;\n\t\t\t\ttopicData = data.topicData;\n\n\t\t\t\tgroups.join('Global Moderators', globalModUid, done);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should update category teaser properly', async () => {\n\t\tconst util = require('util');\n\t\tconst getCategoriesAsync = util.promisify(async (callback) => {\n\t\t\trequest(`${nconf.get('url')}/api/categories`, { json: true }, (err, res, body) => {\n\t\t\t\tcallback(err, body);\n\t\t\t});\n\t\t});\n\n\t\tconst postResult = await topics.post({ uid: globalModUid, cid: cid, title: 'topic title', content: '123456789' });\n\n\t\tlet data = await getCategoriesAsync();\n\t\tassert.equal(data.categories[0].teaser.pid, postResult.postData.pid);\n\t\tassert.equal(data.categories[0].posts[0].content, '123456789');\n\t\tassert.equal(data.categories[0].posts[0].pid, postResult.postData.pid);\n\n\t\tconst newUid = await user.create({ username: 'teaserdelete' });\n\t\tconst newPostResult = await topics.post({ uid: newUid, cid: cid, title: 'topic title', content: 'xxxxxxxx' });\n\n\t\tdata = await getCategoriesAsync();\n\t\tassert.equal(data.categories[0].teaser.pid, newPostResult.postData.pid);\n\t\tassert.equal(data.categories[0].posts[0].content, 'xxxxxxxx');\n\t\tassert.equal(data.categories[0].posts[0].pid, newPostResult.postData.pid);\n\n\t\tawait user.delete(1, newUid);\n\n\t\tdata = await getCategoriesAsync();\n\t\tassert.equal(data.categories[0].teaser.pid, postResult.postData.pid);\n\t\tassert.equal(data.categories[0].posts[0].content, '123456789');\n\t\tassert.equal(data.categories[0].posts[0].pid, postResult.postData.pid);\n\t});\n\n\tit('should change owner of post and topic properly', async () => {\n\t\tconst oldUid = await user.create({ username: 'olduser' });\n\t\tconst newUid = await user.create({ username: 'newuser' });\n\t\tconst postResult = await topics.post({ uid: oldUid, cid: cid, title: 'change owner', content: 'original post' });\n\t\tconst postData = await topics.reply({ uid: oldUid, tid: postResult.topicData.tid, content: 'firstReply' });\n\t\tconst pid1 = postResult.postData.pid;\n\t\tconst pid2 = postData.pid;\n\n\t\tassert.deepStrictEqual(await db.sortedSetScores(`tid:${postResult.topicData.tid}:posters`, [oldUid, newUid]), [2, null]);\n\n\t\tawait posts.changeOwner([pid1, pid2], newUid);\n\n\t\tassert.deepStrictEqual(await db.sortedSetScores(`tid:${postResult.topicData.tid}:posters`, [oldUid, newUid]), [0, 2]);\n\n\t\tassert.deepStrictEqual(await posts.isOwner([pid1, pid2], oldUid), [false, false]);\n\t\tassert.deepStrictEqual(await posts.isOwner([pid1, pid2], newUid), [true, true]);\n\n\t\tassert.strictEqual(await user.getUserField(oldUid, 'postcount'), 0);\n\t\tassert.strictEqual(await user.getUserField(newUid, 'postcount'), 2);\n\n\t\tassert.strictEqual(await user.getUserField(oldUid, 'topiccount'), 0);\n\t\tassert.strictEqual(await user.getUserField(newUid, 'topiccount'), 1);\n\n\t\tassert.strictEqual(await db.sortedSetScore('users:postcount', oldUid), 0);\n\t\tassert.strictEqual(await db.sortedSetScore('users:postcount', newUid), 2);\n\n\t\tassert.strictEqual(await topics.isOwner(postResult.topicData.tid, oldUid), false);\n\t\tassert.strictEqual(await topics.isOwner(postResult.topicData.tid, newUid), true);\n\t});\n\n\tit('should fail to change owner if new owner does not exist', async () => {\n\t\ttry {\n\t\t\tawait posts.changeOwner([1], '9999999');\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:no-user]]');\n\t\t}\n\t});\n\n\tit('should fail to change owner if user is not authorized', async () => {\n\t\ttry {\n\t\t\tawait socketPosts.changeOwner({ uid: voterUid }, { pids: [1, 2], toUid: voterUid });\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:no-privileges]]');\n\t\t}\n\t});\n\n\tit('should return falsy if post does not exist', (done) => {\n\t\tposts.getPostData(9999, (err, postData) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(postData, null);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('voting', () => {\n\t\tit('should fail to upvote post if group does not have upvote permission', (done) => {\n\t\t\tprivileges.categories.rescind(['groups:posts:upvote', 'groups:posts:downvote'], cid, 'registered-users', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.upvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\t\tsocketPosts.downvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err) => {\n\t\t\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\t\t\tprivileges.categories.give(['groups:posts:upvote', 'groups:posts:downvote'], cid, 'registered-users', (err) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should upvote a post', (done) => {\n\t\t\tsocketPosts.upvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(result.post.upvotes, 1);\n\t\t\t\tassert.equal(result.post.downvotes, 0);\n\t\t\t\tassert.equal(result.post.votes, 1);\n\t\t\t\tassert.equal(result.user.reputation, 1);\n\t\t\t\tposts.hasVoted(postData.pid, voterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.upvoted, true);\n\t\t\t\t\tassert.equal(data.downvoted, false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should get voters', (done) => {\n\t\t\tsocketPosts.getVoters({ uid: globalModUid }, { pid: postData.pid, cid: cid }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.upvoteCount, 1);\n\t\t\t\tassert.equal(data.downvoteCount, 0);\n\t\t\t\tassert(Array.isArray(data.upvoters));\n\t\t\t\tassert.equal(data.upvoters[0].username, 'upvoter');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get upvoters', (done) => {\n\t\t\tsocketPosts.getUpvoters({ uid: globalModUid }, [postData.pid], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data[0].otherCount, 0);\n\t\t\t\tassert.equal(data[0].usernames, 'upvoter');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should unvote a post', (done) => {\n\t\t\tsocketPosts.unvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(result.post.upvotes, 0);\n\t\t\t\tassert.equal(result.post.downvotes, 0);\n\t\t\t\tassert.equal(result.post.votes, 0);\n\t\t\t\tassert.equal(result.user.reputation, 0);\n\t\t\t\tposts.hasVoted(postData.pid, voterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.upvoted, false);\n\t\t\t\t\tassert.equal(data.downvoted, false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should downvote a post', (done) => {\n\t\t\tsocketPosts.downvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(result.post.upvotes, 0);\n\t\t\t\tassert.equal(result.post.downvotes, 1);\n\t\t\t\tassert.equal(result.post.votes, -1);\n\t\t\t\tassert.equal(result.user.reputation, -1);\n\t\t\t\tposts.hasVoted(postData.pid, voterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.upvoted, false);\n\t\t\t\t\tassert.equal(data.downvoted, true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should prevent downvoting more than total daily limit', async () => {\n\t\t\tconst oldValue = meta.config.downvotesPerDay;\n\t\t\tmeta.config.downvotesPerDay = 1;\n\t\t\tlet err;\n\t\t\tconst p1 = await topics.reply({\n\t\t\t\tuid: voteeUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\tcontent: 'raw content',\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tawait socketPosts.downvote({ uid: voterUid }, { pid: p1.pid, room_id: 'topic_1' });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.equal(err.message, '[[error:too-many-downvotes-today, 1]]');\n\t\t\tmeta.config.downvotesPerDay = oldValue;\n\t\t});\n\n\t\tit('should prevent downvoting target user more than total daily limit', async () => {\n\t\t\tconst oldValue = meta.config.downvotesPerUserPerDay;\n\t\t\tmeta.config.downvotesPerUserPerDay = 1;\n\t\t\tlet err;\n\t\t\tconst p1 = await topics.reply({\n\t\t\t\tuid: voteeUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\tcontent: 'raw content',\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tawait socketPosts.downvote({ uid: voterUid }, { pid: p1.pid, room_id: 'topic_1' });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.equal(err.message, '[[error:too-many-downvotes-today-user, 1]]');\n\t\t\tmeta.config.downvotesPerUserPerDay = oldValue;\n\t\t});\n\t});\n\n\tdescribe('bookmarking', () => {\n\t\tit('should bookmark a post', (done) => {\n\t\t\tsocketPosts.bookmark({ uid: voterUid }, { pid: postData.pid, room_id: `topic_${postData.tid}` }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.isBookmarked, true);\n\t\t\t\tposts.hasBookmarked(postData.pid, voterUid, (err, hasBookmarked) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(hasBookmarked, true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should unbookmark a post', (done) => {\n\t\t\tsocketPosts.unbookmark({ uid: voterUid }, { pid: postData.pid, room_id: `topic_${postData.tid}` }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.isBookmarked, false);\n\t\t\t\tposts.hasBookmarked([postData.pid], voterUid, (err, hasBookmarked) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(hasBookmarked[0], false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('post tools', () => {\n\t\tit('should error if data is invalid', (done) => {\n\t\t\tsocketPosts.loadPostTools({ uid: globalModUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load post tools', (done) => {\n\t\t\tsocketPosts.loadPostTools({ uid: globalModUid }, { pid: postData.pid, cid: cid }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data.posts.display_edit_tools);\n\t\t\t\tassert(data.posts.display_delete_tools);\n\t\t\t\tassert(data.posts.display_moderator_tools);\n\t\t\t\tassert(data.posts.display_move_tools);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('delete/restore/purge', () => {\n\t\tfunction createTopicWithReply(callback) {\n\t\t\ttopics.post({\n\t\t\t\tuid: voterUid,\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'topic to delete/restore/purge',\n\t\t\t\tcontent: 'A post to delete/restore/purge',\n\t\t\t}, (err, topicPostData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttopics.reply({\n\t\t\t\t\tuid: voterUid,\n\t\t\t\t\ttid: topicPostData.topicData.tid,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\tcontent: 'A post to delete/restore and purge',\n\t\t\t\t}, (err, replyData) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tcallback(topicPostData, replyData);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tlet tid;\n\t\tlet mainPid;\n\t\tlet replyPid;\n\n\t\tbefore((done) => {\n\t\t\tcreateTopicWithReply((topicPostData, replyData) => {\n\t\t\t\ttid = topicPostData.topicData.tid;\n\t\t\t\tmainPid = topicPostData.postData.pid;\n\t\t\t\treplyPid = replyData.pid;\n\t\t\t\tprivileges.categories.give(['groups:purge'], cid, 'registered-users', done);\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\tsocketPosts.delete({ uid: voterUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should delete a post', (done) => {\n\t\t\tsocketPosts.delete({ uid: voterUid }, { pid: replyPid, tid: tid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'deleted', (err, isDeleted) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(isDeleted, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not see post content if global mod does not have posts:view_deleted privilege', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tuser.create({ username: 'global mod', password: '123456' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tgroups.join('Global Moderators', uid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tprivileges.categories.rescind(['groups:posts:view_deleted'], cid, 'Global Moderators', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\thelpers.loginUser('global mod', '123456', (err, _jar) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tconst jar = _jar;\n\n\t\t\t\t\t\trequest(`${nconf.get('url')}/api/topic/${tid}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(body.posts[1].content, '[[topic:post_is_deleted]]');\n\t\t\t\t\t\t\tprivileges.categories.give(['groups:posts:view_deleted'], cid, 'Global Moderators', next);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should restore a post', (done) => {\n\t\t\tsocketPosts.restore({ uid: voterUid }, { pid: replyPid, tid: tid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'deleted', (err, isDeleted) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(isDeleted, 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should delete posts', (done) => {\n\t\t\tsocketPosts.deletePosts({ uid: globalModUid }, { pids: [replyPid, mainPid] }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'deleted', (err, deleted) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(deleted, 1);\n\t\t\t\t\tposts.getPostField(mainPid, 'deleted', (err, deleted) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(deleted, 1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should delete topic if last main post is deleted', (done) => {\n\t\t\ttopics.post({ uid: voterUid, cid: cid, title: 'test topic', content: 'test topic' }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.deletePosts({ uid: globalModUid }, { pids: [data.postData.pid] }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\ttopics.getTopicField(data.topicData.tid, 'deleted', (err, deleted) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(deleted, 1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should purge posts and purge topic', (done) => {\n\t\t\tcreateTopicWithReply((topicPostData, replyData) => {\n\t\t\t\tsocketPosts.purgePosts({ uid: voterUid }, {\n\t\t\t\t\tpids: [replyData.pid, topicPostData.postData.pid],\n\t\t\t\t\ttid: topicPostData.topicData.tid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tposts.exists(`post:${replyData.pid}`, (err, exists) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(exists, false);\n\t\t\t\t\t\ttopics.exists(topicPostData.topicData.tid, (err, exists) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert(!exists);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('edit', () => {\n\t\tlet pid;\n\t\tlet replyPid;\n\t\tlet tid;\n\t\tbefore((done) => {\n\t\t\ttopics.post({\n\t\t\t\tuid: voterUid,\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'topic to edit',\n\t\t\t\tcontent: 'A post to edit',\n\t\t\t}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tpid = data.postData.pid;\n\t\t\t\ttid = data.topicData.tid;\n\t\t\t\ttopics.reply({\n\t\t\t\t\tuid: voterUid,\n\t\t\t\t\ttid: tid,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\tcontent: 'A reply to edit',\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\treplyPid = data.pid;\n\t\t\t\t\tprivileges.categories.give(['groups:posts:edit'], cid, 'registered-users', done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if user is not logged in', (done) => {\n\t\t\tsocketPosts.edit({ uid: 0 }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:not-logged-in]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if data is invalid or missing', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if title is too short', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', title: 'a' }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:title-too-short, ${meta.config.minimumTitleLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if title is too long', (done) => {\n\t\t\tconst longTitle = new Array(meta.config.maximumTitleLength + 2).join('a');\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', title: longTitle }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:title-too-long, ${meta.config.maximumTitleLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with too few tags', (done) => {\n\t\t\tconst oldValue = meta.config.minimumTagsPerTopic;\n\t\t\tmeta.config.minimumTagsPerTopic = 1;\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', tags: [] }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:not-enough-tags, ${meta.config.minimumTagsPerTopic}]]`);\n\t\t\t\tmeta.config.minimumTagsPerTopic = oldValue;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with too many tags', (done) => {\n\t\t\tconst tags = [];\n\t\t\tfor (let i = 0; i < meta.config.maximumTagsPerTopic + 1; i += 1) {\n\t\t\t\ttags.push(`tag${i}`);\n\t\t\t}\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', tags: tags }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:too-many-tags, ${meta.config.maximumTagsPerTopic}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if content is too short', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'e' }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:content-too-short, ${meta.config.minimumPostLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if content is too long', (done) => {\n\t\t\tconst longContent = new Array(meta.config.maximumPostLength + 2).join('a');\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: longContent }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:content-too-long, ${meta.config.maximumPostLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should edit post', async () => {\n\t\t\tconst data = await socketPosts.edit({ uid: voterUid }, {\n\t\t\t\tpid: pid,\n\t\t\t\tcontent: 'edited post content',\n\t\t\t\ttitle: 'edited title',\n\t\t\t\ttags: ['edited'],\n\t\t\t});\n\n\t\t\tassert.strictEqual(data.content, 'edited post content');\n\t\t\tassert.strictEqual(data.editor, voterUid);\n\t\t\tassert.strictEqual(data.topic.title, 'edited title');\n\t\t\tassert.strictEqual(data.topic.tags[0].value, 'edited');\n\t\t\tconst res = await db.getObject(`post:${pid}`);\n\t\t\tassert(!res.hasOwnProperty('bookmarks'));\n\t\t});\n\n\t\tit('should disallow post editing for new users if post was made past the threshold for editing', (done) => {\n\t\t\tmeta.config.newbiePostEditDuration = 1;\n\t\t\tsetTimeout(() => {\n\t\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content again', title: 'edited title again', tags: ['edited-twice'] }, (err, data) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:post-edit-duration-expired, 1]]');\n\t\t\t\t\tmeta.config.newbiePostEditDuration = 3600;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t}, 1000);\n\t\t});\n\n\t\tit('should edit a deleted post', (done) => {\n\t\t\tsocketPosts.delete({ uid: voterUid }, { pid: pid, tid: tid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited deleted content', title: 'edited deleted title', tags: ['deleted'] }, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.content, 'edited deleted content');\n\t\t\t\t\tassert.equal(data.editor, voterUid);\n\t\t\t\t\tassert.equal(data.topic.title, 'edited deleted title');\n\t\t\t\t\tassert.equal(data.topic.tags[0].value, 'deleted');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should edit a reply post', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'edited reply' }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.content, 'edited reply');\n\t\t\t\tassert.equal(data.editor, voterUid);\n\t\t\t\tassert.equal(data.topic.isMainPost, false);\n\t\t\t\tassert.equal(data.topic.renamed, false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return diffs', (done) => {\n\t\t\tposts.diffs.get(replyPid, 0, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(Array.isArray(data));\n\t\t\t\tassert(data[0].pid, replyPid);\n\t\t\t\tassert(data[0].patch);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load diffs and reconstruct post', (done) => {\n\t\t\tposts.diffs.load(replyPid, 0, voterUid, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.content, 'A reply to edit');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not allow guests to view diffs', (done) => {\n\t\t\tsocketPosts.getDiffs({ uid: 0 }, { pid: 1 }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should allow registered-users group to view diffs', (done) => {\n\t\t\tsocketPosts.getDiffs({ uid: 1 }, { pid: 1 }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tassert.strictEqual('boolean', typeof data.editable);\n\t\t\t\tassert.strictEqual(false, data.editable);\n\n\t\t\t\tassert.equal(true, Array.isArray(data.timestamps));\n\t\t\t\tassert.strictEqual(1, data.timestamps.length);\n\n\t\t\t\tassert.equal(true, Array.isArray(data.revisions));\n\t\t\t\tassert.strictEqual(data.timestamps.length, data.revisions.length);\n\t\t\t\t['timestamp', 'username'].every(prop => Object.keys(data.revisions[0]).includes(prop));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not delete first diff of a post', async () => {\n\t\t\tconst timestamps = await posts.diffs.list(replyPid);\n\t\t\tawait assert.rejects(async () => {\n\t\t\t\tawait posts.diffs.delete(replyPid, timestamps[0], voterUid);\n\t\t\t}, {\n\t\t\t\tmessage: '[[error:invalid-data]]',\n\t\t\t});\n\t\t});\n\n\t\tit('should delete a post diff', async () => {\n\t\t\tawait socketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'another edit has been made' });\n\t\t\tawait socketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'most recent edit' });\n\t\t\tconst timestamp = (await posts.diffs.list(replyPid)).pop();\n\t\t\tawait posts.diffs.delete(replyPid, timestamp, voterUid);\n\t\t\tconst differentTimestamp = (await posts.diffs.list(replyPid)).pop();\n\t\t\tassert.notStrictEqual(timestamp, differentTimestamp);\n\t\t});\n\n\t\tit('should load (oldest) diff and reconstruct post correctly after a diff deletion', async () => {\n\t\t\tconst data = await posts.diffs.load(replyPid, 0, voterUid);\n\t\t\tassert.strictEqual(data.content, 'A reply to edit');\n\t\t});\n\t});\n\n\tdescribe('move', () => {\n\t\tlet replyPid;\n\t\tlet tid;\n\t\tlet moveTid;\n\n\t\tbefore((done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\ttopics.post({\n\t\t\t\t\t\tuid: voterUid,\n\t\t\t\t\t\tcid: cid,\n\t\t\t\t\t\ttitle: 'topic 1',\n\t\t\t\t\t\tcontent: 'some content',\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t\tfunction (data, next) {\n\t\t\t\t\ttid = data.topicData.tid;\n\t\t\t\t\ttopics.post({\n\t\t\t\t\t\tuid: voterUid,\n\t\t\t\t\t\tcid: cid,\n\t\t\t\t\t\ttitle: 'topic 2',\n\t\t\t\t\t\tcontent: 'some content',\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t\tfunction (data, next) {\n\t\t\t\t\tmoveTid = data.topicData.tid;\n\t\t\t\t\ttopics.reply({\n\t\t\t\t\t\tuid: voterUid,\n\t\t\t\t\t\ttid: tid,\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t\tcontent: 'A reply to move',\n\t\t\t\t\t}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\treplyPid = data.pid;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should error if uid is not logged in', (done) => {\n\t\t\tsocketPosts.movePost({ uid: 0 }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:not-logged-in]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if data is invalid', (done) => {\n\t\t\tsocketPosts.movePost({ uid: globalModUid }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if user does not have move privilege', (done) => {\n\t\t\tsocketPosts.movePost({ uid: voterUid }, { pid: replyPid, tid: moveTid }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\n\t\tit('should move a post', (done) => {\n\t\t\tsocketPosts.movePost({ uid: globalModUid }, { pid: replyPid, tid: moveTid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'tid', (err, tid) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(tid, moveTid);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to move post if not moderator of target category', async () => {\n\t\t\tconst cat1 = await categories.create({ name: 'Test Category', description: 'Test category created by testing script' });\n\t\t\tconst cat2 = await categories.create({ name: 'Test Category', description: 'Test category created by testing script' });\n\t\t\tconst result = await socketTopics.post({ uid: globalModUid }, { title: 'target topic', content: 'queued topic', cid: cat2.cid });\n\t\t\tconst modUid = await user.create({ username: 'modofcat1' });\n\t\t\tawait privileges.categories.give(privileges.categories.userPrivilegeList, cat1.cid, modUid);\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait socketPosts.movePost({ uid: modUid }, { pid: replyPid, tid: result.tid });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:no-privileges]]');\n\t\t});\n\t});\n\n\tdescribe('getPostSummaryByPids', () => {\n\t\tit('should return empty array for empty pids', (done) => {\n\t\t\tposts.getPostSummaryByPids([], 0, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get post summaries', (done) => {\n\t\t\tposts.getPostSummaryByPids([postData.pid], 0, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data[0].user);\n\t\t\t\tassert(data[0].topic);\n\t\t\t\tassert(data[0].category);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get recent poster uids', (done) => {\n\t\ttopics.reply({\n\t\t\tuid: voterUid,\n\t\t\ttid: topicData.tid,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontent: 'some content',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tposts.getRecentPosterUids(0, 1, (err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(Array.isArray(uids));\n\t\t\t\tassert.equal(uids.length, 2);\n\t\t\t\tassert.equal(uids[0], voterUid);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('parse', () => {\n\t\tit('should not crash and return falsy if post data is falsy', (done) => {\n\t\t\tposts.parsePost(null, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(postData, null);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should store post content in cache', (done) => {\n\t\t\tconst oldValue = global.env;\n\t\t\tglobal.env = 'production';\n\t\t\tconst postData = {\n\t\t\t\tpid: 9999,\n\t\t\t\tcontent: 'some post content',\n\t\t\t};\n\t\t\tposts.parsePost(postData, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.parsePost(postData, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tglobal.env = oldValue;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should parse signature and remove links and images', (done) => {\n\t\t\tmeta.config['signatures:disableLinks'] = 1;\n\t\t\tmeta.config['signatures:disableImages'] = 1;\n\t\t\tconst userData = {\n\t\t\t\tsignature: '<img src=\"boop\"/><a href=\"link\">test</a> derp',\n\t\t\t};\n\n\t\t\tposts.parseSignature(userData, 1, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.userData.signature, 'test derp');\n\t\t\t\tmeta.config['signatures:disableLinks'] = 0;\n\t\t\t\tmeta.config['signatures:disableImages'] = 0;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should turn relative links in post body to absolute urls', (done) => {\n\t\t\tconst nconf = require('nconf');\n\t\t\tconst content = '<a href=\"/users\">test</a> <a href=\"youtube.com\">youtube</a>';\n\t\t\tconst parsedContent = posts.relativeToAbsolute(content, posts.urlRegex);\n\t\t\tassert.equal(parsedContent, `<a href=\"${nconf.get('base_url')}/users\">test</a> <a href=\"//youtube.com\">youtube</a>`);\n\t\t\tdone();\n\t\t});\n\n\t\tit('should turn relative links in post body to absolute urls', (done) => {\n\t\t\tconst nconf = require('nconf');\n\t\t\tconst content = '<a href=\"/users\">test</a> <a href=\"youtube.com\">youtube</a> some test <img src=\"/path/to/img\"/>';\n\t\t\tlet parsedContent = posts.relativeToAbsolute(content, posts.urlRegex);\n\t\t\tparsedContent = posts.relativeToAbsolute(parsedContent, posts.imgRegex);\n\t\t\tassert.equal(parsedContent, `<a href=\"${nconf.get('base_url')}/users\">test</a> <a href=\"//youtube.com\">youtube</a> some test <img src=\"${nconf.get('base_url')}/path/to/img\"/>`);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('socket methods', () => {\n\t\tlet pid;\n\t\tbefore((done) => {\n\t\t\ttopics.reply({\n\t\t\t\tuid: voterUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tcontent: 'raw content',\n\t\t\t}, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tpid = postData.pid;\n\t\t\t\tprivileges.categories.rescind(['groups:topics:read'], cid, 'guests', done);\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\tsocketPosts.reply({ uid: 0 }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid tid', (done) => {\n\t\t\tsocketPosts.reply({ uid: 0 }, { tid: 0, content: 'derp' }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to get raw post because of privilege', (done) => {\n\t\t\tsocketPosts.getRawPost({ uid: 0 }, pid, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to get raw post because post is deleted', (done) => {\n\t\t\tposts.setPostField(pid, 'deleted', 1, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.getRawPost({ uid: voterUid }, pid, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:no-post]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should get raw post content', (done) => {\n\t\t\tposts.setPostField(pid, 'deleted', 0, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.getRawPost({ uid: voterUid }, pid, (err, postContent) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(postContent, 'raw content');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should get post', (done) => {\n\t\t\tsocketPosts.getPost({ uid: voterUid }, pid, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(postData);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get post category', (done) => {\n\t\t\tsocketPosts.getCategory({ uid: voterUid }, pid, (err, postCid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(cid, postCid);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\tsocketPosts.getPidIndex({ uid: voterUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get pid index', (done) => {\n\t\t\tsocketPosts.getPidIndex({ uid: voterUid }, { pid: pid, tid: topicData.tid, topicPostSort: 'oldest_to_newest' }, (err, index) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(index, 4);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get pid index in reverse', (done) => {\n\t\t\ttopics.reply({\n\t\t\t\tuid: voterUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\tcontent: 'raw content',\n\t\t\t}, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tsocketPosts.getPidIndex({ uid: voterUid }, { pid: postData.pid, tid: topicData.tid, topicPostSort: 'newest_to_oldest' }, (err, index) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(index, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('filterPidsByCid', () => {\n\t\tit('should return pids as is if cid is falsy', (done) => {\n\t\t\tposts.filterPidsByCid([1, 2, 3], null, (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([1, 2, 3], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should filter pids by single cid', (done) => {\n\t\t\tposts.filterPidsByCid([postData.pid, 100, 101], cid, (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([postData.pid], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should filter pids by multiple cids', (done) => {\n\t\t\tposts.filterPidsByCid([postData.pid, 100, 101], [cid, 2, 3], (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([postData.pid], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should filter pids by multiple cids', (done) => {\n\t\t\tposts.filterPidsByCid([postData.pid, 100, 101], [cid], (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([postData.pid], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should error if user does not exist', (done) => {\n\t\tuser.isReadyToPost(21123123, 1, (err) => {\n\t\t\tassert.equal(err.message, '[[error:no-user]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('post queue', () => {\n\t\tlet uid;\n\t\tlet queueId;\n\t\tlet topicQueueId;\n\t\tlet jar;\n\t\tbefore((done) => {\n\t\t\tmeta.config.postQueue = 1;\n\t\t\tuser.create({ username: 'newuser' }, (err, _uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuid = _uid;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.postQueue = 0;\n\t\t\tmeta.config.groupsExemptFromPostQueue = [];\n\t\t\tdone();\n\t\t});\n\n\t\tit('should add topic to post queue', (done) => {\n\t\t\tsocketTopics.post({ uid: uid }, { title: 'should be queued', content: 'queued topic content', cid: cid }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(result.queued, true);\n\t\t\t\tassert.equal(result.message, '[[success:post-queued]]');\n\t\t\t\ttopicQueueId = result.id;\n\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should add reply to post queue', (done) => {\n\t\t\tsocketPosts.reply({ uid: uid }, { content: 'this is a queued reply', tid: topicData.tid }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(result.queued, true);\n\t\t\t\tassert.equal(result.message, '[[success:post-queued]]');\n\t\t\t\tqueueId = result.id;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load queued posts', (done) => {\n\t\t\thelpers.loginUser('globalmod', 'globalmodpwd', (err, _jar) => {\n\t\t\t\tjar = _jar;\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[0].type, 'topic');\n\t\t\t\t\tassert.equal(body.posts[0].data.content, 'queued topic content');\n\t\t\t\t\tassert.equal(body.posts[1].type, 'reply');\n\t\t\t\t\tassert.equal(body.posts[1].data.content, 'this is a queued reply');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if data is invalid', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should edit post in queue', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: queueId, content: 'newContent' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[1].type, 'reply');\n\t\t\t\t\tassert.equal(body.posts[1].data.content, 'newContent');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should edit topic title in queue', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, title: 'new topic title' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[0].type, 'topic');\n\t\t\t\t\tassert.equal(body.posts[0].data.title, 'new topic title');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should edit topic category in queue', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, cid: 2 }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[0].type, 'topic');\n\t\t\t\t\tassert.equal(body.posts[0].data.cid, 2);\n\t\t\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, cid: cid }, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should prevent regular users from approving posts', (done) => {\n\t\t\tsocketPosts.accept({ uid: uid }, { id: queueId }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should prevent regular users from approving non existing posts', (done) => {\n\t\t\tsocketPosts.accept({ uid: uid }, { id: 123123 }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should accept queued posts and submit', (done) => {\n\t\t\tlet ids;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tdb.getSortedSetRange('post:queue', 0, -1, next);\n\t\t\t\t},\n\t\t\t\tfunction (_ids, next) {\n\t\t\t\t\tids = _ids;\n\t\t\t\t\tsocketPosts.accept({ uid: globalModUid }, { id: ids[0] }, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsocketPosts.accept({ uid: globalModUid }, { id: ids[1] }, next);\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should not crash if id does not exist', (done) => {\n\t\t\tsocketPosts.reject({ uid: globalModUid }, { id: '123123123' }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should bypass post queue if user is in exempt group', async () => {\n\t\t\tconst oldValue = meta.config.groupsExemptFromPostQueue;\n\t\t\tmeta.config.groupsExemptFromPostQueue = ['registered-users'];\n\t\t\tconst uid = await user.create({ username: 'mergeexemptuser' });\n\t\t\tconst result = await socketTopics.post({ uid: uid, emit: () => {} }, { title: 'should not be queued', content: 'topic content', cid: cid });\n\t\t\tassert.strictEqual(result.title, 'should not be queued');\n\t\t\tmeta.config.groupsExemptFromPostQueue = oldValue;\n\t\t});\n\n\t\tit('should update queued post\\'s topic if target topic is merged', async () => {\n\t\t\tconst uid = await user.create({ username: 'mergetestsuser' });\n\t\t\tconst result1 = await socketTopics.post({ uid: globalModUid }, { title: 'topic A', content: 'topic A content', cid: cid });\n\t\t\tconst result2 = await socketTopics.post({ uid: globalModUid }, { title: 'topic B', content: 'topic B content', cid: cid });\n\n\t\t\tconst result = await socketPosts.reply({ uid: uid }, { content: 'the moved queued post', tid: result1.tid });\n\n\t\t\tawait topics.merge([\n\t\t\t\tresult1.tid, result2.tid,\n\t\t\t], globalModUid, { mainTid: result2.tid });\n\n\t\t\tlet postData = await posts.getQueuedPosts();\n\t\t\tpostData = postData.filter(p => parseInt(p.data.tid, 10) === parseInt(result2.tid, 10));\n\t\t\tassert.strictEqual(postData.length, 1);\n\t\t\tassert.strictEqual(postData[0].data.content, 'the moved queued post');\n\t\t\tassert.strictEqual(postData[0].data.tid, result2.tid);\n\t\t});\n\t});\n\n\tdescribe('upload methods', () => {\n\t\tlet pid;\n\t\tlet purgePid;\n\n\t\tbefore(async () => {\n\t\t\t// Create stub files for testing\n\t\t\t['abracadabra.png', 'shazam.jpg', 'whoa.gif', 'amazeballs.jpg', 'wut.txt', 'test.bmp']\n\t\t\t\t.forEach(filename => fs.closeSync(fs.openSync(path.join(nconf.get('upload_path'), 'files', filename), 'w')));\n\n\t\t\tconst topicPostData = await topics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid: 1,\n\t\t\t\ttitle: 'topic with some images',\n\t\t\t\tcontent: 'here is an image [alt text](/assets/uploads/files/abracadabra.png) and another [alt text](/assets/uploads/files/shazam.jpg)',\n\t\t\t});\n\t\t\tpid = topicPostData.postData.pid;\n\n\t\t\tconst purgePostData = await topics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid: 1,\n\t\t\t\ttitle: 'topic with some images, to be purged',\n\t\t\t\tcontent: 'here is an image [alt text](/assets/uploads/files/whoa.gif) and another [alt text](/assets/uploads/files/amazeballs.jpg)',\n\t\t\t});\n\t\t\tpurgePid = purgePostData.postData.pid;\n\t\t});\n\n\t\tdescribe('.sync()', () => {\n\t\t\tit('should properly add new images to the post\\'s zset', (done) => {\n\t\t\t\tposts.uploads.sync(pid, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tdb.sortedSetCard(`post:${pid}:uploads`, (err, length) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(length, 2);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should remove an image if it is edited out of the post', (done) => {\n\t\t\t\tasync.series([\n\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\tposts.edit({\n\t\t\t\t\t\t\tpid: pid,\n\t\t\t\t\t\t\tuid: 1,\n\t\t\t\t\t\t\tcontent: 'here is an image [alt text](/assets/uploads/files/abracadabra.png)... AND NO MORE!',\n\t\t\t\t\t\t}, next);\n\t\t\t\t\t},\n\t\t\t\t\tasync.apply(posts.uploads.sync, pid),\n\t\t\t\t], (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdb.sortedSetCard(`post:${pid}:uploads`, (err, length) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(1, length);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.list()', () => {\n\t\t\tit('should display the uploaded files for a specific post', (done) => {\n\t\t\t\tposts.uploads.list(pid, (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(true, Array.isArray(uploads));\n\t\t\t\t\tassert.strictEqual(1, uploads.length);\n\t\t\t\t\tassert.equal('string', typeof uploads[0]);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.isOrphan()', () => {\n\t\t\tit('should return false if upload is not an orphan', (done) => {\n\t\t\t\tposts.uploads.isOrphan('abracadabra.png', (err, isOrphan) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(false, isOrphan);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return true if upload is an orphan', (done) => {\n\t\t\t\tposts.uploads.isOrphan('shazam.jpg', (err, isOrphan) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(true, isOrphan);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.associate()', () => {\n\t\t\tit('should add an image to the post\\'s maintained list of uploads', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, 'whoa.gif'),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(2, uploads.length);\n\t\t\t\t\tassert.strictEqual(true, uploads.includes('whoa.gif'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should allow arrays to be passed in', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, ['amazeballs.jpg', 'wut.txt']),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(4, uploads.length);\n\t\t\t\t\tassert.strictEqual(true, uploads.includes('amazeballs.jpg'));\n\t\t\t\t\tassert.strictEqual(true, uploads.includes('wut.txt'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should save a reverse association of md5sum to pid', (done) => {\n\t\t\t\tconst md5 = filename => crypto.createHash('md5').update(filename).digest('hex');\n\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, ['test.bmp']),\n\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\tdb.getSortedSetRange(`upload:${md5('test.bmp')}:pids`, 0, -1, next);\n\t\t\t\t\t},\n\t\t\t\t], (err, pids) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(true, Array.isArray(pids));\n\t\t\t\t\tassert.strictEqual(true, pids.length > 0);\n\t\t\t\t\tassert.equal(pid, pids[0]);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should not associate a file that does not exist on the local disk', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, ['nonexistant.xls']),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(uploads.length, 5);\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('nonexistant.xls'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.dissociate()', () => {\n\t\t\tit('should remove an image from the post\\'s maintained list of uploads', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.dissociate, pid, 'whoa.gif'),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(4, uploads.length);\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('whoa.gif'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should allow arrays to be passed in', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.dissociate, pid, ['amazeballs.jpg', 'wut.txt']),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(2, uploads.length);\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('amazeballs.jpg'));\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('wut.txt'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.dissociateAll()', () => {\n\t\t\tit('should remove all images from a post\\'s maintained list of uploads', async () => {\n\t\t\t\tawait posts.uploads.dissociateAll(pid);\n\t\t\t\tconst uploads = await posts.uploads.list(pid);\n\n\t\t\t\tassert.equal(uploads.length, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Dissociation on purge', () => {\n\t\t\tit('should not dissociate images on post deletion', async () => {\n\t\t\t\tawait posts.delete(purgePid, 1);\n\t\t\t\tconst uploads = await posts.uploads.list(purgePid);\n\n\t\t\t\tassert.equal(uploads.length, 2);\n\t\t\t});\n\n\t\t\tit('should dissociate images on post purge', async () => {\n\t\t\t\tawait posts.purge(purgePid, 1);\n\t\t\t\tconst uploads = await posts.uploads.list(purgePid);\n\n\t\t\t\tassert.equal(uploads.length, 0);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('post uploads management', () => {\n\t\tlet topic;\n\t\tlet reply;\n\t\tbefore((done) => {\n\t\t\ttopics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'topic to test uploads with',\n\t\t\t\tcontent: '[abcdef](/assets/uploads/files/abracadabra.png)',\n\t\t\t}, (err, topicPostData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttopics.reply({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\ttid: topicPostData.topicData.tid,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\tcontent: '[abcdef](/assets/uploads/files/shazam.jpg)',\n\t\t\t\t}, (err, replyData) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\ttopic = topicPostData;\n\t\t\t\t\treply = replyData;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should automatically sync uploads on topic create and reply', (done) => {\n\t\t\tdb.sortedSetsCard([`post:${topic.topicData.mainPid}:uploads`, `post:${reply.pid}:uploads`], (err, lengths) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(1, lengths[0]);\n\t\t\t\tassert.strictEqual(1, lengths[1]);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should automatically sync uploads on post edit', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tasync.apply(posts.edit, {\n\t\t\t\t\tpid: reply.pid,\n\t\t\t\t\tuid: 1,\n\t\t\t\t\tcontent: 'no uploads',\n\t\t\t\t}),\n\t\t\t\tfunction (postData, next) {\n\t\t\t\t\tposts.uploads.list(reply.pid, next);\n\t\t\t\t},\n\t\t\t], (err, uploads) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(true, Array.isArray(uploads));\n\t\t\t\tassert.strictEqual(0, uploads.length);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Topic Backlinks', () => {\n\t\tlet tid1;\n\t\tbefore(async () => {\n\t\t\ttid1 = await topics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid,\n\t\t\t\ttitle: 'Topic backlink testing - topic 1',\n\t\t\t\tcontent: 'Some text here for the OP',\n\t\t\t});\n\t\t\ttid1 = tid1.topicData.tid;\n\t\t});\n\n\t\tdescribe('.syncBacklinks()', () => {\n\t\t\tit('should error on invalid data', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait topics.syncBacklinks();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tassert(e);\n\t\t\t\t\tassert.strictEqual(e.message, '[[error:invalid-data]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should do nothing if the post does not contain a link to a topic', async () => {\n\t\t\t\tconst backlinks = await topics.syncBacklinks({\n\t\t\t\t\tcontent: 'This is a post\\'s content',\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(backlinks, 0);\n\t\t\t});\n\n\t\t\tit('should create a backlink if it detects a topic link in a post', async () => {\n\t\t\t\tconst count = await topics.syncBacklinks({\n\t\t\t\t\tpid: 2,\n\t\t\t\t\tcontent: `This is a link to [topic 1](${nconf.get('url')}/topic/1/abcdef)`,\n\t\t\t\t});\n\t\t\t\tconst events = await topics.events.get(1, 1);\n\t\t\t\tconst backlinks = await db.getSortedSetMembers('pid:2:backlinks');\n\n\t\t\t\tassert.strictEqual(count, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\n\t\t\t\tassert(backlinks);\n\t\t\t\tassert(backlinks.includes('1'));\n\t\t\t});\n\n\t\t\tit('should remove the backlink (but keep the event) if the post no longer contains a link to a topic', async () => {\n\t\t\t\tconst count = await topics.syncBacklinks({\n\t\t\t\t\tpid: 2,\n\t\t\t\t\tcontent: 'This is a link to [nothing](http://example.org)',\n\t\t\t\t});\n\t\t\t\tconst events = await topics.events.get(1, 1);\n\t\t\t\tconst backlinks = await db.getSortedSetMembers('pid:2:backlinks');\n\n\t\t\t\tassert.strictEqual(count, 0);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\n\t\t\t\tassert(backlinks);\n\t\t\t\tassert.strictEqual(backlinks.length, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('integration tests', () => {\n\t\t\tit('should create a topic event in the referenced topic', async () => {\n\t\t\t\tconst topic = await topics.post({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\tcid,\n\t\t\t\t\ttitle: 'Topic backlink testing - topic 2',\n\t\t\t\t\tcontent: `Some text here for the OP &ndash; ${nconf.get('url')}/topic/${tid1}`,\n\t\t\t\t});\n\n\t\t\t\tconst events = await topics.events.get(tid1, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\n\t\t\t\tassert.strictEqual(events[0].type, 'backlink');\n\t\t\t\tassert.strictEqual(parseInt(events[0].uid, 10), 1);\n\t\t\t\tassert.strictEqual(events[0].href, `/post/${topic.postData.pid}`);\n\t\t\t});\n\n\t\t\tit('should not create a topic event if referenced topic is the same as current topic', async () => {\n\t\t\t\tawait topics.reply({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\ttid: tid1,\n\t\t\t\t\tcontent: `Referencing itself &ndash; ${nconf.get('url')}/topic/${tid1}`,\n\t\t\t\t});\n\n\t\t\t\tconst events = await topics.events.get(tid1, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\t// should still equal 1\n\t\t\t});\n\n\t\t\tit('should not show backlink events if the feature is disabled', async () => {\n\t\t\t\tmeta.config.topicBacklinks = 0;\n\n\t\t\t\tawait topics.post({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\tcid,\n\t\t\t\t\ttitle: 'Topic backlink testing - topic 3',\n\t\t\t\t\tcontent: `Some text here for the OP &ndash; ${nconf.get('url')}/topic/${tid1}`,\n\t\t\t\t});\n\n\t\t\t\tconst events = await topics.events.get(tid1, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 0);\n\t\t\t});\n\t\t});\n\t});\n});\n", "'use strict';\n\n// For tests relating to Transifex configuration, check i18n.js\n\nconst assert = require('assert');\nconst shim = require('../public/src/modules/translator');\n\nconst { Translator } = shim;\nconst db = require('./mocks/databasemock');\n\ndescribe('Translator shim', () => {\n\tdescribe('.translate()', () => {\n\t\tit('should translate correctly', (done) => {\n\t\t\tshim.translate('[[global:pagination.out_of, (foobar), [[global:home]]]]', (translated) => {\n\t\t\t\tassert.strictEqual(translated, '(foobar) out of Home');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should accept a language parameter and adjust accordingly', (done) => {\n\t\t\tshim.translate('[[global:home]]', 'de', (translated) => {\n\t\t\t\tassert.strictEqual(translated, '\u00dcbersicht');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should translate empty string properly', (done) => {\n\t\t\tshim.translate('', 'en-GB', (translated) => {\n\t\t\t\tassert.strictEqual(translated, '');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should translate empty string properly', async () => {\n\t\t\tconst translated = await shim.translate('', 'en-GB');\n\t\t\tassert.strictEqual(translated, '');\n\t\t});\n\t});\n});\n\ndescribe('new Translator(language)', () => {\n\tit('should throw if not passed a language', (done) => {\n\t\tassert.throws(() => {\n\t\t\tnew Translator();\n\t\t}, /language string/);\n\t\tdone();\n\t});\n\n\tdescribe('.translate()', () => {\n\t\tit('should handle basic translations', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:home]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys in regular text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('Let\\'s go [[global:home]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Let\\'s go Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys in regular text with another language specified', () => {\n\t\t\tconst translator = Translator.create('de');\n\n\t\t\treturn translator.translate('[[global:home]] test').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '\u00dcbersicht test');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys with parameters', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:pagination.out_of, 1, 5]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '1 out of 5');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys inside language keys', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[notifications:outgoing_link_message, [[global:guest]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'You are now leaving Guest');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys inside language keys with multiple parameters', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[notifications:user_posted_to, [[global:guest]], My Topic]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '<strong>Guest</strong> has posted a reply to: <strong>My Topic</strong>');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys inside language keys with all parameters as language keys', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[notifications:user_posted_to, [[global:guest]], [[global:guest]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '<strong>Guest</strong> has posted a reply to: <strong>Guest</strong>');\n\t\t\t});\n\t\t});\n\n\t\tit('should properly handle parameters that contain square brackets', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:pagination.out_of, [guest], [[global:home]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '[guest] out of Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should properly handle parameters that contain parentheses', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:pagination.out_of, (foobar), [[global:home]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '(foobar) out of Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should escape language key parameters with HTML in them', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst key = '[[global:403.login, <strong>test</strong>]]';\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Perhaps you should <a href=\\'&lt;strong&gt;test&lt;/strong&gt;/login\\'>try logging in</a>?');\n\t\t\t});\n\t\t});\n\n\t\tit('should not unescape html in parameters', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst key = '[[pages:tag, some&amp;tag]]';\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Topics tagged under &quot;some&amp;tag&quot;');\n\t\t\t});\n\t\t});\n\n\t\tit('should translate escaped translation arguments properly', () => {\n\t\t\t// https://github.com/NodeBB/NodeBB/issues/9206\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst key = '[[notifications:upvoted_your_post_in, test1, error: Error: &lsqb;&lsqb;error:group-name-too-long&rsqb;&rsqb; on NodeBB Upgrade]]';\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '<strong>test1</strong> has upvoted your post in <strong>error: Error: &lsqb;&lsqb;error:group-name-too-long&rsqb;&rsqb; on NodeBB Upgrade</strong>.');\n\t\t\t});\n\t\t});\n\n\t\tit('should properly escape and ignore % and \\\\, in arguments', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst title = 'Test 1\\\\, 2\\\\, 3 %2 salmon';\n\t\t\tconst key = `[[topic:composer.replying_to, ${title}]]`;\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Replying to Test 1&#44; 2&#44; 3 &#37;2 salmon');\n\t\t\t});\n\t\t});\n\n\t\tit('should not escape regular %', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst title = '3 % salmon';\n\t\t\tconst key = `[[topic:composer.replying_to, ${title}]]`;\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Replying to 3 % salmon');\n\t\t\t});\n\t\t});\n\n\t\tit('should not translate [[derp] some text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[derp] some text').then((translated) => {\n\t\t\t\tassert.strictEqual('[[derp] some text', translated);\n\t\t\t});\n\t\t});\n\n\t\tit('should not translate [[derp]] some text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[derp]] some text').then((translated) => {\n\t\t\t\tassert.strictEqual('[[derp]] some text', translated);\n\t\t\t});\n\t\t});\n\n\t\tit('should not translate [[derp:xyz] some text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[derp:xyz] some text').then((translated) => {\n\t\t\t\tassert.strictEqual('[[derp:xyz] some text', translated);\n\t\t\t});\n\t\t});\n\n\t\tit('should translate keys with slashes properly', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[pages:users/latest]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Latest Users');\n\t\t\t});\n\t\t});\n\n\t\tit('should use key for unknown keys without arguments', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[unknown:key.without.args]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'key.without.args');\n\t\t\t});\n\t\t});\n\n\t\tit('should use backup for unknown keys with arguments', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[unknown:key.with.args, arguments are here, derpity, derp]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'unknown:key.with.args, arguments are here, derpity, derp');\n\t\t\t});\n\t\t});\n\n\t\tit('should ignore unclosed tokens', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('here is some stuff and other things [[abc:xyz, other random stuff should be fine here [[global:home]] and more things [[pages:users/latest]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'here is some stuff and other things abc:xyz, other random stuff should be fine here Home and more things Latest Users');\n\t\t\t});\n\t\t});\n\t});\n});\n\ndescribe('Translator.create()', () => {\n\tit('should return an instance of Translator', (done) => {\n\t\tconst translator = Translator.create('en-GB');\n\n\t\tassert(translator instanceof Translator);\n\t\tdone();\n\t});\n\tit('should return the same object for the same language', (done) => {\n\t\tconst one = Translator.create('de');\n\t\tconst two = Translator.create('de');\n\n\t\tassert.strictEqual(one, two);\n\t\tdone();\n\t});\n\tit('should default to defaultLang', (done) => {\n\t\tconst translator = Translator.create();\n\n\t\tassert.strictEqual(translator.lang, 'en-GB');\n\t\tdone();\n\t});\n});\n\ndescribe('Translator modules', () => {\n\tit('should work before registered', () => {\n\t\tconst translator = Translator.create();\n\n\t\tTranslator.registerModule('test-custom-integer-format', lang => function (key, args) {\n\t\t\tconst num = parseInt(args[0], 10) || 0;\n\t\t\tif (key === 'binary') {\n\t\t\t\treturn num.toString(2);\n\t\t\t}\n\t\t\tif (key === 'hex') {\n\t\t\t\treturn num.toString(16);\n\t\t\t}\n\t\t\tif (key === 'octal') {\n\t\t\t\treturn num.toString(8);\n\t\t\t}\n\t\t\treturn num.toString();\n\t\t});\n\n\t\treturn translator.translate('[[test-custom-integer-format:octal, 24]]').then((translation) => {\n\t\t\tassert.strictEqual(translation, '30');\n\t\t});\n\t});\n\n\tit('should work after registered', () => {\n\t\tconst translator = Translator.create('de');\n\n\t\treturn translator.translate('[[test-custom-integer-format:octal, 23]]').then((translation) => {\n\t\t\tassert.strictEqual(translation, '27');\n\t\t});\n\t});\n\n\tit('registerModule be passed the language', (done) => {\n\t\tTranslator.registerModule('something', (lang) => {\n\t\t\tassert.ok(lang);\n\t\t});\n\n\t\tconst translator = Translator.create('fr_FR');\n\t\tdone();\n\t});\n});\n\ndescribe('Translator static methods', () => {\n\tdescribe('.removePatterns', () => {\n\t\tit('should remove translator patterns from text', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.removePatterns('Lorem ipsum dolor [[sit:amet]], consectetur adipiscing elit. [[sed:vitae, [[semper:dolor]]]] lorem'),\n\t\t\t\t'Lorem ipsum dolor , consectetur adipiscing elit.  lorem'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\tdescribe('.escape', () => {\n\t\tit('should escape translation patterns within text', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.escape('some nice text [[global:home]] here'),\n\t\t\t\t'some nice text &lsqb;&lsqb;global:home&rsqb;&rsqb; here'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('.unescape', () => {\n\t\tit('should unescape escaped translation patterns within text', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.unescape('some nice text \\\\[\\\\[global:home\\\\]\\\\] here'),\n\t\t\t\t'some nice text [[global:home]] here'\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.unescape('some nice text &lsqb;&lsqb;global:home&rsqb;&rsqb; here'),\n\t\t\t\t'some nice text [[global:home]] here'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('.compile', () => {\n\t\tit('should create a translator pattern from a key and list of arguments', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.compile('amazing:cool', 'awesome', 'great'),\n\t\t\t\t'[[amazing:cool, awesome, great]]'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\n\t\tit('should escape `%` and `,` in arguments', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.compile('amazing:cool', '100% awesome!', 'one, two, and three'),\n\t\t\t\t'[[amazing:cool, 100&#37; awesome!, one&#44; two&#44; and three]]'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('add translation', () => {\n\t\tit('should add custom translations', async () => {\n\t\t\tshim.addTranslation('en-GB', 'my-namespace', { foo: 'a custom translation' });\n\t\t\tconst t = await shim.translate('this is best [[my-namespace:foo]]');\n\t\t\tassert.strictEqual(t, 'this is best a custom translation');\n\t\t});\n\t});\n\n\tdescribe('translate nested keys', () => {\n\t\tit('should handle nested translations', async () => {\n\t\t\tshim.addTranslation('en-GB', 'my-namespace', {\n\t\t\t\tkey: {\n\t\t\t\t\tkey1: 'key1 translated',\n\t\t\t\t\tkey2: {\n\t\t\t\t\t\tkey3: 'key3 translated',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t\tconst t1 = await shim.translate('this is best [[my-namespace:key.key1]]');\n\t\t\tconst t2 = await shim.translate('this is best [[my-namespace:key.key2.key3]]');\n\t\t\tassert.strictEqual(t1, 'this is best key1 translated');\n\t\t\tassert.strictEqual(t2, 'this is best key3 translated');\n\t\t});\n\t\tit(\"should try the defaults if it didn't reach a string in a nested translation\", async () => {\n\t\t\tshim.addTranslation('en-GB', 'my-namespace', {\n\t\t\t\tdefault1: {\n\t\t\t\t\tdefault1: 'default1 translated',\n\t\t\t\t\t'': 'incorrect priority',\n\t\t\t\t},\n\t\t\t\tdefault2: {\n\t\t\t\t\t'': 'default2 translated',\n\t\t\t\t},\n\t\t\t});\n\t\t\tconst d1 = await shim.translate('this is best [[my-namespace:default1]]');\n\t\t\tconst d2 = await shim.translate('this is best [[my-namespace:default2]]');\n\t\t\tassert.strictEqual(d1, 'this is best default1 translated');\n\t\t\tassert.strictEqual(d2, 'this is best default2 translated');\n\t\t});\n\t});\n});\n"], "fixing_code": ["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst utils = require('./utils');\nconst { paths } = require('./constants');\nconst plugins = require('./plugins');\n\nconst Languages = module.exports;\nconst languagesPath = path.join(__dirname, '../build/public/language');\n\nconst files = fs.readdirSync(path.join(paths.nodeModules, '/timeago/locales'));\nLanguages.timeagoCodes = files.filter(f => f.startsWith('jquery.timeago')).map(f => f.split('.')[2]);\n\nLanguages.get = async function (language, namespace) {\n\tconst pathToLanguageFile = path.join(languagesPath, language, `${namespace}.json`);\n\tif (!pathToLanguageFile.startsWith(languagesPath)) {\n\t\tthrow new Error('[[error:invalid-path]]');\n\t}\n\tconst data = await fs.promises.readFile(pathToLanguageFile, 'utf8');\n\tconst parsed = JSON.parse(data) || {};\n\tconst result = await plugins.hooks.fire('filter:languages.get', {\n\t\tlanguage,\n\t\tnamespace,\n\t\tdata: parsed,\n\t});\n\treturn result.data;\n};\n\nlet codeCache = null;\nLanguages.listCodes = async function () {\n\tif (codeCache && codeCache.length) {\n\t\treturn codeCache;\n\t}\n\ttry {\n\t\tconst file = await fs.promises.readFile(path.join(languagesPath, 'metadata.json'), 'utf8');\n\t\tconst parsed = JSON.parse(file);\n\n\t\tcodeCache = parsed.languages;\n\t\treturn parsed.languages;\n\t} catch (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn [];\n\t\t}\n\t\tthrow err;\n\t}\n};\n\nlet listCache = null;\nLanguages.list = async function () {\n\tif (listCache && listCache.length) {\n\t\treturn listCache;\n\t}\n\n\tconst codes = await Languages.listCodes();\n\n\tlet languages = await Promise.all(codes.map(async (folder) => {\n\t\ttry {\n\t\t\tconst configPath = path.join(languagesPath, folder, 'language.json');\n\t\t\tconst file = await fs.promises.readFile(configPath, 'utf8');\n\t\t\tconst lang = JSON.parse(file);\n\t\t\treturn lang;\n\t\t} catch (err) {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}));\n\n\t// filter out invalid ones\n\tlanguages = languages.filter(lang => lang && lang.code && lang.name && lang.dir);\n\n\tlistCache = languages;\n\treturn languages;\n};\n\nLanguages.userTimeagoCode = async function (userLang) {\n\tconst languageCodes = await Languages.listCodes();\n\tconst timeagoCode = utils.userLangToTimeagoCode(userLang);\n\tif (languageCodes.includes(userLang) && Languages.timeagoCodes.includes(timeagoCode)) {\n\t\treturn timeagoCode;\n\t}\n\treturn '';\n};\n\nrequire('./promisify')(Languages);\n", "'use strict';\n\n\nconst assert = require('assert');\nconst async = require('async');\nconst request = require('request');\nconst nconf = require('nconf');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\n\nconst db = require('./mocks/databasemock');\nconst topics = require('../src/topics');\nconst posts = require('../src/posts');\nconst categories = require('../src/categories');\nconst privileges = require('../src/privileges');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst socketPosts = require('../src/socket.io/posts');\nconst socketTopics = require('../src/socket.io/topics');\nconst meta = require('../src/meta');\nconst helpers = require('./helpers');\n\ndescribe('Post\\'s', () => {\n\tlet voterUid;\n\tlet voteeUid;\n\tlet globalModUid;\n\tlet postData;\n\tlet topicData;\n\tlet cid;\n\n\tbefore((done) => {\n\t\tasync.series({\n\t\t\tvoterUid: function (next) {\n\t\t\t\tuser.create({ username: 'upvoter' }, next);\n\t\t\t},\n\t\t\tvoteeUid: function (next) {\n\t\t\t\tuser.create({ username: 'upvotee' }, next);\n\t\t\t},\n\t\t\tglobalModUid: function (next) {\n\t\t\t\tuser.create({ username: 'globalmod', password: 'globalmodpwd' }, next);\n\t\t\t},\n\t\t\tcategory: function (next) {\n\t\t\t\tcategories.create({\n\t\t\t\t\tname: 'Test Category',\n\t\t\t\t\tdescription: 'Test category created by testing script',\n\t\t\t\t}, next);\n\t\t\t},\n\t\t}, (err, results) => {\n\t\t\tif (err) {\n\t\t\t\treturn done(err);\n\t\t\t}\n\n\t\t\tvoterUid = results.voterUid;\n\t\t\tvoteeUid = results.voteeUid;\n\t\t\tglobalModUid = results.globalModUid;\n\t\t\tcid = results.category.cid;\n\n\t\t\ttopics.post({\n\t\t\t\tuid: results.voteeUid,\n\t\t\t\tcid: results.category.cid,\n\t\t\t\ttitle: 'Test Topic Title',\n\t\t\t\tcontent: 'The content of test topic',\n\t\t\t}, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn done(err);\n\t\t\t\t}\n\t\t\t\tpostData = data.postData;\n\t\t\t\ttopicData = data.topicData;\n\n\t\t\t\tgroups.join('Global Moderators', globalModUid, done);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should update category teaser properly', async () => {\n\t\tconst util = require('util');\n\t\tconst getCategoriesAsync = util.promisify(async (callback) => {\n\t\t\trequest(`${nconf.get('url')}/api/categories`, { json: true }, (err, res, body) => {\n\t\t\t\tcallback(err, body);\n\t\t\t});\n\t\t});\n\n\t\tconst postResult = await topics.post({ uid: globalModUid, cid: cid, title: 'topic title', content: '123456789' });\n\n\t\tlet data = await getCategoriesAsync();\n\t\tassert.equal(data.categories[0].teaser.pid, postResult.postData.pid);\n\t\tassert.equal(data.categories[0].posts[0].content, '123456789');\n\t\tassert.equal(data.categories[0].posts[0].pid, postResult.postData.pid);\n\n\t\tconst newUid = await user.create({ username: 'teaserdelete' });\n\t\tconst newPostResult = await topics.post({ uid: newUid, cid: cid, title: 'topic title', content: 'xxxxxxxx' });\n\n\t\tdata = await getCategoriesAsync();\n\t\tassert.equal(data.categories[0].teaser.pid, newPostResult.postData.pid);\n\t\tassert.equal(data.categories[0].posts[0].content, 'xxxxxxxx');\n\t\tassert.equal(data.categories[0].posts[0].pid, newPostResult.postData.pid);\n\n\t\tawait user.delete(1, newUid);\n\n\t\tdata = await getCategoriesAsync();\n\t\tassert.equal(data.categories[0].teaser.pid, postResult.postData.pid);\n\t\tassert.equal(data.categories[0].posts[0].content, '123456789');\n\t\tassert.equal(data.categories[0].posts[0].pid, postResult.postData.pid);\n\t});\n\n\tit('should change owner of post and topic properly', async () => {\n\t\tconst oldUid = await user.create({ username: 'olduser' });\n\t\tconst newUid = await user.create({ username: 'newuser' });\n\t\tconst postResult = await topics.post({ uid: oldUid, cid: cid, title: 'change owner', content: 'original post' });\n\t\tconst postData = await topics.reply({ uid: oldUid, tid: postResult.topicData.tid, content: 'firstReply' });\n\t\tconst pid1 = postResult.postData.pid;\n\t\tconst pid2 = postData.pid;\n\n\t\tassert.deepStrictEqual(await db.sortedSetScores(`tid:${postResult.topicData.tid}:posters`, [oldUid, newUid]), [2, null]);\n\n\t\tawait posts.changeOwner([pid1, pid2], newUid);\n\n\t\tassert.deepStrictEqual(await db.sortedSetScores(`tid:${postResult.topicData.tid}:posters`, [oldUid, newUid]), [0, 2]);\n\n\t\tassert.deepStrictEqual(await posts.isOwner([pid1, pid2], oldUid), [false, false]);\n\t\tassert.deepStrictEqual(await posts.isOwner([pid1, pid2], newUid), [true, true]);\n\n\t\tassert.strictEqual(await user.getUserField(oldUid, 'postcount'), 0);\n\t\tassert.strictEqual(await user.getUserField(newUid, 'postcount'), 2);\n\n\t\tassert.strictEqual(await user.getUserField(oldUid, 'topiccount'), 0);\n\t\tassert.strictEqual(await user.getUserField(newUid, 'topiccount'), 1);\n\n\t\tassert.strictEqual(await db.sortedSetScore('users:postcount', oldUid), 0);\n\t\tassert.strictEqual(await db.sortedSetScore('users:postcount', newUid), 2);\n\n\t\tassert.strictEqual(await topics.isOwner(postResult.topicData.tid, oldUid), false);\n\t\tassert.strictEqual(await topics.isOwner(postResult.topicData.tid, newUid), true);\n\t});\n\n\tit('should fail to change owner if new owner does not exist', async () => {\n\t\ttry {\n\t\t\tawait posts.changeOwner([1], '9999999');\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:no-user]]');\n\t\t}\n\t});\n\n\tit('should fail to change owner if user is not authorized', async () => {\n\t\ttry {\n\t\t\tawait socketPosts.changeOwner({ uid: voterUid }, { pids: [1, 2], toUid: voterUid });\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:no-privileges]]');\n\t\t}\n\t});\n\n\tit('should return falsy if post does not exist', (done) => {\n\t\tposts.getPostData(9999, (err, postData) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(postData, null);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('voting', () => {\n\t\tit('should fail to upvote post if group does not have upvote permission', (done) => {\n\t\t\tprivileges.categories.rescind(['groups:posts:upvote', 'groups:posts:downvote'], cid, 'registered-users', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.upvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\t\tsocketPosts.downvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err) => {\n\t\t\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\t\t\tprivileges.categories.give(['groups:posts:upvote', 'groups:posts:downvote'], cid, 'registered-users', (err) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should upvote a post', (done) => {\n\t\t\tsocketPosts.upvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(result.post.upvotes, 1);\n\t\t\t\tassert.equal(result.post.downvotes, 0);\n\t\t\t\tassert.equal(result.post.votes, 1);\n\t\t\t\tassert.equal(result.user.reputation, 1);\n\t\t\t\tposts.hasVoted(postData.pid, voterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.upvoted, true);\n\t\t\t\t\tassert.equal(data.downvoted, false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should get voters', (done) => {\n\t\t\tsocketPosts.getVoters({ uid: globalModUid }, { pid: postData.pid, cid: cid }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.upvoteCount, 1);\n\t\t\t\tassert.equal(data.downvoteCount, 0);\n\t\t\t\tassert(Array.isArray(data.upvoters));\n\t\t\t\tassert.equal(data.upvoters[0].username, 'upvoter');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get upvoters', (done) => {\n\t\t\tsocketPosts.getUpvoters({ uid: globalModUid }, [postData.pid], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data[0].otherCount, 0);\n\t\t\t\tassert.equal(data[0].usernames, 'upvoter');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should unvote a post', (done) => {\n\t\t\tsocketPosts.unvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(result.post.upvotes, 0);\n\t\t\t\tassert.equal(result.post.downvotes, 0);\n\t\t\t\tassert.equal(result.post.votes, 0);\n\t\t\t\tassert.equal(result.user.reputation, 0);\n\t\t\t\tposts.hasVoted(postData.pid, voterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.upvoted, false);\n\t\t\t\t\tassert.equal(data.downvoted, false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should downvote a post', (done) => {\n\t\t\tsocketPosts.downvote({ uid: voterUid }, { pid: postData.pid, room_id: 'topic_1' }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(result.post.upvotes, 0);\n\t\t\t\tassert.equal(result.post.downvotes, 1);\n\t\t\t\tassert.equal(result.post.votes, -1);\n\t\t\t\tassert.equal(result.user.reputation, -1);\n\t\t\t\tposts.hasVoted(postData.pid, voterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.upvoted, false);\n\t\t\t\t\tassert.equal(data.downvoted, true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should prevent downvoting more than total daily limit', async () => {\n\t\t\tconst oldValue = meta.config.downvotesPerDay;\n\t\t\tmeta.config.downvotesPerDay = 1;\n\t\t\tlet err;\n\t\t\tconst p1 = await topics.reply({\n\t\t\t\tuid: voteeUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\tcontent: 'raw content',\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tawait socketPosts.downvote({ uid: voterUid }, { pid: p1.pid, room_id: 'topic_1' });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.equal(err.message, '[[error:too-many-downvotes-today, 1]]');\n\t\t\tmeta.config.downvotesPerDay = oldValue;\n\t\t});\n\n\t\tit('should prevent downvoting target user more than total daily limit', async () => {\n\t\t\tconst oldValue = meta.config.downvotesPerUserPerDay;\n\t\t\tmeta.config.downvotesPerUserPerDay = 1;\n\t\t\tlet err;\n\t\t\tconst p1 = await topics.reply({\n\t\t\t\tuid: voteeUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\tcontent: 'raw content',\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tawait socketPosts.downvote({ uid: voterUid }, { pid: p1.pid, room_id: 'topic_1' });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.equal(err.message, '[[error:too-many-downvotes-today-user, 1]]');\n\t\t\tmeta.config.downvotesPerUserPerDay = oldValue;\n\t\t});\n\t});\n\n\tdescribe('bookmarking', () => {\n\t\tit('should bookmark a post', (done) => {\n\t\t\tsocketPosts.bookmark({ uid: voterUid }, { pid: postData.pid, room_id: `topic_${postData.tid}` }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.isBookmarked, true);\n\t\t\t\tposts.hasBookmarked(postData.pid, voterUid, (err, hasBookmarked) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(hasBookmarked, true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should unbookmark a post', (done) => {\n\t\t\tsocketPosts.unbookmark({ uid: voterUid }, { pid: postData.pid, room_id: `topic_${postData.tid}` }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.isBookmarked, false);\n\t\t\t\tposts.hasBookmarked([postData.pid], voterUid, (err, hasBookmarked) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(hasBookmarked[0], false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('post tools', () => {\n\t\tit('should error if data is invalid', (done) => {\n\t\t\tsocketPosts.loadPostTools({ uid: globalModUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load post tools', (done) => {\n\t\t\tsocketPosts.loadPostTools({ uid: globalModUid }, { pid: postData.pid, cid: cid }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data.posts.display_edit_tools);\n\t\t\t\tassert(data.posts.display_delete_tools);\n\t\t\t\tassert(data.posts.display_moderator_tools);\n\t\t\t\tassert(data.posts.display_move_tools);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('delete/restore/purge', () => {\n\t\tfunction createTopicWithReply(callback) {\n\t\t\ttopics.post({\n\t\t\t\tuid: voterUid,\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'topic to delete/restore/purge',\n\t\t\t\tcontent: 'A post to delete/restore/purge',\n\t\t\t}, (err, topicPostData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttopics.reply({\n\t\t\t\t\tuid: voterUid,\n\t\t\t\t\ttid: topicPostData.topicData.tid,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\tcontent: 'A post to delete/restore and purge',\n\t\t\t\t}, (err, replyData) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tcallback(topicPostData, replyData);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tlet tid;\n\t\tlet mainPid;\n\t\tlet replyPid;\n\n\t\tbefore((done) => {\n\t\t\tcreateTopicWithReply((topicPostData, replyData) => {\n\t\t\t\ttid = topicPostData.topicData.tid;\n\t\t\t\tmainPid = topicPostData.postData.pid;\n\t\t\t\treplyPid = replyData.pid;\n\t\t\t\tprivileges.categories.give(['groups:purge'], cid, 'registered-users', done);\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\tsocketPosts.delete({ uid: voterUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should delete a post', (done) => {\n\t\t\tsocketPosts.delete({ uid: voterUid }, { pid: replyPid, tid: tid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'deleted', (err, isDeleted) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(isDeleted, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not see post content if global mod does not have posts:view_deleted privilege', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tuser.create({ username: 'global mod', password: '123456' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tgroups.join('Global Moderators', uid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tprivileges.categories.rescind(['groups:posts:view_deleted'], cid, 'Global Moderators', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\thelpers.loginUser('global mod', '123456', (err, _jar) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tconst jar = _jar;\n\n\t\t\t\t\t\trequest(`${nconf.get('url')}/api/topic/${tid}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(body.posts[1].content, '[[topic:post_is_deleted]]');\n\t\t\t\t\t\t\tprivileges.categories.give(['groups:posts:view_deleted'], cid, 'Global Moderators', next);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should restore a post', (done) => {\n\t\t\tsocketPosts.restore({ uid: voterUid }, { pid: replyPid, tid: tid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'deleted', (err, isDeleted) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(isDeleted, 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should delete posts', (done) => {\n\t\t\tsocketPosts.deletePosts({ uid: globalModUid }, { pids: [replyPid, mainPid] }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'deleted', (err, deleted) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(deleted, 1);\n\t\t\t\t\tposts.getPostField(mainPid, 'deleted', (err, deleted) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(deleted, 1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should delete topic if last main post is deleted', (done) => {\n\t\t\ttopics.post({ uid: voterUid, cid: cid, title: 'test topic', content: 'test topic' }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.deletePosts({ uid: globalModUid }, { pids: [data.postData.pid] }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\ttopics.getTopicField(data.topicData.tid, 'deleted', (err, deleted) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(deleted, 1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should purge posts and purge topic', (done) => {\n\t\t\tcreateTopicWithReply((topicPostData, replyData) => {\n\t\t\t\tsocketPosts.purgePosts({ uid: voterUid }, {\n\t\t\t\t\tpids: [replyData.pid, topicPostData.postData.pid],\n\t\t\t\t\ttid: topicPostData.topicData.tid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tposts.exists(`post:${replyData.pid}`, (err, exists) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(exists, false);\n\t\t\t\t\t\ttopics.exists(topicPostData.topicData.tid, (err, exists) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert(!exists);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('edit', () => {\n\t\tlet pid;\n\t\tlet replyPid;\n\t\tlet tid;\n\t\tbefore((done) => {\n\t\t\ttopics.post({\n\t\t\t\tuid: voterUid,\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'topic to edit',\n\t\t\t\tcontent: 'A post to edit',\n\t\t\t}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tpid = data.postData.pid;\n\t\t\t\ttid = data.topicData.tid;\n\t\t\t\ttopics.reply({\n\t\t\t\t\tuid: voterUid,\n\t\t\t\t\ttid: tid,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\tcontent: 'A reply to edit',\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\treplyPid = data.pid;\n\t\t\t\t\tprivileges.categories.give(['groups:posts:edit'], cid, 'registered-users', done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if user is not logged in', (done) => {\n\t\t\tsocketPosts.edit({ uid: 0 }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:not-logged-in]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if data is invalid or missing', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if title is too short', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', title: 'a' }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:title-too-short, ${meta.config.minimumTitleLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if title is too long', (done) => {\n\t\t\tconst longTitle = new Array(meta.config.maximumTitleLength + 2).join('a');\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', title: longTitle }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:title-too-long, ${meta.config.maximumTitleLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with too few tags', (done) => {\n\t\t\tconst oldValue = meta.config.minimumTagsPerTopic;\n\t\t\tmeta.config.minimumTagsPerTopic = 1;\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', tags: [] }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:not-enough-tags, ${meta.config.minimumTagsPerTopic}]]`);\n\t\t\t\tmeta.config.minimumTagsPerTopic = oldValue;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with too many tags', (done) => {\n\t\t\tconst tags = [];\n\t\t\tfor (let i = 0; i < meta.config.maximumTagsPerTopic + 1; i += 1) {\n\t\t\t\ttags.push(`tag${i}`);\n\t\t\t}\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content', tags: tags }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:too-many-tags, ${meta.config.maximumTagsPerTopic}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if content is too short', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'e' }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:content-too-short, ${meta.config.minimumPostLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if content is too long', (done) => {\n\t\t\tconst longContent = new Array(meta.config.maximumPostLength + 2).join('a');\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: longContent }, (err) => {\n\t\t\t\tassert.equal(err.message, `[[error:content-too-long, ${meta.config.maximumPostLength}]]`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should edit post', async () => {\n\t\t\tconst data = await socketPosts.edit({ uid: voterUid }, {\n\t\t\t\tpid: pid,\n\t\t\t\tcontent: 'edited post content',\n\t\t\t\ttitle: 'edited title',\n\t\t\t\ttags: ['edited'],\n\t\t\t});\n\n\t\t\tassert.strictEqual(data.content, 'edited post content');\n\t\t\tassert.strictEqual(data.editor, voterUid);\n\t\t\tassert.strictEqual(data.topic.title, 'edited title');\n\t\t\tassert.strictEqual(data.topic.tags[0].value, 'edited');\n\t\t\tconst res = await db.getObject(`post:${pid}`);\n\t\t\tassert(!res.hasOwnProperty('bookmarks'));\n\t\t});\n\n\t\tit('should disallow post editing for new users if post was made past the threshold for editing', (done) => {\n\t\t\tmeta.config.newbiePostEditDuration = 1;\n\t\t\tsetTimeout(() => {\n\t\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited post content again', title: 'edited title again', tags: ['edited-twice'] }, (err, data) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:post-edit-duration-expired, 1]]');\n\t\t\t\t\tmeta.config.newbiePostEditDuration = 3600;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t}, 1000);\n\t\t});\n\n\t\tit('should edit a deleted post', (done) => {\n\t\t\tsocketPosts.delete({ uid: voterUid }, { pid: pid, tid: tid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: pid, content: 'edited deleted content', title: 'edited deleted title', tags: ['deleted'] }, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data.content, 'edited deleted content');\n\t\t\t\t\tassert.equal(data.editor, voterUid);\n\t\t\t\t\tassert.equal(data.topic.title, 'edited deleted title');\n\t\t\t\t\tassert.equal(data.topic.tags[0].value, 'deleted');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should edit a reply post', (done) => {\n\t\t\tsocketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'edited reply' }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.content, 'edited reply');\n\t\t\t\tassert.equal(data.editor, voterUid);\n\t\t\t\tassert.equal(data.topic.isMainPost, false);\n\t\t\t\tassert.equal(data.topic.renamed, false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return diffs', (done) => {\n\t\t\tposts.diffs.get(replyPid, 0, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(Array.isArray(data));\n\t\t\t\tassert(data[0].pid, replyPid);\n\t\t\t\tassert(data[0].patch);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load diffs and reconstruct post', (done) => {\n\t\t\tposts.diffs.load(replyPid, 0, voterUid, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.content, 'A reply to edit');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not allow guests to view diffs', (done) => {\n\t\t\tsocketPosts.getDiffs({ uid: 0 }, { pid: 1 }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should allow registered-users group to view diffs', (done) => {\n\t\t\tsocketPosts.getDiffs({ uid: 1 }, { pid: 1 }, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tassert.strictEqual('boolean', typeof data.editable);\n\t\t\t\tassert.strictEqual(false, data.editable);\n\n\t\t\t\tassert.equal(true, Array.isArray(data.timestamps));\n\t\t\t\tassert.strictEqual(1, data.timestamps.length);\n\n\t\t\t\tassert.equal(true, Array.isArray(data.revisions));\n\t\t\t\tassert.strictEqual(data.timestamps.length, data.revisions.length);\n\t\t\t\t['timestamp', 'username'].every(prop => Object.keys(data.revisions[0]).includes(prop));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not delete first diff of a post', async () => {\n\t\t\tconst timestamps = await posts.diffs.list(replyPid);\n\t\t\tawait assert.rejects(async () => {\n\t\t\t\tawait posts.diffs.delete(replyPid, timestamps[0], voterUid);\n\t\t\t}, {\n\t\t\t\tmessage: '[[error:invalid-data]]',\n\t\t\t});\n\t\t});\n\n\t\tit('should delete a post diff', async () => {\n\t\t\tawait socketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'another edit has been made' });\n\t\t\tawait socketPosts.edit({ uid: voterUid }, { pid: replyPid, content: 'most recent edit' });\n\t\t\tconst timestamp = (await posts.diffs.list(replyPid)).pop();\n\t\t\tawait posts.diffs.delete(replyPid, timestamp, voterUid);\n\t\t\tconst differentTimestamp = (await posts.diffs.list(replyPid)).pop();\n\t\t\tassert.notStrictEqual(timestamp, differentTimestamp);\n\t\t});\n\n\t\tit('should load (oldest) diff and reconstruct post correctly after a diff deletion', async () => {\n\t\t\tconst data = await posts.diffs.load(replyPid, 0, voterUid);\n\t\t\tassert.strictEqual(data.content, 'A reply to edit');\n\t\t});\n\t});\n\n\tdescribe('move', () => {\n\t\tlet replyPid;\n\t\tlet tid;\n\t\tlet moveTid;\n\n\t\tbefore((done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\ttopics.post({\n\t\t\t\t\t\tuid: voterUid,\n\t\t\t\t\t\tcid: cid,\n\t\t\t\t\t\ttitle: 'topic 1',\n\t\t\t\t\t\tcontent: 'some content',\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t\tfunction (data, next) {\n\t\t\t\t\ttid = data.topicData.tid;\n\t\t\t\t\ttopics.post({\n\t\t\t\t\t\tuid: voterUid,\n\t\t\t\t\t\tcid: cid,\n\t\t\t\t\t\ttitle: 'topic 2',\n\t\t\t\t\t\tcontent: 'some content',\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t\tfunction (data, next) {\n\t\t\t\t\tmoveTid = data.topicData.tid;\n\t\t\t\t\ttopics.reply({\n\t\t\t\t\t\tuid: voterUid,\n\t\t\t\t\t\ttid: tid,\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t\tcontent: 'A reply to move',\n\t\t\t\t\t}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\treplyPid = data.pid;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should error if uid is not logged in', (done) => {\n\t\t\tsocketPosts.movePost({ uid: 0 }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:not-logged-in]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if data is invalid', (done) => {\n\t\t\tsocketPosts.movePost({ uid: globalModUid }, {}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if user does not have move privilege', (done) => {\n\t\t\tsocketPosts.movePost({ uid: voterUid }, { pid: replyPid, tid: moveTid }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\n\t\tit('should move a post', (done) => {\n\t\t\tsocketPosts.movePost({ uid: globalModUid }, { pid: replyPid, tid: moveTid }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.getPostField(replyPid, 'tid', (err, tid) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(tid, moveTid);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to move post if not moderator of target category', async () => {\n\t\t\tconst cat1 = await categories.create({ name: 'Test Category', description: 'Test category created by testing script' });\n\t\t\tconst cat2 = await categories.create({ name: 'Test Category', description: 'Test category created by testing script' });\n\t\t\tconst result = await socketTopics.post({ uid: globalModUid }, { title: 'target topic', content: 'queued topic', cid: cat2.cid });\n\t\t\tconst modUid = await user.create({ username: 'modofcat1' });\n\t\t\tawait privileges.categories.give(privileges.categories.userPrivilegeList, cat1.cid, modUid);\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait socketPosts.movePost({ uid: modUid }, { pid: replyPid, tid: result.tid });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:no-privileges]]');\n\t\t});\n\t});\n\n\tdescribe('getPostSummaryByPids', () => {\n\t\tit('should return empty array for empty pids', (done) => {\n\t\t\tposts.getPostSummaryByPids([], 0, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get post summaries', (done) => {\n\t\t\tposts.getPostSummaryByPids([postData.pid], 0, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data[0].user);\n\t\t\t\tassert(data[0].topic);\n\t\t\t\tassert(data[0].category);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get recent poster uids', (done) => {\n\t\ttopics.reply({\n\t\t\tuid: voterUid,\n\t\t\ttid: topicData.tid,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontent: 'some content',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tposts.getRecentPosterUids(0, 1, (err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(Array.isArray(uids));\n\t\t\t\tassert.equal(uids.length, 2);\n\t\t\t\tassert.equal(uids[0], voterUid);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('parse', () => {\n\t\tit('should not crash and return falsy if post data is falsy', (done) => {\n\t\t\tposts.parsePost(null, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(postData, null);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should store post content in cache', (done) => {\n\t\t\tconst oldValue = global.env;\n\t\t\tglobal.env = 'production';\n\t\t\tconst postData = {\n\t\t\t\tpid: 9999,\n\t\t\t\tcontent: 'some post content',\n\t\t\t};\n\t\t\tposts.parsePost(postData, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tposts.parsePost(postData, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tglobal.env = oldValue;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should parse signature and remove links and images', (done) => {\n\t\t\tmeta.config['signatures:disableLinks'] = 1;\n\t\t\tmeta.config['signatures:disableImages'] = 1;\n\t\t\tconst userData = {\n\t\t\t\tsignature: '<img src=\"boop\"/><a href=\"link\">test</a> derp',\n\t\t\t};\n\n\t\t\tposts.parseSignature(userData, 1, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.userData.signature, 'test derp');\n\t\t\t\tmeta.config['signatures:disableLinks'] = 0;\n\t\t\t\tmeta.config['signatures:disableImages'] = 0;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should turn relative links in post body to absolute urls', (done) => {\n\t\t\tconst nconf = require('nconf');\n\t\t\tconst content = '<a href=\"/users\">test</a> <a href=\"youtube.com\">youtube</a>';\n\t\t\tconst parsedContent = posts.relativeToAbsolute(content, posts.urlRegex);\n\t\t\tassert.equal(parsedContent, `<a href=\"${nconf.get('base_url')}/users\">test</a> <a href=\"//youtube.com\">youtube</a>`);\n\t\t\tdone();\n\t\t});\n\n\t\tit('should turn relative links in post body to absolute urls', (done) => {\n\t\t\tconst nconf = require('nconf');\n\t\t\tconst content = '<a href=\"/users\">test</a> <a href=\"youtube.com\">youtube</a> some test <img src=\"/path/to/img\"/>';\n\t\t\tlet parsedContent = posts.relativeToAbsolute(content, posts.urlRegex);\n\t\t\tparsedContent = posts.relativeToAbsolute(parsedContent, posts.imgRegex);\n\t\t\tassert.equal(parsedContent, `<a href=\"${nconf.get('base_url')}/users\">test</a> <a href=\"//youtube.com\">youtube</a> some test <img src=\"${nconf.get('base_url')}/path/to/img\"/>`);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('socket methods', () => {\n\t\tlet pid;\n\t\tbefore((done) => {\n\t\t\ttopics.reply({\n\t\t\t\tuid: voterUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tcontent: 'raw content',\n\t\t\t}, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tpid = postData.pid;\n\t\t\t\tprivileges.categories.rescind(['groups:topics:read'], cid, 'guests', done);\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\tsocketPosts.reply({ uid: 0 }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid tid', (done) => {\n\t\t\tsocketPosts.reply({ uid: 0 }, { tid: 0, content: 'derp' }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to get raw post because of privilege', (done) => {\n\t\t\tsocketPosts.getRawPost({ uid: 0 }, pid, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to get raw post because post is deleted', (done) => {\n\t\t\tposts.setPostField(pid, 'deleted', 1, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.getRawPost({ uid: voterUid }, pid, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:no-post]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should get raw post content', (done) => {\n\t\t\tposts.setPostField(pid, 'deleted', 0, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketPosts.getRawPost({ uid: voterUid }, pid, (err, postContent) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(postContent, 'raw content');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should get post', (done) => {\n\t\t\tsocketPosts.getPost({ uid: voterUid }, pid, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(postData);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get post category', (done) => {\n\t\t\tsocketPosts.getCategory({ uid: voterUid }, pid, (err, postCid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(cid, postCid);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\tsocketPosts.getPidIndex({ uid: voterUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get pid index', (done) => {\n\t\t\tsocketPosts.getPidIndex({ uid: voterUid }, { pid: pid, tid: topicData.tid, topicPostSort: 'oldest_to_newest' }, (err, index) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(index, 4);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get pid index in reverse', (done) => {\n\t\t\ttopics.reply({\n\t\t\t\tuid: voterUid,\n\t\t\t\ttid: topicData.tid,\n\t\t\t\tcontent: 'raw content',\n\t\t\t}, (err, postData) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tsocketPosts.getPidIndex({ uid: voterUid }, { pid: postData.pid, tid: topicData.tid, topicPostSort: 'newest_to_oldest' }, (err, index) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(index, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('filterPidsByCid', () => {\n\t\tit('should return pids as is if cid is falsy', (done) => {\n\t\t\tposts.filterPidsByCid([1, 2, 3], null, (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([1, 2, 3], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should filter pids by single cid', (done) => {\n\t\t\tposts.filterPidsByCid([postData.pid, 100, 101], cid, (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([postData.pid], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should filter pids by multiple cids', (done) => {\n\t\t\tposts.filterPidsByCid([postData.pid, 100, 101], [cid, 2, 3], (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([postData.pid], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should filter pids by multiple cids', (done) => {\n\t\t\tposts.filterPidsByCid([postData.pid, 100, 101], [cid], (err, pids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.deepEqual([postData.pid], pids);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should error if user does not exist', (done) => {\n\t\tuser.isReadyToPost(21123123, 1, (err) => {\n\t\t\tassert.equal(err.message, '[[error:no-user]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('post queue', () => {\n\t\tlet uid;\n\t\tlet queueId;\n\t\tlet topicQueueId;\n\t\tlet jar;\n\t\tbefore((done) => {\n\t\t\tmeta.config.postQueue = 1;\n\t\t\tuser.create({ username: 'newuser' }, (err, _uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuid = _uid;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.postQueue = 0;\n\t\t\tmeta.config.groupsExemptFromPostQueue = [];\n\t\t\tdone();\n\t\t});\n\n\t\tit('should add topic to post queue', (done) => {\n\t\t\tsocketTopics.post({ uid: uid }, { title: 'should be queued', content: 'queued topic content', cid: cid }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(result.queued, true);\n\t\t\t\tassert.equal(result.message, '[[success:post-queued]]');\n\t\t\t\ttopicQueueId = result.id;\n\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should add reply to post queue', (done) => {\n\t\t\tsocketPosts.reply({ uid: uid }, { content: 'this is a queued reply', tid: topicData.tid }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(result.queued, true);\n\t\t\t\tassert.equal(result.message, '[[success:post-queued]]');\n\t\t\t\tqueueId = result.id;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load queued posts', (done) => {\n\t\t\thelpers.loginUser('globalmod', 'globalmodpwd', (err, _jar) => {\n\t\t\t\tjar = _jar;\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[0].type, 'topic');\n\t\t\t\t\tassert.equal(body.posts[0].data.content, 'queued topic content');\n\t\t\t\t\tassert.equal(body.posts[1].type, 'reply');\n\t\t\t\t\tassert.equal(body.posts[1].data.content, 'this is a queued reply');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if data is invalid', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should edit post in queue', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: queueId, content: 'newContent' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[1].type, 'reply');\n\t\t\t\t\tassert.equal(body.posts[1].data.content, 'newContent');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should edit topic title in queue', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, title: 'new topic title' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[0].type, 'topic');\n\t\t\t\t\tassert.equal(body.posts[0].data.title, 'new topic title');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should edit topic category in queue', (done) => {\n\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, cid: 2 }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post-queue`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(body.posts[0].type, 'topic');\n\t\t\t\t\tassert.equal(body.posts[0].data.cid, 2);\n\t\t\t\t\tsocketPosts.editQueuedContent({ uid: globalModUid }, { id: topicQueueId, cid: cid }, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should prevent regular users from approving posts', (done) => {\n\t\t\tsocketPosts.accept({ uid: uid }, { id: queueId }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should prevent regular users from approving non existing posts', (done) => {\n\t\t\tsocketPosts.accept({ uid: uid }, { id: 123123 }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should accept queued posts and submit', (done) => {\n\t\t\tlet ids;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tdb.getSortedSetRange('post:queue', 0, -1, next);\n\t\t\t\t},\n\t\t\t\tfunction (_ids, next) {\n\t\t\t\t\tids = _ids;\n\t\t\t\t\tsocketPosts.accept({ uid: globalModUid }, { id: ids[0] }, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsocketPosts.accept({ uid: globalModUid }, { id: ids[1] }, next);\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should not crash if id does not exist', (done) => {\n\t\t\tsocketPosts.reject({ uid: globalModUid }, { id: '123123123' }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should bypass post queue if user is in exempt group', async () => {\n\t\t\tconst oldValue = meta.config.groupsExemptFromPostQueue;\n\t\t\tmeta.config.groupsExemptFromPostQueue = ['registered-users'];\n\t\t\tconst uid = await user.create({ username: 'mergeexemptuser' });\n\t\t\tconst result = await socketTopics.post({ uid: uid, emit: () => {} }, { title: 'should not be queued', content: 'topic content', cid: cid });\n\t\t\tassert.strictEqual(result.title, 'should not be queued');\n\t\t\tmeta.config.groupsExemptFromPostQueue = oldValue;\n\t\t});\n\n\t\tit('should update queued post\\'s topic if target topic is merged', async () => {\n\t\t\tconst uid = await user.create({ username: 'mergetestsuser' });\n\t\t\tconst result1 = await socketTopics.post({ uid: globalModUid }, { title: 'topic A', content: 'topic A content', cid: cid });\n\t\t\tconst result2 = await socketTopics.post({ uid: globalModUid }, { title: 'topic B', content: 'topic B content', cid: cid });\n\n\t\t\tconst result = await socketPosts.reply({ uid: uid }, { content: 'the moved queued post', tid: result1.tid });\n\n\t\t\tawait topics.merge([\n\t\t\t\tresult1.tid, result2.tid,\n\t\t\t], globalModUid, { mainTid: result2.tid });\n\n\t\t\tlet postData = await posts.getQueuedPosts();\n\t\t\tpostData = postData.filter(p => parseInt(p.data.tid, 10) === parseInt(result2.tid, 10));\n\t\t\tassert.strictEqual(postData.length, 1);\n\t\t\tassert.strictEqual(postData[0].data.content, 'the moved queued post');\n\t\t\tassert.strictEqual(postData[0].data.tid, result2.tid);\n\t\t});\n\t});\n\n\tdescribe('upload methods', () => {\n\t\tlet pid;\n\t\tlet purgePid;\n\n\t\tbefore(async () => {\n\t\t\t// Create stub files for testing\n\t\t\t['abracadabra.png', 'shazam.jpg', 'whoa.gif', 'amazeballs.jpg', 'wut.txt', 'test.bmp']\n\t\t\t\t.forEach(filename => fs.closeSync(fs.openSync(path.join(nconf.get('upload_path'), 'files', filename), 'w')));\n\n\t\t\tconst topicPostData = await topics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid: 1,\n\t\t\t\ttitle: 'topic with some images',\n\t\t\t\tcontent: 'here is an image [alt text](/assets/uploads/files/abracadabra.png) and another [alt text](/assets/uploads/files/shazam.jpg)',\n\t\t\t});\n\t\t\tpid = topicPostData.postData.pid;\n\n\t\t\tconst purgePostData = await topics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid: 1,\n\t\t\t\ttitle: 'topic with some images, to be purged',\n\t\t\t\tcontent: 'here is an image [alt text](/assets/uploads/files/whoa.gif) and another [alt text](/assets/uploads/files/amazeballs.jpg)',\n\t\t\t});\n\t\t\tpurgePid = purgePostData.postData.pid;\n\t\t});\n\n\t\tdescribe('.sync()', () => {\n\t\t\tit('should properly add new images to the post\\'s zset', (done) => {\n\t\t\t\tposts.uploads.sync(pid, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tdb.sortedSetCard(`post:${pid}:uploads`, (err, length) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(length, 2);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should remove an image if it is edited out of the post', (done) => {\n\t\t\t\tasync.series([\n\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\tposts.edit({\n\t\t\t\t\t\t\tpid: pid,\n\t\t\t\t\t\t\tuid: 1,\n\t\t\t\t\t\t\tcontent: 'here is an image [alt text](/assets/uploads/files/abracadabra.png)... AND NO MORE!',\n\t\t\t\t\t\t}, next);\n\t\t\t\t\t},\n\t\t\t\t\tasync.apply(posts.uploads.sync, pid),\n\t\t\t\t], (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdb.sortedSetCard(`post:${pid}:uploads`, (err, length) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(1, length);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.list()', () => {\n\t\t\tit('should display the uploaded files for a specific post', (done) => {\n\t\t\t\tposts.uploads.list(pid, (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(true, Array.isArray(uploads));\n\t\t\t\t\tassert.strictEqual(1, uploads.length);\n\t\t\t\t\tassert.equal('string', typeof uploads[0]);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.isOrphan()', () => {\n\t\t\tit('should return false if upload is not an orphan', (done) => {\n\t\t\t\tposts.uploads.isOrphan('abracadabra.png', (err, isOrphan) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(false, isOrphan);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return true if upload is an orphan', (done) => {\n\t\t\t\tposts.uploads.isOrphan('shazam.jpg', (err, isOrphan) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(true, isOrphan);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.associate()', () => {\n\t\t\tit('should add an image to the post\\'s maintained list of uploads', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, 'whoa.gif'),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(2, uploads.length);\n\t\t\t\t\tassert.strictEqual(true, uploads.includes('whoa.gif'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should allow arrays to be passed in', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, ['amazeballs.jpg', 'wut.txt']),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(4, uploads.length);\n\t\t\t\t\tassert.strictEqual(true, uploads.includes('amazeballs.jpg'));\n\t\t\t\t\tassert.strictEqual(true, uploads.includes('wut.txt'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should save a reverse association of md5sum to pid', (done) => {\n\t\t\t\tconst md5 = filename => crypto.createHash('md5').update(filename).digest('hex');\n\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, ['test.bmp']),\n\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\tdb.getSortedSetRange(`upload:${md5('test.bmp')}:pids`, 0, -1, next);\n\t\t\t\t\t},\n\t\t\t\t], (err, pids) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(true, Array.isArray(pids));\n\t\t\t\t\tassert.strictEqual(true, pids.length > 0);\n\t\t\t\t\tassert.equal(pid, pids[0]);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should not associate a file that does not exist on the local disk', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.associate, pid, ['nonexistant.xls']),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(uploads.length, 5);\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('nonexistant.xls'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.dissociate()', () => {\n\t\t\tit('should remove an image from the post\\'s maintained list of uploads', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.dissociate, pid, 'whoa.gif'),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(4, uploads.length);\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('whoa.gif'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should allow arrays to be passed in', (done) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(posts.uploads.dissociate, pid, ['amazeballs.jpg', 'wut.txt']),\n\t\t\t\t\tasync.apply(posts.uploads.list, pid),\n\t\t\t\t], (err, uploads) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(2, uploads.length);\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('amazeballs.jpg'));\n\t\t\t\t\tassert.strictEqual(false, uploads.includes('wut.txt'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.dissociateAll()', () => {\n\t\t\tit('should remove all images from a post\\'s maintained list of uploads', async () => {\n\t\t\t\tawait posts.uploads.dissociateAll(pid);\n\t\t\t\tconst uploads = await posts.uploads.list(pid);\n\n\t\t\t\tassert.equal(uploads.length, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Dissociation on purge', () => {\n\t\t\tit('should not dissociate images on post deletion', async () => {\n\t\t\t\tawait posts.delete(purgePid, 1);\n\t\t\t\tconst uploads = await posts.uploads.list(purgePid);\n\n\t\t\t\tassert.equal(uploads.length, 2);\n\t\t\t});\n\n\t\t\tit('should dissociate images on post purge', async () => {\n\t\t\t\tawait posts.purge(purgePid, 1);\n\t\t\t\tconst uploads = await posts.uploads.list(purgePid);\n\n\t\t\t\tassert.equal(uploads.length, 0);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('post uploads management', () => {\n\t\tlet topic;\n\t\tlet reply;\n\t\tbefore((done) => {\n\t\t\ttopics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'topic to test uploads with',\n\t\t\t\tcontent: '[abcdef](/assets/uploads/files/abracadabra.png)',\n\t\t\t}, (err, topicPostData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttopics.reply({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\ttid: topicPostData.topicData.tid,\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\tcontent: '[abcdef](/assets/uploads/files/shazam.jpg)',\n\t\t\t\t}, (err, replyData) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\ttopic = topicPostData;\n\t\t\t\t\treply = replyData;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should automatically sync uploads on topic create and reply', (done) => {\n\t\t\tdb.sortedSetsCard([`post:${topic.topicData.mainPid}:uploads`, `post:${reply.pid}:uploads`], (err, lengths) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(1, lengths[0]);\n\t\t\t\tassert.strictEqual(1, lengths[1]);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should automatically sync uploads on post edit', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tasync.apply(posts.edit, {\n\t\t\t\t\tpid: reply.pid,\n\t\t\t\t\tuid: 1,\n\t\t\t\t\tcontent: 'no uploads',\n\t\t\t\t}),\n\t\t\t\tfunction (postData, next) {\n\t\t\t\t\tposts.uploads.list(reply.pid, next);\n\t\t\t\t},\n\t\t\t], (err, uploads) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(true, Array.isArray(uploads));\n\t\t\t\tassert.strictEqual(0, uploads.length);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Topic Backlinks', () => {\n\t\tlet tid1;\n\t\tbefore(async () => {\n\t\t\ttid1 = await topics.post({\n\t\t\t\tuid: 1,\n\t\t\t\tcid,\n\t\t\t\ttitle: 'Topic backlink testing - topic 1',\n\t\t\t\tcontent: 'Some text here for the OP',\n\t\t\t});\n\t\t\ttid1 = tid1.topicData.tid;\n\t\t});\n\n\t\tdescribe('.syncBacklinks()', () => {\n\t\t\tit('should error on invalid data', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait topics.syncBacklinks();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tassert(e);\n\t\t\t\t\tassert.strictEqual(e.message, '[[error:invalid-data]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should do nothing if the post does not contain a link to a topic', async () => {\n\t\t\t\tconst backlinks = await topics.syncBacklinks({\n\t\t\t\t\tcontent: 'This is a post\\'s content',\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(backlinks, 0);\n\t\t\t});\n\n\t\t\tit('should create a backlink if it detects a topic link in a post', async () => {\n\t\t\t\tconst count = await topics.syncBacklinks({\n\t\t\t\t\tpid: 2,\n\t\t\t\t\tcontent: `This is a link to [topic 1](${nconf.get('url')}/topic/1/abcdef)`,\n\t\t\t\t});\n\t\t\t\tconst events = await topics.events.get(1, 1);\n\t\t\t\tconst backlinks = await db.getSortedSetMembers('pid:2:backlinks');\n\n\t\t\t\tassert.strictEqual(count, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\n\t\t\t\tassert(backlinks);\n\t\t\t\tassert(backlinks.includes('1'));\n\t\t\t});\n\n\t\t\tit('should remove the backlink (but keep the event) if the post no longer contains a link to a topic', async () => {\n\t\t\t\tconst count = await topics.syncBacklinks({\n\t\t\t\t\tpid: 2,\n\t\t\t\t\tcontent: 'This is a link to [nothing](http://example.org)',\n\t\t\t\t});\n\t\t\t\tconst events = await topics.events.get(1, 1);\n\t\t\t\tconst backlinks = await db.getSortedSetMembers('pid:2:backlinks');\n\n\t\t\t\tassert.strictEqual(count, 0);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\n\t\t\t\tassert(backlinks);\n\t\t\t\tassert.strictEqual(backlinks.length, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('integration tests', () => {\n\t\t\tit('should create a topic event in the referenced topic', async () => {\n\t\t\t\tconst topic = await topics.post({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\tcid,\n\t\t\t\t\ttitle: 'Topic backlink testing - topic 2',\n\t\t\t\t\tcontent: `Some text here for the OP &ndash; ${nconf.get('url')}/topic/${tid1}`,\n\t\t\t\t});\n\n\t\t\t\tconst events = await topics.events.get(tid1, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\n\t\t\t\tassert.strictEqual(events[0].type, 'backlink');\n\t\t\t\tassert.strictEqual(parseInt(events[0].uid, 10), 1);\n\t\t\t\tassert.strictEqual(events[0].href, `/post/${topic.postData.pid}`);\n\t\t\t});\n\n\t\t\tit('should not create a topic event if referenced topic is the same as current topic', async () => {\n\t\t\t\tawait topics.reply({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\ttid: tid1,\n\t\t\t\t\tcontent: `Referencing itself &ndash; ${nconf.get('url')}/topic/${tid1}`,\n\t\t\t\t});\n\n\t\t\t\tconst events = await topics.events.get(tid1, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 1);\t// should still equal 1\n\t\t\t});\n\n\t\t\tit('should not show backlink events if the feature is disabled', async () => {\n\t\t\t\tmeta.config.topicBacklinks = 0;\n\n\t\t\t\tawait topics.post({\n\t\t\t\t\tuid: 1,\n\t\t\t\t\tcid,\n\t\t\t\t\ttitle: 'Topic backlink testing - topic 3',\n\t\t\t\t\tcontent: `Some text here for the OP &ndash; ${nconf.get('url')}/topic/${tid1}`,\n\t\t\t\t});\n\n\t\t\t\tconst events = await topics.events.get(tid1, 1);\n\t\t\t\tassert(events);\n\t\t\t\tassert.strictEqual(events.length, 0);\n\t\t\t});\n\t\t});\n\t});\n});\n", "'use strict';\n\n// For tests relating to Transifex configuration, check i18n.js\n\nconst assert = require('assert');\nconst shim = require('../public/src/modules/translator');\n\nconst { Translator } = shim;\nconst db = require('./mocks/databasemock');\n\ndescribe('Translator shim', () => {\n\tdescribe('.translate()', () => {\n\t\tit('should translate correctly', (done) => {\n\t\t\tshim.translate('[[global:pagination.out_of, (foobar), [[global:home]]]]', (translated) => {\n\t\t\t\tassert.strictEqual(translated, '(foobar) out of Home');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should accept a language parameter and adjust accordingly', (done) => {\n\t\t\tshim.translate('[[global:home]]', 'de', (translated) => {\n\t\t\t\tassert.strictEqual(translated, '\u00dcbersicht');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should translate empty string properly', (done) => {\n\t\t\tshim.translate('', 'en-GB', (translated) => {\n\t\t\t\tassert.strictEqual(translated, '');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should translate empty string properly', async () => {\n\t\t\tconst translated = await shim.translate('', 'en-GB');\n\t\t\tassert.strictEqual(translated, '');\n\t\t});\n\n\t\tit('should not allow path traversal', async () => {\n\t\t\tconst t = await shim.translate('[[../../../../config:secret]]');\n\t\t\tassert.strictEqual(t, 'secret');\n\t\t});\n\t});\n});\n\ndescribe('new Translator(language)', () => {\n\tit('should throw if not passed a language', (done) => {\n\t\tassert.throws(() => {\n\t\t\tnew Translator();\n\t\t}, /language string/);\n\t\tdone();\n\t});\n\n\tdescribe('.translate()', () => {\n\t\tit('should handle basic translations', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:home]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys in regular text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('Let\\'s go [[global:home]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Let\\'s go Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys in regular text with another language specified', () => {\n\t\t\tconst translator = Translator.create('de');\n\n\t\t\treturn translator.translate('[[global:home]] test').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '\u00dcbersicht test');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys with parameters', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:pagination.out_of, 1, 5]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '1 out of 5');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys inside language keys', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[notifications:outgoing_link_message, [[global:guest]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'You are now leaving Guest');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys inside language keys with multiple parameters', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[notifications:user_posted_to, [[global:guest]], My Topic]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '<strong>Guest</strong> has posted a reply to: <strong>My Topic</strong>');\n\t\t\t});\n\t\t});\n\n\t\tit('should handle language keys inside language keys with all parameters as language keys', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[notifications:user_posted_to, [[global:guest]], [[global:guest]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '<strong>Guest</strong> has posted a reply to: <strong>Guest</strong>');\n\t\t\t});\n\t\t});\n\n\t\tit('should properly handle parameters that contain square brackets', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:pagination.out_of, [guest], [[global:home]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '[guest] out of Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should properly handle parameters that contain parentheses', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\treturn translator.translate('[[global:pagination.out_of, (foobar), [[global:home]]]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '(foobar) out of Home');\n\t\t\t});\n\t\t});\n\n\t\tit('should escape language key parameters with HTML in them', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst key = '[[global:403.login, <strong>test</strong>]]';\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Perhaps you should <a href=\\'&lt;strong&gt;test&lt;/strong&gt;/login\\'>try logging in</a>?');\n\t\t\t});\n\t\t});\n\n\t\tit('should not unescape html in parameters', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst key = '[[pages:tag, some&amp;tag]]';\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Topics tagged under &quot;some&amp;tag&quot;');\n\t\t\t});\n\t\t});\n\n\t\tit('should translate escaped translation arguments properly', () => {\n\t\t\t// https://github.com/NodeBB/NodeBB/issues/9206\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst key = '[[notifications:upvoted_your_post_in, test1, error: Error: &lsqb;&lsqb;error:group-name-too-long&rsqb;&rsqb; on NodeBB Upgrade]]';\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, '<strong>test1</strong> has upvoted your post in <strong>error: Error: &lsqb;&lsqb;error:group-name-too-long&rsqb;&rsqb; on NodeBB Upgrade</strong>.');\n\t\t\t});\n\t\t});\n\n\t\tit('should properly escape and ignore % and \\\\, in arguments', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst title = 'Test 1\\\\, 2\\\\, 3 %2 salmon';\n\t\t\tconst key = `[[topic:composer.replying_to, ${title}]]`;\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Replying to Test 1&#44; 2&#44; 3 &#37;2 salmon');\n\t\t\t});\n\t\t});\n\n\t\tit('should not escape regular %', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\n\t\t\tconst title = '3 % salmon';\n\t\t\tconst key = `[[topic:composer.replying_to, ${title}]]`;\n\t\t\treturn translator.translate(key).then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Replying to 3 % salmon');\n\t\t\t});\n\t\t});\n\n\t\tit('should not translate [[derp] some text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[derp] some text').then((translated) => {\n\t\t\t\tassert.strictEqual('[[derp] some text', translated);\n\t\t\t});\n\t\t});\n\n\t\tit('should not translate [[derp]] some text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[derp]] some text').then((translated) => {\n\t\t\t\tassert.strictEqual('[[derp]] some text', translated);\n\t\t\t});\n\t\t});\n\n\t\tit('should not translate [[derp:xyz] some text', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[derp:xyz] some text').then((translated) => {\n\t\t\t\tassert.strictEqual('[[derp:xyz] some text', translated);\n\t\t\t});\n\t\t});\n\n\t\tit('should translate keys with slashes properly', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[pages:users/latest]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'Latest Users');\n\t\t\t});\n\t\t});\n\n\t\tit('should use key for unknown keys without arguments', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[unknown:key.without.args]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'key.without.args');\n\t\t\t});\n\t\t});\n\n\t\tit('should use backup for unknown keys with arguments', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('[[unknown:key.with.args, arguments are here, derpity, derp]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'unknown:key.with.args, arguments are here, derpity, derp');\n\t\t\t});\n\t\t});\n\n\t\tit('should ignore unclosed tokens', () => {\n\t\t\tconst translator = Translator.create('en-GB');\n\t\t\treturn translator.translate('here is some stuff and other things [[abc:xyz, other random stuff should be fine here [[global:home]] and more things [[pages:users/latest]]').then((translated) => {\n\t\t\t\tassert.strictEqual(translated, 'here is some stuff and other things abc:xyz, other random stuff should be fine here Home and more things Latest Users');\n\t\t\t});\n\t\t});\n\t});\n});\n\ndescribe('Translator.create()', () => {\n\tit('should return an instance of Translator', (done) => {\n\t\tconst translator = Translator.create('en-GB');\n\n\t\tassert(translator instanceof Translator);\n\t\tdone();\n\t});\n\tit('should return the same object for the same language', (done) => {\n\t\tconst one = Translator.create('de');\n\t\tconst two = Translator.create('de');\n\n\t\tassert.strictEqual(one, two);\n\t\tdone();\n\t});\n\tit('should default to defaultLang', (done) => {\n\t\tconst translator = Translator.create();\n\n\t\tassert.strictEqual(translator.lang, 'en-GB');\n\t\tdone();\n\t});\n});\n\ndescribe('Translator modules', () => {\n\tit('should work before registered', () => {\n\t\tconst translator = Translator.create();\n\n\t\tTranslator.registerModule('test-custom-integer-format', lang => function (key, args) {\n\t\t\tconst num = parseInt(args[0], 10) || 0;\n\t\t\tif (key === 'binary') {\n\t\t\t\treturn num.toString(2);\n\t\t\t}\n\t\t\tif (key === 'hex') {\n\t\t\t\treturn num.toString(16);\n\t\t\t}\n\t\t\tif (key === 'octal') {\n\t\t\t\treturn num.toString(8);\n\t\t\t}\n\t\t\treturn num.toString();\n\t\t});\n\n\t\treturn translator.translate('[[test-custom-integer-format:octal, 24]]').then((translation) => {\n\t\t\tassert.strictEqual(translation, '30');\n\t\t});\n\t});\n\n\tit('should work after registered', () => {\n\t\tconst translator = Translator.create('de');\n\n\t\treturn translator.translate('[[test-custom-integer-format:octal, 23]]').then((translation) => {\n\t\t\tassert.strictEqual(translation, '27');\n\t\t});\n\t});\n\n\tit('registerModule be passed the language', (done) => {\n\t\tTranslator.registerModule('something', (lang) => {\n\t\t\tassert.ok(lang);\n\t\t});\n\n\t\tconst translator = Translator.create('fr_FR');\n\t\tdone();\n\t});\n});\n\ndescribe('Translator static methods', () => {\n\tdescribe('.removePatterns', () => {\n\t\tit('should remove translator patterns from text', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.removePatterns('Lorem ipsum dolor [[sit:amet]], consectetur adipiscing elit. [[sed:vitae, [[semper:dolor]]]] lorem'),\n\t\t\t\t'Lorem ipsum dolor , consectetur adipiscing elit.  lorem'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\tdescribe('.escape', () => {\n\t\tit('should escape translation patterns within text', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.escape('some nice text [[global:home]] here'),\n\t\t\t\t'some nice text &lsqb;&lsqb;global:home&rsqb;&rsqb; here'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('.unescape', () => {\n\t\tit('should unescape escaped translation patterns within text', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.unescape('some nice text \\\\[\\\\[global:home\\\\]\\\\] here'),\n\t\t\t\t'some nice text [[global:home]] here'\n\t\t\t);\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.unescape('some nice text &lsqb;&lsqb;global:home&rsqb;&rsqb; here'),\n\t\t\t\t'some nice text [[global:home]] here'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('.compile', () => {\n\t\tit('should create a translator pattern from a key and list of arguments', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.compile('amazing:cool', 'awesome', 'great'),\n\t\t\t\t'[[amazing:cool, awesome, great]]'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\n\t\tit('should escape `%` and `,` in arguments', (done) => {\n\t\t\tassert.strictEqual(\n\t\t\t\tTranslator.compile('amazing:cool', '100% awesome!', 'one, two, and three'),\n\t\t\t\t'[[amazing:cool, 100&#37; awesome!, one&#44; two&#44; and three]]'\n\t\t\t);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('add translation', () => {\n\t\tit('should add custom translations', async () => {\n\t\t\tshim.addTranslation('en-GB', 'my-namespace', { foo: 'a custom translation' });\n\t\t\tconst t = await shim.translate('this is best [[my-namespace:foo]]');\n\t\t\tassert.strictEqual(t, 'this is best a custom translation');\n\t\t});\n\t});\n\n\tdescribe('translate nested keys', () => {\n\t\tit('should handle nested translations', async () => {\n\t\t\tshim.addTranslation('en-GB', 'my-namespace', {\n\t\t\t\tkey: {\n\t\t\t\t\tkey1: 'key1 translated',\n\t\t\t\t\tkey2: {\n\t\t\t\t\t\tkey3: 'key3 translated',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t\tconst t1 = await shim.translate('this is best [[my-namespace:key.key1]]');\n\t\t\tconst t2 = await shim.translate('this is best [[my-namespace:key.key2.key3]]');\n\t\t\tassert.strictEqual(t1, 'this is best key1 translated');\n\t\t\tassert.strictEqual(t2, 'this is best key3 translated');\n\t\t});\n\t\tit(\"should try the defaults if it didn't reach a string in a nested translation\", async () => {\n\t\t\tshim.addTranslation('en-GB', 'my-namespace', {\n\t\t\t\tdefault1: {\n\t\t\t\t\tdefault1: 'default1 translated',\n\t\t\t\t\t'': 'incorrect priority',\n\t\t\t\t},\n\t\t\t\tdefault2: {\n\t\t\t\t\t'': 'default2 translated',\n\t\t\t\t},\n\t\t\t});\n\t\t\tconst d1 = await shim.translate('this is best [[my-namespace:default1]]');\n\t\t\tconst d2 = await shim.translate('this is best [[my-namespace:default2]]');\n\t\t\tassert.strictEqual(d1, 'this is best default1 translated');\n\t\t\tassert.strictEqual(d2, 'this is best default2 translated');\n\t\t});\n\t});\n});\n"], "filenames": ["src/languages.js", "test/posts.js", "test/translator.js"], "buggy_code_start_loc": [16, 4, 36], "buggy_code_end_loc": [17, 5, 36], "fixing_code_start_loc": [16, 4, 37], "fixing_code_end_loc": [21, 5, 42], "type": "CWE-22", "message": "Nodebb is an open source Node.js based forum software. Prior to v1.18.5, a path traversal vulnerability was present that allowed users to access JSON files outside of the expected `languages/` directory. The vulnerability has been patched as of v1.18.5. Users are advised to upgrade as soon as possible.", "other": {"cve": {"id": "CVE-2021-43788", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-29T20:15:08.253", "lastModified": "2022-10-27T19:32:51.133", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nodebb is an open source Node.js based forum software. Prior to v1.18.5, a path traversal vulnerability was present that allowed users to access JSON files outside of the expected `languages/` directory. The vulnerability has been patched as of v1.18.5. Users are advised to upgrade as soon as possible."}, {"lang": "es", "value": "Nodebb es un software de foro de c\u00f3digo abierto basado en Node.js. En versiones anteriores a v1.18.5, se presentaba una vulnerabilidad de salto de ruta que permit\u00eda a usuarios acceder a archivos JSON fuera del directorio esperado \"languages/\". La vulnerabilidad ha sido parcheada a partir de la versi\u00f3n v1.18.5. Se aconseja a usuarios que actualicen lo antes posible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.4", "versionEndIncluding": "1.18.4", "matchCriteriaId": "6B0118EF-AB2D-420C-A454-405F2058F38A"}]}]}], "references": [{"url": "https://blog.sonarsource.com/nodebb-remote-code-execution-with-one-shot/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/commit/c8b2fc46dc698db687379106b3f01c71b80f495f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/releases/tag/v1.18.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/security/advisories/GHSA-pfj7-2qfw-vwgm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/c8b2fc46dc698db687379106b3f01c71b80f495f"}}