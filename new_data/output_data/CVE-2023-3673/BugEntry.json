{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin;\n\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Types\\Types;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Log\\Handler\\ApplicationLoggerDb;\nuse Pimcore\\Tool\\Storage;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\StreamedResponse;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Exception\\AccessDeniedHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * @internal\n */\nclass LogController extends AdminController implements KernelControllerEventInterface\n{\n    /**\n     * @param ControllerEvent $event\n     */\n    public function onKernelControllerEvent(ControllerEvent $event)\n    {\n        if (!$this->getAdminUser()->isAllowed('application_logging')) {\n            throw new AccessDeniedHttpException(\"Permission denied, user needs 'application_logging' permission.\");\n        }\n    }\n\n    /**\n     * @Route(\"/log/show\", name=\"pimcore_admin_log_show\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function showAction(Request $request, Connection $db)\n    {\n        $qb = $db->createQueryBuilder();\n        $qb\n            ->select('*')\n            ->from(ApplicationLoggerDb::TABLE_NAME)\n            ->setFirstResult($request->get('start', 0))\n            ->setMaxResults($request->get('limit', 50));\n\n        $sortingSettings = QueryParams::extractSortingSettings(array_merge(\n            $request->request->all(),\n            $request->query->all()\n        ));\n\n        if ($sortingSettings['orderKey']) {\n            $qb->orderBy($sortingSettings['orderKey'], $sortingSettings['order']);\n        } else {\n            $qb->orderBy('id', 'DESC');\n        }\n\n        $priority = $request->get('priority');\n        if(!empty($priority)) {\n            $qb->andWhere($qb->expr()->eq('priority', ':priority'));\n            $qb->setParameter('priority', $priority);\n        }\n\n        if ($fromDate = $this->parseDateObject($request->get('fromDate'), $request->get('fromTime'))) {\n            $qb->andWhere('timestamp > :fromDate');\n            $qb->setParameter('fromDate', $fromDate, Types::DATETIME_MUTABLE);\n        }\n\n        if ($toDate = $this->parseDateObject($request->get('toDate'), $request->get('toTime'))) {\n            $qb->andWhere('timestamp <= :toDate');\n            $qb->setParameter('toDate', $toDate, Types::DATETIME_MUTABLE);\n        }\n\n        if (!empty($component = $request->get('component'))) {\n            $qb->andWhere('component = ' . $qb->createNamedParameter($component));\n        }\n\n        if (!empty($relatedObject = $request->get('relatedobject'))) {\n            $qb->andWhere('relatedobject = ' . $qb->createNamedParameter($relatedObject));\n        }\n\n        if (!empty($message = $request->get('message'))) {\n            $qb->andWhere('message LIKE ' . $qb->createNamedParameter('%' . $message . '%'));\n        }\n\n        if (!empty($pid = $request->get('pid'))) {\n            $qb->andWhere('pid LIKE ' . $qb->createNamedParameter('%' . $pid . '%'));\n        }\n\n        $totalQb = clone $qb;\n        $totalQb->setMaxResults(null)\n            ->setFirstResult(0)\n            ->select('COUNT(id) as count');\n        $total = $totalQb->execute()->fetch();\n        $total = (int) $total['count'];\n\n        $stmt = $qb->execute();\n        $result = $stmt->fetchAllAssociative();\n\n        $logEntries = [];\n        foreach ($result as $row) {\n            $fileobject = null;\n            if ($row['fileobject']) {\n                $fileobject = str_replace(PIMCORE_PROJECT_ROOT, '', $row['fileobject']);\n            }\n\n            $logEntry = [\n                'id' => $row['id'],\n                'pid' => $row['pid'],\n                'message' => $row['message'],\n                'timestamp' => $row['timestamp'],\n                'priority' => $row['priority'],\n                'fileobject' => $fileobject,\n                'relatedobject' => $row['relatedobject'],\n                'relatedobjecttype' => $row['relatedobjecttype'],\n                'component' => $row['component'],\n                'source' => $row['source'],\n            ];\n\n            $logEntries[] = $logEntry;\n        }\n\n        return $this->adminJson([\n            'p_totalCount' => $total,\n            'p_results' => $logEntries,\n        ]);\n    }\n\n    /**\n     * @param string|null $date\n     * @param string|null $time\n     *\n     * @return \\DateTime|null\n     */\n    private function parseDateObject($date = null, $time = null)\n    {\n        if (empty($date)) {\n            return null;\n        }\n\n        $pattern = '/^(?P<date>\\d{4}\\-\\d{2}\\-\\d{2})T(?P<time>\\d{2}:\\d{2}:\\d{2})$/';\n\n        $dateTime = null;\n        if (preg_match($pattern, $date, $dateMatches)) {\n            if (!empty($time) && preg_match($pattern, $time, $timeMatches)) {\n                $dateTime = new \\DateTime(sprintf('%sT%s', $dateMatches['date'], $timeMatches['time']));\n            } else {\n                $dateTime = new \\DateTime($date);\n            }\n        }\n\n        return $dateTime;\n    }\n\n    /**\n     * @Route(\"/log/priority-json\", name=\"pimcore_admin_log_priorityjson\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function priorityJsonAction(Request $request)\n    {\n        $priorities[] = ['key' => '', 'value' => '-'];\n        foreach (ApplicationLoggerDb::getPriorities() as $key => $p) {\n            $priorities[] = ['key' => $key, 'value' => $p];\n        }\n\n        return $this->adminJson(['priorities' => $priorities]);\n    }\n\n    /**\n     * @Route(\"/log/component-json\", name=\"pimcore_admin_log_componentjson\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function componentJsonAction(Request $request)\n    {\n        $components[] = ['key' => '', 'value' => '-'];\n        foreach (ApplicationLoggerDb::getComponents() as $p) {\n            $components[] = ['key' => $p, 'value' => $p];\n        }\n\n        return $this->adminJson(['components' => $components]);\n    }\n\n    /**\n     * @Route(\"/log/show-file-object\", name=\"pimcore_admin_log_showfileobject\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     *\n     * @throws \\Exception\n     */\n    public function showFileObjectAction(Request $request)\n    {\n        $filePath = $request->get('filePath');\n        $storage = Storage::get('application_log');\n\n        if ($storage->fileExists($filePath)) {\n            $fileHandle = $storage->readStream($filePath);\n            $response = $this->getResponseForFileHandle($fileHandle);\n            $response->headers->set('Content-Type', 'text/plain');\n        } else {\n            // Fallback to local path when file is not found in flysystem that might still be using the constant\n\n            if (!filter_var($filePath, FILTER_VALIDATE_URL)) {\n                if (!file_exists($filePath)) {\n                    $filePath = PIMCORE_PROJECT_ROOT.DIRECTORY_SEPARATOR.$filePath;\n                }\n                $filePath = realpath($filePath);\n                $fileObjectPath = realpath(PIMCORE_LOG_FILEOBJECT_DIRECTORY);\n            } else {\n                $fileObjectPath = PIMCORE_LOG_FILEOBJECT_DIRECTORY;\n            }\n\n            if (!str_starts_with($filePath, $fileObjectPath)) {\n                throw new AccessDeniedHttpException('Accessing file out of scope');\n            }\n\n            if (file_exists($filePath)) {\n                $fileHandle = fopen($filePath, 'rb');\n                $response = $this->getResponseForFileHandle($fileHandle);\n                $response->headers->set('Content-Type', 'text/plain');\n            } else {\n                $response = new Response();\n                $response->headers->set('Content-Type', 'text/plain');\n                $response->setContent('Path `'.$filePath.'` not found.');\n                $response->setStatusCode(404);\n            }\n        }\n\n        return $response;\n    }\n\n    /**\n     * @param resource $fileHandle\n     *\n     * @return StreamedResponse\n     */\n    private function getResponseForFileHandle($fileHandle)\n    {\n        return new StreamedResponse(\n            static function () use ($fileHandle) {\n                while (!feof($fileHandle)) {\n                    echo fread($fileHandle, 8192);\n                }\n                fclose($fileHandle);\n            }\n        );\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin;\n\nuse Doctrine\\DBAL\\Exception\\SyntaxErrorException;\nuse Doctrine\\DBAL\\Query\\QueryBuilder as DoctrineQueryBuilder;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Translation;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Session;\nuse Pimcore\\Translation\\ExportService\\Exporter\\ExporterInterface;\nuse Pimcore\\Translation\\ExportService\\ExportServiceInterface;\nuse Pimcore\\Translation\\ImportDataExtractor\\ImportDataExtractorInterface;\nuse Pimcore\\Translation\\ImporterService\\ImporterServiceInterface;\nuse Pimcore\\Translation\\TranslationItemCollection\\TranslationItemCollection;\nuse Pimcore\\Translation\\Translator;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpKernel\\Exception\\BadRequestHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * @Route(\"/translation\")\n *\n * @internal\n */\nclass TranslationController extends AdminController\n{\n    protected const PLACEHOLDER_NAME = 'placeHolder';\n\n    /**\n     * @Route(\"/import\", name=\"pimcore_admin_translation_import\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return JsonResponse\n     */\n    public function importAction(Request $request, LocaleServiceInterface $localeService)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $dialect = $request->get('csvSettings', null);\n        $session = Session::get('pimcore_importconfig');\n        $tmpFile = $session->get('translation_import_file');\n\n        if ($dialect) {\n            $dialect = json_decode($dialect);\n        }\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $merge = $request->get('merge');\n        $overwrite = !$merge;\n\n        $allowedLanguages = $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations();\n        if ($admin) {\n            $allowedLanguages = Tool\\Admin::getLanguages();\n        }\n\n        $delta = Translation::importTranslationsFromFile(\n            $tmpFile,\n            $domain,\n            $overwrite,\n            $allowedLanguages,\n            $dialect\n        );\n\n        if (is_file($tmpFile)) {\n            @unlink($tmpFile);\n        }\n\n        $result = [\n            'success' => true,\n        ];\n        if ($merge) {\n            $enrichedDelta = [];\n\n            foreach ($delta as $item) {\n                $lg = $item['lg'];\n                $currentLocale = $localeService->findLocale();\n                $item['lgname'] = \\Locale::getDisplayLanguage($lg, $currentLocale);\n                $item['icon'] = $this->generateUrl('pimcore_admin_misc_getlanguageflag', ['language' => $lg]);\n                $item['current'] = $item['text'];\n                $enrichedDelta[] = $item;\n            }\n\n            $result['delta'] = base64_encode(json_encode($enrichedDelta));\n        }\n\n        $response = $this->adminJson($result);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/upload-import\", name=\"pimcore_admin_translation_uploadimportfile\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function uploadImportFileAction(Request $request)\n    {\n        $tmpData = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        //store data for further usage\n        $filename = uniqid('import_translations-');\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $filename;\n        File::put($importFile, $tmpData);\n\n        Session::useSession(function (AttributeBagInterface $session) use ($importFile) {\n            $session->set('translation_import_file', $importFile);\n        }, 'pimcore_importconfig');\n\n        // determine csv settings\n        $dialect = Tool\\Admin::determineCsvDialect($importFile);\n\n        //ignore if line terminator is already hex otherwise generate hex for string\n        if (!empty($dialect->lineterminator) && empty(preg_match('/[a-f0-9]{2}/i', $dialect->lineterminator))) {\n            $dialect->lineterminator = bin2hex($dialect->lineterminator);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n            'config' => [\n                'csvSettings' => $dialect,\n            ],\n        ]);\n    }\n\n    /**\n     * @Route(\"/export\", name=\"pimcore_admin_translation_export\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n\n        $joins = [];\n\n        $list->setOrder('asc');\n        $list->setOrderKey($tableName . '.key', false);\n\n        $conditions = $this->getGridFilterCondition($request, $tableName, false, $admin);\n        if (!empty($conditions)) {\n            $list->setCondition($conditions['condition'], $conditions['params']);\n        }\n\n        $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n        if ($filters) {\n            $joins = array_merge($joins, $filters['joins']);\n        }\n\n        $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n\n        try {\n            $list->load();\n        } catch (SyntaxErrorException $syntaxErrorException) {\n            throw new \\InvalidArgumentException('Check your arguments.');\n        }\n\n        $translations = [];\n        $translationObjects = $list->getTranslations();\n\n        // fill with one dummy translation if the store is empty\n        if (empty($translationObjects)) {\n            if ($admin) {\n                $t = new Translation();\n                $t->setDomain(Translation::DOMAIN_ADMIN);\n                $languages = Tool\\Admin::getLanguages();\n            } else {\n                $t = new Translation();\n                $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n            }\n\n            foreach ($languages as $language) {\n                $t->addTranslation($language, '');\n            }\n\n            $translationObjects[] = $t;\n        }\n\n        foreach ($translationObjects as $t) {\n            $row = $t->getTranslations();\n            $row = Element\\Service::escapeCsvRecord($row);\n            $translations[] = array_merge(\n                ['key' => $t->getKey(),\n                    'creationDate' => $t->getCreationDate(),\n                    'modificationDate' => $t->getModificationDate(),\n                ],\n                $row\n            );\n        }\n\n        //header column\n        $columns = array_keys($translations[0]);\n\n        if ($admin) {\n            $languages = Tool\\Admin::getLanguages();\n        } else {\n            $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n        }\n\n        //add language columns which have no translations yet\n        foreach ($languages as $l) {\n            if (!in_array($l, $columns)) {\n                $columns[] = $l;\n            }\n        }\n\n        //remove invalid languages\n        foreach ($columns as $key => $column) {\n            if (strtolower(trim($column)) != 'key' && !in_array($column, $languages)) {\n                unset($columns[$key]);\n            }\n        }\n        $columns = array_values($columns);\n\n        $headerRow = [];\n        foreach ($columns as $key => $value) {\n            $headerRow[] = '\"' . $value . '\"';\n        }\n        $csv = implode(';', $headerRow) . \"\\r\\n\";\n\n        foreach ($translations as $t) {\n            $tempRow = [];\n            foreach ($columns as $key) {\n                $value = $t[$key] ?? null;\n                //clean value of evil stuff such as \" and linebreaks\n                if (is_string($value)) {\n                    $value = Tool\\Text::removeLineBreaks($value);\n                    $value = str_replace('\"', '&quot;', $value);\n\n                    $tempRow[$key] = '\"' . $value . '\"';\n                } else {\n                    $tempRow[$key] = $value;\n                }\n            }\n            $csv .= implode(';', $tempRow) . \"\\r\\n\";\n        }\n\n        $response = new Response(\"\\xEF\\xBB\\xBF\" . $csv);\n        $response->headers->set('Content-Encoding', 'UTF-8');\n        $response->headers->set('Content-Type', 'text/csv; charset=UTF-8');\n        $response->headers->set('Content-Disposition', 'attachment; filename=\"export_' . $domain . '_translations.csv\"');\n        ini_set('display_errors', '0'); //to prevent warning messages in csv\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/add-admin-translation-keys\", name=\"pimcore_admin_translation_addadmintranslationkeys\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAdminTranslationKeysAction(Request $request)\n    {\n        $keys = $request->get('keys');\n        if ($keys) {\n            $availableLanguages = Tool\\Admin::getLanguages();\n            $data = $this->decodeJson($keys);\n            foreach ($data as $translationData) {\n                $t = null; // reset\n\n                try {\n                    $t = Translation::getByKey($translationData, Translation::DOMAIN_ADMIN);\n                } catch (\\Exception $e) {\n                    Logger::log((string) $e);\n                }\n                if (!$t instanceof Translation) {\n                    $t = new Translation();\n                    $t->setDomain(Translation::DOMAIN_ADMIN);\n                    $t->setKey($translationData);\n                    $t->setCreationDate(time());\n                    $t->setModificationDate(time());\n\n                    foreach ($availableLanguages as $lang) {\n                        $t->addTranslation($lang, '');\n                    }\n\n                    try {\n                        $t->save();\n                    } catch (\\Exception $e) {\n                        Logger::log((string) $e);\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson(null);\n    }\n\n    /**\n     * @Route(\"/translations\", name=\"pimcore_admin_translation_translations\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Translator $translator\n     *\n     * @return JsonResponse\n     */\n    public function translationsAction(Request $request, TranslatorInterface $translator)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain === Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        if ($request->get('data')) {\n            $data = $this->decodeJson($request->get('data'));\n\n            if ($request->get('xaction') == 'destroy') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t instanceof Translation) {\n                    $t->delete();\n                }\n\n                return $this->adminJson(['success' => true, 'data' => []]);\n            } elseif ($request->get('xaction') == 'update') {\n                $t = Translation::getByKey($data['key'], $domain);\n\n                foreach ($data as $key => $value) {\n                    $key = preg_replace('/^_/', '', $key, 1);\n                    if (!in_array($key, ['key', 'type'])) {\n                        $t->addTranslation($key, $value);\n                    }\n                }\n\n                if ($data['key']) {\n                    $t->setKey($data['key']);\n                }\n\n                if ($data['type']) {\n                    $t->setType($data['type']);\n                }\n                $t->setModificationDate(time());\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            } elseif ($request->get('xaction') == 'create') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t) {\n                    return $this->adminJson([\n                        'message' => 'identifier_already_exists',\n                        'success' => false,\n                    ]);\n                }\n\n                $t = new Translation();\n                $t->setDomain($domain);\n                $t->setKey($data['key']);\n                $t->setCreationDate(time());\n                $t->setModificationDate(time());\n                $t->setType($data['type'] ?? null);\n\n                foreach (Tool::getValidLanguages() as $lang) {\n                    $t->addTranslation($lang, '');\n                }\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            }\n        } else {\n            // get list of types\n            $list = new Translation\\Listing();\n            $list->setDomain($domain);\n\n            $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n            $list->setOrder('asc');\n            $list->setOrderKey($tableName . '.key', false);\n\n            $sortingSettings = \\Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams::extractSortingSettings(\n                array_merge($request->request->all(), $request->query->all())\n            );\n\n            $joins = [];\n\n            if ($orderKey = $sortingSettings['orderKey']) {\n                if (in_array(trim($orderKey, '_'), $validLanguages)) {\n                    $orderKey = trim($orderKey, '_');\n                    $joins[] = [\n                        'language' => $orderKey,\n                    ];\n                    $list->setOrderKey($orderKey);\n                } elseif ($list->isValidOrderKey($sortingSettings['orderKey'])) {\n                    $list->setOrderKey($tableName . '.' . $sortingSettings['orderKey'], false);\n                }\n            }\n            if ($sortingSettings['order']) {\n                $list->setOrder($sortingSettings['order']);\n            }\n\n            $list->setLimit($request->get('limit'));\n            $list->setOffset($request->get('start'));\n\n            $conditions = $this->getGridFilterCondition($request, $tableName, false, $admin);\n            $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n            if ($filters) {\n                $joins = array_merge($joins, $filters['joins']);\n            }\n\n            if (!empty($conditions)) {\n                $list->setCondition($conditions['condition'], $conditions['params']);\n            }\n\n            $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n\n            try {\n                $list->load();\n            } catch (SyntaxErrorException $syntaxErrorException) {\n                throw new \\InvalidArgumentException('Check your arguments.');\n            }\n\n            $translations = [];\n            $searchString = $request->get('searchString');\n            foreach ($list->getTranslations() as $t) {\n                //Reload translation to get complete data,\n                //if translation fetched based on the text not key\n                if ($searchString && !strpos($searchString, $t->getKey())) {\n                    if (!$t = Translation::getByKey($t->getKey(), $domain)) {\n                        continue;\n                    }\n                }\n\n                $translations[] = array_merge(\n                    $this->prefixTranslations($t->getTranslations()),\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ]\n                );\n            }\n\n            return $this->adminJson(['data' => $translations, 'success' => true, 'total' => $list->getTotalCount()]);\n        }\n\n        return $this->adminJson(['success' => false]);\n    }\n\n    /**\n     * @param array $translations\n     *\n     * @return array\n     */\n    protected function prefixTranslations($translations)\n    {\n        if (!is_array($translations)) {\n            return $translations;\n        }\n\n        $prefixedTranslations = [];\n        foreach ($translations as $lang => $trans) {\n            $prefixedTranslations['_' . $lang] = $trans;\n        }\n\n        return $prefixedTranslations;\n    }\n\n    /**\n     * @param array $joins\n     * @param Translation\\Listing $list\n     * @param string $tableName\n     * @param array $filters\n     */\n    protected function extendTranslationQuery($joins, $list, $tableName, $filters)\n    {\n        if ($joins) {\n            $list->onCreateQueryBuilder(\n                function (DoctrineQueryBuilder $select) use (\n                    $joins,\n                    $tableName,\n                    $filters\n                ) {\n                    $db = \\Pimcore\\Db::get();\n\n                    $alreadyJoined = [];\n\n                    foreach ($joins as $join) {\n                        $fieldname = $join['language'];\n\n                        if (isset($alreadyJoined[$fieldname])) {\n                            continue;\n                        }\n                        $alreadyJoined[$fieldname] = 1;\n\n                        $select->addSelect($fieldname . '.text AS ' . $fieldname);\n                        $select->leftJoin(\n                            $tableName,\n                            $tableName,\n                            $fieldname,\n                            '('\n                            . $fieldname . '.key = ' . $tableName . '.key'\n                            . ' and ' . $fieldname . '.language = ' . $db->quote($fieldname)\n                            . ')'\n                        );\n                    }\n\n                    $havings = $filters['conditions'];\n                    if ($havings) {\n                        $havings = implode(' AND ', $havings);\n                        $select->having($havings);\n                    }\n                }\n            );\n        }\n    }\n\n    /**\n     * @param Request $request\n     * @param string $tableName\n     * @param bool $languageMode\n     * @param bool $admin\n     *\n     * @return array\n     */\n    protected function getGridFilterCondition(Request $request, $tableName, $languageMode = false, $admin = false)\n    {\n        $placeHolderCount = 0;\n        $joins = [];\n        $conditions = [];\n        $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n        $db = \\Pimcore\\Db::get();\n        $conditionFilters = [];\n\n        $filterJson = $request->get('filter');\n        if ($filterJson) {\n            $propertyField = 'property';\n            $operatorField = 'operator';\n\n            $filters = $this->decodeJson($filterJson);\n\n            foreach ($filters as $filter) {\n                $operator = '=';\n                $field = null;\n                $value = null;\n\n                $fieldname = $filter[$propertyField];\n                if (in_array(ltrim($fieldname, '_'), $validLanguages)) {\n                    $fieldname = ltrim($fieldname, '_');\n                }\n                $fieldname = str_replace('--', '', $fieldname);\n\n                if (!$languageMode && in_array($fieldname, $validLanguages)\n                    || $languageMode && !in_array($fieldname, $validLanguages)) {\n                    continue;\n                }\n\n                if (!$languageMode) {\n                    $fieldname = $tableName . '.' . $fieldname;\n                }\n\n                if (!empty($filter['value'])) {\n                    if ($filter['type'] == 'string') {\n                        $operator = 'LIKE';\n                        $field = $fieldname;\n                        $value = '%' . $filter['value'] . '%';\n                    } elseif ($filter['type'] == 'date' ||\n                        (in_array($fieldname, ['modificationDate', 'creationDate']))) {\n                        if ($filter[$operatorField] == 'lt') {\n                            $operator = '<';\n                        } elseif ($filter[$operatorField] == 'gt') {\n                            $operator = '>';\n                        } elseif ($filter[$operatorField] == 'eq') {\n                            $operator = '=';\n                            $fieldname = \"UNIX_TIMESTAMP(DATE(FROM_UNIXTIME({$fieldname})))\";\n                        }\n                        $filter['value'] = strtotime($filter['value']);\n                        $field = $fieldname;\n                        $value = $filter['value'];\n                    }\n                }\n\n                if ($field && $value) {\n                    $condition = $db->quoteIdentifier($field) . ' ' . $operator . ' ' . $db->quote($value);\n\n                    if ($languageMode) {\n                        $conditions[$fieldname] = $condition;\n                        $joins[] = [\n                            'language' => $fieldname,\n                        ];\n                    } else {\n                        $placeHolderName = self::PLACEHOLDER_NAME . $placeHolderCount;\n                        $placeHolderCount++;\n                        $conditionFilters[] = [\n                            'condition' => $field . ' ' . $operator . ' :' . $placeHolderName,\n                            'field' => $placeHolderName,\n                            'value' => $value,\n                        ];\n                    }\n                }\n            }\n        }\n\n        if ($request->get('searchString')) {\n            $conditionFilters[] = [\n                'condition' => '(lower(' . $tableName . '.key) LIKE :filterTerm OR lower(' . $tableName . '.text) LIKE :filterTerm)',\n                'field' => 'filterTerm',\n                'value' => '%' . mb_strtolower($request->get('searchString')) . '%',\n            ];\n        }\n\n        if ($languageMode) {\n            return [\n                'joins' => $joins,\n                'conditions' => $conditions,\n            ];\n        }\n\n        if(!empty($conditionFilters)) {\n            $conditions = [];\n            $params = [];\n            foreach($conditionFilters as $conditionFilter) {\n                $conditions[] = $conditionFilter['condition'];\n                $params[$conditionFilter['field']] = $conditionFilter['value'];\n            }\n\n            $conditionFilters = [\n                'condition' => implode(' AND ', $conditions),\n                'params' => $params,\n            ];\n        }\n\n        return $conditionFilters;\n    }\n\n    /**\n     * @Route(\"/cleanup\", name=\"pimcore_admin_translation_cleanup\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function cleanupAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n        $list->cleanup();\n\n        \\Pimcore\\Cache::clearTags(['translator', 'translate']);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * -----------------------------------------------------------------------------------\n     * THE FOLLOWING ISN'T RELATED TO THE SHARED TRANSLATIONS OR ADMIN-TRANSLATIONS\n     * XLIFF CONTENT-EXPORT & MS WORD CONTENT-EXPORT\n     * -----------------------------------------------------------------------------------\n     */\n\n    /**\n     * @Route(\"/content-export-jobs\", name=\"pimcore_admin_translation_contentexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function contentExportJobsAction(Request $request)\n    {\n        $data = $this->decodeJson($request->get('data'));\n        $elements = [];\n        $jobs = [];\n        $exportId = uniqid();\n        $source = $request->get('source');\n        $target = $request->get('target');\n        $type = $request->get('type');\n\n        $source = str_replace('_', '-', $source);\n        $target = str_replace('_', '-', $target);\n\n        if ($data && is_array($data)) {\n            foreach ($data as $element) {\n                $elements[$element['type'] . '_' . $element['id']] = [\n                    'id' => $element['id'],\n                    'type' => $element['type'],\n                ];\n\n                $el = null;\n\n                if ($element['children']) {\n                    $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    $baseClass = ELement\\Service::getBaseClassNameForElement($element['type']);\n                    $listClass = '\\\\Pimcore\\\\Model\\\\' . $baseClass . '\\\\Listing';\n                    $list = new $listClass();\n                    $list->setUnpublished(true);\n                    if ($el instanceof DataObject\\AbstractObject) {\n                        // inlcude variants\n                        $list->setObjectTypes(\n                            [DataObject::OBJECT_TYPE_VARIANT,\n                                DataObject::OBJECT_TYPE_OBJECT,\n                                DataObject::OBJECT_TYPE_FOLDER, ]\n                        );\n                    }\n                    $list->setCondition(\n                        ($el instanceof DataObject ? 'o_' : '') . 'path LIKE ?',\n                        [$list->escapeLike($el->getRealFullPath() . ($el->getRealFullPath() != '/' ? '/' : '')) . '%']\n                    );\n                    $childs = $list->load();\n\n                    foreach ($childs as $child) {\n                        $childId = $child->getId();\n                        $elements[$element['type'] . '_' . $childId] = [\n                            'id' => $childId,\n                            'type' => $element['type'],\n                        ];\n\n                        if (isset($element['relations']) && $element['relations']) {\n                            $childDependencies = $child->getDependencies()->getRequires();\n                            foreach ($childDependencies as $cd) {\n                                if ($cd['type'] == 'object' || $cd['type'] == 'document') {\n                                    $elements[$cd['type'] . '_' . $cd['id']] = $cd;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (isset($element['relations']) && $element['relations']) {\n                    if (!$el instanceof Element\\ElementInterface) {\n                        $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    }\n\n                    $dependencies = $el->getDependencies()->getRequires();\n                    foreach ($dependencies as $dependency) {\n                        if ($dependency['type'] == 'object' || $dependency['type'] == 'document') {\n                            $elements[$dependency['type'] . '_' . $dependency['id']] = $dependency;\n                        }\n                    }\n                }\n            }\n        }\n\n        $elements = array_values($elements);\n\n        $elementsPerJob = 10;\n        if ($type == 'word') {\n            // the word export can only handle one document per request\n            // the problem is Document\\Service::render(), ... in the action can be a $this->redirect() or exit;\n            // nobody knows what's happening in an action ;-) So we need to isolate them in isolated processes\n            // so that the export doesn't stop completely after a \"redirect\" or any other unexpected behavior of an action\n            $elementsPerJob = 1;\n        }\n\n        // one job = X elements\n        $elements = array_chunk($elements, $elementsPerJob);\n        foreach ($elements as $chunk) {\n            $jobs[] = [[\n                'url' => $request->getBaseUrl() . '/admin/translation/' . $type . '-export',\n                'method' => 'POST',\n                'params' => [\n                    'id' => $exportId,\n                    'source' => $source,\n                    'target' => $target,\n                    'data' => $this->encodeJson($chunk),\n                ],\n            ]];\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n                'jobs' => $jobs,\n                'id' => $exportId,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/xliff-export\", name=\"pimcore_admin_translation_xliffexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ExportServiceInterface $exportService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffExportAction(Request $request, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n        $target = $request->get('target');\n\n        $translationItems = new TranslationItemCollection();\n\n        foreach ($data as $el) {\n            $element = Element\\Service::getElementById($el['type'], $el['id']);\n            $translationItems->addPimcoreElement($element);\n        }\n\n        $exportService->exportTranslationItems($translationItems, $source, [$target], $id);\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/xliff-export-download\", name=\"pimcore_admin_translation_xliffexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param ExporterInterface $translationExporter\n     *\n     * @return BinaryFileResponse\n     */\n    public function xliffExportDownloadAction(Request $request, ExporterInterface $translationExporter, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $exportFile = $exportService->getTranslationExporter()->getExportFilePath($id);\n\n        $response = new BinaryFileResponse($exportFile);\n        $response->headers->set('Content-Type', $translationExporter->getContentType());\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, basename($exportFile));\n        $response->deleteFileAfterSend(true);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-upload\", name=\"pimcore_admin_translation_xliffimportupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportUploadAction(Request $request, ImportDataExtractorInterface $importDataExtractor)\n    {\n        $jobs = [];\n        $id = uniqid();\n        $importFile = $importDataExtractor->getImportFilePath($id);\n        copy($_FILES['file']['tmp_name'], $importFile);\n\n        $steps = $importDataExtractor->countSteps($id);\n\n        for ($i = 0; $i < $steps; $i++) {\n            $jobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_translation_xliffimportelement'),\n                'method' => 'POST',\n                'params' => [\n                    'id' => $id,\n                    'step' => $i,\n                ],\n            ]];\n        }\n\n        $response = $this->adminJson([\n            'success' => true,\n            'jobs' => $jobs,\n            'id' => $id,\n        ]);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-element\", name=\"pimcore_admin_translation_xliffimportelement\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     * @param ImporterServiceInterface $importerService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportElementAction(Request $request, ImportDataExtractorInterface $importDataExtractor, ImporterServiceInterface $importerService)\n    {\n        $id = $request->get('id');\n        $step = $request->get('step');\n\n        try {\n            $attributeSet = $importDataExtractor->extractElement($id, $step);\n            if ($attributeSet) {\n                $importerService->import($attributeSet);\n            } else {\n                Logger::warning(sprintf('Could not resolve element %s', $id));\n            }\n        } catch (\\Exception $e) {\n            Logger::err($e->getMessage());\n\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/word-export\", name=\"pimcore_admin_translation_wordexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function wordExportAction(Request $request)\n    {\n        ini_set('display_errors', 'off');\n\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, false);\n\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n\n        if (!is_file($exportFile)) {\n            File::put($exportFile, '');\n        }\n\n        foreach ($data as $el) {\n            try {\n                $element = Element\\Service::getElementById($el['type'], $el['id']);\n                $output = '';\n\n                // check supported types (subtypes)\n                if (!in_array($element->getType(), ['page', 'snippet', 'email', 'object'])) {\n                    continue;\n                }\n\n                if ($element instanceof Element\\ElementInterface) {\n                    $output .= '<h1 class=\"element-headline\">' . ucfirst(\n                        $element->getType()\n                    ) . ' - ' . $element->getRealFullPath() . ' (ID: ' . $element->getId() . ')</h1>';\n                }\n\n                if ($element instanceof Document\\PageSnippet) {\n                    if ($element instanceof Document\\Page) {\n                        $structuredDataEmpty = true;\n                        $structuredData = '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Structured Data</span></td>\n                                </tr>\n                        ';\n\n                        if ($element->getTitle()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Title</span></td>\n                                    <td>' . $element->getTitle() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getDescription()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Description</span></td>\n                                    <td>' . $element->getDescription() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getProperty('navigation_name')) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Navigation</span></td>\n                                    <td>' . $element->getProperty('navigation_name') . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        $structuredData .= '</table>';\n\n                        if (!$structuredDataEmpty) {\n                            $output .= $structuredData;\n                        }\n                    }\n\n                    // we need to set the parameter \"pimcore_admin\" here to be able to render unpublished documents\n                    $html = Document\\Service::render($element, [], false, ['pimcore_admin' => true]);\n\n                    $html = preg_replace(\n                        '@</?(img|meta|div|section|aside|article|body|bdi|bdo|canvas|embed|footer|head|header|html)([^>]+)?>@',\n                        '',\n                        $html\n                    );\n                    $html = preg_replace('/<!--(.*)-->/Uis', '', $html);\n\n                    $dom = new Tool\\DomCrawler($html);\n                    // remove containers including their contents\n                    $elements = $dom->filter('form, script, style, noframes, noscript, object, area, mapm, video, audio, iframe, textarea, input, select, button');\n                    foreach ($elements as $element) {\n                        $element->parentNode->removeChild($element);\n                    }\n\n                    $clearText = function ($string) {\n                        $string = str_replace(\"\\r\\n\", '', $string);\n                        $string = str_replace(\"\\n\", '', $string);\n                        $string = str_replace(\"\\r\", '', $string);\n                        $string = str_replace(\"\\t\", '', $string);\n                        $string = preg_replace('/&[a-zA-Z0-9]+;/', '', $string); // remove html entities\n                        $string = preg_replace('#[ ]+#', '', $string);\n\n                        return $string;\n                    };\n\n                    // remove empty tags (where it matters)\n                    // replace links => links get [Linktext]\n                    $elements = $dom->filter('a');\n                    foreach ($elements as $element) {\n                        $string = $clearText($element->textContent);\n                        if (!empty($string)) {\n                            $newNode = $element->ownerDocument->createTextNode('[' . $element->textContent . ']');\n\n                            $element->parentNode->replaceChild($newNode, $element);\n                        } else {\n                            $element->ownerDocument->textContent = '';\n                        }\n                    }\n\n                    if ($dom->count() > 0) {\n                        $html = $dom->html();\n                    }\n\n                    $dom->clear();\n                    unset($dom);\n\n                    // force closing tags\n                    $doc = new \\DOMDocument();\n                    libxml_use_internal_errors(true);\n                    $doc->loadHTML('<?xml encoding=\"UTF-8\"><article>' . $html . '</article>');\n                    libxml_clear_errors();\n                    $html = $doc->saveHTML();\n\n                    $bodyStart = strpos($html, '<body>');\n                    $bodyEnd = strpos($html, '</body>');\n                    if ($bodyStart && $bodyEnd) {\n                        $html = substr($html, $bodyStart + 6, $bodyEnd - $bodyStart);\n                    }\n\n                    $output .= $html;\n                } elseif ($element instanceof DataObject\\Concrete) {\n                    $hasContent = false;\n\n                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields|null $fd */\n                    $fd = $element->getClass()->getFieldDefinition('localizedfields');\n                    if ($fd) {\n                        $definitions = $fd->getFieldDefinitions();\n\n                        $locale = str_replace('-', '_', $source);\n                        if (!Tool::isValidLanguage($locale)) {\n                            $locale = \\Locale::getPrimaryLanguage($locale);\n                        }\n\n                        $output .= '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Localized Data</span></td>\n                                </tr>\n                        ';\n\n                        foreach ($definitions as $definition) {\n                            // check allowed datatypes\n                            if (!in_array($definition->getFieldtype(), ['input', 'textarea', 'wysiwyg'])) {\n                                continue;\n                            }\n\n                            $content = $element->{'get' . ucfirst($definition->getName())}($locale);\n\n                            if (!empty($content)) {\n                                $output .= '\n                                <tr>\n                                    <td><span style=\"color:#cc2929;\">' . $definition->getTitle() . ' (' . $definition->getName() . ')<span></td>\n                                    <td>' . $content . '&nbsp;</td>\n                                </tr>\n                                ';\n\n                                $hasContent = true;\n                            }\n                        }\n\n                        $output .= '</table>';\n                    }\n\n                    if (!$hasContent) {\n                        $output = ''; // there's no content in the object, so reset all contents and do not inclide it in the export\n                    }\n                }\n\n                // append contents\n                if (!empty($output)) {\n                    $f = fopen($exportFile, 'a+');\n                    fwrite($f, $output);\n                    fclose($f);\n                }\n            } catch (\\Exception $e) {\n                Logger::error('Word Export: ' . $e);\n\n                throw $e;\n            }\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/word-export-download\", name=\"pimcore_admin_translation_wordexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function wordExportDownloadAction(Request $request)\n    {\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, true);\n\n        // no conversion, output html file, works fine with MS Word and LibreOffice\n        $content = file_get_contents($exportFile);\n        @unlink($exportFile);\n\n        // replace <script> and <link>\n        $content = preg_replace('/<link[^>]+>/im', '$1', $content);\n        $content = preg_replace(\"/<script[^>]+>(.*)?<\\/script>/im\", '$1', $content);\n\n        $content =\n            \"<html>\\n\" .\n            \"<head>\\n\" .\n            '<style type=\"text/css\">' . \"\\n\" .\n            file_get_contents(PIMCORE_WEB_ROOT . '/bundles/pimcoreadmin/css/word-export.css') .\n            \"</style>\\n\" .\n            \"</head>\\n\\n\" .\n            \"<body>\\n\" .\n            $content .\n            \"\\n\\n</body>\\n\" .\n            \"</html>\\n\";\n\n        $response = new Response($content);\n        $response->headers->set('Content-Type', 'text/html');\n        $response->headers->set(\n            'Content-Disposition',\n            'attachment; filename=\"word-export-' . date('Ymd') . '_' . uniqid() . '.htm\"'\n        );\n\n        return $response;\n    }\n\n    private function sanitzeExportId(string $id): string\n    {\n        if (empty($id) || !preg_match('/^[a-z0-9]+$/', $id)) {\n            throw new BadRequestHttpException('Invalid export ID format');\n        }\n\n        return $id;\n    }\n\n    private function getExportFilePath(string $id, bool $checkExistence = true): string\n    {\n        // no need to check for path traversals here as sanitizeExportId restricted the ID parameter\n        $exportFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . DIRECTORY_SEPARATOR . $id . '.html';\n\n        if ($checkExistence && !file_exists($exportFile)) {\n            throw $this->createNotFoundException(sprintf('Export file does not exist at path %s', $exportFile));\n        }\n\n        return $exportFile;\n    }\n\n    /**\n     * @Route(\"/merge-item\", name=\"pimcore_admin_translation_mergeitem\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function mergeItemAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n\n        $dataList = json_decode($request->get('data'), true);\n\n        foreach ($dataList as $data) {\n            $t = Translation::getByKey($data['key'], $domain, true);\n            $newValue = htmlspecialchars_decode($data['current']);\n            $t->addTranslation($data['lg'], $newValue);\n            $t->setModificationDate(time());\n            $t->save();\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-website-translation-languages\", name=\"pimcore_admin_translation_getwebsitetranslationlanguages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getWebsiteTranslationLanguagesAction(Request $request)\n    {\n        return $this->adminJson(\n            [\n                'view' => $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations(),\n\n                //when no view language is defined, all languages are editable. if one view language is defined, it\n                //may be possible that no edit language is set intentionally\n                'edit' => $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations(),\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-translation-domains\", name=\"pimcore_admin_translation_gettranslationdomains\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTranslationDomainsAction(Request $request)\n    {\n        $translation = new Translation();\n\n        $domains = array_map(\n            fn ($domain) => ['name' => $domain],\n            $translation->getDao()->getAvailableDomains(),\n        );\n\n        return $this->adminJson(['domains' => $domains]);\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Helper;\n\nuse Carbon\\Carbon;\n\n/**\n * @internal\n */\nclass QueryParams\n{\n    /**\n     * @param array $params\n     *\n     * @return array  [orderKey => null|string, order => null|string]\n     */\n    public static function extractSortingSettings($params)\n    {\n        $orderKey = null;\n        $order = null;\n\n        $sortParam = isset($params['sort']) ? $params['sort'] : false;\n        if ($sortParam) {\n            $sortParam = json_decode($sortParam, true);\n            $sortParam = $sortParam[0];\n\n            if (substr($sortParam['property'], 0, 1) != '~') {\n                $orderKey = $sortParam['property'];\n                $order = $sortParam['direction'];\n            } else {\n                $orderKey = $sortParam['property'];\n                $order = $sortParam['direction'];\n\n                $parts = explode('~', $orderKey);\n\n                $fieldname = $parts[2];\n                $groupKeyId = $parts[3];\n                $groupKeyId = explode('-', $groupKeyId);\n                $groupId = (int) $groupKeyId[0];\n                $keyid = (int) $groupKeyId[1];\n\n                return ['orderKey' => $sortParam['property'], 'fieldname' => $fieldname, 'groupId' => $groupId, 'keyId' => $keyid, 'order' => $order, 'isFeature' => 1];\n            }\n        }\n\n        return ['orderKey' => $orderKey, 'order' => $order];\n    }\n\n    /**\n     * @param string $param\n     *\n     * @return int\n     */\n    public static function getRecordIdForGridRequest($param)\n    {\n        $param = json_decode($param, true);\n\n        return $param['id'];\n    }\n\n    /**\n     * Creates a condition string from the passed ExtJs filter definitions\n     *\n     * @param string $filterString\n     * @param array $matchExact\n     * @param bool $returnString\n     * @param array $callbacks\n     *\n     * @return array|string\n     *\n     * @throws \\Exception\n     */\n    public static function getFilterCondition($filterString, $matchExact = ['id', 'o_id'], $returnString = true, $callbacks = [])\n    {\n        if (!$filterString) {\n            return '';\n        }\n        $conditions = [];\n\n        $filters = json_decode($filterString);\n        $db = \\Pimcore\\Db::get();\n        foreach ($filters as $f) {\n            if ($f->type == 'string') {\n                if (in_array($f->property, $matchExact)) {\n                    $conditions[$f->property][] = ' ' . $db->quoteIdentifier($f->property) . ' = ' . $db->quote($f->value) . ' ';\n                } else {\n                    $conditions[$f->property][] = ' ' . $db->quoteIdentifier($f->property) . ' LIKE ' . $db->quote('%' . $f->value . '%') . ' ';\n                }\n            } elseif ($f->type == 'numeric') {\n                $symbol = null;\n                if ($f->operator == 'eq') {\n                    $symbol = ' = ';\n                } elseif ($f->operator == 'lt') {\n                    $symbol = ' < ';\n                } elseif ($f->operator == 'gt') {\n                    $symbol = ' > ';\n                }\n                $conditions[$f->property][] = ' ' . $db->quoteIdentifier($f->property)  . ' ' . $symbol . $db->quote($f->value) . ' ';\n            } elseif ($f->type == 'date') {\n                /**\n                 * make sure you pass the date as timestamp\n                 *\n                 * filter: {type : 'date',dateFormat: 'timestamp'}\n                 */\n                $date = Carbon::createFromTimestamp($f->value)->setTime(0, 0, 0);\n\n                if ($f->operator == 'eq') {\n                    $conditions[$f->property][] = ' ' . $f->property . ' >= ' . $db->quote($date->getTimestamp());\n                    $conditions[$f->property][] = ' ' . $f->property . ' <= ' . $db->quote($date->addDay()->subSecond()->getTimestamp());\n                } elseif ($f->operator == 'lt') {\n                    $conditions[$f->property][] = ' ' . $f->property . ' < ' . $db->quote($date->getTimestamp());\n                } elseif ($f->operator == 'gt') {\n                    $conditions[$f->property][] = ' ' . $f->property . ' > ' . $db->quote($date->addDay()->subSecond()->getTimestamp());\n                }\n            } else {\n                throw new \\Exception('Filer of type ' . $f->type . ' not jet supported.');\n            }\n        }\n\n        $conditionsGrouped = [];\n        foreach ($conditions as $fieldName => $fieldConditions) {\n            if (count($fieldConditions) > 1) {\n                $conditionsGrouped[$fieldName] = ' (' . implode(' AND ', $fieldConditions) . ') ';\n            } else {\n                $conditionsGrouped[$fieldName] = $fieldConditions[0];\n            }\n        }\n        if ($returnString) {\n            return implode(' OR ', $conditionsGrouped);\n        } else {\n            return $conditionsGrouped;\n        }\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\Search\\Backend\\Data;\n\nuse Pimcore\\Model\\Search\\Backend\\Data;\n\n/**\n * @internal\n *\n * @method \\Pimcore\\Model\\Search\\Backend\\Data\\Listing\\Dao getDao()\n * @method Data[] load()\n * @method Data|false current()\n * @method int getTotalCount()\n */\nclass Listing extends \\Pimcore\\Model\\Listing\\AbstractListing\n{\n    /**\n     * @return Data[]\n     */\n    public function getEntries()\n    {\n        return $this->getData();\n    }\n\n    /**\n     * @param Data[]|null $entries\n     *\n     * @return $this\n     */\n    public function setEntries($entries)\n    {\n        return $this->setData($entries);\n    }\n\n    /**\n     * @throws \\Exception\n     */\n    public function __construct()\n    {\n        $this->initDao(__CLASS__);\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\Translation;\n\nuse Pimcore\\Model;\nuse Pimcore\\Model\\Exception\\NotFoundException;\n\n/**\n * @method \\Pimcore\\Model\\Translation\\Listing\\Dao getDao()\n * @method Model\\Translation[] load()\n * @method array loadRaw()\n * @method Model\\Translation|false current()\n * @method int getTotalCount()\n * @method void onCreateQueryBuilder(?callable $callback)\n * @method void cleanup()\n *\n */\nclass Listing extends Model\\Listing\\AbstractListing\n{\n    /**\n     * @internal\n     *\n     * @var int maximum number of cacheable items\n     */\n    protected static $cacheLimit = 5000;\n\n    /**\n     * @internal\n     *\n     * @var string\n     */\n    protected $domain = Model\\Translation::DOMAIN_DEFAULT;\n\n    /**\n     * @internal\n     *\n     * @var string[]|null\n     */\n    protected ?array $languages = null;\n\n    /**\n     * @return string\n     */\n    public function getDomain(): string\n    {\n        return $this->domain;\n    }\n\n    /**\n     * @param string $domain\n     */\n    public function setDomain(string $domain): void\n    {\n        if (!Model\\Translation::isAValidDomain($domain)) {\n            throw new NotFoundException(sprintf('Translation domain table \"translations_%s\" does not exist', $domain));\n        }\n\n        $this->domain = $domain;\n    }\n\n    /**\n     * @return string[]|null\n     */\n    public function getLanguages(): ?array\n    {\n        return $this->languages;\n    }\n\n    /**\n     * @param string[]|null $languages\n     */\n    public function setLanguages(?array $languages): void\n    {\n        $this->languages = $languages;\n    }\n\n    /**\n     * @return \\Pimcore\\Model\\Translation[]\n     */\n    public function getTranslations()\n    {\n        return $this->getData();\n    }\n\n    /**\n     * @param array $translations\n     *\n     * @return \\Pimcore\\Model\\Translation\\Listing\n     */\n    public function setTranslations($translations)\n    {\n        return $this->setData($translations);\n    }\n\n    /**\n     * @return int\n     */\n    public static function getCacheLimit()\n    {\n        return self::$cacheLimit;\n    }\n\n    /**\n     * @param int $cacheLimit\n     */\n    public static function setCacheLimit($cacheLimit)\n    {\n        self::$cacheLimit = $cacheLimit;\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin;\n\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Types\\Types;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Log\\Handler\\ApplicationLoggerDb;\nuse Pimcore\\Tool\\Storage;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\StreamedResponse;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Exception\\AccessDeniedHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * @internal\n */\nclass LogController extends AdminController implements KernelControllerEventInterface\n{\n    /**\n     * @param ControllerEvent $event\n     */\n    public function onKernelControllerEvent(ControllerEvent $event)\n    {\n        if (!$this->getAdminUser()->isAllowed('application_logging')) {\n            throw new AccessDeniedHttpException(\"Permission denied, user needs 'application_logging' permission.\");\n        }\n    }\n\n    /**\n     * @Route(\"/log/show\", name=\"pimcore_admin_log_show\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function showAction(Request $request, Connection $db)\n    {\n        $qb = $db->createQueryBuilder();\n        $qb\n            ->select('*')\n            ->from(ApplicationLoggerDb::TABLE_NAME)\n            ->setFirstResult($request->get('start', 0))\n            ->setMaxResults($request->get('limit', 50));\n\n        $sortingSettings = QueryParams::extractSortingSettings(array_merge(\n            $request->request->all(),\n            $request->query->all()\n        ));\n\n        if ($sortingSettings['orderKey']) {\n            $qb->orderBy($db->quoteIdentifier($sortingSettings['orderKey']), $sortingSettings['order']);\n        } else {\n            $qb->orderBy('id', 'DESC');\n        }\n\n        $priority = $request->get('priority');\n        if(!empty($priority)) {\n            $qb->andWhere($qb->expr()->eq('priority', ':priority'));\n            $qb->setParameter('priority', $priority);\n        }\n\n        if ($fromDate = $this->parseDateObject($request->get('fromDate'), $request->get('fromTime'))) {\n            $qb->andWhere('timestamp > :fromDate');\n            $qb->setParameter('fromDate', $fromDate, Types::DATETIME_MUTABLE);\n        }\n\n        if ($toDate = $this->parseDateObject($request->get('toDate'), $request->get('toTime'))) {\n            $qb->andWhere('timestamp <= :toDate');\n            $qb->setParameter('toDate', $toDate, Types::DATETIME_MUTABLE);\n        }\n\n        if (!empty($component = $request->get('component'))) {\n            $qb->andWhere('component = ' . $qb->createNamedParameter($component));\n        }\n\n        if (!empty($relatedObject = $request->get('relatedobject'))) {\n            $qb->andWhere('relatedobject = ' . $qb->createNamedParameter($relatedObject));\n        }\n\n        if (!empty($message = $request->get('message'))) {\n            $qb->andWhere('message LIKE ' . $qb->createNamedParameter('%' . $message . '%'));\n        }\n\n        if (!empty($pid = $request->get('pid'))) {\n            $qb->andWhere('pid LIKE ' . $qb->createNamedParameter('%' . $pid . '%'));\n        }\n\n        $totalQb = clone $qb;\n        $totalQb->setMaxResults(null)\n            ->setFirstResult(0)\n            ->select('COUNT(id) as count');\n        $total = $totalQb->execute()->fetch();\n        $total = (int) $total['count'];\n\n        $stmt = $qb->execute();\n        $result = $stmt->fetchAllAssociative();\n\n        $logEntries = [];\n        foreach ($result as $row) {\n            $fileobject = null;\n            if ($row['fileobject']) {\n                $fileobject = str_replace(PIMCORE_PROJECT_ROOT, '', $row['fileobject']);\n            }\n\n            $logEntry = [\n                'id' => $row['id'],\n                'pid' => $row['pid'],\n                'message' => $row['message'],\n                'timestamp' => $row['timestamp'],\n                'priority' => $row['priority'],\n                'fileobject' => $fileobject,\n                'relatedobject' => $row['relatedobject'],\n                'relatedobjecttype' => $row['relatedobjecttype'],\n                'component' => $row['component'],\n                'source' => $row['source'],\n            ];\n\n            $logEntries[] = $logEntry;\n        }\n\n        return $this->adminJson([\n            'p_totalCount' => $total,\n            'p_results' => $logEntries,\n        ]);\n    }\n\n    /**\n     * @param string|null $date\n     * @param string|null $time\n     *\n     * @return \\DateTime|null\n     */\n    private function parseDateObject($date = null, $time = null)\n    {\n        if (empty($date)) {\n            return null;\n        }\n\n        $pattern = '/^(?P<date>\\d{4}\\-\\d{2}\\-\\d{2})T(?P<time>\\d{2}:\\d{2}:\\d{2})$/';\n\n        $dateTime = null;\n        if (preg_match($pattern, $date, $dateMatches)) {\n            if (!empty($time) && preg_match($pattern, $time, $timeMatches)) {\n                $dateTime = new \\DateTime(sprintf('%sT%s', $dateMatches['date'], $timeMatches['time']));\n            } else {\n                $dateTime = new \\DateTime($date);\n            }\n        }\n\n        return $dateTime;\n    }\n\n    /**\n     * @Route(\"/log/priority-json\", name=\"pimcore_admin_log_priorityjson\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function priorityJsonAction(Request $request)\n    {\n        $priorities[] = ['key' => '', 'value' => '-'];\n        foreach (ApplicationLoggerDb::getPriorities() as $key => $p) {\n            $priorities[] = ['key' => $key, 'value' => $p];\n        }\n\n        return $this->adminJson(['priorities' => $priorities]);\n    }\n\n    /**\n     * @Route(\"/log/component-json\", name=\"pimcore_admin_log_componentjson\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function componentJsonAction(Request $request)\n    {\n        $components[] = ['key' => '', 'value' => '-'];\n        foreach (ApplicationLoggerDb::getComponents() as $p) {\n            $components[] = ['key' => $p, 'value' => $p];\n        }\n\n        return $this->adminJson(['components' => $components]);\n    }\n\n    /**\n     * @Route(\"/log/show-file-object\", name=\"pimcore_admin_log_showfileobject\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     *\n     * @throws \\Exception\n     */\n    public function showFileObjectAction(Request $request)\n    {\n        $filePath = $request->get('filePath');\n        $storage = Storage::get('application_log');\n\n        if ($storage->fileExists($filePath)) {\n            $fileHandle = $storage->readStream($filePath);\n            $response = $this->getResponseForFileHandle($fileHandle);\n            $response->headers->set('Content-Type', 'text/plain');\n        } else {\n            // Fallback to local path when file is not found in flysystem that might still be using the constant\n\n            if (!filter_var($filePath, FILTER_VALIDATE_URL)) {\n                if (!file_exists($filePath)) {\n                    $filePath = PIMCORE_PROJECT_ROOT.DIRECTORY_SEPARATOR.$filePath;\n                }\n                $filePath = realpath($filePath);\n                $fileObjectPath = realpath(PIMCORE_LOG_FILEOBJECT_DIRECTORY);\n            } else {\n                $fileObjectPath = PIMCORE_LOG_FILEOBJECT_DIRECTORY;\n            }\n\n            if (!str_starts_with($filePath, $fileObjectPath)) {\n                throw new AccessDeniedHttpException('Accessing file out of scope');\n            }\n\n            if (file_exists($filePath)) {\n                $fileHandle = fopen($filePath, 'rb');\n                $response = $this->getResponseForFileHandle($fileHandle);\n                $response->headers->set('Content-Type', 'text/plain');\n            } else {\n                $response = new Response();\n                $response->headers->set('Content-Type', 'text/plain');\n                $response->setContent('Path `'.$filePath.'` not found.');\n                $response->setStatusCode(404);\n            }\n        }\n\n        return $response;\n    }\n\n    /**\n     * @param resource $fileHandle\n     *\n     * @return StreamedResponse\n     */\n    private function getResponseForFileHandle($fileHandle)\n    {\n        return new StreamedResponse(\n            static function () use ($fileHandle) {\n                while (!feof($fileHandle)) {\n                    echo fread($fileHandle, 8192);\n                }\n                fclose($fileHandle);\n            }\n        );\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin;\n\nuse Doctrine\\DBAL\\Exception\\SyntaxErrorException;\nuse Doctrine\\DBAL\\Query\\QueryBuilder as DoctrineQueryBuilder;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Translation;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Session;\nuse Pimcore\\Translation\\ExportService\\Exporter\\ExporterInterface;\nuse Pimcore\\Translation\\ExportService\\ExportServiceInterface;\nuse Pimcore\\Translation\\ImportDataExtractor\\ImportDataExtractorInterface;\nuse Pimcore\\Translation\\ImporterService\\ImporterServiceInterface;\nuse Pimcore\\Translation\\TranslationItemCollection\\TranslationItemCollection;\nuse Pimcore\\Translation\\Translator;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpKernel\\Exception\\BadRequestHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * @Route(\"/translation\")\n *\n * @internal\n */\nclass TranslationController extends AdminController\n{\n    protected const PLACEHOLDER_NAME = 'placeHolder';\n\n    /**\n     * @Route(\"/import\", name=\"pimcore_admin_translation_import\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return JsonResponse\n     */\n    public function importAction(Request $request, LocaleServiceInterface $localeService)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $dialect = $request->get('csvSettings', null);\n        $session = Session::get('pimcore_importconfig');\n        $tmpFile = $session->get('translation_import_file');\n\n        if ($dialect) {\n            $dialect = json_decode($dialect);\n        }\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $merge = $request->get('merge');\n        $overwrite = !$merge;\n\n        $allowedLanguages = $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations();\n        if ($admin) {\n            $allowedLanguages = Tool\\Admin::getLanguages();\n        }\n\n        $delta = Translation::importTranslationsFromFile(\n            $tmpFile,\n            $domain,\n            $overwrite,\n            $allowedLanguages,\n            $dialect\n        );\n\n        if (is_file($tmpFile)) {\n            @unlink($tmpFile);\n        }\n\n        $result = [\n            'success' => true,\n        ];\n        if ($merge) {\n            $enrichedDelta = [];\n\n            foreach ($delta as $item) {\n                $lg = $item['lg'];\n                $currentLocale = $localeService->findLocale();\n                $item['lgname'] = \\Locale::getDisplayLanguage($lg, $currentLocale);\n                $item['icon'] = $this->generateUrl('pimcore_admin_misc_getlanguageflag', ['language' => $lg]);\n                $item['current'] = $item['text'];\n                $enrichedDelta[] = $item;\n            }\n\n            $result['delta'] = base64_encode(json_encode($enrichedDelta));\n        }\n\n        $response = $this->adminJson($result);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/upload-import\", name=\"pimcore_admin_translation_uploadimportfile\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function uploadImportFileAction(Request $request)\n    {\n        $tmpData = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        //store data for further usage\n        $filename = uniqid('import_translations-');\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $filename;\n        File::put($importFile, $tmpData);\n\n        Session::useSession(function (AttributeBagInterface $session) use ($importFile) {\n            $session->set('translation_import_file', $importFile);\n        }, 'pimcore_importconfig');\n\n        // determine csv settings\n        $dialect = Tool\\Admin::determineCsvDialect($importFile);\n\n        //ignore if line terminator is already hex otherwise generate hex for string\n        if (!empty($dialect->lineterminator) && empty(preg_match('/[a-f0-9]{2}/i', $dialect->lineterminator))) {\n            $dialect->lineterminator = bin2hex($dialect->lineterminator);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n            'config' => [\n                'csvSettings' => $dialect,\n            ],\n        ]);\n    }\n\n    /**\n     * @Route(\"/export\", name=\"pimcore_admin_translation_export\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain == Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n\n        $joins = [];\n\n        $list->setOrder('asc');\n        $list->setOrderKey($tableName . '.key', false);\n\n        $conditions = $this->getGridFilterCondition($request, $tableName, false, $admin);\n        if (!empty($conditions)) {\n            $list->setCondition($conditions['condition'], $conditions['params']);\n        }\n\n        $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n        if ($filters) {\n            $joins = array_merge($joins, $filters['joins']);\n        }\n\n        $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n\n        try {\n            $list->load();\n        } catch (SyntaxErrorException $syntaxErrorException) {\n            throw new \\InvalidArgumentException('Check your arguments.');\n        }\n\n        $translations = [];\n        $translationObjects = $list->getTranslations();\n\n        // fill with one dummy translation if the store is empty\n        if (empty($translationObjects)) {\n            if ($admin) {\n                $t = new Translation();\n                $t->setDomain(Translation::DOMAIN_ADMIN);\n                $languages = Tool\\Admin::getLanguages();\n            } else {\n                $t = new Translation();\n                $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n            }\n\n            foreach ($languages as $language) {\n                $t->addTranslation($language, '');\n            }\n\n            $translationObjects[] = $t;\n        }\n\n        foreach ($translationObjects as $t) {\n            $row = $t->getTranslations();\n            $row = Element\\Service::escapeCsvRecord($row);\n            $translations[] = array_merge(\n                ['key' => $t->getKey(),\n                    'creationDate' => $t->getCreationDate(),\n                    'modificationDate' => $t->getModificationDate(),\n                ],\n                $row\n            );\n        }\n\n        //header column\n        $columns = array_keys($translations[0]);\n\n        if ($admin) {\n            $languages = Tool\\Admin::getLanguages();\n        } else {\n            $languages = $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n        }\n\n        //add language columns which have no translations yet\n        foreach ($languages as $l) {\n            if (!in_array($l, $columns)) {\n                $columns[] = $l;\n            }\n        }\n\n        //remove invalid languages\n        foreach ($columns as $key => $column) {\n            if (strtolower(trim($column)) != 'key' && !in_array($column, $languages)) {\n                unset($columns[$key]);\n            }\n        }\n        $columns = array_values($columns);\n\n        $headerRow = [];\n        foreach ($columns as $key => $value) {\n            $headerRow[] = '\"' . $value . '\"';\n        }\n        $csv = implode(';', $headerRow) . \"\\r\\n\";\n\n        foreach ($translations as $t) {\n            $tempRow = [];\n            foreach ($columns as $key) {\n                $value = $t[$key] ?? null;\n                //clean value of evil stuff such as \" and linebreaks\n                if (is_string($value)) {\n                    $value = Tool\\Text::removeLineBreaks($value);\n                    $value = str_replace('\"', '&quot;', $value);\n\n                    $tempRow[$key] = '\"' . $value . '\"';\n                } else {\n                    $tempRow[$key] = $value;\n                }\n            }\n            $csv .= implode(';', $tempRow) . \"\\r\\n\";\n        }\n\n        $response = new Response(\"\\xEF\\xBB\\xBF\" . $csv);\n        $response->headers->set('Content-Encoding', 'UTF-8');\n        $response->headers->set('Content-Type', 'text/csv; charset=UTF-8');\n        $response->headers->set('Content-Disposition', 'attachment; filename=\"export_' . $domain . '_translations.csv\"');\n        ini_set('display_errors', '0'); //to prevent warning messages in csv\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/add-admin-translation-keys\", name=\"pimcore_admin_translation_addadmintranslationkeys\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAdminTranslationKeysAction(Request $request)\n    {\n        $keys = $request->get('keys');\n        if ($keys) {\n            $availableLanguages = Tool\\Admin::getLanguages();\n            $data = $this->decodeJson($keys);\n            foreach ($data as $translationData) {\n                $t = null; // reset\n\n                try {\n                    $t = Translation::getByKey($translationData, Translation::DOMAIN_ADMIN);\n                } catch (\\Exception $e) {\n                    Logger::log((string) $e);\n                }\n                if (!$t instanceof Translation) {\n                    $t = new Translation();\n                    $t->setDomain(Translation::DOMAIN_ADMIN);\n                    $t->setKey($translationData);\n                    $t->setCreationDate(time());\n                    $t->setModificationDate(time());\n\n                    foreach ($availableLanguages as $lang) {\n                        $t->addTranslation($lang, '');\n                    }\n\n                    try {\n                        $t->save();\n                    } catch (\\Exception $e) {\n                        Logger::log((string) $e);\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson(null);\n    }\n\n    /**\n     * @Route(\"/translations\", name=\"pimcore_admin_translation_translations\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Translator $translator\n     *\n     * @return JsonResponse\n     */\n    public function translationsAction(Request $request, TranslatorInterface $translator)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $admin = $domain === Translation::DOMAIN_ADMIN;\n\n        $this->checkPermission(($admin ? 'admin_' : '') . 'translations');\n\n        $translation = new Translation();\n        $translation->setDomain($domain);\n        $tableName = $translation->getDao()->getDatabaseTableName();\n\n        // clear translation cache\n        Translation::clearDependentCache();\n\n        if ($request->get('data')) {\n            $data = $this->decodeJson($request->get('data'));\n\n            if ($request->get('xaction') == 'destroy') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t instanceof Translation) {\n                    $t->delete();\n                }\n\n                return $this->adminJson(['success' => true, 'data' => []]);\n            } elseif ($request->get('xaction') == 'update') {\n                $t = Translation::getByKey($data['key'], $domain);\n\n                foreach ($data as $key => $value) {\n                    $key = preg_replace('/^_/', '', $key, 1);\n                    if (!in_array($key, ['key', 'type'])) {\n                        $t->addTranslation($key, $value);\n                    }\n                }\n\n                if ($data['key']) {\n                    $t->setKey($data['key']);\n                }\n\n                if ($data['type']) {\n                    $t->setType($data['type']);\n                }\n                $t->setModificationDate(time());\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            } elseif ($request->get('xaction') == 'create') {\n                $t = Translation::getByKey($data['key'], $domain);\n                if ($t) {\n                    return $this->adminJson([\n                        'message' => 'identifier_already_exists',\n                        'success' => false,\n                    ]);\n                }\n\n                $t = new Translation();\n                $t->setDomain($domain);\n                $t->setKey($data['key']);\n                $t->setCreationDate(time());\n                $t->setModificationDate(time());\n                $t->setType($data['type'] ?? null);\n\n                foreach (Tool::getValidLanguages() as $lang) {\n                    $t->addTranslation($lang, '');\n                }\n                $t->save();\n\n                $return = array_merge(\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ],\n                    $this->prefixTranslations($t->getTranslations())\n                );\n\n                return $this->adminJson(['data' => $return, 'success' => true]);\n            }\n        } else {\n            // get list of types\n            $list = new Translation\\Listing();\n            $list->setDomain($domain);\n\n            $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n            $list->setOrder('asc');\n            $list->setOrderKey($tableName . '.key', false);\n            $list->setLanguages($validLanguages);\n\n            $sortingSettings = \\Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams::extractSortingSettings(\n                array_merge($request->request->all(), $request->query->all())\n            );\n\n            $joins = [];\n\n            if ($orderKey = $sortingSettings['orderKey']) {\n                if (in_array(trim($orderKey, '_'), $validLanguages)) {\n                    $orderKey = trim($orderKey, '_');\n                    $joins[] = [\n                        'language' => $orderKey,\n                    ];\n                    $list->setOrderKey($orderKey);\n                } elseif ($list->isValidOrderKey($sortingSettings['orderKey'])) {\n                    $list->setOrderKey($tableName . '.' . $sortingSettings['orderKey'], false);\n                }\n            }\n            if ($sortingSettings['order']) {\n                $list->setOrder($sortingSettings['order']);\n            }\n\n            $list->setLimit($request->get('limit'));\n            $list->setOffset($request->get('start'));\n\n            $conditions = $this->getGridFilterCondition($request, $tableName, false, $admin);\n            $filters = $this->getGridFilterCondition($request, $tableName, true, $admin);\n\n            if ($filters) {\n                $joins = array_merge($joins, $filters['joins']);\n            }\n\n            if (!empty($conditions)) {\n                $list->setCondition($conditions['condition'], $conditions['params']);\n            }\n\n            $this->extendTranslationQuery($joins, $list, $tableName, $filters);\n\n            try {\n                $list->load();\n            } catch (SyntaxErrorException $syntaxErrorException) {\n                throw new \\InvalidArgumentException('Check your arguments.');\n            }\n\n            $translations = [];\n            $searchString = $request->get('searchString');\n            foreach ($list->getTranslations() as $t) {\n                //Reload translation to get complete data,\n                //if translation fetched based on the text not key\n                if ($searchString && !strpos($searchString, $t->getKey())) {\n                    if (!$t = Translation::getByKey($t->getKey(), $domain)) {\n                        continue;\n                    }\n                }\n\n                $translations[] = array_merge(\n                    $this->prefixTranslations($t->getTranslations()),\n                    [\n                        'key' => $t->getKey(),\n                        'creationDate' => $t->getCreationDate(),\n                        'modificationDate' => $t->getModificationDate(),\n                        'type' => $t->getType(),\n                    ]\n                );\n            }\n\n            return $this->adminJson(['data' => $translations, 'success' => true, 'total' => $list->getTotalCount()]);\n        }\n\n        return $this->adminJson(['success' => false]);\n    }\n\n    /**\n     * @param array $translations\n     *\n     * @return array\n     */\n    protected function prefixTranslations($translations)\n    {\n        if (!is_array($translations)) {\n            return $translations;\n        }\n\n        $prefixedTranslations = [];\n        foreach ($translations as $lang => $trans) {\n            $prefixedTranslations['_' . $lang] = $trans;\n        }\n\n        return $prefixedTranslations;\n    }\n\n    /**\n     * @param array $joins\n     * @param Translation\\Listing $list\n     * @param string $tableName\n     * @param array $filters\n     */\n    protected function extendTranslationQuery($joins, $list, $tableName, $filters)\n    {\n        if ($joins) {\n            $list->onCreateQueryBuilder(\n                function (DoctrineQueryBuilder $select) use (\n                    $joins,\n                    $tableName,\n                    $filters\n                ) {\n                    $db = \\Pimcore\\Db::get();\n\n                    $alreadyJoined = [];\n\n                    foreach ($joins as $join) {\n                        $fieldname = $join['language'];\n\n                        if (isset($alreadyJoined[$fieldname])) {\n                            continue;\n                        }\n                        $alreadyJoined[$fieldname] = 1;\n\n                        $select->addSelect($fieldname . '.text AS ' . $fieldname);\n                        $select->leftJoin(\n                            $tableName,\n                            $tableName,\n                            $fieldname,\n                            '('\n                            . $fieldname . '.key = ' . $tableName . '.key'\n                            . ' and ' . $fieldname . '.language = ' . $db->quote($fieldname)\n                            . ')'\n                        );\n                    }\n\n                    $havings = $filters['conditions'];\n                    if ($havings) {\n                        $havings = implode(' AND ', $havings);\n                        $select->having($havings);\n                    }\n                }\n            );\n        }\n    }\n\n    /**\n     * @param Request $request\n     * @param string $tableName\n     * @param bool $languageMode\n     * @param bool $admin\n     *\n     * @return array\n     */\n    protected function getGridFilterCondition(Request $request, $tableName, $languageMode = false, $admin = false)\n    {\n        $placeHolderCount = 0;\n        $joins = [];\n        $conditions = [];\n        $validLanguages = $admin ? Tool\\Admin::getLanguages() : $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations();\n\n        $db = \\Pimcore\\Db::get();\n        $conditionFilters = [];\n\n        $filterJson = $request->get('filter');\n        if ($filterJson) {\n            $propertyField = 'property';\n            $operatorField = 'operator';\n\n            $filters = $this->decodeJson($filterJson);\n\n            foreach ($filters as $filter) {\n                $operator = '=';\n                $field = null;\n                $value = null;\n\n                $fieldname = $filter[$propertyField];\n                if (in_array(ltrim($fieldname, '_'), $validLanguages)) {\n                    $fieldname = ltrim($fieldname, '_');\n                }\n                $fieldname = str_replace('--', '', $fieldname);\n\n                if (!$languageMode && in_array($fieldname, $validLanguages)\n                    || $languageMode && !in_array($fieldname, $validLanguages)) {\n                    continue;\n                }\n\n                if (!$languageMode) {\n                    $fieldname = $tableName . '.' . $fieldname;\n                }\n\n                if (!empty($filter['value'])) {\n                    if ($filter['type'] == 'string') {\n                        $operator = 'LIKE';\n                        $field = $fieldname;\n                        $value = '%' . $filter['value'] . '%';\n                    } elseif ($filter['type'] == 'date' ||\n                        (in_array($fieldname, ['modificationDate', 'creationDate']))) {\n                        if ($filter[$operatorField] == 'lt') {\n                            $operator = '<';\n                        } elseif ($filter[$operatorField] == 'gt') {\n                            $operator = '>';\n                        } elseif ($filter[$operatorField] == 'eq') {\n                            $operator = '=';\n                            $fieldname = \"UNIX_TIMESTAMP(DATE(FROM_UNIXTIME({$fieldname})))\";\n                        }\n                        $filter['value'] = strtotime($filter['value']);\n                        $field = $fieldname;\n                        $value = $filter['value'];\n                    }\n                }\n\n                if ($field && $value) {\n                    $condition = $db->quoteIdentifier($field) . ' ' . $operator . ' ' . $db->quote($value);\n\n                    if ($languageMode) {\n                        $conditions[$fieldname] = $condition;\n                        $joins[] = [\n                            'language' => $fieldname,\n                        ];\n                    } else {\n                        $placeHolderName = self::PLACEHOLDER_NAME . $placeHolderCount;\n                        $placeHolderCount++;\n                        $conditionFilters[] = [\n                            'condition' => $field . ' ' . $operator . ' :' . $placeHolderName,\n                            'field' => $placeHolderName,\n                            'value' => $value,\n                        ];\n                    }\n                }\n            }\n        }\n\n        if ($request->get('searchString')) {\n            $conditionFilters[] = [\n                'condition' => '(lower(' . $tableName . '.key) LIKE :filterTerm OR lower(' . $tableName . '.text) LIKE :filterTerm)',\n                'field' => 'filterTerm',\n                'value' => '%' . mb_strtolower($request->get('searchString')) . '%',\n            ];\n        }\n\n        if ($languageMode) {\n            return [\n                'joins' => $joins,\n                'conditions' => $conditions,\n            ];\n        }\n\n        if(!empty($conditionFilters)) {\n            $conditions = [];\n            $params = [];\n            foreach($conditionFilters as $conditionFilter) {\n                $conditions[] = $conditionFilter['condition'];\n                $params[$conditionFilter['field']] = $conditionFilter['value'];\n            }\n\n            $conditionFilters = [\n                'condition' => implode(' AND ', $conditions),\n                'params' => $params,\n            ];\n        }\n\n        return $conditionFilters;\n    }\n\n    /**\n     * @Route(\"/cleanup\", name=\"pimcore_admin_translation_cleanup\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function cleanupAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n        $list = new Translation\\Listing();\n        $list->setDomain($domain);\n        $list->cleanup();\n\n        \\Pimcore\\Cache::clearTags(['translator', 'translate']);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * -----------------------------------------------------------------------------------\n     * THE FOLLOWING ISN'T RELATED TO THE SHARED TRANSLATIONS OR ADMIN-TRANSLATIONS\n     * XLIFF CONTENT-EXPORT & MS WORD CONTENT-EXPORT\n     * -----------------------------------------------------------------------------------\n     */\n\n    /**\n     * @Route(\"/content-export-jobs\", name=\"pimcore_admin_translation_contentexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function contentExportJobsAction(Request $request)\n    {\n        $data = $this->decodeJson($request->get('data'));\n        $elements = [];\n        $jobs = [];\n        $exportId = uniqid();\n        $source = $request->get('source');\n        $target = $request->get('target');\n        $type = $request->get('type');\n\n        $source = str_replace('_', '-', $source);\n        $target = str_replace('_', '-', $target);\n\n        if ($data && is_array($data)) {\n            foreach ($data as $element) {\n                $elements[$element['type'] . '_' . $element['id']] = [\n                    'id' => $element['id'],\n                    'type' => $element['type'],\n                ];\n\n                $el = null;\n\n                if ($element['children']) {\n                    $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    $baseClass = ELement\\Service::getBaseClassNameForElement($element['type']);\n                    $listClass = '\\\\Pimcore\\\\Model\\\\' . $baseClass . '\\\\Listing';\n                    $list = new $listClass();\n                    $list->setUnpublished(true);\n                    if ($el instanceof DataObject\\AbstractObject) {\n                        // inlcude variants\n                        $list->setObjectTypes(\n                            [DataObject::OBJECT_TYPE_VARIANT,\n                                DataObject::OBJECT_TYPE_OBJECT,\n                                DataObject::OBJECT_TYPE_FOLDER, ]\n                        );\n                    }\n                    $list->setCondition(\n                        ($el instanceof DataObject ? 'o_' : '') . 'path LIKE ?',\n                        [$list->escapeLike($el->getRealFullPath() . ($el->getRealFullPath() != '/' ? '/' : '')) . '%']\n                    );\n                    $childs = $list->load();\n\n                    foreach ($childs as $child) {\n                        $childId = $child->getId();\n                        $elements[$element['type'] . '_' . $childId] = [\n                            'id' => $childId,\n                            'type' => $element['type'],\n                        ];\n\n                        if (isset($element['relations']) && $element['relations']) {\n                            $childDependencies = $child->getDependencies()->getRequires();\n                            foreach ($childDependencies as $cd) {\n                                if ($cd['type'] == 'object' || $cd['type'] == 'document') {\n                                    $elements[$cd['type'] . '_' . $cd['id']] = $cd;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (isset($element['relations']) && $element['relations']) {\n                    if (!$el instanceof Element\\ElementInterface) {\n                        $el = Element\\Service::getElementById($element['type'], $element['id']);\n                    }\n\n                    $dependencies = $el->getDependencies()->getRequires();\n                    foreach ($dependencies as $dependency) {\n                        if ($dependency['type'] == 'object' || $dependency['type'] == 'document') {\n                            $elements[$dependency['type'] . '_' . $dependency['id']] = $dependency;\n                        }\n                    }\n                }\n            }\n        }\n\n        $elements = array_values($elements);\n\n        $elementsPerJob = 10;\n        if ($type == 'word') {\n            // the word export can only handle one document per request\n            // the problem is Document\\Service::render(), ... in the action can be a $this->redirect() or exit;\n            // nobody knows what's happening in an action ;-) So we need to isolate them in isolated processes\n            // so that the export doesn't stop completely after a \"redirect\" or any other unexpected behavior of an action\n            $elementsPerJob = 1;\n        }\n\n        // one job = X elements\n        $elements = array_chunk($elements, $elementsPerJob);\n        foreach ($elements as $chunk) {\n            $jobs[] = [[\n                'url' => $request->getBaseUrl() . '/admin/translation/' . $type . '-export',\n                'method' => 'POST',\n                'params' => [\n                    'id' => $exportId,\n                    'source' => $source,\n                    'target' => $target,\n                    'data' => $this->encodeJson($chunk),\n                ],\n            ]];\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n                'jobs' => $jobs,\n                'id' => $exportId,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/xliff-export\", name=\"pimcore_admin_translation_xliffexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ExportServiceInterface $exportService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffExportAction(Request $request, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n        $target = $request->get('target');\n\n        $translationItems = new TranslationItemCollection();\n\n        foreach ($data as $el) {\n            $element = Element\\Service::getElementById($el['type'], $el['id']);\n            $translationItems->addPimcoreElement($element);\n        }\n\n        $exportService->exportTranslationItems($translationItems, $source, [$target], $id);\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/xliff-export-download\", name=\"pimcore_admin_translation_xliffexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param ExporterInterface $translationExporter\n     *\n     * @return BinaryFileResponse\n     */\n    public function xliffExportDownloadAction(Request $request, ExporterInterface $translationExporter, ExportServiceInterface $exportService)\n    {\n        $id = $request->get('id');\n        $exportFile = $exportService->getTranslationExporter()->getExportFilePath($id);\n\n        $response = new BinaryFileResponse($exportFile);\n        $response->headers->set('Content-Type', $translationExporter->getContentType());\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, basename($exportFile));\n        $response->deleteFileAfterSend(true);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-upload\", name=\"pimcore_admin_translation_xliffimportupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportUploadAction(Request $request, ImportDataExtractorInterface $importDataExtractor)\n    {\n        $jobs = [];\n        $id = uniqid();\n        $importFile = $importDataExtractor->getImportFilePath($id);\n        copy($_FILES['file']['tmp_name'], $importFile);\n\n        $steps = $importDataExtractor->countSteps($id);\n\n        for ($i = 0; $i < $steps; $i++) {\n            $jobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_translation_xliffimportelement'),\n                'method' => 'POST',\n                'params' => [\n                    'id' => $id,\n                    'step' => $i,\n                ],\n            ]];\n        }\n\n        $response = $this->adminJson([\n            'success' => true,\n            'jobs' => $jobs,\n            'id' => $id,\n        ]);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/xliff-import-element\", name=\"pimcore_admin_translation_xliffimportelement\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param ImportDataExtractorInterface $importDataExtractor\n     * @param ImporterServiceInterface $importerService\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function xliffImportElementAction(Request $request, ImportDataExtractorInterface $importDataExtractor, ImporterServiceInterface $importerService)\n    {\n        $id = $request->get('id');\n        $step = $request->get('step');\n\n        try {\n            $attributeSet = $importDataExtractor->extractElement($id, $step);\n            if ($attributeSet) {\n                $importerService->import($attributeSet);\n            } else {\n                Logger::warning(sprintf('Could not resolve element %s', $id));\n            }\n        } catch (\\Exception $e) {\n            Logger::err($e->getMessage());\n\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/word-export\", name=\"pimcore_admin_translation_wordexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function wordExportAction(Request $request)\n    {\n        ini_set('display_errors', 'off');\n\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, false);\n\n        $data = $this->decodeJson($request->get('data'));\n        $source = $request->get('source');\n\n        if (!is_file($exportFile)) {\n            File::put($exportFile, '');\n        }\n\n        foreach ($data as $el) {\n            try {\n                $element = Element\\Service::getElementById($el['type'], $el['id']);\n                $output = '';\n\n                // check supported types (subtypes)\n                if (!in_array($element->getType(), ['page', 'snippet', 'email', 'object'])) {\n                    continue;\n                }\n\n                if ($element instanceof Element\\ElementInterface) {\n                    $output .= '<h1 class=\"element-headline\">' . ucfirst(\n                        $element->getType()\n                    ) . ' - ' . $element->getRealFullPath() . ' (ID: ' . $element->getId() . ')</h1>';\n                }\n\n                if ($element instanceof Document\\PageSnippet) {\n                    if ($element instanceof Document\\Page) {\n                        $structuredDataEmpty = true;\n                        $structuredData = '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Structured Data</span></td>\n                                </tr>\n                        ';\n\n                        if ($element->getTitle()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Title</span></td>\n                                    <td>' . $element->getTitle() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getDescription()) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Description</span></td>\n                                    <td>' . $element->getDescription() . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        if ($element->getProperty('navigation_name')) {\n                            $structuredData .= '<tr>\n                                    <td><span style=\"color:#cc2929;\">Navigation</span></td>\n                                    <td>' . $element->getProperty('navigation_name') . '&nbsp;</td>\n                                </tr>';\n                            $structuredDataEmpty = false;\n                        }\n\n                        $structuredData .= '</table>';\n\n                        if (!$structuredDataEmpty) {\n                            $output .= $structuredData;\n                        }\n                    }\n\n                    // we need to set the parameter \"pimcore_admin\" here to be able to render unpublished documents\n                    $html = Document\\Service::render($element, [], false, ['pimcore_admin' => true]);\n\n                    $html = preg_replace(\n                        '@</?(img|meta|div|section|aside|article|body|bdi|bdo|canvas|embed|footer|head|header|html)([^>]+)?>@',\n                        '',\n                        $html\n                    );\n                    $html = preg_replace('/<!--(.*)-->/Uis', '', $html);\n\n                    $dom = new Tool\\DomCrawler($html);\n                    // remove containers including their contents\n                    $elements = $dom->filter('form, script, style, noframes, noscript, object, area, mapm, video, audio, iframe, textarea, input, select, button');\n                    foreach ($elements as $element) {\n                        $element->parentNode->removeChild($element);\n                    }\n\n                    $clearText = function ($string) {\n                        $string = str_replace(\"\\r\\n\", '', $string);\n                        $string = str_replace(\"\\n\", '', $string);\n                        $string = str_replace(\"\\r\", '', $string);\n                        $string = str_replace(\"\\t\", '', $string);\n                        $string = preg_replace('/&[a-zA-Z0-9]+;/', '', $string); // remove html entities\n                        $string = preg_replace('#[ ]+#', '', $string);\n\n                        return $string;\n                    };\n\n                    // remove empty tags (where it matters)\n                    // replace links => links get [Linktext]\n                    $elements = $dom->filter('a');\n                    foreach ($elements as $element) {\n                        $string = $clearText($element->textContent);\n                        if (!empty($string)) {\n                            $newNode = $element->ownerDocument->createTextNode('[' . $element->textContent . ']');\n\n                            $element->parentNode->replaceChild($newNode, $element);\n                        } else {\n                            $element->ownerDocument->textContent = '';\n                        }\n                    }\n\n                    if ($dom->count() > 0) {\n                        $html = $dom->html();\n                    }\n\n                    $dom->clear();\n                    unset($dom);\n\n                    // force closing tags\n                    $doc = new \\DOMDocument();\n                    libxml_use_internal_errors(true);\n                    $doc->loadHTML('<?xml encoding=\"UTF-8\"><article>' . $html . '</article>');\n                    libxml_clear_errors();\n                    $html = $doc->saveHTML();\n\n                    $bodyStart = strpos($html, '<body>');\n                    $bodyEnd = strpos($html, '</body>');\n                    if ($bodyStart && $bodyEnd) {\n                        $html = substr($html, $bodyStart + 6, $bodyEnd - $bodyStart);\n                    }\n\n                    $output .= $html;\n                } elseif ($element instanceof DataObject\\Concrete) {\n                    $hasContent = false;\n\n                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields|null $fd */\n                    $fd = $element->getClass()->getFieldDefinition('localizedfields');\n                    if ($fd) {\n                        $definitions = $fd->getFieldDefinitions();\n\n                        $locale = str_replace('-', '_', $source);\n                        if (!Tool::isValidLanguage($locale)) {\n                            $locale = \\Locale::getPrimaryLanguage($locale);\n                        }\n\n                        $output .= '\n                            <table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">\n                                <tr>\n                                    <td colspan=\"2\"><span style=\"color:#cc2929;font-weight: bold;\">Localized Data</span></td>\n                                </tr>\n                        ';\n\n                        foreach ($definitions as $definition) {\n                            // check allowed datatypes\n                            if (!in_array($definition->getFieldtype(), ['input', 'textarea', 'wysiwyg'])) {\n                                continue;\n                            }\n\n                            $content = $element->{'get' . ucfirst($definition->getName())}($locale);\n\n                            if (!empty($content)) {\n                                $output .= '\n                                <tr>\n                                    <td><span style=\"color:#cc2929;\">' . $definition->getTitle() . ' (' . $definition->getName() . ')<span></td>\n                                    <td>' . $content . '&nbsp;</td>\n                                </tr>\n                                ';\n\n                                $hasContent = true;\n                            }\n                        }\n\n                        $output .= '</table>';\n                    }\n\n                    if (!$hasContent) {\n                        $output = ''; // there's no content in the object, so reset all contents and do not inclide it in the export\n                    }\n                }\n\n                // append contents\n                if (!empty($output)) {\n                    $f = fopen($exportFile, 'a+');\n                    fwrite($f, $output);\n                    fclose($f);\n                }\n            } catch (\\Exception $e) {\n                Logger::error('Word Export: ' . $e);\n\n                throw $e;\n            }\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/word-export-download\", name=\"pimcore_admin_translation_wordexportdownload\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function wordExportDownloadAction(Request $request)\n    {\n        $id = $this->sanitzeExportId((string)$request->get('id'));\n        $exportFile = $this->getExportFilePath($id, true);\n\n        // no conversion, output html file, works fine with MS Word and LibreOffice\n        $content = file_get_contents($exportFile);\n        @unlink($exportFile);\n\n        // replace <script> and <link>\n        $content = preg_replace('/<link[^>]+>/im', '$1', $content);\n        $content = preg_replace(\"/<script[^>]+>(.*)?<\\/script>/im\", '$1', $content);\n\n        $content =\n            \"<html>\\n\" .\n            \"<head>\\n\" .\n            '<style type=\"text/css\">' . \"\\n\" .\n            file_get_contents(PIMCORE_WEB_ROOT . '/bundles/pimcoreadmin/css/word-export.css') .\n            \"</style>\\n\" .\n            \"</head>\\n\\n\" .\n            \"<body>\\n\" .\n            $content .\n            \"\\n\\n</body>\\n\" .\n            \"</html>\\n\";\n\n        $response = new Response($content);\n        $response->headers->set('Content-Type', 'text/html');\n        $response->headers->set(\n            'Content-Disposition',\n            'attachment; filename=\"word-export-' . date('Ymd') . '_' . uniqid() . '.htm\"'\n        );\n\n        return $response;\n    }\n\n    private function sanitzeExportId(string $id): string\n    {\n        if (empty($id) || !preg_match('/^[a-z0-9]+$/', $id)) {\n            throw new BadRequestHttpException('Invalid export ID format');\n        }\n\n        return $id;\n    }\n\n    private function getExportFilePath(string $id, bool $checkExistence = true): string\n    {\n        // no need to check for path traversals here as sanitizeExportId restricted the ID parameter\n        $exportFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . DIRECTORY_SEPARATOR . $id . '.html';\n\n        if ($checkExistence && !file_exists($exportFile)) {\n            throw $this->createNotFoundException(sprintf('Export file does not exist at path %s', $exportFile));\n        }\n\n        return $exportFile;\n    }\n\n    /**\n     * @Route(\"/merge-item\", name=\"pimcore_admin_translation_mergeitem\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function mergeItemAction(Request $request)\n    {\n        $domain = $request->get('domain', Translation::DOMAIN_DEFAULT);\n\n        $dataList = json_decode($request->get('data'), true);\n\n        foreach ($dataList as $data) {\n            $t = Translation::getByKey($data['key'], $domain, true);\n            $newValue = htmlspecialchars_decode($data['current']);\n            $t->addTranslation($data['lg'], $newValue);\n            $t->setModificationDate(time());\n            $t->save();\n        }\n\n        return $this->adminJson(\n            [\n                'success' => true,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-website-translation-languages\", name=\"pimcore_admin_translation_getwebsitetranslationlanguages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getWebsiteTranslationLanguagesAction(Request $request)\n    {\n        return $this->adminJson(\n            [\n                'view' => $this->getAdminUser()->getAllowedLanguagesForViewingWebsiteTranslations(),\n\n                //when no view language is defined, all languages are editable. if one view language is defined, it\n                //may be possible that no edit language is set intentionally\n                'edit' => $this->getAdminUser()->getAllowedLanguagesForEditingWebsiteTranslations(),\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/get-translation-domains\", name=\"pimcore_admin_translation_gettranslationdomains\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTranslationDomainsAction(Request $request)\n    {\n        $translation = new Translation();\n\n        $domains = array_map(\n            fn ($domain) => ['name' => $domain],\n            $translation->getDao()->getAvailableDomains(),\n        );\n\n        return $this->adminJson(['domains' => $domains]);\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Helper;\n\nuse Carbon\\Carbon;\n\n/**\n * @internal\n */\nclass QueryParams\n{\n    /**\n     * @param array $params\n     *\n     * @return array  [orderKey => null|string, order => null|string]\n     */\n    public static function extractSortingSettings($params)\n    {\n        $orderKey = null;\n        $order = null;\n\n        $sortParam = isset($params['sort']) ? $params['sort'] : false;\n        if ($sortParam) {\n            $sortParam = json_decode($sortParam, true);\n            $sortParam = $sortParam[0];\n\n            $order = strtoupper($sortParam['direction']) === 'DESC' ? 'DESC' : 'ASC';\n\n            if (substr($sortParam['property'], 0, 1) != '~') {\n                $orderKey = $sortParam['property'];\n            } else {\n                $orderKey = $sortParam['property'];\n\n                $parts = explode('~', $orderKey);\n\n                $fieldname = $parts[2];\n                $groupKeyId = $parts[3];\n                $groupKeyId = explode('-', $groupKeyId);\n                $groupId = (int) $groupKeyId[0];\n                $keyid = (int) $groupKeyId[1];\n\n                return ['orderKey' => $sortParam['property'], 'fieldname' => $fieldname, 'groupId' => $groupId, 'keyId' => $keyid, 'order' => $order, 'isFeature' => 1];\n            }\n        }\n\n        return ['orderKey' => $orderKey, 'order' => $order];\n    }\n\n    /**\n     * @param string $param\n     *\n     * @return int\n     */\n    public static function getRecordIdForGridRequest($param)\n    {\n        $param = json_decode($param, true);\n\n        return $param['id'];\n    }\n\n    /**\n     * Creates a condition string from the passed ExtJs filter definitions\n     *\n     * @param string $filterString\n     * @param array $matchExact\n     * @param bool $returnString\n     * @param array $callbacks\n     *\n     * @return array|string\n     *\n     * @throws \\Exception\n     */\n    public static function getFilterCondition($filterString, $matchExact = ['id', 'o_id'], $returnString = true, $callbacks = [])\n    {\n        if (!$filterString) {\n            return '';\n        }\n        $conditions = [];\n\n        $filters = json_decode($filterString);\n        $db = \\Pimcore\\Db::get();\n        foreach ($filters as $f) {\n            if ($f->type == 'string') {\n                if (in_array($f->property, $matchExact)) {\n                    $conditions[$f->property][] = ' ' . $db->quoteIdentifier($f->property) . ' = ' . $db->quote($f->value) . ' ';\n                } else {\n                    $conditions[$f->property][] = ' ' . $db->quoteIdentifier($f->property) . ' LIKE ' . $db->quote('%' . $f->value . '%') . ' ';\n                }\n            } elseif ($f->type == 'numeric') {\n                $symbol = null;\n                if ($f->operator == 'eq') {\n                    $symbol = ' = ';\n                } elseif ($f->operator == 'lt') {\n                    $symbol = ' < ';\n                } elseif ($f->operator == 'gt') {\n                    $symbol = ' > ';\n                }\n                $conditions[$f->property][] = ' ' . $db->quoteIdentifier($f->property)  . ' ' . $symbol . $db->quote($f->value) . ' ';\n            } elseif ($f->type == 'date') {\n                /**\n                 * make sure you pass the date as timestamp\n                 *\n                 * filter: {type : 'date',dateFormat: 'timestamp'}\n                 */\n                $date = Carbon::createFromTimestamp($f->value)->setTime(0, 0, 0);\n\n                if ($f->operator == 'eq') {\n                    $conditions[$f->property][] = ' ' . $f->property . ' >= ' . $db->quote($date->getTimestamp());\n                    $conditions[$f->property][] = ' ' . $f->property . ' <= ' . $db->quote($date->addDay()->subSecond()->getTimestamp());\n                } elseif ($f->operator == 'lt') {\n                    $conditions[$f->property][] = ' ' . $f->property . ' < ' . $db->quote($date->getTimestamp());\n                } elseif ($f->operator == 'gt') {\n                    $conditions[$f->property][] = ' ' . $f->property . ' > ' . $db->quote($date->addDay()->subSecond()->getTimestamp());\n                }\n            } else {\n                throw new \\Exception('Filer of type ' . $f->type . ' not jet supported.');\n            }\n        }\n\n        $conditionsGrouped = [];\n        foreach ($conditions as $fieldName => $fieldConditions) {\n            if (count($fieldConditions) > 1) {\n                $conditionsGrouped[$fieldName] = ' (' . implode(' AND ', $fieldConditions) . ') ';\n            } else {\n                $conditionsGrouped[$fieldName] = $fieldConditions[0];\n            }\n        }\n        if ($returnString) {\n            return implode(' OR ', $conditionsGrouped);\n        } else {\n            return $conditionsGrouped;\n        }\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\Search\\Backend\\Data;\n\nuse Pimcore\\Model\\Search\\Backend\\Data;\n\n/**\n * @internal\n *\n * @method \\Pimcore\\Model\\Search\\Backend\\Data\\Listing\\Dao getDao()\n * @method Data[] load()\n * @method Data|false current()\n * @method int getTotalCount()\n */\nclass Listing extends \\Pimcore\\Model\\Listing\\AbstractListing\n{\n    /**\n     * @return Data[]\n     */\n    public function getEntries()\n    {\n        return $this->getData();\n    }\n\n    /**\n     * @param Data[]|null $entries\n     *\n     * @return $this\n     */\n    public function setEntries($entries)\n    {\n        return $this->setData($entries);\n    }\n\n    /**\n     * @throws \\Exception\n     */\n    public function __construct()\n    {\n        $this->initDao(__CLASS__);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function isValidOrderKey($key)\n    {\n        return in_array(\n            $key,\n            [\n                'type',\n                'id',\n                'key',\n                'index',\n                'fullpath',\n                'maintype',\n                'subtype',\n                'published',\n                'creationDate',\n                'modificationDate',\n                'userOwner',\n                'userModification',\n                'data',\n                'properties'\n            ]\n        );\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Model\\Translation;\n\nuse Pimcore\\Model;\nuse Pimcore\\Model\\Exception\\NotFoundException;\n\n/**\n * @method \\Pimcore\\Model\\Translation\\Listing\\Dao getDao()\n * @method Model\\Translation[] load()\n * @method array loadRaw()\n * @method Model\\Translation|false current()\n * @method int getTotalCount()\n * @method void onCreateQueryBuilder(?callable $callback)\n * @method void cleanup()\n *\n */\nclass Listing extends Model\\Listing\\AbstractListing\n{\n    /**\n     * @internal\n     *\n     * @var int maximum number of cacheable items\n     */\n    protected static $cacheLimit = 5000;\n\n    /**\n     * @internal\n     *\n     * @var string\n     */\n    protected $domain = Model\\Translation::DOMAIN_DEFAULT;\n\n    /**\n     * @internal\n     *\n     * @var string[]|null\n     */\n    protected ?array $languages = null;\n\n    /**\n     * @inheritdoc\n     */\n    public function isValidOrderKey($key)\n    {\n        return in_array($key, ['key', 'type']) || in_array($key, $this->getLanguages());\n    }\n\n    /**\n     * @return string\n     */\n    public function getDomain(): string\n    {\n        return $this->domain;\n    }\n\n    /**\n     * @param string $domain\n     */\n    public function setDomain(string $domain): void\n    {\n        if (!Model\\Translation::isAValidDomain($domain)) {\n            throw new NotFoundException(sprintf('Translation domain table \"translations_%s\" does not exist', $domain));\n        }\n\n        $this->domain = $domain;\n    }\n\n    /**\n     * @return string[]|null\n     */\n    public function getLanguages(): ?array\n    {\n        return $this->languages;\n    }\n\n    /**\n     * @param string[]|null $languages\n     */\n    public function setLanguages(?array $languages): void\n    {\n        $this->languages = $languages;\n    }\n\n    /**\n     * @return \\Pimcore\\Model\\Translation[]\n     */\n    public function getTranslations()\n    {\n        return $this->getData();\n    }\n\n    /**\n     * @param array $translations\n     *\n     * @return \\Pimcore\\Model\\Translation\\Listing\n     */\n    public function setTranslations($translations)\n    {\n        return $this->setData($translations);\n    }\n\n    /**\n     * @return int\n     */\n    public static function getCacheLimit()\n    {\n        return self::$cacheLimit;\n    }\n\n    /**\n     * @param int $cacheLimit\n     */\n    public static function setCacheLimit($cacheLimit)\n    {\n        self::$cacheLimit = $cacheLimit;\n    }\n}\n"], "filenames": ["bundles/AdminBundle/Controller/Admin/LogController.php", "bundles/AdminBundle/Controller/Admin/TranslationController.php", "bundles/AdminBundle/Helper/QueryParams.php", "models/Search/Backend/Data/Listing.php", "models/Translation/Listing.php"], "buggy_code_start_loc": [70, 445, 39, 54, 52], "buggy_code_end_loc": [71, 445, 46, 54, 52], "fixing_code_start_loc": [70, 446, 40, 55, 53], "fixing_code_end_loc": [71, 447, 45, 81, 61], "type": "CWE-89", "message": " SQL Injection in GitHub repository pimcore/pimcore prior to 10.5.24.", "other": {"cve": {"id": "CVE-2023-3673", "sourceIdentifier": "security@huntr.dev", "published": "2023-07-14T13:15:09.437", "lastModified": "2023-07-26T14:05:43.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": " SQL Injection in GitHub repository pimcore/pimcore prior to 10.5.24."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.24", "matchCriteriaId": "46438F2F-FAD6-4974-AB49-18753B52873B"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/a06ce0abdba19ae0eefc38b035e677f8f0c2bce9", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/46ca0934-5260-477b-9e86-7b16bb18d0a9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/a06ce0abdba19ae0eefc38b035e677f8f0c2bce9"}}