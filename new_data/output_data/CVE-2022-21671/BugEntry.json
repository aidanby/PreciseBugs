{"buggy_code": ["#### v7.3.0\n\nAdded an optional `pollingHost` field to `ConnectOptions`. This allows callers to override the polling host from gp-v2.herokuapp.com to something else when the polling fallback is used.\n\n#### v7.2.0\n\nReintroduced the change that allows the client to try to call `fetchTokenMetadata` only once when it tries to connect or during unintentional reconnects. The client will keep the metadata cached until the user calls `client.close` explicitly, if the `reuseTokenMetadata` connection option is passed.\n\n#### v7.1.1\n\nAdded Client.addDebugFunc that makes it possible to have more than one debug callback.\n\n#### v7.1.0\n\nReverted changes from v7.0.0 which caused issues in Replit. The client now always gets a new token when it reconnects and downgrades to polling if it didn't receive a valid api command.\n\n#### v7.0.0 [BREAKING]\n\nThe only breaking change is dropping support for `fetchToken` https://github.com/replit/crosis/pull/93/files\n\nClient downgrades to polling less aggressively. Previously it would downgrade after not receiving any valid api command. Now, it relies on the websocket opening as a heuristic for websockets not working.\n\nWhile the client is trying to connect or during unintentional reconnects, the client will call `fetchTokenMetadata` only once. The client will keep the metadata cached until the user calls `client.close` explicitly.\n\nFixed a bug with opening channels with the same name.\n\n#### v6.3.0\n\nAllows opening channel with the same name while if others are closing (synchronously).\n\n#### v6.2.0\n\nAdded Client.getConnectionMetadata() This change adds a way of obtaining the connection metadata for the WebSocket. This allows obtaining the connection's token, among other things.\n\nAllow passing a thunk (function) to the `service` property of `openChannel` this function expects a string returned for the service name. The function is passed the context.\n\nDefault url changed to the global cluster, `eval.repl.it` is no longer supported by the backend.\n\nFor tests and debug mode new environment variables are needed. See README\n\n#### v6.1.0\n\nAdded long polling support. If the websocket connection fails 3 times in a row we now fallback to using polling using Engine-io and a proxy that talks to the backend.\n\n#### v6.0.0 [BREAKING]\n\nThe client has been reworked to handle reconnection internally. The API is drastically different but the general concepts\nare the same. Please refer to updated docs for usage information.\n\n#### v5.0.0\n\nClient close event now emits [CloseResult](https://replit-crosis.masfrost.repl.co/modules/_src_client_.html#closeresult)\n\nChannel closing during `channel.request` no longer throws an error. It now returns an extended @replit/protocol::`Command` that includes a [`channelClosed`](https://replit-crosis.masfrost.repl.co/interfaces/_src_channel_.requestresult.html#channelclosed)\n\n#### v4.1.3\n\nAdded a specific error (Channel.ChannelCloseError) to assert on when checking channel closing.\n\n#### v4.1.0\n\nMake stack traces for `Channel.request` more usable.\n\n#### v4.0.1\n\nIncrement listener limit for the control channel (channel 0) when requesting a channel open.\n\n#### v4.0.0 [BREAKING-ish]\n\nThis is only a breaking change for debugging and stats collection (pings)\n\nSee https://github.com/replit/crosis/pull/15\n\n- Debug pings are not started automatically\n- You can now call `client.startPing` after you connect to maintain old behavior :)\n\n#### v3.0.2 [BREAKING]\n\nSee https://github.com/replit/crosis/pull/12\n\n- Reset the the handshake/connection [`timeout`](https://github.com/replit/crosis/blob/d6dedc5aab6722c557da6df03b71e4e367af305d/src/client.ts#L44) if we get a message on the socket instead of waiting for `{ containerState: READY }`\n- [internal] Refactor to simplify code and fit this in easily.\n", "import * as urllib from 'url';\nimport type { ConnectOptions, GovalMetadata } from '../types';\n\nconst BACKOFF_FACTOR = 1.7;\nconst MAX_BACKOFF = 15000;\n\n/**\n * Calculates the backoff for n retry\n */\nexport function getNextRetryDelay(retryNumber: number): number {\n  const randomMs = Math.floor(Math.random() * 500);\n  const backoff = BACKOFF_FACTOR ** retryNumber * 1000;\n\n  return Math.min(backoff, MAX_BACKOFF) + randomMs;\n}\n\nfunction isWebSocket(w: unknown): w is WebSocket {\n  if (typeof w !== 'object' && typeof w !== 'function') {\n    return false;\n  }\n\n  if (!w) {\n    return false;\n  }\n\n  return 'OPEN' in w && (w as WebSocket).OPEN === 1;\n}\n\n/**\n * Gets a websocket class from the global scope, or asserts if the supplied websocket follows the standard\n */\nexport function getWebSocketClass(\n  WebSocketClass: ConnectOptions<unknown>['WebSocketClass'],\n): typeof WebSocket {\n  if (WebSocketClass) {\n    if (!isWebSocket(WebSocketClass)) {\n      throw new Error('Passed in WebSocket does not look like a standard WebSocket');\n    }\n\n    return WebSocketClass;\n  }\n\n  if (typeof WebSocket !== 'undefined') {\n    if (!isWebSocket(WebSocket)) {\n      throw new Error('Global WebSocket does not look like a standard WebSocket');\n    }\n\n    return WebSocket;\n  }\n\n  throw new Error('Please pass in a WebSocket class or add it to global');\n}\n\n/**\n * Given connection metadata, creates a websocket connection string\n */\nexport function getConnectionStr(\n  connectionMetadata: GovalMetadata,\n  isPolling: boolean,\n  pollingHost?: string,\n): string {\n  const gurl = urllib.parse(connectionMetadata.gurl);\n  if (isPolling) {\n    const host = pollingHost ?? 'gp-v2.herokuapp.com';\n    gurl.hostname = host;\n    gurl.host = host;\n    gurl.pathname = `/wsv2/${connectionMetadata.token}/${encodeURIComponent(\n      connectionMetadata.gurl,\n    )}`;\n  } else {\n    gurl.pathname = `/wsv2/${connectionMetadata.token}`;\n  }\n\n  return urllib.format(gurl);\n}\n"], "fixing_code": ["#### v7.3.1\n\nChanged the default polling host to gp-v2.replit.com.\n\n#### v7.3.0\n\nAdded an optional `pollingHost` field to `ConnectOptions`. This allows callers to override the polling host from gp-v2.herokuapp.com to something else when the polling fallback is used.\n\n#### v7.2.0\n\nReintroduced the change that allows the client to try to call `fetchTokenMetadata` only once when it tries to connect or during unintentional reconnects. The client will keep the metadata cached until the user calls `client.close` explicitly, if the `reuseTokenMetadata` connection option is passed.\n\n#### v7.1.1\n\nAdded Client.addDebugFunc that makes it possible to have more than one debug callback.\n\n#### v7.1.0\n\nReverted changes from v7.0.0 which caused issues in Replit. The client now always gets a new token when it reconnects and downgrades to polling if it didn't receive a valid api command.\n\n#### v7.0.0 [BREAKING]\n\nThe only breaking change is dropping support for `fetchToken` https://github.com/replit/crosis/pull/93/files\n\nClient downgrades to polling less aggressively. Previously it would downgrade after not receiving any valid api command. Now, it relies on the websocket opening as a heuristic for websockets not working.\n\nWhile the client is trying to connect or during unintentional reconnects, the client will call `fetchTokenMetadata` only once. The client will keep the metadata cached until the user calls `client.close` explicitly.\n\nFixed a bug with opening channels with the same name.\n\n#### v6.3.0\n\nAllows opening channel with the same name while if others are closing (synchronously).\n\n#### v6.2.0\n\nAdded Client.getConnectionMetadata() This change adds a way of obtaining the connection metadata for the WebSocket. This allows obtaining the connection's token, among other things.\n\nAllow passing a thunk (function) to the `service` property of `openChannel` this function expects a string returned for the service name. The function is passed the context.\n\nDefault url changed to the global cluster, `eval.repl.it` is no longer supported by the backend.\n\nFor tests and debug mode new environment variables are needed. See README\n\n#### v6.1.0\n\nAdded long polling support. If the websocket connection fails 3 times in a row we now fallback to using polling using Engine-io and a proxy that talks to the backend.\n\n#### v6.0.0 [BREAKING]\n\nThe client has been reworked to handle reconnection internally. The API is drastically different but the general concepts\nare the same. Please refer to updated docs for usage information.\n\n#### v5.0.0\n\nClient close event now emits [CloseResult](https://replit-crosis.masfrost.repl.co/modules/_src_client_.html#closeresult)\n\nChannel closing during `channel.request` no longer throws an error. It now returns an extended @replit/protocol::`Command` that includes a [`channelClosed`](https://replit-crosis.masfrost.repl.co/interfaces/_src_channel_.requestresult.html#channelclosed)\n\n#### v4.1.3\n\nAdded a specific error (Channel.ChannelCloseError) to assert on when checking channel closing.\n\n#### v4.1.0\n\nMake stack traces for `Channel.request` more usable.\n\n#### v4.0.1\n\nIncrement listener limit for the control channel (channel 0) when requesting a channel open.\n\n#### v4.0.0 [BREAKING-ish]\n\nThis is only a breaking change for debugging and stats collection (pings)\n\nSee https://github.com/replit/crosis/pull/15\n\n- Debug pings are not started automatically\n- You can now call `client.startPing` after you connect to maintain old behavior :)\n\n#### v3.0.2 [BREAKING]\n\nSee https://github.com/replit/crosis/pull/12\n\n- Reset the the handshake/connection [`timeout`](https://github.com/replit/crosis/blob/d6dedc5aab6722c557da6df03b71e4e367af305d/src/client.ts#L44) if we get a message on the socket instead of waiting for `{ containerState: READY }`\n- [internal] Refactor to simplify code and fit this in easily.\n", "import * as urllib from 'url';\nimport type { ConnectOptions, GovalMetadata } from '../types';\n\nconst BACKOFF_FACTOR = 1.7;\nconst MAX_BACKOFF = 15000;\n\n/**\n * Calculates the backoff for n retry\n */\nexport function getNextRetryDelay(retryNumber: number): number {\n  const randomMs = Math.floor(Math.random() * 500);\n  const backoff = BACKOFF_FACTOR ** retryNumber * 1000;\n\n  return Math.min(backoff, MAX_BACKOFF) + randomMs;\n}\n\nfunction isWebSocket(w: unknown): w is WebSocket {\n  if (typeof w !== 'object' && typeof w !== 'function') {\n    return false;\n  }\n\n  if (!w) {\n    return false;\n  }\n\n  return 'OPEN' in w && (w as WebSocket).OPEN === 1;\n}\n\n/**\n * Gets a websocket class from the global scope, or asserts if the supplied websocket follows the standard\n */\nexport function getWebSocketClass(\n  WebSocketClass: ConnectOptions<unknown>['WebSocketClass'],\n): typeof WebSocket {\n  if (WebSocketClass) {\n    if (!isWebSocket(WebSocketClass)) {\n      throw new Error('Passed in WebSocket does not look like a standard WebSocket');\n    }\n\n    return WebSocketClass;\n  }\n\n  if (typeof WebSocket !== 'undefined') {\n    if (!isWebSocket(WebSocket)) {\n      throw new Error('Global WebSocket does not look like a standard WebSocket');\n    }\n\n    return WebSocket;\n  }\n\n  throw new Error('Please pass in a WebSocket class or add it to global');\n}\n\n/**\n * Given connection metadata, creates a websocket connection string\n */\nexport function getConnectionStr(\n  connectionMetadata: GovalMetadata,\n  isPolling: boolean,\n  pollingHost?: string,\n): string {\n  const gurl = urllib.parse(connectionMetadata.gurl);\n  if (isPolling) {\n    const host = pollingHost ?? 'gp-v2.replit.com';\n    gurl.hostname = host;\n    gurl.host = host;\n    gurl.pathname = `/wsv2/${connectionMetadata.token}/${encodeURIComponent(\n      connectionMetadata.gurl,\n    )}`;\n  } else {\n    gurl.pathname = `/wsv2/${connectionMetadata.token}`;\n  }\n\n  return urllib.format(gurl);\n}\n"], "filenames": ["CHANGELOG.md", "src/util/helpers.ts"], "buggy_code_start_loc": [0, 64], "buggy_code_end_loc": [0, 65], "fixing_code_start_loc": [1, 64], "fixing_code_end_loc": [5, 65], "type": "CWE-200", "message": "@replit/crosis is a JavaScript client that speaks Replit's container protocol. A vulnerability that involves exposure of sensitive information exists in versions prior to 7.3.1. When using this library as a way to programmatically communicate with Replit in a standalone fashion, if there are multiple failed attempts to contact Replit through a WebSocket, the library will attempt to communicate using a fallback poll-based proxy. The URL of the proxy has changed, so any communication done to the previous URL could potentially reach a server that is outside of Replit's control and the token used to connect to the Repl could be obtained by an attacker, leading to full compromise of that Repl (not of the account). This was patched in version 7.3.1 by updating the address of the fallback WebSocket polling proxy to the new one. As a workaround, a user may specify the new address for the polling host (`gp-v2.replit.com`) in the `ConnectArgs`. More information about this workaround is available in the GitHub Security Advisory.", "other": {"cve": {"id": "CVE-2022-21671", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-11T15:15:08.640", "lastModified": "2022-01-24T20:15:33.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "@replit/crosis is a JavaScript client that speaks Replit's container protocol. A vulnerability that involves exposure of sensitive information exists in versions prior to 7.3.1. When using this library as a way to programmatically communicate with Replit in a standalone fashion, if there are multiple failed attempts to contact Replit through a WebSocket, the library will attempt to communicate using a fallback poll-based proxy. The URL of the proxy has changed, so any communication done to the previous URL could potentially reach a server that is outside of Replit's control and the token used to connect to the Repl could be obtained by an attacker, leading to full compromise of that Repl (not of the account). This was patched in version 7.3.1 by updating the address of the fallback WebSocket polling proxy to the new one. As a workaround, a user may specify the new address for the polling host (`gp-v2.replit.com`) in the `ConnectArgs`. More information about this workaround is available in the GitHub Security Advisory."}, {"lang": "es", "value": "replit/crosis es un cliente JavaScript que habla el protocolo de contenedores de Replit. En versiones anteriores a la 7.3.1, se presenta una vulnerabilidad que implica la exposici\u00f3n de informaci\u00f3n confidencial. Cuando es usada esta biblioteca como una forma de comunicarse program\u00e1ticamente con Replit de forma independiente, si son presentados varios intentos fallidos de contactar con Replit mediante un WebSocket, la biblioteca intentar\u00e1 comunicarse usando un proxy basado en sondeo. La URL del proxy ha cambiado, por lo que cualquier comunicaci\u00f3n realizada a la URL anterior podr\u00eda potencialmente llegar a un servidor que est\u00e1 fuera del control de Replit y el token usado para conectarse al Repl podr\u00eda ser obtenido por un atacante, conllevando a un compromiso total de ese Repl (no de la cuenta). Esto fue parcheado en la versi\u00f3n 7.3.1 actualizando la direcci\u00f3n del proxy de sondeo WebSocket fallback a la nueva. Como soluci\u00f3n, el usuario puede especificar la nueva direcci\u00f3n del host de sondeo (\"gp-v2.replit.com\") en los \"ConnectArgs\". Se presenta m\u00e1s informaci\u00f3n sobre esta medida de mitigaci\u00f3n en el aviso de seguridad de GitHub"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:replit:crosis:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.3.1", "matchCriteriaId": "4AA2E7E2-9774-4EE0-8FA8-9A17E3A3D94D"}]}]}], "references": [{"url": "https://github.com/replit/crosis/commit/e44b6a8f5fa28cb2872e3c19bb8a205bb5bfc281", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/replit/crosis/security/advisories/GHSA-7w54-gp8x-f33m", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/replit/crosis/commit/e44b6a8f5fa28cb2872e3c19bb8a205bb5bfc281"}}