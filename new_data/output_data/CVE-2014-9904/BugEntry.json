{"buggy_code": ["/*\n *  compress_core.c - compress offload core\n *\n *  Copyright (C) 2011 Intel Corporation\n *  Authors:\tVinod Koul <vinod.koul@linux.intel.com>\n *\t\tPierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>\n *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; version 2 of the License.\n *\n *  This program is distributed in the hope that it will be useful, but\n *  WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.\n *\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *\n */\n#define FORMAT(fmt) \"%s: %d: \" fmt, __func__, __LINE__\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" FORMAT(fmt)\n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/math64.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/compress_params.h>\n#include <sound/compress_offload.h>\n#include <sound/compress_driver.h>\n\n/* TODO:\n * - add substream support for multiple devices in case of\n *\tSND_DYNAMIC_MINORS is not used\n * - Multiple node representation\n *\tdriver should be able to register multiple nodes\n */\n\nstatic DEFINE_MUTEX(device_mutex);\n\nstruct snd_compr_file {\n\tunsigned long caps;\n\tstruct snd_compr_stream stream;\n};\n\n/*\n * a note on stream states used:\n * we use follwing states in the compressed core\n * SNDRV_PCM_STATE_OPEN: When stream has been opened.\n * SNDRV_PCM_STATE_SETUP: When stream has been initialized. This is done by\n *\tcalling SNDRV_COMPRESS_SET_PARAMS. running streams will come to this\n *\tstate at stop by calling SNDRV_COMPRESS_STOP, or at end of drain.\n * SNDRV_PCM_STATE_RUNNING: When stream has been started and is\n *\tdecoding/encoding and rendering/capturing data.\n * SNDRV_PCM_STATE_DRAINING: When stream is draining current data. This is done\n *\tby calling SNDRV_COMPRESS_DRAIN.\n * SNDRV_PCM_STATE_PAUSED: When stream is paused. This is done by calling\n *\tSNDRV_COMPRESS_PAUSE. It can be stopped or resumed by calling\n *\tSNDRV_COMPRESS_STOP or SNDRV_COMPRESS_RESUME respectively.\n */\nstatic int snd_compr_open(struct inode *inode, struct file *f)\n{\n\tstruct snd_compr *compr;\n\tstruct snd_compr_file *data;\n\tstruct snd_compr_runtime *runtime;\n\tenum snd_compr_direction dirn;\n\tint maj = imajor(inode);\n\tint ret;\n\n\tif ((f->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tdirn = SND_COMPRESS_PLAYBACK;\n\telse if ((f->f_flags & O_ACCMODE) == O_RDONLY)\n\t\tdirn = SND_COMPRESS_CAPTURE;\n\telse\n\t\treturn -EINVAL;\n\n\tif (maj == snd_major)\n\t\tcompr = snd_lookup_minor_data(iminor(inode),\n\t\t\t\t\tSNDRV_DEVICE_TYPE_COMPRESS);\n\telse\n\t\treturn -EBADFD;\n\n\tif (compr == NULL) {\n\t\tpr_err(\"no device data!!!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dirn != compr->direction) {\n\t\tpr_err(\"this device doesn't support this direction\\n\");\n\t\tsnd_card_unref(compr->card);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tsnd_card_unref(compr->card);\n\t\treturn -ENOMEM;\n\t}\n\tdata->stream.ops = compr->ops;\n\tdata->stream.direction = dirn;\n\tdata->stream.private_data = compr->private_data;\n\tdata->stream.device = compr;\n\truntime = kzalloc(sizeof(*runtime), GFP_KERNEL);\n\tif (!runtime) {\n\t\tkfree(data);\n\t\tsnd_card_unref(compr->card);\n\t\treturn -ENOMEM;\n\t}\n\truntime->state = SNDRV_PCM_STATE_OPEN;\n\tinit_waitqueue_head(&runtime->sleep);\n\tdata->stream.runtime = runtime;\n\tf->private_data = (void *)data;\n\tmutex_lock(&compr->lock);\n\tret = compr->ops->open(&data->stream);\n\tmutex_unlock(&compr->lock);\n\tif (ret) {\n\t\tkfree(runtime);\n\t\tkfree(data);\n\t}\n\tsnd_card_unref(compr->card);\n\treturn ret;\n}\n\nstatic int snd_compr_free(struct inode *inode, struct file *f)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_runtime *runtime = data->stream.runtime;\n\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_DRAINING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tdata->stream.ops->trigger(&data->stream, SNDRV_PCM_TRIGGER_STOP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata->stream.ops->free(&data->stream);\n\tkfree(data->stream.runtime->buffer);\n\tkfree(data->stream.runtime);\n\tkfree(data);\n\treturn 0;\n}\n\nstatic int snd_compr_update_tstamp(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_tstamp *tstamp)\n{\n\tif (!stream->ops->pointer)\n\t\treturn -ENOTSUPP;\n\tstream->ops->pointer(stream, tstamp);\n\tpr_debug(\"dsp consumed till %d total %d bytes\\n\",\n\t\ttstamp->byte_offset, tstamp->copied_total);\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\tstream->runtime->total_bytes_transferred = tstamp->copied_total;\n\telse\n\t\tstream->runtime->total_bytes_available = tstamp->copied_total;\n\treturn 0;\n}\n\nstatic size_t snd_compr_calc_avail(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_avail *avail)\n{\n\tmemset(avail, 0, sizeof(*avail));\n\tsnd_compr_update_tstamp(stream, &avail->tstamp);\n\t/* Still need to return avail even if tstamp can't be filled in */\n\n\tif (stream->runtime->total_bytes_available == 0 &&\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP &&\n\t\t\tstream->direction == SND_COMPRESS_PLAYBACK) {\n\t\tpr_debug(\"detected init and someone forgot to do a write\\n\");\n\t\treturn stream->runtime->buffer_size;\n\t}\n\tpr_debug(\"app wrote %lld, DSP consumed %lld\\n\",\n\t\t\tstream->runtime->total_bytes_available,\n\t\t\tstream->runtime->total_bytes_transferred);\n\tif (stream->runtime->total_bytes_available ==\n\t\t\t\tstream->runtime->total_bytes_transferred) {\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK) {\n\t\t\tpr_debug(\"both pointers are same, returning full avail\\n\");\n\t\t\treturn stream->runtime->buffer_size;\n\t\t} else {\n\t\t\tpr_debug(\"both pointers are same, returning no avail\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tavail->avail = stream->runtime->total_bytes_available -\n\t\t\tstream->runtime->total_bytes_transferred;\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\tavail->avail = stream->runtime->buffer_size - avail->avail;\n\n\tpr_debug(\"ret avail as %lld\\n\", avail->avail);\n\treturn avail->avail;\n}\n\nstatic inline size_t snd_compr_get_avail(struct snd_compr_stream *stream)\n{\n\tstruct snd_compr_avail avail;\n\n\treturn snd_compr_calc_avail(stream, &avail);\n}\n\nstatic int\nsnd_compr_ioctl_avail(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_avail ioctl_avail;\n\tsize_t avail;\n\n\tavail = snd_compr_calc_avail(stream, &ioctl_avail);\n\tioctl_avail.avail = avail;\n\n\tif (copy_to_user((__u64 __user *)arg,\n\t\t\t\t&ioctl_avail, sizeof(ioctl_avail)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_compr_write_data(struct snd_compr_stream *stream,\n\t       const char __user *buf, size_t count)\n{\n\tvoid *dstn;\n\tsize_t copy;\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\t/* 64-bit Modulus */\n\tu64 app_pointer = div64_u64(runtime->total_bytes_available,\n\t\t\t\t    runtime->buffer_size);\n\tapp_pointer = runtime->total_bytes_available -\n\t\t      (app_pointer * runtime->buffer_size);\n\n\tdstn = runtime->buffer + app_pointer;\n\tpr_debug(\"copying %ld at %lld\\n\",\n\t\t\t(unsigned long)count, app_pointer);\n\tif (count < runtime->buffer_size - app_pointer) {\n\t\tif (copy_from_user(dstn, buf, count))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tcopy = runtime->buffer_size - app_pointer;\n\t\tif (copy_from_user(dstn, buf, copy))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(runtime->buffer, buf + copy, count - copy))\n\t\t\treturn -EFAULT;\n\t}\n\t/* if DSP cares, let it know data has been written */\n\tif (stream->ops->ack)\n\t\tstream->ops->ack(stream, count);\n\treturn count;\n}\n\nstatic ssize_t snd_compr_write(struct file *f, const char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\tmutex_lock(&stream->device->lock);\n\t/* write is allowed when stream is running or has been steup */\n\tif (stream->runtime->state != SNDRV_PCM_STATE_SETUP &&\n\t\t\tstream->runtime->state != SNDRV_PCM_STATE_RUNNING) {\n\t\tmutex_unlock(&stream->device->lock);\n\t\treturn -EBADFD;\n\t}\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail returned %ld\\n\", (unsigned long)avail);\n\t/* calculate how much we can write to buffer */\n\tif (avail > count)\n\t\tavail = count;\n\n\tif (stream->ops->copy) {\n\t\tchar __user* cbuf = (char __user*)buf;\n\t\tretval = stream->ops->copy(stream, cbuf, avail);\n\t} else {\n\t\tretval = snd_compr_write_data(stream, buf, avail);\n\t}\n\tif (retval > 0)\n\t\tstream->runtime->total_bytes_available += retval;\n\n\t/* while initiating the stream, write should be called before START\n\t * call, so in setup move state */\n\tif (stream->runtime->state == SNDRV_PCM_STATE_SETUP) {\n\t\tstream->runtime->state = SNDRV_PCM_STATE_PREPARED;\n\t\tpr_debug(\"stream prepared, Houston we are good to go\\n\");\n\t}\n\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\n\nstatic ssize_t snd_compr_read(struct file *f, char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\tmutex_lock(&stream->device->lock);\n\n\t/* read is allowed when stream is running, paused, draining and setup\n\t * (yes setup is state which we transition to after stop, so if user\n\t * wants to read data after stop we allow that)\n\t */\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_XRUN:\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\t\tretval = -EBADFD;\n\t\tgoto out;\n\t}\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail returned %ld\\n\", (unsigned long)avail);\n\t/* calculate how much we can read from buffer */\n\tif (avail > count)\n\t\tavail = count;\n\n\tif (stream->ops->copy) {\n\t\tretval = stream->ops->copy(stream, buf, avail);\n\t} else {\n\t\tretval = -ENXIO;\n\t\tgoto out;\n\t}\n\tif (retval > 0)\n\t\tstream->runtime->total_bytes_transferred += retval;\n\nout:\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic int snd_compr_mmap(struct file *f, struct vm_area_struct *vma)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int snd_compr_get_poll(struct snd_compr_stream *stream)\n{\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\treturn POLLOUT | POLLWRNORM;\n\telse\n\t\treturn POLLIN | POLLRDNORM;\n}\n\nstatic unsigned int snd_compr_poll(struct file *f, poll_table *wait)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval = 0;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\tstream = &data->stream;\n\tif (snd_BUG_ON(!stream))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&stream->device->lock);\n\tif (stream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tretval = -EBADFD;\n\t\tgoto out;\n\t}\n\tpoll_wait(f, &stream->runtime->sleep, wait);\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail is %ld\\n\", (unsigned long)avail);\n\t/* check if we have at least one fragment to fill */\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_DRAINING:\n\t\t/* stream has been woken up after drain is complete\n\t\t * draining done so set stream state to stopped\n\t\t */\n\t\tretval = snd_compr_get_poll(stream);\n\t\tstream->runtime->state = SNDRV_PCM_STATE_SETUP;\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tif (avail >= stream->runtime->fragment_size)\n\t\t\tretval = snd_compr_get_poll(stream);\n\t\tbreak;\n\tdefault:\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\t\tretval = POLLOUT | POLLWRNORM | POLLERR;\n\t\telse\n\t\t\tretval = POLLIN | POLLRDNORM | POLLERR;\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_caps(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tint retval;\n\tstruct snd_compr_caps caps;\n\n\tif (!stream->ops->get_caps)\n\t\treturn -ENXIO;\n\n\tmemset(&caps, 0, sizeof(caps));\n\tretval = stream->ops->get_caps(stream, &caps);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((void __user *)arg, &caps, sizeof(caps)))\n\t\tretval = -EFAULT;\nout:\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_codec_caps(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tint retval;\n\tstruct snd_compr_codec_caps *caps;\n\n\tif (!stream->ops->get_codec_caps)\n\t\treturn -ENXIO;\n\n\tcaps = kzalloc(sizeof(*caps), GFP_KERNEL);\n\tif (!caps)\n\t\treturn -ENOMEM;\n\n\tretval = stream->ops->get_codec_caps(stream, caps);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((void __user *)arg, caps, sizeof(*caps)))\n\t\tretval = -EFAULT;\n\nout:\n\tkfree(caps);\n\treturn retval;\n}\n\n/* revisit this with snd_pcm_preallocate_xxx */\nstatic int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t\t/* if copy is defined the driver will be required to copy\n\t\t * the data from core\n\t\t */\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}\n\nstatic int snd_compress_check_input(struct snd_compr_params *params)\n{\n\t/* first let's check the buffer parameter's */\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\n\t/* now codec parameters */\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nsnd_compr_set_params(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_params *params;\n\tint retval;\n\n\tif (stream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\t/*\n\t\t * we should allow parameter change only when stream has been\n\t\t * opened not in other cases\n\t\t */\n\t\tparams = kmalloc(sizeof(*params), GFP_KERNEL);\n\t\tif (!params)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(params, (void __user *)arg, sizeof(*params))) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tretval = snd_compress_check_input(params);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tretval = snd_compr_allocate_buffer(stream, params);\n\t\tif (retval) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tretval = stream->ops->set_params(stream, params);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tstream->metadata_set = false;\n\t\tstream->next_track = false;\n\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\t\tstream->runtime->state = SNDRV_PCM_STATE_SETUP;\n\t\telse\n\t\t\tstream->runtime->state = SNDRV_PCM_STATE_PREPARED;\n\t} else {\n\t\treturn -EPERM;\n\t}\nout:\n\tkfree(params);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_params(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_codec *params;\n\tint retval;\n\n\tif (!stream->ops->get_params)\n\t\treturn -EBADFD;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\tretval = stream->ops->get_params(stream, params);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((char __user *)arg, params, sizeof(*params)))\n\t\tretval = -EFAULT;\n\nout:\n\tkfree(params);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_metadata(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_metadata metadata;\n\tint retval;\n\n\tif (!stream->ops->get_metadata)\n\t\treturn -ENXIO;\n\n\tif (copy_from_user(&metadata, (void __user *)arg, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\tretval = stream->ops->get_metadata(stream, &metadata);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tif (copy_to_user((void __user *)arg, &metadata, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int\nsnd_compr_set_metadata(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_metadata metadata;\n\tint retval;\n\n\tif (!stream->ops->set_metadata)\n\t\treturn -ENXIO;\n\t/*\n\t* we should allow parameter change only when stream has been\n\t* opened not in other cases\n\t*/\n\tif (copy_from_user(&metadata, (void __user *)arg, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\tretval = stream->ops->set_metadata(stream, &metadata);\n\tstream->metadata_set = true;\n\n\treturn retval;\n}\n\nstatic inline int\nsnd_compr_tstamp(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_tstamp tstamp = {0};\n\tint ret;\n\n\tret = snd_compr_update_tstamp(stream, &tstamp);\n\tif (ret == 0)\n\t\tret = copy_to_user((struct snd_compr_tstamp __user *)arg,\n\t\t\t&tstamp, sizeof(tstamp)) ? -EFAULT : 0;\n\treturn ret;\n}\n\nstatic int snd_compr_pause(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);\n\tif (!retval)\n\t\tstream->runtime->state = SNDRV_PCM_STATE_PAUSED;\n\treturn retval;\n}\n\nstatic int snd_compr_resume(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state != SNDRV_PCM_STATE_PAUSED)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);\n\tif (!retval)\n\t\tstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\n\treturn retval;\n}\n\nstatic int snd_compr_start(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_START);\n\tif (!retval)\n\t\tstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\n\treturn retval;\n}\n\nstatic int snd_compr_stop(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);\n\tif (!retval) {\n\t\tsnd_compr_drain_notify(stream);\n\t\tstream->runtime->total_bytes_available = 0;\n\t\tstream->runtime->total_bytes_transferred = 0;\n\t}\n\treturn retval;\n}\n\nstatic int snd_compress_wait_for_drain(struct snd_compr_stream *stream)\n{\n\tint ret;\n\n\t/*\n\t * We are called with lock held. So drop the lock while we wait for\n\t * drain complete notfication from the driver\n\t *\n\t * It is expected that driver will notify the drain completion and then\n\t * stream will be moved to SETUP state, even if draining resulted in an\n\t * error. We can trigger next track after this.\n\t */\n\tstream->runtime->state = SNDRV_PCM_STATE_DRAINING;\n\tmutex_unlock(&stream->device->lock);\n\n\t/* we wait for drain to complete here, drain can return when\n\t * interruption occurred, wait returned error or success.\n\t * For the first two cases we don't do anything different here and\n\t * return after waking up\n\t */\n\n\tret = wait_event_interruptible(stream->runtime->sleep,\n\t\t\t(stream->runtime->state != SNDRV_PCM_STATE_DRAINING));\n\tif (ret == -ERESTARTSYS)\n\t\tpr_debug(\"wait aborted by a signal\");\n\telse if (ret)\n\t\tpr_debug(\"wait for drain failed with %d\\n\", ret);\n\n\n\twake_up(&stream->runtime->sleep);\n\tmutex_lock(&stream->device->lock);\n\n\treturn ret;\n}\n\nstatic int snd_compr_drain(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP)\n\t\treturn -EPERM;\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);\n\tif (retval) {\n\t\tpr_debug(\"SND_COMPR_TRIGGER_DRAIN failed %d\\n\", retval);\n\t\twake_up(&stream->runtime->sleep);\n\t\treturn retval;\n\t}\n\n\treturn snd_compress_wait_for_drain(stream);\n}\n\nstatic int snd_compr_next_track(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\t/* only a running stream can transition to next track */\n\tif (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\t/* you can signal next track isf this is intended to be a gapless stream\n\t * and current track metadata is set\n\t */\n\tif (stream->metadata_set == false)\n\t\treturn -EPERM;\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_NEXT_TRACK);\n\tif (retval != 0)\n\t\treturn retval;\n\tstream->metadata_set = false;\n\tstream->next_track = true;\n\treturn 0;\n}\n\nstatic int snd_compr_partial_drain(struct snd_compr_stream *stream)\n{\n\tint retval;\n\tif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP)\n\t\treturn -EPERM;\n\t/* stream can be drained only when next track has been signalled */\n\tif (stream->next_track == false)\n\t\treturn -EPERM;\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);\n\tif (retval) {\n\t\tpr_debug(\"Partial drain returned failure\\n\");\n\t\twake_up(&stream->runtime->sleep);\n\t\treturn retval;\n\t}\n\n\tstream->next_track = false;\n\treturn snd_compress_wait_for_drain(stream);\n}\n\nstatic long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tint retval = -ENOTTY;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\tstream = &data->stream;\n\tif (snd_BUG_ON(!stream))\n\t\treturn -EFAULT;\n\tmutex_lock(&stream->device->lock);\n\tswitch (_IOC_NR(cmd)) {\n\tcase _IOC_NR(SNDRV_COMPRESS_IOCTL_VERSION):\n\t\tretval = put_user(SNDRV_COMPRESS_VERSION,\n\t\t\t\t(int __user *)arg) ? -EFAULT : 0;\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_CAPS):\n\t\tretval = snd_compr_get_caps(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_CODEC_CAPS):\n\t\tretval = snd_compr_get_codec_caps(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_SET_PARAMS):\n\t\tretval = snd_compr_set_params(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_PARAMS):\n\t\tretval = snd_compr_get_params(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_SET_METADATA):\n\t\tretval = snd_compr_set_metadata(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_METADATA):\n\t\tretval = snd_compr_get_metadata(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_TSTAMP):\n\t\tretval = snd_compr_tstamp(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_AVAIL):\n\t\tretval = snd_compr_ioctl_avail(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_PAUSE):\n\t\tretval = snd_compr_pause(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_RESUME):\n\t\tretval = snd_compr_resume(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_START):\n\t\tretval = snd_compr_start(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_STOP):\n\t\tretval = snd_compr_stop(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_DRAIN):\n\t\tretval = snd_compr_drain(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_PARTIAL_DRAIN):\n\t\tretval = snd_compr_partial_drain(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_NEXT_TRACK):\n\t\tretval = snd_compr_next_track(stream);\n\t\tbreak;\n\n\t}\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic const struct file_operations snd_compr_file_ops = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.open =\t\tsnd_compr_open,\n\t\t.release =\tsnd_compr_free,\n\t\t.write =\tsnd_compr_write,\n\t\t.read =\t\tsnd_compr_read,\n\t\t.unlocked_ioctl = snd_compr_ioctl,\n\t\t.mmap =\t\tsnd_compr_mmap,\n\t\t.poll =\t\tsnd_compr_poll,\n};\n\nstatic int snd_compress_dev_register(struct snd_device *device)\n{\n\tint ret = -EINVAL;\n\tchar str[16];\n\tstruct snd_compr *compr;\n\n\tif (snd_BUG_ON(!device || !device->device_data))\n\t\treturn -EBADFD;\n\tcompr = device->device_data;\n\n\tsprintf(str, \"comprC%iD%i\", compr->card->number, compr->device);\n\tpr_debug(\"reg %s for device %s, direction %d\\n\", str, compr->name,\n\t\t\tcompr->direction);\n\t/* register compressed device */\n\tret = snd_register_device(SNDRV_DEVICE_TYPE_COMPRESS, compr->card,\n\t\t\tcompr->device, &snd_compr_file_ops, compr, str);\n\tif (ret < 0) {\n\t\tpr_err(\"snd_register_device failed\\n %d\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n\n}\n\nstatic int snd_compress_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_compr *compr;\n\n\tcompr = device->device_data;\n\tsnd_unregister_device(SNDRV_DEVICE_TYPE_COMPRESS, compr->card,\n\t\tcompr->device);\n\treturn 0;\n}\n\n/*\n * snd_compress_new: create new compress device\n * @card: sound card pointer\n * @device: device number\n * @dirn: device direction, should be of type enum snd_compr_direction\n * @compr: compress device pointer\n */\nint snd_compress_new(struct snd_card *card, int device,\n\t\t\tint dirn, struct snd_compr *compr)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = NULL,\n\t\t.dev_register = snd_compress_dev_register,\n\t\t.dev_disconnect = snd_compress_dev_disconnect,\n\t};\n\n\tcompr->card = card;\n\tcompr->device = device;\n\tcompr->direction = dirn;\n\treturn snd_device_new(card, SNDRV_DEV_COMPRESS, compr, &ops);\n}\nEXPORT_SYMBOL_GPL(snd_compress_new);\n\nstatic int snd_compress_add_device(struct snd_compr *device)\n{\n\tint ret;\n\n\tif (!device->card)\n\t\treturn -EINVAL;\n\n\t/* register the card */\n\tret = snd_card_register(device->card);\n\tif (ret)\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tpr_err(\"failed with %d\\n\", ret);\n\treturn ret;\n\n}\n\nstatic int snd_compress_remove_device(struct snd_compr *device)\n{\n\treturn snd_card_free(device->card);\n}\n\n/**\n * snd_compress_register - register compressed device\n *\n * @device: compressed device to register\n */\nint snd_compress_register(struct snd_compr *device)\n{\n\tint retval;\n\n\tif (device->name == NULL || device->dev == NULL || device->ops == NULL)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Registering compressed device %s\\n\", device->name);\n\tif (snd_BUG_ON(!device->ops->open))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!device->ops->free))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!device->ops->set_params))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!device->ops->trigger))\n\t\treturn -EINVAL;\n\n\tmutex_init(&device->lock);\n\n\t/* register a compressed card */\n\tmutex_lock(&device_mutex);\n\tretval = snd_compress_add_device(device);\n\tmutex_unlock(&device_mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(snd_compress_register);\n\nint snd_compress_deregister(struct snd_compr *device)\n{\n\tpr_debug(\"Removing compressed device %s\\n\", device->name);\n\tmutex_lock(&device_mutex);\n\tsnd_compress_remove_device(device);\n\tmutex_unlock(&device_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_compress_deregister);\n\nstatic int __init snd_compress_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit snd_compress_exit(void)\n{\n}\n\nmodule_init(snd_compress_init);\nmodule_exit(snd_compress_exit);\n\nMODULE_DESCRIPTION(\"ALSA Compressed offload framework\");\nMODULE_AUTHOR(\"Vinod Koul <vinod.koul@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["/*\n *  compress_core.c - compress offload core\n *\n *  Copyright (C) 2011 Intel Corporation\n *  Authors:\tVinod Koul <vinod.koul@linux.intel.com>\n *\t\tPierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>\n *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; version 2 of the License.\n *\n *  This program is distributed in the hope that it will be useful, but\n *  WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.\n *\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *\n */\n#define FORMAT(fmt) \"%s: %d: \" fmt, __func__, __LINE__\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" FORMAT(fmt)\n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/math64.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/compress_params.h>\n#include <sound/compress_offload.h>\n#include <sound/compress_driver.h>\n\n/* TODO:\n * - add substream support for multiple devices in case of\n *\tSND_DYNAMIC_MINORS is not used\n * - Multiple node representation\n *\tdriver should be able to register multiple nodes\n */\n\nstatic DEFINE_MUTEX(device_mutex);\n\nstruct snd_compr_file {\n\tunsigned long caps;\n\tstruct snd_compr_stream stream;\n};\n\n/*\n * a note on stream states used:\n * we use follwing states in the compressed core\n * SNDRV_PCM_STATE_OPEN: When stream has been opened.\n * SNDRV_PCM_STATE_SETUP: When stream has been initialized. This is done by\n *\tcalling SNDRV_COMPRESS_SET_PARAMS. running streams will come to this\n *\tstate at stop by calling SNDRV_COMPRESS_STOP, or at end of drain.\n * SNDRV_PCM_STATE_RUNNING: When stream has been started and is\n *\tdecoding/encoding and rendering/capturing data.\n * SNDRV_PCM_STATE_DRAINING: When stream is draining current data. This is done\n *\tby calling SNDRV_COMPRESS_DRAIN.\n * SNDRV_PCM_STATE_PAUSED: When stream is paused. This is done by calling\n *\tSNDRV_COMPRESS_PAUSE. It can be stopped or resumed by calling\n *\tSNDRV_COMPRESS_STOP or SNDRV_COMPRESS_RESUME respectively.\n */\nstatic int snd_compr_open(struct inode *inode, struct file *f)\n{\n\tstruct snd_compr *compr;\n\tstruct snd_compr_file *data;\n\tstruct snd_compr_runtime *runtime;\n\tenum snd_compr_direction dirn;\n\tint maj = imajor(inode);\n\tint ret;\n\n\tif ((f->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tdirn = SND_COMPRESS_PLAYBACK;\n\telse if ((f->f_flags & O_ACCMODE) == O_RDONLY)\n\t\tdirn = SND_COMPRESS_CAPTURE;\n\telse\n\t\treturn -EINVAL;\n\n\tif (maj == snd_major)\n\t\tcompr = snd_lookup_minor_data(iminor(inode),\n\t\t\t\t\tSNDRV_DEVICE_TYPE_COMPRESS);\n\telse\n\t\treturn -EBADFD;\n\n\tif (compr == NULL) {\n\t\tpr_err(\"no device data!!!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dirn != compr->direction) {\n\t\tpr_err(\"this device doesn't support this direction\\n\");\n\t\tsnd_card_unref(compr->card);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tsnd_card_unref(compr->card);\n\t\treturn -ENOMEM;\n\t}\n\tdata->stream.ops = compr->ops;\n\tdata->stream.direction = dirn;\n\tdata->stream.private_data = compr->private_data;\n\tdata->stream.device = compr;\n\truntime = kzalloc(sizeof(*runtime), GFP_KERNEL);\n\tif (!runtime) {\n\t\tkfree(data);\n\t\tsnd_card_unref(compr->card);\n\t\treturn -ENOMEM;\n\t}\n\truntime->state = SNDRV_PCM_STATE_OPEN;\n\tinit_waitqueue_head(&runtime->sleep);\n\tdata->stream.runtime = runtime;\n\tf->private_data = (void *)data;\n\tmutex_lock(&compr->lock);\n\tret = compr->ops->open(&data->stream);\n\tmutex_unlock(&compr->lock);\n\tif (ret) {\n\t\tkfree(runtime);\n\t\tkfree(data);\n\t}\n\tsnd_card_unref(compr->card);\n\treturn ret;\n}\n\nstatic int snd_compr_free(struct inode *inode, struct file *f)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_runtime *runtime = data->stream.runtime;\n\n\tswitch (runtime->state) {\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_DRAINING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tdata->stream.ops->trigger(&data->stream, SNDRV_PCM_TRIGGER_STOP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata->stream.ops->free(&data->stream);\n\tkfree(data->stream.runtime->buffer);\n\tkfree(data->stream.runtime);\n\tkfree(data);\n\treturn 0;\n}\n\nstatic int snd_compr_update_tstamp(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_tstamp *tstamp)\n{\n\tif (!stream->ops->pointer)\n\t\treturn -ENOTSUPP;\n\tstream->ops->pointer(stream, tstamp);\n\tpr_debug(\"dsp consumed till %d total %d bytes\\n\",\n\t\ttstamp->byte_offset, tstamp->copied_total);\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\tstream->runtime->total_bytes_transferred = tstamp->copied_total;\n\telse\n\t\tstream->runtime->total_bytes_available = tstamp->copied_total;\n\treturn 0;\n}\n\nstatic size_t snd_compr_calc_avail(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_avail *avail)\n{\n\tmemset(avail, 0, sizeof(*avail));\n\tsnd_compr_update_tstamp(stream, &avail->tstamp);\n\t/* Still need to return avail even if tstamp can't be filled in */\n\n\tif (stream->runtime->total_bytes_available == 0 &&\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP &&\n\t\t\tstream->direction == SND_COMPRESS_PLAYBACK) {\n\t\tpr_debug(\"detected init and someone forgot to do a write\\n\");\n\t\treturn stream->runtime->buffer_size;\n\t}\n\tpr_debug(\"app wrote %lld, DSP consumed %lld\\n\",\n\t\t\tstream->runtime->total_bytes_available,\n\t\t\tstream->runtime->total_bytes_transferred);\n\tif (stream->runtime->total_bytes_available ==\n\t\t\t\tstream->runtime->total_bytes_transferred) {\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK) {\n\t\t\tpr_debug(\"both pointers are same, returning full avail\\n\");\n\t\t\treturn stream->runtime->buffer_size;\n\t\t} else {\n\t\t\tpr_debug(\"both pointers are same, returning no avail\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tavail->avail = stream->runtime->total_bytes_available -\n\t\t\tstream->runtime->total_bytes_transferred;\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\tavail->avail = stream->runtime->buffer_size - avail->avail;\n\n\tpr_debug(\"ret avail as %lld\\n\", avail->avail);\n\treturn avail->avail;\n}\n\nstatic inline size_t snd_compr_get_avail(struct snd_compr_stream *stream)\n{\n\tstruct snd_compr_avail avail;\n\n\treturn snd_compr_calc_avail(stream, &avail);\n}\n\nstatic int\nsnd_compr_ioctl_avail(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_avail ioctl_avail;\n\tsize_t avail;\n\n\tavail = snd_compr_calc_avail(stream, &ioctl_avail);\n\tioctl_avail.avail = avail;\n\n\tif (copy_to_user((__u64 __user *)arg,\n\t\t\t\t&ioctl_avail, sizeof(ioctl_avail)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_compr_write_data(struct snd_compr_stream *stream,\n\t       const char __user *buf, size_t count)\n{\n\tvoid *dstn;\n\tsize_t copy;\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\t/* 64-bit Modulus */\n\tu64 app_pointer = div64_u64(runtime->total_bytes_available,\n\t\t\t\t    runtime->buffer_size);\n\tapp_pointer = runtime->total_bytes_available -\n\t\t      (app_pointer * runtime->buffer_size);\n\n\tdstn = runtime->buffer + app_pointer;\n\tpr_debug(\"copying %ld at %lld\\n\",\n\t\t\t(unsigned long)count, app_pointer);\n\tif (count < runtime->buffer_size - app_pointer) {\n\t\tif (copy_from_user(dstn, buf, count))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tcopy = runtime->buffer_size - app_pointer;\n\t\tif (copy_from_user(dstn, buf, copy))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(runtime->buffer, buf + copy, count - copy))\n\t\t\treturn -EFAULT;\n\t}\n\t/* if DSP cares, let it know data has been written */\n\tif (stream->ops->ack)\n\t\tstream->ops->ack(stream, count);\n\treturn count;\n}\n\nstatic ssize_t snd_compr_write(struct file *f, const char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\tmutex_lock(&stream->device->lock);\n\t/* write is allowed when stream is running or has been steup */\n\tif (stream->runtime->state != SNDRV_PCM_STATE_SETUP &&\n\t\t\tstream->runtime->state != SNDRV_PCM_STATE_RUNNING) {\n\t\tmutex_unlock(&stream->device->lock);\n\t\treturn -EBADFD;\n\t}\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail returned %ld\\n\", (unsigned long)avail);\n\t/* calculate how much we can write to buffer */\n\tif (avail > count)\n\t\tavail = count;\n\n\tif (stream->ops->copy) {\n\t\tchar __user* cbuf = (char __user*)buf;\n\t\tretval = stream->ops->copy(stream, cbuf, avail);\n\t} else {\n\t\tretval = snd_compr_write_data(stream, buf, avail);\n\t}\n\tif (retval > 0)\n\t\tstream->runtime->total_bytes_available += retval;\n\n\t/* while initiating the stream, write should be called before START\n\t * call, so in setup move state */\n\tif (stream->runtime->state == SNDRV_PCM_STATE_SETUP) {\n\t\tstream->runtime->state = SNDRV_PCM_STATE_PREPARED;\n\t\tpr_debug(\"stream prepared, Houston we are good to go\\n\");\n\t}\n\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\n\nstatic ssize_t snd_compr_read(struct file *f, char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\tmutex_lock(&stream->device->lock);\n\n\t/* read is allowed when stream is running, paused, draining and setup\n\t * (yes setup is state which we transition to after stop, so if user\n\t * wants to read data after stop we allow that)\n\t */\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_OPEN:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_XRUN:\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\t\tretval = -EBADFD;\n\t\tgoto out;\n\t}\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail returned %ld\\n\", (unsigned long)avail);\n\t/* calculate how much we can read from buffer */\n\tif (avail > count)\n\t\tavail = count;\n\n\tif (stream->ops->copy) {\n\t\tretval = stream->ops->copy(stream, buf, avail);\n\t} else {\n\t\tretval = -ENXIO;\n\t\tgoto out;\n\t}\n\tif (retval > 0)\n\t\tstream->runtime->total_bytes_transferred += retval;\n\nout:\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic int snd_compr_mmap(struct file *f, struct vm_area_struct *vma)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int snd_compr_get_poll(struct snd_compr_stream *stream)\n{\n\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\treturn POLLOUT | POLLWRNORM;\n\telse\n\t\treturn POLLIN | POLLRDNORM;\n}\n\nstatic unsigned int snd_compr_poll(struct file *f, poll_table *wait)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval = 0;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\tstream = &data->stream;\n\tif (snd_BUG_ON(!stream))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&stream->device->lock);\n\tif (stream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\tretval = -EBADFD;\n\t\tgoto out;\n\t}\n\tpoll_wait(f, &stream->runtime->sleep, wait);\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail is %ld\\n\", (unsigned long)avail);\n\t/* check if we have at least one fragment to fill */\n\tswitch (stream->runtime->state) {\n\tcase SNDRV_PCM_STATE_DRAINING:\n\t\t/* stream has been woken up after drain is complete\n\t\t * draining done so set stream state to stopped\n\t\t */\n\t\tretval = snd_compr_get_poll(stream);\n\t\tstream->runtime->state = SNDRV_PCM_STATE_SETUP;\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tif (avail >= stream->runtime->fragment_size)\n\t\t\tretval = snd_compr_get_poll(stream);\n\t\tbreak;\n\tdefault:\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\t\tretval = POLLOUT | POLLWRNORM | POLLERR;\n\t\telse\n\t\t\tretval = POLLIN | POLLRDNORM | POLLERR;\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_caps(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tint retval;\n\tstruct snd_compr_caps caps;\n\n\tif (!stream->ops->get_caps)\n\t\treturn -ENXIO;\n\n\tmemset(&caps, 0, sizeof(caps));\n\tretval = stream->ops->get_caps(stream, &caps);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((void __user *)arg, &caps, sizeof(caps)))\n\t\tretval = -EFAULT;\nout:\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_codec_caps(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tint retval;\n\tstruct snd_compr_codec_caps *caps;\n\n\tif (!stream->ops->get_codec_caps)\n\t\treturn -ENXIO;\n\n\tcaps = kzalloc(sizeof(*caps), GFP_KERNEL);\n\tif (!caps)\n\t\treturn -ENOMEM;\n\n\tretval = stream->ops->get_codec_caps(stream, caps);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((void __user *)arg, caps, sizeof(*caps)))\n\t\tretval = -EFAULT;\n\nout:\n\tkfree(caps);\n\treturn retval;\n}\n\n/* revisit this with snd_pcm_preallocate_xxx */\nstatic int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t\t/* if copy is defined the driver will be required to copy\n\t\t * the data from core\n\t\t */\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}\n\nstatic int snd_compress_check_input(struct snd_compr_params *params)\n{\n\t/* first let's check the buffer parameter's */\n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > INT_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\n\t/* now codec parameters */\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nsnd_compr_set_params(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_params *params;\n\tint retval;\n\n\tif (stream->runtime->state == SNDRV_PCM_STATE_OPEN) {\n\t\t/*\n\t\t * we should allow parameter change only when stream has been\n\t\t * opened not in other cases\n\t\t */\n\t\tparams = kmalloc(sizeof(*params), GFP_KERNEL);\n\t\tif (!params)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(params, (void __user *)arg, sizeof(*params))) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tretval = snd_compress_check_input(params);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tretval = snd_compr_allocate_buffer(stream, params);\n\t\tif (retval) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tretval = stream->ops->set_params(stream, params);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tstream->metadata_set = false;\n\t\tstream->next_track = false;\n\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK)\n\t\t\tstream->runtime->state = SNDRV_PCM_STATE_SETUP;\n\t\telse\n\t\t\tstream->runtime->state = SNDRV_PCM_STATE_PREPARED;\n\t} else {\n\t\treturn -EPERM;\n\t}\nout:\n\tkfree(params);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_params(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_codec *params;\n\tint retval;\n\n\tif (!stream->ops->get_params)\n\t\treturn -EBADFD;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\tretval = stream->ops->get_params(stream, params);\n\tif (retval)\n\t\tgoto out;\n\tif (copy_to_user((char __user *)arg, params, sizeof(*params)))\n\t\tretval = -EFAULT;\n\nout:\n\tkfree(params);\n\treturn retval;\n}\n\nstatic int\nsnd_compr_get_metadata(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_metadata metadata;\n\tint retval;\n\n\tif (!stream->ops->get_metadata)\n\t\treturn -ENXIO;\n\n\tif (copy_from_user(&metadata, (void __user *)arg, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\tretval = stream->ops->get_metadata(stream, &metadata);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tif (copy_to_user((void __user *)arg, &metadata, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int\nsnd_compr_set_metadata(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_metadata metadata;\n\tint retval;\n\n\tif (!stream->ops->set_metadata)\n\t\treturn -ENXIO;\n\t/*\n\t* we should allow parameter change only when stream has been\n\t* opened not in other cases\n\t*/\n\tif (copy_from_user(&metadata, (void __user *)arg, sizeof(metadata)))\n\t\treturn -EFAULT;\n\n\tretval = stream->ops->set_metadata(stream, &metadata);\n\tstream->metadata_set = true;\n\n\treturn retval;\n}\n\nstatic inline int\nsnd_compr_tstamp(struct snd_compr_stream *stream, unsigned long arg)\n{\n\tstruct snd_compr_tstamp tstamp = {0};\n\tint ret;\n\n\tret = snd_compr_update_tstamp(stream, &tstamp);\n\tif (ret == 0)\n\t\tret = copy_to_user((struct snd_compr_tstamp __user *)arg,\n\t\t\t&tstamp, sizeof(tstamp)) ? -EFAULT : 0;\n\treturn ret;\n}\n\nstatic int snd_compr_pause(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);\n\tif (!retval)\n\t\tstream->runtime->state = SNDRV_PCM_STATE_PAUSED;\n\treturn retval;\n}\n\nstatic int snd_compr_resume(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state != SNDRV_PCM_STATE_PAUSED)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);\n\tif (!retval)\n\t\tstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\n\treturn retval;\n}\n\nstatic int snd_compr_start(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_START);\n\tif (!retval)\n\t\tstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\n\treturn retval;\n}\n\nstatic int snd_compr_stop(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP)\n\t\treturn -EPERM;\n\tretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);\n\tif (!retval) {\n\t\tsnd_compr_drain_notify(stream);\n\t\tstream->runtime->total_bytes_available = 0;\n\t\tstream->runtime->total_bytes_transferred = 0;\n\t}\n\treturn retval;\n}\n\nstatic int snd_compress_wait_for_drain(struct snd_compr_stream *stream)\n{\n\tint ret;\n\n\t/*\n\t * We are called with lock held. So drop the lock while we wait for\n\t * drain complete notfication from the driver\n\t *\n\t * It is expected that driver will notify the drain completion and then\n\t * stream will be moved to SETUP state, even if draining resulted in an\n\t * error. We can trigger next track after this.\n\t */\n\tstream->runtime->state = SNDRV_PCM_STATE_DRAINING;\n\tmutex_unlock(&stream->device->lock);\n\n\t/* we wait for drain to complete here, drain can return when\n\t * interruption occurred, wait returned error or success.\n\t * For the first two cases we don't do anything different here and\n\t * return after waking up\n\t */\n\n\tret = wait_event_interruptible(stream->runtime->sleep,\n\t\t\t(stream->runtime->state != SNDRV_PCM_STATE_DRAINING));\n\tif (ret == -ERESTARTSYS)\n\t\tpr_debug(\"wait aborted by a signal\");\n\telse if (ret)\n\t\tpr_debug(\"wait for drain failed with %d\\n\", ret);\n\n\n\twake_up(&stream->runtime->sleep);\n\tmutex_lock(&stream->device->lock);\n\n\treturn ret;\n}\n\nstatic int snd_compr_drain(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\tif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP)\n\t\treturn -EPERM;\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);\n\tif (retval) {\n\t\tpr_debug(\"SND_COMPR_TRIGGER_DRAIN failed %d\\n\", retval);\n\t\twake_up(&stream->runtime->sleep);\n\t\treturn retval;\n\t}\n\n\treturn snd_compress_wait_for_drain(stream);\n}\n\nstatic int snd_compr_next_track(struct snd_compr_stream *stream)\n{\n\tint retval;\n\n\t/* only a running stream can transition to next track */\n\tif (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\t/* you can signal next track isf this is intended to be a gapless stream\n\t * and current track metadata is set\n\t */\n\tif (stream->metadata_set == false)\n\t\treturn -EPERM;\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_NEXT_TRACK);\n\tif (retval != 0)\n\t\treturn retval;\n\tstream->metadata_set = false;\n\tstream->next_track = true;\n\treturn 0;\n}\n\nstatic int snd_compr_partial_drain(struct snd_compr_stream *stream)\n{\n\tint retval;\n\tif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\n\t\t\tstream->runtime->state == SNDRV_PCM_STATE_SETUP)\n\t\treturn -EPERM;\n\t/* stream can be drained only when next track has been signalled */\n\tif (stream->next_track == false)\n\t\treturn -EPERM;\n\n\tretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);\n\tif (retval) {\n\t\tpr_debug(\"Partial drain returned failure\\n\");\n\t\twake_up(&stream->runtime->sleep);\n\t\treturn retval;\n\t}\n\n\tstream->next_track = false;\n\treturn snd_compress_wait_for_drain(stream);\n}\n\nstatic long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tint retval = -ENOTTY;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\tstream = &data->stream;\n\tif (snd_BUG_ON(!stream))\n\t\treturn -EFAULT;\n\tmutex_lock(&stream->device->lock);\n\tswitch (_IOC_NR(cmd)) {\n\tcase _IOC_NR(SNDRV_COMPRESS_IOCTL_VERSION):\n\t\tretval = put_user(SNDRV_COMPRESS_VERSION,\n\t\t\t\t(int __user *)arg) ? -EFAULT : 0;\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_CAPS):\n\t\tretval = snd_compr_get_caps(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_CODEC_CAPS):\n\t\tretval = snd_compr_get_codec_caps(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_SET_PARAMS):\n\t\tretval = snd_compr_set_params(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_PARAMS):\n\t\tretval = snd_compr_get_params(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_SET_METADATA):\n\t\tretval = snd_compr_set_metadata(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_GET_METADATA):\n\t\tretval = snd_compr_get_metadata(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_TSTAMP):\n\t\tretval = snd_compr_tstamp(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_AVAIL):\n\t\tretval = snd_compr_ioctl_avail(stream, arg);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_PAUSE):\n\t\tretval = snd_compr_pause(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_RESUME):\n\t\tretval = snd_compr_resume(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_START):\n\t\tretval = snd_compr_start(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_STOP):\n\t\tretval = snd_compr_stop(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_DRAIN):\n\t\tretval = snd_compr_drain(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_PARTIAL_DRAIN):\n\t\tretval = snd_compr_partial_drain(stream);\n\t\tbreak;\n\tcase _IOC_NR(SNDRV_COMPRESS_NEXT_TRACK):\n\t\tretval = snd_compr_next_track(stream);\n\t\tbreak;\n\n\t}\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}\n\nstatic const struct file_operations snd_compr_file_ops = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.open =\t\tsnd_compr_open,\n\t\t.release =\tsnd_compr_free,\n\t\t.write =\tsnd_compr_write,\n\t\t.read =\t\tsnd_compr_read,\n\t\t.unlocked_ioctl = snd_compr_ioctl,\n\t\t.mmap =\t\tsnd_compr_mmap,\n\t\t.poll =\t\tsnd_compr_poll,\n};\n\nstatic int snd_compress_dev_register(struct snd_device *device)\n{\n\tint ret = -EINVAL;\n\tchar str[16];\n\tstruct snd_compr *compr;\n\n\tif (snd_BUG_ON(!device || !device->device_data))\n\t\treturn -EBADFD;\n\tcompr = device->device_data;\n\n\tsprintf(str, \"comprC%iD%i\", compr->card->number, compr->device);\n\tpr_debug(\"reg %s for device %s, direction %d\\n\", str, compr->name,\n\t\t\tcompr->direction);\n\t/* register compressed device */\n\tret = snd_register_device(SNDRV_DEVICE_TYPE_COMPRESS, compr->card,\n\t\t\tcompr->device, &snd_compr_file_ops, compr, str);\n\tif (ret < 0) {\n\t\tpr_err(\"snd_register_device failed\\n %d\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n\n}\n\nstatic int snd_compress_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_compr *compr;\n\n\tcompr = device->device_data;\n\tsnd_unregister_device(SNDRV_DEVICE_TYPE_COMPRESS, compr->card,\n\t\tcompr->device);\n\treturn 0;\n}\n\n/*\n * snd_compress_new: create new compress device\n * @card: sound card pointer\n * @device: device number\n * @dirn: device direction, should be of type enum snd_compr_direction\n * @compr: compress device pointer\n */\nint snd_compress_new(struct snd_card *card, int device,\n\t\t\tint dirn, struct snd_compr *compr)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = NULL,\n\t\t.dev_register = snd_compress_dev_register,\n\t\t.dev_disconnect = snd_compress_dev_disconnect,\n\t};\n\n\tcompr->card = card;\n\tcompr->device = device;\n\tcompr->direction = dirn;\n\treturn snd_device_new(card, SNDRV_DEV_COMPRESS, compr, &ops);\n}\nEXPORT_SYMBOL_GPL(snd_compress_new);\n\nstatic int snd_compress_add_device(struct snd_compr *device)\n{\n\tint ret;\n\n\tif (!device->card)\n\t\treturn -EINVAL;\n\n\t/* register the card */\n\tret = snd_card_register(device->card);\n\tif (ret)\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tpr_err(\"failed with %d\\n\", ret);\n\treturn ret;\n\n}\n\nstatic int snd_compress_remove_device(struct snd_compr *device)\n{\n\treturn snd_card_free(device->card);\n}\n\n/**\n * snd_compress_register - register compressed device\n *\n * @device: compressed device to register\n */\nint snd_compress_register(struct snd_compr *device)\n{\n\tint retval;\n\n\tif (device->name == NULL || device->dev == NULL || device->ops == NULL)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Registering compressed device %s\\n\", device->name);\n\tif (snd_BUG_ON(!device->ops->open))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!device->ops->free))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!device->ops->set_params))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!device->ops->trigger))\n\t\treturn -EINVAL;\n\n\tmutex_init(&device->lock);\n\n\t/* register a compressed card */\n\tmutex_lock(&device_mutex);\n\tretval = snd_compress_add_device(device);\n\tmutex_unlock(&device_mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(snd_compress_register);\n\nint snd_compress_deregister(struct snd_compr *device)\n{\n\tpr_debug(\"Removing compressed device %s\\n\", device->name);\n\tmutex_lock(&device_mutex);\n\tsnd_compress_remove_device(device);\n\tmutex_unlock(&device_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_compress_deregister);\n\nstatic int __init snd_compress_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit snd_compress_exit(void)\n{\n}\n\nmodule_init(snd_compress_init);\nmodule_exit(snd_compress_exit);\n\nMODULE_DESCRIPTION(\"ALSA Compressed offload framework\");\nMODULE_AUTHOR(\"Vinod Koul <vinod.koul@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["sound/core/compress_offload.c"], "buggy_code_start_loc": [494], "buggy_code_end_loc": [495], "fixing_code_start_loc": [494], "fixing_code_end_loc": [495], "type": "NVD-CWE-Other", "message": "The snd_compress_check_input function in sound/core/compress_offload.c in the ALSA subsystem in the Linux kernel before 3.17 does not properly check for an integer overflow, which allows local users to cause a denial of service (insufficient memory allocation) or possibly have unspecified other impact via a crafted SNDRV_COMPRESS_SET_PARAMS ioctl call.", "other": {"cve": {"id": "CVE-2014-9904", "sourceIdentifier": "security@android.com", "published": "2016-06-27T10:59:01.283", "lastModified": "2023-01-17T21:42:22.280", "vulnStatus": "Analyzed", "evaluatorComment": "CWE-190: Integer Overflow or Wraparound", "descriptions": [{"lang": "en", "value": "The snd_compress_check_input function in sound/core/compress_offload.c in the ALSA subsystem in the Linux kernel before 3.17 does not properly check for an integer overflow, which allows local users to cause a denial of service (insufficient memory allocation) or possibly have unspecified other impact via a crafted SNDRV_COMPRESS_SET_PARAMS ioctl call."}, {"lang": "es", "value": "La funci\u00f3n snd_compress_check_input en sound/core/compress_offload.c en el subsistema ALSA en el kernel de Linux en versiones anteriores a 3.17 no comprueba correctamente un desbordamiento de enteros, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (insuficiente asignaci\u00f3n de memor\u00eda) o posiblemente tener otros impactos no especificados a trav\u00e9s de una llamada SNDRV_COMPRESS_SET_PARAMS ioctl manipulada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.7", "versionEndExcluding": "3.12.62", "matchCriteriaId": "1652B5BB-07B1-4C35-BE45-9FF9D4A9D8DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.16.37", "matchCriteriaId": "8BD9039D-5837-4376-90C1-051602A3FF94"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_real_time_extension:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "5AB3CAA1-C20C-4A86-841E-EC0858164D7D"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6217e5ede23285ddfee10d2e4ba0cc2d4c046205", "source": "security@android.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00000.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00044.html", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00055.html", "source": "security@android.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3616", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91510", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1036189", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/6217e5ede23285ddfee10d2e4ba0cc2d4c046205", "source": "security@android.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6217e5ede23285ddfee10d2e4ba0cc2d4c046205"}}