{"buggy_code": ["<script lang=\"ts\">\n  import type { EntryBaseAttributes } from \"../entries\";\n  import { urlForAccount, urlForSource } from \"../helpers\";\n  import { _ } from \"../i18n\";\n\n  type ContextBalance = Record<string, string[]>;\n  export let entry: EntryBaseAttributes;\n  export let balances_before: ContextBalance | null;\n  export let balances_after: ContextBalance | null;\n</script>\n\n<p>\n  {_(\"Location\")}:\n  <code>\n    <a href={urlForSource(entry)}>\n      {entry.meta.filename}:{entry.meta.lineno}\n    </a>\n  </code>\n</p>\n\n{#if balances_before && balances_after}\n  <details>\n    <summary>\n      <span>{_(\"Context\")}</span>\n    </summary>\n    <div>\n      <table>\n        <thead>\n          <tr>\n            <th colspan=\"2\">{_(\"Balances before entry\")}</th>\n          </tr>\n        </thead>\n        <tbody>\n          {#each Object.entries(balances_before) as [account, inventory]}\n            <tr>\n              <td><a href={urlForAccount(account)}>{account}</a></td>\n              <td>\n                {@html inventory.join(\"<br>\")}\n              </td>\n            </tr>\n          {/each}\n        </tbody>\n      </table>\n      <table>\n        <thead>\n          <tr>\n            <th colspan=\"2\">{_(\"Balances after entry\")}</th>\n          </tr>\n        </thead>\n        <tbody>\n          {#each Object.entries(balances_after) as [account, inventory]}\n            <tr>\n              <td><a href={urlForAccount(account)}>{account}</a></td>\n              <td>\n                {@html inventory.join(\"<br>\")}\n              </td>\n            </tr>\n          {/each}\n        </tbody>\n      </table>\n    </div>\n  </details>\n{/if}\n", "<script lang=\"ts\">\n  import { onMount, tick } from \"svelte\";\n\n  import { get } from \"../api\";\n  import type { ChartTypes } from \"../charts\";\n  import Chart from \"../charts/Chart.svelte\";\n  import { chartContext } from \"../charts/context\";\n  import { parseQueryChart } from \"../charts/query-charts\";\n  import { getFilterParams } from \"../stores/filters\";\n  import {\n    addToHistory,\n    clearHistory,\n    query_shell_history,\n  } from \"../stores/query\";\n\n  import QueryEditor from \"./QueryEditor.svelte\";\n  import QueryLinks from \"./QueryLinks.svelte\";\n  import ReadonlyQueryEditor from \"./ReadonlyQueryEditor.svelte\";\n\n  let query_string = \"\";\n\n  const resultElems: Record<string, HTMLElement> = {};\n\n  type ResultType = {\n    result?: { table: string; chart: ChartTypes | null };\n    error?: unknown;\n  };\n\n  const query_results: Record<string, ResultType> = {};\n\n  $: query_result_array = $query_shell_history.map(\n    (item): [string, ResultType] => [item, query_results[item] || {}]\n  );\n\n  async function setResult(query: string, res: ResultType) {\n    addToHistory(query);\n    query_results[query] = res;\n    await tick();\n    const url = new URL(window.location.href);\n    url.searchParams.set(\"query_string\", query);\n    window.history.replaceState(null, \"\", url.toString());\n    resultElems[query].setAttribute(\"open\", \"true\");\n  }\n\n  async function clearResults() {\n    clearHistory();\n    await tick();\n    const url = new URL(window.location.href);\n    query_string = \"\";\n    url.searchParams.set(\"query_string\", query_string);\n    window.history.replaceState(null, \"\", url.toString());\n  }\n\n  function submit() {\n    const query = query_string;\n    if (!query) {\n      return;\n    }\n    if (query.trim().toUpperCase() === \"CLEAR\") {\n      clearResults();\n      return;\n    }\n    get(\"query_result\", { query_string: query, ...getFilterParams() }).then(\n      (res) => {\n        const r = parseQueryChart(res.chart, $chartContext);\n        const chart = r.success ? r.value : null;\n        setResult(query, { result: { chart, table: res.table } });\n      },\n      (error) => {\n        setResult(query, { error });\n      }\n    );\n  }\n\n  function click(query: string) {\n    if (!query_results[query]) {\n      query_string = query;\n      submit();\n    }\n  }\n\n  onMount(() => {\n    const url = new URL(window.location.href);\n    query_string = url.searchParams.get(\"query_string\") || \"\";\n    if (query_string) {\n      submit();\n    }\n  });\n</script>\n\n<QueryEditor bind:value={query_string} {submit} />\n<div>\n  {#each query_result_array as [history_item, { result, error }] (history_item)}\n    <details class:error bind:this={resultElems[history_item]}>\n      <summary on:click={() => click(history_item)}>\n        <ReadonlyQueryEditor value={history_item} />\n        {#if result}\n          <span class=\"spacer\" />\n          <QueryLinks query={history_item} />\n        {/if}\n      </summary>\n      <div>\n        {#if result}\n          {#if result.chart}\n            <Chart chart={result.chart} />\n          {/if}\n          {@html result.table}\n        {:else if error}\n          {@html error}\n        {/if}\n      </div>\n    </details>\n  {/each}\n</div>\n\n<style>\n  details > div {\n    max-height: 80vh;\n    overflow: auto;\n  }\n\n  div :global(.query-error) {\n    font-family: var(--font-family-monospaced);\n    color: var(--background);\n    background: var(--error);\n  }\n</style>\n"], "fixing_code": ["<script lang=\"ts\">\n  import type { EntryBaseAttributes } from \"../entries\";\n  import { urlForAccount, urlForSource } from \"../helpers\";\n  import { _ } from \"../i18n\";\n\n  type ContextBalance = Record<string, string[]>;\n  export let entry: EntryBaseAttributes;\n  export let balances_before: ContextBalance | null;\n  export let balances_after: ContextBalance | null;\n</script>\n\n<p>\n  {_(\"Location\")}:\n  <code>\n    <a href={urlForSource(entry)}>\n      {entry.meta.filename}:{entry.meta.lineno}\n    </a>\n  </code>\n</p>\n\n{#if balances_before && balances_after}\n  <details>\n    <summary>\n      <span>{_(\"Context\")}</span>\n    </summary>\n    <div>\n      <table>\n        <thead>\n          <tr>\n            <th colspan=\"2\">{_(\"Balances before entry\")}</th>\n          </tr>\n        </thead>\n        <tbody>\n          {#each Object.entries(balances_before) as [account, inventory]}\n            <tr>\n              <td><a href={urlForAccount(account)}>{account}</a></td>\n              <td>\n                {#each inventory as amount}\n                  {amount}\n                  <br />\n                {/each}\n              </td>\n            </tr>\n          {/each}\n        </tbody>\n      </table>\n      <table>\n        <thead>\n          <tr>\n            <th colspan=\"2\">{_(\"Balances after entry\")}</th>\n          </tr>\n        </thead>\n        <tbody>\n          {#each Object.entries(balances_after) as [account, inventory]}\n            <tr>\n              <td><a href={urlForAccount(account)}>{account}</a></td>\n              <td>\n                {#each inventory as amount}\n                  {amount}\n                  <br />\n                {/each}\n              </td>\n            </tr>\n          {/each}\n        </tbody>\n      </table>\n    </div>\n  </details>\n{/if}\n", "<script lang=\"ts\">\n  import { onMount, tick } from \"svelte\";\n\n  import { get } from \"../api\";\n  import type { ChartTypes } from \"../charts\";\n  import Chart from \"../charts/Chart.svelte\";\n  import { chartContext } from \"../charts/context\";\n  import { parseQueryChart } from \"../charts/query-charts\";\n  import { getFilterParams } from \"../stores/filters\";\n  import {\n    addToHistory,\n    clearHistory,\n    query_shell_history,\n  } from \"../stores/query\";\n\n  import QueryEditor from \"./QueryEditor.svelte\";\n  import QueryLinks from \"./QueryLinks.svelte\";\n  import ReadonlyQueryEditor from \"./ReadonlyQueryEditor.svelte\";\n\n  let query_string = \"\";\n\n  const resultElems: Record<string, HTMLElement> = {};\n\n  type ResultType = {\n    result?: { table: string; chart: ChartTypes | null };\n    error?: unknown;\n  };\n\n  const query_results: Record<string, ResultType> = {};\n\n  $: query_result_array = $query_shell_history.map(\n    (item): [string, ResultType] => [item, query_results[item] || {}]\n  );\n\n  async function setResult(query: string, res: ResultType) {\n    addToHistory(query);\n    query_results[query] = res;\n    await tick();\n    const url = new URL(window.location.href);\n    url.searchParams.set(\"query_string\", query);\n    window.history.replaceState(null, \"\", url.toString());\n    resultElems[query].setAttribute(\"open\", \"true\");\n  }\n\n  async function clearResults() {\n    clearHistory();\n    await tick();\n    const url = new URL(window.location.href);\n    query_string = \"\";\n    url.searchParams.set(\"query_string\", query_string);\n    window.history.replaceState(null, \"\", url.toString());\n  }\n\n  function submit() {\n    const query = query_string;\n    if (!query) {\n      return;\n    }\n    if (query.trim().toUpperCase() === \"CLEAR\") {\n      clearResults();\n      return;\n    }\n    get(\"query_result\", { query_string: query, ...getFilterParams() }).then(\n      (res) => {\n        const r = parseQueryChart(res.chart, $chartContext);\n        const chart = r.success ? r.value : null;\n        setResult(query, { result: { chart, table: res.table } });\n      },\n      (error) => {\n        setResult(query, { error });\n      }\n    );\n  }\n\n  function click(query: string) {\n    if (!query_results[query]) {\n      query_string = query;\n      submit();\n    }\n  }\n\n  onMount(() => {\n    const url = new URL(window.location.href);\n    query_string = url.searchParams.get(\"query_string\") || \"\";\n    if (query_string) {\n      submit();\n    }\n  });\n</script>\n\n<QueryEditor bind:value={query_string} {submit} />\n<div>\n  {#each query_result_array as [history_item, { result, error }] (history_item)}\n    <details class:error bind:this={resultElems[history_item]}>\n      <summary on:click={() => click(history_item)}>\n        <ReadonlyQueryEditor value={history_item} />\n        {#if result}\n          <span class=\"spacer\" />\n          <QueryLinks query={history_item} />\n        {/if}\n      </summary>\n      <div>\n        {#if result}\n          {#if result.chart}\n            <Chart chart={result.chart} />\n          {/if}\n          {@html result.table}\n        {:else if error}\n          {error}\n        {/if}\n      </div>\n    </details>\n  {/each}\n</div>\n\n<style>\n  details > div {\n    max-height: 80vh;\n    overflow: auto;\n  }\n\n  div :global(.query-error) {\n    font-family: var(--font-family-monospaced);\n    color: var(--background);\n    background: var(--error);\n  }\n</style>\n"], "filenames": ["frontend/src/modals/EntryContext.svelte", "frontend/src/query/Query.svelte"], "buggy_code_start_loc": [38, 109], "buggy_code_end_loc": [56, 110], "fixing_code_start_loc": [38, 109], "fixing_code_end_loc": [62, 110], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository beancount/fava prior to 1.22.2.", "other": {"cve": {"id": "CVE-2022-2523", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-25T14:15:10.983", "lastModified": "2022-07-27T19:29:04.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository beancount/fava prior to 1.22.2."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Reflejado en el repositorio de GitHub beancount/fava versiones anteriores a 1.22.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fava_project:fava:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.22.2", "matchCriteriaId": "EB676CC6-C536-4CE1-AE84-05D8839E4BAC"}]}]}], "references": [{"url": "https://github.com/beancount/fava/commit/dccfb6a2f4567f35ce2e9a78e24f92ebf946bc9b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2a1802d8-1c2e-4919-96a7-d4dcf7ffcf8f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/beancount/fava/commit/dccfb6a2f4567f35ce2e9a78e24f92ebf946bc9b"}}