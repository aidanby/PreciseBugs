{"buggy_code": ["/*\n * Vividas VIV format Demuxer\n * Copyright (c) 2012 Krzysztof Klinikowski\n * Copyright (c) 2010 Andrzej Szombierski\n * based on vivparse Copyright (c) 2007 M\u00e5ns Rullg\u00e5rd\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * @brief Vividas VIV (.viv) file demuxer\n * @author Andrzej Szombierski [qq at kuku eu org] (2010-07)\n * @sa http://wiki.multimedia.cx/index.php?title=Vividas_VIV\n */\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avio_internal.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n\n#define MAX_AUDIO_SUBPACKETS 100\n\ntypedef struct VIV_SB_block {\n    int size, n_packets;\n    int64_t byte_offset;\n    int64_t packet_offset;\n} VIV_SB_block;\n\ntypedef struct VIV_SB_entry {\n    int size, flag;\n} VIV_SB_entry;\n\ntypedef struct VIV_AudioSubpacket {\n    int start, pcm_bytes;\n} VIV_AudioSubpacket;\n\ntypedef struct VividasDemuxContext {\n    int n_sb_blocks;\n    VIV_SB_block *sb_blocks;\n    int num_audio;\n\n    uint32_t sb_key;\n    int64_t sb_offset;\n\n    int current_sb, current_sb_entry;\n    uint8_t *sb_buf;\n    AVIOContext *sb_pb;\n    int n_sb_entries;\n    VIV_SB_entry *sb_entries;\n\n    int n_audio_subpackets;\n    int current_audio_subpacket;\n\n    int64_t audio_sample;\n\n    VIV_AudioSubpacket audio_subpackets[MAX_AUDIO_SUBPACKETS];\n} VividasDemuxContext;\n\nstatic int viv_probe(const AVProbeData *p)\n{\n    if (memcmp(p->buf, \"vividas03\", 9))\n        return 0;\n\n    return AVPROBE_SCORE_MAX;\n}\n\nstatic const uint8_t keybits[32] = {\n 20,  52, 111,  10,  27,  71, 142,  53,\n 82, 138,   1,  78,  86, 121, 183,  85,\n105, 152,  39, 140, 172,  11,  64, 144,\n155,   6,  71, 163, 186,  49, 126,  43,\n};\n\nstatic uint32_t decode_key(uint8_t *buf)\n{\n    uint32_t key = 0;\n\n    for (int i = 0; i < 32; i++) {\n        unsigned p = keybits[i];\n        key |= ((buf[p] >> ((i*5+3)&7)) & 1u) << i;\n    }\n\n    return key;\n}\n\nstatic void put_v(uint8_t *p, unsigned v)\n{\n    if (v>>28)\n        *p++ = ((v>>28)&0x7f)|0x80;\n    if (v>>21)\n        *p++ = ((v>>21)&0x7f)|0x80;\n    if (v>>14)\n        *p++ = ((v>>14)&0x7f)|0x80;\n    if (v>>7)\n        *p++ =  ((v>>7)&0x7f)|0x80;\n}\n\nstatic unsigned recover_key(unsigned char sample[4], unsigned expected_size)\n{\n    unsigned char plaintext[8] = { 'S', 'B' };\n\n    put_v(plaintext+2, expected_size);\n\n    return AV_RL32(sample) ^ AV_RL32(plaintext);\n}\n\nstatic void xor_block(void *p1, void *p2, unsigned size, int key, unsigned *key_ptr)\n{\n    unsigned *d1 = p1;\n    unsigned *d2 = p2;\n    unsigned k = *key_ptr;\n\n    size >>= 2;\n\n    while (size > 0) {\n        *d2 = *d1 ^ (HAVE_BIGENDIAN ? av_bswap32(k) : k);\n        k += key;\n        d1++;\n        d2++;\n        size--;\n    }\n\n    *key_ptr = k;\n}\n\nstatic void decode_block(uint8_t *src, uint8_t *dest, unsigned size,\n                         uint32_t key, uint32_t *key_ptr,\n                         int align)\n{\n    unsigned s = size;\n    char tmp[4];\n    int a2;\n\n    if (!size)\n        return;\n\n    align &= 3;\n    a2 = (4 - align) & 3;\n\n    if (align) {\n        uint32_t tmpkey = *key_ptr - key;\n        if (a2 > s) {\n            a2 = s;\n            avpriv_request_sample(NULL, \"tiny aligned block\");\n        }\n        memcpy(tmp + align, src, a2);\n        xor_block(tmp, tmp, 4, key, &tmpkey);\n        memcpy(dest, tmp + align, a2);\n        s -= a2;\n    }\n\n    if (s >= 4) {\n        xor_block(src + a2, dest + a2, s & ~3,\n                  key, key_ptr);\n        s &= 3;\n    }\n\n    if (s) {\n        size -= s;\n        memcpy(tmp, src + size, s);\n        xor_block(&tmp, &tmp, 4, key, key_ptr);\n        memcpy(dest + size, tmp, s);\n    }\n}\n\nstatic uint32_t get_v(uint8_t *p, int len)\n{\n    uint32_t v = 0;\n    const uint8_t *end = p + len;\n\n    do {\n        if (p >= end || v >= UINT_MAX / 128 - *p)\n            return v;\n        v <<= 7;\n        v += *p & 0x7f;\n    } while (*p++ & 0x80);\n\n    return v;\n}\n\nstatic uint8_t *read_vblock(AVIOContext *src, uint32_t *size,\n                            uint32_t key, uint32_t *k2, int align)\n{\n    uint8_t tmp[4];\n    uint8_t *buf;\n    unsigned n;\n\n    if (avio_read(src, tmp, 4) != 4)\n        return NULL;\n\n    decode_block(tmp, tmp, 4, key, k2, align);\n\n    n = get_v(tmp, 4);\n    if (n < 4)\n        return NULL;\n\n    buf = av_malloc(n);\n    if (!buf)\n        return NULL;\n\n    *size = n;\n    n -= 4;\n\n    memcpy(buf, tmp, 4);\n\n    if (avio_read(src, buf + 4, n) == n) {\n        decode_block(buf + 4, buf + 4, n, key, k2, align);\n    } else {\n        av_free(buf);\n        buf = NULL;\n    }\n\n    return buf;\n}\n\nstatic uint8_t *read_sb_block(AVIOContext *src, unsigned *size,\n                              uint32_t *key, unsigned expected_size)\n{\n    uint8_t *buf;\n    uint8_t ibuf[8], sbuf[8];\n    uint32_t k2;\n    unsigned n;\n\n    if (avio_read(src, ibuf, 8) < 8)\n        return NULL;\n\n    k2 = *key;\n    decode_block(ibuf, sbuf, 8, *key, &k2, 0);\n\n    n = get_v(sbuf+2, 6);\n\n    if (sbuf[0] != 'S' || sbuf[1] != 'B' || (expected_size>0 && n != expected_size)) {\n        uint32_t tmpkey = recover_key(ibuf, expected_size);\n        k2 = tmpkey;\n        decode_block(ibuf, sbuf, 8, tmpkey, &k2, 0);\n        n = get_v(sbuf+2, 6);\n        if (sbuf[0] != 'S' || sbuf[1] != 'B' || expected_size != n)\n            return NULL;\n        *key = tmpkey;\n    }\n\n    if (n < 8)\n        return NULL;\n\n    buf = av_malloc(n);\n    if (!buf)\n        return NULL;\n\n    memcpy(buf, sbuf, 8);\n\n    *size = n;\n    n -= 8;\n\n    if (avio_read(src, buf+8, n) < n) {\n        av_free(buf);\n        return NULL;\n    }\n\n    decode_block(buf + 8, buf + 8, n, *key, &k2, 0);\n\n    return buf;\n}\n\nstatic int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)\n{\n    int i, j, ret;\n    int64_t off;\n    int val_1;\n    int num_video;\n    AVIOContext pb0, *pb = &pb0;\n\n    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n\n    ffio_read_varlen(pb); // track_header_len\n    avio_r8(pb); // '1'\n\n    val_1 = ffio_read_varlen(pb);\n\n    for (i=0;i<val_1;i++) {\n        int c = avio_r8(pb);\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        for (j=0;j<c;j++) {\n            if (avio_feof(pb))\n                return AVERROR_EOF;\n            avio_r8(pb); // val_3\n            avio_r8(pb); // val_4\n        }\n    }\n\n    avio_r8(pb); // num_streams\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_5\n\n    avio_r8(pb); // '2'\n    num_video = avio_r8(pb);\n\n    avio_seek(pb, off, SEEK_SET);\n    if (num_video != 1) {\n        av_log(s, AV_LOG_ERROR, \"number of video tracks %d is not 1\\n\", num_video);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    for (i = 0; i < num_video; i++) {\n        AVStream *st = avformat_new_stream(s, NULL);\n        int num, den;\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id = AV_CODEC_ID_VP6;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb);\n        avio_r8(pb); // '3'\n        avio_r8(pb); // val_7\n        num = avio_rl32(pb); // frame_time\n        den = avio_rl32(pb); // time_base\n        avpriv_set_pts_info(st, 64, num, den);\n        st->nb_frames = avio_rl32(pb); // n frames\n        st->codecpar->width = avio_rl16(pb); // width\n        st->codecpar->height = avio_rl16(pb); // height\n        avio_r8(pb); // val_8\n        avio_rl32(pb); // val_9\n\n        avio_seek(pb, off, SEEK_SET);\n    }\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_10\n    avio_r8(pb); // '4'\n    viv->num_audio = avio_r8(pb);\n    avio_seek(pb, off, SEEK_SET);\n\n    if (viv->num_audio != 1)\n        av_log(s, AV_LOG_WARNING, \"number of audio tracks %d is not 1\\n\", viv->num_audio);\n\n    for(i=0;i<viv->num_audio;i++) {\n        int q;\n        AVStream *st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = num_video + i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_VORBIS;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb); // length\n        avio_r8(pb); // '5'\n        avio_r8(pb); //codec_id\n        avio_rl16(pb); //codec_subid\n        st->codecpar->channels = avio_rl16(pb); // channels\n        st->codecpar->sample_rate = avio_rl32(pb); // sample_rate\n        avio_seek(pb, 10, SEEK_CUR); // data_1\n        q = avio_r8(pb);\n        avio_seek(pb, q, SEEK_CUR); // data_2\n        avio_r8(pb); // zeropad\n\n        if (avio_tell(pb) < off) {\n            int num_data;\n            int xd_size = 0;\n            int data_len[256];\n            int offset = 1;\n            uint8_t *p;\n            ffio_read_varlen(pb); // val_13\n            avio_r8(pb); // '19'\n            ffio_read_varlen(pb); // len_3\n            num_data = avio_r8(pb);\n            for (j = 0; j < num_data; j++) {\n                uint64_t len = ffio_read_varlen(pb);\n                if (len > INT_MAX/2 - xd_size) {\n                    return AVERROR_INVALIDDATA;\n                }\n                data_len[j] = len;\n                xd_size += len;\n            }\n\n            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);\n            if (ret < 0)\n                return ret;\n\n            p = st->codecpar->extradata;\n            p[0] = 2;\n\n            for (j = 0; j < num_data - 1; j++) {\n                unsigned delta = av_xiphlacing(&p[offset], data_len[j]);\n                if (delta > data_len[j]) {\n                    return AVERROR_INVALIDDATA;\n                }\n                offset += delta;\n            }\n\n            for (j = 0; j < num_data; j++) {\n                int ret = avio_read(pb, &p[offset], data_len[j]);\n                if (ret < data_len[j]) {\n                    st->codecpar->extradata_size = 0;\n                    av_freep(&st->codecpar->extradata);\n                    break;\n                }\n                offset += data_len[j];\n            }\n\n            if (offset < st->codecpar->extradata_size)\n                st->codecpar->extradata_size = offset;\n        }\n    }\n\n    return 0;\n}\n\nstatic int track_index(VividasDemuxContext *viv, AVFormatContext *s, uint8_t *buf, unsigned size)\n{\n    int64_t off;\n    int64_t poff;\n    int maxnp=0;\n    AVIOContext pb0, *pb = &pb0;\n    int i;\n    int64_t filesize = avio_size(s->pb);\n    uint64_t n_sb_blocks_tmp;\n\n    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n\n    ffio_read_varlen(pb); // track_index_len\n    avio_r8(pb); // 'c'\n    n_sb_blocks_tmp = ffio_read_varlen(pb);\n    if (n_sb_blocks_tmp > size / 2)\n        return AVERROR_INVALIDDATA;\n    viv->sb_blocks = av_calloc(n_sb_blocks_tmp, sizeof(*viv->sb_blocks));\n    if (!viv->sb_blocks) {\n        return AVERROR(ENOMEM);\n    }\n    viv->n_sb_blocks = n_sb_blocks_tmp;\n\n    off = 0;\n    poff = 0;\n\n    for (i = 0; i < viv->n_sb_blocks; i++) {\n        uint64_t size_tmp      = ffio_read_varlen(pb);\n        uint64_t n_packets_tmp = ffio_read_varlen(pb);\n\n        if (size_tmp > INT_MAX || n_packets_tmp > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        viv->sb_blocks[i].byte_offset = off;\n        viv->sb_blocks[i].packet_offset = poff;\n\n        viv->sb_blocks[i].size = size_tmp;\n        viv->sb_blocks[i].n_packets = n_packets_tmp;\n\n        off += viv->sb_blocks[i].size;\n        poff += viv->sb_blocks[i].n_packets;\n\n        if (maxnp < viv->sb_blocks[i].n_packets)\n            maxnp = viv->sb_blocks[i].n_packets;\n    }\n\n    if (filesize > 0 && poff > filesize)\n        return AVERROR_INVALIDDATA;\n\n    viv->sb_entries = av_calloc(maxnp, sizeof(VIV_SB_entry));\n    if (!viv->sb_entries)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic void load_sb_block(AVFormatContext *s, VividasDemuxContext *viv, unsigned expected_size)\n{\n    uint32_t size = 0;\n    int i;\n    AVIOContext *pb = 0;\n\n    if (viv->sb_pb) {\n        av_free(viv->sb_pb);\n        viv->sb_pb = NULL;\n    }\n\n    if (viv->sb_buf)\n        av_free(viv->sb_buf);\n\n    viv->sb_buf = read_sb_block(s->pb, &size, &viv->sb_key, expected_size);\n    if (!viv->sb_buf) {\n        return;\n    }\n\n    pb = avio_alloc_context(viv->sb_buf, size, 0, NULL, NULL, NULL, NULL);\n    if (!pb)\n        return;\n\n    viv->sb_pb = pb;\n\n    avio_r8(pb); //  'S'\n    avio_r8(pb); //  'B'\n    ffio_read_varlen(pb); //  size\n    avio_r8(pb); //  junk\n    ffio_read_varlen(pb); // first packet\n\n    viv->n_sb_entries = viv->sb_blocks[viv->current_sb].n_packets;\n\n    for (i = 0; i < viv->n_sb_entries; i++) {\n        viv->sb_entries[i].size = ffio_read_varlen(pb);\n        viv->sb_entries[i].flag = avio_r8(pb);\n    }\n\n    ffio_read_varlen(pb);\n    avio_r8(pb);\n\n    viv->current_sb_entry = 0;\n}\n\nstatic int viv_read_header(AVFormatContext *s)\n{\n    VividasDemuxContext *viv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t header_end;\n    int num_tracks;\n    uint32_t key, k2;\n    uint32_t v;\n    uint8_t keybuffer[187];\n    uint32_t b22_size = 0;\n    uint32_t b22_key = 0;\n    uint8_t *buf = 0;\n    int ret;\n\n    avio_skip(pb, 9);\n\n    header_end = avio_tell(pb);\n\n    header_end += ffio_read_varlen(pb);\n\n    num_tracks = avio_r8(pb);\n\n    if (num_tracks != 1) {\n        av_log(s, AV_LOG_ERROR, \"number of tracks %d is not 1\\n\", num_tracks);\n        return AVERROR(EINVAL);\n    }\n\n    v = avio_r8(pb);\n    avio_seek(pb, v, SEEK_CUR);\n\n    avio_read(pb, keybuffer, 187);\n    key = decode_key(keybuffer);\n    viv->sb_key = key;\n\n    avio_rl32(pb);\n\n    for (;;) {\n        int64_t here = avio_tell(pb);\n        int block_len, block_type;\n\n        if (here >= header_end)\n            break;\n\n        block_len = ffio_read_varlen(pb);\n        if (avio_feof(pb) || block_len <= 0)\n            return AVERROR_INVALIDDATA;\n\n        block_type = avio_r8(pb);\n\n        if (block_type == 22) {\n            avio_read(pb, keybuffer, 187);\n            b22_key = decode_key(keybuffer);\n            b22_size = avio_rl32(pb);\n        }\n\n        avio_seek(pb, here + block_len, SEEK_SET);\n    }\n\n    if (b22_size) {\n        k2 = b22_key;\n        buf = read_vblock(pb, &v, b22_key, &k2, 0);\n        if (!buf)\n            return AVERROR(EIO);\n\n        av_free(buf);\n    }\n\n    k2 = key;\n    buf = read_vblock(pb, &v, key, &k2, 0);\n    if (!buf)\n        return AVERROR(EIO);\n    ret = track_header(viv, s, buf, v);\n    av_free(buf);\n    if (ret < 0)\n        return ret;\n\n    buf = read_vblock(pb, &v, key, &k2, v);\n    if (!buf)\n        return AVERROR(EIO);\n    ret = track_index(viv, s, buf, v);\n    av_free(buf);\n    if (ret < 0)\n        goto fail;\n\n    viv->sb_offset = avio_tell(pb);\n    if (viv->n_sb_blocks > 0) {\n        viv->current_sb = 0;\n        load_sb_block(s, viv, viv->sb_blocks[0].size);\n    } else {\n        viv->current_sb = -1;\n    }\n\n    return 0;\nfail:\n    av_freep(&viv->sb_blocks);\n    return ret;\n}\n\nstatic int viv_read_packet(AVFormatContext *s,\n                           AVPacket *pkt)\n{\n    VividasDemuxContext *viv = s->priv_data;\n    AVIOContext *pb;\n    int64_t off;\n    int ret;\n\n    if (!viv->sb_pb)\n        return AVERROR(EIO);\n    if (avio_feof(viv->sb_pb))\n        return AVERROR_EOF;\n\n    if (viv->current_audio_subpacket < viv->n_audio_subpackets) {\n        AVStream *astream;\n        int size = viv->audio_subpackets[viv->current_audio_subpacket+1].start - viv->audio_subpackets[viv->current_audio_subpacket].start;\n\n        pb = viv->sb_pb;\n        ret = av_get_packet(pb, pkt, size);\n        if (ret < 0)\n            return ret;\n        pkt->pos += viv->sb_offset + viv->sb_blocks[viv->current_sb].byte_offset;\n\n        pkt->stream_index = 1;\n        astream = s->streams[pkt->stream_index];\n\n        pkt->pts = av_rescale_q(viv->audio_sample, av_make_q(1, astream->codecpar->sample_rate), astream->time_base);\n        viv->audio_sample += viv->audio_subpackets[viv->current_audio_subpacket].pcm_bytes / 2 / astream->codecpar->channels;\n        pkt->flags |= AV_PKT_FLAG_KEY;\n        viv->current_audio_subpacket++;\n        return 0;\n    }\n\n    if (viv->current_sb_entry >= viv->n_sb_entries) {\n        if (viv->current_sb+1 >= viv->n_sb_blocks)\n            return AVERROR(EIO);\n        viv->current_sb++;\n\n        load_sb_block(s, viv, 0);\n        viv->current_sb_entry = 0;\n    }\n\n    pb = viv->sb_pb;\n    if (!pb)\n        return AVERROR(EIO);\n    off = avio_tell(pb);\n\n    if (viv->current_sb_entry >= viv->n_sb_entries)\n        return AVERROR_INVALIDDATA;\n\n    off += viv->sb_entries[viv->current_sb_entry].size;\n\n    if (viv->sb_entries[viv->current_sb_entry].flag == 0) {\n        uint64_t v_size = ffio_read_varlen(pb);\n\n        if (!viv->num_audio)\n            return AVERROR_INVALIDDATA;\n\n        ffio_read_varlen(pb);\n        if (v_size > INT_MAX || !v_size)\n            return AVERROR_INVALIDDATA;\n        ret = av_get_packet(pb, pkt, v_size);\n        if (ret < 0)\n            return ret;\n        pkt->pos += viv->sb_offset + viv->sb_blocks[viv->current_sb].byte_offset;\n\n        pkt->pts = viv->sb_blocks[viv->current_sb].packet_offset + viv->current_sb_entry;\n        pkt->flags |= (pkt->data[0]&0x80)?0:AV_PKT_FLAG_KEY;\n        pkt->stream_index = 0;\n\n        for (int i = 0; i < MAX_AUDIO_SUBPACKETS - 1; i++) {\n            int start, pcm_bytes;\n            start = ffio_read_varlen(pb);\n            pcm_bytes = ffio_read_varlen(pb);\n\n            if (i > 0 && start == 0)\n                break;\n\n            viv->n_audio_subpackets = i + 1;\n            viv->audio_subpackets[i].start = start;\n            viv->audio_subpackets[i].pcm_bytes = pcm_bytes;\n        }\n        viv->audio_subpackets[viv->n_audio_subpackets].start = (int)(off - avio_tell(pb));\n        viv->current_audio_subpacket = 0;\n\n    } else {\n        uint64_t v_size = ffio_read_varlen(pb);\n\n        if (v_size > INT_MAX || !v_size)\n            return AVERROR_INVALIDDATA;\n        ret = av_get_packet(pb, pkt, v_size);\n        if (ret < 0)\n            return ret;\n        pkt->pos += viv->sb_offset + viv->sb_blocks[viv->current_sb].byte_offset;\n        pkt->pts = viv->sb_blocks[viv->current_sb].packet_offset + viv->current_sb_entry;\n        pkt->flags |= (pkt->data[0] & 0x80) ? 0 : AV_PKT_FLAG_KEY;\n        pkt->stream_index = 0;\n    }\n\n    viv->current_sb_entry++;\n\n    return 0;\n}\n\nstatic int viv_read_close(AVFormatContext *s)\n{\n    VividasDemuxContext *viv = s->priv_data;\n\n    av_freep(&viv->sb_pb);\n    av_freep(&viv->sb_buf);\n    av_freep(&viv->sb_blocks);\n    av_freep(&viv->sb_entries);\n\n    return 0;\n}\n\nstatic int viv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    VividasDemuxContext *viv = s->priv_data;\n    int64_t frame;\n\n    if (stream_index == 0)\n        frame = timestamp;\n    else\n        frame = av_rescale_q(timestamp, s->streams[0]->time_base, s->streams[stream_index]->time_base);\n\n    for (int i = 0; i < viv->n_sb_blocks; i++) {\n        if (frame >= viv->sb_blocks[i].packet_offset && frame < viv->sb_blocks[i].packet_offset + viv->sb_blocks[i].n_packets) {\n            // flush audio packet queue\n            viv->current_audio_subpacket = 0;\n            viv->n_audio_subpackets = 0;\n            viv->current_sb = i;\n            // seek to ith sb block\n            avio_seek(s->pb, viv->sb_offset + viv->sb_blocks[i].byte_offset, SEEK_SET);\n            // load the block\n            load_sb_block(s, viv, 0);\n            // most problematic part: guess audio offset\n            viv->audio_sample = av_rescale_q(viv->sb_blocks[i].packet_offset, av_make_q(s->streams[1]->codecpar->sample_rate, 1), av_inv_q(s->streams[0]->time_base));\n            // hand-tuned 1.s a/v offset\n            viv->audio_sample += s->streams[1]->codecpar->sample_rate;\n            viv->current_sb_entry = 0;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nAVInputFormat ff_vividas_demuxer = {\n    .name           = \"vividas\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Vividas VIV\"),\n    .priv_data_size = sizeof(VividasDemuxContext),\n    .read_probe     = viv_probe,\n    .read_header    = viv_read_header,\n    .read_packet    = viv_read_packet,\n    .read_close     = viv_read_close,\n    .read_seek      = viv_read_seek,\n};\n"], "fixing_code": ["/*\n * Vividas VIV format Demuxer\n * Copyright (c) 2012 Krzysztof Klinikowski\n * Copyright (c) 2010 Andrzej Szombierski\n * based on vivparse Copyright (c) 2007 M\u00e5ns Rullg\u00e5rd\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * @brief Vividas VIV (.viv) file demuxer\n * @author Andrzej Szombierski [qq at kuku eu org] (2010-07)\n * @sa http://wiki.multimedia.cx/index.php?title=Vividas_VIV\n */\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"avio_internal.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n\n#define MAX_AUDIO_SUBPACKETS 100\n\ntypedef struct VIV_SB_block {\n    int size, n_packets;\n    int64_t byte_offset;\n    int64_t packet_offset;\n} VIV_SB_block;\n\ntypedef struct VIV_SB_entry {\n    int size, flag;\n} VIV_SB_entry;\n\ntypedef struct VIV_AudioSubpacket {\n    int start, pcm_bytes;\n} VIV_AudioSubpacket;\n\ntypedef struct VividasDemuxContext {\n    int n_sb_blocks;\n    VIV_SB_block *sb_blocks;\n    int num_audio;\n\n    uint32_t sb_key;\n    int64_t sb_offset;\n\n    int current_sb, current_sb_entry;\n    uint8_t *sb_buf;\n    AVIOContext *sb_pb;\n    int n_sb_entries;\n    VIV_SB_entry *sb_entries;\n\n    int n_audio_subpackets;\n    int current_audio_subpacket;\n\n    int64_t audio_sample;\n\n    VIV_AudioSubpacket audio_subpackets[MAX_AUDIO_SUBPACKETS];\n} VividasDemuxContext;\n\nstatic int viv_probe(const AVProbeData *p)\n{\n    if (memcmp(p->buf, \"vividas03\", 9))\n        return 0;\n\n    return AVPROBE_SCORE_MAX;\n}\n\nstatic const uint8_t keybits[32] = {\n 20,  52, 111,  10,  27,  71, 142,  53,\n 82, 138,   1,  78,  86, 121, 183,  85,\n105, 152,  39, 140, 172,  11,  64, 144,\n155,   6,  71, 163, 186,  49, 126,  43,\n};\n\nstatic uint32_t decode_key(uint8_t *buf)\n{\n    uint32_t key = 0;\n\n    for (int i = 0; i < 32; i++) {\n        unsigned p = keybits[i];\n        key |= ((buf[p] >> ((i*5+3)&7)) & 1u) << i;\n    }\n\n    return key;\n}\n\nstatic void put_v(uint8_t *p, unsigned v)\n{\n    if (v>>28)\n        *p++ = ((v>>28)&0x7f)|0x80;\n    if (v>>21)\n        *p++ = ((v>>21)&0x7f)|0x80;\n    if (v>>14)\n        *p++ = ((v>>14)&0x7f)|0x80;\n    if (v>>7)\n        *p++ =  ((v>>7)&0x7f)|0x80;\n}\n\nstatic unsigned recover_key(unsigned char sample[4], unsigned expected_size)\n{\n    unsigned char plaintext[8] = { 'S', 'B' };\n\n    put_v(plaintext+2, expected_size);\n\n    return AV_RL32(sample) ^ AV_RL32(plaintext);\n}\n\nstatic void xor_block(void *p1, void *p2, unsigned size, int key, unsigned *key_ptr)\n{\n    unsigned *d1 = p1;\n    unsigned *d2 = p2;\n    unsigned k = *key_ptr;\n\n    size >>= 2;\n\n    while (size > 0) {\n        *d2 = *d1 ^ (HAVE_BIGENDIAN ? av_bswap32(k) : k);\n        k += key;\n        d1++;\n        d2++;\n        size--;\n    }\n\n    *key_ptr = k;\n}\n\nstatic void decode_block(uint8_t *src, uint8_t *dest, unsigned size,\n                         uint32_t key, uint32_t *key_ptr,\n                         int align)\n{\n    unsigned s = size;\n    char tmp[4];\n    int a2;\n\n    if (!size)\n        return;\n\n    align &= 3;\n    a2 = (4 - align) & 3;\n\n    if (align) {\n        uint32_t tmpkey = *key_ptr - key;\n        if (a2 > s) {\n            a2 = s;\n            avpriv_request_sample(NULL, \"tiny aligned block\");\n        }\n        memcpy(tmp + align, src, a2);\n        xor_block(tmp, tmp, 4, key, &tmpkey);\n        memcpy(dest, tmp + align, a2);\n        s -= a2;\n    }\n\n    if (s >= 4) {\n        xor_block(src + a2, dest + a2, s & ~3,\n                  key, key_ptr);\n        s &= 3;\n    }\n\n    if (s) {\n        size -= s;\n        memcpy(tmp, src + size, s);\n        xor_block(&tmp, &tmp, 4, key, key_ptr);\n        memcpy(dest + size, tmp, s);\n    }\n}\n\nstatic uint32_t get_v(uint8_t *p, int len)\n{\n    uint32_t v = 0;\n    const uint8_t *end = p + len;\n\n    do {\n        if (p >= end || v >= UINT_MAX / 128 - *p)\n            return v;\n        v <<= 7;\n        v += *p & 0x7f;\n    } while (*p++ & 0x80);\n\n    return v;\n}\n\nstatic uint8_t *read_vblock(AVIOContext *src, uint32_t *size,\n                            uint32_t key, uint32_t *k2, int align)\n{\n    uint8_t tmp[4];\n    uint8_t *buf;\n    unsigned n;\n\n    if (avio_read(src, tmp, 4) != 4)\n        return NULL;\n\n    decode_block(tmp, tmp, 4, key, k2, align);\n\n    n = get_v(tmp, 4);\n    if (n < 4)\n        return NULL;\n\n    buf = av_malloc(n);\n    if (!buf)\n        return NULL;\n\n    *size = n;\n    n -= 4;\n\n    memcpy(buf, tmp, 4);\n\n    if (avio_read(src, buf + 4, n) == n) {\n        decode_block(buf + 4, buf + 4, n, key, k2, align);\n    } else {\n        av_free(buf);\n        buf = NULL;\n    }\n\n    return buf;\n}\n\nstatic uint8_t *read_sb_block(AVIOContext *src, unsigned *size,\n                              uint32_t *key, unsigned expected_size)\n{\n    uint8_t *buf;\n    uint8_t ibuf[8], sbuf[8];\n    uint32_t k2;\n    unsigned n;\n\n    if (avio_read(src, ibuf, 8) < 8)\n        return NULL;\n\n    k2 = *key;\n    decode_block(ibuf, sbuf, 8, *key, &k2, 0);\n\n    n = get_v(sbuf+2, 6);\n\n    if (sbuf[0] != 'S' || sbuf[1] != 'B' || (expected_size>0 && n != expected_size)) {\n        uint32_t tmpkey = recover_key(ibuf, expected_size);\n        k2 = tmpkey;\n        decode_block(ibuf, sbuf, 8, tmpkey, &k2, 0);\n        n = get_v(sbuf+2, 6);\n        if (sbuf[0] != 'S' || sbuf[1] != 'B' || expected_size != n)\n            return NULL;\n        *key = tmpkey;\n    }\n\n    if (n < 8)\n        return NULL;\n\n    buf = av_malloc(n);\n    if (!buf)\n        return NULL;\n\n    memcpy(buf, sbuf, 8);\n\n    *size = n;\n    n -= 8;\n\n    if (avio_read(src, buf+8, n) < n) {\n        av_free(buf);\n        return NULL;\n    }\n\n    decode_block(buf + 8, buf + 8, n, *key, &k2, 0);\n\n    return buf;\n}\n\nstatic int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)\n{\n    int i, j, ret;\n    int64_t off;\n    int val_1;\n    int num_video;\n    AVIOContext pb0, *pb = &pb0;\n\n    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n\n    ffio_read_varlen(pb); // track_header_len\n    avio_r8(pb); // '1'\n\n    val_1 = ffio_read_varlen(pb);\n\n    for (i=0;i<val_1;i++) {\n        int c = avio_r8(pb);\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        for (j=0;j<c;j++) {\n            if (avio_feof(pb))\n                return AVERROR_EOF;\n            avio_r8(pb); // val_3\n            avio_r8(pb); // val_4\n        }\n    }\n\n    avio_r8(pb); // num_streams\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_5\n\n    avio_r8(pb); // '2'\n    num_video = avio_r8(pb);\n\n    avio_seek(pb, off, SEEK_SET);\n    if (num_video != 1) {\n        av_log(s, AV_LOG_ERROR, \"number of video tracks %d is not 1\\n\", num_video);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    for (i = 0; i < num_video; i++) {\n        AVStream *st = avformat_new_stream(s, NULL);\n        int num, den;\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codecpar->codec_id = AV_CODEC_ID_VP6;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb);\n        avio_r8(pb); // '3'\n        avio_r8(pb); // val_7\n        num = avio_rl32(pb); // frame_time\n        den = avio_rl32(pb); // time_base\n        avpriv_set_pts_info(st, 64, num, den);\n        st->nb_frames = avio_rl32(pb); // n frames\n        st->codecpar->width = avio_rl16(pb); // width\n        st->codecpar->height = avio_rl16(pb); // height\n        avio_r8(pb); // val_8\n        avio_rl32(pb); // val_9\n\n        avio_seek(pb, off, SEEK_SET);\n    }\n\n    off = avio_tell(pb);\n    off += ffio_read_varlen(pb); // val_10\n    avio_r8(pb); // '4'\n    viv->num_audio = avio_r8(pb);\n    avio_seek(pb, off, SEEK_SET);\n\n    if (viv->num_audio != 1)\n        av_log(s, AV_LOG_WARNING, \"number of audio tracks %d is not 1\\n\", viv->num_audio);\n\n    for(i=0;i<viv->num_audio;i++) {\n        int q;\n        AVStream *st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = num_video + i;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_VORBIS;\n\n        off = avio_tell(pb);\n        off += ffio_read_varlen(pb); // length\n        avio_r8(pb); // '5'\n        avio_r8(pb); //codec_id\n        avio_rl16(pb); //codec_subid\n        st->codecpar->channels = avio_rl16(pb); // channels\n        st->codecpar->sample_rate = avio_rl32(pb); // sample_rate\n        avio_seek(pb, 10, SEEK_CUR); // data_1\n        q = avio_r8(pb);\n        avio_seek(pb, q, SEEK_CUR); // data_2\n        avio_r8(pb); // zeropad\n\n        if (avio_tell(pb) < off) {\n            int num_data;\n            int xd_size = 1;\n            int data_len[256];\n            int offset = 1;\n            uint8_t *p;\n            ffio_read_varlen(pb); // val_13\n            avio_r8(pb); // '19'\n            ffio_read_varlen(pb); // len_3\n            num_data = avio_r8(pb);\n            for (j = 0; j < num_data; j++) {\n                uint64_t len = ffio_read_varlen(pb);\n                if (len > INT_MAX/2 - xd_size) {\n                    return AVERROR_INVALIDDATA;\n                }\n                data_len[j] = len;\n                xd_size += len + 1 + len/255;\n            }\n\n            ret = ff_alloc_extradata(st->codecpar, xd_size);\n            if (ret < 0)\n                return ret;\n\n            p = st->codecpar->extradata;\n            p[0] = 2;\n\n            for (j = 0; j < num_data - 1; j++) {\n                unsigned delta = av_xiphlacing(&p[offset], data_len[j]);\n                av_assert0(delta <= xd_size - offset);\n                offset += delta;\n            }\n\n            for (j = 0; j < num_data; j++) {\n                int ret = avio_read(pb, &p[offset], data_len[j]);\n                if (ret < data_len[j]) {\n                    st->codecpar->extradata_size = 0;\n                    av_freep(&st->codecpar->extradata);\n                    break;\n                }\n                av_assert0(data_len[j] <= xd_size - offset);\n                offset += data_len[j];\n            }\n\n            if (offset < st->codecpar->extradata_size)\n                st->codecpar->extradata_size = offset;\n        }\n    }\n\n    return 0;\n}\n\nstatic int track_index(VividasDemuxContext *viv, AVFormatContext *s, uint8_t *buf, unsigned size)\n{\n    int64_t off;\n    int64_t poff;\n    int maxnp=0;\n    AVIOContext pb0, *pb = &pb0;\n    int i;\n    int64_t filesize = avio_size(s->pb);\n    uint64_t n_sb_blocks_tmp;\n\n    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n\n    ffio_read_varlen(pb); // track_index_len\n    avio_r8(pb); // 'c'\n    n_sb_blocks_tmp = ffio_read_varlen(pb);\n    if (n_sb_blocks_tmp > size / 2)\n        return AVERROR_INVALIDDATA;\n    viv->sb_blocks = av_calloc(n_sb_blocks_tmp, sizeof(*viv->sb_blocks));\n    if (!viv->sb_blocks) {\n        return AVERROR(ENOMEM);\n    }\n    viv->n_sb_blocks = n_sb_blocks_tmp;\n\n    off = 0;\n    poff = 0;\n\n    for (i = 0; i < viv->n_sb_blocks; i++) {\n        uint64_t size_tmp      = ffio_read_varlen(pb);\n        uint64_t n_packets_tmp = ffio_read_varlen(pb);\n\n        if (size_tmp > INT_MAX || n_packets_tmp > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        viv->sb_blocks[i].byte_offset = off;\n        viv->sb_blocks[i].packet_offset = poff;\n\n        viv->sb_blocks[i].size = size_tmp;\n        viv->sb_blocks[i].n_packets = n_packets_tmp;\n\n        off += viv->sb_blocks[i].size;\n        poff += viv->sb_blocks[i].n_packets;\n\n        if (maxnp < viv->sb_blocks[i].n_packets)\n            maxnp = viv->sb_blocks[i].n_packets;\n    }\n\n    if (filesize > 0 && poff > filesize)\n        return AVERROR_INVALIDDATA;\n\n    viv->sb_entries = av_calloc(maxnp, sizeof(VIV_SB_entry));\n    if (!viv->sb_entries)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic void load_sb_block(AVFormatContext *s, VividasDemuxContext *viv, unsigned expected_size)\n{\n    uint32_t size = 0;\n    int i;\n    AVIOContext *pb = 0;\n\n    if (viv->sb_pb) {\n        av_free(viv->sb_pb);\n        viv->sb_pb = NULL;\n    }\n\n    if (viv->sb_buf)\n        av_free(viv->sb_buf);\n\n    viv->sb_buf = read_sb_block(s->pb, &size, &viv->sb_key, expected_size);\n    if (!viv->sb_buf) {\n        return;\n    }\n\n    pb = avio_alloc_context(viv->sb_buf, size, 0, NULL, NULL, NULL, NULL);\n    if (!pb)\n        return;\n\n    viv->sb_pb = pb;\n\n    avio_r8(pb); //  'S'\n    avio_r8(pb); //  'B'\n    ffio_read_varlen(pb); //  size\n    avio_r8(pb); //  junk\n    ffio_read_varlen(pb); // first packet\n\n    viv->n_sb_entries = viv->sb_blocks[viv->current_sb].n_packets;\n\n    for (i = 0; i < viv->n_sb_entries; i++) {\n        viv->sb_entries[i].size = ffio_read_varlen(pb);\n        viv->sb_entries[i].flag = avio_r8(pb);\n    }\n\n    ffio_read_varlen(pb);\n    avio_r8(pb);\n\n    viv->current_sb_entry = 0;\n}\n\nstatic int viv_read_header(AVFormatContext *s)\n{\n    VividasDemuxContext *viv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t header_end;\n    int num_tracks;\n    uint32_t key, k2;\n    uint32_t v;\n    uint8_t keybuffer[187];\n    uint32_t b22_size = 0;\n    uint32_t b22_key = 0;\n    uint8_t *buf = 0;\n    int ret;\n\n    avio_skip(pb, 9);\n\n    header_end = avio_tell(pb);\n\n    header_end += ffio_read_varlen(pb);\n\n    num_tracks = avio_r8(pb);\n\n    if (num_tracks != 1) {\n        av_log(s, AV_LOG_ERROR, \"number of tracks %d is not 1\\n\", num_tracks);\n        return AVERROR(EINVAL);\n    }\n\n    v = avio_r8(pb);\n    avio_seek(pb, v, SEEK_CUR);\n\n    avio_read(pb, keybuffer, 187);\n    key = decode_key(keybuffer);\n    viv->sb_key = key;\n\n    avio_rl32(pb);\n\n    for (;;) {\n        int64_t here = avio_tell(pb);\n        int block_len, block_type;\n\n        if (here >= header_end)\n            break;\n\n        block_len = ffio_read_varlen(pb);\n        if (avio_feof(pb) || block_len <= 0)\n            return AVERROR_INVALIDDATA;\n\n        block_type = avio_r8(pb);\n\n        if (block_type == 22) {\n            avio_read(pb, keybuffer, 187);\n            b22_key = decode_key(keybuffer);\n            b22_size = avio_rl32(pb);\n        }\n\n        avio_seek(pb, here + block_len, SEEK_SET);\n    }\n\n    if (b22_size) {\n        k2 = b22_key;\n        buf = read_vblock(pb, &v, b22_key, &k2, 0);\n        if (!buf)\n            return AVERROR(EIO);\n\n        av_free(buf);\n    }\n\n    k2 = key;\n    buf = read_vblock(pb, &v, key, &k2, 0);\n    if (!buf)\n        return AVERROR(EIO);\n    ret = track_header(viv, s, buf, v);\n    av_free(buf);\n    if (ret < 0)\n        return ret;\n\n    buf = read_vblock(pb, &v, key, &k2, v);\n    if (!buf)\n        return AVERROR(EIO);\n    ret = track_index(viv, s, buf, v);\n    av_free(buf);\n    if (ret < 0)\n        goto fail;\n\n    viv->sb_offset = avio_tell(pb);\n    if (viv->n_sb_blocks > 0) {\n        viv->current_sb = 0;\n        load_sb_block(s, viv, viv->sb_blocks[0].size);\n    } else {\n        viv->current_sb = -1;\n    }\n\n    return 0;\nfail:\n    av_freep(&viv->sb_blocks);\n    return ret;\n}\n\nstatic int viv_read_packet(AVFormatContext *s,\n                           AVPacket *pkt)\n{\n    VividasDemuxContext *viv = s->priv_data;\n    AVIOContext *pb;\n    int64_t off;\n    int ret;\n\n    if (!viv->sb_pb)\n        return AVERROR(EIO);\n    if (avio_feof(viv->sb_pb))\n        return AVERROR_EOF;\n\n    if (viv->current_audio_subpacket < viv->n_audio_subpackets) {\n        AVStream *astream;\n        int size = viv->audio_subpackets[viv->current_audio_subpacket+1].start - viv->audio_subpackets[viv->current_audio_subpacket].start;\n\n        pb = viv->sb_pb;\n        ret = av_get_packet(pb, pkt, size);\n        if (ret < 0)\n            return ret;\n        pkt->pos += viv->sb_offset + viv->sb_blocks[viv->current_sb].byte_offset;\n\n        pkt->stream_index = 1;\n        astream = s->streams[pkt->stream_index];\n\n        pkt->pts = av_rescale_q(viv->audio_sample, av_make_q(1, astream->codecpar->sample_rate), astream->time_base);\n        viv->audio_sample += viv->audio_subpackets[viv->current_audio_subpacket].pcm_bytes / 2 / astream->codecpar->channels;\n        pkt->flags |= AV_PKT_FLAG_KEY;\n        viv->current_audio_subpacket++;\n        return 0;\n    }\n\n    if (viv->current_sb_entry >= viv->n_sb_entries) {\n        if (viv->current_sb+1 >= viv->n_sb_blocks)\n            return AVERROR(EIO);\n        viv->current_sb++;\n\n        load_sb_block(s, viv, 0);\n        viv->current_sb_entry = 0;\n    }\n\n    pb = viv->sb_pb;\n    if (!pb)\n        return AVERROR(EIO);\n    off = avio_tell(pb);\n\n    if (viv->current_sb_entry >= viv->n_sb_entries)\n        return AVERROR_INVALIDDATA;\n\n    off += viv->sb_entries[viv->current_sb_entry].size;\n\n    if (viv->sb_entries[viv->current_sb_entry].flag == 0) {\n        uint64_t v_size = ffio_read_varlen(pb);\n\n        if (!viv->num_audio)\n            return AVERROR_INVALIDDATA;\n\n        ffio_read_varlen(pb);\n        if (v_size > INT_MAX || !v_size)\n            return AVERROR_INVALIDDATA;\n        ret = av_get_packet(pb, pkt, v_size);\n        if (ret < 0)\n            return ret;\n        pkt->pos += viv->sb_offset + viv->sb_blocks[viv->current_sb].byte_offset;\n\n        pkt->pts = viv->sb_blocks[viv->current_sb].packet_offset + viv->current_sb_entry;\n        pkt->flags |= (pkt->data[0]&0x80)?0:AV_PKT_FLAG_KEY;\n        pkt->stream_index = 0;\n\n        for (int i = 0; i < MAX_AUDIO_SUBPACKETS - 1; i++) {\n            int start, pcm_bytes;\n            start = ffio_read_varlen(pb);\n            pcm_bytes = ffio_read_varlen(pb);\n\n            if (i > 0 && start == 0)\n                break;\n\n            viv->n_audio_subpackets = i + 1;\n            viv->audio_subpackets[i].start = start;\n            viv->audio_subpackets[i].pcm_bytes = pcm_bytes;\n        }\n        viv->audio_subpackets[viv->n_audio_subpackets].start = (int)(off - avio_tell(pb));\n        viv->current_audio_subpacket = 0;\n\n    } else {\n        uint64_t v_size = ffio_read_varlen(pb);\n\n        if (v_size > INT_MAX || !v_size)\n            return AVERROR_INVALIDDATA;\n        ret = av_get_packet(pb, pkt, v_size);\n        if (ret < 0)\n            return ret;\n        pkt->pos += viv->sb_offset + viv->sb_blocks[viv->current_sb].byte_offset;\n        pkt->pts = viv->sb_blocks[viv->current_sb].packet_offset + viv->current_sb_entry;\n        pkt->flags |= (pkt->data[0] & 0x80) ? 0 : AV_PKT_FLAG_KEY;\n        pkt->stream_index = 0;\n    }\n\n    viv->current_sb_entry++;\n\n    return 0;\n}\n\nstatic int viv_read_close(AVFormatContext *s)\n{\n    VividasDemuxContext *viv = s->priv_data;\n\n    av_freep(&viv->sb_pb);\n    av_freep(&viv->sb_buf);\n    av_freep(&viv->sb_blocks);\n    av_freep(&viv->sb_entries);\n\n    return 0;\n}\n\nstatic int viv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    VividasDemuxContext *viv = s->priv_data;\n    int64_t frame;\n\n    if (stream_index == 0)\n        frame = timestamp;\n    else\n        frame = av_rescale_q(timestamp, s->streams[0]->time_base, s->streams[stream_index]->time_base);\n\n    for (int i = 0; i < viv->n_sb_blocks; i++) {\n        if (frame >= viv->sb_blocks[i].packet_offset && frame < viv->sb_blocks[i].packet_offset + viv->sb_blocks[i].n_packets) {\n            // flush audio packet queue\n            viv->current_audio_subpacket = 0;\n            viv->n_audio_subpackets = 0;\n            viv->current_sb = i;\n            // seek to ith sb block\n            avio_seek(s->pb, viv->sb_offset + viv->sb_blocks[i].byte_offset, SEEK_SET);\n            // load the block\n            load_sb_block(s, viv, 0);\n            // most problematic part: guess audio offset\n            viv->audio_sample = av_rescale_q(viv->sb_blocks[i].packet_offset, av_make_q(s->streams[1]->codecpar->sample_rate, 1), av_inv_q(s->streams[0]->time_base));\n            // hand-tuned 1.s a/v offset\n            viv->audio_sample += s->streams[1]->codecpar->sample_rate;\n            viv->current_sb_entry = 0;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nAVInputFormat ff_vividas_demuxer = {\n    .name           = \"vividas\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Vividas VIV\"),\n    .priv_data_size = sizeof(VividasDemuxContext),\n    .read_probe     = viv_probe,\n    .read_header    = viv_read_header,\n    .read_packet    = viv_read_packet,\n    .read_close     = viv_read_close,\n    .read_seek      = viv_read_seek,\n};\n"], "filenames": ["libavformat/vividas.c"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [420], "fixing_code_start_loc": [31], "fixing_code_end_loc": [421], "type": "CWE-787", "message": "track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing.", "other": {"cve": {"id": "CVE-2020-35964", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-03T19:15:11.720", "lastModified": "2022-08-06T03:23:21.283", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing."}, {"lang": "es", "value": "La funci\u00f3n track_header en la biblioteca libavformat/vividas.c en FFmpeg versi\u00f3n 4.3.1, presenta una escritura fuera de l\u00edmites debido al empaquetado extradata incorrecto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "65A3F408-676A-487B-BB80-121E55740A36"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26622", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202105-24", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7"}}