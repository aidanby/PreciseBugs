{"buggy_code": ["<?php\n/**\n * Class LoginBasic\n *\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nclass LoginBasic extends AbstractLoginFSMExtension\n{\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('basic');\n\t}\n\n\tprotected function OnModeDetection(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']))\n\t\t{\n\t\t\tif (isset($_SERVER['HTTP_AUTHORIZATION']) && !empty($_SERVER['HTTP_AUTHORIZATION']))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'basic';\n\t\t\t}\n\t\t\telseif (isset($_SERVER['REDIRECT_HTTP_AUTHORIZATION']) && !empty($_SERVER['REDIRECT_HTTP_AUTHORIZATION']))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'basic';\n\t\t\t}\n\t\t\telseif (isset($_SERVER['PHP_AUTH_USER']))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'basic';\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnReadCredentials(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']) || $_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\tlist($sAuthUser, $sAuthPwd) = $this->GetAuthUserAndPassword();\n\t\t\t$_SESSION['login_temp_auth_user'] =  $sAuthUser;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\tlist($sAuthUser, $sAuthPwd) = $this->GetAuthUserAndPassword();\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, $sAuthPwd, $_SESSION['login_mode'], 'internal'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\tlist($sAuthUser) = $this->GetAuthUserAndPassword();\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'internal', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\tLoginWebPage::HTTP401Error();\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = true;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprivate function GetAuthUserAndPassword()\n\t{\n\t\t$sAuthUser = '';\n\t\t$sAuthPwd = null;\n\t\t$sAuthorization = '';\n\t\tif (isset($_SERVER['HTTP_AUTHORIZATION']) && !empty($_SERVER['HTTP_AUTHORIZATION']))\n\t\t{\n\t\t\t$sAuthorization = $_SERVER['HTTP_AUTHORIZATION'];\n\t\t}\n\t\telseif (isset($_SERVER['REDIRECT_HTTP_AUTHORIZATION']) && !empty($_SERVER['REDIRECT_HTTP_AUTHORIZATION']))\n\t\t{\n\t\t\t$sAuthorization = $_SERVER['REDIRECT_HTTP_AUTHORIZATION'];\n\t\t}\n\n\t\tif (!empty($sAuthorization))\n\t\t{\n\t\t\tlist($sAuthUser, $sAuthPwd) = explode(':', base64_decode(substr($sAuthorization, 6)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (isset($_SERVER['PHP_AUTH_USER']))\n\t\t\t{\n\t\t\t\t$sAuthUser = $_SERVER['PHP_AUTH_USER'];\n\t\t\t\t// Unfortunately, the RFC is not clear about the encoding...\n\t\t\t\t// IE and FF supply the user and password encoded in ISO-8859-1 whereas Chrome provides them encoded in UTF-8\n\t\t\t\t// So let's try to guess if it's an UTF-8 string or not... fortunately all encodings share the same ASCII base\n\t\t\t\tif (!LoginWebPage::LooksLikeUTF8($sAuthUser))\n\t\t\t\t{\n\t\t\t\t\t// Does not look like and UTF-8 string, try to convert it from iso-8859-1 to UTF-8\n\t\t\t\t\t// Supposed to be harmless in case of a plain ASCII string...\n\t\t\t\t\t$sAuthUser = iconv('iso-8859-1', 'utf-8', $sAuthUser);\n\t\t\t\t}\n\t\t\t\t$sAuthPwd = $_SERVER['PHP_AUTH_PW'];\n\t\t\t\tif (!LoginWebPage::LooksLikeUTF8($sAuthPwd))\n\t\t\t\t{\n\t\t\t\t\t// Does not look like and UTF-8 string, try to convert it from iso-8859-1 to UTF-8\n\t\t\t\t\t// Supposed to be harmless in case of a plain ASCII string...\n\t\t\t\t\t$sAuthPwd = iconv('iso-8859-1', 'utf-8', $sAuthPwd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array($sAuthUser, $sAuthPwd);\n\t}\n}\n", "<?php\n\n/**\n * Class LoginExternal\n *\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nclass LoginExternal extends AbstractLoginFSMExtension\n{\n\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('external');\n\t}\n\n\tprotected function OnModeDetection(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']))\n\t\t{\n\t\t\t$sAuthUser = $this->GetAuthUser();\n\t\t\tif ($sAuthUser && (strlen($sAuthUser) > 0))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'external';\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\t$sAuthUser = $this->GetAuthUser();\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, '', $_SESSION['login_mode'], 'external'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\t$sAuthUser = $this->GetAuthUser();\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'external', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = false;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\tLoginWebPage::HTTP401Error();\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @return bool\n\t */\n\tprivate function GetAuthUser()\n\t{\n\t\t$sExtAuthVar = MetaModel::GetConfig()->GetExternalAuthenticationVariable(); // In which variable is the info passed ?\n\t\teval('$sAuthUser = isset('.$sExtAuthVar.') ? '.$sExtAuthVar.' : false;'); // Retrieve the value\n\t\t/** @var string $sAuthUser */\n\t\treturn $sAuthUser; // Retrieve the value\n\t}\n}", "<?php\n\n/**\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\n/**\n * Class LoginForm\n *\n * @since 2.7.0\n */\nclass LoginForm extends AbstractLoginFSMExtension implements iLoginUIExtension\n{\n\tprivate $bForceFormOnError = false;\n\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('form');\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnReadCredentials(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']) || ($_SESSION['login_mode'] == 'form'))\n\t\t{\n\t\t\t$sAuthUser = utils::ReadPostedParam('auth_user', '', 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadPostedParam('auth_pwd', null, 'raw_data');\n\t\t\tif ($this->bForceFormOnError || empty($sAuthUser) || empty($sAuthPwd))\n\t\t\t{\n\t\t\t\tif (array_key_exists('HTTP_X_COMBODO_AJAX', $_SERVER))\n\t\t\t\t{\n\t\t\t\t\t// X-Combodo-Ajax is a special header automatically added to all ajax requests\n\t\t\t\t\t// Let's reply that we're currently logged-out\n\t\t\t\t\theader('HTTP/1.0 401 Unauthorized');\n\t\t\t\t\texit;\n\t\t\t\t}\n\n\t\t\t\t// No credentials yet, display the form\n\t\t\t\t$oPage = LoginWebPage::NewLoginWebPage();\n\t\t\t\t$oPage->DisplayLoginForm($this->bForceFormOnError);\n\t\t\t\t$oPage->output();\n\t\t\t\t$this->bForceFormOnError = false;\n\t\t\t\texit;\n\t\t\t}\n\n\t\t\t$_SESSION['login_temp_auth_user'] =  $sAuthUser;\n\t\t\t$_SESSION['login_mode'] = 'form';\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\t$sAuthUser = utils::ReadPostedParam('auth_user', '', 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadPostedParam('auth_pwd', null, 'raw_data');\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, $sAuthPwd, $_SESSION['login_mode'], 'internal'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\tif (isset($_SESSION['auth_user']))\n\t\t\t{\n\t\t\t\t// If FSM reenter this state (example 2FA) then the auth_user is not resubmitted\n\t\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$sAuthUser = utils::ReadPostedParam('auth_user', '', 'raw_data');\n\t\t\t}\n\t\t\t// Store 'auth_user' in session for further use\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'internal', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\t$this->bForceFormOnError = true;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = true;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @throws \\Exception\n\t */\n\tpublic function GetTwigContext()\n\t{\n\t\t$oLoginContext = new LoginTwigContext();\n\t\t$oLoginContext->AddPostedVar('auth_user');\n\t\t$oLoginContext->AddPostedVar('auth_pwd');\n\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', true, 'raw_data');\n\t\t$sAuthPwd = utils::ReadParam('suggest_pwd', '', true, 'raw_data');\n\n\t\t$aData = array(\n\t\t\t'sAuthUser' => $sAuthUser,\n\t\t\t'sAuthPwd' => $sAuthPwd,\n\t\t);\n\t\t$oLoginContext->AddBlockExtension('login_input', new LoginBlockExtension('extensionblock/loginforminput.html.twig', $aData));\n\t\t$oLoginContext->AddBlockExtension('login_submit', new LoginBlockExtension('extensionblock/loginformsubmit.html.twig'));\n\t\t$oLoginContext->AddBlockExtension('login_form_footer', new LoginBlockExtension('extensionblock/loginformfooter.html.twig'));\n\n\t\t$bEnableResetPassword = MetaModel::GetConfig()->Get('forgot_password');\n\t\t$sResetPasswordUrl = utils::GetAbsoluteUrlAppRoot() . 'pages/UI.php?loginop=forgot_pwd';\n\t\t$aData = array(\n\t\t\t'bEnableResetPassword' => $bEnableResetPassword,\n\t\t\t'sResetPasswordUrl' => $sResetPasswordUrl,\n\t\t);\n\t\t$oLoginContext->AddBlockExtension('login_links', new LoginBlockExtension('extensionblock/loginformlinks.html.twig', $aData));\n\n\t\treturn $oLoginContext;\n\t}\n}\n", "<?php\n\n/**\n * Class LoginURL\n *\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nclass LoginURL extends AbstractLoginFSMExtension\n{\n\t/**\n\t * @var bool\n\t */\n\tprivate $bErrorOccurred = false;\n\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('url');\n\t}\n\n\tprotected function OnModeDetection(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']) && !$this->bErrorOccurred)\n\t\t{\n\t\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadParam('auth_pwd', null, false, 'raw_data');\n\t\t\tif (!empty($sAuthUser) && !empty($sAuthPwd))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'url';\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnReadCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$_SESSION['login_temp_auth_user'] =  utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadParam('auth_pwd', null, false, 'raw_data');\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, $sAuthPwd, $_SESSION['login_mode'], 'internal'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'internal', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$this->bErrorOccurred = true;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = true;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n}"], "fixing_code": ["<?php\n/**\n * Class LoginBasic\n *\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nclass LoginBasic extends AbstractLoginFSMExtension\n{\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('basic');\n\t}\n\n\tprotected function OnModeDetection(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']))\n\t\t{\n\t\t\tif (isset($_SERVER['HTTP_AUTHORIZATION']) && !empty($_SERVER['HTTP_AUTHORIZATION']))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'basic';\n\t\t\t}\n\t\t\telseif (isset($_SERVER['REDIRECT_HTTP_AUTHORIZATION']) && !empty($_SERVER['REDIRECT_HTTP_AUTHORIZATION']))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'basic';\n\t\t\t}\n\t\t\telseif (isset($_SERVER['PHP_AUTH_USER']))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'basic';\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnReadCredentials(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']) || $_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\tlist($sAuthUser, $sAuthPwd) = $this->GetAuthUserAndPassword();\n\t\t\t$_SESSION['login_temp_auth_user'] =  $sAuthUser;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\tlist($sAuthUser, $sAuthPwd) = $this->GetAuthUserAndPassword();\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, $sAuthPwd, $_SESSION['login_mode'], 'internal'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t\t// Save the checked user\n\t\t\t$_SESSION['auth_user'] = $sAuthUser;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'internal', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\tLoginWebPage::HTTP401Error();\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'basic')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = true;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprivate function GetAuthUserAndPassword()\n\t{\n\t\t$sAuthUser = '';\n\t\t$sAuthPwd = null;\n\t\t$sAuthorization = '';\n\t\tif (isset($_SERVER['HTTP_AUTHORIZATION']) && !empty($_SERVER['HTTP_AUTHORIZATION']))\n\t\t{\n\t\t\t$sAuthorization = $_SERVER['HTTP_AUTHORIZATION'];\n\t\t}\n\t\telseif (isset($_SERVER['REDIRECT_HTTP_AUTHORIZATION']) && !empty($_SERVER['REDIRECT_HTTP_AUTHORIZATION']))\n\t\t{\n\t\t\t$sAuthorization = $_SERVER['REDIRECT_HTTP_AUTHORIZATION'];\n\t\t}\n\n\t\tif (!empty($sAuthorization))\n\t\t{\n\t\t\tlist($sAuthUser, $sAuthPwd) = explode(':', base64_decode(substr($sAuthorization, 6)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (isset($_SERVER['PHP_AUTH_USER']))\n\t\t\t{\n\t\t\t\t$sAuthUser = $_SERVER['PHP_AUTH_USER'];\n\t\t\t\t// Unfortunately, the RFC is not clear about the encoding...\n\t\t\t\t// IE and FF supply the user and password encoded in ISO-8859-1 whereas Chrome provides them encoded in UTF-8\n\t\t\t\t// So let's try to guess if it's an UTF-8 string or not... fortunately all encodings share the same ASCII base\n\t\t\t\tif (!LoginWebPage::LooksLikeUTF8($sAuthUser))\n\t\t\t\t{\n\t\t\t\t\t// Does not look like and UTF-8 string, try to convert it from iso-8859-1 to UTF-8\n\t\t\t\t\t// Supposed to be harmless in case of a plain ASCII string...\n\t\t\t\t\t$sAuthUser = iconv('iso-8859-1', 'utf-8', $sAuthUser);\n\t\t\t\t}\n\t\t\t\t$sAuthPwd = $_SERVER['PHP_AUTH_PW'];\n\t\t\t\tif (!LoginWebPage::LooksLikeUTF8($sAuthPwd))\n\t\t\t\t{\n\t\t\t\t\t// Does not look like and UTF-8 string, try to convert it from iso-8859-1 to UTF-8\n\t\t\t\t\t// Supposed to be harmless in case of a plain ASCII string...\n\t\t\t\t\t$sAuthPwd = iconv('iso-8859-1', 'utf-8', $sAuthPwd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array($sAuthUser, $sAuthPwd);\n\t}\n}\n", "<?php\n\n/**\n * Class LoginExternal\n *\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nclass LoginExternal extends AbstractLoginFSMExtension\n{\n\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('external');\n\t}\n\n\tprotected function OnModeDetection(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']))\n\t\t{\n\t\t\t$sAuthUser = $this->GetAuthUser();\n\t\t\tif ($sAuthUser && (strlen($sAuthUser) > 0))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'external';\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\t$sAuthUser = $this->GetAuthUser();\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, '', $_SESSION['login_mode'], 'external'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t\t// Save the checked user\n\t\t\t$_SESSION['auth_user'] = $sAuthUser;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'external', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = false;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'external')\n\t\t{\n\t\t\tLoginWebPage::HTTP401Error();\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @return bool\n\t */\n\tprivate function GetAuthUser()\n\t{\n\t\t$sExtAuthVar = MetaModel::GetConfig()->GetExternalAuthenticationVariable(); // In which variable is the info passed ?\n\t\teval('$sAuthUser = isset('.$sExtAuthVar.') ? '.$sExtAuthVar.' : false;'); // Retrieve the value\n\t\t/** @var string $sAuthUser */\n\t\treturn $sAuthUser; // Retrieve the value\n\t}\n}", "<?php\n\n/**\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\n/**\n * Class LoginForm\n *\n * @since 2.7.0\n */\nclass LoginForm extends AbstractLoginFSMExtension implements iLoginUIExtension\n{\n\tprivate $bForceFormOnError = false;\n\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('form');\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnReadCredentials(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']) || ($_SESSION['login_mode'] == 'form'))\n\t\t{\n\t\t\t$sAuthUser = utils::ReadPostedParam('auth_user', '', 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadPostedParam('auth_pwd', null, 'raw_data');\n\t\t\tif ($this->bForceFormOnError || empty($sAuthUser) || empty($sAuthPwd))\n\t\t\t{\n\t\t\t\tif (array_key_exists('HTTP_X_COMBODO_AJAX', $_SERVER))\n\t\t\t\t{\n\t\t\t\t\t// X-Combodo-Ajax is a special header automatically added to all ajax requests\n\t\t\t\t\t// Let's reply that we're currently logged-out\n\t\t\t\t\theader('HTTP/1.0 401 Unauthorized');\n\t\t\t\t\texit;\n\t\t\t\t}\n\n\t\t\t\t// No credentials yet, display the form\n\t\t\t\t$oPage = LoginWebPage::NewLoginWebPage();\n\t\t\t\t$oPage->DisplayLoginForm($this->bForceFormOnError);\n\t\t\t\t$oPage->output();\n\t\t\t\t$this->bForceFormOnError = false;\n\t\t\t\texit;\n\t\t\t}\n\n\t\t\t$_SESSION['login_temp_auth_user'] =  $sAuthUser;\n\t\t\t$_SESSION['login_mode'] = 'form';\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\t$sAuthUser = utils::ReadPostedParam('auth_user', '', 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadPostedParam('auth_pwd', null, 'raw_data');\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, $sAuthPwd, $_SESSION['login_mode'], 'internal'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t\t// Save the checked user\n\t\t\t$_SESSION['auth_user'] = $sAuthUser;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\t// Store 'auth_user' in session for further use\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'internal', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\t$this->bForceFormOnError = true;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'form')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = true;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @throws \\Exception\n\t */\n\tpublic function GetTwigContext()\n\t{\n\t\t$oLoginContext = new LoginTwigContext();\n\t\t$oLoginContext->AddPostedVar('auth_user');\n\t\t$oLoginContext->AddPostedVar('auth_pwd');\n\n\t\t$sAuthUser = utils::ReadParam('auth_user', '', true, 'raw_data');\n\t\t$sAuthPwd = utils::ReadParam('suggest_pwd', '', true, 'raw_data');\n\n\t\t$aData = array(\n\t\t\t'sAuthUser' => $sAuthUser,\n\t\t\t'sAuthPwd' => $sAuthPwd,\n\t\t);\n\t\t$oLoginContext->AddBlockExtension('login_input', new LoginBlockExtension('extensionblock/loginforminput.html.twig', $aData));\n\t\t$oLoginContext->AddBlockExtension('login_submit', new LoginBlockExtension('extensionblock/loginformsubmit.html.twig'));\n\t\t$oLoginContext->AddBlockExtension('login_form_footer', new LoginBlockExtension('extensionblock/loginformfooter.html.twig'));\n\n\t\t$bEnableResetPassword = MetaModel::GetConfig()->Get('forgot_password');\n\t\t$sResetPasswordUrl = utils::GetAbsoluteUrlAppRoot() . 'pages/UI.php?loginop=forgot_pwd';\n\t\t$aData = array(\n\t\t\t'bEnableResetPassword' => $bEnableResetPassword,\n\t\t\t'sResetPasswordUrl' => $sResetPasswordUrl,\n\t\t);\n\t\t$oLoginContext->AddBlockExtension('login_links', new LoginBlockExtension('extensionblock/loginformlinks.html.twig', $aData));\n\n\t\treturn $oLoginContext;\n\t}\n}\n", "<?php\n\n/**\n * Class LoginURL\n *\n * @copyright   Copyright (C) 2010-2019 Combodo SARL\n * @license     http://opensource.org/licenses/AGPL-3.0\n */\n\nclass LoginURL extends AbstractLoginFSMExtension\n{\n\t/**\n\t * @var bool\n\t */\n\tprivate $bErrorOccurred = false;\n\n\t/**\n\t * Return the list of supported login modes for this plugin\n\t *\n\t * @return array of supported login modes\n\t */\n\tpublic function ListSupportedLoginModes()\n\t{\n\t\treturn array('url');\n\t}\n\n\tprotected function OnModeDetection(&$iErrorCode)\n\t{\n\t\tif (!isset($_SESSION['login_mode']) && !$this->bErrorOccurred)\n\t\t{\n\t\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadParam('auth_pwd', null, false, 'raw_data');\n\t\t\tif (!empty($sAuthUser) && !empty($sAuthPwd))\n\t\t\t{\n\t\t\t\t$_SESSION['login_mode'] = 'url';\n\t\t\t}\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnReadCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$_SESSION['login_temp_auth_user'] =  utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCheckCredentials(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$sAuthUser = utils::ReadParam('auth_user', '', false, 'raw_data');\n\t\t\t$sAuthPwd = utils::ReadParam('auth_pwd', null, false, 'raw_data');\n\t\t\tif (!UserRights::CheckCredentials($sAuthUser, $sAuthPwd, $_SESSION['login_mode'], 'internal'))\n\t\t\t{\n\t\t\t\t$iErrorCode = LoginWebPage::EXIT_CODE_WRONGCREDENTIALS;\n\t\t\t\treturn LoginWebPage::LOGIN_FSM_ERROR;\n\t\t\t}\n\t\t\t// Save the checked user\n\t\t\t$_SESSION['auth_user'] = $sAuthUser;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnCredentialsOK(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$sAuthUser = $_SESSION['auth_user'];\n\t\t\tLoginWebPage::OnLoginSuccess($sAuthUser, 'internal', $_SESSION['login_mode']);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnError(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$this->bErrorOccurred = true;\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n\n\tprotected function OnConnected(&$iErrorCode)\n\t{\n\t\tif ($_SESSION['login_mode'] == 'url')\n\t\t{\n\t\t\t$_SESSION['can_logoff'] = true;\n\t\t\treturn LoginWebPage::CheckLoggedUser($iErrorCode);\n\t\t}\n\t\treturn LoginWebPage::LOGIN_FSM_CONTINUE;\n\t}\n}"], "filenames": ["application/loginbasic.class.inc.php", "application/loginexternal.class.inc.php", "application/loginform.class.inc.php", "application/loginurl.class.inc.php"], "buggy_code_start_loc": [61, 45, 73, 60], "buggy_code_end_loc": [71, 55, 94, 70], "fixing_code_start_loc": [62, 46, 74, 61], "fixing_code_end_loc": [73, 57, 88, 72], "type": "CWE-863", "message": "Combodo iTop is an open source, web-based IT service management platform. Prior to versions 2.7.8 and 3.0.2-1, a user who can log in on iTop is able to take over any account just by knowing the account's username. This issue is fixed in versions 2.7.8 and 3.0.2-1.", "other": {"cve": {"id": "CVE-2022-39214", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-14T16:15:10.277", "lastModified": "2023-03-18T03:52:45.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Combodo iTop is an open source, web-based IT service management platform. Prior to versions 2.7.8 and 3.0.2-1, a user who can log in on iTop is able to take over any account just by knowing the account's username. This issue is fixed in versions 2.7.8 and 3.0.2-1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.8", "matchCriteriaId": "B6FFC841-DFF5-49DE-9B60-51CB5F979693"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:*:*:*:*:*:*:*:*", "versionStartExcluding": "3.0.0", "versionEndExcluding": "3.0.2-1", "matchCriteriaId": "BFD5F02C-2718-439E-AA59-6E1A0B18B024"}]}]}], "references": [{"url": "https://github.com/Combodo/iTop/commit/4c1df9927d1dc6b0181ee20721f93346def026fd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Combodo/iTop/commit/bdebea62b642622ed71410b26c81e8537e6e58fa", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Combodo/iTop/security/advisories/GHSA-vj96-j84g-jhx4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Combodo/iTop/commit/4c1df9927d1dc6b0181ee20721f93346def026fd"}}