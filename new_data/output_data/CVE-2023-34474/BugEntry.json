{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               PPPP   RRRR    OOO   FFFFF  IIIII  L      EEEEE               %\n%               P   P  R   R  O   O  F        I    L      E                   %\n%               PPPP   RRRR   O   O  FFF      I    L      EEE                 %\n%               P      R R    O   O  F        I    L      E                   %\n%               P      R  R    OOO   F      IIIII  LLLLL  EEEEE               %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Image Profile Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#include <wchar.h>\n#if defined(MAGICKCORE_HAVE_LCMS_LCMS2_H)\n#include <lcms/lcms2.h>\n#else\n#include \"lcms2.h\"\n#endif\n#endif\n#if defined(MAGICKCORE_XML_DELEGATE)\n#  include <libxml/parser.h>\n#  include <libxml/tree.h>\n#endif\n\f\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  SetImageProfileInternal(Image *,const char *,const StringInfo *,\n    const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  WriteTo8BimProfile(Image *,const char*,const StringInfo *);\n\f\n/*\n  Typedef declarations\n*/\nstruct _ProfileInfo\n{\n  char\n    *name;\n\n  size_t\n    length;\n\n  unsigned char\n    *info;\n\n  size_t\n    signature;\n};\n\ntypedef struct _CMSExceptionInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} CMSExceptionInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o f i l e s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProfiles() clones one or more image profiles.\n%\n%  The format of the CloneImageProfiles method is:\n%\n%      MagickBooleanType CloneImageProfiles(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProfiles(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (clone_image->profiles != (void *) NULL)\n    {\n      if (image->profiles != (void *) NULL)\n        DestroyImageProfiles(image);\n      image->profiles=CloneSplayTree((SplayTreeInfo *) clone_image->profiles,\n        (void *(*)(void *)) ConstantString,(void *(*)(void *)) CloneStringInfo);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProfile() deletes a profile from the image by its name.\n%\n%  The format of the DeleteImageProfile method is:\n%\n%      MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return(MagickFalse);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->profiles,name));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o f i l e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProfiles() releases memory associated with an image profile map.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      void DestroyImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProfiles(Image *image)\n{\n  if (image->profiles != (SplayTreeInfo *) NULL)\n    image->profiles=DestroySplayTree((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProfile() gets a profile associated with an image by name.\n%\n%  The format of the GetImageProfile method is:\n%\n%      const StringInfo *GetImageProfile(const Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport const StringInfo *GetImageProfile(const Image *image,\n  const char *name)\n{\n  const StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  profile=(const StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o f i l e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProfile() gets the next profile name for an image.\n%\n%  The format of the GetNextImageProfile method is:\n%\n%      char *GetNextImageProfile(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o hash_info: the hash info.\n%\n*/\nMagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P r o f i l e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProfileImage() associates, applies, or removes an ICM, IPTC, or generic\n%  profile with / to / from an image.  If the profile is NULL, it is removed\n%  from the image otherwise added or applied.  Use a name of '*' and a profile\n%  of NULL to remove all profiles from the image.\n%\n%  ICC and ICM profiles are handled as follows: If the image does not have\n%  an associated color profile, the one you provide is associated with the\n%  image and the image pixels are not transformed.  Otherwise, the colorspace\n%  transform defined by the existing and new profile are applied to the image\n%  pixels and the new profile is associated with the image.\n%\n%  The format of the ProfileImage method is:\n%\n%      MagickBooleanType ProfileImage(Image *image,const char *name,\n%        const void *datum,const size_t length,const MagickBooleanType clone)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: Name of profile to add or remove: ICC, IPTC, or generic profile.\n%\n%    o datum: the profile data.\n%\n%    o length: the length of the profile.\n%\n%    o clone: should be MagickFalse.\n%\n*/\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n\ntypedef struct _LCMSInfo\n{\n  ColorspaceType\n    colorspace;\n\n  cmsUInt32Number\n    type;\n\n  size_t\n    channels;\n\n  cmsHPROFILE\n    profile;\n\n  int\n    intent;\n\n  double\n    scale[4],\n    translate[4];\n\n  void\n    **magick_restrict pixels;\n} LCMSInfo;\n\n#if LCMS_VERSION < 2060\nstatic void* cmsGetContextUserData(cmsContext ContextID)\n{\n  return(ContextID);\n}\n\nstatic cmsContext cmsCreateContext(void *magick_unused(Plugin),void *UserData)\n{\n  magick_unreferenced(Plugin);\n  return((cmsContext) UserData);\n}\n\nstatic void cmsSetLogErrorHandlerTHR(cmsContext magick_unused(ContextID),\n  cmsLogErrorHandlerFunction Fn)\n{\n  magick_unreferenced(ContextID);\n  cmsSetLogErrorHandler(Fn);\n}\n\nstatic void cmsDeleteContext(cmsContext magick_unused(ContextID))\n{\n  magick_unreferenced(ContextID);\n}\n#endif\n\nstatic void **DestroyPixelTLS(void **pixels)\n{\n  ssize_t\n    i;\n\n  if (pixels == (void **) NULL)\n    return((void **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (void *) NULL)\n      pixels[i]=RelinquishMagickMemory(pixels[i]);\n  pixels=(void **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic void **AcquirePixelTLS(const size_t columns,const size_t channels,\n  MagickBooleanType highres)\n{\n  ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  size_t\n    size;\n\n  void\n    **pixels;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(void **) AcquireQuantumMemory(number_threads,sizeof(*pixels));\n  if (pixels == (void **) NULL)\n    return((void **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  size=sizeof(double);\n  if (highres == MagickFalse)\n    size=sizeof(Quantum);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=AcquireQuantumMemory(columns,channels*size);\n    if (pixels[i] == (void *) NULL)\n      return(DestroyPixelTLS(pixels));\n  }\n  return(pixels);\n}\n\nstatic cmsHTRANSFORM *DestroyTransformTLS(cmsHTRANSFORM *transform)\n{\n  ssize_t\n    i;\n\n  assert(transform != (cmsHTRANSFORM *) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (transform[i] != (cmsHTRANSFORM) NULL)\n      cmsDeleteTransform(transform[i]);\n  transform=(cmsHTRANSFORM *) RelinquishMagickMemory(transform);\n  return(transform);\n}\n\nstatic cmsHTRANSFORM *AcquireTransformTLS(const LCMSInfo *source_info,\n  const LCMSInfo *target_info,const cmsUInt32Number flags,\n  cmsContext cms_context)\n{\n  cmsHTRANSFORM\n    *transform;\n\n  size_t\n    number_threads;\n\n  ssize_t\n    i;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  transform=(cmsHTRANSFORM *) AcquireQuantumMemory(number_threads,\n    sizeof(*transform));\n  if (transform == (cmsHTRANSFORM *) NULL)\n    return((cmsHTRANSFORM *) NULL);\n  (void) memset(transform,0,number_threads*sizeof(*transform));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    transform[i]=cmsCreateTransformTHR(cms_context,source_info->profile,\n      source_info->type,target_info->profile,target_info->type,\n      target_info->intent,flags);\n    if (transform[i] == (cmsHTRANSFORM) NULL)\n      return(DestroyTransformTLS(transform));\n  }\n  return(transform);\n}\n\nstatic void CMSExceptionHandler(cmsContext context,cmsUInt32Number severity,\n  const char *message)\n{\n  CMSExceptionInfo\n    *cms_exception;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  cms_exception=(CMSExceptionInfo *) cmsGetContextUserData(context);\n  if (cms_exception == (CMSExceptionInfo *) NULL)\n    return;\n  exception=cms_exception->exception;\n  if (exception == (ExceptionInfo *) NULL)\n    return;\n  image=cms_exception->image;\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"UnableToTransformColorspace\",\"`%s'\",\"unknown context\");\n      return;\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"lcms: #%u, %s\",\n      severity,message != (char *) NULL ? message : \"no message\");\n  (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n    \"UnableToTransformColorspace\",\"`%s', %s (#%u)\",image->filename,\n    message != (char *) NULL ? message : \"no message\",severity);\n}\n\nstatic void TransformDoublePixels(const int id,const Image* image,\n  const LCMSInfo *source_info,const LCMSInfo *target_info,\n  const cmsHTRANSFORM *transform,Quantum *q)\n{\n#define GetLCMSPixel(source_info,pixel,index) \\\n  (source_info->scale[index]*((QuantumScale*pixel)+source_info->translate[index]))\n#define SetLCMSPixel(target_info,pixel,index) \\\n  ClampToQuantum(target_info->scale[index]*((QuantumRange*pixel)+target_info->translate[index]))\n\n  double\n    *p;\n\n  ssize_t\n    x;\n\n  p=(double *) source_info->pixels[id];\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    *p++=GetLCMSPixel(source_info,GetPixelRed(image,q),0);\n    if (source_info->channels > 1)\n      {\n        *p++=GetLCMSPixel(source_info,GetPixelGreen(image,q),1);\n        *p++=GetLCMSPixel(source_info,GetPixelBlue(image,q),2);\n      }\n    if (source_info->channels > 3)\n      *p++=GetLCMSPixel(source_info,GetPixelBlack(image,q),3);\n    q+=GetPixelChannels(image);\n  }\n  cmsDoTransform(transform[id],source_info->pixels[id],target_info->pixels[id],\n    (unsigned int) image->columns);\n  p=(double *) target_info->pixels[id];\n  q-=GetPixelChannels(image)*image->columns;\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (target_info->channels == 1)\n      SetPixelGray(image,SetLCMSPixel(target_info,*p,0),q);\n    else\n      SetPixelRed(image,SetLCMSPixel(target_info,*p,0),q);\n    p++;\n    if (target_info->channels > 1)\n      {\n        SetPixelGreen(image,SetLCMSPixel(target_info,*p,1),q);\n        p++;\n        SetPixelBlue(image,SetLCMSPixel(target_info,*p,2),q);\n        p++;\n      }\n    if (target_info->channels > 3)\n      {\n        SetPixelBlack(image,SetLCMSPixel(target_info,*p,3),q);\n        p++;\n      }\n    q+=GetPixelChannels(image);\n  }\n}\n\nstatic void TransformQuantumPixels(const int id,const Image* image,\n  const LCMSInfo *source_info,const LCMSInfo *target_info,\n  const cmsHTRANSFORM *transform,Quantum *q)\n{\n  Quantum\n    *p;\n\n  ssize_t\n    x;\n\n  p=(Quantum *) source_info->pixels[id];\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    *p++=GetPixelRed(image,q);\n    if (source_info->channels > 1)\n      {\n        *p++=GetPixelGreen(image,q);\n        *p++=GetPixelBlue(image,q);\n      }\n    if (source_info->channels > 3)\n      *p++=GetPixelBlack(image,q);\n    q+=GetPixelChannels(image);\n  }\n  cmsDoTransform(transform[id],source_info->pixels[id],target_info->pixels[id],\n    (unsigned int) image->columns);\n  p=(Quantum *) target_info->pixels[id];\n  q-=GetPixelChannels(image)*image->columns;\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (target_info->channels == 1)\n      SetPixelGray(image,*p++,q);\n    else\n      SetPixelRed(image,*p++,q);\n    if (target_info->channels > 1)\n      {\n        SetPixelGreen(image,*p++,q);\n        SetPixelBlue(image,*p++,q);\n      }\n    if (target_info->channels > 3)\n      SetPixelBlack(image,*p++,q);\n    q+=GetPixelChannels(image);\n  }\n}\n\nstatic inline void SetLCMSInfoTranslate(LCMSInfo *info,const double translate)\n{\n  info->translate[0]=translate;\n  info->translate[1]=translate;\n  info->translate[2]=translate;\n  info->translate[3]=translate;\n}\n\nstatic inline void SetLCMSInfoScale(LCMSInfo *info,const double scale)\n{\n  info->scale[0]=scale;\n  info->scale[1]=scale;\n  info->scale[2]=scale;\n  info->scale[3]=scale;\n}\n#endif\n\nstatic MagickBooleanType SetsRGBImageProfile(Image *image,\n  ExceptionInfo *exception)\n{\n  static unsigned char\n    sRGBProfile[] =\n    {\n      0x00, 0x00, 0x0c, 0x8c, 0x61, 0x72, 0x67, 0x6c, 0x02, 0x20, 0x00, 0x00,\n      0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20,\n      0x07, 0xde, 0x00, 0x01, 0x00, 0x06, 0x00, 0x16, 0x00, 0x0f, 0x00, 0x3a,\n      0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,\n      0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xd6,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d, 0x61, 0x72, 0x67, 0x6c,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x99,\n      0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0xec, 0x00, 0x00, 0x00, 0x67,\n      0x64, 0x6d, 0x6e, 0x64, 0x00, 0x00, 0x02, 0x54, 0x00, 0x00, 0x00, 0x70,\n      0x64, 0x6d, 0x64, 0x64, 0x00, 0x00, 0x02, 0xc4, 0x00, 0x00, 0x00, 0x88,\n      0x74, 0x65, 0x63, 0x68, 0x00, 0x00, 0x03, 0x4c, 0x00, 0x00, 0x00, 0x0c,\n      0x76, 0x75, 0x65, 0x64, 0x00, 0x00, 0x03, 0x58, 0x00, 0x00, 0x00, 0x67,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x24,\n      0x6c, 0x75, 0x6d, 0x69, 0x00, 0x00, 0x03, 0xe4, 0x00, 0x00, 0x00, 0x14,\n      0x6d, 0x65, 0x61, 0x73, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x24,\n      0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x6b, 0x70, 0x74, 0x00, 0x00, 0x04, 0x30, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x44, 0x00, 0x00, 0x00, 0x14,\n      0x67, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x58, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x6c, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,\n      0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36,\n      0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75, 0x69, 0x76,\n      0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x77, 0x77,\n      0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20, 0x31, 0x39,\n      0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c,\n      0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x3f, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31,\n      0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75,\n      0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77,\n      0x77, 0x77, 0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20,\n      0x31, 0x39, 0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66,\n      0x69, 0x6c, 0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x72, 0x65, 0x61,\n      0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x47, 0x72, 0x61, 0x65, 0x6d,\n      0x65, 0x20, 0x57, 0x2e, 0x20, 0x47, 0x69, 0x6c, 0x6c, 0x2e, 0x20, 0x52,\n      0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f,\n      0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,\n      0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x4e, 0x6f, 0x20, 0x57,\n      0x61, 0x72, 0x72, 0x61, 0x6e, 0x74, 0x79, 0x2c, 0x20, 0x55, 0x73, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6f, 0x77, 0x6e,\n      0x20, 0x72, 0x69, 0x73, 0x6b, 0x2e, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20,\n      0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69,\n      0x65, 0x63, 0x2e, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74,\n      0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e,\n      0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,\n      0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e,\n      0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47,\n      0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61,\n      0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x45, 0x43,\n      0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44,\n      0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63,\n      0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,\n      0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x73, 0x69, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x43, 0x52, 0x54, 0x20, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xa4, 0x7c,\n      0x00, 0x14, 0x5f, 0x30, 0x00, 0x10, 0xce, 0x02, 0x00, 0x03, 0xed, 0xb2,\n      0x00, 0x04, 0x13, 0x0a, 0x00, 0x03, 0x5c, 0x67, 0x00, 0x00, 0x00, 0x01,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x0a, 0x3d,\n      0x00, 0x50, 0x00, 0x00, 0x00, 0x57, 0x1e, 0xb8, 0x6d, 0x65, 0x61, 0x73,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x02, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x51, 0x00, 0x01, 0x00, 0x00,\n      0x00, 0x01, 0x16, 0xcc, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa0,\n      0x00, 0x00, 0x38, 0xf5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x97, 0x00, 0x00, 0xb7, 0x87,\n      0x00, 0x00, 0x18, 0xd9, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x24, 0x9f, 0x00, 0x00, 0x0f, 0x84, 0x00, 0x00, 0xb6, 0xc4,\n      0x63, 0x75, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n      0x00, 0x00, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x14, 0x00, 0x19,\n      0x00, 0x1e, 0x00, 0x23, 0x00, 0x28, 0x00, 0x2d, 0x00, 0x32, 0x00, 0x37,\n      0x00, 0x3b, 0x00, 0x40, 0x00, 0x45, 0x00, 0x4a, 0x00, 0x4f, 0x00, 0x54,\n      0x00, 0x59, 0x00, 0x5e, 0x00, 0x63, 0x00, 0x68, 0x00, 0x6d, 0x00, 0x72,\n      0x00, 0x77, 0x00, 0x7c, 0x00, 0x81, 0x00, 0x86, 0x00, 0x8b, 0x00, 0x90,\n      0x00, 0x95, 0x00, 0x9a, 0x00, 0x9f, 0x00, 0xa4, 0x00, 0xa9, 0x00, 0xae,\n      0x00, 0xb2, 0x00, 0xb7, 0x00, 0xbc, 0x00, 0xc1, 0x00, 0xc6, 0x00, 0xcb,\n      0x00, 0xd0, 0x00, 0xd5, 0x00, 0xdb, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0xeb,\n      0x00, 0xf0, 0x00, 0xf6, 0x00, 0xfb, 0x01, 0x01, 0x01, 0x07, 0x01, 0x0d,\n      0x01, 0x13, 0x01, 0x19, 0x01, 0x1f, 0x01, 0x25, 0x01, 0x2b, 0x01, 0x32,\n      0x01, 0x38, 0x01, 0x3e, 0x01, 0x45, 0x01, 0x4c, 0x01, 0x52, 0x01, 0x59,\n      0x01, 0x60, 0x01, 0x67, 0x01, 0x6e, 0x01, 0x75, 0x01, 0x7c, 0x01, 0x83,\n      0x01, 0x8b, 0x01, 0x92, 0x01, 0x9a, 0x01, 0xa1, 0x01, 0xa9, 0x01, 0xb1,\n      0x01, 0xb9, 0x01, 0xc1, 0x01, 0xc9, 0x01, 0xd1, 0x01, 0xd9, 0x01, 0xe1,\n      0x01, 0xe9, 0x01, 0xf2, 0x01, 0xfa, 0x02, 0x03, 0x02, 0x0c, 0x02, 0x14,\n      0x02, 0x1d, 0x02, 0x26, 0x02, 0x2f, 0x02, 0x38, 0x02, 0x41, 0x02, 0x4b,\n      0x02, 0x54, 0x02, 0x5d, 0x02, 0x67, 0x02, 0x71, 0x02, 0x7a, 0x02, 0x84,\n      0x02, 0x8e, 0x02, 0x98, 0x02, 0xa2, 0x02, 0xac, 0x02, 0xb6, 0x02, 0xc1,\n      0x02, 0xcb, 0x02, 0xd5, 0x02, 0xe0, 0x02, 0xeb, 0x02, 0xf5, 0x03, 0x00,\n      0x03, 0x0b, 0x03, 0x16, 0x03, 0x21, 0x03, 0x2d, 0x03, 0x38, 0x03, 0x43,\n      0x03, 0x4f, 0x03, 0x5a, 0x03, 0x66, 0x03, 0x72, 0x03, 0x7e, 0x03, 0x8a,\n      0x03, 0x96, 0x03, 0xa2, 0x03, 0xae, 0x03, 0xba, 0x03, 0xc7, 0x03, 0xd3,\n      0x03, 0xe0, 0x03, 0xec, 0x03, 0xf9, 0x04, 0x06, 0x04, 0x13, 0x04, 0x20,\n      0x04, 0x2d, 0x04, 0x3b, 0x04, 0x48, 0x04, 0x55, 0x04, 0x63, 0x04, 0x71,\n      0x04, 0x7e, 0x04, 0x8c, 0x04, 0x9a, 0x04, 0xa8, 0x04, 0xb6, 0x04, 0xc4,\n      0x04, 0xd3, 0x04, 0xe1, 0x04, 0xf0, 0x04, 0xfe, 0x05, 0x0d, 0x05, 0x1c,\n      0x05, 0x2b, 0x05, 0x3a, 0x05, 0x49, 0x05, 0x58, 0x05, 0x67, 0x05, 0x77,\n      0x05, 0x86, 0x05, 0x96, 0x05, 0xa6, 0x05, 0xb5, 0x05, 0xc5, 0x05, 0xd5,\n      0x05, 0xe5, 0x05, 0xf6, 0x06, 0x06, 0x06, 0x16, 0x06, 0x27, 0x06, 0x37,\n      0x06, 0x48, 0x06, 0x59, 0x06, 0x6a, 0x06, 0x7b, 0x06, 0x8c, 0x06, 0x9d,\n      0x06, 0xaf, 0x06, 0xc0, 0x06, 0xd1, 0x06, 0xe3, 0x06, 0xf5, 0x07, 0x07,\n      0x07, 0x19, 0x07, 0x2b, 0x07, 0x3d, 0x07, 0x4f, 0x07, 0x61, 0x07, 0x74,\n      0x07, 0x86, 0x07, 0x99, 0x07, 0xac, 0x07, 0xbf, 0x07, 0xd2, 0x07, 0xe5,\n      0x07, 0xf8, 0x08, 0x0b, 0x08, 0x1f, 0x08, 0x32, 0x08, 0x46, 0x08, 0x5a,\n      0x08, 0x6e, 0x08, 0x82, 0x08, 0x96, 0x08, 0xaa, 0x08, 0xbe, 0x08, 0xd2,\n      0x08, 0xe7, 0x08, 0xfb, 0x09, 0x10, 0x09, 0x25, 0x09, 0x3a, 0x09, 0x4f,\n      0x09, 0x64, 0x09, 0x79, 0x09, 0x8f, 0x09, 0xa4, 0x09, 0xba, 0x09, 0xcf,\n      0x09, 0xe5, 0x09, 0xfb, 0x0a, 0x11, 0x0a, 0x27, 0x0a, 0x3d, 0x0a, 0x54,\n      0x0a, 0x6a, 0x0a, 0x81, 0x0a, 0x98, 0x0a, 0xae, 0x0a, 0xc5, 0x0a, 0xdc,\n      0x0a, 0xf3, 0x0b, 0x0b, 0x0b, 0x22, 0x0b, 0x39, 0x0b, 0x51, 0x0b, 0x69,\n      0x0b, 0x80, 0x0b, 0x98, 0x0b, 0xb0, 0x0b, 0xc8, 0x0b, 0xe1, 0x0b, 0xf9,\n      0x0c, 0x12, 0x0c, 0x2a, 0x0c, 0x43, 0x0c, 0x5c, 0x0c, 0x75, 0x0c, 0x8e,\n      0x0c, 0xa7, 0x0c, 0xc0, 0x0c, 0xd9, 0x0c, 0xf3, 0x0d, 0x0d, 0x0d, 0x26,\n      0x0d, 0x40, 0x0d, 0x5a, 0x0d, 0x74, 0x0d, 0x8e, 0x0d, 0xa9, 0x0d, 0xc3,\n      0x0d, 0xde, 0x0d, 0xf8, 0x0e, 0x13, 0x0e, 0x2e, 0x0e, 0x49, 0x0e, 0x64,\n      0x0e, 0x7f, 0x0e, 0x9b, 0x0e, 0xb6, 0x0e, 0xd2, 0x0e, 0xee, 0x0f, 0x09,\n      0x0f, 0x25, 0x0f, 0x41, 0x0f, 0x5e, 0x0f, 0x7a, 0x0f, 0x96, 0x0f, 0xb3,\n      0x0f, 0xcf, 0x0f, 0xec, 0x10, 0x09, 0x10, 0x26, 0x10, 0x43, 0x10, 0x61,\n      0x10, 0x7e, 0x10, 0x9b, 0x10, 0xb9, 0x10, 0xd7, 0x10, 0xf5, 0x11, 0x13,\n      0x11, 0x31, 0x11, 0x4f, 0x11, 0x6d, 0x11, 0x8c, 0x11, 0xaa, 0x11, 0xc9,\n      0x11, 0xe8, 0x12, 0x07, 0x12, 0x26, 0x12, 0x45, 0x12, 0x64, 0x12, 0x84,\n      0x12, 0xa3, 0x12, 0xc3, 0x12, 0xe3, 0x13, 0x03, 0x13, 0x23, 0x13, 0x43,\n      0x13, 0x63, 0x13, 0x83, 0x13, 0xa4, 0x13, 0xc5, 0x13, 0xe5, 0x14, 0x06,\n      0x14, 0x27, 0x14, 0x49, 0x14, 0x6a, 0x14, 0x8b, 0x14, 0xad, 0x14, 0xce,\n      0x14, 0xf0, 0x15, 0x12, 0x15, 0x34, 0x15, 0x56, 0x15, 0x78, 0x15, 0x9b,\n      0x15, 0xbd, 0x15, 0xe0, 0x16, 0x03, 0x16, 0x26, 0x16, 0x49, 0x16, 0x6c,\n      0x16, 0x8f, 0x16, 0xb2, 0x16, 0xd6, 0x16, 0xfa, 0x17, 0x1d, 0x17, 0x41,\n      0x17, 0x65, 0x17, 0x89, 0x17, 0xae, 0x17, 0xd2, 0x17, 0xf7, 0x18, 0x1b,\n      0x18, 0x40, 0x18, 0x65, 0x18, 0x8a, 0x18, 0xaf, 0x18, 0xd5, 0x18, 0xfa,\n      0x19, 0x20, 0x19, 0x45, 0x19, 0x6b, 0x19, 0x91, 0x19, 0xb7, 0x19, 0xdd,\n      0x1a, 0x04, 0x1a, 0x2a, 0x1a, 0x51, 0x1a, 0x77, 0x1a, 0x9e, 0x1a, 0xc5,\n      0x1a, 0xec, 0x1b, 0x14, 0x1b, 0x3b, 0x1b, 0x63, 0x1b, 0x8a, 0x1b, 0xb2,\n      0x1b, 0xda, 0x1c, 0x02, 0x1c, 0x2a, 0x1c, 0x52, 0x1c, 0x7b, 0x1c, 0xa3,\n      0x1c, 0xcc, 0x1c, 0xf5, 0x1d, 0x1e, 0x1d, 0x47, 0x1d, 0x70, 0x1d, 0x99,\n      0x1d, 0xc3, 0x1d, 0xec, 0x1e, 0x16, 0x1e, 0x40, 0x1e, 0x6a, 0x1e, 0x94,\n      0x1e, 0xbe, 0x1e, 0xe9, 0x1f, 0x13, 0x1f, 0x3e, 0x1f, 0x69, 0x1f, 0x94,\n      0x1f, 0xbf, 0x1f, 0xea, 0x20, 0x15, 0x20, 0x41, 0x20, 0x6c, 0x20, 0x98,\n      0x20, 0xc4, 0x20, 0xf0, 0x21, 0x1c, 0x21, 0x48, 0x21, 0x75, 0x21, 0xa1,\n      0x21, 0xce, 0x21, 0xfb, 0x22, 0x27, 0x22, 0x55, 0x22, 0x82, 0x22, 0xaf,\n      0x22, 0xdd, 0x23, 0x0a, 0x23, 0x38, 0x23, 0x66, 0x23, 0x94, 0x23, 0xc2,\n      0x23, 0xf0, 0x24, 0x1f, 0x24, 0x4d, 0x24, 0x7c, 0x24, 0xab, 0x24, 0xda,\n      0x25, 0x09, 0x25, 0x38, 0x25, 0x68, 0x25, 0x97, 0x25, 0xc7, 0x25, 0xf7,\n      0x26, 0x27, 0x26, 0x57, 0x26, 0x87, 0x26, 0xb7, 0x26, 0xe8, 0x27, 0x18,\n      0x27, 0x49, 0x27, 0x7a, 0x27, 0xab, 0x27, 0xdc, 0x28, 0x0d, 0x28, 0x3f,\n      0x28, 0x71, 0x28, 0xa2, 0x28, 0xd4, 0x29, 0x06, 0x29, 0x38, 0x29, 0x6b,\n      0x29, 0x9d, 0x29, 0xd0, 0x2a, 0x02, 0x2a, 0x35, 0x2a, 0x68, 0x2a, 0x9b,\n      0x2a, 0xcf, 0x2b, 0x02, 0x2b, 0x36, 0x2b, 0x69, 0x2b, 0x9d, 0x2b, 0xd1,\n      0x2c, 0x05, 0x2c, 0x39, 0x2c, 0x6e, 0x2c, 0xa2, 0x2c, 0xd7, 0x2d, 0x0c,\n      0x2d, 0x41, 0x2d, 0x76, 0x2d, 0xab, 0x2d, 0xe1, 0x2e, 0x16, 0x2e, 0x4c,\n      0x2e, 0x82, 0x2e, 0xb7, 0x2e, 0xee, 0x2f, 0x24, 0x2f, 0x5a, 0x2f, 0x91,\n      0x2f, 0xc7, 0x2f, 0xfe, 0x30, 0x35, 0x30, 0x6c, 0x30, 0xa4, 0x30, 0xdb,\n      0x31, 0x12, 0x31, 0x4a, 0x31, 0x82, 0x31, 0xba, 0x31, 0xf2, 0x32, 0x2a,\n      0x32, 0x63, 0x32, 0x9b, 0x32, 0xd4, 0x33, 0x0d, 0x33, 0x46, 0x33, 0x7f,\n      0x33, 0xb8, 0x33, 0xf1, 0x34, 0x2b, 0x34, 0x65, 0x34, 0x9e, 0x34, 0xd8,\n      0x35, 0x13, 0x35, 0x4d, 0x35, 0x87, 0x35, 0xc2, 0x35, 0xfd, 0x36, 0x37,\n      0x36, 0x72, 0x36, 0xae, 0x36, 0xe9, 0x37, 0x24, 0x37, 0x60, 0x37, 0x9c,\n      0x37, 0xd7, 0x38, 0x14, 0x38, 0x50, 0x38, 0x8c, 0x38, 0xc8, 0x39, 0x05,\n      0x39, 0x42, 0x39, 0x7f, 0x39, 0xbc, 0x39, 0xf9, 0x3a, 0x36, 0x3a, 0x74,\n      0x3a, 0xb2, 0x3a, 0xef, 0x3b, 0x2d, 0x3b, 0x6b, 0x3b, 0xaa, 0x3b, 0xe8,\n      0x3c, 0x27, 0x3c, 0x65, 0x3c, 0xa4, 0x3c, 0xe3, 0x3d, 0x22, 0x3d, 0x61,\n      0x3d, 0xa1, 0x3d, 0xe0, 0x3e, 0x20, 0x3e, 0x60, 0x3e, 0xa0, 0x3e, 0xe0,\n      0x3f, 0x21, 0x3f, 0x61, 0x3f, 0xa2, 0x3f, 0xe2, 0x40, 0x23, 0x40, 0x64,\n      0x40, 0xa6, 0x40, 0xe7, 0x41, 0x29, 0x41, 0x6a, 0x41, 0xac, 0x41, 0xee,\n      0x42, 0x30, 0x42, 0x72, 0x42, 0xb5, 0x42, 0xf7, 0x43, 0x3a, 0x43, 0x7d,\n      0x43, 0xc0, 0x44, 0x03, 0x44, 0x47, 0x44, 0x8a, 0x44, 0xce, 0x45, 0x12,\n      0x45, 0x55, 0x45, 0x9a, 0x45, 0xde, 0x46, 0x22, 0x46, 0x67, 0x46, 0xab,\n      0x46, 0xf0, 0x47, 0x35, 0x47, 0x7b, 0x47, 0xc0, 0x48, 0x05, 0x48, 0x4b,\n      0x48, 0x91, 0x48, 0xd7, 0x49, 0x1d, 0x49, 0x63, 0x49, 0xa9, 0x49, 0xf0,\n      0x4a, 0x37, 0x4a, 0x7d, 0x4a, 0xc4, 0x4b, 0x0c, 0x4b, 0x53, 0x4b, 0x9a,\n      0x4b, 0xe2, 0x4c, 0x2a, 0x4c, 0x72, 0x4c, 0xba, 0x4d, 0x02, 0x4d, 0x4a,\n      0x4d, 0x93, 0x4d, 0xdc, 0x4e, 0x25, 0x4e, 0x6e, 0x4e, 0xb7, 0x4f, 0x00,\n      0x4f, 0x49, 0x4f, 0x93, 0x4f, 0xdd, 0x50, 0x27, 0x50, 0x71, 0x50, 0xbb,\n      0x51, 0x06, 0x51, 0x50, 0x51, 0x9b, 0x51, 0xe6, 0x52, 0x31, 0x52, 0x7c,\n      0x52, 0xc7, 0x53, 0x13, 0x53, 0x5f, 0x53, 0xaa, 0x53, 0xf6, 0x54, 0x42,\n      0x54, 0x8f, 0x54, 0xdb, 0x55, 0x28, 0x55, 0x75, 0x55, 0xc2, 0x56, 0x0f,\n      0x56, 0x5c, 0x56, 0xa9, 0x56, 0xf7, 0x57, 0x44, 0x57, 0x92, 0x57, 0xe0,\n      0x58, 0x2f, 0x58, 0x7d, 0x58, 0xcb, 0x59, 0x1a, 0x59, 0x69, 0x59, 0xb8,\n      0x5a, 0x07, 0x5a, 0x56, 0x5a, 0xa6, 0x5a, 0xf5, 0x5b, 0x45, 0x5b, 0x95,\n      0x5b, 0xe5, 0x5c, 0x35, 0x5c, 0x86, 0x5c, 0xd6, 0x5d, 0x27, 0x5d, 0x78,\n      0x5d, 0xc9, 0x5e, 0x1a, 0x5e, 0x6c, 0x5e, 0xbd, 0x5f, 0x0f, 0x5f, 0x61,\n      0x5f, 0xb3, 0x60, 0x05, 0x60, 0x57, 0x60, 0xaa, 0x60, 0xfc, 0x61, 0x4f,\n      0x61, 0xa2, 0x61, 0xf5, 0x62, 0x49, 0x62, 0x9c, 0x62, 0xf0, 0x63, 0x43,\n      0x63, 0x97, 0x63, 0xeb, 0x64, 0x40, 0x64, 0x94, 0x64, 0xe9, 0x65, 0x3d,\n      0x65, 0x92, 0x65, 0xe7, 0x66, 0x3d, 0x66, 0x92, 0x66, 0xe8, 0x67, 0x3d,\n      0x67, 0x93, 0x67, 0xe9, 0x68, 0x3f, 0x68, 0x96, 0x68, 0xec, 0x69, 0x43,\n      0x69, 0x9a, 0x69, 0xf1, 0x6a, 0x48, 0x6a, 0x9f, 0x6a, 0xf7, 0x6b, 0x4f,\n      0x6b, 0xa7, 0x6b, 0xff, 0x6c, 0x57, 0x6c, 0xaf, 0x6d, 0x08, 0x6d, 0x60,\n      0x6d, 0xb9, 0x6e, 0x12, 0x6e, 0x6b, 0x6e, 0xc4, 0x6f, 0x1e, 0x6f, 0x78,\n      0x6f, 0xd1, 0x70, 0x2b, 0x70, 0x86, 0x70, 0xe0, 0x71, 0x3a, 0x71, 0x95,\n      0x71, 0xf0, 0x72, 0x4b, 0x72, 0xa6, 0x73, 0x01, 0x73, 0x5d, 0x73, 0xb8,\n      0x74, 0x14, 0x74, 0x70, 0x74, 0xcc, 0x75, 0x28, 0x75, 0x85, 0x75, 0xe1,\n      0x76, 0x3e, 0x76, 0x9b, 0x76, 0xf8, 0x77, 0x56, 0x77, 0xb3, 0x78, 0x11,\n      0x78, 0x6e, 0x78, 0xcc, 0x79, 0x2a, 0x79, 0x89, 0x79, 0xe7, 0x7a, 0x46,\n      0x7a, 0xa5, 0x7b, 0x04, 0x7b, 0x63, 0x7b, 0xc2, 0x7c, 0x21, 0x7c, 0x81,\n      0x7c, 0xe1, 0x7d, 0x41, 0x7d, 0xa1, 0x7e, 0x01, 0x7e, 0x62, 0x7e, 0xc2,\n      0x7f, 0x23, 0x7f, 0x84, 0x7f, 0xe5, 0x80, 0x47, 0x80, 0xa8, 0x81, 0x0a,\n      0x81, 0x6b, 0x81, 0xcd, 0x82, 0x30, 0x82, 0x92, 0x82, 0xf4, 0x83, 0x57,\n      0x83, 0xba, 0x84, 0x1d, 0x84, 0x80, 0x84, 0xe3, 0x85, 0x47, 0x85, 0xab,\n      0x86, 0x0e, 0x86, 0x72, 0x86, 0xd7, 0x87, 0x3b, 0x87, 0x9f, 0x88, 0x04,\n      0x88, 0x69, 0x88, 0xce, 0x89, 0x33, 0x89, 0x99, 0x89, 0xfe, 0x8a, 0x64,\n      0x8a, 0xca, 0x8b, 0x30, 0x8b, 0x96, 0x8b, 0xfc, 0x8c, 0x63, 0x8c, 0xca,\n      0x8d, 0x31, 0x8d, 0x98, 0x8d, 0xff, 0x8e, 0x66, 0x8e, 0xce, 0x8f, 0x36,\n      0x8f, 0x9e, 0x90, 0x06, 0x90, 0x6e, 0x90, 0xd6, 0x91, 0x3f, 0x91, 0xa8,\n      0x92, 0x11, 0x92, 0x7a, 0x92, 0xe3, 0x93, 0x4d, 0x93, 0xb6, 0x94, 0x20,\n      0x94, 0x8a, 0x94, 0xf4, 0x95, 0x5f, 0x95, 0xc9, 0x96, 0x34, 0x96, 0x9f,\n      0x97, 0x0a, 0x97, 0x75, 0x97, 0xe0, 0x98, 0x4c, 0x98, 0xb8, 0x99, 0x24,\n      0x99, 0x90, 0x99, 0xfc, 0x9a, 0x68, 0x9a, 0xd5, 0x9b, 0x42, 0x9b, 0xaf,\n      0x9c, 0x1c, 0x9c, 0x89, 0x9c, 0xf7, 0x9d, 0x64, 0x9d, 0xd2, 0x9e, 0x40,\n      0x9e, 0xae, 0x9f, 0x1d, 0x9f, 0x8b, 0x9f, 0xfa, 0xa0, 0x69, 0xa0, 0xd8,\n      0xa1, 0x47, 0xa1, 0xb6, 0xa2, 0x26, 0xa2, 0x96, 0xa3, 0x06, 0xa3, 0x76,\n      0xa3, 0xe6, 0xa4, 0x56, 0xa4, 0xc7, 0xa5, 0x38, 0xa5, 0xa9, 0xa6, 0x1a,\n      0xa6, 0x8b, 0xa6, 0xfd, 0xa7, 0x6e, 0xa7, 0xe0, 0xa8, 0x52, 0xa8, 0xc4,\n      0xa9, 0x37, 0xa9, 0xa9, 0xaa, 0x1c, 0xaa, 0x8f, 0xab, 0x02, 0xab, 0x75,\n      0xab, 0xe9, 0xac, 0x5c, 0xac, 0xd0, 0xad, 0x44, 0xad, 0xb8, 0xae, 0x2d,\n      0xae, 0xa1, 0xaf, 0x16, 0xaf, 0x8b, 0xb0, 0x00, 0xb0, 0x75, 0xb0, 0xea,\n      0xb1, 0x60, 0xb1, 0xd6, 0xb2, 0x4b, 0xb2, 0xc2, 0xb3, 0x38, 0xb3, 0xae,\n      0xb4, 0x25, 0xb4, 0x9c, 0xb5, 0x13, 0xb5, 0x8a, 0xb6, 0x01, 0xb6, 0x79,\n      0xb6, 0xf0, 0xb7, 0x68, 0xb7, 0xe0, 0xb8, 0x59, 0xb8, 0xd1, 0xb9, 0x4a,\n      0xb9, 0xc2, 0xba, 0x3b, 0xba, 0xb5, 0xbb, 0x2e, 0xbb, 0xa7, 0xbc, 0x21,\n      0xbc, 0x9b, 0xbd, 0x15, 0xbd, 0x8f, 0xbe, 0x0a, 0xbe, 0x84, 0xbe, 0xff,\n      0xbf, 0x7a, 0xbf, 0xf5, 0xc0, 0x70, 0xc0, 0xec, 0xc1, 0x67, 0xc1, 0xe3,\n      0xc2, 0x5f, 0xc2, 0xdb, 0xc3, 0x58, 0xc3, 0xd4, 0xc4, 0x51, 0xc4, 0xce,\n      0xc5, 0x4b, 0xc5, 0xc8, 0xc6, 0x46, 0xc6, 0xc3, 0xc7, 0x41, 0xc7, 0xbf,\n      0xc8, 0x3d, 0xc8, 0xbc, 0xc9, 0x3a, 0xc9, 0xb9, 0xca, 0x38, 0xca, 0xb7,\n      0xcb, 0x36, 0xcb, 0xb6, 0xcc, 0x35, 0xcc, 0xb5, 0xcd, 0x35, 0xcd, 0xb5,\n      0xce, 0x36, 0xce, 0xb6, 0xcf, 0x37, 0xcf, 0xb8, 0xd0, 0x39, 0xd0, 0xba,\n      0xd1, 0x3c, 0xd1, 0xbe, 0xd2, 0x3f, 0xd2, 0xc1, 0xd3, 0x44, 0xd3, 0xc6,\n      0xd4, 0x49, 0xd4, 0xcb, 0xd5, 0x4e, 0xd5, 0xd1, 0xd6, 0x55, 0xd6, 0xd8,\n      0xd7, 0x5c, 0xd7, 0xe0, 0xd8, 0x64, 0xd8, 0xe8, 0xd9, 0x6c, 0xd9, 0xf1,\n      0xda, 0x76, 0xda, 0xfb, 0xdb, 0x80, 0xdc, 0x05, 0xdc, 0x8a, 0xdd, 0x10,\n      0xdd, 0x96, 0xde, 0x1c, 0xde, 0xa2, 0xdf, 0x29, 0xdf, 0xaf, 0xe0, 0x36,\n      0xe0, 0xbd, 0xe1, 0x44, 0xe1, 0xcc, 0xe2, 0x53, 0xe2, 0xdb, 0xe3, 0x63,\n      0xe3, 0xeb, 0xe4, 0x73, 0xe4, 0xfc, 0xe5, 0x84, 0xe6, 0x0d, 0xe6, 0x96,\n      0xe7, 0x1f, 0xe7, 0xa9, 0xe8, 0x32, 0xe8, 0xbc, 0xe9, 0x46, 0xe9, 0xd0,\n      0xea, 0x5b, 0xea, 0xe5, 0xeb, 0x70, 0xeb, 0xfb, 0xec, 0x86, 0xed, 0x11,\n      0xed, 0x9c, 0xee, 0x28, 0xee, 0xb4, 0xef, 0x40, 0xef, 0xcc, 0xf0, 0x58,\n      0xf0, 0xe5, 0xf1, 0x72, 0xf1, 0xff, 0xf2, 0x8c, 0xf3, 0x19, 0xf3, 0xa7,\n      0xf4, 0x34, 0xf4, 0xc2, 0xf5, 0x50, 0xf5, 0xde, 0xf6, 0x6d, 0xf6, 0xfb,\n      0xf7, 0x8a, 0xf8, 0x19, 0xf8, 0xa8, 0xf9, 0x38, 0xf9, 0xc7, 0xfa, 0x57,\n      0xfa, 0xe7, 0xfb, 0x77, 0xfc, 0x07, 0xfc, 0x98, 0xfd, 0x29, 0xfd, 0xba,\n      0xfe, 0x4b, 0xfe, 0xdc, 0xff, 0x6d, 0xff, 0xff\n    };\n\n  StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (GetImageProfile(image,\"icc\") != (const StringInfo *) NULL)\n    return(MagickFalse);\n  profile=AcquireStringInfo(sizeof(sRGBProfile));\n  SetStringInfoDatum(profile,sRGBProfile);\n  status=SetImageProfile(image,\"icc\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name,\n  const void *datum,const size_t length,ExceptionInfo *exception)\n{\n#define ProfileImageTag  \"Profile/Image\"\n#ifndef TYPE_XYZ_8\n  #define TYPE_XYZ_8 (COLORSPACE_SH(PT_XYZ)|CHANNELS_SH(3)|BYTES_SH(1))\n#endif\n#define ThrowProfileException(severity,tag,context) \\\n{ \\\n  if (profile != (StringInfo *) NULL) \\\n     profile=DestroyStringInfo(profile); \\\n  if (cms_context != (cmsContext) NULL) \\\n    cmsDeleteContext(cms_context); \\\n  if (source_info.profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(source_info.profile); \\\n  if (target_info.profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(target_info.profile); \\\n  ThrowBinaryException(severity,tag,context); \\\n}\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(name != (const char *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((datum == (const void *) NULL) || (length == 0))\n    {\n      char\n        *next;\n\n      /*\n        Delete image profile(s).\n      */\n      ResetImageProfileIterator(image);\n      for (next=GetNextImageProfile(image); next != (const char *) NULL; )\n      {\n        if (IsOptionMember(next,name) != MagickFalse)\n          {\n            (void) DeleteImageProfile(image,next);\n            ResetImageProfileIterator(image);\n          }\n        next=GetNextImageProfile(image);\n      }\n      return(MagickTrue);\n    }\n  /*\n    Add a ICC, IPTC, or generic profile to the image.\n  */\n  status=MagickTrue;\n  profile=AcquireStringInfo((size_t) length);\n  SetStringInfoDatum(profile,(unsigned char *) datum);\n  if ((LocaleCompare(name,\"icc\") != 0) && (LocaleCompare(name,\"icm\") != 0))\n    status=SetImageProfile(image,name,profile,exception);\n  else\n    {\n      const StringInfo\n        *icc_profile;\n\n      icc_profile=GetImageProfile(image,\"icc\");\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          const char\n            *value;\n\n          value=GetImageProperty(image,\"exif:ColorSpace\",exception);\n          (void) value;\n          if (LocaleCompare(value,\"1\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R98.\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          icc_profile=GetImageProfile(image,\"icc\");\n        }\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          profile=DestroyStringInfo(profile);\n          return(MagickTrue);\n        }\n#if !defined(MAGICKCORE_LCMS_DELEGATE)\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n        \"'%s' (LCMS)\",image->filename);\n#else\n      {\n        cmsContext\n          cms_context;\n\n        CMSExceptionInfo\n          cms_exception;\n\n        LCMSInfo\n          source_info,\n          target_info;\n\n        /*\n          Transform pixel colors as defined by the color profiles.\n        */\n        cms_exception.image=image;\n        cms_exception.exception=exception;\n        cms_context=cmsCreateContext(NULL,&cms_exception);\n        if (cms_context == (cmsContext) NULL)\n          {\n            profile=DestroyStringInfo(profile);\n            ThrowBinaryException(ResourceLimitError,\n              \"ColorspaceColorProfileMismatch\",name);\n          }\n        cmsSetLogErrorHandlerTHR(cms_context,CMSExceptionHandler);\n        source_info.profile=cmsOpenProfileFromMemTHR(cms_context,\n          GetStringInfoDatum(profile),(cmsUInt32Number)\n          GetStringInfoLength(profile));\n        if (source_info.profile == (cmsHPROFILE) NULL)\n          {\n            profile=DestroyStringInfo(profile);\n            cmsDeleteContext(cms_context);\n            ThrowBinaryException(ResourceLimitError,\n              \"ColorspaceColorProfileMismatch\",name);\n          }\n        if ((cmsGetDeviceClass(source_info.profile) != cmsSigLinkClass) &&\n            (icc_profile == (StringInfo *) NULL))\n          status=SetImageProfile(image,name,profile,exception);\n        else\n          {\n            CacheView\n              *image_view;\n\n            cmsColorSpaceSignature\n              signature;\n\n            cmsHTRANSFORM\n              *magick_restrict transform;\n\n            cmsUInt32Number\n              flags;\n\n            MagickBooleanType\n              highres;\n\n            MagickOffsetType\n              progress;\n\n            ssize_t\n              y;\n\n            target_info.profile=(cmsHPROFILE) NULL;\n            if (icc_profile != (StringInfo *) NULL)\n              {\n                target_info.profile=source_info.profile;\n                source_info.profile=cmsOpenProfileFromMemTHR(cms_context,\n                  GetStringInfoDatum(icc_profile),(cmsUInt32Number)\n                  GetStringInfoLength(icc_profile));\n                if (source_info.profile == (cmsHPROFILE) NULL)\n                  ThrowProfileException(ResourceLimitError,\n                    \"ColorspaceColorProfileMismatch\",name);\n              }\n            highres=MagickTrue;\n#if !defined(MAGICKCORE_HDRI_SUPPORT) || (MAGICKCORE_QUANTUM_DEPTH > 16)\n            {\n              const char\n                *artifact;\n\n              artifact=GetImageArtifact(image,\"profile:highres-transform\");\n              if (IsStringFalse(artifact) != MagickFalse)\n                highres=MagickFalse;\n            }\n#endif\n            SetLCMSInfoScale(&source_info,1.0);\n            SetLCMSInfoTranslate(&source_info,0.0);\n            source_info.colorspace=sRGBColorspace;\n            source_info.channels=3;\n            switch (cmsGetColorSpace(source_info.profile))\n            {\n              case cmsSigCmykData:\n              {\n                source_info.colorspace=CMYKColorspace;\n                source_info.channels=4;\n                if (highres != MagickFalse)\n                  {\n                    source_info.type=(cmsUInt32Number) TYPE_CMYK_DBL;\n                    SetLCMSInfoScale(&source_info,100.0);\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_CMYK_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_CMYK_16;\n#endif\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                source_info.colorspace=GRAYColorspace;\n                source_info.channels=1;\n                if (highres != MagickFalse)\n                  source_info.type=(cmsUInt32Number) TYPE_GRAY_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_GRAY_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_GRAY_16;\n#endif\n                break;\n              }\n              case cmsSigLabData:\n              {\n                source_info.colorspace=LabColorspace;\n                if (highres != MagickFalse)\n                  {\n                    source_info.type=(cmsUInt32Number) TYPE_Lab_DBL;\n                    source_info.scale[0]=100.0;\n                    source_info.scale[1]=255.0;\n                    source_info.scale[2]=255.0;\n                    source_info.translate[1]=(-0.5);\n                    source_info.translate[2]=(-0.5);\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_Lab_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_Lab_16;\n#endif\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                source_info.colorspace=sRGBColorspace;\n                if (highres != MagickFalse)\n                  source_info.type=(cmsUInt32Number) TYPE_RGB_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_RGB_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_RGB_16;\n#endif\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                source_info.colorspace=XYZColorspace;\n                if (highres != MagickFalse)\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_16;\n#endif\n                break;\n              }\n              default:\n                ThrowProfileException(ImageError,\n                  \"ColorspaceColorProfileMismatch\",name);\n            }\n            signature=cmsGetPCS(source_info.profile);\n            if (target_info.profile != (cmsHPROFILE) NULL)\n              signature=cmsGetColorSpace(target_info.profile);\n            SetLCMSInfoScale(&target_info,1.0);\n            SetLCMSInfoTranslate(&target_info,0.0);\n            target_info.channels=3;\n            switch (signature)\n            {\n              case cmsSigCmykData:\n              {\n                target_info.colorspace=CMYKColorspace;\n                target_info.channels=4;\n                if (highres != MagickFalse)\n                  {\n                    target_info.type=(cmsUInt32Number) TYPE_CMYK_DBL;\n                    SetLCMSInfoScale(&target_info,0.01);\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_CMYK_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_CMYK_16;\n#endif\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                target_info.colorspace=GRAYColorspace;\n                target_info.channels=1;\n                if (highres != MagickFalse)\n                  target_info.type=(cmsUInt32Number) TYPE_GRAY_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_GRAY_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_GRAY_16;\n#endif\n                break;\n              }\n              case cmsSigLabData:\n              {\n                target_info.colorspace=LabColorspace;\n                if (highres != MagickFalse)\n                  {\n                    target_info.type=(cmsUInt32Number) TYPE_Lab_DBL;\n                    target_info.scale[0]=0.01;\n                    target_info.scale[1]=1/255.0;\n                    target_info.scale[2]=1/255.0;\n                    target_info.translate[1]=0.5;\n                    target_info.translate[2]=0.5;\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_Lab_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_Lab_16;\n#endif\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                target_info.colorspace=sRGBColorspace;\n                if (highres != MagickFalse)\n                  target_info.type=(cmsUInt32Number) TYPE_RGB_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_RGB_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_RGB_16;\n#endif\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                target_info.colorspace=XYZColorspace;\n                if (highres != MagickFalse)\n                  target_info.type=(cmsUInt32Number) TYPE_XYZ_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_XYZ_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_16;\n#endif\n                break;\n              }\n              default:\n                ThrowProfileException(ImageError,\n                  \"ColorspaceColorProfileMismatch\",name);\n            }\n            switch (image->rendering_intent)\n            {\n              case AbsoluteIntent:\n              {\n                target_info.intent=INTENT_ABSOLUTE_COLORIMETRIC;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                target_info.intent=INTENT_PERCEPTUAL;\n                break;\n              }\n              case RelativeIntent:\n              {\n                target_info.intent=INTENT_RELATIVE_COLORIMETRIC;\n                break;\n              }\n              case SaturationIntent:\n              {\n                target_info.intent=INTENT_SATURATION;\n                break;\n              }\n              default:\n              {\n                target_info.intent=INTENT_PERCEPTUAL;\n                break;\n              }\n            }\n            flags=cmsFLAGS_HIGHRESPRECALC;\n#if defined(cmsFLAGS_BLACKPOINTCOMPENSATION)\n            if (image->black_point_compensation != MagickFalse)\n              flags|=cmsFLAGS_BLACKPOINTCOMPENSATION;\n#endif\n            transform=AcquireTransformTLS(&source_info,&target_info,flags,\n              cms_context);\n            if (transform == (cmsHTRANSFORM *) NULL)\n              ThrowProfileException(ImageError,\"UnableToCreateColorTransform\",\n                name);\n            /*\n              Transform image as dictated by the source & target image profiles.\n            */\n            source_info.pixels=AcquirePixelTLS(image->columns,\n              source_info.channels,highres);\n            target_info.pixels=AcquirePixelTLS(image->columns,\n              target_info.channels,highres);\n            if ((source_info.pixels == (void **) NULL) ||\n                (target_info.pixels == (void **) NULL))\n              {\n                target_info.pixels=DestroyPixelTLS(target_info.pixels);\n                source_info.pixels=DestroyPixelTLS(source_info.pixels);\n                transform=DestroyTransformTLS(transform);\n                ThrowProfileException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",image->filename);\n              }\n            if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n              {\n                target_info.pixels=DestroyPixelTLS(target_info.pixels);\n                source_info.pixels=DestroyPixelTLS(source_info.pixels);\n                transform=DestroyTransformTLS(transform);\n                if (source_info.profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(source_info.profile);\n                if (target_info.profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(target_info.profile);\n                return(MagickFalse);\n              }\n            if (target_info.colorspace == CMYKColorspace)\n              (void) SetImageColorspace(image,target_info.colorspace,exception);\n            progress=0;\n            image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel for schedule(static) shared(status) \\\n              magick_number_threads(image,image,image->rows,1)\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const int\n                id = GetOpenMPThreadId();\n\n              MagickBooleanType\n                sync;\n\n              Quantum\n                *magick_restrict q;\n\n              if (status == MagickFalse)\n                continue;\n              q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                {\n                  status=MagickFalse;\n                  continue;\n                }\n              if (highres != MagickFalse)\n                TransformDoublePixels(id,image,&source_info,&target_info,\n                  transform,q);\n              else\n                TransformQuantumPixels(id,image,&source_info,&target_info,\n                  transform,q);\n              sync=SyncCacheViewAuthenticPixels(image_view,exception);\n              if (sync == MagickFalse)\n                status=MagickFalse;\n              if (image->progress_monitor != (MagickProgressMonitor) NULL)\n                {\n                  MagickBooleanType\n                    proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n                  #pragma omp atomic\n#endif\n                  progress++;\n                  proceed=SetImageProgress(image,ProfileImageTag,progress,\n                    image->rows);\n                  if (proceed == MagickFalse)\n                    status=MagickFalse;\n                }\n            }\n            image_view=DestroyCacheView(image_view);\n            (void) SetImageColorspace(image,target_info.colorspace,exception);\n            switch (signature)\n            {\n              case cmsSigRgbData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  TrueColorType : TrueColorAlphaType;\n                break;\n              }\n              case cmsSigCmykData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  ColorSeparationType : ColorSeparationAlphaType;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  GrayscaleType : GrayscaleAlphaType;\n                break;\n              }\n              default:\n                break;\n            }\n            target_info.pixels=DestroyPixelTLS(target_info.pixels);\n            source_info.pixels=DestroyPixelTLS(source_info.pixels);\n            transform=DestroyTransformTLS(transform);\n            if ((status != MagickFalse) &&\n                (cmsGetDeviceClass(source_info.profile) != cmsSigLinkClass))\n              status=SetImageProfile(image,name,profile,exception);\n            if (target_info.profile != (cmsHPROFILE) NULL)\n              (void) cmsCloseProfile(target_info.profile);\n          }\n        (void) cmsCloseProfile(source_info.profile);\n        cmsDeleteContext(cms_context);\n      }\n#endif\n    }\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProfile() removes a named profile from the image and returns its\n%  value.\n%\n%  The format of the RemoveImageProfile method is:\n%\n%      void *RemoveImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport StringInfo *RemoveImageProfile(Image *image,const char *name)\n{\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  profile=(StringInfo *) RemoveNodeFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t P r o f i l e I t e r a t o r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImageProfileIterator() resets the image profile iterator.  Use it in\n%  conjunction with GetNextImageProfile() to iterate over all the profiles\n%  associated with an image.\n%\n%  The format of the ResetImageProfileIterator method is:\n%\n%      ResetImageProfileIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImageProfileIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProfile() adds a named profile to the image.  If a profile with the\n%  same name already exists, it is replaced.  This method differs from the\n%  ProfileImage() method in that it does not apply CMS color profiles.\n%\n%  The format of the SetImageProfile method is:\n%\n%      MagickBooleanType SetImageProfile(Image *image,const char *name,\n%        const StringInfo *profile)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name, for example icc, exif, and 8bim (8bim is the\n%      Photoshop wrapper for iptc profiles).\n%\n%    o profile: A StringInfo structure that contains the named profile.\n%\n*/\n\nstatic void *DestroyProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic inline const unsigned char *ReadResourceByte(const unsigned char *p,\n  unsigned char *quantum)\n{\n  *quantum=(*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(unsigned int) (*p++) << 24;\n  *quantum|=(unsigned int) (*p++) << 16;\n  *quantum|=(unsigned int) (*p++) << 8;\n  *quantum|=(unsigned int) (*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceShort(const unsigned char *p,\n  unsigned short *quantum)\n{\n  *quantum=(unsigned short) (*p++) << 8;\n  *quantum|=(unsigned short) (*p++);\n  return(p);\n}\n\nstatic inline void WriteResourceLong(unsigned char *p,\n  const unsigned int quantum)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) (quantum >> 24);\n  buffer[1]=(unsigned char) (quantum >> 16);\n  buffer[2]=(unsigned char) (quantum >> 8);\n  buffer[3]=(unsigned char) quantum;\n  (void) memcpy(p,buffer,4);\n}\n\nstatic void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((count < 0) || (p > (datum+length-count)) || (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_extent;\n\n        StringInfo\n          *extract_profile;\n\n        extract_extent=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) memcpy(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_extent=profile->length;\n            if ((extract_extent & 0x01) != 0)\n              extract_extent++;\n            extract_profile=AcquireStringInfo(offset+extract_extent+extent);\n            (void) memcpy(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,(unsigned int)\n              profile->length);\n            (void) memcpy(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) memcpy(extract_profile->datum+offset+extract_extent,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n\nstatic void GetProfilesFromResourceBlock(Image *image,\n  const StringInfo *resource_block,ExceptionInfo *exception)\n{\n  const unsigned char\n    *datum;\n\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id;\n\n  datum=GetStringInfoDatum(resource_block);\n  length=GetStringInfoLength(resource_block);\n  for (p=datum; p < (datum+length-16); )\n  {\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length) ||\n        (count <= 0))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned int\n          resolution;\n\n        unsigned short\n          units;\n\n        /*\n          Resolution.\n        */\n        if (count < 10)\n          break;\n        p=ReadResourceLong(p,&resolution);\n        image->resolution.x=((double) resolution)/65536.0;\n        p=ReadResourceShort(p,&units)+2;\n        p=ReadResourceLong(p,&resolution)+4;\n        image->resolution.y=((double) resolution)/65536.0;\n        /*\n          Values are always stored as pixels per inch.\n        */\n        if ((ResolutionType) units != PixelsPerCentimeterResolution)\n          image->units=PixelsPerInchResolution;\n        else\n          {\n            image->units=PixelsPerCentimeterResolution;\n            image->resolution.x/=2.54;\n            image->resolution.y/=2.54;\n          }\n        break;\n      }\n      case 0x0404:\n      {\n        /*\n          IPTC profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"iptc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x040c:\n      {\n        /*\n          Thumbnail.\n        */\n        p+=count;\n        break;\n      }\n      case 0x040f:\n      {\n        /*\n          ICC Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"icc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0422:\n      {\n        /*\n          EXIF Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"exif\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0424:\n      {\n        /*\n          XMP Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"xmp\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void PatchCorruptProfile(const char *name,StringInfo *profile)\n{\n  unsigned char\n    *p;\n\n  size_t\n    length;\n\n  /*\n    Detect corrupt profiles and if discovered, repair.\n  */\n  if (LocaleCompare(name,\"xmp\") == 0)\n    {\n      /*\n        Remove garbage after xpacket end.\n      */\n      p=GetStringInfoDatum(profile);\n      p=(unsigned char *) strstr((const char *) p,\"<?xpacket end=\\\"w\\\"?>\");\n      if (p != (unsigned char *) NULL)\n        {\n          p+=19;\n          length=p-GetStringInfoDatum(profile);\n          if (length != GetStringInfoLength(profile))\n            {\n              *p='\\0';\n              SetStringInfoLength(profile,length);\n            }\n        }\n      return;\n    }\n  if (LocaleCompare(name,\"exif\") == 0)\n    {\n      /*\n        Check if profile starts with byte order marker instead of Exif.\n      */\n      p=GetStringInfoDatum(profile);\n      if ((LocaleNCompare((const char *) p,\"MM\",2) == 0) ||\n          (LocaleNCompare((const char *) p,\"II\",2) == 0))\n        {\n          const unsigned char\n            profile_start[] = \"Exif\\0\\0\";\n\n          StringInfo\n            *exif_profile;\n\n          exif_profile=AcquireStringInfo(6);\n          if (exif_profile != (StringInfo *) NULL)\n            {\n              SetStringInfoDatum(exif_profile,profile_start);\n              ConcatenateStringInfo(exif_profile,profile);\n              SetStringInfoLength(profile,GetStringInfoLength(exif_profile));\n              SetStringInfo(profile,exif_profile);\n              exif_profile=DestroyStringInfo(exif_profile);\n            }\n        }\n    }\n}\n\n#if defined(MAGICKCORE_XML_DELEGATE)\nstatic MagickBooleanType ValidateXMPProfile(Image *image,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  xmlDocPtr\n    document;\n\n  /*\n    Parse XML profile.\n  */\n  document=xmlReadMemory((const char *) GetStringInfoDatum(profile),(int)\n    GetStringInfoLength(profile),\"xmp.xml\",NULL,XML_PARSE_NOERROR |\n    XML_PARSE_NOWARNING);\n  if (document == (xmlDocPtr) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"CorruptImageProfile\",\"`%s' (XMP)\",image->filename);\n      return(MagickFalse);\n    }\n  xmlFreeDoc(document);\n  return(MagickTrue);\n}\n#else\nstatic MagickBooleanType ValidateXMPProfile(Image *image,\n  const StringInfo *magick_unused(profile),ExceptionInfo *exception)\n{\n  magick_unreferenced(profile);\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"'%s' (XML)\",\n    image->filename);\n  return(MagickFalse);\n}\n#endif\n\nstatic MagickBooleanType SetImageProfileInternal(Image *image,const char *name,\n  const StringInfo *profile,const MagickBooleanType recursive,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *clone_profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  clone_profile=CloneStringInfo(profile);\n  PatchCorruptProfile(name,clone_profile);\n  if ((LocaleCompare(name,\"xmp\") == 0) &&\n      (ValidateXMPProfile(image,clone_profile,exception) == MagickFalse))\n    {\n      clone_profile=DestroyStringInfo(clone_profile);\n      return(MagickTrue);\n    }\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MagickPathExtent);\n  LocaleLower(key);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),clone_profile);\n  if (status != MagickFalse)\n    {\n      if (LocaleCompare(name,\"8bim\") == 0)\n        GetProfilesFromResourceBlock(image,clone_profile,exception);\n      else\n        if (recursive == MagickFalse)\n          WriteTo8BimProfile(image,name,clone_profile);\n    }\n  return(status);\n}\n\nMagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  return(SetImageProfileInternal(image,name,profile,MagickFalse,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e P r o f i l e s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageProfiles() synchronizes image properties with the image profiles.\n%\n%  The format of the SyncImageProfiles method is:\n%\n%      void SyncImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline int ReadProfileByte(unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed short ReadProfileShort(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileLong(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileMSBLong(unsigned char **p,size_t *length)\n{\n  signed int\n    value;\n\n  if (*length < 4)\n    return(0);\n  value=ReadProfileLong(MSBEndian,*p);\n  (*length)-=4;\n  *p+=4;\n  return(value);\n}\n\nstatic inline signed short ReadProfileMSBShort(unsigned char **p,\n  size_t *length)\n{\n  signed short\n    value;\n\n  if (*length < 2)\n    return(0);\n  value=ReadProfileShort(MSBEndian,*p);\n  (*length)-=2;\n  *p+=2;\n  return(value);\n}\n\nstatic inline void WriteProfileLong(const EndianType endian,\n  const size_t value,unsigned char *p)\n{\n  unsigned char\n    buffer[4];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      (void) memcpy(p,buffer,4);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  (void) memcpy(p,buffer,4);\n}\n\nstatic void WriteProfileShort(const EndianType endian,\n  const unsigned short value,unsigned char *p)\n{\n  unsigned char\n    buffer[2];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      (void) memcpy(p,buffer,2);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  (void) memcpy(p,buffer,2);\n}\n\nstatic void SyncExifProfile(const Image *image,unsigned char *exif,\n  size_t length)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack] = { { 0, 0 } };\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    number_entries;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory;\n\n  if (length < 16)\n    return;\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return;\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return;\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return;\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || ((size_t) offset >= length))\n    return;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(int) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadProfileLong(endian,q+8);\n          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          if (number_bytes == 8)\n            (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          if (number_bytes == 8)\n            (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,((size_t) image->units)+1,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t) ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return;\n}\n\nstatic void Sync8BimProfile(const Image *image,\n  const StringInfo *profile)\n{\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *p;\n\n  unsigned short\n    id;\n\n  length=GetStringInfoLength(profile);\n  p=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadProfileByte(&p,&length) != 0x38)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x42)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x49)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x4D)\n      continue;\n    if (length < 7)\n      return;\n    id=ReadProfileMSBShort(&p,&length);\n    count=(ssize_t) ReadProfileByte(&p,&length);\n    if ((count >= (ssize_t) length) || (count < 0))\n      return;\n    p+=count;\n    length-=count;\n    if ((*p & 0x01) == 0)\n      (void) ReadProfileByte(&p,&length);\n    count=(ssize_t) ReadProfileMSBLong(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return;\n    if ((id == 0x3ED) && (count == 16))\n      {\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.x*2.54*65536.0),p);\n        else\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.x*65536.0),p);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.y*2.54*65536.0),p+8);\n        else\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.y*65536.0),p+8);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);\n      }\n    if (id == 0x0422)\n      SyncExifProfile(image,p,count);\n    p+=count;\n    length-=count;\n  }\n  return;\n}\n\nstatic void ReplaceXmpValue(StringInfo *profile,size_t start,size_t end,\n  const char *value)\n{\n  char\n    *datum;\n\n  size_t\n    length,\n    new_length,\n    value_length;\n\n  length=GetStringInfoLength(profile);\n  value_length=strlen(value);\n  new_length=length-(end-start)+value_length;\n  if (new_length > length)\n    SetStringInfoLength(profile,new_length);\n  datum=(char *) GetStringInfoDatum(profile);\n  memmove(datum+start+value_length,datum+end,length-end);\n  memcpy(datum+start,value,value_length);\n  if (new_length < length)\n    {\n      SetStringInfoLength(profile,new_length);\n      *(datum+new_length)='\\0';\n    }\n}\n\nstatic MagickBooleanType GetXmpOffsets(const StringInfo *profile,\n  const char *tag,size_t *start,size_t *end)\n{\n  char\n    *datum,\n    *pos;\n\n  size_t\n    length,\n    tag_length;\n\n  datum=(char *) GetStringInfoDatum(profile);\n  length=GetStringInfoLength(profile);\n  pos=strstr(datum,tag);\n  tag_length=strlen(tag);\n  if ((pos == (char *) NULL) || ((pos-datum) < 1) || (*(pos-1) != '<') ||\n      (((pos-datum)+tag_length) > length) || (*(pos+tag_length) != '>'))\n    return(MagickFalse);\n  *start=(pos-datum)+tag_length+1;\n  pos=strstr(datum+*start,\"<\");\n  if (pos == (char *) NULL)\n    return(MagickFalse);\n  *end=(pos-datum);\n  return(MagickTrue);\n}\n\nstatic void GetXmpNumeratorAndDenominator(double value,size_t *numerator,\n  size_t *denominator)\n{\n  double\n    df;\n\n  *numerator=0;\n  *denominator=1;\n  if (value <= MagickEpsilon)\n    return;\n  *numerator=1;\n  df=1.0;\n  while(fabs(df - value) > MagickEpsilon)\n  {\n    if (df < value)\n      (*numerator)++;\n    else\n      {\n        (*denominator)++;\n        *numerator=(size_t) (value*(*denominator));\n      }\n    df=*numerator/(double)*denominator;\n  }\n}\n\nstatic void SyncXmpProfile(const Image *image,StringInfo *profile)\n{\n  char\n    value[MagickPathExtent];\n\n  size_t\n    denominator,\n    end,\n    numerator,\n    start;\n\n  *value='\\0';\n  if (GetXmpOffsets(profile,\"tiff:XResolution\",&start,&end) != MagickFalse)\n    {\n      GetXmpNumeratorAndDenominator(image->resolution.x,&numerator,\n        &denominator);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%zu/%zu\",numerator,\n        denominator);\n      ReplaceXmpValue(profile,start,end,value);\n    }\n  if (GetXmpOffsets(profile,\"tiff:YResolution\",&start,&end) != MagickFalse)\n    {\n      if ((fabs(image->resolution.x-image->resolution.y) > MagickEpsilon) ||\n          (*value == '\\0'))\n        {\n          GetXmpNumeratorAndDenominator(image->resolution.y,&numerator,\n            &denominator);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%zu/%zu\",numerator,\n            denominator);\n        }\n      ReplaceXmpValue(profile,start,end,value);\n    }\n  if (GetXmpOffsets(profile,\"tiff:ResolutionUnit\",&start,&end) != MagickFalse)\n    {\n      (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n        ((int) image->units)+1);\n      ReplaceXmpValue(profile,start,end,value);\n    }\n  if (GetXmpOffsets(profile,\"tiff:Orientation\",&start,&end) != MagickFalse)\n    {\n      (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n        (int) image->orientation);\n      ReplaceXmpValue(profile,start,end,value);\n    }\n}\n\nMagickPrivate void SyncImageProfiles(Image *image)\n{\n  StringInfo\n    *profile;\n\n  profile=(StringInfo *) GetImageProfile(image,\"8BIM\");\n  if (profile != (StringInfo *) NULL)\n    Sync8BimProfile(image,profile);\n  profile=(StringInfo *) GetImageProfile(image,\"EXIF\");\n  if (profile != (StringInfo *) NULL)\n    SyncExifProfile(image,GetStringInfoDatum(profile),GetStringInfoLength(\n      profile));\n  profile=(StringInfo *) GetImageProfile(image,\"XMP\");\n  if (profile != (StringInfo *) NULL)\n    SyncXmpProfile(image,profile);\n}\n\nstatic void UpdateClipPath(unsigned char *blob,size_t length,\n  const size_t old_columns,const size_t old_rows,\n  const RectangleInfo *new_geometry)\n{\n  ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector;\n\n  knot_count=0;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadProfileMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadProfileMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          double\n            x,\n            y;\n\n          signed int\n            xx,\n            yy;\n\n          y=(double) ReadProfileMSBLong(&blob,&length);\n          y=y*old_rows/4096.0/4096.0;\n          y-=new_geometry->y;\n          yy=(signed int) ((y*4096*4096)/new_geometry->height);\n          WriteProfileLong(MSBEndian,(size_t) yy,blob-4);\n          x=(double) ReadProfileMSBLong(&blob,&length);\n          x=x*old_columns/4096.0/4096.0;\n          x-=new_geometry->x;\n          xx=(signed int) ((x*4096*4096)/new_geometry->width);\n          WriteProfileLong(MSBEndian,(size_t) xx,blob-4);\n        }\n        knot_count--;\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n}\n\nMagickPrivate void Update8BIMClipPath(const Image *image,\n  const size_t old_columns,const size_t old_rows,\n  const RectangleInfo *new_geometry)\n{\n  const StringInfo\n    *profile;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id;\n\n  unsigned char\n    *info;\n\n  assert(image != (Image *) NULL);\n  assert(new_geometry != (RectangleInfo *) NULL);\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while (length > 0)\n  {\n    if (ReadProfileByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadProfileByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadProfileByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadProfileByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadProfileMSBShort(&info,&length);\n    count=(ssize_t) ReadProfileByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        info+=count;\n        length-=count;\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadProfileByte(&info,&length);\n    count=(ssize_t) ReadProfileMSBLong(&info,&length);\n    if ((count < 0) || ((size_t) count > length))\n      {\n        length=0;\n        continue;\n      }\n    if ((id > 1999) && (id < 2999))\n      UpdateClipPath(info,(size_t) count,old_columns,old_rows,new_geometry);\n    info+=count;\n    length-=MagickMin(count,(ssize_t) length);\n  }\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                          TTTTT  IIIII  M   M   222                          %\n%                            T      I    MM MM  2   2                         %\n%                            T      I    M M M     2                          %\n%                            T      I    M   M    2                           %\n%                            T    IIIII  M   M  22222                         %\n%                                                                             %\n%                                                                             %\n%                          Read PSX TIM2 Image Format                         %\n%                                                                             %\n%                               Software Design                               %\n%                             Ramiro Balado Ordax                             %\n%                                   May 2019                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 2019 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n Typedef declarations\n*/\ntypedef struct _TIM2FileHeader\n{\n  unsigned int\n    magic_num;\n\n  unsigned char\n    format_vers,\n    format_type;\n\n  unsigned short\n    image_count;\n} TIM2FileHeader;\n\ntypedef struct _TIM2ImageHeader\n{\n  unsigned int\n    total_size,\n    clut_size,\n    image_size;\n\n  unsigned short\n    header_size,\n    clut_color_count;\n\n  unsigned char\n    img_format,\n    mipmap_count,\n    clut_type,\n    bpp_type;\n\n  unsigned short\n    width,\n    height;\n\n  MagickSizeType\n    GsTex0,\n    GsTex1;\n\n  unsigned int\n    GsRegs,\n    GsTexClut;\n} TIM2ImageHeader;\n\ntypedef enum\n{\n  CSM1=0,\n  CSM2=1,\n} CSM;\n\ntypedef enum\n{\n  RGBA32=0,\n  RGB24=1,\n  RGBA16=2,\n} TIM2ColorEncoding;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  R e a d T I M 2 I m a g e                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIM2Image() reads a PS2 TIM image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTIM2Image method is:\n%\n%      Image *ReadTIM2Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic inline void ReadTIM2ImageHeader(Image *image,TIM2ImageHeader *header)\n{\n  header->total_size=ReadBlobLSBLong(image);\n  header->clut_size=ReadBlobLSBLong(image);\n  header->image_size=ReadBlobLSBLong(image);\n  header->header_size=ReadBlobLSBShort(image);\n\n  header->clut_color_count=ReadBlobLSBShort(image);\n  header->img_format=(unsigned char) ReadBlobByte(image);\n  header->mipmap_count=(unsigned char) ReadBlobByte(image);\n  header->clut_type=(unsigned char) ReadBlobByte(image);\n  header->bpp_type=(unsigned char) ReadBlobByte(image);\n\n  header->width=ReadBlobLSBShort(image);\n  header->height=ReadBlobLSBShort(image);\n\n  header->GsTex0=ReadBlobMSBLongLong(image);\n  header->GsTex1=ReadBlobMSBLongLong(image);\n  header->GsRegs=ReadBlobMSBLong(image);\n  header->GsTexClut=ReadBlobMSBLong(image);\n}\n\nstatic inline Quantum GetChannelValue(unsigned int word,unsigned char channel,\n  TIM2ColorEncoding ce)\n{\n  switch(ce)\n  {\n    case RGBA16:\n      /* Documentation specifies padding with zeros for converting from 5 to 8 bits. */\n      return ScaleCharToQuantum((word>>channel*5 & ~(~0x0U<<5))<<3);\n    case RGB24:\n    case RGBA32:\n      return ScaleCharToQuantum(word>>channel*8 & ~(~0x0U<<8));\n    default:\n      return QuantumRange;\n  }\n}\n\nstatic inline Quantum GetAlpha(unsigned int word,TIM2ColorEncoding ce)\n{\n  switch(ce)\n  {\n    case RGBA16:\n      return ScaleCharToQuantum((word>>3*5&0x1F)==0?0:0xFF);\n    case RGBA32:\n      /* 0x80 -> 1.0 alpha. Multiply by 2 and clamp to 0xFF */\n      return ScaleCharToQuantum(MagickMin((word>>3*8&0xFF)<<1,0xFF));\n    default:\n      return 0xFF;\n  }\n}\n\nstatic inline void deshufflePalette(Image *image,PixelInfo* oldColormap)\n{\n  const size_t\n    pages=image->colors/32,  /* Pages per CLUT */\n    blocks=4,  /* Blocks per page */\n    colors=8;  /* Colors per block */\n\n  int\n    page;\n\n  size_t\n    i=0;\n\n  (void) memcpy(oldColormap,image->colormap,(size_t)image->colors*\n    sizeof(*oldColormap));\n\n  /*\n   * Swap the 2nd and 3rd block in each page\n   */\n  for (page=0; page < (ssize_t) pages; page++)\n  {\n    memcpy(&(image->colormap[i+1*colors]),&(oldColormap[i+2*colors]),colors*\n      sizeof(PixelInfo));\n    memcpy(&(image->colormap[i+2*colors]),&(oldColormap[i+1*colors]),colors*\n      sizeof(PixelInfo));\n\n    i+=blocks*colors;\n  }\n}\n\nstatic MagickBooleanType ReadTIM2ImageData(const ImageInfo *image_info,\n  Image *image,TIM2ImageHeader *header,char clut_depth,char bits_per_pixel,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    x;\n\n  Quantum\n    *q;\n\n  unsigned char\n    *p;\n\n  size_t\n    bits_per_line,\n    bytes_per_line;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *row_data;\n\n  unsigned int\n    word;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n   * User data\n   */\n  status=DiscardBlobBytes(image,header->header_size-48);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n   * Image data\n   */\n  bits_per_line=image->columns*bits_per_pixel;\n  bytes_per_line=bits_per_line/8 + ((bits_per_line%8==0) ? 0 : 1);\n  row_data=(unsigned char*) AcquireQuantumMemory(1,bytes_per_line);\n  if (row_data == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image_info->filename);\n  if (clut_depth != 0)\n    {\n      image->colors=header->clut_color_count;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n          row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image_info->filename);\n        }\n      switch (bits_per_pixel)\n      {\n        case 4:\n        {\n          for (y=0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n            {\n              SetPixelIndex(image,(*p >> 0) & 0x0F,q);\n              q+=GetPixelChannels(image);\n              SetPixelIndex(image,(*p >> 4) & 0x0F,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              {\n                SetPixelIndex(image,(*p >> 4) & 0x0F,q);\n                p++;\n                q+=GetPixelChannels(image);\n              }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        case 8:\n        {\n          for (y=0;y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        default:\n        {\n          row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n          ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n            image_info->filename);\n        }\n      }\n      SyncImage(image,exception);\n    }\n  else  /* has_clut==false */\n    {\n      switch (bits_per_pixel)\n      {\n        case 16:\n        {\n          for (y=0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              word = ((unsigned int)* p   )<<0*8 |\n                      ((unsigned int)*(p+1))<<1*8;\n\n              SetPixelRed(image,GetChannelValue(word,0,RGBA16),q);\n              SetPixelGreen(image,GetChannelValue(word,1,RGBA16),q);\n              SetPixelBlue(image,GetChannelValue(word,2,RGBA16),q);\n              SetPixelAlpha(image,GetAlpha(word,RGBA16),q);\n              q+=GetPixelChannels(image);\n              p+=sizeof(unsigned short);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        case 24:\n        {\n          for (y = 0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              word = (unsigned int)(* p   )<<0*8 |\n                      (unsigned int)(*(p+1))<<1*8 |\n                      (unsigned int)(*(p+2))<<2*8;\n\n              SetPixelRed(image,GetChannelValue(word,0,RGB24),q);\n              SetPixelGreen(image,GetChannelValue(word,1,RGB24),q);\n              SetPixelBlue(image,GetChannelValue(word,2,RGB24),q);\n              q+=GetPixelChannels(image);\n              p+=3;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        case 32:\n        {  \n          for (y = 0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              word = ((unsigned int)* p   )<<0*8 |\n                      ((unsigned int)*(p+1))<<1*8 |\n                      ((unsigned int)*(p+2))<<2*8 |\n                      ((unsigned int)*(p+3))<<3*8;\n\n              SetPixelRed(image,GetChannelValue(word,0,RGBA32),q);\n              SetPixelGreen(image,GetChannelValue(word,1,RGBA32),q);\n              SetPixelBlue(image,GetChannelValue(word,2,RGBA32),q);\n              SetPixelAlpha(image,GetAlpha(word,RGBA32),q);\n              q+=GetPixelChannels(image);\n              p+=4;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        default:\n        {\n          row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n          ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n            image_info->filename);\n        }\n      }\n    }\n  row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n  if ((status != MagickFalse) && (clut_depth != 0))\n  {\n    CSM\n      csm;\n\n    ssize_t\n      i;\n\n    unsigned char\n      *clut_data;\n\n    /*\n      * ### Read CLUT Data ###\n      */\n    clut_data=(unsigned char *) AcquireQuantumMemory(1,header->clut_size);\n    if (clut_data == (unsigned char *) NULL)\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    count=ReadBlob(image,header->clut_size,clut_data);\n    if (count != (ssize_t) (header->clut_size))\n      {\n        clut_data=(unsigned char *) RelinquishMagickMemory(clut_data);\n        ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n          image_info->filename);\n      }\n    /*\n      * ### Process CLUT Data ###\n      */\n    p=clut_data;\n    switch(clut_depth)\n    {\n      case 16:\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          word = ((unsigned short)* p   )<<0*8 |\n                  ((unsigned short)*(p+1))<<1*8;\n\n          image->colormap[i].red=GetChannelValue(word,0,RGBA16);\n          image->colormap[i].green=GetChannelValue(word,1,RGBA16);\n          image->colormap[i].blue=GetChannelValue(word,2,RGBA16);\n          image->colormap[i].alpha=GetAlpha(word,RGBA16);\n          p+=2;\n        }\n        break;\n      }\n      case 24:\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          word = ((unsigned int)* p   )<<0*8 |\n                  ((unsigned int)*(p+1))<<1*8 |\n                  ((unsigned int)*(p+2))<<2*8;\n\n          image->colormap[i].red=GetChannelValue(word,0,RGB24);\n          image->colormap[i].green=GetChannelValue(word,1,RGB24);\n          image->colormap[i].blue=GetChannelValue(word,2,RGB24);\n          p+=3;\n        }\n        break;\n      }\n      case 32:\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          word = ((unsigned int)* p   )<<0*8 |\n                  ((unsigned int)*(p+1))<<1*8 |\n                  ((unsigned int)*(p+2))<<2*8 |\n                  ((unsigned int)*(p+3))<<3*8;\n\n          image->colormap[i].red=GetChannelValue(word,0,RGBA32);\n          image->colormap[i].green=GetChannelValue(word,1,RGBA32);\n          image->colormap[i].blue=GetChannelValue(word,2,RGBA32);\n          image->colormap[i].alpha=GetAlpha(word,RGBA32);\n          p+=4;\n        }\n        break;\n      }\n    }\n    clut_data=(unsigned char *) RelinquishMagickMemory(clut_data);\n    /* CSM: CLUT Storage Mode */\n    switch ((int) header->clut_type>>4)  /* High 4 bits */\n    {\n      case 0:\n        csm=CSM1;\n        break;\n      case 1:\n        csm=CSM2;\n        break;\n      default:\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image_info->filename);\n        break;\n    }\n    if (csm == CSM1)\n      {\n        PixelInfo\n          *oldColormap;\n\n        oldColormap=(PixelInfo *) AcquireQuantumMemory((size_t)(image->colors)+\n          1,sizeof(*image->colormap));\n        if (oldColormap == (PixelInfo *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image_info->filename);\n        deshufflePalette(image,oldColormap);\n        RelinquishMagickMemory(oldColormap);\n      }\n  }\n  return(status);\n}\n\nstatic Image *ReadTIM2Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  TIM2FileHeader\n    file_header;\n\n  /*\n   * Open image file.\n   */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  file_header.magic_num=ReadBlobMSBLong(image);\n  if (file_header.magic_num != 0x54494D32) /* \"TIM2\" */\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  file_header.format_vers=ReadBlobByte(image);\n  if (file_header.format_vers != 0x04)\n    ThrowReaderException(CoderError,\"ImageTypeNotSupported\");\n  file_header.format_type=ReadBlobByte(image);\n  file_header.image_count=ReadBlobLSBShort(image);\n  if (DiscardBlobBytes(image,8) == MagickFalse) /* reserved */\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  if ((file_header.format_type > 0) &&\n      (DiscardBlobBytes(image,112) == MagickFalse))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n   * Process each image. Only one image supported for now\n   */\n  if (file_header.image_count != 1)\n    ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n  for (i=0; i < (ssize_t) file_header.image_count; i++)\n  {\n    char\n      clut_depth,\n      bits_per_pixel;\n\n    TIM2ImageHeader\n      image_header;\n\n    if (i > 0)\n      {\n        /*\n          Proceed to next image.\n        */\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n    ReadTIM2ImageHeader(image,&image_header);\n    if (image_header.mipmap_count != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (image_header.header_size < 48)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((MagickSizeType) image_header.image_size > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((MagickSizeType) image_header.clut_size > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    image->columns=image_header.width;\n    image->rows=image_header.height;\n    clut_depth=0;\n    if (image_header.clut_type !=0)\n      {\n        switch((int) image_header.clut_type&0x0F)  /* Low 4 bits */\n        {\n          case 1:\n            clut_depth=16;\n            break;\n          case 2:\n            clut_depth=24;\n            break;\n          case 3:\n            clut_depth=32;\n            break;\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            break;\n        }\n      }\n    switch ((int) image_header.bpp_type)\n    {\n      case 1:\n        bits_per_pixel=16;\n        break;\n      case 2:\n        bits_per_pixel=24;\n        break;\n      case 3:\n        bits_per_pixel=32;\n        break;\n      case 4:\n        bits_per_pixel=4;  /* Implies CLUT */\n        break;\n      case 5:\n        bits_per_pixel=8;  /* Implies CLUT */\n        break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        break;\n    }\n    image->depth=(clut_depth != 0) ? clut_depth : bits_per_pixel;\n    if ((image->depth == 16) || (image->depth == 32))\n      image->alpha_trait=BlendPixelTrait;\n    if (image->ping == MagickFalse)\n      {\n        status=ReadTIM2ImageData(image_info,image,&image_header,clut_depth,\n          bits_per_pixel,exception);\n        if (status==MagickFalse)\n          break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((image->storage_class == PseudoClass) && (EOFBlob(image) != MagickFalse))\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I M 2 I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIM2Image() adds attributes for the TIM2 image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIM2Image method is:\n%\n%      size_t RegisterTIM2Image(void)\n%\n*/\nModuleExport size_t RegisterTIM2Image(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TIM2\",\"TM2\",\"PS2 TIM2\");\n  entry->decoder=(DecodeImageHandler *) ReadTIM2Image;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I M 2 I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIM2Image() removes format registrations made by the\n%  TIM2 module from the list of supported formats.\n%\n%  The format of the UnregisterTIM2Image method is:\n%\n%      UnregisterTIM2Image(void)\n%\n*/\nModuleExport void UnregisterTIM2Image(void)\n{\n  (void) UnregisterMagickInfo(\"TM2\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               PPPP   RRRR    OOO   FFFFF  IIIII  L      EEEEE               %\n%               P   P  R   R  O   O  F        I    L      E                   %\n%               PPPP   RRRR   O   O  FFF      I    L      EEE                 %\n%               P      R R    O   O  F        I    L      E                   %\n%               P      R  R    OOO   F      IIIII  LLLLL  EEEEE               %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Image Profile Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#include <wchar.h>\n#if defined(MAGICKCORE_HAVE_LCMS_LCMS2_H)\n#include <lcms/lcms2.h>\n#else\n#include \"lcms2.h\"\n#endif\n#endif\n#if defined(MAGICKCORE_XML_DELEGATE)\n#  include <libxml/parser.h>\n#  include <libxml/tree.h>\n#endif\n\f\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  SetImageProfileInternal(Image *,const char *,const StringInfo *,\n    const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  WriteTo8BimProfile(Image *,const char*,const StringInfo *);\n\f\n/*\n  Typedef declarations\n*/\nstruct _ProfileInfo\n{\n  char\n    *name;\n\n  size_t\n    length;\n\n  unsigned char\n    *info;\n\n  size_t\n    signature;\n};\n\ntypedef struct _CMSExceptionInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} CMSExceptionInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o f i l e s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProfiles() clones one or more image profiles.\n%\n%  The format of the CloneImageProfiles method is:\n%\n%      MagickBooleanType CloneImageProfiles(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProfiles(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (clone_image->profiles != (void *) NULL)\n    {\n      if (image->profiles != (void *) NULL)\n        DestroyImageProfiles(image);\n      image->profiles=CloneSplayTree((SplayTreeInfo *) clone_image->profiles,\n        (void *(*)(void *)) ConstantString,(void *(*)(void *)) CloneStringInfo);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProfile() deletes a profile from the image by its name.\n%\n%  The format of the DeleteImageProfile method is:\n%\n%      MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return(MagickFalse);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->profiles,name));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o f i l e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProfiles() releases memory associated with an image profile map.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      void DestroyImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProfiles(Image *image)\n{\n  if (image->profiles != (SplayTreeInfo *) NULL)\n    image->profiles=DestroySplayTree((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProfile() gets a profile associated with an image by name.\n%\n%  The format of the GetImageProfile method is:\n%\n%      const StringInfo *GetImageProfile(const Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport const StringInfo *GetImageProfile(const Image *image,\n  const char *name)\n{\n  const StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  profile=(const StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o f i l e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProfile() gets the next profile name for an image.\n%\n%  The format of the GetNextImageProfile method is:\n%\n%      char *GetNextImageProfile(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o hash_info: the hash info.\n%\n*/\nMagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P r o f i l e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProfileImage() associates, applies, or removes an ICM, IPTC, or generic\n%  profile with / to / from an image.  If the profile is NULL, it is removed\n%  from the image otherwise added or applied.  Use a name of '*' and a profile\n%  of NULL to remove all profiles from the image.\n%\n%  ICC and ICM profiles are handled as follows: If the image does not have\n%  an associated color profile, the one you provide is associated with the\n%  image and the image pixels are not transformed.  Otherwise, the colorspace\n%  transform defined by the existing and new profile are applied to the image\n%  pixels and the new profile is associated with the image.\n%\n%  The format of the ProfileImage method is:\n%\n%      MagickBooleanType ProfileImage(Image *image,const char *name,\n%        const void *datum,const size_t length,const MagickBooleanType clone)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: Name of profile to add or remove: ICC, IPTC, or generic profile.\n%\n%    o datum: the profile data.\n%\n%    o length: the length of the profile.\n%\n%    o clone: should be MagickFalse.\n%\n*/\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n\ntypedef struct _LCMSInfo\n{\n  ColorspaceType\n    colorspace;\n\n  cmsUInt32Number\n    type;\n\n  size_t\n    channels;\n\n  cmsHPROFILE\n    profile;\n\n  int\n    intent;\n\n  double\n    scale[4],\n    translate[4];\n\n  void\n    **magick_restrict pixels;\n} LCMSInfo;\n\n#if LCMS_VERSION < 2060\nstatic void* cmsGetContextUserData(cmsContext ContextID)\n{\n  return(ContextID);\n}\n\nstatic cmsContext cmsCreateContext(void *magick_unused(Plugin),void *UserData)\n{\n  magick_unreferenced(Plugin);\n  return((cmsContext) UserData);\n}\n\nstatic void cmsSetLogErrorHandlerTHR(cmsContext magick_unused(ContextID),\n  cmsLogErrorHandlerFunction Fn)\n{\n  magick_unreferenced(ContextID);\n  cmsSetLogErrorHandler(Fn);\n}\n\nstatic void cmsDeleteContext(cmsContext magick_unused(ContextID))\n{\n  magick_unreferenced(ContextID);\n}\n#endif\n\nstatic void **DestroyPixelTLS(void **pixels)\n{\n  ssize_t\n    i;\n\n  if (pixels == (void **) NULL)\n    return((void **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (void *) NULL)\n      pixels[i]=RelinquishMagickMemory(pixels[i]);\n  pixels=(void **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic void **AcquirePixelTLS(const size_t columns,const size_t channels,\n  MagickBooleanType highres)\n{\n  ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  size_t\n    size;\n\n  void\n    **pixels;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(void **) AcquireQuantumMemory(number_threads,sizeof(*pixels));\n  if (pixels == (void **) NULL)\n    return((void **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  size=sizeof(double);\n  if (highres == MagickFalse)\n    size=sizeof(Quantum);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=AcquireQuantumMemory(columns,channels*size);\n    if (pixels[i] == (void *) NULL)\n      return(DestroyPixelTLS(pixels));\n  }\n  return(pixels);\n}\n\nstatic cmsHTRANSFORM *DestroyTransformTLS(cmsHTRANSFORM *transform)\n{\n  ssize_t\n    i;\n\n  assert(transform != (cmsHTRANSFORM *) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (transform[i] != (cmsHTRANSFORM) NULL)\n      cmsDeleteTransform(transform[i]);\n  transform=(cmsHTRANSFORM *) RelinquishMagickMemory(transform);\n  return(transform);\n}\n\nstatic cmsHTRANSFORM *AcquireTransformTLS(const LCMSInfo *source_info,\n  const LCMSInfo *target_info,const cmsUInt32Number flags,\n  cmsContext cms_context)\n{\n  cmsHTRANSFORM\n    *transform;\n\n  size_t\n    number_threads;\n\n  ssize_t\n    i;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  transform=(cmsHTRANSFORM *) AcquireQuantumMemory(number_threads,\n    sizeof(*transform));\n  if (transform == (cmsHTRANSFORM *) NULL)\n    return((cmsHTRANSFORM *) NULL);\n  (void) memset(transform,0,number_threads*sizeof(*transform));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    transform[i]=cmsCreateTransformTHR(cms_context,source_info->profile,\n      source_info->type,target_info->profile,target_info->type,\n      target_info->intent,flags);\n    if (transform[i] == (cmsHTRANSFORM) NULL)\n      return(DestroyTransformTLS(transform));\n  }\n  return(transform);\n}\n\nstatic void CMSExceptionHandler(cmsContext context,cmsUInt32Number severity,\n  const char *message)\n{\n  CMSExceptionInfo\n    *cms_exception;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  cms_exception=(CMSExceptionInfo *) cmsGetContextUserData(context);\n  if (cms_exception == (CMSExceptionInfo *) NULL)\n    return;\n  exception=cms_exception->exception;\n  if (exception == (ExceptionInfo *) NULL)\n    return;\n  image=cms_exception->image;\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"UnableToTransformColorspace\",\"`%s'\",\"unknown context\");\n      return;\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"lcms: #%u, %s\",\n      severity,message != (char *) NULL ? message : \"no message\");\n  (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n    \"UnableToTransformColorspace\",\"`%s', %s (#%u)\",image->filename,\n    message != (char *) NULL ? message : \"no message\",severity);\n}\n\nstatic void TransformDoublePixels(const int id,const Image* image,\n  const LCMSInfo *source_info,const LCMSInfo *target_info,\n  const cmsHTRANSFORM *transform,Quantum *q)\n{\n#define GetLCMSPixel(source_info,pixel,index) \\\n  (source_info->scale[index]*((QuantumScale*pixel)+source_info->translate[index]))\n#define SetLCMSPixel(target_info,pixel,index) \\\n  ClampToQuantum(target_info->scale[index]*((QuantumRange*pixel)+target_info->translate[index]))\n\n  double\n    *p;\n\n  ssize_t\n    x;\n\n  p=(double *) source_info->pixels[id];\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    *p++=GetLCMSPixel(source_info,GetPixelRed(image,q),0);\n    if (source_info->channels > 1)\n      {\n        *p++=GetLCMSPixel(source_info,GetPixelGreen(image,q),1);\n        *p++=GetLCMSPixel(source_info,GetPixelBlue(image,q),2);\n      }\n    if (source_info->channels > 3)\n      *p++=GetLCMSPixel(source_info,GetPixelBlack(image,q),3);\n    q+=GetPixelChannels(image);\n  }\n  cmsDoTransform(transform[id],source_info->pixels[id],target_info->pixels[id],\n    (unsigned int) image->columns);\n  p=(double *) target_info->pixels[id];\n  q-=GetPixelChannels(image)*image->columns;\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (target_info->channels == 1)\n      SetPixelGray(image,SetLCMSPixel(target_info,*p,0),q);\n    else\n      SetPixelRed(image,SetLCMSPixel(target_info,*p,0),q);\n    p++;\n    if (target_info->channels > 1)\n      {\n        SetPixelGreen(image,SetLCMSPixel(target_info,*p,1),q);\n        p++;\n        SetPixelBlue(image,SetLCMSPixel(target_info,*p,2),q);\n        p++;\n      }\n    if (target_info->channels > 3)\n      {\n        SetPixelBlack(image,SetLCMSPixel(target_info,*p,3),q);\n        p++;\n      }\n    q+=GetPixelChannels(image);\n  }\n}\n\nstatic void TransformQuantumPixels(const int id,const Image* image,\n  const LCMSInfo *source_info,const LCMSInfo *target_info,\n  const cmsHTRANSFORM *transform,Quantum *q)\n{\n  Quantum\n    *p;\n\n  ssize_t\n    x;\n\n  p=(Quantum *) source_info->pixels[id];\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    *p++=GetPixelRed(image,q);\n    if (source_info->channels > 1)\n      {\n        *p++=GetPixelGreen(image,q);\n        *p++=GetPixelBlue(image,q);\n      }\n    if (source_info->channels > 3)\n      *p++=GetPixelBlack(image,q);\n    q+=GetPixelChannels(image);\n  }\n  cmsDoTransform(transform[id],source_info->pixels[id],target_info->pixels[id],\n    (unsigned int) image->columns);\n  p=(Quantum *) target_info->pixels[id];\n  q-=GetPixelChannels(image)*image->columns;\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (target_info->channels == 1)\n      SetPixelGray(image,*p++,q);\n    else\n      SetPixelRed(image,*p++,q);\n    if (target_info->channels > 1)\n      {\n        SetPixelGreen(image,*p++,q);\n        SetPixelBlue(image,*p++,q);\n      }\n    if (target_info->channels > 3)\n      SetPixelBlack(image,*p++,q);\n    q+=GetPixelChannels(image);\n  }\n}\n\nstatic inline void SetLCMSInfoTranslate(LCMSInfo *info,const double translate)\n{\n  info->translate[0]=translate;\n  info->translate[1]=translate;\n  info->translate[2]=translate;\n  info->translate[3]=translate;\n}\n\nstatic inline void SetLCMSInfoScale(LCMSInfo *info,const double scale)\n{\n  info->scale[0]=scale;\n  info->scale[1]=scale;\n  info->scale[2]=scale;\n  info->scale[3]=scale;\n}\n#endif\n\nstatic MagickBooleanType SetsRGBImageProfile(Image *image,\n  ExceptionInfo *exception)\n{\n  static unsigned char\n    sRGBProfile[] =\n    {\n      0x00, 0x00, 0x0c, 0x8c, 0x61, 0x72, 0x67, 0x6c, 0x02, 0x20, 0x00, 0x00,\n      0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20,\n      0x07, 0xde, 0x00, 0x01, 0x00, 0x06, 0x00, 0x16, 0x00, 0x0f, 0x00, 0x3a,\n      0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,\n      0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xd6,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d, 0x61, 0x72, 0x67, 0x6c,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x99,\n      0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0xec, 0x00, 0x00, 0x00, 0x67,\n      0x64, 0x6d, 0x6e, 0x64, 0x00, 0x00, 0x02, 0x54, 0x00, 0x00, 0x00, 0x70,\n      0x64, 0x6d, 0x64, 0x64, 0x00, 0x00, 0x02, 0xc4, 0x00, 0x00, 0x00, 0x88,\n      0x74, 0x65, 0x63, 0x68, 0x00, 0x00, 0x03, 0x4c, 0x00, 0x00, 0x00, 0x0c,\n      0x76, 0x75, 0x65, 0x64, 0x00, 0x00, 0x03, 0x58, 0x00, 0x00, 0x00, 0x67,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x24,\n      0x6c, 0x75, 0x6d, 0x69, 0x00, 0x00, 0x03, 0xe4, 0x00, 0x00, 0x00, 0x14,\n      0x6d, 0x65, 0x61, 0x73, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x24,\n      0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x6b, 0x70, 0x74, 0x00, 0x00, 0x04, 0x30, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x44, 0x00, 0x00, 0x00, 0x14,\n      0x67, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x58, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x6c, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,\n      0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36,\n      0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75, 0x69, 0x76,\n      0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x77, 0x77,\n      0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20, 0x31, 0x39,\n      0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c,\n      0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x3f, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31,\n      0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75,\n      0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77,\n      0x77, 0x77, 0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20,\n      0x31, 0x39, 0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66,\n      0x69, 0x6c, 0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x72, 0x65, 0x61,\n      0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x47, 0x72, 0x61, 0x65, 0x6d,\n      0x65, 0x20, 0x57, 0x2e, 0x20, 0x47, 0x69, 0x6c, 0x6c, 0x2e, 0x20, 0x52,\n      0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f,\n      0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,\n      0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x4e, 0x6f, 0x20, 0x57,\n      0x61, 0x72, 0x72, 0x61, 0x6e, 0x74, 0x79, 0x2c, 0x20, 0x55, 0x73, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6f, 0x77, 0x6e,\n      0x20, 0x72, 0x69, 0x73, 0x6b, 0x2e, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20,\n      0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69,\n      0x65, 0x63, 0x2e, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74,\n      0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e,\n      0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,\n      0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e,\n      0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47,\n      0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61,\n      0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x45, 0x43,\n      0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44,\n      0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63,\n      0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,\n      0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x73, 0x69, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x43, 0x52, 0x54, 0x20, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xa4, 0x7c,\n      0x00, 0x14, 0x5f, 0x30, 0x00, 0x10, 0xce, 0x02, 0x00, 0x03, 0xed, 0xb2,\n      0x00, 0x04, 0x13, 0x0a, 0x00, 0x03, 0x5c, 0x67, 0x00, 0x00, 0x00, 0x01,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x0a, 0x3d,\n      0x00, 0x50, 0x00, 0x00, 0x00, 0x57, 0x1e, 0xb8, 0x6d, 0x65, 0x61, 0x73,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x02, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x51, 0x00, 0x01, 0x00, 0x00,\n      0x00, 0x01, 0x16, 0xcc, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa0,\n      0x00, 0x00, 0x38, 0xf5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x97, 0x00, 0x00, 0xb7, 0x87,\n      0x00, 0x00, 0x18, 0xd9, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x24, 0x9f, 0x00, 0x00, 0x0f, 0x84, 0x00, 0x00, 0xb6, 0xc4,\n      0x63, 0x75, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n      0x00, 0x00, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x14, 0x00, 0x19,\n      0x00, 0x1e, 0x00, 0x23, 0x00, 0x28, 0x00, 0x2d, 0x00, 0x32, 0x00, 0x37,\n      0x00, 0x3b, 0x00, 0x40, 0x00, 0x45, 0x00, 0x4a, 0x00, 0x4f, 0x00, 0x54,\n      0x00, 0x59, 0x00, 0x5e, 0x00, 0x63, 0x00, 0x68, 0x00, 0x6d, 0x00, 0x72,\n      0x00, 0x77, 0x00, 0x7c, 0x00, 0x81, 0x00, 0x86, 0x00, 0x8b, 0x00, 0x90,\n      0x00, 0x95, 0x00, 0x9a, 0x00, 0x9f, 0x00, 0xa4, 0x00, 0xa9, 0x00, 0xae,\n      0x00, 0xb2, 0x00, 0xb7, 0x00, 0xbc, 0x00, 0xc1, 0x00, 0xc6, 0x00, 0xcb,\n      0x00, 0xd0, 0x00, 0xd5, 0x00, 0xdb, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0xeb,\n      0x00, 0xf0, 0x00, 0xf6, 0x00, 0xfb, 0x01, 0x01, 0x01, 0x07, 0x01, 0x0d,\n      0x01, 0x13, 0x01, 0x19, 0x01, 0x1f, 0x01, 0x25, 0x01, 0x2b, 0x01, 0x32,\n      0x01, 0x38, 0x01, 0x3e, 0x01, 0x45, 0x01, 0x4c, 0x01, 0x52, 0x01, 0x59,\n      0x01, 0x60, 0x01, 0x67, 0x01, 0x6e, 0x01, 0x75, 0x01, 0x7c, 0x01, 0x83,\n      0x01, 0x8b, 0x01, 0x92, 0x01, 0x9a, 0x01, 0xa1, 0x01, 0xa9, 0x01, 0xb1,\n      0x01, 0xb9, 0x01, 0xc1, 0x01, 0xc9, 0x01, 0xd1, 0x01, 0xd9, 0x01, 0xe1,\n      0x01, 0xe9, 0x01, 0xf2, 0x01, 0xfa, 0x02, 0x03, 0x02, 0x0c, 0x02, 0x14,\n      0x02, 0x1d, 0x02, 0x26, 0x02, 0x2f, 0x02, 0x38, 0x02, 0x41, 0x02, 0x4b,\n      0x02, 0x54, 0x02, 0x5d, 0x02, 0x67, 0x02, 0x71, 0x02, 0x7a, 0x02, 0x84,\n      0x02, 0x8e, 0x02, 0x98, 0x02, 0xa2, 0x02, 0xac, 0x02, 0xb6, 0x02, 0xc1,\n      0x02, 0xcb, 0x02, 0xd5, 0x02, 0xe0, 0x02, 0xeb, 0x02, 0xf5, 0x03, 0x00,\n      0x03, 0x0b, 0x03, 0x16, 0x03, 0x21, 0x03, 0x2d, 0x03, 0x38, 0x03, 0x43,\n      0x03, 0x4f, 0x03, 0x5a, 0x03, 0x66, 0x03, 0x72, 0x03, 0x7e, 0x03, 0x8a,\n      0x03, 0x96, 0x03, 0xa2, 0x03, 0xae, 0x03, 0xba, 0x03, 0xc7, 0x03, 0xd3,\n      0x03, 0xe0, 0x03, 0xec, 0x03, 0xf9, 0x04, 0x06, 0x04, 0x13, 0x04, 0x20,\n      0x04, 0x2d, 0x04, 0x3b, 0x04, 0x48, 0x04, 0x55, 0x04, 0x63, 0x04, 0x71,\n      0x04, 0x7e, 0x04, 0x8c, 0x04, 0x9a, 0x04, 0xa8, 0x04, 0xb6, 0x04, 0xc4,\n      0x04, 0xd3, 0x04, 0xe1, 0x04, 0xf0, 0x04, 0xfe, 0x05, 0x0d, 0x05, 0x1c,\n      0x05, 0x2b, 0x05, 0x3a, 0x05, 0x49, 0x05, 0x58, 0x05, 0x67, 0x05, 0x77,\n      0x05, 0x86, 0x05, 0x96, 0x05, 0xa6, 0x05, 0xb5, 0x05, 0xc5, 0x05, 0xd5,\n      0x05, 0xe5, 0x05, 0xf6, 0x06, 0x06, 0x06, 0x16, 0x06, 0x27, 0x06, 0x37,\n      0x06, 0x48, 0x06, 0x59, 0x06, 0x6a, 0x06, 0x7b, 0x06, 0x8c, 0x06, 0x9d,\n      0x06, 0xaf, 0x06, 0xc0, 0x06, 0xd1, 0x06, 0xe3, 0x06, 0xf5, 0x07, 0x07,\n      0x07, 0x19, 0x07, 0x2b, 0x07, 0x3d, 0x07, 0x4f, 0x07, 0x61, 0x07, 0x74,\n      0x07, 0x86, 0x07, 0x99, 0x07, 0xac, 0x07, 0xbf, 0x07, 0xd2, 0x07, 0xe5,\n      0x07, 0xf8, 0x08, 0x0b, 0x08, 0x1f, 0x08, 0x32, 0x08, 0x46, 0x08, 0x5a,\n      0x08, 0x6e, 0x08, 0x82, 0x08, 0x96, 0x08, 0xaa, 0x08, 0xbe, 0x08, 0xd2,\n      0x08, 0xe7, 0x08, 0xfb, 0x09, 0x10, 0x09, 0x25, 0x09, 0x3a, 0x09, 0x4f,\n      0x09, 0x64, 0x09, 0x79, 0x09, 0x8f, 0x09, 0xa4, 0x09, 0xba, 0x09, 0xcf,\n      0x09, 0xe5, 0x09, 0xfb, 0x0a, 0x11, 0x0a, 0x27, 0x0a, 0x3d, 0x0a, 0x54,\n      0x0a, 0x6a, 0x0a, 0x81, 0x0a, 0x98, 0x0a, 0xae, 0x0a, 0xc5, 0x0a, 0xdc,\n      0x0a, 0xf3, 0x0b, 0x0b, 0x0b, 0x22, 0x0b, 0x39, 0x0b, 0x51, 0x0b, 0x69,\n      0x0b, 0x80, 0x0b, 0x98, 0x0b, 0xb0, 0x0b, 0xc8, 0x0b, 0xe1, 0x0b, 0xf9,\n      0x0c, 0x12, 0x0c, 0x2a, 0x0c, 0x43, 0x0c, 0x5c, 0x0c, 0x75, 0x0c, 0x8e,\n      0x0c, 0xa7, 0x0c, 0xc0, 0x0c, 0xd9, 0x0c, 0xf3, 0x0d, 0x0d, 0x0d, 0x26,\n      0x0d, 0x40, 0x0d, 0x5a, 0x0d, 0x74, 0x0d, 0x8e, 0x0d, 0xa9, 0x0d, 0xc3,\n      0x0d, 0xde, 0x0d, 0xf8, 0x0e, 0x13, 0x0e, 0x2e, 0x0e, 0x49, 0x0e, 0x64,\n      0x0e, 0x7f, 0x0e, 0x9b, 0x0e, 0xb6, 0x0e, 0xd2, 0x0e, 0xee, 0x0f, 0x09,\n      0x0f, 0x25, 0x0f, 0x41, 0x0f, 0x5e, 0x0f, 0x7a, 0x0f, 0x96, 0x0f, 0xb3,\n      0x0f, 0xcf, 0x0f, 0xec, 0x10, 0x09, 0x10, 0x26, 0x10, 0x43, 0x10, 0x61,\n      0x10, 0x7e, 0x10, 0x9b, 0x10, 0xb9, 0x10, 0xd7, 0x10, 0xf5, 0x11, 0x13,\n      0x11, 0x31, 0x11, 0x4f, 0x11, 0x6d, 0x11, 0x8c, 0x11, 0xaa, 0x11, 0xc9,\n      0x11, 0xe8, 0x12, 0x07, 0x12, 0x26, 0x12, 0x45, 0x12, 0x64, 0x12, 0x84,\n      0x12, 0xa3, 0x12, 0xc3, 0x12, 0xe3, 0x13, 0x03, 0x13, 0x23, 0x13, 0x43,\n      0x13, 0x63, 0x13, 0x83, 0x13, 0xa4, 0x13, 0xc5, 0x13, 0xe5, 0x14, 0x06,\n      0x14, 0x27, 0x14, 0x49, 0x14, 0x6a, 0x14, 0x8b, 0x14, 0xad, 0x14, 0xce,\n      0x14, 0xf0, 0x15, 0x12, 0x15, 0x34, 0x15, 0x56, 0x15, 0x78, 0x15, 0x9b,\n      0x15, 0xbd, 0x15, 0xe0, 0x16, 0x03, 0x16, 0x26, 0x16, 0x49, 0x16, 0x6c,\n      0x16, 0x8f, 0x16, 0xb2, 0x16, 0xd6, 0x16, 0xfa, 0x17, 0x1d, 0x17, 0x41,\n      0x17, 0x65, 0x17, 0x89, 0x17, 0xae, 0x17, 0xd2, 0x17, 0xf7, 0x18, 0x1b,\n      0x18, 0x40, 0x18, 0x65, 0x18, 0x8a, 0x18, 0xaf, 0x18, 0xd5, 0x18, 0xfa,\n      0x19, 0x20, 0x19, 0x45, 0x19, 0x6b, 0x19, 0x91, 0x19, 0xb7, 0x19, 0xdd,\n      0x1a, 0x04, 0x1a, 0x2a, 0x1a, 0x51, 0x1a, 0x77, 0x1a, 0x9e, 0x1a, 0xc5,\n      0x1a, 0xec, 0x1b, 0x14, 0x1b, 0x3b, 0x1b, 0x63, 0x1b, 0x8a, 0x1b, 0xb2,\n      0x1b, 0xda, 0x1c, 0x02, 0x1c, 0x2a, 0x1c, 0x52, 0x1c, 0x7b, 0x1c, 0xa3,\n      0x1c, 0xcc, 0x1c, 0xf5, 0x1d, 0x1e, 0x1d, 0x47, 0x1d, 0x70, 0x1d, 0x99,\n      0x1d, 0xc3, 0x1d, 0xec, 0x1e, 0x16, 0x1e, 0x40, 0x1e, 0x6a, 0x1e, 0x94,\n      0x1e, 0xbe, 0x1e, 0xe9, 0x1f, 0x13, 0x1f, 0x3e, 0x1f, 0x69, 0x1f, 0x94,\n      0x1f, 0xbf, 0x1f, 0xea, 0x20, 0x15, 0x20, 0x41, 0x20, 0x6c, 0x20, 0x98,\n      0x20, 0xc4, 0x20, 0xf0, 0x21, 0x1c, 0x21, 0x48, 0x21, 0x75, 0x21, 0xa1,\n      0x21, 0xce, 0x21, 0xfb, 0x22, 0x27, 0x22, 0x55, 0x22, 0x82, 0x22, 0xaf,\n      0x22, 0xdd, 0x23, 0x0a, 0x23, 0x38, 0x23, 0x66, 0x23, 0x94, 0x23, 0xc2,\n      0x23, 0xf0, 0x24, 0x1f, 0x24, 0x4d, 0x24, 0x7c, 0x24, 0xab, 0x24, 0xda,\n      0x25, 0x09, 0x25, 0x38, 0x25, 0x68, 0x25, 0x97, 0x25, 0xc7, 0x25, 0xf7,\n      0x26, 0x27, 0x26, 0x57, 0x26, 0x87, 0x26, 0xb7, 0x26, 0xe8, 0x27, 0x18,\n      0x27, 0x49, 0x27, 0x7a, 0x27, 0xab, 0x27, 0xdc, 0x28, 0x0d, 0x28, 0x3f,\n      0x28, 0x71, 0x28, 0xa2, 0x28, 0xd4, 0x29, 0x06, 0x29, 0x38, 0x29, 0x6b,\n      0x29, 0x9d, 0x29, 0xd0, 0x2a, 0x02, 0x2a, 0x35, 0x2a, 0x68, 0x2a, 0x9b,\n      0x2a, 0xcf, 0x2b, 0x02, 0x2b, 0x36, 0x2b, 0x69, 0x2b, 0x9d, 0x2b, 0xd1,\n      0x2c, 0x05, 0x2c, 0x39, 0x2c, 0x6e, 0x2c, 0xa2, 0x2c, 0xd7, 0x2d, 0x0c,\n      0x2d, 0x41, 0x2d, 0x76, 0x2d, 0xab, 0x2d, 0xe1, 0x2e, 0x16, 0x2e, 0x4c,\n      0x2e, 0x82, 0x2e, 0xb7, 0x2e, 0xee, 0x2f, 0x24, 0x2f, 0x5a, 0x2f, 0x91,\n      0x2f, 0xc7, 0x2f, 0xfe, 0x30, 0x35, 0x30, 0x6c, 0x30, 0xa4, 0x30, 0xdb,\n      0x31, 0x12, 0x31, 0x4a, 0x31, 0x82, 0x31, 0xba, 0x31, 0xf2, 0x32, 0x2a,\n      0x32, 0x63, 0x32, 0x9b, 0x32, 0xd4, 0x33, 0x0d, 0x33, 0x46, 0x33, 0x7f,\n      0x33, 0xb8, 0x33, 0xf1, 0x34, 0x2b, 0x34, 0x65, 0x34, 0x9e, 0x34, 0xd8,\n      0x35, 0x13, 0x35, 0x4d, 0x35, 0x87, 0x35, 0xc2, 0x35, 0xfd, 0x36, 0x37,\n      0x36, 0x72, 0x36, 0xae, 0x36, 0xe9, 0x37, 0x24, 0x37, 0x60, 0x37, 0x9c,\n      0x37, 0xd7, 0x38, 0x14, 0x38, 0x50, 0x38, 0x8c, 0x38, 0xc8, 0x39, 0x05,\n      0x39, 0x42, 0x39, 0x7f, 0x39, 0xbc, 0x39, 0xf9, 0x3a, 0x36, 0x3a, 0x74,\n      0x3a, 0xb2, 0x3a, 0xef, 0x3b, 0x2d, 0x3b, 0x6b, 0x3b, 0xaa, 0x3b, 0xe8,\n      0x3c, 0x27, 0x3c, 0x65, 0x3c, 0xa4, 0x3c, 0xe3, 0x3d, 0x22, 0x3d, 0x61,\n      0x3d, 0xa1, 0x3d, 0xe0, 0x3e, 0x20, 0x3e, 0x60, 0x3e, 0xa0, 0x3e, 0xe0,\n      0x3f, 0x21, 0x3f, 0x61, 0x3f, 0xa2, 0x3f, 0xe2, 0x40, 0x23, 0x40, 0x64,\n      0x40, 0xa6, 0x40, 0xe7, 0x41, 0x29, 0x41, 0x6a, 0x41, 0xac, 0x41, 0xee,\n      0x42, 0x30, 0x42, 0x72, 0x42, 0xb5, 0x42, 0xf7, 0x43, 0x3a, 0x43, 0x7d,\n      0x43, 0xc0, 0x44, 0x03, 0x44, 0x47, 0x44, 0x8a, 0x44, 0xce, 0x45, 0x12,\n      0x45, 0x55, 0x45, 0x9a, 0x45, 0xde, 0x46, 0x22, 0x46, 0x67, 0x46, 0xab,\n      0x46, 0xf0, 0x47, 0x35, 0x47, 0x7b, 0x47, 0xc0, 0x48, 0x05, 0x48, 0x4b,\n      0x48, 0x91, 0x48, 0xd7, 0x49, 0x1d, 0x49, 0x63, 0x49, 0xa9, 0x49, 0xf0,\n      0x4a, 0x37, 0x4a, 0x7d, 0x4a, 0xc4, 0x4b, 0x0c, 0x4b, 0x53, 0x4b, 0x9a,\n      0x4b, 0xe2, 0x4c, 0x2a, 0x4c, 0x72, 0x4c, 0xba, 0x4d, 0x02, 0x4d, 0x4a,\n      0x4d, 0x93, 0x4d, 0xdc, 0x4e, 0x25, 0x4e, 0x6e, 0x4e, 0xb7, 0x4f, 0x00,\n      0x4f, 0x49, 0x4f, 0x93, 0x4f, 0xdd, 0x50, 0x27, 0x50, 0x71, 0x50, 0xbb,\n      0x51, 0x06, 0x51, 0x50, 0x51, 0x9b, 0x51, 0xe6, 0x52, 0x31, 0x52, 0x7c,\n      0x52, 0xc7, 0x53, 0x13, 0x53, 0x5f, 0x53, 0xaa, 0x53, 0xf6, 0x54, 0x42,\n      0x54, 0x8f, 0x54, 0xdb, 0x55, 0x28, 0x55, 0x75, 0x55, 0xc2, 0x56, 0x0f,\n      0x56, 0x5c, 0x56, 0xa9, 0x56, 0xf7, 0x57, 0x44, 0x57, 0x92, 0x57, 0xe0,\n      0x58, 0x2f, 0x58, 0x7d, 0x58, 0xcb, 0x59, 0x1a, 0x59, 0x69, 0x59, 0xb8,\n      0x5a, 0x07, 0x5a, 0x56, 0x5a, 0xa6, 0x5a, 0xf5, 0x5b, 0x45, 0x5b, 0x95,\n      0x5b, 0xe5, 0x5c, 0x35, 0x5c, 0x86, 0x5c, 0xd6, 0x5d, 0x27, 0x5d, 0x78,\n      0x5d, 0xc9, 0x5e, 0x1a, 0x5e, 0x6c, 0x5e, 0xbd, 0x5f, 0x0f, 0x5f, 0x61,\n      0x5f, 0xb3, 0x60, 0x05, 0x60, 0x57, 0x60, 0xaa, 0x60, 0xfc, 0x61, 0x4f,\n      0x61, 0xa2, 0x61, 0xf5, 0x62, 0x49, 0x62, 0x9c, 0x62, 0xf0, 0x63, 0x43,\n      0x63, 0x97, 0x63, 0xeb, 0x64, 0x40, 0x64, 0x94, 0x64, 0xe9, 0x65, 0x3d,\n      0x65, 0x92, 0x65, 0xe7, 0x66, 0x3d, 0x66, 0x92, 0x66, 0xe8, 0x67, 0x3d,\n      0x67, 0x93, 0x67, 0xe9, 0x68, 0x3f, 0x68, 0x96, 0x68, 0xec, 0x69, 0x43,\n      0x69, 0x9a, 0x69, 0xf1, 0x6a, 0x48, 0x6a, 0x9f, 0x6a, 0xf7, 0x6b, 0x4f,\n      0x6b, 0xa7, 0x6b, 0xff, 0x6c, 0x57, 0x6c, 0xaf, 0x6d, 0x08, 0x6d, 0x60,\n      0x6d, 0xb9, 0x6e, 0x12, 0x6e, 0x6b, 0x6e, 0xc4, 0x6f, 0x1e, 0x6f, 0x78,\n      0x6f, 0xd1, 0x70, 0x2b, 0x70, 0x86, 0x70, 0xe0, 0x71, 0x3a, 0x71, 0x95,\n      0x71, 0xf0, 0x72, 0x4b, 0x72, 0xa6, 0x73, 0x01, 0x73, 0x5d, 0x73, 0xb8,\n      0x74, 0x14, 0x74, 0x70, 0x74, 0xcc, 0x75, 0x28, 0x75, 0x85, 0x75, 0xe1,\n      0x76, 0x3e, 0x76, 0x9b, 0x76, 0xf8, 0x77, 0x56, 0x77, 0xb3, 0x78, 0x11,\n      0x78, 0x6e, 0x78, 0xcc, 0x79, 0x2a, 0x79, 0x89, 0x79, 0xe7, 0x7a, 0x46,\n      0x7a, 0xa5, 0x7b, 0x04, 0x7b, 0x63, 0x7b, 0xc2, 0x7c, 0x21, 0x7c, 0x81,\n      0x7c, 0xe1, 0x7d, 0x41, 0x7d, 0xa1, 0x7e, 0x01, 0x7e, 0x62, 0x7e, 0xc2,\n      0x7f, 0x23, 0x7f, 0x84, 0x7f, 0xe5, 0x80, 0x47, 0x80, 0xa8, 0x81, 0x0a,\n      0x81, 0x6b, 0x81, 0xcd, 0x82, 0x30, 0x82, 0x92, 0x82, 0xf4, 0x83, 0x57,\n      0x83, 0xba, 0x84, 0x1d, 0x84, 0x80, 0x84, 0xe3, 0x85, 0x47, 0x85, 0xab,\n      0x86, 0x0e, 0x86, 0x72, 0x86, 0xd7, 0x87, 0x3b, 0x87, 0x9f, 0x88, 0x04,\n      0x88, 0x69, 0x88, 0xce, 0x89, 0x33, 0x89, 0x99, 0x89, 0xfe, 0x8a, 0x64,\n      0x8a, 0xca, 0x8b, 0x30, 0x8b, 0x96, 0x8b, 0xfc, 0x8c, 0x63, 0x8c, 0xca,\n      0x8d, 0x31, 0x8d, 0x98, 0x8d, 0xff, 0x8e, 0x66, 0x8e, 0xce, 0x8f, 0x36,\n      0x8f, 0x9e, 0x90, 0x06, 0x90, 0x6e, 0x90, 0xd6, 0x91, 0x3f, 0x91, 0xa8,\n      0x92, 0x11, 0x92, 0x7a, 0x92, 0xe3, 0x93, 0x4d, 0x93, 0xb6, 0x94, 0x20,\n      0x94, 0x8a, 0x94, 0xf4, 0x95, 0x5f, 0x95, 0xc9, 0x96, 0x34, 0x96, 0x9f,\n      0x97, 0x0a, 0x97, 0x75, 0x97, 0xe0, 0x98, 0x4c, 0x98, 0xb8, 0x99, 0x24,\n      0x99, 0x90, 0x99, 0xfc, 0x9a, 0x68, 0x9a, 0xd5, 0x9b, 0x42, 0x9b, 0xaf,\n      0x9c, 0x1c, 0x9c, 0x89, 0x9c, 0xf7, 0x9d, 0x64, 0x9d, 0xd2, 0x9e, 0x40,\n      0x9e, 0xae, 0x9f, 0x1d, 0x9f, 0x8b, 0x9f, 0xfa, 0xa0, 0x69, 0xa0, 0xd8,\n      0xa1, 0x47, 0xa1, 0xb6, 0xa2, 0x26, 0xa2, 0x96, 0xa3, 0x06, 0xa3, 0x76,\n      0xa3, 0xe6, 0xa4, 0x56, 0xa4, 0xc7, 0xa5, 0x38, 0xa5, 0xa9, 0xa6, 0x1a,\n      0xa6, 0x8b, 0xa6, 0xfd, 0xa7, 0x6e, 0xa7, 0xe0, 0xa8, 0x52, 0xa8, 0xc4,\n      0xa9, 0x37, 0xa9, 0xa9, 0xaa, 0x1c, 0xaa, 0x8f, 0xab, 0x02, 0xab, 0x75,\n      0xab, 0xe9, 0xac, 0x5c, 0xac, 0xd0, 0xad, 0x44, 0xad, 0xb8, 0xae, 0x2d,\n      0xae, 0xa1, 0xaf, 0x16, 0xaf, 0x8b, 0xb0, 0x00, 0xb0, 0x75, 0xb0, 0xea,\n      0xb1, 0x60, 0xb1, 0xd6, 0xb2, 0x4b, 0xb2, 0xc2, 0xb3, 0x38, 0xb3, 0xae,\n      0xb4, 0x25, 0xb4, 0x9c, 0xb5, 0x13, 0xb5, 0x8a, 0xb6, 0x01, 0xb6, 0x79,\n      0xb6, 0xf0, 0xb7, 0x68, 0xb7, 0xe0, 0xb8, 0x59, 0xb8, 0xd1, 0xb9, 0x4a,\n      0xb9, 0xc2, 0xba, 0x3b, 0xba, 0xb5, 0xbb, 0x2e, 0xbb, 0xa7, 0xbc, 0x21,\n      0xbc, 0x9b, 0xbd, 0x15, 0xbd, 0x8f, 0xbe, 0x0a, 0xbe, 0x84, 0xbe, 0xff,\n      0xbf, 0x7a, 0xbf, 0xf5, 0xc0, 0x70, 0xc0, 0xec, 0xc1, 0x67, 0xc1, 0xe3,\n      0xc2, 0x5f, 0xc2, 0xdb, 0xc3, 0x58, 0xc3, 0xd4, 0xc4, 0x51, 0xc4, 0xce,\n      0xc5, 0x4b, 0xc5, 0xc8, 0xc6, 0x46, 0xc6, 0xc3, 0xc7, 0x41, 0xc7, 0xbf,\n      0xc8, 0x3d, 0xc8, 0xbc, 0xc9, 0x3a, 0xc9, 0xb9, 0xca, 0x38, 0xca, 0xb7,\n      0xcb, 0x36, 0xcb, 0xb6, 0xcc, 0x35, 0xcc, 0xb5, 0xcd, 0x35, 0xcd, 0xb5,\n      0xce, 0x36, 0xce, 0xb6, 0xcf, 0x37, 0xcf, 0xb8, 0xd0, 0x39, 0xd0, 0xba,\n      0xd1, 0x3c, 0xd1, 0xbe, 0xd2, 0x3f, 0xd2, 0xc1, 0xd3, 0x44, 0xd3, 0xc6,\n      0xd4, 0x49, 0xd4, 0xcb, 0xd5, 0x4e, 0xd5, 0xd1, 0xd6, 0x55, 0xd6, 0xd8,\n      0xd7, 0x5c, 0xd7, 0xe0, 0xd8, 0x64, 0xd8, 0xe8, 0xd9, 0x6c, 0xd9, 0xf1,\n      0xda, 0x76, 0xda, 0xfb, 0xdb, 0x80, 0xdc, 0x05, 0xdc, 0x8a, 0xdd, 0x10,\n      0xdd, 0x96, 0xde, 0x1c, 0xde, 0xa2, 0xdf, 0x29, 0xdf, 0xaf, 0xe0, 0x36,\n      0xe0, 0xbd, 0xe1, 0x44, 0xe1, 0xcc, 0xe2, 0x53, 0xe2, 0xdb, 0xe3, 0x63,\n      0xe3, 0xeb, 0xe4, 0x73, 0xe4, 0xfc, 0xe5, 0x84, 0xe6, 0x0d, 0xe6, 0x96,\n      0xe7, 0x1f, 0xe7, 0xa9, 0xe8, 0x32, 0xe8, 0xbc, 0xe9, 0x46, 0xe9, 0xd0,\n      0xea, 0x5b, 0xea, 0xe5, 0xeb, 0x70, 0xeb, 0xfb, 0xec, 0x86, 0xed, 0x11,\n      0xed, 0x9c, 0xee, 0x28, 0xee, 0xb4, 0xef, 0x40, 0xef, 0xcc, 0xf0, 0x58,\n      0xf0, 0xe5, 0xf1, 0x72, 0xf1, 0xff, 0xf2, 0x8c, 0xf3, 0x19, 0xf3, 0xa7,\n      0xf4, 0x34, 0xf4, 0xc2, 0xf5, 0x50, 0xf5, 0xde, 0xf6, 0x6d, 0xf6, 0xfb,\n      0xf7, 0x8a, 0xf8, 0x19, 0xf8, 0xa8, 0xf9, 0x38, 0xf9, 0xc7, 0xfa, 0x57,\n      0xfa, 0xe7, 0xfb, 0x77, 0xfc, 0x07, 0xfc, 0x98, 0xfd, 0x29, 0xfd, 0xba,\n      0xfe, 0x4b, 0xfe, 0xdc, 0xff, 0x6d, 0xff, 0xff\n    };\n\n  StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (GetImageProfile(image,\"icc\") != (const StringInfo *) NULL)\n    return(MagickFalse);\n  profile=AcquireStringInfo(sizeof(sRGBProfile));\n  SetStringInfoDatum(profile,sRGBProfile);\n  status=SetImageProfile(image,\"icc\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name,\n  const void *datum,const size_t length,ExceptionInfo *exception)\n{\n#define ProfileImageTag  \"Profile/Image\"\n#ifndef TYPE_XYZ_8\n  #define TYPE_XYZ_8 (COLORSPACE_SH(PT_XYZ)|CHANNELS_SH(3)|BYTES_SH(1))\n#endif\n#define ThrowProfileException(severity,tag,context) \\\n{ \\\n  if (profile != (StringInfo *) NULL) \\\n     profile=DestroyStringInfo(profile); \\\n  if (cms_context != (cmsContext) NULL) \\\n    cmsDeleteContext(cms_context); \\\n  if (source_info.profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(source_info.profile); \\\n  if (target_info.profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(target_info.profile); \\\n  ThrowBinaryException(severity,tag,context); \\\n}\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(name != (const char *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((datum == (const void *) NULL) || (length == 0))\n    {\n      char\n        *next;\n\n      /*\n        Delete image profile(s).\n      */\n      ResetImageProfileIterator(image);\n      for (next=GetNextImageProfile(image); next != (const char *) NULL; )\n      {\n        if (IsOptionMember(next,name) != MagickFalse)\n          {\n            (void) DeleteImageProfile(image,next);\n            ResetImageProfileIterator(image);\n          }\n        next=GetNextImageProfile(image);\n      }\n      return(MagickTrue);\n    }\n  /*\n    Add a ICC, IPTC, or generic profile to the image.\n  */\n  status=MagickTrue;\n  profile=AcquireStringInfo((size_t) length);\n  SetStringInfoDatum(profile,(unsigned char *) datum);\n  if ((LocaleCompare(name,\"icc\") != 0) && (LocaleCompare(name,\"icm\") != 0))\n    status=SetImageProfile(image,name,profile,exception);\n  else\n    {\n      const StringInfo\n        *icc_profile;\n\n      icc_profile=GetImageProfile(image,\"icc\");\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          const char\n            *value;\n\n          value=GetImageProperty(image,\"exif:ColorSpace\",exception);\n          (void) value;\n          if (LocaleCompare(value,\"1\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R98.\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          icc_profile=GetImageProfile(image,\"icc\");\n        }\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          profile=DestroyStringInfo(profile);\n          return(MagickTrue);\n        }\n#if !defined(MAGICKCORE_LCMS_DELEGATE)\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n        \"'%s' (LCMS)\",image->filename);\n#else\n      {\n        cmsContext\n          cms_context;\n\n        CMSExceptionInfo\n          cms_exception;\n\n        LCMSInfo\n          source_info,\n          target_info;\n\n        /*\n          Transform pixel colors as defined by the color profiles.\n        */\n        cms_exception.image=image;\n        cms_exception.exception=exception;\n        cms_context=cmsCreateContext(NULL,&cms_exception);\n        if (cms_context == (cmsContext) NULL)\n          {\n            profile=DestroyStringInfo(profile);\n            ThrowBinaryException(ResourceLimitError,\n              \"ColorspaceColorProfileMismatch\",name);\n          }\n        cmsSetLogErrorHandlerTHR(cms_context,CMSExceptionHandler);\n        source_info.profile=cmsOpenProfileFromMemTHR(cms_context,\n          GetStringInfoDatum(profile),(cmsUInt32Number)\n          GetStringInfoLength(profile));\n        if (source_info.profile == (cmsHPROFILE) NULL)\n          {\n            profile=DestroyStringInfo(profile);\n            cmsDeleteContext(cms_context);\n            ThrowBinaryException(ResourceLimitError,\n              \"ColorspaceColorProfileMismatch\",name);\n          }\n        if ((cmsGetDeviceClass(source_info.profile) != cmsSigLinkClass) &&\n            (icc_profile == (StringInfo *) NULL))\n          status=SetImageProfile(image,name,profile,exception);\n        else\n          {\n            CacheView\n              *image_view;\n\n            cmsColorSpaceSignature\n              signature;\n\n            cmsHTRANSFORM\n              *magick_restrict transform;\n\n            cmsUInt32Number\n              flags;\n\n            MagickBooleanType\n              highres;\n\n            MagickOffsetType\n              progress;\n\n            ssize_t\n              y;\n\n            target_info.profile=(cmsHPROFILE) NULL;\n            if (icc_profile != (StringInfo *) NULL)\n              {\n                target_info.profile=source_info.profile;\n                source_info.profile=cmsOpenProfileFromMemTHR(cms_context,\n                  GetStringInfoDatum(icc_profile),(cmsUInt32Number)\n                  GetStringInfoLength(icc_profile));\n                if (source_info.profile == (cmsHPROFILE) NULL)\n                  ThrowProfileException(ResourceLimitError,\n                    \"ColorspaceColorProfileMismatch\",name);\n              }\n            highres=MagickTrue;\n#if !defined(MAGICKCORE_HDRI_SUPPORT) || (MAGICKCORE_QUANTUM_DEPTH > 16)\n            {\n              const char\n                *artifact;\n\n              artifact=GetImageArtifact(image,\"profile:highres-transform\");\n              if (IsStringFalse(artifact) != MagickFalse)\n                highres=MagickFalse;\n            }\n#endif\n            SetLCMSInfoScale(&source_info,1.0);\n            SetLCMSInfoTranslate(&source_info,0.0);\n            source_info.colorspace=sRGBColorspace;\n            source_info.channels=3;\n            switch (cmsGetColorSpace(source_info.profile))\n            {\n              case cmsSigCmykData:\n              {\n                source_info.colorspace=CMYKColorspace;\n                source_info.channels=4;\n                if (highres != MagickFalse)\n                  {\n                    source_info.type=(cmsUInt32Number) TYPE_CMYK_DBL;\n                    SetLCMSInfoScale(&source_info,100.0);\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_CMYK_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_CMYK_16;\n#endif\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                source_info.colorspace=GRAYColorspace;\n                source_info.channels=1;\n                if (highres != MagickFalse)\n                  source_info.type=(cmsUInt32Number) TYPE_GRAY_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_GRAY_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_GRAY_16;\n#endif\n                break;\n              }\n              case cmsSigLabData:\n              {\n                source_info.colorspace=LabColorspace;\n                if (highres != MagickFalse)\n                  {\n                    source_info.type=(cmsUInt32Number) TYPE_Lab_DBL;\n                    source_info.scale[0]=100.0;\n                    source_info.scale[1]=255.0;\n                    source_info.scale[2]=255.0;\n                    source_info.translate[1]=(-0.5);\n                    source_info.translate[2]=(-0.5);\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_Lab_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_Lab_16;\n#endif\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                source_info.colorspace=sRGBColorspace;\n                if (highres != MagickFalse)\n                  source_info.type=(cmsUInt32Number) TYPE_RGB_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_RGB_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_RGB_16;\n#endif\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                source_info.colorspace=XYZColorspace;\n                if (highres != MagickFalse)\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_16;\n#endif\n                break;\n              }\n              default:\n                ThrowProfileException(ImageError,\n                  \"ColorspaceColorProfileMismatch\",name);\n            }\n            signature=cmsGetPCS(source_info.profile);\n            if (target_info.profile != (cmsHPROFILE) NULL)\n              signature=cmsGetColorSpace(target_info.profile);\n            SetLCMSInfoScale(&target_info,1.0);\n            SetLCMSInfoTranslate(&target_info,0.0);\n            target_info.channels=3;\n            switch (signature)\n            {\n              case cmsSigCmykData:\n              {\n                target_info.colorspace=CMYKColorspace;\n                target_info.channels=4;\n                if (highres != MagickFalse)\n                  {\n                    target_info.type=(cmsUInt32Number) TYPE_CMYK_DBL;\n                    SetLCMSInfoScale(&target_info,0.01);\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_CMYK_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_CMYK_16;\n#endif\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                target_info.colorspace=GRAYColorspace;\n                target_info.channels=1;\n                if (highres != MagickFalse)\n                  target_info.type=(cmsUInt32Number) TYPE_GRAY_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_GRAY_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_GRAY_16;\n#endif\n                break;\n              }\n              case cmsSigLabData:\n              {\n                target_info.colorspace=LabColorspace;\n                if (highres != MagickFalse)\n                  {\n                    target_info.type=(cmsUInt32Number) TYPE_Lab_DBL;\n                    target_info.scale[0]=0.01;\n                    target_info.scale[1]=1/255.0;\n                    target_info.scale[2]=1/255.0;\n                    target_info.translate[1]=0.5;\n                    target_info.translate[2]=0.5;\n                  }\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_Lab_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_Lab_16;\n#endif\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                target_info.colorspace=sRGBColorspace;\n                if (highres != MagickFalse)\n                  target_info.type=(cmsUInt32Number) TYPE_RGB_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_RGB_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_RGB_16;\n#endif\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                target_info.colorspace=XYZColorspace;\n                if (highres != MagickFalse)\n                  target_info.type=(cmsUInt32Number) TYPE_XYZ_DBL;\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n                else\n                  target_info.type=(cmsUInt32Number) TYPE_XYZ_8;\n#elif (MAGICKCORE_QUANTUM_DEPTH == 16)\n                else\n                  source_info.type=(cmsUInt32Number) TYPE_XYZ_16;\n#endif\n                break;\n              }\n              default:\n                ThrowProfileException(ImageError,\n                  \"ColorspaceColorProfileMismatch\",name);\n            }\n            switch (image->rendering_intent)\n            {\n              case AbsoluteIntent:\n              {\n                target_info.intent=INTENT_ABSOLUTE_COLORIMETRIC;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                target_info.intent=INTENT_PERCEPTUAL;\n                break;\n              }\n              case RelativeIntent:\n              {\n                target_info.intent=INTENT_RELATIVE_COLORIMETRIC;\n                break;\n              }\n              case SaturationIntent:\n              {\n                target_info.intent=INTENT_SATURATION;\n                break;\n              }\n              default:\n              {\n                target_info.intent=INTENT_PERCEPTUAL;\n                break;\n              }\n            }\n            flags=cmsFLAGS_HIGHRESPRECALC;\n#if defined(cmsFLAGS_BLACKPOINTCOMPENSATION)\n            if (image->black_point_compensation != MagickFalse)\n              flags|=cmsFLAGS_BLACKPOINTCOMPENSATION;\n#endif\n            transform=AcquireTransformTLS(&source_info,&target_info,flags,\n              cms_context);\n            if (transform == (cmsHTRANSFORM *) NULL)\n              ThrowProfileException(ImageError,\"UnableToCreateColorTransform\",\n                name);\n            /*\n              Transform image as dictated by the source & target image profiles.\n            */\n            source_info.pixels=AcquirePixelTLS(image->columns,\n              source_info.channels,highres);\n            target_info.pixels=AcquirePixelTLS(image->columns,\n              target_info.channels,highres);\n            if ((source_info.pixels == (void **) NULL) ||\n                (target_info.pixels == (void **) NULL))\n              {\n                target_info.pixels=DestroyPixelTLS(target_info.pixels);\n                source_info.pixels=DestroyPixelTLS(source_info.pixels);\n                transform=DestroyTransformTLS(transform);\n                ThrowProfileException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",image->filename);\n              }\n            if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n              {\n                target_info.pixels=DestroyPixelTLS(target_info.pixels);\n                source_info.pixels=DestroyPixelTLS(source_info.pixels);\n                transform=DestroyTransformTLS(transform);\n                if (source_info.profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(source_info.profile);\n                if (target_info.profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(target_info.profile);\n                return(MagickFalse);\n              }\n            if (target_info.colorspace == CMYKColorspace)\n              (void) SetImageColorspace(image,target_info.colorspace,exception);\n            progress=0;\n            image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel for schedule(static) shared(status) \\\n              magick_number_threads(image,image,image->rows,1)\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const int\n                id = GetOpenMPThreadId();\n\n              MagickBooleanType\n                sync;\n\n              Quantum\n                *magick_restrict q;\n\n              if (status == MagickFalse)\n                continue;\n              q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                {\n                  status=MagickFalse;\n                  continue;\n                }\n              if (highres != MagickFalse)\n                TransformDoublePixels(id,image,&source_info,&target_info,\n                  transform,q);\n              else\n                TransformQuantumPixels(id,image,&source_info,&target_info,\n                  transform,q);\n              sync=SyncCacheViewAuthenticPixels(image_view,exception);\n              if (sync == MagickFalse)\n                status=MagickFalse;\n              if (image->progress_monitor != (MagickProgressMonitor) NULL)\n                {\n                  MagickBooleanType\n                    proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n                  #pragma omp atomic\n#endif\n                  progress++;\n                  proceed=SetImageProgress(image,ProfileImageTag,progress,\n                    image->rows);\n                  if (proceed == MagickFalse)\n                    status=MagickFalse;\n                }\n            }\n            image_view=DestroyCacheView(image_view);\n            (void) SetImageColorspace(image,target_info.colorspace,exception);\n            switch (signature)\n            {\n              case cmsSigRgbData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  TrueColorType : TrueColorAlphaType;\n                break;\n              }\n              case cmsSigCmykData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  ColorSeparationType : ColorSeparationAlphaType;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  GrayscaleType : GrayscaleAlphaType;\n                break;\n              }\n              default:\n                break;\n            }\n            target_info.pixels=DestroyPixelTLS(target_info.pixels);\n            source_info.pixels=DestroyPixelTLS(source_info.pixels);\n            transform=DestroyTransformTLS(transform);\n            if ((status != MagickFalse) &&\n                (cmsGetDeviceClass(source_info.profile) != cmsSigLinkClass))\n              status=SetImageProfile(image,name,profile,exception);\n            if (target_info.profile != (cmsHPROFILE) NULL)\n              (void) cmsCloseProfile(target_info.profile);\n          }\n        (void) cmsCloseProfile(source_info.profile);\n        cmsDeleteContext(cms_context);\n      }\n#endif\n    }\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProfile() removes a named profile from the image and returns its\n%  value.\n%\n%  The format of the RemoveImageProfile method is:\n%\n%      void *RemoveImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport StringInfo *RemoveImageProfile(Image *image,const char *name)\n{\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  profile=(StringInfo *) RemoveNodeFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t P r o f i l e I t e r a t o r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImageProfileIterator() resets the image profile iterator.  Use it in\n%  conjunction with GetNextImageProfile() to iterate over all the profiles\n%  associated with an image.\n%\n%  The format of the ResetImageProfileIterator method is:\n%\n%      ResetImageProfileIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImageProfileIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProfile() adds a named profile to the image.  If a profile with the\n%  same name already exists, it is replaced.  This method differs from the\n%  ProfileImage() method in that it does not apply CMS color profiles.\n%\n%  The format of the SetImageProfile method is:\n%\n%      MagickBooleanType SetImageProfile(Image *image,const char *name,\n%        const StringInfo *profile)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name, for example icc, exif, and 8bim (8bim is the\n%      Photoshop wrapper for iptc profiles).\n%\n%    o profile: A StringInfo structure that contains the named profile.\n%\n*/\n\nstatic void *DestroyProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic inline const unsigned char *ReadResourceByte(const unsigned char *p,\n  unsigned char *quantum)\n{\n  *quantum=(*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(unsigned int) (*p++) << 24;\n  *quantum|=(unsigned int) (*p++) << 16;\n  *quantum|=(unsigned int) (*p++) << 8;\n  *quantum|=(unsigned int) (*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceShort(const unsigned char *p,\n  unsigned short *quantum)\n{\n  *quantum=(unsigned short) (*p++) << 8;\n  *quantum|=(unsigned short) (*p++);\n  return(p);\n}\n\nstatic inline void WriteResourceLong(unsigned char *p,\n  const unsigned int quantum)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) (quantum >> 24);\n  buffer[1]=(unsigned char) (quantum >> 16);\n  buffer[2]=(unsigned char) (quantum >> 8);\n  buffer[3]=(unsigned char) quantum;\n  (void) memcpy(p,buffer,4);\n}\n\nstatic void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((count < 0) || (p > (datum+length-count)) || (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_extent;\n\n        StringInfo\n          *extract_profile;\n\n        extract_extent=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) memcpy(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_extent=profile->length;\n            if ((extract_extent & 0x01) != 0)\n              extract_extent++;\n            extract_profile=AcquireStringInfo(offset+extract_extent+extent);\n            (void) memcpy(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,(unsigned int)\n              profile->length);\n            (void) memcpy(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) memcpy(extract_profile->datum+offset+extract_extent,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n\nstatic void GetProfilesFromResourceBlock(Image *image,\n  const StringInfo *resource_block,ExceptionInfo *exception)\n{\n  const unsigned char\n    *datum;\n\n  const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id;\n\n  datum=GetStringInfoDatum(resource_block);\n  length=GetStringInfoLength(resource_block);\n  for (p=datum; p < (datum+length-16); )\n  {\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length) ||\n        (count <= 0))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned int\n          resolution;\n\n        unsigned short\n          units;\n\n        /*\n          Resolution.\n        */\n        if (count < 10)\n          break;\n        p=ReadResourceLong(p,&resolution);\n        image->resolution.x=((double) resolution)/65536.0;\n        p=ReadResourceShort(p,&units)+2;\n        p=ReadResourceLong(p,&resolution)+4;\n        image->resolution.y=((double) resolution)/65536.0;\n        /*\n          Values are always stored as pixels per inch.\n        */\n        if ((ResolutionType) units != PixelsPerCentimeterResolution)\n          image->units=PixelsPerInchResolution;\n        else\n          {\n            image->units=PixelsPerCentimeterResolution;\n            image->resolution.x/=2.54;\n            image->resolution.y/=2.54;\n          }\n        break;\n      }\n      case 0x0404:\n      {\n        /*\n          IPTC profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"iptc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x040c:\n      {\n        /*\n          Thumbnail.\n        */\n        p+=count;\n        break;\n      }\n      case 0x040f:\n      {\n        /*\n          ICC Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"icc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0422:\n      {\n        /*\n          EXIF Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"exif\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0424:\n      {\n        /*\n          XMP Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"xmp\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void PatchCorruptProfile(const char *name,StringInfo *profile)\n{\n  unsigned char\n    *p;\n\n  size_t\n    length;\n\n  /*\n    Detect corrupt profiles and if discovered, repair.\n  */\n  if (LocaleCompare(name,\"xmp\") == 0)\n    {\n      /*\n        Remove garbage after xpacket end.\n      */\n      p=GetStringInfoDatum(profile);\n      p=(unsigned char *) strstr((const char *) p,\"<?xpacket end=\\\"w\\\"?>\");\n      if (p != (unsigned char *) NULL)\n        {\n          p+=19;\n          length=p-GetStringInfoDatum(profile);\n          if (length != GetStringInfoLength(profile))\n            {\n              *p='\\0';\n              SetStringInfoLength(profile,length);\n            }\n        }\n      return;\n    }\n  if (LocaleCompare(name,\"exif\") == 0)\n    {\n      /*\n        Check if profile starts with byte order marker instead of Exif.\n      */\n      p=GetStringInfoDatum(profile);\n      if ((LocaleNCompare((const char *) p,\"MM\",2) == 0) ||\n          (LocaleNCompare((const char *) p,\"II\",2) == 0))\n        {\n          const unsigned char\n            profile_start[] = \"Exif\\0\\0\";\n\n          StringInfo\n            *exif_profile;\n\n          exif_profile=AcquireStringInfo(6);\n          if (exif_profile != (StringInfo *) NULL)\n            {\n              SetStringInfoDatum(exif_profile,profile_start);\n              ConcatenateStringInfo(exif_profile,profile);\n              SetStringInfoLength(profile,GetStringInfoLength(exif_profile));\n              SetStringInfo(profile,exif_profile);\n              exif_profile=DestroyStringInfo(exif_profile);\n            }\n        }\n    }\n}\n\n#if defined(MAGICKCORE_XML_DELEGATE)\nstatic MagickBooleanType ValidateXMPProfile(Image *image,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  xmlDocPtr\n    document;\n\n  /*\n    Parse XML profile.\n  */\n  document=xmlReadMemory((const char *) GetStringInfoDatum(profile),(int)\n    GetStringInfoLength(profile),\"xmp.xml\",NULL,XML_PARSE_NOERROR |\n    XML_PARSE_NOWARNING);\n  if (document == (xmlDocPtr) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"CorruptImageProfile\",\"`%s' (XMP)\",image->filename);\n      return(MagickFalse);\n    }\n  xmlFreeDoc(document);\n  return(MagickTrue);\n}\n#else\nstatic MagickBooleanType ValidateXMPProfile(Image *image,\n  const StringInfo *magick_unused(profile),ExceptionInfo *exception)\n{\n  magick_unreferenced(profile);\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"'%s' (XML)\",\n    image->filename);\n  return(MagickFalse);\n}\n#endif\n\nstatic MagickBooleanType SetImageProfileInternal(Image *image,const char *name,\n  const StringInfo *profile,const MagickBooleanType recursive,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *clone_profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  clone_profile=CloneStringInfo(profile);\n  PatchCorruptProfile(name,clone_profile);\n  if ((LocaleCompare(name,\"xmp\") == 0) &&\n      (ValidateXMPProfile(image,clone_profile,exception) == MagickFalse))\n    {\n      clone_profile=DestroyStringInfo(clone_profile);\n      return(MagickTrue);\n    }\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MagickPathExtent);\n  LocaleLower(key);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),clone_profile);\n  if (status != MagickFalse)\n    {\n      if (LocaleCompare(name,\"8bim\") == 0)\n        GetProfilesFromResourceBlock(image,clone_profile,exception);\n      else\n        if (recursive == MagickFalse)\n          WriteTo8BimProfile(image,name,clone_profile);\n    }\n  return(status);\n}\n\nMagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  return(SetImageProfileInternal(image,name,profile,MagickFalse,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e P r o f i l e s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageProfiles() synchronizes image properties with the image profiles.\n%\n%  The format of the SyncImageProfiles method is:\n%\n%      void SyncImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline int ReadProfileByte(unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed short ReadProfileShort(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileLong(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileMSBLong(unsigned char **p,size_t *length)\n{\n  signed int\n    value;\n\n  if (*length < 4)\n    return(0);\n  value=ReadProfileLong(MSBEndian,*p);\n  (*length)-=4;\n  *p+=4;\n  return(value);\n}\n\nstatic inline signed short ReadProfileMSBShort(unsigned char **p,\n  size_t *length)\n{\n  signed short\n    value;\n\n  if (*length < 2)\n    return(0);\n  value=ReadProfileShort(MSBEndian,*p);\n  (*length)-=2;\n  *p+=2;\n  return(value);\n}\n\nstatic inline void WriteProfileLong(const EndianType endian,\n  const size_t value,unsigned char *p)\n{\n  unsigned char\n    buffer[4];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      (void) memcpy(p,buffer,4);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  (void) memcpy(p,buffer,4);\n}\n\nstatic void WriteProfileShort(const EndianType endian,\n  const unsigned short value,unsigned char *p)\n{\n  unsigned char\n    buffer[2];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      (void) memcpy(p,buffer,2);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  (void) memcpy(p,buffer,2);\n}\n\nstatic void SyncExifProfile(const Image *image,unsigned char *exif,\n  size_t length)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack] = { { 0, 0 } };\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    number_entries;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory;\n\n  if (length < 16)\n    return;\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return;\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return;\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return;\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || ((size_t) offset >= length))\n    return;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(int) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadProfileLong(endian,q+8);\n          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          if (number_bytes == 8)\n            (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          if (number_bytes == 8)\n            (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,((size_t) image->units)+1,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t) ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return;\n}\n\nstatic void Sync8BimProfile(const Image *image,\n  const StringInfo *profile)\n{\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *p;\n\n  unsigned short\n    id;\n\n  length=GetStringInfoLength(profile);\n  p=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadProfileByte(&p,&length) != 0x38)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x42)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x49)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x4D)\n      continue;\n    if (length < 7)\n      return;\n    id=ReadProfileMSBShort(&p,&length);\n    count=(ssize_t) ReadProfileByte(&p,&length);\n    if ((count >= (ssize_t) length) || (count < 0))\n      return;\n    p+=count;\n    length-=count;\n    if ((*p & 0x01) == 0)\n      (void) ReadProfileByte(&p,&length);\n    count=(ssize_t) ReadProfileMSBLong(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return;\n    if ((id == 0x3ED) && (count == 16))\n      {\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.x*2.54*65536.0),p);\n        else\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.x*65536.0),p);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.y*2.54*65536.0),p+8);\n        else\n          WriteProfileLong(MSBEndian,(unsigned int) CastDoubleToLong(\n            image->resolution.y*65536.0),p+8);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);\n      }\n    if (id == 0x0422)\n      SyncExifProfile(image,p,count);\n    p+=count;\n    length-=count;\n  }\n  return;\n}\n\nstatic void ReplaceXmpValue(StringInfo *profile,size_t start,size_t end,\n  const char *value)\n{\n  char\n    *datum;\n\n  size_t\n    length,\n    new_length,\n    value_length;\n\n  length=GetStringInfoLength(profile);\n  value_length=strlen(value);\n  new_length=length-(end-start)+value_length;\n  if (new_length > length)\n    SetStringInfoLength(profile,new_length);\n  datum=(char *) GetStringInfoDatum(profile);\n  (void) memmove(datum+start+value_length,datum+end,length-end);\n  (void) memcpy(datum+start,value,value_length);\n  if (new_length < length)\n    {\n      SetStringInfoLength(profile,new_length);\n      datum=(char *) GetStringInfoDatum(profile);\n      *(datum+new_length)='\\0';\n    }\n}\n\nstatic MagickBooleanType GetXmpOffsets(const StringInfo *profile,\n  const char *tag,size_t *start,size_t *end)\n{\n  char\n    *datum,\n    *pos;\n\n  size_t\n    length,\n    tag_length;\n\n  datum=(char *) GetStringInfoDatum(profile);\n  length=GetStringInfoLength(profile);\n  pos=strstr(datum,tag);\n  tag_length=strlen(tag);\n  if ((pos == (char *) NULL) || ((pos-datum) < 1) || (*(pos-1) != '<') ||\n      (((pos-datum)+tag_length) > length) || (*(pos+tag_length) != '>'))\n    return(MagickFalse);\n  *start=(pos-datum)+tag_length+1;\n  pos=strstr(datum+*start,\"<\");\n  if (pos == (char *) NULL)\n    return(MagickFalse);\n  *end=(pos-datum);\n  return(MagickTrue);\n}\n\nstatic void GetXmpNumeratorAndDenominator(double value,size_t *numerator,\n  size_t *denominator)\n{\n  double\n    df;\n\n  *numerator=0;\n  *denominator=1;\n  if (value <= MagickEpsilon)\n    return;\n  *numerator=1;\n  df=1.0;\n  while(fabs(df - value) > MagickEpsilon)\n  {\n    if (df < value)\n      (*numerator)++;\n    else\n      {\n        (*denominator)++;\n        *numerator=(size_t) (value*(*denominator));\n      }\n    df=*numerator/(double)*denominator;\n  }\n}\n\nstatic void SyncXmpProfile(const Image *image,StringInfo *profile)\n{\n  char\n    value[MagickPathExtent];\n\n  size_t\n    denominator,\n    end,\n    numerator,\n    start;\n\n  *value='\\0';\n  if (GetXmpOffsets(profile,\"tiff:XResolution\",&start,&end) != MagickFalse)\n    {\n      GetXmpNumeratorAndDenominator(image->resolution.x,&numerator,\n        &denominator);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%zu/%zu\",numerator,\n        denominator);\n      ReplaceXmpValue(profile,start,end,value);\n    }\n  if (GetXmpOffsets(profile,\"tiff:YResolution\",&start,&end) != MagickFalse)\n    {\n      if ((fabs(image->resolution.x-image->resolution.y) > MagickEpsilon) ||\n          (*value == '\\0'))\n        {\n          GetXmpNumeratorAndDenominator(image->resolution.y,&numerator,\n            &denominator);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%zu/%zu\",numerator,\n            denominator);\n        }\n      ReplaceXmpValue(profile,start,end,value);\n    }\n  if (GetXmpOffsets(profile,\"tiff:ResolutionUnit\",&start,&end) != MagickFalse)\n    {\n      (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n        ((int) image->units)+1);\n      ReplaceXmpValue(profile,start,end,value);\n    }\n  if (GetXmpOffsets(profile,\"tiff:Orientation\",&start,&end) != MagickFalse)\n    {\n      (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n        (int) image->orientation);\n      ReplaceXmpValue(profile,start,end,value);\n    }\n}\n\nMagickPrivate void SyncImageProfiles(Image *image)\n{\n  StringInfo\n    *profile;\n\n  profile=(StringInfo *) GetImageProfile(image,\"8BIM\");\n  if (profile != (StringInfo *) NULL)\n    Sync8BimProfile(image,profile);\n  profile=(StringInfo *) GetImageProfile(image,\"EXIF\");\n  if (profile != (StringInfo *) NULL)\n    SyncExifProfile(image,GetStringInfoDatum(profile),GetStringInfoLength(\n      profile));\n  profile=(StringInfo *) GetImageProfile(image,\"XMP\");\n  if (profile != (StringInfo *) NULL)\n    SyncXmpProfile(image,profile);\n}\n\nstatic void UpdateClipPath(unsigned char *blob,size_t length,\n  const size_t old_columns,const size_t old_rows,\n  const RectangleInfo *new_geometry)\n{\n  ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector;\n\n  knot_count=0;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadProfileMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadProfileMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          double\n            x,\n            y;\n\n          signed int\n            xx,\n            yy;\n\n          y=(double) ReadProfileMSBLong(&blob,&length);\n          y=y*old_rows/4096.0/4096.0;\n          y-=new_geometry->y;\n          yy=(signed int) ((y*4096*4096)/new_geometry->height);\n          WriteProfileLong(MSBEndian,(size_t) yy,blob-4);\n          x=(double) ReadProfileMSBLong(&blob,&length);\n          x=x*old_columns/4096.0/4096.0;\n          x-=new_geometry->x;\n          xx=(signed int) ((x*4096*4096)/new_geometry->width);\n          WriteProfileLong(MSBEndian,(size_t) xx,blob-4);\n        }\n        knot_count--;\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n}\n\nMagickPrivate void Update8BIMClipPath(const Image *image,\n  const size_t old_columns,const size_t old_rows,\n  const RectangleInfo *new_geometry)\n{\n  const StringInfo\n    *profile;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id;\n\n  unsigned char\n    *info;\n\n  assert(image != (Image *) NULL);\n  assert(new_geometry != (RectangleInfo *) NULL);\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while (length > 0)\n  {\n    if (ReadProfileByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadProfileByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadProfileByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadProfileByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadProfileMSBShort(&info,&length);\n    count=(ssize_t) ReadProfileByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        info+=count;\n        length-=count;\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadProfileByte(&info,&length);\n    count=(ssize_t) ReadProfileMSBLong(&info,&length);\n    if ((count < 0) || ((size_t) count > length))\n      {\n        length=0;\n        continue;\n      }\n    if ((id > 1999) && (id < 2999))\n      UpdateClipPath(info,(size_t) count,old_columns,old_rows,new_geometry);\n    info+=count;\n    length-=MagickMin(count,(ssize_t) length);\n  }\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                          TTTTT  IIIII  M   M   222                          %\n%                            T      I    MM MM  2   2                         %\n%                            T      I    M M M     2                          %\n%                            T      I    M   M    2                           %\n%                            T    IIIII  M   M  22222                         %\n%                                                                             %\n%                                                                             %\n%                          Read PSX TIM2 Image Format                         %\n%                                                                             %\n%                               Software Design                               %\n%                             Ramiro Balado Ordax                             %\n%                                   May 2019                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 2019 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n Typedef declarations\n*/\ntypedef struct _TIM2FileHeader\n{\n  unsigned int\n    magic_num;\n\n  unsigned char\n    format_vers,\n    format_type;\n\n  unsigned short\n    image_count;\n} TIM2FileHeader;\n\ntypedef struct _TIM2ImageHeader\n{\n  unsigned int\n    total_size,\n    clut_size,\n    image_size;\n\n  unsigned short\n    header_size,\n    clut_color_count;\n\n  unsigned char\n    img_format,\n    mipmap_count,\n    clut_type,\n    bpp_type;\n\n  unsigned short\n    width,\n    height;\n\n  MagickSizeType\n    GsTex0,\n    GsTex1;\n\n  unsigned int\n    GsRegs,\n    GsTexClut;\n} TIM2ImageHeader;\n\ntypedef enum\n{\n  CSM1=0,\n  CSM2=1,\n} CSM;\n\ntypedef enum\n{\n  RGBA32=0,\n  RGB24=1,\n  RGBA16=2,\n} TIM2ColorEncoding;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  R e a d T I M 2 I m a g e                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIM2Image() reads a PS2 TIM image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadTIM2Image method is:\n%\n%      Image *ReadTIM2Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic inline void ReadTIM2ImageHeader(Image *image,TIM2ImageHeader *header)\n{\n  header->total_size=ReadBlobLSBLong(image);\n  header->clut_size=ReadBlobLSBLong(image);\n  header->image_size=ReadBlobLSBLong(image);\n  header->header_size=ReadBlobLSBShort(image);\n\n  header->clut_color_count=ReadBlobLSBShort(image);\n  header->img_format=(unsigned char) ReadBlobByte(image);\n  header->mipmap_count=(unsigned char) ReadBlobByte(image);\n  header->clut_type=(unsigned char) ReadBlobByte(image);\n  header->bpp_type=(unsigned char) ReadBlobByte(image);\n\n  header->width=ReadBlobLSBShort(image);\n  header->height=ReadBlobLSBShort(image);\n\n  header->GsTex0=ReadBlobMSBLongLong(image);\n  header->GsTex1=ReadBlobMSBLongLong(image);\n  header->GsRegs=ReadBlobMSBLong(image);\n  header->GsTexClut=ReadBlobMSBLong(image);\n}\n\nstatic inline Quantum GetChannelValue(unsigned int word,unsigned char channel,\n  TIM2ColorEncoding ce)\n{\n  switch(ce)\n  {\n    case RGBA16:\n      /* Documentation specifies padding with zeros for converting from 5 to 8 bits. */\n      return ScaleCharToQuantum((word>>channel*5 & ~(~0x0U<<5))<<3);\n    case RGB24:\n    case RGBA32:\n      return ScaleCharToQuantum(word>>channel*8 & ~(~0x0U<<8));\n    default:\n      return QuantumRange;\n  }\n}\n\nstatic inline Quantum GetAlpha(unsigned int word,TIM2ColorEncoding ce)\n{\n  switch(ce)\n  {\n    case RGBA16:\n      return ScaleCharToQuantum((word>>3*5&0x1F)==0?0:0xFF);\n    case RGBA32:\n      /* 0x80 -> 1.0 alpha. Multiply by 2 and clamp to 0xFF */\n      return ScaleCharToQuantum(MagickMin((word>>3*8&0xFF)<<1,0xFF));\n    default:\n      return 0xFF;\n  }\n}\n\nstatic inline void deshufflePalette(Image *image,PixelInfo* oldColormap)\n{\n  const size_t\n    pages=image->colors/32,  /* Pages per CLUT */\n    blocks=4,  /* Blocks per page */\n    colors=8;  /* Colors per block */\n\n  int\n    page;\n\n  size_t\n    i=0;\n\n  (void) memcpy(oldColormap,image->colormap,(size_t)image->colors*\n    sizeof(*oldColormap));\n\n  /*\n   * Swap the 2nd and 3rd block in each page\n   */\n  for (page=0; page < (ssize_t) pages; page++)\n  {\n    memcpy(&(image->colormap[i+1*colors]),&(oldColormap[i+2*colors]),colors*\n      sizeof(PixelInfo));\n    memcpy(&(image->colormap[i+2*colors]),&(oldColormap[i+1*colors]),colors*\n      sizeof(PixelInfo));\n\n    i+=blocks*colors;\n  }\n}\n\nstatic MagickBooleanType ReadTIM2ImageData(const ImageInfo *image_info,\n  Image *image,TIM2ImageHeader *header,char clut_depth,char bits_per_pixel,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    x;\n\n  Quantum\n    *q;\n\n  unsigned char\n    *p;\n\n  size_t\n    bits_per_line,\n    bytes_per_line;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *row_data;\n\n  unsigned int\n    word;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n   * User data\n   */\n  status=DiscardBlobBytes(image,header->header_size-48);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n   * Image data\n   */\n  bits_per_line=image->columns*bits_per_pixel;\n  bytes_per_line=bits_per_line/8 + ((bits_per_line%8==0) ? 0 : 1);\n  row_data=(unsigned char*) AcquireQuantumMemory(1,bytes_per_line);\n  if (row_data == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image_info->filename);\n  if (clut_depth != 0)\n    {\n      image->colors=header->clut_color_count;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n          row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image_info->filename);\n        }\n      switch (bits_per_pixel)\n      {\n        case 4:\n        {\n          for (y=0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n            {\n              SetPixelIndex(image,(*p >> 0) & 0x0F,q);\n              q+=GetPixelChannels(image);\n              SetPixelIndex(image,(*p >> 4) & 0x0F,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              {\n                SetPixelIndex(image,(*p >> 4) & 0x0F,q);\n                p++;\n                q+=GetPixelChannels(image);\n              }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        case 8:\n        {\n          for (y=0;y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        default:\n        {\n          row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n          ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n            image_info->filename);\n        }\n      }\n      SyncImage(image,exception);\n    }\n  else  /* has_clut==false */\n    {\n      switch (bits_per_pixel)\n      {\n        case 16:\n        {\n          for (y=0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              word = ((unsigned int)* p   )<<0*8 |\n                      ((unsigned int)*(p+1))<<1*8;\n\n              SetPixelRed(image,GetChannelValue(word,0,RGBA16),q);\n              SetPixelGreen(image,GetChannelValue(word,1,RGBA16),q);\n              SetPixelBlue(image,GetChannelValue(word,2,RGBA16),q);\n              SetPixelAlpha(image,GetAlpha(word,RGBA16),q);\n              q+=GetPixelChannels(image);\n              p+=sizeof(unsigned short);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        case 24:\n        {\n          for (y = 0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              word = (unsigned int)(* p   )<<0*8 |\n                      (unsigned int)(*(p+1))<<1*8 |\n                      (unsigned int)(*(p+2))<<2*8;\n\n              SetPixelRed(image,GetChannelValue(word,0,RGB24),q);\n              SetPixelGreen(image,GetChannelValue(word,1,RGB24),q);\n              SetPixelBlue(image,GetChannelValue(word,2,RGB24),q);\n              q+=GetPixelChannels(image);\n              p+=3;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        case 32:\n        {  \n          for (y = 0; y<(ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            count=ReadBlob(image,bytes_per_line,row_data);\n            if (count != (ssize_t) bytes_per_line)\n              {\n                row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n                ThrowBinaryException(CorruptImageError,\n                  \"InsufficientImageDataInFile\",image_info->filename);\n              }\n            p=row_data;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              word = ((unsigned int)* p   )<<0*8 |\n                      ((unsigned int)*(p+1))<<1*8 |\n                      ((unsigned int)*(p+2))<<2*8 |\n                      ((unsigned int)*(p+3))<<3*8;\n\n              SetPixelRed(image,GetChannelValue(word,0,RGBA32),q);\n              SetPixelGreen(image,GetChannelValue(word,1,RGBA32),q);\n              SetPixelBlue(image,GetChannelValue(word,2,RGBA32),q);\n              SetPixelAlpha(image,GetAlpha(word,RGBA32),q);\n              q+=GetPixelChannels(image);\n              p+=4;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,\n                  (MagickOffsetType) y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n          break;\n        }\n        default:\n        {\n          row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n          ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n            image_info->filename);\n        }\n      }\n    }\n  row_data=(unsigned char *) RelinquishMagickMemory(row_data);\n  if ((status != MagickFalse) && (clut_depth != 0))\n  {\n    CSM\n      csm;\n\n    ssize_t\n      i;\n\n    unsigned char\n      *clut_data;\n\n    /*\n      * ### Read CLUT Data ###\n      */\n    clut_data=(unsigned char *) AcquireQuantumMemory(2,\n      MagickMax(header->clut_size,image->colors));\n    if (clut_data == (unsigned char *) NULL)\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    (void) memset(clut_data,0,2*MagickMax(header->clut_size,image->colors));\n    count=ReadBlob(image,header->clut_size,clut_data);\n    if (count != (ssize_t) (header->clut_size))\n      {\n        clut_data=(unsigned char *) RelinquishMagickMemory(clut_data);\n        ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n          image_info->filename);\n      }\n    /*\n      * ### Process CLUT Data ###\n      */\n    p=clut_data;\n    switch(clut_depth)\n    {\n      case 16:\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          word = ((unsigned short)* p   )<<0*8 |\n                  ((unsigned short)*(p+1))<<1*8;\n\n          image->colormap[i].red=GetChannelValue(word,0,RGBA16);\n          image->colormap[i].green=GetChannelValue(word,1,RGBA16);\n          image->colormap[i].blue=GetChannelValue(word,2,RGBA16);\n          image->colormap[i].alpha=GetAlpha(word,RGBA16);\n          p+=2;\n        }\n        break;\n      }\n      case 24:\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          word = ((unsigned int)* p   )<<0*8 |\n                  ((unsigned int)*(p+1))<<1*8 |\n                  ((unsigned int)*(p+2))<<2*8;\n\n          image->colormap[i].red=GetChannelValue(word,0,RGB24);\n          image->colormap[i].green=GetChannelValue(word,1,RGB24);\n          image->colormap[i].blue=GetChannelValue(word,2,RGB24);\n          p+=3;\n        }\n        break;\n      }\n      case 32:\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          word = ((unsigned int)* p   )<<0*8 |\n                  ((unsigned int)*(p+1))<<1*8 |\n                  ((unsigned int)*(p+2))<<2*8 |\n                  ((unsigned int)*(p+3))<<3*8;\n\n          image->colormap[i].red=GetChannelValue(word,0,RGBA32);\n          image->colormap[i].green=GetChannelValue(word,1,RGBA32);\n          image->colormap[i].blue=GetChannelValue(word,2,RGBA32);\n          image->colormap[i].alpha=GetAlpha(word,RGBA32);\n          p+=4;\n        }\n        break;\n      }\n    }\n    clut_data=(unsigned char *) RelinquishMagickMemory(clut_data);\n    /* CSM: CLUT Storage Mode */\n    switch ((int) header->clut_type>>4)  /* High 4 bits */\n    {\n      case 0:\n        csm=CSM1;\n        break;\n      case 1:\n        csm=CSM2;\n        break;\n      default:\n        ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n          image_info->filename);\n        break;\n    }\n    if (csm == CSM1)\n      {\n        PixelInfo\n          *oldColormap;\n\n        oldColormap=(PixelInfo *) AcquireQuantumMemory((size_t)(image->colors)+\n          1,sizeof(*image->colormap));\n        if (oldColormap == (PixelInfo *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image_info->filename);\n        deshufflePalette(image,oldColormap);\n        RelinquishMagickMemory(oldColormap);\n      }\n  }\n  return(status);\n}\n\nstatic Image *ReadTIM2Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  TIM2FileHeader\n    file_header;\n\n  /*\n   * Open image file.\n   */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  file_header.magic_num=ReadBlobMSBLong(image);\n  if (file_header.magic_num != 0x54494D32) /* \"TIM2\" */\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  file_header.format_vers=ReadBlobByte(image);\n  if (file_header.format_vers != 0x04)\n    ThrowReaderException(CoderError,\"ImageTypeNotSupported\");\n  file_header.format_type=ReadBlobByte(image);\n  file_header.image_count=ReadBlobLSBShort(image);\n  if (DiscardBlobBytes(image,8) == MagickFalse) /* reserved */\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  if ((file_header.format_type > 0) &&\n      (DiscardBlobBytes(image,112) == MagickFalse))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n   * Process each image. Only one image supported for now\n   */\n  if (file_header.image_count != 1)\n    ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n  for (i=0; i < (ssize_t) file_header.image_count; i++)\n  {\n    char\n      clut_depth,\n      bits_per_pixel;\n\n    TIM2ImageHeader\n      image_header;\n\n    if (i > 0)\n      {\n        /*\n          Proceed to next image.\n        */\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n    ReadTIM2ImageHeader(image,&image_header);\n    if (image_header.mipmap_count != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (image_header.header_size < 48)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((MagickSizeType) image_header.image_size > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((MagickSizeType) image_header.clut_size > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    image->columns=image_header.width;\n    image->rows=image_header.height;\n    clut_depth=0;\n    if (image_header.clut_type !=0)\n      {\n        switch((int) image_header.clut_type&0x0F)  /* Low 4 bits */\n        {\n          case 1:\n            clut_depth=16;\n            break;\n          case 2:\n            clut_depth=24;\n            break;\n          case 3:\n            clut_depth=32;\n            break;\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            break;\n        }\n      }\n    switch ((int) image_header.bpp_type)\n    {\n      case 1:\n        bits_per_pixel=16;\n        break;\n      case 2:\n        bits_per_pixel=24;\n        break;\n      case 3:\n        bits_per_pixel=32;\n        break;\n      case 4:\n        bits_per_pixel=4;  /* Implies CLUT */\n        break;\n      case 5:\n        bits_per_pixel=8;  /* Implies CLUT */\n        break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        break;\n    }\n    image->depth=(clut_depth != 0) ? clut_depth : bits_per_pixel;\n    if ((image->depth == 16) || (image->depth == 32))\n      image->alpha_trait=BlendPixelTrait;\n    if (image->ping == MagickFalse)\n      {\n        status=ReadTIM2ImageData(image_info,image,&image_header,clut_depth,\n          bits_per_pixel,exception);\n        if (status==MagickFalse)\n          break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((image->storage_class == PseudoClass) && (EOFBlob(image) != MagickFalse))\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I M 2 I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIM2Image() adds attributes for the TIM2 image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIM2Image method is:\n%\n%      size_t RegisterTIM2Image(void)\n%\n*/\nModuleExport size_t RegisterTIM2Image(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TIM2\",\"TM2\",\"PS2 TIM2\");\n  entry->decoder=(DecodeImageHandler *) ReadTIM2Image;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I M 2 I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIM2Image() removes format registrations made by the\n%  TIM2 module from the list of supported formats.\n%\n%  The format of the UnregisterTIM2Image method is:\n%\n%      UnregisterTIM2Image(void)\n%\n*/\nModuleExport void UnregisterTIM2Image(void)\n{\n  (void) UnregisterMagickInfo(\"TM2\");\n}\n"], "filenames": ["MagickCore/profile.c", "coders/tim2.c"], "buggy_code_start_loc": [2474, 522], "buggy_code_end_loc": [2478, 525], "fixing_code_start_loc": [2474, 522], "fixing_code_end_loc": [2480, 528], "type": "CWE-787", "message": "A heap-based buffer overflow issue was discovered in ImageMagick's ReadTIM2ImageData() function in coders/tim2.c. A local attacker could trick the user in opening specially crafted file, triggering an out-of-bounds read error, allowing an application to crash, resulting in a denial of service.", "other": {"cve": {"id": "CVE-2023-34474", "sourceIdentifier": "secalert@redhat.com", "published": "2023-06-16T20:15:09.370", "lastModified": "2023-11-07T04:15:37.653", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A heap-based buffer overflow issue was discovered in ImageMagick's ReadTIM2ImageData() function in coders/tim2.c. A local attacker could trick the user in opening specially crafted file, triggering an out-of-bounds read error, allowing an application to crash, resulting in a denial of service."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.1.1-10", "matchCriteriaId": "7603CE7E-F1AC-4A6D-A125-0004C041487A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB176AC3-3CDA-4DDA-9089-C67B2F73AA62"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-34474", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2214148", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/1061db7f80fdc9ef572ac60b55f408f7bab6e1b0", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/45DUUXYMAEEAW55GSLAXN25VPKCRAIDA/", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4UFQJCYJ23HWHNDOVKBHZQ7HCXXL6MM3/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/1061db7f80fdc9ef572ac60b55f408f7bab6e1b0"}}